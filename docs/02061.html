<html>
<head>
<title>Creating a Diversified Portfolio with Correlation Matrix in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python中的相关矩阵创建多元化投资组合</h1>
<blockquote>原文：<a href="https://medium.com/codex/creating-a-diversified-portfolio-with-correlation-matrix-in-python-7d7825255a2d?source=collection_archive---------1-----------------------#2021-06-27">https://medium.com/codex/creating-a-diversified-portfolio-with-correlation-matrix-in-python-7d7825255a2d?source=collection_archive---------1-----------------------#2021-06-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="afa8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">所有投资股票市场的人都必须知道的过程</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/0f9ed8b98fa1f41e5adb5237c5973af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hN_M97yZ1E8PIYoK"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">安德烈·泰森在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="a787" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">介绍</h1><p id="5e66" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">对可交易资产的投资不仅由机构或专业交易者进行，也由普通人进行，他们的目标是在长期的基础上赚取额外收入。第一类交易者是专业人士和机构交易者，他们喜欢在市场上赚很多钱，因此承担巨大的风险(就像孤注一掷的情况)。第二类人是普通人，他们在本质上与第一类人相反。他们的目标不是马上发财，而是随着时间的推移逐渐增加的稳定收入。重要的是，他们讨厌风险，喜欢持续的收入。</p><p id="006c" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">为了同时满足这两个条件，投资者创造了投资组合多样化这个术语。这个概念的定义是，在一个人的投资组合中持有不同数量的股票，最终降低风险，增加稳定收入的确定性。</p><p id="cc24" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">多元化投资组合中的股票不是随机选择的，而是遵循一定的步骤或方法。在这篇文章中，我们将遵循一种统计方法，即使用相关矩阵来选择正确的股票，并在多样化的投资组合中持有。在此之前，什么是相关性？相关性只不过是两个或多个变量之间关系的大小。相关性可以分为三种类型:两个或更多变量之间的关系大于零(&gt; 0)的正相关性，关系小于零的负相关性(&lt; 0), and No correlation where the reading is equal to zero (= 0).</p><p id="ce89" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">The ultimate goal of this article is to find the two best stocks among FAANG (acronym of Facebook, Amazon, Apple, Netflix, Google) to hold in a diversified portfolio that achieves lesser risk with gradual constant income. With that being said, let’s code the approach in Python.</p><p id="ef0a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">在继续之前，免责声明:本文的唯一目的是教育人们，必须被视为信息，而不是投资建议等。</strong></p><h1 id="88a2" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">用Python实现</h1><p id="c3ba" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">编码部分可以分为以下几个步骤:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="6482" class="lm jp hi li b fi ln lo l lp lq"><strong class="li hj">1. Importing packages<br/>2. Extracting Stock Data from Twelve Data<br/>3. Calculating Returns<br/>4. Creating and Analyzing the Correlation Matrix<br/>5. Backtesting<br/>6. Volatility Comparison</strong></span></pre><p id="47bb" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h2 id="118f" class="lm jp hi bd jq lr ls lt ju lu lv lw jy kp lx ly ka kt lz ma kc kx mb mc ke md bi translated">步骤1:导入包</h2><p id="5675" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包将是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib和Seaborn，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="9e40" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="e533" class="lm jp hi li b fi ln lo l lp lq"><strong class="li hj"># IMPORTING PACKAGES<br/></strong><br/>import pandas as pd<br/>import requests<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>from matplotlib import style<br/>from matplotlib import rcParams<br/><br/>style.use('fivethirtyeight')<br/>rcParams['figure.figsize'] = (20, 10)</span></pre><p id="4086" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">既然我们已经将所有需要的包导入到python环境中。让我们用十二数据的API端点来拉FAANG(脸书、亚马逊、苹果、网飞、谷歌的缩写)的历史数据。</p><h2 id="ce90" class="lm jp hi bd jq lr ls lt ju lu lv lw jy kp lx ly ka kt lz ma kc kx mb mc ke md bi translated">步骤2:从12个数据中提取股票数据</h2><p id="9d5c" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这一步中，我们将使用twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">提供的API端点提取FAANG的历史股票数据。在此之前，请注意twelvedata.com</a><a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank"/>:十二数据公司是领先的市场数据提供商之一，拥有大量适用于所有类型市场数据的API端点。它非常容易与十二数据提供的API进行交互，并且拥有有史以来最好的文档。此外，确保您在<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>上有一个帐户，只有这样，您才能访问您的API密钥(使用API提取数据的重要元素)。</p><p id="1749" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="1f7a" class="lm jp hi li b fi ln lo l lp lq"><strong class="li hj"># EXTRACTING STOCKS DATA<br/></strong><br/>def get_historical_data(symbol, start_date, end_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df = df[df.index &lt;= end_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>fb = get_historical_data('FB', '2020-01-01', '2021-01-01')<br/>amzn = get_historical_data('AMZN', '2020-01-01', '2021-01-01')<br/>aapl = get_historical_data('AAPL', '2020-01-01', '2021-01-01')<br/>nflx = get_historical_data('NFLX', '2020-01-01', '2021-01-01')<br/>googl = get_historical_data('GOOGL', '2020-01-01', '2021-01-01')</span></pre><p id="f672" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>我们做的第一件事是定义一个名为‘get _ historical _ data’的函数，它将股票的符号(‘symbol’)、历史数据的开始日期(‘start _ date’)和结束日期(‘end _ date’)作为参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们调用创建的函数来从2020年开始提取FAANG的历史数据，并将其存储到各自的变量中(' fb '，' amzn '，' aapl '，' nflx '，' googl ')。</p><h2 id="3c5c" class="lm jp hi bd jq lr ls lt ju lu lv lw jy kp lx ly ka kt lz ma kc kx mb mc ke md bi translated">步骤3:计算回报</h2><p id="822f" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这一步中，我们将计算所有FAANG股票的累积收益，并绘制它们，以观察它们之间的相关性。</p><p id="13e0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="5c41" class="lm jp hi li b fi ln lo l lp lq"><strong class="li hj"># CALCULATING RETURNS<br/></strong><br/>fb_rets, fb_rets.name = fb['close'] / fb['close'].iloc[0], 'fb'<br/>amzn_rets, amzn_rets.name = amzn['close'] / amzn['close'].iloc[0], 'amzn'<br/>aapl_rets, aapl_rets.name = aapl['close'] / aapl['close'].iloc[0], 'aapl'<br/>nflx_rets, nflx_rets.name = nflx['close'] / nflx['close'].iloc[0], 'nflx'<br/>googl_rets, googl_rets.name = googl['close'] / googl['close'].iloc[0], 'googl'<br/><br/>plt.plot(fb_rets, label = 'FB')<br/>plt.plot(amzn_rets, label = 'AMZN')<br/>plt.plot(aapl_rets, label = 'AAPL')<br/>plt.plot(nflx_rets, label = 'NFLX')<br/>plt.plot(googl_rets, label = 'GOOGL', color = 'purple')<br/>plt.legend(fontsize = 16)<br/>plt.title('FAANG CUMULATIVE RETURNS')<br/>plt.show()</span></pre><p id="bfae" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/ba5ebcb244ead35b8ad8435cf87b4fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eltUKjfpiI1KSfL5Y3l6qQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="62e0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>前几行，我们是用股票的当前收盘价值除以股票的初始收盘价值来计算每只FAANG股票的累计收益。然后，我们在Matplotlib包的帮助下绘制回报，我们得到了上面的结果图。回报也可以在每日时间框架内计算，但选择累积回报的原因是，当绘制成图表时，我们很容易注意到股票之间的相关性。例如，从上面的图表中，我们可以注意到所有五只股票之间存在很强的相关性，因为它们的价格都显示出类似的波动或运动。相反，在每日回报图中不可能观察到这种变化，因为这些线会相互重叠。</p><h2 id="5b6a" class="lm jp hi bd jq lr ls lt ju lu lv lw jy kp lx ly ka kt lz ma kc kx mb mc ke md bi translated">步骤4:创建和分析相关矩阵</h2><p id="f7ec" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在所有步骤中，这是最有趣的一步，我们将根据之前计算的回报构建一个相关矩阵，并对其进行分析，以了解哪些股票最适合我们的多元化投资组合。</p><p id="3c1f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="ee38" class="lm jp hi li b fi ln lo l lp lq"><strong class="li hj"># CREATING THE CORRELATION MATRIX<br/></strong><br/>rets = [fb_rets, amzn_rets, aapl_rets, nflx_rets, googl_rets]<br/>rets_df = pd.DataFrame(rets).T.dropna()<br/>rets_corr = rets_df.corr()<br/><br/>plt.style.use('default')<br/>sns.heatmap(rets_corr, annot = True, linewidths = 0.5)<br/>plt.show()</span></pre><p id="a5aa" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mf"><img src="../Images/3d39b3810e8dfd2ad043f649569db776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*QvI5atwoS1cNOywj9sVfUw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="df8a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>首先，我们创建一个名为‘RETs’的变量来存储我们之前计算的所有回报，在下一步中，我们将使用它创建一个数据框架。为了计算股票之间的相关性，我们使用Pandas软件包提供的“corr”函数，并将矩阵存储到“rets_corr”变量中。除非以热图的形式绘制，否则相关矩阵没有意义。</p><p id="e974" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">可以使用Matplotlib绘制热图，但是徒劳无功。这就是Seaborn发挥作用的地方。Seaborn是一个python包，它提供了大量函数来创建统计图形表示。因此，我们使用Seaborn软件包提供的“热图”功能从关联矩阵中绘制出热图。</p><p id="1a23" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在，让我们来分析代表股票之间相关性的热图。我们可以在图中看到一些值，这些值就是相关分数。谷歌和脸书之间的相关系数是0.91，代表着很强的关系。这意味着，如果谷歌股票下跌10%，脸书也会下跌8%左右(因为它不是100%相关)，反之亦然。同样，我们可以看到，谷歌和网飞之间的相关性为0.69，代表较弱的关系(与其他关系相比)，其价格运动将彼此相反(不太多，但有点，因为它不是负相关)。</p><p id="db8d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">持有多元化投资组合的主要目标是尽可能降低风险，为了实现这一目标，我们必须持有彼此高度不相关的股票。即使我们投资组合中的一只股票小幅下跌，另一只不相关的股票也会回补，因为它们的价格波动是成反比的。从上面的相关性矩阵中，我们可以说谷歌和网飞是最不相关的，所以在我们的多元化投资组合中持有这两只股票是最理想的。</p><h2 id="77df" class="lm jp hi bd jq lr ls lt ju lu lv lw jy kp lx ly ka kt lz ma kc kx mb mc ke md bi translated">步骤5:回溯测试</h2><p id="2a5c" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">现在，我们已经决定了在我们的多元化投资组合中持有哪些股票，让我们试着做一个回溯测试，看看我们的投资组合表现如何。这一步是最重要的一步，不仅对我们的投资组合进行多样化，而且对每一项金融研究都是如此，因为它能让我们对投资策略的表现有所了解。</p><p id="aa27" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="2e85" class="lm jp hi li b fi ln lo l lp lq"><strong class="li hj"># BACKTESTING<br/></strong><br/>investment_value = 100000<br/>N = 2<br/>nflx_allocation = investment_value / N<br/>googl_allocation = investment_value / N<br/><br/>nflx_stocks = floor(nflx_allocation / nflx['close'][0])<br/>googl_stocks = floor(googl_allocation / googl['close'][0])<br/><br/>nflx_investment_rets = nflx_rets * nflx_stocks<br/>googl_investment_rets = googl_rets * googl_stocks<br/>total_rets = round(sum(((nflx_investment_rets + googl_investment_rets) / 2).dropna()), 3)<br/>total_rets_pct = round((total_rets / investment_value) * 100, 3)<br/><br/>print(cl(f'Profit gained from the investment : {total_rets} USD', attrs = ['bold']))<br/>print(cl(f'Profit percentage of our investment : {total_rets_pct}%', attrs = ['bold']))</span></pre><p id="c634" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="5798" class="lm jp hi li b fi ln lo l lp lq"><strong class="li hj">Profit gained from the investment : 30428.957 USD</strong><br/><strong class="li hj">Profit percentage of our investment : 30.429%</strong></span></pre><p id="ee67" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>首先，我们创建一个名为‘investment _ value’的变量来存储我们想要投资的总资本，即十万美元。接下来，我们将资本平均分配给两只股票，资本分配相等的投资组合称为等权重投资组合。有时，投资者通过一些因素为投资组合中的每只股票分配独特的权重，但这超出了本文的范围。之后，我们将创建两个新变量，即“nflx_stocks”和“googl_stocks ”,以存储我们可以用资本金额购买的股票数量。然后，是投资回报的计算。首先，我们通过将我们购买的股票数量乘以我们之前计算的股票回报来计算每只股票的回报。</p><p id="757e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">之后，为了计算我们多样化投资组合的总回报，我们找到了每只股票平均回报的总和。我们还通过将总投资回报除以总投资资本，然后乘以100来计算利润率。从显示的输出中，我们可以看到我们的投资组合在一年内获得了大约30500美元的利润，利润率为30.429%。那还不错！</p><h2 id="da3f" class="lm jp hi bd jq lr ls lt ju lu lv lw jy kp lx ly ka kt lz ma kc kx mb mc ke md bi translated">第六步:波动性比较</h2><p id="2553" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我之前说过，持有多元化投资组合的最终目的是尽可能降低风险，创收是次要的。现在我们知道我们设法从我们的投资组合中获得了一些利润，让我们看看我们是否能够将风险降到最低。现在，有很多金融工具可以用来衡量风险，在这篇文章中，我们将利用波动率。对于那些不知道什么是波动性的人来说，波动性是投资者用来计算投资风险的工具。</p><p id="cd7b" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="600b" class="lm jp hi li b fi ln lo l lp lq"><strong class="li hj"># VOLATILITY CALCULATION<br/></strong>    <br/>rets_df['Portfolio'] = (rets_df[['googl', 'nflx']].sum(axis = 1)) / 2<br/>daily_pct_change = rets_df.pct_change()<br/>volatility = round(np.log(daily_pct_change + 1).std() * np.sqrt(252), 5)<br/><br/>companies = ['FACEBOOK', 'APPLE', 'AMAZON', 'NFLX', 'GOOGL', 'PORTFOLIO']<br/>for i in range(len(volatility)):<br/>    if i == 5:<br/>        print(cl(f'{companies[i]} VOLATILITY : {volatility[i]}', attrs = ['bold'], color = 'green'))<br/>    else:<br/>        print(cl(f'{companies[i]} VOLATILITY : {volatility[i]}', attrs = ['bold']))</span></pre><p id="1407" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="1c3a" class="lm jp hi li b fi ln lo l lp lq">FACEBOOK VOLATILITY : 0.46539<br/>APPLE VOLATILITY : 0.38944<br/>AMAZON VOLATILITY : 0.47043<br/>NFLX VOLATILITY : 0.46069<br/>GOOGL VOLATILITY : 0.3881<br/><strong class="li hj">PORTFOLIO VOLATILITY : 0.37843</strong></span></pre><p id="3156" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>首先，我们在‘RETs _ df’数据框架中创建一个新的列‘Portfolio ’(我们以前使用过)来存储我们多样化投资组合的回报。然后，我们使用Pandas包提供的“pct_change”函数来计算“rets_df”中每只股票的当前读数和先前读数之间的百分比变化，并将它们存储到“daily_pct_change”变量中。然后是波动率计算。在讨论代码之前，有一个公式需要记住，这是计算年化波动率的公式:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="79a0" class="lm jp hi li b fi ln lo l lp lq"><strong class="li hj">VOLATILITY </strong>= <strong class="li hj">LOG </strong>[ ( <strong class="li hj">STD OF PCT CHANGE</strong> + <strong class="li hj">1 </strong>) * <strong class="li hj">SQRT OF 252</strong> ]</span><span id="5290" class="lm jp hi li b fi mg lo l lp lq">where,<br/><strong class="li hj">STD OF PCT CHANGE</strong> = Standard Deviation of Daily Percentage Change<br/><strong class="li hj">SQRT OF 252</strong> = Square Root of 252</span></pre><p id="5e5a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们将上述公式代入我们的代码，计算每只股票的波动率，并将它们存储到“波动率”变量中。从显示的输出中，我们可以看到，与其他FAANG股票相比，我们的多元化投资组合实现了最小的波动性。太好了！</p><h1 id="e2c3" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">最后的想法！</h1><p id="1e7f" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">经过漫长的编程过程，我们已经成功地建立了一个多元化的投资组合，将风险降至最低，并获得利润。我还将我们投资组合的表现与SPY ETF(一种专为跟踪标准普尔500市场指数走势而设计的ETF)的表现进行了比较，似乎我们以微小的差异否决了它。现在，我们来谈谈改进。</p><p id="7ce5" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">可以改进的第一个方面是使用大量的股票。在本文中，我们只考虑了五只股票，并从中挑选了两只相关性较低的股票。但是，当持有大量不相关的股票时，投资组合多样化的概念表现最佳。例如，我们可以考虑标准普尔500市场指数中包含的所有股票，并挑选高度不相关的股票。通过这样做，我们可以实现两件重要的事情。</p><p id="4901" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">首先，我们将能够找到高度不相关的股票。在这篇文章中，最小相关分数是0.69(这实际上是一个很好的正相关关系)，因为我们只有几只股票。但是，如果我们考虑由不同部门组成的大量股票，我们可以设法找到即使相关性很低的股票，帮助提高我们的投资组合的表现。其次，我们将能够更有效地降低风险。</p><p id="9c4a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">另一个可以改进的方面，不仅是持有股票，还有其他资产。多元化投资组合的第一个目标是降低风险，第二个主要目标是产生稳定的收入。定期从股票中获得回报的确定性很低，因为它具有特定水平的波动性，无法完全消除或降低，而当我们将我们的投资组合扩大到更广泛的资产范围，如债券、交易所交易基金等，恒定收入的概率就会增加。</p><p id="f254" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">话虽如此，你已经到了文章的结尾。如果您忘记了遵循任何编码部分，不要担心。我在最后提供了完整的源代码。希望你能从这篇文章中学到一些新的有用的东西。</p><h2 id="3c28" class="lm jp hi bd jq lr ls lt ju lu lv lw jy kp lx ly ka kt lz ma kc kx mb mc ke md bi translated">完整代码:</h2><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="3f16" class="lm jp hi li b fi ln lo l lp lq"># IMPORTING PACKAGES<br/><br/>import pandas as pd<br/>import requests<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>from matplotlib import style<br/>from matplotlib import rcParams<br/><br/>style.use('fivethirtyeight')<br/>rcParams['figure.figsize'] = (20, 10)<br/><br/># EXTRACTING STOCKS DATA<br/><br/>def get_historical_data(symbol, start_date, end_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df = df[df.index &lt;= end_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>fb = get_historical_data('FB', '2020-01-01', '2021-01-01')<br/>amzn = get_historical_data('AMZN', '2020-01-01', '2021-01-01')<br/>aapl = get_historical_data('AAPL', '2020-01-01', '2021-01-01')<br/>nflx = get_historical_data('NFLX', '2020-01-01', '2021-01-01')<br/>googl = get_historical_data('GOOGL', '2020-01-01', '2021-01-01')<br/><br/># CALCULATING RETURNS<br/><br/>fb_rets, fb_rets.name = fb['close'] / fb['close'].iloc[0], 'fb'<br/>amzn_rets, amzn_rets.name = amzn['close'] / amzn['close'].iloc[0], 'amzn'<br/>aapl_rets, aapl_rets.name = aapl['close'] / aapl['close'].iloc[0], 'aapl'<br/>nflx_rets, nflx_rets.name = nflx['close'] / nflx['close'].iloc[0], 'nflx'<br/>googl_rets, googl_rets.name = googl['close'] / googl['close'].iloc[0], 'googl'<br/><br/>plt.plot(fb_rets, label = 'FB')<br/>plt.plot(amzn_rets, label = 'AMZN')<br/>plt.plot(aapl_rets, label = 'AAPL')<br/>plt.plot(nflx_rets, label = 'NFLX')<br/>plt.plot(googl_rets, label = 'GOOGL', color = 'purple')<br/>plt.legend(fontsize = 16)<br/>plt.title('FAANG CUMULATIVE RETURNS')<br/>plt.show()<br/><br/># CREATING THE CORRELATION MATRIX<br/><br/>rets = [fb_rets, amzn_rets, aapl_rets, nflx_rets, googl_rets]<br/>rets_df = pd.DataFrame(rets).T.dropna()<br/>rets_corr = rets_df.corr()<br/><br/>plt.style.use('default')<br/>sns.heatmap(rets_corr, annot = True, linewidths = 0.5)<br/>plt.show()<br/><br/># BACKTESTING<br/><br/>investment_value = 100000<br/>N = 2<br/>nflx_allocation = investment_value / N<br/>googl_allocation = investment_value / N<br/><br/>nflx_stocks = floor(nflx_allocation / nflx['close'][0])<br/>googl_stocks = floor(googl_allocation / googl['close'][0])<br/><br/>nflx_investment_rets = nflx_rets * nflx_stocks<br/>googl_investment_rets = googl_rets * googl_stocks<br/>total_rets = round(sum(((nflx_investment_rets + googl_investment_rets) / 2).dropna()), 3)<br/>total_rets_pct = round((total_rets / investment_value) * 100, 3)<br/><br/>print(cl(f'Profit gained from the investment : {total_rets} USD', attrs = ['bold']))<br/>print(cl(f'Profit percentage of our investment : {total_rets_pct}%', attrs = ['bold']))<br/><br/> # VOLATILITY CALCULATION<br/>    <br/>rets_df['Portfolio'] = (rets_df[['googl', 'nflx']].sum(axis = 1)) / 2<br/>daily_pct_change = rets_df.pct_change()<br/>volatility = round(np.log(daily_pct_change + 1).std() * np.sqrt(252), 5)<br/><br/>companies = ['FACEBOOK', 'APPLE', 'AMAZON', 'NFLX', 'GOOGL', 'PORTFOLIO']<br/>for i in range(len(volatility)):<br/>    if i == 5:<br/>        print(cl(f'{companies[i]} VOLATILITY : {volatility[i]}', attrs = ['bold'], color = 'green'))<br/>    else:<br/>        print(cl(f'{companies[i]} VOLATILITY : {volatility[i]}', attrs = ['bold']))</span></pre></div></div>    
</body>
</html>