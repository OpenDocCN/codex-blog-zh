<html>
<head>
<title>Recursion Demystified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归去神秘化</h1>
<blockquote>原文：<a href="https://medium.com/codex/recursion-demystified-483ad9b1a36d?source=collection_archive---------9-----------------------#2021-01-12">https://medium.com/codex/recursion-demystified-483ad9b1a36d?source=collection_archive---------9-----------------------#2021-01-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="02c7" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="https://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><div class=""><h2 id="273c" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">一个简化的令人麻木的概念</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/01c444f5a933e59192dac5b61bbbf7ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VeRtDySH_Oxe0V9z"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">由<a class="ae jw" href="https://unsplash.com/@timmarshall?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·马歇尔</a>在<a class="ae jw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="5187" class="ke kf hi bd kg kh ki kj kk kl km kn ko ix kp iy kq ja kr jb ks jd kt je ku kv bi translated">有什么大惊小怪的？</h1><p id="7467" class="pw-post-body-paragraph kw kx hi ky b kz la is lb lc ld iv le lf lg lh li lj lk ll lm ln lo lp lq lr hb bi translated">递归似乎是一个让每个初学计算机科学的学生头疼几个月的话题。这个概念可以通过各种不同的材料引入，然而，它最明显的是以递归函数的形式出现。一般来说，函数用于将执行特定任务的语句组合在一起，并消除重复的代码行。你调用一个函数来执行代码行。函数甚至可以调用其他函数来帮助完成手头的过程。调用自身的函数称为递归函数。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ls"><img src="../Images/b357c6f581e046a4184cbe5c0b1e97bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LlRz4eUqmMtF7beO"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">由<a class="ae jw" href="https://unsplash.com/@roman_lazygeek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗马法师</a>在<a class="ae jw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="4e8c" class="ke kf hi bd kg kh lt kj kk kl lu kn ko ix lv iy kq ja lw jb ks jd lx je ku kv bi translated">需要了解的关键术语</h1><ul class=""><li id="94de" class="ly lz hi ky b kz la lc ld lf ma lj mb ln mc lr md me mf mg bi translated">基础案例</li><li id="0e7a" class="ly lz hi ky b kz mh lc mi lf mj lj mk ln ml lr md me mf mg bi translated">递推关系</li><li id="2329" class="ly lz hi ky b kz mh lc mi lf mj lj mk ln ml lr md me mf mg bi translated">递归定义</li><li id="5f81" class="ly lz hi ky b kz mh lc mi lf mj lj mk ln ml lr md me mf mg bi translated">递归下降</li><li id="3999" class="ly lz hi ky b kz mh lc mi lf mj lj mk ln ml lr md me mf mg bi translated">递归上升</li></ul><p id="d12b" class="pw-post-body-paragraph kw kx hi ky b kz mm is lb lc mn iv le lf mo lh li lj mp ll lm ln mq lp lq lr hb bi translated">基本情况<strong class="ky hs">本质上是问题的最简单形式。我们在递归实现中需要一个<strong class="ky hs">基础用例</strong>来防止函数无限地调用自己。</strong></p><p id="911b" class="pw-post-body-paragraph kw kx hi ky b kz mm is lb lc mn iv le lf mo lh li lj mp ll lm ln mq lp lq lr hb bi translated"><strong class="ky hs">递归关系</strong>是根据问题本身的更简单版本来定义问题。</p><p id="ed66" class="pw-post-body-paragraph kw kx hi ky b kz mm is lb lc mn iv le lf mo lh li lj mp ll lm ln mq lp lq lr hb bi translated"><strong class="ky hs">基础用例</strong>和<strong class="ky hs">递归关系</strong>的组合给了我们<strong class="ky hs">递归定义</strong>。递归实现几乎总是直接来自<strong class="ky hs">递归定义</strong>。</p><p id="3404" class="pw-post-body-paragraph kw kx hi ky b kz mm is lb lc mn iv le lf mo lh li lj mp ll lm ln mq lp lq lr hb bi translated"><strong class="ky hs">递归下降</strong>是指一个函数不断调用自己，直到到达一个<strong class="ky hs">基用例</strong>为止。</p><p id="5c70" class="pw-post-body-paragraph kw kx hi ky b kz mm is lb lc mn iv le lf mo lh li lj mp ll lm ln mq lp lq lr hb bi translated"><strong class="ky hs">递归上升</strong>是当到达<strong class="ky hs">基本情况</strong>时返回到每个递归函数调用。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="9a15" class="ke kf hi bd kg kh ki kj kk kl km kn ko ix kp iy kq ja kr jb ks jd kt je ku kv bi translated">通过数字的阶乘解释递归</h1><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mr"><img src="../Images/b4ee00663d5e1db1cc105f28153c80ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5V-Y8jPn23834GhKn8Ebpw.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">作者图片</figcaption></figure><p id="7d6d" class="pw-post-body-paragraph kw kx hi ky b kz mm is lb lc mn iv le lf mo lh li lj mp ll lm ln mq lp lq lr hb bi translated">在上图中，您可以看到每个关键术语是如何与计算/实现一个数的阶乘的过程的某个部分相联系的。一个数的阶乘可以写成这个数乘以这个数的阶乘减一。展示了4！= 4* 3!, 3!= 3 * 2!以此类推，导致<strong class="ky hs">递归下降</strong>。一次0！被击中，用1代替它允许我们开始计算阶乘。完成每个因式分解的乘法所产生的连续计算导致了<strong class="ky hs">递归上升</strong>。0的阶乘为1是我们的<strong class="ky hs">基础案例</strong>(问题的最简单形式)。4!等于4 * (4 - 1)！是我们的<strong class="ky hs">递归关系</strong>(该问题根据其自身的更简单版本来定义)。任何数的阶乘的更一般的递推关系是n！= n * (n - 1)！。对于任何递归实现，我们总是希望首先从编写基本用例开始。这样做，就保证了我们的函数不会无限地执行递归(假设我们的基本情况和递归关系是正确的)。从上图中可以看出，<strong class="ky hs">基本用例</strong>和<strong class="ky hs">递归关系</strong>一起构成了<strong class="ky hs">递归定义</strong>。<strong class="ky hs">递归定义</strong>将允许我们导出计算一个数的阶乘的实现。</p><h1 id="0df7" class="ke kf hi bd kg kh lt kj kk kl lu kn ko ix lv iy kq ja lw jb ks jd lx je ku kv bi translated">递归阶乘实现</h1><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div></figure><h2 id="2f5f" class="mu kf hi bd kg mv mw mx kk my mz na ko lf nb nc kq lj nd ne ks ln nf ng ku ho bi translated">替代实现</h2><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="c94f" class="pw-post-body-paragraph kw kx hi ky b kz mm is lb lc mn iv le lf mo lh li lj mp ll lm ln mq lp lq lr hb bi translated">注意:<strong class="ky hs">基本情况</strong>和<strong class="ky hs">递归关系</strong>是可变的。它们的值完全依赖于你试图递归解决的问题。在试图递归解决任何问题之前，你必须确定正确的<strong class="ky hs">基础案例</strong>和<strong class="ky hs">递归关系</strong>。然而，俗话说得好:“任何可以递归解决的问题都可以迭代解决。”因此，不要试图递归地解决所有问题。如果某些事情可以迭代解决，那么就迭代解决它(除非递归产生更快的运行速度)。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="0d6b" class="ke kf hi bd kg kh ki kj kk kl km kn ko ix kp iy kq ja kr jb ks jd kt je ku kv bi translated">线性链表数据结构的基本解释</h1><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mr"><img src="../Images/b643c70d5ca305a11b30df8f43085398.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xozO42H8CY_Dla3ONLThSg.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">作者图片</figcaption></figure><p id="7204" class="pw-post-body-paragraph kw kx hi ky b kz mm is lb lc mn iv le lf mo lh li lj mp ll lm ln mq lp lq lr hb bi translated">现在，我在一篇关于递归的文章中提到线性链表的唯一原因是因为它与我帮助理解递归如何工作的方法有关。上图描述了一个线性链表是如何以一种绘制格式表示的。单词“list”是指向链表中第一个节点的指针。指针只是一个变量，它在内存中存储某个项目的地址。在这种情况下，列表存储列表中第一个节点的地址(在内存中)。每个盒子被称为节点。链接列表的节点由信息字段和文本字段组成。信息字段可以包含任何种类的项目。这些项目可以包括从整数到字符串，甚至对象的任何东西。下一个字段包含链表中下一个节点的地址。我们说下一个字段“指向”列表中的下一个节点。</p><p id="9583" class="pw-post-body-paragraph kw kx hi ky b kz mm is lb lc mn iv le lf mo lh li lj mp ll lm ln mq lp lq lr hb bi translated">注意:上图中的最后一个节点有一个奇怪的指针，以两个破折号结尾。该符号表示最后一个节点的next字段不包含任何到另一个节点的地址。因此，符号表示“列表的结尾”</p><h1 id="c9fb" class="ke kf hi bd kg kh lt kj kk kl lu kn ko ix lv iy kq ja lw jb ks jd lx je ku kv bi translated">我直观地看到递归如何工作的方法</h1><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mr"><img src="../Images/8b69789437a6665549a7edb0ea6143ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sAIRc5hDJ_HiJgTUnFwT6Q.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">作者图片</figcaption></figure><p id="e3f3" class="pw-post-body-paragraph kw kx hi ky b kz mm is lb lc mn iv le lf mo lh li lj mp ll lm ln mq lp lq lr hb bi translated">我如何应用线性链表的相关概念来理解递归？在上图中，你可以看到每个阶乘函数调用都有自己的指针。其思想是将每个函数调用视为可以访问它自己的函数实现。换句话说，每个函数调用都“指向”它自己的实现。以这种方式思考递归可以让你直观地看到<strong class="ky hs">递归下降</strong>和<strong class="ky hs">递归上升</strong>在起作用。当你跟随指针(或者箭头，如果这有助于你更好地理解它的话)，从一个函数实现到下一个函数实现，你正在执行<strong class="ky hs">递归下降</strong>。当您到达最后一个函数实现时(当n = 0时)，跟随指针返回到每个函数调用执行<strong class="ky hs">递归上升</strong>并最终计算4！。</p><p id="b3c6" class="pw-post-body-paragraph kw kx hi ky b kz mm is lb lc mn iv le lf mo lh li lj mp ll lm ln mq lp lq lr hb bi translated">注意:为了节省空间，我将else语句写在了一行中(当n = 1时)。这确实使该方法工作得更好或更差。如果else语句写在另一行，无论如何都不会影响该方法的工作方式。</p><p id="1a39" class="pw-post-body-paragraph kw kx hi ky b kz mm is lb lc mn iv le lf mo lh li lj mp ll lm ln mq lp lq lr hb bi translated">我直观地看到递归如何工作的方法可以应用于任何递归实现。我甚至用这种方法来看看斐波那契数列的递归实现是如何工作的。是的，像上面的图像一样写出这个过程可能并不适合每种情况，但最终，它有助于你理解递归。理解递归才是真正重要的。</p></div></div>    
</body>
</html>