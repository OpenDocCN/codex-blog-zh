<html>
<head>
<title>Tic Tac Toe in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">爪哇井字游戏</h1>
<blockquote>原文：<a href="https://medium.com/codex/tic-tac-toe-e53212028341?source=collection_archive---------0-----------------------#2021-05-06">https://medium.com/codex/tic-tac-toe-e53212028341?source=collection_archive---------0-----------------------#2021-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="1129" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">Java教程—井字游戏</h2><div class=""/><div class=""><h2 id="c6b6" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">如何用Java创建一个控制台井字游戏</h2></div></div><div class="ab cl jg jh gp ji" role="separator"><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl"/></div><div class="hb hc hd he hf"><figure class="jo jp jq jr fd js er es paragraph-image"><div class="er es jn"><img src="../Images/8e0dbef6eaf26c970699d04592a91415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*A9Wa48URAJEve7GrqtyGJQ.png"/></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">井字游戏(作者创作)</figcaption></figure><p id="0335" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">井字游戏是一个经典的编程问题，许多开发人员在他们的编程之旅中都遇到过。看似简单，井字游戏可以教会开发者:</p><ul class=""><li id="1c03" class="kv kw hi kb b kc kd kf kg ki kx km ky kq kz ku la lb lc ld bi translated">数组</li><li id="9aac" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">布尔运算</li><li id="1f00" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">条件式</li><li id="7c6d" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">功能</li><li id="a427" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">环</li><li id="7d48" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">变量</li><li id="3311" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">数据结构</li></ul><p id="b4a2" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">在本教程中，我们将创建一个控制台井字游戏，它依靠随机数发生器来控制计算机。在适用的地方，我将评论如何改进代码。本教程将使用最基本的解决方案，使所有技能水平都可以使用。永远记住在每一节的末尾测试你的代码，以确保它能正常工作！我们开始吧。</p><p id="1ef6" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">注意:你可以在YouTube上以视频格式欣赏整个教程:</p><figure class="jo jp jq jr fd js"><div class="bz dy l di"><div class="lj lk l"/></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">教程的Youtube链接</figcaption></figure><p id="61dc" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><em class="ll">如有任何困惑，可随时查看完整代码</em> <a class="ae lm" href="https://github.com/Taylor-McNeil/YouTubeTutorials-/blob/master/TicTacToe.java" rel="noopener ugc nofollow" target="_blank"> <em class="ll">此处</em> </a> <em class="ll">。</em></p><h1 id="420c" class="ln lo hi bd lp lq lr ls lt lu lv lw lx ix ly iy lz ja ma jb mb jd mc je md me bi translated">构建董事会</h1><p id="9266" class="pw-post-body-paragraph jz ka hi kb b kc mf is ke kf mg iv kh ki mh kk kl km mi ko kp kq mj ks kt ku hb bi translated"><em class="ll">为了简单起见，整个教程将构建在一个类中，并提供几个函数。</em></p><p id="3a4b" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">构建游戏的第一步是创建棋盘。我们将使用一个充满破折号[ - ]、竖线[ | ]和空格[" "]的2D字符数组来创建我们的电路板。让我们创建一个名为<em class="ll"> gameBoard </em>的数组，并填充它。我们还将创建一个名为<em class="ll"> printBoard() </em>的函数，让我们能够可视化电路板。</p><figure class="jo jp jq jr fd js er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mk"><img src="../Images/6e7a07e69f237d770b74e4dfac0b8cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLRBnJt4VzuzJnKU6M4wFg.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">游戏板的可视化(由作者创建)</figcaption></figure><figure class="jo jp jq jr fd js"><div class="bz dy l di"><div class="mp lk l"/></div></figure><p id="57bf" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">这段代码的快速解释。竖线下划线，空格表示井字游戏棋盘的网格。你可以把棋盘想象成空间1-9。第一个空格是[0][0]。第二个空格是[0][2]。第三个空格是[0][4]等。</p><p id="7e9d" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><em class="ll">所有指标均在备注中注明。竖线存在；然而，在我们的游戏逻辑中，我们并没有把它们计算在内。</em></p><p id="2d5b" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><em class="ll"> printBoard() </em>接收一个2D数组并将数组内容打印到控制台。它通过使用嵌套的for循环来实现这一点。第一个循环告诉计算机，对于<em class="ll">游戏板</em>中的每个字符行，执行第二个循环。</p><p id="9cc1" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">第二个循环要求，对于行中的每个字符，打印出该字符。在每第二个循环的末尾，我们创建一个新的行来防止所有的字符被打印在同一行上。</p><pre class="jo jp jq jr fd mq mr ms mt aw mu bi"><span id="1aaa" class="mv lo hi mr b fi mw mx l my mz">/**<em class="ll">Note: Printing the board could be accomplished using the tradition for loop. I think the foreach loop is easier to read. **/</em></span><span id="3fe9" class="mv lo hi mr b fi na mx l my mz">for (int row = 0; row &lt; gameBoard.length; row++) {<br/>  for (int c = 0; c &lt; gameBoard[0].length; c++) {<br/>    System.out.print(gameBoard[row][c]);<br/>  }<br/>  System.out.println();<br/>}</span></pre><p id="9ef1" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">这个功能完成后，我们就完成了电路板的构建。</p></div><div class="ab cl jg jh gp ji" role="separator"><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl"/></div><div class="hb hc hd he hf"><h1 id="03c5" class="ln lo hi bd lp lq nb ls lt lu nc lw lx ix nd iy lz ja ne jb mb jd nf je md me bi translated">放置工件</h1><p id="c39e" class="pw-post-body-paragraph jz ka hi kb b kc mf is ke kf mg iv kh ki mh kk kl km mi ko kp kq mj ks kt ku hb bi translated">现在，我们已经建立了我们的董事会，让我们潜入游戏逻辑。我们需要一种方法来确定哪个角色代表玩家和计算机；以及将这些角色放在黑板上的方法。所以让我们创建一些规则:</p><ul class=""><li id="7781" class="kv kw hi kb b kc kd kf kg ki kx km ky kq kz ku la lb lc ld bi translated">玩家将由<strong class="kb hs"> X </strong>字符和数字1代表</li><li id="6312" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">计算机将由字符<strong class="kb hs">和数字2表示</strong></li><li id="0db7" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">放置棋子的有效索引为[0][0]，[0][2]，[0][4]，[1][0]，[1][2]，[1][4]，[2][0]，[2][2]，[2][4]</li></ul><p id="e177" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">使用所有这些规则，我们可以创建一个叫做<em class="ll"> updateBoard的方法。</em>这将允许我们根据轮到谁以及他们选择的位置来更新<em class="ll">游戏板</em>中的位置。</p><figure class="jo jp jq jr fd js"><div class="bz dy l di"><div class="mp lk l"/></div></figure><p id="6693" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><em class="ll">注意:这是之前的课；我们刚刚在printBoard()函数下添加了updateBoard()函数。</em></p><p id="b841" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><em class="ll"> updateBoard() </em>接收棋子将要放置的位置，轮到谁了，以及游戏板的状态。</p><p id="fbb1" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">用我们之前的规则，玩家等于1，他们的角色是X；计算机等于2，它们的字符是o。使用if-else语句来确定该轮到谁了，以及应该放置什么棋子。</p><p id="cf41" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">在我们决定轮到谁之后，我们需要决定将棋子放在哪里。switch语句用于区分不同的情况。情况1表示玩家或电脑选择了第一个位置。(也就是左上角)根据谁选择了那个位置，相应的棋子就放在那个位置，我们就脱离了switch语句。</p><pre class="jo jp jq jr fd mq mr ms mt aw mu bi"><span id="771a" class="mv lo hi mr b fi mw mx l my mz">/** Change the position and player to see the pieces move around the board. Insert this function call in the main method and play around with the numbers to see the pieces appear. **/</span><span id="295e" class="mv lo hi mr b fi na mx l my mz">updateBoard(5, 1, gameBoard);<br/>updateBoard(1, 2, gameBoard);<br/>updateBoard(7, 1, gameBoard);</span></pre><p id="e94c" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">在这一点上，你应该能够:在棋盘上为电脑和玩家添加棋子。请务必通过从播放器切换到计算机来测试此功能。</p></div><div class="ab cl jg jh gp ji" role="separator"><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl"/></div><div class="hb hc hd he hf"><h1 id="cc2f" class="ln lo hi bd lp lq nb ls lt lu nc lw lx ix nd iy lz ja ne jb mb jd nf je md me bi translated">获取玩家输入</h1><p id="7796" class="pw-post-body-paragraph jz ka hi kb b kc mf is ke kf mg iv kh ki mh kk kl km mi ko kp kq mj ks kt ku hb bi translated">现在我们可以看到棋盘并在棋盘上放置棋子，我们希望玩家告诉我们棋子应该放在哪里。为此，我们将创建一个名为<em class="ll"> playerMove()的新函数。</em>在<em class="ll"> playerMove() </em>中，我们将利用内置的Scanner类来检索玩家输入，并包括一些用户验证，以确保用户输入有效的响应。</p><figure class="jo jp jq jr fd js"><div class="bz dy l di"><div class="mp lk l"/></div></figure><p id="0ffd" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><em class="ll">注:这是之前的课；我们刚刚在updateBoard()下添加了playerMove()函数。我们还导入了扫描仪库，并在第5行创建了一个新的扫描仪对象。为了可读性，我把main方法留在了这里。</em></p><pre class="jo jp jq jr fd mq mr ms mt aw mu bi"><span id="26a2" class="mv lo hi mr b fi mw mx l my mz">/** We have created a static Scanner here because we will utilize the player input in other areas. If we create only one instance to hold the player response, we do not have to worry about deleted or having multiple Scanner objects. **/</span></pre><p id="fae8" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><em class="ll"> playerMove() </em>函数本身很简单。我们询问玩家他们想要移动到什么位置，保存这个响应，并将其输入到我们的<em class="ll"> updateBoard() </em>函数中。</p><pre class="jo jp jq jr fd mq mr ms mt aw mu bi"><span id="bb7d" class="mv lo hi mr b fi mw mx l my mz">/** Line #15 has code for testing this function. Play around with feeding different values into the function. Do you notice that something is off? **/</span></pre><p id="9f61" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">如果您尝试在代码中添加不同的值，您可能会注意到有些地方不对劲。也就是说，您实际上可以将字符放在已经包含字符的空格的顶部。这在井字游戏中是不允许的，我们需要解决这个问题。为此，我们将在放置棋子之前创建一个函数来验证玩家的移动。</p></div><div class="ab cl jg jh gp ji" role="separator"><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl"/></div><div class="hb hc hd he hf"><h1 id="4435" class="ln lo hi bd lp lq nb ls lt lu nc lw lx ix nd iy lz ja ne jb mb jd nf je md me bi translated">验证移动</h1><p id="ca4a" class="pw-post-body-paragraph jz ka hi kb b kc mf is ke kf mg iv kh ki mh kk kl km mi ko kp kq mj ks kt ku hb bi translated">为了验证玩家是否进行了有效的移动，我们需要确定什么是有效的移动。在我们的世界里，我们正在构建一个由破折号[ — ]、竖线[ | ]和空格[" "]组成的游戏。虚线和空格代表板上的空白区域。</p><pre class="jo jp jq jr fd mq mr ms mt aw mu bi"><span id="d940" class="mv lo hi mr b fi mw mx l my mz">/**         _ | _ | _     Helpful indices:[0][0] , [0][2] , [0][4]<br/>            _ | _ | _                     [1][0] , [1][2] , [1][4]<br/>              |   |                       [2][0] , [2][2] , [2][4]   <br/>**/     </span></pre><p id="3f82" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">因此，如果一名球员选择了一个除了破折号或空格之外的空格，这个位置要么无效，要么被占据。例如，[0][1]是竖线，那是我们游戏的无效空格。</p><p id="6e72" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><em class="ll">注意:如果你回头看看注释或图表，你可以看到哪些值对应于有效空间。</em></p><figure class="jo jp jq jr fd js"><div class="bz dy l di"><div class="mp lk l"/></div></figure><p id="69ca" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><em class="ll">注意:我们更新了playerMove()函数，并在其下添加了isValidMove()函数。</em></p><p id="cf0a" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><em class="ll">玩家移动</em>()功能现在在放置棋子和更新棋盘之前检查玩家是否正在进行有效的移动。我们更新了<em class="ll"> playerMove() </em>函数，增加了一个while循环和一个布尔函数。布尔值保存着i <em class="ll"> sValidMove </em>()函数的结果。当<em class="ll"> isValidMove </em>()的结果为false时，程序将不断循环，直到玩家输入有效的移动。</p><p id="d3cd" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">进入<em class="ll"> isValidMove </em>()函数，该函数接受玩家的移动输入，并测试玩家输入的位置是否为空。如果该位置为空，则返回true，否则返回false，因为该位置已被占用。</p><pre class="jo jp jq jr fd mq mr ms mt aw mu bi"><span id="c3dc" class="mv lo hi mr b fi mw mx l my mz">/** You could implement the validation differently. You could create a set for empty positions. You could check if the position was in the empty position set and return true or false based on that. You would need to fill the set with empty positions in the main method before running the game. **/</span><span id="7806" class="mv lo hi mr b fi na mx l my mz">import java.util.HashSet;</span><span id="d01e" class="mv lo hi mr b fi na mx l my mz">static Set&lt;Integer&gt; emptyPositions = new HashSet&lt;Integer&gt;();</span><span id="a07b" class="mv lo hi mr b fi na mx l my mz">public static void main(String [] args){</span><span id="d49f" class="mv lo hi mr b fi na mx l my mz">  char [][] gameBoard = {{'_','|','_','|','_'},{'_', '|',   <br/>  '_','|','_'},{' ','|',' ','|',' '}};</span><span id="18b2" class="mv lo hi mr b fi na mx l my mz">  for(int i =1; i&lt;10; i++){<br/>      emptyPositions.add(i);<br/>  }<br/>  <br/>  playerMove(gameBoard);</span><span id="38b3" class="mv lo hi mr b fi na mx l my mz">...omitting playerMove ...</span><span id="45fb" class="mv lo hi mr b fi na mx l my mz">public static boolean isValidMove(int move, char[][] gameboard){</span><span id="fb1a" class="mv lo hi mr b fi na mx l my mz">if(!emptyPositions.contains(move)){<br/>    return false;<br/>  }else{<br/>    emptyPositions.remove(move);<br/>    return true;<br/>  }</span><span id="42a9" class="mv lo hi mr b fi na mx l my mz">/** You can test this out by calling playerMove() a few times in the main method. Check and see if your invalid moves from before are allowed now. **/</span></pre></div><div class="ab cl jg jh gp ji" role="separator"><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl"/></div><div class="hb hc hd he hf"><h1 id="143f" class="ln lo hi bd lp lq nb ls lt lu nc lw lx ix nd iy lz ja ne jb mb jd nf je md me bi translated">模拟计算机</h1><p id="b568" class="pw-post-body-paragraph jz ka hi kb b kc mf is ke kf mg iv kh ki mh kk kl km mi ko kp kq mj ks kt ku hb bi translated">为了简单起见，我们将使用随机数生成器来模拟计算机。电脑会在每一回合选择一个0-9之间的随机数。我们将在<em class="ll"> computerMove() </em>函数中调用<em class="ll"> isValidMove() </em>函数，以确保我们的计算机也在有效空间中移动。</p><figure class="jo jp jq jr fd js"><div class="bz dy l di"><div class="mp lk l"/></div></figure><p id="ce91" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><em class="ll">注意:这个函数放在isValidMove()函数下面。</em></p><p id="aebb" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><em class="ll"> computerMove() </em>函数与<em class="ll"> playerMove() </em>函数非常相似。唯一的区别是随机对象的引入。不要忘记导入随机库。随机对象将允许我们生成一个从0到10的数字。</p><pre class="jo jp jq jr fd mq mr ms mt aw mu bi"><span id="80a0" class="mv lo hi mr b fi mw mx l my mz">/** You could stop the bound of the random number generator at 10.</span><span id="435c" class="mv lo hi mr b fi na mx l my mz">int move = rand.nextInt(10); <br/>int move = rand.nextInt(9)+1;</span><span id="1667" class="mv lo hi mr b fi na mx l my mz">These two lines of code are equivalent. Something worth pointing out is that the random number generator begins with zero and ends with the bound number not being included. That zero could cause us problems; however, we already handled that in our switch case in isValidMove(). Our valid moves only include 1 - 9. Anything else outside that range is automatically considered an invalid move and returns a false value for isValidMove().<br/>You can test this out by calling computerMove() a few times in the main method. Mix it up and call playerMove() too. You should start to see the beginnings of a game now. **/</span></pre></div><div class="ab cl jg jh gp ji" role="separator"><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl"/></div><div class="hb hc hd he hf"><h1 id="8869" class="ln lo hi bd lp lq nb ls lt lu nc lw lx ix nd iy lz ja ne jb mb jd nf je md me bi translated">赢得比赛</h1><p id="a24f" class="pw-post-body-paragraph jz ka hi kb b kc mf is ke kf mg iv kh ki mh kk kl km mi ko kp kq mj ks kt ku hb bi translated">我们的游戏开始成形了；只剩下几步了。我们需要确定获胜的条件或者游戏结束的时间。遵循传统井字游戏规则，获胜条件如下:</p><ul class=""><li id="2c9b" class="kv kw hi kb b kc kd kf kg ki kx km ky kq kz ku la lb lc ld bi translated">左轴上的对角线</li><li id="2d03" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">右轴上的对角线</li><li id="3641" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">三个横在顶部</li><li id="ead6" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">三个横在中间</li><li id="5e48" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">三个横在底部</li><li id="9a90" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">右边三个</li><li id="1cb7" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">三个在中间</li><li id="31ff" class="kv kw hi kb b kc le kf lf ki lg km lh kq li ku la lb lc ld bi translated">左边三个</li></ul><figure class="jo jp jq jr fd js er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mk"><img src="../Images/ca87f512ba56d01c666186b860e95a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EqNTsKuDTLFDROOZDjWCQA.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">所有可能获胜组合的视觉效果(由作者创建)</figcaption></figure><p id="0e65" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">这些是获胜的条件；然而，游戏也可以处于平局状态，其中所有的空间都被填满，并且没有一个获胜条件被满足。按照这个逻辑，我们希望在每次玩家或计算机移动时检查是否满足任何获胜条件。</p><pre class="jo jp jq jr fd mq mr ms mt aw mu bi"><span id="06fc" class="mv lo hi mr b fi mw mx l my mz">/** Technically, we do not have to check after every move. We can start checking after five moves, but we will check after every move to keep it simple. **/</span></pre><p id="1f8d" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">检查是否满足获胜条件的最简单方法是检查组合中的所有空格是否都相同。例如，如果[0][0]、[1][0]和[2][0]被填满，那么玩家或计算机在左侧垂直向下有三个，并且已经赢了。让我们创建一个名为<em class="ll"> isGameOver()的新函数。</em></p><figure class="jo jp jq jr fd js"><div class="bz dy l di"><div class="mp lk l"/></div></figure><p id="76b3" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><em class="ll">注意:这个函数放在computerMove()函数下面。</em></p><p id="9cdc" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">这个函数是前面使用的逻辑的巨大扩展。有八种可能获胜条件和一种平局条件。该函数检查计算机或玩家是否满足任何获胜条件。如果满足赢的条件或平局，那么游戏结束，将返回一个真结果，否则将返回一个假结果。</p><pre class="jo jp jq jr fd mq mr ms mt aw mu bi"><span id="e565" class="mv lo hi mr b fi mw mx l my mz">/** There are many ways to check to see if the player or computer has won. You could:</span><span id="4034" class="mv lo hi mr b fi na mx l my mz">- Convert all the rows and diagonals into sets, and check the length. A set can only contain unique values. Thus a winning set will only have a length of 1.</span><span id="16d5" class="mv lo hi mr b fi na mx l my mz">-Make the current snippet smaller and check to see if the space is equal to the space next to it. For example is [0][0] == [0][2] == [0][4] and just determine what symbol is inside of the spaces.</span><span id="7335" class="mv lo hi mr b fi na mx l my mz">-Use a for loop for checking instead of using a giant if statement. You could use a loop for the horizontal conditions, a loop for the vertical, and a loop for the diagonals.</span><span id="915a" class="mv lo hi mr b fi na mx l my mz">These are just a few ways. There are more ways than these. **/</span></pre></div><div class="ab cl jg jh gp ji" role="separator"><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl jm"/><span class="jj bw bk jk jl"/></div><div class="hb hc hd he hf"><h1 id="e721" class="ln lo hi bd lp lq nb ls lt lu nc lw lx ix nd iy lz ja ne jb mb jd nf je md me bi translated">再玩一次？</h1><p id="a176" class="pw-post-body-paragraph jz ka hi kb b kc mf is ke kf mg iv kh ki mh kk kl km mi ko kp kq mj ks kt ku hb bi translated">在哪里放置这个函数可能不明显，这是因为我们还没有创建游戏循环。一旦满足获胜条件或平局，游戏循环将允许玩家再次游戏。为了实现这一点，我们将在两个while循环中包装main方法。第一个是检查玩家是否想再玩一次，第二个是检查游戏是否结束。我们将创建两个布尔值，gameOver和playAgain。</p><figure class="jo jp jq jr fd js"><div class="bz dy l di"><div class="mp lk l"/></div></figure><p id="ae1d" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><em class="ll">注:这是我们游戏的主要功能。所有其他函数都是在这个函数之外编写的。</em></p><p id="6f02" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">playAgain是主要的while循环。当playAgain为真时，整个游戏将继续。我们通过欢迎玩家并允许他们迈出第一步来开始游戏。游戏将通过调用<em class="ll"> playerMove() </em>函数继续，并遍历我们之前创建的所有方法。然后我们将使用<em class="ll"> isGameOver() </em>函数检查第12行的电路板状态。如果游戏结束了，我们就跳出内部while循环，问玩家是否想再玩一次。</p><p id="1aad" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">如果游戏没有结束，它将成为计算机的回合，序列将一次又一次地重复，直到一个赢的条件或平局被满足。一旦<em class="ll"> isGameOver() </em>返回false，我们将打印出分数，并询问玩家是否想再玩一次。我们将重用之前保存玩家输入的扫描仪。根据玩家的输入，我们将结束游戏或重新开始游戏。</p><p id="3df3" class="pw-post-body-paragraph jz ka hi kb b kc kd is ke kf kg iv kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">如果你仔细看，第34行包含一个我们还没有写的函数，叫做<em class="ll"> resetBoard() </em>。这是因为它直到现在才变得相关。该功能将电路板设置回其初始状态。如果你愿意，你可以添加一个积分系统来记录分数。</p><figure class="jo jp jq jr fd js"><div class="bz dy l di"><div class="mp lk l"/></div></figure><h1 id="bf7d" class="ln lo hi bd lp lq lr ls lt lu lv lw lx ix ly iy lz ja ma jb mb jd mc je md me bi translated">鳍状物</h1><p id="9962" class="pw-post-body-paragraph jz ka hi kb b kc mf is ke kf mg iv kh ki mh kk kl km mi ko kp kq mj ks kt ku hb bi translated">我们完了。你现在已经有了一个用Java编写的完整的井字游戏控制台。世界是你的。通过创建其他游戏来继续提高你的编码技能，永远不要停止学习。贪吃蛇可能是一个有趣的游戏。如果你需要参考的话，这里的<a class="ae lm" href="https://github.com/Taylor-McNeil/YouTubeTutorials-/blob/master/TicTacToe.java" rel="noopener ugc nofollow" target="_blank"/>再次成为最终代码。你可以在<a class="ae lm" href="https://twitter.com/ThatDevTaylor" rel="noopener ugc nofollow" target="_blank"> twitter </a>上找到我，我在思考新的文章，谈论游戏。</p></div></div>    
</body>
</html>