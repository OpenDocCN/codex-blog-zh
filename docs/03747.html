<html>
<head>
<title>Understanding and implementing consistent hash algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解和实现一致哈希算法</h1>
<blockquote>原文：<a href="https://medium.com/codex/understanding-and-implementing-consistent-hash-algorithm-e53a35afa428?source=collection_archive---------3-----------------------#2021-09-21">https://medium.com/codex/understanding-and-implementing-consistent-hash-algorithm-e53a35afa428?source=collection_archive---------3-----------------------#2021-09-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1dce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在go-zero的分布式缓存实现中，我们大量使用了一致哈希算法。在本文中，我们将讨论一致散列的算法及其在go-zero中的实现细节。</p><p id="5de9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以存储为例，不可能说我们的存储只是整个微服务体系中的单个节点。</p><ul class=""><li id="5bd1" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">首先是提高稳定性。如果单个节点停机，整个存储将面临服务不可用。</li><li id="6a47" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">第二，对于数据容错。单节点数据丢失导致数据丢失。而对于多节点的情况，节点有备份，除非相互备份的节点同时被破坏。</li></ul><p id="edfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么问题就来了，多节点的情况下数据应该写到哪个节点呢？</p><h1 id="e982" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">混杂</h1><figure class="kq kr ks kt fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es kp"><img src="../Images/5f939deb2ddde6789bd63f4acf3ac32b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N8vcGTWtTu8qcidJ"/></div></div></figure><p id="3992" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以本质上:我们需要一个输入值，它可以被“压缩”**并转换成一个更小的值，通常是唯一的，并且格式非常紧凑，比如uint64**。</p><ul class=""><li id="fa72" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">幂等的:每次用相同的值计算散列，它必须保证获得相同的值</li></ul><p id="e61c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是<code class="du lb lc ld le b">hash</code>算法的作用。</p><p id="3a30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而是采用常规的<code class="du lb lc ld le b">hash</code>算法进行路由，例如<code class="du lb lc ld le b">key % N</code>。如果一个节点由于异常或心跳异常而退出集群，那么<code class="du lb lc ld le b">hash route</code>将导致大量数据被<code class="du lb lc ld le b">redistributed</code>到不同的节点。当一个节点接受一个新的请求时，需要重新处理逻辑来获取数据:如果在缓存中，很容易造成<strong class="ih hj"> <em class="lf">缓存雪崩</em> </strong>。</p><p id="a3f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，有必要引入<code class="du lb lc ld le b">consistent hash</code>算法。</p><h1 id="0f43" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">一致散列</h1><p id="b927" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">我们来看看<code class="du lb lc ld le b">consistent hash</code>是如何解决这些问题的。</p><h1 id="e3da" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">缺乏创意地改写</h1><p id="7954" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">让我们从解决巨大的<code class="du lb lc ld le b">rehash</code>问题开始。</p><figure class="kq kr ks kt fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ll"><img src="../Images/2e2c844cb022e378ee9192b7d87fc4be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IV9kYGxrAwjMXGAr"/></div></div></figure><p id="08f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上图，当添加一个新节点时，唯一受影响的键是<code class="du lb lc ld le b">key31</code>。添加(删除)新节点时，只有该节点附近的数据会受到影响。其他节点的数据不会受到影响，从而解决了节点变更的问题。</p><p id="dc81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这正是:单调性。这也是<code class="du lb lc ld le b">normal hash</code>算法无法满足分布式场景的原因。</p><h1 id="34f0" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">数据偏斜</h1><p id="46a7" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">其实上图显示目前大部分键都集中在<code class="du lb lc ld le b">node 1</code>上。如果在节点数量比较少的时候，可以触发集中在某个<code class="du lb lc ld le b">node</code>上的大部分按键，那么监控时发现的问题就是:节点之间负载不均衡。</p><p id="bd8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，<code class="du lb lc ld le b">consistent hash</code>引入了<code class="du lb lc ld le b">virtual node</code>的概念。</p><p id="4433" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于负载是不均匀的，我们人为地构建了一个平衡的场景，但是实际的节点只有这么多。所以我们用<code class="du lb lc ld le b">virtual node</code>来划分区域，而实际服务的节点还是和前面的一样。</p><h1 id="bc28" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">具体实施</h1><p id="307d" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">先说<code class="du lb lc ld le b">Get()</code>。</p><h1 id="4490" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">得到</h1><figure class="kq kr ks kt fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lm"><img src="../Images/fd1f4e2b9cb2a23c0758eb464b3603f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GsnIdASgW3yrzeYE"/></div></div></figure><p id="1b16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先说一下实现的原理。</p><ol class=""><li id="4228" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ln jj jk jl bi translated">计算<code class="du lb lc ld le b">key</code>的散列值</li><li id="ea95" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ln jj jk jl bi translated">找到第一个匹配的<code class="du lb lc ld le b">virtual node</code>的索引，并获取相应的<code class="du lb lc ld le b">h.keys[index]</code>:虚拟节点哈希值</li><li id="5744" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ln jj jk jl bi translated">去这个<code class="du lb lc ld le b">ring</code>找一个与之匹配的<code class="du lb lc ld le b">actual node</code></li></ol><p id="3cc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，我们可以看到<code class="du lb lc ld le b">ring</code>得到了一个<code class="du lb lc ld le b">[]node</code>。这是因为在计算<code class="du lb lc ld le b">virtual node hash</code>时，在不同的<code class="du lb lc ld le b">virtual node hash</code>对应于实际节点的情况下，可能存在散列冲突。</p><p id="0704" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也意味着<code class="du lb lc ld le b">node</code>和<code class="du lb lc ld le b">virtual node</code>是一对多的关系。而里面的<code class="du lb lc ld le b">ring</code>是下面的设计。</p><figure class="kq kr ks kt fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lo"><img src="../Images/6d42af5f5996680927f48c75a865a105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kQaYR8iMGriTQbXw"/></div></div></figure><p id="b6a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这实际上显示了一致性散列的分配策略。</p><ol class=""><li id="0ed5" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ln jj jk jl bi translated"><code class="du lb lc ld le b">virtual node</code>用作值域划分。<code class="du lb lc ld le b">key</code>用于获取<code class="du lb lc ld le b">node</code>，由<code class="du lb lc ld le b">virtual node</code>限定。</li><li id="86db" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ln jj jk jl bi translated"><code class="du lb lc ld le b">virtual node</code>确保<code class="du lb lc ld le b">hash</code>分配给不同节点的键大致均匀分布。也就是<strong class="ih hj">拆分装订</strong>。</li><li id="13fd" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ln jj jk jl bi translated">添加新节点时，会分配多个<code class="du lb lc ld le b">virtual nodes</code>。新节点可以承载多个现有节点的压力，从全局角度来看，扩容时更容易实现负载均衡。</li></ol><h1 id="e434" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">添加节点</h1><figure class="kq kr ks kt fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lp"><img src="../Images/440b9020170dd7da7f1fb7c2bb0521f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uaoelUmUU6K4Z4jo"/></div></div></figure><p id="c135" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">读完<code class="du lb lc ld le b">Get</code>，你实际上大概知道了整个一致hash是怎么设计的。</p><pre class="kq kr ks kt fd lq le lr ls aw lt bi"><span id="6c17" class="lu js hi le b fi lv lw l lx ly"><strong class="le hj">type</strong> ConsistentHash <strong class="le hj">struct</strong> {<br/>  hashFunc Func // hash function<br/>  replicas <strong class="le hj">int</strong> // virtual node amplification factor<br/>  keys []<strong class="le hj">uint64</strong> // store virtual node hash<br/>  ring <strong class="le hj">map</strong>[<strong class="le hj">uint64</strong>][]<strong class="le hj">interface</strong>{} // virtual node to actual node correspondence<br/>  nodes <strong class="le hj">map</strong>[<strong class="le hj">string</strong>]lang.PlaceholderType // actual node storage [easy to find quickly, so use map]<br/>  lock sync.RWMutex<br/>}</span></pre><p id="bb60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样基本的一致散列就完全实现了。</p><blockquote class="lz ma mb"><p id="0d64" class="if ig lf ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><em class="hi">代码:</em><a class="ae mf" href="https://github.com/tal-tech/go-zero/blob/master/core/hash/consistenthash.go" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://github . com/tal-tech/go-zero/blob/master/core/hash/consistent hash . go</em></a></p></blockquote><h1 id="e949" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">使用场景</h1><p id="104b" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">开头实际上是说一致性哈希可以广泛应用于分布式系统中。</p><ol class=""><li id="8382" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ln jj jk jl bi translated">分布式缓存。可以在<code class="du lb lc ld le b">redis cluster</code>这样的存储系统上构建一个<code class="du lb lc ld le b">cache proxy</code>，自由控制路由。对于这个路由规则，我们可以使用一致散列算法</li><li id="1fc7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ln jj jk jl bi translated">服务发现</li><li id="1a55" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ln jj jk jl bi translated">任务的分布式调度</li></ol><p id="cd80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述所有分布式系统都可以用于负载均衡模块。</p><h1 id="bba0" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">项目地址</h1><p id="338f" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated"><a class="ae mf" href="https://github.com/zeromicro/go-zero" rel="noopener ugc nofollow" target="_blank">T3【https://github.com/zeromicro/go-zero】T5</a></p><p id="4345" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">欢迎使用go-zero，给个<strong class="ih hj">星</strong>支持我们！</p></div></div>    
</body>
</html>