# JavaScript 数据结构和算法(递归，第 1 部分)

> 原文：<https://medium.com/codex/javascript-data-structures-and-algorithms-recursion-part-1-fb2c33ccbc17?source=collection_archive---------8----------------------->

![](img/7621f3965a0fe564cd7913af46176665.png)

[西蒙朱](https://unsplash.com/@smnzhu?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

你好，欢迎光临！如果您不是第一次阅读，那么我希望您已经阅读了本系列的前一篇文章，其中介绍了树数据结构中的搜索算法的基础知识(如果没有，那么您可以阅读前一篇文章的第 2 部分[这里](/@oaluna/javascript-data-structures-and-algorithms-search-algorithms-part-2-6f7c577b32e9)，或者[这里](/@oaluna/javascript-algorithms-and-data-structures-search-algorithms-part-1-8270911d5f84)第 1 部分)。

今天我将谈论一个编程概念，我发现这个概念至今仍难以理解。没错，今天我们来谈谈*递归*。递归是一种解决问题的技术，在这种技术中，一个给定的解决方案(或者在我们的例子中，是一个函数)调用它自己来解决问题。一位不知名的编程圣人曾经说过:

> "为了理解递归，必须理解递归."

仅仅是这句话就为我揭开了众所周知的困惑的面纱，也让我明白了这句话的真正含义。说到这里，让我们开始吧！

# 递归方法

正如我前面提到的，编程中的递归是一种解决问题的方法，其中函数调用自身来解决给定的问题。这是一个简单的定义，但是自从我第一次了解到这个编程概念(直到我发现这个匿名引用，见上)以来，它就让我晕头转向。这是一种我们至少用过一次的解决问题的技巧，尽管你可能不记得了。如果你曾经求解过阶乘，比如必须求出 5 的值！在学校，那么你在生活中至少用过一次递归。递归作为一种解决问题的模式，在同一个函数体内调用一个函数。递归要求重复进行，将数据分解到其最低值，也称为递归函数的*基例*。

让我们看一个阶乘表达式(别担心，这不是复杂的数学)。提醒一下，阶乘是从 1 到 *n 的所有非零整数的乘积。可以评估为 **5 * 4 * 3 * 2 * 1** ，等于 **120** 。让我们构建一个接收数字 *n* 并返回其阶乘值的函数。这比听起来简单；你能做到的！*

虽然我说过使用递归解决问题只是简单地调用函数本身*，*如果没有停止递归过程的方法，这样做实际上会导致调用堆栈(大小有限)在运行这个函数时溢出。不用说，这是有问题的。我们需要建立一个所谓的基础案例，也就是所谓的中断条件。只要我们的递归回调不超过调用堆栈的大小限制，堆栈中的任何返回值都可以用作基本情况。

这对我们的阶乘函数意味着什么？这意味着我们不能乘以一个小于 1 的数，所以这一定是我们定义基本情况的值。由于阶乘涉及 1 和 *n* 之间的每个非零整数，我们可以反向工作，从我们的数中减去 1，直到 *n* 等于 1，并且不继续超过 1(因为如果 n = 1，那么 n-1 = 0，并且 5*4*3*2*1*0 = 0)。这意味着当 n-1 等于 1 时，我们必须停止递归，并在到达那个数(2)时返回那个值(而不是再次递归调用它自己)。恭喜你，你刚刚找到了我们的基本情况，这已经是我们递归函数的一半逻辑了。让我们开始写出来:

我们的阶乘递归函数，以及我们的基本情况条件语句。(创建于 https://carbon.now.sh)

简单，不是吗？现在我们知道了递归必须在哪里结束，剩下的就是定义递归逻辑本身了。让我们反向操作，从 *n* 乘到 1，而不是从 1 到 *n* 、递增。所有需要做的就是从 *n* 中一次又一次地减去 1，或者递归地。哒哒！就是这样。现在，您可以在控制台中运行递归函数并检查结果:

我们成功了，孩子们！(创建于 https://carbon.now.sh)

(附带说明:你可能需要使用浏览器的 DevTools 手动运行递归回调，因为我们的数量需要在范围内冒泡。在这种情况下，只需在调试器的范围工具中单击“单步执行”即可在“局部”选项卡中查看存储的局部变量。)

乍一看，这似乎并不复杂，但是递归是一种强大的解决问题的方法。虽然它在空间复杂度方面可以运行得很高，但它比必须迭代一系列值要好，因为每个嵌套循环都会增加 O(n)的时间复杂度。

# 永恒的科技面试经典:斐波那契数列算法

让我们来看一个可以用递归来解决的技术面试问题(事实上，如果你用递归来解决这个问题，看起来非常好)。这是一个老掉牙的斐波那契数列问题，我第一次读到这个问题是在这里，这个问题被无数的面试官恶心地使用过，它说:

> **"给定一个由 *n* 个数字组成的数组，写一个函数返回斐波那契数列中的第 *n* 个元素。(**约束:假设 0<n≤30)

**斐波纳契数列是一个数字序列，其中任意两个连续的数字加起来是数列中的第三个数字。比如斐波那契数列的前十个数字是[1，1，2，3，5，8，13，21，34，55](因为 1 + 1 = 2，1 + 2 = 3，2 + 3 = 5 等。).就上面的问题而言，我们的任务是找到斐波纳契数列中 10 个数字的数组中的第 10 个元素。听起来很可怕，但是所有的逆境都是可以克服的。让我们一步一步地递归解决这个问题。**

**另一种解释斐波纳契数列定义的方式是，每三个数字是它自己减 1 和它自己减 2 的和。现在，停在那里。如果你重读这个问题，我们得到一个约束，0 < n. This means that neither *n-1* 和 *n-2* 都不能等于 0。就这样，我们找到了找到基本案例的方法。如果 n-2 不小于 1，n-1 也是，那么(n-2)+(n-1)至少是 2。我们唯一能接受的低于 2 的值是 1。因此:**

**斐波那契数列函数的基本情况。(创建于 https://carbon.now.sh)**

**其余的几乎是自己写的。我不确定为什么我要在快照之间写这篇中间评论:**

**我们的递归斐波那契数列函数(创建于 https://carbon.now.sh)**

**好东西，读者！我知道递归可能很棘手，但是理解它可以帮你避免很多麻烦。我想我今天就说到这里，下一次，我们将更深入地研究递归用例，主要是广度优先搜索和深度优先搜索。记得练习，练习，练习。下次见！**