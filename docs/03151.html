<html>
<head>
<title>Binary Search Tree Traversals (Inorder, Preorder, and Postorder)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉查找树遍历(有序、前序和后序)</h1>
<blockquote>原文：<a href="https://medium.com/codex/binary-search-tree-traversals-inorder-preorder-and-postorder-6f458e10dbb0?source=collection_archive---------9-----------------------#2021-08-20">https://medium.com/codex/binary-search-tree-traversals-inorder-preorder-and-postorder-6f458e10dbb0?source=collection_archive---------9-----------------------#2021-08-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ab0f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用Javascript解释树遍历。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8f42bb27810fc7bc2922829e35d987a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Kw0Whme280SdcSSCf5-Fg.png"/></div></div></figure><h1 id="ebee" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated"><strong class="ak">什么是二分搜索法树？</strong></h1><p id="318f" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">二分搜索法树是计算机科学中使用的基本数据结构之一。</p><p id="9d9b" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">二分搜索法树的概念包括节点的集合。这包括一个根节点以及相同类型的父节点、子节点和叶节点。每个节点都连接有0、1或2个子节点。左边的子代必须小于父代，右边的子代必须大于父代。没有子节点的节点是叶节点。这些内部节点集合构成了所谓的子树。这样可以在视觉上形成树状结构。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="dd94" class="lh jk hi ld b fi li lj l lk ll">                             10<br/>                           /    \<br/>                          8      15<br/>                         / \    /  \<br/>                        6   9  12  16</span></pre><p id="da92" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在Javascript中创建一个二叉查找树，我们通常通过一个类似于<code class="du lm ln lo ld b">BinarySearchTree</code>或<code class="du lm ln lo ld b">BST</code>的类和一个<code class="du lm ln lo ld b">Node</code>类来实现。我们给我们的树几个方法，如<code class="du lm ln lo ld b">insert()</code>、<code class="du lm ln lo ld b">remove()</code>和<code class="du lm ln lo ld b">contains()</code>。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="ac1f" class="lh jk hi ld b fi li lj l lk ll">class Node {<br/>    constructor(value) {<br/>        this.value = value;<br/>        this.left = null;<br/>        this.right = null;<br/>    }<br/>}<br/>class BinarySearchTree {<br/>    constructor(value) {<br/>        this.root = value;<br/>    }<br/>    contains(node) {<br/>        ...<br/>    }<br/>    <br/>    insert(node) {<br/>        ...<br/>    }<br/>    <br/>    remove(node) {<br/>        ...<br/>    }<br/>}</span></pre><p id="c77e" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">为了浏览这些二分搜索法树，我们通过三种主要的遍历方法来实现，这三种方法分别叫做有序、前序和后序。这些通常在Javascript中递归执行。让我们在接下来的小节中回顾一下这些遍历方法。</p><h1 id="0f41" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">中根次序</h1><p id="b648" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">为了执行有序遍历，我们总是先从左边的节点开始遍历，然后访问当前节点和右边的节点。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="3099" class="lh jk hi ld b fi li lj l lk ll">inOrderTraverse(node) { <br/> // check if tree node exists<br/> if (node) {<br/>  // traverse down left subtree (Left, Node, Right)<br/>  inOrderTraverse(node.left);<br/>  console.log(node.value);<br/>  inOrderTraverse(node.right);<br/> }<br/>}</span></pre><p id="994d" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在这个方法中，我们首先检查以确保当前节点不是<code class="du lm ln lo ld b">null</code>。然后，如果我们的节点存在，我们开始我们的遍历。首先，我们递归访问左边的子节点，然后打印出当前节点，最后，我们递归遍历右边的子节点。这将重复进行，直到访问完所有节点。</p><h1 id="e71c" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">预购</h1><p id="8858" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">对于前序遍历，我们遵循相同的步骤，只是顺序不同。我们将首先从当前节点开始，然后移动到左右节点。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="96db" class="lh jk hi ld b fi li lj l lk ll">preOrderTraverse(node) {<br/> if (node) {<br/>  // traverse tree preorder (Current, Left, Right)<br/>  console.log(node.value);<br/>  preOrderTraverse(node.left);<br/>  preOrderTraverse(node.right);<br/> }<br/>}</span></pre><p id="55c3" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">像我们的inorder遍历一样，我们检查以确保我们试图遍历的当前节点存在。然后，我们访问当前节点，在递归调用左右节点上的方法之前将它打印出来，直到到达末尾。</p><h1 id="d779" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">后期订单</h1><p id="1faf" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">您可能已经猜到了，后序遍历与前序遍历相反。首先，我们先遍历左边的子节点，然后是右边的子节点，最后是当前节点。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="9f6b" class="lh jk hi ld b fi li lj l lk ll">postOrderTraverse(node) {<br/> if (node) {<br/>  // traverse tree postorder (Left, Right, Current)<br/>  postOrderTraverse(node.left);<br/>  postOrderTraverse(node.right);<br/>  console.log(node.value);<br/> }<br/>}</span></pre><p id="03ab" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">就像前面的遍历方法一样，我们总是确保检查节点不是<code class="du lm ln lo ld b">null</code>。然后，在打印当前节点值之前，我们在左右节点上递归调用我们的方法，直到遍历完整个树。</p><h1 id="7303" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">摘要</h1><p id="9863" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">这是对计算机科学中一些最常见的树遍历类型的简要解释。每种遍历技术都为我们提供了一种不同的方式来导航和访问树中的每个节点。关于这个主题的更多信息，请查看我在下面提供的参考资料。</p><h1 id="e260" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">参考</h1><ul class=""><li id="de6a" class="lp lq hi kd b ke kf kh ki kk lr ko ls ks lt kw lu lv lw lx bi translated"><a class="ae ly" href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/" rel="noopener ugc nofollow" target="_blank">极客之极客——穿越树</a></li><li id="f539" class="lp lq hi kd b ke lz kh ma kk mb ko mc ks md kw lu lv lw lx bi translated"><a class="ae ly" href="https://www.youtube.com/watch?v=BHB0B1jFKQc" rel="noopener ugc nofollow" target="_blank">二叉树训练营</a></li></ul></div></div>    
</body>
</html>