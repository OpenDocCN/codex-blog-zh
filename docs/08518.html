<html>
<head>
<title>Best Libraries for Fuzzy Matching In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中模糊匹配的最佳库</h1>
<blockquote>原文：<a href="https://medium.com/codex/best-libraries-for-fuzzy-matching-in-python-cbb3e0ef87dd?source=collection_archive---------0-----------------------#2022-08-14">https://medium.com/codex/best-libraries-for-fuzzy-matching-in-python-cbb3e0ef87dd?source=collection_archive---------0-----------------------#2022-08-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c293" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">字符串匹配变得简单</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a26ba68d84ae460284ad01f054e0a689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*schtwb4M3jQWa-dHrqu3Lw.png"/></div></div></figure><p id="da72" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">数据科学家在日常工作中必须处理各种数据。数据处理的最大挑战之一来自非结构化数据。当数据不能以表格(结构化)的方式表示时，就称为非结构化数据。<a class="ae kf" href="https://writersbyte.com/uncategorized/why-is-big-data-so-important/" rel="noopener ugc nofollow" target="_blank">非结构化数据</a>包括文本、音频、视频文件等。</p><p id="b321" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">文本数据是通过使用特殊技术来处理的。一种这样的技术是模糊匹配。模糊匹配是指寻找字符串之间的相似性，这些相似性度量可以用于多种目的。模糊匹配可以通过多种算法来完成，每种算法都有其优缺点。下面我们来讨论一下这些算法。</p><h2 id="1c19" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">常见的模糊匹配算法</h2><p id="d80e" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">模糊匹配用于检查两个字符串是相同还是不同，如果是后者，则检查它们不同的原因。模糊匹配通常被称为<strong class="jl hj">编辑距离，</strong>，即字符串A需要编辑多少才能匹配字符串B？有多种计算相似性度量的方法。我们来讨论三个最常见的。</p><ul class=""><li id="cf98" class="lg lh hi jl b jm jn jp jq js li jw lj ka lk ke ll lm ln lo bi translated"><strong class="jl hj">莱文斯坦距离</strong></li></ul><p id="7651" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">弗拉基米尔·莱文斯坦于1965年首次使用了莱文斯坦距离。它通过计算将第一个字符串转换为第二个字符串所需的最小单字符编辑次数来确定两个字符串之间的相似性。Levenshtein将以下操作视为编辑:</p><ol class=""><li id="c59d" class="lg lh hi jl b jm jn jp jq js li jw lj ka lk ke lp lm ln lo bi translated">添加</li><li id="a228" class="lg lh hi jl b jm lq jp lr js ls jw lt ka lu ke lp lm ln lo bi translated">删除</li><li id="4346" class="lg lh hi jl b jm lq jp lr js ls jw lt ka lu ke lp lm ln lo bi translated">代替</li></ol><p id="db00" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所需编辑的数量越小，两个字符串越接近。</p><ul class=""><li id="db11" class="lg lh hi jl b jm jn jp jq js li jw lj ka lk ke ll lm ln lo bi translated"><strong class="jl hj">damer au–Levenshtein距离</strong></li></ul><p id="ee8f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Damerau-Levenshtein的工作方式与传统的Levenshtein算法完全相同，但有一点改进。除了上面提到的三个编辑，Damerau-Levenshtein还考虑了换位。换位相当于交换两个相邻的字符，被认为是一次操作。Damerau指出，这四种操作占所有人类拼写错误的80%。</p><ul class=""><li id="37a4" class="lg lh hi jl b jm jn jp jq js li jw lj ka lk ke ll lm ln lo bi translated"><strong class="jl hj">贾罗-温克勒距离</strong></li></ul><p id="92fc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Jaro-Winkler距离算法是在1990年提出的。它建立在Jaro相似性算法的基础上，该算法使用以下公式来计算相似性。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lv"><img src="../Images/7012c0d784672dc15cea145f8b9ddb8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*vIztsIBmptmnBwa3lDhENQ.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">Jaro相似方程</figcaption></figure><ul class=""><li id="c816" class="lg lh hi jl b jm jn jp jq js li jw lj ka lk ke ll lm ln lo bi translated">m =匹配字符的数量</li><li id="43c1" class="lg lh hi jl b jm lq jp lr js ls jw lt ka lu ke ll lm ln lo bi translated">t是转座数的一半</li><li id="ca4e" class="lg lh hi jl b jm lq jp lr js ls jw lt ka lu ke ll lm ln lo bi translated">|s1|和|s2|分别是每个字符串的长度。</li></ul><p id="ac80" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Jaro相似性返回一个介于0和1之间的分数，其中0表示不匹配，1表示字符串完全相同。Jaro-Winkler通过对第一个<em class="ma"> i </em>匹配字符应用更多权重来修改公式。我不会讲太多细节，但最终形式由下面的等式表示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mb"><img src="../Images/8b4bc0ae5867a8b3fd83a68fd3e4e71f.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*aj55epqWjrK0xaATqikWog.png"/></div></figure><p id="1d46" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在继续之前，如果你觉得这些内容有帮助，请考虑在<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/codex/ko-fi.com/moosaali9906"> Ko-Fi </a>上支持我。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><a href="http://ko-fi.com/moosaali9906"><div class="er es mc"><img src="../Images/a9b75b9a2d9b6bf73b23151d0a95f04f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RAVsw7Mcvsh8aJL3LuG6bg.png"/></div></a><figcaption class="lw lx et er es ly lz bd b be z dx translated">在高保真上支持我</figcaption></figure><h2 id="c7d7" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">python中的模糊匹配库</h2><p id="cf2c" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">Python有很多模糊匹配算法的实现。我收集了一些可供开源使用的最好的库。</p><ol class=""><li id="793e" class="lg lh hi jl b jm jn jp jq js li jw lj ka lk ke lp lm ln lo bi translated"><strong class="jl hj"> FuzzyWuzzy </strong></li></ol><p id="1e4d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">FuzzyWuzzy使用模糊匹配的Levenshtein距离实现来给出所提供的句子之间的比率分数。</p><p id="fac7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用以下命令安装库。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es md"><img src="../Images/a7b84ae3a42fda42401a537c065f75b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDKWb3UJYbzK5pMgW5-tSQ.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">模糊的装置</figcaption></figure><p id="b67f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">安装完成后，只需如下所示的一行代码就可以使用这个库。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/28fe92f5a765304652b9863d8ed58992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDJJUxeJxscHSfag2RAvmA.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">测试fuzzywuzzy</figcaption></figure><p id="ac3e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">得到的比率是90，意味着这两个句子90%相似。</p><p id="be4d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">该库还附带了一个额外的包，可以将计算速度提高10倍。从他们的<a class="ae kf" href="https://pypi.org/project/fuzzywuzzy/" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多关于FuzzyWuzzy的信息。</p><p id="64b7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">2.<strong class="jl hj"> Rapidfuzz </strong></p><p id="6ff5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">RapidFuzz与FuzzyWuzzy是完全相同的实现，但主要是用C++编写的，并在它的基础上提供了额外的算法改进。它的C++实现使得这个库非常快，并且它提供了一些优于FuzzyWuzzy的额外好处。</p><ul class=""><li id="af7d" class="lg lh hi jl b jm jn jp jq js li jw lj ka lk ke ll lm ln lo bi translated">这是一个麻省理工学院的许可证，所以你可以为你的项目自由选择许可证。</li><li id="f192" class="lg lh hi jl b jm lq jp lr js ls jw lt ka lu ke ll lm ln lo bi translated">它包含了一些额外的实现，比如Jaro-Winkler，这是FuzzyWuzzy中没有的</li></ul><p id="f13e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您可以使用以下命令安装该库。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/0e1d69463c0d2e63194a4303a0b075e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqEwSOttCI29PXHQXHafaw.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">安装RapidFuzz</figcaption></figure><p id="a58f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">它的功能与FuzzyWuzzy完全相同，但速度更快。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/717f910e89c0eada1ee795379dc91d91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g5DG9rxqFFWH7rElp7DQNg.png"/></div></div></figure><p id="c0d3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个比率是<strong class="jl hj"> 80.7% </strong></p><p id="2a3e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">RapidFuzz也提供了更多的功能，类似于FuzzyWuzzy。在<a class="ae kf" href="https://pypi.org/project/rapidfuzz/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中阅读更多关于它们的信息。</p><p id="6226" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">3.贾罗-温克勒<strong class="jl hj"/></p><p id="e8a6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Jaro-Winkler距离在python中也有多种实现，但很明显，其中许多都是不正确的。根据StackOverflow 上的一个用户所说，pyjarowinkler (一个非常古老和流行的python库)产生的结果似乎不正确。我用jaro-winkler库测试了同样的问题，得到了与其他正确实现匹配的结果。</p><p id="8650" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用以下命令安装库。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/fa1da87c39b9e185b7543294a1c82612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wic8fV-vR845R5hURSUf0Q.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">安装jaro-winkler</figcaption></figure><p id="73a6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用“jaro_winkler_metric”函数计算距离。参见下面的应用程序。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mf"><img src="../Images/e4fa23a97bab34585fe7d5179b67d775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sYI5gnEXfFIboSBbzhMCwA.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">测试jaro-winkler库</figcaption></figure><p id="3f21" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">相似度为<strong class="jl hj"> 78.3 % </strong></p><p id="0201" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在计算比率或百分比时，Jaro-Winkler距离比Levenshtein或damer au–Levenshtein具有非常重要的优势。后面提到的算法为较小的字符串提供了误导性的结果。下面我们来看一个例子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/f13019eb9feea0f31a004f1b65429680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhu2hpslhDPLGrCDsfqIPQ.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">测试较短的字符串</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mh"><img src="../Images/c2a48016127cb966d360938a4e7c3322.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/1*3fcDu2Mwo97GNQSpPe_nKg.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">结果</figcaption></figure><p id="18c0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">即使字符串只相差一个字符，比率也是67%，这是一个非常大的数字。现在让我们和Jaro-Winkler距离比较一下。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/10535c9dfca09e3634ca823ea0f8746b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXKct0OUFu9Jnz0k2658pw.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mi"><img src="../Images/8270251131b0e58ef2c4fc7db8ee8a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*ux4nDdN-d6-hXEGc5WAHzA.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">两种算法的结果</figcaption></figure><p id="5cb7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Jaro-Winkler算法返回相似性百分比<strong class="jl hj"> 82.2%，</strong>这是一个合理得多的数字。</p><h2 id="0be5" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">模糊匹配的应用</h2><p id="eb8c" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">字符串匹配在日常应用中起着重要的作用。当你在谷歌上搜索某样东西，它会用著名的<em class="ma">“包括……的结果”来纠正你的错别字。</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/3f1986695214a0edff4e4a65a74480c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_9uny7yp28XO7661wXHUQ.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">谷歌字符串匹配</figcaption></figure><p id="bc0a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在后台，谷歌实际上通过编辑距离算法运行您的查询，并将其与预定义词典中的每个单词进行匹配。同样功能的另一个例子是手机上的自动更正功能。</p><p id="f2f2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">它也用于许多搜索算法中，这些算法弹出与实际查询相似的术语建议。这使得搜索功能更加高级，因为即使您没有输入准确的术语，也可以找到正确的匹配项。</p><p id="f8a0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">模糊匹配的另一个应用是消除数据库中的重复记录。很多时候，我们的记录包含类似的数据，所以像“分组”这样的把戏不起作用。模糊匹配有助于挑选出定义的阈值内的所有记录。</p><h2 id="7663" class="kg kh hi bd ki kj kk kl km kn ko kp kq js kr ks kt jw ku kv kw ka kx ky kz la bi translated">总结想法</h2><p id="c6c0" class="pw-post-body-paragraph jj jk hi jl b jm lb ij jo jp lc im jr js ld ju jv jw le jy jz ka lf kc kd ke hb bi translated">模糊匹配是一种简单却非常有用的<a class="ae kf" href="https://writersbyte.com/datascience/applied-data-science-with-python-and-pandas/" rel="noopener ugc nofollow" target="_blank">数据处理</a>技术。它用于web应用程序的不同方面，也包含在许多数据处理管道中。Python提供了一些惊人的库，实现了某种形式的模糊匹配。这些库提供了简单的API来计算字符串匹配分数，可以在您的应用程序中使用。</p></div></div>    
</body>
</html>