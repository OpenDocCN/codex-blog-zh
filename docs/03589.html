<html>
<head>
<title>Memory Cache in .NET Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内存缓存输入。网络核心</h1>
<blockquote>原文：<a href="https://medium.com/codex/memory-cache-in-net-core-c647379bafb?source=collection_archive---------0-----------------------#2021-09-10">https://medium.com/codex/memory-cache-in-net-core-c647379bafb?source=collection_archive---------0-----------------------#2021-09-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f945" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何使用内存缓存的实用指南？网络核心应用</p><h1 id="c4be" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">为什么要使用内存缓存？</h1><p id="d855" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我的假设是一个事实，我们中的大多数人——开发人员——不得不从外部资源读取一些数据。数据库、云存储或API过于频繁——数据几乎总是相同的。我必须诚实地承认，在许多情况下，我并不关心那个问题——毕竟，没有足够的数据来使它工作得不够快。🤔</p><p id="a4bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个非常短视的观点，因为我们不能假设在我们的应用程序中，未来不会有越来越多的数据需要获取，也不会有更多的用户“触发”过多读取外部数据源的事件。</p><p id="6e31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">内存缓存允许我们在应用程序的内存中存储一些变化很小的数据，并使得快速读取它们成为可能。我们把快速阅读归功于缓存使用的数据结构——字典(键值对集合)。此外，缓存从应用程序内存读取数据，而不是从外部来源读取数据——它总是比第二种方式更快。</p><h1 id="7ceb" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">理论结束，实施的时间到了</h1><p id="6601" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我将介绍我自己在。NET Core app。当然，实现总是依赖于需求，所以这只是某种如何实现的指南。</p><p id="9ed0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们使用的简单架构:</strong></p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/ab630c857c41f9f4350b766e883809b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tdb70VjFhTuVCATgu_hCSQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">蓝框—接口，绿框—类别</figcaption></figure><p id="e955" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的基本抽象是ICacheService接口。它包含可以被任何其他类型(简单或复杂)替换的通用参数。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kw"><img src="../Images/7ecd7df00f4b321a7546bb102dbb7548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*yq1FCtPLt5hzTpPbnLdUXQ.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">ICacheService接口</figcaption></figure><p id="dcf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它提供了三种基本的缓存操作:读、写和删除。异步读取数据很好，所以Get方法是任务的类型。</p><p id="896c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将准备实现ICacheService接口的MemoryCacheService类。该服务包含所有三种方法的默认实现:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kx"><img src="../Images/5081ce0cff365ec47bda3647c6f3a649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*C5neFblc_7sb9LXD4Qalcg.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">MemoryCacheService类</figcaption></figure><p id="4f2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> A使用我们还要补充:<em class="ky">使用微软。Extensions . Caching.Memory</em> </strong></p><p id="3403" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面，我将描述每一种方法:</p><ul class=""><li id="4f31" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated"><strong class="ih hj"> Get </strong> —读取存储在指定键下的值(缓存数据的名称，字符串类型)。如果指定的键不存在，返回T类型等的默认值。对于integer，它将是0，对于复杂的类模型，它就是null。我将此方法标记为虚拟的，因为我想在自定义内存缓存服务实现中覆盖它。</li><li id="3da4" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><strong class="ih hj">设置</strong> —设置新的缓存条目或重写现有条目。如果我们想创建一个新条目，唯一的字符串键是必要的。此外，我们可以提供一些定制的MemoryCacheEntryOptions。我为应用程序中的每个缓存对象使用默认设置，但当然我们可以覆盖Set方法中的第三个参数，并为每个条目提供自定义设置！</li><li id="5518" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><strong class="ih hj">移除</strong> —移除缓存的对象及其关键字。</li></ul><h1 id="ebfb" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">让我们创建自定义实现！</h1><p id="48b1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在，我们能够扩展我们的基本实现并创建定制的MemoryCacheService，它可以包含指定模型的更多逻辑。</p><p id="f2c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的例子中，一些游戏服务器的统计数据被读取得太频繁了，所以我决定使用内存缓存并将这些数据存储在其中。</p><p id="992f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我从创建空的自定义接口开始，它继承了base one。现在，我可以扩展基本功能，并只为指定的StatsModel类型添加一些方法。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ln"><img src="../Images/16b66d895880491b58d2c9dca356c193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*qVqLxP92DdOk2l7lVesZ6A.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">空IStatsMemoryCacheService</figcaption></figure><p id="d30a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，看一下实现:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lo"><img src="../Images/ca989a3685c5b03ac9cb95f30d30d035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSUu9bR1nLYsVW5_9DW8hQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">自定义StatsMemoryCacheService类</figcaption></figure><p id="fdd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几乎所有的东西都以和基本类一样的方式使用，Set和Remove方法完全一样。我唯一做的就是重写了Get方法。</p><p id="b149" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我试图找到我的缓存值，如果键不存在——从文件中获取统计数据并覆盖内存缓存条目。此外，我还使用滑动到期选项覆盖了内存缓存条目选项——我将在后面谈到这一点。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="b257" class="jd je hi bd jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw ma jy jz ka bi translated">在应用程序中注册内存缓存服务</h1><p id="ea6e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们必须做的最后一件事是在DI容器中注册我们的内存缓存服务，以便将它们注入到我们的应用程序中。</p><p id="c47f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我创建了一个简单的静态类，它扩展了IServiceCollection:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mb"><img src="../Images/66d9cc1432662a26a302edd6eb4ee107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*s0vTLny0eaUkhRM2sq3nVw.png"/></div></figure><p id="7a3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在启动时使用:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mc"><img src="../Images/ef475e96bc6046df42fcc14d5eca675b.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*NpQlQ15-6uzQGDSUic78_A.png"/></div></figure><p id="13cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">瞧，现在我们可以在我们想要的地方注入我们的内存缓存了！😎</p><h1 id="ced3" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">MemoryCacheEntryOptions呢？</h1><p id="1e5c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">MemoryCacheEntryOptions有一些设置可以使用，但我想描述一下最重要的设置:</p><ul class=""><li id="81b4" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">滑动呼气</li><li id="6f1b" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">绝对呼气</li></ul><p id="8ce3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">长话短说，如果必须在一段时间后自动清空缓存，绝对过期是更好的选择。在滑动过期的情况下，内存缓存可以在指定的时间后被删除，但如果缓存被经常读取，它将不会被清除！在这种情况下，如果我们想在这段时间后刷新数据，我们可能会失望。(当然，我们仍然能够覆盖现有条目，但是旧值不会被清除，直到我们覆盖它们为止)😕。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="6398" class="jd je hi bd jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw ma jy jz ka bi translated">结论</h1><p id="3f47" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">如果我们必须处理外部数据源，内存缓存是开发人员手中非常有用的工具。它加速并提高了我们应用的可扩展性。</p><p id="e9ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我热情地鼓励您阅读关于内存缓存及其选项的MS文档:<a class="ae md" href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/memory?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank">ASP.NET核心中的内存缓存|微软文档</a>。</p><p id="0c9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读，祝您愉快，让代码与您同在！💻 ⌨️ 🖥</p></div></div>    
</body>
</html>