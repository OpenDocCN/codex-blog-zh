<html>
<head>
<title>Compilation Process in C: Easy Introduction — StackZero</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C语言编译过程:简单介绍— StackZero</h1>
<blockquote>原文：<a href="https://medium.com/codex/compilation-process-in-c-easy-introduction-stackzero-9a2b1720576?source=collection_archive---------14-----------------------#2022-06-01">https://medium.com/codex/compilation-process-in-c-easy-introduction-stackzero-9a2b1720576?source=collection_archive---------14-----------------------#2022-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3420edc8102d6b60943d10a18d32225d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rh2BSuAnQG2Sk6li7T0k7g.jpeg"/></div></div></figure><h1 id="d991" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">定义</h1><p id="fbfe" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">c语言(更一般地说是编译语言)中的编译是从人类可读的源代码开始，生成可执行二进制文件的过程。</p><p id="348b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在C语言中，整个编译过程由四个阶段组成，可以概括如下:</p><p id="672c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">许多编译器合并了一些阶段。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/6aefb9a98ff37fb16f91344217450713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6Uet8C9So98a0LLJ_ufNg.jpeg"/></div></div></figure><h1 id="44c4" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">预处理</h1><p id="283d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">除了非常简单的程序，C中的编译过程必须管理许多源文件。每个源文件都包含<em class="kw">宏</em>(<strong class="jq hj">#定义</strong>)和<em class="kw">包含</em>(<strong class="jq hj">#包含</strong>)。<br/>预处理器负责扩展<strong class="jq hj"> #define </strong>和<strong class="jq hj"> #include </strong>指令，换句话说，就是用相应的代码替换指令。</p><p id="c347" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了更好地理解，我们可以看到一个简单的C语言HelloWorld程序，并尝试使用<a class="ae kx" href="https://www.gnu.org/software/gcc/" rel="noopener ugc nofollow" target="_blank"> GCC </a>对其进行预处理。</p><p id="a4fe" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="kw"> helloworld.h </em></p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="edf5" class="ld ir hi kz b fi le lf l lg lh">int helloworld();</span></pre><p id="b7e7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="kw"> helloworld.c </em></p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="cf04" class="ld ir hi kz b fi le lf l lg lh">#include &lt;stdio.h&gt; <br/>#include "helloworld.h" </span><span id="94ab" class="ld ir hi kz b fi li lf l lg lh">#define HELLOWORLD "Hello World!\n" <br/>int helloworld() <br/>{ <br/>    printf("%s", HELLOWORLD); <br/>    return 0; <br/>} </span><span id="265d" class="ld ir hi kz b fi li lf l lg lh">int main(){ <br/>    helloworld(); <br/>    return 0; <br/>}</span></pre><p id="e455" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">一旦我们编写了这段代码，我们就可以用GCC以这种方式进行预处理，而不需要完全编译:</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="c9cd" class="ld ir hi kz b fi le lf l lg lh">gcc -E -P helloworld.c</span></pre><p id="4efb" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">它会打印出这样的内容:</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="d203" class="ld ir hi kz b fi le lf l lg lh">typedef long unsigned int size_t; <br/>typedef __builtin_va_list __gnuc_va_list; <br/>int helloworld();<br/>typedef unsigned char __u_char; <br/>typedef unsigned short int __u_short; <br/>typedef unsigned int __u_int; <br/>typedef unsigned long int __u_long; <br/>typedef signed char __int8_t; <br/>typedef unsigned char __uint8_t; <br/>typedef signed short int __int16_t; <br/>typedef unsigned short int __uint16_t; <br/>typedef signed int __int32_t; </span><span id="de62" class="ld ir hi kz b fi li lf l lg lh">.... <br/>int helloworld();<br/> <br/>int helloworld() <br/>{ <br/>    printf("%s", "Hello World!\n"); <br/>    return 0; <br/>} <br/>int main()<br/>{ <br/>    helloworld(); <br/>    return 0; <br/>}</span></pre><p id="5355" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为简洁起见，跳过的第一部分是对<em class="kw"> stdio </em> <em class="kw">头</em>的扩展，第二部分正是对我们的头和宏的扩展。</p><h1 id="b19c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">汇编</h1><p id="a9a1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">接下来就是编译，简单来说就是从源代码到汇编的转换。<br/>显然，这似乎没有意义，为什么不直接输出二进制呢？这个中间步骤使得下一步工作变得更容易，只需要为所有编程语言编写一个独特的汇编程序。</p><p id="9969" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在编译过程中，编译器会进行一些优化并保留符号(除了剥离的情况)。</p><p id="ea59" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了更好地理解，我们可以将汇编输出传递给GCC选项-S. <br/>出于可读性的原因，我们不做任何优化</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="f8fe" class="ld ir hi kz b fi le lf l lg lh">gcc -S helloworld.c</span></pre><p id="5558" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">输出将是一个. s文件，这是ASM文件的默认扩展名。</p><p id="3571" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">你好，世界</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="daa2" class="ld ir hi kz b fi le lf l lg lh">.LC0:<br/> .string "Hello World!"<br/> .text<br/> .globl helloworld<br/> .type helloworld, <a class="ae kx" href="http://twitter.com/function" rel="noopener ugc nofollow" target="_blank">@function</a><br/>helloworld:<br/>.LFB0:<br/> .cfi_startproc<br/> endbr64<br/> pushq %rbp<br/> .cfi_def_cfa_offset 16<br/> .cfi_offset 6, -16<br/> movq %rsp, %rbp<br/> .cfi_def_cfa_register 6<br/> leaq .LC0(%rip), %rdi<br/> call puts@PLT<br/> movl $0, %eax<br/> popq %rbp<br/> .cfi_def_cfa 7, 8<br/> ret<br/> .cfi_endproc<br/>.LFE0:<br/> .size helloworld, .-helloworld<br/> .globl main<br/> .type main, <a class="ae kx" href="http://twitter.com/function" rel="noopener ugc nofollow" target="_blank">@function</a><br/>main:<br/>.LFB1:<br/> .cfi_startproc<br/> endbr64<br/> pushq %rbp<br/> .cfi_def_cfa_offset 16<br/> .cfi_offset 6, -16<br/> movq %rsp, %rbp<br/> .cfi_def_cfa_register 6<br/> movl $0, %eax<br/> call helloworld<br/> movl $0, %eax<br/> popq %rbp<br/> .cfi_def_cfa 7, 8<br/> ret<br/> .cfi_endproc</span></pre><p id="a0f9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果您更喜欢英特尔语法而不是美国电话电报公司，正确的命令是:</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="c875" class="ld ir hi kz b fi le lf l lg lh">gcc -S masm=intel</span></pre><h1 id="d08e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">装配</h1><p id="aa46" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">汇编器的工作是将ASM文件转换成目标文件，也称为“<em class="kw">模块</em>”。<br/>输出是机器码，每个ASM文件对应一个目标文件。</p><p id="ec31" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们在实践中试试:</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="971c" class="ld ir hi kz b fi le lf l lg lh">gcc -c helloworld.c -o helloworld.o</span></pre><p id="121c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">它会输出目标文件，如果我们想更好的理解它，可以使用<a class="ae kx" href="https://man7.org/linux/man-pages/man1/file.1.html" rel="noopener ugc nofollow" target="_blank">文件</a>命令。</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="1cac" class="ld ir hi kz b fi le lf l lg lh">file helloworld.out </span><span id="bbf1" class="ld ir hi kz b fi li lf l lg lh">#OUTPUT <br/>helloworld.out: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span></pre><p id="fbf8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">它说这是一个ELF文件(可执行和可链接格式),并且是可重定位的。</p><p id="8e5f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这意味着它不需要固定的内存地址，编译独立于其他对象运行。这也清楚地表明，我们面对的是一个对象，而不是一个可执行文件。<br/>对象可以包含对其他对象函数的引用，而在链接之前，它们只是被替换为重定位符号，所以显然一个对象在链接到其他对象之前是无法工作的。</p><p id="ff7e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">但是现在是时候进入链接阶段了。</p><h1 id="259e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">连接</h1><p id="788f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">链接器负责执行最后一步:将所有对象合并到一个可执行文件中。</p><p id="24c3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">一眼看去，它合并了所有对象，甚至解析了对库的符号引用。<br/>Linux中的库有两种类型:</p><ul class=""><li id="5b50" class="lj lk hi jq b jr km jv kn jz ll kd lm kh ln kl lo lp lq lr bi translated"><strong class="jq hj">静态</strong>(每个可执行文件的一个实例)</li><li id="51cc" class="lj lk hi jq b jr ls jv lt jz lu kd lv kh lw kl lo lp lq lr bi translated"><strong class="jq hj">共享/动态</strong>(所有进程共享的实例)</li></ul><p id="31a9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">链接器将静态库合并到可执行文件中，但是不知道共享/动态库的地址，所以，在这种情况下，留下符号引用。</p><p id="366d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">通常情况下，链接器和编译器是分离的实体，不管怎样，GCC会在编译过程结束时自动调用它。</p><p id="8a13" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们将看到所有阶段，包括链接，只需编写以下命令:</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="921a" class="ld ir hi kz b fi le lf l lg lh">gcc helloworld.c -o helloworld.out</span></pre><p id="851a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在这种情况下，<a class="ae kx" href="https://man7.org/linux/man-pages/man1/file.1.html" rel="noopener ugc nofollow" target="_blank">文件</a>命令的输出将是:</p><pre class="ks kt ku kv fd ky kz la lb aw lc bi"><span id="a110" class="ld ir hi kz b fi le lf l lg lh">file helloworld.out </span><span id="091a" class="ld ir hi kz b fi li lf l lg lh">#OUTPUT <br/>a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=c5cc275bf56a938597e5a05fc410eaa9e519f422, for GNU/Linux 3.2.0, not stripped</span></pre><p id="3246" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">所以最终我们获得了我们的可执行文件，也许我们更好地理解了整个过程。</p><p id="f863" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我希望您喜欢这篇文章的内容，在这种情况下，我邀请您阅读关于<a class="ae kx" href="https://www.stackzero.net" rel="noopener ugc nofollow" target="_blank"> Stackzero </a>的其他文章，并随时提出任何问题或建议任何改进。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="4e84" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="kw">原载于2022年6月1日https://www.stackzero.net</em><a class="ae kx" href="https://www.stackzero.net/compilation-process-in-c/" rel="noopener ugc nofollow" target="_blank"><em class="kw"/></a><em class="kw">。</em></p></div></div>    
</body>
</html>