<html>
<head>
<title>Python Design Pattern — Part I: Creational Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python设计模式——第一部分:创造性设计模式</h1>
<blockquote>原文：<a href="https://medium.com/codex/python-design-pattern-part-i-creational-design-pattern-30f2e11aa099?source=collection_archive---------6-----------------------#2021-07-25">https://medium.com/codex/python-design-pattern-part-i-creational-design-pattern-30f2e11aa099?source=collection_archive---------6-----------------------#2021-07-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b227" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创造性设计模式提供了多样化的对象创建机制，这提高了现有代码的灵活性和重用性。</p><p id="5a46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated"><span class="l je jf jg bm jh ji jj jk jl di">如果</span>我们试图在软件工程的背景下定义设计模式，没有什么比<a class="ae jm" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank">维基百科</a>更能给出直截了当的定义了:</p><blockquote class="jn jo jp"><p id="80a1" class="if ig jq ih b ii ij ik il im in io ip jr ir is it js iv iw ix jt iz ja jb jc hb bi translated">在软件工程中，<strong class="ih hj">软件设计模式</strong>是一种通用的、可重用的解决方案，用于解决软件设计中给定环境下经常出现的问题。</p></blockquote><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/1bf095aa6d105bc18b30f32752dc40a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FmK5Zjvb2xyzULM26QPROg.jpeg"/></div></div></figure><p id="6974" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设计模式上下文中有三个主要类别:创建、结构和行为模式。创造性设计模式主要处理各种对象创建机制，这增加了现有代码的灵活性和重用性。结构模式解释了如何将对象和类组装成更大的结构，同时保持这些结构的灵活性和高效性。行为设计模式与算法和对象之间的责任分配有关。在这篇短文中，我们将通过Python中的一些例子向您展示创造性的设计模式。</p><p id="3c00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，创造性设计模式提供了各种对象创建机制，这提高了代码的灵活性，便于将来重用。这也促进了开发人员之间的交流，以便在高度动态的环境中更有效地协作。</p><p id="4fb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建设计模式主要由处理对象创建的五个有用组件组成:</p><ul class=""><li id="96e0" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">工厂方法</li><li id="fc84" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">抽象工厂</li><li id="0166" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">建设者</li><li id="d404" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">原型</li><li id="1027" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">一个</li></ul><p id="5f70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在接下来的文章中，我们将逐一介绍，并向您展示一些Python示例。</p><h1 id="4d79" class="ku kv hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">工厂方法</h1><p id="0e8c" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">工厂方法是一种创造性的设计模式，它为超类提供了调用和创建对象的接口，所创建的对象的类型可以由子类控制和确定。</p><h2 id="fc1d" class="lx kv hi bd kw ly lz ma la mb mc md le iq me mf li iu mg mh lm iy mi mj lq mk bi translated">问题</h2><p id="3b41" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">假设您有一个宠物管理应用程序。最初，你只有一个宠物类，叫做<em class="jq">狗。你的大部分代码都存在于<code class="du ml mm mn mo b">Dog</code>类中。后来想出了一个需要多加类比如<em class="jq">猫</em>的情况。将<code class="du ml mm mn mo b">Cat</code>添加到应用程序中需要对整个代码库进行修改。此外，如果增加更多的类别，这个问题将会恶化。</em></p><h2 id="2b7d" class="lx kv hi bd kw ly lz ma la mb mc md le iq me mf li iu mg mh lm iy mi mj lq mk bi translated">解决办法</h2><p id="9eaf" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">工厂方法允许您从另一个对象创建一个对象。它是构造调用(使用new操作符),调用一个特殊的<em class="jq">工厂</em>方法。请注意，为了使用工厂方法，最好是所有要调用的类共享相同的方法和属性。</p><h2 id="7a95" class="lx kv hi bd kw ly lz ma la mb mc md le iq me mf li iu mg mh lm iy mi mj lq mk bi translated">Python示例代码</h2><p id="f452" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">这是工厂方法的Python示例。如你所见，我们有两个不同的类，<code class="du ml mm mn mo b">dog</code>和<code class="du ml mm mn mo b">cat </code>。两个类可以从<code class="du ml mm mn mo b">get_pet</code>工厂类中调用。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h1 id="9dfa" class="ku kv hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">抽象工厂</h1><p id="d947" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">抽象工厂允许您创建一系列相关对象，而无需指定具体的类。换句话说，你可以通过一个接口调用类的家族。当你想创建一堆相关的操作时，也可以使用它。</p><h2 id="a8cc" class="lx kv hi bd kw ly lz ma la mb mc md le iq me mf li iu mg mh lm iy mi mj lq mk bi translated">问题</h2><p id="cde4" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">假设您想创建一个宠物店，里面有宠物的名字、食物和声音。您需要一种方法来创建单独的家具对象，以便它们与同一族的其他对象相匹配。</p><h2 id="b001" class="lx kv hi bd kw ly lz ma la mb mc md le iq me mf li iu mg mh lm iy mi mj lq mk bi translated">解决办法</h2><p id="b0b2" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">你可以通过一个超类抽象工厂来创建和调用所有这些类。您实际上是单独创建相关的类，并通过一个公共接口调用它们。</p><h2 id="fc11" class="lx kv hi bd kw ly lz ma la mb mc md le iq me mf li iu mg mh lm iy mi mj lq mk bi translated">Python示例代码</h2><p id="e594" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">下面是使用抽象工厂创建两个类的Python片段。通过<code class="du ml mm mn mo b">petfactory</code>类我们创建了创建宠物对象的接口。接下来，我们使用<code class="du ml mm mn mo b">petStore</code>来访问物体的名称、食物和声音。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h1 id="7ea5" class="ku kv hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">建设者</h1><p id="ba26" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">生成器作为一种创造性的设计模式，让您一步一步地构建一个复杂的系统。该模式允许您构造不同的对象，每个对象都来自已经构建的组件的子集。</p><h2 id="fa70" class="lx kv hi bd kw ly lz ma la mb mc md le iq me mf li iu mg mh lm iy mi mj lq mk bi translated">问题</h2><p id="7364" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">想象一个复杂的对象，它需要费力地逐步初始化许多字段和嵌套对象。为了用任何一组可用组件构造任何单个对象，您需要编写许多类，每个类对应于一个特定的集合。</p><h2 id="14b1" class="lx kv hi bd kw ly lz ma la mb mc md le iq me mf li iu mg mh lm iy mi mj lq mk bi translated">解决办法</h2><p id="edc4" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">解决方案是，您可以将组装任务卸载到一个名为builder的单独类中。建造者的责任是组装通常由<em class="jq">主管规定的所需步骤。</em>然而，director的存在并不是必须的，但会提高可读性和模块化。</p><h2 id="74f5" class="lx kv hi bd kw ly lz ma la mb mc md le iq me mf li iu mg mh lm iy mi mj lq mk bi translated">Python示例</h2><p id="7040" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">这里，我们想创建两辆具有不同选项的汽车:一辆带喇叭，另一辆不带喇叭。我们通过从超类<code class="du ml mm mn mo b">builder</code>继承的<code class="du ml mm mn mo b">engine_builder </code>类添加选项。<code class="du ml mm mn mo b">engine_builder</code>包括由<code class="du ml mm mn mo b">builder</code>指定的所有选项结构。该控制器包括两种方法，分别对应于两个不同的选项。指导者指定步骤，构建者构建对象。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h1 id="4396" class="ku kv hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">原型</h1><p id="e546" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">Prototype是一种创造性的设计模式，它允许您复制现有的对象，而无需让您的代码依赖于它们的类。</p><h2 id="b9fc" class="lx kv hi bd kw ly lz ma la mb mc md le iq me mf li iu mg mh lm iy mi mj lq mk bi translated">问题</h2><p id="c5e5" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">假设你有一个对象，你想创建它的精确副本。你会怎么做？首先，您必须创建一个相同类的新对象。然后，您必须遍历原始对象的所有字段，并将它们的值复制到新对象<a class="ae jm" href="https://refactoring.guru/design-patterns/prototype" rel="noopener ugc nofollow" target="_blank">【1】</a>。这种方法有一个缺点。并非所有的属性和方法都可以在对象外部看到，并且可能是私有的。</p><h2 id="52d1" class="lx kv hi bd kw ly lz ma la mb mc md le iq me mf li iu mg mh lm iy mi mj lq mk bi translated">解决办法</h2><p id="33a3" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">原型模式将克隆过程委托给被克隆的实际对象。该模式为所有支持克隆的对象声明了一个公共接口。通常用<code class="du ml mm mn mo b">clone</code>法识别。</p><h2 id="8ad7" class="lx kv hi bd kw ly lz ma la mb mc md le iq me mf li iu mg mh lm iy mi mj lq mk bi translated">Python示例</h2><p id="def3" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">在这里，我们想要从另一个创建的汽车中克隆一个汽车对象。为此，我们将首先注册该类，然后使用<code class="du ml mm mn mo b">clone</code>方法将其克隆到另一个不同名称的对象中。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="mp mq l"/></div></figure><h1 id="bea5" class="ku kv hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">一个</h1><p id="b877" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">Singleton允许确保一个类只有一个实例化，并且是全局可访问的。</p><h2 id="b903" class="lx kv hi bd kw ly lz ma la mb mc md le iq me mf li iu mg mh lm iy mi mj lq mk bi translated">问题</h2><p id="5625" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">单例设计模式旨在解决两个常见问题。一是我们要确保一个给定的类只有一个实例。我们为什么关心？在一些应用程序中，我们有一个共享文件，比如在不同类之间共享的数据库。我们希望确保每个类都有相同的数据库副本。singleton试图解决的第二个问题是全局访问，这使得一个类可以被程序中任何地方的任何类访问。</p><h2 id="1995" class="lx kv hi bd kw ly lz ma la mb mc md le iq me mf li iu mg mh lm iy mi mj lq mk bi translated">Python示例</h2><p id="7038" class="pw-post-body-paragraph if ig hi ih b ii ls ik il im lt io ip iq lu is it iu lv iw ix iy lw ja jb jc hb bi translated">在这里，我们有一本词典，我们希望在某个时候能对它进行编辑。我们首先看到，文件包含了<code class="du ml mm mn mo b">John="Paid</code>，然后又添加了另一个元素。现在，内容改为{ '约翰':'付费'，'露西':'未付费' }。</p></div><div class="ab cl mr ms gp mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hb hc hd he hf"><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="mp mq l"/></div></figure><p id="976e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">文章到此结束:)</p><p id="530c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考</p><p id="2891" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[1]<a class="ae jm" href="https://refactoring.guru/design-patterns/prototype" rel="noopener ugc nofollow" target="_blank">https://refactoring.guru/design-patterns/prototype</a></p></div></div>    
</body>
</html>