<html>
<head>
<title>Top Java Performance Tuning Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java性能调优技巧</h1>
<blockquote>原文：<a href="https://medium.com/codex/top-java-performance-tuning-tips-3f4458c02ce0?source=collection_archive---------1-----------------------#2022-05-03">https://medium.com/codex/top-java-performance-tuning-tips-3f4458c02ce0?source=collection_archive---------1-----------------------#2022-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/b577c84d15a2191e5b770e9b4f034b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iDcgo5lnKYj7s8Ob_527yw.png"/></div></div></figure><div class=""/><h1 id="282c" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">简介:</strong></h1><p id="fb51" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">迄今为止，世界上最流行的编程语言之一是Java，它于1995年5月首次发布。开发人员通常使用Java来开发基于web的应用程序。对于许多开发人员来说，构建这些应用程序很容易，但是通过使用最少的资源来提供最佳用户体验和高性能的应用程序却很难构建。这是一个常见的误解，我们必须成为优化应用程序的专家，但事实并非如此。虽然这需要一些知识和经验，但是使用各种最佳实践，您可以轻松地优化您的java应用程序。</p><h1 id="02a3" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">什么是Java性能调优？</strong></h1><p id="741c" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当Java应用程序运行时，它会使用大量资源(包括内存、网络带宽、CPU周期数或二者的组合),因此，为了提高应用程序的性能，应该尽量减少它使用的资源数量，这就是所谓的Java性能调优。这些调优实践可以帮助您防止许多与Java应用程序相关的常见问题，例如</p><ul class=""><li id="e08e" class="km kn ht jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><strong class="jq hu">应用程序性能缓慢:</strong> <br/>有时我们的应用程序加载时间过长，这是因为我们的应用程序没有处理所需的进程，而是花费大量时间清理垃圾，导致性能低下。</li><li id="689e" class="km kn ht jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hu">内存过度消耗:</strong> <br/>在Java虚拟机中，内存消耗取决于应用程序中当前运行的活动对象的数量。这通常是由于内存泄漏造成的，在内存泄漏中，垃圾收集器不会删除堆中存在的未使用的对象，从而导致应用程序的性能下降。</li></ul><p id="a9a2" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">在本文中，我们将介绍10个技巧，您可以遵循这些技巧来优化您的Java应用程序并提供最佳的用户体验。这些技巧中有些是特定于语言的，而有些是独立于语言的，可以用于任何编程语言。</p><h2 id="7639" class="lf ir ht bd is lg lh li iw lj lk ll ja jz lm ln je kd lo lp ji kh lq lr jm ls bi translated"><strong class="ak"> 1)使用分析器</strong></h2><p id="01a2" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在性能调优过程中，第一步是使用分析器。使用分析器来确定代码的低效部分是非常重要的。手动执行该过程可能会导致微不足道的性能提升。这是因为开发人员认为没有效率的代码部分实际上可能并不是没有效率的部分。此外，开发人员无法确定该代码元素需要多长时间才能完全执行。</p><p id="f22a" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">分析器有助于检查字节码的每一部分，并告诉我们执行应用程序需要多少时间。它为我们提供了不同的工具，允许我们更好地理解代码的性能，并允许我们关注最关键的部分。</p><p id="2a7d" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">一些最流行的分析器是NetBeans Profiler和Java VisualVM。这些分析器可以在不同的操作系统上轻松工作。</p><h2 id="912d" class="lf ir ht bd is lg lh li iw lj lk ll ja jz lm ln je kd lo lp ji kh lq lr jm ls bi translated"><strong class="ak"> 2)少写代码</strong></h2><p id="4134" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们都编写程序，为了增加可读性，我们倾向于编写越来越多的代码，即使代码可以减少。此外，有些人仍然根据开发人员编写的代码的长度来评估他们，因此删除不必要的代码这些代码并不被视为有所贡献。但是这样做的缺点是程序需要更多的时间来执行，从而降低了应用程序的性能。有些人认为编写长代码不会影响性能，但实际上，与较长的代码相比，删减后的代码执行起来花费的时间更少。</p><p id="da04" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">随着需要编译的代码量的增加，编译器需要花费更多的时间来执行它。当越来越多的对象要从内存中推入和弹出时，垃圾收集器所做的工作会增加，垃圾收集器周期会花费更长的时间。如果有更多的类需要加载到Java虚拟机中，程序将需要更长的时间才能启动。执行更多的代码也会降低它容纳硬件缓存的可能性。</p><p id="115e" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">没有必要避免编写越来越多的代码。如果你想添加额外的功能，那么肯定你应该添加更多的代码。保持平衡将提供最好的用户体验。</p><h2 id="82ec" class="lf ir ht bd is lg lh li iw lj lk ll ja jz lm ln je kd lo lp ji kh lq lr jm ls bi translated"><strong class="ak"> 3)过早优化</strong></h2><p id="638e" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">过早优化是指程序员在他们并不真正需要的东西上浪费大量时间。它是编程中面临的大多数问题的根源。为了提高性能，程序员花费大量时间在错误的方向上工作，结果导致性能下降。随着程序员在不必要的事情上花费越来越多的时间，对性能的整体影响可以忽略不计。每当你在两种代码中进行选择时，你总是选择简短、清晰和容易理解的那一种。</p><p id="02cf" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated"><em class="lt">论证代码是否应该优化的最有效方法是什么？</em></p><p id="abe0" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">首先，我们应该为应用程序代码指定时间，例如，我们可以为我们希望在特定时间内包含的记录数量设置一个特定的数量。</p><p id="5cf6" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">因此，您可以很容易地识别出应用程序中导致性能下降的元素，最后您可以使用我们之前讨论过的分析器。</p><h2 id="0b3e" class="lf ir ht bd is lg lh li iw lj lk ll ja jz lm ln je kd lo lp ji kh lq lr jm ls bi translated">4)编写高效的算法</h2><p id="a92d" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">性能受到Java中大量细节以及许多调优标志的影响。编写更好的算法也是Java性能调优最重要的方面之一。写得好的算法起着重要的作用，因为好的算法可以提高应用程序的性能，而写得不好的算法会导致性能下降。</p><p id="6a77" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">Java虚拟机可以优化数组边界检查，这有助于循环更快地遍历数组的每个元素，并且如果循环依次遍历每个元素，它可以展开循环操作以提供额外的速度。然而，如果循环被设计为搜索数组中的特定元素，那么任何优化都不会起作用。相反，散列表将用于提高效率。</p><p id="5cbf" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">因此，当我们想要高性能时，拥有一个好的算法是至关重要的。</p><h2 id="6d58" class="lf ir ht bd is lg lh li iw lj lk ll ja jz lm ln je kd lo lp ji kh lq lr jm ls bi translated"><strong class="ak"> 5) Java堆</strong></h2><p id="bb28" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了让Java有效地处理内存需求，它严重依赖于它的内存堆。堆的第一次分配应该总是很小，然后可以逐渐增加。通常，在优化问题的过程中所面临的问题是通过扩大堆的大小来处理的，这在垃圾收集开销很大的情况下是行不通的。</p><p id="22ef" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">此外，垃圾收集成本会显著降低吞吐量，从而导致性能下降。此外，我们可以通过尽早调优垃圾收集器来避免堆的大小分配问题。根据我们的需要，我们可以选择从1gb到8gb的堆大小。</p><p id="fb54" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">一般来说，Java堆空间应该扩展到服务器总随机存取内存的1/2。扩展空间超过这个范围可能会导致性能问题。</p><h2 id="6d8b" class="lf ir ht bd is lg lh li iw lj lk ll ja jz lm ln je kd lo lp ji kh lq lr jm ls bi translated"><strong class="ak"> 6)调优垃圾收集</strong></h2><p id="d705" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">由于垃圾收集过程非常复杂，所以很难确定我们程序的实际性能。但是处理垃圾收集器对于优化是很重要的，因此分析和更改垃圾收集器设置应该同时执行。</p><p id="6ea0" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">随着你对结果的满意，你将能够转移到另一种形式的优化。确认您也在关注异常值以及事务所用的平均时间。异常值不容易定位，并且是性能下降的主要原因。</p><p id="fb93" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">此外，了解程序运行时性能下降的后果是至关重要的。运行时会出现速度下降，如果每隔几天出现一次，可以忽略不计，但如果频繁出现，就不能忽略。为工作负载选择最佳优化路径，并适当地调优程序。</p><h2 id="cab8" class="lf ir ht bd is lg lh li iw lj lk ll ja jz lm ln je kd lo lp ji kh lq lr jm ls bi translated"><strong class="ak"> 7)在一个语句中连接字符串时，避免使用+运算符</strong></h2><p id="f6ba" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">将字符串组合成一个新的字符串被称为字符串连接，Java包含了大量的字符串连接方式。连接两个字符串最简单的方法是使用+运算符。</p><p id="400c" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated"><strong class="jq hu">例如:</strong></p><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="6ee6" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">你可以在<a class="ae ma" href="https://www.interviewbit.com/online-java-compiler/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hu"> Interviewbit </strong> </a>上试用这个代码。</p><p id="152d" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">您一定听说过使用+运算符不是字符串连接的最佳实践。在程序逻辑中，当您连接字符串时，这是准确的。字符串是不可变的，在我们的例子中，我们创建了一个对象s，其中存储了两个字符串的连接。为此，需要额外的内存，这会导致性能下降。因此，在这种情况下应该调用StringBuilder方法，我们将在下一点讨论这一点。</p><h2 id="a78c" class="lf ir ht bd is lg lh li iw lj lk ll ja jz lm ln je kd lo lp ji kh lq lr jm ls bi translated"><strong class="ak"> 8)使用原语而不是对象</strong></h2><p id="6cf1" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">提高应用程序性能的一个简单而有效的方法是使用原语而不是对象。我们知道原语存在于堆栈中，而对象存储在Java的堆内存中。与访问原语相比，从堆中访问对象是一个较慢的过程。因此应该使用原语而不是包装类。</p><p id="e4ee" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">例如，您应该使用boolean而不是使用Boolean。</p><p id="a8d8" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">性能会受到很大的影响，因为如果不正确地使用包装类，Java中可能会出现NullPointerException，并且会占用更多的内存。</p><h2 id="348e" class="lf ir ht bd is lg lh li iw lj lk ll ja jz lm ln je kd lo lp ji kh lq lr jm ls bi translated"><strong class="ak"> 9)访问集合需要尽可能少的方法调用</strong></h2><p id="59e2" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在许多情况下，程序员试图访问HashMap或HashTable中键的值。</p><p id="88b7" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">例如，检查下面的代码:</p><figure class="lu lv lw lx fd hk er es paragraph-image"><div class="er es mb"><img src="../Images/4b1e1ec221cc22bec6d47cc9b4996897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*_SNbCsi-A5O7_I1MCI_HdA.png"/></div></figure><p id="c7d0" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">从代码中可以看出，首先检查索引，然后访问索引中的值。上面的程序使用了2个调用。现在来看看一个更优化的程序写下来:</p><figure class="lu lv lw lx fd hk er es paragraph-image"><div class="er es mc"><img src="../Images/9bcd86cece8509adeffe0b9288138b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*QdQ2nfjX3OrJ4UAc0wyvOw.png"/></div></figure><p id="4713" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">使用这种方法，每次执行循环时，方法调用减少1。因此，如果我们访问该值的次数非常多，那么就会减少大量的方法调用，从而提高性能。</p><h2 id="adeb" class="lf ir ht bd is lg lh li iw lj lk ll ja jz lm ln je kd lo lp ji kh lq lr jm ls bi translated"><strong class="ak"> 10)使用同步时要小心</strong></h2><p id="32a6" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">与C++不同，在Java中可以非常容易地执行同步。在没有预先了解同步对性能的影响的情况下，许多程序员使用同步。不恰当地使用同步会因线程阻塞而严重影响性能。</p><p id="33ab" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">Java开发人员经常犯同步静态变量的错误。变量可以在存储字符串的类中声明:</p><figure class="lu lv lw lx fd hk er es paragraph-image"><div class="er es md"><img src="../Images/ea2e3506bdd51aaec3378b7f87a28558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*ijhnKu842TV_B3PEFhtSBQ.png"/></div></figure><p id="a22d" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">现在假设在不同的类中声明了一个不同名称的变量</p><figure class="lu lv lw lx fd hk er es paragraph-image"><div class="er es me"><img src="../Images/0fa49a060adf63d5ae6c1faac35ff166.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*JgZEORZhpD2YWVCMrCHz8Q.png"/></div></figure><p id="428e" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">你可能认为这两者不能互相干扰，但事实并非如此，因为S1和S2指向同一个字符串，即“pointed_by_same”。</p><p id="01d3" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">因此为了避免干扰，字符串应该这样声明:</p><figure class="lu lv lw lx fd hk er es paragraph-image"><div class="er es mf"><img src="../Images/ff4d089c9f8267330545e63c5d76f21c.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*qK9oGkMqt_PngKA-Y07AqQ.png"/></div></figure><p id="0d7b" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">为了优化应用程序的性能，同步块应该包含最少的处理。</p><h1 id="7c57" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">结论:</strong></h1><p id="89fd" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">以上是一些简单的Java性能调优技巧。很多时候，程序员会跳过优化部分，如果数据很大，这会严重影响应用程序的性能。正如您所看到的，这些优化一点也不难应用，只需要最少的努力。通过这些优化，您将看到应用程序的性能显著提高，从而提供更好的用户体验。</p><p id="1384" class="pw-post-body-paragraph jo jp ht jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">因此，您应该关注应用程序中可以优化性能的关键领域，因为解决正确的领域应该不需要太多的努力。</p></div></div>    
</body>
</html>