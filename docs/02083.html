<html>
<head>
<title>How Rust Prevents Data Races</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust如何防止数据竞争</h1>
<blockquote>原文：<a href="https://medium.com/codex/eda-needs-to-be-using-rust-pt-2-59d2263ebb03?source=collection_archive---------1-----------------------#2021-06-29">https://medium.com/codex/eda-needs-to-be-using-rust-pt-2-59d2263ebb03?source=collection_archive---------1-----------------------#2021-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a7ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">TL；dr: </strong> Rust的内存管理模型在本系列的<a class="ae jd" href="https://jasonmccampbell.medium.com/eda-needs-to-be-using-rust-a6a09911da74" rel="noopener">第1部分</a>中讨论过，它很好地扩展了，在使用共享内存并发时提供了类似的数据竞争保护。这篇文章着眼于两个具体的例子，说明编译器如何在编译时防止难以重现且耗时的错误<em class="je">。</em></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/ec3fd82bde1733935b9438c8fa4e0ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mbR_t72qjhx8O_6i"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx translated">管理相互作用的线程可能很难或者不可能进行推理。静态分析可以解决许多共享数据交互不可避免的问题。照片由<a class="ae jd" href="https://unsplash.com/@nima__shabani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尼玛·沙巴尼</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="426d" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">唯一好的共享数据是不可变的共享数据</h1><p id="4019" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">EDA ( <a class="ae jd" href="https://en.wikipedia.org/wiki/Electronic_design_automation" rel="noopener ugc nofollow" target="_blank">电子设计自动化</a>)工具是一类技术计算应用，通常专注于半导体和电子系统的设计和验证。正如本系列第1部分<a class="ae jd" href="https://jasonmccampbell.medium.com/eda-needs-to-be-using-rust-a6a09911da74" rel="noopener">中所讨论的，运行时通常是这些计算密集型工具的竞争优势。能够最大限度提高硬件性能的高效算法是必需的，随着服务器级处理器配备</a><a class="ae jd" href="https://www.amd.com/en/processors/ryzen" rel="noopener ugc nofollow" target="_blank"> 16 </a>、<a class="ae jd" href="https://ark.intel.com/content/www/us/en/ark/products/series/93797/intel-xeon-processor-e7-v4-family.html" rel="noopener ugc nofollow" target="_blank"> 20 </a>或每个设备更多的内核，这意味着并行算法。</p><p id="ad72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在理想情况下，单线程进程通过传输数据进行通信，而不共享数据。在现实世界中，当一个8字节的指针可以传递给另一个线程时，在进程之间复制GB和TB的数据通常是不切实际的。</p><p id="7521" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，共享内存并行性很难获得并保持正确。对共享数据的所有访问都必须受到保护，并且在任何情况下都要使用保护措施。不会错过对共享数据的访问，甚至是对一个无害的、不可重入的函数的隐藏调用，该函数原本是打算供单线程使用的。</p><p id="e2d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Rust语言的明确设计目标之一是实现安全高效的并发编程，以至于社区已经采纳了“无畏并发”的口号。这篇文章将深入探讨Rust独特的所有权模型如何不仅确保内存安全，甚至跨线程，而且在编译时检测和防止数据竞争<em class="je">。</em></p><h1 id="284a" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">静态消除数据竞争</h1><p id="8875" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">前一篇文章这样总结了Rust的所有权规则:</p><ol class=""><li id="7077" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated">每个值都有一个所有者(例如，变量、结构字段)，当所有者超出范围时，该值被释放(丢弃);</li><li id="7341" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><strong class="ih hj">一个值最多只能有一个可变引用；或者</strong></li><li id="4118" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><strong class="ih hj">对于一个值可能有任意数量的不可变引用，并且当它们存在时，该值可能不会被改变；</strong></li><li id="1162" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated">所有引用的生存期必须不长于被引用的值。</li></ol><p id="9747" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">规则2和3与那些用于<a class="ae jd" href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock" rel="noopener ugc nofollow" target="_blank">读者-写者锁</a>的规则相同:允许多个读者(不可变引用)或单个写者(可变引用)访问。再加上内存管理的值和引用的生命周期分析，编译器现在有了静态检测潜在数据竞争的基础。</p><p id="ed9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更好地理解这一点，让我们看一个简单的C++例子:</p><pre class="jg jh ji jj fd lm ln lo lp aw lq bi"><span id="da37" class="lr jw hi ln b fi ls lt l lu lv">int main() {<br/>  std::string msg = "Hello";</span><span id="acce" class="lr jw hi ln b fi lw lt l lu lv">  std::thread t1([&amp;](){ <br/>    std::cout &lt;&lt; msg &lt;&lt; std::endl;<br/>  });<br/>  msg += ", world!";<br/>  t1.join();<br/>  return 0;<br/>}</span></pre><p id="c25d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个例子产生了一个线程来打印<code class="du lx ly lz ln b">msg</code>的内容，而主线程继续改变这个消息。打印出什么结果？在我使用g++ 10.2的笔记本电脑上，我得到“你好，世界！”。稍加改动，结果改成了“你好”。如果我真的(不)幸运，如果访问重叠，我甚至可能会看到数据损坏问题。</p><p id="f1e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是Rust中的同一个例子:</p><pre class="jg jh ji jj fd lm ln lo lp aw lq bi"><span id="ef96" class="lr jw hi ln b fi ls lt l lu lv">fn main() {<br/>  let mut msg = "Hello".to_string();</span><span id="d9c9" class="lr jw hi ln b fi lw lt l lu lv">  let handle = thread::spawn(|| {<br/>    println!("{}", &amp;msg);<br/>  });<br/>  msg.push_str(", world!");<br/>  handle.join().unwrap();<br/>}</span></pre><div class="ma mb ez fb mc md"><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=6f1e483ead2741a1da8457edbe2b1e78" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">Rust Playground —运行此示例查看完整的编译器输出</h2></div></div></a></div><p id="cb05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编译器会产生两个错误，本例中最重要的一个错误是:</p><pre class="jg jh ji jj fd lm ln lo lp aw lq bi"><span id="b2cb" class="lr jw hi ln b fi ls lt l lu lv">error<a class="ae jd" href="https://doc.rust-lang.org/stable/error-index.html#E0502" rel="noopener ugc nofollow" target="_blank">[E0502]</a>: cannot borrow `msg` as mutable because it is also borrowed as immutable<br/> <a class="ae jd" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=6f1e483ead2741a1da8457edbe2b1e78#" rel="noopener ugc nofollow" target="_blank">--&gt; src/main.rs:9:5</a></span></pre><p id="15a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">传递给<code class="du lx ly lz ln b">thread::spawn</code>的闭包隐式地创建了对<code class="du lx ly lz ln b">msg</code>的不可变引用。然而，<code class="du lx ly lz ln b">msg</code>之后也可变地使用，违反了禁止同时拥有可变和不可变的值引用的禁令。编译器已经捕捉到了数据竞争。将<code class="du lx ly lz ln b">push_str</code>命令移到对<code class="du lx ly lz ln b">thread::spawn</code>的调用之上是这个问题的一个潜在解决方案，因为在创建线程时不再需要可变引用。</p><p id="5ac4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">报告的第二个错误是<code class="du lx ly lz ln b">msg</code>可能活得不够长，因为它是堆栈分配的，将在<code class="du lx ly lz ln b">main</code>结束时被释放。尽管该示例确实加入了线程，但为了避免这个问题，编译器并不分析派生的线程会对该值做什么。</p><p id="2a69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终的、正确的版本修改了<code class="du lx ly lz ln b">msg</code>的值，然后<em class="je">将</em>移动到衍生的线程，保证它在需要的时候保持有效。编译器还保证主线程不再访问该值—它已经被移动了。因此，编译器还防止了释放后使用错误的可能性，即派生的线程释放字符串内存，而原始线程有一个对它的悬空引用。</p><div class="ma mb ez fb mc md"><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ff95280ae1160d243e30749ad4ad683d" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">Rust Playground —最终工作版本</h2></div></div></a></div><p id="2cb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个例子展示了编译器如何通过防止两个线程访问同一个值来检测和防止数据竞争，从而帮助实现传输数据而不是共享数据的理想情况。但是当需要共享和修改来自不同线程的数据时呢？下一个例子探索了如何利用Rust的所有权模型来保证同步数据被正确访问，并防止意外的(或有意的？)绕过同步的引用泄漏。</p><h1 id="4fed" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">安全地共享可变数据</h1><p id="d028" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">共享可变数据需要某种方法来获得对数据的独占访问，以防止在一个或多个读取器处于活动状态时被修改。通常这是通过互斥锁来完成的。</p><p id="b066" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在C++中，一个常见的模式是使用<a class="ae jd" href="https://en.cppreference.com/w/cpp/language/raii" rel="noopener ugc nofollow" target="_blank"> RAII </a>来获取锁，并保证锁在一个块结束时被释放。一个典型的例子是这样的:</p><pre class="jg jh ji jj fd lm ln lo lp aw lq bi"><span id="958d" class="lr jw hi ln b fi ls lt l lu lv">void MyClass::method() {<br/>  Lock lck(mut);    // Acquire lock on mutex 'mut'<br/>  ... use the synchronized data ...<br/>}</span></pre><p id="3396" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种模式的优点是，它保证锁在块的末尾被<code class="du lx ly lz ln b">Lock</code>析构函数释放，即使同步的代码中出现异常。不幸的是，这种模式没有明确告诉我们<code class="du lx ly lz ln b">MyClass</code>的哪些成员需要同步，也没有阻止代码在没有持有锁的情况下访问同步的数据。</p><p id="c9ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Rust利用值的单一所有权规则来消除这两个缺点。具体来说，互斥体<em class="je">拥有</em>的值，所以所有的访问都必须通过它，并且不存在给定的数据元素是否需要同步的问题。此外，对数据的引用不能存在超过锁的生存期。怎么会？</p><p id="2c08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看一个例子，看看到底发生了什么。</p><pre class="jg jh ji jj fd lm ln lo lp aw lq bi"><span id="c638" class="lr jw hi ln b fi ls lt l lu lv">fn main() {<br/>    let str = "Hello".to_string();<br/>    let sref = &amp;str;  // Attempt to cheat!<br/>    <br/>    // Atomic ref count (Arc) owns mutex, which owns the string<br/>    let rc = Arc::new(Mutex::new(str));<br/>    <br/>    let rc_to_thread = Arc::clone(&amp;rc);<br/>    let h = thread::spawn(move || {<br/>        let mut thread_str = rc_to_thread.lock().unwrap();<br/>        (*thread_str).push_str(", world!");<br/>    });</span><span id="d08a" class="lr jw hi ln b fi lw lt l lu lv">    h.join().unwrap();<br/>    println!("m = {:?}", sref);<br/>}</span></pre><div class="ma mb ez fb mc md"><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=390e3cb99ee28142767befd3d61f37fb" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">Rust Playground —在此运行示例</h2></div></div></a></div><p id="be24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与前面的示例类似，创建了字符串<code class="du lx ly lz ln b">Hello,</code>,字符串的其余部分将被追加。然而，在这种情况下，派生线程将执行追加，主线程将写出结果。一旦字符串被创建，它就被移动到一个<code class="du lx ly lz ln b"><a class="ae jd" href="https://doc.rust-lang.org/std/sync/struct.Mutex.html" rel="noopener ugc nofollow" target="_blank">Mutex</a></code> <a class="ae jd" href="https://doc.rust-lang.org/std/sync/struct.Mutex.html" rel="noopener ugc nofollow" target="_blank">实例</a>中(由该实例拥有)，并且互斥体由一个Arc ( <a class="ae jd" href="https://doc.rust-lang.org/std/sync/struct.Arc.html" rel="noopener ugc nofollow" target="_blank">原子引用计数</a>)值拥有。</p><p id="4b2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，在Rust中，每个值必须只有一个所有者。Arc是互斥体和字符串的唯一所有者，但它是特殊的:实际的“所有者”是一个堆分配的、原子引用计数的容器，这里的<code class="du lx ly lz ln b">rc</code>值是一个指向该容器的智能指针。下面一行:</p><pre class="jg jh ji jj fd lm ln lo lp aw lq bi"><span id="ea59" class="lr jw hi ln b fi ls lt l lu lv">let rc_to_thread = Arc::clone(&amp;rc);</span></pre><p id="c15c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">克隆智能指针，增加引用计数。因此<code class="du lx ly lz ln b">rc_to_thread</code>可以被移动到新线程——它将有一个新的所有者——但是两个Arc实例引用相同的值。(关于Arc和Mutex如何绕过Rust的规则的描述，请参见结尾的“附录:进入Arc和Mutex的不安全杂草”。)</p><p id="cf23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接收到<code class="du lx ly lz ln b">rc_to_thread</code>的第二个线程能够访问该字符串。我们已经成功地使该字符串在两个线程中可用，并且只要存在对它的任何引用，该字符串就将保持有效。然而，<code class="du lx ly lz ln b">Arc</code>没有任何同步行为，所以它只能返回不可变的引用，因此派生的线程不能向它追加内容。(Rust不允许在安全代码中使用C++的<code class="du lx ly lz ln b">const_cast</code>)。</p><p id="2d24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是<code class="du lx ly lz ln b">Mutex</code>发挥作用的地方:通过提供同步，<code class="du lx ly lz ln b">lock().unwrap()</code>调用能够返回一个对字符串的<em class="je">可变</em>引用。值<code class="du lx ly lz ln b">thread_str</code>是一个智能指针，它持有锁，直到该值被丢弃(超出范围)，并提供对字符串值的访问。</p><p id="c132" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是传递给线程的lambda函数:</p><pre class="jg jh ji jj fd lm ln lo lp aw lq bi"><span id="fcd5" class="lr jw hi ln b fi ls lt l lu lv">{<br/>  let mut thread_str = rc_to_thread.lock().unwrap();<br/>  (*thread_str).push_str(", world!");<br/>}</span></pre><p id="2861" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，这类似于C++锁定模式，因为<code class="du lx ly lz ln b">thread_str </code>持有锁，直到作用域结束。最大的区别是<code class="du lx ly lz ln b">thread_str</code>是一个智能指针，它既持有锁<em class="je">又在解引用时提供对包含值的访问。</em></p><p id="1ce3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么这种差异很重要？考虑一个稍微复杂一点的试图作弊的lambda函数:</p><pre class="jg jh ji jj fd lm ln lo lp aw lq bi"><span id="6dac" class="lr jw hi ln b fi ls lt l lu lv">{<br/>  let str_ref : &amp;String;<br/>  if true {<br/>    let mut thread_str = rc_to_thread.lock().unwrap();<br/>    (*thread_str).push_str(", world!");<br/>    str_ref = &amp;(*thread_str);  // Save a reference outside the lock<br/>  }<br/>  ...<br/>}</span></pre><p id="ea55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的代码试图在锁之外保存对同步数据的引用。然而，规则4阻止了这种尝试:引用不能比它们所引用的值更长久。<code class="du lx ly lz ln b">str_ref</code>比锁的持有者<code class="du lx ly lz ln b">thread_str</code>活得长，因此被阻止。</p><p id="a3a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终的工作版本避免了任何绕过锁定机制的尝试，而是在打印时通过<code class="du lx ly lz ln b">rc</code>锁定值。完整的代码可以在下面的链接中看到和实验。</p><div class="ma mb ez fb mc md"><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9f06761438f62d33b8d5e3393736d2ef" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">Rust Playground —在此运行最终版本</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">尝试注入编译器检测不到的数据竞争！</h3></div></div></div></a></div><h1 id="cd44" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">摘要</h1><p id="2723" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">在我职业生涯的某个阶段，我是构建跨平台、基于Python的GUI团队的一员。我们被一个只在Mac OS上出现的罕见的内存损坏问题所困扰。随着GUI的稳定，它变得越来越紧迫，因为虽然不频繁，但它不是我们会附带的东西，而且它抵制调试。阿桑什么也没透露。</p><p id="6ba7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在专注了一两天却一无所获之后，一天早上醒来，我意识到这不是内存分配问题，而是时间问题。应用程序本身是单线程的，但是底层GUI库确实使用了线程。花一个小时审查与堆栈跟踪远程相关的任何代码，发现绑定库中指针的使用不同步。</p><p id="08fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像这样的错误很容易犯，但是很难重现，因此很难发现和纠正。在这种情况下，我们轻而易举地花了一周，也许更长时间，开发人员的宝贵时间试图找到问题。这正是现在可以在编译时<em class="je"/>捕捉并消除的那种问题。</p><p id="4d73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这里的例子已经提供了足够的细节，并且没有被工具淹没，让我们了解Rust是如何工作的，并且能够防止这样的错误。如果你有兴趣阅读更多内容，可以考虑Mozilla的“<a class="ae jd" href="https://blog.rust-lang.org/2017/11/14/Fearless-Concurrency-In-Firefox-Quantum.html" rel="noopener ugc nofollow" target="_blank">无畏并发</a>”帖子，该帖子讲述了他们在两次失败的尝试后成功并行化Firefox中的CSS渲染器，或者“Rust Book”关于并发的章节以了解更多细节。</p><p id="c4b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本系列的前两篇文章关注的是非常量化的好处:内存和并发安全性。在最后一篇文章中，我将改变思路，专注于我认为有可能通过增加开源和公司专有代码的重用来显著提高开发人员生产力的内容。</p><h1 id="2e2e" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">附录:进入弧和互斥的不安全杂草</h1><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es ml"><img src="../Images/75a303338cbe86c39db1678c08135f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SZVkVoYwgMnHinzr"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx translated">unsafe关键字允许代码在需要时跳出正常的安全界限。<a class="ae jd" href="https://unsplash.com/@jacksloop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">千斤顶单桅帆船</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="6a15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lx ly lz ln b">Arc</code>和<code class="du lx ly lz ln b">Mutex</code>类型似乎都违反了Rust编译器的规则:Arc允许一个值有多个所有者，Mutex可以从一个不可变的引用生成一个可变的引用，类似于C++中的<code class="du lx ly lz ln b">const_cast</code>。这两个例子都很好地说明了Rust的<code class="du lx ly lz ln b">unsafe</code>关键字如何被用来实现安全抽象的原语。让我们看看它们是如何工作的。</p><p id="e9e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调用<code class="du lx ly lz ln b">Arc::new</code>会创建智能指针引用容器，以及一个单独分配的内存块，用于保存引用计数和值。分配这个内存块需要一个不安全的操作，因为生存期不依赖于特定的值。当智能指针实例被创建和销毁(“删除”)时，引用计数被更新。一旦它达到零，就会执行另一个不安全的操作来丢弃该值并释放分配的内存。</p><p id="18cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，<code class="du lx ly lz ln b">Arc</code>智能指针只返回对所包含值的不可变引用，而对不可变<code class="du lx ly lz ln b">Mutex</code>调用<code class="du lx ly lz ln b">lock()</code>会返回对所包含值的<em class="je">可变</em>引用。一旦满足了锁定语义，互斥体就可以通过调用C++ <code class="du lx ly lz ln b">const_cast</code>(一个不安全的操作)的等价物来实现这一点。</p><p id="6864" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里重要的部分是<code class="du lx ly lz ln b">Arc</code>和<code class="du lx ly lz ln b">Mutex</code>没有被编译器特殊对待，任何人都可以编写具有相同功能的新原语。那么你可能会想，如果开发人员可以插入一个<code class="du lx ly lz ln b">unsafe</code>代码块，这不是否定了Rust的安全优势吗？</p><p id="3c12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答案就看<code class="du lx ly lz ln b">unsafe</code>怎么用了。在这里讨论的两种情况下，类型提供了一个定义良好的安全接口，它封装了少量不安全的代码。这允许仔细检查类型以确保正确的行为，并利用编译器对大部分代码的安全保证。</p><p id="b7c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">人们当然可以在应用程序中声明大量的代码<code class="du lx ly lz ln b">unsafe</code>，如果需要的话，可以通过编译器的检查，就像可以用C++编写C风格的、大量使用指针的代码，而忽略STL一样。两者都有合法的用途，但通常只占应用程序的一小部分。或者，套用比尔·克林顿的话，这样的代码应该是不安全的、合法的、罕见的。</p></div></div>    
</body>
</html>