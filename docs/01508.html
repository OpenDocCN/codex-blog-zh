<html>
<head>
<title>10+ Fundamental Things To Approach React As Your Girlfriend!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为你的女朋友，10+基本的方法！</h1>
<blockquote>原文：<a href="https://medium.com/codex/10-fundamental-things-to-approach-react-as-your-girlfriend-c0ef99e16910?source=collection_archive---------8-----------------------#2021-05-07">https://medium.com/codex/10-fundamental-things-to-approach-react-as-your-girlfriend-c0ef99e16910?source=collection_archive---------8-----------------------#2021-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d57b648818e9b8d9f2146b766ab0d723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H6MMkB0oYf93B2hAIReABQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">反应</figcaption></figure><p id="94fa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，把自己想象成一个想要女朋友的孤独不酷的男生。然后，你认识了一个叫<strong class="iw hj"> REACT </strong>的女孩。她是如此的酷和吸引人，以至于你疯狂地想让她成为你的女朋友。但是，你是一个不知道如何接近她的怪胎。</p><p id="1cb6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">嗯！我为什么在这里？我会让你成为React的完美男友。为了做到这一点，我会教你一些基本的和独特的东西，这样你就可以无所畏惧地接近她，还会教你一些赢得她的心的技巧。所以，让我们开始吧！</strong></p><h1 id="3a30" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">谁在作出反应？她的背景是什么？</h1><p id="3215" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated"><strong class="iw hj"> React </strong>是一个用于构建用户界面的JavaScript库。她是web应用程序的视图层。不像典型的孟加拉女孩那样的框架，你和她在一起不用被限制和绑定某些规则。你可以享受按照自己的思维方式做出很酷的特征，因为她不会叫，而且她很灵活。她总是专注于一件事，那就是构建界面。如果没有React或类似的库，我们将需要用本地Web APIs和JavaScript手动构建ui，这并不容易。但是她让我们变得简单、快速和灵活。她是独一无二的，有吸引力的，因为她与虚拟世界一起工作，这使她比其他人更特别。</p><p id="afdd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好了，玩笑时间结束！现在，让我们认真了解一下React。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><h1 id="d73b" class="js jt hi bd ju jv lc jx jy jz ld kb kc kd le kf kg kh lf kj kk kl lg kn ko kp bi translated"><strong class="ak">为什么React与其他库不同？</strong></h1><p id="5fdf" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">React不同于其他库，因为它在开发者和浏览器之间创建了一种通用语言。它允许我们开发人员描述ui并管理状态上的动作，而不是对DOM元素采取动作。它只是用户界面的语言。当该状态发生任何动作时，React会根据以前的变化有效地更新DOM中的ui。React用虚拟Dom做到了这一点。</p><h1 id="fd6c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">虚拟世界和差异是如何起作用的</h1><p id="0af8" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">与它的许多前辈不同，React不是直接在浏览器的文档对象模型(DOM)上运行，而是在一个虚拟DOM(T11)上运行。要理解虚拟DOM，首先需要了解实际Dom是如何工作的。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/71a7cafd73ddb74c4bb9bcd5ebe5fa7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_2q5yo_fg5viX-z3mXWHA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">DOM如何工作</figcaption></figure><p id="a1f9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当我们编写代码来开发web应用程序时，HTML和CSS由解析器解析，并通过一些过程创建一个框架树。然后它创建一个带有样式的布局并显示它。构建布局的整个过程是在浏览器中的DOM进程下进行的。虚拟DOM做同样的事情，但实际上是反作用的。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/88595f8eabfbcea0f60d3ebf7c116210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*7o4nQhaCzm8iq-2nd0_XCA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">反应虚拟Dom和差分过程</figcaption></figure><p id="4a22" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">基本上，React App虚拟地创建了一个虚拟Dom，当任何东西被改变时，它通过一些不同的算法来与以前的改变进行比较，并进行协调。在这个过程之后，它只在有实际变化的节点及其子节点上更新实际的DOM。React虚拟DOM完全存在于内存中，是web浏览器DOM的一种表示。因此，当我们编写一个React组件时，我们并不是直接写入DOM，而是编写一个虚拟组件，React将转换为DOM。这是让React更受欢迎的一个优点。</p><h1 id="8fe7" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">什么是JSX？</h1><p id="0e65" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">当我们作出反应时，JSX这个词是不可避免的。我们所有的React组件都有一个Render()函数，它指定React组件的HTML输出是什么。JavaScript扩展，或者更常见的<strong class="iw hj"> JSX </strong>，是一个React扩展，允许我们编写看起来像HTML的JavaScript。React和浏览器不需要处理JSX，因为编译器会处理它。将一种形式的语法翻译成另一种形式的编译器被称为“翻译程序”。要翻译JSX，我们可以使用通天塔或打字稿。例如，jsComplete playground使用TypeScript来传输您放入其中的任何JSX。当您使用create-react-app时，生成的应用程序将在内部使用Babel来传输您的JSX。</p><h1 id="f92a" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">反应组分</h1><p id="1b06" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">组件就像函数和返回HTML元素的独立且可重用的代码。它们的作用与JavaScript函数通过render()函数返回HTML相同。组件让你的代码更具T4可读性，更容易使用。简单地说，组件是一个JavaScript类或函数，它可以选择接受像属性(props)这样的输入，并返回一个描述UI的某个部分应该如何显示的React元素。有两种类型的组件，</p><ol class=""><li id="0633" class="ln lo hi iw b ix iy jb jc jf lp jj lq jn lr jr ls lt lu lv bi translated"><em class="lw">类组件</em></li><li id="e5d6" class="ln lo hi iw b ix lx jb ly jf lz jj ma jn mb jr ls lt lu lv bi translated"><em class="lw">功能组件</em></li></ol><h1 id="180d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">类组件</strong></h1><p id="e23b" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这些组件是使用ES6的类创建的。它们有一些额外的特性，比如处理onClick事件的方法、本地状态和其他功能。</p><p id="4436" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最简单形式的类组件:</p><pre class="li lj lk ll fd mc md me mf aw mg bi"><span id="e77f" class="mh jt hi md b fi mi mj l mk ml"><strong class="md hj">class</strong> Greeting <strong class="md hj">extends</strong> React.Component {<br/>  <strong class="md hj">render()</strong>{<br/>    <strong class="md hj">return</strong> <strong class="md hj">&lt;h1&gt;</strong>Hi, I’m a smart component!<strong class="md hj">&lt;/h1&gt;</strong>;<br/>  }<br/>}</span></pre><h1 id="7071" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">功能成分</h1><p id="d214" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这些组件简单地由一个函数表示，该函数可以选择接受props并返回一个React元素以呈现给页面。您可能会发现功能组件被称为无状态的<em class="lw"> </em>或表示性的。</p><p id="2634" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">=&gt; <strong class="iw hj">功能性</strong>因为它们基本上都是功能</p><p id="d3b4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">=&gt; <strong class="iw hj">无状态</strong>因为它们不持有和/或管理状态</p><p id="f86a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">=&gt; <strong class="iw hj">表示性的</strong>因为它们所做的只是输出UI元素</p><p id="54c1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最简单形式的功能组件如下所示:</p><pre class="li lj lk ll fd mc md me mf aw mg bi"><span id="b647" class="mh jt hi md b fi mi mj l mk ml"><strong class="md hj">const</strong> Greeting = () =&gt; <strong class="md hj">&lt;h1&gt;</strong>Hi, I’m a dumb component!<strong class="md hj">&lt;/h1&gt;</strong>;</span></pre><h1 id="719c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">小道具</h1><p id="a7d1" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">Props是传递给React组件的参数。它们就像JavaScript中的函数参数<em class="lw">和HTML中的</em>属性。</p><pre class="li lj lk ll fd mc md me mf aw mg bi"><span id="6f53" class="mh jt hi md b fi mi mj l mk ml">const Welcome = (props) =&gt; {<br/>  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;<br/>}<br/><br/>const App = ()=&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Welcome name="Sara" /&gt;      <br/>      &lt;Welcome name="Cahal" /&gt;      <br/>      &lt;Welcome name="Edite" /&gt;    <br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="4f0c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如你所见，我们可以将属性作为对象传递给子组件，并通过props(properties)接收它以供使用。Props更像是组件之间的网线。</p><h1 id="8c23" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">反应钩</h1><p id="13dc" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">钩子是React 16.8版本中引入的新特性。它允许您在不编写类的情况下使用状态和其他React特性。它在类内不起作用。如果你写了一个函数组件，然后你想给它添加一些状态，以前你是通过把它转换成一个类来实现的。但是，现在您可以通过在现有的函数组件中使用一个钩子来实现。所有的钩子函数都是以“使用”这个词开始的。当你用钩子做事情的时候，它是非常强大的，没有限制的。</p><p id="4bb1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">React应用程序中有一种重要的钩子类型和声明状态的新方法。Hook使用useState()函数组件来设置和检索状态。让我们通过下面的例子来理解钩子状态:</p><pre class="li lj lk ll fd mc md me mf aw mg bi"><span id="92c5" class="mh jt hi md b fi mi mj l mk ml"><strong class="md hj">import</strong> React, { useState } from 'react';</span><span id="a403" class="mh jt hi md b fi mm mj l mk ml">const App = ()=&gt; { </span><span id="383c" class="mh jt hi md b fi mm mj l mk ml">  c<!-- -->onst [count, setCount] = useState(0);</span><span id="d9e1" class="mh jt hi md b fi mm mj l mk ml">return (<br/>    &lt;div&gt;<br/>     <!-- -->&lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>     &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt;<!-- -->   <br/>    &lt;/div&gt;<br/>  );<br/>}<br/>export <strong class="md hj">default</strong> App;</span></pre><p id="3f7e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">输出是:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/f4a8068491f24575ce2ad218e72620a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WpAPIMrUzR6gjwYU0C-aTQ.png"/></div></div></figure><p id="d3e1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">还有很多钩子，比如useEffect、useContext、useReducer、useRef、useMemo等等。</p><h1 id="c885" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">反应组件生命周期</h1><p id="bbf5" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在React中，每个组件创建过程都包含各种生命周期方法。这些生命周期方法被称为组件的生命周期。这些生命周期方法并不复杂，并且在组件生命周期的不同点被调用。组件的生命周期分为<strong class="iw hj">四个阶段</strong>。它们是:</p><ol class=""><li id="e57f" class="ln lo hi iw b ix iy jb jc jf lp jj lq jn lr jr ls lt lu lv bi translated">初始相位</li><li id="190f" class="ln lo hi iw b ix lx jb ly jf lz jj ma jn mb jr ls lt lu lv bi translated">安装阶段</li><li id="ffa3" class="ln lo hi iw b ix lx jb ly jf lz jj ma jn mb jr ls lt lu lv bi translated">更新阶段</li><li id="4930" class="ln lo hi iw b ix lx jb ly jf lz jj ma jn mb jr ls lt lu lv bi translated">卸载阶段</li></ol><p id="5c7c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每个阶段都包含一些特定于该特定阶段的生命周期方法。让我们逐一讨论这些阶段:</p><h1 id="4412" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">1.初始相位</h1><p id="154b" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这是生命周期的<strong class="iw hj">诞生</strong>阶段。在这里，组件开始了通向DOM的旅程。在这个阶段，组件包含默认的道具和初始状态。初始阶段只出现一次，由以下方法组成。</p><ul class=""><li id="f438" class="ln lo hi iw b ix iy jb jc jf lp jj lq jn lr jr mo lt lu lv bi translated"><strong class="iw hj"> getDefaultProps() </strong> <br/>它用来指定道具的默认值。它在组件的创建或来自父组件的任何属性被传递给它之前被调用。</li><li id="efb8" class="ln lo hi iw b ix lx jb ly jf lz jj ma jn mb jr mo lt lu lv bi translated"><strong class="iw hj"> getInitialState() </strong> <br/>它用来指定状态的默认值。它在创建组件之前被调用。</li></ul><h1 id="983e" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">2.安装阶段</h1><p id="53d3" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在这个阶段，组件的元素被创建并插入到DOM中。它由以下方法组成:</p><ul class=""><li id="a349" class="ln lo hi iw b ix iy jb jc jf lp jj lq jn lr jr mo lt lu lv bi translated"><strong class="iw hj">componentWillMount()</strong><br/>在组件呈现到DOM之前立即调用。在这种情况下，当您在该方法中调用<strong class="iw hj"> setState() </strong>时，组件将不会<strong class="iw hj">重新呈现</strong>。</li><li id="93b2" class="ln lo hi iw b ix lx jb ly jf lz jj ma jn mb jr mo lt lu lv bi translated"><strong class="iw hj">componentDidMount()</strong><br/>在组件被渲染并放置在DOM上后，立即调用这个函数。现在，您可以进行任何DOM查询操作。</li><li id="061f" class="ln lo hi iw b ix lx jb ly jf lz jj ma jn mb jr mo lt lu lv bi translated"><strong class="iw hj"> render() </strong> <br/>这个方法在每一个组件中都有定义。它负责返回一个根HTML节点元素。如果不想渲染什么，可以返回一个<strong class="iw hj"> null </strong>或者<strong class="iw hj"> false </strong>值。</li></ul><h1 id="0a06" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">3.更新阶段</h1><p id="5180" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这是react组件生命周期的下一个阶段。这里，我们得到新的<strong class="iw hj">道具</strong>并改变<strong class="iw hj">状态</strong>。这一阶段允许处理用户与组件从父订单到子订单的通信。这个阶段的主要目标是确保组件显示其自身的最新版本。与出生或死亡阶段不同，这个阶段会一次又一次地重复。这个阶段由以下方法组成。</p><ul class=""><li id="feaf" class="ln lo hi iw b ix iy jb jc jf lp jj lq jn lr jr mo lt lu lv bi translated"><strong class="iw hj">componentwillreceiveprops()</strong><br/>当一个组件接收到新的道具时调用。如果您想要更新状态以响应属性更改，您应该使用<strong class="iw hj"> setState() </strong>方法比较props和nextProps以执行状态转换。</li><li id="a0be" class="ln lo hi iw b ix lx jb ly jf lz jj ma jn mb jr mo lt lu lv bi translated"><strong class="iw hj">shouldComponentUpdate()</strong><br/>当一个组件决定对DOM进行任何更改时，它被调用。它允许您控制组件自我更新的行为。如果此方法返回true，组件将更新。否则，组件将跳过更新。</li><li id="f068" class="ln lo hi iw b ix lx jb ly jf lz jj ma jn mb jr mo lt lu lv bi translated"><strong class="iw hj">componentWillUpdate()</strong><br/>它在组件更新发生之前被调用。这里不能通过调用<strong class="iw hj"> setState() </strong>方法来改变组件状态。如果<strong class="iw hj">shouldComponentUpdate()</strong>返回false，则不会调用它。</li><li id="4422" class="ln lo hi iw b ix lx jb ly jf lz jj ma jn mb jr mo lt lu lv bi translated"><strong class="iw hj"> render() </strong> <br/>调用它来检查<strong class="iw hj"> props </strong>和<strong class="iw hj"> state </strong>并返回以下类型之一:React元素、数组和片段、布尔值或null、字符串和数字。如果shouldComponentUpdate()返回false，render()内的代码将被再次调用，以确保组件正确显示自身。</li><li id="320b" class="ln lo hi iw b ix lx jb ly jf lz jj ma jn mb jr mo lt lu lv bi translated"><strong class="iw hj">componentDidUpdate()</strong><br/>在组件更新发生后立即调用。在这个方法中，您可以将任何想要在更新发生时执行的代码放入其中。初始呈现时不会调用此方法。</li></ul><h1 id="11d6" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">4.卸载阶段</h1><p id="2f50" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这是react组件生命周期的最后阶段。当一个组件实例被从DOM中<strong class="iw hj">销毁</strong>和<strong class="iw hj">卸载</strong>时，它被调用。这个阶段只包含一种方法，如下所示。</p><ul class=""><li id="d40f" class="ln lo hi iw b ix iy jb jc jf lp jj lq jn lr jr mo lt lu lv bi translated"><strong class="iw hj">componentWillUnmount()</strong><br/>在组件被永久销毁和卸载之前，立即调用该方法。它执行任何必要的与<strong class="iw hj">清理</strong>相关的任务，比如使计时器失效、事件监听器、取消网络请求或者清理DOM元素。如果组件实例被卸载，则不能再次装载它。</li></ul><h1 id="eef2" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">反应优化性能</h1><p id="92e4" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在生产React应用程序之前，优化性能是一个需要考虑的重要过程。有多种优化React应用程序的方法可以显著提高应用程序的速度和整体用户体验。虽然有许多方法可以优化性能，但今天我将使用3个简单的过程作为示例:</p><p id="1fd5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">使用React。片段，以避免向DOM添加额外的节点</strong></p><p id="4214" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用React。Fragment不会向DOM添加任何额外的节点，并且在大型应用程序中会提高一些速度。语法如下所示:</p><pre class="li lj lk ll fd mc md me mf aw mg bi"><span id="6ed2" class="mh jt hi md b fi mi mj l mk ml">const Columns = () =&gt; {<br/>  return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;td&gt;Hello React!&lt;/td&gt;<br/>      &lt;td&gt;Hello React Again!&lt;/td&gt;<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>}</span></pre><p id="b730" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您也可以使用短语法<code class="du mp mq mr md b">&lt;&gt;&lt;/&gt;</code>来声明一个片段。</p><pre class="li lj lk ll fd mc md me mf aw mg bi"><span id="07b4" class="mh jt hi md b fi mi mj l mk ml">const Columns = () =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;td&gt;Hello React!&lt;/td&gt;<br/>      &lt;td&gt;Hello React Again!&lt;/td&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="3983" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">使用生产版本</strong></p><p id="d205" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">优化React应用程序的另一种方法是确保在部署之前将应用程序捆绑到生产环境中。这在你开发的时候非常有用，但是它会使你的应用程序变得很大，响应速度比平时慢。如果您的项目是使用create-react-app构建的，您可以通过在部署之前运行“npm run build”来解决这个问题，这将在“build”文件夹中创建您的应用程序的生产就绪版本，然后您可以进行部署。你可以使用“react开发者工具”(React开发者的chrome扩展)来确认你的应用是处于开发模式还是生产模式</p><p id="a95b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">使用react-window虚拟化大型列表</strong></p><p id="ba10" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当您想要渲染大型表格或数据列表时，它会降低应用程序的性能。在react-window和react-virtualized等库的帮助下，虚拟化可以在这种情况下提供帮助。它们通过仅呈现列表中当前可见的项目来帮助解决这个问题，这允许高效地呈现任何大小的列表。</p><p id="8e98" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以，这是一些让你的女朋友做出反应的技巧和旅行哈哈！</p><p id="5869" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我知道这不是很多，但我会收集更多的信息，并在未来写更多的关于react的易懂的博客。</p></div></div>    
</body>
</html>