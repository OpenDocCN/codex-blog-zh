<html>
<head>
<title>Efficiently serving Blobs from Azure Storage in ASP.NET Core using custom ActionResult</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用自定义ActionResult从ASP.NET核心中的Azure存储高效地服务Blobs</h1>
<blockquote>原文：<a href="https://medium.com/codex/efficiently-serving-blobs-from-azure-storage-in-asp-net-core-using-custom-actionresult-33399faaecbf?source=collection_archive---------0-----------------------#2021-09-11">https://medium.com/codex/efficiently-serving-blobs-from-azure-storage-in-asp-net-core-using-custom-actionresult-33399faaecbf?source=collection_archive---------0-----------------------#2021-09-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/942124a4c5ca9240abdead672f4b7f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46r2tHSQhP8gSpquIz32Uw.png"/></div></div></figure><p id="7f24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能已经在使用Azure Blob存储来存储应用程序中的一些文件。你能有效地将这些文件返回给用户吗？有几件事是经常做的。</p><h2 id="e666" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">匿名公共访问</h2><p id="760e" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">这很容易，需要一点努力。根据<a class="ae ko" href="https://docs.microsoft.com/en-us/azure/storage/blobs/anonymous-read-access-configure?tabs=portal" rel="noopener ugc nofollow" target="_blank">官方文档</a>，你可以在容器中对你的blobs进行匿名公共访问。上传文件后，您可以将blob的URL放入响应中，例如<em class="kp">https://contoso . blob . core . windows . net/container 1/dir 1/file 1 . pdf</em></p><p id="05d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更进一步，您可以在存储帐户上启用CDN，可选地为文件添加前缀。您将设置一个CDN配置文件，其端点指向您的blob存储帐户。官方文档用更简单的方式解释了这些步骤。然后，在将blob写入响应之前，修改它的URL。对于我们上面的blob，你会得到类似于<em class="kp">https://contoso.azureedge.net/container1/dir1/file1.pdf</em>的结果，如果你给CDN端点原点添加一个前缀，你可以省略一些路径段。例如，您可以将路径设置为<code class="du kq kr ks kt b">/container1/dir1</code>，这样得到的URL将是<em class="kp">https://contoso.azureedge.net/file1.pdf</em>。使用CDN可以提供更好的用户体验，并有助于节省Blob存储成本，但这不是本文的重点。关于这个有大量的信息。</p><h2 id="13f7" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">认证怎么样？</h2><p id="a9c6" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">你已经开发了你的应用程序，但是你想决定是否有人可以访问某些文件。例如，在共享存储帐户的多租户应用程序中。Azure Blob存储支持使用密钥和Azure AD的身份验证。密钥是为您的应用程序准备的。对于您组织中的用户(拥有Azure订阅的租户，其中存在存储帐户)，Azure AD可能足以控制权限，或者使用SharePoint等更具企业级的解决方案会更好。不幸的是，情况并非总是如此，至少在我的工作中是这样。</p><p id="28ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个也是相当可靠的选择是使用ASP.NET核心，您可以根据自己的喜好控制用户访问，并在此过程中，向最终用户隐藏文件存储位置的内在特性。在大多数情况下，您可以将文件下载到内存或本地磁盘，然后在响应中提供它。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="4ec8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">眼熟吗？是啊！为什么？这是最简单的方法，如果可行，为什么要改变呢？不幸的是，至少在我能想到的两种情况下，这往往是低效的:</p><ol class=""><li id="6858" class="la lb hi is b it iu ix iy jb lc jf ld jj le jn lf lg lh li bi translated">您希望支持HTTP HEAD动词，而不仅仅是HTTP GET，而不必从Azure Blob存储中下载文件。</li><li id="ed71" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">您需要客户端在下载内容时执行测距。</li></ol><p id="c3f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这两种情况下，您需要决定是否下载文件的内容。第二种情况对于大文件特别有用。存储/内存(易失性和非易失性)是昂贵的，您并不总是有足够的资源用于这些下载。</p><h2 id="54e2" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">解决方案？把密码给我！！！</h2><p id="2000" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">这个问题的解决方案是利用<code class="du kq kr ks kt b">Azure.Storage.Blobs</code>库提供的所有特性，包括流式下载。如果文件很大，HTTP HEAD请求将帮助HTTP客户端(如浏览器)在下载前做好适当的准备，如检查空间、计划并行下载(如下载管理器)。</p><p id="6b19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们创建了一个定制的<code class="du kq kr ks kt b">ActionResult</code>实现，因为内置的<code class="du kq kr ks kt b">FileStreamResult</code>和<code class="du kq kr ks kt b">FileContentResult</code>期望您拥有完整的流或字节数组。基本上，它们只支持本地文件或内容可以保存在内存中的小文件。在这里我们创造<code class="du kq kr ks kt b">BlobStorageResult</code>:</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="e51d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了使用它，我们将控制器简化为:</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="4b61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简单吧？没那么快。我们还需要实现<code class="du kq kr ks kt b">IActionResultExecutor&lt;BlobStorageResult&gt;</code>才能在<code class="du kq kr ks kt b">ExecuteResultAsync(…)</code>中解决。幸运的是，这并不难。鉴于<code class="du kq kr ks kt b">BlobStorageResult</code>继承了<code class="du kq kr ks kt b">FileResult</code>，我们可以利用内置的<code class="du kq kr ks kt b">FileResultExecutorBase</code>。blob毕竟是一个文件(大多数时候)。</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="50c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我写这篇文章时，我查看了<a class="ae ko" href="https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/Infrastructure/FileStreamResultExecutor.cs" rel="noopener ugc nofollow" target="_blank">filestream result executor</a>的内置实现。起初，我认为我甚至不需要使用<code class="du kq kr ks kt b">FileResult</code>,因为这将是不同的，直到我意识到使用它将允许我使用<code class="du kq kr ks kt b">FileResultExecutorBase</code>,它做许多锅炉板，例如:</p><ol class=""><li id="38fc" class="la lb hi is b it iu ix iy jb lc jf ld jj le jn lf lg lh li bi translated">验证请求头中提供的范围，并决定我们是否应该写主体。</li><li id="733d" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">设置适当的响应头(内容长度、内容类型、If范围、范围、内容范围等)和响应代码(200、206或416)。</li></ol><p id="dc92" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">提议的方法实现了什么？</p><ol class=""><li id="5106" class="la lb hi is b it iu ix iy jb lc jf ld jj le jn lf lg lh li bi translated">允许客户端请求一个范围，当他们这样做时，我们只使用<code class="du kq kr ks kt b">DownloadStreamingAsync(…)</code>从Azure Blob存储中下载范围</li><li id="415a" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">如果我们有HTTP HEAD请求所需的详细信息(例如来自数据库)，我们可以避免调用Azure Blob存储。</li><li id="ad22" class="la lb hi is b it lj ix lk jb ll jf lm jj ln jn lf lg lh li bi translated">当我们没有HTTP HEAD请求所需的细节时，我们可以只获取更快更小的blob属性。</li></ol><p id="32e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，设置服务非常简单:</p><figure class="ku kv kw kx fd ij"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="801a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后可以在Startup.cs文件中调用<code class="du kq kr ks kt b">services.AddBlobStorage(...)</code>。</p><p id="f585" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管这可能涵盖了大多数场景，但它不支持页面blobs(或者可能是错误地支持？让我知道)，或者传递ContainerName和BlobName而不是BlobUrl，但是可以在应用程序中修改。</p></div></div>    
</body>
</html>