<html>
<head>
<title>Dart Apprentice — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dart学徒-第二部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/dart-apprentice-part-ii-ab00b7e8ee03?source=collection_archive---------7-----------------------#2021-08-21">https://medium.com/codex/dart-apprentice-part-ii-ab00b7e8ee03?source=collection_archive---------7-----------------------#2021-08-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a522" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于软件每天都在增长，开发人员需要更高水平的编程知识，以便在更短的时间内提供更好的解决方案。在这一部分中，我将向您展示Dart学徒手册的其余部分，包括Dart中的集合、函数和类。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/8cbc8411855da5567bca8d0ada621faa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2L4kzevhwgKOThuMPKE8WA.jpeg"/></div></figure><p id="2c3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你不熟悉dart编程的基础，我建议你先阅读下面链接中的第一部分，然后继续第二部分:</p><div class="jl jm ez fb jn jo"><a rel="noopener follow" target="_blank" href="/@hseify69/dart-apprentice-part-i-2ba5aaaa0f4c"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd hj fi z dy jt ea eb ju ed ef hh bi translated">飞镖学徒—第一部分</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">开发跨平台软件的最新技术之一是Flutter，它不仅可以用来开发IOS系统，还可以用来开发跨平台软件</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">medium.com</p></div></div><div class="jx l"><div class="jy l jz ka kb jx kc jj jo"/></div></div></a></div></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="fbf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面我将介绍函数作为一种编写一次代码并多次使用的方法，集合作为一种可以保存一批特殊类型的变量，而类作为新类型的蓝图。准备一杯美味的饮料，开始吧。</p><h1 id="1b14" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">功能:</h1><p id="3234" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">一个函数是一个小任务，或者有时是几个更小的相关任务的集合，可以与其他函数结合使用来完成一个更大的任务。你可以把功能想象成机器；他们接受你提供给他们的东西(输入)，并产生不同的东西(输出)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ln"><img src="../Images/bb31923994aba002831acf8a6d269901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JYfzFswc1rDnu8hF"/></div></div></figure><p id="b23b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">日常生活中有很多这样的例子。用苹果榨汁机，你放入苹果，你得到苹果汁。输入是苹果；输出的是果汁。</p><h1 id="cc93" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">Dart功能剖析:</h1><p id="a7af" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">在Dart中，函数由返回类型、名称、圆括号中的参数列表和大括号中的主体组成。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ls"><img src="../Images/43d9ec2ca1ed8b71b8e0b6b545ed4b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K58fax2Wk_kESZub"/></div></div></figure><p id="f0ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是该函数的标记部分的简短摘要:</p><ul class=""><li id="28bd" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated">返回类型:这个先来；它会立即告诉你函数输出的类型。这个特定的函数将返回一个字符串，但是您的函数可以返回您喜欢的任何类型。如果函数不返回任何东西，也就是说，如果它执行一些工作，但不产生输出值，那么可以使用void作为返回类型。</li><li id="82f1" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">函数名:您几乎可以给函数起任何您喜欢的名字，但是您应该遵循lowerCamelCase命名约定。在这一章的后面，你会学到更多的命名规则。</li><li id="fb20" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">参数:参数是函数的输入；它们放在函数名后面的括号里。这个例子只有一个参数，但是如果有多个参数，可以用逗号分隔。对于每个参数，首先编写类型，然后是名称。正如变量名一样，参数名应该使用小写字母。</li><li id="693b" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">返回值:这是函数的输出，它应该与返回类型相匹配。在上面的示例中，函数使用return关键字返回一个字符串值。但是，如果返回类型是void，则不返回任何内容。返回类型、函数名和参数统称为函数签名。大括号之间的代码称为函数体。</li></ul><p id="f28a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是上面的函数在程序上下文中的样子:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="b099" class="mm kl hi mi b fi mn mo l mp mq">void main() {<br/>    const input = 12;<br/>    final output = compliment(input);<br/>    print(output);<br/>}</span><span id="c193" class="mm kl hi mi b fi mr mo l mp mq">String compliment(int number) {<br/>    return '$number is a very nice number.';<br/>}</span></pre><p id="8592" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在运行代码，您将看到以下结果:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="d1ef" class="mm kl hi mi b fi mn mo l mp mq">12 is a very nice number.</span></pre><h1 id="cf9c" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">关于参数的更多信息</h1><p id="d681" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">Dart中的参数非常灵活，因此它们应该有自己的部分。</p><h1 id="8b50" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">使用多个参数</h1><p id="350a" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">在Dart函数中，可以使用任意数量的参数。如果您的函数有多个参数，只需用逗号分隔即可。这是一个有两个参数的函数:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="33da" class="mm kl hi mi b fi mn mo l mp mq">void helloPersonAndPet(String person, String pet) {<br/>    print('Hello, $person, and your furry friend, $pet!');<br/>}</span></pre><p id="8d1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似上面的参数称为位置参数，因为您必须按照编写函数时定义参数的顺序来提供参数。如果您以错误的顺序调用带有参数的函数，您将得到一些明显错误的东西:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="e8d5" class="mm kl hi mi b fi mn mo l mp mq">helloPersonAndPet('Fluffy', 'Chris');<br/>// Hello, Fluffy, and your furry friend, Chris!</span></pre><h1 id="baf5" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">使参数可选</h1><p id="8495" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">为了表示参数是可选的，可以用方括号将参数括起来，并在类型后添加一个问号，如下所示:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="83ec" class="mm kl hi mi b fi mn mo l mp mq">String fullName(String first, String last, [String? title]) {<br/>    if (title != null) {<br/>        return '$title $first $last';<br/>    } else {<br/>        return '$first $last';<br/>    }<br/>}</span></pre><p id="256f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">写作【字符串？title]使标题可选。如果您没有为title传入一个值，那么它的值将为null，这意味着“没有值”。这里有两个例子来测试它:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="ee75" class="mm kl hi mi b fi mn mo l mp mq">print(fullName('Ray', 'Wenderlich'));<br/>print(fullName('Albert', 'Einstein', 'Professor'));</span></pre><p id="c064" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在运行它，您将看到以下内容:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="73b3" class="mm kl hi mi b fi mn mo l mp mq">Ray Wenderlic<br/>Professor Albert Einsteinh</span></pre><h1 id="5a04" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">提供默认值</h1><p id="133a" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">您甚至可以通过用默认值声明参数来为函数签名中的参数初始化值。看一下这个例子:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="c5a6" class="mm kl hi mi b fi mn mo l mp mq">bool withinTolerance(int value, [int min = 0, int max = 10]) {<br/>    return min &lt;= value &amp;&amp; value &lt;= max;<br/>}</span></pre><p id="89fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有三个参数，其中两个是可选的:min和max。如果不为它们指定值，则最小值将为0，最大值将为10。这里有一些具体的例子来说明:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="c063" class="mm kl hi mi b fi mn mo l mp mq">withinTolerance(5) // true<br/>withinTolerance(15) // false</span></pre><p id="8528" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于5介于0和10之间，因此计算结果为true但是由于15大于默认的最大值10，所以它的计算结果为false。如果您想指定默认值以外的值，也可以这样做:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="0903" class="mm kl hi mi b fi mn mo l mp mq">withinTolerance(9, 7, 11) // true</span></pre><p id="be92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为9介于7和11之间，所以该函数返回true。如果这还不够糟糕，下面的函数调用也返回true:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="9919" class="mm kl hi mi b fi mn mo l mp mq">withinTolerance(9, 7) // true</span></pre><p id="9511" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为函数使用位置参数，所以提供的参数必须遵循您定义参数的顺序。这意味着值是9，最小值是7，最大值的默认值是10。但是谁会记得呢？也许命名参数有助于更容易地阅读代码。</p><h1 id="9baf" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">命名参数</h1><p id="2258" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">Dart允许您在函数调用中使用命名参数来使参数的含义更加清晰。要创建一个命名参数，需要用花括号而不是方括号将它括起来。下面是与上面相同的函数，但是使用了命名参数:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="3c57" class="mm kl hi mi b fi mn mo l mp mq">bool withinTolerance(int value, {int min = 0, int max = 10}) {<br/>    return min &lt;= value &amp;&amp; value &lt;= max;<br/>}</span></pre><p id="1daa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意以下几点:</p><ul class=""><li id="190e" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated">min和max用大括号括起来，这意味着在向函数提供参数值时必须使用参数名。</li><li id="a389" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">像方括号一样，花括号使得里面的参数是可选的。因为value不在大括号内，所以它仍然是必需的。</li></ul><p id="fbe8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要提供参数，可以使用参数名，后跟一个冒号，然后是参数值。下面是您现在调用该函数的方式:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="7299" class="mm kl hi mi b fi mn mo l mp mq">withinTolerance(9, min: 7, max: 11); // true</span></pre><p id="d093" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">命名参数的另一个好处是，您不必按照定义它们的确切顺序来使用它们。这两种调用函数的方法是等效的:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="b510" class="mm kl hi mi b fi mn mo l mp mq">withinTolerance(9, min: 7, max: 11); // true<br/>withinTolerance(9, max: 11, min: 7); // true</span></pre><p id="36c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于命名参数是可选的，这意味着以下函数调用也是有效的:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="37e8" class="mm kl hi mi b fi mn mo l mp mq">withinTolerance(5); // true<br/>withinTolerance(15); // false</span><span id="028e" class="mm kl hi mi b fi mr mo l mp mq">withinTolerance(5, min: 7); // false<br/>withinTolerance(15, max: 20); // true</span></pre><h1 id="cf1d" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">使命名参数成为必需的；</h1><p id="faed" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">您想要的是使value成为必需的而不是可选的，同时仍然保持它作为一个命名参数。您可以通过在大括号中包含value并在前面添加所需的关键字来实现这一点:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="d97f" class="mm kl hi mi b fi mn mo l mp mq">bool withinTolerance(required int value,int min = 0,int max = 10,}) {<br/>    return min &lt;= value &amp;&amp; value &lt;= max;<br/>}</span></pre><p id="fc6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了必需的关键字，如果您在调用函数时没有提供value的值，VS代码将会警告您:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ms"><img src="../Images/2b25a8c717d06d6c07ad5fa55176a340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cIKNYYv62brRHog2"/></div></div></figure><p id="16cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在书中读到更多关于函数的内容，特别是匿名函数和箭头函数。</p><h1 id="992c" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">班级</h1><p id="47c4" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">在第一部分中，您使用了内置类型，如int、String和bool。现在，您已经准备好学习一种更灵活的方法，通过使用类来创建自己的类型。</p><h1 id="e6b9" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">Dart类</h1><p id="9d57" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">类就像告诉系统如何制造对象的建筑蓝图，其中对象是存储在计算机内存中的实际数据。如果一个类是蓝图，那么你可以说对象就像蓝图所代表的房子。例如，String类将其数据描述为UTF-16代码单元的集合，但String对象是类似“Hello，Dart！”的具体内容。</p><p id="f56a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类是面向对象编程的核心组件。它们用于将数据和功能组合在一个结构中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mt"><img src="../Images/999775dad52dc401deee473665481ec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BU42bHnsfPgceq7l"/></div></div></figure><p id="c4c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些函数用于转换数据。类内部的函数称为方法，而构造函数是用于从类中创建对象的特殊方法。</p><h1 id="0135" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">定义类别</h1><p id="830c" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">要定义一个新的类，必须使用' class '关键字，然后写下这个类的名字，然后用花括号把它的内容括起来。在Dart文件的顶层编写以下简单的类。你的类应该在main函数之外，在它的上面或者下面。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="9a1b" class="mm kl hi mi b fi mn mo l mp mq">class User {<br/>    int id = 0;<br/>    String name = '';<br/>}</span></pre><p id="2846" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将创建一个名为User的类。它有两个属性:id是int，默认值为0，name是String，默认值为空字符串。</p><h1 id="384a" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">从类创建对象</h1><p id="f997" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">如上所述，您从类中创建的值称为对象。对象的另一个名字是实例，所以创建一个对象有时被称为实例化一个类。</p><p id="5fce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于像上面那样在Dart文件中编写类只是创建了蓝图，所以用户对象还不存在。您可以像调用函数一样调用类名来创建一个。在main函数中添加以下代码行:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="30ce" class="mm kl hi mi b fi mn mo l mp mq">final user = User();</span></pre><p id="49bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将创建用户类的一个实例，并将该实例或对象存储在User中。请注意User后面的空括号。看起来你在调用一个没有任何参数的函数。事实上，您调用的是一种叫做构造函数方法的函数。在这一章的后面，你会学到更多关于它们的知识。现在，简单地理解以这种方式使用你的类创建了你的类的一个实例。</p><h1 id="1d8b" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">为属性赋值</h1><p id="3963" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">既然user中存储了一个User实例，就可以使用点标记法为该对象的属性分配新值。要访问name属性，请键入用户点名称，然后给它一个值:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="b9de" class="mm kl hi mi b fi mn mo l mp mq">user.name = 'Ray';</span></pre><p id="7829" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，以类似的方式设置ID:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="80c8" class="mm kl hi mi b fi mn mo l mp mq">user.id = 42;</span></pre><h1 id="5788" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">级联符号</h1><p id="fed5" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">Dart提供了级联运算符(..)允许您将同一个对象上的多个赋值链接在一起，而不必重复对象名称。以下代码是等效的:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="6d9c" class="mm kl hi mi b fi mn mo l mp mq">final user = User()<br/>    ..name = 'Ray'<br/>    ..id = 42;</span></pre><p id="ffd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意分号只出现在最后一行。</p><h1 id="e922" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">构造器</h1><p id="eeb0" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">构造函数是创建或构造类的实例的方法。也就是说，构造函数构建新的对象。构造函数与类同名，构造函数方法的隐式返回类型也是与类本身相同的类型。</p><h1 id="ec78" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">默认构造函数</h1><p id="2786" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">目前，用户类没有显式的构造函数。在这种情况下，Dart提供了一个默认的构造函数，它不接受任何参数，只返回该类的一个实例。例如，像这样定义一个类:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="3acc" class="mm kl hi mi b fi mn mo l mp mq">class Address {<br/>    var value = '';<br/>}</span></pre><p id="118d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相当于这样写:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="8b1d" class="mm kl hi mi b fi mn mo l mp mq">class Address {<br/>    Address();<br/>    var value = '';<br/>}</span></pre><p id="5cc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">包含默认的Address()构造函数是可选的。</p><h1 id="333d" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">自定义构造函数</h1><p id="0791" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">与上面的默认构造函数一样，构造函数的名称应该与类名相同。这种类型的构造函数称为生成式构造函数，因为它直接生成同一类型的对象。</p><h1 id="cc8d" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">长格式构造函数</h1><p id="a23a" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">在类体的顶部添加以下创成式构造函数方法:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="fb48" class="mm kl hi mi b fi mn mo l mp mq">User(int id, String name) {<br/>    this.id = id;<br/>    this.name = name;<br/>}</span></pre><p id="41a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个新的关键字。它是做什么的？</p><p id="5e32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构造函数体中的关键字this允许你明确你所谈论的是哪个变量。意思是这个物体。所以this.name指的是名为name的对象属性，而name(不带this)指的是构造函数参数。对构造函数参数使用与类属性相同的名称称为隐藏。因此，上面的构造函数采用id和name参数，并用它来初始化对象的属性。</p><h1 id="3494" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">简式构造函数</h1><p id="bda3" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">Dart还有一个短格式的构造函数，在这个构造函数中不提供函数体，而是列出要初始化的属性，以this关键字为前缀。发送给短格式构造函数的参数用于初始化相应的对象属性。最后一个代码段与下面的代码段完全相同:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="ef1b" class="mm kl hi mi b fi mn mo l mp mq">User(this.id, this.name);</span></pre><p id="1333" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Dart从类体中声明的属性本身推断出构造函数参数类型int和String。</p><h1 id="e16f" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">命名构造函数</h1><p id="85e9" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">Dart还有第二种类型的生成构造函数，称为命名构造函数，您可以通过在类名上添加标识符来创建它。它采用以下模式:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="f313" class="mm kl hi mi b fi mn mo l mp mq">ClassName.identifierName()</span></pre><p id="ca0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么你想要一个命名的构造函数而不是一个漂亮整洁的默认构造函数呢？嗯，有时你有一些常见的情况，你想提供一个方便的构造函数。或者，您可能有一些特殊的情况，需要用稍微不同的方法来构造某些类。</p><p id="f048" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，假设您想要一个具有预设ID和名称的匿名用户。您可以通过创建命名构造函数来实现这一点。在短格式构造函数下添加以下命名构造函数:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="dbfc" class="mm kl hi mi b fi mn mo l mp mq">User.anonymous() {<br/>    id = 0;<br/>    name = 'anonymous';<br/>}</span></pre><p id="cb0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构造函数的标识符或命名部分是匿名的。命名构造函数可能有参数，但在这种情况下，没有参数。因为没有任何容易混淆的参数名，所以不需要使用this.id或this.name，而是直接使用属性变量id和name。像这样调用main中的命名构造函数:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="6815" class="mm kl hi mi b fi mn mo l mp mq">final anonymousUser = User.anonymous();<br/>print(anonymousUser);</span></pre><h1 id="2a47" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">静态成员</h1><p id="34dd" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">如果将static放在成员变量或方法的前面，会导致变量或方法属于类而不是实例:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="0598" class="mm kl hi mi b fi mn mo l mp mq">class SomeClass {<br/>    static int myProperty = 0;<br/>    static void myMethod() {<br/>        print('Hello, Dart!');<br/>    }<br/>}</span></pre><p id="8fcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以这样访问它们:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="2ff8" class="mm kl hi mi b fi mn mo l mp mq">final value = SomeClass.myProperty;<br/>SomeClass.myMethod();</span></pre><p id="13a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，您不必实例化一个对象来访问myProperty或调用myMethod。相反，您可以直接使用类名来获取值并调用方法。</p><h1 id="a779" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">收集</h1><p id="089c" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">在您制作的几乎每个应用程序中，您都将处理数据集合。数据可以用多种方式组织，每种方式都有不同的用途。Dart提供了多种解决方案来满足您的收藏需求，在本章中，您将了解三种主要的解决方案:列表、集合和地图。</p><h1 id="6804" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">列表</h1><p id="e7c9" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">每当您有一个非常大的单一类型的对象集合，并且这些对象有一个相关的排序时，您可能会希望使用一个列表作为数据结构来对对象进行排序。Dart中的列表类似于其他语言中的数组。</p><p id="1f46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了一个包含六个元素的列表。列表是从零开始的，所以第一个元素在索引0处。第一个元素的值是cake，第二个元素的值是pie，依此类推，直到索引5处的最后一个元素，即cookie。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mu"><img src="../Images/97a9445d922ca0eed3c5ba7659c5e617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7GJ3NeTAz-2SC0zG"/></div></div></figure><p id="a318" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">列表的顺序很重要。馅饼在蛋糕之后，但在甜甜圈之前。如果多次遍历列表，可以确保元素保持在相同的位置和顺序。</p><h1 id="fca4" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">创建列表</h1><p id="1f07" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">您可以通过在方括号中指定列表的初始元素来创建列表。这被称为列表文字。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="589e" class="mm kl hi mi b fi mn mo l mp mq">var desserts = ['cookies', 'cupcakes', 'donuts', 'pie'];</span></pre><p id="f6ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于这个列表中的所有元素都是字符串，Dart推断这是一个字符串类型的列表。</p><p id="f6a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以重新分配甜点(但是为什么会有人想要重新分配甜点呢？)带有一个空列表，如下所示:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="1dfc" class="mm kl hi mi b fi mn mo l mp mq">desserts = [];</span></pre><p id="ed1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Dart还是知道甜品是一串的。但是，如果您要像这样初始化一个新的空列表:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="d86b" class="mm kl hi mi b fi mn mo l mp mq">var snacks = [];</span></pre><p id="bbb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Dart没有足够的信息来知道列表应该包含哪种对象。在这种情况下，Dart简单地推断它是一个动态列表。这会导致您失去类型安全，这是您不希望的。如果您从一个空列表开始，您应该像这样指定类型:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="676f" class="mm kl hi mi b fi mn mo l mp mq">List&lt;String&gt; snacks = [];</span></pre><p id="aea9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有几个细节需要注意:</p><ul class=""><li id="b8ce" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated">List是数据类型或类名，正如您之前所学的。</li><li id="d6d0" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">这里的尖括号&lt; &gt;是Dart中泛型类型的符号。通用列表意味着你可以有一个任何东西的列表；你只需把你想要的类型放在尖括号里。在这种情况下，您有一个字符串列表，但是您可以用任何其他类型替换String。例如，List <int>将生成一个整数列表，List <bool>将生成一个布尔值列表，List <grievance>将生成一个不满列表——但是您必须自己定义该类型，因为默认情况下Dart没有附带任何类型。</grievance></bool></int></li></ul><p id="fb66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建空列表的一个稍微好一点的语法是使用var或final并将泛型类型移到右边:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="1aa5" class="mm kl hi mi b fi mn mo l mp mq">var snacks = &lt;String&gt;[];</span></pre><h1 id="5413" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">访问元素</h1><p id="eac1" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">要访问列表的元素，可以通过下标符号引用它的索引，其中索引号放在列表名称后面的方括号中。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="4bb7" class="mm kl hi mi b fi mn mo l mp mq">final secondElement = desserts[1];<br/>print(secondElement);</span></pre><p id="a8bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要忘记列表是从零开始的，所以索引1获取第二个元素。运行该代码，您将看到预期的纸杯蛋糕。</p><p id="8b78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果知道值但不知道索引，可以使用indexOf方法来查找:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="2ec8" class="mm kl hi mi b fi mn mo l mp mq">final index = desserts.indexOf('pie')<br/>final value = desserts[index];;</span></pre><p id="4517" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为“pie”是从零开始的列表中的第四项，所以index是3，value是pie。</p><h1 id="550d" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">为列表元素赋值</h1><p id="327b" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">正如访问元素一样，也可以使用下标符号为特定元素赋值:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="4003" class="mm kl hi mi b fi mn mo l mp mq">desserts[1] = 'cake';</span></pre><p id="719b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这会将索引1处的值从cupcakes更改为cake。</p><h1 id="e2ea" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">向列表中添加元素</h1><p id="9ed6" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">默认情况下，Dart中的列表是可增长的，因此可以使用add方法添加元素。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="f41d" class="mm kl hi mi b fi mn mo l mp mq">desserts.add('brownies');</span></pre><p id="b9a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行它，你会看到:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="f562" class="mm kl hi mi b fi mn mo l mp mq">[cookies, cake, donuts, pie, brownies]</span></pre><h1 id="a538" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">从列表中删除元素</h1><p id="6b4a" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">可以使用remove方法删除元素。所以如果你有点饿了，吃了蛋糕，你可以写:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="a161" class="mm kl hi mi b fi mn mo l mp mq">desserts.remove('cake');<br/>print(desserts);</span></pre><p id="7104" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这留下了一个包含四个元素的列表:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="2906" class="mm kl hi mi b fi mn mo l mp mq">[cookies, donuts, pie, brownies]</span></pre><h1 id="71ae" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">列表属性</h1><p id="6d1b" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">List之类的集合有许多属性。为了演示它们，使用下面的饮料列表。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="5050" class="mm kl hi mi b fi mn mo l mp mq">const drinks = ['water', 'milk', 'juice', 'soda'];</span></pre><p id="75b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以访问列表中的第一个和最后一个元素:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="ea67" class="mm kl hi mi b fi mn mo l mp mq">drinks.first   // water<br/>drinks.last    // soda</span></pre><p id="5320" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还可以检查列表是否为空:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="7925" class="mm kl hi mi b fi mn mo l mp mq">drinks.isEmpty      // false<br/>drinks.isNotEmpty   // true</span></pre><p id="d4d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这相当于以下内容:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="c9fa" class="mm kl hi mi b fi mn mo l mp mq">drinks.length == 0   // false<br/>drinks.length &gt; 0    // true</span></pre><h1 id="39b9" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">遍历列表中的元素</h1><p id="2e47" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">在这一部分，你可以回到你的甜点清单:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="ccb0" class="mm kl hi mi b fi mn mo l mp mq">const desserts = ['cookies', 'cupcakes', 'donuts', 'pie'];</span></pre><p id="8133" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在for循环部分，您看到了如何遍历列表，所以这是对for-in循环的回顾。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="0df2" class="mm kl hi mi b fi mn mo l mp mq">for (var dessert in desserts) {<br/>    print(dessert);<br/>}</span></pre><p id="0624" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次循环时，甜点都被赋予一个来自甜点的元素。</p><p id="1a54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您也可以使用forEach函数:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="39c1" class="mm kl hi mi b fi mn mo l mp mq">desserts.forEach((dessert) =&gt; print(dessert));</span></pre><h1 id="b659" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">设置</h1><p id="cafc" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">集合用于创建唯一元素的集合。Dart中的集合类似于它们的数学对应物。与允许重复的列表不同，集合中不允许重复。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mu"><img src="../Images/194ad2c1c656c7703194cbb3bfb5ed06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3hO3pKQmueFyFJHw"/></div></div></figure><h1 id="aa14" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">创建集合</h1><p id="3ad9" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">您可以在Dart中使用集合类型注释创建空集，如下所示:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="cb7b" class="mm kl hi mi b fi mn mo l mp mq">final Set&lt;int&gt; someSet = {};</span></pre><p id="ed80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尖括号中带有int的通用语法告诉Dart在集合中只允许整数。以下形式较短，但结果相同:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="7061" class="mm kl hi mi b fi mn mo l mp mq">final someSet = &lt;int&gt;{};<br/>final anotherSet = {1, 2, 3};</span></pre><h1 id="ba4b" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">集合上的运算</h1><p id="3e5f" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">要查看一个集合是否包含一个项，可以使用contains方法，该方法返回一个bool。添加以下两行，并再次运行代码:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="e42d" class="mm kl hi mi b fi mn mo l mp mq">print(anotherSet.contains(1)); // true<br/>print(anotherSet.contains(99)); // false</span></pre><p id="54eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为anotherSet包含1，所以该方法返回true，而检查99返回false。</p><p id="860f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与可增长列表一样，您可以在集合中添加和删除元素。若要添加元素，请使用add方法。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="43c9" class="mm kl hi mi b fi mn mo l mp mq">final someSet = &lt;int&gt;{};<br/>someSet.add(42);<br/>someSet.add(2112);<br/>someSet.add(42);<br/>print(someSet);</span></pre><p id="ae9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行该程序以查看以下设置:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="69b7" class="mm kl hi mi b fi mn mo l mp mq">{42, 2112}</span></pre><p id="5fbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意,“42”被添加了一次。这是因为set保存每个项目一次，如果你试图添加重复的项目，set会忽略它。</p><p id="6b90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也可以使用remove方法删除元素:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="f57a" class="mm kl hi mi b fi mn mo l mp mq">someSet.remove(2112);</span></pre><p id="a5f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打印someSet以显示只剩下一个元素:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="99e0" class="mm kl hi mi b fi mn mo l mp mq">{42}</span></pre><p id="fe02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用addAll将列表中的元素添加到集合中:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="da92" class="mm kl hi mi b fi mn mo l mp mq">someSet.addAll([1, 2, 3, 4]);</span></pre><p id="1846" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再次打印someSet以显示新内容:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="11c5" class="mm kl hi mi b fi mn mo l mp mq">{42, 1, 2, 3, 4}</span></pre><h1 id="5715" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">地图</h1><p id="ac14" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">Dart中的映射是用于保存键值对的数据结构。它们类似于其他语言中的散列表和字典。</p><p id="b95a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果您不熟悉地图，您可以将它们视为包含数据的变量集合。键是变量名，值是变量保存的数据。查找特定值的方法是为映射提供映射到该值的键的名称。</p><p id="fc50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下图中，蛋糕映射到500卡路里，甜甜圈映射到150卡路里。蛋糕和甜甜圈是键，而500和150是值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mu"><img src="../Images/d7f20471a8876ec469cda93f93d5652d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l3RZOpDeoIVa9cWD"/></div></div></figure><p id="f75a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每对中的键和值用冒号分隔，连续的键-值对用逗号分隔。</p><h1 id="c721" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">创建空地图</h1><p id="e096" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">像List和Set一样，Map是一个泛型类型，但是Map有两个类型参数:一个用于键，一个用于值。您可以使用map并指定键和值的类型来创建空的Map变量:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="e757" class="mm kl hi mi b fi mn mo l mp mq">final Map&lt;String, int&gt; emptyMap = {};</span></pre><p id="1581" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本例中，String是键的类型，int是值的类型。做同样事情的一个稍微简单的方法是将泛型类型移到右边:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="e2e2" class="mm kl hi mi b fi mn mo l mp mq">final emptyMap = &lt;String, int&gt;{};</span></pre><p id="dc0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以使用大括号创建非空的map变量，其中Dart推断键和值类型。Dart知道这是一个映射，因为每个元素都是由冒号分隔的一对。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="8333" class="mm kl hi mi b fi mn mo l mp mq">final inventory = {<br/>    'cakes': 20,<br/>    'pies': 14,<br/>    'donuts': 37,<br/>    'cookies': 141,<br/>};</span></pre><h1 id="a621" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">唯一键</h1><p id="58e3" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">映射的键应该是唯一的。如下所示的地图不起作用:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="7a3d" class="mm kl hi mi b fi mn mo l mp mq">final treasureMap = {<br/>    'garbage': 'in the dumpster',<br/>    'glasses': 'on your head',<br/>    'gold': 'in the cave',<br/>    'gold': 'under your mattress',<br/>};</span></pre><p id="a7ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两把钥匙叫黄金。你怎么知道去哪里找？你可能在想，“嘿，这是金子。我两个地方都看。”如果您真的想这样设置，那么您可以将String映射到List:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="5300" class="mm kl hi mi b fi mn mo l mp mq">final treasureMap = {<br/>    'garbage': ['in the dumpster'],<br/>    'glasses': ['on your head'],<br/>    'gold': ['in the cave', 'under your mattress'],<br/>};</span></pre><p id="8992" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在每个键都包含一个条目列表，但是键本身是唯一的。值没有唯一性的限制。这很好:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="7efa" class="mm kl hi mi b fi mn mo l mp mq">final myHouse = {<br/>    'bedroom': 'messy',<br/>    'kitchen': 'messy',<br/>    'living room': 'messy',<br/>    'code': 'clean',<br/>};</span></pre><h1 id="906a" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">地图上的操作</h1><p id="e56a" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">除了使用键而不是索引的映射之外，您可以使用类似于列表的下标符号来访问映射中的单个元素。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="752d" class="mm kl hi mi b fi mn mo l mp mq">final numberOfCakes = inventory['cakes'];</span></pre><p id="b24e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您回忆一下上面的内容，密钥cakes被映射到整数20，因此打印numberOfCakes可以看到20。如果键不存在，映射将返回null。</p><p id="ebbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只需将新元素分配给地图中尚不存在的元素，就可以将新元素添加到地图中。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="af63" class="mm kl hi mi b fi mn mo l mp mq">inventory['brownies'] = 3;</span></pre><p id="0147" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打印库存以查看地图末尾的布朗尼及其价值:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="fdd7" class="mm kl hi mi b fi mn mo l mp mq">{cakes: 20, pies: 14, donuts: 37, cookies: 141, brownies: 3}</span></pre><p id="8e28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，映射的键是唯一的，因此如果您为已经存在的键赋值，将会覆盖现有的值。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="8574" class="mm kl hi mi b fi mn mo l mp mq">inventory['cakes'] = 1;</span></pre><p id="4d2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打印库存以确认蛋糕原来是20，但现在是1:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="c9e8" class="mm kl hi mi b fi mn mo l mp mq">{cakes: 1, pies: 14, donuts: 37, cookies: 141, brownies: 3}</span></pre><p id="ac29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用remove通过键从地图中移除元素。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="563e" class="mm kl hi mi b fi mn mo l mp mq">inventory.remove('cookies');</span></pre><p id="79b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和结果:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="ac81" class="mm kl hi mi b fi mn mo l mp mq">{cakes: 1, pies: 14, donuts: 37, brownies: 3}</span></pre><h1 id="93c2" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">地图属性</h1><p id="a440" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">和列表一样，地图也有属性。例如，以下属性指示(使用不同的度量)地图是否为空:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="3332" class="mm kl hi mi b fi mn mo l mp mq">inventory.isEmpty     // false<br/>inventory.isNotEmpty  // true<br/>inventory.length      // 4</span></pre><p id="8608" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还可以使用键和值属性分别访问键和值。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="7824" class="mm kl hi mi b fi mn mo l mp mq">print(inventory.keys);<br/>print(inventory.values);</span></pre><p id="71a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您将它打印出来时，您会看到以下内容:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="4b2f" class="mm kl hi mi b fi mn mo l mp mq">(cakes, pies, donuts, brownies)<br/>(1, 14, 37, 3)</span></pre><p id="a42c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要检查某个键是否在映射中，可以使用containsKey方法:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="1b6a" class="mm kl hi mi b fi mn mo l mp mq">print(inventory.containsKey('pies'));<br/>// true</span></pre><p id="ff5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用containsValue对值执行同样的操作。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="7d70" class="mm kl hi mi b fi mn mo l mp mq">print(inventory.containsValue(42));<br/>// false</span></pre><h1 id="e02a" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">在地图元素上循环</h1><p id="9485" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">映射的键和值属性是可迭代的，因此可以对它们进行循环。下面是一个迭代键的例子:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="2fdd" class="mm kl hi mi b fi mn mo l mp mq">for (var item in inventory.keys) {<br/>    print(inventory[item]);<br/>}</span></pre><p id="aba0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还可以使用forEach来迭代map的元素，这将为您提供键和值。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="a5d6" class="mm kl hi mi b fi mn mo l mp mq">inventory.forEach((key, value) =&gt; print('$key -&gt; $value'));</span></pre><p id="3174" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个for循环做同样的事情:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="236d" class="mm kl hi mi b fi mn mo l mp mq">for (final entry in inventory.entries) {<br/>    print('${entry.key} -&gt; ${entry.value}');<br/>}</span></pre><p id="0cc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行任一循环都会产生以下结果:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="1152" class="mm kl hi mi b fi mn mo l mp mq">cakes -&gt; 1<br/>pies -&gt; 14<br/>donuts -&gt; 37<br/>brownies -&gt; 3</span></pre><h1 id="12b1" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">集合上的映射</h1><p id="f268" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">通过集合映射，您可以对集合中的每个元素执行操作，就像通过循环运行一样。为此，集合有一个map方法，该方法将匿名函数作为参数，并根据该函数对元素的操作返回另一个集合。编写以下代码:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="2660" class="mm kl hi mi b fi mn mo l mp mq">const numbers = [1, 2, 3, 4];<br/>final squares = numbers.map((number) =&gt; number * number);</span></pre><p id="66c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在匿名函数体内，你可以做任何你想做的事情。在上面的例子中，你平方每个输入值。打印正方形以查看结果:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="faeb" class="mm kl hi mi b fi mn mo l mp mq">(1, 4, 9, 16)</span></pre><h1 id="3406" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">过滤收藏</h1><p id="4e26" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">通过使用where方法，您可以过滤类似List的可迭代集合，并将其设置为另一个更短的集合。在您已经拥有的代码下面添加下面一行:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="50ec" class="mm kl hi mi b fi mn mo l mp mq">final evens = squares.where((square) =&gt; square.isEven);</span></pre><p id="63ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数的输入也是列表中的每个元素，但是与map不同，该函数返回的值必须是布尔值。如果函数为特定元素返回true，那么该元素将被添加到结果集合中，但是如果返回false，那么该元素将被排除。使用isEven使偶数的条件为真，所以您已经将平方过滤为偶数值。打印evens，您将获得:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="20c5" class="mm kl hi mi b fi mn mo l mp mq">(4, 16)</span></pre><h1 id="beff" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">对列表进行排序</h1><p id="c5b1" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">对列表调用sort会根据数据类型对元素进行排序。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="894e" class="mm kl hi mi b fi mn mo l mp mq">final desserts = ['cookies', 'pie', 'donuts', 'brownies'];<br/>desserts.sort();</span></pre><p id="4bf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打印甜点，你会看到以下内容:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="4bdf" class="mm kl hi mi b fi mn mo l mp mq">[brownies, cookies, donuts, pie]</span></pre><p id="a327" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于甜点保存字符串，调用列表上的sort会按字母顺序排列它们。排序是就地完成的，这意味着排序会改变输入列表本身。这也意味着如果你试图排序一个常量列表，你会得到一个错误。</p><p id="0f33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用reversed以相反的顺序生成列表。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="1bd7" class="mm kl hi mi b fi mn mo l mp mq">var dessertsReversed = desserts.reversed;</span></pre><p id="e572" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这会产生以下结果:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="1596" class="mm kl hi mi b fi mn mo l mp mq">(pie, donuts, cookies, brownies)</span></pre><h1 id="546f" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">高级课程</h1><p id="939e" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">在许多情况下，您需要创建共享一些基本功能的类的层次结构。您可以通过扩展类来创建自己的层次结构。这也称为继承，因为这些类形成了一棵树，其中的子类继承父类。父类和子类也分别称为超类和子类。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mv"><img src="../Images/663e5dcf33707164a520261a1a4ec31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IYsiK-b8a-TvF3Kz"/></div></div></figure><h1 id="1fe6" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">创建您的第一个子类</h1><p id="eee6" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">这里我们有一个Person类，它有两个给定的字段Name和surname:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="61af" class="mm kl hi mi b fi mn mo l mp mq">class Person {<br/>    Person(this.givenName, this.surname);</span><span id="3795" class="mm kl hi mi b fi mr mo l mp mq">    String givenName;<br/>    String surname;<br/>    String get fullName =&gt; '$givenName $surname';</span><span id="bfdb" class="mm kl hi mi b fi mr mo l mp mq">    @override<br/>    String toString() =&gt; fullName;<br/>}</span></pre><p id="7eb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们添加与Person具有相同字段的Student class，外加一个grade字段:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="62ea" class="mm kl hi mi b fi mn mo l mp mq">class Student {<br/>    Student(this.givenName, this.surname);</span><span id="b38a" class="mm kl hi mi b fi mr mo l mp mq">    String givenName;<br/>    String surname;<br/>    String grade = 'F';<br/>    String get fullName =&gt; '$givenName $surname';</span><span id="d84b" class="mm kl hi mi b fi mr mo l mp mq">    @override<br/>    String toString() =&gt; fullName;<br/>}</span></pre><p id="a111" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过让学生扩展Person，可以消除学生和Person之间的重复。通过在类名后添加extends Person，并删除除学生构造函数和等级之外的所有内容，可以做到这一点。用以下代码替换Student类:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="779e" class="mm kl hi mi b fi mn mo l mp mq">class Student extends Person {<br/>    Student(String givenName, String surname)<br/>         : super(givenName, surname);<br/></span><span id="1f08" class="mm kl hi mi b fi mr mo l mp mq">    String grade = 'F';<br/>}</span></pre><p id="0a7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有几点需要注意:</p><ul class=""><li id="93c0" class="lt lu hi ih b ii ij im in iq lv iu lw iy lx jc ly lz ma mb bi translated">构造函数参数名不再引用它。每当您看到关键字this时，您应该记住这是指当前对象，在本例中是Student类的一个实例。由于Student不再包含字段名称givenName和surname，使用this.givenName或this.surname将没有任何引用。</li><li id="edf6" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">与此相反，super关键字用于引用层次结构中的上一级。类似于您在上面的中学习的转发构造函数，使用super(givenName，surname)将构造函数参数传递给另一个构造函数。但是，因为您使用的是super而不是this，所以您将参数转发给父类的构造函数，也就是Person的构造函数。</li></ul><h1 id="99e7" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">使用类</h1><p id="d44c" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">好，回到最初的例子。像这样创建人和学生对象:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="5e94" class="mm kl hi mi b fi mn mo l mp mq">final jon = Person('Jon', 'Snow');<br/>final jane = Student('Jane', 'Snow');<br/>print(jon.fullName);<br/>print(jane.fullName);</span></pre><p id="ba07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行并观察两者都有全名:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="fce2" class="mm kl hi mi b fi mn mo l mp mq">Jon Snow<br/>Jane Snow</span></pre><h1 id="dd56" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">覆盖父方法</h1><p id="6450" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">假设您希望学生的全名以不同于默认的方式打印出来。您可以通过重写全名getter来实现这一点。将以下两行添加到学生类的底部:</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="f480" class="mm kl hi mi b fi mn mo l mp mq">@override<br/>String get fullName =&gt; '$surname, $givenName';</span></pre><p id="699b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">@override '告诉编译器使用这个实现而不是父函数。虽然在Dart中使用@override在技术上是可选的，但它确实有所帮助，因为如果您认为您正在覆盖父类中实际上不存在的内容，编译器会给出一个错误。</p><p id="d89a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在运行代码，您会看到学生的全名与家长的不同。</p><pre class="je jf jg jh fd mh mi mj mk aw ml bi"><span id="adfc" class="mm kl hi mi b fi mn mo l mp mq">Jon Snow<br/>Snow, Jane</span></pre></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h1 id="480a" class="kk kl hi bd km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld na lf lg lh bi translated">结论</h1><p id="2244" class="pw-post-body-paragraph if ig hi ih b ii li ik il im lj io ip iq lk is it iu ll iw ix iy lm ja jb jc hb bi translated">感谢您花时间阅读这篇文章。我将努力帮助您更加熟悉Dart编程语言。我之前提到过，这本书是对原书的总结，给那些因为时间不够而想快速浏览这本书的人。如果你有足够的时间来学习更深入的主题，请花时间阅读这本书。谢谢你的鼓励，我期待着你的有用的评论。</p></div></div>    
</body>
</html>