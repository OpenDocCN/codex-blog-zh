<html>
<head>
<title>Traversing a Forest of Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遍历数据森林</h1>
<blockquote>原文：<a href="https://medium.com/codex/traversing-a-forest-of-data-92ed41572e10?source=collection_archive---------2-----------------------#2021-02-22">https://medium.com/codex/traversing-a-forest-of-data-92ed41572e10?source=collection_archive---------2-----------------------#2021-02-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="1ee9" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><figure class="ev ex ip iq ir is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es io"><img src="../Images/c4e713787a7a02e46fb5af95ff80b628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uxkCVKJ_fC2LXcqr"/></div></div><figcaption class="iz ja et er es jb jc bd b be z dx translated"><a class="ae jd" href="https://unsplash.com/@michaelbenz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克尔·本茨</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="8540" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">Javascript中关于二分搜索法树的所有内容</h1></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="a649" class="je jf hi bd jg jh kj jj jk jl kk jn jo jp kl jr js jt km jv jw jx kn jz ka kb bi translated">结构的整体性</h1><p id="97db" class="pw-post-body-paragraph ko kp hi kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll hb bi translated">编程和数据存储是相辅相成的。关于哪种数据结构被认为是最好的，有许多不同的学派。在这种情况下,“最佳”通常与结构的时间复杂度有关，或者解释程序在存储器中处理或定位单个数据块需要多长时间。由于计算机只能在规定的时间内运行有限的动作，所以效率是编写代码时的“游戏名称”。效率可以以多种形式出现，但是就数据结构而言，当考虑对其中的数据进行操作的时间复杂性时，有三个主要关注点。这些包括数据的遍历、数据片段的删除和新数据片段的插入，所有这些都发生在结构中。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="433a" class="je jf hi bd jg jh kj jj jk jl kk jn jo jp kl jr js jt km jv jw jx kn jz ka kb bi translated">二叉查找树</h1><p id="c618" class="pw-post-body-paragraph ko kp hi kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll hb bi translated">一种广泛使用的数据结构类型是二叉查找树，从现在起将被称为BST。从它们的名字可以很快推断出BST是树状结构，这意味着它们是非线性的。换句话说，树状结构有相互分支的节点或实例。BST中节点之间的关联称为父/子关系。此外，当父节点有两个子节点时，子节点的结合可以被称为兄弟关系。这两个孩子通常被称为左孩子和右孩子。正如大多数人类家庭的情况一样，孩子们受到的待遇也大相径庭。这将在下面的章节中进一步探讨。</p><figure class="ln lo lp lq fd is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es lm"><img src="../Images/cd74a3e9404fffe7e94746d9cb68353d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kzqOEmhmKT8ClfB6O9PZgw.png"/></div></div><figcaption class="iz ja et er es jb jc bd b be z dx translated">图片src:<a class="ae jd" href="https://en.wikipedia.org/wiki/Binary_search_tree" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Binary_search_tree</a></figcaption></figure></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h2 id="c5f4" class="lr jf hi bd jg ls lt lu jk lv lw lx jo kz ly lz js ld ma mb jw lh mc md ka ho bi translated">关键原则</h2><p id="b061" class="pw-post-body-paragraph ko kp hi kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll hb bi translated">BST有几个关键原则，它们既定义了应该使用BST的情况，又将BST与其他数据存储技术区分开来。排名不分先后:</p><ol class=""><li id="f5d3" class="me mf hi kq b kr mg kv mh kz mi ld mj lh mk ll ml mm mn mo bi translated">每个数据段必须与所有其他数据段不同，这意味着它只能存在一次。</li><li id="db73" class="me mf hi kq b kr mp kv mq kz mr ld ms lh mt ll ml mm mn mo bi translated">每个节点可以有0、1或2个子节点。</li><li id="ac4c" class="me mf hi kq b kr mp kv mq kz mr ld ms lh mt ll ml mm mn mo bi translated">除了BST中的最后几个节点(也称为叶节点)，每个节点都有两个子节点。</li><li id="3d11" class="me mf hi kq b kr mp kv mq kz mr ld ms lh mt ll ml mm mn mo bi translated">第一个节点或根节点是比较值和决定下一步采取什么措施时使用的第一个值。</li><li id="9dc2" class="me mf hi kq b kr mp kv mq kz mr ld ms lh mt ll ml mm mn mo bi translated">左侧子节点的值将始终小于其父节点的值，而右侧子节点的值将始终大于其父节点的值。</li></ol><figure class="ln lo lp lq fd is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es mu"><img src="../Images/8107d6b97a75ada7703f6583c017d4c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qzpoLhANgCg1RPmt1gxiXQ.png"/></div></div><figcaption class="iz ja et er es jb jc bd b be z dx translated">显示BST节点的父/子/兄弟关系的图表</figcaption></figure><p id="524a" class="pw-post-body-paragraph ko kp hi kq b kr mg kt ku kv mh kx ky kz mv lb lc ld mw lf lg lh mx lj lk ll hb bi translated"><strong class="kq hs"> <em class="my">在BST中搜索、添加或删除时，使用二分搜索法。这意味着解释器将把一个值与根节点进行比较；如果它比根的值大，焦点将转移到右边的子节点，如果它比根的值小，则关注左边的子节点。这一直持续到解释器的目标完成，或者到达叶节点。本质上，这意味着每次比较后必须处理的数据量减半，这有利于数据结构的时间复杂度。</em>T3】</strong></p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h2 id="c7de" class="lr jf hi bd jg ls lt lu jk lv lw lx jo kz ly lz js ld ma mb jw lh mc md ka ho bi translated">主要方法</h2><p id="a5e1" class="pw-post-body-paragraph ko kp hi kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll hb bi translated">BST或任何数据存储方法都是可以利用的工具。为了让它们在实际应用中真正有用，它们必须完成三个主要操作:遍历、插入和删除存储在其中的数据。BSTs通常有一个动作方法(<strong class="kq hs"><em class="my">【depthFirstLog(callback)</em></strong>)，该方法接受回调函数并通过它传递每条数据。它们通常还有一个contains方法(<strong class="kq hs"><em class="my">【contains(value)】</em></strong>)和一个insert方法(<strong class="kq hs"><em class="my">【insert(value)】</em></strong>)，每个方法都接受一个值作为唯一的参数。删除方法有时包括在内。在实现BST时，还会使用节点构造函数来创建新的BST实例。它与创建最终产品BST的方法配合使用。BST创建函数的实现如下所示:</p><pre class="ln lo lp lq fd mz na nb nc aw nd bi"><span id="8177" class="lr jf hi na b fi ne nf l ng nh">const BinarySearchTree = (value) =&gt; {</span><span id="ae21" class="lr jf hi na b fi ni nf l ng nh">var BST = Object.create(BinarySearchTree.prototype);</span><span id="0cf8" class="lr jf hi na b fi ni nf l ng nh">BST.value = value;<br/>  BST.right = null;<br/>  BST.left = null;</span><span id="8daf" class="lr jf hi na b fi ni nf l ng nh">return BST;</span><span id="b836" class="lr jf hi na b fi ni nf l ng nh">};</span></pre><p id="4482" class="pw-post-body-paragraph ko kp hi kq b kr mg kt ku kv mh kx ky kz mv lb lc ld mw lf lg lh mx lj lk ll hb bi translated">正如您所看到的，右边和左边的节点都用null值初始化。Null将总是被传递到叶节点，因此当访问BST中的值时，null将是基本情况，这意味着递归将在到达值为null的节点时停止。</p><p id="fe23" class="pw-post-body-paragraph ko kp hi kq b kr mg kt ku kv mh kx ky kz mv lb lc ld mw lf lg lh mx lj lk ll hb bi translated">接下来，可以将方法添加到构造函数的原型中:</p><pre class="ln lo lp lq fd mz na nb nc aw nd bi"><span id="1c65" class="lr jf hi na b fi ne nf l ng nh">// Insert //<br/>BinarySearchTree.prototype.insert = (value) =&gt; {<br/>};</span><span id="76e3" class="lr jf hi na b fi ni nf l ng nh">// Contains //<br/>BinarySearchTree.prototype.contains = (value) =&gt; {<br/>};</span><span id="85f5" class="lr jf hi na b fi ni nf l ng nh">// Depth First Log //<br/>BinarySearchTree.prototype.depthFirstLog = (callback) =&gt; {<br/>};</span></pre><h2 id="c04c" class="lr jf hi bd jg ls lt lu jk lv lw lx jo kz ly lz js ld ma mb jw lh mc md ka ho bi translated">插入</h2><p id="22fd" class="pw-post-body-paragraph ko kp hi kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll hb bi translated">insert方法将接受一个值，该值将被添加到现有的BST中。首先，它将检查树是否为空。如果是，它将创建一个新的树，将传入的值放在根节点中。但是，如果树不为空，该方法会将传递给它的值与根的值进行比较。如果它大于根的值，它将会看向根的右子节点。如果它小于根的值，它将向根的左子节点看。这将继续下去，直到右边或左边的孩子不再存在，此时新值将被添加到树中。</p><p id="f829" class="pw-post-body-paragraph ko kp hi kq b kr mg kt ku kv mh kx ky kz mv lb lc ld mw lf lg lh mx lj lk ll hb bi translated">时间复杂度—线性(O(n))；平均情况:O(log n)</p><h2 id="bce6" class="lr jf hi bd jg ls lt lu jk lv lw lx jo kz ly lz js ld ma mb jw lh mc md ka ho bi translated">包含</h2><p id="ec51" class="pw-post-body-paragraph ko kp hi kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll hb bi translated">contains方法将以与insert方法相同的方式遍历BST。它将与root进行比较，并相应地向左或向右移动。这两种方法的主要区别在于，insert操作BST并且不返回任何内容，而contains只是查看BST并返回一个布尔值，这取决于它是否能够在BST中找到传入的值。</p><p id="035a" class="pw-post-body-paragraph ko kp hi kq b kr mg kt ku kv mh kx ky kz mv lb lc ld mw lf lg lh mx lj lk ll hb bi translated">时间复杂度—线性(O(n))；平均情况:O(log n)</p><h2 id="7f39" class="lr jf hi bd jg ls lt lu jk lv lw lx jo kz ly lz js ld ma mb jw lh mc md ka ho bi translated">深度第一测井</h2><p id="81bb" class="pw-post-body-paragraph ko kp hi kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll hb bi translated">depthFirstLog方法的行为必须不同于contains和insert。这是由其性质决定的；因为必须对BST中的所有值采取行动，所以解释器不能简单地执行二分搜索法。相反，它必须沿着每个分支向下，将值传递给回调函数，然后沿着分支向上移动，再沿着它的兄弟节点向下移动。这将一直持续到树的最末端。为了向下移动，然后返回一个分支，递归应该用于该方法的实现。</p><p id="b485" class="pw-post-body-paragraph ko kp hi kq b kr mg kt ku kv mh kx ky kz mv lb lc ld mw lf lg lh mx lj lk ll hb bi translated">时间复杂度—线性(O(n))；平均情况:O(log n)</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="af0e" class="pw-post-body-paragraph ko kp hi kq b kr mg kt ku kv mh kx ky kz mv lb lc ld mw lf lg lh mx lj lk ll hb bi translated">二分搜索法树是非常有用的数据存储结构形式。当访问存储在其中的数据时，它们可以保持合理的时间复杂度。如果处理大量的数据，必须相对快速地调用和/或遍历这些数据，它们尤其适用。大多数程序员都会从掌握二分搜索法树艺术中受益匪浅。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><pre class="ln lo lp lq fd mz na nb nc aw nd bi"><span id="1494" class="lr jf hi na b fi ne nf l ng nh"><strong class="na hs"><em class="my">References:</em></strong></span><span id="c2eb" class="lr jf hi na b fi ni nf l ng nh">[1]: Pawar, Prakash. “How Binary Search Trees Work in JavaScript - JavaScript in Plain English.” <em class="my">Medium</em>, Javascript in Plain English, 7 Feb. 2019, js.plainenglish.io/binary-search-tree-in-javascript-ca5aa7ba05de.</span><span id="3b42" class="lr jf hi na b fi ni nf l ng nh"><strong class="na hs"><em class="my">Further Reading:</em></strong></span><span id="2284" class="lr jf hi na b fi ni nf l ng nh">- Hall, Joshua. “Binary Search Trees Through JavaScript.” <em class="my">DigitalOcean</em>, 23 Jan. 2021, www.digitalocean.com/community/tutorials/js-binary-search-trees.</span><span id="e6f0" class="lr jf hi na b fi ni nf l ng nh">- Han, Tim. “JavaScript: What Is a Binary Search Tree? - JavaScript in Plain English.” <em class="my">Medium</em>, Javascript in Plain English, 11 Apr. 2019, js.plainenglish.io/javascript-what-is-a-binary-search-tree-a602155abae4.</span><span id="d2b8" class="lr jf hi na b fi ni nf l ng nh">- Jay. “Detailed Binary Search Tree Guide in JavaScript.” <em class="my">The Coding Delight</em>, 27 Mar. 2019, <a class="ae jd" href="http://www.thecodingdelight.com/binary-search-tree-implementation-javascript." rel="noopener ugc nofollow" target="_blank">www.thecodingdelight.com/binary-search-tree-implementation-javascript.</a></span><span id="1637" class="lr jf hi na b fi ni nf l ng nh">- Mejia, Adrian. “Tree Data Structures in JavaScript for Beginners.” <em class="my">Adrian Mejia Blog</em>, 23 May 2019, adrianmejia.com/data-structures-for-beginners-trees-binary-search-tree-tutorial.</span><span id="8a70" class="lr jf hi na b fi ni nf l ng nh">- Mitrakos, Michael. “Implement a Binary Search Tree in JavaScript - InitJS.” <em class="my">Medium</em>, 23 Feb. 2020, initjs.org/implement-a-binary-search-tree-in-javascript-952a44ee7c26.</span><span id="2cfa" class="lr jf hi na b fi ni nf l ng nh">- Pawar, Prakash. “How Binary Search Trees Work in JavaScript - JavaScript in Plain English.” <em class="my">Medium</em>, Javascript in Plain English, 7 Feb. 2019, js.plainenglish.io/binary-search-tree-in-javascript-ca5aa7ba05de.</span><span id="8f8b" class="lr jf hi na b fi ni nf l ng nh">- Zakas, Nicholas. “Computer Science in JavaScript: Binary Search Tree, Part 1.” <em class="my">Human Who Codes</em>, 9 June 2009, humanwhocodes.com/blog/2009/06/09/computer-science-in-javascript-binary-search-tree-part-1.</span></pre></div></div>    
</body>
</html>