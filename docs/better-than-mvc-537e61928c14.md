# 比 MVC 更好

> 原文：<https://medium.com/codex/better-than-mvc-537e61928c14?source=collection_archive---------7----------------------->

模型-视图-控制器是当今最流行的设计模式之一。大多数现代编程语言都有实现 MVC 的框架。今天，大多数开发人员理所当然地认为 MVC 将是新应用程序的模式。我对此没有问题，因为我认为这是实现关注点分离的好方法。

如果你问许多初级开发人员模型代表什么，他们会告诉你模型是那个实体的底层数据库表的表示。许多框架将数据库操作与模型联系在一起，为什么不呢？甚至[维基百科也将模型](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)定义为:

> “模式的中心组成部分。它是应用程序的动态数据结构，独立于用户界面。它直接管理应用程序的数据、逻辑和规则。”

我的争吵对象是我所谓的“重量级模特”在这里，模型不仅与数据库实现紧密耦合，还包含应用程序的逻辑和规则。当我提到业务逻辑时，我指的是逻辑和规则。我们的应用程序的业务逻辑与我们的数据库交织在一起。我们对实体的了解完全依赖于后备存储的实现。

这个后台存储甚至成为我们许多业务规则的实现。想要实现一些关于数据实体的特别棘手的业务逻辑吗？用您的数据库语言编写一个存储过程，并让它在幕后发生！虽然业绩增长可能相当可观，但吹笛者必须得到报酬。我确信应该在数据库级别实现逻辑的想法来自数据库供应商。他们肯定通过出售许可证赚了很多钱，一旦你这么做了，你就被套牢了。

> “一旦你开始走上黑暗之路，它将永远主宰你的命运，吞噬你。”-尤达

![](img/ea33f20d1fbb9d2f01e3295fc4ba868a.png)

尤达，讨论设计模式。

**一点历史**

在过去的日子里(哇，我一直这么说)，软件公司非常关心数据库不可知论者。应用程序构建为在客户的环境中运行，而不是在我们自己的托管服务器上运行。一家公司可以选择在单一供应商的数据库上运行，这将限制他们的市场，或者他们可以构建最低标准的应用程序，并在大量数据库上运行。将数据库访问层与应用程序的其余部分分离开来是实现这一目标的关键。我甚至看到了可怕的代码库，你会看到巨大的 switch 语句隐藏在业务逻辑中，比如在 Sybase 上这样做，在 DB2 上那样做，等等。ORMs 成为解决这个问题的流行方法。

但是我们在这个过程中失去了一些东西。开发人员开始将业务逻辑和数据访问放入他们的模型中。或者他们开始将业务逻辑放入他们的控制器中，这变成了一套对数据做各种事情的方法。

**缺陷从何而来？**

我们应用程序中最大的缺陷是什么？显然，这是商业逻辑。我们要么不理解需求，行为需要改变，要么我们在实现需求的方式上犯了错误。偶尔，我们实现数据访问的方式可能会有缺陷，但是大多数 ORM 隐藏了太多的复杂性，所以我们不会在上面花太多时间。UI 中的错误通常只是呈现同一事物的不同方式。

写申请最耗时的部分是什么？同样，这是商业逻辑。解决问题很容易。知道要解决什么是最难的部分，也是最花时间的。我们开发的大部分内容只是为了确定我们是否得到了正确的需求。

我确信，为什么这么多开发人员认为编写单元测试既费时又没什么好处，是因为他们正在努力理解业务逻辑。如果您的业务逻辑隐藏在您的控制器或模型中，那么将它们分离成易于测试的东西就变得非常困难。当你被绑定到一个数据库实现时，使用 TDD 是非常困难的，因为那些测试会运行得很慢。我们希望我们的测试运行得超快，因为我们希望保持一种高效的流动状态。

如果我们的业务逻辑在一个单独的层中，那么测试该层就不会依赖于用户界面或后备存储。

**MVCS 更好**

它没有 MVC 那么受关注，但是 MVCS 模式更胜一筹。S 代表服务。我们构建了一个服务层来处理应用程序的所有业务逻辑。这一切都在一个地方，它没有耦合到任何具体的东西。

在这种方法中，模型只包含数据访问组件。如果不使用 ORM，就不要在模型中使用。范围、索引、主键和关系通过 ORM 进入模型。控制器只接受请求，执行验证以确定请求是合法的，并返回响应。控制器不与模型对话，它总是通过服务层。

服务不消费请求，这取决于控制器。服务不直接访问数据实体，这取决于模型。将服务所做的一切都看作是内存中的操作。我们可以构建一个服务，而无需对数据库的设计做出任何决定。为了能够专注于服务，我们可以在测试中模拟任何我们需要的东西。服务与模型没有一对一的关系。一个服务可以调用很多模型，一个模型可以被很多服务调用。

更好的是，我可以使用行为驱动开发(BDD)并在实现测试时调用服务。现在，我已经有了一种方法来清楚地描述业务逻辑，验证我的服务确实在这样做，并与我的用户就我们是否已经获得了正确的需求进行对话。

能够有一个包含应用程序核心的单独的层，远离它将如何呈现或表格将看起来像什么的干扰，给了我们在过程早期粉碎那些缺陷的最好方法。如果我们需要进行不可避免的更改，这将变得容易得多，因为逻辑不会跨多个模型和数据库对象传播。

如果我们需要通过将逻辑放入数据库层来优化某些东西，比如存储过程或函数，我们仍然可以这样做。但是，只有在我们知道已经发现了真正的需求以及如何实现它之后，我们才应该这样做。一开始就在数据库中做这些工作只是不成熟的优化。很有可能，YAGNI。让它工作，让它正确，让它快。

**单一责任原则**

SRP 告诉我们[每个软件模块应该有且只有一个理由改变](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html)。如果我们将我们的业务逻辑分离到一个单独的服务层中，那么我们已经使遵守 SRP 变得相当容易。每个参与者都可以拥有自己的模块，其中包含该参与者所需的规则和逻辑。CFO 和 dock manager 都不关心我们如何实现 CRUD，他们只关心他们特定的业务逻辑。由于我们的服务层不依赖于特定的模型，我们可以通过 actor 来分离我们的服务，并调用相同的模型。模型不知道它们上面的层发生了什么。对于参与者来说，将要改变的部分与数据操作是分开的。

如果您遵循 SRP 并将您的逻辑放在您的模型中，那么您必须为访问相同数据的每个参与者实现一个单独的模型。然后你用 SRP 换了 DRY，这根本不是我们想要做的。

**这不是新的**

为服务建立一个独立层的想法已经存在很长时间了。但是有很多流行的框架(Laravel，我在看你)，没有这个概念。他们只是假设 MVC。考虑到如今大量自学成才的人编写代码，很容易理解为什么他们不考虑跳出框架来做这件事。(当然，在 Laravel 中，添加服务层非常容易。但是我的品牌:服务工匠指挥部呢？是第三方。)

这对于那些只做简单编码的小项目来说有必要吗？大概不会。当你想成为一名职业球员时，这只是一个问题。小项目的问题在于，如果它们成功了，很快就会变成大项目。如果您以这种模式开始这些项目，您会发现在开始时投入的时间并不多(真的，在您的 IDE 中创建一个新类需要多长时间？).中间和结尾的回报是可观的。