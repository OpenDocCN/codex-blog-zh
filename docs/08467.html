<html>
<head>
<title>How I Designed Optimistic Concurrency In Mongo With C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何用C#在Mongo中设计开放式并发的</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-i-designed-optimistic-concurrency-in-mongo-with-c-8b62c8aabc40?source=collection_archive---------4-----------------------#2022-08-10">https://medium.com/codex/how-i-designed-optimistic-concurrency-in-mongo-with-c-8b62c8aabc40?source=collection_archive---------4-----------------------#2022-08-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="59e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">处理您的交易</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a84b6df45d5eb94fa1e51e3cb82d5713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZASCesG5vMQg7Zyp_XURqA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae jt" href="https://stock.adobe.com/uk/contributor/200563983/abdul-qaiyoom?load_type=author&amp;prev_url=detail" rel="noopener ugc nofollow" target="_blank">阿卜杜勒·卡约姆</a>在<a class="ae jt" href="https://stock.adobe.com/" rel="noopener ugc nofollow" target="_blank"> stock.adobe </a>的照片</figcaption></figure><p id="23af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我一直喜欢使用mongo作为NOSQL数据库，当我开始学习mongo时，非常惊喜地发现它实际上可以处理<a class="ae jt" href="https://www.mongodb.com/docs/upcoming/core/transactions/" rel="noopener ugc nofollow" target="_blank">多文档事务</a>。</p><p id="d811" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问:好，那么我们为什么需要一个并发控制？</p><p id="836f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答:虽然拥有事务将确保我们保存的操作是自动执行的，但我们必须确保<strong class="ih hj">在读取、启动事务和保存之间的时间内，数据没有发生变化</strong>。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h2 id="e552" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">定义</h2><p id="2731" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">乐观并发控制是一种允许多个事务在互不干扰的情况下完成的控制。<strong class="ih hj"> </strong>事务不会在资源中设置锁，因此不会阻塞数据库上的任何资源。它主要依赖于在提交之前验证没有其他事务修改过它所读取的数据。如果发现任何冲突的修改，则提交事务回滚。</p><p id="5f1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阶段:</p><ul class=""><li id="1352" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated"><strong class="ih hj">开始</strong>:记录时间戳。</li><li id="d8f6" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><strong class="ih hj">修改</strong>:读取数据库资源，应用修改。</li><li id="4e40" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><strong class="ih hj">验证</strong>:检查数据是否被其他交易修改过。</li><li id="6db8" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><strong class="ih hj">提交/回滚</strong>:如果有冲突，中止事务。</li></ul></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h2 id="d477" class="kb kc hi bd kd ke kf kg kh ki kj kk kl iq km kn ko iu kp kq kr iy ks kt ku kv bi translated">设计概念</h2><ul class=""><li id="eab6" class="lb lc hi ih b ii kw im kx iq lp iu lq iy lr jc lg lh li lj bi translated">创建一个实施时间戳属性的基本实体</li><li id="b929" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">创建一个装饰器集合，在内部使用<code class="du ls lt lu lv b">IMongoCollection</code>并处理时间戳验证</li><li id="1641" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">创建一个助手类，用于轻松抛出一些异常</li></ul></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><blockquote class="lw lx ly"><p id="bfca" class="if ig lz ih b ii ij ik il im in io ip ma ir is it mb iv iw ix mc iz ja jb jc hb bi translated">基本实体</p></blockquote><p id="8051" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本实体有一个在构造函数中生成的时间戳，但是我们没有限制它的setter的可访问性，因为我们也将在decorator集合中改变它的值(你可以做的一件事是使它成为内部的，但是这取决于你的需要)</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="md me l"/></div></figure><blockquote class="lw lx ly"><p id="9301" class="if ig lz ih b ii ij ik il im in io ip ma ir is it mb iv iw ix mc iz ja jb jc hb bi translated">装饰类</p></blockquote><p id="fc85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">decorator类只是您在真实场景中需要的一小部分，但是它提供了一些我如何处理它的基本概念:</p><ul class=""><li id="623b" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated"><em class="lz"> CountAsync </em>:这里没有并发控制，我只是把session改为最后一个参数作为可选参数</li><li id="0f27" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><em class="lz"> DeleteOneAsync </em>:这里我们首先检查结果是否被确认(必须将<a class="ae jt" href="https://www.mongodb.com/docs/manual/reference/write-concern/" rel="noopener ugc nofollow" target="_blank"> write concert设置为多数</a>)。如果失败，我实际上是在检查数据库中是否有一个条目，在这种情况下，写操作失败是因为<strong class="ih hj">时间戳过滤器失败了。</strong>这听起来像是一个昂贵的操作(但它只对失败的场景有效)</li><li id="87a0" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><em class="lz"> DeleteManyAsync </em>:你可以看到我在这里使用了BulkWrite方法，这是因为我需要知道被删除的资源的数量。</li><li id="0c9d" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">ReplaceManyAsync:我在这里也使用了BulkWrite，但是我在检查修改的资源的数量。</li></ul><p id="b2c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">请记住，所有操作都必须通过在我们正在更新的资源上创建过滤器来执行，过滤器必须包含时间戳。在保存之前，我们必须将时间戳更新为一个新值</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="md me l"/></div></figure><blockquote class="lw lx ly"><p id="93c0" class="if ig lz ih b ii ij ik il im in io ip ma ir is it mb iv iw ix mc iz ja jb jc hb bi translated">助手</p></blockquote><p id="e6c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ThrowHelpers助手类是我喜欢使用的简单的东西，因为它使代码更加整洁</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="md me l"/></div></figure></div></div>    
</body>
</html>