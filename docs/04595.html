<html>
<head>
<title>Linked List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链表</h1>
<blockquote>原文：<a href="https://medium.com/codex/linked-list-fa0eba0f4c0f?source=collection_archive---------7-----------------------#2021-12-16">https://medium.com/codex/linked-list-fa0eba0f4c0f?source=collection_archive---------7-----------------------#2021-12-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/25f3abf64ac71c5f7f9ea73ed18ba677.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/0*W0IilvgQ9B4CwS32"/></div><figcaption class="im in et er es io ip bd b be z dx translated">链接……任天堂的链接财产</figcaption></figure><p id="5e2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在计算机科学中，数据结构是一个复杂的话题，在课堂上、训练营中谈论起来可能会很乏味，在技术面试中甚至会更有压力。毕竟，了解我们的代码将如何与我们的数据一起工作是至关重要的。我想这就是为什么他们称我们为软件工程师。</p><p id="5ff8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们管理、组织和存储数据，这是对数据结构的描述。但更确切的含义是，<a class="ae jo" href="https://dl.acm.org/doi/10.5555/1074100.1074312" rel="noopener ugc nofollow" target="_blank">数据结构</a>是数据值、它们之间的关系以及可应用于数据的功能或操作的集合。现在我们知道了数据结构的百科含义，我们来谈谈其中的一种结构，链表。</p><p id="b26b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://www.30secondsofcode.org/articles/s/js-data-structures-linked-list" rel="noopener ugc nofollow" target="_blank">链表</a>是一种线性数据结构，表示元素的集合，其中每个元素指向下一个元素。链表中的第一个元素是头，最后一个元素是尾。想象一下玩第一款《塞尔达传说》游戏，每个地牢都是不同的元素。没有支线任务，没有很多秘密要揭开，只是大约8个小时的游戏线性方法。这就是链表的工作方式，指针移动到下一个元素。第一个元素是头，最后一个元素是尾。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jp"><img src="../Images/ae6f2d67a8f422aeabebfbce049e199b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S203ikKIw-L_cokf.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">链接列表图形</figcaption></figure><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jy"><img src="../Images/1bb9a07bac7b067734321dca52844359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KtxYRlZFAoEPL6X-.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">想象一下给这张地图一个线性的方法。再说一次，没有支线任务。</figcaption></figure><p id="9a9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们知道了什么是链表，让我们深入研究一些编码和我们可以在链表类中实现的不同方法。</p><pre class="jq jr js jt fd jz ka kb kc aw kd bi"><span id="8bdd" class="ke kf hi ka b fi kg kh l ki kj">class Node {<br/>  constructor(value) {<br/>    this.value = value;<br/>    this.next = null;<br/>    this.prev = null<br/>  }<br/>}</span></pre><p id="dbdd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要创建<code class="du kk kl km ka b">node</code>类。一些编码人员更喜欢在每个方法中声明<code class="du kk kl km ka b">Node</code>。创建<code class="du kk kl km ka b">node</code>类，然后在<code class="du kk kl km ka b">LinkedList</code>类的每个新方法中创建变量<code class="du kk kl km ka b">const newNode = new Node(value);</code>，结果是一个更干净的代码。这两种方法都很好，这取决于编码者。</p><pre class="jq jr js jt fd jz ka kb kc aw kd bi"><span id="c500" class="ke kf hi ka b fi kg kh l ki kj">class LinkedList {<br/>  constructor(value) {<br/>    this.head = {<br/>      value: value,<br/>      next: null, <br/>    };<br/>    this.tail = this.head; <br/>    this.length = 1;<br/>  }<br/>}</span></pre><p id="4094" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我们编写了<code class="du kk kl km ka b">Node</code>类，那么让我们继续并开始处理<code class="du kk kl km ka b">LinkedList</code>类。在这个类中，我们用<code class="du kk kl km ka b">value</code>和<code class="du kk kl km ka b">next</code>声明头部。接下来是<code class="du kk kl km ka b">tail</code>，也就是<code class="du kk kl km ka b">head</code>。我们将完成<code class="du kk kl km ka b">LinkedList</code>类，声明<code class="du kk kl km ka b">length</code>将从1开始。</p><pre class="jq jr js jt fd jz ka kb kc aw kd bi"><span id="bac4" class="ke kf hi ka b fi kg kh l ki kj">append(value) {<br/>    const newNode = new Node(value);<br/>    this.tail.next = newNode; <br/>    this.tail = newNode; <br/>    this.length++;<br/>    return this;<br/>}</span></pre><p id="8020" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在创建包含一些元素的链表之前，我们需要添加一个附加值。我们正在创建的结构需要它的<code class="du kk kl km ka b">head</code>和<code class="du kk kl km ka b">tail</code>。首先，<code class="du kk kl km ka b">newNode</code>将一辆新的<code class="du kk kl km ka b">Node</code>载着<code class="du kk kl km ka b">value</code>作为论据。<code class="du kk kl km ka b">this.tail.next</code>和<code class="du kk kl km ka b">this.tail</code>都会是<code class="du kk kl km ka b">newNode</code>。在将两者都声明为<code class="du kk kl km ka b">newNode</code>之后，我们增加长度，返回这个。</p><p id="8d75" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注:</strong>如有需要，请参考本<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank">文档</a>中关于<code class="du kk kl km ka b">this</code>操作员的内容。</p><p id="da52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们创建链表，值将是Link和他的公主Zelda。</p><p id="c106" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，让我们创建<code class="du kk kl km ka b">myLinkedList</code>变量，用一个包含值链接的字符串。</p><pre class="jq jr js jt fd jz ka kb kc aw kd bi"><span id="6116" class="ke kf hi ka b fi kg kh l ki kj">let myLinkedList = new LinkedList(“Link”);</span></pre><p id="714c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们通过添加塞尔达来用方法<code class="du kk kl km ka b">append</code>调用它。</p><pre class="jq jr js jt fd jz ka kb kc aw kd bi"><span id="e9e0" class="ke kf hi ka b fi kg kh l ki kj">myLinkedList.append("Zelda");</span><span id="ceac" class="ke kf hi ka b fi kn kh l ki kj">//output:<br/>LinkedList {<br/>  head: { value: 'Link', next: { value: 'Zelda', next: null } },<br/>  tail: { value: 'Zelda', next: null },<br/>  length: 2</span></pre><p id="d886" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">添加了<code class="du kk kl km ka b">append</code>方法后，我们来学习如何做<code class="du kk kl km ka b">prepend</code>方法，并将其添加到我们的类中。</p><pre class="jq jr js jt fd jz ka kb kc aw kd bi"><span id="7c58" class="ke kf hi ka b fi kg kh l ki kj">prepend(value) {<br/>    const newNode = new Node(value);<br/>    newNode.next = this.head;<br/>    this.head = newNode;<br/>    this.length++;<br/>    return this <br/>}</span></pre><p id="542c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能已经注意到了，<code class="du kk kl km ka b">prepend</code>方法与<code class="du kk kl km ka b">append</code>非常相似。不同之处在于<code class="du kk kl km ka b">newNode.next</code>是<code class="du kk kl km ka b">this.head</code>而<code class="du kk kl km ka b">this.head</code>是<code class="du kk kl km ka b">newNode</code>。</p><pre class="jq jr js jt fd jz ka kb kc aw kd bi"><span id="5361" class="ke kf hi ka b fi kg kh l ki kj">myLinkedList.prepend("Ganon");</span><span id="d96b" class="ke kf hi ka b fi kn kh l ki kj">//output:<br/>LinkedList {<br/>  head: { value: 'Ganon', next: { value: 'Link', next: [Object] } },<br/>  tail: { value: 'Zelda', next: null },<br/>  length: 3<br/>}</span></pre><p id="4504" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个电子游戏都需要一个反派，所以让我们把加农放在名单的前面。</p><pre class="jq jr js jt fd jz ka kb kc aw kd bi"><span id="0877" class="ke kf hi ka b fi kg kh l ki kj">printList() {<br/>    const array = [];<br/>    let currentNode = this.head;<br/>    while(currentNode !== null){<br/>        array.push(currentNode.value)<br/>        currentNode = currentNode.next<br/>    }<br/>    return array;<br/>}</span></pre><p id="b442" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">插入方法是所有方法中最复杂的。所以让我们休息一下，创造一些更简单的东西。方法将创建一个数组来显示链表中所有的值。</p><pre class="jq jr js jt fd jz ka kb kc aw kd bi"><span id="9ef3" class="ke kf hi ka b fi kg kh l ki kj">myLinkedList.printList()</span><span id="e64b" class="ke kf hi ka b fi kn kh l ki kj">output:<br/>[ 'Ganon', 'Link', 'Zelda' ]</span></pre><p id="5b0f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，现在我们深吸一口气，该做插入方法了。</p><pre class="jq jr js jt fd jz ka kb kc aw kd bi"><span id="7a02" class="ke kf hi ka b fi kg kh l ki kj">insert(index, value) {<br/>    if (index &gt;= this.length) {<br/>      return this.append(value);<br/>    }<br/>    if (index === 0) {<br/>      this.prepend(value);<br/>      return this.printList();<br/>    }<br/>    const newNode = new Node(value);<br/>    const leader = this.traverseToIndex(index - 1)<br/>    const holdingPointer = leader.next;<br/>    leader.next = newNode;<br/>    newNode.next = holdingPointer;<br/>    this.length++;<br/>    return this.printList();<br/>}<br/>traverseToIndex(index) {<br/>    let counter = 0;<br/>    let currentNode = this.head;<br/>    while (counter !== index) {<br/>      currentNode = currentNode.next;<br/>      counter++<br/>    }<br/>    return currentNode;<br/>}</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es ko"><img src="../Images/3104cf4ffbcf08aec8e560eab5bb0549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wZtfR-N6vSgtxIE7FdM_jw.jpeg"/></div></div></figure><p id="aaa0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如前所述，这个变得复杂了。我将列举这些步骤，因为在这种方法中有许多要展开的内容。</p><ol class=""><li id="ab1f" class="kp kq hi is b it iu ix iy jb kr jf ks jj kt jn ku kv kw kx bi translated">声明两个参数，我们将放置新值的索引和我们将添加的值。</li><li id="4c81" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">如果新添加的索引号大于或等于索引长度，则为新值<code class="du kk kl km ka b">append</code>，如果新添加的索引号等于<code class="du kk kl km ka b">0</code>，则为<code class="du kk kl km ka b">prepend</code>的条件语句。如果没有这些语句，代码在这两种情况下都会中断。</li><li id="6dd5" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">我们还创建了方法<code class="du kk kl km ka b">traverseToIndex</code>(记住基础知识，计算机索引从数字<code class="du kk kl km ka b">0</code>开始，而不是像人类计数一样从数字<code class="du kk kl km ka b">1</code>开始)。</li><li id="6f58" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">我们以与前面方法相同的方式添加了一个新节点，并且还创建了一个<code class="du kk kl km ka b">leader</code>，它将是从<code class="du kk kl km ka b">1</code>和<code class="du kk kl km ka b">holdingPointer</code>中减去的索引，T5将紧挨着<code class="du kk kl km ka b">leader</code>。</li><li id="74ca" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><code class="du kk kl km ka b">leader.next</code>将是<code class="du kk kl km ka b">newNode</code>，<code class="du kk kl km ka b">newNode.next</code>将是<code class="du kk kl km ka b">holdingPointer</code>，索引长度递增，我们将使用方法<code class="du kk kl km ka b">printList</code>返回。</li></ol><p id="c3b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有很多东西需要理解，但是不要担心，重复是理解的关键。我们继续，最后通过添加其他人来调用它。</p><pre class="jq jr js jt fd jz ka kb kc aw kd bi"><span id="1725" class="ke kf hi ka b fi kg kh l ki kj">myLinkedList.insert(2, "Luigi");</span><span id="d86e" class="ke kf hi ka b fi kn kh l ki kj">//output:<br/>[ 'Ganon', 'Link', 'Luigi', 'Zelda' ]</span></pre><p id="5d10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看看谁来了。似乎Luigi厌倦了生活在他哥哥的阴影下或者害怕闹鬼的房子。他的绿色衣服很容易隐藏在林克或任何绿色灌木后面，以免被海露尔发现。既然这不是Super Smash Bros，那我们就把他从名单里剔除，送他回他该去的蘑菇王国吧。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/93e0207bc896e5dbe31238b8a47dc746.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/0*jdJbCCU-2q7OhR_u"/></div><figcaption class="im in et er es io ip bd b be z dx translated">对不起，路易吉，回你的豪宅去吧。</figcaption></figure><pre class="jq jr js jt fd jz ka kb kc aw kd bi"><span id="176a" class="ke kf hi ka b fi kg kh l ki kj">remove(index) {<br/>    const leader = this.traverseToIndex(index-1);<br/>    const unwantedNode = leader.next;<br/>    leader.next = unwantedNode.next; <br/>    this.length--; <br/>    return this.printList();<br/>}</span></pre><p id="a286" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">移除方法将包括<code class="du kk kl km ka b">leader</code>减去<code class="du kk kl km ka b">1</code>的索引，<code class="du kk kl km ka b">unwantedNode</code>为<code class="du kk kl km ka b">leader.next</code>，<code class="du kk kl km ka b">leader.next</code>为<code class="du kk kl km ka b">unwantedNode</code>。当您编写自己的链表时，您会注意到与其他方法有很多相似之处，其他类似的代码行都是递减索引长度，而不是递增并通过使用<code class="du kk kl km ka b">printList</code>方法返回结果来查看更简单的数组。</p><pre class="jq jr js jt fd jz ka kb kc aw kd bi"><span id="83b4" class="ke kf hi ka b fi kg kh l ki kj">myLinkedList.remove(2);</span><span id="9f25" class="ke kf hi ka b fi kn kh l ki kj">output//<br/>[ 'Ganon', 'Link', 'Zelda' ]</span></pre><p id="0b34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用索引<code class="du kk kl km ka b">2</code>运行remove方法，Luigi从索引<code class="du kk kl km ka b">2</code>中消失。</p><p id="3458" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注:</strong>我们可以随时<code class="du kk kl km ka b">console.log(myLinkedList)</code>以便知道整个列表是什么样子的。</p><p id="bc48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是完整代码，供您参考:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="caa3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们有它，这是很多，但它值得努力。记得练习，阅读，寻找更多的参考资料，如果你被要求创建一个链表，拿出你最好的一面。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/6a503acfcc2da1793f5f7ea0711f1f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/0*tZTzYVphK7jN9S8v.gif"/></div></figure><p id="465f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不久，我将解释如何创建一个双向链表。</p><p id="f4c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编码快乐！</p><h1 id="a6ef" class="lh kf hi bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">总结:</h1><ol class=""><li id="59b4" class="kp kq hi is b it me ix mf jb mg jf mh jj mi jn ku kv kw kx bi translated">数据结构介绍</li><li id="de67" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">什么是链表</li><li id="6065" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">用一个附加类对整个链表类进行编码，以创建节点和以下方法:</li><li id="95c3" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">附加</li><li id="a7c1" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">预先考虑</li><li id="3849" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">插入</li><li id="f47e" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">返回一个数组</li><li id="1ab2" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">遍历到索引</li><li id="8cd1" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">去除</li></ol><h1 id="6180" class="lh kf hi bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">参考资料:</h1><ol class=""><li id="941d" class="kp kq hi is b it me ix mf jb mg jf mh jj mi jn ku kv kw kx bi translated"><a class="ae jo" href="https://dl.acm.org/doi/10.5555/1074100.1074312" rel="noopener ugc nofollow" target="_blank">数据结构</a>，1987。Horowitz和s . Sahni，<em class="mj">Pascal语言的数据结构基础</em>，第二版。马里兰州洛克维尔:计算机科学出版社。</li><li id="e27b" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">30秒代码，<a class="ae jo" href="https://www.30secondsofcode.org/articles/s/js-data-structures-linked-list" rel="noopener ugc nofollow" target="_blank">链表</a></li><li id="e841" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">MDN网络文档，<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank">本</a></li></ol></div></div>    
</body>
</html>