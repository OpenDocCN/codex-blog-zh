<html>
<head>
<title>What can we Moq?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们可以订购什么？</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-can-we-moq-d2d5caa0c8bf?source=collection_archive---------8-----------------------#2022-09-24">https://medium.com/codex/what-can-we-moq-d2d5caa0c8bf?source=collection_archive---------8-----------------------#2022-09-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0937" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">最受欢迎和友好的嘲笑图书馆。网</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/2b08e96c0a23cae88c1814ce6d4d2cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FLkt20TWbO5dmWss"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jn" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>拍摄的照片</figcaption></figure><p id="4fcb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">很多时候，当我们想在单元测试中测试一个组件时，这个组件会使用作为其依赖的对象。模拟对象用于测试，作为真实实现的替代。我们可以为模拟对象配置不同的行为，这样我们就可以测试组件来正确处理所有的行为。</p><h1 id="307a" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">我们能嘲笑什么？</h1><p id="0403" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我们可以将mock视为动态创建的类型的实例，它实现了接口。模拟对象也可以是从类继承的实例，并且能够重写该类的虚方法，并实现其抽象方法。</p><p id="f15c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是为什么我们不能测试依赖于私有或静态方法的情况(至少没有简单的方法可以做到)。在静态方法的情况下，我们可以像这里的<a class="ae jn" rel="noopener" href="/@martinrybak/how-to-mock-singletons-and-static-methods-in-unit-tests-cbe915933c7d">建议的那样使用包装器来解决。</a></p><p id="ebb3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">嘲讽<em class="lh">接口</em>方法和<em class="lh">属性</em> : </strong></p><p id="a238" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这个例子中，我们有一个接口<em class="lh"> IEmailValidator </em>，它有一个包含字符串列表的属性和一个验证电子邮件地址的方法。<em class="lh"> UserController </em>在更新用户邮箱时使用这个接口。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="2236" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我们想要测试控制器的<em class="lh"> UpdateEmail </em>方法时，我们需要模拟<em class="lh"> IEmailValidator </em>。<em class="lh"> SetUpGet </em>是配置该接口返回属性值的方法(第8行)，在第9行可以看到调用<em class="lh"> Validate </em>方法时如何配置返回值:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="9e8b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">嘲讽<em class="lh">抽象</em>和<em class="lh">虚拟</em>方法:</strong></p><p id="3602" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里有一个例子，我们可以模拟一个从抽象类继承的对象，这个抽象类既有一个虚方法，又有一个抽象方法。抽象方法是需要由子类实现的方法。虚方法是一种由抽象类实现的方法，但是子类总是可以覆盖这个实现。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="a44a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这个例子中，子类(<em class="lh"> TextFileReader </em>)没有覆盖抽象类实现。当模仿<em class="lh"> TextFileReader，</em>时，您可以看到有两个如何配置虚拟方法的选项:</p><ol class=""><li id="42a6" class="lk ll hi jq b jr js ju jv jx lm kb ln kf lo kj lp lq lr ls bi translated">设置一个新的返回值，如第2行所述。</li><li id="ed01" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">使用CallBase()，它将mock配置为使用父类已经为该类实现的行为(第6行)。这对每一个虚方法都是正确的，不管它是在抽象类中实现还是在常规类中实现。</li></ol><p id="6978" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">抽象方法的配置和我们在接口中的配置是一样的。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="17c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">嘲讽<em class="lh">保护</em>方法:</strong></p><p id="0514" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这个例子中，我们有一个使用了<em class="lh"> HttpClient </em>的类。当我们想要测试<em class="lh"> GetCarPrice </em>方法时，我们需要找到一种模仿<em class="lh"> HttpClient - </em>的方法，因为这个方法依赖于<em class="lh"> HttpClient。</em></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="7d40" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不幸的是，我们不能模仿它的<em class="lh"> GetAsync </em>方法，因为<em class="lh"> HttpClient </em>不是一个接口，这个方法既不是抽象的也不是虚拟的。</p><p id="c9a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> <em class="lh">起订量。受保护的</em> </strong>名称空间给了我们模仿受保护方法的能力。<em class="lh"> Protected() </em>只是给你访问权(大概是通过反射，因为它是基于字符串的)来覆盖受保护的成员。</p><p id="9bbe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="lh"> HttpClient </em>依赖于<em class="lh"> HttpMessageHandler。</em>无论何时调用<em class="lh"> GetAsync </em>方法，它都会通过<em class="lh"> HttpMessageHandler的SendAsync </em>方法。这是一个受保护的方法，因此我们可以模拟它。我们可以将模拟的<em class="lh"> HttpMessageHandler </em>注入到HttpClient中，并由此模拟<em class="lh"> GetAsync </em>方法<em class="lh">的返回值。</em></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><blockquote class="ly"><p id="bb33" class="lz ma hi bd mb mc md me mf mg mh kj dx translated">所以继续用Moq嘲讽吧😃</p></blockquote></div></div>    
</body>
</html>