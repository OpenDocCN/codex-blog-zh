<html>
<head>
<title>Machine Learning — Logistic Regression with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习—使用Python的逻辑回归</h1>
<blockquote>原文：<a href="https://medium.com/codex/machine-learning-logistic-regression-with-python-5ed4ded9d146?source=collection_archive---------0-----------------------#2020-10-30">https://medium.com/codex/machine-learning-logistic-regression-with-python-5ed4ded9d146?source=collection_archive---------0-----------------------#2020-10-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="e179" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">药典</h2><div class=""/><div class=""><h2 id="1070" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">Python中用于分类和预测的逻辑回归实用介绍</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/873981e4a7586e0792231570777fdf25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYBAzYZ_a47empFL0mlGdA.jpeg"/></div></div></figure><h1 id="f2e2" class="js jt hi bd ju jv jw jx jy jz ka kb kc ix kd iy ke ja kf jb kg jd kh je ki kj bi translated">逻辑回归</h1><p id="812d" class="pw-post-body-paragraph kk kl hi km b kn ko is kp kq kr iv ks kt ku kv kw kx ky kz la lb lc ld le lf hb bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di"> L </span>逻辑回归是一种可用于回归和分类任务的算法，但它广泛用于分类任务。'</p><p id="b281" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">逻辑回归用于在因变量的帮助下预测分类变量。考虑有两个类，并且要检查一个新的数据点属于哪个类。然后算法计算范围从0到1的概率值。比如今天会不会下雨。</p><h1 id="46e5" class="js jt hi bd ju jv jw jx jy jz ka kb kc ix kd iy ke ja kf jb kg jd kh je ki kj bi translated">用于逻辑回归的Python</h1><p id="68b3" class="pw-post-body-paragraph kk kl hi km b kn ko is kp kq kr iv ks kt ku kv kw kx ky kz la lb lc ld le lf hb bi translated">Python是最强大的，对于数据科学家来说，执行简单或复杂的机器学习算法非常方便。它有一个强大的机器学习包的广泛档案，以帮助数据科学家自动化他们的编码方式。在本文中，我们将使用python的scikit-learn包来构建和评估我们的逻辑回归模型。我们要解决的案例是，一家电信公司的客户是否愿意留在那里。用python来解吧！</p><h2 id="7421" class="lu jt hi bd ju lv lw lx jy ly lz ma kc kt mb mc ke kx md me kg lb mf mg ki ho bi translated">步骤1:导入包</h2><p id="a44b" class="pw-post-body-paragraph kk kl hi km b kn ko is kp kq kr iv ks kt ku kv kw kx ky kz la lb lc ld le lf hb bi translated">对于我们的逻辑回归模型，主要的包包括用于构建和训练模型的scikit-learn，用于数据处理的pandas，以及用于处理数组的NumPy。让我们用python导入所有需要的包！</p><p id="1ebf" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="b53b" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">我们的下一步将是使用pandas导入和处理数据。我们还将在下一步做一些EDA和清洗过程。</p><h2 id="8345" class="lu jt hi bd ju lv lw lx jy ly lz ma kc kt mb mc ke kx md me kg lb mf mg ki ho bi translated">步骤2:导入和使用数据</h2><p id="bd0c" class="pw-post-body-paragraph kk kl hi km b kn ko is kp kq kr iv ks kt ku kv kw kx ky kz la lb lc ld le lf hb bi translated">我们将使用电信数据集来预测客户流失。这是一个历史客户数据集，其中每行代表一个客户。这些数据相对容易理解，你可能会发现你可以立即使用的见解。一般来说，留住客户比获得新客户成本更低，所以这种分析的重点是预测哪些客户会留在公司。该数据集提供的信息有助于您预测哪些行为将有助于您留住客户。您可以分析所有相关的客户数据，并制定有针对性的客户维系计划。</p><p id="5f76" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">数据集包括以下信息:</p><ul class=""><li id="b81d" class="mj mk hi km b kn lp kq lq kt ml kx mm lb mn lf mo mp mq mr bi translated">上个月内离开的客户—这一列称为流失</li><li id="5c47" class="mj mk hi km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated">每位客户已注册的服务—电话、多条线路、互联网、在线安全、在线备份、设备保护、技术支持以及流媒体电视和电影</li><li id="e5bd" class="mj mk hi km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated">客户账户信息——他们成为客户的时间、合同、支付方式、无纸化账单、每月费用和总费用</li><li id="9d4b" class="mj mk hi km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated">客户的人口统计信息—性别、年龄范围，以及他们是否有伴侣和家属</li></ul><p id="ee52" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">让我们使用python导入和清理数据吧！</p><p id="7082" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="4d9b" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">输出:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mx"><img src="../Images/92da0b800830f3d2901711a9c35246f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_4XlAN-AbZGHWymihWqt5w.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">作者图片</figcaption></figure><p id="4c04" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">既然我们已经将数据导入到python环境中。是时候使用熊猫的便捷功能来探索数据集了。</p><p id="7606" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">㈠数据的统计视图</p><p id="4000" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="2063" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">输出:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nc"><img src="../Images/d793c97d177e88b93f4ba26a433dea70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owGiPlQ1mpdqYS_WciLkRA.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">作者图片</figcaption></figure><p id="3632" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">㈡数据信息</p><p id="4646" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="4305" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">输出:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nd"><img src="../Images/e11f8928354e4f121ca630cd0f239805.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*oI-p63udSvhONvXyp3C44g.png"/></div><figcaption class="my mz et er es na nb bd b be z dx translated">作者图片</figcaption></figure><p id="511b" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">至此，我们结束了工作和探索数据集的过程。接下来，我们将把数据集分成两部分，一部分是训练集，另一部分是测试集。让我们进行下一步。</p><h2 id="4e15" class="lu jt hi bd ju lv lw lx jy ly lz ma kc kt mb mc ke kx md me kg lb mf mg ki ho bi translated">步骤3:拆分数据集</h2><p id="4657" class="pw-post-body-paragraph kk kl hi km b kn ko is kp kq kr iv ks kt ku kv kw kx ky kz la lb lc ld le lf hb bi translated">正如我之前提到的，在这个过程中，我们将把数据集分成训练集和测试集。为此，我们首先定义自变量为“X”变量，因变量为“Y”变量。让我们用python来定义变量吧！</p><p id="a828" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="14c9" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">输出:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ne"><img src="../Images/317f1e8d2d1813bd279d03b6bda3dbf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q5V8gvkG2GV57mtLMIgzkQ.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">作者图片</figcaption></figure><p id="0558" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">使用scikit-learn中的<em class="nf">‘standard scaler’</em>函数，我们将标准化独立变量或‘X’变量。按照代码在python中规范化X变量。</p><p id="9ba9" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="29e5" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">输出:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ng"><img src="../Images/6ae287eda3716ef02943e19d85442573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HmZjcHDnBNePJAbLVIazLg.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">作者图片</figcaption></figure><p id="d5a2" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">现在，我们拥有了将数据分成训练集和测试集所需的所有组件。我们可以使用python中scikit-learn提供的<em class="nf">‘train _ test _ split’</em>函数来拆分我们的数据。让我们用python拆分我们的数据吧！</p><p id="071b" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="dea3" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">输出:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nh"><img src="../Images/3f60d7867c81cb154f7455885f3b27e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGLer4mpkJzvw9We9zyIOw.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">作者图片</figcaption></figure><p id="afe9" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">在将数据分成训练集和测试集之后，我们现在已经准备好用python进行逻辑回归建模了。所以我们进行下一步。</p><h2 id="b679" class="lu jt hi bd ju lv lw lx jy ly lz ma kc kt mb mc ke kx md me kg lb mf mg ki ho bi translated">步骤4:建模(用scikit-learn进行逻辑回归)</h2><p id="0cd0" class="pw-post-body-paragraph kk kl hi km b kn ko is kp kq kr iv ks kt ku kv kw kx ky kz la lb lc ld le lf hb bi translated">让我们使用scikit-learn包中的‘logistic regression’函数来构建我们的模型。该函数实现逻辑回归，并可以使用不同的数值优化器来查找参数，包括“牛顿-cg”、“lbfgs”、“liblinear”、“sag”、“saga”解算器。</p><p id="1932" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">Scikit-learn中的逻辑回归版本，支持正则化。正则化是一种用于解决机器学习模型中过拟合问题的技术。<em class="nf">‘C’</em>参数表示正则化强度的倒数，它必须是正浮点数。较小的值指定较强的正则化。现在，让我们用python中的火车设置来拟合我们的模型。</p><p id="9fce" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="ea8a" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">输出:</p><pre class="jh ji jj jk fd ni nj nk nl aw nm bi"><span id="f70b" class="lu jt hi nj b fi nn no l np nq"><strong class="nj hs">LogisticRegression(C=0.1,class_weight=None,dual=False,          fit_intercept=True,intercept_scaling=1,l1_ratio=None,max_iter=100,<br/>multi_class='auto',n_jobs=None,penalty='l2',random_state=None, solver='liblinear',tol=0.0001,verbose=0,warm_start=False)</strong></span></pre><p id="7971" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">现在，我们可以使用经过训练的逻辑回归模型对测试集进行一些预测。按照代码用python做预测。</p><p id="e2b0" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="7233" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">输出:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nr"><img src="../Images/740f8e0f2c3aa59edeeb8bda37c3c9bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*4HF8q3xfdsLLjsu-LkyZgw.png"/></div><figcaption class="my mz et er es na nb bd b be z dx translated">作者图片</figcaption></figure><p id="2c46" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">在上面的代码中，<em class="nf"> 'predict_proba' </em>返回所有类的估计值，按类的标签排序。所以，第一列是类1的概率，P(Y=1|X)，第二列是类0的概率，P(Y=0|X)。</p><h2 id="c0ab" class="lu jt hi bd ju lv lw lx jy ly lz ma kc kt mb mc ke kx md me kg lb mf mg ki ho bi translated">步骤5:模型评估</h2><p id="7653" class="pw-post-body-paragraph kk kl hi km b kn ko is kp kq kr iv ks kt ku kv kw kx ky kz la lb lc ld le lf hb bi translated">在这一步中，我们将使用scikit-learn提供的五个评估指标来评估我们的模型，即<em class="nf">【JAC card _ similarity _ score】</em><em class="nf">【precision _ score】</em><em class="nf">【log _ loss】</em><em class="nf">【classification _ report】</em>，最后是<em class="nf">【混淆矩阵】</em>。</p><p id="529b" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">(i) Jaccard相似性得分或Jaccard指数</p><p id="693c" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">我们可以将Jaccard定义为交集的大小除以两个标签集的并集的大小。如果样本的整个预测标签集严格匹配真实标签集，则子集准确度为1.0；否则为0.0。按照代码使用‘JAC card _ similarity _ score’函数来评估我们的python模型。</p><p id="9055" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="01c0" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">输出:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ns"><img src="../Images/0e252bfc36bf73d31dd88962dfd538a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4rUHB7EOxgh4dAfqL61KIw.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">作者图片</figcaption></figure><p id="dee1" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">(二)精确评分</p><p id="af46" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">现在，让我们尝试使用“precision_score”评估指标来评估我们的python模型。</p><p id="6336" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="5ae2" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">输出:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nt"><img src="../Images/18234e25fd672a5d24438164410c41bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpVPxRiVQbXm5pvKa9_uGQ.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">作者图片</figcaption></figure><p id="ffb2" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">㈢原木损失</p><p id="9817" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">现在，让我们尝试对数损失进行评估。在逻辑回归中，输出可以是客户流失的概率为是(或等于1)。这个概率是0到1之间的一个值。对数损失(对数损失)衡量分类器的性能，其中预测输出是介于0和1之间的概率值。请记住，对数损失值越低，我们的模型的准确性越高。用python来做吧！</p><p id="986a" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="a980" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">输出:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nu"><img src="../Images/c6ee37a8fd53c5bc8285386004cca494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*m2O3F0oIJrG0wCCEwlC06A.png"/></div><figcaption class="my mz et er es na nb bd b be z dx translated">作者图片</figcaption></figure><p id="61c0" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">(四)分类报告</p><p id="3c63" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><em class="nf">‘分类_报告’</em>函数提供了我们模型的摘要。它包括精确度分数、F1分数、召回和支持指标。观察一个分类报告，我们可以很容易地了解我们的模型的准确性和性能。用python来做吧！</p><p id="a0dc" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="9402" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">输出:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nv"><img src="../Images/e2329be174912dc303679af0aea7d392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-gMNdBa4PmXy62yFB__OwQ.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">作者图片</figcaption></figure><p id="97cc" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">基于每个部分的计数，我们可以计算每个标签的精度和召回率:</p><ul class=""><li id="9996" class="mj mk hi km b kn lp kq lq kt ml kx mm lb mn lf mo mp mq mr bi translated"><strong class="km hs">精度</strong>是在已经预测了类别标签的情况下对精度的度量。它由下式定义:精度= TP / (TP + FP)</li><li id="dc96" class="mj mk hi km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated"><strong class="km hs">回忆</strong>是真阳性率。它被定义为:召回= TP / (TP + FN)</li></ul><p id="7b4b" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">所以，我们可以计算每个类的精度和召回率。</p><p id="82d9" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> F1得分:</strong>现在，我们可以根据标签的精确度和召回率来计算每个标签的F1得分。F1分数是精度和召回率的调和平均值，其中F1分数在1时达到其最佳值(完美的精度和召回率),在0时最差。这是一个很好的方式来表明一个分类器具有良好的召回率和精确度。</p><p id="f328" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">最后，我们可以知道这个分类器的平均准确度是两个标签的F1分数的平均值，在我们的例子中是0.74。</p><p id="fde2" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">㈤混淆矩阵</p><p id="7220" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">以热图形式查看混淆矩阵比以数组形式查看更有意义。尽管scikit-learn有一个内置的函数来绘制混淆矩阵，我们还是打算用python从头开始定义和绘制它。按照代码在python中实现一个定制的混淆矩阵函数。</p><p id="c8b1" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="79b1" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">输出:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nw"><img src="../Images/c1026560dc33dbe88d27779456d10509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pk83fxqwrPPm3sMjaxFQ9g.png"/></div></div><figcaption class="my mz et er es na nb bd b be z dx translated">作者图片</figcaption></figure><p id="4b56" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">看第一排。第一行是测试集中实际流失值为1的客户。正如你所计算的，40个客户中，17个客户的流失率为1。在这17个中，分类器正确地预测了其中5个为1，12个为0。这意味着，对于5个客户，在测试集中实际的客户流失值是1，并且分类器也正确地预测这些客户流失值是1。然而，虽然12个客户的实际标签是1，但分类器预测它们是0，这不是很好。我们可以认为这是第一行模型的错误。</p><p id="7bfe" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">流失值为0的客户呢？让我们看看第二排。看起来有43个客户的流失率为0。分类器正确地预测其中42个为0，其中一个错误地为1。因此，它很好地预测了流失值为0的客户。</p><p id="79fa" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">混淆矩阵的一个好处是显示了模型正确预测或区分类别的能力。在二元分类器的特定情况下，比如这个例子，我们可以将这些数字解释为真阳性、假阳性、真阴性和假阴性的计数。</p><h1 id="ef5f" class="js jt hi bd ju jv jw jx jy jz ka kb kc ix kd iy ke ja kf jb kg jd kh je ki kj bi translated">最后的想法！</h1><p id="55f6" class="pw-post-body-paragraph kk kl hi km b kn ko is kp kq kr iv ks kt ku kv kw kx ky kz la lb lc ld le lf hb bi translated">经过长时间的python实际实现过程，我们最终构建了一个全功能的逻辑回归模型，可以用来解决现实世界的问题。即使像scikit-learn和NumPy这样的软件包可以解决所有复杂的数学问题，但拥有强大的数学基础总是好的。此外，我们在本文中构建的模型是非常基础的，因此，在构建逻辑回归模型时有很多需要探索的地方。请记住，实践学习真的很重要，当谈到机器学习时，我们往往会忘记这些概念。所以，永远不要停止学习，永远不要停止实施。如果您忘记了遵循任何编码部分，不要担心，我已经在本文末尾提供了完整的源代码。</p><p id="ff95" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated"><strong class="km hs">快乐的机器学习！</strong></p><p id="0f56" class="pw-post-body-paragraph kk kl hi km b kn lp is kp kq lq iv ks kt lr kv kw kx ls kz la lb lt ld le lf hb bi translated">完整代码:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mh mi l"/></div></figure></div></div>    
</body>
</html>