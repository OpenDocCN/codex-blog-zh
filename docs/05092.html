<html>
<head>
<title>Connecting a Flask Application to a Raspberry Pi PostgreSQL server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Flask应用程序连接到Raspberry Pi PostgreSQL服务器</h1>
<blockquote>原文：<a href="https://medium.com/codex/connecting-a-flask-application-to-a-raspberry-pi-postgresql-server-b37b54286ab0?source=collection_archive---------10-----------------------#2022-01-31">https://medium.com/codex/connecting-a-flask-application-to-a-raspberry-pi-postgresql-server-b37b54286ab0?source=collection_archive---------10-----------------------#2022-01-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es im"><img src="../Images/705e83b3607a2c4749d38642f092d4a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*GLARhzXYeUUyXWnoW7Ib2Q.png"/></div></figure><p id="a3e3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有了一些使用Flask和使用sqlite数据库创建自己的小型本地应用程序的经验后，我想推动自己，为我正在制作的应用程序创建一个数据库服务器。幸运的是，我有一个备用的Raspberry Pi 4坐在家里什么也不做，所以在安装了一个无头版本的Raspbian并启用SSH后，它就可以开始了…</p><p id="cde6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">在Raspberry Pi上设置PostgreSQL</strong></p><p id="cccc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在Pi上安装操作系统并检查它是否启动后，第一步是在本地网络上找到Pi的IP地址。这可以通过在Pi上的终端中运行<code class="du js jt ju jv b">ip address</code>命令来完成，或者通过对网络上的设备运行nmap扫描来识别与Pi相关联的IP。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es jw"><img src="../Images/598a4b29788dcadc82a01740568d8aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*37Q6AZ-GlZtFo4en4BTdNw.png"/></div></figure><p id="4b17" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦找到IP地址，就可以从主设备ssh到Pi，这就是已经采用的方法。为此，请在终端中运行以下命令，并按照提示输入密码进行连接。</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="f048" class="kb kc hi jv b fi kd ke l kf kg">user@mycomputer$ ssh pi@&lt;ip_address&gt;</span></pre><p id="33a2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">安装PostgreSQL </strong></p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es kh"><img src="../Images/53e25ad20bb4f83798a5159a24b3fd06.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*JiRveJQpuAzkB0eW73_W-g.png"/></div></figure><p id="7973" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">连接到Pi后，下一步是更新包管理并将PostgreSQL安装到设备上。以下命令将完成此操作，并确保安装最新版本的PostgreSQL。</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="f386" class="kb kc hi jv b fi kd ke l kf kg">pi@raspberrypi$ <!-- -->sudo apt-get update<br/>pi@raspberrypi$ <!-- -->sudo apt-get install postgres -y</span></pre><p id="f2f5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">访问Pi上的psql</strong></p><p id="300a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">虽然仍然通过SSH连接到Pi并安装了PostgreSQL，但下一步是创建一个数据库用户和数据库，以便与Flask应用程序一起使用。要使用管理员权限访问psql的命令行应用程序，可以使用以下命令:</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="3515" class="kb kc hi jv b fi kd ke l kf kg">pi@raspberrypi$ <!-- -->sudo -u postgres psql</span><span id="7a00" class="kb kc hi jv b fi ki ke l kf kg">postgres=# </span></pre><p id="f85b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">创建一个psql用户</strong></p><p id="ebad" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过psql的管理员访问权限，可以创建一个用户:</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="7ba7" class="kb kc hi jv b fi kd ke l kf kg">postgres=# create user &lt;username&gt;;</span></pre><p id="dc5f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这将创建一个没有密码的数据库用户，虽然可以在创建用户时设置密码，但我不知道如何设置。因此，我在创建后使用以下命令为用户设置密码。</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="71d2" class="kb kc hi jv b fi kd ke l kf kg">pi@raspberrypi$ sudo -u postgres psql<br/>postgres =# ALTER USER &lt;username&gt; PASSWORD '&lt;new password&gt;';</span></pre><p id="d0e0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">创建数据库</strong></p><p id="525f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">同样，对于psql的管理员访问权限，可以使用以下命令创建数据库:</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="c45b" class="kb kc hi jv b fi kd ke l kf kg">postgres=# create database &lt;db_name&gt;;</span></pre><p id="e13a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，可以向上一步中创建的用户授予特权。</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="37f1" class="kb kc hi jv b fi kd ke l kf kg">pi@raspberrypi$ sudo -u postgres psql<br/>postgres=# grant all privileges on database mydb to myuser;</span></pre><p id="4dd2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">启用从其他设备到数据库的连接</strong></p><p id="f652" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">目前，我们有一个数据库和一个可以访问它的用户。然而，在这个阶段唯一可以连接到数据库的连接只能来自Raspberry Pi。由于Pi充当Flask应用程序的数据库服务器，因此需要在PostgreSQL的配置文件中启用到它的连接。需要修改的文件需要root权限才能编辑，并且可以在<code class="du js jt ju jv b">/etc/postgres/</code>目录中找到。</p><p id="0e33" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，在<strong class="iw hj"> pg_hba.conf </strong>文件中，来自IPv4地址的连接需要被更改为<strong class="iw hj"> 0.0.0.0/0 </strong>，以允许来自连接到同一网络的设备的连接。下面一行应该从[旧的]改为[新的]。</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="41dc" class="kb kc hi jv b fi kd ke l kf kg">pi@raspberrypi$ <!-- -->sudo vim /etc/postgres/13/main/pg_hba.conf</span><span id="8cc4" class="kb kc hi jv b fi ki ke l kf kg">[old]    host   all   all   192.168.1.111/24   trust    <br/>[new]    host   all   all   0.0.0.0/0          trust</span></pre><p id="34e9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">其次，需要修改<strong class="iw hj"> postgres.conf </strong>文件，将<code class="du js jt ju jv b">listen_address</code>变量配置为活动的，并列出所有地址的连接。这可以通过删除行首的注释并编辑文件来实现，如下所示:</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="1b0c" class="kb kc hi jv b fi kd ke l kf kg">pi@raspberrypi$ <!-- -->sudo vim /etc/postgres/13/main/postgres.conf<br/>    listen_address = "*"</span></pre><p id="ce6e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，要启用对数据库配置的更改，需要重新启动PostgreSQL服务。</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="cfb0" class="kb kc hi jv b fi kd ke l kf kg">pi@raspberrypi$ <!-- -->sudo service postgresql restart</span></pre></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="f95a" class="kj kc hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">设置Flask App连接数据库</strong></h1><p id="4b1f" class="pw-post-body-paragraph iu iv hi iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr hb bi translated">每当我创建一个Flask应用程序时，我都会参考<a class="ae ll" href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world" rel="noopener ugc nofollow" target="_blank"> Flask Mega教程</a>来了解项目设置的基础知识，所以我不会在这里详细介绍。项目的基本文件结构如下:</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="2866" class="kb kc hi jv b fi kd ke l kf kg">Project_Folder/<br/>|<br/>|--main.py<br/>|--config.py<br/>|--venv/<br/>|--app/<br/>   |<br/>   |--__init__.py<br/>   |--routes.py<br/>   |--models.py<br/>   |--templates/<br/>      |<br/>      |--index.html</span></pre><h2 id="bd6f" class="kb kc hi bd kk lm ln lo ko lp lq lr ks jf ls lt kw jj lu lv la jn lw lx le ly bi translated"><strong class="ak">安装依赖关系</strong></h2><p id="778f" class="pw-post-body-paragraph iu iv hi iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr hb bi translated">要安装所需的依赖项，请在终端中运行以下命令:</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="904f" class="kb kc hi jv b fi kd ke l kf kg">user@mycomputer$ python3 -m venv venv # setup python environment<br/>user@mycomputer$ source venv/bin/activate # activate environment<br/>(venv)user@mycomputer$ pip3 install flask <br/>(venv)user@mycomputer$ pip3 install flask-sqlalchemy<br/>(venv)user@mycomputer$ pip3 install flask-migrate<br/>(venv)user@mycomputer$ <!-- -->pip3 install python-dotenv</span></pre><h2 id="f70a" class="kb kc hi bd kk lm ln lo ko lp lq lr ks jf ls lt kw jj lu lv la jn lw lx le ly bi translated"><strong class="ak">设置main.py </strong></h2><p id="34ce" class="pw-post-body-paragraph iu iv hi iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr hb bi translated">main.py文件将是运行应用程序的脚本，并将利用app文件夹中的脚本。设置main.py文件，使其包含以下内容:</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="f26d" class="kb kc hi jv b fi kd ke l kf kg">from app import app</span><span id="866f" class="kb kc hi jv b fi ki ke l kf kg">if __name__ == "__main__":<br/>    app.run(debug = True)</span></pre><h2 id="22f3" class="kb kc hi bd kk lm ln lo ko lp lq lr ks jf ls lt kw jj lu lv la jn lw lx le ly bi translated"><strong class="ak">设置配置文件</strong></h2><p id="c43a" class="pw-post-body-paragraph iu iv hi iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr hb bi translated">现在，在上面的Project_Folder中，编辑config.py配置文件来存储数据库的连接细节。</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="b611" class="kb kc hi jv b fi kd ke l kf kg">import os</span><span id="3f7e" class="kb kc hi jv b fi ki ke l kf kg">class Config(object):<br/>    SECRET_KEY = os.environ.get('SECRET_KEY') or 'you-will-never-guess'<br/>    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \<br/>        'postgresql://&lt;db_username&gt;:&lt;db_password&gt;<br/>        @&lt;db_ip_address&gt;:5432/website'<br/>    SQLALCHEMY_TRACK_MODIFICATIONS = True</span></pre><h2 id="8f26" class="kb kc hi bd kk lm ln lo ko lp lq lr ks jf ls lt kw jj lu lv la jn lw lx le ly bi translated"><strong class="ak">设置app/__init__。py </strong></h2><p id="f873" class="pw-post-body-paragraph iu iv hi iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr hb bi translated">__init__。py文件设置应用程序的主Flask实例，以及数据库管理的SQLAlchemy和Migrate实例。最后，这个文件还将使用前面创建的config.py文件中的Config对象为应用程序建立配置。</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="d65d" class="kb kc hi jv b fi kd ke l kf kg">from flask import Flask<br/>from config import Config<br/>from flask_sqlalchemy import SQLAlchemy<br/>from flask_migrate import Migrate</span><span id="9b92" class="kb kc hi jv b fi ki ke l kf kg">app = Flask(__name__)<br/>app.config.from_object(Config)<br/>db = SQLAlchemy(app)<br/>migrate = Migrate(app, db)</span><span id="88d3" class="kb kc hi jv b fi ki ke l kf kg">from app import routes</span></pre><p id="d21d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">__init__的最后一行。py文件正在从应用程序包中导入routes.py文件。这需要到文件的最后一行，以解决循环导入问题，因为应用程序(如上定义)需要导入到routes.py文件中。</p><h2 id="ef36" class="kb kc hi bd kk lm ln lo ko lp lq lr ks jf ls lt kw jj lu lv la jn lw lx le ly bi translated"><strong class="ak">设置routes.py </strong></h2><p id="fc65" class="pw-post-body-paragraph iu iv hi iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr hb bi translated">routes.py文件将定义应用程序中可用的不同URL。该文件包含一系列可以映射到一个或多个URL端点的“查看”函数。例如，主页可能希望被映射到“/”和“/index”URL中。创建函数时，装饰符:<code class="du js jt ju jv b">@app.route("&lt;destination&gt;")</code>用于将URL与函数关联起来。也可以在视图函数中呈现HTML模板来生成页面。这是通过从Flask包中导入<code class="du js jt ju jv b">render_template</code>函数来完成的。要渲染的模板存储在应用包的<code class="du js jt ju jv b">templates</code>文件夹中，通过将文件名传递给<code class="du js jt ju jv b">render_template</code>函数来访问。额外的参数也可以传递到函数中，以改变页面上显示的内容。</p><p id="db60" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在本例中，index.html文件包含以下内容:</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="e3e3" class="kb kc hi jv b fi kd ke l kf kg">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;meta charset="utf-8"&gt;<br/>        &lt;title&gt;{{ title }}&lt;/title&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>       &lt;h1&gt;{{ title }}&lt;/h1&gt;<br/>    &lt;/body&gt;</span></pre><p id="0e64" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">routes.py文件包含以下内容来生成索引页面:</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="c9c7" class="kb kc hi jv b fi kd ke l kf kg">from app import app<br/>from flask import render_template</span><span id="af7b" class="kb kc hi jv b fi ki ke l kf kg">@app.route("/")<br/>@app.route("/index")<br/>def index():<br/>    return render_template("index.html", title = "Home Page")</span></pre><h2 id="4bdf" class="kb kc hi bd kk lm ln lo ko lp lq lr ks jf ls lt kw jj lu lv la jn lw lx le ly bi translated"><strong class="ak">首次运行应用程序</strong></h2><p id="f4c5" class="pw-post-body-paragraph iu iv hi iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr hb bi translated">在继续创建数据库模型并进行全面测试之前，检查Flask设置和到目前为止所做的一切工作是否正常非常重要。为此，需要将main.py文件分配给<code class="du js jt ju jv b">FLASK_APP</code>环境变量。这可以通过在Project_Folder目录中创建一个. flaskenv文件来实现。</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="66e0" class="kb kc hi jv b fi kd ke l kf kg">FLASK_APP=main.py</span></pre><p id="10c2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用这个环境文件，可以在终端中调用“flask”命令来运行应用程序和执行数据库迁移任务。要运行该应用程序，只需调用:</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="63c5" class="kb kc hi jv b fi kd ke l kf kg">(venv)user@mycomputer$ flask run</span></pre><p id="9d47" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这将在终端中启动一个调试器，通过在任何web浏览器中导航到127.0.0.1:5000，应用程序将可见。</p><h2 id="9af8" class="kb kc hi bd kk lm ln lo ko lp lq lr ks jf ls lt kw jj lu lv la jn lw lx le ly bi translated">创建用户数据库模型</h2><p id="9666" class="pw-post-body-paragraph iu iv hi iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr hb bi translated">现在，应用程序最基本的形式已经可以工作了，是时候添加与前面创建的数据库的交互了。这是通过在models.py文件中创建一个类来实现的，该类反映了数据在数据库中的存储方式。这些类通常被称为数据库模型或数据模型。</p><p id="084d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在models.py文件中，可以添加以下内容来为应用程序创建第一个数据库模型。在这种情况下，数据库将存储有趣新闻故事的标题和链接，以及谁将它们添加到数据库中:</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="6810" class="kb kc hi jv b fi kd ke l kf kg">from app import db</span><span id="f068" class="kb kc hi jv b fi ki ke l kf kg">class InterestingNews(db.Model):<br/>    id = db.Column(db.Integer, primary_key = True)<br/>    added_by = db.Column(db.String(64))<br/>    title = db.Column(db.String(128))<br/>    link = db.Column(db.String(128))</span><span id="f4d9" class="kb kc hi jv b fi ki ke l kf kg">    def __repr__(self):<br/>        return f"&lt;{self.added_by} added: {self.title}&gt;"</span></pre><p id="b81d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面代码中需要注意的一些事情。首先，代码第一行导入的<code class="du js jt ju jv b">db</code>对象是__init__中SQLAlchemy设置的实例。之前的py文件。其次，该类继承了先前存在的<code class="du js jt ju jv b">db.Model</code>类。最后，当在数据中创建新列时，它被定义为一个<code class="du js jt ju jv b">db.Column</code>对象，然后在其中指定数据类型。这将在以后的阶段中作为数据输入数据库时的验证。</p><h2 id="0397" class="kb kc hi bd kk lm ln lo ko lp lq lr ks jf ls lt kw jj lu lv la jn lw lx le ly bi translated">数据库的终端测试</h2><p id="cd94" class="pw-post-body-paragraph iu iv hi iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr hb bi translated">要测试数据库连接，启动Python3终端并运行以下命令:</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="26f3" class="kb kc hi jv b fi kd ke l kf kg">&gt;&gt;&gt; from app import db<br/>&gt;&gt;&gt; from app.models import InterestingNews<br/>&gt;&gt;&gt; news= InterestingNews(added_by= "name", title= "Funny story",<br/>                          link= "http://&lt;link_to_story&gt;")<br/>&gt;&gt;&gt; db.create_all()<br/>&gt;&gt;&gt; db.session.add(news)<br/>&gt;&gt;&gt; db.session.commit()<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; InterestingNews.query.all()<br/>[&lt;name added: Funny story&gt;]</span></pre><h2 id="a867" class="kb kc hi bd kk lm ln lo ko lp lq lr ks jf ls lt kw jj lu lv la jn lw lx le ly bi translated">创建表单以捕获数据</h2><p id="90db" class="pw-post-body-paragraph iu iv hi iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr hb bi translated">现在可以在终端中添加到数据库的连接和故事了，让我们更新flask应用程序以包含一个收集用户输入的表单。</p><p id="50a5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里的第一步是在app文件夹中创建一个名为<code class="du js jt ju jv b">forms.py</code>的新文件，在编辑该文件之前，还需要安装一个依赖项:</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="d075" class="kb kc hi jv b fi kd ke l kf kg">(venv)user@mycomputer$ pip3 install flask-wtf</span></pre><p id="6484" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在在<code class="du js jt ju jv b">forms.py</code>中，可以创建收集新闻故事链接的表单。表单字段将与之前创建的数据库模型的字段相匹配。</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="6e6c" class="kb kc hi jv b fi kd ke l kf kg">from flask_wtf import FlaskForm<br/>from wtforms import StringField, SubmitField<br/>from wtforms.validators import DataRequired</span><span id="8e92" class="kb kc hi jv b fi ki ke l kf kg">class NewsForm(FlaskForm):<br/>    added_by = StringField("Added By", validators=[DataRequired()])<br/>    title = StringField("Article Title", <br/>                         validators=[DataRequired()])<br/>    link = StringField("Article Link", validators=[DataRequired()])<br/>    submit = SubmitField("Submit")</span></pre><p id="6e8b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的NewsForm继承了FlaskForm类，并利用了wtforms模块中的StringField和SubmitFields。</p><p id="8c44" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要将表单放入网页，需要更新<code class="du js jt ju jv b">routes.py</code>文件来导入表单，并将其传递给生成页面的render_template函数。</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="adb1" class="kb kc hi jv b fi kd ke l kf kg">from app import app<br/>from flask import redirect, render_template, url_for<br/>from app.forms import NewsForm</span><span id="6087" class="kb kc hi jv b fi ki ke l kf kg">@app.route("/")<br/>@app.route("/index")<br/>def index():<br/>    news_form = NewsForm()<br/>    if news_form.validate_on_submit():<br/>        return redirect(url_for("index"))</span><span id="d3fa" class="kb kc hi jv b fi ki ke l kf kg">    return render_template("index.html", title = "Home Page", <br/>                            form = news_form)</span></pre><p id="0a22" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du js jt ju jv b">index.html</code>现在可以使用Jinja2将表单对象嵌入到表单中的页面上。在下面的代码中，定义了表单，使用语法<code class="du js jt ju jv b">{{ form.attribute.label }}</code>调用表单对象中的项目来提取文本标签，使用语法<code class="du js jt ju jv b">{{form.attribute(size=32)}}</code>来创建输入字段。</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="d4e3" class="kb kc hi jv b fi kd ke l kf kg">...<br/>&lt;form action="" method="post"&gt;<br/>    {{ form.hidden_tag() }}<br/>    &lt;p&gt;<br/>        {{ form.added_by.label }}&lt;br&gt;<br/>        {{ form.added_by(size=32) }}<br/>    &lt;/p&gt;<br/>    &lt;p&gt;<br/>        {{ form.title.label }}&lt;br&gt;<br/>        {{ form.title(size=32) }}<br/>    &lt;/p&gt;<br/>    &lt;p&gt;<br/>        {{ form.link.label }}&lt;br&gt;<br/>        {{ form.link(size=32) }}<br/>    &lt;/p&gt;<br/>    &lt;p&gt;{{ form.submit() }}&lt;/p&gt;<br/>&lt;/form&gt;<br/>...</span></pre><p id="72c3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，这个项目的最后阶段是在页面上显示一个表格，其中包含已经提交的新闻文章。在<code class="du js jt ju jv b">routes.py</code>文件的前一阶段，表单在提交时被验证。在验证表单的if语句中，表单的内容可以用来创建数据库项，就像在python shell中创建一样。</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="1c31" class="kb kc hi jv b fi kd ke l kf kg">from app import app<br/>from flask import redirect, render_template, url_for<br/>from app import db<br/>from app.forms import NewsForm<br/>from app.models import InterestingNews</span><span id="46ff" class="kb kc hi jv b fi ki ke l kf kg">@app.route("/")<br/>@app.route("/index")<br/>def index():<br/>    news_form = NewsForm()<br/>    news_stories = InterestingNews.query.all()</span><span id="f27e" class="kb kc hi jv b fi ki ke l kf kg">    if news_form.validate_on_submit():<br/>        news = InterestingNews(<br/>                 added_by = news_form.added_by.data,<br/>                 title = news_form.title.data,<br/>                 link = news_form.link.data<br/>        )<br/>        db.session.add(news)<br/>        db.session.commit()<br/>        return redirect(url_for("index"))</span><span id="6597" class="kb kc hi jv b fi ki ke l kf kg">    return render_template("index.html", title = "Home Page", <br/>                           form = news_form, stories = news_stories)</span></pre><p id="1024" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了让表格显示在web页面中，<code class="du js jt ju jv b">index.html</code>文件将被更新为包含一个表格，该表格带有一个表单循环，以生成与数据库中条目数量相对应的行数。</p><pre class="in io ip iq fd jx jv jy jz aw ka bi"><span id="981c" class="kb kc hi jv b fi kd ke l kf kg">...<br/>&lt;table&gt;<br/>   &lt;tr&gt;<br/>        &lt;th&gt;Added By&lt;/th&gt;<br/>        &lt;th&gt;Article Title&lt;/th&gt;<br/>        &lt;th&gt;Link&lt;/th&gt;<br/>    &lt;/tr&gt;<br/>    {% for story in stories %}<br/>        &lt;tr&gt;<br/>            &lt;td&gt;{{ story.added_by }}&lt;/td&gt;<br/>            &lt;td&gt;{{ story.title }}&lt;/td&gt;<br/>            &lt;td&gt;&lt;a href="{{ story.link }}"&gt;link&lt;a&gt;&lt;/td&gt;<br/>        &lt;/tr&gt;<br/>    {% endfor %}<br/>&lt;/table&gt;<br/>...</span></pre><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lz"><img src="../Images/e8c41f1ba648398289f65d9fb61b2739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*wJelfjcJSyBTlAdtUX-n3A.png"/></div></figure><h2 id="5528" class="kb kc hi bd kk lm ln lo ko lp lq lr ks jf ls lt kw jj lu lv la jn lw lx le ly bi translated">结论</h2><p id="b4ac" class="pw-post-body-paragraph iu iv hi iw b ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr hb bi translated">这篇文章比预期的要长。然而，总结一下这里所做的一切:</p><ul class=""><li id="915d" class="ma mb hi iw b ix iy jb jc jf mc jj md jn me jr mf mg mh mi bi translated">在Raspberry Pi 4上设置PostgreSQL服务器</li><li id="c950" class="ma mb hi iw b ix mj jb mk jf ml jj mm jn mn jr mf mg mh mi bi translated">创建模板烧瓶应用程序</li><li id="d7f8" class="ma mb hi iw b ix mj jb mk jf ml jj mm jn mn jr mf mg mh mi bi translated">将Flask应用程序连接到PostgreSQL服务器</li><li id="b659" class="ma mb hi iw b ix mj jb mk jf ml jj mm jn mn jr mf mg mh mi bi translated">创建表单以更新数据库</li><li id="1b19" class="ma mb hi iw b ix mj jb mk jf ml jj mm jn mn jr mf mg mh mi bi translated">在应用程序的表格中显示数据库内容</li></ul><p id="4abc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我希望这是对建立数据库并将其与Flask应用程序连接的有用介绍。这是一个简单的概述，有许多方法可以做到这一点，这些例子只是支持本文的基础。请随意对代码进行实验，并尝试提出其他示例，如果您真的这样做了，请在本文的评论中告诉我。我打算在以后的文章中扩展这个应用程序。</p><p id="ba8c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">非常感谢您的阅读:)</p></div></div>    
</body>
</html>