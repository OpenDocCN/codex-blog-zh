<html>
<head>
<title>Spring Boot Reactive Web Application — WebFlux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot反应式网络应用— WebFlux</h1>
<blockquote>原文：<a href="https://medium.com/codex/spring-boot-reactive-web-application-webflux-acef6ed7f37f?source=collection_archive---------3-----------------------#2022-04-25">https://medium.com/codex/spring-boot-reactive-web-application-webflux-acef6ed7f37f?source=collection_archive---------3-----------------------#2022-04-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/3da018514e21eefe14215c0c7c5be8a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*cvtVSnFy1Osko8Ic1YZqPQ.jpeg"/></div></figure><div class=""/><p id="982e" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">WebFlux是Spring Framework的一部分，它有助于实现一种编程范式，这种范式提倡一种异步、非阻塞、事件驱动的数据处理方法，称为反应式编程。反应式系统具有某些特性，使其成为低延迟、高吞吐量工作负载的理想选择。但这意味着什么呢？让我们先快速描述一下这些关键词。</p><p id="dfd5" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">异步:</strong>异步代码是一种并行编程技术，允许一个工作单元独立于主应用线程运行。当该单元的工作完成时，它将通知主线程，该主线程最终将通过精确的设计来提高性能和增强响应能力。</p><p id="e512" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">非阻塞:</strong>如果任何一个线程的失败或挂起不会导致另一个线程的失败或挂起，那么这个进程称为<strong class="io hq"> </strong>非阻塞。</p><p id="4aa3" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">事件驱动:</strong> It <strong class="io hq"/></p><p id="2e2f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了更好地理解它，让我们考虑一个例子，比如REST API，它简单地从数据库获取一些信息，并以JSON响应的形式返回。用Spring Web MVC实现这个例子，它有一个阻塞的特性，你会得到这样一个流程:</p><figure class="jk jl jm jn fd hk er es paragraph-image"><div class="er es hg"><img src="../Images/6e073396b2c1dcf273be7ec8b5cc0f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*5EbwXAu2IWduCtLXpSRk4g.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">用阻塞线程处理Web MVC请求</figcaption></figure><p id="1115" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">每个传入的请求都将由HTTP线程池中不同线程中的HTTP请求处理程序来处理。在服务层处理请求(包括从数据库获取信息)期间，线程被阻塞，不能被任何其他请求使用。正如您所看到的，服务器可以处理的请求数量取决于线程池的大小，如果阻塞过程花费的时间比预期的长，您将面临更长的响应时间，并且无法响应新的传入请求。</p><p id="6398" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另一方面，我们可以使用一种反应式方法，在我们的例子中是作为Spring Boot应用程序一部分的WebFlux。Spring WebFlux在内部使用<a class="ae js" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank"> Project Reactor </a>及其publisher实现Flux和Mono。</p><h2 id="f66e" class="jt ju hp bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">通量<t/></h2><p id="9de8" class="pw-post-body-paragraph im in hp io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">一个<code class="du kt ku kv kw b"><strong class="io hq">Flux&lt;T&gt;</strong></code>是一个标准的<code class="du kt ku kv kw b"><strong class="io hq">Publisher&lt;T&gt;</strong></code>，它代表一个0到N个发射项的异步序列，可选地由一个完成信号或一个错误终止。正如在Reactive Streams规范中，这三种类型的信号转换成对下游用户的<code class="du kt ku kv kw b"><strong class="io hq">onNext</strong></code>、<code class="du kt ku kv kw b"><strong class="io hq">onComplete</strong></code>和<code class="du kt ku kv kw b"><strong class="io hq">onError</strong></code>方法的调用。</p><h2 id="baf5" class="jt ju hp bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">单声道<t/></h2><p id="60b1" class="pw-post-body-paragraph im in hp io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">一个<code class="du kt ku kv kw b"><strong class="io hq">Mono&lt;T&gt;</strong></code>是一个专门的<code class="du kt ku kv kw b"><strong class="io hq">Publisher&lt;T&gt;</strong></code>，它通过发出最多一个<em class="kx">信号，然后以一个<code class="du kt ku kv kw b"><strong class="io hq">onComplete</strong></code>信号终止(成功的<code class="du kt ku kv kw b"><strong class="io hq">Mono</strong></code>，有或没有值)，或者只发出一个<code class="du kt ku kv kw b"><strong class="io hq">onError</strong></code>信号(失败的<code class="du kt ku kv kw b"><strong class="io hq">Mono</strong></code>)。</em></p><figure class="jk jl jm jn fd hk er es paragraph-image"><div class="er es hg"><img src="../Images/30da0f62a813e7ff2409bbd753145046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*2DmPAU8wanGJV_R60pnrZw.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">使用非阻塞线程处理Webflux请求</figcaption></figure><p id="d2eb" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如您在该图中看到的，与web MVC阻塞模型不同，所有传入的HTTP请求实际上都是由一个或一小组线程处理的。对于作为事件的每个传入请求，流程将传递给EventHandler来执行预期的业务逻辑，在本例中是从数据库中检索数据。使用非阻塞的R2DBC代替JDBC将有助于我们获得完全的非阻塞流。这意味着一旦从数据库请求的数据可用，它将被返回，在此期间，将不会有线程被阻塞请求。由于这个功能，您不会因为I/O延迟而阻塞线程，从而浪费处理时间。</p><h2 id="b53b" class="jt ju hp bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">应用服务器</h2><p id="3015" class="pw-post-body-paragraph im in hp io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">Spring Webflux默认将<a class="ae js" href="https://netty.io/" rel="noopener ugc nofollow" target="_blank"> Netty </a>作为嵌入式服务器。除此之外，在<a class="ae js" href="https://tomcat.apache.org/" rel="noopener ugc nofollow" target="_blank"> Tomcat </a>、<a class="ae js" href="https://www.eclipse.org/jetty/" rel="noopener ugc nofollow" target="_blank"> Jetty </a>、<a class="ae js" href="https://undertow.io/" rel="noopener ugc nofollow" target="_blank">under flow</a>等Servlet 3.1+容器上也支持。这里要注意的是，Netty和Undertow是非servlet运行时，Tomcat和Jetty是众所周知的servlet容器。</p><h1 id="9297" class="ky ju hp bd jv kz la lb jz lc ld le kd lf lg lh kg li lj lk kj ll lm ln km lo bi translated">Spring Boot的例子</h1><p id="c844" class="pw-post-body-paragraph im in hp io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">为了更好地理解，让我们使用Webflux创建一个示例REST API。假设我们想要一个用于教育应用的API，我们有两个端点，如下所示:</p><p id="f671" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> …/students/{id} </strong>:使用id检索学生信息</p><p id="2207" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">…/学生/列表</strong>:检索学生列表</p><h2 id="e5e9" class="jt ju hp bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">属国</h2><p id="90ce" class="pw-post-body-paragraph im in hp io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">以下依赖项是创建WebFlux web应用程序所需的基础。</p><pre class="jk jl jm jn fd lp kw lq lr aw ls bi"><span id="c7a3" class="jt ju hp kw b fi lt lu l lv lw">&lt;<strong class="kw hq">dependency</strong>&gt;<br/>      &lt;<strong class="kw hq">groupId</strong>&gt;org.springframework.boot&lt;/<strong class="kw hq">groupId</strong>&gt;<br/>      &lt;<strong class="kw hq">artifactId</strong>&gt;spring-boot-starter-webflux&lt;/<strong class="kw hq">artifactId</strong>&gt;<br/>&lt;/<strong class="kw hq">dependency</strong>&gt;</span></pre><p id="c066" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">除此之外，为了拥有一个完全非阻塞的反应式应用程序，您需要使用r2dbc启动器。</p><pre class="jk jl jm jn fd lp kw lq lr aw ls bi"><span id="e6db" class="jt ju hp kw b fi lt lu l lv lw">&lt;<strong class="kw hq">dependency</strong>&gt;<br/>   &lt;<strong class="kw hq">groupId</strong>&gt;org.springframework.boot&lt;/<strong class="kw hq">groupId</strong>&gt;<br/>   &lt;<strong class="kw hq">artifactId</strong>&gt;spring-boot-starter-data-r2dbc&lt;/<strong class="kw hq">artifactId</strong>&gt;<br/>&lt;/<strong class="kw hq">dependency</strong>&gt;</span></pre><p id="b15c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为简单起见，我们在测试应用程序中使用H2，这就是为什么我们在应用程序中需要r2dbc h2驱动程序依赖项。如果您使用MySQL、SQL Server或任何其他数据库，您可以轻松找到合适的驱动程序。</p><pre class="jk jl jm jn fd lp kw lq lr aw ls bi"><span id="0a1b" class="jt ju hp kw b fi lt lu l lv lw">&lt;<strong class="kw hq">dependency</strong>&gt;<br/>   &lt;<strong class="kw hq">groupId</strong>&gt;io.r2dbc&lt;/<strong class="kw hq">groupId</strong>&gt;<br/>   &lt;<strong class="kw hq">artifactId</strong>&gt;r2dbc-h2&lt;/<strong class="kw hq">artifactId</strong>&gt;<br/>&lt;/<strong class="kw hq">dependency</strong>&gt;</span></pre><h2 id="2c04" class="jt ju hp bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">控制器</h2><p id="033f" class="pw-post-body-paragraph im in hp io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">对于WebFlux应用程序，控制器将类似于Web MVC应用程序。在我们的例子中，每个端点有两个GET方法，唯一的区别是方法的返回类型。</p><pre class="jk jl jm jn fd lp kw lq lr aw ls bi"><span id="9015" class="jt ju hp kw b fi lt lu l lv lw">@RestController<br/>@RequestMapping(<strong class="kw hq">"/student"</strong>)<br/><strong class="kw hq">public class </strong>StudentController {<br/><br/>    @Autowired<br/>    StudentService <strong class="kw hq">studentService</strong>;<br/><br/>    @GetMapping(<strong class="kw hq">"/{id}"</strong>)<br/>    <strong class="kw hq">public </strong>Mono&lt;Student&gt; getStudentById(@PathVariable Long id ){<br/>        <strong class="kw hq">return studentService</strong>.getStudentById(id);<br/>    }<br/><br/>    @GetMapping(<strong class="kw hq">"/list"</strong>)<br/>    <strong class="kw hq">public </strong>Flux&lt;Student&gt; getStudentList(){<br/>        <strong class="kw hq">return studentService</strong>.getStudentList();<br/>    }<br/>    <br/>}</span></pre><p id="2148" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从代码中可以看出，这是一个非常常见的rest控制器。可能引起您注意的是0到1响应的返回类型<code class="du kt ku kv kw b">Mono&lt;T&gt;</code>和0到n响应的返回类型<code class="du kt ku kv kw b">Flux&lt;T&gt;</code>的不同。</p><h2 id="c80d" class="jt ju hp bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">服务</h2><p id="506d" class="pw-post-body-paragraph im in hp io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">为学生提供的服务与你日常使用的服务也没有太大的不同。</p><pre class="jk jl jm jn fd lp kw lq lr aw ls bi"><span id="26a0" class="jt ju hp kw b fi lt lu l lv lw">@Service<br/><strong class="kw hq">public class </strong>StudentService {<br/><br/>    @Autowired<br/>    StudentRepository <strong class="kw hq">studentRepository</strong>;<br/><br/>    <strong class="kw hq">public </strong>Mono&lt;Student&gt; getStudentById(Long id ){<br/>        <strong class="kw hq">return studentRepository</strong>.findById(id);<br/>    }<br/><br/>    <strong class="kw hq">public </strong>Flux&lt;Student&gt; getStudentList(){<br/>        <strong class="kw hq">return studentRepository</strong>.findAll();<br/>    }<br/><br/>}</span></pre><h2 id="70c8" class="jt ju hp bd jv jw jx jy jz ka kb kc kd ix ke kf kg jb kh ki kj jf kk kl km kn bi translated">贮藏室ˌ仓库</h2><p id="044a" class="pw-post-body-paragraph im in hp io b ip ko ir is it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj hb bi translated">由于我们使用r2dbc数据，我们将从<code class="du kt ku kv kw b">R2dbcRepository&lt;T,ID&gt;</code>接口扩展我们的学生资源库。</p><pre class="jk jl jm jn fd lp kw lq lr aw ls bi"><span id="0cd1" class="jt ju hp kw b fi lt lu l lv lw"><strong class="kw hq">public interface </strong>StudentRepository <strong class="kw hq">extends </strong>R2dbcRepository&lt;Student, Long&gt; {<br/>}</span></pre><p id="539c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于应用程序属性，以下属性足以作为开始。</p><pre class="jk jl jm jn fd lp kw lq lr aw ls bi"><span id="77b1" class="jt ju hp kw b fi lt lu l lv lw"><strong class="kw hq">spring.r2dbc.url</strong>=<strong class="kw hq">r2dbc:h2:mem:///~/db/testdb<br/>spring.r2dbc.username</strong>=<strong class="kw hq">sa<br/>spring.r2dbc.password</strong>=</span></pre><p id="c5c3" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，准备好您的学生实体和一些样本记录，您就可以测试应用程序了。</p><pre class="jk jl jm jn fd lp kw lq lr aw ls bi"><span id="b8ea" class="jt ju hp kw b fi lt lu l lv lw">@Data<br/>@AllArgsConstructor<br/>@NoArgsConstructor<br/>@Table(<strong class="kw hq">"student"</strong>)<br/><strong class="kw hq">public class </strong>Student {<br/>    <br/>    @Id<br/>    @GeneratedValue(strategy = GenerationType.<strong class="kw hq"><em class="kx">SEQUENCE</em></strong>)<br/>    <strong class="kw hq">private </strong>Long <strong class="kw hq">id</strong>;<br/>    <strong class="kw hq">private </strong>String <strong class="kw hq">name</strong>;<br/><br/>}</span></pre><p id="a615" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以用任何像chrome一样支持事件流的客户端来测试这个API。你可以在<a class="ae js" href="https://github.com/farzinpashaee/medium/tree/main/Spring%20Boot%20WebFlux%20-%20Reactive" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到这个项目的代码。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="a3f8" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">希望这篇文章对你有所帮助，请支持我，为这个故事鼓掌。如果你不知道事情是这样的:</p><figure class="jk jl jm jn fd hk er es paragraph-image"><div class="er es me"><img src="../Images/2a19a406941f6b1291729b823980ae34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O0NsAaAstdfp2z-m.gif"/></div></figure><p id="4374" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">或者在这里给我买杯咖啡<a class="ae js" href="https://www.buymeacoffee.com/fpashaee" rel="noopener ugc nofollow" target="_blank">！</a></p><p id="dccd" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">资源:</strong><a class="ae js" href="https://en.wikipedia.org/wiki/Event-driven_programming" rel="noopener ugc nofollow" target="_blank">en.wikipedia.org</a>，<a class="ae js" href="https://projectreactor.io/docs/core/release/reference/" rel="noopener ugc nofollow" target="_blank"> projectreactor.io </a></p></div></div>    
</body>
</html>