<html>
<head>
<title>AlphaCode’s Creativity and Problem-Solving Ability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AlphaCode的创造力和解决问题的能力</h1>
<blockquote>原文：<a href="https://medium.com/codex/alphacodes-creativity-and-problem-solving-ability-4f11d8f518a9?source=collection_archive---------24-----------------------#2022-05-23">https://medium.com/codex/alphacodes-creativity-and-problem-solving-ability-4f11d8f518a9?source=collection_archive---------24-----------------------#2022-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/3cab2d9600c5e571e92a274b43349727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fHDuVzaJo_5cXhrL"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">丹尼尔·弗兰奇在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><figure class="ev ex iw ix iy hk er es paragraph-image"><div class="er es iv"><img src="../Images/5b93b1ac3e5bf87631f118a56511b8af.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*846r6iapjSBiS0tHpOEmIQ.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图片来自<a class="ae hv" href="https://elbo.ai/" rel="noopener ugc nofollow" target="_blank"> https://elbo.ai </a>:编写计算机程序的机器人</figcaption></figure><h1 id="1b03" class="iz ja hy bd jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw bi translated"><strong class="ak">总结</strong></h1><p id="d3ea" class="pw-post-body-paragraph jx jy hy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">当任务是对一组英语指令进行编码时，AlphaCode非常擅长编写计算机程序。当需要一些洞察力来解决问题集时，AlphaCode擅长编写代码，但当需要更深入的洞察力时，它就不那么擅长了。</p><p id="1f90" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">通常，当发现这种洞察力时，它会导致一个与问题集中的指令没有关系的解决方案。有时，在一行代码中会实现多个逻辑操作，并且公认的解决方案通常非常简短。这种创造性的过程是显著的和有趣的，但不容易用转化和注意力的过程来解释。</p><p id="ac3a" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">强调了两个解决方案，它们简洁地显示了创作过程的结果，并将形成如何实现洞察力的进一步工作的基础。</p><h1 id="55f8" class="iz ja hy bd jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw bi translated"><strong class="ak">背景</strong></h1><p id="0a99" class="pw-post-body-paragraph jx jy hy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">这是我第二篇关于DeepMind的名为AlphaCode的编写计算机程序的技术的文章。他们的突破似乎不仅仅是人类语言翻译近期发展的延伸:创造性和解决问题都涉及其中。在我的第一篇文章中，我得出结论说<strong class="jz hz"> AlphaCode很棒，但有缺陷，但可能有用。</strong></p><p id="a115" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode不知道什么时候出错了，也没有办法自我修复。然而，我认为AlphaCode在与人类程序员的合作中可能是有用的，这就像有一个专家团队，总是和立即可用。还有其他协作工具，如OpenAI Codex和GitHub Copilot，我认为它们与AlphaCode有本质的不同。有了Codex和Copilot，人类开始这个过程，而有了AlphaCode，情况正好相反。这是一个关键的区别，因为字母代码似乎提供了创造力，并在事后由人类“收拾”来解决问题。</p><p id="3140" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">这篇文章讲的是AlphaCode的创造力和解决问题的能力。</p><h1 id="2bd2" class="iz ja hy bd jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw bi translated"><strong class="ak">证据</strong></h1><p id="94a6" class="pw-post-body-paragraph jx jy hy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">AlphaCode团队决定测试他们的技术，用它参加CodeForces的编码比赛。CodeForces公布了三个实际上来自AlphaCode的竞争对手的名字:SelectorUnlimited、Waggle Collide和AngularNumeric。这些参赛者使用Python语言尝试了33个问题，提出了54个解决方案。对于两个问题，AlphaCode的流程没有足够的测试数据。我已经将剩下的问题分类如下表所示:</p><figure class="lb lc ld le fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es la"><img src="../Images/8f6864fad08deefcc06d40bcd844e709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aw6DipS-72_YV_jCyzfNAw.png"/></div></div></figure><p id="34ec" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">使用CodeForces，一个问题用英语提出，并使用一些标准的数学符号。输入和所需的输出都已定义。提供了一小组具有正确输出的示例输入，有时还会提供解释。AlphaCode使用这套测试数据作为训练过程的一部分来开发解决方案。</p><p id="12c5" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">当一个潜在的解决方案被开发出来时，它被提交给CodeForces，然后code forces使用以前看不到的测试来测试这个解决方案。如果解决方案对于所有测试都是正确的，并且在时间和内存限制内运行，则该解决方案被接受。这些解决方案被计入上面的“已接受的解决方案”一栏。</p><p id="a7c2" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">通常在CodeForces中，会有一些洞察力或知识允许程序员创造性地产生一个简短、优雅、快速和内存高效的解决方案。如果AlphaCode发现了此洞察，它将被计入“发现的洞察”列</p><p id="bbb6" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">如果没有认识到这一点，一种较慢的强力方法通常可以完成这项工作，但不会被接受。这些解决方案，连同被接受的解决方案，被计算在上面的“解决方案被接受或时间失败”栏中。这篇专栏文章展示了AlphaCode在哪些方面提供了解决方案。</p><p id="9915" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">问题类型</strong></p><p id="f5aa" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">这31个问题被分为两类:</p><p id="ea21" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">一个简单的问题是通过对一组指令进行编码来获得解决方案。产生一个解决方案不需要洞察力，或许也不需要创造力</p><p id="97ce" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">一些问题受益于洞察力，这将导致比暴力更优雅的解决方案，并且经常需要避免由于时间或内存问题而导致的失败</p><p id="43c2" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">直截了当的结果</strong></p><p id="3a03" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">该过程的第一阶段是让AlphaCode“理解”问题:解释指令并转换成某种内部表示。这显然是该过程中非常重要的一步，AlphaCode团队报告称，问题语言的人工简化会产生更好的结果。他们还表明，去除问题解释的元素会降低成功。</p><p id="aa05" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">上表显示，AlphaCode能够为13个简单的问题提供解决方案。我们可以得出结论，AlphaCode擅长“理解”问题。第十四个问题的解决方案稍微复杂一些，因为它需要用两个独立的变量进行优化。</p><p id="94a5" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">总的来说，这些结果表明，AlphaCode擅长提供解决方案，即把问题编码或翻译成计算机语言。鉴于该系统的传统，这也许并不意外。</p><p id="5a71" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">真知灼见讨论</strong></p><p id="3650" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">这17个包含的问题中，洞察是有用的，在那里我们可以看到AlphaCode在工作中的创造性过程。举个例子，附录A中更深入探讨的gcd问题，可以简化为:给定n，求A，b，c其中a+b+c = n，gcd(a，b) = c其中GCD是最大公约数。其中的洞见是，通过使用c = 1，那么只需要求解gcd (b，n-b-1) = 1中的b。</p><p id="07a8" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode发现了这种洞察力。当人类产生这样一个解决方案时，我们说他们理解了问题，创造了一个解决方案，然后将它编码。</p><p id="9dec" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">“创造了一个解决方案”这一点对于机器学习来说是新的，也是有趣的。它从哪里来？AlphaCode是如何创造任何东西的？</p><p id="62e4" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">我们知道，AlphaCode似乎并不是通过复制长代码块来解决问题的。在论文中，该团队指出:我们没有发现证据表明我们的模型从训练数据中复制了核心逻辑。</p><p id="6347" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">现在应该可以放心地假设，AlphaCode只能知道它在训练数据中找到的内容。不过，我们可以假设，字母代码能够通过以新的方式组合现有知识来创造新的知识。毕竟，这通常是人类创造新东西的方式。</p><p id="06fc" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">通过对17个问题的解决方案的详细分析，是否有可能更好地理解这一创造性的过程？</p><p id="bbfa" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">在9个没有发现洞见的问题中，有5个问题的难度与发现洞见的问题相似。其中，一个强力解决方案被接受，另外两个按时失败。由此我们可以得出结论，创造性解决方案的一个或多个元素在训练数据中缺失。</p><p id="5562" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">在另外四个案例中，这个问题需要比平常更深刻的洞察力。这些问题将在附录a的末尾详细讨论。在每种情况下，见解都不是直截了当的，但是在一个案例中，AlphaCode确实提供了一个被接受的暴力解决方案。</p><p id="1f7e" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">缩小差距</strong></p><p id="53fd" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">在发现洞察力的八个问题中，对于人类来说，在五个案例中，洞察力来自对问题的逻辑分析和对数字的良好理解。<em class="lf">消除差距</em>问题是一个很好的例子，在附录b中有更全面的描述。本质上，提出问题时描述的过程被忽略，没有编码。求解是通过求一组数的平均值得到的，输入数据后用五行代码求解。</p><p id="1de9" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">矩形上的三角形</strong></p><p id="4841" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">对于其他三个案例，需要特定的知识。例如，矩形上有<em class="lf">个三角形，</em> <strong class="jz hz"> </strong>人类编码员需要知道三角形的公式以及如何获得三角形的高度。</p><p id="54f8" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">矩形上的<em class="lf">三角形</em>问题在附录b中有更全面的描述。总之，给定一个尺寸为w，h的矩形，边上有许多点，但不包括角上的点，找出由一边的两点和另一边的一点组成的面积最大的三角形。AlphaCode实际上在一行计算中实现了一个解决方案，它正确地识别了三角形最大面积的参数，并在正确的方程中使用了这些参数。</p><p id="f32a" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">结论</strong></p><p id="95f0" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">这一分析表明，在需要对一组指令进行编码的情况下，AlphaCode在生产计算机程序方面非常成功。</p><p id="2225" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">在需要一些洞察力的地方，它在生产计算机程序方面也相当成功(大约50%)。AlphaCode在处理需要更深刻洞察力的复杂问题时不太成功。</p><p id="9553" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">令人印象深刻的是，AlphaCode能够展示洞察力并产生创造性的解决方案。不幸的是，与transformer模型相关的通常解释，包括模型参与的标记<em class="lf">、</em>的突出显示，对理解这个过程没有帮助。</p><p id="b643" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">两个示例问题，即<em class="lf">闭合矩形</em>上的间隙和<em class="lf">三角形，已经被识别，这在研究这一创作过程时可能是有用的。在这两种情况下，解决方案都很简短，需要世界知识，并且不是基于对问题描述的编码。</em></p><p id="8eb9" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">DeepMind团队已经表明，解决方案不是基于从训练数据中大量复制。然而，AlphaCode的洞察力通常出现在短代码中，解决方案的本质可以在一行中。这条线可能隐藏在数百万行训练代码中吗？或者解决方案是两个或更多相关见解的创造性组合？不管怎样，这都是值得注意的。</p><p id="65cb" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">有一句老话，太阳底下无新事。我们提到的见解来自某个地方，进一步探索将是令人着迷的。也许我的下一步是深入研究训练数据。而我们也不应该因为另一句话“创意只是未被发现的抄袭”而心灰意冷！</p><h1 id="5908" class="iz ja hy bd jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw bi translated">附录A:有些见解是有用的，但并不总是能找到</h1><p id="0f9a" class="pw-post-body-paragraph jx jy hy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated">有19个问题需要一些洞察力。在八个案例中，AlphaCode提供了至少一个利用这种洞察力的解决方案。</p><p id="8974" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">在另外两种情况下(<em class="lf">建立排列</em>和<em class="lf">洗牌</em> ) <strong class="jz hz"> </strong>初始测试数据不具有代表性，因此给了AlphaCode一个对一组不充分解决方案的错误引导。这些案例不包括在以下百分比中。</p><p id="df69" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">在其他五种情况下，所需的洞察力与使用洞察力的八个问题所需的水平大致相同。在其中的三个案例中，成功地使用了迭代或蛮力方法。在其他情况下，暴力方法失败了。</p><p id="d974" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">在另外四个案例中，所需的洞察力特别模糊，AlphaCode没有找到洞察力或提供可接受的解决方案。</p><p id="f560" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">总的来说，当洞察有用时，AlphaCode在不到50%的情况下提供了这种专业知识。对于大约20%的情况，提供了非最佳解决方案，并且在大约30%的情况下，AlphaCode被难倒。</p><figure class="lb lc ld le fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lg"><img src="../Images/dd8324189ad987f3e4aaec077f760c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kl1Ki8WL5VyLd5sdkOOYIw.png"/></div></div></figure><p id="26ab" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">缺少余数:发现洞察力</strong></p><p id="6db9" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">在这个问题中，给你一个长度为n的不同正整数的数组。从数组中找出n/2个向下舍入的不同整数对x和y，这样y/x的余数就不会出现在数组中。如果有多个解决方案，打印任意一个。</p><p id="e504" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">所以给定数组2 7 5 3 4 8，可能的解是:874332。</p><p id="5865" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察</strong>:如果x是最小的数，y可以是其他任何数。</p><p id="f6bc" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode提供了五种尝试，四种使用暴力方法，一种基于上述见解。</p><p id="fcbd" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">不过，具有洞察力的代码很冗长。它包含不必要的代码、低效的测试和双重循环。在人工生成的代码中，您永远也找不到用臃肿的代码实现的如此聪明的解决方案。他们只是不能在一起。</p><p id="00cb" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">而且是一个非零:顿悟发现？</strong></p><p id="e182" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">给定一个包含l和r之间所有整数的数组，要确保按位and产生一个非零值，需要删除的最小元素数是多少？</p><p id="35ba" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察:</strong>找出哪个位是最常见的，并计算它出现的频率，比如说x。那么答案就是集合中的整数个数——x</p><p id="85f2" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AC提供了七种解决方案，但都按时失败。这些方法看起来的确是基于洞察力，但是实现起来太慢了。</p><p id="1184" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">数组与运算:洞察发现</strong></p><p id="fc6f" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">在这个问题中，给你一个由n个整数和另一个整数k组成的数组，其中2k &lt;=n. Perform k operations where two elements of the array, x and y, are removed and your score is increased by the maximum integer less than x/y. After the k operations add the remaining elements to the score. Find the minimum score possible.</p><p id="3ba3" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz"> Insight: </strong>通过将最高的数用作除数，将下一个最高的数用作被除数来获得最小分数。</p><p id="1f39" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode提供了两种尝试，两种尝试都是基于上述见解并被接受。这些解决方案包含逻辑上的错误和低效，但不会影响结果。</p><p id="894f" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">构建排列:未找到洞察力</strong></p><p id="0a1f" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">输入是三个整数n，a，b。给定整数1到n，排列整数，使得有a最大值和b最小值</p><p id="7ec0" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察:</strong>仅当abs(a-b) &lt; = 1时才有可能。如果a &gt; =b从最大值开始，否则从最小值开始</p><p id="ae30" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">初始测试数据不包括a-b = 1的情况。这是一个重要的案件，六次尝试都失败了。解决方案在正确的轨道上，但不会与更具代表性的测试集一起输入。</p><p id="c168" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">缩小差距:发现真知灼见</strong></p><p id="b589" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">问题是要尽量减小城市街区的高度差。本质上，问题是最小化一组整数之间的差。</p><p id="57ac" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察:</strong>整数求和，除以整数个数。如果有余数，答案是1，否则答案是0。</p><p id="5587" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">六次尝试由AlphaCode提供，三次使用迭代方法，三次基于上述见解。基于洞察力的三个包含不影响结果的不必要的代码。</p><p id="dd46" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">构建一个矩形:发现洞察力</strong></p><p id="6e88" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">有三根长度为整数l1、l2和l3的棍子。你被要求把其中的一根断成两段，这样你就可以用这4根棍子做出一个长方形。</p><p id="d34d" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">洞察力:如果两根木棒大小相等，第三根一定长度相等。或者，最长的棍子必须与其他两个棍子长度相加的长度相同。</p><p id="572c" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode提供了三种尝试，其中一种不应该被包括在内，因为它没有提供输出，另外两种是基于上面的见解。这两个基于洞察力的实现是不整洁和低效的。</p><p id="5b46" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">禁止序列:未发现洞察</strong></p><p id="11ce" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">给定两个字符串，S和T，找出不包括T作为子序列的S的最小排列。t是abc的一个置换。如果a中的字母在字母表中比b中的字母出现得早，则字符串a小于b。如果a可以通过从b中删除零个或多个字母来生成，则字符串a是b的子序列。</p><p id="1343" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察:</strong>解决方法就是只要T &lt; &gt; abc就行排序。如果T = abc，则执行acb等</p><p id="5920" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode只提供了一个解决方案，而且是错误的。错过了洞察力，并尝试了暴力方法。</p><p id="cdbe" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz"> GCD问题:发现洞察力</strong></p><p id="06de" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">给定n，求a，b，c其中a+b+c = n，gcd(a，b) = c其中gcd是最大公约数</p><p id="09f9" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察:</strong>通过使用c = 1，那么只需要在一个循环中找到gcd (b，n-b-1) = 1</p><p id="6d4c" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode提供了两种尝试，两种都是基于上面的见解并产生干净有效的代码。</p><p id="29f7" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">最小化距离:未发现洞察力</strong></p><p id="5388" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">仓库位于原点两侧的数字线上。每个仓库需要交付一个包裹。你从起点出发，最多可以携带k个包裹。你要运送到n个仓库，在最后一次运送时结束任务。完成任务所需的最小距离是多少？</p><p id="0088" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察力:</strong>避免在原始保存包中移动的低效率。</p><p id="94b7" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode提供了两次尝试，一次是错误的，另一次有运行时错误。错误的解决方案解决了号码线两端的起点，但是没有考虑到移动通过原始持有包裹的低效率</p><p id="75d8" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">失踪的二元模型:洞察发现</strong></p><p id="6cdf" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">单词w由一系列的a和b组成。可以从单词中产生一组二元模型，并按照它们在单词中出现的顺序呈现。去掉一个二元模型，问题是找到w。</p><p id="67cb" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察力:</strong>通过将一个二元模型中的第二个字母与下一个二元模型的第一个字母进行比较来检测缺失的二元模型。如果它们是不同的，丢失的二元模型的位置已经被找到。</p><p id="dee1" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode提供了15次尝试，其中14次是错误的，如果最初的测试更加严格，就不会被包括在内，一个解决方案基于上述见解，生成了干净高效的代码。</p><p id="6f9b" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">绘制数组:未找到洞察力</strong></p><p id="234f" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">给定一个正整数数组，选择一个整数d，使得数组中每隔一个整数就能被d整除，并且后面的整数不能整除。</p><p id="817b" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察:</strong>使用gcd()查找数组中的偶数和奇数元素。然后对偶数检查是否奇数，对奇数检查是否偶数产生余数。如果找到了，那么d存在。</p><p id="7a8e" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode提供了七次尝试，其中一次是错误的，其他解决方案会及时失败，并且基于迭代方法。AlphaCode没有发现这种洞察力，尽管一些解决方案确实使用了gcd()，但是它们是基于强力解决方案的。</p><p id="891a" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi">.</p><p id="7daf" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">辣椒粉和排列:未发现洞察力</strong></p><p id="cca3" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">排列是从1到n的任意顺序的n个不同数字的数组。通过对数组的元素执行运算，对给定的数字数组进行排列。操作是用mod x替换数组中的元素a，其中x是您可以定义的数字。对于每个操作，a和x可以改变。找出所需的最小操作数。</p><p id="ef10" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察</strong>:排序后当发现一个数&gt; n时，测试:ai mod y必须&lt; ai/2</p><p id="06b6" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode提供了两种尝试，两种方法都使用暴力。一次尝试错误，一次准时失败。没有发现洞察力。</p><p id="f884" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">坡旅甲和子序列的和:未找到洞察力</strong></p><p id="b6dd" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">从数组a中的3个正整数，产生一个新的排序数组b，长度为原始数组a中所有子序列之和的7。给定b找到a。</p><p id="d395" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察:</strong> a由b中两个最小的整数和最大的减去两个最小的整数组成</p><p id="612d" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode提供了三种尝试，虽然都被接受，但都是基于蛮力方法。AlphaCode找不到洞察力。</p><p id="42f4" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">无序播放:未找到洞察力</strong></p><p id="01aa" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">从二进制字符串中，选择恰好包含k个1的子字符串。打乱子字符串，使其成为原始字符串的新版本。通过选择不同的子字符串，可以得到多少种不同版本的原始字符串？</p><p id="facf" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察:</strong>需要组合公式的知识</p><p id="4ac7" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">只有一种尝试，不使用公式组合，容易失败。最初的测试只包含一个例子。</p><p id="43f3" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">矩形上的三角形:洞察发现</strong></p><p id="a311" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">给定一个矩形，尺寸为w，h，边上有许多点，但角上没有，找出由一边的两点和另一边的一点组成的面积最大的三角形。输出面积*2</p><p id="6f89" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞见</strong>:解答使用了三角形的面积公式。使用最大底部乘以高度</p><p id="86bd" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode提供了三种尝试，所有的尝试都被接受，并且都基于洞察力。</p><h1 id="4e97" class="iz ja hy bd jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw bi translated">需要但未找到的模糊见解</h1><p id="a03e" class="pw-post-body-paragraph jx jy hy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><strong class="jz hz">圣诞巧克力</strong></p><p id="a181" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">在一个数组中有一个将整数a转换为整数b的运算:其中k是2^k&gt;=a，b = 2^k-a。给定一个不同数字的数组，对于数组中的每一对，比如x和y，计算出将x转换为y所需的最少运算次数。在数组中找出一对，使从一对转换为第二对所需的最少运算次数最大化。</p><p id="cd88" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察力:</strong>每一个选项都要尝试，寻找最大最小值。寻找最小值在示例中有所暗示:通过零移动到解决方案</p><p id="b70c" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">只有一次错误的尝试。该方法没有返回步数的方法。这个问题只提供了两个例子。</p><p id="d6e4" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">烛台</strong></p><p id="2489" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">给定一个由0和1组成的字符串a，确定是否可以使用以下操作获得类似的字符串b:选择一个1，该1将保持不变，该字符串的所有其他元素将翻转为另一个值。</p><p id="068b" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察:</strong>设n为字符串的长度，x和y分别为字符串a和b中1的个数，z为a和b中不相同的元素个数。如果x= y那么ans = z，如果x= n+1-y那么ans =n-z。</p><p id="550f" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode提供了两次尝试，一次是错误的，另一次有运行时错误。</p><p id="d499" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">新年难题:</strong></p><p id="db54" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">Vlad有n个朋友，他将访问m个商店中的n-1个商店，为他的每个朋友买一份礼物。对于每个商店，都有一个n整数的列表，用来衡量最好的礼物会给他的每个朋友带来的快乐。弗拉德想最大限度地增加他的礼物所能带来的快乐。</p><p id="c261" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察:</strong>解是朋友最大欢喜和店铺最大欢喜的最小值。通过选择倒数第二个最大值来计算n-1次访问，可以获得商店的最大快乐。</p><p id="7654" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode提供了两种尝试，一种是错误的，而另一种解决方案虽然被接受，但是基于迭代方法。AlphaCode没有发现实际上模糊的洞察力。</p><p id="e6bd" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">二次集合</strong></p><p id="d580" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">如果一个正整数的元素的阶乘的乘积是一个正整数的平方，那么这个正整数集就是一个二次集。找出集合1，2，3…n的子集的最大二次集合</p><p id="f788" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察:</strong>阶乘分析显示哪些数字没有匹配对来提供平方。这种理解产生了一些需要编码的测试条件。</p><p id="30aa" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode提供了三次尝试，两次是错误的，另一次有运行时错误。测试代码在测试解决方案的可接受性方面帮助不大。</p><h1 id="c701" class="iz ja hy bd jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw bi translated">附录B:所选AlphaCode解决方案的详细分析</h1><p id="5bc0" class="pw-post-body-paragraph jx jy hy jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku hb bi translated"><strong class="jz hz">缺少余数</strong></p><p id="bd73" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">在这个问题中，给你一个长度为n的不同正整数的数组。从数组中找出n/2个向下舍入的不同整数对x和y，这样y/x的余数就不会出现在数组中。如果有多个解决方案，打印任意一个。</p><p id="4574" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">所以给定数组2 7 5 3 4 8，可能的解是:874332。</p><p id="2274" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">有一个非常简单的解决方案:将数组按升序排序，对于一个解决方案，x是列表中的第一个条目，y可以是任何其他数字:</p><p id="71ef" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">数组排序为2 3 4 5 7 8</p><p id="8f9f" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">x = 2</p><p id="c95d" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">y = 3余数1</p><p id="860d" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">y = 4余数0</p><p id="435a" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">y = 5余数1</p><p id="e7c2" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">不需要划分或检查。因此，除以数组中最小的数，余数就不会在数组中。</p><p id="5770" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">如你所料，解决这个问题的代码很简单。聪明的/创造性的/艰苦的工作是在打开电脑之前完成的:</p><pre class="lb lc ld le fd lh li lj lk aw ll bi"><span id="edee" class="lm ja hy li b fi ln lo l lp lq">for _ in range(int(input())):<br/>n=int(input())<br/>a=list(map(int,input().split()))<br/>a.sort()<br/>for i in range(n//2):<br/>print(a[i+1], a[0])</span></pre><p id="e001" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode对这个问题尝试了5次。它有3个解决方案被接受，2个因耗时太长而失败。事实上，被接受的解决方案中有两个与失败的解决方案非常相似，但编码效率略高。这四个解决方案是蛮力尝试，其中代码将所有内容除以所有内容以找到可接受的答案。</p><p id="37c9" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz"> AlphaCode确实在另一个被接受的解决方案上使用了创造性/巧妙的解决方案(ref)。</strong></p><p id="847d" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">不幸的是，这是一组冗长的代码:与上面的6行代码相比，有31行代码。它还包含不必要的代码、低效的测试和双重循环。在人工生成的代码中，您永远也找不到用臃肿的代码实现的如此聪明的解决方案。他们只是不能在一起。</p><p id="9b92" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">数组和运算</strong></p><p id="7678" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">在这个问题中，给你一个由n个整数和另一个整数k组成的数组，其中2k &lt;=n. Perform k operations where two elements of the array, x and y, are removed and your score is increased by the maximum integer less than x/y. After the k operations add the remaining elements to the score. Find the minimum score possible.</p><p id="22c0" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">The key to this problem is to realise that the minimum score is obtained by using the highest numbers as the divisors and the next highest numbers as the dividends.</p><p id="7164" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">There is a very simple solution: sort the array, add each element to the score for the first n-2k elements, then for k steps add int(next highest divided by highest) to the score and move to the next pair.</p><pre class="lb lc ld le fd lh li lj lk aw ll bi"><span id="37d7" class="lm ja hy li b fi ln lo l lp lq">for t in range(int(input())):<br/>n, k = map(int, input().split())<br/>a = [int(i) for i in input().split()]<br/>a.sort()<br/>s = sum(a[:n-(2*k)])<br/>for i in range(n-(2*k), n, 2):<br/>s += a[i]//a[i+1]<br/>print(s)</span></pre><p id="22f0" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode provides two solutions which are identical. The solutions are based on using the highest numbers for the divisions and are accepted. The solutions are not without their problems:</p><p id="e4fe" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">A calculation is done for every value of k from 0 to k. This would never produce a wrong final result as a minimum check is used but it is an unnecessary complication</p><p id="de03" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">The switch between adding the elements to dividing them is very clumsy and again unnecessary.</p><p id="d6cc" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode presents no brute force solutions which is understandable as they would be necessarily complex to code.</p><p id="83ea" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">填补了缺口</strong></p><p id="83a0" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">描述了一个过程(【https://codeforces.com/contest/1615/problem/A】T2)来修改n个塔块以最小化最高和最短之间的高度差。这个过程包括从一个塔上移动一块砖，并将其添加到另一个塔上。最高和最低的最小差距是多少？</p><p id="d7a9" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">这个问题的措辞是精心设计的，会把粗心的程序员引向暴力解决方案。本质上，问题是最小化一组整数之间的差，答案只能是1或0。</p><p id="57a6" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞察:</strong>整数求和，除以整数个数。如果有余数，答案是1，否则答案是0。</p><p id="6e15" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">六次尝试由AlphaCode提供，三次使用迭代方法，三次基于上述见解。基于洞察力的三个包含不影响结果的不必要的代码。下面是去掉一些冗余代码后的一个解决方案。</p><pre class="lb lc ld le fd lh li lj lk aw ll bi"><span id="9722" class="lm ja hy li b fi ln lo l lp lq">for _ in range(int(input())):<br/>n = int(input())<br/>l = list(map(int,input().split()))<br/>s = sum(l)<br/>if s%n == 0:<br/>print(0)<br/>else:<br/>print(1)</span></pre><p id="883c" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">因此，问题中描述的过程被忽略，解决方案基于求平均值，如果有余数，则答案为1，否则为0。</p><p id="efd3" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">数据输入在前三行代码中完成，解决方案只需要五行代码。</p><p id="b739" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">矩形上的三角形</strong></p><p id="14a2" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">给定一个矩形，尺寸为w，h，边上有许多点，但角上没有，找出由一边的两点和另一边的一点组成的面积最大的三角形。输出面积*2</p><p id="71cc" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated"><strong class="jz hz">洞见</strong>:解答使用了三角形的面积公式。使用最大底部乘以高度</p><p id="6acc" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">AlphaCode提供了三种尝试，所有的尝试都被接受，并且都基于洞察力。这里有一个例子:</p><pre class="lb lc ld le fd lh li lj lk aw ll bi"><span id="47e9" class="lm ja hy li b fi ln lo l lp lq">t = int(input())<br/>for i in range(t):<br/>w, h = map(int, input().split())<br/>x1 = list(map(int, input().split()))[1:]<br/>x2 = list(map(int, input().split()))[1:]<br/>y1 = list(map(int, input().split()))[1:]<br/>y2 = list(map(int, input().split()))[1:]<br/>x1.sort()<br/>x2.sort()<br/>y1.sort()<br/>y2.sort()<br/>print(max(x1[-1] * h — x1[0] * h, x2[-1] * h — x2[0] * h, y1[-1] * w — y1[0] * w, y2[-1] * w — y2[0] * w))</span></pre><p id="d37c" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">前七行处理数据输入。这个解是用五行得到的。计算在一行中完成，其中打印了最大底部乘以高度。</p><p id="a3a7" class="pw-post-body-paragraph jx jy hy jz b ka kv kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kz ks kt ku hb bi translated">计算矩形各边的最大底边时，需要四条排序线。需要三角形的公式来完成计算。人类编码员会知道矩形的邻边是三角形的高度。AlphaCode怎么知道的？</p></div></div>    
</body>
</html>