<html>
<head>
<title>Design Patterns | Way to understand LLD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式|理解LLD的方法</h1>
<blockquote>原文：<a href="https://medium.com/codex/design-patterns-way-to-understand-lld-38b3a102c627?source=collection_archive---------15-----------------------#2021-08-24">https://medium.com/codex/design-patterns-way-to-understand-lld-38b3a102c627?source=collection_archive---------15-----------------------#2021-08-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/f3fd4c8f32564dde6760f05185ab5ba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*hfZGco4avrvmESbYinWv5w.jpeg"/></div></figure><p id="5bc6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你目前正试图为亚马逊、微软或大型科技公司做准备，有三个主题你必须准备清楚。每个人都知道算法和数据结构有多重要。系统设计，换句话说，HLD(高层设计),为此我将强烈推荐Alex Xu的这本书。简单且做得很好的解释。和设计模式，即LLD(低级设计)。通过这些博客，我将尝试传达我对设计模式的理解，并希望能对读者有所帮助。我希望你们熟悉Python和它的类。开始吧！</p><p id="a007" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">什么是设计模式？</p><p id="888f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">简而言之，您可以基于一般问题的一般解决方案来构建您的代码。这些通用的解决方案被称为设计模式。设计模式是各种软件开发人员经验的积累。他们认为处理问题的最佳方式。设计模式在数量上是多种多样的，但是在我接下来的文章中，我们将只讨论其中最重要的10种。先说策略模式。</p><p id="b0b5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">战略模式</strong></p><p id="cd41" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">先说个例子。它会帮助我让你更好地理解这个概念。</p><p id="404f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你买了东西，现在你想让它被送到。许多公司都以不同的成本收费来这样做。我们想要的是有一个单一的接口，将处理这些不同的托运人，并计算与他们每个人的运输成本。当我们读到这类问题时，我们首先想到的是if/else语句。如果发货人是UPS，我们会这样做，否则我们会这样做，等等。了解策略模式将增强你的思维，摆脱这些原始的if/else语句。</p><p id="61e9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，有各种各样的托运人，如联邦快递，UPS，邮政服务，未来可能会有很多。所以我们的解决方案也应该是可扩展的。</p><p id="abe3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，我们将创建一个<strong class="io hj">订单</strong>类。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="5f85" class="jt ju hi jp b fi jv jw l jx jy">class Order:<br/>    def __init__(self):<br/>        pass</span></pre><p id="4b9f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请注意，我们的订单类不包含任何内容。将<strong class="io hj">的单一职责赋予特定的类</strong>是策略模式的一个原则。我们的运输成本类别<strong class="io hj">不会依赖</strong>订单类别。它们执行两种不同的功能。</p><p id="5559" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们将定义我们的ShippingCost类，它将作为这个问题的<strong class="io hj">上下文</strong>。运费会由它来计算。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="3976" class="jt ju hi jp b fi jv jw l jx jy">class ShippingCost:<br/>    def __init__(self, strategy):<br/>        self._strategy = strategy</span><span id="d4f5" class="jt ju hi jp b fi jz jw l jx jy">    def shipping_cost(self, order):<br/>        return self._strategy.calculate(order)</span></pre><p id="a743" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它从各种各样的运输商那里接受了一个策略。并在此基础上计算成本。</p><p id="7c2e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了让不同的发货人有不同的逻辑，我们必须有一个公共的<strong class="io hj">接口</strong>，在此基础上，我们将构建我们的代码，这样当我们给我们的类一些输入时，将会产生相同类型的输出。为了在Python中实现接口，我们使用ABC或抽象基类。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="d991" class="jt ju hi jp b fi jv jw l jx jy">from abc import ABCMeta, abstractmethod</span><span id="48e4" class="jt ju hi jp b fi jz jw l jx jy">class AbsStrategy:<br/>    __metaclass__ = ABCMeta</span><span id="f29b" class="jt ju hi jp b fi jz jw l jx jy">    @abstractmethod<br/>    def calculate(self, order):<br/>        pass</span></pre><p id="2f8b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的接口告诉我们，每个将从它继承的类必须在它们的定义中有<em class="ka"> calculate </em>方法。</p><p id="2ea3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我们将在基于我们的接口的各自的类中为不同的发货商定义逻辑/算法。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="0b81" class="jt ju hi jp b fi jv jw l jx jy">class FedExStrategy(AbsStrategy):<br/>    def calculate(self, order):<br/>        return 3.00</span><span id="19dd" class="jt ju hi jp b fi jz jw l jx jy">class PostalStrategy(AbsStrategy):<br/>    def calculate(self, order):<br/>        return 5.00</span><span id="2821" class="jt ju hi jp b fi jz jw l jx jy">class UPSStrategy(AbsStrategy):<br/>    def calculate(self, order):<br/>        return 4.00</span></pre><p id="e09f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以看到这个<strong class="io hj">是如何扩展的</strong>。如果你想添加另一个发货人，你只需要添加它自己的类。你不需要在我们的<strong class="io hj">上下文</strong>中进行修改，即ShippingCost或者我们的<strong class="io hj">接口</strong>或者在任何地方使用if/else，就像我们已经处理了<strong class="io hj">打开/关闭原则</strong>一样。</p><blockquote class="kb kc kd"><p id="31d0" class="im in ka io b ip iq ir is it iu iv iw ke iy iz ja kf jc jd je kg jg jh ji jj hb bi translated">驱动程序代码</p></blockquote><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="b093" class="jt ju hi jp b fi jv jw l jx jy"># Test FedX services</span><span id="a462" class="jt ju hi jp b fi jz jw l jx jy">order = Order()<br/>strategy = FedExStrategy()<br/>cost_calculator = ShippingCost(strategy)<br/>cost = cost_calculator.shipping_cost(order)<br/>assert cost == 3.00</span><span id="a3ff" class="jt ju hi jp b fi jz jw l jx jy"># Test UPS shipping</span><span id="901f" class="jt ju hi jp b fi jz jw l jx jy">order = Order()<br/>strategy = UPSStrategy()<br/>cost_calculator = ShippingCost(strategy)<br/>cost = cost_calculator.shipping_cost(order)<br/>assert cost == 4.00</span><span id="32a5" class="jt ju hi jp b fi jz jw l jx jy"># Test POST shipping</span><span id="e4f5" class="jt ju hi jp b fi jz jw l jx jy">order = Order()<br/>strategy = PostalStrategy()<br/>cost_calculator = ShippingCost(strategy)<br/>cost = cost_calculator.shipping_cost(order)<br/>assert cost == 5.00</span><span id="7b23" class="jt ju hi jp b fi jz jw l jx jy">print("All test passed\n\n\n")</span></pre><p id="a284" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以看到不同的成本是如何通过不同的策略或政策计算出来的。这就是为什么这种模式也被称为<strong class="io hj">策略模式</strong>。</p><p id="564c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ka">不同种类的逻辑/算法被封装，可以互换使用，如我们的驱动程序代码中的</em> <strong class="io hj"> <em class="ka">策略变量</em> </strong> <em class="ka">所示。</em></p><p id="edb0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">ShippingCost类将采用一个策略，并从它自己的私有方法“shipping_cost”中调用它们的calculate方法。</p><p id="5049" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您可以将上述代码复制到一个文件中。浏览并运行它。</p><p id="9c52" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们对策略模式的讨论到此结束。希望您能看到这一点的用处，并利用它来改进您的代码结构，给每个人留下深刻印象！下次见。</p></div></div>    
</body>
</html>