<html>
<head>
<title>Unity3D: How to Play Sound FX!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity3D:声音FX怎么玩！</h1>
<blockquote>原文：<a href="https://medium.com/codex/unity3d-how-to-play-sound-fx-54e840e385e9?source=collection_archive---------9-----------------------#2021-04-21">https://medium.com/codex/unity3d-how-to-play-sound-fx-54e840e385e9?source=collection_archive---------9-----------------------#2021-04-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7fa1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">你想知道如何在Unity中为你的游戏播放音效吗？你来对地方了！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d5a94b033d35161611bcf73ff655b7cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIFF436mys4WSxkmOs7Nvg.png"/></div></div></figure><p id="52c1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">目标是创建一个模块化的声音系统来调用特定的声音片段到它们在代码中各自的位置。如果你了解软件工程的基本原理，那么你应该记住SOLID中的S。</p><blockquote class="kf kg kh"><p id="bd61" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated"><strong class="jl hj">单一责任原则。</strong></p></blockquote><p id="40d5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们想创建一个负责游戏音频的对象。然后我们可以用它作为其他脚本交流的参考。</p><h1 id="0f68" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">创建游戏对象</h1><p id="5167" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">首先，让我们创建一个空的游戏对象，并将其命名为“Audio_Manager”</p><p id="a5f8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将保存我们所有声音剪辑的数据。</p><p id="ef2e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们还想附加“音频源”组件。我们稍后将引用它来播放任何被调用的声音。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lj"><img src="../Images/80e2814597c1bedb8b747beba1512641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*yknsJ-untRIl_cplyhV7DQ.png"/></div></figure><h1 id="abc3" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">创建脚本</h1><p id="03cc" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">我们需要创建一个脚本，并将其命名为“<strong class="jl hj"> AudioManager </strong>”将其附加到“<strong class="jl hj">Audio _ Manager</strong>”<em class="ki">游戏对象</em>。</p><p id="4a0b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">打开脚本，这样我们就可以开始编程了。</p><h1 id="ea1d" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">添加代码</h1><p id="6591" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">去掉启动和更新功能。我们不会使用它们。你现在应该有一个漂亮干净的界面(类布局)。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="3a52" class="lp kn hi ll b fi lq lr l ls lt">using UnityEngine;</span><span id="0af4" class="lp kn hi ll b fi lu lr l ls lt">public class AudioManager : MonoBehaviour<br/>{<br/><br/>}</span></pre><p id="aff7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们需要一个连接到“Audio_Manager”游戏对象的音频源的引用。</p><p id="afc7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du lv lw lx ll b">[SerializeField] private AudioSource _audioSource = null;</code></p><p id="3c80" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">保存脚本，返回Unity，并将音频源组件附加到检查器中的新栏。</p><p id="40c7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们还想创建“AudioClip”类型的变量来存储我们的声音剪辑。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="aa9c" class="lp kn hi ll b fi lq lr l ls lt">[SerializeField] private AudioClip _laser = null;<br/>[SerializeField] private AudioClip _explosion = null;<br/>[SerializeField] private AudioClip _powerup = null;</span></pre><p id="9f15" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们有了音频源和音频剪辑，我们可以为每个声音剪辑创建特定的公共方法。它将允许其他脚本调用它们，这就是我们想要做的。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="a291" class="lp kn hi ll b fi lq lr l ls lt">public void PlayExplosionSound()<br/>{<br/>   _audioSource.PlayOneShot(_explosion);<br/>}</span><span id="16ff" class="lp kn hi ll b fi lu lr l ls lt">public void PlayLaserSound()<br/>{<br/>   _audioSource.PlayOneShot(_laser);<br/>}</span><span id="62ae" class="lp kn hi ll b fi lu lr l ls lt">public void PlayPowerupSound()<br/>{<br/>   _audioSource.clip = _powerup;<br/>   _audioSource.Play();<br/>}</span></pre><p id="6a00" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们需要获取我们的<code class="du lv lw lx ll b">_audioSource</code>组件来访问<code class="du lv lw lx ll b">PlayOneShot(audio clip here)</code>函数。然后，我们需要将特定的音频片段传入函数的参数中。</p><p id="f501" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">什么是<code class="du lv lw lx ll b">PlayOneShot()</code>？它不会取消正在播放的剪辑。因此，如果我们同时有多个爆炸，前面的声音剪辑不会被切断。它会阻止它。</p><p id="d53d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这部分做完了！我只调用了三个方法，它们引用了播放各自的音频剪辑。背景音乐将拥有自己的游戏对象，作为“音频管理器”的子对象一会儿告诉你为什么！</p><h1 id="dc46" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">调用方法</h1><p id="b4f1" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">然后，我们需要将函数调用到它们在代码中的正确位置。我举个例子。</p><p id="c88f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我有一个开机脚本。它会检查玩家是否与它发生碰撞，激活该类型的能力，然后破坏加电游戏对象。</p><p id="6426" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们想在声音被破坏之前播放它。</p><p id="3192" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，让我们参考一下我们的AudioManager脚本:</p><p id="b2a9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du lv lw lx ll b">private AudioManager _audioManager = null;</code></p><p id="0c48" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们希望PowerUp脚本查找“Audio_Manager”游戏对象，并获取附加的“AudioManager”脚本。所以让我们找到它:</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="ecf9" class="lp kn hi ll b fi lq lr l ls lt">private void Awake()<br/>{<br/>   _audioManager =  GameObject.Find(“Audio_Manager”).GetComponent&lt;AudioManager&gt;();<br/>}</span></pre><p id="1983" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我们已经在<code class="du lv lw lx ll b">_audioManager</code>中缓存了“AudioManager ”,我们可以调用该函数来播放加电声音剪辑。我们将在逻辑所在的OnTriggerEnter2D()中调用它。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="7412" class="lp kn hi ll b fi lq lr l ls lt">private void OnTriggerEnter2D(Collider2D other)<br/>{<br/>   if (other.CompareTag(“Player”))<br/>   {<br/>      var player = other.transform.GetComponent&lt;Player&gt;();</span><span id="9492" class="lp kn hi ll b fi lu lr l ls lt">      if(player != null)<br/>      {<br/>         switch (_powerupType)<br/>         {<br/>            case PowerupType.TripleShot:<br/>               player.TripleShotActive();<br/>               break;<br/>            case PowerupType.Speed:<br/>               player.SpeedBoostActive();<br/>               break;<br/>            case PowerupType.Shield:<br/>               player.ShieldActive();<br/>               break;<br/>            default:<br/>               _powerupType = PowerupType.None;<br/>               break;<br/>          }<br/>      }</span><span id="c261" class="lp kn hi ll b fi lu lr l ls lt">      <strong class="ll hj">_audioManager.PlayPowerupSound();</strong></span><span id="155c" class="lp kn hi ll b fi lu lr l ls lt">      Destroy(gameObject);<br/>   }<br/>}</span></pre><p id="e909" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">用粗体表示，我们调用位于AudioManager脚本中的函数，在开机声音被破坏之前播放它。有道理。我们不想在游戏对象被破坏后调用它。不会叫的。</p><p id="305c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是在游戏中使用音效的一种方式。有许多方法可以解决这个问题。没有错误的做事方式。关键在于哪种方式更优？</p><h1 id="391b" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">背景音乐</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/95b4c72360cc52dceee6fee4167ae3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XS78kr_4Qe4CQqAE"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx translated">由<a class="ae md" href="https://unsplash.com/@sasotusar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨奥·图萨尔</a>在<a class="ae md" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c5d5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于背景音乐，我们希望它不间断地播放。因此，我们需要将音频源与AudioManager引用的音频源分开，并为背景音乐创建一个新的音频源。</p><p id="db7a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在“Audio_Manager”游戏对象中创建新的空游戏对象。我们希望它是一个子对象。命名为“BG_Music。”附加一个“音频源”组件。将背景音乐音频剪辑拖到“音频剪辑”栏中，确保选中“循环”和“唤醒时播放”。你完了！</p><p id="d65e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们现在有了一个简单的模块化音效系统。恭喜你。今天到此为止！感谢您的阅读。</p></div></div>    
</body>
</html>