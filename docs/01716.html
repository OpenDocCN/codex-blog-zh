<html>
<head>
<title>AWS API Gateway + Lambda — I’m going to need more coffee for this</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS API Gateway+Lambda——我需要更多的咖啡</h1>
<blockquote>原文：<a href="https://medium.com/codex/aws-api-gateway-lambda-im-going-to-need-more-coffee-for-this-21a210d48ec0?source=collection_archive---------2-----------------------#2021-05-23">https://medium.com/codex/aws-api-gateway-lambda-im-going-to-need-more-coffee-for-this-21a210d48ec0?source=collection_archive---------2-----------------------#2021-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e0c2b276639ecb959f17d9eec83e20bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9tCqCWAEQJCY_qzH5yKNAQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">泰姆斯米德的屋顶海洋(作者拍摄)</figcaption></figure><p id="0c17" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你回顾了我在过去几个月中使用AWS Lambda函数的经历，你可能不会惊讶地发现我的注意力已经转向想要探索在Lambda函数之前栓接一个API。在这种疯狂中有一些方法:虽然我对基于Lambda的处理和存档照片的管道很满意，但我真的想在上面放一个web界面，以便于浏览照片。我最初的想法是定期构建静态网页(因为我是按日期组织的)，但仔细想想，这是一个丑陋的想法。所以……是时候研究如何组装一个无服务器API了。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="878e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我首先要说的是，AWS让这变得比它应该变得更难了。围绕这一点的文档和教程材料可能会好得多。这些材料实际上没有什么<em class="js">错误</em>，但是它们是不透明和分散的。我认为这是由两件事造成的。首先，AWS API网关有两个版本，每个版本都支持HTTP和WebSockets，语义和配置略有不同。所以很多(零碎的)教程材料都在谈论WebSockets而不是HTTP，或者谈论版本1而不是版本2产品，或者将所有这些混合在一起。其次，用于管理AWS API网关的公开API和使用控制台的体验之间存在微妙的语义差异。坦率地说，我认为控制台是设置API网关的一个非常好的界面，其逻辑流程很有意义。它和AWS API不太匹配，当然也和Terraform不太匹配。</p><p id="d168" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，如果你回头看看我写的东西，你会注意到我是基础设施即代码和<a class="ae ka" href="https://www.terraform.io" rel="noopener ugc nofollow" target="_blank">地形</a>的粉丝。因此，即使对于这样一个简单的探索，我的偏好也是用Terraform来构建解决方案。有很多人谈论基础设施即代码对于可重复性、安全性或开发速度的好处，但对我来说还有一个额外的目的:一旦你习惯了阅读它，Terraform代码中使用的Hashicorp HCL可以很好地记录基础设施是如何配置的。在控制台上单击并不提供该记录，并且原始API调用在应用和管理配置的所有粘合代码中掩盖了配置。</p><p id="d560" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以。让我们继续吧。我最初的实验是一个非常简单的API。几个月前，我写了一些Java代码来探索如何使用<a class="ae ka" href="https://aws.amazon.com/codecommit/" rel="noopener ugc nofollow" target="_blank"> AWS CodeCommit </a>和<a class="ae ka" href="https://aws.amazon.com/codeartifact/" rel="noopener ugc nofollow" target="_blank"> AWS CodeArtifact </a>(参见<a class="ae ka" href="https://levelup.gitconnected.com/aws-codeartifact-with-maven-further-adventures-with-serverless-4ff07fd69e1b" rel="noopener ugc nofollow" target="_blank">https://level up . git connected . com/AWS-code artifact-with-maven-further-adventures-with-server less-4ff 07 FD 69 E1 b</a>)，所以对它的逻辑扩展是将这个库包装在一个Lambda中，并在它前面加上一个API。</p><p id="043c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这包括三个部分:定义API的Terraform代码、定义Lambda的Terraform代码和一些定义Lambda的Java代码。我还建立了基础设施来执行Lambda代码的无服务器构建，但我不会在这里花时间。(如果你有兴趣，请前往:<a class="ae ka" href="https://rahook.medium.com/serverless-code-pipelines-on-aws-30dfc91889c6" rel="noopener">https://ra hook . medium . com/server less-code-pipelines-on-AWS-30 DFC 91889 c 6</a>)。我也不会在定义Lambda的Terraform代码上花太多时间，因为除了API网关和Lambda之间的一点点连接之外，我在过去已经写过了。</p><p id="8630" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最好从AWS API网关开始。这在AWS文档中有所涉及，但那是一个错综复杂的段落，都是一样的。该定义有四个基本部分，不包括自定义域名的配置和某种认证/授权方案的配置。</p><p id="7e20" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，有<a class="ae ka" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/apigatewayv2_api" rel="noopener ugc nofollow" target="_blank"> API网关</a>本身。这里没有太多要定义的，它主要是一个存在的陈述，并成为所有其他配置的根源:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="f58f" class="kk kl hi kg b fi km kn l ko kp">resource "aws_apigatewayv2_api" "cidrapi" {<br/>  name = local.name<br/>  description   = "description here..."<br/>  version       = "1.0.0"<br/>  protocol_type = "HTTP"<br/>  disable_execute_api_endpoint = false<br/>  tags = merge({ "Name" = local.name }, var.tags)<br/>}</span></pre><p id="e802" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">API网关获得一个名称、一个描述和一个类型——指定<code class="du kq kr ks kg b">disable_execute_api_endpoint</code>无论如何都是默认的，但是我把它留在那里是为了提醒自己，当我想在它的位置添加一个自定义域时，禁用默认端点。</p><p id="e6d7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，您有一个或多个<a class="ae ka" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/apigatewayv2_integration" rel="noopener ugc nofollow" target="_blank">集成</a>来指定后端将会是什么。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="21c9" class="kk kl hi kg b fi km kn l ko kp">resource "aws_apigatewayv2_integration" "cidrapi" {<br/>  api_id           = aws_apigatewayv2_api.cidrapi.id<br/>  integration_type = "AWS_PROXY"</span><span id="f4ca" class="kk kl hi kg b fi kt kn l ko kp">  connection_type        = "INTERNET"<br/>  description            = "cidrapi service"<br/>  integration_method     = "POST"<br/>  integration_uri        = aws_lambda_function.cidrapi.invoke_arn<br/>  payload_format_version = "2.0"<br/>  timeout_milliseconds   = 30000<br/>}</span></pre><p id="8461" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有一个<em class="js"> lot </em>可以在这些集成上配置，即使是像这样一个简单的Lambda。这大部分都很简单，但是文档中对<em class="js"> integration_method </em>和<em class="js"> integration_type </em>解释得不够清楚。对于lambda来说，不明显的是只支持POST，这代表了网关调用Lambda的方式，与公开的API方法没有任何关系，这些方法可能是POST、GET、DELETE或任何您喜欢的方法。“代理”这个词的使用也有点误导，但是如果您认为API Gateway不仅仅是一个简单的门面的话，这是有意义的。</p><p id="556d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在他们的文档和例子中没有很好的表达，但是API Gateway，尤其是新版本，是一项非常令人印象深刻和灵活的技术。各种介绍性材料和教程可能会让您认为API Gateway仅限于在一些后端服务前设置一个门面。相反，可以将它视为一个独立的web服务器(有点像<a class="ae ka" href="https://www.nginx.com" rel="noopener ugc nofollow" target="_blank"> NGINX </a>)，它可以直接响应传入的请求，将请求传递给后端服务或外部URL，管理身份验证和TLS终止，并进行复杂的流量过滤、转换和整形。</p><p id="e495" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们简单的Lambda案例中，我们实际上只是使用API Gateway作为代理，以Lambda可以消化的形式(通过POST)将传入的请求传递给Lambda，并向调用者进行反向转换。对于大多数API+Lambda场景来说，这将是一个非常(非常)通用的模型，他们构建的架构在公开的API和Lambda后端代码之间提供了非常好的解耦。</p><p id="cbcc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们有一个API，我们有一个或多个集成—下一步是定义<a class="ae ka" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/apigatewayv2_route" rel="noopener ugc nofollow" target="_blank"> <em class="js">路线</em> </a> <em class="js">。</em>一般来说，这些定义了API将响应什么操作，以及如何处理这些操作。同样，在定义授权方面有很大的灵活性，并且有一些转换请求参数的工具，但是对于我们的简单例子，我们可以只传递请求:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="562b" class="kk kl hi kg b fi km kn l ko kp">resource "aws_apigatewayv2_route" "regions" {<br/>  operation_name = "listRegions"<br/>  api_id         = aws_apigatewayv2_api.cidrapi.id<br/>  route_key      = "GET /regions"<br/>  target         =<br/>     "integrations/${aws_apigatewayv2_integration.cidrapi.id}"<br/>}</span><span id="0381" class="kk kl hi kg b fi kt kn l ko kp">resource "aws_apigatewayv2_route" "services" {<br/>  operation_name = "listServices"<br/>  api_id         = aws_apigatewayv2_api.cidrapi.id<br/>  route_key      = "GET /services"<br/>  target         =<br/>     "integrations/${aws_apigatewayv2_integration.cidrapi.id}"<br/>}</span><span id="cb98" class="kk kl hi kg b fi kt kn l ko kp">resource "aws_apigatewayv2_route" "cidr" {<br/>  operation_name = "listCidr"<br/>  api_id         = aws_apigatewayv2_api.cidrapi.id<br/>  route_key      = "GET /cidr"<br/>  target         =<br/>     "integrations/${aws_apigatewayv2_integration.cidrapi.id}"<br/>}</span><span id="731e" class="kk kl hi kg b fi kt kn l ko kp">resource "aws_apigatewayv2_route" "cidr_region" {<br/>  operation_name = "listCidrByRegion"<br/>  api_id         = aws_apigatewayv2_api.cidrapi.id<br/>  route_key      = "GET /cidr/{region}"<br/>  target         =<br/>     "integrations/${aws_apigatewayv2_integration.cidrapi.id}"<br/>}</span><span id="f99a" class="kk kl hi kg b fi kt kn l ko kp">resource "aws_apigatewayv2_route" "cidr_service" {<br/>  operation_name = "listCidrByService"<br/>  api_id         = aws_apigatewayv2_api.cidrapi.id<br/>  route_key      = "GET /cidr/{region}/{service}"<br/>  target         =<br/>     "integrations/${aws_apigatewayv2_integration.cidrapi.id}"<br/>}</span></pre><p id="38f4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我的例子中，我定义了5个操作，并将它们交给我的集成来处理。这里需要注意一些事情。我可以有一个使用<code class="du kq kr ks kg b">$default</code>作为<code class="du kq kr ks kg b">route_key</code>的单一路由，但是这可能会要求我的Lambda需要更多的逻辑来理解传入的请求。此外，通过使用特定的<code class="du kq kr ks kg b">route_key</code>，API网关本身负责拒绝我不感兴趣的传入请求，而不是强制Lambda调用拒绝这些请求——换句话说，随意调用暴露的API不会导致不必要的Lambda调用。最后，您可能已经注意到，每条路线都可能有不同的目标，这对于一个重要的应用程序来说是非常可能的。</p><p id="d821" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">关于<a class="ae ka" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-routes.html" rel="noopener ugc nofollow" target="_blank">路由关键字</a>的文档非常混乱，不清楚是否可以定义预期的路径变量(例如上面例子中的<code class="du kq kr ks kg b">{region}</code>)以及“catch all”变量，这些变量或多或少代表URL末尾的通配符匹配(他们在文档中使用<code class="du kq kr ks kg b">{proxy+}</code>，只是为了增加混乱)。这些路径变量将显示为Lambda代码可用的路径变量的有序列表。如果你用了一个路线键，比如</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="f603" class="kk kl hi kg b fi km kn l ko kp">GET /{proxy+}</span></pre><p id="9387" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后<em class="js">任何</em>请求路径都会被接受，路径的所有元素最终都会在Lambda处理程序中显示为路径元素的有序列表。这看起来很方便，但是它使得Lambda代码更加复杂。在API Gateway中定义相当精确的路线，让您的Lambda代码更简单、更笨。</p><p id="c083" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">到目前为止，我们有API网关，一个或多个集成，一些路线。最后缺失的部分是相当混乱的命名“<a class="ae ka" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-stages.html" rel="noopener ugc nofollow" target="_blank">阶段</a>”。我怀疑AWS中的设计和意图在实现过程中发生了部分改变，文档非常简洁，没有提供任何信息。<em class="js">可能</em>他们认为这是一种公开不同版本的API，或者公开开发/测试/生产版本的方式(请<em class="js">不要这样做</em>——在这些阶段使用不同的帐户！)但是这里允许直接指定Lambdas(绕过集成配置)，并在请求中插入额外的参数(绕过路由配置)，这就变得混乱了。最后，您可以使用神奇的名称<code class="du kq kr ks kg b">$default</code>创建一个默认的stage，但是您可能不应该这样做。我需要花更多的时间在服务的这个特别混乱的角落。</p><p id="4307" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">尽管围绕着<em class="js">阶段</em>有些混乱，但是你不能不使用它——没有一个定义好的阶段，API就不会被发布并可供调用。另外，在<em class="js">阶段</em>中，您可以选择指定日志记录、监控和(特别是)速率限制:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="655c" class="kk kl hi kg b fi km kn l ko kp">resource "aws_apigatewayv2_stage" "v1" {<br/>  api_id      = aws_apigatewayv2_api.cidrapi.id<br/>  name        = "v1"<br/>  description = "V1 for ${local.name}"<br/>  auto_deploy = true</span><span id="b3d8" class="kk kl hi kg b fi kt kn l ko kp">  default_route_settings {<br/>    throttling_burst_limit = 50<br/>    throttling_rate_limit  = 100<br/>  }<br/>  tags = merge({ "Name" = local.name, "Version" = "V1" }, var.tags)<br/>}</span></pre><p id="8c1c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于这个API将会出现在互联网上(尽管有一个模糊的随机URL)，我想严格限制我的Lambda被调用的频率。这个月我最不需要的就是AWS的意外账单！</p><p id="3394" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您还会注意到我将<code class="du kq kr ks kg b">auto_deploy</code>设置为<code class="du kq kr ks kg b">true</code>——如果我将其设置为false，那么我还必须指定一个<a class="ae ka" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/apigatewayv2_deployment" rel="noopener ugc nofollow" target="_blank">部署</a>。虽然这样做的目的是让我能够控制API的发布时间，但这不是我现在需要的。API一经定义就发布，并且每当它的定义改变时就更新。</p><p id="e58b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">毕竟，这意味着我们可以使用stage的<code class="du kq kr ks kg b">invoke_url</code>属性来调用Lambda。你应该记得我有一条路线，路线关键字是这样的</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="c369" class="kk kl hi kg b fi km kn l ko kp">GET /cidr/{region}/{service}</span></pre><p id="a779" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我用<code class="du kq kr ks kg b">name</code>“v1”定义了这个阶段。我可以调用的结果URL变成了:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="a266" class="kk kl hi kg b fi km kn l ko kp">https://mqciw5p4x8.execute-api.eu-west-2.amazonaws.com/v1/cidr/eu-west-2/EBS</span></pre><p id="b9eb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">(那可能对你有用，但是我不能保证URL没有改变！)</p><p id="623d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后一点——我们需要允许AWS API Gateway调用我们的Lambda。我总是被这个绊倒，可能是因为Lambda权限不是通过AWS IAM服务管理的。所以最后一部分是:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b01d" class="kk kl hi kg b fi km kn l ko kp">resource "aws_lambda_permission" "allow_api" {<br/>  for_each = toset([<br/>    "services",<br/>    "cidr",<br/>    "cidr/{region}",<br/>    "cidr/{region}/{service}",<br/>    "regions"<br/>  ])</span><span id="9416" class="kk kl hi kg b fi kt kn l ko kp">  statement_id_prefix = "ExecuteByAPI"<br/>  action              = "lambda:InvokeFunction"<br/>  function_name       = aws_lambda_function.cidrapi.function_name<br/>  principal           = "apigateway.amazonaws.com"<br/>  source_arn          = "${aws_apigatewayv2_api.cidrapi.execution_arn}/*/*/${each.key}"<br/>}</span></pre><p id="1be2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这并不是非常复杂，尽管相对于<code class="du kq kr ks kg b">execution_arn</code>指定<code class="du kq kr ks kg b">source_arn</code>的需求有点笨拙。在这种情况下，我为每个潜在的输入源创建独立的权限，但是我可以用通配符代替<code class="du kq kr ks kg b">${each.key}</code>创建一个单独的权限，例如</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="2488" class="kk kl hi kg b fi km kn l ko kp">resource "aws_lambda_permission" "allow_api" {<br/>  statement_id_prefix = "ExecuteByAPI"<br/>  action              = "lambda:InvokeFunction"<br/>  function_name       = aws_lambda_function.cidrapi.function_name<br/>  principal           = "apigateway.amazonaws.com"<br/>  source_arn          = "${aws_apigatewayv2_api.cidrapi.execution_arn}/*/*/*"<br/>}</span></pre><p id="212f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，我选择不这样做，因为我更喜欢从一开始就应用最小特权的原则，而不是在我可能忘记的时候试图添加它。如果你的Lambda支持大量的请求URL，这种方法可能不适合你，但是如果你的Lambda正在做几个不相关的任务，你应该把它分开。</p><p id="ded2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在地形方面就是这样，让我们考虑Lambda代码。使用<a class="ae ka" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-java.html" rel="noopener ugc nofollow" target="_blank"> Lambda SDK </a>非常愉快，调用处理程序的定义非常简单。</p><p id="ea52" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">不过我要说的是，我并不完全喜欢为AWS Lambda使用Java。当Lambda实例还没有预热时，API明显很慢，当实例启动时，它需要相当长的时间来获得响应，而Java完成它的启动:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="158f" class="kk kl hi kg b fi km kn l ko kp">$ time curl https://mqciw5p4x8.execute-api.eu-west-2.amazonaws.com/v1/cidr/eu-west-2/EBS</span><span id="8e83" class="kk kl hi kg b fi kt kn l ko kp">["18.168.37.136/29","18.168.37.144/30"]</span><span id="16d1" class="kk kl hi kg b fi kt kn l ko kp">curl   0.02s user 0.01s system 0% cpu 26.383 total</span></pre><p id="5f61" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦实例运行，响应时间是没问题的，但是第一次命中是致命的。在我用Go或者Python做的任何实验中，这一点都不明显。</p><p id="d019" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">抛开这一点，处理程序代码很简单。有一些你需要的导入:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="26d9" class="kk kl hi kg b fi km kn l ko kp">import com.amazonaws.services.lambda.runtime.Context;<br/>import com.amazonaws.services.lambda.runtime.RequestHandler;<br/>import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent;<br/>import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse;</span></pre><p id="018c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当然还有相关的Maven依赖项(如果你坚持使用Gradle，那就靠你自己了):</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="d5fb" class="kk kl hi kg b fi km kn l ko kp">&lt;dependency&gt;<br/>  &lt;groupId&gt;com.amazonaws&lt;/groupId&gt;<br/>  &lt;artifactId&gt;aws-lambda-java-core&lt;/artifactId&gt;<br/>  &lt;version&gt;1.2.1&lt;/version&gt;<br/>&lt;/dependency&gt;<br/><br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;com.amazonaws&lt;/groupId&gt;<br/>  &lt;artifactId&gt;aws-lambda-java-events&lt;/artifactId&gt;<br/>  &lt;version&gt;3.8.0&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="0556" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">类定义是<code class="du kq kr ks kg b">RequestHandler</code>的一个实现:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="2d23" class="kk kl hi kg b fi km kn l ko kp">public class Handler implements RequestHandler&lt;APIGatewayV2HTTPEvent, APIGatewayV2HTTPResponse&gt; {<br/>}</span></pre><p id="ee83" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这要求我们实现一个单一的功能:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="af0b" class="kk kl hi kg b fi km kn l ko kp">@Override<br/>public APIGatewayV2HTTPResponse handleRequest(final APIGatewayV2HTTPEvent event, final Context context) {<br/>}</span></pre><p id="63a9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">很明显，<code class="du kq kr ks kg b">APIGatewayV2HTTPEvent</code>和<code class="du kq kr ks kg b">APIGatewayV2HTTPResponse</code>分别包装了请求和响应。<code class="du kq kr ks kg b">Context</code>对象包含关于Lambda及其环境的细节，比如函数名和ARN，但它也给你提供了对<code class="du kq kr ks kg b">LambdaLogger</code>的访问:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="60da" class="kk kl hi kg b fi km kn l ko kp">context.getLogger().log("this message shows up in the console")</span></pre><p id="8c40" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果Lambda被连接到CloudWatch，那么日志消息会被发送到那里，否则它们会被发送到Lambda控制台。当你写代码的时候，你不需要知道<em class="js">的任何事情。但是请注意，当您测试处理程序时，您需要注入一个模拟上下文，并且在测试期间提供一个模拟<code class="du kq kr ks kg b">LambdaLogger</code>来记录到您的本地日志环境中也是很方便的。AWS Lambda开发人员指南包含了一些有用的例子。</em></p><p id="e9e2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">传入的<code class="du kq kr ks kg b">APIGatewayV2HTTPEvent</code>包含相当多您可能需要处理请求的东西，但是不要让它压倒您。呈现为JSON的传入请求示例如下:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="032e" class="kk kl hi kg b fi km kn l ko kp">{<br/>    "version": "2.0",<br/>    "routeKey": "GET /cidr/{region}/{service}",<br/>    "rawPath": "/v1/cidr/eu-west-2/S3",<br/>    "rawQueryString": "ipv6=true",<br/>    "headers": {<br/>        "accept": "*/*",<br/>        "content-length": "0",<br/>        "host": "mqciw5p4x8.execute-api.eu-west-2.amazonaws.com",<br/>        "user-agent": "curl/7.64.1",<br/>        "x-amzn-trace-id": "Root=1-60a7a07d-39030559613c7c1754c2ff6d",<br/>        "x-forwarded-for": "89.36.68.26",<br/>        "x-forwarded-port": "443",<br/>        "x-forwarded-proto": "https"<br/>    },<br/>    "queryStringParameters": {<br/>        "ipv6": "true"<br/>    },<br/>    "pathParameters": {<br/>        "region": "eu-west-2",<br/>        "service": "S3"<br/>    },<br/>    "isBase64Encoded": false,<br/>    "requestContext": {<br/>        "routeKey": "GET /cidr/{region}/{service}",<br/>        "accountId": "304388919931",<br/>        "stage": "v1",<br/>        "apiId": "mqciw5p4x8",<br/>        "domainName": "mqciw5p4x8.execute-api.eu-west-2.amazonaws.com",<br/>        "domainPrefix": "mqciw5p4x8",<br/>        "time": "21/May/2021:11:58:53 +0000",<br/>        "timeEpoch": 1621598333192,<br/>        "http": {<br/>            "method": "GET",<br/>            "path": "/v1/cidr/eu-west-2/S3",<br/>            "protocol": "HTTP/1.1",<br/>            "sourceIp": "89.36.68.26",<br/>            "userAgent": "curl/7.64.1"<br/>        },<br/>        "requestId": "frYDkj2TrPEEMWw="<br/>    }<br/>}</span></pre><p id="cf17" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">幸运的是，您不必处理JSON的任何一部分，或者所有这些细节，因为请求/响应对象为您提供了有用的方法。</p><p id="0e77" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">出于我的目的，我需要看到被调用的HTTP路径、路径参数(如果有的话)和查询参数(如果有的话)。</p><p id="0ba9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">获取路径？简单(但注意它不包括和查询参数):</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="e01c" class="kk kl hi kg b fi km kn l ko kp">String rawPath = event.getRawPath();</span><span id="cf30" class="kk kl hi kg b fi kt kn l ko kp">--&gt; "/v1/cidr/eu-west-2/S3"</span></pre><p id="1569" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">测试是否有查询参数“ipv6=true”也很简单，因为<code class="du kq kr ks kg b">getQueryStringParameters()</code>给了我们一个<code class="du kq kr ks kg b">Map&lt;String, String&gt;</code></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="2276" class="kk kl hi kg b fi km kn l ko kp">boolean ipv6 = Boolean.<em class="js">parseBoolean</em>(<br/>    event.getQueryStringParameters()<br/>         .getOrDefault("ipv6", "false")<br/>);</span><span id="10d4" class="kk kl hi kg b fi kt kn l ko kp">--&gt; false</span></pre><p id="f2f7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">路径参数也是如此。我有“服务”路径参数吗？</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="0f4a" class="kk kl hi kg b fi km kn l ko kp">String service = event.getPathParameters()<br/>    .getOrDefault("service", null);</span><span id="ae3c" class="kk kl hi kg b fi kt kn l ko kp">--&gt; "S3"</span></pre><p id="c03b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这足以让我调用我的库来计算响应。构建响应很简单(注意，我使用Google的<a class="ae ka" href="https://github.com/google/gson" rel="noopener ugc nofollow" target="_blank"> GSON </a>序列化为JSON):</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="ddba" class="kk kl hi kg b fi km kn l ko kp">Gson gson = new GsonBuilder().setPrettyPrinting().create();</span><span id="ddac" class="kk kl hi kg b fi kt kn l ko kp">responseData = &lt;&lt;calling my library here&gt;&gt;</span><span id="0cd5" class="kk kl hi kg b fi kt kn l ko kp">return APIGatewayV2HTTPResponse.<em class="js">builder</em>()<br/>        .withStatusCode(200)<br/>        .withHeaders(Map.<em class="js">of</em>("Content-Type","application/json"))<br/>        .withBody(gson.toJson(responseData))<br/>        .build();</span></pre><p id="cea5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">或者，如果我想建立一个错误响应:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="1ea7" class="kk kl hi kg b fi km kn l ko kp">return APIGatewayV2HTTPResponse.<em class="js">builder</em>()<br/>        .withStatusCode(503)<br/>        .withHeaders(Map.<em class="js">of</em>("Content-Type", "application/json"))<br/>        .withBody("{}").build();</span></pre><p id="9b7d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这种情况下，我仍然返回一个空的JSON对象，只是为了在错误响应和良好响应之间保持一致。</p><p id="f155" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">AWS API Gateway有很多令人喜欢的地方，尤其是新版本。它结合了强大的功能和灵活性，以及易于设置、部署和管理的优势。将它与Lambda函数结合起来，会产生一种架构，它消除了传统API+后端服务解决方案的许多麻烦。对于许多用例来说，这是一个理想的解决方案，因此令人失望的是，现有的文档和教程材料太差了，以至于学习曲线变得不必要的陡峭。</p></div></div>    
</body>
</html>