<html>
<head>
<title>Coding the True Strength Index and Backtesting a Trading Strategy in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python编写真实力量指数代码和回测交易策略</h1>
<blockquote>原文：<a href="https://medium.com/codex/coding-the-true-strength-index-and-backtesting-a-trading-strategy-in-python-24cb24b796be?source=collection_archive---------0-----------------------#2021-06-14">https://medium.com/codex/coding-the-true-strength-index-and-backtesting-a-trading-strategy-in-python-24cb24b796be?source=collection_archive---------0-----------------------#2021-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="978d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在python中实现强大指标和交易策略的完整过程，以便在市场中进行更好的交易</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a0680cb794b5dc936c87114de6463e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ON22t_DyUASe1Iye"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="90f1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有一个领域存在着奇特的技术指标，如相对强弱指数、随机振荡器、MACD等。，我们今天要讨论的指标肯定会添加到这个列表中，因为它的性能超过了上述指标。这就是真正的力量指数，简称TSI。</p><p id="0481" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本文中，我们将首先建立一些关于该指标的基本直觉，以及它是如何计算的或其背后的数学。然后，我们将进入编程部分，在这里我们将使用Python从头构建指标，构建交易策略，对策略进行回溯测试，并将结果与SPY ETF(一种专门用于跟踪标准普尔500市场指数运动的ETF)的结果进行比较。事不宜迟，让我们跳入文章吧！</p><p id="bce1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在继续之前，如果你想在没有任何代码的情况下回溯测试你的交易策略，有一个解决方案。这是<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">的后验区</a>。这是一个平台，可以免费对不同类型的可交易资产的任意数量的交易策略进行回溯测试，无需编码。点击这里的链接，你可以马上使用这个工具:<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">https://www.backtestzone.com/</a></p><h1 id="201d" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">真实强度指数</h1><p id="db0b" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">真实力量指数(TSI)是一个动量振荡器，主要由交易者用来确定市场是向上还是向下的动量，并随之交易。它还用于识别市场的当前状态，超买或超卖，但这不是该指标的主要优势。真实强度指数由两部分组成:</p><ul class=""><li id="2e00" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated">TSI线:第一部分是TSI线本身，通过首先确定实际价格变化(当前收盘价减去前一收盘价)和绝对价格变化(实际价格变化的绝对值)来计算。然后，实际价格变化和绝对价格变化都采用周期数为25的均线(多头)。然后这两个EMA被13天的指数移动平均线平滑。用两个EMA平滑数据序列的过程称为双重平滑，这样做的目的是消除数据中的噪声。现在，双重平滑的实际价格变化除以双重平滑的绝对价格变化，然后乘以100，以获得TSI线的读数。请注意，我们考虑的参数(25，13)是典型设置，但可以相应调整。计算可能很模糊，但如果我们以公式或图示的形式来解释，就很容易理解:</li></ul><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="7b6c" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">TSI LINE</strong> = [ <strong class="lr hj">DS. ACTUAL PC</strong> / <strong class="lr hj">DS. ABSOLUTE PC</strong> ] * <strong class="lr hj">100</strong></span><span id="b0c1" class="lv kl hi lr b fi ma lx l ly lz">where,</span><span id="3915" class="lv kl hi lr b fi ma lx l ly lz"><strong class="lr hj">DS. ACTUAL PC</strong> = Double smoothed actual price change with the length of 25 and 13</span><span id="f0fd" class="lv kl hi lr b fi ma lx l ly lz"><strong class="lr hj">DS. ABSOLUTE PC</strong> = Double smoothed absolute price change with the length of 25 and 13</span></pre><ul class=""><li id="c33d" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated">信号线:下一个组件是信号线组件，它只是TSI在指定周期数(在7到12个周期内)的指数移动平均值。大多数交易者喜欢日交易周期接近7，长期投资周期接近12。在本文中，我们将周期数定为12，因为我们将处理每日时间段的股票数据，而不是分钟时间段的数据。该计算可以表示如下:</li></ul><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="2f09" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">SIGNAL LINE</strong> = <strong class="lr hj">EXP.MA 13</strong> [ <strong class="lr hj">TSI LINE </strong>]</span></pre><p id="50d8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是该指标的全部内容及其背后的数学原理。现在，让我们分析一个图表，其中真实力量指数的读数与苹果的收盘价数据一起绘制，以建立对该指标及其工作方式的更多理解。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/de451ed26d77a433fa54417d9682898e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lR8j6BGua8rkWwqD1lz1hg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="e5a2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的图表分为两个面板:上面的面板显示了苹果公司的收盘价数据，下面的面板显示了TSI的成分读数。正如我之前所说，TSI主要用于发现市场的动力，这可以在图表中清楚地看到，TSI读数高于正区域(大于零)直接表明市场处于上升势头，低于负区域表明市场处于下降势头。</p><p id="1d0e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，让我们看看TSI如何被用来确定市场是处于超买还是超卖的状态。通常，像RSI这样的指标有一个超买和超卖水平的标准阈值，分别是70和30，这些阈值适用于任何可交易的资产。然而，在使用真实力量指数时，超买和超卖的水平因资产而异，在我们的情况下，我们可以认为-10是超卖水平，10是超买水平。但是，它不会像其他流行的动量振荡器那样有效。</p><p id="d1ec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">说到交易策略，据我所知，我们可以根据真正的实力指数运用三种策略。第一个是超买和超卖水平。这是动量振荡器中最常见的策略，每当TSI的成分低于超卖水平时，就会显示买入信号，每当两个成分的读数都高于超买水平时，就会产生卖出信号。我个人不使用这种策略，因为我相信真正的力量指数没有超买和超卖的概念。</p><p id="4980" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第二个交易策略是零线交叉，当TSI的成分从零以下交叉到零以上时，显示买入信号，同样，当TSI的成分从零以上交叉时，显示卖出信号。这个策略是有效的，但不如我们将要讨论的下一个交易策略有效。</p><p id="60df" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后一个交易策略，也是我们将在本文中实施的策略是信号线交叉，每当TSI线从信号线的下方交叉到上方时，它显示买入信号，同样，每当TSI线从信号线的上方交叉到下方时，它显示卖出信号。这种策略是最常用的交易策略之一，同时使用真正的力量指数，因为它在市场上的效率。这种交易策略可以表示如下:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="6857" class="lv kl hi lr b fi lw lx l ly lz">IF <strong class="lr hj">PREV.TLINE</strong> &lt; <strong class="lr hj">PREV.SLINE</strong> AND <strong class="lr hj">CUR.TLINE </strong>&gt; <strong class="lr hj">CUR.SLINE</strong> ==&gt; <strong class="lr hj">BUY SIGNAL</strong><br/>IF <strong class="lr hj">PREV.TLINE</strong> &gt; <strong class="lr hj">PREV.SLINE</strong> AND <strong class="lr hj">CUR.TLINE </strong>&lt;<strong class="lr hj"> CUR.SLINE</strong> ==&gt; <strong class="lr hj">SELL SIGNAL</strong></span></pre><p id="e8a8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就是这样！这就结束了我们关于真实强度指数的理论部分。现在让我们继续编程，我们将首先使用Python从头构建指标，构建信号线交叉交易策略，对苹果股票数据进行回溯测试，并将结果与SPY ETF的结果进行比较。来做点编码吧！在继续之前，关于免责声明的一个注意事项:本文的唯一目的是教育人们，必须被视为一个信息，而不是投资建议等。</p><h1 id="fe6c" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">用Python实现</h1><p id="76b9" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">编码部分分为以下几个步骤:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="263a" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">1. Importing Packages<br/>2. Extracting Stock Data from Twelve Data<br/>3. True Strength Index Calculation<br/>4. Creating the Signal line crossover Trading Strategy<br/>5. Plotting the Trading Lists<br/>6. Creating our Position<br/>7. Backtesting<br/>8. SPY ETF Comparison</strong></span></pre><p id="7d55" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h1 id="e5bb" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">步骤1:导入包</h1><p id="fabc" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="3156" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="e277" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># IMPORTING PACKAGES<br/></strong><br/>import pandas as pd<br/>import requests<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)</span></pre><p id="d9d8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经将所有需要的包导入到python中。我们用十二数据的API端点来拉一下苹果的历史数据。</p><h2 id="c515" class="lv kl hi bd km mc md me kq mf mg mh ku jx mi mj kw kb mk ml ky kf mm mn la mo bi translated">步骤2:从12个数据中提取数据</h2><p id="b704" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将使用由<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>提供的API端点提取苹果的历史股票数据。在此之前，请注意twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank"/>:十二数据公司是领先的市场数据提供商之一，拥有大量各种市场数据的API端点。它非常容易与十二数据提供的API进行交互，并且拥有有史以来最好的文档。此外，确保你有一个twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">的账户，只有这样，你才能访问你的API密匙(用API提取数据的重要元素)。</a></p><p id="a8d8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="603e" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># EXTRACTING STOCK DATA<br/></strong><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>aapl = get_historical_data('AAPL', '2019-01-01')<br/>aapl.tail()</span></pre><p id="aad5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/44b06ae51e5b1b8aa5732dd67db7a5a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gORXwbM22ZyuPz4Bh_8sbw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="1e31" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们做的第一件事是定义一个名为‘get _ historical _ data’的函数，该函数将股票的符号(‘symbol’)和历史数据的起始日期(‘start _ date’)作为参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们正在调用创建的函数来提取苹果从2019年开始的历史数据，并将其存储到‘AAPL’变量中。</p><h2 id="d36e" class="lv kl hi bd km mc md me kq mf mg mh ku jx mi mj kw kb mk ml ky kf mm mn la mo bi translated">步骤3:真实强度指数计算</h2><p id="00de" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将按照之前讨论的方法和公式计算真实强度指数的组成部分。</p><p id="0e69" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="d2ca" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># TRUE STRENGTH INDEX CALCULATION <br/></strong><br/>def get_tsi(close, long, short, signal):<br/>    diff = close - close.shift(1)<br/>    abs_diff = abs(diff)<br/>    <br/>    diff_smoothed = diff.ewm(span = long, adjust = False).mean()<br/>    diff_double_smoothed = diff_smoothed.ewm(span = short, adjust = False).mean()<br/>    abs_diff_smoothed = abs_diff.ewm(span = long, adjust = False).mean()<br/>    abs_diff_double_smoothed = abs_diff_smoothed.ewm(span = short, adjust = False).mean()<br/>    <br/>    tsi = (diff_double_smoothed / abs_diff_double_smoothed) * 100<br/>    signal = tsi.ewm(span = signal, adjust = False).mean()<br/>    tsi = tsi[tsi.index &gt;= '2020-01-01'].dropna()<br/>    signal = signal[signal.index &gt;= '2020-01-01'].dropna()<br/>    <br/>    return tsi, signal<br/><br/>aapl['tsi'], aapl['signal_line'] = get_tsi(aapl['close'], 25, 13, 12)<br/>aapl = aapl[aapl.index &gt;= '2020-01-01']<br/>aapl.tail()</span></pre><p id="d5ee" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/75366ba87487bcb833746109ba79a5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NdP0QchzjEMy-0rRlkwf0Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="4406" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为“get_tsi”的函数，它将股票的收盘价数据(“close”)、长均线的回望期(“long”)、短均线的回望期(“short”)和信号线的回望期(“signal”)作为参数。在函数内部，我们首先计算实际价格变化(' diff ')和绝对价格变化(' abs_diff ')并将其存储到各自的变量中。</p><p id="e902" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，使用Pandas软件包提供的“ewm”函数来确定指数移动平均值，我们对之前计算的价格变化进行双重平滑，以获得双重平滑的实际价格变化(“diff_double_smoothed”)和双重平滑的绝对价格变化(“abs_diff_double_smoothed”)。</p><p id="ae1b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，我们将双平滑值代入TSI线的公式，以确定其读数。为了计算信号线的值，我们采用特定周期数的已确定TSI线读数的EMA。最后，我们将返回计算出的组件，并调用创建的函数来存储Apple的TSI组件的值。</p><h2 id="2ba9" class="lv kl hi bd km mc md me kq mf mg mh ku jx mi mj kw kb mk ml ky kf mm mn la mo bi translated">步骤4:创建交易策略</h2><p id="026b" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">这一步，我们要用python实现讨论过的真实力指标信号线交叉交易策略。</p><p id="928d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="fcaa" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># TRUE STRENGTH INDEX STRATEGY<br/></strong><br/>def implement_tsi_strategy(prices, tsi, signal_line):<br/>    buy_price = []<br/>    sell_price = []<br/>    tsi_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(prices)):<br/>        if tsi[i-1] &lt; signal_line[i-1] and tsi[i] &gt; signal_line[i]:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                tsi_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                tsi_signal.append(0)<br/>        elif tsi[i-1] &gt; signal_line[i-1] and tsi[i] &lt; signal_line[i]:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                tsi_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                tsi_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            tsi_signal.append(0)<br/>            <br/>    return buy_price, sell_price, tsi_signal<br/><br/>buy_price, sell_price, tsi_signal = implement_tsi_strategy(aapl['close'], aapl['tsi'], aapl['signal_line'])</span></pre><p id="ef1e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为‘implement _ TSI _ strategy’的函数，它将股票价格(‘prices’)和真实强度指数的成分(‘TSI’，‘signal _ line’)作为参数。</p><p id="df2a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在该函数中，我们创建了三个空列表(buy_price、sell_price和tsi_signal ),在创建交易策略时，将在这些列表中追加值。</p><p id="ceb8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之后，我们通过for循环实施交易策略。在for循环内部，我们传递某些条件，如果条件得到满足，相应的值将被追加到空列表中。如果购买股票的条件得到满足，买入价将被追加到“buy_price”列表中，信号值将被追加为1，表示购买股票。类似地，如果卖出股票的条件得到满足，卖价将被追加到“sell_price”列表中，信号值将被追加为-1，表示卖出股票。</p><p id="3e4a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们返回附加了值的列表。然后，我们调用创建的函数并将值存储到各自的变量中。除非我们画出这些值，否则这个列表没有任何意义。所以，让我们画出创建的交易列表的值。</p><h2 id="30d0" class="lv kl hi bd km mc md me kq mf mg mh ku jx mi mj kw kb mk ml ky kf mm mn la mo bi translated">第五步:绘制交易信号</h2><p id="b934" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将绘制已创建的交易列表，以使它们有意义。</p><p id="01e5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="5c3a" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># TRUE STRENGTH INDEX TRADING SIGNALS PLOT<br/></strong><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(aapl['close'], linewidth = 2)<br/>ax1.plot(aapl.index, buy_price, marker = '^', markersize = 12, color = 'green', linewidth = 0, label = 'BUY SIGNAL')<br/>ax1.plot(aapl.index, sell_price, marker = 'v', markersize = 12, color = 'r', linewidth = 0, label = 'SELL SIGNAL')<br/>ax1.legend()<br/>ax1.set_title('AAPL TSI TRADING SIGNALS')<br/>ax2.plot(aapl['tsi'], linewidth = 2, color = 'orange', label = 'TSI LINE')<br/>ax2.plot(aapl['signal_line'], linewidth = 2, color = '#FF006E', label = 'SIGNAL LINE')<br/>ax2.set_title('AAPL TSI 25,13,12')<br/>ax2.legend()<br/>plt.show()</span></pre><p id="b947" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/866c6ae0218a2626e6e56806905c567b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G0KMQI5icn1G1IgMcn9ElA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="7b13" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们在绘制真实力量指数的成分，以及信号线交叉交易策略产生的买入和卖出信号。我们可以观察到，每当TSI线的前一个读数低于信号线的前一个读数，而TSI线的当前读数高于信号线的当前读数时，就会在图表中绘制绿色的买入信号。类似地，只要TSI线的前一个读数高于信号线的前一个读数，而TSI线的当前读数低于信号线的当前读数，图表中就会出现红色的卖出信号。</p><h2 id="3e84" class="lv kl hi bd km mc md me kq mf mg mh ku jx mi mj kw kb mk ml ky kf mm mn la mo bi translated">步骤6:创建我们的职位</h2><p id="100f" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将创建一个列表，如果我们持有股票，该列表将指示1；如果我们不拥有或持有股票，该列表将指示0。</p><p id="fedb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="e9f5" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># STOCK POSITION<br/></strong><br/>position = []<br/>for i in range(len(tsi_signal)):<br/>    if tsi_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(aapl['close'])):<br/>    if tsi_signal[i] == 1:<br/>        position[i] = 1<br/>    elif tsi_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = aapl['close']<br/>tsi = aapl['tsi']<br/>signal_line = aapl['signal_line']<br/>tsi_signal = pd.DataFrame(tsi_signal).rename(columns = {0:'tsi_signal'}).set_index(aapl.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'tsi_position'}).set_index(aapl.index)<br/><br/>frames = [close_price, tsi, signal_line, tsi_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy</span></pre><p id="0209" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/f05339981df574dd444414dfdfc22f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRIeUQ6bujZ1geRps_CMVA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="c5b1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们创建一个名为‘position’的空列表。我们传递两个for循环，一个是为“位置”列表生成值，以匹配“信号”列表的长度。另一个for循环是我们用来生成实际位置值的循环。在第二个for循环中，我们对“signal”列表的值进行迭代，而“position”列表的值被附加到满足哪个条件上。如果我们持有股票，头寸的价值仍为1；如果我们卖出或不持有股票，头寸的价值仍为0。最后，我们正在进行一些数据操作，将所有创建的列表合并到一个数据帧中。</p><p id="bfa8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从显示的输出中，我们可以看到，在前两行中，我们在股票中的位置保持为1(因为真实强度指数信号没有任何变化)，但是当真实强度指数交易信号代表卖出信号(-1)时，我们的位置突然变为-1。我们的头寸将保持为0，直到交易信号发生一些变化。现在是时候实现一些回溯测试过程了！</p><h2 id="948a" class="lv kl hi bd km mc md me kq mf mg mh ku jx mi mj kw kb mk ml ky kf mm mn la mo bi translated">步骤7:回溯测试</h2><p id="f110" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在继续之前，有必要知道什么是回溯测试。回溯测试是查看我们的交易策略在给定股票数据上表现如何的过程。在我们的例子中，我们将对苹果股票数据的真实实力指数交易策略实施回溯测试过程。</p><p id="9628" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="bd7c" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># BACKTESTING<br/></strong><br/>aapl_ret = pd.DataFrame(np.diff(aapl['close'])).rename(columns = {0:'returns'})<br/>tsi_strategy_ret = []<br/><br/>for i in range(len(aapl_ret)):<br/>    returns = aapl_ret['returns'][i]*strategy['tsi_position'][i]<br/>    tsi_strategy_ret.append(returns)<br/>    <br/>tsi_strategy_ret_df = pd.DataFrame(tsi_strategy_ret).rename(columns = {0:'tsi_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/aapl['close'][0])<br/>tsi_investment_ret = []<br/><br/>for i in range(len(tsi_strategy_ret_df['tsi_returns'])):<br/>    returns = number_of_stocks*tsi_strategy_ret_df['tsi_returns'][i]<br/>    tsi_investment_ret.append(returns)<br/><br/>tsi_investment_ret_df = pd.DataFrame(tsi_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(tsi_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the tsi strategy by investing $100k in AAPL : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the tsi strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre><p id="9f98" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="ce88" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">Profit gained from the tsi strategy by investing $100k in AAPL : 71095.33</strong><br/><strong class="lr hj">Profit percentage of the tsi strategy : 71%</strong></span></pre><p id="c1cf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们使用NumPy包提供的‘diff’函数计算苹果股票的回报，并将其作为数据帧存储到‘AAPL _ ret’变量中。接下来，我们传递一个for循环来迭代' aapl_ret '变量的值，以计算我们从TSI交易策略中获得的回报，这些回报值被附加到' tsi_strategy_ret '列表中。接下来，我们将“tsi_strategy_ret”列表转换为数据帧，并将其存储到“tsi_strategy_ret_df”变量中。</p><p id="0d1e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是回溯测试过程。我们将通过投资10万美元到我们的交易策略中来回测我们的策略。首先，我们将投资金额存储到“投资值”变量中。之后，我们正在计算使用投资金额可以购买的苹果股票数量。你可以注意到，我使用了Math软件包提供的“floor”函数，因为当投资金额除以苹果股票的收盘价时，它会输出一个十进制数。股票数量应该是整数，而不是小数。使用“底数”函数，我们可以去掉小数。请记住,“floor”函数比“round”函数要复杂得多。然后，我们传递一个for循环来查找投资回报，后面是一些数据操作任务。</p><p id="826b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们打印了我们通过投资10万到我们的交易策略中得到的总回报，并且显示我们在一年中获得了大约71，000美元的利润。那还不错！现在，让我们将我们的回报与SPY ETF(一种旨在跟踪标准普尔500股票市场指数的ETF)的回报进行比较。</p><h2 id="24d2" class="lv kl hi bd km mc md me kq mf mg mh ku jx mi mj kw kb mk ml ky kf mm mn la mo bi translated">第八步:间谍ETF对比</h2><p id="42b4" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">这一步是可选的，但强烈推荐，因为我们可以了解我们的交易策略相对于基准(间谍ETF)的表现如何。在这一步，我们将使用我们创建的“get_historical_data”函数提取SPY ETF数据，并将我们从SPY ETF获得的回报与我们在Apple上的TSI信号线交叉交易策略回报进行比较。</p><p id="3db8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可能已经注意到，在我所有的算法交易文章中，我没有将策略结果与标准普尔500市场指数本身进行比较，而是与SPY ETF进行比较，这是因为大多数股票数据提供商(如12 Data)不提供标准普尔500指数数据。所以，我别无选择，只能选择间谍ETF。如果你有幸得到标准普尔500市场指数数据，建议用它来做比较，而不是任何ETF。</p><p id="6e8a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="f5db" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># SPY ETF COMPARISON<br/></strong><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('TSI Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre><p id="e408" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="1e07" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">Benchmark profit by investing $100k : 23370.75</strong><br/><strong class="lr hj">Benchmark Profit percentage : 23%</strong><br/><strong class="lr hj">TSI Strategy profit is 48% higher than the Benchmark Profit</strong></span></pre><p id="9273" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>这一步中使用的代码几乎与前一个回溯测试步骤中使用的代码相似，但我们不是投资苹果，而是通过不实施任何交易策略来投资SPY ETF。从输出可以看出，我们的真实力指数信号线交叉交易策略已经跑赢了SPY ETF 48%。太好了！</p><h1 id="ebfd" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后的想法！</h1><p id="7df2" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在经历了压倒性的理论和编程过程后，我们已经成功地了解了真正的实力指数是什么，指标背后的数学原理，以及基于它的盈利交易策略的实施。尽管我们成功超越了间谍ETF的业绩，但我们仍落后于一个特定领域。</p><p id="05e7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本文中，我们的算法在所有交易中买入和卖出相同数量的股票，但在现实世界中交易时，这不是一个最佳决策，因为它是任意的，这就是头寸规模的概念发挥作用的地方。对于那些对这个概念没有概念的人来说，头寸规模是将我们投资组合的一部分分配给我们想要交易的特定股票的过程。我们可以做的是，我们可以部署一个头寸规模系统，评估每笔交易的风险，并相应地分配股票数量。这不仅能大幅提升业绩，还能防止我们面临意外损失。所以，我强烈建议你跟进这个概念，并尝试把它应用到交易策略中。</p><p id="af18" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">话虽如此，你已经到了文章的结尾。如果您忘记了遵循任何编码部分，不要担心。我在最后提供了完整的源代码。希望你能从这篇文章中学到一些新的有用的东西。</p><h2 id="dd37" class="lv kl hi bd km mc md me kq mf mg mh ku jx mi mj kw kb mk ml ky kf mm mn la mo bi translated">完整代码:</h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="2637" class="lv kl hi lr b fi lw lx l ly lz"># IMPORTING PACKAGES<br/><br/>import pandas as pd<br/>import requests<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)<br/><br/># EXTRACTING STOCK DATA<br/><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>aapl = get_historical_data('AAPL', '2019-01-01')<br/>aapl.tail()<br/><br/># TRUE STRENGTH INDEX CALCULATION <br/><br/>def get_tsi(close, long, short, signal):<br/>    diff = close - close.shift(1)<br/>    abs_diff = abs(diff)<br/>    <br/>    diff_smoothed = diff.ewm(span = long, adjust = False).mean()<br/>    diff_double_smoothed = diff_smoothed.ewm(span = short, adjust = False).mean()<br/>    abs_diff_smoothed = abs_diff.ewm(span = long, adjust = False).mean()<br/>    abs_diff_double_smoothed = abs_diff_smoothed.ewm(span = short, adjust = False).mean()<br/>    <br/>    tsi = (diff_double_smoothed / abs_diff_double_smoothed) * 100<br/>    signal = tsi.ewm(span = signal, adjust = False).mean()<br/>    tsi = tsi[tsi.index &gt;= '2020-01-01'].dropna()<br/>    signal = signal[signal.index &gt;= '2020-01-01'].dropna()<br/>    <br/>    return tsi, signal<br/><br/>aapl['tsi'], aapl['signal_line'] = get_tsi(aapl['close'], 25, 13, 12)<br/>aapl = aapl[aapl.index &gt;= '2020-01-01']<br/>aapl.tail()<br/><br/># TRUE STRENGTH INDEX PLOT<br/><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(aapl['close'], linewidth = 2.5)<br/>ax1.set_title('AAPL CLOSING PRICE')<br/>ax2.plot(aapl['tsi'], linewidth = 2, color = 'orange', label = 'TSI LINE')<br/>ax2.plot(aapl['signal_line'], linewidth = 2, color = '#FF006E', label = 'SIGNAL LINE')<br/>ax2.set_title('AAPL TSI 25,13,12')<br/>ax2.legend()<br/>plt.show()<br/><br/># TRUE STRENGTH INDEX STRATEGY<br/><br/>def implement_tsi_strategy(prices, tsi, signal_line):<br/>    buy_price = []<br/>    sell_price = []<br/>    tsi_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(prices)):<br/>        if tsi[i-1] &lt; signal_line[i-1] and tsi[i] &gt; signal_line[i]:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                tsi_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                tsi_signal.append(0)<br/>        elif tsi[i-1] &gt; signal_line[i-1] and tsi[i] &lt; signal_line[i]:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                tsi_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                tsi_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            tsi_signal.append(0)<br/>            <br/>    return buy_price, sell_price, tsi_signal<br/><br/>buy_price, sell_price, tsi_signal = implement_tsi_strategy(aapl['close'], aapl['tsi'], aapl['signal_line'])<br/><br/># TRUE STRENGTH INDEX TRADING SIGNALS PLOT<br/><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(aapl['close'], linewidth = 2)<br/>ax1.plot(aapl.index, buy_price, marker = '^', markersize = 12, color = 'green', linewidth = 0, label = 'BUY SIGNAL')<br/>ax1.plot(aapl.index, sell_price, marker = 'v', markersize = 12, color = 'r', linewidth = 0, label = 'SELL SIGNAL')<br/>ax1.legend()<br/>ax1.set_title('AAPL TSI TRADING SIGNALS')<br/>ax2.plot(aapl['tsi'], linewidth = 2, color = 'orange', label = 'TSI LINE')<br/>ax2.plot(aapl['signal_line'], linewidth = 2, color = '#FF006E', label = 'SIGNAL LINE')<br/>ax2.set_title('AAPL TSI 25,13,12')<br/>ax2.legend()<br/>plt.show()<br/><br/># STOCK POSITION<br/><br/>position = []<br/>for i in range(len(tsi_signal)):<br/>    if tsi_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(aapl['close'])):<br/>    if tsi_signal[i] == 1:<br/>        position[i] = 1<br/>    elif tsi_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = aapl['close']<br/>tsi = aapl['tsi']<br/>signal_line = aapl['signal_line']<br/>tsi_signal = pd.DataFrame(tsi_signal).rename(columns = {0:'tsi_signal'}).set_index(aapl.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'tsi_position'}).set_index(aapl.index)<br/><br/>frames = [close_price, tsi, signal_line, tsi_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy<br/>strategy[12:17]<br/><br/># BACKTESTING<br/><br/>aapl_ret = pd.DataFrame(np.diff(aapl['close'])).rename(columns = {0:'returns'})<br/>tsi_strategy_ret = []<br/><br/>for i in range(len(aapl_ret)):<br/>    returns = aapl_ret['returns'][i]*strategy['tsi_position'][i]<br/>    tsi_strategy_ret.append(returns)<br/>    <br/>tsi_strategy_ret_df = pd.DataFrame(tsi_strategy_ret).rename(columns = {0:'tsi_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/aapl['close'][0])<br/>tsi_investment_ret = []<br/><br/>for i in range(len(tsi_strategy_ret_df['tsi_returns'])):<br/>    returns = number_of_stocks*tsi_strategy_ret_df['tsi_returns'][i]<br/>    tsi_investment_ret.append(returns)<br/><br/>tsi_investment_ret_df = pd.DataFrame(tsi_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(tsi_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the tsi strategy by investing $100k in AAPL : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the tsi strategy : {}%'.format(profit_percentage), attrs = ['bold']))<br/><br/># SPY ETF COMPARISON<br/><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('TSI Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre></div></div>    
</body>
</html>