<html>
<head>
<title>Creating an NFT whitelist using Merkle Tree Proofs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Merkle树证明创建NFT白名单</h1>
<blockquote>原文：<a href="https://medium.com/codex/creating-an-nft-whitelist-using-merkle-tree-proofs-9668fbe72cb4?source=collection_archive---------0-----------------------#2022-03-15">https://medium.com/codex/creating-an-nft-whitelist-using-merkle-tree-proofs-9668fbe72cb4?source=collection_archive---------0-----------------------#2022-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e237" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将白名单加入以太坊或多边形NFT智能合约的最简单、最安全的方法。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/2903267a96c9b7b50f4b92719dd6d5d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LASA8nrOsZq4a4cINcAbeg.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">由<a class="ae ju" href="https://unsplash.com/@toddquackenbush?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">托德·夸肯布什</a>在<a class="ae ju" href="https://unsplash.com/s/photos/tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="4e30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多NFT项目目前都实现了某种白名单。这也是一个好主意。它减少了机器人的数量。它让鲸鱼有更小的机会铸造数量惊人的代币，如果你实现它们，它可以给白名单上的用户更多的额外津贴。</p><p id="c242" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是如何实现安全的白名单呢？您可能希望使用后端服务器，以某种方式验证签名，并以某种方式保护智能合约，使其不会被欺骗。Merkle Tree Proofs是最好的方法之一，所以让我们看看如何将它们用于白名单。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="5152" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是Merkle树？</h1><p id="5258" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">Merkle树是一种用于加密的树状结构。一棵Merkle树有任意数量的被称为叶子的节点。这些是将被散列的数据值，在我们的例子中是白名单用户的地址。每对散列将被再次散列，然后这些散列对将被散列，直到只剩下一个节点。根节点。</p><p id="10af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这确保了节点中的任何变化都会反映到最终的根节点中。这使得检查值是否正确变得相当容易。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lf"><img src="../Images/8427acb4dff16d086394fd093372b624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RGgq2559CDYZYU_Epl5ncA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">左图:漂亮打印的Markle树和节点名称；右图:同一棵树的真实图像。</figcaption></figure><p id="be0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OpenZeppelin有一个智能合约，我们可以使用它来轻松地添加我们需要的功能，以便在我们自己的合约中轻松检查证明。我们只需要创建一个根节点，并为智能契约的函数提供一个散列。因此，让我们创建Merkle树，并设置我们需要的后端。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="73d9" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">后端</h1><p id="4090" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">如前所述，我们需要一个后端。这将是我们创建Merkle树的部分，这样用户就不能更改它来添加他们自己的地址。这将在一个服务器上完成，然后该服务器使用正确的参数调用智能契约来执行链上检查。</p><p id="d8bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要安装一些软件包。我们将使用NPM，但你也可以使用纱线。我们将初始化Node(用于测试)，安装MerkleProofJS，并安装Keccak256，因为它是Solidity的默认散列函数。</p><pre class="jf jg jh ji fd lg lh li lj aw lk bi"><span id="e3ab" class="ll kd hi lh b fi lm ln l lo lp">npm init -y<br/>npm i merkleproofjs<br/>npm i keccak256</span></pre><p id="f686" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦安装了软件包，我们可以创建一个名为<code class="du lq lr ls lh b">index.js</code>的文件，并在需要时通过在控制台中运行<code class="du lq lr ls lh b">node index.js</code>来运行它。我将使用<code class="du lq lr ls lh b">console.log</code>来展示每个步骤并提供更多信息。</p><p id="c888" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们应该做的第一件事是创建一个白名单以太坊地址列表，我已经添加了一个7个随机地址的列表(包括“0x”)并将它们作为字符串放入一个数组中。</p><p id="8c52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们需要使用keccak256将它们全部散列，以创建我们的树叶。完成所有的叶子后，我们可以创建Merkle树并通过使用MerkleTreeJS得到我们的根hash。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="2248" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这些，我们可以创建证明，将它们发送到区块链进行验证，或者在发送交易之前自己验证它们，这可能会浪费用户的资金。</p><p id="6bc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们以某种方式从前端检索用户的地址，像我们的叶子一样散列它，并使用我们已经用正确地址制作的Merkle树检索证明。</p><p id="bf6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在以十六进制格式创建证明后，我们也可以从<code class="du lq lr ls lh b">merkleTree</code>变量中验证它。这可能是有用的，但不是必需的，因为我们只需要将证明发送到区块链。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="cad5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使其在生产中安全且易于使用的最佳方式是创建一个API，您可以使用需要散列到Merkle证明中的正确数据调用该API(但其他人不能),在前端获取证明，并使用web3js通过用户钱包中的事务将其发送到区块链。</p><p id="eebd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以看看智能合约将如何实现适当的功能来验证我们发送给它的Merkle证明。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="5b6e" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">智能合同</h1><p id="247e" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">在智能契约中验证Merkle证明非常容易，因为它只需要我们从OpenZeppelin的Merkle Proof契约中调用一个函数。</p><p id="9fe8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在执行我们想要执行的功能之前，我们只需在一个<code class="du lq lr ls lh b">require</code>语句中调用OpenZeppelin的<code class="du lq lr ls lh b">verify</code>函数，比如铸造令牌。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="79b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果希望更安全，可以为根创建一个私有变量，并使用setter函数来设置它。不过这取决于你，这样看起来会更好，并且在原始根哈希出现问题时会更安全。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="09cb" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="8a90" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">就是这样。您可能需要稍微修改一些代码来使用Truffle进行测试，或者实际上在API内部实现它，但是这应该非常相似，如果不是相同的话。</p><p id="bb5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非常感谢您的阅读，祝您度过美好的一天。</p><p id="f7b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑通过成为中级会员来支持我。它帮了我大忙，不会花你任何额外的费用，而且你可以阅读尽可能多的中等文章！</p><p id="1650" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae ju" href="https://twitter.com/0xmbvissers" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae ju" href="https://gm.xyz/u/mbvissers.eth" rel="noopener ugc nofollow" target="_blank"> gm.xyz </a>上关注我，以跟上我的项目。</p><p id="4c1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看<a class="ae ju" href="https://kangaroomob.io/" rel="noopener ugc nofollow" target="_blank">袋鼠黑帮</a> NFT项目。</p><p id="9a37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">检查多边形上的<a class="ae ju" href="https://www.pixel-pizzas.com/" rel="noopener ugc nofollow" target="_blank">像素披萨</a>。</p></div></div>    
</body>
</html>