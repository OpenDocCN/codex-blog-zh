<html>
<head>
<title>Wait, where’s my pineapple?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">等等，我的菠萝呢？</h1>
<blockquote>原文：<a href="https://medium.com/codex/wait-wheres-my-pineapple-7e02174036b8?source=collection_archive---------10-----------------------#2021-04-10">https://medium.com/codex/wait-wheres-my-pineapple-7e02174036b8?source=collection_archive---------10-----------------------#2021-04-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3812" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Django Rest框架中的多序列化器与多视图</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8ebceb48189945450a4a54b8172626a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KRfKSxp3laBJtOCp"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://unsplash.com/@enginakyurt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> engin akyurt </a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a070" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当你在Django Rest框架中创建简单的CRUD API视图时，我猜大多数时候你只创建了两个端点:一个用于<em class="kk">列表/创建</em>动作，另一个用于<em class="kk">检索/更新/销毁</em>动作。</p><p id="9a63" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对多个动作只实现一个视图意味着它们也只有一个序列化器。代码越少，越‘干’，不是吗？然而，有时这并不太好，因为我们的API可能在每个操作中都需要不同格式的数据。如果这种情况发生在我们身上，我们该怎么办？</p><p id="4159" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个问题有许多解决方案和不同的方法，我将试着介绍其中的几种。</p><h1 id="b7f5" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">简介</h1><p id="2f0b" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">假设我们有一家披萨店(谁不爱吃披萨？)我们需要实现一个应用程序，我们的客户可以在其中下订单。</p><p id="e314" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这些模型如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://gist.github.com/ewelina29/c025651c47948e46e630dbbf1d4e211b" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ewelina 29/c 025651 c 47948 e 46 e 630 dbb f1 d 4 e 211 b</a></figcaption></figure><p id="a9bd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以我们有一个带字段的<code class="du lk ll lm ln b">Pizza</code>模型:</p><ul class=""><li id="ad2f" class="lo lp hi jq b jr js ju jv jx lq kb lr kf ls kj lt lu lv lw bi translated"><code class="du lk ll lm ln b">name</code>，</li><li id="a157" class="lo lp hi jq b jr lx ju ly jx lz kb ma kf mb kj lt lu lv lw bi translated"><code class="du lk ll lm ln b">price</code>(在这种情况下不重要)，</li><li id="ec08" class="lo lp hi jq b jr lx ju ly jx lz kb ma kf mb kj lt lu lv lw bi translated"><code class="du lk ll lm ln b">ingredients</code> ( <strong class="jq hj"> ManyToManyField </strong>到<code class="du lk ll lm ln b">Ingredient</code>，因为每一个披萨都可以有很多食材)，</li><li id="5fd6" class="lo lp hi jq b jr lx ju ly jx lz kb ma kf mb kj lt lu lv lw bi translated"><code class="du lk ll lm ln b">sauce</code> ( <strong class="jq hj">外键</strong>)到<code class="du lk ll lm ln b">Sauce</code>模式因为每个披萨只能有一种酱)。</li></ul><p id="f9ab" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们实现一个非常简单的继承自<code class="du lk ll lm ln b">generics.ListCreateAPIView</code>的<code class="du lk ll lm ln b">PizzaAPIView</code>来处理<em class="kk">列表/创建</em>动作。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://gist.github.com/ewelina29/86f4492aa832fe65aa20c4aa6316aa16" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ewelina 29/86f 4492 aa 832 Fe 65 aa 20 C4 aa 6316 aa 16</a></figcaption></figure><p id="a1b5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">而且非常基础的<code class="du lk ll lm ln b">PizzaSerializer</code>继承自<code class="du lk ll lm ln b">ModelSerializer</code>:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://gist.github.com/ewelina29/f4e2dfc0d5e664cd8088231fbca44e40" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ewelina 29/f 4 e 2 DFC 0d 5 e 664 CD 8088231 fbca 44 e 40</a></figcaption></figure><p id="d044" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lk ll lm ln b">urls.py</code>中还有一行代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://gist.github.com/ewelina29/3ba603e239e383d794c027f914435036" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ewelina 29/3ba 603 e 239 e 383d 794 c 027 f 914435036</a></figcaption></figure><p id="6496" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">快速查看我们的<code class="du lk ll lm ln b">Ingredients</code>和<code class="du lk ll lm ln b">Sauces</code>桌，了解我们餐厅的厨房有什么菜:)</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mc"><img src="../Images/3a030736c52b741db8c1215656d65b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*eQlHiSs4l_sS_wWsNnURfQ.png"/></div></figure><p id="79ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">好了，让我们一起创造有史以来最好的披萨吧:)。<br/>JSON(针对POST请求)应该是这样的:</p><pre class="iy iz ja jb fd md ln me mf aw mg bi"><span id="7364" class="mh km hi ln b fi mi mj l mk ml">{<br/>    "name": "Hawaiian",<br/>    "price": 29.99,<br/>    "sauce": 1,<br/>    "ingredients": [1,2,5]<br/>}</span></pre><p id="6bd9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">并发送GET请求来获取列表。让我们来看看回应:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mm"><img src="../Images/d0fa95ba2ae7ebfe05e188311976e956.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*eNlmXiku-ZV2XlafyhcAOA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">GET请求的响应</figcaption></figure><p id="7645" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">嗯，一切正常，但是…我的菠萝在哪里？！我不想在我们的清单上看到酱料和配料的标识，而是它们的名称。</p><p id="e99c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如何不费力地做到这一点并保持代码整洁？</p><h1 id="e1b2" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">多个视图—多个序列化程序</h1><p id="d8e8" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">第一个解决方案是将我们的视图分成两个独立的视图:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://gist.github.com/ewelina29/ada20176e8230e519c8913e7598076fe" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ewelina 29/ada 20176 e 8230 e 519 c 8913 e 7598076 Fe</a></figcaption></figure><p id="689b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这样我们就可以创建一个新的序列化程序来处理<code class="du lk ll lm ln b">PizzaListAPIView</code>:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://gist.github.com/ewelina29/2d85154150efb213817472971689f233" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ewelina 29/2d 85154150 efb 213817472971689 f 233</a></figcaption></figure><p id="a5c2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我覆盖了字段<code class="du lk ll lm ln b">sauce</code>以返回酱油的名称(使用<code class="du lk ll lm ln b">source</code>属性)并将<code class="du lk ll lm ln b">depth = 1</code>添加到<code class="du lk ll lm ln b">Meta</code>类以获得完整的对象。</p><p id="a152" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">还有一件事。我们需要为每个视图创建一个单独的端点。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://gist.github.com/ewelina29/810a907e956c77e9770971f3013674aa" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ewelina 29/810 a 907 e 956 c 77 e 9770971 f 3013674 aa</a></figcaption></figure><p id="6644" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们的结果看起来会像这样:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mn"><img src="../Images/de528f9a3ac4047d4d02490761b27fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*c2PH0I54Xa5MSE3tc2J37Q.png"/></div></figure><p id="cca6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">是啊，菠萝披萨！我就喜欢这样:)</p><p id="fae0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是这种方法需要创建额外的视图和端点。也许有更好的解决办法？</p><h1 id="84b5" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">一个视图—一个序列化程序</h1><p id="37af" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">为什么不试一试，将所有内容混合在一个视图和一个序列化程序中呢？让我们回到基本的<code class="du lk ll lm ln b">PizzaAPIView</code>并稍微修改一下<code class="du lk ll lm ln b">PizzaSerializer</code>:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://gist.github.com/ewelina29/bc1a789b965a72747d6f50f67d63da4c" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ewelina 29/BC 1a 789 b 965 a 72747 d6f 50 f 67d 63 da4c</a></figcaption></figure><p id="cc91" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我添加了两个额外的字段:<code class="du lk ll lm ln b">selected_sauce</code>和<code class="du lk ll lm ln b">selected_ingredients</code>，以我们想要的格式返回对象。我还给它们分配了<code class="du lk ll lm ln b">read_only</code>属性，这样它们只在GET方法的响应中可用。</p><p id="e956" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">还有一件事。通过将<code class="du lk ll lm ln b">write_only</code>属性分配给<code class="du lk ll lm ln b">sauce</code>和<code class="du lk ll lm ln b">ingredients</code>字段，我确信这两个字段在POST请求数据中是必需的，但是它们不会显示在响应中。</p><p id="8093" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这种方法允许我们在一个视图和一个序列化器中处理两种方法。但它总是最佳解决方案吗？答案取决于你。</p><p id="65fd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你问我的意见，我觉得当<em class="kk">列表</em>和<em class="kk">创建</em>视图中的同一个字段有不同的名称时会很混乱。此外，当我需要查看每个字段定义并检查它是<code class="du lk ll lm ln b">read_only</code>还是<code class="du lk ll lm ln b">write_only</code>的时候，我会因为在一个类中收集了太多信息而感到不知所措，这使得代码不够干净。</p><p id="896d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是我寻找其他解决方案的原因，以下是我的发现…</p><h1 id="e854" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">一个视图—多个序列化程序</h1><p id="069e" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">让我们回到我们的基本观点，稍微修改一下。Django Rest框架提供了许多方法，我们可以简单地覆盖这些方法来实现我们的目标。(如果你想了解更多，请点击查看<a class="ae jn" href="https://www.django-rest-framework.org/api-guide/generic-views/#methods" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="f26d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">其中一种方法就是<code class="du lk ll lm ln b">get_serializer_class()</code>。当我们发送请求并且Django正在寻找serializer类时，这个方法被调用。默认情况下，它返回视图中定义的<code class="du lk ll lm ln b">serializer_class</code>。但是如果我们覆盖了这个方法，真正的奇迹就会发生…</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://gist.github.com/ewelina29/d4bf88c1215feb99286f1e369d50caa5" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ewelina 29/d4bf 88 c 1215 feb 99286 f1 e 369d 50 CAA 5</a></figcaption></figure><p id="3fb1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是怎么回事？只是简单地检查我们的请求方法是否是POST(这意味着我们正在创建一个新对象)。如果是，我们告诉Django使用<code class="du lk ll lm ln b">PizzaCreateSerializer</code>。在任何其他情况下，将使用<code class="du lk ll lm ln b">PizzaListSerializer</code>。</p><p id="fb0f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后我们可以创建我们的序列化程序:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://gist.github.com/ewelina29/3c415961609a79fa185577a14e3b4fd6" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ewelina 29/3c 415961609 a 79 fa 185577 a 14 E3 B4 FD 6</a></figcaption></figure><p id="4d3b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">并更新<code class="du lk ll lm ln b">urls.py:</code></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://gist.github.com/ewelina29/e9cb1c26cee1046710a9d68c2f026b2d" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ewelina 29/e 9 CB 1c 26 ce e1046710 a9 d 68 C2 f 026 b2d</a></figcaption></figure><p id="4931" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">哇，太神奇了！我们刚刚在一个视图中使用了两个序列化器。我们甚至可以更进一步，通过在<code class="du lk ll lm ln b">get_serializer_class()</code>方法中实现我们可以想象的任何逻辑来使用我们想要的。</p><p id="f308" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在代码看起来干净多了，每个序列化器只负责一个动作。</p><h1 id="2844" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">结论</h1><p id="5996" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">正如你所看到的，几乎每个问题都有许多解决方案，每个解决方案在某些情况下都可能是正确的，所以了解不同的方法并根据你的需要交替使用它们真的很有帮助。不要犹豫尝试你的代码——这是发现新事物和(希望)更好东西的最好方法！:)</p><p id="a0a0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">又及:我希望你不会因为披萨上的菠萝而恨我，但我真的很喜欢它；).</p></div></div>    
</body>
</html>