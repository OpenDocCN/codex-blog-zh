<html>
<head>
<title>Learn TypeScript — Advanced level</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习打字稿—高级水平</h1>
<blockquote>原文：<a href="https://medium.com/codex/learn-typescript-advanced-level-75675db35825?source=collection_archive---------10-----------------------#2022-05-11">https://medium.com/codex/learn-typescript-advanced-level-75675db35825?source=collection_archive---------10-----------------------#2022-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9fb841d607e94fbe57bb5c58a36e1464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qJoUjo4QuKsMsdKz"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">(来源:<a class="ae iu" href="https://unsplash.com/photos/nKEARsgmrqc" rel="noopener ugc nofollow" target="_blank">unsplash.com</a>)</figcaption></figure><p id="667e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated"><span class="l ju jv jw bm jx jy jz ka kb di">在这篇文章中，我将讨论几个话题，比如函数、循环、OOP等等。</span></p><h1 id="fc5b" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">类型脚本函数</h1><p id="9f20" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">函数是JavaScript中任何应用程序的基本构件。</p><p id="e5b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它使得代码可读、可维护和可重用。我们可以用它来建立抽象层，模仿类、信息隐藏和模块。</p><p id="6db2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，在TypeScript中，我们有了类、命名空间和模块的概念，但是函数仍然是描述如何做事的一个不可或缺的部分。</p><p id="f11e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">一个函数有三个方面:</strong></p><p id="278f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 1】函数声明:</strong></p><p id="eb8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">函数声明告诉编译器函数名、函数参数和返回类型。</p><p id="4260" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">函数声明的语法是-</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="0d2c" class="lo kd hi lk b fi lp lq l lr ls">function functionName( [arg1, arg2, ...argN] );</span></pre><p id="a828" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2】功能定义:</strong></p><p id="ebe6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它包含将要执行的实际语句。它规定了具体任务的内容和完成方式。</p><p id="1d4d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">函数定义的语法是-</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="4c62" class="lo kd hi lk b fi lp lq l lr ls">function functionName( [arg1, arg2, ...argN] ){<br/>//code to be executed<br/>}</span></pre><p id="cbde" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3】函数调用:</strong></p><p id="04b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以在程序的任何地方调用一个函数。函数调用和函数声明中的参数/实参不能不同。我们必须传递与函数声明中声明的相同数量的函数。</p><p id="b667" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">函数调用的语法是-</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="e4eb" class="lo kd hi lk b fi lp lq l lr ls">FunctionName();</span></pre><p id="d6a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">功能创建</strong></p><p id="6aa2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以用两种方法创建一个函数。这些是:</p><ul class=""><li id="290e" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">命名函数</li><li id="9ab7" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">匿名函数</li></ul><p id="1ec3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">命名函数</strong></p><p id="6fae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们通过给定的名字来声明和调用一个函数时，那么这种类型的函数被称为名为的<strong class="ix hj">函数。</strong></p><p id="6798" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="7ce9" class="lo kd hi lk b fi lp lq l lr ls">functionName( [arguments] ) { }</span></pre><p id="9e85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="a976" class="lo kd hi lk b fi lp lq l lr ls">//Function Definition  <br/>function display() {  <br/>    console.log("Hello JavaTpoint!");  <br/>}  <br/>//Function Call  <br/>display();</span></pre><p id="e98b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">匿名功能</strong></p><p id="391f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有名字的函数称为匿名函数。这些类型的函数是在运行时动态声明的。</p><p id="8836" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它被定义为一个表达式。我们可以把它存储在一个变量中，所以它不需要函数名。</p><p id="4b6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像标准函数一样，它也接受输入并返回输出。我们可以通过使用包含function的变量名来调用它。</p><p id="63e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="9f8d" class="lo kd hi lk b fi lp lq l lr ls">let res = function( [arguments] ) { }</span></pre><p id="71fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="27b0" class="lo kd hi lk b fi lp lq l lr ls">// Anonymous function  <br/>let myAdd = function (x: number, y: number) : number {  <br/>    return x + y;  <br/>};  <br/>// Anonymous function call  <br/>console.log(myAdd(5,3));</span></pre><p id="3bea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">功能参数</strong></p><p id="f408" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参数是传递给函数的值或变量。</p><p id="4be0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在TypeScript中，编译器接受函数签名中定义的相同数量和类型的参数。</p><p id="6b58" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果编译器与函数签名中的参数不匹配，那么它会给出编译错误。</p><p id="9cc5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">功能参数可分为以下几类:</strong></p><ul class=""><li id="872b" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">任选参数</li><li id="4d0f" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">默认参数</li><li id="2ef1" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">休息参数</li></ul><p id="34af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">可选参数</strong></p><p id="cea2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在JavaScript中，我们可以调用一个函数而不传递任何参数。</p><p id="ecdb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在JavaScript函数中，参数是可选的，当我们这样做时，每个参数值都是未定义的。</p><p id="7ea1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与JavaScript不同，如果我们试图调用一个函数而不提供函数签名中声明的参数的确切数量和类型，TypeScript编译器将抛出错误。</p><p id="4f3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过使用问号('？'来使用可选参数来克服这个问题<strong class="ix hj">)</strong>。</p><p id="d6ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着可以在可能接收值也可能不接收值的参数后面附加一个“？”签名以将它们标记为可选。</p><p id="04e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="a093" class="lo kd hi lk b fi lp lq l lr ls">function function_name(parameter1[:type], parameter2[:type], parameter3 ? [:type]) { }</span></pre><p id="ff69" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="6332" class="lo kd hi lk b fi lp lq l lr ls">function showDetails(id:number,name:string,e_mail_id?:string) {   <br/>   console.log("ID:", id, " Name:",name);   <br/>   if(e_mail_id!=undefined)    <br/>   console.log("Email-Id:",e_mail_id);   <br/>}  <br/>showDetails(101,"Virat Kohli");  <br/>showDetails(105,"Sachin","sachin@javatpoint.com");</span></pre><p id="6967" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，<strong class="ix hj">电子邮件id </strong>被标记为可选参数。</p><p id="9fda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">默认参数</strong></p><p id="7218" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">TypeScript提供了为函数参数设置默认值的选项。</p><p id="bb7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果用户没有向参数传递值，TypeScript将初始化该参数的默认值。</p><p id="bc90" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认参数的行为与可选参数相同。</p><p id="3bad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于默认参数，如果在函数调用中没有传递值，那么默认参数必须跟在函数签名中所需的参数后面。</p><p id="8cf3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">我们不能同时将参数设为可选和默认。</strong></p><p id="3056" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="9d28" class="lo kd hi lk b fi lp lq l lr ls">function function_name(parameter1[:type], parameter2[:type] = default_value) { }</span></pre><p id="971d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="c64d" class="lo kd hi lk b fi lp lq l lr ls">function displayName(name: string, greeting: string = "Hello") : string {  <br/>    return greeting + ' ' + name + '!';  <br/>}  <br/>console.log(displayName('JavaTpoint'));   //Returns "Hello JavaTpoint!"  <br/>console.log(displayName('JavaTpoint', 'Hi'));   //Returns "Hi JavaTpoint!".  <br/>console.log(displayName('Sachin'));    //Returns "Hello Sachin!"</span></pre><p id="a1b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">剩余参数</strong></p><p id="a607" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">rest参数用于将零个或多个值传递给函数。</p><p id="b733" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过在参数前加上三个“点”字符('…')来声明它。</p><p id="6cc5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它允许函数在不使用arguments对象的情况下拥有不同数量的参数。</p><p id="b9be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">TypeScript编译器将使用rest参数创建一个参数数组，以便所有数组方法都可以使用rest参数。</p><p id="b730" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">rest参数很有用，这里我们有一个未确定数量的参数。</strong></p><p id="ebba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">rest参数遵循的规则:</strong></p><ul class=""><li id="f02f" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">一个函数中只允许一个rest参数。</li><li id="f9a1" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">它必须是数组类型。</li><li id="88d4" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">它必须是参数列表中的最后一个参数。</li></ul><p id="9d25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="9f3c" class="lo kd hi lk b fi lp lq l lr ls">function function_name(parameter1[:type], parameter2[:type], ...parameter[:type]) { }</span></pre><p id="9f39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="a483" class="lo kd hi lk b fi lp lq l lr ls">function sum(a: number, ...b: number[]): number {  <br/>  let result = a;  <br/>  for (var i = 0; i &lt; b.length; i++) {  <br/>  result += b[i];  <br/>  }  <br/>  return result;  <br/>}  <br/>let result1 = sum(3, 5);  <br/>let result2 = sum(3, 5, 7, 9);  <br/>console.log(result1 +"\\n" + result2);</span></pre></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="cab0" class="kc kd hi bd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz bi translated">键入箭头函数</h1><p id="bd22" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">ES6版的TypeScript提供了一个arrow函数，它是定义匿名函数的<strong class="ix hj">简写</strong>语法。</p><p id="b2c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它省略了function关键字。我们可以称之为粗箭(因为-&gt;是细箭而= &gt;是"<strong class="ix hj">粗</strong>箭)。</p><p id="0dad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它也被称为<strong class="ix hj">λ函数</strong>。</p><p id="a912" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">arrow函数具有"<strong class="ix hj"> this </strong>"关键字的词法作用域。</p><p id="212d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">语法</strong></p><p id="ea8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以将箭头函数的语法分成三个部分:</p><ul class=""><li id="e92f" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated"><strong class="ix hj">参数:</strong>一个函数可以有也可以没有参数。</li><li id="d586" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><strong class="ix hj">箭头符号/λ符号</strong> (= &gt;)</li><li id="a1d4" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><strong class="ix hj">语句:</strong>表示函数的指令集。</li></ul><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="10db" class="lo kd hi lk b fi lp lq l lr ls">(parameter1, parameter2, ..., parameterN) =**&gt;** expression;</span></pre><p id="4b6e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们使用<strong class="ix hj">胖箭头(= &gt; ) </strong>符号，就没有必要使用<strong class="ix hj">函数</strong>关键字。</p><p id="7814" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参数在括号()中传递，函数表达式包含在大括号{}中。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="fc19" class="lo kd hi lk b fi lp lq l lr ls">// ES5: Without arrow function  <br/>var getResult = function(username, points) {  <br/>  return username + ' scored ' + points + ' points!';  <br/>};  <br/>  <br/>// ES6: With arrow function  <br/>var getResult = (username: string, points: number): string =&gt; {  <br/>  return `${ username } scored ${ points } points!`;  <br/>}</span></pre><p id="2efa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">带参数</strong>的箭头功能</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="8a6c" class="lo kd hi lk b fi lp lq l lr ls">let sum = (a: number, b: number): number =&gt; {  <br/>            return a + b;  <br/>}  <br/>console.log(sum(20, 30)); //returns 50</span></pre><p id="0889" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，</p><p id="8afb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> sum </strong>是箭头函数，</p><p id="26d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">“a:number，b: number </strong>”是一个参数类型，</p><p id="6644" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">":数字</strong>"是(函数的)返回类型，</p><p id="26b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并且<strong class="ix hj">箭头符号= &gt; </strong>将函数参数和函数体分开。</p><p id="a788" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">无参数箭头功能</strong></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="7d77" class="lo kd hi lk b fi lp lq l lr ls">let Print = () =&gt; console.log("Hello JavaTpoint!");  <br/>Print();</span></pre><p id="2b2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在箭头函数中，<strong class="ix hj">如果函数体只包含一条语句，那么就不需要花括号和return关键字。</strong></p><p id="2960" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以从下面的例子中理解它-</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="27b2" class="lo kd hi lk b fi lp lq l lr ls">let sum = (a: number, b: number) =**&gt;** a + b;<br/>console.log("SUM: " +sum(5, 15));</span></pre></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="d702" class="kc kd hi bd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz bi translated">TypeScript循环</h1><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/ac27e2d9498c139961782df2b96f2997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*RVbxIXz6v1KpbwFMxYzwWQ.png"/></div></figure><p id="e493" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">确定循环</strong></p><p id="6b80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个循环中，<strong class="ix hj">我们知道在执行语句块之前的迭代次数。</strong></p><p id="7c65" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个“<strong class="ix hj"> for循环</strong>”就是这个循环的最好例子。</p><p id="2b10" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">在这里，我们要讨论三种类型的循环:</strong></p><ol class=""><li id="f0cb" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js mu lz ma mb bi translated">for循环</li><li id="35d7" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js mu lz ma mb bi translated">为..循环的</li><li id="707b" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js mu lz ma mb bi translated">为..在回路中</li></ol><p id="601e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">为循环</strong></p><p id="97a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它用于将代码块执行特定的次数。</p><p id="a8f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个<strong class="ix hj"> for </strong>语句在一行中包含了初始化、条件和增量/减量，这提供了一个更短且易于调试的循环结构。</p><p id="09eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">for循环的语法如下所示。</p><p id="9c26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="c7f3" class="lo kd hi lk b fi lp lq l lr ls">for (first expression; second expression; third expression ) {  <br/>    // statements to be executed repeatedly  <br/>}</span></pre><p id="defb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="683c" class="lo kd hi lk b fi lp lq l lr ls">let n=5;<br/>let i;</span><span id="931c" class="lo kd hi lk b fi mv lq l lr ls">for (i=0;i&lt;n;i++){<br/>    console.log(i)<br/>}</span></pre><p id="45a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出-</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="e70c" class="lo kd hi lk b fi lp lq l lr ls">0<br/>1<br/>2<br/>3<br/>4</span></pre><p id="82fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">对于..循环的</strong></p><p id="161b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">森林..of循环用于迭代和访问数组、字符串、集合、映射、列表或元组集合的元素。</p><p id="5caa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">的语法..下面给出了循环的:</p><p id="8dd0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="03ad" class="lo kd hi lk b fi lp lq l lr ls">for (var val of list) {<br/>//statements to be executed<br/>}</span></pre><p id="31f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="5d82" class="lo kd hi lk b fi lp lq l lr ls">let arr = [1, 2, 3, 4, 5];  <br/>  <br/>for (var val of arr) {  <br/>  console.log(val);  <br/>}</span></pre><p id="607f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出-</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/eabdb52884e59b427f38500847f37c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*IhuRgHKraz-FI1dWNOFIlQ.png"/></div></figure><p id="00f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">对于..在循环中</strong></p><p id="5f84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">森林..in循环与数组、列表或元组一起使用。</p><p id="4b4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该循环遍历列表或集合，并在每次迭代中返回一个索引。</p><p id="ad9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，“<strong class="ix hj"> val </strong>的数据类型应该是字符串或者任意。</p><p id="f999" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">的语法..回路中给出如下:</p><p id="50a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="9b89" class="lo kd hi lk b fi lp lq l lr ls">for (var val in list) {<br/>//statements<br/>}</span></pre><p id="8075" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="7538" class="lo kd hi lk b fi lp lq l lr ls">let str:any = "JavaTpoint";  <br/>  <br/>for (let index in str) {  <br/>  console.log('Index of ${str[index]}: ${index}');  <br/>}</span></pre><p id="0586" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出-</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/314ae41f31941502600cfb54b3b501e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*plwMpM7ltmW4M4msF-KHwQ.png"/></div></figure><p id="7129" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">区别为..的和为的..在</strong>中</p><p id="92bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">两个循环都遍历列表，但是它们的迭代类型不同。<strong class="ix hj">为..in </strong>循环返回被迭代对象的索引列表，而..循环返回被迭代对象的<strong class="ix hj">值列表</strong>。</p><p id="2f83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下示例展示了这些差异:</p><p id="4fd0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="783c" class="lo kd hi lk b fi lp lq l lr ls">let myArray = [10, 20, 30, 40, 50,];  </span><span id="5e75" class="lo kd hi lk b fi mv lq l lr ls">console.log("Output of for..in loop ");  <br/>for (let index in myArray) {  <br/>   console.log(index);  <br/>}  </span><span id="64be" class="lo kd hi lk b fi mv lq l lr ls">console.log("Output of for..of loop ");  <br/>for (let val of myArray) {  <br/>   console.log(val);  <br/>}</span></pre><p id="19be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">不定循环</strong></p><p id="c786" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在无限循环中，在开始执行语句块之前，迭代次数是未知的。</p><p id="d265" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有两个无限循环:</p><ol class=""><li id="95d5" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js mu lz ma mb bi translated">while循环</li><li id="7aac" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js mu lz ma mb bi translated">do-while循环</li></ol><p id="372f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> While循环</strong></p><p id="e2b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">TypeScript while循环无限次迭代元素。它重复执行指令，直到指定的条件评估为真。当迭代次数未知时，我们可以使用它。</p><p id="304e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">while循环语法如下所示:</p><p id="0079" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="d82f" class="lo kd hi lk b fi lp lq l lr ls">while (condition)    <br/>{    <br/>    //code to be executed    <br/>}</span></pre><p id="0bf9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">while循环语法的解释是-</p><p id="4ff2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">While循环通过检查条件开始执行。如果条件评估为真，则执行循环体语句。如果条件为假，循环将被终止，从而结束循环的生命周期。</p><p id="3289" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="569c" class="lo kd hi lk b fi lp lq l lr ls">let num = 4;  <br/>let factorial = 1;  <br/>  <br/>while(num &gt;=1) {  <br/>   factorial = factorial * num;  <br/>   num--;  <br/>}  <br/>console.log("The factorial of the given number is: "+factorial);</span></pre><p id="6406" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> Do-while循环</strong></p><p id="b32a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似于while循环，TypeScript do-while循环无限次迭代元素。</p><p id="407d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是与while循环有一个不同之处，即无论条件是真还是假，它都至少执行一次。</p><p id="8beb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当迭代次数不固定，且至少要执行一次循环时，建议使用do-while。</p><p id="2bb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">do-while循环语法如下所示:</p><p id="0a32" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="4525" class="lo kd hi lk b fi lp lq l lr ls">do{    <br/>    //code to be executed    <br/>}while (condition);</span></pre><p id="659e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">do-while循环语法的解释是-</p><p id="08f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">do-while循环第一次开始执行语句时不检查任何条件。在执行语句和更新变量值之后，它开始评估条件。如果条件为真，则循环的下一次迭代开始执行。如果条件为假，循环将被终止，从而结束循环的生命周期。</p><p id="f18e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="9ac9" class="lo kd hi lk b fi lp lq l lr ls">let n = 10;  <br/>  <br/>do {   <br/>    console.log(n);   <br/>    n++;   <br/> } while(n&lt;=15);</span></pre></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="f1dc" class="kc kd hi bd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz bi translated"><strong class="ak">打字班</strong></h1><p id="0197" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">在像Java和C#这样的面向对象编程语言中，类是用来创建可重用组件的基本实体。</p><p id="9f18" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">功能传递给类，对象从类中创建。</p><p id="71d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在ECMAScript 6中，引入了面向对象的基于类的方法。</p><p id="3a55" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">TypeScript引入了类来利用封装和抽象等面向对象技术的优势。</p><p id="c0f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">TypeScript编译器将TypeScript中的类编译成普通的JavaScript函数，以便跨平台和浏览器工作。</p><p id="ac34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用哎呀的话说，一个类是一个用于创建对象的<strong class="ix hj">模板</strong>或<strong class="ix hj">蓝图</strong>。</p><p id="6103" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个类可以包括以下内容:</p><ul class=""><li id="151e" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">构造器</li><li id="0e4c" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">属性(属性/变量/字段)</li><li id="2425" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">方法(功能)</li></ul><p id="c74d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="837a" class="lo kd hi lk b fi lp lq l lr ls">class &lt;class_name&gt;{    <br/>    field;    <br/>    method;    <br/>}</span></pre><p id="426d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="91a4" class="lo kd hi lk b fi lp lq l lr ls">class Student {  <br/>    studCode: number;  <br/>    studName: string;  <br/>  <br/>    constructor(code: number, name: string) {  <br/>            this.studName = name;  <br/>            this.studCode = code;  <br/>    }  <br/>  <br/>    getGrade() : string {  <br/>        return "A+" ;  <br/>    }  <br/>}</span></pre><p id="8cdc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">TypeScript编译器在下面的JavaScript代码中转换上述类。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="61d3" class="lo kd hi lk b fi lp lq l lr ls">var Student = /** @class */ (function () {  <br/>    function Student(code, name) {  <br/>        this.studName = name;  <br/>        this.studCode = code;  <br/>    }  <br/>    Student.prototype.getGrade = function () {  <br/>        return "A+";  <br/>    };  <br/>    return Student;  <br/>}());</span></pre><p id="ca8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">创建一个</strong>类的对象</p><p id="8c12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类通过使用<strong class="ix hj"> new </strong>关键字后跟<strong class="ix hj">类名</strong>来创建对象。</p><p id="b305" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="835c" class="lo kd hi lk b fi lp lq l lr ls">let object_name = new class_name(parameter)</span></pre><p id="014f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> new关键字:</strong>用于实例化(创建)内存中的对象。</p><p id="def6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">表达式的右边调用构造函数，它可以传递值</p><p id="7082" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="b094" class="lo kd hi lk b fi lp lq l lr ls">//Creating an object or instance     <br/>let obj = new Student();</span></pre><p id="d6d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">对象初始化</strong></p><p id="0e36" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">对象初始化是指在对象中存储数据。</strong>有三种方法可以初始化对象。这些是:</p><ul class=""><li id="15e7" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">通过引用变量</li></ul><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="d798" class="lo kd hi lk b fi lp lq l lr ls">//Creating an object or instance     <br/>let obj = new Student();  <br/>  <br/>//Initializing an object by reference variable  <br/>obj.id = 101;  <br/>obj.name = "Virat Kohli";</span></pre><ul class=""><li id="6a70" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">通过方法</li></ul><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="87c5" class="lo kd hi lk b fi lp lq l lr ls">class Student {   <br/>    //defining fields    <br/>    id: number;  <br/>    name:string;  <br/>  <br/>    //creating method or function   <br/>    display():void {   <br/>        console.log("Student ID is: "+this.id)   <br/>        console.log("Student ID is: "+this.name)   <br/>    }   <br/>}   <br/>  <br/>//Creating an object or instance     <br/>let obj = new Student();  <br/>obj.id = 101;  <br/>obj.name = "Virat Kohli";  <br/>obj.display();</span></pre><ul class=""><li id="a9f5" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">由构造者</li></ul><p id="e09c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">构造函数用于<strong class="ix hj">初始化</strong>一个对象。</p><p id="af71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在TypeScript中，构造函数方法总是用名称“<strong class="ix hj">构造函数</strong>”来定义</p><p id="b390" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在构造函数中，我们可以通过使用<strong class="ix hj">这个</strong>关键字来访问一个类的成员。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="115c" class="lo kd hi lk b fi lp lq l lr ls">//defining constructor   <br/>constructor(id: number, name:string) {   <br/>    this.id = id;  <br/>    this.name = name;  <br/>}</span></pre><p id="ecbb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有必要总是在类中有一个构造函数。</p><p id="d584" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">构造函数、方法和对象示例-</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="9237" class="lo kd hi lk b fi lp lq l lr ls">//Defining a Student class.  <br/>class Student {   <br/>    //defining fields    <br/>    id: number;  <br/>    name:string;  <br/>     <br/>    //defining constructor   <br/>   constructor(id: number, name:string) {   <br/>       this.id = id;  <br/>       this.name = name;  <br/>   }    <br/>     <br/>   //creating method or function   <br/>   display():void {   <br/>      console.log("Function displays Student ID is: "+this.id)   <br/>      console.log("Function displays Student ID is: "+this.name)   <br/>   }   <br/>}   <br/>  <br/>//Creating an object or instance     <br/>let obj = new Student(101, "Virat Kohli")  <br/>  <br/>//access the field   <br/>console.log("Reading attribute value of Student as: " +obj.id,)  <br/>console.log("Reading attribute value of Student as: " +obj.name)  <br/>  <br/>//access the method or function  <br/>obj.display()</span></pre><p id="ec8f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出-</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es my"><img src="../Images/78bebeaac726e038544859e1925d41de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*Q6uxiO5JxcdZXGinpG8Mvg.png"/></div></figure></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="c791" class="kc kd hi bd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz bi translated">类型脚本访问修饰符</h1><p id="3902" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated"><strong class="ix hj">数据隐藏</strong>是一种用于隐藏内部对象细节的技术。</p><p id="d27d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个类可以控制其数据成员对其他类成员的可见性。</p><p id="2d5a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种能力被称为<strong class="ix hj">封装或数据隐藏</strong>。</p><p id="5253" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> OOPs使用访问修饰符</strong>的概念来实现<strong class="ix hj">封装</strong>。</p><p id="cc7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">访问修饰符定义了类数据成员在其定义类之外的可见性。</p><p id="fc57" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> TypeScript支持三种访问修饰符。他们是:</strong></p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/9e2c67ad96c5239d567d59f663fb5f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*lG40a-r9rJX0k_x4DcghWw.png"/></div></figure><p id="2502" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 1]公开</strong></p><p id="615e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，在TypeScript中，类的所有成员(属性和方法)都是公共的。</p><p id="68d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，没有必要在成员前面加上这个关键字。</p><p id="8255" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以在任何地方不受任何限制地访问这个数据成员。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="934b" class="lo kd hi lk b fi lp lq l lr ls">class Student {  <br/>    public studCode: number;  <br/>    studName: string;  <br/>}  <br/>  <br/>let stud = new Student();  <br/>stud.studCode = 101;  <br/>stud.studName = "Joe Root";  <br/>  <br/>console.log(stud.studCode+ " "+stud.studName);</span></pre><p id="9ab8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，<strong class="ix hj"> studCode </strong>是public，<strong class="ix hj"> studName </strong>是不带修饰符声明的，因此TypeScript默认将它们视为<strong class="ix hj"> public </strong>。</p><p id="10c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于数据成员是公共的，因此可以使用类的对象在类外部访问它们。</p><p id="5539" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2】私人</strong></p><p id="e2d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">私有访问修饰符不能在其包含类之外访问。</p><p id="dd67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它确保类成员仅对它包含的类可见。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="4f93" class="lo kd hi lk b fi lp lq l lr ls">class Student {  <br/> studCode: number;  <br/> private studName: string;  <br/> constructor(code: number, name: string){  <br/>  this.studCode = code;  <br/>  this.studName = name;  <br/> }  <br/>public display() {  <br/>return (`My unique code: ${this.studCode}, my name: ${this.studName}.`);  <br/>}  <br/>}  <br/>  <br/>let student: Student = new Student(1, "JoeRoot");  <br/>console.log(student.display());</span></pre><p id="7304" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，<strong class="ix hj"> studName </strong>是private，而<strong class="ix hj"> studCode </strong>是在没有修饰符的情况下声明的，因此TypeScript默认将其视为public。</p><p id="210b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们在类之外访问私有成员，它会给出一个编译错误。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="fc42" class="lo kd hi lk b fi lp lq l lr ls">//This will give an error<br/>console.log(student.studName); <br/>//We can't access private members from class object</span></pre><p id="3724" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3】受保护的</strong></p><p id="2a68" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">受保护的访问修饰符只能在类及其子类中访问。</p><p id="c3d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们不能从包含它的类的外部访问它。</p><p id="8a16" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="b997" class="lo kd hi lk b fi lp lq l lr ls">class Student {  <br/>    public studCode: number;  <br/>    protected studName: string;  <br/>    constructor(code: number, name: string){  <br/>        this.studCode = code;  <br/>        this.studName = name;  <br/>        }  <br/>}  <br/>class Person extends Student {  <br/>    private department: string;  <br/>  <br/>    constructor(code: number, name: string, department: string) {  <br/>        super(code, name);  <br/>        this.department = department;  <br/>    }  <br/>    public getElevatorPitch() {  <br/>        return (`My unique code: ${this.studCode}, my name: ${this.studName} and I am in ${this.department} Branch.`);  <br/>    }  <br/>}  <br/>let joeRoot = new Person(1, "JoeRoot", "CS");  <br/>console.log(joeRoot.getElevatorPitch());</span></pre><p id="6297" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，我们不能使用<strong class="ix hj">学生</strong>类之外的名字。我们仍然可以在Person类的实例方法中使用它，因为<strong class="ix hj"> Person </strong>类是从Student类派生的。(例如，Person类继承了Student类)</p><p id="0848" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">总结</strong></p><ul class=""><li id="52bb" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated"><code class="du na nb nc lk b">private</code>修饰符允许在同一个类中访问。</li><li id="7dfb" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><code class="du na nb nc lk b">protected</code>修饰符允许在同一个类和子类中访问。</li><li id="bfdc" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated"><code class="du na nb nc lk b">public</code>修饰符允许从任何位置访问。</li></ul></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="bf77" class="kc kd hi bd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz bi translated">TypeScript访问器</h1><p id="7362" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">在TypeScript中，访问器属性提供了访问和设置类成员的方法。</p><p id="62e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它有下面给出的两种方法。</p><ol class=""><li id="7efd" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js mu lz ma mb bi translated">吸气剂</li><li id="66b9" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js mu lz ma mb bi translated">作曲者</li></ol><p id="0604" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">吸气剂</strong></p><p id="49fa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">getter访问器属性是用于检索变量值的常规方法。</p><p id="9c28" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在object literal中，getter属性由关键字“<strong class="ix hj"> get </strong>表示。它可以是公共的、私有的和受保护的。</p><p id="1a6d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="a1fe" class="lo kd hi lk b fi lp lq l lr ls">get propName() {  <br/>    // getter, the code executed on getting obj.propName  <br/>  },</span></pre><p id="9240" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="58e9" class="lo kd hi lk b fi lp lq l lr ls">class MyDrawing {    <br/>    length: number = 20;    <br/>    breadth: number = 15;    <br/>   <br/>    get rectangle() {    <br/>        return this.length * this.breadth;    <br/>    }    <br/>}    <br/>let obj=new MyDrawing();<br/>console.log(obj.rectangle);</span></pre><p id="1549" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">设定器</strong></p><p id="a312" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">setter访问器属性是用于更新变量值的常规方法。</p><p id="a01a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在object literal中，setter属性由关键字“<strong class="ix hj"> set </strong>表示。</p><p id="681d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="f9bb" class="lo kd hi lk b fi lp lq l lr ls">set propName(value) {  <br/>    // setter, the code executed on setting obj.propName = value  <br/>  }</span></pre><p id="300a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="79de" class="lo kd hi lk b fi lp lq l lr ls">class Student {<br/>    studentName:string;<br/>    studentRollno:number;</span><span id="76ed" class="lo kd hi lk b fi mv lq l lr ls">    constructor(name:string,rollno:number){<br/>        this.studentName=name;<br/>        this.studentRollno=rollno;<br/>    }</span><span id="d0e7" class="lo kd hi lk b fi mv lq l lr ls">    get getname(){<br/>        return this.studentName;<br/>    }</span><span id="4327" class="lo kd hi lk b fi mv lq l lr ls">    set setname(value:string){<br/>     this.studentName=value;<br/>        <br/>    }</span><span id="1bf8" class="lo kd hi lk b fi mv lq l lr ls">}</span><span id="3196" class="lo kd hi lk b fi mv lq l lr ls">let obj1 = new Student("ninad",65);</span><span id="247a" class="lo kd hi lk b fi mv lq l lr ls">//getter call<br/>console.log(obj1.getname)</span><span id="4985" class="lo kd hi lk b fi mv lq l lr ls">//setter call<br/>obj1.studentName="walanj";</span><span id="ffa4" class="lo kd hi lk b fi mv lq l lr ls">console.log(obj1.getname)</span></pre><p id="a679" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注:</strong></p><ul class=""><li id="31d6" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated"><strong class="ix hj"> getter </strong>和<strong class="ix hj"> setter </strong>为我们提供了一种更好地控制如何在每个对象上访问成员的方法。</li><li id="0035" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">TypeScript访问器要求我们将编译器设置为输出ECMAScript 5或更高版本。它不支持ECMAScript 5。</li><li id="1231" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">具有get属性但没有任何set属性的访问器被自动假定为只读的。当我们从代码中生成一个<strong class="ix hj"> .d.ts </strong>文件时，这很有帮助。</li></ul></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="bcc1" class="kc kd hi bd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz bi translated">类型脚本继承</h1><p id="a4db" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">继承是OOPs语言的一个方面，它提供了程序从现有类创建新类的能力。</p><p id="1e9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">它是一种从另一个类获取一个类的属性和行为的机制。</strong></p><p id="b333" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其成员被继承的类被称为<strong class="ix hj">基类/超类，</strong>而继承这些成员的类被称为<strong class="ix hj">派生/子/子类</strong>。</p><p id="04db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在子类中，我们可以覆盖或修改其父类的行为。</p><p id="2221" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">TypeScript通过extends关键字使用类继承。</p><p id="f5cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">TypeScript只支持<strong class="ix hj">单一继承和多级继承。</strong></p><p id="575a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">不支持多重和混合继承。</strong></p><p id="bf0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">句法</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="109c" class="lo kd hi lk b fi lp lq l lr ls">class sub_class_name extends super_class_name  <br/>{  <br/>        // methods and fields  <br/>}</span></pre><p id="3908" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">继承的类型</strong></p><p id="78ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以把传承分为<strong class="ix hj">五种</strong>。这些是:</p><ul class=""><li id="0e30" class="lt lu hi ix b iy iz jc jd jg lv jk lw jo lx js ly lz ma mb bi translated">单一遗传</li><li id="f790" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">多级遗传</li><li id="2ee2" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">多重遗传</li><li id="9613" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">分层继承</li><li id="097e" class="lt lu hi ix b iy mc jc md jg me jk mf jo mg js ly lz ma mb bi translated">混合遗传</li></ul><p id="98fa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> TypeScript仅支持单级和多级继承。它不支持多重、层次和混合继承。</strong></p><p id="0e1d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">单一继承</strong></p><p id="ee32" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">单一继承最多可以从一个父类继承属性和行为。</p><p id="5c8b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="a697" class="lo kd hi lk b fi lp lq l lr ls">class Shape {   <br/>   Area:number   <br/>   constructor(area:number) {   <br/>      this.Area = area  <br/>   }   <br/>}   <br/>class Circle extends Shape {   <br/>   display():void {   <br/>      console.log("Area of the circle: "+this.Area)   <br/>   }   <br/>}  <br/>var obj = new Circle(320);   <br/>obj.display()</span></pre><p id="dd40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">多级继承</strong></p><p id="0a37" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当一个派生类是从另一个派生类派生出来的时候，那么这种类型的继承被称为<strong class="ix hj">多级继承</strong>。</p><p id="7ead" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，多级继承有<strong class="ix hj">多个父类。</strong></p><p id="7551" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这类似于祖父、父亲和孩子之间的<strong class="ix hj">关系</strong>。</p><p id="d529" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例子</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="918e" class="lo kd hi lk b fi lp lq l lr ls">class Animal {   <br/>    eat() {   <br/>        console.log("Eating")   <br/>     }   <br/>}   <br/>class Dog extends Animal {   <br/>   bark() {   <br/>      console.log("Barking")   <br/>   }   <br/>}  <br/>class BabyDog extends Dog{   <br/>    weep() {   <br/>        console.log("Weeping")   <br/>     }  <br/>}  <br/>let obj = new BabyDog();   <br/>obj.eat();  <br/>obj.bark();  <br/>obj.weep()</span></pre></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><p id="4d8f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="nd">感谢你阅读这篇文章！如果你有任何问题，请在下面留言。请务必关注</em><a class="ne nf ge" href="https://medium.com/u/7368122f55cb?source=post_page-----75675db35825--------------------------------" rel="noopener" target="_blank"><em class="nd">Ninad Walanj</em></a><em class="nd">以获得关于TypeScript的最新文章的通知。</em></p><blockquote class="ng nh ni"><p id="79c1" class="iv iw nd ix b iy iz ja jb jc jd je jf nj jh ji jj nk jl jm jn nl jp jq jr js hb bi translated"><em class="hi">可以通过</em><a class="ae iu" href="https://www.linkedin.com/in/ninad-walanj-0040031b6/" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="hi">LinkedIn</em></strong></a><em class="hi"/><a class="ae iu" href="https://github.com/NinadWalanj" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"><em class="hi">GitHub</em></strong></a><em class="hi">与我联系，或者通过访问</em><a class="ae iu" rel="noopener" href="/@ninadwalanj"><strong class="ix hj"><em class="hi">【Medium.com</em></strong></a><strong class="ix hj"><em class="hi">。</em> </strong> <em class="hi">访问我的网站— </em> <a class="ae iu" href="https://ninadwalanj.netlify.app/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="hi">尼纳德·瓦兰吉</em> </strong> </a> <strong class="ix hj"> <em class="hi">。</em>T51】</strong></p></blockquote></div></div>    
</body>
</html>