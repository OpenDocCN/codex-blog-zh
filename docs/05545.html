<html>
<head>
<title>SQL Parse Format Function — A Technical Deep Dive by Apache ShardingSphere</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL解析格式函数Apache ShardingSphere的技术深度探索</h1>
<blockquote>原文：<a href="https://medium.com/codex/sql-parse-format-function-a-technical-deep-dive-by-apache-shardingsphere-f5183e1de215?source=collection_archive---------5-----------------------#2022-03-09">https://medium.com/codex/sql-parse-format-function-a-technical-deep-dive-by-apache-shardingsphere-f5183e1de215?source=collection_archive---------5-----------------------#2022-03-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0c9d" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">复杂的SQL语句是数据科学家和工程师遇到的一些最常见的问题。例如，您能一眼理解下面复杂的SQL语句吗？</p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="ca3f" class="jo jp hi jk b fi jq jr l js jt">select a.order_id,a.status,sum(b.money) as money from t_order a inner join (select c.order_id as order_id, c.number * d.price as money from t_order_detail c inner join t_order_price d on c.s_id = d.s_id) b on a.order_id = b.order_id where b.money &gt; 100 group by a.order_id</span></pre><p id="9555" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">格式化怎么样？下面格式化的格式化版本是不是更容易理解？</p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="e855" class="jo jp hi jk b fi jq jr l js jt">SELECT a . order_id , a . status , SUM(b . money) AS money</span><span id="e937" class="jo jp hi jk b fi ju jr l js jt">FROM t_order a INNER JOIN</span><span id="7217" class="jo jp hi jk b fi ju jr l js jt">(</span><span id="e0e5" class="jo jp hi jk b fi ju jr l js jt">SELECT c . order_id AS order_id, c . number * d . price AS money</span><span id="ba69" class="jo jp hi jk b fi ju jr l js jt">FROM t_order_detail c INNER JOIN t_order_price d ON c . s_id = d . s_id</span><span id="f1e8" class="jo jp hi jk b fi ju jr l js jt">) b ON a . order_id = b . order_id</span><span id="b305" class="jo jp hi jk b fi ju jr l js jt">WHERE</span><span id="cb32" class="jo jp hi jk b fi ju jr l js jt">b . money &gt; 100</span><span id="36d1" class="jo jp hi jk b fi ju jr l js jt">GROUP BY a . order_id;</span></pre><p id="7d2a" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">解析如此复杂的SQL的第一步总是格式化，然后可以根据格式化的内容解析它的SQL语义。因此，SQL格式化程序是任何数据库软件的基本功能之一。</p><p id="02a6" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">因此，<a class="ae jv" href="https://shardingsphere.apache.org" rel="noopener ugc nofollow" target="_blank"> Apache ShardingSphere </a>现在提供了一个名为SQL Parse Format的SQL格式化工具，它依赖于ShardingSphere的SQL方言解析器。</p><p id="d474" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj"> SQL解析格式是ShardingSphere解析引擎的重要功能，也是ShardingSphere的SQL Audit (TODO)的基础。</strong>本文深入探讨了SQL解析格式函数:</p><ul class=""><li id="5228" class="jw jx hi ij b ik il io ip is jy iw jz ja ka je kb kc kd ke bi translated">它的核心理念是什么？</li><li id="e40e" class="jw jx hi ij b ik kf io kg is kh iw ki ja kj je kb kc kd ke bi translated">你如何使用它？</li><li id="f716" class="jw jx hi ij b ik kf io kg is kh iw ki ja kj je kb kc kd ke bi translated">如何开发SQL解析格式？</li></ul><h1 id="8014" class="kk jp hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">解析引擎</strong></h1><p id="602c" class="pw-post-body-paragraph ih ii hi ij b ik lh im in io li iq ir is lj iu iv iw lk iy iz ja ll jc jd je hb bi translated">首先，我们需要介绍更多关于Apache ShardingSphere的解析器引擎，因为SQL解析格式是解析器引擎的一个独特且相对独立的功能。</p><p id="7256" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">Apache ShardingSphere开发了解析器引擎来提取SQL中的关键信息，例如数据分片的字段和用于数据加密的重写列。到目前为止，Apache ShardingSphere的解析器引擎已经经历了三次迭代。</p><p id="0f67" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">最初的解析器引擎利用<a class="ae jv" href="https://druid.apache.org" rel="noopener ugc nofollow" target="_blank"> Druid </a>作为它的SQL解析器，并且在sharding sphere 1.4 . x版之前表现得相当好。</p><p id="9348" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">后来，ShardingSphere社区决定自己开发第二代解析器引擎。由于使用目的发生了变化，ShardingSphere采用了另一种方法来理解SQL:只提取数据分片所需的上下文信息，而不生成解析树或二次遍历，以提高性能和兼容性。</p><p id="1d5e" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">目前，第三代ShardingSphere解析引擎使用<a class="ae jv" href="https://www.antlr.org" rel="noopener ugc nofollow" target="_blank"> ANTLR </a>作为解析树生成器，然后通过进行二次树遍历来提取上下文信息。它基本上兼容更多的SQL方言，这进一步加速了在Apache ShardingSphere中开发其他功能。</p><p id="5297" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">在5.0.x版本中，ShardingSphere开发人员进一步增强了最新解析器引擎的性能，将树遍历方法从监听器更改为访问者，并为预编译的SQL语句添加解析结果缓存。</p><p id="ac3a" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">SQL解析格式的实现归功于新的解析引擎。接下来，我们来看看SQL解析格式函数。</p><h1 id="6489" class="kk jp hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak"> SQL解析器格式</strong></h1><p id="bfb0" class="pw-post-body-paragraph ih ii hi ij b ik lh im in io li iq ir is lj iu iv iw lk iy iz ja ll jc jd je hb bi translated">SQL解析格式用于格式化SQL语句。此外，SQL解析格式功能将在未来的SQL审计中使用，为用户提供查看SQL历史、用报表显示格式化的SQL，或者进一步分析或处理SQL。</p><p id="38ef" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">例如，使用SQL Parse格式格式化的以下SQL的每一部分都变得更加清晰，因为换行和关键字都是大写的:</p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="c430" class="jo jp hi jk b fi jq jr l js jt">select age as b, name as n from table1 join table2 where id = 1 and name = 'lu';<br/>-- After Formatting<br/>SELECT age AS b, name AS n<br/>FROM table1 JOIN table2<br/>WHERE <br/>        id = 1<br/>        and name = 'lu';</span></pre><p id="4e9f" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">到目前为止，我们已经介绍了SQL解析格式的基础知识。</p><blockquote class="lm ln lo"><p id="96f9" class="ih ii lp ij b ik il im in io ip iq ir lq it iu iv lr ix iy iz ls jb jc jd je hb bi translated">接下来我们来回答这个问题:SQL解析格式是什么概念？</p></blockquote><p id="456c" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">一条SQL语句在Apache ShardingSphere中是如何格式化的？以下面的SQL为例:</p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="9560" class="jo jp hi jk b fi jq jr l js jt">select order_id from t_order where status = 'OK'</span></pre><ol class=""><li id="f21c" class="jw jx hi ij b ik il io ip is jy iw jz ja ka je lt kc kd ke bi translated">Apache ShardingSphere使用<code class="du lu lv lw jk b">ANTLR4</code>作为它的解析器引擎生成器。首先，我们需要遵循ANTLR4方法来定义<code class="du lu lv lw jk b">.g4</code>文件中<code class="du lu lv lw jk b">select</code>的语法(以MySQL为例)。</li></ol><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="b270" class="jo jp hi jk b fi jq jr l js jt">simpleSelect<br/>    : SELECT ALL? targetList? intoClause? fromClause? whereClause? groupClause? havingClause? windowClause?<br/>    | SELECT distinctClause targetList intoClause? fromClause? whereClause? groupClause? havingClause? windowClause?<br/>    | valuesClause<br/>    | TABLE relationExpr<br/>    ;</span></pre><p id="ff11" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">2.我们可以使用IDEA的ANTLR4插件轻松查看SQL语句的语法树。</p><p id="c6af" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">更多关于ANTLR4的信息，请参考:<a class="ae jv" href="https://plugins.jetbrains.com/plugin/7358-antlr-v4." rel="noopener ugc nofollow" target="_blank">https://plugins.jetbrains.com/plugin/7358-antlr-v4.</a></p><figure class="jf jg jh ji fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es lx"><img src="../Images/fdf7c8bb922620040a8de2476d6b1f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EiWkP_kYN3sLOH4qsPonDA.jpeg"/></div></div></figure><p id="cedd" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">ANTLR4可以编译我们定义的语法文件:它首先对SQL语句进行词法分析，将其拆分为不可分割的部分，即记号，并根据不同数据库的字典值将这些记号划分为关键字，表达式。</p><p id="88e5" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">例如，在上图中，我们得到了关键字<code class="du lu lv lw jk b">SELECT</code>、<code class="du lu lv lw jk b">FROM</code>、<code class="du lu lv lw jk b">WHERE</code>、<code class="du lu lv lw jk b">= </code>和变量<code class="du lu lv lw jk b">order_id</code>、<code class="du lu lv lw jk b">t_order</code>、<code class="du lu lv lw jk b">status</code>、<code class="du lu lv lw jk b">OK</code>。</p><p id="6393" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">3.然后ANTLR4将解析器引擎的输出转换成语法树，如上图所示。</p><p id="8480" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">基于Apache ShardingSphere的源代码，上述过程复制如下。</p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="6139" class="jo jp hi jk b fi jq jr l js jt">String sql = "select order_id from t_order where status = 'OK'";<br/>CacheOption cacheOption = new CacheOption(128, 1024L, 4);<br/>SQLParserEngine parserEngine = new SQLParserEngine("MySQL", cacheOption, false);<br/>ParseContext parseContext = parserEngine.parse(sql, false);</span></pre><p id="1ba3" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">4.Apache ShardingSphere的SQL解析器引擎封装并抽象了ANTLR4解析器:它通过SPI加载SQL方言解析器。用户还可以通过SPI的扩展点来扩展数据方言。此外，ShardingSphere在内部增加了一个缓存机制来提高性能。看一下如下解析的相关代码:</p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="e876" class="jo jp hi jk b fi jq jr l js jt">public ParseContext parse(final String sql) {<br/>    ParseASTNode result = twoPhaseParse(sql);<br/>    if (result.getRootNode() instanceof ErrorNode) {<br/>        throw new SQLParsingException("Unsupported SQL of `%s`", sql);<br/>    }<br/>    return new ParseContext(result.getRootNode(), result.getHiddenTokens());<br/>}<br/><br/>private ParseASTNode twoPhaseParse(final String sql) {<br/>    DatabaseTypedSQLParserFacade sqlParserFacade = DatabaseTypedSQLParserFacadeRegistry.getFacade(databaseType);<br/>    SQLParser sqlParser = SQLParserFactory.newInstance(sql, sqlParserFacade.getLexerClass(), sqlParserFacade.getParserClass(), sqlCommentParseEnabled);<br/>    try {<br/>        ((Parser) sqlParser).getInterpreter().setPredictionMode(PredictionMode.SLL);<br/>        return (ParseASTNode) sqlParser.parse();<br/>    } catch (final ParseCancellationException ex) {<br/>        ((Parser) sqlParser).reset();<br/>        ((Parser) sqlParser).getInterpreter().setPredictionMode(PredictionMode.LL);<br/>        try {<br/>            return (ParseASTNode) sqlParser.parse();<br/>        } catch (final ParseCancellationException e) {<br/>            throw new SQLParsingException("You have an error in your SQL syntax");<br/>        }<br/>    }<br/>}</span></pre><p id="93d5" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><code class="du lu lv lw jk b">twoPhaseParse</code>是解析器的核心。首先会根据数据库类型将其加载到正确的解析器类中，然后由于反射机制会生成一个ANTLR4的解析器实例。然后，ANTLR4提供了两种解析方式:先进行快速解析，如果失败，再进行常规解析。用户可以通过快速解析获得大多数SQL语句的解析结果，从而提高解析性能。解析之后，我们得到解析树。</p><p id="2867" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">那么Apache ShardingSphere如何从解析树中获取格式化的SQL语句呢？</p><p id="22e5" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">事实上，ShardingSphere使用了<code class="du lu lv lw jk b">Visitor</code>方法。ANTLR4提供了两种访问语法树的方法:<code class="du lu lv lw jk b">Listener</code>和<code class="du lu lv lw jk b">Visitor</code>。ShardingSphere选择后者来访问语法树。下面的代码显示了如何从语法树中获取格式化的SQL:</p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="0a63" class="jo jp hi jk b fi jq jr l js jt">SQLVisitorEngine visitorEngine = new SQLVisitorEngine("MySQL", "FORMAT", new Properties());<br/>String result = visitorEngine.visit(parseContext);</span></pre><p id="6943" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">Apache ShardingSphere的<code class="du lu lv lw jk b">SQLVisitorEngine</code>也抽象和封装了各种方言访问者。核心方法如下所示:</p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="8a7c" class="jo jp hi jk b fi jq jr l js jt">public &lt;T&gt; T visit(final ParseContext parseContext) {<br/>    ParseTreeVisitor&lt;T&gt; visitor = SQLVisitorFactory.newInstance(databaseType, visitorType, SQLVisitorRule.valueOf(parseContext.getParseTree().getClass()), props);<br/>    T result = parseContext.getParseTree().accept(visitor);<br/>    appendSQLComments(parseContext, result);<br/>    return result;<br/>}</span></pre><p id="baed" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">首先，就上述<code class="du lu lv lw jk b">Visitor</code>方法而言，根据数据库类型和访问者的类型来决定要使用的访问者，并且还通过反射机制在内部实例化访问者。目前，<code class="du lu lv lw jk b">visitorType</code>支持两种方式:<code class="du lu lv lw jk b">FORMAT</code>和<code class="du lu lv lw jk b">STATEMENT</code>。后者是Apache ShardingSphere常用的，可以将SQL转换成<code class="du lu lv lw jk b">Statement</code>信息，提取相关的上下文信息，提供数据分片等功能。其实这也是SQL解析格式和其他普通解析引擎函数的唯一区别。</p><p id="806b" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">接下来，我们还是以SQL语句为例，提供具体的代码来展示<code class="du lu lv lw jk b">Visitor</code>是如何格式化它的。</p><p id="956c" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><code class="du lu lv lw jk b">MySQLFormatSQLVisitor</code>用于访问SQL。基于<code class="du lu lv lw jk b">DEBUG</code>代码，我们可以清晰的看到这次访问的执行路径如下图所示。Visitor遍历语法树的所有部分，ANTLR4根据定义的语法规则生成访问每个节点的默认方法。Apache ShardingSphere利用关键方法，成功开发了完整的SQL格式化功能。</p><figure class="jf jg jh ji fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es lx"><img src="../Images/bb85375dd64a157b45dedf7443eb18a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjjACczbInC-K4t8EX-pEw.jpeg"/></div></div></figure><p id="4b67" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">下面的代码可以帮助我们更好地理解<code class="du lu lv lw jk b">Visitor</code>如何格式化SQL。</p><p id="21e6" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">当<code class="du lu lv lw jk b">Visitor</code>遍历到<code class="du lu lv lw jk b">select</code>时，<code class="du lu lv lw jk b">Visitor</code>会先格式化，然后再访问<code class="du lu lv lw jk b">projection</code>。<code class="du lu lv lw jk b">projection</code>的内部格式化将通过<code class="du lu lv lw jk b">visitProjections</code>方法进一步实现。</p><p id="0e96" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">在访问<code class="du lu lv lw jk b">from</code>之前处理空行。由<code class="du lu lv lw jk b">Visitor</code>实例化的对象维护一个<code class="du lu lv lw jk b">StringBuilder</code>来存储格式化的结果。因为每个SQL的解析器和访问者都是新创建的实例化对象，所以不存在线程问题。最终遍历之后，Apache ShardingSphere在<code class="du lu lv lw jk b">StringBuilder</code>中输出结果，然后我们得到格式化的SQL。</p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="e869" class="jo jp hi jk b fi jq jr l js jt">public String visitQuerySpecification(final QuerySpecificationContext ctx) {<br/>    formatPrint("SELECT ");<br/>    int selectSpecCount = ctx.selectSpecification().size();<br/>    for (int i = 0; i &lt; selectSpecCount; i++) {<br/>        visit(ctx.selectSpecification(i));<br/>        formatPrint(" ");<br/>    }<br/>    visit(ctx.projections());<br/>    if (null != ctx.fromClause()) {<br/>        formatPrintln();<br/>        visit(ctx.fromClause());<br/>    }<br/>    if (null != ctx.whereClause()) {<br/>        formatPrintln();<br/>        visit(ctx.whereClause());<br/>    }<br/>    if (null != ctx.groupByClause()) {<br/>        formatPrintln();<br/>        visit(ctx.groupByClause());<br/>    }<br/>    if (null != ctx.havingClause()) {<br/>        formatPrintln();<br/>        visit(ctx.havingClause());<br/>    }<br/>    if (null != ctx.windowClause()) {<br/>        formatPrintln();<br/>        visit(ctx.windowClause());<br/>    }<br/>    return result.toString();<br/>}</span></pre><p id="1715" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">现在，基于上面的过程分析和代码片段，您可以理解SQL解析格式的原理。</p><h1 id="3520" class="kk jp hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">SQL解析格式用户指南</strong></h1><p id="20cf" class="pw-post-body-paragraph ih ii hi ij b ik lh im in io li iq ir is lj iu iv iw lk iy iz ja ll jc jd je hb bi translated">您可能会发现在Apache ShardingSphere中使用SQL Parse Format函数很容易，只要您知道它的原理。</p><p id="437f" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">至于Java应用，用户只需要添加依赖项，调用API即可。</p><ul class=""><li id="0eb1" class="jw jx hi ij b ik il io ip is jy iw jz ja ka je kb kc kd ke bi translated"><strong class="ij hj">添加依赖关系</strong></li></ul><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="bae2" class="jo jp hi jk b fi jq jr l js jt">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;<br/>    &lt;artifactId&gt;shardingsphere-sql-parser-engine&lt;/artifactId&gt;<br/>    &lt;version&gt;${project.version}&lt;/version&gt;<br/>&lt;/dependency&gt;<br/><br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;<br/>    &lt;artifactId&gt;shardingsphere-sql-parser-mysql&lt;/artifactId&gt;<br/>    &lt;version&gt;${project.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><ul class=""><li id="7201" class="jw jx hi ij b ik il io ip is jy iw jz ja ka je kb kc kd ke bi translated"><strong class="ij hj">调用API </strong></li></ul><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="03d0" class="jo jp hi jk b fi jq jr l js jt">public static void main(String[] args) {<br/>    String sql = "select order_id from t_order where status = 'OK'";<br/>    CacheOption cacheOption = new CacheOption(128, 1024L, 4);<br/>    SQLParserEngine parserEngine = new SQLParserEngine("MySQL", cacheOption, false);<br/>    ParseContext parseContext = parserEngine.parse(sql, false);<br/>    SQLVisitorEngine visitorEngine = new SQLVisitorEngine("MySQL", "FORMAT", new Properties());<br/>    String result = visitorEngine.visit(parseContext);<br/>    System.out.println(result);<br/>}</span></pre><ul class=""><li id="26f6" class="jw jx hi ij b ik il io ip is jy iw jz ja ka je kb kc kd ke bi translated"><strong class="ij hj">属性支持的参数</strong></li></ul><figure class="jf jg jh ji fd ly er es paragraph-image"><div class="er es mf"><img src="../Images/ba2af574e5d376f8978f39705b306065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*1Ft7G0EKkayVy5vrbcsDBg.png"/></div></figure><p id="c355" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">还可以在ShardingSphere-Proxy中使用DistSQL对SQL解析格式函数执行操作:</p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="82b9" class="jo jp hi jk b fi jq jr l js jt">mysql&gt; FORMAT select order_id from t_user where status = 'OK';<br/>+-----------------------------------------------------+<br/>| formatted_result                                    |<br/>+-----------------------------------------------------+<br/>| SELECT order_id<br/>FROM t_user<br/>WHERE<br/>        status = 'OK'; |<br/>+-----------------------------------------------------+</span></pre><p id="2a25" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">就上述<code class="du lu lv lw jk b">Statement</code>模式而言，也可以让用户方便地查看从SQL转换而来的<code class="du lu lv lw jk b">SQLStatement </code>的结果。</p><pre class="jf jg jh ji fd jj jk jl jm aw jn bi"><span id="94c7" class="jo jp hi jk b fi jq jr l js jt">mysql&gt; parse SELECT id, name FROM t_user WHERE status = 'ACTIVE' AND age &gt; 18;<br/>+----------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+<br/>| parsed_statement     | parsed_statement_detail                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |<br/>+----------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+<br/>| MySQLSelectStatement | {"projections":{"startIndex":7,"stopIndex":14,"distinctRow":false,"projections":[{"column":{"startIndex":7,"stopIndex":8,"identifier":{"value":"id","quoteCharacter":"NONE"}}},{"column":{"startIndex":11,"stopIndex":14,"identifier":{"value":"name","quoteCharacter":"NONE"}}}]},"from":{"tableName":{"startIndex":21,"stopIndex":26,"identifier":{"value":"t_user","quoteCharacter":"NONE"}}},"where":{"startIndex":28,"stopIndex":63,"expr":{"startIndex":34,"stopIndex":63,"left":{"startIndex":34,"stopIndex":50,"left":{"startIndex":34,"stopIndex":39,"identifier":{"value":"status","quoteCharacter":"NONE"}},"right":{"startIndex":43,"stopIndex":50,"literals":"ACTIVE"},"operator":"\u003d","text":"status \u003d \u0027ACTIVE\u0027"},"right":{"startIndex":56,"stopIndex":63,"left":{"startIndex":56,"stopIndex":58,"identifier":{"value":"age","quoteCharacter":"NONE"}},"right":{"startIndex":62,"stopIndex":63,"literals":18},"operator":"\u003e","text":"age \u003e 18"},"operator":"AND","text":"status \u003d \u0027ACTIVE\u0027 AND age \u003e 18"}},"unionSegments":[],"parameterCount":0,"commentSegments":[]} |<br/>+----------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></pre><p id="de97" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">更多<a class="ae jv" href="https://opensource.com/article/21/9/distsql" rel="noopener ugc nofollow" target="_blank"> DistSQL </a>函数请参考文档:<a class="ae jv" href="https://shardingsphere.apache.org/document/current/cn/concepts/distsql/" rel="noopener ugc nofollow" target="_blank">https://sharding sphere . Apache . org/document/current/cn/concepts/dist SQL/</a></p><h1 id="8c40" class="kk jp hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">结论</strong></h1><p id="4f86" class="pw-post-body-paragraph ih ii hi ij b ik lh im in io li iq ir is lj iu iv iw lk iy iz ja ll jc jd je hb bi translated">目前Apache ShardingSphere的Format函数只支持<a class="ae jv" href="https://www.mysql.com" rel="noopener ugc nofollow" target="_blank"> MySQL </a>。在理解了它的概念以及如何使用它之后，如果您感兴趣，欢迎您为开发SQL Parse Format函数做出贡献。</p><h1 id="5318" class="kk jp hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">Apache ShardingSphere开源项目链接:</h1><p id="442f" class="pw-post-body-paragraph ih ii hi ij b ik lh im in io li iq ir is lj iu iv iw lk iy iz ja ll jc jd je hb bi translated"><a class="ae jv" href="https://github.com/apache/shardingsphere" rel="noopener ugc nofollow" target="_blank"> ShardingSphere Github </a></p><p id="f175" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><a class="ae jv" href="https://twitter.com/ShardingSphere" rel="noopener ugc nofollow" target="_blank"> ShardingSphere Twitter </a></p><p id="0921" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><a class="ae jv" href="https://join.slack.com/t/apacheshardingsphere/shared_invite/zt-sbdde7ie-SjDqo9%7EI4rYcR18bq0SYTg" rel="noopener ugc nofollow" target="_blank"> ShardingSphere松弛通道</a></p><p id="b353" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><a class="ae jv" href="https://shardingsphere.apache.org/community/cn/contribute/" rel="noopener ugc nofollow" target="_blank">投稿指南</a></p><h1 id="ba83" class="kk jp hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">作者</strong></h1><p id="9ca4" class="pw-post-body-paragraph ih ii hi ij b ik lh im in io li iq ir is lj iu iv iw lk iy iz ja ll jc jd je hb bi translated"><strong class="ij hj">陈楚欣</strong></p><blockquote class="lm ln lo"><p id="4f9a" class="ih ii lp ij b ik il im in io ip iq ir lq it iu iv lr ix iy iz ls jb jc jd je hb bi translated">SphereEx中间件工程师&amp; Apache ShardingSphere提交者</p><p id="ef80" class="ih ii lp ij b ik il im in io ip iq ir lq it iu iv lr ix iy iz ls jb jc jd je hb bi translated">目前，他致力于开发Apache ShardingSphere的内核模块。</p></blockquote><figure class="jf jg jh ji fd ly er es paragraph-image"><div class="er es mg"><img src="../Images/7975263603e870fa256aa38978a4c237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*smrIU5STVJsJRais0_Tghg.png"/></div></figure></div></div>    
</body>
</html>