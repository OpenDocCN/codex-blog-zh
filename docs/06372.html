<html>
<head>
<title>Chapter 09</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第09章</h1>
<blockquote>原文：<a href="https://medium.com/codex/chapter-09-a86ad4ede4cc?source=collection_archive---------25-----------------------#2022-04-20">https://medium.com/codex/chapter-09-a86ad4ede4cc?source=collection_archive---------25-----------------------#2022-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1ffb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">构造函数和垃圾收集</strong></p><p id="0193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">-栈和堆- </strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/3424ea7a18cca906576749e0053cf0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/0*jGash_k4vM15TnMf"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jl"><img src="../Images/40ae007d32701dc838930201569f271e.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/0*1hJVRjrB_MvdWwPi"/></div></figure><p id="f462" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jm translated"><span class="l jn jo jp bm jq jr js jt ju di"> T </span>应用程序不断地需要Java堆空间，但是栈只用于当前正在运行的函数或者方法。所有对象都是在堆空间中创建的，而对这些对象的任何引用都存储在堆栈中。堆上的对象可以从程序中的任何地方访问。</p><p id="eb6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">栈顶的方法总是当前正在运行的方法。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jv"><img src="../Images/42b45583d65118c900450d8cd353c46e.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/0*R1ZdVjDKk2EAFD8V"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jw"><img src="../Images/7d57abd2fa686d5a5acf4be0c61e5716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6cdoRNsldtcM1osq"/></div></div></figure><p id="8ba3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一个局部变量是对一个对象的引用，那么只有该变量在堆栈中，而对象在堆中。</p><p id="93c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实例变量存在于属于对象的堆中。</p><p id="febe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Duck()不是引用构造函数的方法，如下面的代码所示。通过调用构造函数，一旦正确地启动了代码，就可以运行它。</p><blockquote class="kb kc kd"><p id="6312" class="if ig ke ih b ii ij ik il im in io ip kf ir is it kg iv iw ix kh iz ja jb jc hb bi translated">Duck myduck =新鸭()；</p></blockquote><p id="74bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="ke">-对象创建-</em>-T9】</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es ki"><img src="../Images/e6e6fa680ba4025554134c5da0c870e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AKNHfRu8uZHoeW_F"/></div></div></figure><p id="9416" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们没有使用Duck()函数；相反，我们使用Duck构造函数。当我们说新JVM时，我们的意思是它接收构造器代码并执行它。实例化对象时执行的代码在构造函数中。</p><p id="7aec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用setter方法来允许程序员设置实例变量的大小，如下所示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es kj"><img src="../Images/36fbfc8afbacf45e5ecaadc5c4eb4cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ABKGCRwkx6Oo8pFY"/></div></div></figure><p id="dfd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这个类有不止一个构造函数，那么它就是一个重载的构造函数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kk"><img src="../Images/b3149d503d3b5ae7406739700edd49b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/0*MCVsL1-c201iAttb"/></div></figure><p id="d046" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">-关于构造函数要记住的四件事- </strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kl"><img src="../Images/30092468c70f765476e34bb8359eecbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*zx-Jcm2DqUeOPYKKi569vg.png"/></div></figure><p id="db9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你创建了一个带参数的构造函数，但是想要一个不带参数的构造函数，你必须自己写。</p><p id="7f30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重载的构造函数必须有单独的参数列表，不支持两个构造函数具有相同的参数列表。参数的顺序和类型包含在参数列表中。</p><ul class=""><li id="235f" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">当您在类类型上键入new时，将调用构造函数。</li><li id="d928" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">它必须与类同名，但是没有返回类型。</li><li id="5926" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">如果你没有给类添加构造函数，编译器会给你添加一个无参数的构造函数。</li><li id="d011" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">有可能有许多带有不同参数列表的构造函数。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es la"><img src="../Images/52c596e18c4352225d8758635a66095e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/0*3tjzE19AnecgE8It"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es lb"><img src="../Images/0793b11ffa24124e67a67ade49204636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hj18is1Lx4ZGxBa8"/></div></div></figure><p id="0964" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出为</strong></p><ul class=""><li id="6bdd" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated"><strong class="ih hj"> <em class="ke">首发…</em> </strong></li><li id="6b94" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated"><strong class="ih hj"> <em class="ke">制造动物</em> </strong></li><li id="91c2" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated"><strong class="ih hj"> <em class="ke">制作河马</em> </strong></li></ul><p id="62a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">超类和继承。</strong></p><p id="5c76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当在构造函数中调用super()时，超类构造函数被推到堆栈顶部，后面是对象构造函数。当object()完成时，它从堆栈中移除，并插入下一个子类构造函数。</p><p id="5bc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此()可用于从另一个类的重载构造函数中调用构造函数。This()必须是构造函数中的第一条语句，并且只能在构造函数中使用。可以在构造函数中调用super()或this()，但不能同时调用两者。</p><p id="60a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">局部变量只存在于声明它的方法中，但实例变量在对象的整个生命周期中都存在。如果对象仍然存在，则对象的实例变量仍然存在。</p><p id="5f21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只要局部变量的堆栈帧在堆栈上，局部变量就是活的。</p><p id="0f2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">杀人对象。</strong></p><p id="6113" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.一旦对象超出范围，就对其进行引用。'</p><p id="cb69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.然后将引用分配给另一个对象。</p><p id="a9f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.将引用设置为null。</p></div></div>    
</body>
</html>