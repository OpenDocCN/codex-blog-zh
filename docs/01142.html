<html>
<head>
<title>Building A Simple CRUD App With Node JS, Express JS, and MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node JS、Express JS和MongoDB构建一个简单的CRUD应用程序</h1>
<blockquote>原文：<a href="https://medium.com/codex/building-a-simple-crud-app-with-node-js-express-js-and-mongodb-6e96d13edae7?source=collection_archive---------0-----------------------#2021-04-07">https://medium.com/codex/building-a-simple-crud-app-with-node-js-express-js-and-mongodb-6e96d13edae7?source=collection_archive---------0-----------------------#2021-04-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/8ea074bcabf7896c275b8f18839c8598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RG2GDRY3uUbNYvESrHw9qA.jpeg"/></div></div></figure><div class=""/><p id="b76c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前，大多数网站运行在基于API的后端结构上，我们只需通过调用API从网站前端发送请求，并获得所需的结果。在本文中，我们将从基础开始，用Node JS、Express JS和MongoDB的应用程序构建一个简单的CRUD(创建、读取、更新和删除)应用程序。在我们进入应用程序之前，让我们看看我们将要使用的工具。</p><h2 id="49e0" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">所需元素</h2><p id="0ce1" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">MongoDB :这是最常用的NoSQL数据库之一。它不需要任何特定的模式，是一个文档类型的数据库，也就是说，它以键值格式存储数据。可以根据需要的版本从<a class="ae ko" href="https://docs.mongodb.com/manual/installation/" rel="noopener ugc nofollow" target="_blank">这里</a>安装。随着MongoDB的安装，我们还需要安装Mongo Compass。Mongo Compass是一个帮助我们可视化MongoDB数据库的工具。对于这个应用程序，我们可以将其作为一个集群安装在我们的私有系统上，并将其托管在本地主机上，以便与我们的应用程序进行交互，或者我们也可以使用<a class="ae ko" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> Mongo Atlas </a>。Mongo Atlas是MongoDB的云数据库服务。某些资源是免费的。我们可以在那里创建一个免费的数据库，并从我们的应用程序中访问它。要设置MongoDB Atlas，请遵循以下步骤:</p><ol class=""><li id="ef38" class="kp kq ht is b it iu ix iy jb kr jf ks jj kt jn ku kv kw kx bi translated">如果你还没有注册Mongo Atlas。创建一个新帐户。</li><li id="cbcb" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">点击:创建集群-&gt;找到这个演示项目的免费版本-&gt;点击创建-&gt;保持默认规范-&gt;点击创建集群。</li><li id="dc06" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">现在我们需要添加访问数据库的用户。这类似于创建配置文件来访问资源。进入数据库访问-&gt;设置用户名和密码-&gt;最后添加用户</li><li id="9873" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">我们还需要添加IP，我们将使用它来访问数据库。转到网络访问-&gt;转到添加IP -&gt;添加当前IP</li><li id="a3dd" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">我们必须等到MongoDB数据库云部署完毕。</li><li id="9f85" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">部署后，我们需要转到群集-&gt;然后单击连接-&gt;单击连接到应用程序-&gt;然后指定应用程序-&gt;我们需要复制URL。</li><li id="3b69" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">在URL中，我们需要替换用户名和密码，并将其作为常量字符串传递。</li></ol><p id="4c6c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> Node JS: </strong> Node JS是一个开源的服务器环境，在后台使用Javascript。Node JS使用事件驱动的异步非阻塞编程方法。这是什么意思？Node JS实际上运行在单线程上。因此，从技术上讲，它应该能够一次服务一个请求。因此，在这种情况下，当有多个请求时，请求会排队，系统会变慢。对节点JS的请求大多是基于IO的。这里，Node JS的非阻塞IO理论就发挥作用了。当主节点JS线程接收到一个IO请求时，它只是将该请求传送给一些工作线程，这些工作线程主要是服务器系统的内核级线程，然后返回去处理另一个用户请求，而不是仅被一个请求阻塞。这就是为什么说节点JS有一个非阻塞IO。现在，您可能想知道，节点JS如何处理请求的响应。这就是编程方法的异步特性的来源。Node JS中的每个IO请求都有一个<strong class="is hu">回调函数</strong>，当响应返回时激活。然后，节点JS线程再次以异步方式获取响应。这就是为什么说节点JS是异步的。节点Js包由NPM或节点包管理器安装和管理。节点JS可以从<a class="ae ko" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">这里</a>安装。也可以使用以下方式进行安装:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="2632" class="jo jp ht li b fi lm ln l lo lp">sudo apt update<br/>sudo apt install nodejs<br/>sudo apt install npm</span></pre><p id="73ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用以下方式验证已安装服务的版本:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="4065" class="jo jp ht li b fi lm ln l lo lp">nodejs -v<br/>npm -v</span></pre><p id="bca1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Express JS:  Express是一个最小且灵活的Node.js web应用程序框架，它为web和移动应用程序提供了一组健壮的特性。它充当中间件，支持HTTP请求。Express JS还有助于为应用程序创建路由架构。</p><p id="ba61" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们已经看到了所有需要的元素，让我们继续应用程序。</p><h2 id="6a15" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated"><strong class="ak">构建应用</strong></h2><p id="7d63" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">要构建一个应用程序，我们首先需要使用以下命令启动文件夹中的节点数据包管理器:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="a89d" class="jo jp ht li b fi lm ln l lo lp">npm init</span></pre><p id="bc8b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦我们启动了包管理器，它就会创建一个package.json文件，其中包含以下必填字段和author字段。</p><figure class="ld le lf lg fd hk er es paragraph-image"><div class="er es lq"><img src="../Images/77fe4121263b0ea3b78cd901271d9194.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*VnMLmmp4Dkdj7ueYV9r05A.png"/></div></figure><p id="ff51" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们需要使用npm install <package_name>为节点JS安装所需的依赖项。</package_name></p><p id="8aa0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于一个简单的CRUD应用程序，我们需要一些特定的库。它们是:</p><ol class=""><li id="7359" class="kp kq ht is b it iu ix iy jb kr jf ks jj kt jn ku kv kw kx bi translated"><strong class="is hu"> Express: </strong>我们讨论过，需要Express JS，所以需要安装。安装:<strong class="is hu"> npm快速安装</strong></li><li id="d74b" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hu"> Nodemon: </strong>这个库有助于在我们对源代码做一些修改时自动更新服务器。安装:<strong class="is hu"> npm安装节点。</strong></li><li id="4d23" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hu">mongose:</strong>帮助建立连接，查询MongoDB。安装:<strong class="is hu"> npm安装猫鼬。</strong></li></ol><p id="7f5b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦安装了库依赖项，我们需要再次转到package.json，并将"<strong class="is hu"> scripts </strong>"字段更改为</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="82ff" class="jo jp ht li b fi lm ln l lo lp">"start": "nodemon index.js"</span></pre><p id="d556" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">改变这一点的原因是，实际上我们的整个应用程序是从“index.js”文件启动的。现在，每当我们对源代码进行更改时，我们都希望Nodemon以开发模式启动应用程序脚本。</p><p id="8589" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像Node JS这样的系统目前是在MVC(模型视图控制器)架构上运行的。这是一种设计模式。这个想法是，它有助于专注于应用程序的特定部分，并在模块化的基础上构建它。这些组件是:</p><p id="601b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">模型:</strong>它表示数据库中存储的数据的结构和约束。</p><p id="3470" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">视图:</strong>根据用户的需求，将所需数据呈现给用户的方式。</p><p id="0897" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">控制器:</strong>这个部分控制用户的请求，并生成适当的响应，反馈给用户。</p><p id="e476" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在完成基本结构之后，我们将开始创建所需的文件和文件夹。</p><p id="1207" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，我们首先创建一个文件“index.js”，这是我们的启动脚本页面。</p><p id="86fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在“index.js”文件中，我们包括express和mongoose，并初始化express应用程序:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="d921" class="jo jp ht li b fi lm ln l lo lp">const express= require('express');<br/>const mongoose= require('mongoose');</span><span id="f404" class="jo jp ht li b fi lr ln l lo lp">const app=express();</span></pre><p id="1759" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“require”关键字用于将模块导入我们的程序代码。不过这是旧的格式。在新版本中，我们可以使用“导入”关键字。</p><p id="177f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们需要建立与MongoDB服务器的数据库连接。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="ccb6" class="jo jp ht li b fi lm ln l lo lp">const url= "mongodb://localhost:27017";</span><span id="5f8d" class="jo jp ht li b fi lr ln l lo lp">mongoose.connect(url,{useNewUrlParser: true});<br/>const con= mongoose.connection;<br/>app.use(express.json());<br/>try{<br/>    con.on('open',() =&gt; {<br/>        console.log('connected');<br/>    })<br/>}catch(error)<br/>{<br/>    console.log("Error: "+error);<br/>}</span></pre><p id="ebf3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的脚本将帮助我们连接到MongoDB。如果我们使用Mongo Atlas，我们只需要将变量“url”替换为如上图所示从Atlas中获取的URL。语句<strong class="is hu"> app.use() </strong>让应用程序使用某些特性。这里的元素“express.json”帮助节点应用程序解析json数据。为此，我们也可以使用主体解析器库。</p><p id="52c5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们已经准备好托管应用程序了。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="8f09" class="jo jp ht li b fi lm ln l lo lp">const port=9000;<br/>app.listen(port, () =&gt;{<br/>    console.log('Server started');<br/>})</span></pre><p id="a114" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们只需要我们的应用程序监听一个特定的端口。我们在这里选择了端口9000。</p><p id="92ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦我们成功托管了应用程序，让我们来看看如何定义我们将用于应用程序的数据结构。在这个应用程序中，我们将简单地创建一个学生记录应用程序。</p><p id="db28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们创建一个名为“模型”的文件夹。该文件夹保存项目数据库中存储的所有数据的模型结构。我们将使用NoSQL，但我们仍然需要一个基本的结构来说明应该有哪些字段以及对这些字段的约束。因此，在模型文件夹中，我们创建了一个“studentdata.js”文件。该文件应该包含数据库中学生数据条目的结构。现在，对于每个组件，我们都需要一个模型文件。因为我们只有一个组件，只有学生数据，所以在“Model”文件夹中只有一个文件。那么，我们来看看如何定义模型。</p><p id="2bd5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了构建模型，我们需要使用Mongoose库中的模式和模型函数。mongoose.schema()函数帮助定义数据库的模式，mongoose.model()函数帮助转换模式并将其导出为数据模型。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="f09e" class="jo jp ht li b fi lm ln l lo lp">const mongoose =require('mongoose');</span><span id="8ecd" class="jo jp ht li b fi lr ln l lo lp">const studentSchema = mongoose.Schema({<br/>    name: {<br/>        type: String,<br/>        required: true,<br/>    },<br/>    roll: {<br/>        type: String,<br/>        required: true,<br/>        unique: true,    <br/>    },<br/>    registration: {<br/>        type: String,<br/>        required: true,<br/>        unique: true,<br/>    },<br/>    subjects: {<br/>        type: [String],<br/>        required: true,<br/>    },<br/>    registered_on: {<br/>        type: Date,<br/>        default: new Date(),<br/>    },</span><span id="d874" class="jo jp ht li b fi lr ln l lo lp">})</span><span id="9706" class="jo jp ht li b fi lr ln l lo lp">var studentdata=mongoose.model('studentdata',studentSchema);<br/>module.exports= studentdata;</span></pre><p id="5fd2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码展示了如何创建一个模式和数据模型。对于每个字段，我们必须定义如下所示的特性。“主题”字段是一个数组，因此表示为一个字符串数组。同样，对于每个字段，我们必须定义变量的类型。声明之后，我们需要导出模型，这样我们就可以使用后端其他部分的功能。因此，我们将模型导出为变量“studentdata”。这里我们使用了" module.exports "命令，但它在ES6以后的版本中" export "关键字起作用。</p><p id="4b0f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们来看两个最重要的部分:路线和控制器。路由是实际创建和托管API的部分。通常情况下，我们不需要创建控制器，但这是一个很好的做法，因为有时如果有太多的控制功能，如果我们将它们全部堆叠在路由文件中，管理起来会变得非常困难。因此，我们在控制器部分定义函数，并将它们导入到路由部分，以保持操作处理更加流畅。</p><p id="7272" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，让我们看看路由实际上是什么。当用户想要从数据库中查询数据或者想要将数据推入数据库时，类似地删除或更新，前端以API调用的形式发出请求。现在，每个问题都有不同的要求。对于查询，我们有GET请求，对于发送数据，我们有POST请求。这些被称为HTTP请求。它们支持客户端和服务器之间的交互，并作为请求-响应协议工作。HTTP请求包括:</p><p id="d4ac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> GET用于从指定的资源请求数据。</strong></p><p id="2194" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> POST用于向服务器发送数据以创建/更新资源。</strong></p><p id="cff5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> HEAD:与GET相同，但是它只传输状态行和头部分。</strong></p><p id="36ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">PUT:用上传的内容替换目标资源的所有当前表示。</p><p id="eec7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">删除:删除URI给出的目标资源的所有当前表示。</p><p id="3315" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">连接:建立到由给定URI标识的服务器的隧道。</strong></p><p id="fd93" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">补丁:补丁方法将部分修改应用于资源</strong></p><p id="e275" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，要使用这些请求，express js具有路由功能。<strong class="is hu">路线定义采用以下结构:</strong></p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="074c" class="jo jp ht li b fi lm ln l lo lp"><strong class="li hu">app.METHOD(PATH, HANDLER)</strong></span></pre><p id="5052" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">其中:</strong></p><ul class=""><li id="b70c" class="kp kq ht is b it iu ix iy jb kr jf ks jj kt jn ls kv kw kx bi translated"><strong class="is hu"> app是express的一个实例。</strong></li><li id="7c38" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ls kv kw kx bi translated"><strong class="is hu">方法是一个HTTP请求方法，小写。</strong></li><li id="bfc3" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ls kv kw kx bi translated"><strong class="is hu"> PATH是服务器上的路径。(网址路径)</strong></li><li id="bed3" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ls kv kw kx bi translated"><strong class="is hu">处理程序是路径匹配时执行的功能。(处理函数)</strong></li></ul><p id="056e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">方法是必需的请求，如果是查询，方法将是GET方法，依此类推。该路径是请求URL。说，我们请求</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="2994" class="jo jp ht li b fi lm ln l lo lp">www.abc.com/xyz</span></pre><p id="fc70" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么“/xyz”就是路径。处理函数是在请求完成时执行的异步回调函数。那么，让我们看看路由器实际上是如何创建的。</p><p id="fac7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们创建一个“Routes”文件夹，在其中创建所有路由文件。对于域的每个子部分，我们创建一个单独的文件。例如:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="616f" class="jo jp ht li b fi lm ln l lo lp"><a class="ae ko" href="http://www.abc.com/xyz" rel="noopener ugc nofollow" target="_blank">www.abc.com/xyz</a><br/>www.abc.com/pqr<br/>www.abc.com/cde</span></pre><p id="38df" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“xyz”、“pqr”、“cde”都是abc.com域名的子域名。对于每条路线，我们在routes文件夹中创建单独的js文件。我们的应用程序非常简单，只有“/students”路径，所以我们的Routes文件夹中只有一个js文件。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="8d91" class="jo jp ht li b fi lm ln l lo lp">const express = require("express");</span><span id="ab4e" class="jo jp ht li b fi lr ln l lo lp">const  student_Act = require("../controllers/students");</span><span id="0f3a" class="jo jp ht li b fi lr ln l lo lp">const router = express.Router();</span><span id="7e21" class="jo jp ht li b fi lr ln l lo lp">router.get('/', student_Act.getStudents);<br/>router.get('/:roll', student_Act.getspecStudent);<br/>router.post('/', student_Act.createstudent);<br/>router.patch('/:roll', student_Act.updatestudent);<br/>router.delete('/:roll', student_Act.deletestudent);</span><span id="847b" class="jo jp ht li b fi lr ln l lo lp">module.exports=router;</span></pre><p id="bde9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码显示了如何创建一个路由器。现在，你可以看到我们使用了“/”作为路径，而不是“/学生”。这是因为当我们将整个东西嵌入到index.js文件中时，我们将在路径中使用扩展名“students”。我们已经从控制器文件夹中导入了所有的函数，接下来我们将创建这个文件夹。每个路由都相应地传递了处理函数。现在，在一些地方，我们看到路径是“/:roll”，这是参数传递的方式。在这个项目中，我们使用roll字段作为主键来标识每个学生。因此，它在一些路由中作为参数传递，作为标识学生的主键。当我们需要获取特定学生的数据、更新或删除特定学生数据时，已经传递了这些参数。</p><p id="70c5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以将参数传递为:</p><ol class=""><li id="54e8" class="kp kq ht is b it iu ix iy jb kr jf ks jj kt jn ku kv kw kx bi translated">使用参数字符串形式的参数字符串示例:<a class="ae ko" href="http://www.abc.com/student/23" rel="noopener ugc nofollow" target="_blank">www.abc.com/student/23</a>其中23是参数，我们需要将后端的URL构造为:<br/> app.get('/path/:id ')</li><li id="30b3" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">使用查询字符串:我们可以以查询字符串的形式传递参数:<br/>例如:app.get('path ')</li></ol><p id="37f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦我们创建了路由器，我们就将它导出并嵌入到索引js文件中。</p><p id="69db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们转到控制器部分，定义要在Routes部分使用的函数。</p><p id="4217" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们创建一个名为“控制器”的文件夹。其中我们用Routes文件夹结构相应地定义了js文件。在这种情况下，我们相应地在“Routes”文件夹中创建文件“students.js”。</p><p id="4028" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在js文件中，我们首先导入依赖项、我们创建的模型、express路由器和mongoose。接下来，我们将函数定义如下:</p><p id="d97d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">查询所有学生数据</strong></p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="42fe" class="jo jp ht li b fi lm ln l lo lp">const getStudents = async (req, res) =&gt; {<br/>    try {<br/>        const student= await Student.find();<br/>        <br/>        res.status(200).json(student);<br/>    } catch(error) {<br/>        res.status(404).json({message: error.message});<br/>    }<br/>}</span></pre><p id="2058" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的函数用于从数据库中查询所有的学生数据。我们可以使用。来自mongoose的find()函数。我们使用了“async”和“await”关键字，因为数据库查询需要时间，所以需要使用节点js的异步属性。现在，我们已经传递给参数“请求”和“响应”。对于从客户端到服务器的每个HTTP请求，都会传递这两个参数。</p><p id="2e0f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">查询所有学生数据</strong></p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="4e39" class="jo jp ht li b fi lm ln l lo lp">const getspecStudent = async (req,res) =&gt; {<br/>    const roll = req.params.roll;</span><span id="052d" class="jo jp ht li b fi lr ln l lo lp">try {<br/>        const stud = await Student.findOne({roll: roll});</span><span id="2f9e" class="jo jp ht li b fi lr ln l lo lp">res.status(200).json(stud);<br/>    } catch(error) {<br/>        res.status(404).json({ message: error.message});<br/>    }<br/>}</span></pre><p id="d030" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们所看到的，在第二条语句中，我们已经从URL中检索了roll参数。我们可以使用findone()以roll作为查询字段来查找特定的学生。</p><p id="911c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">将学生数据发布到数据库</strong></p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="60ed" class="jo jp ht li b fi lm ln l lo lp">const createstudent =  async (req, res) =&gt; {<br/>    console.log(req.body);<br/>    const newstudent = new Student({<br/>        name:req.body.name,<br/>        roll:req.body.roll,<br/>        registration:req.body.registration,<br/>        subjects:req.body.subjects,<br/>        created_on:req.body.created_on</span><span id="3c7f" class="jo jp ht li b fi lr ln l lo lp">})<br/>    try {<br/>        await newstudent.save();</span><span id="5151" class="jo jp ht li b fi lr ln l lo lp">res.status(201).json(newstudent);</span><span id="87a4" class="jo jp ht li b fi lr ln l lo lp">} catch(error) {<br/>        res.status(400).json({ message : error.message});<br/>    }</span></pre><p id="26cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这里的post请求，我们已经获得了如下所示的请求体。</p><p id="9c92" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，我们还创建了更新和删除功能。在我们创建了所有的函数之后，我们将它们导出，以便在我们的路由文件中导入和使用。</p><p id="dd5b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦所有东西都创建好了，我们就回到我们的“index.js”文件并在那里嵌入路由，如图所示。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="3af1" class="jo jp ht li b fi lm ln l lo lp">const studentrouter= require("./routes/students");<br/>app.use('/students',studentrouter)</span></pre><p id="6df6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，student.js文件中的每条路径都可以在“/students”路径中访问。</p><h2 id="41ca" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">结果呢</h2><p id="b8ba" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">一切就绪后，我们可以使用以下工具启动我们的服务器:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="98b0" class="jo jp ht li b fi lm ln l lo lp">npm start</span></pre><p id="4d9d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用像邮递员这样的应用程序来可视化结果。</p><figure class="ld le lf lg fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lt"><img src="../Images/37fcaffe2592947c77418c465bf1ab42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GtGZeIfCiFmpszIIVZqmFQ.png"/></div></div></figure><p id="c5ae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上图显示了我们如何使用Postman在<a class="ae ko" href="http://localhost:9000/students" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/students</a>URL上创建POST查询。主体作为原始JSON传递。</p><h2 id="c65f" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated"><strong class="ak">结论</strong></h2><p id="103f" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">这就是我们如何创建一个简单的CRUD应用程序。</p><p id="4551" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">项目链接可以在<a class="ae ko" href="https://github.com/abr-98/CRUD-App-" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="db6d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这有所帮助！！！。</p></div></div>    
</body>
</html>