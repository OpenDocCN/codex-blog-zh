<html>
<head>
<title>Custom Error Responses With ASP.NET Core 6 Web API and FluentValidation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ASP.NET核心6 Web API和FluentValidation定制错误响应</h1>
<blockquote>原文：<a href="https://medium.com/codex/custom-error-responses-with-asp-net-core-6-web-api-and-fluentvalidation-888a3b16c80f?source=collection_archive---------1-----------------------#2022-09-22">https://medium.com/codex/custom-error-responses-with-asp-net-core-6-web-api-and-fluentvalidation-888a3b16c80f?source=collection_archive---------1-----------------------#2022-09-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="40d6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何在ASP.NET核心中自动化错误处理</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e1297b38146da576d8b7f45a274d2974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q__RIKxXf2-vdP1w"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">埃里克·麦克林在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3225" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">假设我们正在创建一个多个客户端应该使用的公共API，并且我们已经达到了验证传入模型和处理坏请求的程度。我们希望尽可能自动化这一过程。此外，要求为每个错误实现一个唯一的代码，并将其包含在响应中。让我们考虑如何使用ASP.NET核心6和FluentValidation来实现这一点。</p><h1 id="59ff" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak">创建一个Web API项目</strong></h1><p id="d852" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">首先，让我们在命令行中使用以下三个命令创建一个新的web项目解决方案:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="2f7e" class="lm kl hi li b fi ln lo l lp lq">dotnet new sln --name WebAPICustomErrorResponses<br/>dotnet new web --name WebAPI --framework net6.0<br/>dotnet sln add .\WebAPI\WebAPI.csproj</span></pre><p id="e7fc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们转到WebAPI项目，并向其中添加Swagger和FluentValidation包:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="2f72" class="lm kl hi li b fi ln lo l lp lq">cd WebAPI<br/>dotnet add package Swashbuckle.AspNetCore --version 6.2.3<br/>dotnet add package FluentValidation.AspNetCore --version 11.1.2</span></pre><p id="b4e5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">转到<em class="lr"> launchSettings.json </em>并将下面一行添加到WebAPI和IIS Express配置文件中:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="1ed5" class="lm kl hi li b fi ln lo l lp lq">"launchUrl": "swagger"</span></pre><p id="cec9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">并使<em class="lr"> Program.cs </em>看起来<em class="lr"> </em>这样:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">程序. cs</figcaption></figure><h1 id="326e" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">实现端点</h1><p id="9dff" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在我们的演示应用程序中，我们将实现一个简单的API来创建和获取产品。产品模型看起来是这样的:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">产品. cs</figcaption></figure><p id="7529" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">具有GET和POST方法的控制器如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">ProductsController.cs</figcaption></figure><p id="f04c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们不会花太多时间为我们的产品建立一个数据库或另一个存储，因为这不是本文要讨论的，所以让我们只使用<em class="lr"> Products </em>静态字段并将我们的项目存储在那里(第9行)。</p><p id="c174" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要将控制器添加到ASP.NET核心，让我们修改<em class="lr"> Program.cs </em>这种<em class="lr"> </em>方式(第6行和第15行):</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">程序. cs</figcaption></figure><h1 id="bc88" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak">验证请求</strong></h1><p id="ef88" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">现在，我们已经到了需要在将产品添加到存储之前对其进行验证的时候了。如前所述，要求每个错误都有一个唯一的代码。因此，让我们定义以下误差模型:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Error.cs</figcaption></figure><p id="8080" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，让我们创建<em class="lr"> ProductValidator </em>类，并向<em class="lr">产品</em>模型添加一些验证规则:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">ProductValidator.cs</figcaption></figure><p id="08c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了让它工作，我们还需要向服务提供者<em class="lr"> </em>注册<em class="lr"> ProductValidator </em>，所以在您的<em class="lr"> Program.cs中添加下面一行代码:</em></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">程序. cs</figcaption></figure><p id="5a56" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们将验证器注入控制器:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">ProductsController.cs</figcaption></figure><p id="8bed" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了测试这一点，让我们尝试创建一个名称和数量为空的产品:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lu"><img src="../Images/1793ce69dac9d5e55584b149811220a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_pArK2jIxEIjMNUIH114cA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">API错误响应</figcaption></figure><p id="f6bd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以现在我们不能创建一个带有无效字段的新产品，错误模型也符合要求，但是我们如何改进我们的代码来进一步扩展呢？</p><h1 id="5451" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak">自动验证</strong></h1><p id="11b3" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">手动验证效果很好，但是如果我们不想在每个需要验证的端点中编写相同的代码呢？幸运的是，FluentValidation给了我们这个机会。首先，我们这样修改<em class="lr"> Program.cs </em>:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">程序. cs</figcaption></figure><p id="9394" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们移除了<em class="lr"> ProductValidator </em>注册，并代之以来自我们程序集的所有验证器的自动注册(第10–13行)。因为这几行代码，我们不再需要在<em class="lr"> Program.cs. </em>中注册验证器</p><p id="bb04" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，我们不需要在我们的端点编写错误处理代码，ASP.NET会为我们做这些。因此，让我们将<em class="lr"> ProductsController </em>回滚到以下状态:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">ProductsController.cs</figcaption></figure><p id="79a0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们来看看:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/6a83b07b98871ffb77e5a6628fd031c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fd5A8loWSWj7_r4SUF1Rcg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">API错误响应</figcaption></figure><p id="8935" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">验证仍然有效，但是请等待！错误模型改变了，这背后的原因是ASP.NET使用它的<a class="ae jn" href="https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-6.0" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> ModelState </em> </a>来处理所有无效请求。</p><p id="8571" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了克服这种行为，我们需要求助于没有被很好地记录的方法。</p><p id="4b68" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，我们需要实现一个拦截器，并将错误代码和消息一起传递给ModelState。拦截器可能是这样的:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">usecustomerrormodelinterceptor . cs</figcaption></figure><p id="c212" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">事实是，我们不能在这样的拦截器中覆盖ModelState结构。但是我们可以将错误序列化到适当的模型中，并将其作为字符串向前传递。</p><p id="3f0f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可能认为如果我们在拦截器中序列化我们的错误，我们也需要在其他地方反序列化它们…您是对的！</p><p id="0325" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们转到<em class="lr"> Program.cs </em>并对其进行如下修改:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">程序. cs</figcaption></figure><p id="6ce4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第13–23行是这里的关键，我们正在反序列化来自拦截器的错误，并更改错误响应的默认结构以适应我们的<em class="lr">错误</em>模型。</p><p id="a5d3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另外，不要忘记向服务提供者注册拦截器(第29行)。</p><p id="e8da" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们再次调用我们的端点:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/cd9bb87444032e6e05c646ed40db1077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UgL0ysd7clb14Hcdb_-KTw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">API错误响应</figcaption></figure><p id="b023" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们得到了预期的结果！可能是这样…但是让我们稍微改进和重构我们的程序。</p><h1 id="4ffb" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak">重构</strong></h1><p id="1cf5" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">为了使编写新验证器的过程更加方便，让我们创建一个小的扩展方法:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">ValidatorExtensions.cs</figcaption></figure><p id="f7ad" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个方法的用法是这样的:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">ProductValidator.cs</figcaption></figure><h1 id="0bb9" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak">结论</strong></h1><p id="45e3" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">好吧，就这样。感谢阅读！你可以在我的<a class="ae jn" href="https://github.com/BohdanTron/WebAPICustomErrorResponses" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到源代码。</p></div></div>    
</body>
</html>