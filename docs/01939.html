<html>
<head>
<title>Using the Strategy Pattern in Laravel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Laravel中的策略模式</h1>
<blockquote>原文：<a href="https://medium.com/codex/using-the-bridge-pattern-in-laravel-8fbe484817f1?source=collection_archive---------1-----------------------#2021-06-17">https://medium.com/codex/using-the-bridge-pattern-in-laravel-8fbe484817f1?source=collection_archive---------1-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d637c69d9515ea227b04a8875a31c1cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zr0oVnkzkJk2SFjDUGopfw.png"/></div></div></figure><h1 id="be77" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="d7dc" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在软件和web开发中，编写可维护和可扩展的代码总是很重要。您最初创建的解决方案可能会随着时间的推移而改变。所以，你需要确保你写代码的方式在将来不需要整个重写或重构。</p><p id="3b80" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">策略模式</strong>可以用来提高代码的可扩展性，也可以随着时间的推移提高可维护性。</p><h1 id="e9cf" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">目标受众</h1><p id="1df3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这篇文章是为Laravel开发人员写的，他们了解接口是如何工作的，以及如何使用它们来解耦你的代码。如果你对这个主题有点不确定，看看我上周的帖子，讨论了<a class="ae kr" href="https://ashallendesign.co.uk/blog/using-interfaces-to-write-better-php-code" rel="noopener ugc nofollow" target="_blank">使用接口编写更好的PHP代码</a>。</p><p id="55d4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">强烈建议您理解<a class="ae kr" href="https://laravel.com/docs/8.x/controllers#dependency-injection-and-controllers" rel="noopener ugc nofollow" target="_blank">依赖注入</a>以及<a class="ae kr" href="https://laravel.com/docs/8.x/container#introduction" rel="noopener ugc nofollow" target="_blank"> Laravel服务容器</a>如何工作。</p><h1 id="ed12" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">什么是策略模式？</h1><p id="8698" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><a class="ae kr" href="https://refactoring.guru/design-patterns/strategy" rel="noopener ugc nofollow" target="_blank">重构大师</a>将策略模式定义为“行为设计模式，它让你定义一系列算法，将每一个算法放入一个单独的类，并使它们的对象可以互换”。这一开始听起来可能有点可怕，但我保证没有你想象的那么糟糕。如果你想深入了解设计模式，我强烈推荐你去看看重构大师。他们在深入解释策略模式以及其他结构模式方面做得很好。</p><p id="465d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">策略模式基本上是一种帮助我们分离代码并使其具有超级可扩展性的模式。事实上，你可能每天都在使用它，甚至在使用<code class="du ks kt ku kv b">Storage</code>和<code class="du ks kt ku kv b">Cache</code>立面(以及其他一些地方)时都没有注意到。假设您使用以下代码:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="72a0" class="le ir hi kv b fi lf lg l lh li">Cache::put('name', 'Ash Allen', 600);</span></pre><p id="6dcb" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">上面的代码通过使用<a class="ae kr" href="https://laravel.com/docs/8.x/facades#introduction" rel="noopener ugc nofollow" target="_blank"> facade </a>从服务容器中解析一个类。我不会深入探讨facade是如何工作的，因为这不是本文的真正目的，但是需要知道的重要一点是，这里的<code class="du ks kt ku kv b">Cache</code> facade将一个接口(<code class="du ks kt ku kv b">Illuminate\Contracts\Cache\Factory</code>具体来说)绑定到一个类并使用它。然后在关键字'<em class="lj"> name </em>下存储单词'<em class="lj">Ash Allen</em>' 10分钟。</p><p id="fd03" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">正如你可能在<a class="ae kr" href="https://laravel.com/docs/8.x/cache#introduction" rel="noopener ugc nofollow" target="_blank"> Laravel文档</a>和你的项目配置中注意到的，Laravel支持一些不同的缓存驱动，包括:<a class="ae kr" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>、<a class="ae kr" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> DynamoDB </a>、<a class="ae kr" href="https://memcached.org/" rel="noopener ugc nofollow" target="_blank"> Memcached </a>和数据库。例如，如果我们在<em class="lj">中设置缓存驱动程序。env </em>文件到<code class="du ks kt ku kv b">CACHE_DRIVER=redis</code>，当我们运行上面的代码片段时，数据将存储在我们的Redis缓存中。然而，如果我们将驱动程序改为<code class="du ks kt ku kv b">CACHE_DRIVER=database</code>，这将导致数据存储在数据库中。</p><p id="7b82" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">每个不同的缓存驱动程序都有自己的类，处理框架如何与缓存交互。所以，当我们在我们的<em class="lj">里换驱动的时候。env </em>，Laravel需要知道使用哪个驱动。这就是策略模式介入的地方。在幕后，每当我们使用<code class="du ks kt ku kv b">Cache</code>外观时，Laravel实际上是从服务容器解析一个<code class="du ks kt ku kv b">Illuminate\Contracts\Cache\Factory</code>接口。它通过检查配置值(例如<em class="lj"> redis </em>、<em class="lj">数据库</em>等)来实现这一点。)然后将该接口映射到一个类。例如，每当我们将缓存驱动程序设置为<code class="du ks kt ku kv b">CACHE_DRIVER=redis</code>并尝试解析<code class="du ks kt ku kv b">Factory</code>接口时，我们将获得一个专门与Redis缓存交互的类，除此之外别无其他。</p><p id="d8af" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如您所见，策略模式可以提高代码的可扩展性。例如，如果我们想创建自己的自定义缓存驱动程序，我们可以只创建实现，然后让Laravel知道它可供使用。关于更多的上下文，<a class="ae kr" href="https://laravel.com/docs/8.x/cache#adding-custom-cache-drivers" rel="noopener ugc nofollow" target="_blank">查看Laravel文档</a>，看看如何添加你自己的驱动程序的例子。</p><h1 id="0439" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">使用Laravel中的策略模式</h1><p id="b541" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在我们对策略模式有了一个基本的概念，让我们看看如何在我们自己的Laravel应用程序中使用它。</p><p id="085f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">假设我们有一个Laravel应用程序，用户可以使用它来获取汇率和货币转换。现在，假设我们的应用程序使用一个外部API ( <a class="ae kr" href="https://exchangeratesapi.io" rel="noopener ugc nofollow" target="_blank"> exchangeratesapi.io </a>)来获取最新的货币转换。</p><p id="99fa" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以创建这个类来与API交互:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="db80" class="le ir hi kv b fi lf lg l lh li">class ExchangeRatesApiIO<br/>{<br/>    public function getRate(string $from, string $to): float<br/>    {<br/>        // Make a call to the exchangeratesapi.io API here and fetch<br/>        // the exchange rate.</span><span id="62f9" class="le ir hi kv b fi lk lg l lh li">        return $rate;<br/>    }<br/>}</span></pre><p id="5c08" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，让我们在控制器方法中使用这个类，这样我们就可以返回给定货币的汇率。我们将使用依赖注入来解析容器中的类:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="2e0a" class="le ir hi kv b fi lf lg l lh li">class RateController extends Controller<br/>{<br/>    public function __invoke(ExchangeRatesApiIO $exchangeRatesApiIO): JsonResponse<br/>    {<br/>        $rate = $exchangeRatesApiIO-&gt;getRate(<br/>            request()-&gt;from,<br/>            request()-&gt;to,<br/>        );</span><span id="1044" class="le ir hi kv b fi lk lg l lh li">        return response()-&gt;json(['rate' =&gt; $rate]);<br/>    }<br/>}</span></pre><p id="de26" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这段代码将按预期工作，但是我们已经将<code class="du ks kt ku kv b">ExchangeRatesApiIO</code>类与控制器方法紧密耦合。这意味着，如果我们决定迁移到使用不同的API，比如<a class="ae kr" href="https://fixer.io" rel="noopener ugc nofollow" target="_blank"> Fixer </a>，在未来，我们将需要用我们的新类替换代码库中所有使用<code class="du ks kt ku kv b">ExchangeRatesApiIO</code>类的地方。可以想象，在大型项目中，这有时会是一项缓慢而乏味的任务。因此，为了避免这个问题，我们可以使用策略模式来绑定和解析接口，而不是尝试在控制器方法中实例化一个类。</p><p id="4132" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们首先创建一个新的<code class="du ks kt ku kv b">ExchangeRatesService</code>界面:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="0f5c" class="le ir hi kv b fi lf lg l lh li">interface ExchangeRatesService<br/>{<br/>    public function getRate(string $from, string $to): float;<br/>}</span></pre><p id="2ce1" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们现在可以更新我们的<code class="du ks kt ku kv b">ExchangeRatesApiIO</code>类来实现这个接口:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="3380" class="le ir hi kv b fi lf lg l lh li">class ExchangeRatesApiIO implements ExchangeRatesService<br/>{<br/>    public function getRate(string $from, string $to): float<br/>    {<br/>        // Make a call to the exchangeratesapi.io API here and fetch the exchange rate.</span><span id="f48f" class="le ir hi kv b fi lk lg l lh li">        return $rate;<br/>    }<br/>}</span></pre><p id="53ff" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在我们已经完成了，我们可以更新我们的控制器方法来注入接口而不是类:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="d00a" class="le ir hi kv b fi lf lg l lh li">class RateController extends Controller<br/>{<br/>    public function __invoke(ExchangeRatesService $exchangeRatesService): JsonResponse<br/>    {<br/>        $rate = $exchangeRatesService-&gt;getRate(<br/>            request()-&gt;from,<br/>            request()-&gt;to,<br/>        );</span><span id="b677" class="le ir hi kv b fi lk lg l lh li">        return response()-&gt;json(['rate' =&gt; $rate]);<br/>    }<br/>}</span></pre><p id="46ca" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">当然，我们不能实例化一个接口；我们想要实例化<code class="du ks kt ku kv b">ExchangeRatesApiIO</code>类。因此，每当我们试图从容器中解析接口时，我们需要告诉Laravel该做什么。我们可以通过使用<a class="ae kr" href="https://laravel.com/docs/8.x/providers#introduction" rel="noopener ugc nofollow" target="_blank">服务提供者</a>来做到这一点。有些人更喜欢将这样的东西放在他们的<code class="du ks kt ku kv b">AppServiceProvider</code>中，并将他们所有的绑定放在一个地方。然而，我更喜欢为我想要创建的每个绑定创建一个单独的提供者。这纯粹是个人喜好，你觉得什么更适合你的工作流程。对于本例，我们将创建自己的服务提供商。</p><p id="99f5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们使用Artisan命令创建一个新的服务提供者:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="ce1f" class="le ir hi kv b fi lf lg l lh li">php artisan make:provider ExchangeRatesServiceProvider</span></pre><p id="6997" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">然后我们需要记住在<code class="du ks kt ku kv b">app/config.php</code>中注册这个服务提供商，如下所示:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="f15a" class="le ir hi kv b fi lf lg l lh li">return [<br/>    <br/>    'providers' =&gt; [<br/>        // ...<br/>        \App\Providers\ExchangeRatesServiceProvider::class,<br/>        // ...<br/>    ],<br/> <br/>];</span></pre><p id="37cc" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，我们可以向服务提供者添加代码来绑定接口和类:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="ae48" class="le ir hi kv b fi lf lg l lh li">class ExchangeRatesServiceProvider extends ServiceProvider<br/>{<br/>    public function register(): void<br/>    {<br/>        $this-&gt;app-&gt;bind(ExchangeRatesService::class, ExchangeRatesApiIO::class);<br/>    }<br/>}</span></pre><p id="7b40" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在我们已经完成了所有这些，当我们在控制器方法中依赖注入<code class="du ks kt ku kv b">ExchangeRatesService</code>接口时，我们将收到一个可以使用的<code class="du ks kt ku kv b">ExchangeRatesApiIO</code>类。</p><h1 id="f1a2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">更进一步</h1><p id="9e6b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">既然我们知道了如何将一个接口绑定到一个类，让我们更进一步。让我们想象一下，只要我们想更新一个配置字段，就可以决定是使用ExchangeRatesAPI.io还是Fixer.io API。</p><p id="e776" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们还没有处理Fixer.io API的类，所以让我们创建一个并确保它实现了<code class="du ks kt ku kv b">ExchangeRatesService</code>接口:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="94ee" class="le ir hi kv b fi lf lg l lh li">class FixerIO implements ExchangeRatesService<br/>{<br/>    public function getRate(string $from, string $to): float<br/>    {<br/>        // Make a call to the Fixer API here and fetch the exchange rate.</span><span id="cd3d" class="le ir hi kv b fi lk lg l lh li">        return $rate;<br/>    }<br/>}</span></pre><p id="dae6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们现在将在我们的<code class="du ks kt ku kv b">config/services.php</code>文件中创建一个新字段:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="6e01" class="le ir hi kv b fi lf lg l lh li">return [</span><span id="98e3" class="le ir hi kv b fi lk lg l lh li">    //...</span><span id="309c" class="le ir hi kv b fi lk lg l lh li">    'exchange-rates-driver' =&gt; env('EXCHANGE_RATES_DRIVER'),</span><span id="99b1" class="le ir hi kv b fi lk lg l lh li">];</span></pre><p id="d310" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们现在可以更新我们的服务提供者，以更改每当我们从容器中解析接口时将返回的类:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="e13b" class="le ir hi kv b fi lf lg l lh li">class ExchangeRatesServiceProvider extends ServiceProvider<br/>{<br/>    public function register(): void<br/>    {<br/>        $this-&gt;app-&gt;bind(ExchangeRatesService::class, function ($app) {<br/>            if (config('services.exchange-rates-driver') === 'exchangeratesapiio') {<br/>                return new ExchangeRatesApiIO();<br/>            }<br/>    <br/>            if (config('services.exchange-rates-driver') === 'fixerio') {<br/>                return new FixerIO();<br/>            }<br/>    <br/>            throw new Exception('The exchange rates driver is invalid.');<br/>        });<br/>    }<br/>}</span></pre><p id="9f8f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，如果我们在<em class="lj">中设置汇率驱动因素。env </em>到<code class="du ks kt ku kv b">EXCHANGE_RATES_DRIVER=exchangeratesapiio</code>并尝试从容器中解析<code class="du ks kt ku kv b">ExchangeRatesService</code>，我们将收到一个<code class="du ks kt ku kv b">ExchangeRatesApiIO</code>类。如果我们在<em class="lj">中设置汇率驱动因素。env </em>到<code class="du ks kt ku kv b">EXCHANGE_RATES_DRIVER=fixerio</code>并尝试从容器中解析<code class="du ks kt ku kv b">ExchangeRatesService</code>，我们将收到一个<code class="du ks kt ku kv b">FixerIO</code>类。如果我们不小心将driver设置为其他任何东西，就会抛出一个异常，让我们知道这是不正确的。</p><p id="9508" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">由于这两个类实现了相同的接口，我们可以无缝地更改<em class="lj">中的<code class="du ks kt ku kv b">EXCHANGE_RATES_DRIVER</code>字段。env </em>文件，不需要在任何地方修改任何其他代码。</p><h1 id="4384" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="b0c1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">你脑子炸了吗？如果是，不用担心！就我个人而言，当我第一次了解这个话题时，我觉得很难理解。我觉得直到我付诸实践，自己用了，才开始真正理解。所以，我建议你自己花点时间尝试一下。一旦你习惯了使用它，我保证你会开始在你自己的项目中使用它。</p><p id="c80c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">希望这篇文章已经向您概述了什么是策略模式，以及如何在Laravel中使用它来提高代码的可扩展性和可维护性。</p><p id="7393" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果你觉得这篇文章有用，我很乐意在评论中听到。</p><p id="927a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">继续建造令人敬畏的东西！🚀</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="30c0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="lj">最初发表于</em><a class="ae kr" href="https://ashallendesign.co.uk/blog/using-the-bridge-pattern-in-laravel" rel="noopener ugc nofollow" target="_blank"><em class="lj"/></a><em class="lj">。</em></p></div></div>    
</body>
</html>