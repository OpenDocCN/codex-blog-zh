<html>
<head>
<title>How does Xcode work when we build the iOS app project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当我们构建iOS应用程序项目时，Xcode是如何工作的</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-xcode-work-when-we-build-the-ios-app-project-95fe95f0b17?source=collection_archive---------4-----------------------#2022-10-18">https://medium.com/codex/how-xcode-work-when-we-build-the-ios-app-project-95fe95f0b17?source=collection_archive---------4-----------------------#2022-10-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/5593a7981f995ff244b450be155fddf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XReL9ZpMLiQMYUA9"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">罗斯·斯奈登在<a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2594" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你们中的许多人都熟悉Xcode，通常，Xcode被许多iOS开发人员用来开发一个iOS应用程序，但你是否一直想知道Xcode从我们的源代码到成为可执行的应用程序的过程是什么。ipa)？在这篇文章中，我将以简洁的方式向你解释Xcode如何处理我们的源代码，使之成为一些可执行的应用程序。</p><p id="1d3e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果你查看Xcode中的<code class="du kb kc kd ke b">Show the report navigator</code>菜单，有一个过程叫做构建，如果你点击它，它会显示从<code class="du kb kc kd ke b">prepare build</code>到<code class="du kb kc kd ke b">build target of your project</code>的许多过程。在本文中，我将只解释构建目标过程的阶段，尤其是在称为编译和链接的过程中，因为如果您想从Xcode构建系统迁移到自己的构建系统中，这是一个非常基本的概念。</p><p id="3e6d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在我们开始解释编译和链接过程之前，通常编程语言有两种不同的类型，第一种是解释编程语言，第二种是编译编程语言。</p><p id="a8e7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">解释编程语言的主要思想从字面上看是一种不进行编译过程的编程语言，然而，它进行解释或翻译该语言的过程。</p><p id="7f59" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">通常解释型编程语言会复制用户将要运行的源代码。为了运行源代码，用户将需要解释器来翻译或解释代码。代码和解释器将同时运行。解释器的一个例子是网络浏览器。</p><p id="cc94" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">解释程序语言的例子有PHP、ruby、javascript等。</p><p id="a4f6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">编译编程语言的主要思想是将高级或人类可读的源代码翻译成机器代码的程序，它将作为可执行的应用程序由CPU运行。</p><p id="c9e1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">编译编程语言的例子有swift、objective c、java、c++等。</p><p id="109c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">而且，因为swift是一种编译的编程语言，难怪在Xcode中，当我们构建iOS应用程序项目时，Xcode将需要编译Swift源代码并将其链接到可执行的应用程序中，以便设备可以运行该应用程序。ipa)。</p><p id="230b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">与其他编程语言一样，swift具有与其他编程语言相同的编译器和链接器进程，但在swift中，它具有一些额外的进程，这就是为什么它使swift编译器进程比其他程序更复杂。我不会在这里讨论细节，因为这将需要一个漫长的阅读旅程来解释它。</p><p id="3ea4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">所以基本上swift在编译过程中有两个维度，即前端和后端。</p><ul class=""><li id="31be" class="kf kg hi jf b jg jh jk jl jo kh js ki jw kj ka kk kl km kn bi translated"><strong class="jf hj">前端:</strong>在前端swift像其他常见的编程语言一样进行词法分析、解析和语义分析，例如在这个过程中，swift代码将被词法分析作为文本和令牌，传递给解析器转换成程序的结构化表示。这个表示也将被传递给语义分析，之后它将被传递给后端流程。</li><li id="9e3f" class="kf kg hi jf b jg ko jk kp jo kq js kr jw ks ka kk kl km kn bi translated"><strong class="jf hj">后端:</strong> Swift在后端做了一些非常聪明的事情来处理优化和代码生成阶段。Swift编译器使用LLVM进行优化和二进制生成。当Swift代码以抽象语法树(AST)的形式被解析时，该语法树然后通过语义分析并被转换成Swift中间语言(SIL)。这段代码与LLVM IR(中间表示)一起经过分析和优化。在这里LLVM把我们原来的Swift代码变成了汇编代码，最后以二进制文件结束，然后它会被链接成一个可执行的app。</li></ul><p id="8c57" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是我为swift编译和链接流程创建的简明图表。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es kt"><img src="../Images/3a367fa25001038094063d541d909a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2dWtBdSA3BVZbl_-9TEIKg.png"/></div></div></figure><p id="a613" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">简而言之，我们的档案。swift在swift编译过程中会被LLVM翻译成汇编文件，最后变成二进制文件(。o)，这是一个二进制文件，用于创建可执行的应用程序。以及如何从二进制文件创建可执行的app？在这里，我们需要链接过程，所以基本上链接器是将一个或多个目标文件组合成一个二进制或可执行文件的计算机系统程序。想象一个拼图，在你看到拼图的图像之前，你需要把每一块组合到正确的地方，直到你看到一个完整的图像。在这种情况下，你作为组合拼图碎片的人，意味着你是链接者，拼图的每一个碎片都是目标文件。</p><p id="a299" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我希望这个解释已经非常简洁地解释了swift编程语言中的编译和链接过程，现在让我们动手编译和链接我们的swift文件。</p><p id="52fa" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你可以试着按照下面的这些命令，在<a class="ae jc" href="https://github.com/dannysantoso/ios-compiler-medium" rel="noopener ugc nofollow" target="_blank">这里</a>使用示例代码进行编译和链接。</p><p id="b688" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">或者您可以为这个示例类创建一个单独的文件。</p><ul class=""><li id="298f" class="kf kg hi jf b jg jh jk jl jo kh js ki jw kj ka kk kl km kn bi translated">用下面的代码创建一个名为Bob.swift的文件。</li></ul><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="ku kv l"/></div></figure><ul class=""><li id="7b24" class="kf kg hi jf b jg jh jk jl jo kh js ki jw kj ka kk kl km kn bi translated">使用以下代码创建一个名为John.swift的文件</li></ul><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="ku kv l"/></div></figure><ul class=""><li id="9886" class="kf kg hi jf b jg jh jk jl jo kh js ki jw kj ka kk kl km kn bi translated">使用以下代码创建一个名为People.swift的文件</li></ul><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="ku kv l"/></div></figure><ul class=""><li id="5316" class="kf kg hi jf b jg jh jk jl jo kh js ki jw kj ka kk kl km kn bi translated">使用以下代码创建一个名为main.swift的文件</li></ul><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="de8b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在你创建了这些文件或者下载了我分享的源代码之后。现在让我们试着编译所有这些文件。您可以尝试使用以下命令:</p><pre class="in io ip iq fd kw ke kx ky aw kz bi"><span id="5ffa" class="la lb hi ke b fi lc ld l le lf">swiftc main.swift John.swift Bob.swift People.swift -o Executable.out</span></pre><p id="6484" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这个命令中，你将我们需要的所有文件swift写在里面，并在-o后定义了可执行文件名，-o在这里意味着输出。因此，在您运行这个命令之后，可执行的应用程序将被命名为Executable.out。</p><p id="6414" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果您想知道这个编译背后的所有进程，您可以添加-v (verbose)来了解其中的进程。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lg"><img src="../Images/423ccdf549338aafa5c79e6bc481664f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4iVkeeR5Yj84AfaABkcEHQ.png"/></div></div></figure><p id="2d40" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如您所见，在第一行和第二行，编译器定义了要使用的架构目标和swift版本，之后，在我标记的红线中，它显示了终端显示编译main.swift的命令，在蓝线中显示了编译John.swift的命令，等等。直到我们有了所有的二进制文件，终端将显示链接所有这些二进制文件的命令。</p><p id="071f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">不幸的是，通过使用这个命令，每次我们修改代码时，我们都需要重新编译所有这些文件。所以这就是为什么我们可以分开来把每个模块作为一个模块一个一个地编译，所以如果一个文件有任何变化，我们只编译变化文件所在的一个模块。</p><p id="c15d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这也是为什么，当你有一个完整的iOS应用程序项目，其中有一个大文件，当你创建一个小的变化，将需要很长时间来编译。因为它将再次编译应用程序项目中的所有文件。解决方案是您需要将这些文件作为一个模块分开。</p><p id="bc4b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">下面是一个例子，如果你想分开每次编译。</p><ul class=""><li id="683f" class="kf kg hi jf b jg jh jk jl jo kh js ki jw kj ka kk kl km kn bi translated">编译People.swift</li></ul><pre class="in io ip iq fd kw ke kx ky aw kz bi"><span id="c7d9" class="la lb hi ke b fi lc ld l le lf">swiftc -c People.swift</span></pre><p id="fe84" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因为People file/class根本没有任何依赖关系，所以我们可以直接使用这个命令。</p><ul class=""><li id="7eb5" class="kf kg hi jf b jg jh jk jl jo kh js ki jw kj ka kk kl km kn bi translated">编译John.swift</li></ul><pre class="in io ip iq fd kw ke kx ky aw kz bi"><span id="8a3e" class="la lb hi ke b fi lc ld l le lf">swiftc -c John.swift People.swift -module-name MyApp</span></pre><p id="0b74" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">由于John.swift与People.swift有依赖关系，我们需要在命令中声明依赖文件，并将它们分组到一个模块中。</p><p id="c078" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">该命令中的顺序文件名很重要，第一个顺序是将被转换为目标文件的swift文件，其余的是文件依赖关系。</p><p id="f369" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">-module-name —是要构建的模块的名称，为了便于理解，您可以假设这是同一目录中的一组swift文件。</p><ul class=""><li id="82fd" class="kf kg hi jf b jg jh jk jl jo kh js ki jw kj ka kk kl km kn bi translated">编译Bob.swift</li></ul><pre class="in io ip iq fd kw ke kx ky aw kz bi"><span id="0eab" class="la lb hi ke b fi lc ld l le lf">swiftc -c Bob.swift People.swift -module-name MyApp</span></pre><p id="047d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">与John.swift的编译过程相同，由于Bob.swift与People.swift有依赖关系，我们需要在命令中声明依赖文件，并将它们分组到一个模块中。</p><ul class=""><li id="31e7" class="kf kg hi jf b jg jh jk jl jo kh js ki jw kj ka kk kl km kn bi translated">编译main.swift</li></ul><pre class="in io ip iq fd kw ke kx ky aw kz bi"><span id="7732" class="la lb hi ke b fi lc ld l le lf">swiftc -c main.swift Bob.swift John.swift People.swift -module-name MyApp</span></pre><p id="5307" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">因为在主类中初始化John和Bob类依赖于People类，对于这个例子，我们需要添加John、Bob和People类作为依赖来运行命令。</p><p id="13cf" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在你得到4个目标文件<code class="du kb kc kd ke b">main.o</code>、<code class="du kb kc kd ke b">John.o</code>、<code class="du kb kc kd ke b">Bob.o</code>和<code class="du kb kc kd ke b">People.o</code>后，我们需要将它们链接成一个可执行文件，因为我们还不能运行或看到程序。</p><p id="acbc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">要链接所有这些二进制文件，你可以使用<code class="du kb kc kd ke b">ld</code>或<code class="du kb kc kd ke b">swiftc</code>命令。</p><p id="6c4b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果你想使用<code class="du kb kc kd ke b">ld</code>命令，它会更复杂，你可以看到上面图片中的链接器进程的例子，它使用<code class="du kb kc kd ke b">ld </code>命令链接所有的二进制文件。在这里，我们需要从架构、工具链路径、swift路径和SDK路径等多个方面进行声明。</p><p id="b7cd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">下面是一个例子，说明如何使用<code class="du kb kc kd ke b">swiftc</code>命令将它们链接起来创建一个可执行的应用程序。</p><pre class="in io ip iq fd kw ke kx ky aw kz bi"><span id="cd9a" class="la lb hi ke b fi lc ld l le lf">swiftc main.o People.o Bob.o John.o -o Executable.app</span></pre><p id="9d5e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最后，<code class="du kb kc kd ke b">ld</code>和<code class="du kb kc kd ke b">swiftc</code>命令会生成与你在-o参数后定义的名称相同的可执行app。那就是<code class="du kb kc kd ke b">Executable.app</code></p><p id="f785" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这就是Xcode中的编译和链接过程，你可以用自己的构建系统来改进Xcode构建系统过程，也可以使用我将在下一个主题中讨论的Bazel构建系统或其他构建系统。</p><p id="261a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj">参考文献:</strong></p><p id="aeb7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae jc" href="https://github.com/apple/swift" rel="noopener ugc nofollow" target="_blank">苹果/Swift:Swift编程语言(github.com)</a></p><p id="c5b4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae jc" rel="noopener" href="/xcblog/a-brief-overview-of-swift-compiler-7af0bd684718">swift编译器简介(medium.com)</a></p></div></div>    
</body>
</html>