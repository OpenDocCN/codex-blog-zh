<html>
<head>
<title>Everything you need to know about Smart Pointers in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于C++中的智能指针，你需要知道的一切</h1>
<blockquote>原文：<a href="https://medium.com/codex/everything-you-need-to-know-about-smart-pointers-in-c-3a92c9dcd532?source=collection_archive---------6-----------------------#2021-09-09">https://medium.com/codex/everything-you-need-to-know-about-smart-pointers-in-c-3a92c9dcd532?source=collection_archive---------6-----------------------#2021-09-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c5fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">C++中的智能指针提供了一种更安全、更简洁的操作指针的方式。它们省去了所有麻烦，例如，由内存泄漏和悬空指针引起的麻烦。</p><p id="b1e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文从理论和实践的角度介绍了智能指针:</p><ul class=""><li id="70a8" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">它介绍了标准库中可用的三个智能指针类，并向您展示了如何使用它们；</li><li id="68e5" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">它展示了如何从头开始实现其中两个类的简单版本，以便您能够理解底层机制。</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/bbadb8fd294833ea8afac7851a8b14a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ambdyq2PhqnJiXMR"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">罗宾·沃拉尔在<a class="ae kh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="45d1" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">总体想法和动机</h1><p id="3ee7" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">当在C++程序中动态分配内存时，我们需要手动释放它，通常使用关键字<code class="du ll lm ln lo b">delete</code>:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="677c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该程序显示:</p><pre class="js jt ju jv fd lr lo ls lt aw lu bi"><span id="feb3" class="lv kj hi lo b fi lw lx l ly lz">Oh hello! I am X!<br/>I'm dying…</span></pre><p id="a6ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一行由指令行20打印，第二行由指令行21打印。</p><p id="ff9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不得不释放动态分配的内存块会导致一些问题。特别是:</p><ul class=""><li id="ccbf" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">我们可能忘记删除指针，导致内存泄漏。</li><li id="9084" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">这可能会使程序变得异常安全更加困难。例如，如果<code class="du ll lm ln lo b">saySomething</code>或<code class="du ll lm ln lo b">MyClass</code>的构造函数抛出异常，那么<code class="du ll lm ln lo b">delete</code>语句行21将不会被执行，并且<code class="du ll lm ln lo b">MyClass</code>的析构函数也不会被调用，导致内存泄漏和潜在的更严重的后果。</li></ul><p id="0092" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<code class="du ll lm ln lo b">myClass</code>没有被动态分配，那么当对象超出范围时，析构函数将被自动调用。智能指针的主要目标之一是将这种行为扩展到指针:<em class="ma">智能指针是指针的包装器，它提供了自动内存管理等功能。</em></p><p id="2493" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">他们使用操作符重载来模仿常规指针操作的语法，比如<code class="du ll lm ln lo b">*</code>和<code class="du ll lm ln lo b">-&gt;</code>。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="2b20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">标准库提供了三个智能指针类:<code class="du ll lm ln lo b">unique_ptr</code>、<code class="du ll lm ln lo b">shared_ptr</code>和<code class="du ll lm ln lo b">weak_ptr</code>。</p><h1 id="023f" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">唯一指针</h1><p id="3f55" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">类<code class="du ll lm ln lo b">unique_ptr</code>是C++中最简单的智能指针。关于他们，你需要知道两件事。</p><ul class=""><li id="f06a" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">一旦它们超出范围，就会被自动删除。我们称这样的指针为“作用域指针”。因此，当我们想在有限的范围内引用动态分配的对象时，它们特别有用。</li><li id="24b7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">你不能复制它们(因此限定词<em class="ma">唯一</em>)。</li></ul><p id="2c2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个点是相连的:如果你有一个作用域指针<code class="du ll lm ln lo b">y</code>的副本<code class="du ll lm ln lo b">x</code>，那么当<code class="du ll lm ln lo b">y</code>超出作用域时，<code class="du ll lm ln lo b">x</code>和<code class="du ll lm ln lo b">y</code>都指向的内存块被释放。<code class="du ll lm ln lo b">y</code>会因此变成悬空指针。</p><h1 id="2804" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">唯一指针不能做的事情</h1><p id="72b9" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">正如我们刚才所说的，有两种操作不能用唯一指针执行:复制和赋值。下面的程序显示了可能导致错误的两个操作:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="451a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您需要移动一个唯一指针并将其传递给另一个函数，您可能需要使用标准库函数<code class="du ll lm ln lo b">move</code>，如下例所示:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="203f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<code class="du ll lm ln lo b">move</code>后，<code class="du ll lm ln lo b">ptr</code>成为空指针:你将所指向的块<code class="du ll lm ln lo b">ptr</code>的所有权从<code class="du ll lm ln lo b">ptr</code>转移到<code class="du ll lm ln lo b">bar</code>。</p><h1 id="0aaa" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">例子</h1><p id="416b" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">让我们回到前面给出的例子。首先，我们需要在文件顶部包含<code class="du ll lm ln lo b">memory</code>头:</p><pre class="js jt ju jv fd lr lo ls lt aw lu bi"><span id="e86b" class="lv kj hi lo b fi lw lx l ly lz">#include &lt;memory&gt;</span></pre><p id="a5f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们将修改<code class="du ll lm ln lo b">main</code>函数，使其看起来像这样:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="95e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用<code class="du ll lm ln lo b">std::make_unique</code>创建一个唯一的指针。它将参数序列传递给<code class="du ll lm ln lo b">MyClass</code>的构造函数。然后，我们可以使用箭头操作符来访问对象的属性和方法，就像我们处理常规指针一样。</p><p id="0e41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码打印了下面两行:</p><pre class="js jt ju jv fd lr lo ls lt aw lu bi"><span id="adee" class="lv kj hi lo b fi lw lx l ly lz">Oh hello! I am X!<br/>I'm dying…</span></pre><p id="1b6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，当我们超出作用域时，析构函数被调用，这意味着存储<code class="du ll lm ln lo b">MyClass</code>实例的内存块确实已经被自动释放。</p><p id="ec41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">智能指针也适用于基本类型:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="d910" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这会产生以下输出:</p><pre class="js jt ju jv fd lr lo ls lt aw lu bi"><span id="4e26" class="lv kj hi lo b fi lw lx l ly lz">0x7fc6d3405b40<br/>1</span></pre><p id="861b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一行表示指针的内存地址。第二行指示它所指向的值。</p><h2 id="1b17" class="lv kj hi bd kk mi mj mk ko ml mm mn ks iq mo mp kw iu mq mr la iy ms mt le mu bi translated">从头开始实现唯一指针</h2><p id="4d7b" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">我们将创建一个名为<code class="du ll lm ln lo b">MiniUniquePointer</code>的泛型类，并依赖于类型<code class="du ll lm ln lo b">T</code>。它将存储类型为<code class="du ll lm ln lo b">T*</code>的指针<code class="du ll lm ln lo b">mPtr</code>和以下方法:</p><ul class=""><li id="6e5c" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">构造函数接受一个类型为<code class="du ll lm ln lo b">T*</code>的参数并将其赋给<code class="du ll lm ln lo b">mPtr</code>，</li><li id="8a8d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">析构函数，删除<code class="du ll lm ln lo b">mPtr</code>，</li><li id="58e7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du ll lm ln lo b">operator*</code>和<code class="du ll lm ln lo b">operator-&gt;</code>对应的是常规指针操作符。<code class="du ll lm ln lo b">operator*</code>返回对<code class="du ll lm ln lo b">mPtr</code>(即<code class="du ll lm ln lo b">*mPtr</code>)后面的值的引用，<code class="du ll lm ln lo b">operator-&gt;</code>返回<code class="du ll lm ln lo b">mPtr</code>本身。</li></ul><p id="08ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是实现过程:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="0003" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了定义我们上面描述的四个方法之外，我们还显式删除了复制构造函数和赋值操作符，以防止用户复制。</p><p id="c25a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们实例化并使用<code class="du ll lm ln lo b">MiniUniquePointer</code>,如下所示:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lp lq l"/></div></figure><h1 id="17ed" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">共享指针</h1><p id="499f" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">C++中存在的第二种智能指针是<em class="ma">共享指针</em>。共享指针可以被复制，并且它们所指向的内存块不会被释放，直到指向它的所有其他共享指针都被析构。当一个共享指针被实例化时，一个额外的内存块被分配。它被称为<em class="ma">控制块</em>，记录已经复印的份数。引用计数器一达到0，共享指针指向的对象就被删除，也就是说，当最后一个剩余副本被销毁或被分配另一个指针时。</p><p id="ad24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个额外的功能是以较大的开销为代价的，所以当一个唯一的指针足够用时，不应该使用共享指针。</p><h1 id="a19b" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">例子</h1><p id="b6fa" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">正如我们对唯一指针所做的那样，我们通过将类的构造函数的参数传递给函数<code class="du ll lm ln lo b">std::make_shared</code>来创建共享指针:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="91a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像使用唯一指针一样，我们可以使用<code class="du ll lm ln lo b">-&gt;</code>访问<code class="du ll lm ln lo b">MyClass</code>的相应实例的成员，当<code class="du ll lm ln lo b">main</code>函数终止时，它占用的内存块被释放。然而，我们现在可以制作<code class="du ll lm ln lo b">sharedPtr</code>的新副本，并在多个范围内共享它们:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="ab80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们运行上面的程序，我们将得到以下输出:</p><pre class="js jt ju jv fd lr lo ls lt aw lu bi"><span id="4d0f" class="lv kj hi lo b fi lw lx l ly lz">From main Oh hello! I am X!<br/>From hello Oh hello! I am X!<br/>Back in main<br/>I'm dying…</span></pre><p id="3eda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所见——正如我们所料——一旦主函数终止，那么<code class="du ll lm ln lo b">sharedPtr</code>和<code class="du ll lm ln lo b">localPtr</code>所指向的<code class="du ll lm ln lo b">MyClass</code>的实例就会被删除。<code class="du ll lm ln lo b">localPtr</code>之前出作用域了，但是引用计数器记得<code class="du ll lm ln lo b">sharedPtr</code>可能还需要用。</p><h1 id="9e56" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">履行</h1><p id="8f3a" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">我们将从创建一个负责统计引用的类<code class="du ll lm ln lo b">ControlBlock</code>开始。它将有一个类型为<code class="du ll lm ln lo b">int</code>的属性<code class="du ll lm ln lo b">mReferenceCount</code>和两个分别递增和递减<code class="du ll lm ln lo b">mReferenceCount</code>的方法<code class="du ll lm ln lo b">add</code>和<code class="du ll lm ln lo b">remove</code>。实现非常简单:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="e407" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要注意的一点是:我们对添加一个新引用后的引用数量不感兴趣，但是我们需要检查在删除一个引用后它是否达到了零。这就是为什么<code class="du ll lm ln lo b">add</code>和<code class="du ll lm ln lo b">remove</code>的返回类型不同。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="7332" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">核心<code class="du ll lm ln lo b">MiniSharedPointer</code>类的结构与<code class="du ll lm ln lo b">MiniUniquePointer</code>非常相似。然而，我们需要存储一个指向控制块(<code class="du ll lm ln lo b">mControlBlock</code>)的指针，我们实现这些方法的方式有很多不同:</p><ul class=""><li id="34e2" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">构造函数除了存储指针之外还实例化新的控制块，</li><li id="4a06" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">析构函数告诉控制块一个引用已经被移除，并且只有当引用计数器达到零时才删除指针(并释放控制块),</li><li id="d74e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">复制构造器递增引用计数器并将<code class="du ll lm ln lo b">mControlBlock</code>和<code class="du ll lm ln lo b">mPtr</code>的值从现有实例复制到正在构造的实例，</li><li id="4e3a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">赋值操作符递减左边的引用计数器，如果它达到零，就执行适当的清除，然后做同样的事情，就好像我们调用复制构造函数将左边复制到右边一样。</li></ul><p id="c121" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们按如下方式实现它:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lp lq l"/></div></figure><h1 id="b78b" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">处理悬空指针和循环依赖</h1><p id="5c91" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">我们讨论的最后一种智能指针是<em class="ma">弱指针</em>。弱指针类似于共享指针，只是它们没有控制块和引用计数器。这意味着您可以共享它们，但是它们指向的对象可能会在它们超出范围或被分配另一个指针之前被销毁。</p><p id="c4a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您需要知道两种操作弱指针的方法:</p><ul class=""><li id="29b4" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du ll lm ln lo b">expired</code>:它不接受参数，返回<code class="du ll lm ln lo b">true</code>它所指向的内存块已经被释放，<code class="du ll lm ln lo b">false</code>否则；</li><li id="19f2" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><code class="du ll lm ln lo b">lock</code>:不接受参数，返回<code class="du ll lm ln lo b">expired() ? shared_pointer&lt;T&gt;() : shared_pointer(*this)</code>。这是一种“安全的取消引用”方法，因为它能够在检查内存块是否已被释放后获取内存块的值。</li></ul><p id="6200" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的例子展示了它们的行为:</p><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="0c10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是输出:</p><pre class="js jt ju jv fd lr lo ls lt aw lu bi"><span id="62e6" class="lv kj hi lo b fi lw lx l ly lz">I'm dying…<br/>weakPtr points to a deallocated block</span></pre><p id="6f11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ll lm ln lo b">sharedPtr</code>超出范围(第8行)。它所指向的内存块随后被释放，即使<code class="du ll lm ln lo b">weakPtr</code>仍然持有对它的引用。因此，<code class="du ll lm ln lo b">weakPtr.lock()</code>返回一个空的共享指针，并且不满足第11行的条件。</p><p id="253e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">弱指针有两个主要优点:</p><ul class=""><li id="8272" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">它们防止由悬空指针引起的错误:通过提供一种方法来检查它们所指向的块是否已经被释放，它们防止用户取消引用和操作悬空指针。</li><li id="b8a9" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">它们解决了循环依赖问题。例如，如果您运行以下代码:</li></ul><figure class="js jt ju jv fd jw"><div class="bz dy l di"><div class="lp lq l"/></div></figure><p id="3a40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么<code class="du ll lm ln lo b">a</code>和<code class="du ll lm ln lo b">b</code>都不会被析构:只要<code class="du ll lm ln lo b">a</code>还活着，就不能析构<code class="du ll lm ln lo b">b</code>，因为<code class="du ll lm ln lo b">a</code>包含对<code class="du ll lm ln lo b">b</code>的引用，同样，<code class="du ll lm ln lo b">a</code>也不能被析构，因为<code class="du ll lm ln lo b">b</code>包含对它的引用。这会导致内存泄漏。</p><p id="fc68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了避免这个问题，我们可以简单地将<code class="du ll lm ln lo b">B</code>和<code class="du ll lm ln lo b">A</code>的属性<code class="du ll lm ln lo b">a</code>和<code class="du ll lm ln lo b">b</code>的类型从<code class="du ll lm ln lo b">shared_ptr</code>改为<code class="du ll lm ln lo b">weak_ptr</code>。</p><h1 id="f5d0" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">参考资料:</h1><p id="1294" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated"><a class="ae kh" href="https://www.codeproject.com/Articles/15351/Implementing-a-simple-smart-pointer-in-c" rel="noopener ugc nofollow" target="_blank">在C++中实现简单的智能指针</a></p><p id="979c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kh" href="https://www.youtube.com/watch?v=UOB7-B2MfwA&amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;index=44" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=UOB7-B2MfwA&amp;list = pllratfbnz 98 dudn 48 yfguldqgd 0s 4 FFB&amp;index = 44</a></p><p id="2b44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【http://ootips.org/yonat/4dev/smart-pointers.html】</p><p id="ae91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kh" href="https://iamsorush.com/posts/weak-pointer-cpp/" rel="noopener ugc nofollow" target="_blank">https://iamsorush.com/posts/weak-pointer-cpp/</a></p><p id="79e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kh" href="https://www.internalpointers.com/post/move-smart-pointers-and-out-functions-modern-c" rel="noopener ugc nofollow" target="_blank">在现代C++中将智能指针移入和移出函数</a></p></div></div>    
</body>
</html>