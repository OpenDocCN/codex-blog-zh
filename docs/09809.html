<html>
<head>
<title>Mix up your Kotlin functions with Function Composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Kotlin函数与函数组合混合使用</h1>
<blockquote>原文：<a href="https://medium.com/codex/mix-up-your-kotlin-functions-with-function-composition-c0f635d40c87?source=collection_archive---------0-----------------------#2022-11-11">https://medium.com/codex/mix-up-your-kotlin-functions-with-function-composition-c0f635d40c87?source=collection_archive---------0-----------------------#2022-11-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="68d1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Kotlin和Haskell之间的函数式编程交换</h2></div><p id="52c2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近，我学习了一种不同的函数式编程语言，叫做Haskell。让我印象深刻的是<code class="du jt ju jv jw b">.</code>操作符，它是一个二元操作符，接受两个函数并输出另一个函数。这个<code class="du jt ju jv jw b">.</code>操作符在像Haskell这样的语言中非常有用，我想知道我是否可以在Kotlin中复制它。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es jx"><img src="../Images/b1948704d256af4dfb7f055c968ef855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XZb7UcPWYLQUdR2o"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx translated">亚历克斯·康德拉蒂耶夫在<a class="ae kn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="aa91" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">(。Haskell中的)运算符</h1><p id="6677" class="pw-post-body-paragraph ix iy hi iz b ja lg ij jc jd lh im jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">在Haskell中，<code class="du jt ju jv jw b">.</code>用于组合两个函数。这是函数定义:</p><pre class="jy jz ka kb fd ll jw lm bn ln lo bi"><span id="8a44" class="lp kp hi jw b be lq lr l ls lt">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c<br/>(.) f g x = f (g x) </span></pre><p id="56e3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你不认识哈斯克尔，请不要担心。这里我定义了一个函数，它接收一个泛型类型的函数<code class="du jt ju jv jw b">b</code>并输出<code class="du jt ju jv jw b">c</code>，另一个函数接收<code class="du jt ju jv jw b">a</code>并返回<code class="du jt ju jv jw b">b</code>。给出这两个函数，它返回另一个函数，该函数接受<code class="du jt ju jv jw b">a</code>并返回<code class="du jt ju jv jw b">c</code>。</p><h2 id="2541" class="lu kp hi bd kq lv lw lx ku ly lz ma ky jg mb mc la jk md me lc jo mf mg le mh bi translated">Haskell中的用法</h2><p id="cc53" class="pw-post-body-paragraph ix iy hi iz b ja lg ij jc jd lh im jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我们可以把map函数看作是这个主题的一个主要例子。</p><pre class="jy jz ka kb fd ll jw lm bn ln lo bi"><span id="8175" class="lp kp hi jw b be lq lr l ls lt">composition :: [Int] -&gt; [Double]<br/>composition = map ((10.5 -) . (* 100.0))<br/><br/>main = do<br/>  let list = [1..10]<br/>  print (composition list)</span></pre><p id="db4e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与任何其他语言一样，map函数接受列表和转换列表中每个元素的函数。在这里，我们先将<strong class="iz hj">的</strong>和<em class="mi">乘以100 </em>和<strong class="iz hj">然后再将</strong>和<em class="mi">的数字从10.5 </em>中减去。</p><h1 id="9cfe" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">科特林函数合成</h1><p id="c0c5" class="pw-post-body-paragraph ix iy hi iz b ja lg ij jc jd lh im jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我在Kotlin中创建了一个中缀扩展函数，如下所示:</p><pre class="jy jz ka kb fd ll jw lm bn ln lo bi"><span id="6d65" class="lp kp hi jw b be lq lr l ls lt">infix fun &lt;A, B, C&gt; ((A) -&gt; B).then(other: (B) -&gt; C): (A) -&gt; C {<br/>    return { other(this(it)) }<br/>}</span></pre><p id="0e24" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们来分解一下这个函数要做什么。</p><ol class=""><li id="3959" class="mj mk hi iz b ja jb jd je jg ml jk mm jo mn js mo mp mq mr bi translated">我们用三种通用类型定义函数<code class="du jt ju jv jw b">then</code>:<code class="du jt ju jv jw b">A</code>、<code class="du jt ju jv jw b">B</code>和<code class="du jt ju jv jw b">C</code>。</li><li id="58fb" class="mj mk hi iz b ja ms jd mt jg mu jk mv jo mw js mo mp mq mr bi translated">它是lambda函数的扩展:<code class="du jt ju jv jw b">(A) -&gt; B</code>。</li><li id="492a" class="mj mk hi iz b ja ms jd mt jg mu jk mv jo mw js mo mp mq mr bi translated">它接受一个类型为<code class="du jt ju jv jw b">(B) -&gt; C</code>的参数。</li><li id="7fc5" class="mj mk hi iz b ja ms jd mt jg mu jk mv jo mw js mo mp mq mr bi translated">它返回一个类型为<code class="du jt ju jv jw b">(A) -&gt; C</code>的lambda函数。</li><li id="677a" class="mj mk hi iz b ja ms jd mt jg mu jk mv jo mw js mo mp mq mr bi translated">给函数加上前缀<code class="du jt ju jv jw b">infix</code>。</li></ol><h2 id="a6a7" class="lu kp hi bd kq lv lw lx ku ly lz ma ky jg mb mc la jk md me lc jo mf mg le mh bi translated">科特林语的用法</h2><p id="8bcb" class="pw-post-body-paragraph ix iy hi iz b ja lg ij jc jd lh im jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">用法与Haskell不太相似，因为它不是本地的；然而，这是对代码的一个很好的补充。</p><pre class="jy jz ka kb fd ll jw lm bn ln lo bi"><span id="f282" class="lp kp hi jw b be lq lr l ls lt">fun main() {<br/>  val f1: (Int) -&gt; Double = { it * 100.0 }<br/>  val f2: (Double) -&gt; Double = { 10.5 - it }<br/><br/>  val range = 1..10<br/>  println(range.map(f1 then f2))<br/>}</span></pre><h1 id="1e2e" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">结论</h1><p id="89ab" class="pw-post-body-paragraph ix iy hi iz b ja lg ij jc jd lh im jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">要不要把OOP概念从Java翻译过来？没问题。你希望融入Haskell的函数式语言概念吗？太棒了。Kotlin作为一种语言的灵活性令人惊叹，这使它成为一种优秀的语言(在我看来)，也是我个人最喜欢的语言。</p></div><div class="ab cl mx my gp mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hb hc hd he hf"><p id="9850" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你喜欢读我的文章，并学到了一些东西。谢谢大家！✌️</p><pre class="jy jz ka kb fd ll jw lm bn ln lo bi"><span id="f004" class="lp kp hi jw b be lq lr l ne lt"><strong class="jw hj">Want to connect?</strong><br/><br/>My <a class="ae kn" href="https://github.com/cybercoder-naj" rel="noopener ugc nofollow" target="_blank">GitHub</a> profile.<br/>My <a class="ae kn" href="https://cybercoder-naj.github.io" rel="noopener ugc nofollow" target="_blank">Portfolio</a> website.</span></pre></div></div>    
</body>
</html>