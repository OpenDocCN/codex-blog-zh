<html>
<head>
<title>Introduction to dependency injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入简介</h1>
<blockquote>原文：<a href="https://medium.com/codex/introduction-to-dependency-injection-ca4099cf225f?source=collection_archive---------10-----------------------#2021-09-06">https://medium.com/codex/introduction-to-dependency-injection-ca4099cf225f?source=collection_archive---------10-----------------------#2021-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e6a1359341910bd237bb0777797c9f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VtkyCKQRIzvHAP_d"/></div></div></figure><p id="2c01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你好。</p><p id="3d0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一种解释什么是依赖注入并探讨以下主题的快速简单的方法:</p><ol class=""><li id="289a" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">什么是依赖注入？</li><li id="bffd" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">类中的依赖注入</li><li id="bfa1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">函数中的依赖注入</li><li id="d987" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">优势</li><li id="59c6" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">不足之处</li><li id="f1e8" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">依赖注入容器(简要提及)</li></ol><h1 id="9f03" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">什么是依赖注入？</strong></h1><p id="9819" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">名字可能看起来很复杂，但是如果您构建了比“Hello World”更复杂的应用程序，那么您可能已经在使用依赖注入了。</p><p id="d7fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">依赖注入是软件工程中的一种技术，其中一个对象接收它所依赖的已经初始化的其他对象。这些被称为依赖。</p><h1 id="0cbb" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">类中的依赖注入</h1><p id="50c7" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">通常你的对象会在构造函数中自己初始化它的所有属性，但是这种方法迫使你的对象知道如何实现其他对象，有时候你不想处理这些。处理日志就是一个很好的例子。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/903a322a2031c643032f58c7d4a1f2fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*05QaRb5e53-5oUZJNtQQow.png"/></div></div></figure><p id="9021" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码中，仅仅通过这个简单的代码，您就已经使用了依赖项，但是在将来使用这种类型的实现时，您可能会遇到一些问题:</p><ol class=""><li id="1ef1" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">您正在对象内部初始化一个新的Logger实例，并且Person的每个后续实例也将初始化另一个Logger对象。这可能会导致一些开销。</li><li id="e99f" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">您的Person对象负责初始化它的Logger对象，因此如果将来该对象发生更改，您需要记住并返回到Person类进行必要的更改。</li></ol><p id="21fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以这样做:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/a2a3707eca0ec44820cb20a62eb8632d.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*7EIniqRAKK6SbvSRsTQxxA.png"/></div></figure><p id="edcd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您现在看到的，构造函数需要一个logger对象，所以您仍然依赖logger类，但是您不再需要处理logger对象的初始化和配置，并且可以专注于记录重要的信息。</p><p id="ac15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这对于一次性应用程序来说已经足够好了，但是如果你认为你正在开发的应用程序将会是下一个百万美元的应用程序，你可以更进一步，再抽象一点。</p><p id="c0f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以传递接口ILogger，而不是传递Logger类的具体实现。对于您的Person对象，一切都将像以前一样工作，但是现在您可以根据您开发的内容灵活地更改logger实现和策略。</p><p id="0a06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您只是测试您的应用程序，您可以使用只记录到控制台的ConsoleLogger，如果您正在开发web应用程序，您可以使用记录到文件的FileLogger，甚至是两者都做的HybridLogger。</p><p id="ba44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你能想到的任何类型的日志都可以被实现，你的Person对象并不关心它是如何实现的，他所关心的是你有一个名为log的方法，通过这个方法，对象知道它的消息将被记录。</p><p id="b3c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从非常简单的ILogger接口开始:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/8ca071901e576445ea4f52268790e51f.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*wIiGh13Eopaps9TfyAmyWQ.png"/></div></figure><p id="5378" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们的ConsoleLogger实现:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/65582fdfb7868ea59a15a0d42bf3e65b.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*ZZGZHzPuYlibnICQqxWhpA.png"/></div></figure><p id="e197" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们的文件记录器实现:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/f5f60f98dfcb52b943e44a5546ea3396.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*cjjT3gFqorZpYajJsls_5w.png"/></div></figure><p id="40aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们回到Person类，让对象依赖于ILogger:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/9b6d2c43e75e765676076a79d1dd3da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*xRMkuYLPcrQ1jE9_9Bpw6g.png"/></div></figure><p id="ee2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，我们有一个依赖注入的例子，有一些松散耦合的代码。</p><h1 id="7b7d" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">函数中的依赖注入</h1><p id="3875" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">您也可以在您的函数中使用这种技术，原理是相同的，您不希望只是为了记录一些信息而处理logger对象的初始化，所以您应该这样做:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/db32f01a31465885eed822f3b5f371f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*HTKpktI2BWkez-tTVSo30Q.png"/></div></figure><p id="e522" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也许在某些用例中，你不想将日志程序注入到对象中，而只需要在一个函数中使用它，这是一个很好的方法。</p><h1 id="723b" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">DI的优势</h1><p id="b842" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">依赖注入的所有优点都是代码解耦的结果，使其更加灵活:</p><ul class=""><li id="e295" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lq ju jv jw bi translated">简化单元测试，因为具体对象可以用存根或模拟来替换。</li><li id="7ebf" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lq ju jv jw bi translated">减少了样板代码，因为依赖项只在一个地方创建。</li><li id="0ffb" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lq ju jv jw bi translated">允许并发开发，不同的开发人员可以在相互使用的类上工作，因为他们需要知道类(接口)之间的“绑定契约”。</li></ul><h1 id="9581" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">DI的缺点</h1><p id="4628" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">解耦代码就像一把双刃剑，既有优势，也有劣势:</p><ul class=""><li id="6f54" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lq ju jv jw bi translated">代码可能变得难以跟踪。代码的复杂性从类本身转移到了类之间的链接。</li><li id="88c2" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lq ju jv jw bi translated">需要更多的开发工作。即使你曾经有过一个(1)实现，你也会使用很多接口。</li><li id="900a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lq ju jv jw bi translated">可能会鼓励对框架的依赖，尤其是当你使用DI容器的时候。</li></ul><h1 id="c35e" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">依赖注入容器</h1><p id="0018" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">容器本身是一个类，它知道如何初始化和配置对象，也知道哪些对象需要注入依赖关系</p><p id="75c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在一个框架中，阿迪容器由框架本身管理，你只需要在接口和它们的具体接口之间注册一个链接。例如，在上面的例子中，您会告诉容器，对于任何需要ILogger的对象，容器都应该返回一个ConsoleLogger。</p><p id="c127" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在大多数情况下，您不需要这个容器，但是知道它的存在是很好的，如果需要的话(一个有许多不同对象要管理的大项目)，您应该考虑它。</p><p id="3157" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望你喜欢读我的文章。请让我知道我说的是不是错了，或者是不是有什么应该提到的。</p><p id="0b53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下次见。</p></div></div>    
</body>
</html>