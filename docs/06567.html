<html>
<head>
<title>Angular explained: What is View Encapsulation?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular解释:什么是视图封装？</h1>
<blockquote>原文：<a href="https://medium.com/codex/angular-explained-what-is-view-encapsulation-a9ad905456b?source=collection_archive---------1-----------------------#2022-05-02">https://medium.com/codex/angular-explained-what-is-view-encapsulation-a9ad905456b?source=collection_archive---------1-----------------------#2022-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2e4fd071fae67c87d385ca5f62c83580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BQhz2mBsNhZs1Yfc.jpg"/></div></div></figure><p id="5595" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将介绍前端开发中的一个基本概念— DOM(文档对象模型)。我们将讨论现代框架中使用的两种基本类型:影子DOM和虚拟DOM。解释它们的区别，并说明哪一个用于Angular。</p><h1 id="3cba" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是DOM？</h1><p id="0a1b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">文档对象模型(简称DOM)定义了HTML或XML文档的结构以及访问和操作它的方式。它的目的是提供一个标准的编程接口，可以用于不同的语言和环境。我们可以通过在HTML中添加、更新和删除元素来修改网页的结构。</p><p id="418f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个浏览器都有一个全局对象，名为<em class="kr"> window </em>。它的属性之一是文档，文档也有不同的属性和方法。下面是DOM外观的图形表示:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/7b4bc39c26ecc9ce3f83cff27e24978b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DzAKVs8xOZGLG-74sKhh2Q.png"/></div></div></figure><p id="8f7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们所看到的，它包含一组以树形结构呈现的节点。每个节点代表一个带有属性和特性HTML元素，允许修改。</p><h1 id="0c60" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是虚拟DOM？</h1><p id="0d8a" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在虚拟DOM中，真实DOM的一个副本被保存在内存中，当DOM发生变化时，它会被比较以找出差异。那么应用程序将只更新那些有变化的部分。通过避免重新渲染所有元素，性能也将得到提高。参见虚拟DOM的图解说明。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/5ecb6c5117c2a85aad4f7af9a43129e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DV2ET5_PJlNhvts9VmdREg.png"/></div></div></figure><p id="ff52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，对虚拟DOM进行更改，然后将其与真实DOM进行比较。这个过程叫做<em class="kr">差分。</em>当发现任何差异时，浏览器更新原始DOM中的那些元素。React和Vue框架使用了这个概念。</p><h1 id="39aa" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是暗影DOM？</h1><p id="3c37" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">影子DOM允许一个组件拥有自己的DOM树，它与元素相连，但与子元素分开。它不能从主文档中访问，这就带来了巨大的优势。组件可以有自己的本地样式规则。</p><p id="1dc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它隔离了DOM，所以组件的DOM不会出现在全局DOM中。当我们想到一个应用程序时，我们想象它是由块而不是一个胡德对象构建的，这意味着影子DOM也将提高性能。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/8abcced7a772910e5b78dc5a00e95e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aCwaTv7UKxhD6lNTp93HOw.png"/></div></div></figure><p id="1e5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">影子DOM和虚拟DOM的概念有点不同，但是它们都有助于提高性能。虚拟DOM创建整个DOM树的副本，而影子DOM创建小部分，每个组件都有独立的范围。</p><h1 id="b08c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">角度中的阴影DOM</h1><p id="32e8" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在Angular中，组件是一个拥有自己的模板和样式的类。当我们创建一个组件时，Angular将它的模板放入<strong class="is hj"> shadowRoot，</strong>中，这基本上是那个组件的影子DOM。事实上，Angular不使用原生阴影DOM，它使用模拟。因为大多数浏览器还不支持影子DOM。</p><h1 id="e8c6" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">角度视图封装类型</h1><p id="1b36" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">有三种内置的视图封装类型，这允许我们使用影子DOM。</p><ul class=""><li id="626d" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated"><strong class="is hj">查看封装。无</strong> —无阴影DOM和无样式封装</li><li id="6460" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated"><strong class="is hj">查看封装。仿真的</strong> —没有影子DOM，但是提供了样式封装的仿真</li><li id="9248" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated"><strong class="is hj">查看封装。ShadowDOM </strong> —使用原生的ShadowDOM和它所拥有的一切</li></ul><h2 id="9ebe" class="ln jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">查看封装。没有人</h2><p id="d0fb" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在这个例子中Angular根本没有使用阴影DOM。所有样式都应用于整个文档，这意味着一个组件可以覆盖另一个组件的样式。</p><pre class="kt ku kv kw fd mb mc md me aw mf bi"><span id="0175" class="ln jp hi mc b fi mg mh l mi mj">import {ViewEncapsulation} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'card',<br/>  templateUrl: 'card.component.html',<br/>  styles: [`<br/>    .card-container {<br/>      width: 200px;<br/>      height: 400px;<br/>      background: red;<br/>    }<br/>  `],<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>class CardComponent {<br/>  @Input() title: string;<br/>  @Input() content: string;<br/>}</span></pre><p id="bdbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们也创建一个模板:</p><pre class="kt ku kv kw fd mb mc md me aw mf bi"><span id="2d97" class="ln jp hi mc b fi mg mh l mi mj">&lt;div class="card-container"&gt;<br/>  &lt;h3&gt;{{title}}&lt;/h3&gt;<br/>  &lt;div class="content"&gt;<br/>    &lt;p&gt;{{content}}&lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="af73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Angular将创建一个DOM树，如下所示:</p><pre class="kt ku kv kw fd mb mc md me aw mf bi"><span id="e36d" class="ln jp hi mc b fi mg mh l mi mj">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;style&gt;<br/>      .container {<br/>        width: 200px;<br/>        height: 400px;<br/>        background: red;<br/>      }<br/>    &lt;/style&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;card title="Card example" description="Some details"&gt;<br/>      &lt;div class="card-container"&gt;<br/>        &lt;h3&gt;Card example&lt;/h3&gt;<br/>        &lt;div class="content"&gt;<br/>          &lt;p&gt;Some details&lt;/p&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/card&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><h2 id="8f9b" class="ln jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">查看封装。模仿</h2><p id="3a6b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">它模拟样式封装，即使没有影子DOM。它将一个特定的属性添加到组件的主机元素中，并将相同的属性应用到通过样式提供的所有CSS选择器中。</p><pre class="kt ku kv kw fd mb mc md me aw mf bi"><span id="c339" class="ln jp hi mc b fi mg mh l mi mj">import {ViewEncapsulation} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'card',<br/>  templateUrl: 'card.component.html',<br/>  styles: [`<br/>    .card-container {<br/>      width: 200px;<br/>      height: 400px;<br/>      background: red;<br/>    }<br/>  `],<br/>  encapsulation: ViewEncapsulation.Emulated<br/>})<br/>class CardComponent {<br/>  @Input() title: string;<br/>  @Input() content: string;<br/>}</span></pre><p id="081a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是文档头的样子:</p><pre class="kt ku kv kw fd mb mc md me aw mf bi"><span id="11e7" class="ln jp hi mc b fi mg mh l mi mj">&lt;head&gt;<br/>  &lt;style&gt;<br/>    .card[_ngcontent-1] {<br/>      width: 200px;<br/>      height: 400px;<br/>      background: green;<br/>    }<br/>  &lt;/style&gt;<br/>&lt;/head&gt;</span></pre><p id="1288" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以及组件的模板:</p><pre class="kt ku kv kw fd mb mc md me aw mf bi"><span id="5411" class="ln jp hi mc b fi mg mh l mi mj">&lt;div class="card-container" _ngcontent-0 _nghost-1&gt;<br/>  &lt;h3 _ngcontent-1&gt;{{title}}&lt;/h3&gt;<br/>  &lt;div class="content" _ngcontent-1&gt;<br/>    &lt;p _ngcontent-1&gt;{{content}}&lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><h2 id="c859" class="ln jp hi bd jq lo lp lq ju lr ls lt jy jb lu lv kc jf lw lx kg jj ly lz kk ma bi translated">查看封装。阴影世界</h2><p id="93c0" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">它使用原生的ShadowDOM制作Angular，并启用它的所有功能。</p><pre class="kt ku kv kw fd mb mc md me aw mf bi"><span id="924c" class="ln jp hi mc b fi mg mh l mi mj">import {ViewEncapsulation} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'card',<br/>  templateUrl: 'card.component.html',<br/>  styles: [`<br/>    .card-container {<br/>      width: 200px;<br/>      height: 400px;<br/>      background: red;<br/>    }<br/>  `],<br/>  encapsulation: ViewEncapsulation.ShadowDOM<br/>})<br/>class CardComponent {<br/>  @Input() title: string;<br/>  @Input() content: string;<br/>}</span></pre><p id="04b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们的代码在浏览器中运行时，我们可以看到文档头中没有样式。相反，它被添加到组件的影子根中。</p><pre class="kt ku kv kw fd mb mc md me aw mf bi"><span id="629f" class="ln jp hi mc b fi mg mh l mi mj">&lt;card title="Card example" description="Some details"&gt;<br/>  #shadow-root<br/>  | &lt;style&gt;<br/>  |   .card {<br/>  |     background: red;<br/>  |     width: 200px;<br/>  |     height: 400px;<br/>  |   }<br/>  | &lt;/style&gt;<br/>  | &lt;div class="card"&gt;<br/>  |   &lt;h3&gt;<br/>  |     Card example<br/>  |   &lt;/h3&gt;<br/>  |   &lt;div class="content"&gt;<br/>  |     &lt;p&gt;{{content}}&lt;/p&gt;<br/>  |   &lt;/div&gt;<br/>  | &lt;/div&gt;      <br/>&lt;/card&gt;</span></pre><h1 id="5576" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="e22a" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">现在我们了解了什么是DOM以及它的主要概念类型:虚拟DOM和影子DOM。我们看到，当我们想要提高性能时，它们都非常有用。使用角度视图封装，我们可以决定在我们的情况下哪种方法是正确的选择。</p></div></div>    
</body>
</html>