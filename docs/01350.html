<html>
<head>
<title>Journey to MIT 6.824 - Lab 1 MapReduce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">麻省理工学院之旅6.824 -实验1 MapReduce</h1>
<blockquote>原文：<a href="https://medium.com/codex/journey-to-mit-6-824-lab-1-mapreduce-ebe58800ef9e?source=collection_archive---------2-----------------------#2021-04-21">https://medium.com/codex/journey-to-mit-6-824-lab-1-mapreduce-ebe58800ef9e?source=collection_archive---------2-----------------------#2021-04-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/676f981b9e89aa7f666fcc377155c5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*obv4LAUn87Dc2usy"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">尼克·莫瑞森在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="a9b0" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">动机</h1><p id="7a93" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">今年早些时候，我随意浏览我们公司的讨论组，碰巧看到了麻省理工学院的在线课程《麻省理工学院6.824分布式系统》。在我快速浏览了课程大纲后，我立刻被它吸引住了，并决定尽可能多地学习这门课程。</p><p id="a10e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://pdos.csail.mit.edu/6.824/schedule.html" rel="noopener ugc nofollow" target="_blank">https://pdos.csail.mit.edu/6.824/schedule.html</a></p><p id="cf75" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">当时，我在日常工作中很难处理一个复杂且高度分布式的系统，我希望我能从这门课程中获得一些灵感，并对分布式系统有系统的了解，而不是一些零散的在线文章。</p><p id="8fa3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">另一个原因是本课程中的所有实验室都使用Golang，这是一种在云原生应用程序和开源项目(如k8s和Dapr)中高度采用的语言。我认为这是我学习围棋的好机会。</p><p id="d8bf" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在我终于完成了lab1 MapReduce并通过了所有测试。我觉得分享一下我是如何做到的，我所犯的错误会很有帮助，我相信这比最终的代码更有价值。</p><h1 id="bcb4" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">MapReduce概述</h1><p id="8839" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">现在，让我们进入主题:MapReduce的实验1。在我们深入研究它之前，至少你应该阅读这篇关于MapReduce的<a class="ae iu" href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>来获得一个基本的知识。</p><p id="2ec0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">总结一下MapReduce的核心思想，通常它接受一个大的键值对集合作为输入，并生成另一个通常较小的键值对集合。</p><ul class=""><li id="0ba7" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">映射函数:每个输入键值对(k1，v1)都由一个映射函数处理。map函数将输出(k2，v2)的列表，其中k2是中间密钥。</li><li id="5520" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">Reduce函数:将每个(k2，v2的列表)传递给reduce函数，reduce函数通常将v2的列表合并到一个更小的值列表(v2)中作为最终输出。</li></ul><h1 id="71ed" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">实施MapReduce</h1><p id="8251" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">老实说，当我第一次克隆lab1框架时，我浏览了很长时间，感到困惑，我现在应该做什么。在反复阅读提示和论文后，我终于开始理解事物是如何连接起来的。</p><p id="679f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">需要添加我自己的代码的所有三个文件是:</p><ul class=""><li id="b7fd" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated"><code class="du lk ll lm ln b">src/mr/coordinator.go</code>添加维护状态的逻辑</li><li id="f36c" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated"><code class="du lk ll lm ln b">src/mr/worker.go</code>添加执行每个映射/缩减作业的逻辑。</li><li id="07a9" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated"><code class="du lk ll lm ln b">src/mr/rpc.go</code>添加RPC调用参数并回复契约。</li></ul><p id="946e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这个实验室的总体思路很简单。在这个实验中，框架将启动一个协调器和多个工作器。当一个新的worker生成时，它通过RPC调用向协调器请求一个作业-&gt;执行接收到的作业-&gt;产生输出-&gt;报告作业结果。重复这些步骤，直到整个MapReduce完成。</p><p id="cad3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这里要实现四个主要部分:</p><ul class=""><li id="6da6" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">设计数据结构以保存MapReduce状态</li><li id="f4e8" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">设计协调员和工人之间的沟通</li><li id="7947" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">处理map/reduce工作，并产生适当的输出</li><li id="a8dc" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">协调者</li></ul><h2 id="6c07" class="lo iw hi bd ix lp lq lr jb ls lt lu jf ke lv lw jj ki lx ly jn km lz ma jr mb bi translated">数据结构</h2><p id="df9b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">首先，让我们考虑一下协调者需要维护什么样的状态，并选择合适的数据结构来保存它们:</p><ul class=""><li id="01ad" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">减速器的总数，记为<code class="du lk ll lm ln b">nReducer int</code></li><li id="4726" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">地图作业的状态。一个<code class="du lk ll lm ln b">mapStatus map[string]int</code>来跟踪每个输入文件名及其状态。<code class="du lk ll lm ln b">mapStatus['pg-grimm.txt']=0</code>表示输入文件<code class="du lk ll lm ln b">pg-grimm.txt</code>还没有开始运行。</li><li id="638f" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">裁减职位的状态。一个<code class="du lk ll lm ln b">reduceStatus map[int]int</code>来跟踪每个减速器及其状态。<code class="du lk ll lm ln b">reduceStatus[0]=1</code>表示第一台减速机正在运行。</li><li id="ea10" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">每个地图作业的自增量id。每次将地图作业分配给工作人员时，此id都会增加1。</li><li id="7850" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">中间文件位置。A <code class="du lk ll lm ln b">intermediateFiles[int][]string</code>记录每个减速器的中间文件。</li></ul><p id="4895" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这就是协调员要保持的所有状态。由于works同时与协调器对话，我们也需要一个互斥锁。<code class="du lk ll lm ln b">Coordinator</code>结构如下所示:</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="3f11" class="lo iw hi ln b fi mk ml l mm mn">type Coordinator struct { <br/>    mapStatus         map[string]int <br/>    mapTaskId         int<br/>    reduceStatus      map[int]int<br/>    nReducer          int <br/>    intermediateFiles map[int][]string <br/>    mu                sync.Mutex<br/>}</span></pre><h2 id="f5d6" class="lo iw hi bd ix lp lq lr jb ls lt lu jf ke lv lw jj ki lx ly jn km lz ma jr mb bi translated">位置遥控(remote position control)</h2><p id="aff8" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">一旦我们定义了数据结构，让我们考虑一下协调者和工作者之间需要什么样的通信消息。</p><p id="71b4" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">请求工作:</strong></p><p id="34fb" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">当一个worker被派生时，它通过RPC向协调器请求一个作业。协调器对<code class="du lk ll lm ln b">mapStatus</code>进行迭代，以找到具有以下有效载荷的第一个未分配的地图作业:</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="8819" class="lo iw hi ln b fi mk ml l mm mn">type MapJob struct { <br/>     InputFile    string <br/>     MapJobNumber int <br/>     ReducerCount int<br/>}</span></pre><ul class=""><li id="56c9" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated"><code class="du lk ll lm ln b">InputFile</code>是要打开的输入文件。</li><li id="2641" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated"><code class="du lk ll lm ln b">MapJobNumber</code>被用作中间文件的一部分</li><li id="42a0" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated"><code class="du lk ll lm ln b">ReducerCount</code>用于决定密钥分区。</li></ul><p id="b443" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果未找到未分配的地图作业，但仍有正在运行的地图作业，协调器会向工作器发送一个<code class="du lk ll lm ln b">nil</code>地图作业，以便工作器稍后可以再次请求，因为缩减作业只能在所有地图作业完成后开始。</p><p id="b51d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果所有地图作业都已完成，协调器将遍历<code class="du lk ll lm ln b">reduceStatus</code>以查找第一个未分配的归约作业，其有效负载如下:</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="3788" class="lo iw hi ln b fi mk ml l mm mn">type ReduceJob struct { <br/>     IntermediateFiles []string <br/>     ReduceNumber      int<br/>}</span></pre><ul class=""><li id="a345" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated"><code class="du lk ll lm ln b">IntermediateFiles</code>是减速器编号<code class="du lk ll lm ln b">ReduceNumber</code>的中间文件</li></ul><p id="32e8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果所有作业都已完成，将向工作人员发送退出信号，下面是请求作业响应:</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="fafb" class="lo iw hi ln b fi mk ml l mm mn">type RequestTaskReply struct { <br/>     MapJob    *MapJob <br/>     ReduceJob *ReduceJob <br/>     Done      bool<br/>}</span></pre><p id="d2e5" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">报告已完成的任务</strong></p><p id="7b65" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">每当一个工作者完成一项工作，它就向协调者报告已完成的工作，以便协调者可以更新状态。请求负载取决于作业类型，响应负载为空。</p><p id="958e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果作业是一个地图作业，作业应该将以下信息告诉协调者，<code class="du lk ll lm ln b">InputFile</code>是地图作业标识符，<code class="du lk ll lm ln b">IntermediateFile</code>是该地图作业产生的文件的位置。</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="0be1" class="lo iw hi ln b fi mk ml l mm mn">type ReportMapTaskArgs struct { <br/>     InputFile        string<br/>     IntermediateFile []string<br/>}</span></pre><p id="f5c5" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果作业是缩减作业，则作业只向协调者报告缩减者编号。</p><h2 id="70e0" class="lo iw hi bd ix lp lq lr jb ls lt lu jf ke lv lw jj ki lx ly jn km lz ma jr mb bi translated">工人</h2><p id="7f2f" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">现在是时候进入最具挑战性的部分来实现map/reduce作业的处理程序了。</p><p id="3855" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">地图作业</strong></p><p id="4ffd" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">当一个工人收到一个地图作业时，它首先打开输入文件，阅读所有内容，并准备调用地图函数<code class="du lk ll lm ln b">mapf(filename, string(fileContent))</code>。注意文件名不在字数统计程序的映射函数中使用，但是<code class="du lk ll lm ln b">mapf</code>函数无论如何都需要一个键。</p><p id="d1dd" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在<code class="du lk ll lm ln b">mapf</code>函数中，它只是将内容拆分成一个单词数组，对于每个作品，它生成一个键值对，例如{"hello "，1}，因此<code class="du lk ll lm ln b">mapf</code>函数的最终输出是一个键值对<code class="du lk ll lm ln b">kva</code>数组。</p><p id="8765" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">与real MapReduce的一个显著区别是，所有的中间数据都在一个地方<code class="du lk ll lm ln b">kva</code>，但对于real MapReduce，我们需要将中间数据分成N个分区，其中N是reducers的数量。</p><p id="607c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">所以，工人需要迭代<code class="du lk ll lm ln b">kva</code>。对于每个键值对(k，v)，使用提供的哈希函数来决定这个键属于哪个缩减器:</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="c27c" class="lo iw hi ln b fi mk ml l mm mn">partitionedKva := make([][]KeyValue, reduceCount)  <br/>for _, v := range kva {  <br/>    partitionKey := ihash(v.Key) % reduceCount  <br/>    partitionedKva[partitionKey] = append(partitionedKva[partitionKey], v) <br/>}</span></pre><p id="af57" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">最后，用文件名<code class="du lk ll lm ln b">mr-x-i</code>将<code class="du lk ll lm ln b">partitionedKva[i]</code>持久化到磁盘，其中<code class="du lk ll lm ln b">x</code>是地图作业编号。完成此操作后，工作可以通过RPC报告地图作业已完成。</p><p id="733a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">减少工作</strong></p><p id="b8a4" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">当一个缩减器接收到一个缩减作业时，这个作业包含了需要由这个缩减器处理的所有中间文件。工人首先逐个打开所有的中间文件，构建一个键值对数组<code class="du lk ll lm ln b">kva</code>。</p><p id="7fee" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">通常中间键值对需要排序，所以我们可以使用提供的函数来排序<code class="du lk ll lm ln b">kva</code>。排序后的<code class="du lk ll lm ln b">kva</code>如下图所示:</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="de19" class="lo iw hi ln b fi mk ml l mm mn">{"Key": "A", "Value": "1"}<br/>{"Key": "A", "Value": "1"}<br/>{"Key": "About", "Value": "1"}</span></pre><p id="7657" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><code class="du lk ll lm ln b">reducef</code>函数接受一个键和键的值。在字数统计程序中，工作人员需要迭代排序后的<code class="du lk ll lm ln b">kva</code>来查找同一关键字下的所有值，如下所示:</p><pre class="mc md me mf fd mg ln mh mi aw mj bi"><span id="3b0d" class="lo iw hi ln b fi mk ml l mm mn">reducef("A", ["1", "1"]) =&gt; output A     2<br/>reducef("About", ["1"])  =&gt; output About 1</span></pre><p id="e8b5" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">每次一个<code class="du lk ll lm ln b">reducef</code>输出一个结果，我们可以把它保存到一个临时文件中，一旦所有的键都被归约，我们可以把这个临时文件重命名为最终的输出文件<code class="du lk ll lm ln b">mr-out-x</code>，其中<code class="du lk ll lm ln b">x</code>是归约器的编号。它不直接写入最终输出的原因是工人可以在任何时候崩溃，这可以防止reducer产生一个损坏的输出文件。</p><h2 id="6c90" class="lo iw hi bd ix lp lq lr jb ls lt lu jf ke lv lw jj ki lx ly jn km lz ma jr mb bi translated">协调员</h2><p id="5087" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">对于协调员来说，还有两件事要做:</p><ol class=""><li id="7c27" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq mo lc ld le bi translated">处理工人崩溃</li><li id="da23" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq mo lc ld le bi translated">所有工作完成后退出。</li></ol><p id="a09c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">要退出，协调器应正确执行<code class="du lk ll lm ln b">Done</code>功能。这非常简单，当所有的<code class="du lk ll lm ln b">reduceStatus</code>都完成时，只返回<code class="du lk ll lm ln b">true</code>。</p><p id="a290" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">工作者可以在任何时候崩溃，并且如果工作者崩溃，协调器需要将分配给崩溃工作者状态的作业更新回<code class="du lk ll lm ln b">NotStarted</code>。</p><p id="5775" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">为了实现这一点，我们需要跟踪一个作业被分配给一个工人的时间，协调器将生成一个ticker来检查是否有任何正在运行的作业超时。</p><p id="11dd" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">此时，如果我们运行<code class="du lk ll lm ln b">bash test-mr.sh</code>，您应该会看到所有测试都已通过。</p><h1 id="25d1" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论</h1><p id="2e2e" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">感谢您阅读到这里。我知道这很乏味，很可能不好玩。当我完成这个lab 1 MapReduce时，回头看看它，它并不是非常难。关键是要理解MapReduce的核心思想:</p><ul class=""><li id="a9e6" class="kw kx hi jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">map函数期望什么作为输入？</li><li id="a67b" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">中间输出是什么样子的？</li><li id="f5db" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">reduce函数期望什么作为输入？</li><li id="a14c" class="kw kx hi jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">最终输出是什么样的？</li></ul><p id="d206" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">一旦你弄清楚了它们，你应该能够毫无问题地编写自己的代码。</p><p id="fa9c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">最后，下面是我对lab1的粗略实现:<a class="ae iu" href="https://github.com/QingpingMeng/mit6.824/tree/lab1" rel="noopener ugc nofollow" target="_blank">https://github.com/QingpingMeng/mit6.824/tree/lab1</a></p></div></div>    
</body>
</html>