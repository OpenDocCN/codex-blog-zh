<html>
<head>
<title>Easy tutorial on Java String, StringBuilder and StringBuffer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java字符串、StringBuilder和StringBuffer的简单教程</h1>
<blockquote>原文：<a href="https://medium.com/codex/easy-tutorial-on-java-string-stringbuilder-and-stringbuffer-763b2e1f5fe6?source=collection_archive---------8-----------------------#2022-04-28">https://medium.com/codex/easy-tutorial-on-java-string-stringbuilder-and-stringbuffer-763b2e1f5fe6?source=collection_archive---------8-----------------------#2022-04-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b287fb35254c27a7acc3988ceefa7d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2Dztf9L_X-2Ft6Bd"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@henry_be?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Henry Be </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e069" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本教程中，我们将深入探讨Java String、StringBuilder和StringBuffer的概念，并了解我们应该使用什么类以及何时使用。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="0bbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">字符串被广泛用作一种数据类型，它允许程序员处理单词、句子、电话号码，甚至只是普通的数字。从根本上说，String是一个表示字符值序列的对象。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="551b" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">字符串类</h1><p id="9d4f" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">Java String class是Java自带的标准类，专门用于处理字符串。Java string类实现了Serializable、Comparable和CharSequence接口。字符数组的工作方式也和Java字符串一样。例如:</p><p id="af01" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ld le lf lg b">char[] ch = {‘j’, ‘a’, ‘v’ , ‘a’};</code></p><p id="8c2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ld le lf lg b">String str = new String(ch);</code></p><p id="5832" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将初始化一个新的字符串，其内容为<code class="du ld le lf lg b">java</code>。</p><p id="0555" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面两行可以写成</p><p id="ab1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ld le lf lg b">String str = ”java”;</code></p><p id="6528" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们初始化字符串的第一种方法向我们展示了字符串包含一个字符数组。</p><p id="a985" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">据说Java字符串是不可变的。不可变意味着不可修改或不可改变，这意味着一旦一个字符串对象被创建，我们就不能改变它的内容。</p><p id="0456" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面我们可以看到一个描述这一事实的例子。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="128c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里<code class="du ld le lf lg b">Gaurav</code>没有改变，但是用<code class="du ld le lf lg b">Gaurav Sharma</code>创建了一个新对象。这就是字符串被称为不可变的原因。</p><p id="7bab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是如果我们把它显式赋给引用变量，它就会引用<code class="du ld le lf lg b">Gaurav Sharma</code>对象。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="84d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们将变量s的引用从<code class="du ld le lf lg b">“Gaurav”</code>改为字符串<code class="du ld le lf lg b">“Gaurav sharma”</code></p><h2 id="725c" class="ln kb hi bd kc lo lp lq kg lr ls lt kk jg lu lv ko jk lw lx ks jo ly lz kw ma bi translated">字符串操作</h2><p id="3eb4" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以用字符串执行很多操作，我将在这里列出最重要的。</p><ol class=""><li id="c692" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mg mh mi mj bi translated"><strong class="ix hj">字符串连接:<br/> </strong>这个部分处理使用不同的技术连接两个或更多的字符串</li></ol><ul class=""><li id="ecef" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mk mh mi mj bi translated"><strong class="ix hj">使用+运算符的字符串串联</strong></li></ul><p id="46b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用+操作符连接两个字符串，它将返回一个字符串，该字符串将两个字符串的内容附加在一起。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="faa7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是<code class="du ld le lf lg b">+</code>操作符在连接字符串和数字的情况下会导致歧义。让我们通过一个例子来理解这一点。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="1022" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个例子中，我们可以看到串联的工作方式非常奇怪，足以让我们重新考虑输出</p><blockquote class="ml mm mn"><p id="35d9" class="iv iw mo ix b iy iz ja jb jc jd je jf mp jh ji jj mq jl jm jn mr jp jq jr js hb bi translated">H <!-- -->之前我们得到了输出<code class="du ld le lf lg b"><em class="hi">50TestString2040</em></code>，因为使用+的<strong class="ix hj">字符串连接创建了一个新的字符串，并且它一直将操作数追加到前面操作数的末尾。</strong></p></blockquote><p id="514a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们用循序渐进的方法来更好地理解这句话。</p><p id="dd4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">语句<code class="du ld le lf lg b">10+20+20+s1+s2+20+40</code>的工作方式如下。</p><p id="be58" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">10+20 = 30<br/>30+20=50<br/>50+S1 = 50测试<br/>50测试+S2 = 50测试字符串<br/>50测试字符串+20 = 50测试字符串20<br/>50测试字符串20+40 = 50测试字符串2040</p><p id="3761" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mo">注意:追加到字符串的整数将始终产生一个字符串。</em></p><ul class=""><li id="a791" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mk mh mi mj bi translated"><strong class="ix hj">通过concat方法的字符串连接:</strong></li></ul><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="ccd8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2。比较字符串</strong></p><p id="89f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用各种技术来检查字符串在值和引用方面的相等性。java中有3种方法来比较字符串值。</p><ul class=""><li id="d0d7" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mk mh mi mj bi translated"><strong class="ix hj">字符串比较等于方法</strong></li></ul><p id="7a9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">String equals方法根据字符串的内容对字符串进行比较。它比较字符串的奇偶或相等性。</p><p id="aa5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">String类提供了两种比较内容的方法。</p><p id="88d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ld le lf lg b">public Boolean equals(String str)<br/>public Boolean equalsIgnoreCase(String str)</code></p><p id="63bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ld le lf lg b">equals</code>该方法通常比较两个字符串，但也会考虑大小写</p><p id="214c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ld le lf lg b">“Apple” != “apple”</code></p><p id="3562" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是在<code class="du ld le lf lg b">equalsIgnoreCase</code>的情况下，该陈述将为真</p><p id="8a83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ld le lf lg b">“Apple” == “apple”</code></p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><ul class=""><li id="4f6e" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mk mh mi mj bi translated"><strong class="ix hj">字符串比较by ==运算符</strong></li></ul><p id="e1e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">==运算符比较堆中对象的引用或内存位置。它不检查它所检查的引用值。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><ol class=""><li id="1c0a" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mg mh mi mj bi translated">s1==s2为真，因为二者在字符串常量池中有相同的地址。要了解更多关于字符串常量池的信息，请参考这个链接，因为这个主题很大，超出了本教程的范围。<br/><a class="ae iu" href="https://www.geeksforgeeks.org/string-constant-pool-in-java/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/string-constant-pool-in-java/</a></li><li id="d6f3" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated">s1==s3为假，因为每当我们用new关键字创建一个字符串对象时，我们就在字符串常量池中为这个对象分配一个新的内存位置，这样s1和s3就不会引用堆中的同一个内存位置。</li></ol><ul class=""><li id="5814" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mk mh mi mj bi translated"><strong class="ix hj">用compareTo()方法进行字符串比较</strong></li></ul><p id="2acd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ld le lf lg b">compareTo()</code>方法按字典顺序比较两个字符串，并返回一个整数值，指示第一个字符串小于、等于或大于第二个字符串。对于两个串s1和s2，如果</p><p id="e06a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">s1==s2返回0 <br/> s1 &gt; s2返回正数<br/> s1 &lt; s2返回负数</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="3f92" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们可以看到,<code class="du ld le lf lg b">compareTo</code>方法只检查两个字符串中字母的相对顺序。</p><h2 id="e593" class="ln kb hi bd kc lo lp lq kg lr ls lt kk jg lu lv ko jk lw lx ks jo ly lz kw ma bi translated">String类的一些重要方法</h2><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/00afca3c6466b5bef4df57fc1e3fc14f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TajffgyRBwwVBi7cU50L6A.png"/></div></div></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="2c96" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">STRINGBUFFER类</h1><p id="21f0" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">String和StringBuffer类在java.lang包中定义。StringBuffer类用于创建可变或可修改的字符串。String和StringBuffer中的一切都是相同的，只是StringBuffer类表示一个可增长和可写的字符序列。可以替换StringBuffer中的任何字符，我们也可以在StringBuffer中插入字符，StringBuffer的大小会自行增长。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="e0e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以用3种方法声明StringBuffer(它有3个构造函数),我们将会看到所有的方法。</p><ol class=""><li id="b69f" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mg mh mi mj bi translated"><code class="du ld le lf lg b">StringBuffer str = new StringBuffer();</code> <br/>这将创建一个StringBuffer对象，它是一个空的字符串缓冲区，初始容量为16个字符。</li><li id="8345" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated"><code class="du ld le lf lg b">StringBuffer str = new StringBuffer(String string);<br/></code>这将创建一个StringBuffer对象，将字符串的内容作为参数传递。</li><li id="7c5c" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated">它将创建一个空的StringBuffer对象，初始大小等于作为参数传递的整数。</li></ol><h2 id="71ed" class="ln kb hi bd kc lo lp lq kg lr ls lt kk jg lu lv ko jk lw lx ks jo ly lz kw ma bi translated">StringBuffer方法:</h2><p id="5c65" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">一些方法使字符串缓冲区从字符串中脱颖而出，我们将详细讨论它们</p><ul class=""><li id="963d" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mk mh mi mj bi translated"><strong class="ix hj"> append(): </strong></li></ul><p id="77d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">append方法将给定的参数追加到字符串中。它接受三种类型的参数String、int和Object。</p><blockquote class="ml mm mn"><p id="c70c" class="iv iw mo ix b iy iz ja jb jc jd je jf mp jh ji jj mq jl jm jn mr jp jq jr js hb bi translated"><strong class="ix hj"> <em class="hi">语法:<br/>String buffer append(String str)<br/>String buffer append(int num)<br/>String buffer append(Object obj)</em></strong></p></blockquote><p id="4b29" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">示例:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><ul class=""><li id="f375" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mk mh mi mj bi translated"><strong class="ix hj">插入()</strong></li></ul><p id="0428" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">insert()方法将给定的字符串、字符或对象插入到另一个字符串的给定位置。</p><blockquote class="ml mm mn"><p id="7b4c" class="iv iw mo ix b iy iz ja jb jc jd je jf mp jh ji jj mq jl jm jn mr jp jq jr js hb bi translated"><strong class="ix hj"> <em class="hi">语法:<br/>String buffer insert(int index，String str)<br/>String buffer insert(int index，char ch)<br/>String buffer insert(int index，Object obj)</em>T23】</strong></p></blockquote><p id="88d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">示例:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><ul class=""><li id="02b0" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mk mh mi mj bi translated"><strong class="ix hj">删除()</strong></li></ul><p id="0b08" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">delete()方法用于从索引处的字符串中删除一个字符，或者我们可以删除一个范围内的字符。</p><blockquote class="ml mm mn"><p id="f242" class="iv iw mo ix b iy iz ja jb jc jd je jf mp jh ji jj mq jl jm jn mr jp jq jr js hb bi translated"><strong class="ix hj"> <em class="hi">语法:<br/>string buffer insert(int startIndex，int endIndex) </em> </strong></p></blockquote><p id="e3a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">示例:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><ul class=""><li id="e507" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mk mh mi mj bi translated"><strong class="ix hj">反转()</strong></li></ul><p id="22cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此方法反转字符串。它进行字符串的原位反转。</p><blockquote class="ml mm mn"><p id="a56b" class="iv iw mo ix b iy iz ja jb jc jd je jf mp jh ji jj mq jl jm jn mr jp jq jr js hb bi translated"><strong class="ix hj"> <em class="hi">语法:<br/>string buffer reverse()</em></strong></p></blockquote><p id="d249" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">示例:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><ul class=""><li id="b08a" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mk mh mi mj bi translated"><strong class="ix hj">容量()</strong></li></ul><p id="5351" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java中StringBuffer类的capacity()方法用于返回缓冲区容量。默认情况下，字符串缓冲区的容量为16个字符。通过调用这个方法，我们可以计算它的当前容量。</p><blockquote class="my"><p id="0714" class="mz na hi bd nb nc nd ne nf ng nh js dx translated">如果字符数增加了当前容量Stringbuffer的大小增加了(当前容量*2)+2</p></blockquote><p id="e433" class="pw-post-body-paragraph iv iw hi ix b iy ni ja jb jc nj je jf jg nk ji jj jk nl jm jn jo nm jq jr js hb bi translated">示例:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="3b4d" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">STRINGBUILDER类</h1><p id="c721" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">StringBuilder类用于创建与StringBuffer类相同的可变和可修改的字符串，但StringBuffer和StringBuilder之间的唯一区别是StringBuffer是同步的。StringBuffer的所有方法在StringBuilder中都可用。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h2 id="7706" class="ln kb hi bd kc lo lp lq kg lr ls lt kk jg lu lv ko jk lw lx ks jo ly lz kw ma bi translated">STRING和STRINGBUFFER类之间的区别</h2><p id="8e95" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated"><strong class="ix hj">字符串</strong></p><ol class=""><li id="2c06" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mg mh mi mj bi translated">String类是不可变的。</li><li id="684d" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated">当我们连接太多的字符串时，String会变慢并消耗更多的内存，因为每次它都会创建一个新的实例。</li><li id="2d7a" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated">String类重写Object类的equals()方法。所以你可以用equals()方法比较两个字符串的内容。</li><li id="a31f" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated">字符串类在执行串联操作时速度较慢。</li><li id="e2bd" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated">字符串类使用字符串常量池。</li></ol><p id="2e61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> StringBuffer </strong></p><ol class=""><li id="b5b0" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mg mh mi mj bi translated">当我们连接两个字符串时，StringBuffer速度更快，占用的内存更少。</li><li id="8597" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated">StringBuffer类不重写Object类的equals()方法。</li><li id="3b08" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated">StringBuffer类在执行串联操作时速度更快。</li><li id="7947" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated">StringBuffer类是可变的。</li><li id="2d90" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated">StringBuffer使用堆内存。</li></ol><h2 id="0920" class="ln kb hi bd kc lo lp lq kg lr ls lt kk jg lu lv ko jk lw lx ks jo ly lz kw ma bi translated">STRINGBUILDER和STRINGBUFFER类之间的区别</h2><p id="00c7" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated"><strong class="ix hj"> StringBuffer </strong></p><ol class=""><li id="5e63" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mg mh mi mj bi translated">StringBuffer是同步的，即线程安全的。这意味着两个线程不能同时调用StringBuffer的方法。</li><li id="443e" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated">StringBuffer的效率比StringBuilder低。</li><li id="4238" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated">StringBuffer是在Java 1.0中引入的</li></ol><p id="3632" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> StringBuilder </strong></p><ol class=""><li id="218c" class="mb mc hi ix b iy iz jc jd jg md jk me jo mf js mg mh mi mj bi translated">StringBuilder是<em class="mo">非同步的</em>，也就是说，不是线程安全的。这意味着两个线程可以同时调用StringBuilder的方法。</li><li id="cc4e" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated">StringBuilder比StringBuffer更高效。</li><li id="a88b" class="mb mc hi ix b iy ms jc mt jg mu jk mv jo mw js mg mh mi mj bi translated">StringBuilder是在Java 1.5中引入的</li></ol></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="18e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这都是关于String，StringBuffer和StringBuilder类的，在这里我们了解了这些类是什么，它们能做什么，不能做什么。我希望你喜欢阅读和深入了解这些课程。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="3620" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你明白我在这里说的任何事情，请鼓掌回应并跟我来，因为它帮助我保持动力并从我的时间表中抽出时间来写这些文章。这不会花你任何钱，但会帮我很多忙</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><blockquote class="ml mm mn"><p id="1513" class="iv iw mo ix b iy iz ja jb jc jd je jf mp jh ji jj mq jl jm jn mr jp jq jr js hb bi translated">高拉夫·夏尔马是一个狂热的读者和热情的旅行者。他试图通过传播他的知识和他的生活经历来过一个更有意义和目标的生活！跟随他踏上平衡数字生活和现实生活的新旅程。他住在印度的北阿坎德邦。他在Instagram上的<a class="ae iu" href="https://www.instagram.com/golf._.sierra/" rel="noopener ugc nofollow" target="_blank"> @golf。_.塞拉</a></p></blockquote></div></div>    
</body>
</html>