# JS 中变量声明的奥秘

> 原文：<https://medium.com/codex/the-mystery-of-variable-declaration-in-js-24da9e3c6dfe?source=collection_archive---------12----------------------->

## VAR vs LET vs CONST —如何选择正确！

![](img/0ca1c9f8ba87ce7e1530f1e84027131c.png)

# 介绍

尽管我们大多数前端开发人员一直在定义*Java 脚本*变量，但我经历过很多，尤其是初级开发人员，并不真正*了解*或真正*关心*他们在 JS 中如何声明变量的区别。

我个人认为这个主题**非常重要**，因为变量声明*(在任何语言中)*，是编写代码的一个基本部分，忽略事实将最终导致性能问题，或者你会发现自己在*调试地狱中。*特别是 JS，作为一个子集或纯粹的，仍然是前端应用程序中使用最多的语言之一，**性能**可能很快成为一个问题。

# 为什么这很重要？

你们中的一些人可能会问为什么要这么麻烦，因为最终我们如何定义变量并不重要，除非我们使用像 *Typescript* 这样的东西。🤯由于 JS 被认为是一种高级语言，因此开发人员不需要处理代码中变量的内存分配，一些开发人员忽略了这样一个事实:内存仍然需要以某种方式被分配和释放。它们只是声明一个变量，JS 处理内存分配。

然而，这样的内存分配必须在某一点被释放，以避免内存泄漏和性能问题。收集所有这些*死*对象并从内存中移除它们的分配的过程称为*垃圾收集*。[这里有一篇由](/@_lrlna/garbage-collection-in-v8-an-illustrated-guide-d24a952ee3b8) [Irina Shestak](https://medium.com/u/408458b1f6aa?source=post_page-----24da9e3c6dfe--------------------------------) 撰写的精彩文章，讲述了 JS 中垃圾收集的工作原理。

但是不仅仅糟糕的内存分配会成为一个问题，忽略*最佳实践*也会对代码稳定性产生影响。例如，您可能无意中在代码中的某个地方重新声明了一个`result`对象，这会导致数据损坏。如果你的编译器没有警告你，这将很快导致一场耗费你数小时时间的调试闹剧！

尽管 JavaScript 并不坏，但它仍然允许您做一些非常奇怪的事情——作为开发人员，您应该意识到这一点！

## 辖域

为了理解声明差异的主题，我们首先需要建立*范围的定义。*它不是什么神秘的东西，基本上只是你代码里面一个对象*(函数，变量，类)*的*定义空间*。基本上有两个范围定义:一个对象是

*   **函数作用域，**如果它可以在代码的*根级别*上访问，并且
*   **块范围，**如果对象只能在*块* *内访问(如 if 语句、嵌套函数等)。).*

范围的重要性可能还不清楚，但是我们将在后面的例子中关注这个问题。

## 提升

提升是 *JS 解释器*的默认行为，将所有声明移动到它们作用域的顶部，使它们在整个定义空间都是可访问的。这些声明包括函数、变量和类，尽管提升通常被认为是`var`声明的一个特征。根据 [MDN](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting?retiredLocale=de) ，下列任何一种行为都可以被认为是吊装:

1.  *值提升* →在变量被声明之前访问变量**的值。**
2.  *声明提升* →引用声明前的变量，但值赋给`undefined`。
3.  *词法提升* →声明前引用变量或引用变量范围外导致*引用错误*。

通常，*函数声明* ( `function`，`async function`)受制于**类型 1** ，`var`是**类型 2** 和`let`，`const`和`class` *(词法声明)*的行为类似于**类型 3** 的提升。

既然本文重点讨论*变量*声明*，*那我们最后来说说 JS 中不同的*声明选项*。

# VAR-declaration

`var`声明基本上是 [ES6](https://www.w3schools.com/js/js_es6.asp) 之前时代的遗留物，但在现代应用程序中仍在定期攀升。

> 在我看来，`var` **不应该在任何现代应用中使用**，除了极少数例外。❌——不要用它！

首先，`var` **是函数作用域的**，因此会导致很多问题！让我们看一个例子:

如您所见，`rusty`在`if`语句的内部和外部都是可访问的，因为解释器将它移动到了父作用域的顶部！🤯

虽然起初这似乎不是一个大问题，但是变量已经被分配并停留在内存中，直到**整个函数**完成。这意味着*垃圾收集*永远无法*释放*该变量的分配，因为只要该函数正在执行**就可以到达**！

想象一个正在运行的 web 应用程序，它有一堆在子作用域中声明的内存密集型对象(例如 if 语句)。因为这些对象仍然可以从父作用域中的任何地方访问，所以这些对象的内存永远不会被释放，即使实际使用变量的子作用域不再运行！👎

此外，由于`var`的行为类似于**类型 2 提升**，变量用`undefined`进行初始化，因此在实际声明之前甚至有一个值*。这里有一个例子:*

我们可以看到`rusty`甚至在变量被赋值之前就已经可以访问了！

## VAR 变量的重新声明

在我看来，使用`var`声明最可怕的*含义是，我们可以在函数中的任何时候**重新声明**这样的变量！这不仅在我们每次重新声明的时候分配一个新的内存，而且也考虑到了大量的赋值错误。*

# 信件声明

JS 团队显然也同意这样一个事实，即`var`的行为可能会有问题，因此，随着 ES6 的兴起，引入了新的*块范围的*声明选项`let`和`const`。

> 如果你不确定如何声明你的变量，使用 `***let***`！这是现代 JS 应用程序中声明变量的首选方式，并且导致的问题最少。

但是让我们首先通过一个例子来讨论与`var`声明的区别:

正如你所看到的，`rusty`现在是*块范围的*，只有**存在于定义它的**块中！这意味着一旦这个块终止，分配就变成受制于*垃圾收集*，因为它不能再被到达。这不仅可以提高性能，还可以显著降低重写全局值和类型的风险。

此外，`let`可以被重新赋值，但**不能被重新声明！这意味着你仍然可以给变量分配新的值，但是你不能为变量分配一个全新的内存槽。所以，虽然这是正确的**

这不是

最后，与`var`不同的是，`let`没有用`undefined`初始化**——实际上**根本没有初始化**，因为它的行为类似于 3 型起重。因此，试图在变量实际声明之前访问它，会导致引用错误:**

# **常量声明**

**最后要讨论的申报选项是`const`。正如上一节简要提到的，`const`与*非常相似*与`let`。带有`const`的变量声明是*块范围的*，不能被重新声明。在某些情况下，你可能想要一个更严格的定义，例如，如果你知道你的变量的值在你的声明语句之后不会改变。这正是`const`发挥作用的时候。用`const`声明的变量在变量范围内固定其值:**

**就是这样！🚀**

**我希望这篇文章能帮助你更多地了解 JS 中的变量声明以及它们对你工作的影响！也许你甚至开始理解后端工程师对编程语言中严格规则的迂腐主张。👀**

**一如既往，如果有任何问题或意见，请联系我们！🙏**