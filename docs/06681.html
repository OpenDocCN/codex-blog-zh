<html>
<head>
<title>Practical Use Of SOLID Design Principles In Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实体设计原则在代码中的实际应用</h1>
<blockquote>原文：<a href="https://medium.com/codex/practical-use-of-solid-design-principles-in-code-fadb16869618?source=collection_archive---------0-----------------------#2022-05-07">https://medium.com/codex/practical-use-of-solid-design-principles-in-code-fadb16869618?source=collection_archive---------0-----------------------#2022-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="341a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望我们的软件能够适应不断变化的需求，并允许分散开发。坚实的设计原则可以用来开发面向对象语言提供的许多选项。下面是在代码中实践这些原则的备忘单:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/f9330099417ad9f8f0e0b83557d9f426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b07k2LhqDDzpKDdYcTjh4g.png"/></div></div></figure><h1 id="fa62" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">什么是坚实的设计原则？</h1><p id="dbba" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">SOLID是Robert Martin创造的面向对象设计原则的首字母缩写:</p><ul class=""><li id="68ae" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated"><strong class="ih hj">单一责任原则(SRP) </strong> -一个类应该有且只有一个任务/责任。</li><li id="d2d9" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><strong class="ih hj">开/闭原则(OCP) </strong> -软件实体(类、模块、函数等)。)应该对扩展开放，但对修改关闭。设计和实现应该以这样一种方式来完成，即新的功能可以通过最少的代码修改来引入。</li><li id="1496" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><strong class="ih hj">利斯科夫替换原则(LSP)</strong>——派生类应该能够替换基类，而不违反它所继承或实现的抽象的意图或语义。</li><li id="e0ce" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><strong class="ih hj">接口隔离原则(ISP)</strong>——每个接口应该负责一个特定的任务。不应该强迫客户依赖他们不使用的方法。</li><li id="2fec" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><strong class="ih hj">依赖倒置原则(DIP)</strong>——每个模块应该使用一个抽象层将它们绑定在一起，从而与其他模块分离开来。更高级别的策略抽象驱动实现细节，而不是相反。</li></ul></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><h1 id="62fb" class="jp jq hi bd jr js ln ju jv jw lo jy jz ka lp kc kd ke lq kg kh ki lr kk kl km bi translated">使用坚实的原则编码意味着什么？</h1><ul class=""><li id="e3f5" class="ks kt hi ih b ii kn im ko iq ls iu lt iy lu jc kx ky kz la bi translated">在所有方法之间保持一致的抽象级别。如果一个方法在一个抽象层次上操作，而另一个方法在不同的层次上操作，那么这个类可能有多个职责。</li><li id="cc2d" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">检查是否有仅由类中的方法子集使用的属性。这可能意味着这些属性和方法是独立于类的其他部分的职责。</li><li id="8e64" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">使用<a class="ae lv" href="https://en.wikipedia.org/wiki/Design_by_contract" rel="noopener ugc nofollow" target="_blank">合同设计</a>用于Liskov替代原则。其思想是，一个类及其方法有一个以前置/后置条件形式明确声明的契约。子类型可以削弱(但不能加强)它所覆盖的方法的前提条件。子类型可以加强(但不是削弱)它所覆盖的方法的后置条件。</li><li id="b580" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">什么时候类应该改变应该基于业务对概念的观点，而不是概念的纯粹逻辑分离。</li><li id="e603" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">避免任何维护状态的静态代码。静态代码应该是实用/无状态的。</li><li id="5a2b" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">使用策略模式而不是switch语句，因为后者通常意味着多重责任。</li><li id="3c32" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">使用扩展点、回调、可重写方法使软件可以在不修改现有代码的情况下添加新功能。</li><li id="fba3" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">当一个实现可以用于多个独立类型时，请使用泛型。</li><li id="b528" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">确保新的派生类在不改变其行为的情况下扩展基类。</li><li id="3c3d" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">使用装饰者模式、工厂方法、观察者模式来设计一个应用程序，这个应用程序必须易于修改，只需对现有代码做最小的改动。</li><li id="c2c8" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">当处理外部依赖性和现有的ISP违规时，使用适配器模式，因为它将一个类的接口转换为客户端期望的另一个接口，并允许否则不兼容的类一起工作。</li><li id="4725" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">首选多个客户端接口，而不是一个通用接口，每个接口都应该有一个特定的职责。如果需要，客户端可以实现多个接口。接口不应该有任何外部依赖。</li><li id="6655" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">将类或方法的可访问性最小化到所需的最低特权级别。这通过围绕实现提供适当的封装来保护将来进行更改的能力。</li><li id="96fe" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">如果用户查询需要快速/原始地访问数据层，利用命令查询责任分离(<a class="ae lv" href="https://martinfowler.com/bliki/CQRS.html" rel="noopener ugc nofollow" target="_blank"> CQRS </a>)。</li><li id="b657" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">使用分层设计，将用户界面、服务、业务逻辑、实现和数据访问分成不同的层。</li><li id="e1dc" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">不要在一个包中组合接口和实现。相反，通过运行时机制(如Spring IoC)提供编织实现的能力。</li><li id="90ad" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">依赖接口的代码应该只知道接口。它不应该知道任何实现该接口的特定类。</li><li id="9ffa" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">比起继承，更喜欢<a class="ae lv" href="http://javarevisited.blogspot.ie/2013/06/why-favor-composition-over-inheritance-java-oops-design.html" rel="noopener ugc nofollow" target="_blank">聚合和组合</a>。聚合是一种“有”的关系，继承是一种“是”的关系。比如:汽车是交通工具，所以汽车可以扩展为交通工具。但是汽车有轮子；汽车是由一组轮子组成的，它不是轮子的延伸。</li></ul><blockquote class="lw"><p id="a7a1" class="lx ly hi bd lz ma mb mc md me mf jc dx translated">遵循这些原则并不是万能的，也不会避免设计问题。也就是说，当正确遵循原则时，它们会在可读性、可扩展性、可维护性和可测试性方面产生更好的代码。</p></blockquote><blockquote class="mg mh mi"><p id="f17d" class="if ig mj ih b ii mk ik il im ml io ip mm mn is it mo mp iw ix mq mr ja jb jc hb bi translated">感谢您的阅读！如果您觉得这很有帮助，以下是您可以采取的一些后续步骤:</p></blockquote><ol class=""><li id="7e01" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc ms ky kz la bi translated">这个博客是我的<strong class="ih hj">系统设计系列的一部分。</strong>查看该系列的<a class="ae lv" href="https://iamkanikamodi.medium.com/design-principles-for-microservices-architecture-d637587cf394" rel="noopener">其他博客</a>！</li><li id="a8a7" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc ms ky kz la bi translated">给我点掌声！👏</li><li id="a717" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc ms ky kz la bi translated">在Medium上关注我，并在下面订阅，以便在我发布时获得通知！📨</li></ol></div></div>    
</body>
</html>