<html>
<head>
<title>Add RabbitMQ and gocron to your DigitalOcean droplet [Part 3]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将RabbitMQ和gocron添加到您的数字海洋液滴中[第3部分]</h1>
<blockquote>原文：<a href="https://medium.com/codex/add-rabbitmq-and-gocron-to-your-digitalocean-droplet-part-3-7eac34d84e4?source=collection_archive---------13-----------------------#2022-04-21">https://medium.com/codex/add-rabbitmq-and-gocron-to-your-digitalocean-droplet-part-3-7eac34d84e4?source=collection_archive---------13-----------------------#2022-04-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a9a3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用gocron构建一个简单的消息消费者</h2></div><p id="167a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(这是3部分系列的最后一部分。点击可以阅读上一部分<a class="ae jt" rel="noopener" href="/codex/add-rabbitmq-and-gocron-to-your-digitalocean-droplet-part-2-a0c0fc445ec7"/></p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/b38bfe371912d283222e43583edd0277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6jzKrDGG8mo0uk_2"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@arwinneil?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Arwin Neil Baichoo </a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="8e43" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">前一章的总结</h1><p id="3c53" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">在前一章中，我们已经构建了我们的消息生产者函数<code class="du lh li lj lk b">enqueue</code>。当我们的应用服务器接收流量并向RabbitMQ发布消息时，就会调用<code class="du lh li lj lk b">enqueue</code>函数。根据你的配置，你可以在其他地方调用<code class="du lh li lj lk b">enqueue()</code>函数。</p><h1 id="8931" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">构建消费者</h1><p id="3082" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">接下来，我们将构建cron-job，使其每小时/每分钟运行一次(取决于您的偏好),并使消息从队列中出队。为了简单起见，当一条消息被消费时，我们将使用Mailgun的go包发送一封基本的通知电子邮件。</p><p id="bd07" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(你可以从<a class="ae jt" href="https://github.com/asungur/simple_consumer/blob/main/main.go" rel="noopener ugc nofollow" target="_blank">这里</a>找到简单消费者的回购)</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="c08e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本例中，worker将在后台运行，每2分钟执行一次<code class="du lh li lj lk b">processMessages</code>功能。稍后我们将讨论如何设置这个worker作为一个<code class="du lh li lj lk b">systemd</code>服务来运行。</p><p id="7d82" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似于前面的例子，我们创建了一个<code class="du lh li lj lk b">Connection</code>和一个<code class="du lh li lj lk b">Channel</code>来执行队列中的任务。</p><pre class="jv jw jx jy fd ln lk lo lp aw lq bi"><span id="155c" class="lr kl hi lk b fi ls lt l lu lv">amqpServerURL := os.Getenv("AMQP_SERVER_URL")<br/>	<strong class="lk hj">connectRabbitMQ, err := amqp.Dial(amqpServerURL)</strong><br/>	if err != nil {<br/>		panic(err)<br/>	}<br/>	defer connectRabbitMQ.Close()<br/>	<strong class="lk hj">channelRabbitMQ, err := connectRabbitMQ.Channel()</strong><br/>	if err != nil {<br/>		panic(err)<br/>	}<br/>	defer channelRabbitMQ.Close()</span></pre><p id="7239" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将在通道上使用<code class="du lh li lj lk b">Consume()</code>函数来检索消息。您可以查看选项的注释。为了简单起见，我们会在消费消息时自动确认。</p><pre class="jv jw jx jy fd ln lk lo lp aw lq bi"><span id="5ada" class="lr kl hi lk b fi ls lt l lu lv">messages, err := <strong class="lk hj">channelRabbitMQ.Consume</strong>(<br/><strong class="lk hj">		"FallbackAPIQueue",</strong><br/>		"",<br/>		true,                      // auto acknowledge<br/>		false,                     // exclusive<br/>		false,                     // no local<br/>		false,                     // no wait<br/>		nil,<br/>	)<br/>	if err != nil {<br/>		log.Println(err)<br/>	}<br/>	log.Println("You've connected to RabbitMQ")<br/>	log.Println("Waiting for messages")<br/><br/>	if len(messages) == 0 {<br/>		log.Println("You don't have any messages in the queue")<br/>	}<br/>	for message := range messages {<br/>		if string(message.Body) == "A request has been sent via fallback API" {<br/>			sendSimpleMessage()<br/>		}<br/>	}</span></pre><p id="b2cb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，对于我们消费的每条消息，我们将调用<code class="du lh li lj lk b">sendSimpleMessage()</code></p><p id="4ac7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用Mailgun的go客户端库<code class="du lh li lj lk b">mailgun-go</code>我们可以发送简单的电子邮件。这需要你有一个Mailgun的账户。您需要将您的Mailgun域和API密钥保存在您的环境变量中。如果您没有Mailgun帐户，下面的参考资料部分有一个链接。</p><pre class="jv jw jx jy fd ln lk lo lp aw lq bi"><span id="fd0a" class="lr kl hi lk b fi ls lt l lu lv">func <strong class="lk hj">sendSimpleMessage()</strong> {<br/>	api_key := os.Getenv("MAILGUN_API_KEY")<br/>	sandbox_domain := os.Getenv("MAILGUN_DOMAIN")<br/><br/>	mg := mailgun.NewMailgun(sandbox_domain, api_key)<br/>	sender := "testingsomething@example.com"<br/>	subject := "security warning"<br/>	body := "Your fallback api is exposed"<br/>	recipient := "&lt;YOUR_EMAIL&gt;"<br/>	message := mg.NewMessage(sender, subject, body, recipient)<br/>	ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)<br/>	defer cancel()<br/>	resp, id, err := mg.Send(ctx, message)<br/>	if err != nil {<br/>		log.Fatal(err)<br/>	}<br/>	fmt.Printf("ID: %s Resp: %s\\n", id, resp)<br/>}</span></pre><p id="2e6a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们配置<code class="du lh li lj lk b">systemd</code>来运行这个应用程序作为服务。</p><p id="81ec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lh li lj lk b">systemd</code>是大多数Linux发行版附带的初始化系统和系统管理器。它带有管理工具<code class="du lh li lj lk b">systemctl</code></p><p id="04a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想了解更多关于<code class="du lh li lj lk b">systemd</code>的知识，或者您是新手，您可以在参考资料中找到下面的教程链接。让我们回到创建我们的服务。</p><p id="e4ec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们将创建一个服务文件:</p><pre class="jv jw jx jy fd ln lk lo lp aw lq bi"><span id="0c61" class="lr kl hi lk b fi ls lt l lu lv">$ sudo vim /lib/systemd/system/simple_consumer.service</span></pre><p id="13fa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们将在我们的<code class="du lh li lj lk b">simple_consumer.service</code>中添加以下配置选项:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="00f3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们继续之前，让我们讨论一下其中的一些配置步骤:</p><ol class=""><li id="30ac" class="lw lx hi iz b ja jb jd je jg ly jk lz jo ma js mb mc md me bi translated">在第3行中，<code class="du lh li lj lk b">ConditionPathExists</code>需要确保我们的应用程序目录在开始运行之前已经存在于我们的服务器中</li><li id="8892" class="lw lx hi iz b ja mf jd mg jg mh jk mi jo mj js mb mc md me bi translated">第6行的<code class="du lh li lj lk b">After</code>告诉<code class="du lh li lj lk b">systemd</code>等待，直到<code class="du lh li lj lk b">postgresql</code>服务开始。这是必需的，因为我要将它集成到我的简单API服务器中。根据您的配置，这可能不是必需的。</li><li id="3a7c" class="lw lx hi iz b ja mf jd mg jg mh jk mi jo mj js mb mc md me bi translated">在第12行，我们指定了<code class="du lh li lj lk b">WorkingDirectory</code>。这对于从我们的<code class="du lh li lj lk b">.env</code>文件中检索我们的环境变量很重要。</li><li id="d156" class="lw lx hi iz b ja mf jd mg jg mh jk mi jo mj js mb mc md me bi translated">最后，<code class="du lh li lj lk b">ExecStart</code>指定我们的可执行文件的位置</li></ol><p id="d5b9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在启用我们的系统之前，我们需要给予相关的权限来运行我们的应用程序:</p><pre class="jv jw jx jy fd ln lk lo lp aw lq bi"><span id="38dc" class="lr kl hi lk b fi ls lt l lu lv">$ sudo chmod +x /opt/appDir/simple_consumer</span></pre><p id="213a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在使用<code class="du lh li lj lk b">systemctl</code>我们可以首先启用服务并启动它。我们可以使用最后一个命令来检查应用程序的状态:</p><pre class="jv jw jx jy fd ln lk lo lp aw lq bi"><span id="f077" class="lr kl hi lk b fi ls lt l lu lv">$ sudo systemctl enable simple_consumer      # Enable the service<br/>$ sudo systemctl start simple_consumer       # Start the service<br/>$ sudo systemctl status simple_consumer      # Check service status</span></pre><p id="2940" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让trigger排队几次，并在cron-job运行前后查看我们的队列:</p><pre class="jv jw jx jy fd ln lk lo lp aw lq bi"><span id="3f92" class="lr kl hi lk b fi ls lt l lu lv">$ sudo rabbitmqctl list_queues</span><span id="887d" class="lr kl hi lk b fi mk lt l lu lv">Timeout: 60.0 seconds ...<br/>Listing queues for vhost / ...<br/>name messages<br/>FallbackAPIQueue 3</span></pre><p id="be98" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lh li lj lk b">FallbackAPIQueue</code>旁边的数字应该下降到<code class="du lh li lj lk b">0</code>，在我们的收件箱中，我们应该有一封电子邮件，用于发送从队列中出列的每条消息🎊</p><h1 id="8f29" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">资源</h1><ul class=""><li id="ea9a" class="lw lx hi iz b ja lc jd ld jg ml jk mm jo mn js mo mc md me bi translated"><a class="ae jt" href="https://www.digitalocean.com/community/tutorials/how-to-use-systemctl-to-manage-systemd-services-and-units" rel="noopener ugc nofollow" target="_blank">如何使用Systemctl管理Systemd服务和单元</a></li><li id="341a" class="lw lx hi iz b ja mf jd mg jg mh jk mi jo mj js mo mc md me bi translated"><code class="du lh li lj lk b"><a class="ae jt" href="https://pkg.go.dev/github.com/go-co-op/gocron" rel="noopener ugc nofollow" target="_blank">gocron</a></code>包<a class="ae jt" href="https://pkg.go.dev/github.com/go-co-op/gocron" rel="noopener ugc nofollow" target="_blank">包</a></li><li id="4dc0" class="lw lx hi iz b ja mf jd mg jg mh jk mi jo mj js mo mc md me bi translated"><a class="ae jt" href="https://www.atpeaz.com/running-go-app-as-a-service-on-ubuntu/" rel="noopener ugc nofollow" target="_blank">在Ubuntu上运行Go app作为服务</a></li><li id="d753" class="lw lx hi iz b ja mf jd mg jg mh jk mi jo mj js mo mc md me bi translated"><a class="ae jt" href="https://pkg.go.dev/github.com/BoltApp/mailgun-go" rel="noopener ugc nofollow" target="_blank"> Go mailgun包</a></li><li id="2ac8" class="lw lx hi iz b ja mf jd mg jg mh jk mi jo mj js mo mc md me bi translated"><a class="ae jt" href="https://documentation.mailgun.com/en/latest/quickstart-sending.html" rel="noopener ugc nofollow" target="_blank">配置你的Mailgun账户</a></li></ul></div></div>    
</body>
</html>