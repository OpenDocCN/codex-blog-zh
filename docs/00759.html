<html>
<head>
<title>Richardson Maturity Model for REST APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">REST APIs的Richardson成熟度模型</h1>
<blockquote>原文：<a href="https://medium.com/codex/richardson-maturity-model-for-rest-apis-8c9eaeaa4a6?source=collection_archive---------2-----------------------#2021-03-17">https://medium.com/codex/richardson-maturity-model-for-rest-apis-8c9eaeaa4a6?source=collection_archive---------2-----------------------#2021-03-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="161d" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><div class=""><h2 id="6bc7" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">RMM如何帮助我们构建更好的API</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/32dd91a9b17ad7ceb77786c603643f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*02TF9l458bkpjtv7MOntCQ.jpeg"/></div></div></figure><p id="3b54" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">我研究REST APIs已经有一段时间了，不可避免的会接触到很多关于Leonard Richardson开发的<strong class="ju hs"> Richardson成熟度模型</strong> ( <strong class="ju hs"> R.M.M. </strong>)的文章和推荐。这让我思考为什么它很重要，以及我们如何应用它的原则来制作一个易于使用(和理解)的API。</p><p id="c39b" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">经过一些研究和使用(实现或使用)REST APIs，这些API符合RMM的最高级别和其他远非如此的级别，我有一些结论想在本文中分享。</p><p id="6370" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">我喜欢来自维基百科的理查森成熟度模型的定义:</p><blockquote class="kp kq kr"><p id="98ab" class="js jt ks ju b jv jw is jx jy jz iv ka kt kc kd ke ku kg kh ki kv kk kl km kn hb bi translated">RMM可以用来确定web服务架构遵守REST原则的程度。它将Web API分为四个级别(从0到3 ),每一个更高的级别都对应于对REST设计的更完全的遵循。下一级也包含上一级的所有特征。”</p></blockquote><p id="4428" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">简而言之，RMM告诉我们一个REST API的成熟度级别，符合最后一个级别的被认为是“<em class="ks"> Restful API </em>”。</p><p id="8799" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">描述RMM的成熟度级别及其关键点是很重要的。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es kw"><img src="../Images/6754703a776ce59c21caf151e4473337.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*XlmvFH_2f0LeNFzYJe1AWQ.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx translated">来自:<a class="ae ko" href="https://restfulapi.net/richardson-maturity-model/" rel="noopener ugc nofollow" target="_blank">https://restfulapi.net/richardson-maturity-model/</a></figcaption></figure></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h1 id="3bc3" class="li lj hi bd lk ll lm ln lo lp lq lr ls ix lt iy lu ja lv jb lw jd lx je ly lz bi translated">0级</h1><p id="1c8a" class="pw-post-body-paragraph js jt hi ju b jv ma is jx jy mb iv ka kb mc kd ke kf md kh ki kj me kl km kn hb bi translated">这是最底层，描述了一个web API <em class="ks">，它有一个通过HTTP的URI </em>和一个接受服务支持的所有操作的方法<em class="ks"/>(通常是‘POST’)。因此，没有正确使用HTTP协议，它被用作客户端和服务器之间远程交互的隧道机制。</p><p id="efa9" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">没有明确定义的资源，消息传递以“xml”、“json”或其他文本格式完成。典型的SOAP web服务属于这一类，这被称为'<em class="ks">POX的沼泽</em>'(普通的旧XML)方法。</p><p id="1dd3" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">举个例子，它可以是一个服务，有一个像<em class="ks">/movie service</em>这样的端点，在这里你可以检索关于一部电影或其演员的信息，甚至插入、更新、删除一些用xml描述的电影数据；所有这一切都是通过使用适当的xml有效负载发出POST请求来实现的。</p><h1 id="a65b" class="li lj hi bd lk ll mf ln lo lp mg lr ls ix mh iy lu ja mi jb lw jd mj je ly lz bi translated">一级</h1><p id="913d" class="pw-post-body-paragraph js jt hi ju b jv ma is jx jy mb iv ka kb mc kd ke kf md kh ki kj me kl km kn hb bi translated">在这个层面上，<em class="ks">资源</em>被引入。现在，服务有许多URIs(仍然通常使用HTTP POST方法)，每个URI标识一个资源，所以现在每个资源都可以单独寻址。现在，可以通过特定的URI访问单个资源，而不是单个端点。</p><p id="dea2" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">例如，我们现在可以使用<em class="ks">/movie service</em>和<em class="ks"> /actorsService </em>端点来请求对“电影”和“演员”资源的操作。</p><h1 id="6af4" class="li lj hi bd lk ll mf ln lo lp mg lr ls ix mh iy lu ja mi jb lw jd mj je ly lz bi translated">第二级</h1><p id="59e3" class="pw-post-body-paragraph js jt hi ju b jv ma is jx jy mb iv ka kb mc kd ke kf md kh ki kj me kl km kn hb bi translated">这里，API开始使用<em class="ks"> HTTP动词/方法</em>，以及HTTP状态代码。这一级充分利用了HTTP作为应用层协议的全部潜力。</p><p id="884a" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">通常，GET方法用于从给定的资源获取数据，而POST、PUT和DELETE方法用于突变操作。</p><p id="ee54" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">因此，对于由其URI标识的给定资源，可以提供完整的CRUD(创建、检索、更新和删除)操作。</p><p id="6f6f" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在这一层，HTTP协议用于设置所请求操作的含义，请求体将不再携带操作信息。因此，该API比以前的级别显示出更高的成熟度。</p><p id="2a99" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">例如，我们可能有一个<em class="ks"> /movie </em>端点(URI)，在这里可以使用GET方法读取数据，并使用POST/PUT/DELETE动词创建/更新/删除资源条目。HTTP 200响应状态代码可用于指示操作正常，而400状态代码可用于通知这是一个错误的请求。</p><h1 id="7961" class="li lj hi bd lk ll mf ln lo lp mg lr ls ix mh iy lu ja mi jb lw jd mj je ly lz bi translated">第三级</h1><p id="aa51" class="pw-post-body-paragraph js jt hi ju b jv ma is jx jy mb iv ka kb mc kd ke kf md kh ki kj me kl km kn hb bi translated">这是理查森模型的最后一个也是最成熟的。这一级引入了<em class="ks">超媒体</em>表示，也称为<em class="ks"> HATEOAS </em>(超媒体作为应用程序状态引擎的首字母缩写)。</p><p id="f36d" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">HATEOAS是嵌入在资源响应消息中的元素，它驱动API客户端的交互。</p><p id="ea15" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">通过使用HATEOAS，这种级别鼓励容易发现，并使响应易于自我解释。因此，服务引导消费者通过一系列资源，结果导致应用程序状态转换。</p><p id="899a" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在第三层开发的API通常被认为是完全RESTful的API。</p><p id="91b8" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">例如，想象一个<em class="ks"> /movie </em>端点(URI)，在那里创建了一个新的电影资源，由id = 10标识(通过POST请求创建)。响应可以包含表示当前状态和进一步操作的链接，如下所示:</p><pre class="jh ji jj jk fd mk ml mm mn aw mo bi"><span id="8132" class="mp lj hi ml b fi mq mr l ms mt">// json response representation<br/>{<br/>   "movie": {<br/>      "id": 10,<br/>      "name": "Back to the Future",<br/>      "releaseYear": 1985<br/>      "<strong class="ml hs">links</strong>": <strong class="ml hs">[</strong><br/>         <em class="ks">link: {<br/>            "rel": "self",<br/>            "uri": "/movie/10"<br/>         },<br/>         link: {<br/>            "rel": "comments",<br/>            "uri": "/movie/10/comments"<br/>         }</em><br/>      <strong class="ml hs">]</strong><br/>   }<br/>} </span></pre><p id="ebe8" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在上面的例子中，我们被告知检索到的电影资源的URI是'<em class="ks"> /movie/10 </em>'，在这里我们可以使用http动词(PUT、GET等)请求操作；并告知我们可以在URI '<em class="ks">/movie/10/comments</em>'请求操作该电影的评论资源。</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h1 id="e075" class="li lj hi bd lk ll lm ln lo lp lq lr ls ix lt iy lu ja lv jb lw jd lx je ly lz bi translated">结论</h1><p id="663a" class="pw-post-body-paragraph js jt hi ju b jv ma is jx jy mb iv ka kb mc kd ke kf md kh ki kj me kl km kn hb bi translated">当我第一次看到“成熟模型”时，我首先想到的是:“哦，不，不要再这样了！”。在过去，我曾参与过试图遵循某种“成熟度模型”(比如“<a class="ae ko" href="https://pt.wikipedia.org/wiki/CMMI" rel="noopener ugc nofollow" target="_blank"> CMMI </a>”)的开发过程，这并不是一次好的经历。太多的官僚作风和当时很少的航运法规。</p><p id="32bc" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">但是通过研究RMM，我意识到它是一种简单的规则，可以确保HTTP协议以其全部的能力和特性被使用。</p><p id="55d6" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">简言之，Restful API实现必须是这样的:</p><blockquote class="mu"><p id="a275" class="mv mw hi bd mx my mz na nb nc nd kn dx translated">REST =基于资源的URI +充分利用HTTP规范+超媒体(HATEOAS)</p></blockquote><p id="1dcc" class="pw-post-body-paragraph js jt hi ju b jv ne is jx jy nf iv ka kb ng kd ke kf nh kh ki kj ni kl km kn hb bi translated">当然也有缺点，因为我已经看到了一些关于超媒体表示(HATEOAS)的争议。在“json”请求体中，没有像“xml”中的“xsd”那样的先前模式验证。</p><p id="6d83" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">作为一种标准化，它节省了客户开发人员理解API的资源和操作的时间。</p><p id="c2a3" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在我看来，遵循这种模型可以避免构建描述API的庞大而密集的开发人员门户。列出“资源”、一些请求/响应示例和swagger/openapi文档的简单门户应该足够了。</p><p id="9c70" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">RMM有几个级别，在大多数情况下，级别2对于良好的开发人员体验来说已经足够了。</p><p id="c2b6" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">即使API在底层，到达下一层也只需几步，并不困难！</p><p id="d53c" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">所以我的看法是，可以用Richardson成熟度模型作为指南，简化开发REST APIs的过程，帮助开发者设计出成熟直观的Restful API。</p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><h1 id="fa90" class="li lj hi bd lk ll lm ln lo lp lq lr ls ix lt iy lu ja lv jb lw jd lx je ly lz bi translated">资源和进一步阅读材料:</h1><ul class=""><li id="52c1" class="nj nk hi ju b jv ma jy mb kb nl kf nm kj nn kn no np nq nr bi translated"><a class="ae ko" href="https://martinfowler.com/articles/richardsonMaturityModel.html" rel="noopener ugc nofollow" target="_blank">马丁·福勒的理查森成熟度模型</a></li><li id="b513" class="nj nk hi ju b jv ns jy nt kb nu kf nv kj nw kn no np nq nr bi translated"><a class="ae ko" href="https://restfulapi.net/richardson-maturity-model/" rel="noopener ugc nofollow" target="_blank"> REST API教程:Richardson成熟度模型</a></li><li id="7000" class="nj nk hi ju b jv ns jy nt kb nu kf nv kj nw kn no np nq nr bi translated"><a class="ae ko" href="https://developers.redhat.com/blog/2017/09/13/know-how-restful-your-api-is-an-overview-of-the-richardson-maturity-model/" rel="noopener ugc nofollow" target="_blank">了解你的API有多RESTful:RMM概述</a></li></ul></div></div>    
</body>
</html>