<html>
<head>
<title>Creating a serverless API and hosting a frontend with S3 (Detecting Paris’ locked bicycle stations 4/5)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个无服务器的API和托管一个与S3的前端(检测巴黎的锁自行车站4/5)</h1>
<blockquote>原文：<a href="https://medium.com/codex/creating-a-serverless-api-and-hosting-a-frontend-with-s3-b50e61a8f707?source=collection_archive---------2-----------------------#2021-11-14">https://medium.com/codex/creating-a-serverless-api-and-hosting-a-frontend-with-s3-b50e61a8f707?source=collection_archive---------2-----------------------#2021-11-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5fc70548584165bd21df24c0d4723fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gSePhCLa-2aWB7jn"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">亚历山德拉·卡雷托在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="iv iw ix"><p id="1e3f" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这一系列文章是关于我在学习如何使用AWS无服务器堆栈的同时，花了太多时间试图解决一个小问题(检测巴黎上锁的自行车站，见<a class="ae iu" rel="noopener" href="/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-1-95dcdb477649">第一部分</a>)。要查找其他文章，请跳到页面底部。</p></blockquote></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="bd0a" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">UX和API设计</h1><p id="783e" class="pw-post-body-paragraph iy iz hi jb b jc lc je jf jg ld ji jj le lf jm jn lg lh jq jr li lj ju jv jw hb bi translated">在使用DynamoDb流和Lambda函数实现了检测算法之后(参见<a class="ae iu" rel="noopener" href="/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-3-d532318dfca7">第3部分</a>，我需要一个前端来显示结果。一个简单的HTML表列出每个站点的状态就足够了，但是这有什么意思呢？因此，我将创建一个基本但功能强大的应用程序，让任何人都能够找到最近的电台，并查看其当前内容和状态。我还将使用这个应用程序来显示我的管道正在计算的一些统计数据。</p><p id="3063" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">但是在花时间开发之前，我将先做一个简单的模型。对于每个页面，我将尝试定义需要哪个API。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/6ee095ebfee7ed90c6688c0085e940b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUpxIHlDzFHNM5lPOn4-HQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">web应用程序的简单模型，调用相应的API端点。</figcaption></figure><p id="d675" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">最后，我选定了五个主要页面:</p><ul class=""><li id="2875" class="lp lq hi jb b jc jd jg jh le lr lg ls li lt jw lu lv lw lx bi translated"><strong class="jb hj">主页</strong>包含一些关于今天网络使用情况的指标(带有一个更详细的统计页面的链接)和一个最近站点状态变化的列表(从‘OK’变为‘Locked’的站点，反之亦然)。</li><li id="50b7" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated"><strong class="jb hj">统计页面</strong>显示今天的指标和一个比较预测活动和实际活动的图表。我自己会用它来快速监测我的预测有多准。</li><li id="cf79" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated"><strong class="jb hj">地图页面</strong>定位用户和附近的电台，并将其显示在地图上，使用自定义大头针快速查看锁定或不可用的电台。点击一个大头针将重定向到该站的详细信息页面。</li><li id="8d6f" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated"><strong class="jb hj">电台列表页面</strong>允许用户通过搜索框按名称查找特定电台。</li><li id="17e4" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated"><strong class="jb hj">电台详情页面</strong>显示了特定电台的所有信息，包括一个小地图、电台内容详情和一个显示电台当天活动的图表。</li></ul><p id="69ad" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">填充这些页面所需的所有数据可以通过以下端点进行总结。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/65a3acb8d1d823bc5e53f08fda787dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nQedmY6HyaoH2LkoOAbSbA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">web应用程序所需的API端点列表。</figcaption></figure><blockquote class="iv iw ix"><p id="2068" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hj">注</strong>:理想情况下，我会依靠path参数更容易地获得单个站点的活动或预测(例如:GET /activity/{station-code})。但是，关于缓存的成本和技术限制阻止了我这样做。在第5部分中会有更多的介绍。</p></blockquote><h1 id="3641" class="ke kf hi bd kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb bi translated">带API网关的无服务器API</h1><p id="5783" class="pw-post-body-paragraph iy iz hi jb b jc lc je jf jg ld ji jj le lf jm jn lg lh jq jr li lj ju jv jw hb bi translated">让我们从实现API开始。当然，要在web上公开API，您需要某种始终可用的服务器，对吗？</p><p id="fa76" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">不，或者更确切地说，AWS提供了一个解决方案来管理这个问题，您只需要关注当端点被实际调用时会发生什么。这是<a class="ae iu" href="https://aws.amazon.com/api-gateway/?nc1=h_ls" rel="noopener ugc nofollow" target="_blank"> API网关</a>。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/2c4daa58effd5e321175768ef63a2b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AogT8Vqkb-8Gy6mb.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">无耻地从AWS文档中窃取</figcaption></figure><p id="08dc" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">简而言之，API Gateway充当web和您的代码之间的代理。它公开端点，当一个端点被调用时，它触发您选择的服务，转发调用的参数并返回服务决定的任何内容。在我们的例子中，我们只需要触发一个Lambda函数。从Lambda函数的角度来看，它只是另一个事件，有一个特定的<a class="ae iu" href="https://docs.aws.amazon.com/lambda/latest/dg/services-apigateway.html" rel="noopener ugc nofollow" target="_blank">事件负载</a>。</p><p id="20b4" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">因此，让我们创建第一个"<em class="ja"> GET /stations </em>"端点:</p><p id="a035" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">在SAM/CloudFormation模板中，我们需要创建一个新函数，并声明一个“HttpAPI”事件，使用所需的路径和方法，以及对API网关的引用。然后我们必须创建API网关。SAM用<strong class="jb hj"> AWS::Serverless::HttpApi </strong>类型提供了一个更简单的声明，如果需要的话，它主要需要<a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>配置以及对域名和相关参数的引用。这里我用的是自己的<a class="ae iu" href="http://www.velinfo.fr" rel="noopener ugc nofollow" target="_blank"> velinfo.fr </a> (Velinfo，Velib'+info，懂了吗？)域名。更确切地说，我专门为api创建了一个特定的api.velinfo.fr子域。</p><p id="ca64" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">这需要通过AWS <a class="ae iu" href="https://aws.amazon.com/route53/" rel="noopener ugc nofollow" target="_blank"> Route 53 </a>设置一个域名，并创建相应的托管区域和证书，但我不会深入探讨这个话题。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><blockquote class="iv iw ix"><p id="68df" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hj">注意</strong>:实际上API网关有两种SAM类型:<strong class="jb hj"> AWS::Serverless::Api </strong>和<strong class="jb hj"> AWS::Serverless::HttpApi。</strong>它们分别代表<a class="ae iu" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html" rel="noopener ugc nofollow" target="_blank"> RestApi </a>和<a class="ae iu" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html" rel="noopener ugc nofollow" target="_blank"> HttpApi </a>网关。第一个是特性最丰富的，例如有自己的缓存，而第二个是最基本的，但也是性能最好和最便宜的(大约x3)。我在用最后一个。</p></blockquote><p id="ec47" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">Lambda函数与我们已经看到的函数非常相似。主要区别在于，它将一个特定的事件类型作为参数，并且它将返回一个结构化的对象，该对象将包含表示REST响应所需的状态代码、主体和潜在的头。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="8672" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">这里，我没有使用event参数，但是我可以使用它来查找关于这个特定API调用的上下文信息、使用的路径和查询参数等等。</p><p id="f6e2" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">下面是<a class="ae iu" href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/aws-lambda/trigger/api-gateway-proxy.d.ts" rel="noopener ugc nofollow" target="_blank">事件</a>的样子:</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="86dc" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">让我们部署新的端点(照常使用<code class="du mm mn mo mp b">sam deploy</code>)并测试它。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/f5fdc71757d0f97660bf7dab6997af6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QGXhb1JWNYWu4ruzb1o7FA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用邮递员的端点调用。</figcaption></figure><p id="8d9c" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">效果很好！</p><p id="7301" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">我的大多数端点只是暴露了特定DynamoDb表中的内容，所以我将跳过它们的实现。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/22c37946eaa90ae035e00185616c0047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7e3_wt-Z62u_g_vBHFS9fw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">API网关端点以及相关的Lambda函数和DynamoDb表。</figcaption></figure><h1 id="9885" class="ke kf hi bd kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb bi translated">与S3的前端托管</h1><p id="2e67" class="pw-post-body-paragraph iy iz hi jb b jc lc je jf jg ld ji jj le lf jm jn lg lh jq jr li lj ju jv jw hb bi translated">随着API的创建，我可以开始实现前端。由于角度开发不是本文的主题，我将快进一点。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/0f2bab376a5f26fccdf14ff284c932f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*zd21rK1h25qo1ewHvdHB6w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">电台的详细信息页面。目前只有法文版。</figcaption></figure><p id="738d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">对于那些感兴趣的人，我主要依靠<a class="ae iu" href="https://material.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular Material </a>组件库进行基本的造型和结构。我对地图使用了<a class="ae iu" href="https://www.npmjs.com/package/@agm/core" rel="noopener ugc nofollow" target="_blank"> agm </a>(从长远来看，这可能不是最合理的选择，因为谷歌地图的免费计划非常严格),对自定义图表使用了<a class="ae iu" href="http://twitter.com/swimlane/ngx-charts" rel="noopener ugc nofollow" target="_blank"> ngx-charts </a>。</p><p id="151d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">我可以构建我的前端应用程序，并使用Angular CLI生成相应的静态文件:<code class="du mm mn mo mp b">ng build --prod</code></p><p id="abae" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">但是，我该怎么主持呢？显然，我可以在任何一家虚拟主机公司租一台服务器，在那里托管我的应用程序，但这并不是“无服务器”的😉</p><p id="6797" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">在第1部分，我很快谈到了AWS的“简单存储服务”<a class="ae iu" href="https://aws.amazon.com/s3" rel="noopener ugc nofollow" target="_blank"> S3 </a>。</p><p id="6380" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">S3是一个非常有弹性的对象存储服务。对象可以是任何东西，例如. html或. css文件。如果不是一堆静态文件提供给网络浏览器，那么什么是前端应用程序呢？</p><p id="7ee3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">即使虚拟主机最初不是S3的核心功能(它实际上是作为一种存储服务，通过SDK或API来操作对象/文件)，托管静态网站很快成为S3的一个明显的用例，并且推出了<a class="ae iu" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/HostingWebsiteOnS3Setup.html" rel="noopener ugc nofollow" target="_blank">虚拟主机功能</a>。</p><p id="11d6" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">要使用它，我们首先需要定义一个新的S3“bucket”(bucket是S3的一个存储单位，将其视为一个共享文件夹)，并定义一个WebSiteConfiguration来指定索引文档在哪里(在我的例子中，index.html文件位于bucket的根)。我们还需要定义一个访问策略，允许每个人都可以读取bucket的内容。最后，我们需要知道为这个bucket生成的公共URL是什么，所以我将为此添加一个输出。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="bc73" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">为了创建这个bucket，我只需要用SAM: <code class="du mm mn mo mp b">sam deploy</code>部署配置。在操作的最后，我将获得生成的bucket的URL。</p><p id="95f8" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">但是如果我现在调用它，它什么也不返回。这很正常，因为我创建了这个桶，但是我没有在里面放任何东西。我需要使用AWS CLI将我的静态站点内容推到桶中。为此，我将使用AWS CLI。</p><pre class="ll lm ln lo fd mt mp mu mv aw mw bi"><span id="1cb4" class="mx kf hi mp b fi my mz l na nb">#build using angular CLI<br/>ng build --prod</span><span id="fc44" class="mx kf hi mp b fi nc mz l na nb">#clear the bucket content<br/>aws s3 rm s3://velinfo-frontend --recursive</span><span id="bdb8" class="mx kf hi mp b fi nc mz l na nb">#push the new content<br/>aws s3 cp dist/velinfo s3://velinfo-frontend --recursive --cache-control max-age=31536000</span></pre><p id="bf87" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">在浏览器中调用bucket的URL将显示网站，但是API调用失败。这是因为我们的好朋友<a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>阻止了我的API调用，因为我的站点(或桶)的域不是<a class="ae iu" href="https://www.velinfo.fr" rel="noopener ugc nofollow" target="_blank"> https://www.velinfo.fr </a>所以它不在接受的域列表中。</p><p id="e292" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">为了在<a class="ae iu" href="http://www.velinfo.fr," rel="noopener ugc nofollow" target="_blank"> www.velinfo.fr，</a>上正确托管站点，我需要创建一个DNS记录来指向bucket的URL。为此，我可以简单地使用AWS自己的DNS服务(<a class="ae iu" href="https://aws.amazon.com/route53/" rel="noopener ugc nofollow" target="_blank"> Route53 </a>)并添加一个CNAME记录。</p><p id="4a45" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">现在，成功了！</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/947978acdb82bd2ab37251ec4c157c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCD9ImGVAUV8rtXBhjHsoQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">网站托管在<a class="ae iu" href="https://velinfo.fr" rel="noopener ugc nofollow" target="_blank"> https://www.velinfo.fr </a></figcaption></figure><h1 id="6d85" class="ke kf hi bd kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb bi translated">架构摘要</h1><p id="69b3" class="pw-post-body-paragraph iy iz hi jb b jc lc je jf jg ld ji jj le lf jm jn lg lh jq jr li lj ju jv jw hb bi translated">所以，让我们回顾一下当我访问我的网站时会发生什么:</p><ul class=""><li id="fa73" class="lp lq hi jb b jc jd jg jh le lr lg ls li lt jw lu lv lw lx bi translated"><a class="ae iu" href="http://www.velinfo.fr" rel="noopener ugc nofollow" target="_blank"> <strong class="jb hj"> www.velinfo.fr </strong> </a>域名指向<strong class="jb hj"> velinfo-frontend </strong> S3桶，使用由Route53管理的DNS记录</li><li id="4587" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated"><strong class="jb hj"> velinfo-frontend </strong> bucket被配置为作为网站提供其内容</li><li id="8d77" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated">前端应用程序使用Angular CLI构建，并使用AWS CLI推送到bucket</li><li id="5147" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated">前端应用程序从<strong class="jb hj"> api.velinfo.fr </strong> REST API获取数据</li><li id="2669" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated"><strong class="jb hj"> api.velinfo.fr </strong>使用路由53中管理的DNS记录指向api网关</li><li id="3f95" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated">API网关触发对应于被调用端点的Lambda函数，并向它提供关于调用的所有信息</li><li id="b2bf" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated">Lambda函数调用相应的DynamoDb表</li><li id="3a7d" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated">Lambda函数返回表示状态代码、标题和主体的特定输出。所有这些都由API网关转发回调用者。</li><li id="4a3a" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated">整个基础设施在SAM/CloudFormation模板中定义</li></ul><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/3b15b20028725d782f156082960cfc99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CSm0RQVsboIQ42ILHaZXCg.png"/></div></div></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="755d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">API和web应用程序现在已经完成。但是在结束这个系列之前，我想解决最后一件事:性能。</p><p id="0ec3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">第5部分再见！</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><ul class=""><li id="4884" class="lp lq hi jb b jc jd jg jh le lr lg ls li lt jw lu lv lw lx bi translated"><a class="ae iu" rel="noopener" href="/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-1-95dcdb477649">第1部分</a>:为原型选择AWS无服务器堆栈</li><li id="19fa" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated"><a class="ae iu" href="https://ouvreboite.medium.com/detecting-locked-bicycle-stations-an-aws-serverless-story-part-2-b1967d639699" rel="noopener">第2部分</a>:无服务器应用的主干:Lambda函数和DynamoDb表</li><li id="2e16" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated"><a class="ae iu" rel="noopener" href="/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-3-d532318dfca7">第3部分</a>:用Lambda函数和DynamoDb流实现实时检测算法</li><li id="b36a" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated"><a class="ae iu" href="https://ouvreboite.medium.com/creating-a-serverless-api-and-hosting-a-frontend-with-s3-b50e61a8f707" rel="noopener">第4部分</a>:创建一个无服务器的API，用S3托管一个前端</li><li id="b2f1" class="lp lq hi jb b jc ly jg lz le ma lg mb li mc jw lu lv lw lx bi translated">第5部分:基于Lambda的API的性能调优</li></ul></div></div>    
</body>
</html>