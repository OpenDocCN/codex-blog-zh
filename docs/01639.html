<html>
<head>
<title>Running Concurrent Requests with async/await and Promise.all</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用async/await和Promise.all运行并发请求</h1>
<blockquote>原文：<a href="https://medium.com/codex/running-concurrent-requests-with-async-await-and-promise-all-daaca1b5da4d?source=collection_archive---------4-----------------------#2021-05-18">https://medium.com/codex/running-concurrent-requests-with-async-await-and-promise-all-daaca1b5da4d?source=collection_archive---------4-----------------------#2021-05-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="c940" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="44b4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这篇文章中，我想谈谈JavaScript中的async、await和Promise.all。首先，我将讨论并发性与并行性，以及为什么我们将在本文中关注并行性。然后，我将讨论如何使用async和await以串行方式实现并行算法，以及如何通过使用Promise.all使其并行工作。最后，我将使用Salesforce的Lightning Web组件创建一个示例项目，其中我将使用哈佛的Art Gallery API构建一个艺术画廊。</p><h1 id="141a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">并发性与并行性</h1><p id="1620" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我想简单介绍一下并发性和并行性之间的区别。您可以将并发性与单线程CPU处理多个任务的方式联系起来。单线程CPU通过在进程之间快速切换来模拟并行性，就好像多件事情同时发生一样。并行性是指一个CPU拥有多个内核，实际上可以同时运行两个任务。另一个很好的例子是:</p><blockquote class="kb kc kd"><p id="8bb4" class="jd je ke jf b jg kf ji jj jk kg jm jn kh ki jq jr kj kk ju jv kl km jy jz ka hb bi translated"><em class="hi">并发是两列客户从一个收银台下单(各列轮流下单)；并行是两列顾客从两个收银员处订购(每列有自己的收银员)。[1] </em></p></blockquote><p id="28dc" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">了解这种差异有助于我们从算法的角度考虑我们有哪些选择。我们的目标是并行处理这些HTTP请求。由于JavaScript实现和浏览器可变性的一些限制，我们实际上无法确定我们的算法是并发运行还是并行运行。幸运的是，我根本不需要改变我们的算法。底层的JavaScript事件循环将使代码看起来像是并行运行的，这对于本文来说已经足够好了！</p><h1 id="f10f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">串行异步/等待</h1><p id="2e18" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了理解这个<em class="ke">并行</em>算法，我将首先使用async和await来构建一个<em class="ke">串行</em>算法。如果您在IDE中编写这段代码，您可能会收到一个通知，说在循环中使用await是一个错过的优化机会<em class="ke"> — </em>，而您的IDE将是正确的。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="f2a4" class="kw ig hi ks b fi kx ky l kz la">(async () =&gt; {<br/>	const urls = [<br/>		"https://example.com/posts/1/",<br/>		"https://example.com/posts/1/tags/",<br/>	];<br/>	<br/>	const data = [];<br/>  for (url of urls) {<br/>    await fetch(url)<br/>      .then((response) =&gt; response.json())<br/>      .then((jsonResponse) =&gt; data.push(jsonResponse));<br/>  }</span><span id="796d" class="kw ig hi ks b fi lb ky l kz la">  console.log(data);<br/>})();</span></pre><p id="fb79" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">您可能实现这样的算法的一个原因是，如果您需要从两个不同的URL获取数据，然后将这些数据混合在一起以创建您的最终对象。在上面的代码中，您可以想象我们正在收集一些关于帖子的数据，然后获取关于帖子标签的数据，最后将这些数据合并到您以后实际使用的对象中。</p><p id="f852" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">虽然这段代码可以工作，但是您可能会注意到我们在每次读取时都使用了<code class="du lc ld le ks b">await</code>。您会看到类似这样的内容:</p><ul class=""><li id="bd19" class="lf lg hi jf b jg kf jk kg jo lh js li jw lj ka lk ll lm ln bi translated">开始去拿一号杆</li><li id="5e13" class="lf lg hi jf b jg lo jk lp jo lq js lr jw ls ka lk ll lm ln bi translated">等待提取第一步完成</li><li id="c414" class="lf lg hi jf b jg lo jk lp jo lq js lr jw ls ka lk ll lm ln bi translated">获得帖子一回复</li><li id="365f" class="lf lg hi jf b jg lo jk lp jo lq js lr jw ls ka lk ll lm ln bi translated">开始获取后一个标签</li><li id="7d02" class="lf lg hi jf b jg lo jk lp jo lq js lr jw ls ka lk ll lm ln bi translated">等待张贴一个标签完成</li><li id="a179" class="lf lg hi jf b jg lo jk lp jo lq js lr jw ls ka lk ll lm ln bi translated">获得张贴一个标签响应</li></ul><p id="4bf1" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">问题是，在开始下一个请求之前，我们一直在等待每个网络请求完成。没有必要这样做:计算机完全有能力同时执行多个网络请求。</p><p id="b17b" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">那么如何才能让这个算法更好呢？</p><h1 id="4605" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">异步/并行等待</h1><p id="d2fd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让这个算法更快的最简单的方法是删除<code class="du lc ld le ks b">fetch</code>命令前的<code class="du lc ld le ks b">await</code>关键字。这将告诉JavaScript开始并行执行所有请求。但是为了暂停执行并等待所有的承诺返回，我们需要等待一些东西。我们将使用<code class="du lc ld le ks b">Promise.all</code>来做到这一点。</p><p id="2d74" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">当我们使用<code class="du lc ld le ks b">await Promise.all</code>时，JavaScript将等待传递给<code class="du lc ld le ks b">Promise.all</code>的整个承诺数组进行解析。只有这样，它才会同时返回所有结果。重写看起来像这样:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="d489" class="kw ig hi ks b fi kx ky l kz la">(async () =&gt; {<br/>    const urls = [<br/>        "https://example.com/posts/1/",<br/>        "https://example.com/posts/1/tags/",<br/>    ];<br/>	<br/>    const promises = urls.map((url) =&gt;<br/>        fetch(url).then((response) =&gt; response.json())<br/>    );</span><span id="263c" class="kw ig hi ks b fi lb ky l kz la">    const data = await Promise.all(promises);</span><span id="00ec" class="kw ig hi ks b fi lb ky l kz la">    console.log(data);<br/>})();</span></pre><p id="83d1" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">这段代码将每个URL映射到一个<code class="du lc ld le ks b">promise</code>，然后映射到<code class="du lc ld le ks b">await</code>，以完成所有的承诺。现在，当我们传递代码的<code class="du lc ld le ks b">await Promise.all</code>部分时，我们可以确定两个获取请求都已解决，并且响应在数据数组中的正确位置。因此<code class="du lc ld le ks b">data[0]</code>将是我们的文章数据，而<code class="du lc ld le ks b">data[1]</code>将是我们的标签数据。</p><h1 id="a48d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">一个例子</h1><p id="21ff" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们已经有了实现预取图像库的所有必要的构建块，让我们来构建它。</p><p id="321f" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">下面是我为本文构建的应用程序的截图，这里是关于哈佛艺术博物馆API文档的链接。如果你想继续下去，你需要申请你自己的API密匙。这个过程对我来说似乎很自动，因为你只需填写一个谷歌表格，然后立即在你的电子邮件中收到你的API密匙。</p><figure class="kn ko kp kq fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lu"><img src="../Images/ac8740b62d886e062d5c4982866fdf20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Gy4It1GP29PVgWjQ.png"/></div></div></figure><p id="bbef" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">它看起来不怎么样，但是当你浏览图库时，它会自动预取下一页的数据。这样，查看图库的用户就不会看到实际数据的任何加载时间。图像只有在页面上显示时才会被加载。虽然这些是事后加载的，但是页面的实际数据是即时加载的，因为它缓存在组件中。最后，作为对自己的一个挑战，我在这个项目中使用了Salesforce的Lightning Web组件<em class="ke"> — </em>对我来说是一项全新的技术。让我们开始构建组件。</p><p id="03b8" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">以下是我在学习Lightning Web组件时使用的一些资源。如果您想继续，那么您至少需要设置您的本地开发环境并创建一个“hello world”Lightning Web组件。</p><p id="ee58" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated"><a class="ae lt" href="https://trailhead.salesforce.com/content/learn/projects/quick-start-lightning-web-components/set-up-salesforce-dx" rel="noopener ugc nofollow" target="_blank">建立本地开发环境</a> [3]</p><p id="a380" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated"><a class="ae lt" href="https://trailhead.salesforce.com/content/learn/projects/quick-start-lightning-web-components/create-a-hello-world-lightning-web-component" rel="noopener ugc nofollow" target="_blank">创建一个Hello World Lightning Web组件</a> [4]</p><p id="3fb4" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated"><a class="ae lt" href="https://trailhead.salesforce.com/sample-gallery" rel="noopener ugc nofollow" target="_blank"> LWC样品画廊</a>【5】</p><p id="a0bf" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated"><a class="ae lt" href="https://developer.salesforce.com/docs/component-library/overview/components" rel="noopener ugc nofollow" target="_blank"> LWC组件参考</a>【6】</p><p id="2523" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">好了，现在你的环境设置好了，你已经创建了你的第一个LWC，让我们开始吧。顺便说一下，本文的所有代码都可以在<a class="ae lt" href="https://github.com/bloveless/AsyncAwaitPromiseAllLWC" rel="noopener ugc nofollow" target="_blank">my GitHub repo</a>【7】中找到。</p><p id="1768" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">一个小题外话:如果您来自React背景，那么Lightning Web组件比您可能习惯的组件要稍微受限一些。例如，在以下示例中，您不能在组件属性(即图像src)中使用JavaScript表达式:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="ffdb" class="kw ig hi ks b fi kx ky l kz la">&lt;template for:each={records} for:item="record"&gt;<br/>    &lt;img src={record.images[0].baseimageurl}&gt;<br/>&lt;/template&gt;</span></pre><p id="fa7b" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">原因是，当您将所有代码都放在JavaScript文件中而不是HTML模板文件中时，您的代码会变得更容易测试。所以，让我们把这记在“更适合测试”的帐上，继续我们的生活。</p><p id="3c12" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">为了创建这个图库，我们需要构建两个组件。第一个组件用于显示每个图库图像，第二个组件用于预取和分页。</p><p id="794f" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">第一个组件是两个组件中较简单的一个。在VSCode中，执行命令<code class="du lc ld le ks b">SFDX: Create Lightning Web Component</code>并将组件命名为<code class="du lc ld le ks b">harvardArtMuseumGalleryItem</code>。这将为我们创建三个文件:一个HTML、JavaScript和XML文件。该组件不需要对XML文件进行任何更改，因为项目本身在任何Salesforce管理页面中都不可见。</p><p id="63b2" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">接下来，将HTML文件的内容更改为以下内容:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="7b84" class="kw ig hi ks b fi kx ky l kz la"># force-app/main/default/lwc/harvardArtMuseumGalleryItem/harvardArtMuseumGalleryItem.html</span><span id="7358" class="kw ig hi ks b fi lb ky l kz la">&lt;template&gt;<br/>    &lt;div class="gallery-item" style={backgroundStyle}&gt;&lt;/div&gt;<br/>    {title}<br/>&lt;/template&gt;</span></pre><p id="b184" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">注意，在这个HTML文件中，样式属性被设置为<code class="du lc ld le ks b">{backgroundStyle}</code>，这是我们的JavaScript文件中的一个函数，所以让我们来处理它。</p><p id="3e8e" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">将JS文件的内容更改为以下内容:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="d066" class="kw ig hi ks b fi kx ky l kz la"># force-app/main/default/lwc/harvardArtMuseumGalleryItem/harvardArtMuseumGalleryItem.js</span><span id="04a0" class="kw ig hi ks b fi lb ky l kz la">import { LightningElement, api } from 'lwc';</span><span id="73a2" class="kw ig hi ks b fi lb ky l kz la">export default class HarvardArtMuseumGalleryItem extends LightningElement {<br/>    @api<br/>    record;</span><span id="434f" class="kw ig hi ks b fi lb ky l kz la">    get image() {<br/>        if (this.record.images &amp;&amp; this.record.images.length &gt; 0) {<br/>            return this.record.images[0].baseimageurl;<br/>        }</span><span id="8e6f" class="kw ig hi ks b fi lb ky l kz la">        return "";<br/>    }</span><span id="5f69" class="kw ig hi ks b fi lb ky l kz la">    get title() {<br/>        return this.record.title;<br/>    }</span><span id="2061" class="kw ig hi ks b fi lb ky l kz la">    get backgroundStyle() {<br/>        return `background-image:url('${this.image}');`<br/>    }<br/>}</span></pre><p id="14b5" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">这里有几点需要注意。首先，record属性用<code class="du lc ld le ks b">@api</code>修饰，这允许我们从其他组件向该属性赋值。请留意主图库组件上的这个记录属性。此外，因为我们不能在HTML文件中使用JavaScript表达式，所以我也将背景图片内嵌到了JavaScript文件中。这允许我对图像使用字符串插值。image函数没什么特别的，因为它是<em class="ke"> — </em>只是我从哈佛艺术画廊API接收的记录中获取第一个图像URL的简单方法。</p><p id="adee" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">这个组件的最后一步是添加一个不是自动为我们创建的CSS文件。所以在harvardArtMuseumGalleryItem目录中创建<code class="du lc ld le ks b">harvardArtMuseumGalleryItem.css</code>。您不需要告诉应用程序使用这个文件，因为它的存在会自动包含它。</p><p id="1d5d" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">将新创建的CSS文件的内容更改为以下内容:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="d26b" class="kw ig hi ks b fi kx ky l kz la"># force-app/main/default/lwc/harvardArtMuseumGalleryItem/harvardArtMuseumGalleryItem.css</span><span id="3aa2" class="kw ig hi ks b fi lb ky l kz la">.gallery-item {<br/>    height: 150px;<br/>    width: 100%;<br/>    background-size: cover;<br/>}</span></pre><p id="eecf" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">既然我们繁忙的工作已经结束，我们可以去真正的画廊了。</p><p id="2f92" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">再次在VSCode中运行<code class="du lc ld le ks b">SFDX: Create Lightning Web Component</code>，并将组件命名为<code class="du lc ld le ks b">harvardArtMuseumGallery</code>。这将再次生成我们的HTML、JavaScript和XML文件。这次我们需要密切关注XML文件。XML文件告诉Salesforce允许我们的组件位于何处，以及我们将如何在组件中存储我们的API密钥。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="3cd2" class="kw ig hi ks b fi kx ky l kz la"># force-app/main/default/lwc/harvardArtMuseumGallery/harvardArtMuseumGallery.js-meta.xml</span><span id="ef6c" class="kw ig hi ks b fi lb ky l kz la">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;LightningComponentBundle &gt;<br/>    &lt;apiVersion&gt;51.0&lt;/apiVersion&gt;<br/>    &lt;isExposed&gt;true&lt;/isExposed&gt;<br/>    &lt;targets&gt;<br/>        &lt;target&gt;lightning__HomePage&lt;/target&gt;<br/>    &lt;/targets&gt;<br/>    &lt;targetConfigs&gt;<br/>        &lt;targetConfig targets="lightning__HomePage"&gt;<br/>            &lt;property name="harvardApiKey" type="String" default=""&gt;&lt;/property&gt;<br/>        &lt;/targetConfig&gt;<br/>    &lt;/targetConfigs&gt;<br/>&lt;/LightningComponentBundle&gt;</span></pre><p id="0b5b" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">在这个XML文件中，有三件关键的事情需要注意。第一个是<code class="du lc ld le ks b">isExposed</code>，它将允许我们的组件在Salesforce admin中找到。第二个是<code class="du lc ld le ks b">target</code>，它表示我们的组件可以在Salesforce站点的哪些区域使用。这表明我们允许我们的组件显示在主页类型的页面上。最后，在添加组件时，<code class="du lc ld le ks b">targetConfigs</code>部分会显示一个文本框。在那里，我们可以粘贴我们的API密钥(如下图所示)。你可以在这里找到关于这个XML文件<a class="ae lt" href="https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_lightningcomponentbundle.htm" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></p><figure class="kn ko kp kq fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mc"><img src="../Images/003f0fdf721aae0be6617f93295574fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2a1gPSa3HtiMcm_0.png"/></div></div></figure><p id="be5a" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">接下来，让我们来处理HTML和CSS文件。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="1d51" class="kw ig hi ks b fi kx ky l kz la"># force-app/main/default/lwc/harvardArtMuseumGallery/harvardArtMuseumGallery.html</span><span id="776d" class="kw ig hi ks b fi lb ky l kz la">&lt;template&gt;<br/>    &lt;lightning-card title="HelloWorld" icon-name="custom:custom14"&gt;<br/>        &lt;div class="slds-m-around_medium"&gt;<br/>          &lt;h1&gt;Harvard Gallery&lt;/h1&gt;<br/>          &lt;div class="gallery-container"&gt;<br/>            &lt;template for:each={records} for:item="record"&gt;<br/>              &lt;div key={record.index} class="row"&gt;<br/>                &lt;template for:each={record.value} for:item="item"&gt;<br/>                  &lt;c-harvard-art-museum-gallery-item if:true={item} key={item.id} record={item}&gt;&lt;/c-harvard-art-museum-gallery-item&gt;<br/>                &lt;/template&gt;<br/>              &lt;/div&gt;<br/>            &lt;/template&gt;<br/>          &lt;/div&gt;<br/>          &lt;div class="pagination-container"&gt;<br/>            &lt;button type="button" onclick={previousPage}&gt;&amp;lt;&lt;/button&gt;<br/>            &lt;span class="current-page"&gt;<br/>              {currentPage}<br/>            &lt;/span&gt;<br/>            &lt;button type="button" onclick={nextPage}&gt;&amp;gt;&lt;/button&gt;<br/>          &lt;/div&gt;<br/>        &lt;/div&gt;<br/>      &lt;/lightning-card&gt;<br/>&lt;/template&gt;</span></pre><p id="728a" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">其中大部分是带有一些定制组件的标准HTML。我最想让你注意的一行是<c-harvard-art-museum-gallery-item>标签和它的记录属性。您会记得这是我们在gallery item JavaScript文件中用<code class="du lc ld le ks b">@api</code>修饰的属性。<code class="du lc ld le ks b">@api</code>装饰允许我们通过该属性传递记录。</c-harvard-art-museum-gallery-item></p><p id="6481" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">接下来，在CSS文件上:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="3e97" class="kw ig hi ks b fi kx ky l kz la"># force-app/main/default/lwc/harvardArtMuseumGallery/harvardArtMuseumGallery.css</span><span id="a23e" class="kw ig hi ks b fi lb ky l kz la">h1 {<br/>  font-size: 2em;<br/>  font-weight: bolder;<br/>  margin-bottom: .5em;<br/>}</span><span id="4d4f" class="kw ig hi ks b fi lb ky l kz la">.gallery-container .row {<br/>  display: flex;<br/>}</span><span id="2118" class="kw ig hi ks b fi lb ky l kz la">c-harvard-art-museum-gallery-item {<br/>  margin: 1em;<br/>  flex-grow: 1;<br/>  width: calc(25% - 2em);<br/>}</span><span id="fa71" class="kw ig hi ks b fi lb ky l kz la">.pagination-container {<br/>  text-align: center;<br/>}</span><span id="9916" class="kw ig hi ks b fi lb ky l kz la">.pagination-container .current-page {<br/>  display: inline-block;<br/>  margin: 0 .5em;<br/>}</span></pre><p id="3d11" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">我把最有趣的留到了最后！JavaScript文件包括我们的预取逻辑和页面滚动算法。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="7208" class="kw ig hi ks b fi kx ky l kz la"># force-app/main/default/lwc/harvardArtMuseumGallery/harvardArtMuseumGallery.js</span><span id="c8bc" class="kw ig hi ks b fi lb ky l kz la">import { LightningElement, api } from "lwc";</span><span id="a78f" class="kw ig hi ks b fi lb ky l kz la">const BASE_URL =<br/>  "https://api.harvardartmuseums.org/object?apikey=$1&amp;size=8&amp;hasimage=1&amp;page=$2";</span><span id="13a1" class="kw ig hi ks b fi lb ky l kz la">export default class HarvardArtMuseumGallery extends LightningElement {<br/>  @api harvardApiKey;</span><span id="a71a" class="kw ig hi ks b fi lb ky l kz la">  error;<br/>  records;<br/>  currentPage = 1;<br/>  pagesCache = [];</span><span id="76b7" class="kw ig hi ks b fi lb ky l kz la">  chunkArray(array, size) {<br/>    let result = [];<br/>    for (let value of array) {<br/>      let lastArray = result[result.length - 1];<br/>      if (!lastArray || lastArray.length === size) {<br/>        result.push([value]);<br/>      } else {<br/>        lastArray.push(value);<br/>      }<br/>    }</span><span id="5a41" class="kw ig hi ks b fi lb ky l kz la">    return result.map((item, index) =&gt; ({ value: item, index: index }));<br/>  }</span><span id="7de5" class="kw ig hi ks b fi lb ky l kz la">  nextPage() {<br/>    this.currentPage++;<br/>    this.changePage(this.currentPage);<br/>  }</span><span id="6a85" class="kw ig hi ks b fi lb ky l kz la">  previousPage() {<br/>    if (this.currentPage &gt; 1) {<br/>      this.currentPage--;<br/>      this.changePage(this.currentPage);<br/>    }<br/>  }</span><span id="1942" class="kw ig hi ks b fi lb ky l kz la">  connectedCallback() {<br/>    this.changePage(1);<br/>  }</span><span id="44b0" class="kw ig hi ks b fi lb ky l kz la">  async changePage(page) {<br/>    let lowerBound = ((page - 3) &lt; 0) ? 0 : page - 3;<br/>    const upperBound = page + 3;</span><span id="d03a" class="kw ig hi ks b fi lb ky l kz la">    // Cache the extra pages<br/>    const promises = [];<br/>    for (let i = lowerBound; i &lt;= upperBound; i++) {<br/>      promises.push(this.getRecords(i));<br/>    }</span><span id="896a" class="kw ig hi ks b fi lb ky l kz la">    Promise.all(promises).then(() =&gt; console.log('finished caching pages'));</span><span id="5110" class="kw ig hi ks b fi lb ky l kz la">    // Now this.pages has all the data for the current page and the next/previous pages<br/>    // The idea is that we will start the previous promises in order to prefrech the pages<br/>    // and here we will wait for the current page to either be delivered from the cache or<br/>    // the api call<br/>    this.records = await this.getRecords(page);<br/>  }</span><span id="bac7" class="kw ig hi ks b fi lb ky l kz la">  async getRecords(page) {<br/>    if (page in this.pagesCache) {<br/>      return Promise.resolve(this.pagesCache[page]);<br/>    }</span><span id="9ae7" class="kw ig hi ks b fi lb ky l kz la">    const url = BASE_URL.replace("$1", this.harvardApiKey).replace("$2", page);<br/>    return fetch(url)<br/>      .then((response) =&gt; {<br/>        if (!response.ok) {<br/>          this.error = response;<br/>        }</span><span id="270c" class="kw ig hi ks b fi lb ky l kz la">        return response.json();<br/>      })<br/>      .then((responseJson) =&gt; {<br/>        this.pagesCache[page] = this.chunkArray(responseJson.records, 4);<br/>        return this.pagesCache[page];<br/>      })<br/>      .catch((errorResponse) =&gt; {<br/>        this.error = errorResponse;<br/>      });<br/>  }<br/>}</span></pre><p id="5411" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">请注意，我们正在用<code class="du lc ld le ks b">@api</code>装饰harvardApiKey。这就是我们XML文件中的<code class="du lc ld le ks b">targetConfig</code>属性被注入到组件中的方式。这个文件中的大部分代码都有助于改变页面和分块响应，这样我们就可以获得包含四个图库条目的行。注意<code class="du lc ld le ks b">changePage</code>和<code class="du lc ld le ks b">getRecords</code>:这就是神奇发生的地方。首先，注意<code class="du lc ld le ks b">changePage</code>根据当前请求的页面计算页面范围。如果当前请求的页面是第五页，那么我们将缓存从第二页到第八页的所有页面。然后我们在页面上循环，为每一页创建一个承诺。</p><p id="c05b" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">最初，我认为我们需要在<code class="du lc ld le ks b">Promise.all</code>上<code class="du lc ld le ks b">await</code>，以避免两次加载一个页面。但是后来我意识到，为了不等待所有的页面从API返回，这是一个很低的代价。所以目前的算法如下:</p><ol class=""><li id="e014" class="lf lg hi jf b jg kf jk kg jo lh js li jw lj ka md ll lm ln bi translated">用户请求第五页。</li><li id="fd3d" class="lf lg hi jf b jg lo jk lp jo lq js lr jw ls ka md ll lm ln bi translated">从第二页到第八页计算界限，并为这些请求创建承诺。</li><li id="b16f" class="lf lg hi jf b jg lo jk lp jo lq js lr jw ls ka md ll lm ln bi translated">因为我们不等待承诺返回，所以我们将再次请求第五页，并发出一个额外的API请求(但这只发生在不在缓存中的页面)。</li><li id="101e" class="lf lg hi jf b jg lo jk lp jo lq js lr jw ls ka md ll lm ln bi translated">假设用户前进到第六页。</li><li id="6bd9" class="lf lg hi jf b jg lo jk lp jo lq js lr jw ls ka md ll lm ln bi translated">从第三页到第九页计算界限，并为这些请求创建承诺。</li><li id="3292" class="lf lg hi jf b jg lo jk lp jo lq js lr jw ls ka md ll lm ln bi translated">因为我们在缓存中已经有了第二页到第八页，并且因为我们没有等待那些承诺，所以当第九页的承诺实现时，第六页将立即从缓存中加载(因为它是缓存中唯一丢失的页)。</li></ol><h1 id="2319" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="8fdc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在你知道了！我们探讨了并发性和并行性。我们学习了如何在串行中构建一个async/await流(这是您永远不应该做的)。然后，我们将串行流升级为并行流，并学习了如何在继续之前等待所有承诺解决。最后，我们使用async/await和<code class="du lc ld le ks b">Promise.all</code>为哈佛艺术博物馆构建了一个Lightning Web组件。(尽管在这种情况下，我们不需要<code class="du lc ld le ks b">Promise.all</code>，因为如果我们不等待所有承诺都解决后再继续，算法会工作得更好。)</p><p id="6df3" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">感谢您的阅读，欢迎在下面留下任何评论和问题。</p><p id="ecb1" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">引用:</p><p id="900a" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">[1]<a class="ae lt" href="https://stackoverflow.com/questions/1050222/what-is-the-difference-between-concurrency-and-parallelism" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/1050222/什么是并发与并行的区别</a></p><p id="1aee" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">[2]<a class="ae lt" href="https://github.com/harvardartmuseums/api-docs" rel="noopener ugc nofollow" target="_blank">https://github.com/harvardartmuseums/api-docs</a></p><p id="c162" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">[3]<a class="ae lt" href="https://trailhead.salesforce.com/content/learn/projects/quick-start-lightning-web-components/set-up-salesforce-dx" rel="noopener ugc nofollow" target="_blank">https://trail head . sales force . com/content/learn/projects/quick-start-lightning-web-components/set-up-sales force-dx</a></p><p id="7391" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">[4]<a class="ae lt" href="https://trailhead.salesforce.com/content/learn/projects/quick-start-lightning-web-components/create-a-hello-world-lightning-web-component" rel="noopener ugc nofollow" target="_blank">https://trail head . sales force . com/content/learn/projects/quick-start-lightning-web-components/create-a-hello-world-lightning-web-component</a></p><p id="89ea" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">[5]<a class="ae lt" href="https://trailhead.salesforce.com/sample-gallery" rel="noopener ugc nofollow" target="_blank">https://trailhead.salesforce.com/sample-gallery</a></p><p id="69de" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">[6]<a class="ae lt" href="https://developer.salesforce.com/docs/component-library/overview/components" rel="noopener ugc nofollow" target="_blank">https://developer . sales force . com/docs/component-library/overview/components</a></p><p id="7a12" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated"><a class="ae lt" href="https://github.com/bloveless/AsyncAwaitPromiseAllLWC" rel="noopener ugc nofollow" target="_blank">https://github.com/bloveless/AsyncAwaitPromiseAllLWC</a></p><p id="bc1a" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo ki jq jr js kk ju jv jw km jy jz ka hb bi translated">[8]<a class="ae lt" href="https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_lightningcomponentbundle.htm" rel="noopener ugc nofollow" target="_blank">https://developer . sales force . com/docs/atlas . en-us . API _ meta . meta/API _ meta/meta _ lightning component bundle . htm</a></p></div></div>    
</body>
</html>