<html>
<head>
<title>Background Job &amp; Queue — Pushing Millions of Notifications per Hour</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">后台作业和队列—每小时推送数百万条通知</h1>
<blockquote>原文：<a href="https://medium.com/codex/background-job-queue-pushing-millions-of-notifications-per-hour-d589a57060db?source=collection_archive---------2-----------------------#2021-01-30">https://medium.com/codex/background-job-queue-pushing-millions-of-notifications-per-hour-d589a57060db?source=collection_archive---------2-----------------------#2021-01-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="78cb" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><p id="d453" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">在本文中，我给出了一个将后台作业和队列模型应用到实际系统的案例研究。鉴于目前的系统架构，提出了一个改进版本，并将从不同方面提供设计这种系统的细节。如果整个内容没有多大意义，我强烈建议按照以下顺序阅读我的其他文章:</p><ul class=""><li id="8e23" class="jm jn hi iq b ir is iv iw iz jo jd jp jh jq jl jr js jt ju bi translated"><a class="ae jv" rel="noopener" href="/swlh/background-job-and-queue-conceptual-and-practical-8d075096ec86">概念性和实用性</a></li><li id="351b" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated"><a class="ae jv" rel="noopener" href="/swlh/background-job-and-queue-practical-application-use-cases-8cd1cc83afdf">实际应用用例</a></li><li id="291c" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated"><a class="ae jv" href="https://suhoangtuan.medium.com/background-job-and-queue-concurrency-and-ordering-b892bcfc1761" rel="noopener">并发和执行顺序问题</a></li></ul><h1 id="2f97" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">投入</h1><p id="9035" class="pw-post-body-paragraph io ip hi iq b ir kz it iu iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl hb bi translated">用Python和MySQL编写的通知系统有几个性能问题，即</p><ul class=""><li id="4070" class="jm jn hi iq b ir is iv iw iz jo jd jp jh jq jl jr js jt ju bi translated">降低服务速度的延迟</li><li id="e1bb" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated">高峰时段的高服务需求，导致推送通知的丢失</li><li id="0564" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated">由于大量的呼叫请求，与连接到Firebase相关的失败率很高。</li><li id="d866" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated">令牌管理效率低下，重复和许多非活动令牌会减慢<em class="le">推送</em>流程</li><li id="2eb2" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated">数据库中的数据很难标准化，因此每个<em class="le"> push </em>请求都需要连接3个表。</li><li id="f434" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated">就CPU和RAM而言，浪费了资源</li></ul><p id="db50" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">此外，系统不跟踪<em class="le">推送</em>请求的成功率，也不跟踪其他服务的成功率。下图显示了当前的架构。收到请求后，系统的<strong class="iq hs"> Push API </strong>将从<strong class="iq hs">令牌库</strong>获取请求用户的令牌列表，并将<em class="le"> push </em>请求发送给Firebase API。就是这样。</p><figure class="lg lh li lj fd lk er es paragraph-image"><div class="er es lf"><img src="../Images/335246e058ddf5946b55913eea77ab90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*qTKUmFA3byhy23kyt18xLA.png"/></div></figure><h1 id="dc7d" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">解决办法</h1><p id="6651" class="pw-post-body-paragraph io ip hi iq b ir kz it iu iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl hb bi translated">下面是采用队列和后台作业的新设计:</p><figure class="lg lh li lj fd lk er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ln"><img src="../Images/9bb4bfb370a6da90008aaa2d22d08a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QdcPAeMO9Whq7AqLuwMGQg.png"/></div></div></figure><h2 id="afc7" class="ls kc hi bd kd lt lu lv kh lw lx ly kl iz lz ma kp jd mb mc kt jh md me kx ho bi translated">数据库和API设计</h2><p id="b23a" class="pw-post-body-paragraph io ip hi iq b ir kz it iu iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl hb bi translated">基本上，数据库将存储2个主要数据:</p><ul class=""><li id="f08b" class="jm jn hi iq b ir is iv iw iz jo jd jp jh jq jl jr js jt ju bi translated">用户的<strong class="iq hs">推送令牌</strong>:更新更少，列表读取更多，大量与设备或操作系统信息相关的额外数据。</li><li id="6652" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated"><strong class="iq hs">带日志信息的推送日志</strong>和<em class="le">推送</em>结果频繁插入和更新而读取较少。</li></ul><p id="5d5e" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">根据对数据特征的观察，数据库从MySQL迁移到MongoDB，这样我们就可以在记录的插入/更新操作中利用更好的MongoDB性能。</p><p id="addd" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs"> Push API </strong>负责接收来自其他服务的请求流量。因此，为了加快流程并缩短服务等待时间，整个消息流简化如下:</p><ul class=""><li id="dd58" class="jm jn hi iq b ir is iv iw iz jo jd jp jh jq jl jr js jt ju bi translated">插入<em class="le">推</em>日志到数据库</li><li id="5fd3" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated">从数据库查询用户的令牌</li><li id="9981" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated">基于令牌列表构建一个<em class="le">推送</em>请求</li><li id="193e" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated">调用Firebase API</li><li id="b04f" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated">更新对数据库的<em class="le">推送</em>请求的响应</li></ul><p id="bc88" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">你可以看到，通过将一些功能移出<strong class="iq hs">推送API </strong>，并重新设计数据库，有3个问题与<strong class="iq hs"> API延迟</strong>、<strong class="iq hs">令牌管理、</strong>和<strong class="iq hs">为每个请求</strong>获取令牌的性能相关。</p><h2 id="2f75" class="ls kc hi bd kd lt lu lv kh lw lx ly kl iz lz ma kp jd mb mc kt jh md me kx ho bi translated">工作人员</h2><p id="2a23" class="pw-post-body-paragraph io ip hi iq b ir kz it iu iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl hb bi translated">直截了当地说，工作工人的实施可以从以下简单的步骤开始:</p><ul class=""><li id="d896" class="jm jn hi iq b ir is iv iw iz jo jd jp jh jq jl jr js jt ju bi translated">插入<em class="le">将</em>日志推送到数据库</li><li id="6c2d" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated">从数据库查询用户的令牌</li><li id="408a" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated">基于令牌列表构建一个<em class="le">推送</em>请求</li><li id="a9ee" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated">调用Firebase API</li><li id="4e14" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated">更新<em class="le">推</em>请求对数据库的响应</li></ul><p id="194d" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">为了完成所有这些步骤，大约需要300-400毫秒。因此，系统需要在工作节点上横向扩展，以便从并行计算中获益。但是，有两个因素会对系统性能产生不利影响，它们是:</p><ul class=""><li id="1271" class="jm jn hi iq b ir is iv iw iz jo jd jp jh jq jl jr js jt ju bi translated">插入日志和更新<em class="le">推送</em>结果会增加数据库的工作量</li><li id="eeef" class="jm jn hi iq b ir jw iv jx iz jy jd jz jh ka jl jr js jt ju bi translated">调用API到外部服务，即Firebase在网络连接和延迟方面受到一些限制。</li></ul><p id="9d66" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">为了克服这两个问题，每个worker实例都使用了<strong class="iq hs">批处理</strong>技术。特别是，共享一个公共事物的所有请求将被分组为一批，只包含一个对DB，API的调用。例如，在Golang中，Muster是一个库，它通过以buckets的形式创建批处理来促进批处理的实现。传入的请求将一个接一个地填充这个桶，一旦请求的数量达到一个阈值或者只是超时，将对这个桶采取行动。</p><p id="7f2e" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我列出了工人在处理工作时需要经历的所有步骤。我还将每一步的处理时间信息与系统接收的<strong class="iq hs">n</strong>push<em class="le">请求的数量</em>相加。</p><ul class=""><li id="344b" class="jm jn hi iq b ir is iv iw iz jo jd jp jh jq jl jr js jt ju bi translated">步骤1: <em class="le">将日志插入数据库</em>作业(少于1毫秒x n)</li></ul><blockquote class="mf mg mh"><p id="4aa3" class="io ip le iq b ir is it iu iv iw ix iy mi ja jb jc mj je jf jg mk ji jj jk jl hb bi translated">用请求<em class="hi">将日志插入数据库</em>填充桶</p></blockquote><ul class=""><li id="e196" class="jm jn hi iq b ir is iv iw iz jo jd jp jh jq jl jr js jt ju bi translated">步骤2:批处理(大约10ms x n/1000)</li></ul><blockquote class="mf mg mh"><p id="081f" class="io ip le iq b ir is it iu iv iw ix iy mi ja jb jc mj je jf jg mk ji jj jk jl hb bi translated">触发一批作业<em class="hi">将日志插入数据库</em></p><p id="9b69" class="io ip le iq b ir is it iu iv iw ix iy mi ja jb jc mj je jf jg mk ji jj jk jl hb bi translated">调度<em class="hi">推动</em>工作</p></blockquote><ul class=""><li id="d20f" class="jm jn hi iq b ir is iv iw iz jo jd jp jh jq jl jr js jt ju bi translated">第三步:<em class="le">推送</em>作业(大约5ms x n)</li></ul><blockquote class="mf mg mh"><p id="c94b" class="io ip le iq b ir is it iu iv iw ix iy mi ja jb jc mj je jf jg mk ji jj jk jl hb bi translated">从数据库中筛选与用户相关的令牌</p><p id="a7ad" class="io ip le iq b ir is it iu iv iw ix iy mi ja jb jc mj je jf jg mk ji jj jk jl hb bi translated">基于令牌列表构建一个<em class="hi">推送</em>请求</p><p id="e17f" class="io ip le iq b ir is it iu iv iw ix iy mi ja jb jc mj je jf jg mk ji jj jk jl hb bi translated">用请求<em class="hi">调用Firebase </em>填充桶(不同于步骤1)</p></blockquote><ul class=""><li id="ee6b" class="jm jn hi iq b ir is iv iw iz jo jd jp jh jq jl jr js jt ju bi translated">步骤4:批处理(大约500毫秒x n/500)</li></ul><blockquote class="mf mg mh"><p id="5542" class="io ip le iq b ir is it iu iv iw ix iy mi ja jb jc mj je jf jg mk ji jj jk jl hb bi translated">触发一批作业<em class="hi">调用Firebase </em></p><p id="5045" class="io ip le iq b ir is it iu iv iw ix iy mi ja jb jc mj je jf jg mk ji jj jk jl hb bi translated">用请求<em class="hi">更新数据库</em>填充桶</p></blockquote><ul class=""><li id="340f" class="jm jn hi iq b ir is iv iw iz jo jd jp jh jq jl jr js jt ju bi translated">步骤5:批处理(大约20毫秒x n/1000)</li></ul><blockquote class="mf mg mh"><p id="aa71" class="io ip le iq b ir is it iu iv iw ix iy mi ja jb jc mj je jf jg mk ji jj jk jl hb bi translated">触发一批作业<em class="hi">更新数据库</em></p></blockquote><p id="daf9" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">由于MongoDB和Firebase API的支持<strong class="iq hs">批量写操作</strong>也支持<strong class="iq hs">批量请求</strong>每个调用多达500条消息，这种方法明显减少了API调用的大量等待时间(由于减少了请求的数量)以及分配给DB的资源(减少了查询的数量)。这使得系统在只有一个工作人员和有限资源的情况下，每秒可以推送多达1000次通知，或者每小时可以推送360万次。</p><h1 id="590b" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论和确认</h1><p id="b6f5" class="pw-post-body-paragraph io ip hi iq b ir kz it iu iv la ix iy iz lb jb jc jd lc jf jg jh ld jj jk jl hb bi translated">尽管<strong class="iq hs">批处理</strong>技术的原理很简单，但要实现它并不是一件简单的事情。考虑与<strong class="iq hs">错误</strong>、<strong class="iq hs">重试</strong>和<strong class="iq hs">报告</strong>相关的问题很重要。任何使一个步骤失败的问题都需要付出巨大的努力来解决。这种失败的步骤会对许多<em class="le">推送</em>作业而不是1个作业产生不利影响。但只要你能处理好(没错，就是<strong class="iq hs">如果</strong>的事)，接受取舍也是值得的。</p><p id="c5f8" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">这是我的后台作业和队列概念系列的最后一部分。我想再一次衷心感谢Quang Minh(又名Minh Monmen)允许我翻译他的<a class="ae jv" href="https://kipalog.com/posts/Nghe-thuat-xu-ly-background-job-phan-3--Push-hang-trieu-notification-moi-gio" rel="noopener ugc nofollow" target="_blank">原文</a>。</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><p id="584c" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><em class="le">原载于https://emerging-it-technologies.blogspot.com</em><a class="ae jv" href="https://emerging-it-technologies.blogspot.com/2021/01/background-job-queue-pushing-millions.html" rel="noopener ugc nofollow" target="_blank"><em class="le"/></a><em class="le">。</em></p></div></div>    
</body>
</html>