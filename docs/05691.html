<html>
<head>
<title>How to build a React Native video chat app with Sendbird Calls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Sendbird调用构建React原生视频聊天应用</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-build-a-react-native-video-chat-app-with-sendbird-calls-bd1e4029f415?source=collection_archive---------7-----------------------#2022-03-22">https://medium.com/codex/how-to-build-a-react-native-video-chat-app-with-sendbird-calls-bd1e4029f415?source=collection_archive---------7-----------------------#2022-03-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/e66d57ca317ec51641844b09739eda69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Uwo0caSnAKPxF1C2.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">2022仙鸟</figcaption></figure><div class=""/><div class=""><h2 id="52e3" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">使用JavaScript允许用户在iOS和Android应用程序中进行1:1呼叫并接收推送通知</h2></div><p id="9d8b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">由Charis Theodoulou <br/>解决方案工程师| send bird</p><p id="b0b1" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated"><em class="kj">您可能会发现查看我们的</em> <a class="ae ki" href="https://github.com/charisTheo/RNWebview" rel="noopener ugc nofollow" target="_blank"> <em class="kj">样本代码</em> </a> <em class="kj">很有用。如果需要额外的指导，请参考我们的</em> <a class="ae ki" href="https://sendbird.com/docs/calls" rel="noopener ugc nofollow" target="_blank"> <em class="kj">文档</em> </a> <em class="kj">。别忘了查看一下</em> <a class="ae ki" href="https://sendbird.com/features/voice-and-video" rel="noopener ugc nofollow" target="_blank"> <em class="kj"> Sendbird调用</em> </a> <em class="kj">提供的所有特性。</em></p><blockquote class="kk kl km"><p id="01ac" class="jm jn kj jo b jp jq iy jr js jt jb ju kn jw jx jy ko ka kb kc kp ke kf kg kh hb bi translated"><em class="hx">成为第一个了解新教程、开发者相关聊天/电话发布以及其他重要更新的人，</em> <a class="ae ki" href="https://get.sendbird.com/dev-newsletter-subscription.html" rel="noopener ugc nofollow" target="_blank"> <em class="hx">注册</em> </a> <em class="hx">我们的开发者简讯。</em></p></blockquote><h1 id="0363" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">介绍</h1><p id="9453" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh hb bi translated">本文演示了如何在React本地应用程序中实现<a class="ae ki" href="https://sendbird.com/features/voice-and-video" rel="noopener ugc nofollow" target="_blank"> Sendbird调用</a>。在本教程结束时，您将学习如何呼叫另一个用户，并在Android和iOS上都启用推送通知的情况下接收来电。</p><p id="64b3" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">本教程涵盖了两种解决方案，它们都使用WebView组件进行<a class="ae ki" href="https://webrtc.org/" rel="noopener ugc nofollow" target="_blank"> WebRTC </a>通信。</p><ol class=""><li id="9f7f" class="ln lo hx jo b jp jq js jt jv lp jz lq kd lr kh ls lt lu lv bi translated">带有远程服务器的WebView</li><li id="5db6" class="ln lo hx jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated">带有本地服务器的WebView</li></ol><p id="5da6" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">如果您已经托管了一个实现Sendbird调用的web应用程序，那么远程服务器解决方案是理想的，因为您可以从React本地应用程序中链接它。</p><p id="d71e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">本地服务器解决方案(2)是一个更易于维护的解决方案，它将拥有最快和最友好的开发体验，因为您将所有的物理文件都放在一个项目或存储库中。</p><p id="f09f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">在讨论这两种解决方案之前，我们将分别讨论这两种解决方案，我们需要做一些基础准备工作。</p><h1 id="8a6e" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">步骤1:环境设置</h1><p id="8d7f" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh hb bi translated">作为先决条件，您需要一个React本机应用程序。对于快速设置，使用<a class="ae ki" href="https://github.com/expo/create-react-native-app" rel="noopener ugc nofollow" target="_blank">创建-反应-本地-应用</a>。如果您已经有了自己的应用程序，您可以将以下步骤应用于您的代码库。</p><p id="9f1d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated"><strong class="jo hy">注意</strong>:不推荐使用<a class="ae ki" href="https://reactnative.dev/docs/0.61/webview" rel="noopener ugc nofollow" target="_blank">原生react-原生WebView </a>。因此，你应该使用<a class="ae ki" href="https://github.com/react-native-webview/react-native-webview" rel="noopener ugc nofollow" target="_blank"> react-native-webview </a>来代替。</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="1dbe" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">如果使用React Native &gt;= 0.6.x，则不需要手动链接。安装后在iOS目录下运行pod install即可。如果您使用的是旧版本，请查看React Native Webview 的<a class="ae ki" href="https://github.com/react-native-webview/react-native-webview/blob/master/docs/Getting-Started.md#2-link-native-dependencies" rel="noopener ugc nofollow" target="_blank">入门文档。</a></p><p id="d30c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">接下来，转到要在其中呈现<webview>组件的组件(在本例中是<app>组件)并插入以下代码:</app></webview></p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="dea2" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">allowsInlineMediaPlayback属性以及？uri中的playsinline=1参数在iOS中应该为true。否则，WebView组件中的视频将全屏显示。</p><h1 id="47a6" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">推送通知</h1><p id="665c" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh hb bi translated">如果您想要包含推送通知，请确保查看<a class="ae ki" href="https://github.com/zo0r/react-native-push-notification#readme" rel="noopener ugc nofollow" target="_blank">react-native-Push-notification</a>以了解如何处理远程推送通知。注意，要处理来自Sendbird调用的远程推送通知，您必须实现在注册令牌发布时调用的<a class="ae ki" href="https://github.com/zo0r/react-native-push-notification/blob/da7dde752d83bef782afe05ef33af9fa44593b31/example/NotificationHandler.js#L12" rel="noopener ugc nofollow" target="_blank"> onRegister回调</a>。然后，您必须通过SendBirdCall.reigsterPushToken()将其传递给Sendbird服务器，以从Sendbird服务器获取推送通知。</p><p id="9e01" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">请记住，应该在身份验证之后调用SendBirdCall.reigsterPushToken()函数。</p><p id="d230" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">每当您的应用程序获得远程推送通知时，就会调用<a class="ae ki" href="https://github.com/zo0r/react-native-push-notification/blob/da7dde752d83bef782afe05ef33af9fa44593b31/example/NotificationHandler.js#L4" rel="noopener ugc nofollow" target="_blank"> onNotification回调</a>。这意味着您必须决定它是否是Sendbird消息。您可以通过查找数据对象的sendbird_call属性来区分它们。如果设置了该属性，那么它就是一个Sendbird消息，因此您可以将它传递给JavaScript SDK来正确处理它。</p><p id="d542" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">实现示例请参考<a class="ae ki" href="https://github.com/charisTheo/RNWebview/blob/main/src/services/RemotePushController.js" rel="noopener ugc nofollow" target="_blank"> RemotePushController.js文件</a>。</p><h1 id="2caf" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">Polyfill网络视图</h1><p id="a419" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh hb bi translated">为了让WebView在不同的设备上统一工作，我们必须使用<a class="ae ki" href="https://github.com/react-native-webrtc/react-native-webrtc" rel="noopener ugc nofollow" target="_blank"> react-native-webrtc </a>来填充它。</p><p id="cf55" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">在App.js文件中，添加以下代码:</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="bea7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">尽早调用bypass函数非常重要。</p><p id="3170" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">还要注意，支持引入WebRTC的WebView v37的最低Android版本是<a class="ae ki" href="https://developer.android.com/about/versions/lollipop.html#WebView" rel="noopener ugc nofollow" target="_blank"> Android 5.0(棒棒糖)</a>。</p><h1 id="acf4" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">添加登录功能</h1><p id="9cb3" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh hb bi translated">对于基本的身份验证功能，我们将添加文本输入字段，我们可以在其中添加我们的应用ID、用户ID和访问令牌(如果适用)。在App.js文件中，添加以下内容:</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="6511" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">authQuery变量包含有关应用程序ID、用户ID和访问令牌的编码信息，这些信息将用于登录WebView组件内呈现的网站。要了解authQuery是如何编码的，请查看以下步骤。</p><p id="3047" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">现在，让我们添加状态挂钩和事件侦听器:</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="e7ab" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">在接下来的步骤中，我们将查看WebView组件的uri字段的两个选项。让我们从带有远程服务器的WebView开始。</p><h1 id="1f82" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">步骤2a:使用远程服务器的WebView</h1><p id="4399" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh hb bi translated">您必须准备公共远程服务器来服务HTML页面，包括Sendbird调用JS SDK。在本指南中，我们将使用<a class="ae ki" href="https://sample.calls.sendbird.com/" rel="noopener ugc nofollow" target="_blank">自托管示例</a>。</p><figure class="mb mc md me fd hk er es paragraph-image"><div class="er es mh"><img src="../Images/007978b1938126f064289bbfcfcbea66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*83_9Efnnw6TerXd4.png"/></div></figure><p id="7041" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">这个远程服务器必须提供HTML页面，这个页面最终会转到call view。呼叫视图应该包含<audio>或<video>标签，标签需要具有自动播放、在线播放和可能静音的属性。在我们的示例库中查看调用视图的最小形式。</video></audio></p><p id="0d03" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">按照前面详细介绍的设置，我们可以使用WebView组件从React本地应用程序中呈现Sendbird调用示例web应用程序<a class="ae ki" href="https://sample.calls.sendbird.com/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="0f29" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">这里唯一需要的是将上述URL传递到WebView的source prop的uri字段中:</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><h1 id="413d" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">步骤2b:带有本地服务器的WebView(推荐)</h1><p id="97d3" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh hb bi translated">或者，您可以启动一个本地服务器，在React Native app项目中托管一些本地文件。通过将所有文件整合到一个项目/存储库中，您可以更快地进行开发。它还降低了管理成本，因为这不需要主持一个网站的工作。</p><figure class="mb mc md me fd hk er es paragraph-image"><div class="er es mi"><img src="../Images/4ba535e8515d3ec33c61f7970ecfe96f.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/0*zfjKn1XJRxEJOsu6.png"/></div></figure><p id="8d4e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">首先，安装<a class="ae ki" href="https://www.npmjs.com/package/react-native-static-server" rel="noopener ugc nofollow" target="_blank">react-native-static-server</a>和<a class="ae ki" href="https://www.npmjs.com/package/react-native-fs" rel="noopener ugc nofollow" target="_blank"> react-native-fs </a>包。根据你的React Native和Gradle版本，安装<a class="ae ki" href="https://github.com/itinance/react-native-fs#important" rel="noopener ugc nofollow" target="_blank">合适的react-native-fs版本</a>。</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="e226" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">如果使用React Native &gt;= 0.6.x，则不需要手动链接。否则，运行以下命令:</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="ec52" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">然后针对iOS运行以下命令:</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><h1 id="dd33" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">为本地服务器创建文件</h1><p id="b8d2" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh hb bi translated">在项目的根目录下添加一个名为assets/www的目录。这是我们的构建工件将要去的地方，并且将由我们的本地服务器托管。我们将在接下来的步骤中创建这个本地服务器。</p><p id="2e19" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">现在，对于这些构建工件的源代码，我们将在一个名为SendbirdCalls的文件夹中克隆这个存储库。在React本地项目的根目录中，运行以下命令:</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="0921" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">因此，您的项目结构现在应该如下所示:</p><figure class="mb mc md me fd hk er es paragraph-image"><div class="er es mj"><img src="../Images/d50f13334466997c67030d3bde1d7f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/0*lFj0ENcJRpy6H0us.png"/></div></figure><p id="92ad" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">最后，安装依赖项并构建我们刚刚克隆的SendbirdCalls项目。</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="2bb1" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">一旦上面的命令完成，您应该在<project root=""> /assets/www/目录中获得构建工件。</project></p><figure class="mb mc md me fd hk er es paragraph-image"><div class="er es mk"><img src="../Images/dd8ad0482f94cb78a1e38bfb7fc368da.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/0*Lpq5qDFvHyoAkTWI.png"/></div></figure><h1 id="bf46" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">将文件添加到iOS捆绑包</h1><p id="120c" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh hb bi translated">首先，在Xcode中打开您的iOS项目。iOS项目应该位于ios/ <projectname> .xcodeproj下React原生项目的根目录下。</projectname></p><p id="02e0" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">然后，右键单击项目最顶层的目录，选择“将文件添加到<projectname>”。</projectname></p><figure class="mb mc md me fd hk er es paragraph-image"><div class="er es ml"><img src="../Images/daa5287a5580447eb18b56b8b8cf4648.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/0*bDM4HOcGVKJ13QC7.png"/></div></figure><p id="33a7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">然后选择项目根目录下的assets/www目录。</p><figure class="mb mc md me fd hk er es paragraph-image"><div class="er es mm"><img src="../Images/4ec4e1b21d51097c52b74e9f8ed4ede3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/0*7jy3K5k5WRelxuAO.png"/></div></figure><p id="064b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">单击“Add”后，您应该会看到捆绑到iOS项目中的资产。</p><figure class="mb mc md me fd hk er es paragraph-image"><div class="er es mn"><img src="../Images/f9f2d14d097724cf9d7149957f2eedc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/0*flyH8ACG3xOJVw8l.png"/></div></figure><h1 id="e37d" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">向Android捆绑包添加文件</h1><p id="2418" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh hb bi translated">在<project root=""> /android/app/build.gradle文件中，添加以下代码行，将静态服务器的文件捆绑到android应用程序中:</project></p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="9228" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">然后，如果您在android Studio中打开Android目录，您应该会看到与Android应用程序捆绑在一起的资产目录:</p><figure class="mb mc md me fd hk er es paragraph-image"><div class="er es mo"><img src="../Images/59ef7e7f7ab97104b099ea9c17038a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/0*dqePXGxNizVmtns-.png"/></div></figure><h1 id="d92a" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">在Android上启用明文流量</h1><p id="bac4" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh hb bi translated">这一步对于访问localhost上的本地服务器非常重要。Android默认不允许来自本地主机的流量；为此，我们必须配置一些网络安全参数。</p><p id="3d3d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">为此，在app/src/main/res/xml下创建一个名为network_security_config.xml的新文件，并包含以下代码:</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="9e1f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">然后，在app/src/main/Android manifest . XML文件中，添加以下两行:</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="b3bb" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">现在重复上面的步骤，但是在您的调试目录(app/src/debug/res/xml)中。</p><p id="6a4d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">你可以在本文中了解更多信息。</p><h1 id="b2af" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">创建本地服务器挂钩</h1><p id="eaff" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh hb bi translated">在这一步中，我们将创建一个useStaticServer钩子，当组件挂载并返回它的URL时，它会旋转一个本地静态服务器，这样我们就可以将它传递给<webview>组件。</webview></p><p id="30f0" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">对于useStaticServer钩子，创建一个StaticServer.js文件，如下所示:</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="3535" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">创建新的StaticServer时，传入{localOnly: true}很重要；否则，宿主将无法在localhost上工作。</p><p id="5a45" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">如果您到目前为止一直在关注整个教程，并在SendbirdCalls目录中克隆了<a class="ae ki" href="https://github.com/charisTheo/quickstart-calls-reactjs/" rel="noopener ugc nofollow" target="_blank">这个存储库</a>，您也可以复制图标——尽管这对于本教程来说不是必需的。如果您想这样做，您必须在复制图标之前创建另一个目录:</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="a1c0" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">这是本项目中使用的图标的完整列表。</p><p id="813d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">请记住，此本地静态服务器将在本地主机上运行。如果通过设备的本地IP(例如192.168.10.1)访问服务器，将无法正确初始化Sendbird Calls，因为它需要HTTPS连接，或者需要在本地主机上运行。</p><p id="0247" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">最后，在App.js代码中，添加以下代码行，并将url变量传递到WebView组件的源代码支柱中:</p><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><h1 id="2cb6" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">第3步:运行应用程序</h1><p id="3748" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh hb bi translated">要运行应用程序，只需从项目的根执行npm运行android或npm运行ios在终端上运行应用程序，无论是在真实的设备上还是在仿真器上。</p><p id="f0ae" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">如果您遵循本地服务器实现并克隆了<a class="ae ki" href="https://github.com/charisTheo/quickstart-calls-reactjs/" rel="noopener ugc nofollow" target="_blank"> Sendbird Calls存储库</a>，您可以在Sendbird Calls目录中运行第二个终端命令npm run watch来自动重建SendbirdCalls网站，并重新加载运行在Android设备或仿真器中的React Native应用程序。</p><p id="cfcf" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">如果您正在模拟器上测试android，请确保在运行npm运行Android之前关闭所有模拟器实例，否则metro服务器将与模拟器中的应用程序断开连接。当没有仿真器运行时，React Native脚本应该自动启动仿真器并成功连接到metro服务器。</p><figure class="mb mc md me fd hk er es paragraph-image"><div class="er es mp"><img src="../Images/40c437478572f9c4717bb49c9ecbd07e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/0*WxGw9kpm1QT-r8aJ.png"/></div></figure><p id="465d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">可能会出现请求允许使用麦克风和摄像机的提示。如果您解决了这个问题，您可以像在浏览器版本上一样使用这个调用。</p><h1 id="635e" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">第4步:故障诊断</h1><h2 id="709f" class="mq kr hx bd ks mr ms mt kw mu mv mw la jv mx my lc jz mz na le kd nb nc lg nd bi translated">ios</h2><ol class=""><li id="d4ac" class="ln lo hx jo b jp li js lj jv ne jz nf kd ng kh ls lt lu lv bi translated">错误“NSNumber类型的JSON值“1”无法转换为NSString”<br/>a)从WebView组件中删除allowReadAccessToURLs属性-请在本文<a class="ae ki" href="https://dev.to/craftzdog/fixing-an-error-json-value-1-of-type-nsnumber-cannot-be-converted-to-nsstring-a7l" rel="noopener ugc nofollow" target="_blank"/>中阅读更多内容。</li><li id="d44c" class="ln lo hx jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated">白屏或HTTPS错误<br/> a)您需要在<a class="ae ki" href="http://localhost/" rel="noopener ugc nofollow" target="_blank"> http://localhost/ </a>上访问本地服务器的URL，而不是StaticServer返回的IP(即192.168.18.1)</li><li id="86cb" class="ln lo hx jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated">在macOS上运行react-native run-ios后出现错误“Build error domain = com . apple . core simulator . simerror，code = 405:<br/>a)使用提供的模拟器名称运行相同的命令:</li></ol><figure class="mb mc md me fd hk"><div class="bz dy l di"><div class="mf mg l"/></div></figure><h2 id="cc78" class="mq kr hx bd ks mr ms mt kw mu mv mw la jv mx my lc jz mz na le kd nb nc lg nd bi translated">机器人</h2><ol class=""><li id="9c08" class="ln lo hx jo b jp li js lj jv ne jz nf kd ng kh ls lt lu lv bi translated">白屏或HTTPS错误<br/> a)您需要在AndroidManifest.xml中启用明文流量(遵循“在Android上启用明文流量”的步骤)——在本文的<a class="ae ki" rel="noopener" href="/astrocoders/i-upgraded-to-android-p-and-my-react-native-wont-connect-to-my-computer-to-download-index-delta-42580377e1d3">中了解更多信息。<br/> b)如果在没有Google Play服务和自动更新的模拟器上进行测试，请确保从Play Store更新Google Play服务和Android系统WebView(WebView将为装有</a><a class="ae ki" href="https://developer.chrome.com/docs/multidevice/webview/#will-the-new-webview-auto-update" rel="noopener ugc nofollow" target="_blank"> Android L和更高版本</a>的移动设备自动更新)。</li></ol><figure class="mb mc md me fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nh"><img src="../Images/1cdb5729ca25294ddfe859b6e5a8f51b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pN0KcnIufPYvTfUp.png"/></div></div></figure><p id="fac2" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">c)如果您在更新下没有看到Android系统WebView，您可能需要从设备设置的应用程序信息部分在设备上启用它。如果你也不能从那里启用它，你可能需要在启用和更新Android系统WebView之前暂时禁用Chrome。</p><ol class=""><li id="461c" class="ln lo hx jo b jp jq js jt jv lp jz lq kd lr kh ls lt lu lv bi translated">错误"<em class="kj">无法加载脚本。确保您正在运行Metro服务器，或者您的捆绑包“index.android.bundle”已正确打包以发布</em> " <br/> a)确保在运行npm run android之前关闭所有仿真器实例。当没有模拟器运行时，React本地脚本应该自动启动模拟器并成功连接到metro服务器。</li><li id="b160" class="ln lo hx jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated">WebView加载时出现错误“net::ERR _ CONNECTION _ rejected”<br/>a)创建新的静态服务器(new StaticServer(PORT，path，{localOnly: true})时需要将localOnly参数设置为true</li></ol><h1 id="1996" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">结论</h1><p id="33ce" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh hb bi translated">在本教程中，我们讨论了在带有WebView的React本机应用程序中实现Sendbird调用。现在，您知道如何利用JavaScript的强大功能，允许用户在Android和iOS设备上进行1:1呼叫，并在您的应用程序中接收推送通知。干得好！</p><p id="6544" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">借助支持WebRTC的高质量语音和视频聊天，您正在提升应用参与度和用户满意度。</p><p id="4ea8" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">一如既往，如果您对我们的<a class="ae ki" href="https://community.sendbird.com/" rel="noopener ugc nofollow" target="_blank">社区站点</a>有任何疑问，请告诉我们，感谢您使用Sendbird！</p><p id="67bd" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">编码快乐！🖥</p><blockquote class="kk kl km"><p id="afbd" class="jm jn kj jo b jp jq iy jr js jt jb ju kn jw jx jy ko ka kb kc kp ke kf kg kh hb bi translated"><em class="hx">为了第一时间了解新教程、与开发者相关的聊天/电话发布以及其他重要更新，</em> <a class="ae ki" href="https://get.sendbird.com/dev-newsletter-subscription.html" rel="noopener ugc nofollow" target="_blank"> <em class="hx">注册我们的开发者简讯</em> </a> <em class="hx">。</em></p></blockquote></div></div>    
</body>
</html>