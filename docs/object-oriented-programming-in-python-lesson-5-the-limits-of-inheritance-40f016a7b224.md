# Python 中的面向对象编程—第 5 课。继承的限制

> 原文：<https://medium.com/codex/object-oriented-programming-in-python-lesson-5-the-limits-of-inheritance-40f016a7b224?source=collection_archive---------21----------------------->

![](img/db150015c62a9d2cc7c7b546d8cfe04a.png)

这是五篇系列文章中的第五篇，也是最后一篇，总结了面向对象编程的实际需要和面向对象语言提供的功能，并给出了 Python 中的例子，强调了 Python 对这种范式的解释。在前面的章节中，我们学到了面向对象编程的基本词汇:功能*可替代性*——使用*消息*范例——的*对象*，其行为和数据封装在*类*中。然后，基于在实践中应用面向对象的设计必须*遵守*的观察，遵循既定的习惯用法、模式和架构，我们深入研究了一些复杂的——以及一些简单的——设计模式的详细示例。在这最后一课中，我们将讨论较少讨论的使用继承的面向对象编程的过程方面，并总结我们开始的地方——可替换性，通过这个名称介绍著名的原则。

*本课章节:*

1.  继承的程序含义
2.  “模板方法”模式
3.  “超级电话”习语
4.  可替代性原则

## 1.继承的程序含义

普通的编程智慧倾向于强调继承的*结构*本质，尤其是*数据*及其访问的共同性和差异性，以及继承层次的问题域语义。然而，继承，尤其是当与不可避免的功能性*可替代性*相结合时，具有*程序性*的复杂性，这同样有趣并且经常被忽视，带来可怕的后果。类层次结构不仅仅是数据的层次结构。也是一个或多个算法的分层实现！

从功能的角度来看，只有这么多的*方法*层级。阶级后来出现了。有一些必需的能力，然后有这么多有趣的方法来满足它，然后其中一些也可能激发更具体的方法来满足后者，等等。令人惊讶的是，很多时候一些方法层次总是在一起(例如，它们影响同一个状态)，我们将它们合并成一个类层次(用公共状态完成)。

基于继承的功能可替代性意味着向指定类的对象发送消息并通过其任何子类的方法获得响应的能力。(实际上，正如我们将很快看到的，也可能部分地被它的超类 strata 的方法以及它的子类 strata 的其他方法所响应！)虽然——如同在任何函数库实现中一样——所有这些复杂性对于原始消息的发送者来说是自然隐藏的，但它仍然需要仔细的设计。

设计基类不是一件简单的事情。通过一个基类，你设计了一个框架，其他人可以向其中注入内容，而你并不知道这些内容将会是什么或者如何被使用。这需要以下两个设计职责(至少):(1)将控制的*共性*集中在适当的层，以及(2)促进适当层的控制的*差异*。在这一课中，我将演示两种常见的技术:第一种需求的*模板方法*模式，第二种需求的*超级调用*习语。

让我们重新考虑消息范式。一个对象响应消息，应用其库中的适当方法。(准确地说:应用其类的适当方法，使用它(对象)作为参数)。这就引出了一个奇怪但不可避免的问题:*当一条消息到达一个对象时，谁来响应它:这个对象？对象的继承功能？对象的继承功能？两者的结合？考虑一下，在 Python 中，接收者对象的“超类(继承的)功能”和“子类(被继承的)功能”是旁观者的观点(因为 Python 对象只依赖于一个平面属性字典)，例如，在 C++实现中，这些功能层由不同的对象表示！*

![](img/be38d5a382b9f7f4b6319e47d292f56b.png)

*   “模板法”。带有“孔”的方法，从实际的*子类*中填充。对象传递虚拟消息给它自己，在实际的子类中被覆盖。
*   “超级通话”。子类显式使用继承的方法*。通常，它还会在之前和/或之后添加一些操作。最常见的例子是*构造器*。*

## *2.“模板方法”模式*

*“模板”方法通过在超类中定义和约束过程，并允许(或要求)该过程中的一些(或所有)阶段在继承层次中被覆盖，来对作业的责任进行分层。*

*下面这个简单的例子(这个“过程”不涉及按时间排序的阶段，但仍然演示了该模式)是基于这样的观察:如果每个特定的形状都可以提供它的四个角(根据它自己的逻辑)，那么“计算外接矩形”功能的逻辑可以为所有形状分解(也就是说，简化为抽象基类形状中的“模板方法”)。*

**输出:**

```
*((5, 5), (25, 25))*
```

*尽管“模板方法”模式看起来微不足道，但与本系列中讨论的其他设计模式相比，它具有巨大的*设计*意义。以模板方法为特征的抽象基类在*应用框架*的设计中很常见。当然，模板方法模式的自然栖息地是需要逻辑的*分层*的地方(如继承层次所满足的)。但是在框架不建议子类化的地方，直接注册事件处理程序就可以了。*

## *3.“超级电话”习语*

*与“模板方法”模式相反，超级调用通过将流程集中在*子类*中并将阶段显式转发到其超类(早期绑定)来沿着继承层次结构对责任进行分层。*

*在下面的例子中，(1) Circle *初始化*首先允许其形状层初始化，然后才继续，(2)Circle*序列化*也是如此。这两种情况(初始化和序列化)在面向对象软件中非常典型和常见。*

**输出:**

```
*Circle: x:15 y:15 radius:10*
```

## *4.可替代性原则*

*与一些程序员的直觉相反，*编程*继承，就像它所基于的*封装*一样，主要是功能(方法)，其次才是内容(数据，“状态”)。因此，如上所述，并不是每个在问题领域有意义的语义层次在编程媒介中都是可行的！事实上，一个*的东西是一个*的别的东西(也就是说，可能用它的术语来定义，它的事例构成后者的事例的子集)，仍然不能保证它能成功地*子类*它！*

*考虑一下臭名昭著的例子*正方形是长方形*。首先，我们通过一个同名的类来实现“Rectangle”的思想，存储矩形的尺寸(高度和宽度)，允许访问这些数据(尺寸)，并支持一些基本的数学功能，例如*“计算面积】*、*“计算周长”*、*“测试交点(带点)”*等等。*

*一家生产矩形的小型企业有一个质量保证部门，该部门通过对从矩形生产线上随机收集的样本进行简单测试，对产品进行常规测试。这是一个简单的“健全性测试”，测试给定的矩形，以新的尺寸，确实报告了新的尺寸。检查中的“健全”意味着这个测试是如此的愚蠢，以至于它没有理由失败(或者有吗？等着瞧！)*

**脚注:**

1.  *Rectangle 有两个维度——高度和宽度——并具有预期的 getters 和 setters*
2.  *产品线创建随机的矩形。*
3.  *QA 测试期望测试给出精确的“10x20”。*
4.  *测试函数将矩形设置为新的尺寸，并返回新状态的字符串表示。*

*进入继承(但这次不是胜利，尽管它还不知道)！*

*随着对矩形的需求减少，该公司的销售人员(他不是专业的矩形用户)想出了一个绝妙的主意:“正方形需求量很大。既然大家都知道*正方形是长方形*，我们也可以将我们的长方形生产线转换成正方形！”。销售人员所指的“是一个”的联想，用“正方形是等尺寸的长方形”来表示，即其高度等于其宽度。*

*显然,“正方形作为矩形”的命题是通过子类化实现的。Square 不需要额外的数据。正方形的构造函数接受一个维度，并两次将其传递给它的基本矩形，表示高度=宽度。为了确保始终保持“高度=宽度”约束，从 Rectangle 继承的尺寸设置器被*覆盖*以设置两个尺寸。*

**脚注:**

1.  *矩形不受更改的影响。*
2.  *正方形将其矩形初始化为其边长的两倍。*
3.  *Square getters 返回一个矩形维度(不管是哪个)*
4.  *从 Rectangle 继承的 setters 被覆盖以保持“height = width”的状态。*
5.  *产品线被调整为也支持正方形(或任何符合矩形的东西)。出于可扩展性的考虑，创建单个产品的能力被分离到用户提供的功能中。*
6.  *产品创建的任务委托给用户提供的创建者。*
7.  *这里提供了两个创建器:矩形和正方形。*
8.  *QA 测试不受变更的影响。正如承诺的那样，这仍然是一个矩形产品线，尽管只是稍微扩展了一下。*
9.  *标准测试扩展到也包括正方形。*

*令销售人员沮丧的是，所有从生产线上出现的闪亮的新方块都被质量保证拒绝。*健全性*检查结果是*疯狂的*:根据我们所知，输入尺寸为 10 和 20 的*矩形*，我们期望对象报告“10x20”，但是相反，这个蹩脚的矩形(恰好是正方形)报告“20x20”，必须被拒绝。*哎呀！**

*对于这种违反直觉的失败，有许多流行的解释。例如，上面实现的“高=宽的矩形”是一个*对象*的不变量，而不是一个*类*对象的不变量！可以说——不管问题域的语义如何——在编程上，Square 不继承 Rectangle，或者反过来，或者两者都从第三个类继承，或者其他什么。省省力气吧！虽然上面的代码将*编译*(在大多数商业面向对象语言中，这并不证明对他们有利)，但它有一个*设计*错误！*

**进入**合同设计！**

*“契约式设计”范式(简称“DBC”)是由 Bertrand Meyer 在 20 世纪 80 年代引入的，是 Eiffel 编程语言的一部分。就我们的目的而言，它响应了定义和验证功能“行为”的问题，同时维护并证明“信息隐藏”的需求。无论是谁使用一个对象(也就是向它发送消息),都对完成的工作感兴趣，尽可能不关心对象如何处理它的业务。信息隐藏符合客户和功能供应商的利益。但是，如果客户不知道——也不想知道——供应商同时在做什么，客户怎么能把工作交给供应商，耐心地在外面等着呢？DBC 将问题简化为在将控制传递给方法之前必须占优势的状态约束(客户端的责任)和一旦控制传递回来必须占优势的条件约束(接收者对象的责任)。职能的“合同”包括以下条款:*

1.  *后置条件。产生的结果，以及状态的变化和对该对象或相关对象的副作用。上例中的正方形与*矩形不兼容*，因为正方形覆盖违反了“设置矩形宽度”(即:“宽度=给定宽度，其余部分不受影响”)的后置条件(未指明但很明显)！可替换性是指需要这种类型或兼容类型的对象的功能。这意味着实际调用的方法的后置条件必须与我们想要调用的方法的后置条件相匹配(在声明的类型中)。(实际上，这里允许有限程度的*变化*，但这与本讨论无关)。*
2.  *前提条件。所需的参数，以及接收器和相关对象的状态。如果不满足前置条件，后置条件*未定义*(至少。是否必须验证前提条件是一个值得讨论的问题)。比如:“内存复制”前提条件:目标缓冲区有足够的空间。否则，缓冲区可能会溢出，也可能不会溢出，但复制不会正确完成。*
3.  *该方法可能引发的异常。前提条件可能得到满足，但后续条件可能无法得到保证的情况。“不可抗力”。如果可能的话，恢复是客户端的责任。*

*除了每个可接收消息的条款之外，类的“契约”还可以包含该类的*不变量*:在方法调用之间必须占优势的约束——不需要在每个消息中声明的先决条件和后置条件。(但这与当前的讨论无关)。*

**输入可替代性原则！**

*这里是利斯科夫的“可替代性”原理(简称“LSP”)。*摘自芭芭拉·利斯科夫 1987 年的一次演讲:**

*“……如果对于每一个 S 类型的对象 o1，都有一个 T 类型的对象 o2，使得对于所有用 T 定义的程序 P，当 o1 代替 o2 时，P 的行为不变，那么 S 就是 T 的一个子类型。”*

*这可能看起来很隐晦，所以让我们澄清一下。出于实用目的，我们可以安全地将“对于所有用 T 定义的程序 P”简化为“一个取 T 的函数”。我们还可以有把握地假设(至少在 Python 和其他当代面向对象语言中)，“类型”与“类”相同，“子类型”与“子类”相同(尽管这不是作者的意图)。所以，现在我们在讨论一个接受 T 的函数(或多个函数)，当 T(不考虑它的私有名字)被 s 代替时，它的*“行为不变”*，但是“P 的行为不变”是什么意思呢？首先，如何定义和测试*行为*？“行为”在我所知道的任何编程语言中都不是一个关键字！*

*事实证明，方法的这种(LSP 风格的)“行为”可以很容易地根据 DBC 来定义和测试*。当代码可以用另一个对象(很可能是另一种类型)替换这个对象时，它可以安全地使用一个可替换的对象(出于实际原因，使用函数必须知道参数是可替换的)，并且它(代码)仍然会提供它的后置条件(当然，假设它的前置条件首先得到满足)。**

*回到“Square as Rectangle”的情况:在 Square 中覆盖从 Rectangle 继承的 setters 违反了 LSP。QA 函数需要一个报告“10x20”的矩形，但却得到一个报告“20x20”的无效矩形(实际上是正方形)。*

*在当前讨论的上下文中，关于可替代性原则的有趣之处在于，它使用*功能*的可替代性来建议继承(或其他)类型层次，而不是相反的——常见的——范例:首先建立继承层次，因为它看起来“显而易见”(对某人来说)，然后通过插入匹配的功能和方法来使节点可替代。(狗和猫都是动物。为什么？因为显而易见！有什么是所有动物都会做的吗？我明白了。狗是如何做到这一点的，这和猫的方式有什么不同吗？等等)。据我们所知，在问题域中，一个函数可能会将 S 视为 T 的子类型，而另一个函数可能会将 T 视为 S 的子类型。当然，由于我们希望所有接受 S 的*函数也接受 T，因此编程解决方案需要一个方便的折衷方案。**

*当一个人意识到整个复杂性集中在一个从未被提及、被认为是理所当然的事实上时，可替代性原则就变得清晰而明显了:*“…并且函数使用参数(来完成它的部分工作)”*。在极端(但合法)的情况下，P 用它的“可替换”参数没有做任何有用的事情，那么，就 P 而言，所有类型都是可替换的，这是无用的。*

*可替代性原则提出了两个层次的委托:(1)客户端要求函数使用一个(客户端提供的)参数来完成一项工作*；以及(2)函数依靠这个(客户端提供的)参数来完成它自己(函数)的部分工作。如果一切都按计划进行(我们有可替代性)，那么参数将成功地执行它的部分，导致函数成功地执行它的工作！**

**考虑这个业务隐喻:*我们在这里谈论的是一个*承包商*，他有能力完成一项工作，依靠一个*分包商*来完成部分工作，其中分包商是由客户提供的。如果参与的每个人都是专业的，并且如果前期和后期条件都定义得很好，那么这个非平凡的星座必须工作，即使承包商以前从未见过(客户提供的)分包商！例如，即使承包商期望由客户提供基本级别的手，过度合格或不相关的专业手仍然可以(因为它仍然是可替代的！)*

**士气:*我们知道为功能*可替代性*设计软件基础设施——尤其是常见的面向对象和基于继承的种类——意味着为*扩展*提供一个框架，该框架将(自然地)只在一些严格的*约束下工作*。并且这些约束最好是明确和正式的(这样你的潜在用户——或者甚至你自己——就不会滥用它们！)在这个过程中自然会有许多陷阱，但是——如果一个人从事的是专业工作，就像我在本系列中试图演示的那样——这些陷阱可能很容易避免。当然，成功设计的关键(在任何学科中，以及在软件中)是调整解决方案中使用的技术工具，以适应问题提出的实际需求。面向对象编程为许多功能可替代性问题提供了一个公平的、得到良好支持的(但绝不是唯一的)解决方案。但是如果一个人从最后开始，强迫一个面向对象的设计——以一个严格的继承层次和使用匿名对象的消息的可替代性为特征——从一开始就不需要功能可替代性，仅仅因为这是每个人都在做的事情，那么一个人就是在实践*糟糕的设计*，而不是因为它是——或者不是— *面向对象！**

## *本课程的课程:*

1.  *[可替代性和继承性](/codex/object-oriented-programming-in-python-lesson-1-substitutability-and-inheritance-e5c6661dfca5)*
2.  *[面向对象可替代性的荣耀:“复合”模式](/codex/object-oriented-programming-in-python-chapter-2-the-composite-pattern-4b7da542d5b0)*
3.  *[面向对象可替代性的限制:“访问者”模式](/codex/object-oriented-programming-in-python-chapter-3-the-visitor-pattern-d0b176d4807d)*
4.  *[有些无聊的设计模式](/codex/object-oriented-programming-in-python-lesson-4-some-boring-design-patterns-ee01a81030c3) s*
5.  ***继承的极限** *←(你在这里！)**