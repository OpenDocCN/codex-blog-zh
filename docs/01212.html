<html>
<head>
<title>Benchmarking Static Analysis Tools for C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C语言的基准静态分析工具</h1>
<blockquote>原文：<a href="https://medium.com/codex/11-static-analysis-tools-for-c-4fe5f63c18a5?source=collection_archive---------8-----------------------#2021-04-11">https://medium.com/codex/11-static-analysis-tools-for-c-4fe5f63c18a5?source=collection_archive---------8-----------------------#2021-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8eee" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">关于在C/C++的SARD Juliet测试套件上评估11个用于C编程语言的开源通用SAST工具的报告。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/67f365f02fb6507cd318fe4812c3a870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CftJ0wKvDHD_xQUI.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图片由来自<a class="ae jn" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank">像素</a>的Pixabay提供</figcaption></figure><p id="0dfc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你是开发商吗？如果是这样，你可以理解我的问题:</p><blockquote class="kk kl km"><p id="94a7" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated"><em class="hi">作为一名软件开发人员，如果我使用某种静态分析工具，我能对代码的安全性有什么期望？</em></p></blockquote><p id="4f4c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从这个角度来看，SAST工具也可以被看作是开发人员的一种“保险”:“如果我运行这个工具，我的代码基本上是安全的”。</p><h1 id="4cbf" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">项目动机</h1><p id="17b0" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">有各种各样的工具，无论是商业的还是开源的，都或多或少地声称要做“安全性分析”。从对Debian Linux发行版中的故障模式和漏洞的初步调查开始，我发现一半的漏洞是与内存管理相关的编码错误，其次是与资源管理相关的错误、被污染的输入和有风险的值。因此，我决定使用Juliet测试套件作为我的评估数据集，因为它以相似的权重覆盖了这些弱点。由于各种各样的工具和技术可能会让开发人员感到困惑，很明显，对他们的能力进行评估是可取的。<a class="ae jn" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.500-326.pdf" rel="noopener ugc nofollow" target="_blank"> Juliet测试套件</a>是专门为评估SAST工具的能力而开发的，包含100k个文件中的64099个测试用例。该套件涵盖了100多个不同的弱点，包括所有主要的软件故障模式，并满足了具有地面真实性和统计显著性的要求。因此，精度和召回指标是适用的。</p><p id="16cd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下表根据NVD严重性分数的总和，列出了C包的前10个CWE。显然，“缓冲区溢出”仍然是C程序中的主要缺陷，其次是其他几个与内存相关的漏洞。为了提供更全面的概述，还映射了与C相关的CWE到<a class="ae jn" href="https://cwe.mitre.org/data/definitions/888.html" rel="noopener ugc nofollow" target="_blank"> CWE层级</a>的软件故障模式(SFP)视图的簇。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lo"><img src="../Images/5710eb2542d2b45be7571d1b1abc3a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*croCZuUH7rldb4ee.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">以C为主要语言的Debian软件包中的十大漏洞</figcaption></figure><h1 id="e3f5" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">合成测试案例的评估程序</h1><p id="2f57" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">对于所有工具，在进行这项研究时，Ubuntu 18.04 LTS的最新稳定版本是在英特尔i7–6600 u CPU @ 2.60 Ghz下的虚拟化环境中选择的，磁盘大小为150GB，内存为16GB。因为我们的兴趣是只考虑工具的召回率和精确度，而不是它们的资源使用情况，所以没有为基准测试实现工具的资源控制。</p><p id="9546" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">逐个文件地对数据集运行工具，并记录工具报告。工具报告被收集在数据库中用于进一步处理。将工具的发现与Juliet测试套件清单文件进行比较，通过文件和行号为测试用例指定准确的缺陷位置。如果一个工具的发现和一个关于报告位置的测试用例相匹配，我认为这是一个真正的肯定。如果一个工具报告了另一个位置，我认为这是一个误报。根据测试用例是代表“好的”还是“坏的”代码，所有未报告的位置被视为真的或假的否定。注意，我以这种方式假设条件否定的总和等于所有测试用例的代码行。这与原始程序相反，在原始程序中，条件否定的总和等于测试用例的总和。在这种情况下，与默认的Juliet测试套件过程的50:50的机会相比，获得真阳性或真阴性的概率应该更现实。虽然，这是以惩罚在不同位置报告正确错误的工具为代价的，否则就奖励报告所有错误缺陷类型的工具。使用真/假阳性/阴性的计数，计算工具的<a class="ae jn" href="https://en.wikipedia.org/wiki/Precision_and_recall" rel="noopener ugc nofollow" target="_blank">精度</a>、<a class="ae jn" href="https://en.wikipedia.org/wiki/Precision_and_recall" rel="noopener ugc nofollow" target="_blank">召回</a>和马修斯相关系数(<a class="ae jn" href="https://en.wikipedia.org/wiki/Matthews_correlation_coefficient" rel="noopener ugc nofollow" target="_blank"> MCC </a>)。通过F分数平均精确度和召回率，这样的工具将获得合理的排名。</p><blockquote class="kk kl km"><p id="3fc9" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">为了弥补这一点，我使用了MCC而不是F分数。这种方法也不利于在不同代码位置报告预期漏洞的工具，以及发现预期缺陷以外的其他缺陷的工具。</p></blockquote><p id="9079" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用的指标，即精度、召回率、MCC，定义如下:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lp"><img src="../Images/3d28240c3ed24d018eca0422cad7388a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gFAlYIwxhDJNdNyw.png"/></div></div></figure><p id="bf5d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与F分数相比，MCC奖励更多的真阴性分数。<em class="kn">这不利于报告每个位置的高噪声工具</em>。当处理不平衡数据集时，通常建议使用MCC，这是漏洞的常见情况。</p><h1 id="3d6f" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">要显示的结果</h1><p id="a993" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">下图显示了在Juliet测试套件上测试的所有11个SAST工具的测量精度、召回率和MCC。显然，这些工具的精确度有所不同。关于召回，一些工具几乎什么也没发现(OCLINT)，而其他工具发现了所有测试漏洞的50%以上(AdLint，Frama-C)。关于精确度，有一些工具几乎每两个发现中就有一个是真阳性(Pscan ),还有一些工具，开发人员必须通过数百个发现才能得到一个真阳性(OCLINT)。特别是两个工具显示了精确度和召回率之间的差距。Pscan似乎在某些类型的漏洞方面非常专业，因此它发现的漏洞召回率很低，但精确度很高。AdLint工具显示了良好的召回率，但这是以不良的精度为代价的。事实上，AdLint为大约1/8的测试套件产生了警告，总共产生了80万个警告。请注意，报告每一行代码为漏洞的工具可以获得100%的召回率。</p><p id="b603" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们可以观察到，精确度和召回率的不同特征导致一些工具的MCC几乎一致。因此，AdLint、Clang-Tidy、CppCheck和Flawfinder的准确性几乎不相上下，而声音工具Frama-C和IKOS则非常出色。这一结果与相关工作[1，2，3，4]中的发现一致，其中Frama-C的排名相似。IKOS没有可比性，因为它没有包括在这些评估中。其他据报道准确性较好的工具是Clang和CppCheck。在这个实验中，我证实了CppCheck的高精度和Clang的合理回忆。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lq"><img src="../Images/66b32c59b75be8269bc9b8c2437e3504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HQ2wkwqhFbiBEsKd.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Juliet测试套件的精度、召回率和MCC指标</figcaption></figure><h1 id="c9b2" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">下一步是什么？</h1><p id="382e" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">开发一个作为开放标准的基准测试套件，工具开发人员和安全专家可以加入其中，以促进现实的SAST工具基准测试，这将是一个普遍的兴趣。为了应对基准和工具的快速过时，建立SAST工具的定期和自动化评估，例如，模拟软件验证社区中的类似工作，将是一个有价值的贡献。在评估中包括更多的SAST工具，特别是软件验证器，我故意选择从我的评估中排除，也将允许绘制一个更广泛的图片。然而，我相信这项研究可以成为一个有价值的构建模块，为c语言创建一个更大的SAST工具的状态</p><p id="98e1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">总之，根据这项研究，我可以确定Frama-C是被评估的工具中最好的，尽管它并没有特别关注安全性。另一个声音工具IKOS，之前还没有在Juliet测试套件上评测过，表现类似，在我的基准测试中排名第二。虽然我的评估考虑了该工具在所有其他SFP集群上的性能，但未来工作的前景是进行更具选择性的分析，仅考虑工具声称的漏洞类型。</p><p id="11cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">复制包在<a class="ae jn" href="https://github.com/RohanKrishnamurthy/sastevaluation" rel="noopener ugc nofollow" target="_blank">在线</a>可用。</p><h1 id="92ad" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">参考</h1><ol class=""><li id="2daf" class="lr ls hi jq b jr lj ju lk jx lt kb lu kf lv kj lw lx ly lz bi translated">阿鲁苏艾，美国，Ciobacă，̧.南部、Craciun，v .、Gavrilut，d .、Lucanu，d .:C/c++代码中漏洞检测的开源静态分析工具比较。(2017)在:SYNASC。第161-168页。IEEE计算机学会</li><li id="72e9" class="lr ls hi jq b jr ma ju mb jx mc kb md kf me kj lw lx ly lz bi translated">Chatzieleftheriou，g .，Katsaros，p .:测试驱动静态分析工具以寻找C代码漏洞。(2011年)载于:COMPSAC年研讨会。第96-103页。IEEE计算机学会</li><li id="0e21" class="lr ls hi jq b jr ma ju mb jx mc kb md kf me kj lw lx ly lz bi translated">陆，b，董，w，尹，l，张，l:为有效的程序分析评估和整合不同的缺陷发现器。(2018)年:日。计算机科学讲义，第11293卷，第51-67页。起拱石</li><li id="3f7a" class="lr ls hi jq b jr ma ju mb jx mc kb md kf me kj lw lx ly lz bi translated">Moerman，j .，Smetsers，s .，Schoolderman，m .:评估开放源码静态分析工具的性能。(2018)学士论文，荷兰拉德布大学。</li></ol></div></div>    
</body>
</html>