<html>
<head>
<title>Intro to Multiplayer in Unity with Photon</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多人游戏中的光子入门</h1>
<blockquote>原文：<a href="https://medium.com/codex/intro-to-multiplayer-in-unity-with-photon-eea70ca054fe?source=collection_archive---------4-----------------------#2021-01-25">https://medium.com/codex/intro-to-multiplayer-in-unity-with-photon-eea70ca054fe?source=collection_archive---------4-----------------------#2021-01-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="1155" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><div class=""><h2 id="3395" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">多人游戏编程是棘手的，所以让我们从使用网络游戏对象的基础开始。</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/1455fdead4cc42e24905d7fd4ce60c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pe1x_739R-QdjAxFmWRYHg.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">由<a class="ae jw" href="https://unsplash.com/@florianolv?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗洛里安·奥利佛</a>在<a class="ae jw" href="https://unsplash.com/s/photos/gaming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="193c" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我最珍贵的记忆是和朋友一起玩多人游戏，无论是在网上还是在沙发上。通宵玩光晕，在地下室喝汽水是我们对美好周末的定义。现在我已经踏上了自己的游戏开发之旅，我迫不及待地希望能够构建自己的多人游戏，这样其他人就可以创造自己的回忆了。</p><p id="f27b" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">不幸的是，即使像Unity和Photon这样的工具在易用性方面取得了巨大的进步，也很难直接进入网络化多人编程。在线多人游戏要求你以一种完全不同的方式来看待你的游戏，这种观念上的转变对我来说是一个巨大的绊脚石。在这篇文章中，我将解释如何转变你的思维，用Unity和Photon创建多人游戏。</p><h1 id="c21e" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">引入光子</h1><p id="a3d3" class="pw-post-body-paragraph jx jy hi jz b ka ll is kc kd lm iv kf kg ln ki kj kk lo km kn ko lp kq kr ks hb bi translated">光子是一个伟大的软件包，它为你提供了我们进行多人游戏编程所需的各种代码。为了将重点放在概念上，我们将轻松完成设置步骤。使用Photon非常容易，他们网站上的说明应该足以帮助他们进行设置(<a class="ae jw" href="https://doc.photonengine.com/en-us/pun/current/getting-started/pun-intro" rel="noopener ugc nofollow" target="_blank">https://doc . photonengine . com/en-us/pun/current/getting-started/pun-intro</a>)。基本上，您需要:</p><ul class=""><li id="1db8" class="lq lr hi jz b ka kb kd ke kg ls kk lt ko lu ks lv lw lx ly bi translated">创建一个光子帐户。</li><li id="ae12" class="lq lr hi jz b ka lz kd ma kg mb kk mc ko md ks lv lw lx ly bi translated">通过Photon站点创建一个应用程序来获得一个应用程序ID。</li><li id="db9d" class="lq lr hi jz b ka lz kd ma kg mb kk mc ko md ks lv lw lx ly bi translated">通过包管理器将Photon包添加到Unity项目中。</li><li id="ac7e" class="lq lr hi jz b ka lz kd ma kg mb kk mc ko md ks lv lw lx ly bi translated">在Unity中，运行Photon设置向导来输入您的应用程序ID。</li></ul><p id="094a" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">由于Photon为您提供了一些基本的<strong class="jz hs">免费</strong>用法，您将能够处理多达20个并发用户，而无需进行额外的配置！</p><h1 id="06bc" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">多人多元宇宙</h1><p id="7b57" class="pw-post-body-paragraph jx jy hi jz b ka ll is kc kd lm iv kf kg ln ki kj kk lo km kn ko lp kq kr ks hb bi translated">我最初认为，当我玩在线多人游戏时，就好像每个玩家在某个地方都有一个进入单个游戏实例的窗口。我以为我的命令被发送到那个游戏实例，而我只是看到了游戏的结果，有点像每个人都在看同一个电视节目。从技术上来说，你可以像那样制作你的多人游戏，但是我们将使用一个不同的模型。取而代之的是，每个玩家(也被称为<strong class="jz hs">客户端</strong>)在他们自己的电脑上运行一个<strong class="jz hs">独立的游戏实例</strong>。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es me"><img src="../Images/5a91841a8c339862d82fa0219488042f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ao6rPQwL3AhrxUuzovScMQ.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">照片由<a class="ae jw" href="https://unsplash.com/@jannerboy62?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">尼克·费因斯</a>在<a class="ae jw" href="https://unsplash.com/s/photos/identical?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="05be" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">让我们暂时忽略玩家的输入，想象我们有一个游戏，它从创建一个环境开始。如果你和我加入同一个游戏，那么我们的每台电脑都将独立运行游戏的代码。例如，代码可能放置一些钥匙，锁一些门，初始化一些炸药桶。结果是你和我将会看到完全相同的游戏关卡，考虑到运行的<strong class="jz hs">完全相同的</strong>代码，这是有意义的。</p><p id="dca8" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">在很大程度上，我们不需要改变游戏逻辑的编码方式。无论连接了多少个客户端，都应该应用相同的规则。即使有128个人在玩，也应该有代码说一个桶如果被击中应该会爆炸。当我们不得不考虑如何保持所有客户端<strong class="jz hs">同步</strong>时，棘手的事情就开始了。例如，如果我在游戏中射击一个桶，我们需要确保你的游戏显示我的角色射击和桶爆炸。</p><h1 id="fa8d" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">壮丽的风景</h1><p id="1e7d" class="pw-post-body-paragraph jx jy hi jz b ka ll is kc kd lm iv kf kg ln ki kj kk lo km kn ko lp kq kr ks hb bi translated">光子包给了我们一个叫做<code class="du mf mg mh mi b">PhotonView</code>的单行为组件，好家伙，它要做一些工作了！当你给一个游戏对象附加一个<code class="du mf mg mh mi b">PhotonView</code>时，你就说这个游戏对象在所有客户端上都是相同的<strong class="jz hs">。这意味着，如果一个给定的桶有<code class="du mf mg mh mi b">photonViewID = 1</code>，我们在我的游戏实例中对那个桶做的任何事情都可以与你的游戏实例中的相同桶同步。如果我的桶爆炸，它可以告诉其他客户端中的所有其他版本也爆炸。</strong></p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mj"><img src="../Images/73428bb63454b7c19cdea813cbc0b516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqxMsZwHXOAPXe7eEiYtng.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">斯蒂芬·拉德福德在<a class="ae jw" href="https://unsplash.com/s/photos/explosion?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d1ec" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">照片视图使用名为<strong class="jz hs"> RPC的</strong>函数进行通信。如果一个函数被指定为RPC，那么它可以被其他客户端中的其他版本调用。RPC看起来是这样的:</p><pre class="jh ji jj jk fd mk mi ml mm aw mn bi"><span id="163a" class="mo ku hi mi b fi mp mq l mr ms">public class LaserShot: MonoBehaviourPun<br/>{<br/>  public GameObject laserBeam;</span><span id="b7e7" class="mo ku hi mi b fi mt mq l mr ms">  private void Update()<br/>  {<br/>    if (Input.GetKeyDown(KeyCode.A))<br/>    {<br/>      ShootLaser();<br/>    }<br/>  }</span><span id="00c5" class="mo ku hi mi b fi mt mq l mr ms">  public void ShootLaser()<br/>  {<br/>    laserBeam.SetActive(true);<br/>    this.photonView.RPC("ShootLaser_RPC", RpcTarget.Others);<br/>  }</span><span id="06a9" class="mo ku hi mi b fi mt mq l mr ms">  [PunRPC]<br/>  private void ShootLaser_RPC()<br/>  {<br/>    laserBeam.SetActive(true);<br/>  }<br/>}</span></pre><p id="9f8c" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><em class="mu">(快速旁白:</em> <code class="du mf mg mh mi b"><em class="mu">MonoBehaviourPun </em></code> <em class="mu">与</em> <code class="du mf mg mh mi b"><em class="mu">MonoBehaviour</em></code> <em class="mu">相同，它只是允许你自动访问同一个游戏对象上的一个</em> <code class="du mf mg mh mi b"><em class="mu">PhotonView</em></code> <em class="mu">组件，而不必使用一个</em> <code class="du mf mg mh mi b"><em class="mu">GetComponent</em></code> <em class="mu">调用。)</em></p><p id="6851" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">在这个例子中，每个客户端都有一个角色游戏对象，它有一个<code class="du mf mg mh mi b">LaserShot</code>组件和一个<code class="du mf mg mh mi b">PhotonView</code>组件。</p><ul class=""><li id="171a" class="lq lr hi jz b ka kb kd ke kg ls kk lt ko lu ks lv lw lx ly bi translated">我的游戏实例中的角色调用它的<code class="du mf mg mh mi b">ShootLaser</code>函数，这将激活它在我的游戏中的<code class="du mf mg mh mi b">laserBeam</code>。</li><li id="7d9b" class="lq lr hi jz b ka lz kd ma kg mb kk mc ko md ks lv lw lx ly bi translated">然后，<code class="du mf mg mh mi b">this.photonView.RPC</code>向这个角色游戏对象的所有其他版本发送一个消息(通过<code class="du mf mg mh mi b">RpcTarget.Others</code>参数)告诉它们调用它们的<code class="du mf mg mh mi b">ShootLaser_RPC</code>函数。</li></ul><p id="6e9a" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这里发生的是，我的游戏对象版本激活了它的激光束，然后同一个游戏对象的所有其他版本也收到一个调用来激活它们的激光束。<code class="du mf mg mh mi b">ShootLaser_RPC</code>，可以被称为任何东西，重要的是函数前面有<code class="du mf mg mh mi b">[PunRPC]</code>。</p><h1 id="74bc" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">我的就是我的</h1><p id="f8ca" class="pw-post-body-paragraph jx jy hi jz b ka ll is kc kd lm iv kf kg ln ki kj kk lo km kn ko lp kq kr ks hb bi translated">上面的例子有一个很大的问题。请记住，每个客户端运行的都是同一个游戏的副本。这意味着如果你和我在一场死亡竞赛中，我们每个人都会有一个有两个角色的游戏。由于我的游戏版本有两个角色，每个角色都有一个<code class="du mf mg mh mi b">LaserShot</code>组件，那么点击“A”键将调用每个角色的<code class="du mf mg mh mi b">ShootLaser</code>功能。没有代码来决定我能控制哪个角色！</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mv"><img src="../Images/8761f5044ee4e924ecb4cc8b13df33a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBycq3-c7kXbxQmt94Gkrw.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">照片由<a class="ae jw" href="https://unsplash.com/@maximalfocus?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">最大焦点</a>在<a class="ae jw" href="https://unsplash.com/s/photos/laser?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">不飞溅</a>上拍摄</figcaption></figure><p id="6612" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">不要担心，因为<code class="du mf mg mh mi b">photonView</code>有一个所有权的概念，你可以用这个所有权来决定你的键盘命令是否应该作用于一个特定的游戏对象。</p><p id="df87" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">光子网络游戏中的每个客户端都被称为一个<code class="du mf mg mh mi b">Player</code>，<code class="du mf mg mh mi b">photonView</code>的主人可以被设定为一个给定的<code class="du mf mg mh mi b">Player</code>。在游戏过程中，您可以通过<code class="du mf mg mh mi b">isMine</code>查询一个<code class="du mf mg mh mi b">photonView</code>是否属于本地客户端:</p><pre class="jh ji jj jk fd mk mi ml mm aw mn bi"><span id="1918" class="mo ku hi mi b fi mp mq l mr ms">private void Update() {<br/>  if (this.photonView.isMine &amp;&amp; Input.GetKeyDown(KeyCode.A))<br/>  {<br/>    ShootLaser();<br/>  }<br/>}</span></pre><p id="b4df" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">或者更好的模式:</p><pre class="jh ji jj jk fd mk mi ml mm aw mn bi"><span id="5210" class="mo ku hi mi b fi mp mq l mr ms">private void Update() {<br/>  if (!this.photonView.isMine)<br/>  {<br/>    return;<br/>  }</span><span id="e4dd" class="mo ku hi mi b fi mt mq l mr ms">  if (Input.GetKeyDown(KeyCode.A)<br/>  {<br/>    ShootLaser();<br/>  }<br/>}</span></pre><p id="cc75" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">现在，即使两个玩家都在运行他们的<code class="du mf mg mh mi b">Update</code>功能，只有拥有属于你的<code class="du mf mg mh mi b">photonView</code>的玩家会真正响应输入！</p><h1 id="3c0e" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">非常好</h1><p id="b3a6" class="pw-post-body-paragraph jx jy hi jz b ka ll is kc kd lm iv kf kg ln ki kj kk lo km kn ko lp kq kr ks hb bi translated">保持同步需要大量的工作，因此Photon为您提供了更多的组件，让您的生活变得更加轻松。</p><p id="1360" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">如果你还添加了<code class="du mf mg mh mi b">PhotonTransformView</code>组件，那么游戏对象的位置、旋转和比例可以在客户端之间自动<strong class="jz hs">保持同步</strong>。这意味着你可以专注于让每个玩家控制他们自己角色的移动，这些属性将在游戏的其他版本中更新！</p><p id="28f8" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">类似地，<code class="du mf mg mh mi b">PhotonAnimatorView</code>组件将保持动画参数同步。只要每个玩家控制他们自己的动画师参数，他们将会在游戏的每个版本中自动更新！</p><h1 id="eb94" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">冷静</h1><p id="5c1f" class="pw-post-body-paragraph jx jy hi jz b ka ll is kc kd lm iv kf kg ln ki kj kk lo km kn ko lp kq kr ks hb bi translated">咻，要涵盖的内容太多了！对于网络编程，我们需要学习很多新的模式，但是这些基本概念是你处理问题的方式。这很复杂，但非常可行。我希望这有助于澄清围绕光子和RPC的一些困惑，请随时询问您可能有的任何问题！</p></div></div>    
</body>
</html>