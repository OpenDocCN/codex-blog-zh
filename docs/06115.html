<html>
<head>
<title>Writing Unit Tests for My Game in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Unity中为我的游戏编写单元测试</h1>
<blockquote>原文：<a href="https://medium.com/codex/writing-unit-tests-for-my-game-in-unity-b0163e2c9b47?source=collection_archive---------14-----------------------#2022-04-09">https://medium.com/codex/writing-unit-tests-for-my-game-in-unity-b0163e2c9b47?source=collection_archive---------14-----------------------#2022-04-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5b00" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">假设你已经知道基本的C#和Unity</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/29948bb1b3fc9671bd4691a8b5831659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zIaSC2vRB8gPhWAv4WWGVA.png"/></div></div></figure><p id="52f4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你们中的大多数人一定已经知道我目前正在Unity开发一款游戏，名为《小丑之夜》。这是一个3D低聚第一人称射击游戏，生存恐怖游戏，你被困在一个主题公园，你将努力摆脱出来。别担心，我不会在这里推广它(抱歉，我刚刚做了)，只需在我们的<a class="ae kf" href="https://www.instagram.com/stationrgames/" rel="noopener ugc nofollow" target="_blank"> Instagram页面</a>上查看一下！在这篇文章中，我想说的是Unity中的单元测试。坐着别动，继续读下去！</p><blockquote class="kg"><p id="79bf" class="kh ki hi bd kj kk kl km kn ko kp ke dx translated">当代码运行得非常好的时候，为什么还要测试它呢？</p></blockquote><p id="4fe5" class="pw-post-body-paragraph jj jk hi jl b jm kq ij jo jp kr im jr js ks ju jv jw kt jy jz ka ku kc kd ke hb bi translated">在我作为一名从事硬盘工作的固件开发人员的第一次实习经历中，我遇到了单元测试这个话题。然而，我害怕单元测试的概念，因为我对它一无所知。像大多数开发人员一样，我过去常常嘲笑“测试”代码的想法。"当代码运行良好时，为什么要测试它？"这正是我心中的疑问。开门见山，当我开始开发《小丑之夜》时，我才知道单元测试的重要性。</p><blockquote class="kg"><p id="191c" class="kh ki hi bd kj kk kl km kn ko kp ke dx translated">亲吻(保持简短)</p></blockquote><p id="d54e" class="pw-post-body-paragraph jj jk hi jl b jm kq ij jo jp kr im jr js ks ju jv jw kt jy jz ka ku kc kd ke hb bi translated">简单地说，单元测试是一段测试你的代码的一个“单元”的代码。听起来简单又愚蠢，对吧？应该就是这么简单。但不傻。事实上，单元测试是用来验证一小段逻辑代码的，所以它在特定的场景中完全按照我们想要的方式执行。嗯，理想的做法是将这段代码一般化，使其适用于任何情况。但是保持你的代码简短是很重要的，这样它才能很好地执行每一个也是唯一一个任务——接吻(保持简短)。</p><p id="e8f0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，让我们动手编写Unity中一个简单函数的单元测试。这个单元测试也是我用来评估我的代码片段的。首先，让我们在Unity中设置单元测试特性。Unity的好处在于它提供了Test Runner，这是一个在C#中使用NUnit框架的单元测试特性。它基本上是一个开源测试框架，支持隔离模块中的单元测试。在这里阅读更多<a class="ae kf" href="https://docs.nunit.org/articles/nunit/intro.html" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="438c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在Unity中，直接进入窗口&gt;常规&gt;测试运行程序。对于本文，让我们只在编辑模式下编写一个单元测试，在这里我们可以测试任何不必在播放模式下运行的脚本。在Test Runner中，点击“在当前文件夹中创建测试脚本”按钮，这将允许Unity做两件事:</p><ol class=""><li id="74e3" class="lc ld hi jl b jm jn jp jq js le jw lf ka lg ke lh li lj lk bi translated">创建一个汇编定义文件(这对于将文件依赖与我们的生产代码分开是很重要的)。</li><li id="a174" class="lc ld hi jl b jm ll jp lm js ln jw lo ka lp ke lh li lj lk bi translated">创建一个测试脚本(我们可以将它重命名为我们想要的任何名称，只需给它一个相关的名称)。</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lq"><img src="../Images/d836cd6c88bacf32f60372cdb5b93339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*H693wzEXy6ptYH6KHU9wTA.png"/></div></figure><p id="1b90" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是当测试脚本被创建时你将得到的。如果第二个函数引起了您的注意，那是因为它是一个协程函数。别担心，我们今天不会用到它，你可以随意查找，因为它在为你的游戏编写脚本时被广泛使用。</p><p id="1e72" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如您已经从第一个函数内部的行注释中看到的，使用Assert类来测试条件，这就是我们今天要使用的。在本文中，我将为我的健康组件编写一个单元测试。和任何角色一样，无论是玩家、NPC还是敌人，都需要健康元素。我们会在运行之前或运行期间单独设置它们的健康状况，但更重要的是，我们需要确保设置健康状况的函数正确运行并返回正确的健康数字。然后，就像任何角色一样，它可以承受导致生命值下降的伤害，或者服用生命药剂来增加生命值。那么，让我们在这里定义我们的规则:</p><ol class=""><li id="1160" class="lc ld hi jl b jm jn jp jq js le jw lf ka lg ke lh li lj lk bi translated">在运行之前或运行期间实例化健康时，它应该返回正确的健康值，并且小于最大健康值。</li><li id="f036" class="lc ld hi jl b jm ll jp lm js ln jw lo ka lp ke lh li lj lk bi translated">当且仅当生命值大于零时，它会受到伤害，并返回递减的生命值。</li><li id="4e59" class="lc ld hi jl b jm ll jp lm js ln jw lo ka lp ke lh li lj lk bi translated">当且仅当健康低于最大健康且高于零时，它可以被递增，并且它应该返回递增的健康。</li></ol><p id="5a96" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当然，接下来，我们还需要处理一些极端情况，比如:</p><p id="cd9d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">4.如果生命值低于零，检查它是否能承受伤害，它应该返回零而不是负数。</p><p id="8caf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">5.如果生命值等于或高于最大生命值，并且玩家服用了一剂生命药剂，它应该返回最大生命值。</p><p id="bfcd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">显然，我们需要一个健康的组成部分。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/293f359b61e6eef03469210238166756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AIPg7UELu01Uf9qKlPEH2w.png"/></div></div></figure><p id="1c4e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了本文的简单起见，我们将只使用这个构造函数，它通过给定以下内容来创建一个健康对象:</p><ul class=""><li id="6c9f" class="lc ld hi jl b jm jn jp jq js le jw lf ka lg ke ls li lj lk bi translated">游戏对象应该具有的当前健康状况</li><li id="d211" class="lc ld hi jl b jm ll jp lm js ln jw lo ka lp ke ls li lj lk bi translated">游戏对象应该拥有的最大健康值</li><li id="7889" class="lc ld hi jl b jm ll jp lm js ln jw lo ka lp ke ls li lj lk bi translated">健康变化事件(这是Unity事件系统，我们将在以后的文章中讨论)</li><li id="218e" class="lc ld hi jl b jm ll jp lm js ln jw lo ka lp ke ls li lj lk bi translated">当健康值为零时的事件</li></ul><p id="3e16" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们设定我们的起始健康并测试它。</p><h2 id="ab2d" class="lt lu hi bd lv lw lx ly lz ma mb mc md js me mf mg jw mh mi mj ka mk ml mm mn bi translated">1.Health_SetStartingHealth</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mo"><img src="../Images/6e0687d179775469b44e2f6046d422c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*9moRnCZJoTkZ4wekUD1obg.png"/></div></figure><p id="6423" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">从这里，你可以清楚地看到测试函数上面的<strong class="jl hj"> TestCase </strong>属性。大括号中的整数对应于函数的参数。因此，我们可以传入多组数字来测试函数，但是我们肯定会在尽可能短的测试用例中涵盖所有的极限情况。使用<strong class="jl hj">断言<em class="mp">。IsTrue() </em> </strong>，我们只想比较创建的健康变量是否确实等于我们在<strong class="jl hj">测试用例</strong>属性中传递的内容。</p><h2 id="6b8b" class="lt lu hi bd lv lw lx ly lz ma mb mc md js me mf mg jw mh mi mj ka mk ml mm mn bi translated">2.health _ takedamagebovezerohealth _ ReturnsDecrementedHealth</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/1204ab769bf79b645427c4e6edc129a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJo0DwS73Hil_86knRcT4Q.png"/></div></div></figure><p id="8829" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">忽略TakeDamage()函数，但只知道造成了损害，我们希望确保返回的生命值等于初始生命值减去损害值。简单！</p><h2 id="f642" class="lt lu hi bd lv lw lx ly lz ma mb mc md js me mf mg jw mh mi mj ka mk ml mm mn bi translated">3.health _ increasehealthblowmaxhealth _ ReturnsIncrementedHealth</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/036622a5b2f98e380acaa19421134d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lJe2GRt9WZxMo26fEJdw3Q.png"/></div></div></figure><p id="d2fb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">类似地，对于增量健康，我们希望确保返回的健康等于开始健康和增量的总和，假设它低于最大健康。</p><h2 id="5d8d" class="lt lu hi bd lv lw lx ly lz ma mb mc md js me mf mg jw mh mi mj ka mk ml mm mn bi translated">4.health _ TakeDamageBelowZeroHealth _ ReturnsZero</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ms"><img src="../Images/6105221a9a72560aaadb06fdc7529f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*rVWxdHTG3LlubbO6xbd3Og.png"/></div></figure><p id="21fe" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当玩家或任何角色的生命值低于零，但仍然受到伤害时，无论如何生命值都应该等于零。</p><h2 id="a4bb" class="lt lu hi bd lv lw lx ly lz ma mb mc md js me mf mg jw mh mi mj ka mk ml mm mn bi translated">5.health _ increasehealthboathmaxhealth _ ReturnsMaxHealth</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mt"><img src="../Images/040c88f4abcb3148983353fb4343ce40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSmIHnbPHvtqhp-nBlrJFQ.png"/></div></div></figure><p id="8196" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">类似地，如果健康状况已经高于最大预定值，则应该将其设置为最大值，甚至进一步增加。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="9679" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当您完成了由多个测试组成的整个测试套件的编写后，是时候在Unity中运行它了！</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mu"><img src="../Images/628cc9811c08f2085a54fac66ce7d18e.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*B_gNeMC0A-LCn-SFmrDDig.png"/></div></figure><p id="cae7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在选择了您刚刚创建的健康测试后，只需按“运行所选项目”，然后<em class="mp">瞧</em>！我们最不想要的就是失败的测试，所以只要确保你知道你正在运行什么测试。</p></div><div class="ab cl kv kw gp kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hb hc hd he hf"><p id="c0b3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在本文中，我展示了如何使用内置的测试运行器对Unity中的组件执行单元测试。单元测试经常被忽视，但它是保证代码简短的可靠方法，因为它们测试的都是功能单元。我希望你能在编写单元测试中获得乐趣，因为这仍然是我偶尔喜欢做的最好的事情之一。快乐发展！</p></div></div>    
</body>
</html>