<html>
<head>
<title>Managing Tensorflow models with SQLite3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQLite3管理张量流模型</h1>
<blockquote>原文：<a href="https://medium.com/codex/managing-tensorflow-models-with-sqlite3-87e45e6426c7?source=collection_archive---------31-----------------------#2022-06-13">https://medium.com/codex/managing-tensorflow-models-with-sqlite3-87e45e6426c7?source=collection_archive---------31-----------------------#2022-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="639e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的上一篇文章中，(<a class="ae jd" rel="noopener" href="/p/93c82361d0e9">https://medium.com/p/93c82361d0e9</a>)我们研究了预测金融数据时的常见错误，并开发了我们自己的管道和各种各样的定制工具。在运行了一些回溯测试之后，我意识到:我的模型太多了！我不记得哪些模型做得很好，或者它们有什么参数。灾难！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/3d294edb14765316cb063a460600627c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*drTTN5CkmPleWEFQRqLMCg.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">被所有的模型淹没</figcaption></figure><p id="ccba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，让我们使用SQL数据库来组织我们的模型。这将达到两个目的:</p><ol class=""><li id="4fed" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">在一个地方跟踪我们的模型及其参数，以防我们想要重新创建我们的模型，训练类似的模型，继续训练具有不同超参数的现有模型，或者只是欣赏我们的模型帝国。</li><li id="944a" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">在一个地方可以方便地访问模型参数，以防我们想要创建一个RestAPI(我们将在后面创建)或出于任何其他目的控制我们的本地应用程序变量。</li></ol><p id="5bca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们将结合Python使用SQLite3。</p><p id="115a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们的第一步</strong>是找出我们的数据库模式。我决定使用2个表:Model和Adam_Optimizer。</p><p id="7f69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">模型表将存储模型名称、模型类型、输入形状等参数，以及其他变量，如模型的训练时间间隔和训练时使用的跑马灯数据。</p><p id="66fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Adam_Optimizer表将存储我们的Adam优化器的参数。在我的项目中，我只使用亚当——所以这让我们的生活变得非常简单。如果我们要制作一个包含各种优化器的表，我们需要弄清楚如何处理数量可变的参数——最有可能的方法是将整个参数字典存储为一个BLOB对象。不管怎样，这是一个未来的项目，现在，我们的任务相当简单。</p><p id="76a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">那么，我们开始吧！</strong></p><p id="bc3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用SQLite3，我们首先必须建立到数据库的连接:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="bfa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将连接到我们的数据库。不存在数据库吗？没问题，会创建一个。</p><p id="3dba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们继续之前，我们使用与我上一篇文章中的项目相同的结构。(如果你对密码、市场、深度学习感兴趣，就去读吧！<a class="ae jd" rel="noopener" href="/p/93c82361d0e9">https://medium.com/p/93c82361d0e9</a></p><p id="ba0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的模型使用root/models/interval/ticker/type文件夹子结构，其中interval是时间间隔，ticker是用来训练模型的加密资产，type是模型的类型(例如LSTM)。</p><p id="b3cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我也有ensembly_average类型，这是一个简单的集合，我们以前使用它来平均几个模型。</p><p id="3d75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">澄清了所有这些之后，下面是我们的表格:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="efb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在优化器和模型表之间有一个一对多的关系，这样我们就不必保存优化器的副本(因为一个设置可以用于几个模型)。为了表示这一点，我们将在模型表中的优化器表的“optimizer_id”上使用一个外键属性。我将在后面解释其余的专栏。</p><p id="e676" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要创建这些新表，我们必须使用游标对象，这是一种连接到数据库的方法:</p><pre class="jf jg jh ji fd kk kl km kn aw ko bi"><span id="4555" class="kp kq hi kl b fi kr ks l kt ku">cursor_obj = connection.cursor()<br/>cursor_obj.execute(create_model_table)</span></pre><p id="025c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们需要为在数据库中插入值创建准备好的语句。幸运的是，这对于SQLite3来说非常容易！</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="edfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我们对adam_opt表使用INSERT或IGNORE，这样我们就不会存储任何重复的优化器。运行这两个函数，同时为它们提供一个参数字典，将会在我们的数据库中插入一个单独的条目。</p><p id="d89b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现在是有趣的部分</strong>:获取我们的模型参数并传递给他们。</p><p id="7941" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将通过扫描我们项目中的所有现有模型并将它们的参数写入字典来完成。这样，我们可以用已经存在的模型填充数据库。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="8bfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们初始化一个空字典来存储我们的参数。然后我们将建立一个到我们模型的路径——在我的例子中，我从/sql/ folder运行这个脚本，所以我将获取当前文件夹，并使用pathlib(【https://docs.python.org/3/library/pathlib.html】T2——这真的很好！)库，方法是调用. parent方法转到上一个文件夹。然后，我们将加入我们的模型文件夹，瞧！</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="2bdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将使用os.walk函数遍历models文件夹中的所有文件。我们只对最终文件感兴趣，对任何中间文件夹都不感兴趣，所以我们做了一个额外的循环。我们需要定义我们的有效模型类型——因为我们可能在那里有集合文件夹，我们现在不想使用它们。</p><p id="34a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后使用。split python方法我们可以得到最终文件夹的名称——这将是我们模型的类型。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="c420" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将使用if语句来检查我们的文件是否具有. h5扩展名(Tensorflow默认使用的扩展名)以及文件夹是否在valid_model_types中(整体文件夹将包含我们不想要的模型的副本)。</p><p id="e3f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的第一个参数model_name非常容易获得——只需读出for循环的name变量。</p><p id="7a91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ticker就是“type”文件夹上面的文件夹，interval就是上面的文件夹。我们通过使用。拆分方法。</p><p id="d812" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的模型的类型取决于我们的最终文件夹——我们已经在前面的代码片段中获得了它。</p><p id="147b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们可以使用pathlib Path方法来定义模型的完整路径，这样我们接下来就可以开始加载它们了。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="95ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在剩下的就是使用Keras load_model函数加载我们的模型(不要忘记指定您可能使用的任何自定义对象)。</p><p id="a992" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其余的参数位于模型配置中——我们可以使用。get_config()方法。</p><p id="e882" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以通过使用. optimizer.get_config()来获取加载模型的优化器，并读取其参数。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="1b66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后剩下的事情是检查我们的ticker文件夹是否有任何集合类型，如果有，将“ensemble = True”参数分配给包含在其中的模型。我们简单地检查模型是否存在于系综文件夹中，并分别设置参数。如果文件夹本身不存在，我们可以简单地将ensemble参数设置为False。这样我们可以很容易地检查我们的模型是否是集合的一部分，如果是，是哪个集合。</p><p id="aa68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这样，我们从模型中完全提取了所有需要的特性！</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="cf74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一步是将参数插入到我们的params字典中，其中model_name充当一个键，parameter dictionary是它的值。</p><p id="8a31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完整代码:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="c840" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从单一模型中提取参数的代码大部分是相同的，所以我在这里不包括它。</p><p id="667c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们要做的就是将所有模型及其参数插入数据库:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="e98d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在第3行循环我们的字典键(记住，我们的键是模型名，我们的值是字典本身)。注意，我们首先将值插入adam optimizer表——这是因为在我们的模型表中，我们有一个外键optimizer_id，在能够完全插入数据之前，我们需要知道这个外键。</p><p id="420a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第9行到第11行，我们将使用。游标对象的fetchone方法。之后，我们要做的就是按照正确的顺序提供与我们准备好的语句相匹配的参数，就这样。我们所有的模型现在都整齐地放在我们的数据库中，并有相应的优化器与之匹配。</p><p id="e73e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有最后一件事——我们需要找到一种管理新模型的方法。我们不希望每次训练我们喜欢的新模型时都重新索引我们的数据库。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="1d47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，首先，我们将创建一个函数来将单个模型保存到我们的数据库中。我们将提供模型、ticker和interval的路径(尽管后两者可以像我们之前所做的那样从模型路径中提取)。然后我们要做的就是解析我们的模型，并将其插入数据库。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="6050" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是如果我们想删除我们的模型呢？我们不能只是手动从硬盘或数据库中删除它，我们必须双管齐下。</p><p id="d5da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这个函数，我们需要我们想要删除的模型的路径。首先，在第5–9行，我们将检查一个模型是否存在，如果存在，我们将从存储中删除它。然后，在第11–25行，我们将检查我们的SQL数据库，看看我们的模型是否是一个系综文件夹的一部分，如果是，也从那里删除它。最后，我们可以从SQL数据库中删除我们的模型。漂亮又干净！</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="d104" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们需要创建一个函数，将我们的新模型移动到一个系综文件夹中，如果我们想这样做的话。这很重要，因为我们跟踪一个模型是否是整体的一部分，所以我们不能只是物理地移动模型，我们还需要在我们的数据库中注册它。</p><p id="2c5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，这相当简单:我们将使用Pythons shutil.copyfile方法将我们的模型文件复制到我们提供的ensemble文件夹中，然后将ensemble类型和ensemble状态设置为数据库中正确的类型和状态。</p><p id="860b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们完了。从这里有很多路可以走；我们可以创建一个表来存储我们的回溯测试/测试结果，这样我们就可以看到每个模型的表现，我们可以将它与Keras联系起来，这样经过训练的新模型就会自动注册(可能首先基于某种测试，以确保它们是合适的模型)。也许我们甚至可以为投资领域建立某种交叉训练，其基础是在单个报价器上训练的模型。可能性确实是无穷无尽的！</p><p id="d184" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下次我们将使用这个数据库来创建一个非常基本的RestAPI，并在我们的浏览器中查看模型的预测。</p></div></div>    
</body>
</html>