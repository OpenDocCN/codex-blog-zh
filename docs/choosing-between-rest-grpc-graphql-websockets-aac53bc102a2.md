# 在 REST、gRPC、GraphQL、Websockets 之间选择

> 原文：<https://medium.com/codex/choosing-between-rest-grpc-graphql-websockets-aac53bc102a2?source=collection_archive---------5----------------------->

![](img/7e7b2f88166963eb206061ced2ee7ff5.png)

前端和服务器之间的通信

您在应用或后端和后端之间选择的网络协议对于安全性、可靠性、速度和良好的开发人员体验非常重要。

***免责声明*** *:在本文中，我们只讨论智能手机和平板电脑应用程序用于与其后端通信的网络协议；这是为了同步和面向连接的通信，本质上是基于 TCP 的通信。*

# 背景

当今世界上大中型技术系统中 API 使用的最流行的网络协议是四大协议——REST、gRPC、GraphQL 和 Websockets。除了这些，显然还有其他的，比如 SOAP、MQTT 等等。大多数应用程序和网络前端的通信模式，包括某种类型的*数据*流量，通常是基于 TCP 的。出现这种情况的主要原因是:

*   保证通信是面向连接的，
*   如果移动设备向后端发送消息，它至少应该及时知道服务器是否接收到该消息
*   如果没有接收到该分组，该协议使移动设备能够重新尝试发送它。

TCP 还有助于比 UDP 更容易地建立更高层的安全特性。

# 休息

代表性状态传输协议建立在 HTTP/1.1 之上，依赖于简单的请求/响应模型。这里，手机或平板电脑发送请求，服务器响应请求；请求可以是获取数据、发布数据更新、放置新数据或更新现有数据，等等。REST 请求和响应消息体(或内容)通常采用 JSON 或 YAML 格式，但也支持包括序列化二进制数据在内的各种其他格式。

在这个模型中，服务器通常被期望成为响应者，并且在前端和后端服务器之间也有相对松散的绑定；也就是说，服务器不一定“仅仅”响应移动设备的请求，但通常会更多。因此，REST 对于服务器之间的通信也非常有用，比如将后端服务公开给第三方。

REST 构建在 HTTP 之上，因此通过所有基于 HTTP 的身份验证和授权安全措施来保护它。

休息很好理解；REST 调用类型的区别只是一个字符串代码；内容是人类可读的普通数据，除此之外没有其他复杂之处。对于第一次使用的人来说，您编写的第一个 HTTP 服务器很可能会返回一些最小版本的 REST。

谈到 REST 的**缺点，最大的缺点是通信双方之间请求/响应数据的松耦合。在另一端，没有预期数据格式的约定，因此如果您的前端和后端团队是松散耦合的，这可能会成为一个令人头痛的问题；当一方改变格式而另一方没有改变时，通信路径就中断了。一个类似的大缺点是缺乏对 API 流数据的本地支持。**

# GraphQL

GraphQL 是最流行的通信协议之一，由于前端和后端系统之间的紧密耦合，它近年来越来越受欢迎。它构建在 HTTP/1.1 之上，最初是为了克服 REST 的一些缺点，同时使其适用于与后端高度耦合的前端。典型的用例是 web 和移动应用程序与其后端进行通信。API 端点将是专用的，因此永远不需要用绝对必要的更多信息来响应。请求者可以询问一个人的名字，得到的响应就是这个名字。

```
user {
  name: "Tom Brady"
}
```

将没有额外的信息，如时间戳，位置等。你会得到你想要的。这种对内容数据的细化使得 GraphQL 比 REST 快得多。

此外，GraphQL 提供了一种简单的方法，可以在后端将来自不同来源的数据聚集在一起并返回，这使得 graph QL 成为 REST 上单块系统升级的首选协议。

GraphQL 调用中的数据已经是结构良好的，因此可以很容易地分成层次结构，并通过前端或后端的组件分发。举个例子:这样的回答:

```
user {
  userId: 1234,
  userInfo: {
    name : "Tom Brady",
    profilePic: "https://imgur.com/abcdxyz",
  },
  transactions: [
  {
    txnId: "abxc",
    value: 50,
  },
  {
    txnId: "zxcv",
    value: 100,
  }
  ]
}
```

前端的这个响应可以很容易地(自然地)分解成子“userInfo”和“transactions ”,并路由到不同的组件，而不需要额外的代码来分解它并进行路由。

HTTP/1.1 不提供对缓存的本机支持；GraphQL 确实通过各种编写良好的库得到了解决这个问题的支持，例如 Apollo for React。

与 REST 的动态类型特性相比，内容的强类型特性也为 API 用户提供了很大的帮助，使他们在代码中使用它时能够准确地知道 API 层次字段是什么，而不是像 REST 一样在运行时知道。

GraphQL 解决了 REST 的许多问题，但是像聚合调用的行首阻塞这样的固有问题仍然存在。此外，GraphQL 在处理大量嵌套的数据格式时表现不佳。众所周知，它的性能通常会随着查询的复杂性而降低。

第三方服务器服务器通信不容易采用 GraphQL 的一个原因是缺乏对速率限制(每天/每小时/等等的请求数)的本地支持。

# Websockets

随着互联网的蓬勃发展，HTTP/1.1 中缺乏对流的本地支持或前端和后端系统之间基本上持久的双向通信日益成为一个大问题。2011 年，Websockets 在 [RFC6455](https://datatracker.ietf.org/doc/html/rfc6455) 中被标准化，以解决这个特定的问题。

解决方案很简单->使用 HTTP 进行初始连接设置，然后在相同的底层 TCP 连接上切换到不同的(新的)协议。用开发人员的话来说，将 HTTP 连接“升级”为使用 WebSocket 协议。

Websocket 协议的建立是为了解决一个棘手的问题->基于 HTTP 的系统的本地双向数据流。一旦通信转移到 Websocket 协议上，它还消除了 HTTP 调用的巨大开销(与 HTTP/1.1 的 2000 字节相比，只有 2 字节)。前端应用程序不再需要“长时间轮询”服务器来获取状态或通知。向移动应用程序发送推送通知几乎成为了原生支持。

但它也有自己的缺点，包括没有边缘缓存的可能性，复杂的前端编码体验，如果你想构建一个没有流需求的简单前端，它为特定目的构建的扩展性不好。

> 到目前为止，所有协议都只是在 HTTP/1.1 基础上的改进或增强，HTTP/1.1 是在 2000 年左右标准化的，在几年内被证明不足以满足互联网上快速增长的服务的复杂要求。在 HTTP/2(现在是 HTTP/3)出现之前，这些协议只是在 HTTP/1.1 基础上的更高层次的改进，以解决所有这些问题以及在不断增长的互联网上使用的长期可伸缩性。

# gRPC

gRPC 由 Google 很好地维护，并且主要建立在远程过程调用的概念上，它重新思考了整个请求/响应范式。gRPC 建立在 HTTP/2 之上，为流提供本地支持。在 gRPC 中，在任何人在他们的代码中使用 API 之前，在前端和后端之间预先定义了一个明确的契约。契约以模块或包的形式导入到您的代码中，并为前端和后端之间的契约中支持的函数和流提供一流的支持。在 API 上不能做任何其他事情；更好的是在编码时就知道了。

在 gRPC 中，当从后端获取信息时，前端代码几乎等同于从应用程序中的另一个包获取信息。你不能打电话等着。你只需要调用一个函数，并使用该函数的返回信息。这样的函数存在于“契约文件”中，它是为在前端和后端使用而预先编译的。

gRPC 具有对流的本地支持:服务器端流(下游)、客户端流(上游)和双向流。

gRPC 中交换的消息使用协议缓冲区，而不是 XML、YAML 和 JSON。众所周知，协议缓冲区中传输的数据的序列化速度比 REST 快 2/4/8 倍，这使得 gRPC 比 REST 具有巨大的性能优势。

gRPC 对流、轻量级消息、更快的序列化和消息交换的硬协议提供了本机支持，是机器之间最快的通信方法之一。数据的紧密耦合也使得开发这样的 API 端点成为开发人员的乐趣。

因为 gRPC 是建立在 HTTP/2 之上的，所以它具有对并行请求/响应通道的本地支持。这意味着，您可以在同一个 TCP 流中从同一个前端向同一个后端发出多个请求，每个单独的请求都将从 TCP 流中自己的成帧层被解析，并被并行处理；从而防止行首阻塞。如果第一个请求由于某种原因变得很慢，它不会影响第二个请求，甚至会给它带来更大的性能提升。

如果你喜欢我的文章，请在 Medium 上关注我，阅读更多关于技术及其用途的精彩文章。

我定期撰写不同的技术主题，包括职业指导、最新消息、即将到来的技术等等。这篇博客最初发表在[我在 anirban-mukherjee.com 的博客](https://www.anirban-mukherjee.com/choosing-between-rest-grpc-graphql-websockets/)