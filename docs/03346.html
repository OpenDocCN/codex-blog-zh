<html>
<head>
<title>Parallel Programming in Python Lesson 5. Cooperative programming — synchronous</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的并行编程第5课。合作编程—同步</h1>
<blockquote>原文：<a href="https://medium.com/codex/parallel-programming-in-python-lesson-5-cooperative-programming-synchronous-774aa4dac237?source=collection_archive---------21-----------------------#2021-08-28">https://medium.com/codex/parallel-programming-in-python-lesson-5-cooperative-programming-synchronous-774aa4dac237?source=collection_archive---------21-----------------------#2021-08-28</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><figure class="hi hj fa fc hk hl es et paragraph-image"><div role="button" tabindex="0" class="hm hn di ho bf hp"><div class="es et hh"><img src="../Images/e528ebd9f3ea1a80ff179c57af1bbe8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpEYnHZPiK7cpnFloHeusQ.jpeg"/></div></div></figure><div class=""/><p id="9a59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">本课的章节:</p><ol class=""><li id="83c1" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">介绍</li><li id="33f1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">拉迭代器</li><li id="ca15" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">迭代器要素</li><li id="4c40" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">单个消费者适合从多个生产商那里拉货</li><li id="288d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">推送迭代器</li><li id="363e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">协程要素</li><li id="49cb" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">自动启动</li><li id="79eb" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">单个生产者，适于推送给多个消费者(多播)</li><li id="2bb0" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">传播数据接收器</li><li id="620e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">基于状态机和协程的解决方案的比较</li><li id="dec1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">练习:合作尾服务器</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="32ad" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">1.介绍</h2><p id="7492" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">在前两节课(第三和第四节)中，我们学习了一个简单的<em class="jp">【生产者/消费者】</em>(一对一)用例:</p><ul class=""><li id="2c94" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ll jw jx jy bi translated">生产者发送列举的文本消息，消费者以两秒钟的间隔接收并立即显示这些消息。生产者和消费者都由主程序创建(并配对)，主程序在20秒后关闭生产者，导致消费者也关闭，结果正好显示10条消息”。</li></ul><p id="e1c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">我们已经试验了生产者/消费者用例的各种“常规”实现:首先是多线程，然后是Python自己的<em class="jp">多处理</em>扭曲。所有这些“经典”解决方案都有两个共同的原则:</p><ol class=""><li id="04e2" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">生产者和消费者是松散耦合的——他们从不亲自见面，通过第三方交流。我们考虑了以下通信方式:全局变量、共享变量、点对点消息队列、管道、发布/订阅和套接字。</li><li id="9c10" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">协议是由生产者(生产商品的)规定的。消费者顺从了。</li></ol><p id="cb11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">现在，我们来看一个替代的解决方案，其中生产者和消费者(1)在<em class="jp">控制的同一个线程</em>中<em class="jp">循环</em>，而(2)在<em class="jp">时间上耦合</em>(或者消费者<em class="jp">直接从<em class="jp">生产循环</em>中拉出</em>，或者生产者直接推入<em class="jp">消费循环</em>)。当然，这些解决方案仅限于生产者和消费者从不需要同时执行<em class="jp"/>(在完全相同的时间——不可否认这是<em class="jp">线程</em>的领域)的用例子集。然后，考虑到我们宇宙中几乎所有的生产者/消费者用例并不真正需要同时性，这并不是一个过分的要求！(根据定义，发送消息必须在接收消息之前<em class="jp">发生。只有在非常奇怪的情况下才允许同时发送和接收，例如，消息是分组发送的，或者在接收之前必须发出多条消息，因此两边的外围活动<em class="jp">可能</em>碰巧同时发生)。在质疑这种魔力是否能够实现以及如何实现之前，有很好的理由去尝试:(1)多线程/处理是资源昂贵的，(2)它给设计带来了复杂性，使得程序(不必要的)难以管理和扩展。</em></p><p id="7225" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">该解决方案涉及两种编程范例:</p><ol class=""><li id="b0da" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated"><em class="jp">协同处理</em>(使用<em class="jp">协程</em>)。我们将考虑两种设计模式:(1) <strong class="it hv">拉迭代器</strong>。在每次迭代中，消费循环<em class="jp">从生产循环(暂停)中提取</em>下一条消息，使用它并暂停，等等。(2) <strong class="it hv">推送迭代器</strong>。在每次迭代中，生产循环<em class="jp">将下一条消息推送给消费循环</em>(并暂停)。消费循环从那里接管(并暂停)等等。虽然这种解决方案可以用简单的过程化编程来构建，但结果很可能太复杂而不值得付出努力(这解释了为什么这种设计在实践中并不常见)。这里，<em class="jp">协程</em>的编程特性(相互传递控制、保留执行状态的函数)就派上了用场！Python对协程的支持使得这些解决方案非常简单和易读(当然，对于熟悉这种范式的人来说)。</li><li id="a553" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated"><em class="jp">可替代性</em>(或<em class="jp">多态性</em>)。这些解决方案似乎妥协了基本的<em class="jp">松散耦合</em>(生产者和消费者之间)——不可否认，这个生产者明确地<em class="jp">调用消费者的方法</em>(反之亦然)。但是，问题来了:这个生产者并不清楚(甚至模糊地)它在和谁说话。可以给生产者(反之亦然)任何对象，只要该对象实现了消费者接口(生产者感兴趣的部分，也是生产者期望找到的部分)。正如我们将看到的，迭代参数的可替代性打开了一些有趣的扩展。例如，为什么要用1:1呢？接口背后的对象可能是一个适配器，它允许轻松地实现单个生产者/多个消费者、多个生产者/单个消费者等用例。例如，接口另一端的对象可能是位于另一个线程中的真实对象的代理(如果真的需要并发的话！)</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="4c57" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">2.拉迭代器</h2><p id="9c9a" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">下面的例子使用Python对<em class="jp">结构化迭代的支持，显式地将消费者和生产者耦合在一起，但有所改变。</em>如果我们将我们的生产者/消费者用例约束到<em class="jp">恰好一个消费者，</em>(这是相当现实的)，那么我们可以用这种简单的形式重新表述它:</p><ul class=""><li id="d9bd" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ll jw jx jy bi translated">“消费者迭代来自生产者的消息”。(<em class="jp"> "Iterates" </em>与从文件中提取记录、从字符串中提取字符或从列表中提取对象的方式相同)。</li></ul><p id="6d42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">下面是一个例子(注释如下)</p><figure class="lm ln lo lp fe hl"><div class="bz dz l di"><div class="lq lr l"/></div></figure><p id="cfd0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="5c1a" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">在这个设计中，生产者不是一个线程。</li><li id="0ba0" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">实现<em class="jp">结构化迭代</em>的生产者方法。这个<em class="jp">魔法函数</em>被Python默默调用，以实现生产者对象上循环的<em class="jp">。(稍后将详细介绍)。</em></li><li id="b4ad" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated"><em class="jp"> yield </em>语句挂起循环，向调用for-loop提供当前元素。</li><li id="cc9a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者(一个线程)用一个符合<em class="jp"> Iterable </em>接口的对象初始化，(比如我们的生产者)。</li><li id="deb4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者迭代“存储”在生产者中的消息(据其所知)。</li><li id="d021" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序创建生产者，并用它初始化消费者。</li></ol><p id="f4b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:</em></p><pre class="lm ln lo lp fe ls lt lu lv aw lw bi"><span id="276a" class="kl km hu lt b fj lx ly l lz ma">Round 1 <br/>Round 2 <br/>Round 3 <br/>Round 4 <br/>Round 5 <br/>Round 6 <br/>Round 7 <br/>Round 8 <br/>Round 9 <br/>Round 10 <br/>[End of input]</span></pre></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="6e9a" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">3.迭代器/生成器基础</h2><p id="e19a" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">该序列图展示了通过<em class="jp">数据耦合</em>实现的同步。在消费循环的每次迭代中，“从生产者拉下一条消息”(隐含在<em class="jp"> for循环</em>头中)在设计上通过<em class="jp">“消息”</em>(虚线弧)与生产方的“生成下一条消息”相耦合<em class="jp">，从而在<em class="jp">并行</em>中循环。</em></p><figure class="lm ln lo lp fe hl es et paragraph-image"><div class="es et mb"><img src="../Images/5b34acb00e46cd164f5e2ad927475d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*dddKPvJ0O8ojhLoINhELeQ.png"/></div></figure><p id="36bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">不同于在某些严格用例下支持结构化迭代的其他语言(比如从文件中提取记录或者从标准容器中提取对象)，Python的迭代模型是——在Python精神中——尽可能通用的。任何对象都可以被迭代，只要它的类符合<em class="jp">“iterable”</em>协议，该协议由一个功能组成:魔术方法<strong class="it hv"> __ <em class="jp"> iter__ </em> </strong>。object上的内置函数<em class="jp"> iter </em>调用对象的魔方法<strong class="it hv"> __ <em class="jp"> iter__ </em> </strong>(如果有)，返回一个<em class="jp">迭代器</em>。然后循环继续调用迭代器的__ <em class="jp"> next__ </em>。当迭代器抛出一个特殊异常时，循环终止。</p><p id="89e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">神奇的方法<strong class="it hv"> __ <em class="jp"> iter__ </em> </strong>可能是生成下一个条目的生成器<em class="jp">或者是返回迭代器的普通函数。准确地说，内置的<em class="jp"> iter </em>总是返回一个迭代器。当出现一个生成器(函数<em class="jp">产生</em>)时，它会悄悄地创建一个默认的迭代器。</em></p><figure class="lm ln lo lp fe hl"><div class="bz dz l di"><div class="lq lr l"/></div></figure><p id="6398" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="3e65" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">首先从迭代的对象中获取一个迭代器(使用内置的<em class="jp"> iter </em>，其中使用了制作人的魔<strong class="it hv"> __ <em class="jp"> iter__ </em> </strong>方法)。这给出了一个(默认的)迭代器，它“指向”第一个消息之前的<em class="jp">。(即尚未产生任何消息)。</em></li><li id="ba10" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">在每次迭代中，内置的<em class="jp"> next </em>试图从生产者那里获得下一条消息(使用迭代器的神奇方法<strong class="it hv"> __ <em class="jp"> next__ </em> </strong>，这释放了生产者的神奇方法<strong class="it hv"> __ <em class="jp"> iter__ </em> </strong>，直到下一条<em class="jp"> yield </em>语句，在那里它暂停，返回下一条消息。</li><li id="1c71" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">当生产者决定停止生产消息时(即其神奇方法<strong class="it hv">_ _<em class="jp">ITER _ _</em></strong><em class="jp">返回</em>“正常”——不同于<em class="jp"> yield </em>)，迭代器抛出<em class="jp">停止迭代</em>，从而终止消费循环。</li></ol><p id="418a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">虽然Python迭代器的典型用法隐含在循环的<em class="jp">中(如上所示)，但有些情况下，我们宁愿亲自动手，显式地推进迭代器。以下面的函数为例，它从任意的iterable中获取第一个条目(或者没有条目)。</em></p><figure class="lm ln lo lp fe hl"><div class="bz dz l di"><div class="lq lr l"/></div></figure><p id="12c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="83d3" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">函数<em class="jp">从它的参数中获得一个迭代器</em>，不管它是什么，并返回其中的下一个项(实际上是第一个<em class="jp">项和第一个</em>项，因为Python迭代器天生是未初始化的)</li><li id="73e3" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">如果迭代器为空(next在第一次迭代中失败)，则返回None对象。</li></ol><p id="bc2e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:</em></p><pre class="lm ln lo lp fe ls lt lu lv aw lw bi"><span id="cf7a" class="kl km hu lt b fj lx ly l lz ma">'a' <br/>None</span></pre></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="c392" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">4.单个消费者适合从多个生产商那里拉货</h2><p id="4c73" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">通过接口将消费者耦合到生产者<em class="jp">的设计决策打开了设计，提供了一些有趣的扩展(和有用的)用例。但首先，要证明消费者确实不知道生产商的真实身份:</em></p><figure class="lm ln lo lp fe hl"><div class="bz dz l di"><div class="lq lr l"/></div></figure><p id="e878" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em> <br/> 1。这个消费者用一个字符串初始化(迭代字符)。</p><p id="c845" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:</em></p><pre class="lm ln lo lp fe ls lt lu lv aw lw bi"><span id="ffad" class="kl km hu lt b fj lx ly l lz ma">a <br/>b <br/>c <br/>d <br/>e <br/>f <br/>g <br/>[End of input]</span></pre><p id="0b92" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">一个更有用的扩展是实现单个消费者/多个生产者的情况。并且这是在不对当前实现进行任何重大改变的情况下完成的。由于消费者不知道它真正迭代的是什么，我们将为它提供一个<em class="jp">适配器</em>，在每次来自消费者的迭代请求中，迭代来自生产者数组的下一条消息，它隐藏在里面！</p><p id="77d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">顺便提一下，这个<em class="jp">多生产者适配器</em>提供了展示迭代的“低级”用法的机会，如上所述。</p><figure class="lm ln lo lp fe hl"><div class="bz dz l di"><div class="lq lr l"/></div></figure><p id="b1d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="f604" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">为生产者提供了唯一的前缀，以区分其输出。否则，生产者逻辑没有变化。</li><li id="09ea" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者输出是前缀。</li><li id="5c54" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">多生产者适配器接收生产者列表，并准备对每个生产者进行迭代。</li><li id="fc32" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">多生成器适配器遍历每个生成器，一次遍历一个(下一个)元素。</li><li id="acdd" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">延迟现在由多生产者适配器负责。(我们不希望它依赖于任意数量的生产者)。</li><li id="99eb" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">这里，第一个结束的生产者终止了整个迭代。(另一种解决方案是从列表中删除过期的生产者，并将生产循环的终止推迟到列表变空时)。</li><li id="1f99" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">延迟不再是消费者的责任。否则，没有改变消费者的逻辑。</li><li id="7c6f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序创建三个生产者，前缀为“a”到“c”。</li><li id="6b77" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">这一次，消费者得到了一个超过三个前缀生产者的适配器。</li><li id="357c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">现在有多个生产者停止。</li></ol><p id="bcaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:</em></p><pre class="lm ln lo lp fe ls lt lu lv aw lw bi"><span id="3b0d" class="kl km hu lt b fj lx ly l lz ma">Round a1 <br/>Round b1 <br/>Round c1 <br/>Round a2 <br/>Round b2 <br/>Round c2 <br/>Round a3 <br/>Round b3 <br/>Round c3 <br/>Round a4 <br/>Round b4 <br/>Round c4 <br/>Round a5 <br/>Round b5 <br/>Round c5 <br/>[End of input]</span></pre></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="020b" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">5.推送迭代器</h2><p id="b90b" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">现在来看相反的用例，生产者向消费者的协程提供消息，一次一条。和前面的解决方案一样(消费者迭代生产者)，控制权以明显的(程序化的)方式在他们之间传递，不需要<em class="jp">同步</em>设施。有趣的是，Python也允许我们在这里使用迭代器(通过生成器函数)，但是这个特殊的迭代器<em class="jp">使用专用语法将</em>推送到数据目标(而不是<em class="jp">从数据源拉</em>)。</p><figure class="lm ln lo lp fe hl"><div class="bz dz l di"><div class="lq lr l"/></div></figure><p id="f018" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="dd9d" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">生产者<em class="jp">启动</em>迭代器(即调用下一个的<em class="jp">)。因为Python迭代器是未初始化的，所以需要第一个<em class="jp">get-next</em>("<em class="jp">priming "</em>)将它定位到开始。</em>否则下面的<em class="jp">发送</em>会导致错误！</li><li id="ba5d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者<em class="jp">向消费循环</em>发送消息，<em class="jp">阻塞</em>。</li><li id="9ac8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">由于<em class="jp">发送</em>，不同于<em class="jp">产出</em>不被另一端的(结束)循环终止，输出流必须被<em class="jp">明确关闭</em>。</li><li id="20e0" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费循环阻塞，等待某人(在我们的例子中是生产者)向<em class="jp">发送</em>下一条消息(通过yield <em class="jp">给出</em>消息来实现)。当消息最终被接收时，生产者(发送它的)保持阻塞，直到下一个产出或消耗<em class="jp">退出</em>。将yield括在括号中并不重要，但这是Python的常见做法。</li><li id="9830" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">这种延迟由消费者来管理。</li><li id="22d1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者决定<em class="jp">停止发送</em>(此处不隐含)会引发<em class="jp">发生器退出</em>异常。消费者将这个“异常”解释为循环的合法结束。</li><li id="8709" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序调用<em class="jp">消费</em>，给<em class="jp">消费</em>一个Python <em class="jp">协程</em>包装器，并把它交给生产者。主程序的其余部分不受协议变化的影响。</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="f337" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">6.协程要素</h2><p id="9802" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">序列图展示了通过<em class="jp">数据耦合</em>的同步。在消费循环的每次迭代中，“在消费者中接收下一条消息”<em class="jp"> (yield) </em>在设计上通过“消息”(虚线弧)与“将消息推送给消费者”<em class="jp"> (send) </em>(通过编程阻止)耦合，这是一个并行循环。</p><figure class="lm ln lo lp fe hl es et paragraph-image"><div role="button" tabindex="0" class="hm hn di ho bf hp"><div class="es et mc"><img src="../Images/b499c4b1760079e446ff86e4c0387020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D58rxYBkG92FxwRNwRW8DA.png"/></div></div></figure><p id="4e07" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">注意区别！</em></p><ul class=""><li id="1280" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ll jw jx jy bi translated"><em class="jp">拉</em>-迭代器的产量<em class="jp">产生</em>自变量，<em class="jp">阻塞生产</em>循环，<em class="jp">释放消费</em>循环。</li><li id="8175" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ll jw jx jy bi translated"><em class="jp">推</em>-迭代器的产量<em class="jp">阻塞生产</em>循环，<em class="jp">释放消耗</em>循环，<em class="jp">消耗</em>自变量，</li></ul><p id="be1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">“调用”一个依赖的协程(比如我们的消费者)还没有执行这个函数。相反，它返回一个迭代器，准备运行，有点像线程“构造函数”(例如在需要的地方使用初始化参数的<em class="jp">)。当第一次进入协程时(当被请求推动下一个</em>的<em class="jp">—即第一个</em>的<em class="jp">—输出)，它执行到第一个<em class="jp">产出</em>并暂停，该过程被称为<em class="jp">启动</em>。然后，从另一侧发送的每个项目<em class="jp">释放协程以“推送”未决的<em class="jp">产出值</em>。</em></em></p><p id="5d6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">当然，只要推送迭代器协程在一个<em class="jp">产出</em>点被阻塞，这种机制就能工作，这在输出循环期间是有保证的，但在第一次时就不行了，那时协程还没有被定位在任何有用的地方。这就是为什么需要<em class="jp">灌注</em>的原因。诚然，发电机启动的功能和动机是有点模糊的。为了充分理解它，人们必须深入研究语言的历史。推送迭代器(生成器协同例程)是Python的新增功能，是在现有的(拉取)迭代器上实现的。为了证明这一点，可以编写如下代码:</p><pre class="lm ln lo lp fe ls lt lu lv aw lw bi"><span id="fb83" class="kl km hu lt b fj lx ly l lz ma">inp = yield outp</span></pre><p id="9f57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">虽然这种代码的效用是可疑的，并且被所有教科书强烈反对，但它将会工作。(<em class="jp">产出</em>将首先发生，而由<em class="jp">驱动的分配将最后发送</em>。这一切都始于Python迭代范式，它不区分<em class="jp">指向</em>当前元素和<em class="jp">返回</em>(产生)它，例如，C++ STL就是这样。(Python在这方面并不独特。C#和其他语言也是如此，从设计的角度来看，它更有意义)。Python迭代器天生是“未初始化”的，当需要<em class="jp">获取下一个</em>时，它只会<em class="jp"/>指向第一个元素(并返回它)。第一个<em class="jp">下一个</em>请求将获取第一个元素(如果有)。顺便说一句，如果存在迭代初始化过程，它也将贯穿整个过程。这对于最初的<em class="jp"> pull </em>迭代器很有效，因为<em class="jp"> it </em>控制迭代(另一端被阻塞，直到它让步)。但是<em class="jp">推</em>迭代器不能天生“未初始化”，因为它是从外部控制的！它被封锁，直到有人帮它一个忙，然后<em class="jp">派</em>进去。当这种情况发生时，它必须定位在某个<em class="jp">产量</em>点，等待<em class="jp">发送</em>的到来。为了第一次实现这一点，我们必须使用它(不需要的)能力作为拉迭代器，并指示它检索下一个元素<em class="jp">，即到达第一个屈服点(在这里它什么也没有检索到，因为它什么也没有得到)，并准备好接收。这是一个公认的蹩脚借口，但这就是它的工作方式…</em></p><p id="9a72" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">在协程生命周期的另一端，当它被<em class="jp">返回</em>“正常”终止时(与<em class="jp">产生</em>不同)，它自己主动这么做并不是一个好主意。通常，应由推动侧决定何时<em class="jp">停止推动</em>并终止循环。(与<em class="jp">拉式迭代器</em>相反，拉式迭代器通过提升<em class="jp">停止迭代</em>来保持<em class="jp">发回</em>货物，其自然职责是停止循环)。当生产者发送完信息时，它通过升高<em class="jp">发生器出口</em>向消费者发出停止接收的信号。这给了消费者在退出之前进行清理的机会。</p></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="c749" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">7.自动启动</h2><p id="66b1" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">启动生成器的任务可以被一般化并委托给一个<em class="jp">装饰器</em>，如下例所示。(奇怪的是，这不是内置Python库的一部分)。</p><figure class="lm ln lo lp fe hl"><div class="bz dz l di"><div class="lq lr l"/></div></figure><p id="6176" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="a0c1" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated"><em class="jp">协程</em>函数接受一个函数。</li><li id="21c9" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">在协程装饰器内部隐藏了另一个名为<em class="jp"> start </em>的函数，该函数用于包装接收到的函数。因为我们事先不知道包装的函数将接受什么参数，所以start解决了最大可能的情况:如此多的未命名参数和如此多的命名参数。</li><li id="042a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">Start创建一个<em class="jp">协程</em>(通过调用包装的函数)。它不需要包装的函数作为形式参数，因为它已经在它的<em class="jp">闭包</em>中了。</li><li id="ad7f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者被<em class="jp">装饰</em>为<em class="jp">协程</em>。函数名<em class="jp">消耗</em>现在指向<em class="jp">协程</em>的函数<em class="jp">开始</em>。(消费不亏。它处于<em class="jp">开始</em>的关闭状态。)对<em class="jp"> consume </em>的调用将调用<em class="jp"> start </em>(属于<em class="jp">协程</em>函数)来代替(作为上面<em class="jp">装饰器</em>的结果)，这将调用consume，<em class="jp"> prime </em>它并返回(primed)结果协程对象。</li><li id="a8b2" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序调用它持有的<em class="jp"> consume </em>(实际上是<em class="jp">协程</em>的<em class="jp"> start </em>)，后者调用真正的<em class="jp"> consume </em>，给<em class="jp"> consume </em>一个Python <em class="jp">协程</em>包装器，对其进行预处理并将其返回给主程序，主程序将它交给生产者。主程序的其余部分不受协议变化的影响。</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="d477" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">8.单个生产者，适于推送给多个消费者(多点传送)</h2><p id="8865" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">这个版本<em class="jp"/>将生产者的信息“多播”给多个消费者。多播协程被插入到生产者和消费者之间。延迟被移动到多播</p><figure class="lm ln lo lp fe hl"><div class="bz dz l di"><div class="lq lr l"/></div></figure><p id="1246" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="bacc" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">不同的消费者通过前缀来识别。</li><li id="69e5" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者的消息会相应地加上前缀。</li><li id="2653" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">多播适配器接受一个生成器列表。</li><li id="5d57" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消息依次发送给每个消费者。</li><li id="94b1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">延迟被委托给多播者。(我们不希望它依赖于任意的消费者数量)。</li><li id="d89d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">最后，多播适配器依次关闭每个使用者。</li><li id="0ac5" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序加载带有消费者生成器的多播适配器，前缀为“a”到“c”。</li></ol><p id="6302" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:</em></p><pre class="lm ln lo lp fe ls lt lu lv aw lw bi"><span id="ca3f" class="kl km hu lt b fj lx ly l lz ma">a: Round 1 <br/>b: Round 1 <br/>c: Round 1 <br/>a: Round 2 <br/>b: Round 2 <br/>c: Round 2 <br/>a: Round 3 <br/>b: Round 3 <br/>c: Round 3 <br/>a: Round 4 <br/>b: Round 4 <br/>c: Round 4 <br/>a: Round 5 <br/>b: Round 5 <br/>c: Round 5 <br/>a: [End of input] <br/>b: [End of input] <br/>c: [End of input]</span></pre></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="2eec" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">9.传播数据接收器-协程管道</h2><p id="7be2" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">这个版本通过引入一个可替换的接收器媒介——链中的另一个协程——来一般化消息的显示，它沿着层次结构向下传播，形成一个<em class="jp">管道</em>。</p><figure class="lm ln lo lp fe hl"><div class="bz dz l di"><div class="lq lr l"/></div></figure><p id="608c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="1aa5" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">生产者有两个生产者:消费者和输出媒介。</li><li id="df07" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">使用输出媒介将输出提供给消费者。</li><li id="7ec4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者受到两个因素的影响:信息和目标媒体。(注意，在这个设计中，目标媒体在每个消息中被再次发送，强调消费者与输出媒体的独立性。另一种设计是使用输出介质初始化消费者，假设它不改变并且不依赖于消息)。</li><li id="4be1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者将显示转发到给定的输出媒体。</li><li id="dfd9" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">输出介质被实现为协程以符合设计。(它也可以是一个函数或一个可替换的对象)</li><li id="1aeb" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序用输出介质初始化生产者。</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="7987" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">10.事件驱动与基于协程的解决方案的比较</h2><p id="b243" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">在接下来的讨论中，我们将切换到构建一个课程结构的用例，该结构由dictionary-of-list实现，并从XML加载。我们将使用从XML加载数据的过程，以便比较“传统的”状态机解决方案和另一种基于协程的解决方案，这种解决方案初看起来可能不寻常，但有其魅力，并且肯定展示了范例。</p><p id="049b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">这是我们例子的数据结构实例:</em></p><figure class="lm ln lo lp fe hl"><div class="bz dz l di"><div class="lq lr l"/></div></figure><figure class="lm ln lo lp fe hl es et paragraph-image"><div class="es et md"><img src="../Images/6082776b13cacf3856d25f6329c21e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:204/format:webp/1*P7btdBVZrpIJ_2ivppBucw.png"/></div></figure><p id="0aaa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp"> XML输入:</em></p><figure class="lm ln lo lp fe hl"><div class="bz dz l di"><div class="lq lr l"/></div></figure><p id="e3e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><strong class="it hv">一个“常规”</strong>版本:根据标签填充航向，观察加载状态</p><figure class="lm ln lo lp fe hl"><div class="bz dz l di"><div class="lq lr l"/></div></figure><p id="0c3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="a64e" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">“Course”标签重置解析。</li><li id="1524" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">“Paradigm”标签在课程中打开了一个新的范例，带有(目前)空的课程列表，并将两者都设置为当前。</li><li id="251a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">“language”标签为当前范例添加了一种语言。</li><li id="b694" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">结束元素已注册但未实现。(保留供将来使用)。</li></ol><p id="394d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:</em></p><pre class="lm ln lo lp fe ls lt lu lv aw lw bi"><span id="5f28" class="kl km hu lt b fj lx ly l lz ma">Procedural <br/>  C <br/>  COBOL <br/>OO <br/>  Python <br/>  C++ <br/>  C# <br/>  Java <br/>Functional <br/>  Clojure</span></pre><p id="8daf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><strong class="it hv">基于协程的解决方案:</strong>填充课程，在数据层次中迭代</p><p id="3b26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">这是一个基于协程的XML构建器，使用相同的解析器。构建器在解析器中注册开始标记和结束标记处理程序，这些处理程序提供给协程。协程被构建为<em class="jp">循环中的循环，</em>符合<em class="jp">一对多对多</em>过程数据结构</p><figure class="lm ln lo lp fe hl"><div class="bz dz l di"><div class="lq lr l"/></div></figure><p id="e8cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="8541" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">课程循环(通常执行一次)。</li><li id="e9d6" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">begin-course标签清除课程并重置当前范例。</li><li id="0ea1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">范式循环。</li><li id="533b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">begin-paradigm标签打开一个新的范例作为当前范例，并清除它的语言列表。</li><li id="a29d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">语言循环</li><li id="31fc" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">语言标签将一种语言添加到当前范例中。</li><li id="a7a5" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">结束语言标签(由解析器引入)被忽略。</li><li id="3e9d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">下一种语言。</li><li id="31d4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">下一个范例</li><li id="1836" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">下一道菜(预期结束标签)。</li></ol><p id="765d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">这块小宝石非常有条理(尽管它的实际用途值得怀疑)。我们在这里看到的是传统的<em class="jp">程序性</em>代码，但是被<em class="jp">功能性</em>编程所模拟！它是事件驱动的，但在表面之下。协程的使用有效地对程序员隐藏了状态机。如同在通用程序中一样，<em class="jp">控制结构</em>遵循<em class="jp">数据结构</em>。当然，对数据结构的忠实性是这种设计模式的优点，也是它的缺点。一方面，代码非常清楚。任何初学Python的程序员都可以理解这段代码的作用，即使不熟悉<em class="jp">产出</em>的确切作用。(相比之下，事件驱动的解决方案尽可能地脱离数据结构，几乎不可读)。另一方面，它不是开放-封闭/可扩展的。对数据结构的任何改变都需要物理地改变代码(而事件驱动的解决方案只需要注册额外的处理程序)。尽管如此，我还是建议考虑这种设计模式，因为它的可读性很好，数据结构是可靠的，或者当代码发生变化时扩展代码不成问题。</p></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="cd0f" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">11.练习:合作尾服务器</h2><p id="d672" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">重构第三课中介绍的多线程尾部服务器练习的解决方案，以使用协程。</p><p id="8b0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">这里是官方的“教科书解决方案”:</em></p><figure class="lm ln lo lp fe hl"><div class="bz dz l di"><div class="lq lr l"/></div></figure><p id="07fc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:</em></p><pre class="lm ln lo lp fe ls lt lu lv aw lw bi"><span id="f787" class="kl km hu lt b fj lx ly l lz ma">File 1 to watch: file1.txt <br/>File 2 to watch: file2.txt <br/>File 3 to watch: file3.txt <br/>File 4 to watch: <br/>[Tailing "file1.txt"] <br/>[Tailing "file2.txt"] <br/>[Tailing "file3.txt"] <br/>file3.txt: 1. Mon Aug 23 23:02:22 2021 <br/>file1.txt: 1. Mon Aug 23 23:02:22 2021 <br/>file2.txt: 1. Mon Aug 23 23:02:22 2021 <br/>file3.txt: 2. Mon Aug 23 23:02:27 2021 <br/>file1.txt: 2. Mon Aug 23 23:02:27 2021 <br/>file2.txt: 2. Mon Aug 23 23:02:27 2021 <br/>file3.txt: 3. Mon Aug 23 23:02:32 2021 <br/>file1.txt: 3. Mon Aug 23 23:02:32 2021 <br/>file2.txt: 3. Mon Aug 23 23:02:32 2021 <br/>file3.txt: 4. Mon Aug 23 23:02:37 2021 <br/>file1.txt: 4. Mon Aug 23 23:02:37 2021 <br/>file2.txt: 4. Mon Aug 23 23:02:37 2021 <br/>file1.txt: 5. Mon Aug 23 23:02:42 2021 <br/>file3.txt: 5. Mon Aug 23 23:02:42 2021 <br/>file2.txt: 5. Mon Aug 23 23:02:42 2021 <br/>[stopped tailing "file1.txt"] <br/>[stopped tailing "file2.txt"] <br/>[stopped tailing "file3.txt"]</span></pre><p id="79da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">在这个解决方案中，每个尾部观察器以及尾部服务器都有自己的线程。将解决方案重构为一个尾部服务器，它运行在自己的线程上，但是使用<em class="jp"> pull迭代器</em>模式同步迭代它的尾部观察器。总而言之，解决方案中有两个线程:线程服务器和文件接触功能。</p></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="0635" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">参考</h2><ol class=""><li id="2b44" class="jq jr hu it b iu lg iy lh jc me jg mf jk mg jo jv jw jx jy bi translated">“一个关于协同程序和并发性的奇怪课程”，David Beazley，2009年(<a class="ae mh" href="http://www.dabeaz.com/coroutines/Coroutines.pdf" rel="noopener ugc nofollow" target="_blank">讲座衬托</a>)</li></ol><h2 id="fc67" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">接下来呢？</h2><p id="e897" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">还有一课要上！在下一课，也是最后一课，我们将考虑基于分派的协作处理替代方案，称为<em class="jp">异步</em>执行。</p><p id="0cd6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">内容:</em></p><ol class=""><li id="18af" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated"><a class="ae mh" rel="noopener" href="/codex/parallel-programming-in-python-lesson-1-introduction-210e33d02ea6?source=friends_link&amp;sk=5273e19224913fbd6a3b74f41871a754">简介</a></li><li id="c662" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated"><a class="ae mh" rel="noopener" href="/codex/parallel-programming-in-python-lesson-2-the-thread-b3986e215d4f?source=friends_link&amp;sk=5ad6a9c99ce8947be53af4949ce6f086">螺纹</a></li><li id="c30b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated"><a class="ae mh" rel="noopener" href="/@Avner_17989/parallel-programming-in-python-lesson-3-synchronization-primitives-78ac09befc43">同步原语(多线程)</a></li><li id="e3fe" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated"><a class="ae mh" rel="noopener" href="/codex/parallel-programming-in-python-lesson-4-multi-processing-90f597da89ba">同步原语(多处理)</a></li><li id="78f4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">协同处理—同步— <em class="jp">(你来了！)</em></li><li id="46f2" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">协作处理—异步</li></ol></div></div>    
</body>
</html>