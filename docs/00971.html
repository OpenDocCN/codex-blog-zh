<html>
<head>
<title>Inheritance And How To Implement It In Automation Framework.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">继承以及如何在自动化框架中实现它。</h1>
<blockquote>原文：<a href="https://medium.com/codex/inheritance-and-how-to-implement-it-in-automation-framework-41d1b7c9a200?source=collection_archive---------4-----------------------#2021-03-28">https://medium.com/codex/inheritance-and-how-to-implement-it-in-automation-framework-41d1b7c9a200?source=collection_archive---------4-----------------------#2021-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="f00c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">Java中的继承:简介</strong></h1><p id="df90" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">面向对象编程的核心原则之一——<strong class="jf hj">继承——使我们能够重用现有代码或扩展现有类型。</strong>简单来说，在Java中，一个类可以继承另一个类和多个接口，而一个接口可以继承其他接口。当从现有类继承时，可以重用父类的方法和字段。此外，您还可以向当前类添加新的方法和字段。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es kb"><img src="../Images/ee7ab3235baf1ba1d8b8188d5067b0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*36W1pHnX_Ig9Okn2f8KmcA.png"/></div></figure><p id="f2eb" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">继承代表了<strong class="jf hj">是一种</strong>关系还是一种<strong class="jf hj">父子</strong>关系。考虑父类动物和子类狗。</p><pre class="kc kd ke kf fd ko kp kq kr aw ks bi"><span id="45d5" class="kt ig hi kp b fi ku kv l kw kx">public class Animal {<br/>    public void move(){<br/>        System.<em class="ky">out</em>.println("Animals can move");<br/>    }<br/><br/>    public void sleep(){<br/>        System.<em class="ky">out</em>.println("Animals can sleep");<br/>    }<br/>}</span></pre><p id="fd0e" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">狗类是动物的一个子类。</p><pre class="kc kd ke kf fd ko kp kq kr aw ks bi"><span id="b6f9" class="kt ig hi kp b fi ku kv l kw kx">public class Dog extends Animal {<br/>@Override    <br/>public void move() {<br/>        System.<em class="ky">out</em>.println("Dogs can move");<br/>    }<br/><br/>    public void bark() {<br/>        System.<em class="ky">out</em>.println("Dogs can bark");<br/>    }<br/>}</span></pre><p id="1963" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">除了私有成员之外，Dog类可以访问Animal的所有方法。您可以使用Dog类的对象来访问Animal类的方法。更多详情，请参考本<a class="ae kz" href="https://docs.oracle.com/javase/tutorial/java/IandI/index.html" rel="noopener ugc nofollow" target="_blank">文件</a>。</p><h1 id="a493" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">在测试自动化框架中实现继承</h1><p id="514c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了构建一个健壮的测试自动化框架，使用OOPs概念是必须的，继承是OOPs的核心原则之一。让我们看看为什么，在哪里以及如何在测试自动化框架中使用继承。</p><h2 id="3045" class="kt ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated"><strong class="ak">基类</strong></h2><p id="770c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">每个测试类都扩展到基类。在基类中，我们初始化Webdriver，一些变量和属性文件。我们甚至有TestNg beforeTest，afterTest，beforeMethod和afterMethod。下面给出了基类的一个示例:</p><pre class="kc kd ke kf fd ko kp kq kr aw ks bi"><span id="b30f" class="kt ig hi kp b fi ku kv l kw kx">package Android;<br/><br/>import org.testng.annotations.AfterMethod;<br/>import org.testng.annotations.AfterTest;<br/>import org.testng.annotations.BeforeMethod;<br/>import org.testng.annotations.BeforeTest;<br/><br/>import java.util.HashMap;<br/>import java.util.Map;<br/><br/>public class Base {<br/><br/>    public static String <em class="ky">userPhone </em>= "1234567890";<br/>    public static String <em class="ky">userEmail </em>= "xx.xxxxx@xxxx.com";<br/>    String configFilepath = System.<em class="ky">getProperty</em>("user.dir") + "/path/to/configuration/file";<br/><br/>    /* setting some default params */<br/>    public static Map&lt;String, Object&gt; setDefaultParams() {<br/>        Map&lt;String, Object&gt; defaultParams = new HashMap&lt;&gt;();<br/>        defaultParams.put("key", "value");<br/>        defaultParams.put("key", "value");<br/>        defaultParams.put("key", "value");<br/>        return defaultParams;<br/>    }<br/><br/>    @BeforeTest<br/>    public void initialiseDriver() {<br/>        //Code to initialise driver<br/>    }<br/><br/>    @BeforeTest<br/>    public void signUp() {<br/>        //Code to signup<br/>    }<br/><br/>    @BeforeMethod<br/>    public void startScreeRescording() {<br/>        //code to record screen<br/><br/>    }<br/><br/>    @AfterMethod<br/>    public void stopScreenRecording() {<br/>        //code to stop recording<br/>    }<br/><br/>    @AfterTest<br/>    public void tearDown() {<br/>        //code to close all the resources drivers,properties file, etc<br/>    }<br/>}</span></pre><p id="fef0" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">每个测试类都扩展到基类，这样每个测试类都可以访问非私有变量，比如用户电子邮件和用户电话号码。一些测试需要默认参数，这些常见的默认参数我们在方法setDefaultParams()中设置。通过这样做，我们不需要在测试类中一次又一次地设置变量和默认参数。此外，每当我们运行测试时，我们需要注册并开始记录屏幕，这些是作为TestNg BeforeTest和AfterTest方法提供的，在运行测试类中的测试方法时，TestNg将在父类中查找BeforeTest、BeforeMethod，从而确保注册发生在每个测试之前，屏幕记录在每个测试方法之前开始。我们确保在AfterMethod和AfterTest中停止屏幕录制、退出驱动程序并关闭其他资源。</p><h2 id="f540" class="kt ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated"><strong class="ak">管理网络驱动</strong></h2><p id="d801" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在一个框架中管理多个移动应用程序和不同类型的驱动程序是一项具有挑战性的任务。在一个框架中，一个驱动可以用不同的方式初始化，为了达到这个目的，我们可以使用一个接口。<strong class="jf hj">接口指定了一个类必须做什么，而不是如何做。这是班级的蓝图。</strong></p><p id="42ed" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">让我们看看驱动程序接口是什么样子的:</p><pre class="kc kd ke kf fd ko kp kq kr aw ks bi"><span id="ef1c" class="kt ig hi kp b fi ku kv l kw kx">public interface IDriver&lt;T&gt; {<br/><br/>  T getDriver(String browserName);<br/><br/>  T getDriver(BaseConfig baseConfig);<br/><br/>  T getDriver(String appName, BaseConfig baseConfig);<br/>}</span></pre><p id="f004" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">在驱动程序类中实现上述接口</p><pre class="kc kd ke kf fd ko kp kq kr aw ks bi"><span id="d25f" class="kt ig hi kp b fi ku kv l kw kx">public class CreateAndroidDriver implements IDriver&lt;AndroidDriver&gt;{</span><span id="a137" class="kt ig hi kp b fi ln kv l kw kx">@Override<br/>public AndroidDriver getDriver(String browserName) {<br/>  //provide implementation if using a browser(chrome,firefox etc.)<br/>}</span><span id="293a" class="kt ig hi kp b fi ln kv l kw kx">@Override<br/>public AppiumDriver getDriver(BaseConfig baseConfig){<br/>//provide implementation using a BaseConfig<br/>}</span><span id="be5f" class="kt ig hi kp b fi ln kv l kw kx">@Override<br/>public AppiumDriver getDriver(String appName, BaseConfig baseConfig){<br/>// provide implementation if there are multiple apps and baseConfig<br/>}</span><span id="00ae" class="kt ig hi kp b fi ln kv l kw kx">}</span></pre><p id="e96e" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">有了继承，我们将能够覆盖IDriver <t>接口的方法，这样就可以在派生类中设计接口方法的有意义的实现。我们可以为其他驱动程序，如IOSDriver，WebDriver等类似的实现。</t></p><h2 id="9cce" class="kt ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">管理设备</h2><p id="96da" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在运行自动化测试时，我们可能需要使用多个android或iPhone设备。通过继承，我们将能够轻松地管理这些设备。下面的界面显示了我们可以用设备做什么。</p><pre class="kc kd ke kf fd ko kp kq kr aw ks bi"><span id="e4d9" class="kt ig hi kp b fi ku kv l kw kx">public interface IDevice {<br/>  Device getDevice(String deviceUdid);<br/><br/>  List&lt;Device&gt; getDevices();<br/>}</span></pre><p id="07e8" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">实现上面的接口:</p><pre class="kc kd ke kf fd ko kp kq kr aw ks bi"><span id="1af8" class="kt ig hi kp b fi ku kv l kw kx">public class AndroidDeviceManager implements IDevice{</span><span id="8de0" class="kt ig hi kp b fi ln kv l kw kx">@Override<br/>public List&lt;Device&gt; getDevices() {<br/>//Code showing how to get list of all android devices<br/>}</span><span id="c982" class="kt ig hi kp b fi ln kv l kw kx">@Override<br/>public Device getDevice(String deviceUdid){<br/>//Code to get a connected android device by Uuid<br/>}</span></pre><p id="b9b2" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">这里androidDeviceManger类将提供一个接口方法的实现，定义我们如何通过UUID获得一个android设备或者我们如何获得所有的Android设备。</p><p id="792b" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">类似地，我们可以在iPhone的情况下使用一个IOSDeviceManager类，它自己实现了如何通过UUID获得一个iPhone设备或者如何获得所有连接的iPhone</p><h2 id="729a" class="kt ig hi bd ih la lb lc il ld le lf ip jo lg lh it js li lj ix jw lk ll jb lm bi translated">查询数据库</h2><p id="4821" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在自动化测试中，我们通常会做两种类型的查询，即选择查询和更新查询，而数据库服务器可以是MySQL、Microsoft SQL Server、Oracle、Postgres、Mongo等。我们可以有一个接口，该接口具有我们可以执行的查询类型，并且数据库类具有接口方法的实现。我们可以有如下界面</p><pre class="kc kd ke kf fd ko kp kq kr aw ks bi"><span id="1313" class="kt ig hi kp b fi ku kv l kw kx">public interface IDBManager{</span><span id="660b" class="kt ig hi kp b fi ln kv l kw kx">List&lt;LinkedHashMap&lt;String, String&gt;&gt; doSelect(<br/>    String dbHost,<br/>    int port,<br/>    String dbName,<br/>    boolean isSslEnabled,<br/>    String userName,<br/>    String password,<br/>    String query)<br/>    throws SQLException;</span><span id="ae17" class="kt ig hi kp b fi ln kv l kw kx">int executeUpdate(<br/>    String dbHost,<br/>    int port,<br/>    String dbName,<br/>    boolean isSslEnabled,<br/>    String userName,<br/>    String password,<br/>    String query)<br/>    throws SQLException;</span><span id="4717" class="kt ig hi kp b fi ln kv l kw kx">}</span></pre><p id="c0dd" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">我们可以拥有DBManger类，它将告诉我们如何连接数据库服务器并执行查询。例如:</p><pre class="kc kd ke kf fd ko kp kq kr aw ks bi"><span id="918c" class="kt ig hi kp b fi ku kv l kw kx">public class DBManager implements IDBManager{</span><span id="1787" class="kt ig hi kp b fi ln kv l kw kx">List&lt;LinkedHashMap&lt;String, String&gt;&gt; doSelect(<br/>    String dbHost,<br/>    int port,<br/>    String dbName,<br/>    boolean isSslEnabled,<br/>    String userName,<br/>    String password,<br/>    String query)<br/>    throws SQLException{<br/>//Code for making connection to mysql server and executing query<br/>}</span><span id="61af" class="kt ig hi kp b fi ln kv l kw kx">int executeUpdate(<br/>    String dbHost,<br/>    int port,<br/>    String dbName,<br/>    boolean isSslEnabled,<br/>    String userName,<br/>    String password,<br/>    String query)<br/>    throws SQLException{//Code for making connection to mysql server and executing query<br/>}</span><span id="0780" class="kt ig hi kp b fi ln kv l kw kx">}</span></pre><p id="e801" class="pw-post-body-paragraph jd je hi jf b jg kj ji jj jk kk jm jn jo kl jq jr js km ju jv jw kn jy jz ka hb bi translated">以上是我使用继承的一些方法。有n种方法可以使用继承。如果你以其他方式使用继承，请注释。</p></div></div>    
</body>
</html>