<html>
<head>
<title>Semantic release Angular with Gitlab CI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Gitlab CI的语义发布角度</h1>
<blockquote>原文：<a href="https://medium.com/codex/semantic-release-angular-with-gitlab-ci-ba961c7fe3e?source=collection_archive---------4-----------------------#2021-04-01">https://medium.com/codex/semantic-release-angular-with-gitlab-ci-ba961c7fe3e?source=collection_archive---------4-----------------------#2021-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/07658a32313ef7a916b398b491fd96e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbH0-FTsy55i9ivRIVn_hA.png"/></div></div></figure><p id="e467" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并发布在Gitlab页面上。并用APP_INITIALIZER显示我们的版本。</p><p id="a0bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将介绍在Gitlab CI管道的帮助下发布Angular应用程序的几个步骤，使用语义发布根据我们的提交生成适当的版本，并将该版本推送到部署有Gitlab页面的应用程序中。</p><p id="432a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你需要一些git commit和gitlab的基础知识，但并不复杂。最终的产品离生产就绪还很远，但是对于那些投身于devops问题的人来说，这是一个很好的开始。你会在例子中看到，我们只在主节点上工作，因为我不想添加分支、分叉和合并请求的问题。</p><blockquote class="jo jp jq"><p id="c70a" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj">注</strong>:查看优秀的凯文·克罗伊泽关于<a class="ae jv" rel="noopener" href="/angular-in-depth/handling-angular-environments-in-continuous-delivery-eeaee96f0aae">如何在CI/CD中加载Angular </a>的环境特定配置的这篇文章。</p></blockquote><h1 id="2d19" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">在Angular应用程序中初始化Gitlab CI</h1><p id="64fe" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">这是第一步，很简单，你可以找到相关的资源。<a class="ae jv" href="https://www.youtube.com/watch?v=Jav4vbUrqII" rel="noopener ugc nofollow" target="_blank">在这个视频</a>中，了解一下<strong class="is hj">的基本情况。gitlab-ci.yml </strong>文件。请注意，您不必在Gitlab项目配置中做任何事情来激活CI/CD，如果您转到项目中的<code class="du kz la lb lc b">/settings/ci_cd#runners</code>，您应该会看到<a class="ae jv" href="https://docs.gitlab.com/runner/" rel="noopener ugc nofollow" target="_blank"> Runners </a>已经被激活，这些是共享资源，因此不要期望它们总是以毫秒为单位响应，但基本上，它们将在目标分支上的每次提交时运行。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/16ecf95a1b717b082bfc5f39980aea33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nCJ0z4uPJl2UVRmFsEvv6g.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">默认启用Gitlab CI运行程序</figcaption></figure><p id="8383" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成后，您可以将Angular应用程序上传到您的存储库。我们将有4个步骤:</p><ul class=""><li id="1a45" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn lr ls lt lu bi translated">试验</li><li id="532d" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">释放；排放；发布</li><li id="41bf" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">发布后</li><li id="38e2" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">部署</li></ul><h2 id="593e" class="ma jx hi bd jy mb mc md kc me mf mg kg jb mh mi kk jf mj mk ko jj ml mm ks mn bi translated">在您的管道中配置最小测试</h2><p id="93d0" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">当然，这对于演示来说不是强制性的，但是对于我们的管道来说这是一个好的开始，如果lint或测试失败了，我们认为生成一个发布不是一个好主意。下面是我们的<strong class="is hj">。gitlab-cy.yml </strong>可能看起来像:</p><pre class="le lf lg lh fd mo lc mp mq aw mr bi"><span id="b6f9" class="ma jx hi lc b fi ms mt l mu mv">image: weboaks/node-karma-protractor-chrome</span><span id="66c4" class="ma jx hi lc b fi mw mt l mu mv">stages:<br/>  - test</span><span id="bc6b" class="ma jx hi lc b fi mw mt l mu mv">test:<br/>  stage: test<br/>  script:<br/>    - export CHROME_BIN=/usr/bin/google-chrome<br/>    - npm install -g @angular/cli@9.1.4<br/>    - npm install<br/>    - npm run lint<br/>    - npm run test:ci<br/>  only<br/>  - master</span></pre><blockquote class="jo jp jq"><p id="e68a" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">请小心您的阶段中的“only”参数，因为由于语义发布会在您的回购中创建一个标签，如果您没有指定“only”，发布的创建将触发任何没有正确定位的阶段。</p></blockquote><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/9703c47a233c2518bc5c28ce86722947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1OcpEy6rlt1uEoWKPRAcCA.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">查看由发布触发的失败管道。</figcaption></figure><p id="9ac8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一定要小心，按照最新版Docker图片的说明:<a class="ae jv" href="https://hub.docker.com/r/weboaks/node-karma-protractor-chrome/" rel="noopener ugc nofollow" target="_blank">https://hub . Docker . com/r/web oaks/node-karma-provider-chrome/</a>。特别注意你将要使用的浏览器，配置karma运行Chrome而不是Chrome。</p><pre class="le lf lg lh fd mo lc mp mq aw mr bi"><span id="4039" class="ma jx hi lc b fi ms mt l mu mv">// <strong class="lc hj">karma.conf.js</strong><br/>customLaunchers: {<br/>      ChromeHeadlessCI: {<br/>        base: '<strong class="lc hj">Chromium</strong>',<br/>        flags: ['--no-sandbox', '--headless', '--disable-gpu', '--remote-debugging-port=9222', '--single-run']<br/>      },</span><span id="02af" class="ma jx hi lc b fi mw mt l mu mv">// <strong class="lc hj">package.json</strong><br/>scripts: {<br/>   "test:ci": "ng test --watch=false --browsers=ChromeHeadlessCI",</span></pre><p id="5632" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从现在开始，我们有两个独立的任务:</p><ul class=""><li id="54be" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn lr ls lt lu bi translated">在ci/cd流程中运行语义发布脚本。</li><li id="a303" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">使用由此产生的版本，并在Angular应用程序中呈现给用户。</li></ul><h1 id="462f" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">在您的项目中配置语义发布。</h1><p id="756d" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">主要目标是在您的存储库中生成一个版本。这个版本是一个特定的git标签，没有链接到您的实际代码。所以请记住，我们不会改变我们的应用程序的代码库，但仍然希望向用户显示版本。您可以转到您的项目并创建一个发布:<code class="du kz la lb lc b">/releases/new</code></p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/f81072747c9520daef168a7550a610b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zj_VH7Nidcvg5NcS9yBvOA.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">在Gitlab界面中创建一个发布</figcaption></figure><p id="4a85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Gitlab版本可以通过用户工具或简单的git命令手动生成。<a class="ae jv" href="https://semantic-release.gitbook.io/semantic-release/" rel="noopener ugc nofollow" target="_blank">语义发布</a>是一个项目，将分析我们的提交，并为我们产生这个版本。</p><p id="771b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想要一个完整的过程介绍，请看这篇文章。你有你需要的所有信息，甚至更多关于你的分支策略的信息。我们将从这几点中保留:</p><ul class=""><li id="76ad" class="lm ln hi is b it iu ix iy jb lo jf lp jj lq jn lr ls lt lu bi translated">生成个人访问令牌</li><li id="a245" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">配置GITLAB_TOKEN变量</li><li id="3ff6" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">配置语义发布</li><li id="519d" class="lm ln hi is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">在管道中运行语义发布</li></ul><h2 id="02d7" class="ma jx hi bd jy mb mc md kc me mf mg kg jb mh mi kk jf mj mk ko jj ml mm ks mn bi translated">生成个人访问令牌</h2><p id="fd92" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">这是在您的个人资料页面<code class="du kz la lb lc b">/profile/personal_access_tokens</code>中完成的，正如文章中所述，使用<strong class="is hj"> api </strong>和<strong class="is hj"> write_repository作用域</strong>，这样runner将能够读取提交并发布新版本。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/f2c6d3320f5c2379bb1886c68cf87a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8XX98UpWXgX0aXFJa9DZDg.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">Gitlab个人访问令牌</figcaption></figure><h2 id="357d" class="ma jx hi bd jy mb mc md kc me mf mg kg jb mh mi kk jf mj mk ko jj ml mm ks mn bi translated">配置GITLAB_TOKEN变量</h2><p id="5bcb" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">这个变量是按照惯例命名的，就像Github或其他的自动化插件一样。只需转到<code class="du kz la lb lc b">/simple-ci/-/settings/ci_cd</code>并粘贴您刚刚创建的令牌的值。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/8102088d5e0a124d111faefe4b3e20cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*37bwT4pOtDJba-2SvW0LZg.png"/></div></div></figure><h2 id="439d" class="ma jx hi bd jy mb mc md kc me mf mg kg jb mh mi kk jf mj mk ko jj ml mm ks mn bi translated">配置语义发布</h2><p id="9872" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">我们将要求semantic release生成发布版本，并将版本号保存在一个名为VERSION.txt的文件中(我们稍后将使用它)。您只需要在项目的根文件夹中创建一个名为. releaserc.yml的文件。</p><pre class="le lf lg lh fd mo lc mp mq aw mr bi"><span id="9151" class="ma jx hi lc b fi ms mt l mu mv">// <strong class="lc hj">.releaserc.yml</strong><br/>plugins:<br/>  - "<a class="ae jv" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/commit-analyzer"<br/>  - "<a class="ae jv" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/release-notes-generator"<br/>  - - "<a class="ae jv" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/exec"<br/>    - verifyReleaseCmd: "echo ${nextRelease.version} &gt; <strong class="lc hj">VERSION.txt</strong>"<br/>  - "<a class="ae jv" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/gitlab"<br/>branches:<br/>  - "master"<br/>  - "+([0-9])?(.{+([0-9]),x}).x"<br/>  - name: "alpha"<br/>    prerelease: "alpha"</span></pre><h2 id="bfcb" class="ma jx hi bd jy mb mc md kc me mf mg kg jb mh mi kk jf mj mk ko jj ml mm ks mn bi translated">在我们的管道中运行语义发布</h2><p id="ecea" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">/exec插件将创建我们的VERSION.txt文件。该工具将在我们的发布阶段被调用，如下所示:</p><pre class="le lf lg lh fd mo lc mp mq aw mr bi"><span id="3430" class="ma jx hi lc b fi ms mt l mu mv">stages:<br/>  - test<br/>  - release<br/>[...]<br/>release:<br/>  image: node:13<br/>  stage: release<br/>  only:<br/>    refs:<br/>    - master<br/>    - alpha<br/>    # This matches maintenance branches<br/>    - /^(([0-9]+)\.)?([0-9]+)\.x/<br/>    # This matches pre-releases<br/>    - /^([0-9]+)\.([0-9]+)\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+[0-9A-Za-z-]+)?$/<br/>  script:<br/>    - npm install <a class="ae jv" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/gitlab <a class="ae jv" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/exec<br/>    - npx semantic-release<br/>  artifacts:<br/>    paths:<br/>      - <strong class="lc hj">VERSION.txt</strong></span></pre><p id="9fe2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用另一个图像，因为我们只需要这个阶段的节点。注意我们只安装了2个包，/gitlab和/exec，然后用npx调用semantic-release。您还会看到VERSION.txt文件被声明为一个<strong class="is hj">工件</strong>，以便下一阶段能够读取它。</p><blockquote class="jo jp jq"><p id="f491" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">注意，目前我们需要这个“绝招”，因为没有其他办法，跟随github上的这个讨论，了解人们在使用他们的发布版本号打印输出时遇到了什么样的问题:<a class="ae jv" href="https://github.com/semantic-release/semantic-release/issues/753" rel="noopener ugc nofollow" target="_blank">https://github . com/semantic-release/semantic-release/issues/753</a></p></blockquote><h1 id="b314" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">为Angular app生成一个json文件</h1><p id="7f97" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">这一步将简单地从以前的文件中提取版本，并把它放在一个JSON文件中，该文件将放在已部署应用程序的文件夹中。我更喜欢两个不同的阶段，以分离逻辑。</p><pre class="le lf lg lh fd mo lc mp mq aw mr bi"><span id="9114" class="ma jx hi lc b fi ms mt l mu mv">stages:<br/>  - test<br/>  - release<br/>  - postrelease<br/>[...]<br/>postrelease:<br/>  stage: postrelease<br/>  script:<br/>    - echo "test release"<br/>    - test -f <strong class="lc hj">VERSION.txt</strong><br/>    - appversion=`cat VERSION.txt`<br/>    - sed "s/\"app_version\".*/\"app_version\":\"${appversion}\"/" src/configuration.json &gt; <strong class="lc hj">configuration.json</strong><br/>  artifacts:<br/>    paths:<br/>      - configuration.json<br/>  only:<br/>  - master</span></pre><p id="d83c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个脚本中，我们检查VERSION.txt文件是否可用，替换JSON文件中的内容，并将这个新文件声明为工件。</p><p id="f0e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个configuration.json文件包含在我们的repo中(在/src文件夹中)，它在生命周期或源代码中从不改变，所以本地版本将总是固定的，比如说1.0.0，或者？。？。？。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/c5047c548771e5188811f910078dc56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ES8o4L0Wtxi-6vTnL1hwWw.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">我们应用程序的/src文件夹中的configuration.json文件示例。</figcaption></figure><blockquote class="jo jp jq"><p id="f383" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">关于这个文件，它是一个普通的文件，当由Gitlab Pages或任何类似Nginx的HTTP服务器提供服务时，您只需要将它放在一个适当的web文件夹中，以暴露其内容。但是在dev模式下，当运行ng serve或者运行测试时，您需要将这个文件声明为karma的资产和代理。</p></blockquote><h1 id="6978" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">部署Angular应用程序和配置文件</h1><p id="c6f4" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">最后一个阶段将简单地使用Gitlab页面部署应用程序，当它完成时，它将复制deploy文件夹中的工件。这个阶段非常简单，因为在Gitlab页面上部署就像创建一个名为“Pages”的阶段一样简单。查看本页以供参考:<a class="ae jv" href="https://docs.gitlab.com/ee/user/project/pages/" rel="noopener ugc nofollow" target="_blank">https://docs.gitlab.com/ee/user/project/pages/</a></p><pre class="le lf lg lh fd mo lc mp mq aw mr bi"><span id="d4f5" class="ma jx hi lc b fi ms mt l mu mv">stages:<br/>  - test<br/>  - release<br/>  - postrelease<br/>  - pages<br/>[...]<br/>pages:<br/>  cache:<br/>    paths:<br/>    - node_modules/<br/>  stage: deploy<br/>  script:<br/>    - npm install -g <a class="ae jv" href="http://twitter.com/angular/cli" rel="noopener ugc nofollow" target="_blank">@angular/cli</a>@11.2.6<br/>    - ng build --base-href "<a class="ae jv" href="https://aboudard.gitlab.io/ng-pages/" rel="noopener ugc nofollow" target="_blank">https://username.gitlab.io/ng-pages/</a>"<br/>    - mv dist/ng-pages/* public/<br/>    - test -f <strong class="lc hj">configuration.json</strong><br/>    - mv configuration.json public/<br/>  artifacts:<br/>    paths:<br/>    - public<br/>  only:<br/>  - master<br/>  - pages</span></pre><p id="6ef3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们在文档中看到的，Gitlab Pages只获取/public文件夹中的文件，这就是为什么我们使用您在这里找到的适当域名:<code class="du kz la lb lc b">/pages</code>来构建应用程序，然后将结果移动到/public文件夹中。</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/bda535e98993f0400da8aa8fc0d8f5c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f_ObuL4O3FfY0DSzH2DtCg.png"/></div></div></figure><p id="d1ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">构建完成后，我们还将configuration.json文件移动到/public文件夹中，它将覆盖现有的文件。“页面”阶段将简单地部署该文件夹下的所有内容。</p><h1 id="4c9d" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">在Angular应用程序中显示发布版本</h1><p id="ecc4" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">这是最后一步，可以先完成，因为我们不需要部署来使它工作。基本上，我们在APP_INITIALIZER中请求configuration.json文件，并在服务中公开它。</p><h2 id="fae1" class="ma jx hi bd jy mb mc md kc me mf mg kg jb mh mi kk jf mj mk ko jj ml mm ks mn bi translated">将文件作为资产公开</h2><pre class="le lf lg lh fd mo lc mp mq aw mr bi"><span id="c330" class="ma jx hi lc b fi ms mt l mu mv">// <strong class="lc hj">angular.json</strong><br/>"assets": [<br/>              "src/favicon.ico",<br/>              "src/assets",<br/>              "src/configuration.json"<br/>            ],</span></pre><p id="d650" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，它将总是发布在构建的/dist文件夹中，这就是为什么我们在ng构建之后移动我们的工件。</p><p id="a110" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于单元测试，我们需要声明如果需要，我们可以访问这个文件。</p><pre class="le lf lg lh fd mo lc mp mq aw mr bi"><span id="2010" class="ma jx hi lc b fi ms mt l mu mv">// <strong class="lc hj">karma.conf.js</strong><br/>files: [<br/>      { pattern: './src/configuration.json', watched: false, included: false, served: true, nocache: false }<br/>     ],<br/>     proxies: {<br/>      "/configuration.json": "/base/src/configuration.json"<br/>     }</span></pre><h2 id="3187" class="ma jx hi bd jy mb mc md kc me mf mg kg jb mh mi kk jf mj mk ko jj ml mm ks mn bi translated">在Angular应用程序中请求文件</h2><p id="c499" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">一个简单的方法是创建一个调用服务的APP_INITIALIZER提供程序，这个服务进行HTTP调用。</p><pre class="le lf lg lh fd mo lc mp mq aw mr bi"><span id="98d2" class="ma jx hi lc b fi ms mt l mu mv">// <strong class="lc hj">app.module.ts</strong><br/>export function loadConfigurations(configService: ConfigService): () =&gt; {} {<br/>  return () =&gt; configService.getConf();<br/> }</span><span id="db58" class="ma jx hi lc b fi mw mt l mu mv"><a class="ae jv" href="http://twitter.com/NgModule" rel="noopener ugc nofollow" target="_blank">@NgModule</a>({<br/>  declarations: [ AppComponent ],<br/>  imports: [<br/>    BrowserModule, AppRoutingModule, HttpClientModule<br/>  ],<br/>  providers: [<br/>    {<br/>      provide: APP_INITIALIZER,<br/>      useFactory: loadConfigurations,<br/>      deps: [ConfigService],<br/>      multi: true<br/>    }</span></pre><blockquote class="jo jp jq"><p id="9102" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">请注意，从Angular 12开始，我们现在可以在APP_INITIALIZER中使用Observables，不再需要调用toPromise()。查看本文:<a class="ae jv" href="https://dzhavat.github.io/2021/02/25/using-observable-in-app-initializer.html" rel="noopener ugc nofollow" target="_blank">https://dzhavat . github . io/2021/02/25/using-observable-in-app-initializer . html</a></p></blockquote><p id="6ea5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将是配置服务:</p><pre class="le lf lg lh fd mo lc mp mq aw mr bi"><span id="40bc" class="ma jx hi lc b fi ms mt l mu mv">// <strong class="lc hj">config.service.ts</strong><br/><a class="ae jv" href="http://twitter.com/Injectable" rel="noopener ugc nofollow" target="_blank">@Injectable</a>({<br/>  providedIn: 'root'<br/>})<br/>export class ConfigService {<br/>  configData: Configuration;<br/>  constructor(private http: HttpClient) { }<br/>  getConf(): Promise&lt;Configuration&gt; {<br/>    return this.http.get&lt;Configuration&gt;('configuration.json')<br/>      .pipe(<br/>        tap(result =&gt; {<br/>          this.configData = result;<br/>        })<br/>      ).toPromise();<br/>  }<br/>}</span></pre><p id="9bc5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在任何组件中，我们使用该服务并公开其中的任何内容(它可能是一个可观察到的值，而不是一个简单的值，但它真的不应该在应用程序运行时发生变化)。</p><pre class="le lf lg lh fd mo lc mp mq aw mr bi"><span id="de3d" class="ma jx hi lc b fi ms mt l mu mv">// <strong class="lc hj">app.component.ts</strong><br/>export class AppComponent implements OnInit {</span><span id="4c80" class="ma jx hi lc b fi mw mt l mu mv">title = 'ng-pages';<br/>  configData: Configuration;</span><span id="c2db" class="ma jx hi lc b fi mw mt l mu mv">constructor(private configService: ConfigService) {}</span><span id="471b" class="ma jx hi lc b fi mw mt l mu mv">ngOnInit(): void {<br/>    this.configData = this.configService.configData;<br/>  }</span><span id="31ca" class="ma jx hi lc b fi mw mt l mu mv">}</span></pre><p id="ebee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果在这里是在线的，有一个简单的版本显示:</p><figure class="le lf lg lh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/ac9a19e5f9b53518c3c94eb6ec198171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIgM2oDLJoMvWRVQAWbYVQ.png"/></div></div></figure><p id="c73a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">https://aboudard.gitlab.io/ng-pages/<a class="ae jv" href="https://aboudard.gitlab.io/ng-pages/" rel="noopener ugc nofollow" target="_blank"/></p><p id="0269" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Gitlab repo的原文可以在这里找到:</p><p id="5910" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">【https://gitlab.com/aboudard/ng-pages/ T4】</p><blockquote class="jo jp jq"><p id="27d6" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">最后一件事，当你在回购协议中提交重大变更时要小心，你必须尊重一条规则，以便将结果视为主要版本！看这里:<a class="ae jv" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank">https://github.com/semantic-release/semantic-release</a></p></blockquote></div></div>    
</body>
</html>