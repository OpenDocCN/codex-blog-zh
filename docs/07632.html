<html>
<head>
<title>Builder (Chaining) in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的构建器(链接)</h1>
<blockquote>原文：<a href="https://medium.com/codex/builder-chaining-in-swift-4aa72a8c09de?source=collection_archive---------6-----------------------#2022-06-20">https://medium.com/codex/builder-chaining-in-swift-4aa72a8c09de?source=collection_archive---------6-----------------------#2022-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e493" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在Swift中使用Builder模式包装API</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/b9a8ed6628c79bfdf1f436feb719917f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTsf-Q6Yt72LFOfcCqJtmA.jpeg"/></div></div></figure><h2 id="2d54" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">理解构建器模式</h2><p id="f438" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated"><strong class="kj hj"> Builder </strong>是一个创造性的设计模式，它允许逐步构建复杂的对象。在<strong class="kj hj"> Builder中，</strong>我们将一个复杂对象的构造从它的表示中分离出来，这样相同的构造过程可以创建不同的表示。</p><p id="5840" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">与其他创造模式不同，Builder不要求产品有一个公共界面。这使得使用相同的制造工艺生产不同的产品成为可能。只有当您的产品非常复杂并且需要大量配置时，使用构建器模式才有意义。</p><p id="51a4" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">例如，让我们考虑如何创建一个<code class="du lf lg lh li b">Car</code>。要造一辆基本的车，你需要有车身、发动机、轮胎、方向盘、排挡、油门、刹车、离合器等。但是，如果你想要一辆更强壮、更酷的车，有很酷的合金、很响的排气和其他花哨的东西呢？</p><p id="e38d" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">最简单的解决方案是扩展基本的<code class="du lf lg lh li b">Car</code>类，并创建一组子类来覆盖所有的参数组合。但是最终，你会得到相当多的子类。任何新的参数，比如合金类型，都需要增加层次结构。</p><p id="1de1" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">还有一种方法不涉及子类的繁殖。你可以在基本的<code class="du lf lg lh li b">Car</code>类中创建一个巨大的构造函数，用所有可能的参数控制汽车对象。虽然这种方法确实消除了对子类的需求，但它也产生了另一个问题。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/9ba3e31f960e0ad9bd63770e93d31797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVK8y16usoqs7EGf5x2ZPQ.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">构造函数问题</figcaption></figure><p id="3bfd" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">在上面的例子中，你可以看到<code class="du lf lg lh li b">Car A</code>没有<code class="du lf lg lh li b">Car B</code>拥有的很多东西。像这样，在大多数情况下，大多数参数都不会被使用，这使得<strong class="kj hj">构造函数调用起来非常难看</strong>。例如，只有一小部分汽车具有4x4驱动，因此与4x4驱动相关的参数十有八九是无用的。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="2807" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">如何解决问题</h2><p id="2692" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">Builder模式建议您将对象构造代码从它自己的类中提取出来，并将其移动到名为<code class="du lf lg lh li b"><strong class="kj hj"><em class="lv">builders</em></strong></code>的单独对象中。</p><p id="5741" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">该模式将对象构造组织成一组步骤(<code class="du lf lg lh li b">buildCarBody</code>、<code class="du lf lg lh li b">buildCarEngine</code>等)。).要创建一个对象，您需要对一个构建器对象执行一系列这些步骤。重要的是你不需要调用所有的步骤。您可以只调用产生对象的特定配置所必需的那些步骤。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lw"><img src="../Images/0d9b139181ef4f80410a0e4129c81bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*9d-jC3w3cfCJsqAVlmdDDw.jpeg"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated"><em class="lx">构建器模式让您一步一步地构建复杂的对象。构建器不允许其他对象访问正在构建的产品。</em></figcaption></figure></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="5c6a" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">使用生成器模式包装UIAlertController</h2><p id="d937" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">让我们使用构建器设计模式在iOS中创建一个<code class="du lf lg lh li b"><strong class="kj hj">UIAlertController</strong></code>。通常我们如何创建一个<code class="du lf lg lh li b"><strong class="kj hj">UIAlertController</strong></code> <strong class="kj hj">？</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/a0cd33fb89e49b1344e03bbd9f067e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eX15IhB_sRe16GW-v5HtWw.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">正电码</figcaption></figure><p id="cdab" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">写的和下面一样会有多酷？</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/fb15d5bebba9e7c1551cb7c9be0f031e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B6rcxDcguyjZvu2GrFeVFg.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">建造者代码</figcaption></figure><p id="8802" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">是不是超级酷？</p><p id="a19f" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">现在让我们深入了解如何将<code class="du lf lg lh li b">UIAlertController</code> API包装成它的构建版本。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="c364" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">创造</h2><p id="199c" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">我们将首先创建我们的<code class="du lf lg lh li b">AlertBuilder</code>类，因为我们需要一些基本的输入。一个<code class="du lf lg lh li b">UIAlertController</code>将需要一个<code class="du lf lg lh li b">title</code>、<code class="du lf lg lh li b">message</code>、<code class="du lf lg lh li b">buttons</code>和一个<code class="du lf lg lh li b">rootViewController</code>。我们将使用下面的代码来创建我们的<code class="du lf lg lh li b">AlertBuilder</code></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="17a3" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">这足以帮助我们设置<code class="du lf lg lh li b">UIAlertController</code>的构建版本。这里我们实现了可以在类中识别的构建器模式，它有一个创建方法和几个配置结果对象的方法。这里单个创建方法为<code class="du lf lg lh li b">showAlert</code>，配置方法为<code class="du lf lg lh li b">title</code>、<code class="du lf lg lh li b">message</code>、<code class="du lf lg lh li b">buttons</code>和<code class="du lf lg lh li b">parentViewController</code>。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h2 id="1c33" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">使用</h2><p id="926d" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">我们将转到我们的<code class="du lf lg lh li b">ViewController</code>文件，并在<code class="du lf lg lh li b">viewDidAppear</code>方法中添加<code class="du lf lg lh li b">NVAlertBuilder</code>用法代码，如下所示。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ma mb l"/></div></figure></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="679f" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">我希望您理解了什么是构建器模式，以及如何在您的下一个项目中使用构建器模式。如果你有任何疑问或建议，请告诉我。</p></div></div>    
</body>
</html>