<html>
<head>
<title>What is The Difference between 2NF and 3NF?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2NF和3NF有什么区别？</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-is-the-difference-between-2nf-and-3nf-2ecfb336f7f3?source=collection_archive---------9-----------------------#2021-07-08">https://medium.com/codex/what-is-the-difference-between-2nf-and-3nf-2ecfb336f7f3?source=collection_archive---------9-----------------------#2021-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/33da646d394bf4d463630635b2d145be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9Yzdq-Mb2rIoBvhQ.jpg"/></div></div></figure><h1 id="1156" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="7480" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">数据库中的规范化是组织数据以减少冗余的过程。主要思想是将一个较大的表分割成较小的表，并通过一个关系将它们连接起来。</p><p id="df2f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">但是，像你我这样的最终用户为什么要关心数据规范化呢？</p><p id="d5be" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">要回答这个问题，我们首先需要了解如果我们的数据没有被规范化会发生什么。</p><h1 id="a2d2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">为什么数据库规范化很重要？</h1><p id="e215" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们假设一家公司存储了它所有的数据，比如员工的详细信息、个人信息等等。，在单个表中。开发人员、数据库管理员(DBA)等最终用户可以访问这些数据。但是当多个最终用户同时与数据库交互时会发生什么呢？</p><p id="1578" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">例如，假设一名DBA正在更新数据库，在此过程中，一名开发人员在完全不知情的情况下对数据库执行了另一项操作。这些用户现在对数据库有了完全不同的看法。</p><p id="0bc7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">当多个用户同时与数据库交互时，这种数据不匹配可以被称为异常。</p><p id="c9c7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这就是数据规范化介入的地方。它有助于避免数据不一致，并提供一种更有组织的方式来存储您的数据。因此，无论您是数据库管理员还是最终用户，您都需要了解您的数据是如何存储的，以及这对公司意味着什么。</p><p id="fc58" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">既然我们对没有数据规范化会发生什么有了一个清晰的概念，那么让我们来看看可用于数据库管理(DBMS)的各种范式。</p><h1 id="f32e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">范式</h1><h2 id="e396" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">第一范式(1NF)</h2><p id="e3d7" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果一个关系不包含任何多值或复合属性，则称其为第一范式(1NF)。换句话说，表中的每个属性都必须保存一个原子值；否则，它违背了第一范式的规则。</p><p id="07fb" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们看一个例子:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/8ed02d0648d91bfcd6659fbc544969cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2yzqO5U0fc6xQcnShnMTQ.png"/></div></div></figure><p id="3eec" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">表中的最后一列“租借的电影”包含几个值。该表的1NF版本如下所示:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/b6c3c674153b979fdc31f710bffe864c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PkJMK8p4vTlIu8tZsWk17g.png"/></div></div></figure><p id="2ae3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在您可能想知道，如果上述转换使现有行数加倍，数据规范化如何减少冗余？</p><p id="5a10" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这是因为我们采用了一个简单的场景，其中我们只考虑了一个表。在下一节中，我们将讨论第二范式，它对于数据规范化如何减少总体冗余更有意义。</p><h2 id="6f39" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">第二范式(2NF)</h2><p id="ebf0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果满足以下条件，则关系为第二范式(2NF ):</p><ol class=""><li id="8f46" class="ll lm hi jq b jr km jv kn jz ln kd lo kh lp kl lq lr ls lt bi translated">它是第一范式(1NF ),</li><li id="3a71" class="ll lm hi jq b jr lu jv lv jz lw kd lx kh ly kl lq lr ls lt bi translated">它没有部分依赖性</li></ol><p id="6de6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果可以从候选关键字的真子集确定非关键字属性，则称该关系具有<strong class="jq hj">部分依赖</strong>。</p><p id="a31b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们看一个例子来更好地理解这一点</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/ffc24f77d3cf3e98544cdc85a7913761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zoannwKfZYA7IsiSbnQlRg.png"/></div></div></figure><p id="0e3b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">上表遵循1NF，因为每个属性保存一个值。但是，“教师年龄”是一个非键属性(因为它不能用作标识符——两个人可以有相同的年龄)，它依赖于“教师ID”，后者是候选键的真子集。因此，此表呈现部分依赖关系，不遵循第二范式。</p><p id="7095" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">adobe表格的2NF转换如下所示:</p><p id="6c88" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">表1: </strong></p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/6bef9b5ce0fb483587731a6b7f2c4173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*867xd8Wh1Kq3ILQ9tgewvA.png"/></div></div></figure><p id="a15f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">表二:</strong></p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/b63ca04528481b7cbff3c5342b3f1b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R78ijAO0FzfWlRSQVT8XTA.png"/></div></div></figure><p id="9559" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在，我们不再需要在每次添加新课程时存储教师年龄。当您处理大量行时，这种分解减少了总体冗余。</p><p id="11ee" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们看看链中的下一个范式。</p><h2 id="27fc" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">第三范式(3NF)</h2><p id="e8a5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果符合以下条件，则关系为第三范式(3NF)</p><ol class=""><li id="90e3" class="ll lm hi jq b jr km jv kn jz ln kd lo kh lp kl lq lr ls lt bi translated">它在2NF中，</li><li id="4fd1" class="ll lm hi jq b jr lu jv lv jz lw kd lx kh ly kl lq lr ls lt bi translated">对于所有非关键属性<strong class="jq hj">，它没有<strong class="jq hj">传递依赖</strong>。</strong></li></ol><p id="6b6e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果A-&gt;B and B-&gt; C是两个函数依赖，那么A-&gt;C是传递依赖。如果一个表有这样的间接依赖，那么它就不符合第三范式。</p><p id="5f5f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">或者，如果这些条件之一为真，则具有函数依赖关系A-&gt;B的关系在3NF中</p><ol class=""><li id="8c23" class="ll lm hi jq b jr km jv kn jz ln kd lo kh lp kl lq lr ls lt bi translated">a是超级键</li><li id="c20b" class="ll lm hi jq b jr lu jv lv jz lw kd lx kh ly kl lq lr ls lt bi translated">B是主要属性，即B是候选关键字的一部分</li></ol><p id="ee32" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">考虑下面的表格-</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/ed02cb1d3c9023294f8324ee50ed352f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zM-tqfJLN5AS1NDTjWTCdQ.png"/></div></div></figure><p id="64eb" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">主键:</strong>员工ID <br/> <strong class="jq hj">非键属性:</strong>员工姓名、员工州、员工国家、员工邮政编码</p><ol class=""><li id="26c3" class="ll lm hi jq b jr km jv kn jz ln kd lo kh lp kl lq lr ls lt bi translated">“员工邮政编码”依赖于“员工ID”</li><li id="ad8a" class="ll lm hi jq b jr lu jv lv jz lw kd lx kh ly kl lq lr ls lt bi translated">“雇员州”和“雇员国家”依赖于“雇员邮政编码”。'</li></ol><p id="cff3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因此，根据传递依赖的定义，“雇员州”和“雇员国家”依赖于“雇员ID”因此，该表不在3NF中。我们需要把表分成两部分，最终的转换看起来像这样-</p><p id="9f83" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">表1: </strong></p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/76bcc5020fe261d908bc93ed4ad47574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1QVye47WKBbiUKzJeIw9Q.png"/></div></div></figure><p id="f0ef" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">表2: </strong></p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/d14bc4f1f7b95a7467732294d210ec2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VoXh8jGCzT78nwAUY8s4mg.png"/></div></div></figure><h1 id="03ab" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">第二范式(2NF)和第三范式(3NF)的区别</h1><p id="73a2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对三种范式的概述告诉我们一件事是肯定的——每一种范式都比前一种范式更严格。例如，在2NF中，非主属性不依赖于主(或键)属性，但是一个非主属性可以依赖于另一个非主属性。3NF消除了这种可能性，因为非主属性只依赖于关系的超级键。</p><p id="a8ac" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">此外，2NF处理部分依赖，而3NF专注于避免传递依赖。使用2NF，我们看到重复组从表中删除了，而3NF完全减少了冗余。因此，3NF是一种更强的规范化形式。</p><p id="de92" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">2NF和3NF之间的直接比较有些误导，因为这不是苹果对苹果的比较。3NF是2NF的更复杂的情况，因此，比较这些范式是不公平的。规范化的选择取决于您的数据和最终目标。如果你的目标是减少主要的冗余数据，选择2NF。但是，如果您希望确保引用完整性，3NF是更好的选择。</p></div></div>    
</body>
</html>