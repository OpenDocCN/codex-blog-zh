<html>
<head>
<title>Observer Pattern In PHP 8+</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP 8+中的观察者模式</h1>
<blockquote>原文：<a href="https://medium.com/codex/observer-pattern-in-php-8-569c71dd7837?source=collection_archive---------3-----------------------#2021-07-14">https://medium.com/codex/observer-pattern-in-php-8-569c71dd7837?source=collection_archive---------3-----------------------#2021-07-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/5494673a982148dc7234a6807f21746e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DoB5LSpOU6pdXhQ-ASGyVg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图片来自<a class="ae hv" href="https://pixabay.com/pt/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1209011" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae hv" href="https://pixabay.com/photos/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1209011" rel="noopener ugc nofollow" target="_blank">免费照片</a></figcaption></figure><div class=""/><p id="1c3e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在PHP 8+中实现观察者模式的最简单指南</p><p id="0e1d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">PHP世界中最常用的设计模式之一是<strong class="ix hz">观察器</strong>，当我们有几个依赖于另一个对象的对象，并且需要在那个对象的状态改变时执行一个动作，或者一个对象需要通知其他人而不知道他们是谁或者有多少人时，这非常有用。</p><h1 id="bb19" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">🧐观察者设计模式</h1><p id="5311" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><strong class="ix hz">观察者设计模式</strong>是一种行为设计模式，它让一个对象在事件发生时通知其他对象，比如状态改变或方法执行。</p><p id="052b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个模式由一个名为<strong class="ix hz">可观察</strong>的对象(或某些来源中的<strong class="ix hz">主体</strong> / <strong class="ix hz">发布者</strong>)和许多其他名为<strong class="ix hz">观察者</strong>(或<strong class="ix hz">订阅者</strong>)的对象组成。<strong class="ix hz">可观察对象</strong>拥有一个<strong class="ix hz">观察对象</strong>的列表作为属性，并自动通知它们任何状态变化，通常调用一个观察对象的方法。</p><p id="e609" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">观察者模式通常用于在应用程序<strong class="ix hz">中实现事件处理程序，而不会在主类和事件监听器的对象</strong>之间创建依赖关系。</p><h1 id="4892" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">👷‍♂️实施</h1><p id="fd46" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在我们的例子中，我们将创建一个简单的系统，它可以创建用户并将他们的数据存储在内存中。然后我们将在每次创建用户时实现一个通知</p><p id="3467" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们创建一个只有名称和电子邮件属性的用户类。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="2fbf" class="lg ju hy lc b fi lh li l lj lk">class <strong class="lc hz">User</strong><br/>{<br/>    public function __construct(<br/>        private string $name,<br/>        private string $email<br/>    ) {}<br/>}</span></pre><p id="f172" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，让我们创建一个<em class="kw">用户存储库</em>来存储和处理用户数据:</p><blockquote class="ll lm ln"><p id="a357" class="iv iw kw ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">UsersRepository类将实现<strong class="ix hz">单例模式</strong>,以保证数据被正确持久化</p></blockquote><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="84d1" class="lg ju hy lc b fi lh li l lj lk">class <strong class="lc hz">UsersRepository</strong><br/>{<br/>    private array $users = [];</span><span id="ee5f" class="lg ju hy lc b fi lr li l lj lk">    private static $instance;</span><span id="7a39" class="lg ju hy lc b fi lr li l lj lk">    private function __construct() {}<br/>    private function __clone() {}</span><span id="21e8" class="lg ju hy lc b fi lr li l lj lk">    public function <strong class="lc hz">createUser</strong>(<em class="kw">User</em> $user)<br/>    {<br/>        <em class="kw">$this</em>-&gt;users[] = $user;<br/>    }</span><span id="7c74" class="lg ju hy lc b fi lr li l lj lk">    public static function <strong class="lc hz">getInstance</strong>()<br/>    {<br/>        if(<em class="kw">self</em>::$instance === null) {<br/>            self::$instance = new self;<br/>        }<br/>        return self::$instance;<br/>    }<br/>}</span></pre><p id="0c66" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">PHP有内置的接口来帮助我们实现观察者设计模式。为了实现<strong class="ix hz">可观察的</strong>对象，我们可以使用<a class="ae hv" href="https://php.net/manual/en/class.splsubject.php" rel="noopener ugc nofollow" target="_blank"><strong class="ix hz">spl subject</strong></a><strong class="ix hz"/>接口，对于<strong class="ix hz">观察者</strong>，我们可以使用<a class="ae hv" href="https://www.php.net/manual/en/class.splobserver.php" rel="noopener ugc nofollow" target="_blank"><strong class="ix hz">spl observer</strong></a><strong class="ix hz"/>接口。</p><p id="6553" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们将在<em class="kw"> UsersRepository </em>类上实现<strong class="ix hz"> SplSubject </strong>，这样，当您的状态改变时，该类将能够通知其他类。</p><blockquote class="ll lm ln"><p id="0e8d" class="iv iw kw ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated"><strong class="ix hz"> SplSubject </strong>接口指定我们必须实现<a class="ae hv" href="https://www.php.net/manual/en/splsubject.attach.php" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hz"> attach </strong> </a>方法来订阅一个新的观察者，实现<a class="ae hv" href="https://www.php.net/manual/en/splsubject.detach.php" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hz"> detach </strong> </a>方法来取消订阅一个观察者，实现<a class="ae hv" href="https://www.php.net/manual/en/splsubject.notify.php" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hz"> notify </strong> </a>方法通知所有订阅的观察者。</p></blockquote><p id="fc98" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我会展示最终的结果，然后我们一起一步一步地检查代码。因此，最后一个类将是这样的:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="e7d5" class="lg ju hy lc b fi lh li l lj lk">class <strong class="lc hz">UsersRepository</strong> implements SplSubject<br/>{<br/>    private <strong class="lc hz">\SplObjectStorage</strong> $observers;<br/>    <br/>    private array $users = [];</span><span id="f48b" class="lg ju hy lc b fi lr li l lj lk">    private static $instance;</span><span id="75a6" class="lg ju hy lc b fi lr li l lj lk">    private function __construct()<br/>    {<br/>        $this-&gt;observers = <strong class="lc hz">new \SplObjectStorage</strong>;<br/>    }<br/>    private function __clone() {}</span><span id="8d71" class="lg ju hy lc b fi lr li l lj lk">    public function createUser(<em class="kw">User</em> $user): void<br/>    {<br/>        <em class="kw">$this</em>-&gt;users[] = $user;<br/><strong class="lc hz">        $this-&gt;notify();</strong><br/>    }</span><span id="ab18" class="lg ju hy lc b fi lr li l lj lk">    public function <strong class="lc hz">attach</strong>(\SplObserver $observer): void<br/>    {<br/>        $this-&gt;observers-&gt;attach($observer);<br/>    }</span><span id="dec0" class="lg ju hy lc b fi lr li l lj lk">    public function <strong class="lc hz">detach</strong>(\SplObserver $observer): void<br/>    {<br/>        $this-&gt;observers-&gt;detach($observer);<br/>    }</span><span id="b35c" class="lg ju hy lc b fi lr li l lj lk">    public function <strong class="lc hz">notify</strong>(): void<br/>    {<br/>        foreach($this-&gt;observers as $observer) {<br/>            $observer-&gt;update($this);<br/>        }<br/>    }</span><span id="a2e8" class="lg ju hy lc b fi lr li l lj lk">    public static function getInstance(): self<br/>    {<br/>        if(<em class="kw">self</em>::$instance === null) {<br/>            self::$instance = new self;<br/>        }<br/>        return self::$instance;<br/>    }<br/>}</span></pre><p id="1ab1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一步是实现属性，该属性将保存所有附加到<strong class="ix hz">主题</strong>的观察器，并在构造函数中初始化它:</p><blockquote class="ll lm ln"><p id="38ac" class="iv iw kw ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">PHP有一个处理对象集的内置类叫做<a class="ae hv" href="https://www.php.net/manual/en/class.splobjectstorage.php" rel="noopener ugc nofollow" target="_blank"><strong class="ix hz">SplObjectStorage</strong></a>。它在需要唯一标识对象的情况下很有用，并将在我们的<strong class="ix hz">观察者模式</strong>实现中用来保存我们的<strong class="ix hz">观察者</strong>集合。</p></blockquote><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="0e50" class="lg ju hy lc b fi lh li l lj lk">private <strong class="lc hz">\SplObjectStorage</strong> $observers;</span><span id="ab77" class="lg ju hy lc b fi lr li l lj lk">private function __construct()<br/>{<br/>    $this-&gt;observers = <strong class="lc hz">new \SplObjectStorage</strong>;<br/>}</span></pre><p id="1cab" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，剩下的就是实现方法来处理订阅(<strong class="ix hz">附加</strong>)、取消订阅(<strong class="ix hz">分离</strong>)和通知(<strong class="ix hz">通知</strong>)方法。对于第一个和第二个方法，我们将使用<a class="ae hv" href="https://www.php.net/manual/en/splobjectstorage.attach.php" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hz"> attach </strong> </a>和<a class="ae hv" href="https://www.php.net/manual/en/splobjectstorage.detach.php" rel="noopener ugc nofollow" target="_blank"><strong class="ix hz">detach</strong></a>SplObjectStorage的方法，将一个观察者作为参数传递。对于最后一个，我们将遍历我们的观察者池，调用每个观察者的<strong class="ix hz"> update </strong>方法，将Subject类作为参数传递。</p><blockquote class="ll lm ln"><p id="c655" class="iv iw kw ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">在<strong class="ix hz"> createUser </strong>方法中创建用户后，我们还需要添加一个对<strong class="ix hz"> notify </strong>方法的调用。</p></blockquote><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="8776" class="lg ju hy lc b fi lh li l lj lk">public function createUser(<em class="kw">User</em> $user): void<br/>{<br/>    <em class="kw">$this</em>-&gt;users[] = $user;<br/><strong class="lc hz">    $this-&gt;notify();</strong><br/>}</span><span id="b0c1" class="lg ju hy lc b fi lr li l lj lk">public function <strong class="lc hz">attach</strong>(\SplObserver $observer): void<br/>{<br/>    $this-&gt;observers-&gt;<strong class="lc hz">attach</strong>($observer);<br/>}</span><span id="c706" class="lg ju hy lc b fi lr li l lj lk">public function <strong class="lc hz">detach</strong>(\SplObserver $observer): void<br/>{<br/>    $this-&gt;observers-&gt;<strong class="lc hz">detach</strong>($observer);<br/>}</span><span id="346d" class="lg ju hy lc b fi lr li l lj lk">public function <strong class="lc hz">notify</strong>(): void<br/>{<br/>    foreach($this-&gt;observers as $observer) {<br/>        $observer-&gt;<strong class="lc hz">update</strong>($this);<br/>    }<br/>}</span></pre><p id="ff15" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，我们的<em class="kw">用户资料库</em>完成了。现在，我们必须创建一个类，每次创建用户时都会得到通知。对于这个例子，我们将创建一个虚拟的电子邮件发送者类，它将实现<strong class="ix hz"> SplObserver </strong>接口:</p><blockquote class="ll lm ln"><p id="a07e" class="iv iw kw ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated"><strong class="ix hz"> SplObserver </strong>接口指定我们必须实现<a class="ae hv" href="https://www.php.net/manual/en/splobserver.update.php" rel="noopener ugc nofollow" target="_blank"><strong class="ix hz">update</strong></a><strong class="ix hz"/>方法，该方法将接收实现<strong class="ix hz"> SplSubject </strong>的对象作为唯一参数。</p></blockquote><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="fc7d" class="lg ju hy lc b fi lh li l lj lk">class <strong class="lc hz">Email</strong> implements <strong class="lc hz">\SplObserver</strong><br/>{<br/>    public function <strong class="lc hz">update</strong>(\SplSubject $subject): void<br/>    {<br/>        echo "Email class has been notified!\n";<br/>    }<br/>}</span></pre><p id="d952" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们只需创建一个脚本来测试我们的<strong class="ix hz">观察者模式</strong>实现:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="24fa" class="lg ju hy lc b fi lh li l lj lk">&lt;?php</span><span id="e98d" class="lg ju hy lc b fi lr li l lj lk"># First, we get an instance of UsersRepository and Email classes<br/>$usersRepository = UsersRepository::<strong class="lc hz">getInstance</strong>();<br/>$emailSender = <strong class="lc hz">new Email()</strong>;</span><span id="91f7" class="lg ju hy lc b fi lr li l lj lk"># Then, we attach the Email class to UsersRepository observers' pool<br/>$usersRepository-&gt;<strong class="lc hz">attach</strong>($emailSender);</span><span id="09d9" class="lg ju hy lc b fi lr li l lj lk"># Now we may create a new user<br/>$user = <strong class="lc hz">new User</strong>('Rafael', 'rafaelmelo.programmer@gmail.com');<br/>$usersRepository-&gt;<strong class="lc hz">createUser</strong>($user);</span></pre><p id="95b8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">执行该脚本将导致:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="60c1" class="lg ju hy lc b fi lh li l lj lk">$ Email class has been notified!</span></pre><h1 id="608f" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">📉优势</h1><p id="5878" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">观察者设计模式允许我们在对象之间创建一对多的关系，并且，最好的部分是:主对象不知道它的依赖对象的任何事情。</p><p id="7d65" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那是什么意思？嗯，这允许我们在不改变主对象的情况下实现其他依赖对象，换句话说，这给我们带来了期望的低耦合和高内聚。而且，它符合<a class="ae hv" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hz">开合原理</strong> </a> <strong class="ix hz"> </strong>中所述<strong class="ix hz"/><a class="ae hv" href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#:~:text=SOLID%20is%20an%20acronym%20for,OOD)%20principles%20by%20Robert%20C.&amp;text=O%20%2D%20Open%2Dclosed%20Principle,I%20%2D%20Interface%20Segregation%20Principle" rel="noopener ugc nofollow" target="_blank"><strong class="ix hz">稳固</strong> </a>原理。</p><p id="911a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上，回到我们的例子，除了已经实现的电子邮件通知之外，我们还可以实现其他通知类型，比如SMS，而无需更改<em class="kw"> UsersRepository </em>类。</p><h1 id="731d" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">📈不足之处</h1><p id="f4ff" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">尽管有这些好处，但是滥用观察者模式实现会给系统带来不必要的复杂性。</p><p id="5844" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，我们无法控制观察者的通知顺序，如果系统没有良好的结构，这可能会导致错误或意外的行为。</p><h1 id="6e9e" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">✅结论</h1><p id="aa29" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Observer模式是PHP世界中最常用的设计模式之一，它可以为应用程序带来灵活性，当我们有几个依赖于另一个对象的对象，并且需要在该对象的状态改变时执行某个操作，或者一个对象需要通知其他对象时，它非常有用。</p><p id="147d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很容易实现，主要是在PHP中，我们有内置的接口和类来帮助我们加快开发过程。</p><p id="030f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">观察者模式给我们带来了系统的低耦合和高内聚。另一方面，它会给代码带来不必要的复杂性和意想不到的副作用。</p><p id="9a36" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想更深入地了解这个主题，我建议访问我在下面留下的所有参考资料！</p><h1 id="0ccc" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">📚参考</h1><blockquote class="ll lm ln"><p id="5808" class="iv iw kw ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated"><a class="ae hv" href="https://www.php.net/manual/pt_BR/class.splobserver.php" rel="noopener ugc nofollow" target="_blank">官方SplObserver文档</a></p><p id="ceed" class="iv iw kw ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated"><a class="ae hv" href="https://www.php.net/manual/pt_BR/class.splsubject.php" rel="noopener ugc nofollow" target="_blank">官方SplSubject文档</a></p><p id="9a3e" class="iv iw kw ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated"><a class="ae hv" href="https://refactoring.guru/design-patterns/observer" rel="noopener ugc nofollow" target="_blank">观察者(refactoring.guru) </a></p><p id="e13a" class="iv iw kw ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated"><a class="ae hv" href="https://en.wikipedia.org/wiki/Event_(computing)" rel="noopener ugc nofollow" target="_blank">事件(计算)—维基百科</a></p><p id="d711" class="iv iw kw ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated"><a class="ae hv" href="https://www.sitepoint.com/understanding-the-observer-pattern/" rel="noopener ugc nofollow" target="_blank">通过<a class="ae hv" href="https://www.sitepoint.com/author/iteo" rel="noopener ugc nofollow" target="_blank"> Ignatius Teo </a>理解观察者模式</a></p></blockquote></div></div>    
</body>
</html>