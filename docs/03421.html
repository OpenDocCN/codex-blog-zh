<html>
<head>
<title>Python and Physics: Lorenz and Rossler Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python和物理学:洛伦兹和罗斯勒系统</h1>
<blockquote>原文：<a href="https://medium.com/codex/python-and-physics-lorenz-and-rossler-systems-65735791f5a2?source=collection_archive---------1-----------------------#2021-09-02">https://medium.com/codex/python-and-physics-lorenz-and-rossler-systems-65735791f5a2?source=collection_archive---------1-----------------------#2021-09-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="98d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于我以前关于龙格-库塔方法的文章，我们将探索龙格-库塔方法在绘制著名的洛伦兹和罗斯勒系统图中的一些应用。</p><h1 id="c3aa" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">洛伦兹</strong></h1><p id="cdf9" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">洛伦兹系统是一组方程，显示了某些参数的混沌行为，最显著的是产生了一个有趣的图形。我们将要使用的方程如下</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/48493897297a75175e55ed39476f437a.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*18t0JaZaRqyVusGfO3ATSw.jpeg"/></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">洛伦兹方程</figcaption></figure><p id="903a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些将是我们将插入到我们的导数函数中的方程，这样我们就可以应用RK4(龙格-库塔四步法)方法。首先，我们从导入必要的包开始。</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="4dae" class="kx je hi kt b fi ky kz l la lb">import numpy as np #For arrays<br/>import matplotlib.pyplot as plt #For plotting</span></pre><p id="29f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们从这些方程要用到的变量开始。</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="ef7e" class="kx je hi kt b fi ky kz l la lb">sigma = 10.0 #Variable for dx/dt<br/>rho = 28.0 #Variable for dy/dt<br/>beta = 8/3 #Variable for dz/dt<br/>t = 0 #Starting time<br/>tf = 40 #Ending time<br/>h = 0.01 #Step size for RK4</span><span id="50d8" class="kx je hi kt b fi lc kz l la lb">#These variables were used since they can be easily found for comparison, for example, in Wikipedia under the Lorenz system article</span></pre><p id="e9db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着变量的设定，我们现在开始研究导数函数。</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="bdd0" class="kx je hi kt b fi ky kz l la lb">#Derivative function to work with RK4 loop<br/>def derivative(r,t):<br/>    x = r[0]<br/>    y = r[1]<br/>    z = r[2]<br/>    return np.array([sigma * (y - x), x * (rho - z) - y, (x * y) - (beta * z)])</span></pre><p id="261c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导数函数的快速复习。<em class="ld"> r </em>变量用于数组内部设置的初始条件。我们为每个变量分配数组的值，在本例中为3，然后函数将返回开始时画出的微分方程，但现在是初始条件。每次循环经历一次迭代，函数将继续用新值更新，这些新值将存储在下面的数组中。</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="c3b9" class="kx je hi kt b fi ky kz l la lb">time = np.array([]) #Empty time array to fill for the x-axis<br/>x = np.array([]) #Empty array for x values<br/>y = np.array([]) #Empty array for y values<br/>z = np.array([]) #Empty array for z values</span><span id="58c0" class="kx je hi kt b fi lc kz l la lb">r = np.array([1.0, 1.0, 1.0]) #Initial conditions array</span></pre><p id="4f5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，随着我们的主要部分的设置，我们只是继续前进，并适用于RK4循环内的一切，我们结束了</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="41a3" class="kx je hi kt b fi ky kz l la lb">while (t &lt;= tf ):</span><span id="d47e" class="kx je hi kt b fi lc kz l la lb">        #Appending values to graph<br/>        time = np.append(time, t)<br/>        z = np.append(z, r[2])<br/>        y = np.append(y, r[1])<br/>        x = np.append(x, r[0])</span><span id="0a35" class="kx je hi kt b fi lc kz l la lb">        #RK4 Step method<br/>        k1 = h*derivative(r,t)<br/>        k2 = h*derivative(r+k1/2,t+h/2)<br/>        k3 = h*derivative(r+k2/2,t+h/2)<br/>        k4 = h*derivative(r+k3,t+h)<br/>        r += (k1+2*k2+2*k3+k4)/6</span><span id="a6c6" class="kx je hi kt b fi lc kz l la lb">        #Updating time value with step size<br/>        t = t + h</span></pre><p id="7644" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行循环后，我们的数组应该填充了等量的值，所以现在我们可以继续绘制这些值，这样我们就可以看到它们如何使用下面的代码生成图形。</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="79aa" class="kx je hi kt b fi ky kz l la lb">#Multiple graph plotting<br/>fig, (ax1,ax2,ax3) = plt.subplots(1,3, figsize = (15, 5))<br/>ax1.plot(x, y)<br/>ax1.set_title("X &amp; Y")<br/>ax2.plot(x, z)<br/>ax2.set_title("X &amp; Z")<br/>ax3.plot(y, z)<br/>ax3.set_title("Y &amp; Z")<br/>plt.show()</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/262e3434f1cb661be69d3e7082939508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KqHO7Gn0A6-i3b9AmDD_eA.jpeg"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">针对每个变量绘制的洛伦兹系统图</figcaption></figure><p id="ad0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些是一些有趣的图表！通过对希腊变量使用不同的值，我们可以看到系统行为的变化，有些值会产生复杂的图形。</p><h1 id="1813" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">罗斯勒</strong></h1><p id="34e7" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">与Lorenz系统非常相似，我们将微分方程应用于我们的导数函数，并通过RK4循环运行它，以使用以下方程产生Rossler系统的可视化表示。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lj"><img src="../Images/5e0ef41da2d14270b114f0bc06b03b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*ZE5Uf0enFjpY9RtieXaHAg.jpeg"/></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">罗斯勒方程</figcaption></figure><p id="fd79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这些方程，我们只要把我们的导函数方程中的返回线改成这些，我们就都设置好了。在下面，你会找到完整的代码，以及产生的图表。</p><pre class="kh ki kj kk fd ks kt ku kv aw kw bi"><span id="f5a1" class="kx je hi kt b fi ky kz l la lb">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="c727" class="kx je hi kt b fi lc kz l la lb">a = 0.2<br/>b = 0.2<br/>c = 5.7<br/>t = 0<br/>tf = 100<br/>h = 0.01</span><span id="7923" class="kx je hi kt b fi lc kz l la lb">def derivative(r,t):<br/>    x = r[0]<br/>    y = r[1]<br/>    z = r[2]<br/>    return np.array([- y - z, x + a * y, b + z * (x - c)])</span><span id="cb4c" class="kx je hi kt b fi lc kz l la lb">time = np.array([])<br/>x = np.array([])<br/>y = np.array([])<br/>z = np.array([])</span><span id="a747" class="kx je hi kt b fi lc kz l la lb">r = np.array([0.1, 0.1, 0.1])</span><span id="658e" class="kx je hi kt b fi lc kz l la lb">while (t &lt;= tf ):<br/>    <br/>        time = np.append(time, t)<br/>        z = np.append(z, r[2])<br/>        y = np.append(y, r[1])<br/>        x = np.append(x, r[0])<br/>        <br/>        k1 = h*derivative(r,t)<br/>        k2 = h*derivative(r+k1/2,t+h/2)<br/>        k3 = h*derivative(r+k2/2,t+h/2)<br/>        k4 = h*derivative(r+k3,t+h)<br/>        r += (k1+2*k2+2*k3+k4)/6<br/>        <br/>        t = t + h</span><span id="09ea" class="kx je hi kt b fi lc kz l la lb">fig, (ax1,ax2,ax3) = plt.subplots(1,3, figsize = (15, 5))<br/>ax1.plot(x, y)<br/>ax1.set_title("X &amp; Y")<br/>ax2.plot(x, z)<br/>ax2.set_title("X &amp; Z")<br/>ax3.plot(y, z)<br/>ax3.set_title("Y &amp; Z")<br/>plt.show()</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lk"><img src="../Images/7b93cb67d1994de2566f3740955fd3c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZdXP-Rmp9H5GRKlUxmV-Q.jpeg"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">罗斯勒系统图，针对每个变量绘制</figcaption></figure><p id="4624" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与洛伦兹系统非常相似，罗斯勒系统也表现出复杂的行为，这取决于方程所用的变量。</p><h1 id="06a7" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">概述</strong></h1><p id="4591" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们可以看到龙格-库塔方法对于使用常微分方程的编程方程是多么有用。虽然这些更多的是为了探索物理概念，但这种方法也可以用于帮助其他更实际的模拟。此外，我强烈建议查看这两个系统的维基百科页面，因为它们实际上向你展示了如何在三维空间中用Python编写这些方程！</p></div></div>    
</body>
</html>