<html>
<head>
<title>SQL Server unit testing with tSQLt, Docker, and GitHub Actions!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用tSQLt、Docker和GitHub操作进行SQL Server单元测试！</h1>
<blockquote>原文：<a href="https://medium.com/codex/sql-server-unit-testing-with-tsqlt-docker-and-github-actions-9fa48a4072a6?source=collection_archive---------3-----------------------#2022-10-21">https://medium.com/codex/sql-server-unit-testing-with-tsqlt-docker-and-github-actions-9fa48a4072a6?source=collection_archive---------3-----------------------#2022-10-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5f55" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">真正改变游戏规则的是自动化！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/f27fb8fd5421349aa9ce543112d1a521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OALznui7q9FCJzec"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">卡斯帕·卡米尔·鲁宾在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e088" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本系列的第三篇<a class="ae jn" href="https://segovoni.medium.com/unit-testing-how-to-write-your-first-unit-test-for-t-sql-code-3bc1533acbbc" rel="noopener">上一篇文章</a>中，我们描述了如何为触发器编写和运行单元测试！本文描述了如何使用tSQLt、Docker和GitHub操作对一个或多个SQL Server对象进行自动化测试！</p><h2 id="fb23" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">这里使用的技术和框架</h2><p id="469f" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">tSQLt是一个针对SQL Server的单元测试框架。它提供了创建和执行测试用例的API，并将它们与持续集成服务器集成在一起。在我以前的文章<a class="ae jn" href="https://segovoni.medium.com/unit-testing-the-tsqlt-framework-and-the-execution-of-a-test-e4d135c3e343" rel="noopener">tSQLt框架和测试的执行</a>中已经描述了tSQLt框架的强大功能。</p><p id="55de" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Docker 是最流行的系统之一，用于在称为容器的可隔离、最小且易于部署的环境中运行应用程序。由于SQL Server 2017，SQL Server引擎可以在Docker容器中运行，在Docker容器中运行SQL Server的典型用法涉及软件测试的自动化。</p><p id="ddb3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub Actions </a>是一个持续集成和持续交付(CI/CD)平台，允许您自动化您的构建、测试和部署管道。您可以创建工作流来构建和测试对存储库的每个拉请求，或者将合并的拉请求部署到生产环境中。GitHub提供Linux、Windows和macOS虚拟机来运行您的工作流，或者您可以在自己的数据中心或云基础架构(如Microsoft Azure)中托管自己的自托管运行程序。</p><h2 id="8864" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">病历</h2><p id="795d" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated"><a class="ae jn" href="https://github.com/Microsoft/sql-server-samples/releases/tag/adventureworks" rel="noopener ugc nofollow" target="_blank"> AdventureWorks2017数据库</a>包含生产。存储由假冒公司Adventure Works LTD .管理和销售的产品的产品表。</p><p id="2d8d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们编写的触发器是为了防止将价值小于10的新产品作为“安全库存”插入。该公司希望每种产品的库存不低于10件。安全库存水平对于自动程序来说是一个非常重要的值:它允许重新订购物料。新采购订单和生产订单的创建基于安全库存水平。为了使我们的触发器简单，对于插入命令，它将只响应OnInsert事件。</p><p id="363b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用于创建触发器和相关单元测试的TSQL脚本可以在GitHub<a class="ae jn" href="https://github.com/segovoni/sql-server-demos-ci-cd" rel="noopener ugc nofollow" target="_blank">SQL-server-demos-ci-CD</a>存储库中找到，存储过程production . USP _ Raiserror _ SafetyStockLevel集中处理错误。</p><h2 id="ad41" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">使用tSQLt、Docker和GitHub操作执行无人值守单元测试</h2><p id="7974" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">触发器和相关单元测试的实现已经完成，下一个挑战是<strong class="jq hj">在库的主分支的每次提交时自动执行测试</strong>。为了实现这个目标，有必要确定一个能够支持Docker容器使用的持续集成/持续交付平台。</p><p id="e966" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">GitHub Actions将成为我们的CI/CD平台，它支持Docker容器的使用，并紧密集成到GitHub中，GitHub是管理我们源代码的源代码控件。使用GitHub Actions不是唯一的可能性，但对于这个项目来说，它肯定是最合适的。</p><p id="eba9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们继续创建一个工作流:一个自动化的、可配置的流程，它将执行一个或多个作业。工作流是用存储在保存源代码的同一个存储库中的YAML文件定义的。当存储库中发生事件(例如提交)时，将触发工作流。</p><p id="dd54" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">工作流也可以手动激活或根据定义的计划激活。实现测试自动化工作流的YAML文件在<a class="ae jn" href="https://github.com/segovoni/sql-server-demos-ci-cd/blob/master/.github/workflows/automated-tests.yml" rel="noopener ugc nofollow" target="_blank">这里</a>可用，基本步骤是:</p><ul class=""><li id="a41e" class="lk ll hi jq b jr js ju jv jx lm kb ln kf lo kj lp lq lr ls bi translated">激活事件的定义</li><li id="cad5" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">从Linux上的SQL Server映像创建Docker容器</li><li id="ac9d" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">AdventureWorks2017数据库恢复</li><li id="d34b" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">tSQLt框架的安装</li><li id="00c6" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">创建要测试的数据库对象(SUT)</li><li id="dacd" class="lk ll hi jq b jr lt ju lu jx lv kb lw kf lx kj lp lq lr ls bi translated">创建和执行单元测试</li></ul><h2 id="4b62" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">激活事件的定义</h2><p id="585b" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">激活事件的定义通常在YAML脚本的开头完成，代码片段类似于下面所示。当“主”分支上发生推或拉请求事件时，工作流被激活。“workflow_dispatch”规范允许您从“操作”选项卡中手动运行工作流。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="68d5" class="kk kl hi lz b fi md me l mf mg"># Controls when the workflow will run<br/>on:<br/>  # Triggers the workflow on push or pull request events but only for the "master" branch<br/>  push:<br/>    branches: [ "master" ]<br/>  pull_request:<br/>    branches: [ "master" ]<br/>    <br/>  # Allows you to run this workflow manually from the Actions tab<br/>  workflow_dispatch:</span></pre><h2 id="9078" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">从Linux上的SQL Server映像创建Docker容器</h2><p id="a2a1" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">从Linux上的sqlserver映像创建Docker容器可以通过请求SQL Server服务以及您想要使用的Docker映像的路径来完成。微软为Linux上的SQL Server提供的官方图像可在<a class="ae jn" href="https://hub.docker.com/_/microsoft-mssql-server" rel="noopener ugc nofollow" target="_blank">这里</a>获得。我们不会使用从微软注册表下载的官方图片。我们将使用安装了AdventureWorks数据库的SQL Server的Docker映像，此映像由<a class="ae jn" href="https://hub.docker.com/u/chriseaton" rel="noopener ugc nofollow" target="_blank"> chriseaton </a>发布，您可以在<a class="ae jn" href="https://hub.docker.com/r/chriseaton/adventureworks" rel="noopener ugc nofollow" target="_blank">此链接</a>找到它。下面的YAML代码片段设置SQL Server服务。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="6b42" class="kk kl hi lz b fi md me l mf mg">jobs:<br/>  windows-auth-tsqlt:<br/>    name: Installting tSQLt with SQL Auth<br/>    # The type of runner that the job will run on<br/>    runs-on: ubuntu-latest<br/>    <br/>    services:<br/>      sqlserver:<br/>        image: chriseaton/adventureworks:latest<br/>        ports:<br/>          - 1433:1433<br/>        env:<br/>          ACCEPT_EULA: Y<br/>          SA_PASSWORD: 3uuiCaKxfbForrK</span></pre><p id="f219" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了引用新创建的Docker容器，将它的标识符保存在环境变量中是很重要的。以下YAML代码片段使用创建的容器的ID设置ENV_CONTAINER_ID变量。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="c900" class="kk kl hi lz b fi md me l mf mg">- name: Set environment variable ENV_CONTAINER_ID<br/>  run: echo "ENV_CONTAINER_ID=$(docker ps --all --filter status=running --no-trunc --format "{{.ID}}")" &gt;&gt; $GITHUB_ENV</span></pre><h2 id="4831" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">AdventureWorks2017数据库恢复</h2><p id="8232" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">可以使用下面的<a class="ae jn" href="https://docs.docker.com/engine/reference/commandline/exec/" rel="noopener ugc nofollow" target="_blank"> docker exec </a>命令执行AdventureWorks2017数据库恢复。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="8b6d" class="kk kl hi lz b fi md me l mf mg">- name: Restore AdventureWorks2017<br/>  run: docker exec -i $ENV_CONTAINER_ID /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P "3uuiCaKxfbForrK" -Q "RESTORE DATABASE [AdventureWorks2017] FROM DISK = '/adventureworks.bak' WITH MOVE 'AdventureWorks2017' TO '/var/opt/mssql/data/AdventureWorks.mdf', MOVE 'AdventureWorks2017_log' TO '/var/opt/mssql/data/AdventureWorks_log.ldf'"</span></pre><h2 id="aa3d" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">tSQLt框架的安装</h2><p id="1226" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">AdventureWorks2017数据库中最新版本的tSQLt框架的安装是使用由<a class="ae jn" href="https://github.com/lowlydba" rel="noopener ugc nofollow" target="_blank"> lowlydba </a>发布的GitHub Actions tSQLt安装程序完成的，您可以在这里和<a class="ae jn" href="https://github.com/marketplace/actions/tsqlt-installer" rel="noopener ugc nofollow" target="_blank">GitHub Actions market place</a>上找到更多详细信息<a class="ae jn" href="https://github.com/lowlydba/tsqlt-installer" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="8d72" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用于在AdventureWorks2017数据库中安装tSQLt框架的YAML代码片段如下。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="db26" class="kk kl hi lz b fi md me l mf mg">steps:<br/>  - uses: actions/checkout@v2</span><span id="0f7a" class="kk kl hi lz b fi mh me l mf mg">  - name: Install tSQLt with SQL auth on AdventureWorks2017<br/>    uses: lowlydba/tsqlt-installer@v1<br/>    with:<br/>      sql-instance: localhost<br/>      database: AdventureWorks2017<br/>      version: latest<br/>      user: sa<br/>      password: 3uuiCaKxfbForrK</span></pre><h2 id="385a" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">创建要测试的数据库对象(SUT)</h2><p id="31d5" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">测试环境已经准备好了，我们在Docker容器中有一个Linux上的SQL Server实例；AdventureWorks2017数据库已还原，可以使用了。让我们继续创建触发器和存储过程(管理错误)，它们代表我们测试中的<a class="ae jn" href="https://en.wikipedia.org/wiki/System_under_test" rel="noopener ugc nofollow" target="_blank">系统(SUT) </a>。</p><p id="0f92" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">TR_Product_SafetyStockLevel触发器创建脚本和usp_Raiserror_SafetyStockLevel存储过程创建脚本保存在<a class="ae jn" href="https://github.com/segovoni/sql-server-demos-ci-cd" rel="noopener ugc nofollow" target="_blank"> sql-server-demos-ci-cd </a>存储库的<a class="ae jn" href="https://github.com/segovoni/sql-server-demos-ci-cd/tree/master/source" rel="noopener ugc nofollow" target="_blank">源目录</a>中。</p><p id="4366" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">触发器和存储过程是在附加到SQL Server实例的AdventureWorks2017数据库中创建的，执行此操作的YAML代码片段如下。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="6c36" class="kk kl hi lz b fi md me l mf mg">- name: Create sp usp_Raiserror_SafetyStockLevel<br/>  run: docker exec -i $ENV_CONTAINER_ID /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P "3uuiCaKxfbForrK" -d AdventureWorks2017 -b &lt; ./source/usp-raiserror-safetystocklevel.sql</span><span id="da1d" class="kk kl hi lz b fi mh me l mf mg">- name: Create TR_Product_SafetyStockLevel<br/>  run: docker exec -i $ENV_CONTAINER_ID /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P "3uuiCaKxfbForrK" -d AdventureWorks2017 -b &lt; ./source/tr_product_safetystocklevel.sql</span></pre><h2 id="61c9" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">测试单元的创建和执行</h2><p id="3760" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">这个工作流的最后一个阶段由单元测试的创建和执行来表示。测试类和单元测试创建脚本包含在<a class="ae jn" href="https://github.com/segovoni/sql-server-demos-ci-cd" rel="noopener ugc nofollow" target="_blank"> sql-server-demos-ci-cd </a>存储库的<a class="ae jn" href="https://github.com/segovoni/sql-server-demos-ci-cd/tree/master/unit-test" rel="noopener ugc nofollow" target="_blank">单元测试目录</a>中。</p><p id="7dd1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们继续创建专用于TR_Product_SafetyStockLevel触发器的测试类，我们称之为UnitTestTRProductSafetyStockLevel。以下docker exec命令使用sqlcmd，执行包含在<a class="ae jn" href="https://github.com/segovoni/sql-server-demos-ci-cd/blob/master/unit-test/test-class-trproductsafetystocklevel.sql" rel="noopener ugc nofollow" target="_blank">test-class-trproductsafetystocklevel . SQL</a>脚本中的TSQL命令。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="216b" class="kk kl hi lz b fi md me l mf mg">- name: Create test class UnitTestTRProductSafetyStockLevel<br/>  run: docker exec -i $ENV_CONTAINER_ID /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P "3uuiCaKxfbForrK" -d AdventureWorks2017 -b &lt; ./unit-test/test-class-trproductsafetystocklevel.sql</span></pre><p id="3c47" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们继续创建和执行单元测试。每个。“测试用例”系列的sql文件包含用于创建和运行相关单元测试的TSQL命令。每个存储过程只测试一个测试用例。对于TR_Product_SafetyStockLevel触发器，我们提供了四个测试用例。下面的YAML代码片段创建并运行测试单元。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="d289" class="kk kl hi lz b fi md me l mf mg">- name: Create and run test case try to insert one wrong row<br/>  run: docker exec -i $ENV_CONTAINER_ID /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P "3uuiCaKxfbForrK" -d AdventureWorks2017 -b &lt; ./unit-test/test-case-try-to-insert-one-wrong-row.sql</span><span id="b843" class="kk kl hi lz b fi mh me l mf mg">- name: Create and run test case try to insert one right row<br/>  run: docker exec -i $ENV_CONTAINER_ID /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P "3uuiCaKxfbForrK" -d AdventureWorks2017 -b &lt; ./unit-test/test-case-try-to-insert-one-right-row.sql</span><span id="87c4" class="kk kl hi lz b fi mh me l mf mg">- name: Create and run test case try to insert multiple rows<br/>  run: docker exec -i $ENV_CONTAINER_ID /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P "3uuiCaKxfbForrK" -d AdventureWorks2017 -b &lt; ./unit-test/test-case-try-to-insert-multiple-rows.sql</span><span id="9edf" class="kk kl hi lz b fi mh me l mf mg">- name: Create and run test case try to insert multiple rows ordered<br/>  run: docker exec -i $ENV_CONTAINER_ID /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P "3uuiCaKxfbForrK" -d AdventureWorks2017 -b &lt; ./unit-test/test-case-try-to-insert-multiple-rows-ordered.sql</span></pre><p id="9203" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们工作流的YAML脚本已经完成，您可以在这里找到它<a class="ae jn" href="https://github.com/segovoni/sql-server-demos-ci-cd/blob/master/.github/workflows/automated-tests.yml" rel="noopener ugc nofollow" target="_blank">，我们只需通过从</a><a class="ae jn" href="https://github.com/segovoni/sql-server-demos-ci-cd/actions/workflows/automated-tests.yml" rel="noopener ugc nofollow" target="_blank">操作选项卡</a>手动运行它来检查它。</p><p id="1e44" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果执行的所有操作都成功，则工作流将成功完成。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/ac00940e476ec835909be293afe21c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHrNi_ub-L_oMSH868sHQw.jpeg"/></div></div></figure><h2 id="8015" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">摘要</h2><p id="6d8b" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">为SQL Server解决方案开发的单元测试不仅仅是为了在发布之前验证需求是否已经得到满足；真正的游戏规则改变者表现为在新代码开发和错误修复过程中重复检查的可能性。测试的可重复性提供了自动化测试的能力，这是在持续集成平台中集成自动化测试的必要条件。在本文中，我们描述了如何使用tSQLt、Docker和GitHub操作来自动测试SQL Server对象！</p><p id="f396" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>