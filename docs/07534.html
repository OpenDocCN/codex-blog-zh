<html>
<head>
<title>Data structure and Algorithm: Big O</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构与算法:大O</h1>
<blockquote>原文：<a href="https://medium.com/codex/data-structure-and-algorithm-big-o-fd8f906c602?source=collection_archive---------25-----------------------#2022-06-17">https://medium.com/codex/data-structure-and-algorithm-big-o-fd8f906c602?source=collection_archive---------25-----------------------#2022-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9aa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为开发人员，解决问题是我们旅程中的一个重要方面，当涉及到解决问题时，我们可以给自己一个很大提升的最好方法之一是通过学习<strong class="ih hj">数据结构和算法</strong>。</p><h2 id="a52a" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">什么是数据结构？</strong></h2><p id="94eb" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">数据结构只是存储数据的一种编程方式，因此可以有效地使用它。</p><h2 id="f825" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">什么是算法？</strong></h2><p id="e0c5" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">算法是一个循序渐进的过程，总体上是为了达到预期的目标。算法独立于编程语言，它们可以为任何语言编写。</p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h1 id="3eb1" class="kk je hi bd jf kl km kn jj ko kp kq jn kr ks kt jq ku kv kw jt kx ky kz jw la bi translated"><strong class="ak">大O </strong></h1><p id="9037" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">在可以将代码分类为好代码之前，可以赋予代码两个主要特征。这些特征是:</p><ol class=""><li id="63f5" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">可读性。</li><li id="1995" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">可扩展性。</li></ol><p id="63eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">大O渐近分析</strong>帮助我们确定代码的可伸缩性。说到大O，我们可以问自己一些问题，比如:</p><ol class=""><li id="003a" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">运行一个问题或任务需要多长时间？。这可以认为是一个问题的(<strong class="ih hj">时间复杂度</strong>)。</li><li id="0d0a" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">问题运行时消耗的内存量是多少？这被认为是问题的(<strong class="ih hj">空间复杂度</strong>)。</li></ol><p id="922f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在考虑大O时，有一些关键的符号需要注意:</p><figure class="lq lr ls lt fd lu er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lp"><img src="../Images/bc004acb64ead0990b099d715ced2691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EJ8GptIPuMbgzvoAbn4E3g.jpeg"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">来自<a class="ae mf" href="https://www.bigocheatsheet.com" rel="noopener ugc nofollow" target="_blank">大O cheatsheet </a>的大O图表</figcaption></figure><ol class=""><li id="1972" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated"><strong class="ih hj"> O(1) —常数时间:</strong></li></ol><p id="6cf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就时间和空间而言，这具有最小的复杂性，这意味着您的代码占用更少的内存空间，并且在尽可能短的时间内执行。一个例子可以是:</p><pre class="lq lr ls lt fd mg mh mi mj aw mk bi"><span id="24d1" class="jd je hi mh b fi ml mm l mn mo"><br/> function LogElement(array) {   <br/>      console.log(array[0]);<br/>}</span></pre><p id="b47e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的javascript函数可以被认为是O(1 ),因为它总是在运行时打印索引0的元素，这使得它在尽可能短的时间内执行。</p><p id="ec13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj"> O(n) —线性时间:</strong></p><p id="2a15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">线性时间可以描述为随着元素的增加而增加的操作。就时间和空间复杂性而言，线性时间是第二有效的大O符号。一个例子是:</p><pre class="lq lr ls lt fd mg mh mi mj aw mk bi"><span id="bc63" class="jd je hi mh b fi ml mm l mn mo">function LoopThroughBoxesArrayAndFindBlue(boxes) {<br/>   for (var i = 0; i &lt; boxes.length; i++) {<br/>      if(boxes[i] === 'Blue') {<br/>         console.log("Found Blue")<br/>      }<br/>   }<br/>}</span></pre><p id="ed8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面可以认为是O(n)因为这个循环运行了n次，我们无法确定在找到“BLUE”之前循环会运行多少次。</p><p id="3701" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj"> O(n ) —二次:</strong></p><p id="3672" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们有嵌套循环时，就会发生这种情况。当我们遇到这种情况时，我们必须想出有效的方法来将我们的解转化为O(n)。白板访谈中的O(n)解决方案可以被认为是我们解决问题的第一个也是最低效的解决方案。</p><pre class="lq lr ls lt fd mg mh mi mj aw mk bi"><span id="126f" class="jd je hi mh b fi ml mm l mn mo">function printPairs(boxes) {<br/>  <br/>  for (var i = 0; i &lt; boxes.length; i++){<br/>    for (var j = 0; j &lt; boxes.length; j++){<br/>      console.log (boxes[i] , boxes[j])<br/>    }<br/>  }<br/>}</span><span id="6b71" class="jd je hi mh b fi mp mm l mn mo">const x = [1,2,3,4,5]</span><span id="1c39" class="jd je hi mh b fi mp mm l mn mo">printPairs(x)</span></pre><p id="55e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大O的一个骗术就是总知道一个循环总是被当做O(n)，有嵌套循环就变成O(n * n)就变成O(n)。</p><p id="9c27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">其他大O记法有:<br/> </strong> 1。O(n ) —立方<br/> 2。O(log n) —对数<br/> 3。O(n！)—阶乘时间(这也被称为哦不哈哈)</p><h1 id="9991" class="kk je hi bd jf kl mq kn jj ko mr kq jn kr ms kt jq ku mt kw jt kx mu kz jw la bi translated"><strong class="ak">大魔神的规则</strong></h1><p id="2647" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">1.<strong class="ih hj">最坏的情况</strong> —每当我们遇到问题时，我们必须总是考虑和讨论程序执行所需的最坏的可能时间，然后我们可以进一步思考如何将解决方案优化成可能的最佳执行时间。</p><p id="7ec5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">去掉常数</strong> —我们在寻找一个函数的大O时，找到了消除所有常数的方法，把大O符号化简为O(n)。<br/>在我们得到O(1 + n + 100)的情况下，我们可以说n具有更大的值，因为n可以是任何值，当这种情况发生时，我们丢弃常数，得到O(n)。</p><p id="22f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj">不同的输入术语</strong> —当被问及不同术语的大O时，大多数人往往会在面试中失败，在这种情况下，我们需要注意输入术语…下面的示例代码解释了这一点</p><pre class="lq lr ls lt fd mg mh mi mj aw mk bi"><span id="24d7" class="jd je hi mh b fi ml mm l mn mo">function LoopThroughArray(boxes) {<br/>  boxes.forEach(boxes1 =&gt; {<br/>    console.log(boxes1)<br/>  })</span><span id="067a" class="jd je hi mh b fi mp mm l mn mo">  boxes.forEach(boxes1 =&gt; {<br/>    console.log(boxes1)<br/>  })<br/>}</span></pre><p id="f9b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述函数的大O将是O(n + n ),即O(2n ),当我们去掉常数时，它将变成O(n)。当我们看不同的术语时。</p><pre class="lq lr ls lt fd mg mh mi mj aw mk bi"><span id="241b" class="jd je hi mh b fi ml mm l mn mo">function LoopThroughArray(box, boxes) {<br/>  box.forEach(boxes1 =&gt; {<br/>    console.log(boxes1)<br/>  })</span><span id="a753" class="jd je hi mh b fi mp mm l mn mo">  boxes.forEach(boxes1 =&gt; {<br/>    console.log(boxes1)<br/>  })<br/>}</span></pre><p id="5f3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意命名。大多数人将其称为O(n ),这是非常错误的，这种情况下的大O变成O(a + b ),因为每个输入的大小可以不同，盒子的大小可以是100，盒子的大小可以是1000。因为我们有两个for循环，并不意味着它们循环相同的项。</p><p id="6144" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.<strong class="ih hj">舍弃非主导术语</strong> —当谈到大O时，我们倾向于舍弃最不主导的术语。例如，我们得到一个大O符号O(x +3x + 100 + x/2 ),在这种情况下，x比3x、100和x/2更占优势，因为当谈到大O时，我们考虑可伸缩性。</p><p id="8e95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有关Big O的更多信息，请查看这篇<a class="ae mf" href="https://www.freecodecamp.org/news/big-o-notation-why-it-matters-and-why-it-doesnt-1674cfa8a23c/" rel="noopener ugc nofollow" target="_blank">文章</a>和这个伟大的<a class="ae mf" href="https://www.udemy.com/course/master-the-coding-interview-data-structures-algorithms/" rel="noopener ugc nofollow" target="_blank">课程</a>。</p><p id="d191" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你学习愉快！！！</p></div></div>    
</body>
</html>