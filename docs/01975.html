<html>
<head>
<title>A Theoretical Perspective on XGBoost</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">XGBoost的理论透视</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-theoretical-perspective-on-xgboost-d02735fd609b?source=collection_archive---------7-----------------------#2021-06-19">https://medium.com/codex/a-theoretical-perspective-on-xgboost-d02735fd609b?source=collection_archive---------7-----------------------#2021-06-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/11f26e69226ce872d077531079e39a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*UKIHA2AHtB9WPG-KrfwSZg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://xkcd.com/1838/" rel="noopener ugc nofollow" target="_blank">https://xkcd.com/1838/</a></figcaption></figure><p id="1f2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">梯度增强决策树(GBDT)是一种基于集成的方法，其中在损失函数的残差上按顺序训练树。GBDT的主要开销是构建决策树，最耗时的部分是为每个节点寻找最佳分裂点。2016年推出的XGBoost是解决这些挑战的有效实现，下面是它解决这些问题的方式。</p><p id="1679" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">损失函数是任何监督机器学习模型的核心，XGBoost也不例外。从添加新树到拆分树中的单个节点，损失函数是驱动这一切的因素。由于每个新树都试图最小化剩余误差，所以算法在它们之间是相似的。</p><h2 id="1d8b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">从损失函数到决策树</h2><p id="a9f0" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated"><strong class="ix hj">损失函数和最优叶值:</strong>考虑一个一般的树结构，其中我们有<strong class="ix hj"> T </strong>个叶节点，每个节点作为权重/值<strong class="ix hj"> <em class="kt"> w </em> </strong>。通过对损失函数进行二阶近似，我们可以将其改写为以下形式。最后两项是正则项，分别惩罚叶子的数目和叶子的值。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es ku"><img src="../Images/49c3c1ee1c399087a8660d19571c9b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*FN83drxP3tNBw1fOPb377Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">正则化损失函数</figcaption></figure><p id="a4f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kt"> f(x)，g，</em> </strong>和<strong class="ix hj"> <em class="kt"> h </em> </strong>是数据集中每个样本<strong class="ix hj"> <em class="kt"> i </em> </strong>的树值、梯度和黑森。这些样本中的每一个都将在<strong class="ix hj"> T </strong>叶节点中结束。将为该样本预测叶重。利用这一点，我们可以将损失函数改写成以下形式。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/1cbaff4b916be474520d3b96b0df5bc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*hiF8-GQERCwz88po3XW44g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">损失函数作为叶的总和</figcaption></figure><p id="a48b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种形式中，损失函数变成二次函数的和，并且当和<em class="kt">即</em>叶的每个元素达到其最小值时，损失函数可以达到最小值。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es la"><img src="../Images/8925257695c10336c1b5a2ecd5eeac2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*2jIY8ADgkpKYQ3jMYfBe2Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">树叶重量和树结构得分</figcaption></figure><p id="9ca6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">损失函数值(<strong class="ix hj"> L* </strong>)的最小值可以作为<em class="kt">分数</em>来判断树的结构，并根据这个度量来决定修剪树或选择分裂的阈值。</p><p id="d4db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">分裂查找算法:</strong>每个树从根节点开始，然后通过选择特征和分裂点将每个节点分裂成两个节点。XGBoost使用一个<em class="kt">预排序算法</em>，该算法通过计算该特征的<em class="kt">加权百分位数</em>对特征进行排序并列出候选点，其中Hessians用作权重。每个样本的误差由该样本的hessian加权，并且可以通过以如下形式重写损失函数来看到:</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/c10186b77e700fe0b2fc0072598c397b.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*_YZsRsDzpZBkFRZAX6JPlQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作为加权和的损失函数</figcaption></figure><p id="5290" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，每个节点可以在特征集及其候选分裂点上运行贪婪搜索，以选择在树得分中具有最大增益的一个。</p><h2 id="a893" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">驱动速度的因素</h2><p id="aee6" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">算法选择和系统设计都在加速中扮演着重要角色。一个因素是使用上面提到的预排序算法。其他的如下所述。</p><p id="bb0a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">处理稀疏数据:</strong>由于一次性编码或缺少值，最终得到稀疏数据集的情况很常见。分裂查找算法仅考虑非缺失值，这降低了计算复杂度。对于缺失值，它可以向左或向右。对这两种情况进行评估，并选择具有最佳树分数的一种。</p><p id="f5a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">用于并行学习的列块:</strong>为了找到特征上的最佳分割，需要排序，这是最耗时的方面。每个特征以<a class="ae iu" href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS)" rel="noopener ugc nofollow" target="_blank">压缩列(CSC) </a>格式存储在内存单元或<em class="kt">块中。</em>由于split-finding算法适用于排序后的数据，因此可以将行分成多个块。每个块可以在不同的机器上(用于分布式学习),或者当数据太大而不适合内存时存储在磁盘上。使用这种排序结构，分位数查找步骤变成了对排序列的线性扫描。这对于频繁产生候选项的每个节点上的本地提议是有价值的。</p><p id="a513" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">高速缓存感知访问:</strong>块结构有助于优化分裂查找的计算复杂度，但是引入了另一个问题。每个已排序的要素现在的顺序与原始数据索引不同。以这种不连续的顺序访问它们的梯度统计数据，这在时间上引入了开销。为了在近似算法中解决这个问题，选择每个块中⁶样本的最佳大小。较大的块大小将导致缓存未命中，因为梯度统计数据不适合CPU缓存。</p><h2 id="e243" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">与LightGBM的比较</h2><p id="e194" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">LightGBM是由微软引入的，以缓解现有算法(如XGBoost)对更大特征维度的不满意结果。XGBoost需要扫描所有数据实例来检查所有特性的信息增益，这可能是一个瓶颈。引入了两种新技术来缓解这种情况:</p><p id="d5d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">基于梯度的单侧采样(GOSS): </strong>这个概念用于对训练任何新决策树的数据实例的数量进行下采样。任何样品的梯度都是其重要性的有用指标。低梯度意味着该样本的训练误差很小，并且它已经被很好地训练。在算法中，这是通过仅使用具有最高梯度的顶部样本和低梯度样本的随机子集来使用的。仍然需要包含低梯度样本，否则会改变数据分布。尽管来自低梯度样本的信息增益减少了一个因子以保持其低重要性。</p><p id="6161" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">排他性特征捆绑(EFB): </strong>在高维数据中，很多特征可以是稀疏的、互斥的(例如:一键编码)。这种排他性可用于将它们捆绑在一起，并通过减少特征尺寸来实现加速，而不会损害性能。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><ol class=""><li id="2bf9" class="lj lk hi ix b iy iz jc jd jg ll jk lm jo ln js lo lp lq lr bi translated">陈，t .，&amp; Guestrin，C. (2016年8月)。Xgboost:一个可扩展的树提升系统。在<em class="kt">第22届acm sigkdd知识发现和数据挖掘国际会议论文集</em>(第785–794页)。</li><li id="3577" class="lj lk hi ix b iy ls jc lt jg lu jk lv jo lw js lo lp lq lr bi translated">柯国光，孟，陈，王，陈，马，刘天元(2017)。Lightgbm:一种高效的梯度推进决策树。<em class="kt">神经信息处理系统的进展</em>，<em class="kt"> 30 </em>，3146–3154。</li></ol><p id="2795" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kt">如果你有问题或者评论里有反馈，请告诉我。</em>T13】</strong></p></div></div>    
</body>
</html>