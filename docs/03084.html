<html>
<head>
<title>Tabular network data model. Part 2. Important features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">表格网络数据模型。第二部分。重要特征</h1>
<blockquote>原文：<a href="https://medium.com/codex/tabular-network-data-model-part-2-important-features-99a07f514b4?source=collection_archive---------24-----------------------#2021-08-17">https://medium.com/codex/tabular-network-data-model-part-2-important-features-99a07f514b4?source=collection_archive---------24-----------------------#2021-08-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="863c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">表格网络数据库——在关系数据库、网络数据库和面向对象编程概念的交叉点上建立数据模型和相关软件的新方法</h2></div><p id="8638" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">【这是<em class="jt">表格网络数据模型</em>系列的第3部分。点击查看所有帖子<a class="ae ju" rel="noopener" href="/@azur06400/tabular-network-data-model-series-f7b8469ed333">的链接。]</a></p><h2 id="4628" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jg kg kh ki jk kj kk kl jo km kn ko kp bi translated">类库而不是数据操作语言</h2><p id="2e0b" class="pw-post-body-paragraph ix iy hi iz b ja kq ij jc jd kr im jf jg ks ji jj jk kt jm jn jo ku jq jr js hb bi translated">表格式网络模型中不使用主键和外键的概念。因此，在超表(HT，参见定义<a class="ae ju" rel="noopener" href="/@azur06400/tabular-network-data-model-part-1-conceptual-definition-49e84104b8aa">这里</a>)中没有具有主键的属性，因为从引用类型属性(RTA，参见定义<a class="ae ju" rel="noopener" href="/@azur06400/tabular-network-data-model-part-1-conceptual-definition-49e84104b8aa">这里</a>)字段直接寻址到行是可用的。</p><p id="aaee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在关系数据库中，一个或几个字段(组合键)可以用作主键，其值唯一地标识表中的每一行。在SQL中没有这样的形式主义是不可能做到这一点的。</p><p id="0621" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当使用对象关系映射(ORM)时，程序员可以显式地为表指定主键，但这在实践中很少见，因为默认情况下主键是存储行的唯一标识符(通常是自然数)的ID字段。因此，关系数据库内存中行的物理顺序可能与id的顺序不一致。</p><p id="1970" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ORM会自动创建这样的ID字段，并在添加新行时向其中写入唯一的值。系统的完整性通过id的值来维护，它们用于搜索记录(从具有外键和多对多键的字段中)。</p><p id="d15c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ORM的概念提供了一个放弃数据库查询语言的机会，通过使用适当的方法而不是查询，用ORM类来代替它。例如，ORM Django包含方法<code class="du kv kw kx ky b">objects.all(…)</code>、<code class="du kv kw kx ky b">objects.get(…)</code>、<code class="du kv kw kx ky b">and objects.filter(…)</code>。</p><p id="31f9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为表格式网络数据库(TNDB)开发一种特殊的数据操作语言似乎是有问题的，因为语法和语义的复杂性使得很难实现这样的引擎并在编程中使用它。</p><p id="5ff0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个解决方案是采用ORM的思想:要使用TNDB，必须创建一个类库，它在功能上类似于ORM类。换句话说，程序员收到一个通用面向对象语言的包:一组用于创建数据库和操作数据的类。</p><p id="7f05" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我开发的软件(类的包)比ORM系统有优势:所有操作都是直接使用数据库文件执行的，不需要中间翻译成SQL，也不需要使用事务引擎来解释SQL查询。</p><h2 id="259f" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jg kg kh ki jk kj kk kl jo km kn ko kp bi translated">为表格网络模型解释关系模型中的规范化概念</h2><p id="d66c" class="pw-post-body-paragraph ix iy hi iz b ja kq ij jc jd kr im jf jg ks ji jj jk kt jm jn jo ku jq jr js hb bi translated">这一小节简要地考察了表格网络模型如何与规范化的概念相联系，这在关系数据库的理论和实践中是非常重要的。规范化关系系统的数据模型(模式)的目标是消除数据重复和获得搜索查询的冲突答案的可能性，并在删除单个事实时删除一般化的事实。</p><p id="0dad" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">规范化关系的基础是函数依赖(FD)的概念，包括关系内部和关系之间。</p><p id="3414" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过消除所有的FD(完全的、部分的和多值的内部关系(当然，除了非关键属性对关键属性的依赖)来应用规范化的思想在理论上是一个“模糊”的领域。</p><p id="305c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果尽可能严格地考虑关系模型，所有的主键和外键只代表“自然的”数据库域，不应该包含用于行标识的代理键。在这种情况下，如果两个键的属性都与一个“自然”域配对，则只能使用对来连接两个表(第一个表的外键的属性与第二个表的主键的属性)。然而，在实践中，大多数关系数据库包含要在主键中使用的代理键，开发人员通常采用这种方法来避免和/或简化规范化。</p><p id="95b2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有几种范式是可以区分的(其中前六种最为人所知)，每一种都是前一种的细化。开发人员在理解和满足需求方面越“先进”，数据库设计就越好，即“越接近理想状态”</p><p id="1c72" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上，在最好的情况下，大多数程序员只限于前三种。因此，在实践中几乎没有关系数据库是完全规范化的，这会导致操作和维护过程中的问题。</p><p id="f168" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过比较关系数据库中关系的范式和HT中表的属性，可以得出以下结论:</p><ul class=""><li id="ff43" class="kz la hi iz b ja jb jd je jg lb jk lc jo ld js le lf lg lh bi translated">作为域和属性概念的“合并”的结果，第一范式(不包括对数据原子性的要求)在表格网络模型中被“自动”支持。</li><li id="cb96" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">第二范式的要求不适用于表格网络模型，因为没有定义主键。作为替代，可以使用表内每个RTA字段的值对其所有数据类型属性(DTA，参见定义<a class="ae ju" rel="noopener" href="/@azur06400/tabular-network-data-model-part-1-conceptual-definition-49e84104b8aa">此处</a>)字段的值的组合的完全函数依赖性的要求。</li><li id="f0af" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">如果考虑表中的任何DTA，而不是关系中的非关键属性，则可以修改并接受第三范式的要求。</li></ul><p id="935f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">HT的“网络”组件使得“清楚地”观察表之间的所有FD并在数据模型中正确地解释它们成为可能。</p><p id="11c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">建模实践中的主要问题总是属性之间的多值FD。第四和第五正常关系形式已被提出来消除这些问题中的大部分。如果RTA正确地反映了模拟自然系统中关系的语义和自然本质，表格网络模型就不会遇到这样的困难。</p><h2 id="6694" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jg kg kh ki jk kj kk kl jo km kn ko kp bi translated">搜索波</h2><p id="8e18" class="pw-post-body-paragraph ix iy hi iz b ja kq ij jc jd kr im jf jg ks ji jj jk kt jm jn jo ku jq jr js hb bi translated">对于TNDBs，搜索查询被图论中的一个概念所取代，即搜索波。搜索波的传播(计算、形成)结果是以地址对“表号、行号”作为节点，以RTA作为边的有向图。TNDB的搜索波形图是一个网络，在大多数情况下用树来表示。</p><p id="3780" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">搜索波可以是“正向”和“反向”</p><p id="970a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当搜索前沿从初始行穿过RTA场时，直接波递归地形成。因此，一个表中直达波的最大数量等于其中RTA字段的数量。对于熟悉图论的读者来说，应该清楚这是如何发生的。</p><p id="ce6e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过包含链接到初始行(递归)的行，从“自下而上”生成反向(向后)波。</p><p id="ca44" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与关系数据库不同，如果不考虑从/向外部存储器物理加载和卸载数据的成本，TNDBs中的搜索性能不依赖于存储的数据量(表中的行数)。计算搜索波所需的时间只取决于最终图的大小，而最终图是由显式链接构建的。</p><p id="f472" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在TNDB中，可以在两个“坐标”中控制波浪的计算:</p><ol class=""><li id="cf81" class="kz la hi iz b ja jb jd je jg lb jk lc jo ld js ln lf lg lh bi translated">通过限制搜索深度(链接数量)</li><li id="0757" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js ln lf lg lh bi translated">仅考虑(包括在wave中)一些区域贸易协定。</li></ol><p id="534a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑使用前一篇文章 — <em class="jt">目录</em>示例数据库中<a class="ae ju" rel="noopener" href="/@azur06400/tabular-network-data-model-part-1-conceptual-definition-49e84104b8aa">图2所示的TNDB示例计算直射波和逆射波。请注意，表2中行号为1的文章“数据库”(<em class="jt">文章</em>)有两个媒体文件——在表3的“1”行和“k”行(<em class="jt">媒体文件</em>)——表2中行号为“j”的文章(“T8”文章)有一个媒体文件——在表3的“n”行(<em class="jt">媒体文件</em>)。</a></p><p id="1381" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来自表1中第1行的无限制的直达波(<em class="jt">文章作者</em>)生成了图1所示的图。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/12e106986db5fa056297d2b2724816ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zWtkMD1-jfeNxWPf41vL5A.jpeg"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">图1:从表1的第1行直接搜索“Catalog”示例数据库(图2在<a class="ae ju" rel="noopener" href="/@azur06400/tabular-network-data-model-part-1-conceptual-definition-49e84104b8aa">前一篇文章</a>)。在这个网络中，节点是表格的行(“表格编号，行编号”的对)，边(箭头)是由RTA的值生成的链接(它们的符号名称显示在箭头上)</figcaption></figure><figure class="lp lq lr ls fd lt er es paragraph-image"><div class="er es me"><img src="../Images/7298233eb35d75bae9673fa0578850e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*iV5XFPnxcRwKCQtNo22Qpw.jpeg"/></div><figcaption class="ma mb et er es mc md bd b be z dx translated">图HTed web编辑器的屏幕截图，显示了表格网络数据库的直接波形树。</figcaption></figure><p id="2d00" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">图3显示了一个与上一篇文章中图2的数据模型略有不同的例子。区别在于没有“主要作者”的概念，因此没有“共同作者”的属性(假设共同作者之间“平等”)；所以RTA <em class="jt">合著</em>不存在，RTA <em class="jt">文章</em>的链接属于“多对多”的范畴。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/9866053b540097c915ee77fb8d06e525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2CjtIjCBlu08tr9TjvDSDg.jpeg"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">图3:目录示例数据库的第二个版本</figcaption></figure><p id="49a1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">表3 ( <em class="jt">媒体文件</em>)中第“1”行(“Django ORM视频课程”)的逆波示例如下:</p><ul class=""><li id="f174" class="kz la hi iz b ja jb jd je jg lb jk lc jo ld js le lf lg lh bi translated">对于<em class="jt">目录</em> HT的第一种变型(见<a class="ae ju" rel="noopener" href="/@azur06400/tabular-network-data-model-part-1-conceptual-definition-49e84104b8aa">上一篇</a>中的图2)，见下图4。</li><li id="c75e" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">对于<em class="jt">目录</em> HT的第二个变体(本文中的图2)，请参见下面的图5。</li></ul><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/0443c39e02a1b758947504bef0c01e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4EtNrfyxZ9wpcGDKlJxcEQ.jpeg"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">图4:第一版目录的逆波(图2在<a class="ae ju" rel="noopener" href="/@azur06400/tabular-network-data-model-part-1-conceptual-definition-49e84104b8aa">前一篇</a>中)。</figcaption></figure><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/031e30600fa173c70061ad4ffa41d087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhA-TAJJ95-vbrQinbOHlA.jpeg"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">图5:第二版“目录”的逆波(本文图2)。</figcaption></figure><p id="1c0d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">TNDBs类和ORM类使用搜索、过滤和保存操作，在表的行和应用程序内存中的对象之间提供对应关系(映射、转换)。</p><p id="b442" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除此之外，TNDB类可以通过图形搜索波的实现创建具有更复杂结构的对象——网络和树。换句话说，当搜索数据或修改数据时，只有一个复杂的TNDB对象可以包含所有必要的信息，其形式是一组简单对象的结构化集合，这些对象映射不同的行。因为使用了物理寻址，所以这个集合计算起来很快，不需要索引和哈希表。</p><h2 id="6873" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jg kg kh ki jk kj kk kl jo km kn ko kp bi translated">超表管理系统</h2><p id="cc8b" class="pw-post-body-paragraph ix iy hi iz b ja kq ij jc jd kr im jf jg ks ji jj jk kt jm jn jo ku jq jr js hb bi translated">表格网络数据库管理系统的第一个完整的功能实现被称为超表格管理系统(HTMS)。</p><p id="f11b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简单是创造HTMS的主要动机。使用HTMS并不比使用众所周知的ORM系统更复杂，比如Django ORM。然而，表格网络模型比关系模型更接近真实世界，这使得设计数据库更容易。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/4c6b7e9037fb2d66c9dd0e48958f707c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KYySqsNOT3uMyeh8IEb2BA.jpeg"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">图6:四个HTMS级别:第一列包含级别的名称，第二列包含功能的简要描述，第三列包含相应软件包中的类名。“包”应该理解为Python包索引(PyPI，Python编程语言的软件仓库)的术语。</figcaption></figure><p id="c8ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">HTMS包括以下级别和包(见图6):</p><ul class=""><li id="bfc6" class="kz la hi iz b ja jb jd je jg lb jk lc jo ld js le lf lg lh bi translated">HTMS应用编程接口(API)的“对象级”包括用于创建HT对象的<code class="du kv kw kx ky b">HT_Obj</code>类，以及用于将对象映射(转换)到表格行或从表格行映射对象的<code class="du kv kw kx ky b">Obj_RAM</code>类。这一层的主要函数类是<code class="du kv kw kx ky b">Obj_RAM</code>，其方法提供了操纵、搜索和过滤数据的基本操作，结果类似于ORM中的<code class="du kv kw kx ky b">objects</code>方法；</li><li id="75d9" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">HTMS API的“中间层”是一组类和函数，它们构成了对象级的基础:用于组织一般的HT结构以及单个表的模型(类似于Django ORM中的<code class="du kv kw kx ky b">models</code>),用于支持HT属性、表、行和字段的常见操作(创建、更改、删除等)。即考虑语义类型<em class="jt">整体</em>、<em class="jt">多部分</em>、<em class="jt">原因</em>的参照类型属性的“重大”变化，形成搜索波；</li><li id="0a69" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">“低级”HTMS API是一组类和实用函数。它构成了中间层和对象层的基础；</li><li id="37bf" class="kz la hi iz b ja li jd lj jg lk jk ll jo lm js le lf lg lh bi translated">“文件级”HTMS API是远程缓存访问网络服务器上的数据库文件的子系统。</li></ul><p id="c083" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用HTMS的软件开发人员可以从三个选项中选择一个。只应用中级API。在这种情况下，对数据库的操作将以表行的“术语”来形式化。<br/> 2。仅应用对象级API。对数据库的操作将以对象的“术语”来形式化，同时可以使用整个中级API装置，因为对象级类是从中级API类中派生出来的:<code class="du kv kw kx ky b">HT_Obj(HTdb)</code>和<code class="du kv kw kx ky b">Obj_RAM(Table)</code>。<br/> 3。应用这两种API。</p><p id="74bf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">HTMS用户界面创建为一个通用HT屏幕编辑器— <em class="jt"> HTed </em>，实现为一个网站。它可以连接到任何数据服务器，而不考虑应用程序。<em class="jt"> HTed </em>用于创建、设计和编辑与HTMS兼容的数据库文件。它在功能上接近用于PostgreSQL ⁴.的<em class="jt"> PgAdmin </em> web实用程序</p><p id="8372" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于大多数应用程序，使用对象级和中级的类和函数就足够了。他们两个合起来是HTMS的一个<strong class="iz hj">逻辑层次</strong>。</p><p id="a019" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">低级和文件级——如果高级开发人员想了解HTMS技术，可以使用它们。他们两个加起来都是一个<strong class="iz hj">身体等级</strong>的HTMS。</p><p id="5f58" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">表格网络模型在HTMS的逻辑和物理层的实现将在以后的文章中详细讨论。我计划继续写表格网络模型和我的软件的具体实现。</p><p id="108e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">HTMS软件支持表格网络数据模型的完整实现，上传到我在⁵⁶⁷⁸⁹.<code class="du kv kw kx ky b">github.com</code>的存储库还有一个关于笼子和HTMS类和功能的详细描述。根据<a class="ae ju" href="http://www.apache.org/licenses/LICENSE-2.0" rel="noopener ugc nofollow" target="_blank"> Apache许可证许可的软件，版本2.0 </a>。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="e091" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">更新</strong>(2022年8月12日)</p><p id="1ef0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文授权:<a class="ae ju" href="https://creativecommons.org/licenses/by-nc-nd/4.0" rel="noopener ugc nofollow" target="_blank"> CC BY-NC-ND 4.0 </a></p><h2 id="3a7b" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jg kg kh ki jk kj kk kl jo km kn ko kp bi translated">引文</h2><p id="49ab" class="pw-post-body-paragraph ix iy hi iz b ja kq ij jc jd kr im jf jg ks ji jj jk kt jm jn jo ku jq jr js hb bi translated">[1]: <em class="jt">姜戈奥姆</em>。<a class="ae ju" href="https://www.fullstackpython.com/django-orm.html" rel="noopener ugc nofollow" target="_blank">www.fullstackpython.com/django-orm.html</a></p><p id="730d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[2]:埃德加·考德。1990.数据库管理的关系模型:第二版。艾迪森-韦斯利</p><p id="faf5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[3]: <em class="jt"> PostgreSQL </em>。<a class="ae ju" href="https://www.postgresql.org" rel="noopener ugc nofollow" target="_blank">www.postgresql.org</a></p><p id="226a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[4]: <em class="jt"> PgAdmin </em>。<a class="ae ju" href="https://www.pgadmin.org" rel="noopener ugc nofollow" target="_blank">www.pgadmin.org</a></p><p id="abdb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[5]: <em class="jt">笼式系统。</em><a class="ae ju" href="https://github.com/Arselon/Cage" rel="noopener ugc nofollow" target="_blank">github.com/Arselon/Cage</a></p><p id="3870" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">【6】:HTMS。github.com/Arselon/HTMST2</p><p id="d031" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[7]: <em class="jt"> HTMS对象级别</em>。<a class="ae ju" href="https://github.com/Arselon/HTMS/tree/main/htms_obj" rel="noopener ugc nofollow" target="_blank">github.com/Arselon/HTMS/tree/main/htms_obj</a></p><p id="8a97" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">【8】:<em class="jt">HTMS中层。</em>T10】github.com/Arselon/HTMS/tree/main/htms_mid</p><p id="d46d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">【9】:<em class="jt">HTMS低级别。</em><a class="ae ju" href="https://github.com/Arselon/HTMS/tree/main/htms_low" rel="noopener ugc nofollow" target="_blank">github.com/Arselon/HTMS/tree/main/htms_low</a></p></div></div>    
</body>
</html>