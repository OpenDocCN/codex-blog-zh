<html>
<head>
<title>Fixing Intel compiler’s unfair CPU dispatcher (Part 2/2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修复英特尔编译器的不公平CPU调度程序(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/fixing-intel-compilers-unfair-cpu-dispatcher-part-2-2-1920bf17315c?source=collection_archive---------4-----------------------#2022-06-05">https://medium.com/codex/fixing-intel-compilers-unfair-cpu-dispatcher-part-2-2-1920bf17315c?source=collection_archive---------4-----------------------#2022-06-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="816c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">测试补丁对性能的影响</h2></div><p id="b496" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章的<a class="ae jt" href="https://shoubhikrmaiti.medium.com/fixing-intel-compilers-unfair-cpu-dispatcher-part-1-2-4a4a367c8919" rel="noopener">前一部分</a>中，我提到了一种修补用英特尔编译器编译或链接到英特尔MKL的二进制文件的方法，以规避不公平的CPU调度程序。补丁应该允许使用SIMD指令和AMD处理器的其他优化。</p><p id="a33e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我将运行基准测试，以了解补丁带来的性能提升。请注意，使用SIMD指令只会提高数值应用程序的性能。如果有一个软件不做繁重的计算，那么打补丁就没有好处。还要注意，二进制补丁总是很危险的，而且总是有可能通过打补丁来破坏软件。</p><p id="276d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在所有基准测试中，我使用了英特尔C/C++编译器、英特尔Fortran编译器和英特尔MKL 2021 . 6 . 0版。编译后的可执行文件在Windows系统的AMD锐龙7 5800H处理器上运行。</p><h2 id="1862" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated"><strong class="ak">基准Fortran的矩阵乘法</strong></h2><p id="cad5" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">Fortran提供了一个内部函数<code class="du ku kv kw kx b">matmul()</code>，允许将两个矩阵相乘。对于这个基准测试，我使用了一个Fortran代码，它将两个不同大小的方阵相乘，用随机实数填充(<code class="du ku kv kw kx b">REAL*8</code>，相当于x64上的C <code class="du ku kv kw kx b">double</code>)矩阵乘法重复100次，并测量了总运行时间。</p><p id="6fd5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，在这种情况下，我没有使用任何来自英特尔MKL的BLAS例程。我正在使用固有函数来测试编译器对于繁重的数值计算可以使用多少矢量化。源代码可以在<a class="ae jt" href="https://github.com/shoubhikraj/intel-cpu-patch/blob/main/benchmarks/matmul-noblas-test.f90" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我用<code class="du ku kv kw kx b">QaxCORE-AVX2</code>编译的，因为我的笔记本电脑支持AVX2。请注意，Windows上的默认代码路径是SSE2。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ky"><img src="../Images/7b9a5ac52ebd680c275a53d274704ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BRuq4kv1s7ab3zMDploLQ.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">用Fortran语言实现矩阵乘法的结果</figcaption></figure><p id="6335" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">软件的原始版本和修补版本之间的结果非常不同。在原始版本(即无补丁版本)中，矩阵乘法使用SSE2指令。当CPU调度程序被修补为不歧视AMD处理器时，它运行更快的AVX2代码路径。</p><p id="6821" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">SSE2 <code class="du ku kv kw kx b">XMM</code>寄存器的长度为128位，因此它们可以在一条指令中处理2个<code class="du ku kv kw kx b">REAL*8</code>数字(每个64位)。而AVX2 <code class="du ku kv kw kx b">YMM</code>寄存器是256位长，所以它们可以处理4个<code class="du ku kv kw kx b">REAL*8</code>数字。因此AVX2的效率应该大约是SSE2的两倍，这就是图中的结果。SSE2和AVX2之间的差异对于大型矩阵(例如3000x3000)尤为重要。在Linux上，您会看到更大的差异，因为编译器中的默认代码路径是x86，即没有SIMD指令。</p><h2 id="3261" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">基准#2:采用MKL的矩阵乘法</h2><p id="79ab" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">MKL提供BLAS例程，其中DGEMM是非常常用的一个。DGEMM也可以用来乘两个矩阵。在这个基准测试中，我使用了一个Fortran代码，它将两个填充了随机数的固定大小的方阵相乘。矩阵乘法重复100次，并测量运行时间。</p><p id="2e6a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这一次，我使用了英特尔MKL来查看MKL是否使用dispatcher在AMD上运行慢速代码路径。英特尔<a class="ae jt" href="https://www.intel.com/content/www/us/en/developer/articles/release-notes/intel-math-kernel-library-release-notes-and-new-features.html" rel="noopener ugc nofollow" target="_blank">声称</a>已经解决了2020.3版MKL中非英特尔处理器的性能问题。源代码可以在<a class="ae jt" href="https://github.com/shoubhikraj/intel-cpu-patch/blob/main/benchmarks/Fortran-dgemm.f90" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lo"><img src="../Images/7e9031fff07eb5c9515f480699ecdd31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y4ibdkyoP9bxTPhu8ADAkw.png"/></div></div></figure><p id="5682" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，软件的修补版本和未修补版本之间似乎没有太大区别。修补CPUID检查器似乎确实在很小程度上提高了性能。因此，看起来英特尔确实修复了MKL，使其能够为非英特尔处理器使用正确的矢量指令。</p><p id="82a1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一件需要注意的事情是，英特尔MKL的DGEMM例程比Fortran固有的<code class="du ku kv kw kx b">matmul()</code>要快。比如3000x3000矩阵上的DGEMM比带AVX2的<code class="du ku kv kw kx b">matmul()</code>快25%左右。数学库的开发者通常会在很大程度上优化他们的代码，以尽可能提高效率。</p><h2 id="aa55" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">基准#3: C++点积</h2><p id="3bf9" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated"><a class="ae jt" href="https://en.wikipedia.org/wiki/Dot_product" rel="noopener ugc nofollow" target="_blank">两个数组之间的点积</a>是一种将数组中相应的元素相乘，然后将结果相加的运算。我用一个C++代码来计算两个数组的点积。由于数字的乘法和加法，FMA指令在这里非常有用。</p><p id="9dc5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，我用<code class="du ku kv kw kx b">-arch:pentium -QaxCORE-AVX2</code>编译。我已经将基线代码路径设置为x86(旧的奔腾处理器只使用x86)，这样默认代码路径和SIMD矢量化代码路径之间的差异就更加明显了。请注意，这种情况下要完成的计算量非常小(例如，与数组乘法相比)，因此FMA矢量化的速度差异很小(以秒为单位)。源代码可以在<a class="ae jt" href="https://github.com/shoubhikraj/intel-cpu-patch/tree/main/benchmarks/cpp-array-dot" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lp"><img src="../Images/9b626aa015c4192b8bec88762008c3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*a_MbmmFQ0L5GRT-A-B-goA.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">阵列点积测试的结果</figcaption></figure><p id="1bdd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，FMA指令确实提供了一点点提升。但是，正如我上面提到的，所做的计算量不足以显示时间上的巨大差异。在真正的科学应用中，会有繁重的计算，SIMD会变得很重要。(顺便说一句，现代科学软件越来越多地使用GPU加速，它也使用SIMD，只是SIMD“寄存器”在GPU中，而不是在CPU中。并且“核心”的数量和“寄存器”的大小也比CPU中可用的要大得多。)</p><h2 id="1f77" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">修补的其他用途</h2><p id="bc83" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">允许在AMD和其他处理器上使用英特尔编译器的自动CPU调度是打补丁的好处之一。另一种可能需要打补丁的情况是软件编译时带有<code class="du ku kv kw kx b">-Qx</code>标志。如果使用这个标志，那么产生的二进制文件甚至不能在非Intel系统上运行。</p><p id="c41d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您会看到如下消息:</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lq"><img src="../Images/c84f58e4a341ef4980858b0cdb740720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAIsEYo-fGVKgvE1YyjTig.png"/></div></div></figure><p id="2868" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不幸的是，如果您以这种方式编译了二进制文件，修补CPUID检查器也将删除此消息并允许您的代码运行。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lr"><img src="../Images/490c50a2d9d4eee144fadef528d98d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8ACz_fgWx3Q7ECKRySAEg.png"/></div></div></figure><p id="6df1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，打补丁消除了错误信息，软件运行良好。(注意，如果您的CPU不能运行AVX2，并且您针对AVX2进行编译，您仍然会看到一条错误消息。)</p><h1 id="663a" class="ls jv hi bd jw lt lu lv ka lw lx ly ke io lz ip kh ir ma is kk iu mb iv kn mc bi translated">结论</h1><p id="9387" class="pw-post-body-paragraph ix iy hi iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">因此，所有这些的结果是，您可以非常轻松地利用AMD和其他非英特尔处理器上的英特尔C++/Fortran编译器自动向量化和多任务分派。您所需要的只是python安装。</p><p id="cb16" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种方法的一个问题是，您仍然需要针对不同的非Intel CPUs进行不同的修改。“修复”并没有禁用英特尔的CPU调度，它只是改变了正在比较的CPUID供应商字符串。所以，如果你给程序打补丁，用<code class="du ku kv kw kx b">AuthenticAMD</code>代替<code class="du ku kv kw kx b">GenuineIntel</code>，那么程序现在只能在AMD处理器上正确运行。调度员将不会通过nano或其他东西公平地工作。</p><p id="4ef4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，以这种方式修补二进制文件存在风险。一些软件确实有合法的理由检查CPUID供应商字符串，例如为了正确地管理线程。(很多游戏都是这样做的，因为不同的CPU需要不同的线程调度才能发挥最佳效果。)正如我在上面所展示的，MKL在没有任何补丁的AMD处理器上运行良好，所以补丁是不必要的。</p><p id="1544" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，英特尔将来可能会混淆这种CPU检查代码，以防止打补丁。英特尔还可能在未来完全取消CPU供应商检查，只使用适用于所有品牌CPU的公平调度程序，但这似乎不太可能，因为英特尔希望在自己的CPU上提供最佳性能。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="657c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！请随时在回复中留下评论或问题。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="ebf6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">python脚本和基准数据可以在这里找到:<a class="ae jt" href="https://github.com/shoubhikraj/intel-cpu-patch" rel="noopener ugc nofollow" target="_blank">https://github.com/shoubhikraj/intel-cpu-patch</a></p></div></div>    
</body>
</html>