<html>
<head>
<title>Javascript Event Handling — Deep Dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript事件处理—深入探讨</h1>
<blockquote>原文：<a href="https://medium.com/codex/javascript-event-handling-deep-dive-aef60127abb?source=collection_archive---------9-----------------------#2021-07-21">https://medium.com/codex/javascript-event-handling-deep-dive-aef60127abb?source=collection_archive---------9-----------------------#2021-07-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a4e1146cccf27562fa7658eda007cd58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iy_KuWuo9WI2RL2LgRvEwg.jpeg"/></div></div></figure><blockquote class="iq"><p id="c4a9" class="ir is hi bd it iu iv iw ix iy iz ja dx translated"><em class="jb">中等乡亲，请添加对嵌套列表的支持。</em></p><p id="66c4" class="ir is hi bd it iu jc jd je jf jg ja dx translated"><em class="jb">真诚的技术作家</em></p></blockquote><h1 id="3e60" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">目录</h1><ul class=""><li id="b46d" class="kf kg hi kh b ki kj kk kl km kn ko kp kq kr ja ks kt ku kv bi translated">介绍</li><li id="8bdb" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated">概观</li><li id="4ad6" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated">深潜</li><li id="1b52" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated">资源</li></ul><h1 id="b049" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js lb ju jv jw lc jy jz ka ld kc kd ke bi translated">介绍</h1><p id="702b" class="pw-post-body-paragraph le lf hi kh b ki kj lg lh kk kl li lj km lk ll lm ko ln lo lp kq lq lr ls ja hb bi translated"><strong class="kh hj">目标</strong></p><p id="8e13" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">本文采用公正的方法来研究各种UI工具中的事件处理。内容基于官方文件— <strong class="kh hj"> <em class="ly">而非</em> </strong>的意见。</p><p id="4cec" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj">目的</strong></p><p id="a338" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">目的是理解这些工具是如何解决相同的“<em class="ly">问题</em>”。</p><p id="89b9" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj">这篇文章不是什么</strong></p><p id="52f5" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">本文不评估利弊，也不推荐一种工具优于另一种。</p><h1 id="6b47" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js lb ju jv jw lc jy jz ka ld kc kd ke bi translated">概观</h1><p id="c28e" class="pw-post-body-paragraph le lf hi kh b ki kj lg lh kk kl li lj km lk ll lm ko ln lo lp kq lq lr ls ja hb bi translated">Javascript世界正以极快的速度发展。在很长一段时间里，一个网页都是由一个单一的脚本文件组成的，这个脚本文件处理所有的事情——从在页面上启用交互性到调用服务和呈现内容。这种模式有明显的缺点。整体架构难以长期扩展和维护。特别是在有几个工程师贡献代码的企业级别，单一的架构往往会变得一团糟，难以调试。</p><p id="53cf" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">Javascript的固有特性允许工程师对这种模式进行创新，并想出巧妙的方法来解决缺点。现在有很多前端库和框架，每一个都有自己的超能力和解决问题的方式。因此，现代开发人员在选择一个系统来构建他们的应用程序时，选择余地很大。</p><p id="6f62" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">尽管可供开发人员使用的工具列表已经非常详尽，但是没有多少能够经受住时间和战争的考验。在本文中，我们将调查那些(相当)毫发无损的人，试图了解他们是如何处理事件的。</p><h1 id="1b17" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js lb ju jv jw lc jy jz ka ld kc kd ke bi translated">深潜</h1><p id="2453" class="pw-post-body-paragraph le lf hi kh b ki kj lg lh kk kl li lj km lk ll lm ko ln lo lp kq lq lr ls ja hb bi translated">本节将深入探讨几个流行的、公开可用的UI库和框架，研究它们是如何处理事件的。让我们从最受欢迎的开始。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/b1fee9cca286c10de43e2bb24f2ae91a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qubwlTVk4ug_VRRd"/></div></div></figure><h2 id="a718" class="mf ji hi bd jj mg mh mi jn mj mk ml jr km mm mn jv ko mo mp jz kq mq mr kd ms bi translated">在React中处理事件</h2><p id="e88d" class="pw-post-body-paragraph le lf hi kh b ki kj lg lh kk kl li lj km lk ll lm ko ln lo lp kq lq lr ls ja hb bi translated">React中的事件处理围绕<a class="ae lz" href="https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/events/ReactBrowserEventEmitter.js" rel="noopener ugc nofollow" target="_blank">reactbrowsereventmitter</a>展开。源代码中的第一个注释很好地解释了它是如何工作的。</p><p id="77c3" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><code class="du mt mu mv mw b">ReactBrowserEventEmitter</code>事件处理总结:</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/f825aab2eee5c79d7cd752bbef31540b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eqfdpm6qHJ0-skTs"/></div></div></figure><h2 id="a837" class="mf ji hi bd jj mg mh mi jn mj mk ml jr km mm mn jv ko mo mp jz kq mq mr kd ms bi translated">让我们深入研究并逐一分析:</h2><blockquote class="my mz na"><p id="c706" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> → </em>顶级委托用于捕获大多数原生浏览器事件。这可能只发生在主线程中，由<code class="du mt mu mv mw b">ReactDOMEventListener</code>负责，它是注入的，因此可以支持可插拔事件源。这是发生在主线程中的唯一工作。</p></blockquote><p id="4448" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">React使用事件委托来处理应用程序中的大多数交互事件。这意味着当一个带有<code class="du mt mu mv mw b">onClick</code>处理程序的<code class="du mt mu mv mw b">button</code>被渲染时</p><pre class="mb mc md me fd ne mw nf ng aw nh bi"><span id="7f19" class="mf ji hi mw b fi ni nj l nk nl">&lt;button onClick={() =&gt; console.log('button was clicked')}&gt;Click here&lt;/button&gt;</span></pre><p id="5f11" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">React没有将事件监听器附加到<code class="du mt mu mv mw b">button</code>节点。取而代之的是，它获取一个对应用程序呈现的文档根的引用，并且<a class="ae lz" href="https://github.com/facebook/react/blob/8a8d973d3cc5623676a84f87af66ef9259c3937c/packages/react-dom/src/client/ReactDOMComponent.js#L225" rel="noopener ugc nofollow" target="_blank">在那里安装</a>一个事件监听器。React对每个事件类型使用一个事件监听器来调用虚拟DOM中所有提交的处理程序。每当DOM事件被触发时，这些顶级侦听器通过React源代码启动实际的事件调度——它为每个处理程序重新调度事件。这可以在<a class="ae lz" href="https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/events/EventPluginHub.js" rel="noopener ugc nofollow" target="_blank"> EventPluginHub </a>的源代码中看到。</p><blockquote class="my mz na"><p id="8397" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated">→我们对事件进行标准化和重复数据删除，以解决浏览器的问题。这可以在工作线程中完成。</p></blockquote><p id="8259" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj"> React使事件类型正常化</strong>，这样每个浏览器，不管它的底层引擎是旧的还是新的，都将拥有一致的事件参数。这意味着，在所有浏览器、设备和操作系统中，一个<code class="du mt mu mv mw b">click</code>事件会有这样的参数</p><ul class=""><li id="da46" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><strong class="kh hj">布尔型</strong> altKey</li><li id="07aa" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><strong class="kh hj">布尔型</strong>元键</li><li id="463b" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><strong class="kh hj">布尔型</strong> ctrlKey</li><li id="8ac3" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><strong class="kh hj">布尔型</strong>shift键</li><li id="b973" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><strong class="kh hj">布尔型</strong> getModifierState(key)</li><li id="5822" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><strong class="kh hj">数字</strong>按钮</li><li id="af29" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><strong class="kh hj">数字</strong>按钮</li><li id="4340" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><strong class="kh hj">编号</strong> clientX</li><li id="397b" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><strong class="kh hj">号</strong>号主顾</li><li id="fcaa" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><strong class="kh hj">编号</strong> pageX</li><li id="d89f" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><strong class="kh hj">编号</strong>佩吉</li><li id="c97a" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><strong class="kh hj">号</strong>屏幕</li><li id="e9ca" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><strong class="kh hj">编号</strong> screenX</li><li id="b063" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><strong class="kh hj">多事件目标</strong>相关目标</li></ul><p id="cd19" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">📖<strong class="kh hj">延伸阅读</strong>:React中支持的事件，阅读<a class="ae lz" href="https://reactjs.org/docs/events.html#supported-events" rel="noopener ugc nofollow" target="_blank">本</a>。</p><blockquote class="my mz na"><p id="7627" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated">→将这些原生事件(带有用于捕获它的相关顶级类型)转发给<code class="du mt mu mv mw b">EventPluginHub</code>，它将依次询问插件是否要提取任何合成事件。</p></blockquote><p id="aece" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">React考虑每个事件的性质，并将它们分类到不同的桶中。它有专门的插件来管理每个桶中的事件。<strong class="kh hj">然后，这些插件中的每一个依次负责提取和处理该桶中的各种事件类型</strong>。例如，<code class="du mt mu mv mw b">SimpleEventPlugin</code>将处理在普通浏览器中实现的事件，如鼠标和按键事件(<a class="ae lz" href="https://share.cocalc.com/share/a04c90b3eaea18961287b4f6b5c13a7df2d3f0f1/react/wstein/node_modules/react/lib/SimpleEventPlugin.js?viewer=share" rel="noopener ugc nofollow" target="_blank">源</a>)，而<code class="du mt mu mv mw b">ChangeEventPlugin</code>将处理<code class="du mt mu mv mw b">onChange</code>事件(<a class="ae lz" href="https://share.cocalc.com/share/a04c90b3eaea18961287b4f6b5c13a7df2d3f0f1/react/wstein/react-with-addons.js?viewer=share" rel="noopener ugc nofollow" target="_blank">源</a>)。将所有插件统一到一个地方并将事件重定向到每个插件的最后一个部分是<code class="du mt mu mv mw b">EventPluginHub</code>。</p><p id="b029" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">这为我们理解React如何看待事件打开了大门。React引入了<code class="du mt mu mv mw b">SyntheticEvents</code>的概念，React将其定义为“<em class="ly">通过规范化浏览器怪癖</em>实现DOM Level 3 Events API”。基本上，它是一个<strong class="kh hj">包装器，用相同的接口包装浏览器的本地事件对象</strong>——并且它在所有浏览器上的工作都是一样的。</p><p id="f8c6" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">对于React v16和更早版本，合成事件利用轮询机制。这种机制确保了在多个处理程序中使用同一个对象实例，但是在每次调用之前都会用新的属性对其进行重置，然后将其释放。</p><blockquote class="my mz na"><p id="1811" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated">→然后<code class="du mt mu mv mw b">EventPluginHub</code>将通过用“dispatches ”(一系列关注该事件的监听器和id)注释来处理每个事件。</p></blockquote><p id="3ffa" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj">在React生态系统中，对于任何一种事件类型</strong>，都会在文档根附加一个事件监听器。由于每个事件类型很可能有多个处理程序，<strong class="kh hj"> React将累积事件及其处理程序</strong> ( <a class="ae lz" href="https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/events/EventPropagators.js#L90" rel="noopener ugc nofollow" target="_blank">源</a>)。然后，它将进行相关的分派，包括事件处理程序及其对应的纤程节点。纤程节点是虚拟DOM树中的节点。纤程节点是使用React的协调算法计算的，这是它驱动页面更新的“diffing”算法。</p><p id="7635" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">📖<strong class="kh hj">延伸阅读</strong> : <a class="ae lz" href="https://blog.logrocket.com/deep-dive-into-react-fiber-internals/" rel="noopener ugc nofollow" target="_blank">反应纤维架构</a></p><p id="d8b7" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">📖<strong class="kh hj">延伸阅读</strong> : <a class="ae lz" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">反应和解理念</a></p><blockquote class="my mz na"><p id="31ce" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated">→然后<code class="du mt mu mv mw b">EventPluginHub</code>分派事件。</p></blockquote><p id="1ec4" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">谜题的最后一部分— <strong class="kh hj">插件中心检查积累的信息并分派事件</strong>，从而调用提交的事件处理程序(<a class="ae lz" href="https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/events/EventPluginUtils.js#L77" rel="noopener ugc nofollow" target="_blank">源</a>)。</p><p id="56fa" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj">简单演示</strong></p><p id="d198" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">下面是React → <a class="ae lz" href="https://codesandbox.io/s/thirsty-wildflower-57x4m?file=/src/App.js" rel="noopener ugc nofollow" target="_blank"> Link </a>中一个简单的点击处理程序演示实现。</p></div><div class="ab cl np nq gp nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="hb hc hd he hf"><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nw"><img src="../Images/fc944f82282050da3dcc6ed31f1be556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pap-CR3HBbB850He"/></div></div></figure><h2 id="8547" class="mf ji hi bd jj mg mh mi jn mj mk ml jr km mm mn jv ko mo mp jz kq mq mr kd ms bi translated">在Vue中处理事件</h2><p id="122b" class="pw-post-body-paragraph le lf hi kh b ki kj lg lh kk kl li lj km lk ll lm ko ln lo lp kq lq lr ls ja hb bi translated">在Vue中，创建一个包含执行javascript的<code class="du mt mu mv mw b">script</code>标签和包装所有标记(DOM和定制元素)的<code class="du mt mu mv mw b">template</code>标签的<code class="du mt mu mv mw b">.vue</code>文件。这是一个Vue组件的自包含实例，它也可以包含一个<code class="du mt mu mv mw b">style</code>标签来存放CSS。</p><blockquote class="my mz na"><p id="75a9" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated">→简单的DOM事件处理</p></blockquote><p id="7b3e" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">Vue允许开发人员使用<code class="du mt mu mv mw b">v-on:&lt;event-name&gt;</code>或简而言之<code class="du mt mu mv mw b">@&lt;event-name</code>指令将事件绑定到元素，并将应用程序的状态存储在<code class="du mt mu mv mw b">data</code> prop中。<strong class="kh hj">所有的事件处理程序都类似的存储在同一个对象</strong>的 <code class="du mt mu mv mw b"><strong class="kh hj">methods</strong></code> <strong class="kh hj">道具中。</strong></p><pre class="mb mc md me fd ne mw nf ng aw nh bi"><span id="aeb0" class="mf ji hi mw b fi ni nj l nk nl">// App.vue</span><span id="0555" class="mf ji hi mw b fi nx nj l nk nl">&lt;template&gt;<br/>    &lt;div id="app"&gt;<br/>        &lt;HelloWorld :msg="msg" /&gt;<br/>        &lt;button <a class="ae lz" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>="greet('World', $event)"&gt;<br/>            click here<br/>        &lt;/button&gt;<br/>    &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="298d" class="mf ji hi mw b fi nx nj l nk nl">&lt;script&gt;<br/>    import HelloWorld from "./components/HelloWorld";</span><span id="ea53" class="mf ji hi mw b fi nx nj l nk nl">export default {<br/>        name: "App",<br/>        components: { HelloWorld },<br/>        data: function () {<br/>            return { msg: "Vue" };<br/>        },<br/>        methods: {<br/>            greet: function (message, $event) { this.msg = message; }<br/>        }<br/>    }<br/>&lt;/script&gt;</span></pre><p id="5ab7" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">应用程序将加载消息“Hello Vue”。点击按钮时，处理程序会将消息设置为World，并显示“Hello World”消息→ <a class="ae lz" href="https://codesandbox.io/s/vue-demo-dom-event-handler-wxces?file=/src/App.vue" rel="noopener ugc nofollow" target="_blank"> REPL </a>。通过从处理程序引用传入一个对象并访问事件处理程序，可以访问原始DOM事件。</p><blockquote class="my mz na"><p id="639b" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated">→事件修饰符</p></blockquote><p id="5d11" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">虽然可以通过简单地传递DOM事件对象来访问处理程序中的DOM事件对象，但是Vue允许通过附加“修饰符”来扩展事件处理，从而改善了开发人员的体验。这样，<strong class="kh hj"> Vue将为您处理这些修饰符，而不是开发人员在他们的处理程序</strong>中显式调用这些修饰符。通过使用点分隔的模式，可以附加多个修改器。支持的修饰符的完整列表如下:</p><ul class=""><li id="25db" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.stop</code></li><li id="6547" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.prevent</code></li><li id="6c17" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.capture</code></li><li id="5f3d" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.self</code></li><li id="71cd" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.once</code></li><li id="01b7" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.passive</code></li></ul><p id="777b" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">因此，一个简单的例子应该是这样的</p><pre class="mb mc md me fd ne mw nf ng aw nh bi"><span id="2c6d" class="mf ji hi mw b fi ni nj l nk nl">/* this will trigger the handler method only once */</span><span id="05e4" class="mf ji hi mw b fi nx nj l nk nl">&lt;button v-on:click.stop.once="clickHandler"&gt;Click me&lt;/button&gt;</span></pre><p id="11f2" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">链接→ <a class="ae lz" href="https://codesandbox.io/s/vue-demo-event-modifiers-gbqmo?file=/src/App.vue" rel="noopener ugc nofollow" target="_blank"> REPL </a></p><blockquote class="my mz na"><p id="a177" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated">→关键修饰符</p></blockquote><p id="80ba" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj"> Vue有一个特性，可以像普通事件处理程序一样附加键盘事件</strong>。它支持一个别名列表，通常附带键盘事件，如<code class="du mt mu mv mw b">enter</code>和<code class="du mt mu mv mw b">tab</code>键。别名的完整列表如下所示:</p><ul class=""><li id="52ba" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.enter</code></li><li id="3cc8" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.tab</code></li><li id="ecc7" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.delete</code>(捕捉“删除”和“退格”键)</li><li id="38eb" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.esc</code></li><li id="94ed" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.up</code></li><li id="968a" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.down</code></li><li id="cd9d" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.left</code></li><li id="962c" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.right</code></li><li id="e4b5" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.space</code></li></ul><p id="edca" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">下面是一个简单的例子</p><pre class="mb mc md me fd ne mw nf ng aw nh bi"><span id="5fd9" class="mf ji hi mw b fi ni nj l nk nl">&lt;!-- only call `vm.submit()` when the `key` is `Enter` --&gt;</span><span id="d263" class="mf ji hi mw b fi nx nj l nk nl">&lt;input v-on:keyup.enter="submit"</span></pre><blockquote class="my mz na"><p id="ab4b" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> →自定义事件</em></p></blockquote><p id="3e0f" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">Vue处理定制事件的发布和订阅。这里需要注意的是，每个应该监听事件的组件都应该维护一个自定义事件的显式列表。一个简单的例子是这样的</p><p id="199a" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">与组件和道具不同，事件名称永远不会在JavaScript中用作变量或属性名，所以没有理由使用camelCase或PascalCase。此外，DOM模板中的<code class="du mt mu mv mw b">v-on</code>事件监听器会自动转换成小写(由于HTML不区分大小写)，所以<code class="du mt mu mv mw b">v-on:myEvent</code>会变成<code class="du mt mu mv mw b">v-on:myevent</code>——使得<code class="du mt mu mv mw b">myEvent</code>无法监听。Vue JS作为一个框架推荐使用kebab-case作为事件名称。</p><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ny"><img src="../Images/18250e3f5612dd7b904d3d5972539833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Av13mU1UpL8eZklC"/></div></div></figure><p id="f021" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">Angular是专注于构建单页面应用程序(spa)的第一代固执己见的框架之一。尽管最近它经历了重大的重新发明，但与目前开发人员可用的更现代的工具(本文将讨论其中一些)相比，它在几个方面仍然存在不足。然而，看看框架如何绑定和处理事件仍然是有价值的。</p><h2 id="075d" class="mf ji hi bd jj mg mh mi jn mj mk ml jr km mm mn jv ko mo mp jz kq mq mr kd ms bi translated">在Angular (4.x和更高版本)中处理事件</h2><p id="9d33" class="pw-post-body-paragraph le lf hi kh b ki kj lg lh kk kl li lj km lk ll lm ko ln lo lp kq lq lr ls ja hb bi translated">Angular有一个非常特殊的语法来绑定和处理事件。该语法由等号左边括号内的目标事件名和右边带引号的模板语句(<a class="ae lz" href="https://angular.io/guide/event-binding" rel="noopener ugc nofollow" target="_blank">源</a>)组成。</p><p id="6855" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">DOM事件绑定和处理的一个简单示例如下</p><pre class="mb mc md me fd ne mw nf ng aw nh bi"><span id="f1eb" class="mf ji hi mw b fi ni nj l nk nl">&lt;button (click)="onSave()"&gt;Save&lt;/button&gt;</span></pre><p id="5d42" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj">当事件被绑定时，Angular为目标事件</strong>配置一个事件处理程序——它也可以用于自定义事件。当组件或指令<em class="ly">引发</em>事件时，处理程序执行<em class="ly">模板语句</em>。然后，模板语句响应事件。</p><p id="a045" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj">在Angular中，可以将一个$event对象传递给处理事件</strong>的函数。<code class="du mt mu mv mw b">$event</code>对象的形状由<code class="du mt mu mv mw b">target event</code>决定。如果事件是本地DOM元素事件，那么<code class="du mt mu mv mw b">$event</code>对象是一个<a class="ae lz" href="https://developer.mozilla.org/en-US/docs/Web/Events" rel="noopener ugc nofollow" target="_blank"> DOM事件对象</a>。让我们看一个简单的例子(<a class="ae lz" href="https://angular.io/guide/event-binding-concepts" rel="noopener ugc nofollow" target="_blank">来源</a>)</p><pre class="mb mc md me fd ne mw nf ng aw nh bi"><span id="59a4" class="mf ji hi mw b fi ni nj l nk nl">&lt;input<br/>    [value]="currentItem.name"<br/>    (input)="currentItem.name=$event.target.val"<br/>/&gt;</span></pre><p id="a4a9" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">这里发生了几件事:</p><ol class=""><li id="8445" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja nz kt ku kv bi translated">代码绑定到<code class="du mt mu mv mw b">&lt;input&gt;</code>元素的<code class="du mt mu mv mw b">input</code>事件，这允许代码监听变化。</li><li id="adb1" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja nz kt ku kv bi translated">当用户进行更改时，组件会引发<code class="du mt mu mv mw b">input</code>事件。</li><li id="5167" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja nz kt ku kv bi translated">绑定在包含DOM事件对象<code class="du mt mu mv mw b">$event</code>的上下文中执行语句。</li><li id="b999" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja nz kt ku kv bi translated">Angular通过遵循路径<code class="du mt mu mv mw b">$event.target.vaue</code>检索更改的文本，并更新<code class="du mt mu mv mw b">name</code>属性。</li></ol><p id="1319" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">如果事件属于一个指令或组件，<code class="du mt mu mv mw b">$event</code>具有该指令或组件产生的形状。</p><p id="ddd8" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">链接→ <a class="ae lz" href="https://stackblitz.com/angular/pegebmnalav?file=src%2Fapp%2Fapp.component.ts" rel="noopener ugc nofollow" target="_blank"> REPL </a></p></div><div class="ab cl np nq gp nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="hb hc hd he hf"><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oa"><img src="../Images/6d19ebaef0cd2de1a3ee49a476d9f7e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YyMqZwI2ht3-mcjc"/></div></div></figure><h2 id="b6a2" class="mf ji hi bd jj mg mh mi jn mj mk ml jr km mm mn jv ko mo mp jz kq mq mr kd ms bi translated">苗条地处理事件</h2><p id="87f6" class="pw-post-body-paragraph le lf hi kh b ki kj lg lh kk kl li lj km lk ll lm ko ln lo lp kq lq lr ls ja hb bi translated">在Svelte中，您创建一个<code class="du mt mu mv mw b">.svelte</code>文件，该文件包含一个组件实例及其CSS、JS和HTML，以及任何需要的定制元素。</p><blockquote class="my mz na"><p id="6361" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> →简单的DOM事件处理</em></p></blockquote><p id="3226" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">单击处理程序的简单演示如下所示:</p><pre class="mb mc md me fd ne mw nf ng aw nh bi"><span id="6138" class="mf ji hi mw b fi ni nj l nk nl">&lt;script&gt;<br/>    let name = 'world';<br/>    function update() { name = 'Svelte'; }<br/>&lt;/script&gt;</span><span id="855f" class="mf ji hi mw b fi nx nj l nk nl">&lt;span on:click={update}&gt;Hello { name }&lt;/span&gt;</span></pre><p id="0319" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">这将在加载时打印<code class="du mt mu mv mw b">Hello World</code>，但是当用户点击<code class="du mt mu mv mw b">h1</code>-&gt;-<a class="ae lz" href="https://svelte.dev/repl/af38f740da8c4733817a26328ba7d061?version=3.31.0" rel="noopener ugc nofollow" target="_blank">REPL</a>时，将更新并打印<code class="du mt mu mv mw b">Hello Svelte</code>。这是DOM事件如<code class="du mt mu mv mw b">click</code>、<code class="du mt mu mv mw b">mousemove</code>等在Svelte中实现的一般模式(它也支持内联处理程序)。</p><blockquote class="my mz na"><p id="5a10" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> →事件修改器</em></p></blockquote><p id="cb5f" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj">系统允许开发者给事件</strong>添加管道分隔的<em class="ly">修饰符</em>，如<code class="du mt mu mv mw b">preventDefault</code>和<code class="du mt mu mv mw b">stopPropagation</code>。handler函数可以接受一个也可以访问这些修饰符的<code class="du mt mu mv mw b">event</code>参数，但是Svelte通过提供这些快捷键改善了开发人员的体验。示例如下所示:</p><pre class="mb mc md me fd ne mw nf ng aw nh bi"><span id="23b1" class="mf ji hi mw b fi ni nj l nk nl">&lt;script&gt;<br/>    function handleClick() { alert('This alert will trigger only once!'); }<br/>&lt;/script&gt;</span><span id="2541" class="mf ji hi mw b fi nx nj l nk nl">&lt;button on:click|once={ handleClick }&gt;Click here&lt;/button&gt;</span></pre><p id="f52e" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">因此，图案看起来像<code class="du mt mu mv mw b">on:&lt;event-name&gt;|modifier1|modifier2|...</code> → <a class="ae lz" href="https://svelte.dev/repl/a5d264f4ace9462faf39b2a592e97295?version=3.31.0" rel="noopener ugc nofollow" target="_blank"> REPL </a>。修改器的完整列表如下(<a class="ae lz" href="https://svelte.dev/tutorial/event-modifiers" rel="noopener ugc nofollow" target="_blank">来源</a>):</p><ul class=""><li id="aeba" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">preventDefault</code> -在运行处理程序之前调用<code class="du mt mu mv mw b">event.preventDefault()</code>。对于客户端表单处理非常有用</li><li id="9e1a" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">stopPropagation</code> -调用<code class="du mt mu mv mw b">event.stopPropagation()</code>，防止事件到达下一个元素</li><li id="1e5c" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">passive</code> -改进触摸/滚轮事件的滚动性能(Svelte会在安全的地方自动添加)</li><li id="43dd" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">nonpassive</code> -明确设置<code class="du mt mu mv mw b">passive: false</code></li><li id="f6e4" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">capture</code> -在<em class="ly">捕获</em>阶段而不是<em class="ly">冒泡</em>阶段(<a class="ae lz" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling_and_capture" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>)触发处理程序</li><li id="9cdd" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">once</code> -第一次运行后移除处理器</li><li id="52c5" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">self</code> -只有当<code class="du mt mu mv mw b">event.target</code>是元素本身时才触发处理程序</li></ul><blockquote class="my mz na"><p id="bc49" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> →调度事件</em></p></blockquote><p id="8167" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj">在Svelte中，父组件可以使用名为<code class="du mt mu mv mw b">createEventDispatcher</code>的函数根据子组件</strong>发送的数据更新状态。函数允许子组件以用户定义的键发出数据对象。然后父组件可以随心所欲地处理它- &gt; <a class="ae lz" href="https://svelte.dev/repl/2212634b19314d2c9e157dffd73edd8f?version=3.31.0" rel="noopener ugc nofollow" target="_blank"> REPL </a>(打开控制台查看分派的数据对象)。</p><blockquote class="my mz na"><p id="5d0c" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> →事件转发</em></p></blockquote><p id="0203" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">对组件事件的警告是它不会<em class="ly">冒泡</em>。因此，<strong class="kh hj">如果一个父组件需要监听一个由深层嵌套组件发出的事件，所有的中间组件将不得不<em class="ly">转发</em>那个事件</strong>。当我们遍历苗条的DOM时，通过在每个包装组件上添加自定义数据键来实现事件转发。最后，需要处理事件的父组件为它实现一个处理程序→ <a class="ae lz" href="https://svelte.dev/repl/49b1b14aef8f4bff8fab771394ae876c?version=3.32.3" rel="noopener ugc nofollow" target="_blank"> REPL </a>(打开控制台看演示)。</p><blockquote class="my mz na"><p id="1f99" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> →动作</em></p></blockquote><p id="55ac" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">苗条事件处理的最后一部分是<code class="du mt mu mv mw b">actions</code>的实现。<strong class="kh hj">动作是元素级函数，对添加自定义事件处理程序</strong>很有用。与转换函数类似，动作函数接收<code class="du mt mu mv mw b">node</code>和一些可选参数，并返回一个动作对象。那个对象可以有一个<code class="du mt mu mv mw b">destroy</code>函数，当元素被卸载时被调用→ <a class="ae lz" href="https://svelte.dev/repl/79f3cd81b76d42909ec69e042c74abd5?version=3.31.0" rel="noopener ugc nofollow" target="_blank"> REPL </a>(借用自Svelte官方资源)。</p><p id="562e" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">📖<strong class="kh hj">延伸阅读</strong> : <a class="ae lz" href="https://svelte.dev/tutorial/basics" rel="noopener ugc nofollow" target="_blank">苗条官方教程</a></p><p id="e802" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">📖<strong class="kh hj">延伸阅读</strong> : <a class="ae lz" href="https://lihautan.com/compile-svelte-in-your-head-part-1/#adding-event-listeners" rel="noopener ugc nofollow" target="_blank">在你的头脑中编译苗条</a></p></div><div class="ab cl np nq gp nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="hb hc hd he hf"><figure class="mb mc md me fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ob"><img src="../Images/b60e14aa18a1ce8c99ffcdc42491e78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lQZadNC25yT9Csz5"/></div></div></figure><h2 id="2799" class="mf ji hi bd jj mg mh mi jn mj mk ml jr km mm mn jv ko mo mp jz kq mq mr kd ms bi translated">在jQuery中处理事件</h2><p id="e730" class="pw-post-body-paragraph le lf hi kh b ki kj lg lh kk kl li lj km lk ll lm ko ln lo lp kq lq lr ls ja hb bi translated">使用jQuery的主要好处是它使得DOM遍历和操作非常方便。因为大多数由用户发起的浏览器事件都是为了提供UI反馈，所以这个特性很方便。在引擎盖下，jQuery使用了一个强大的“选择器”引擎，名为<a class="ae lz" href="https://github.com/jquery/sizzle" rel="noopener ugc nofollow" target="_blank"> Sizzle </a>。Sizzle是一个纯粹的JS-CSS选择器引擎，设计用于任何主机库中。</p><p id="0b6f" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">让我们看看jQuery如何绑定和处理事件的编程模型和类别。所提供的“源代码”链接是API的官方文档，并且包含关于它们如何工作的附加信息:</p><blockquote class="my mz na"><p id="e26c" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> →浏览器事件</em></p></blockquote><p id="4439" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">来源:<a class="ae lz" href="https://api.jquery.com/category/events/browser-events/" rel="noopener ugc nofollow" target="_blank">浏览器事件</a></p><p id="4381" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">jQuery可以处理下列现成的浏览器事件。</p><ul class=""><li id="db96" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.error()</code>:将事件处理程序绑定到“error”JS事件(<a class="ae lz" href="https://api.jquery.com/error/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="7bde" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.resize()</code>:将事件处理程序绑定到“resize”JS事件，或者触发元素上的(<a class="ae lz" href="https://api.jquery.com/resize/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="a40d" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.scroll()</code>:将事件处理程序绑定到“scroll”JS事件，或者在元素上触发事件(<a class="ae lz" href="https://api.jquery.com/scroll/" rel="noopener ugc nofollow" target="_blank">来源</a></li></ul><blockquote class="my mz na"><p id="ca68" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> →文件装载</em></p></blockquote><p id="597d" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">来源:<a class="ae lz" href="https://api.jquery.com/category/events/document-loading/" rel="noopener ugc nofollow" target="_blank">文件加载</a></p><p id="ab88" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">jQuery提供了一系列现成的API来处理与初始页面加载相关的事件。</p><ul class=""><li id="a3e0" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">jQuery.holdReady()</code>:暂停或释放jQuery就绪事件的执行(<a class="ae lz" href="https://api.jquery.com/jQuery.holdReady/" rel="noopener ugc nofollow" target="_blank">源</a>)。</li><li id="28c3" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">jQuery.ready()</code>:一个类似承诺的对象，在文档准备好的时候解析(<a class="ae lz" href="https://api.jquery.com/jQuery.ready/" rel="noopener ugc nofollow" target="_blank">源</a>)。</li><li id="54a1" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">load()</code>:将事件处理程序绑定到“load”JS事件(<a class="ae lz" href="https://api.jquery.com/load-event/" rel="noopener ugc nofollow" target="_blank"> source </a>)。</li><li id="a2d4" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">ready()</code>:指定DOM满载时执行的函数(<a class="ae lz" href="https://api.jquery.com/ready/" rel="noopener ugc nofollow" target="_blank"> source </a>)。</li><li id="356e" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">unload()</code>:绑定一个事件处理程序到“unload”JS事件(<a class="ae lz" href="https://api.jquery.com/unload/" rel="noopener ugc nofollow" target="_blank"> source </a>)。</li></ul><blockquote class="my mz na"><p id="ad84" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> →表单事件</em></p></blockquote><p id="80c5" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">来源:<a class="ae lz" href="https://api.jquery.com/category/events/form-events/" rel="noopener ugc nofollow" target="_blank">表单事件</a></p><p id="7602" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">jQuery提供了一系列现成的API来处理常见的表单事件</p><ul class=""><li id="b141" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.blur()</code>:将事件处理程序绑定到“模糊”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/blur/" rel="noopener ugc nofollow" target="_blank">源</a>)</li><li id="036d" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.change()</code>:将事件处理程序绑定到“change”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/change/" rel="noopener ugc nofollow" target="_blank"> source </a></li><li id="ea0d" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.focus()</code>:将一个事件处理程序绑定到“焦点”JS事件，或者在一个元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/focus/" rel="noopener ugc nofollow" target="_blank">源</a>)</li><li id="c655" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.focusin()</code>:将事件处理程序绑定到“focus in”JS事件(<a class="ae lz" href="https://api.jquery.com/focusin/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="d917" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.focusout()</code>:将事件处理程序绑定到“focus out”JS事件(<a class="ae lz" href="https://api.jquery.com/focusout/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="5ea3" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.select()</code>:将事件处理程序绑定到“select”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/select/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="d7dc" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.submit()</code>:将事件处理程序绑定到“submit”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/submit/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li></ul><blockquote class="my mz na"><p id="ebfc" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> →键盘事件</em></p></blockquote><p id="a94a" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">来源:<a class="ae lz" href="https://api.jquery.com/category/events/keyboard-events/" rel="noopener ugc nofollow" target="_blank">键盘事件</a></p><p id="b202" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">以下是jQuery提供的用于处理键盘事件的现成API</p><ul class=""><li id="f364" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.keydown()</code>:将事件处理程序绑定到“keydown”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/keydown/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="2771" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.keypress()</code>:将事件处理程序绑定到“keypress”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/keypress/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="be10" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.keyup()</code>:将一个事件处理程序绑定到“keyup”JS事件，或者在一个元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/keyup/" rel="noopener ugc nofollow" target="_blank">源</a>)</li></ul><blockquote class="my mz na"><p id="caeb" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> →鼠标事件</em></p></blockquote><p id="4c97" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">来源:<a class="ae lz" href="https://api.jquery.com/category/events/mouse-events/" rel="noopener ugc nofollow" target="_blank">鼠标事件</a></p><p id="bc0a" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">就事件处理而言，这就是jQuery开始大放异彩的地方。它提供了一大套现成的鼠标事件绑定器供开发人员使用。</p><ul class=""><li id="727e" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.click()</code>:将事件处理程序绑定到“click”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/click/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="4447" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.dblclick()</code>:将事件处理程序绑定到“dblclick”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/dblclick/" rel="noopener ugc nofollow" target="_blank"> source </a></li><li id="6e04" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.contextmenu()</code>:将事件处理程序绑定到“context menu”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/contextmenu/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="2547" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.mousemove()</code>:将事件处理程序绑定到“mousemove”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/mousemove/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="a565" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.mouseout()</code>:将事件处理程序绑定到“mouseout”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/mouseout/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="e0b1" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.mouseover()</code>:将事件处理程序绑定到“mouse over”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/mouseover/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="9f67" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.mouseup()</code>:将事件处理程序绑定到“mouseup”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/mouseup/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="201e" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.toggle()</code>:将事件处理程序绑定到“toggle”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/toggle-event/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="1e44" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.hover()</code>:将事件处理程序绑定到“hover”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/hover/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="a972" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.mousedown()</code>:将事件处理程序绑定到“mousedown”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/mousedown/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="bc22" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.mouseenter()</code>:将事件处理程序绑定到“mouse enter”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/mouseenter/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="b6ba" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">.mouseleave()</code>:将事件处理程序绑定到“mouseleave”JS事件，或者在元素上触发该事件(<a class="ae lz" href="https://api.jquery.com/mouseleave/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li></ul><blockquote class="my mz na"><p id="c7e6" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> →事件对象</em></p></blockquote><p id="29a2" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">来源:<a class="ae lz" href="https://api.jquery.com/category/events/event-object/" rel="noopener ugc nofollow" target="_blank">事件对象</a>，<a class="ae lz" href="https://learn.jquery.com/events/inside-event-handling-function/" rel="noopener ugc nofollow" target="_blank">内部事件处理函数</a></p><p id="5d59" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">jQuery中的事件处理程序接受事件对象作为第一个参数。该对象可以访问各种属性和修饰符。以下是一些比较常见的问题:</p><ul class=""><li id="31ff" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">event.currentTarget()</code>:事件处理冒泡阶段的当前DOM元素(<a class="ae lz" href="https://api.jquery.com/event.currentTarget/" rel="noopener ugc nofollow" target="_blank">源</a>)</li><li id="4613" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">event.target()</code>:发起事件的DOM元素(<a class="ae lz" href="https://api.jquery.com/event.target/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="4804" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">event.data()</code>:当当前正在执行的处理程序被绑定时，传递给处理程序的可选数据对象(<a class="ae lz" href="https://api.jquery.com/event.data/" rel="noopener ugc nofollow" target="_blank">源</a>)</li><li id="168b" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">event.preventDefault()</code>:如果调用该方法，将不会触发事件的默认动作(<a class="ae lz" href="https://api.jquery.com/event.preventDefault/" rel="noopener ugc nofollow" target="_blank"> source </a>)</li><li id="bc77" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">event.stopPropagation()</code>:防止事件在DOM树中冒泡，防止任何父处理程序被通知该事件(<a class="ae lz" href="https://api.jquery.com/event.stopPropagation/" rel="noopener ugc nofollow" target="_blank">源</a>)</li></ul><p id="d1c8" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">📕<strong class="kh hj">注</strong>:以下信息与比<code class="du mt mu mv mw b">1.6.4</code>更高版本的jQuery相关</p><blockquote class="my mz na"><p id="d5b4" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> →事件处理程序附件API </em></p></blockquote><p id="8296" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">来源:<a class="ae lz" href="https://api.jquery.com/on/" rel="noopener ugc nofollow" target="_blank"/><code class="du mt mu mv mw b"><a class="ae lz" href="https://api.jquery.com/on/" rel="noopener ugc nofollow" target="_blank">.on()</a></code><a class="ae lz" href="https://api.jquery.com/on/" rel="noopener ugc nofollow" target="_blank">事件处理程序附件API </a></p><p id="b45b" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">jQuery的现代版本提供了一个包罗万象的API来处理事件——T2。该API旨在用一个简单的动作绑定上面列出的几乎所有事件。根据官方文档，从jQuery - 1.7版本开始，这是绑定事件的推荐方式(<a class="ae lz" href="https://learn.jquery.com/events/handling-events/" rel="noopener ugc nofollow" target="_blank">根据官方文档</a>)。下面是一些语法示例:</p><pre class="mb mc md me fd ne mw nf ng aw nh bi"><span id="c370" class="mf ji hi mw b fi ni nj l nk nl">// Markup to be used for all examples that follow<br/>&lt;div class='outer'&gt;<br/>    &lt;span class='inner'&gt;Any content&lt;/span&gt;<br/>&lt;/div&gt;</span><span id="52ae" class="mf ji hi mw b fi nx nj l nk nl">// Exhibit A: the simple click handler, targeting the inner span<br/>$('.outer .inner').on('click', function(event) {<br/>    console.log(event);<br/>    alert( 'inner span was clicked!!' );<br/>});</span><span id="b2ea" class="mf ji hi mw b fi nx nj l nk nl">// Exhibit B: attaching separate handlers to different event types<br/>$('.outer .inner').on({<br/>    mouseenter: function() {<br/>        console.log( 'hovered over a span' );<br/>    },<br/>    mouseleave: function() {<br/>        console.log( 'mouse left a span' );    <br/>    },<br/>    click: function() {<br/>        console.log( 'clicked a span' );    <br/>    }<br/>});</span><span id="1932" class="mf ji hi mw b fi nx nj l nk nl">// Exhibit C: attaching the same handler to different event types<br/>$('.outer .inner').on('click', function() {<br/>    console.log( 'The span was either clicked or hovered on' );<br/>});</span><span id="d9fd" class="mf ji hi mw b fi nx nj l nk nl">// Exhibit D: Event delegation --&gt; binding events to elements that don't exist yet<br/>$('.outer .inner').on('click', '&lt;selector-of-element-that-dont-exist-yet&gt;', function() {<br/>    console.log( 'The element was clicked' );<br/>});</span></pre><blockquote class="my mz na"><p id="da3b" class="le lf ly kh b ki lt lg lh kk lu li lj nb lv ll lm nc lw lo lp nd lx lr ls ja hb bi translated"><em class="hi"> →其他事件处理程序附件API</em></p></blockquote><p id="e1d1" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated">来源:<a class="ae lz" href="https://api.jquery.com/category/events/event-handler-attachment/" rel="noopener ugc nofollow" target="_blank">事件处理程序附件</a></p><p id="7d45" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><code class="du mt mu mv mw b">.on()</code> API可以说是jQuery提供的最流行的API。除此之外，jQuery还有其他现成的接口，提供了一套有用的功能。以下是最常见的问题列表:</p><ul class=""><li id="87c1" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">one()</code>:为元素附加一个事件处理程序。每个事件类型的每个元素最多执行一次处理程序(<a class="ae lz" href="https://api.jquery.com/one/" rel="noopener ugc nofollow" target="_blank">源</a></li><li id="1da9" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">off()</code>:移除事件处理程序(<a class="ae lz" href="https://api.jquery.com/off/" rel="noopener ugc nofollow" target="_blank">源</a>)</li><li id="aa51" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><code class="du mt mu mv mw b">trigger()</code>:执行给定事件类型(<a class="ae lz" href="https://api.jquery.com/trigger/" rel="noopener ugc nofollow" target="_blank">源</a>)的匹配元素所附带的所有处理程序和行为</li></ul><h1 id="f471" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js lb ju jv jw lc jy jz ka ld kc kd ke bi translated">资源</h1><ul class=""><li id="889f" class="kf kg hi kh b ki kj kk kl km kn ko kp kq kr ja ks kt ku kv bi translated"><a class="ae lz" href="https://github.com/collections/front-end-javascript-frameworks" rel="noopener ugc nofollow" target="_blank">前端JS框架列表</a></li></ul><p id="f8d2" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj">做出反应</strong></p><ul class=""><li id="6028" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><a class="ae lz" href="https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/events/ReactBrowserEventEmitter.js" rel="noopener ugc nofollow" target="_blank">reactbrowsereventmitter</a></li><li id="7dde" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://github.com/facebook/react/blob/8a8d973d3cc5623676a84f87af66ef9259c3937c/packages/react-dom/src/client/ReactDOMComponent.js" rel="noopener ugc nofollow" target="_blank">反应堆组件</a></li><li id="240f" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://reactjs.org/docs/events.html#supported-events" rel="noopener ugc nofollow" target="_blank">合成事件</a></li><li id="29df" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/events/EventPluginHub.js" rel="noopener ugc nofollow" target="_blank"> EventPluginHub </a></li><li id="fd07" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://share.cocalc.com/share/a04c90b3eaea18961287b4f6b5c13a7df2d3f0f1/react/wstein/node_modules/react/lib/SimpleEventPlugin.js?viewer=share" rel="noopener ugc nofollow" target="_blank">简单事件插件</a></li><li id="b110" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://share.cocalc.com/share/a04c90b3eaea18961287b4f6b5c13a7df2d3f0f1/react/wstein/react-with-addons.js?viewer=share" rel="noopener ugc nofollow" target="_blank"> ChangeEventPlugin </a></li><li id="cee1" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/events/EventPropagators.js" rel="noopener ugc nofollow" target="_blank">事件传播器</a></li><li id="d965" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/events/EventPluginUtils.js" rel="noopener ugc nofollow" target="_blank">事件插件</a></li><li id="9092" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">对账算法</a></li><li id="b2f5" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://blog.logrocket.com/deep-dive-into-react-fiber-internals/" rel="noopener ugc nofollow" target="_blank">反应光纤架构</a></li></ul><p id="dd90" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj">苗条的</strong></p><ul class=""><li id="c941" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><a class="ae lz" href="https://svelte.dev/tutorial/basics" rel="noopener ugc nofollow" target="_blank">苗条官方教程</a></li><li id="9212" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://lihautan.com/compile-svelte-in-your-head-part-1/#adding-event-listeners" rel="noopener ugc nofollow" target="_blank">在你的头脑中编译苗条</a></li></ul><p id="3173" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj"> Vue </strong></p><ul class=""><li id="99d0" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><a class="ae lz" href="https://vuejs.org/v2/guide/events.html" rel="noopener ugc nofollow" target="_blank">事件处理</a></li><li id="9eda" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://vuejs.org/v2/guide/events.html#Event-Modifiers" rel="noopener ugc nofollow" target="_blank">事件修改器</a></li><li id="089f" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://vuejs.org/v2/guide/events.html#Key-Modifiers" rel="noopener ugc nofollow" target="_blank">键盘事件</a></li><li id="cf86" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://vuejs.org/v2/guide/components-custom-events.html" rel="noopener ugc nofollow" target="_blank">自定义事件</a></li></ul><p id="24d4" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj">有角度的</strong></p><ul class=""><li id="862e" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><a class="ae lz" href="https://angular.io/guide/event-binding" rel="noopener ugc nofollow" target="_blank">事件处理</a></li><li id="1169" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://angular.io/guide/event-binding-concepts" rel="noopener ugc nofollow" target="_blank">事件绑定概念</a></li></ul><p id="685b" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><strong class="kh hj"> jQuery </strong></p><ul class=""><li id="0393" class="kf kg hi kh b ki lt kk lu km nm ko nn kq no ja ks kt ku kv bi translated"><a class="ae lz" href="https://github.com/jquery/sizzle" rel="noopener ugc nofollow" target="_blank">咝咝声</a></li><li id="0f4b" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://api.jquery.com/category/events/browser-events/" rel="noopener ugc nofollow" target="_blank">浏览器事件</a></li><li id="7691" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://api.jquery.com/category/events/document-loading/" rel="noopener ugc nofollow" target="_blank">文件加载</a></li><li id="00e5" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://api.jquery.com/category/events/form-events/" rel="noopener ugc nofollow" target="_blank">表单事件</a></li><li id="d786" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://api.jquery.com/category/events/keyboard-events/" rel="noopener ugc nofollow" target="_blank">键盘事件</a></li><li id="cd9b" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://api.jquery.com/category/events/mouse-events/" rel="noopener ugc nofollow" target="_blank">鼠标事件</a></li><li id="baa7" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://api.jquery.com/category/events/event-object/" rel="noopener ugc nofollow" target="_blank">事件对象</a></li><li id="b602" class="kf kg hi kh b ki kw kk kx km ky ko kz kq la ja ks kt ku kv bi translated"><a class="ae lz" href="https://learn.jquery.com/events/inside-event-handling-function/" rel="noopener ugc nofollow" target="_blank">内部事件处理函数</a></li></ul></div><div class="ab cl np nq gp nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="hb hc hd he hf"><p id="8a45" class="pw-post-body-paragraph le lf hi kh b ki lt lg lh kk lu li lj km lv ll lm ko lw lo lp kq lx lr ls ja hb bi translated"><em class="ly">原发布于</em><a class="ae lz" href="https://nasidulislam.hashnode.dev/js-event-handling-deep-dive" rel="noopener ugc nofollow" target="_blank"><em class="ly">https://nasidulislam . hashnode . dev</em></a><em class="ly">。</em></p></div></div>    
</body>
</html>