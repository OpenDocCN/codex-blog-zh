<html>
<head>
<title>Clean Architecture in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中干净的架构</h1>
<blockquote>原文：<a href="https://medium.com/codex/clean-architecture-in-scala-41d1ab05a618?source=collection_archive---------3-----------------------#2022-03-28">https://medium.com/codex/clean-architecture-in-scala-41d1ab05a618?source=collection_archive---------3-----------------------#2022-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0ac8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，什么是干净的架构？罗伯特·c·马丁(鲍勃大叔)声称，尽管系统架构在细节上有所不同，但它们非常相似。六边形建筑和洋葱形建筑是比较流行的。这些架构将引导程序员开发具有以下特征的系统:</p><ul class=""><li id="60ee" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">独立于框架</li><li id="9a4c" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">可试验的</li><li id="bc94" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">独立于用户界面</li><li id="cb89" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">独立于数据库</li><li id="f498" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">独立于任何外部机构</li></ul><p id="0cd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在他的<a class="ae jr" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">博客</a>或者他的书<em class="js">清洁架构:软件结构和设计的工匠指南</em>中读到更多。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="8741" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">我们的风格</h1><p id="8527" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi ld translated">虽然每个人都期望一个架构提供一组确切的组件，并指示他们做什么，但是干净的架构是一个让我们修改和利用它的指南。这个示意图是我们干净的建筑风格。</p><figure class="ln lo lp lq fd lr er es paragraph-image"><div class="er es lm"><img src="../Images/c055d8f3ee9ead0066dcc1456ed8ffcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*VvEDFkd5-7crH_PHzw34Mg.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">我们干净的建筑</figcaption></figure><p id="f80b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，这和鲍勃叔叔的风格非常相似。它由四层组成，分别是企业层、应用层、适配器层和基础设施层。</p><p id="8255" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">包含领域实体和领域相关用例的企业层是应用层的底层。另一方面，示意图试图同时显示架构和请求流，因为域在流中不起作用，所以实体不是示意图的一部分。然而，黄框应该被认为是企业的领域，那么进入体系结构这一部分的任何对象都应该是已定义的实体或原始数据。把<a class="ae jr" href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="noopener ugc nofollow" target="_blank">数据传输对象(DTO) </a>和<a class="ae jr" href="https://en.wikipedia.org/wiki/Data_access_object" rel="noopener ugc nofollow" target="_blank">数据访问对象(DAO) </a>转换成这个区域边界的域对象，就是工厂的作用。每个外部接口和存储库可能都有自己的DTO或DAO，因此为每个接口和存储库创建一个适配器包是非常重要的。</p><figure class="ln lo lp lq fd lr er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es ly"><img src="../Images/76080b31c8b1ffed64f29a6d4e392e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7LkQDyDqLN3rRSrNYkETA.jpeg"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">鲍勃叔叔的干净建筑</figcaption></figure><h1 id="d289" class="ka kb hi bd kc kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx bi translated">Scala模板</h1><p id="c553" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi ld translated">在实现应用程序之前，我想创建一个模板。以下所有的结构和代码都可以在<a class="ae jr" href="https://github.com/SaeidDadkhah/clean-arch-example" rel="noopener ugc nofollow" target="_blank">我的GitHub库</a>中找到。随意制造问题和公关。</p><p id="e04d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此项目包含多个子项目。在这里，我将描述一下<code class="du mi mj mk ml b">./01_template</code>中的<code class="du mi mj mk ml b">template</code>项目。下图是该项目的包装。</p><figure class="ln lo lp lq fd lr er es paragraph-image"><div class="er es mm"><img src="../Images/58a4fcf49b1bb9bd6a6d315f3f149a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*pRljkChf83d41FWz2r05Ww.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">01.模板—包装</figcaption></figure><h1 id="0cfe" class="ka kb hi bd kc kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx bi translated">企业层</h1><p id="09bb" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi ld translated">构建一个应用程序需要一个起点，而<code class="du mi mj mk ml b">Application.scala</code>就是我们应用程序的起点。<code class="du mi mj mk ml b">domain</code>包是最重要的包，也是我们应用程序的核心，它将包含实体和企业规则。为了显示它与架构的关系，它是企业层中唯一的包。</p><h1 id="c1ff" class="ka kb hi bd kc kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx bi translated">应用层</h1><p id="eb62" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi ld translated">毫无疑问，程序员会在这一层投入相当多的逻辑和精力，所以在这里使用一些抽象是个好主意。应用层由<code class="du mi mj mk ml b">application</code>和<code class="du mi mj mk ml b">contract</code>包组成，<code class="du mi mj mk ml b">contract</code>包只包含抽象。<code class="du mi mj mk ml b">service</code>包是<code class="du mi mj mk ml b">contract</code>包中的一个包。所有用例的定义都将在这个包中，它们都应该继承<code class="du mi mj mk ml b">c.s.Service</code>类。下面是实现。</p><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="9fce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mi mj mk ml b">Service</code>抽象类定义了调用服务时我们应该期望什么。每个服务应该只有一个公共成员可以使用。服务的所有结果和响应都应该包装在一个容器类中，让我们以一种功能性的方式处理异常。<code class="du mi mj mk ml b">Try</code>和<code class="du mi mj mk ml b">Either</code>可能是我们的潜在选择，但它们有一个严重的缺点，那就是同步性。不使用任何外部框架和库的最佳选择是使用Scala的<code class="du mi mj mk ml b">Future</code>。因此每个服务都有一个方法<code class="du mi mj mk ml b">call</code>获取一个参数和一个<code class="du mi mj mk ml b">ExecutionContext</code>并返回一个<code class="du mi mj mk ml b">Future</code>对象。例如，我们可以像使用<code class="du mi mj mk ml b">checkUserService.call("Saeid")</code>一样使用<code class="du mi mj mk ml b">CheckUserService[String, Boolean]</code>的一个实例，并期待一个<code class="du mi mj mk ml b">Future[Boolean]</code>对象。</p><p id="962b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mi mj mk ml b">callback</code>包将包含几乎所有带有简单CRUD操作签名的实体的抽象回调类。我们将把所有服务的实现放在<code class="du mi mj mk ml b">application</code>包中。</p><h1 id="540f" class="ka kb hi bd kc kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx bi translated">适配器层</h1><p id="1e89" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi ld translated"><span class="l le lf lg bm lh li lj lk ll di"> E </span>企业和应用层将完成这项工作，但我们需要触发它们并存储副作用和结果。适配器层负责连接逻辑和基础设施。<code class="du mi mj mk ml b">entry</code>包，顾名思义，就是我们将外部接口连接到服务<strong class="ih hj"> <em class="js">(非用例)</em> </strong>的地方，我们可以使用<code class="du mi mj mk ml b">repository</code>包中的数据源。如果我们决定在某个时候更改数据库，它只会影响这里。如果新旧数据库都支持同一个连接器，比如说JDBC，即使在这里也不会有影响。因此这就是鲍勃大叔声称它是<strong class="ih hj"> <em class="js">独立于数据库</em> </strong>的原因。</p><h1 id="16cb" class="ka kb hi bd kc kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx bi translated">基础设施层和配置</h1><p id="a158" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi ld translated">现在简化模板很容易。我们需要将我们的应用程序连接到基础设施，并且我们只需要一组配置来完成这项工作。有趣的是，我直到现在才谈到框架，这就是为什么Bob叔叔声称它是独立于框架的<strong class="ih hj"><em class="js"/></strong><em class="js"/>和独立于UI的<em class="js">。</em></p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="6c52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请继续关注实现应用程序的下一篇文章。请随意查看GitHub库和未解决的问题。我希望你喜欢这个教程。谢谢你。</p></div></div>    
</body>
</html>