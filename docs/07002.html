<html>
<head>
<title>What are Abstract Data Flows and why should you use them?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是抽象数据流，为什么要使用它们？</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-are-abstract-data-flows-and-why-should-you-use-them-8a95cb330931?source=collection_archive---------6-----------------------#2022-05-24">https://medium.com/codex/what-are-abstract-data-flows-and-why-should-you-use-them-8a95cb330931?source=collection_archive---------6-----------------------#2022-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4ab4b603f7409fa93cbd7131a37fd7ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBs5J7GglGEpEfUQMttZVA.png"/></div></div></figure><h1 id="3be3" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">无需基础设施承诺的自动化</h1><p id="3c9d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">想象一下，如果您只需点击几下，就可以在您选择的任何基础设施上部署一个生产就绪的工业级数据平台<strong class="jq hj">，并轻松地在不同的基础设施之间切换。显然，这将大大降低您的开发成本。<a class="ae km" href="https://github.com/ticowiko/adf" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">【抽象数据流(ADF) </strong> </a>通过从根本上解耦2个问题来实现这一点:</strong></p><ol class=""><li id="7a55" class="kn ko hi jq b jr kp jv kq jz kr kd ks kh kt kl ku kv kw kx bi translated">我想如何处理我的数据？</li><li id="4b31" class="kn ko hi jq b jr ky jv kz jz la kd lb kh lc kl ku kv kw kx bi translated">我想怎么做？</li></ol><p id="1d5a" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">实际上，该框架只是将您的管道规范分成两个完全独立的部分:</p><ul class=""><li id="5cde" class="kn ko hi jq b jr kp jv kq jz kr kd ks kh kt kl lg kv kw kx bi translated">您的<strong class="jq hj">流配置</strong>表达了您的管道的功能细节(数据血统、元数据、聚合等)。).</li><li id="6643" class="kn ko hi jq b jr ky jv kz jz la kd lb kh lc kl lg kv kw kx bi translated">您的<strong class="jq hj">实现者配置</strong>，它包含实际的基础设施细节。可以实现<em class="lh">任何</em>流程配置。</li></ul><p id="ecce" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">ADF框架的强大之处在于，所有的<strong class="jq hj">实现者配置文件都是完全可互换的</strong>，允许最终用户部署基础设施、编排基础设施、对基础设施进行基准测试以及切换到另一个基础设施，所有这些都只需点击几下鼠标。让我们通过一个简单的例子来看看这是什么样子的。</p><h1 id="5864" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">这一切是如何运作的</h1><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/f29c8eaca4529d10a7de3e2837c94f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gITboJ9ic63Hy7JoIrZ6CQ.png"/></div></div></figure><h2 id="1b10" class="ln ir hi bd is lo lp lq iw lr ls lt ja jz lu lv je kd lw lx ji kh ly lz jm ma bi translated">流量配置</h2><p id="57c8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们要做的第一件事是编写我们的<strong class="jq hj">流配置文件</strong>。这描述了我们数据流的实际结构，特别是数据谱系和元数据，作为一系列相互关联的处理步骤。这是一个非常简单的配置，其中<code class="du mb mc md me b">light</code>和<code class="du mb mc md me b">heavy</code>层中的两个着陆步骤通过在<code class="du mb mc md me b">expose</code>层中的简单连接结合在一起:</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="dddc" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">注意，虽然每个处理步骤指向一个层名称(<code class="du mb mc md me b">light</code>、<code class="du mb mc md me b">heavy</code>和<code class="du mb mc md me b">expose</code>，但是这个名称实际上对应的是什么仍未确定。在这一点上，我们仍然是基础设施不可知的。在Web UI中(由一个<a class="ae km" href="https://github.com/ticowiko/adf_app" rel="noopener ugc nofollow" target="_blank">姊妹库</a>提供)，我们可以看到我们的流配置对应的是什么。为了更好地展示这个框架，我们在上面的例子中的流配置中增加了几个步骤:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/e6710b384145e9605089dec09c48d954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*5_r2ggnFwtU_OP80ILjL1w.png"/></div></figure><h2 id="cc8d" class="ln ir hi bd is lo lp lq iw lr ls lt ja jz lu lv je kd lw lx ji kh ly lz jm ma bi translated">处理功能</h2><p id="76ed" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在我有了一个与基础设施无关的数据流结构，我如何以一种与基础设施无关的方式定义我的处理需求呢？答案就在我的流配置中的每一步所指向的处理函数中。这些函数操纵<strong class="jq hj">抽象数据结构(ADS) </strong>，抽象数据结构是类似数据帧的对象，其实际处理细节尚未确定，直到我们选择一个实现者。例如，下面是我们在上面的流配置中提到的连接操作:</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><h2 id="b4f4" class="ln ir hi bd is lo lp lq iw lr ls lt ja jz lu lv je kd lw lx ji kh ly lz jm ma bi translated">实施者配置</h2><p id="5826" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们现在已经定义了我们的功能需求，但对我们的处理基础设施最终会是什么样子却没有一点头绪。为了实际运行我们的管道，我们现在需要将我们的流配置插入到我们选择的的<strong class="jq hj"> <em class="lh">任何</em>实现者配置中，指定每个层名称对应的内容。假设我们只想在本地机器上运行一个简单的测试，让我们的<code class="du mb mc md me b">light</code>层基于Pandas，我们的<code class="du mb mc md me b">heavy</code>层基于PySpark，我们的<code class="du mb mc md me b">expose</code>层基于SQLite。我们的实现者配置需要的唯一信息是我们选择的实现者</strong>的<strong class="jq hj">类、写入数据的<strong class="jq hj">根路径</strong>和<strong class="jq hj">层名称对应关系</strong>:</strong></p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="f239" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">既然框架已经有了它需要的所有信息，我们可以在命令行上或通过Web UI运行setup命令:</p><pre class="lj lk ll lm fd mi me mj mk aw ml bi"><span id="d4bb" class="ln ir hi me b fi mm mn l mo mp">adf-launcher.py implementer.yaml setup-implementer<br/>adf-launcher.py implementer.yaml setup-flows flows.yaml</span></pre><p id="d23a" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">这样做应该会修改我们的根数据目录，如下所示:</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="e100" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">实现者已经为每个处理步骤创建了一个目录，它期望在那里存储用于<code class="du mb mc md me b">Pandas</code>和<code class="du mb mc md me b">PySpark</code>层的CSV，以及用于<code class="du mb mc md me b">expose</code>层的<code class="du mb mc md me b">expose.db</code>文件。<code class="du mb mc md me b">state.db</code>文件是一个包含处理状态信息的sqlite数据库。框架唯一不能为我们做的是创建源数据，所以让我们继续以CSV文件的形式将一些样本数据复制到登陆步骤中，然后我们可以运行<strong class="jq hj"> orchestrator </strong>，再次使用命令行或web界面:</p><pre class="lj lk ll lm fd mi me mj mk aw ml bi"><span id="5c73" class="ln ir hi me b fi mm mn l mo mp">adf-launcher.py implementer.yaml orchestrate flows.yaml</span></pre><p id="38da" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">这样，我们可以看到我们的数据批沿着管道传输:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/23a5053bd854811310ee3b70e0ee2929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*K7z1NUYFHRYVaZk4lepVPw.png"/></div></figure><p id="8769" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">我们的目录内容应该变成这样:</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="7505" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">在登录步骤之外，我们可以看到正在创建CSV文件，其中包含已按要求处理的数据。因为最后一步是在<code class="du mb mc md me b">expose</code>层，我们可以在<code class="du mb mc md me b">expose.db</code>数据库中看到它的结果:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/38b666ee99f7a43941f24a29e8bc090d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJz4ak5-2yaVtsCBWQhWOw.png"/></div></div></figure><h2 id="5ec2" class="ln ir hi bd is lo lp lq iw lr ls lt ja jz lu lv je kd lw lx ji kh ly lz jm ma bi translated">切换到可伸缩的AWS实现者</h2><p id="9c90" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这很简单:实现者根据我们的层规范自动构建了一个数据平台，然后根据我们的功能需求编排它并处理我们的数据。但是数据平台本身有点乏味:它是一堆CSV和一个sqlite数据库。非常适合原型开发，但是不适合扩展。换句话说，我们现在想要在完全不同的架构上运行<strong class="jq hj">完全相同的流配置。</strong></p><p id="af09" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">ADF框架的强大之处在于它能够通过更改单个配置文件来操作这个开关:<strong class="jq hj">实现者配置文件</strong>。为了从根本上改变我们的基础设施，我们保留了相同的流配置文件和相同的处理功能，并且我们只将上面的实现者配置文件更改为:</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="b729" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">与本地实现者相比，这里发生了更多的事情，但并不多。特别是，除了指定层名和它们对应的具体基础设施之间的对应关系，我们还提供了规模信息。因此，我们已经将我们的<code class="du mb mc md me b">light</code>层映射到Lambda函数，用于使用Pandas的无服务器计算，将我们的<code class="du mb mc md me b">heavy</code>层映射到EMR集群，用于使用PySpark的分布式计算，将我们的<code class="du mb mc md me b">expose</code>层映射到红移数据库，以使我们的数据可以使用SQL消费。</p><p id="acf3" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">这一次，setup命令将根据规范创建每个AWS资源。它还将使用红移光谱连接基于EMR和红移的层，创建外部表以在两个数据层之间无缝转换数据。它还为所有新创建的资源创建了一个VPC，为每个资源创建了安全组，并创建了一整套附加资源，旨在提供一个全功能的工业级数据平台。所有这些都是在幕后完成的，最终用户只需为每个数据层提供他所需的规模。使用这个新的实现者运行orchestrator，我们应该看到我们的数据在AWS S3存储桶上沿着管道传输:</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="15e2" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">这一次，不是在<strong class="jq hj"> sqlite </strong>数据库上公开数据，而是在<strong class="jq hj">红移</strong>上提供数据:</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="3f1c" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">现在你知道了！只需切换一个配置文件，我们就可以在预先构建的基础架构上部署和运行完全相同的处理管道，我们可以轻松地根据自己的需要进行扩展。</p><h2 id="7ab1" class="ln ir hi bd is lo lp lq iw lr ls lt ja jz lu lv je kd lw lx ji kh ly lz jm ma bi translated">流控制</h2><p id="de11" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在这一点上，最重要的是基础设施无关的接口足够灵活，以适应我们希望表达的任何需求。为了实现这一点，ADF使用基于Python hook的方法让用户控制通过管道的数据流。提供的挂钩有:</p><ul class=""><li id="965c" class="kn ko hi jq b jr kp jv kq jz kr kd ks kh kt kl lg kv kw kx bi translated"><strong class="jq hj">批处理排序挂钩</strong>:定义下一组要运行的批处理id。<br/> <em class="lh">默认行为</em>:对于每个成功的批处理，创建一个具有相同批处理ID的下游批处理。</li><li id="ab3a" class="kn ko hi jq b jr ky jv kz jz la kd lb kh lc kl lg kv kw kx bi translated"><strong class="jq hj">数据加载器钩子</strong>:定义每一步要加载的输入数据。<br/> <em class="lh">默认行为</em>:对于给定的批次ID，加载上游步骤中该批次ID对应的数据。</li><li id="a9f0" class="kn ko hi jq b jr ky jv kz jz la kd lb kh lc kl lg kv kw kx bi translated"><strong class="jq hj">批次依赖挂钩</strong>:定义删除给定批次时，要删除哪些下游批次。<br/> <em class="lh">默认行为</em>:对于给定的批次ID，删除所有具有相同批次ID的下游批次。</li></ul><p id="26b4" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">当orchestrator启动处理作业时，这些挂钩提供了对其行为的完全控制。因此，您对数据流的控制力几乎没有限制。<strong class="jq hj"> <em class="lh">能码就能有！</em> </strong></p><h1 id="eac4" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">为什么这应该是您的新数据平台模式</h1><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/38904022bf3fa11f5d9fef3fad568013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNh-MFgAwUQNkHoYIRJiKw.png"/></div></div></figure><p id="e0dd" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">现代数据堆栈的宽度和深度一样大。ADF框架的目标是提供数据平台自动化的好处(便宜、快速和高质量的数据基础设施),而没有主要的缺点:被任何特定的基础设施所束缚。这种方法有许多优点:</p><ul class=""><li id="24d2" class="kn ko hi jq b jr kp jv kq jz kr kd ks kh kt kl lg kv kw kx bi translated"><strong class="jq hj">大量预先构建的基础设施</strong>:在几分钟内，用户就可以选择适合其用例的实施者，并开始部署基础设施和运行管道。</li><li id="5489" class="kn ko hi jq b jr ky jv kz jz la kd lb kh lc kl lg kv kw kx bi translated"><strong class="jq hj">共同数据平台开发</strong>:最终用户很少会开发自己的实现者。左拷贝许可保证了所有未来的ADF实现者也将是开源的。这意味着实施者将由社区开发，为最常见的基础设施用例(大容量实施者、流实施者、多云实施者等)提供更高质量的解决方案。)，而不是每个数据工程团队重新发明轮子。</li><li id="fc46" class="kn ko hi jq b jr ky jv kz jz la kd lb kh lc kl lg kv kw kx bi translated"><strong class="jq hj">减少对云的依赖</strong>:因为您对实现者的选择可以通过切换单个配置文件来实现，所以更改您的目标基础设施变得微不足道。这意味着您不仅可以切换您的数据平台正在使用的服务，甚至可以完全切换云，在几分钟内将您的整个数据平台从内部迁移到AWS、GCP、Azure、雪花以及其他任何地方。</li><li id="2296" class="kn ko hi jq b jr ky jv kz jz la kd lb kh lc kl lg kv kw kx bi translated"><strong class="jq hj">简化的开发体验</strong>:本地实现者是一个至关重要的工具，因为它允许管道的快速原型化和测试。管道结果甚至可以在研讨会期间与利益相关方“实时”验证，并在部署到云上之前即时修改以满足他们的需求，因为本地实施者只需几秒钟即可完成设置和运行。</li><li id="7610" class="kn ko hi jq b jr ky jv kz jz la kd lb kh lc kl lg kv kw kx bi translated"><strong class="jq hj">自动化数据治理</strong>:您的流配置包含了您轻松自动化数据治理所需的所有信息:您的数据血统和元数据。因为orchestrator使用这种流配置，所以可以有力地保证您的治理元数据将严格匹配您的实际处理。</li><li id="e35e" class="kn ko hi jq b jr ky jv kz jz la kd lb kh lc kl lg kv kw kx bi translated"><strong class="jq hj">以数据为中心的编排</strong>:基本的编排单元是一批数据，而不是抽象的运行ID。这意味着您的DAG定义和状态与处理和存储直接相关。作为交换，所有实现者将授予现成的数据版本和批量重置。</li></ul><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/eadb77b93b5edfc5b33f70a5642f638e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xzO8A957pRxnLKpSL3tjug.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">在您的数据堆栈中定位ADF</figcaption></figure><p id="ef65" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz ld kb kc kd le kf kg kh lf kj kk kl hb bi translated">从根本上说，ADF不是一个DAG工具:它是一个数据处理工具。当您定义DAG来定义管道结构时，ADF框架保证DAG中的每个节点都将系统地创建和持久化一批数据。通过在每个节点施加这种行为，框架可以为我们处理几乎所有的事情，并且可以在几乎任何平台上进行。通过比传统的orchestrator或scheduler更加专注，ADF框架可以大大降低开发成本，同时保证高质量的最终结果。</p><h1 id="78d4" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">链接</h1><ul class=""><li id="736e" class="kn ko hi jq b jr js jv jw jz my kd mz kh na kl lg kv kw kx bi translated"><a class="ae km" href="https://github.com/ticowiko/adf" rel="noopener ugc nofollow" target="_blank">核心ADF库</a>:包含核心ADF代码和配置文件和类API的详细文档。</li><li id="8e7f" class="kn ko hi jq b jr ky jv kz jz la kd lb kh lc kl lg kv kw kx bi translated">ADF Web UI存储库:包含Web UI姐妹存储库以及一个简单的入门教程。</li></ul></div></div>    
</body>
</html>