<html>
<head>
<title>What Makes A Programming Language Too Complicated?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是什么让编程语言过于复杂？</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-makes-a-programming-language-too-complicated-1f64e0172ac2?source=collection_archive---------1-----------------------#2020-08-04">https://medium.com/codex/what-makes-a-programming-language-too-complicated-1f64e0172ac2?source=collection_archive---------1-----------------------#2020-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/276db979f1a8181db2d4feb4a4a3c399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jbuZNWvqAY_RRy9L"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">由<a class="ae hv" href="https://unsplash.com/@jefflssantos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰佛森·桑多斯</a>在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="0a0f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编程语言最重要的一个方面是它的复杂性。太简单的语言通常被认为是不表达的和冗长的，而太复杂的语言很难学习并导致难以理解的代码库。因此，编程语言设计者最终不得不对复杂性采取立场。例如，简单性可以说是Go最重要的特性，而C++似乎增加了几乎所有流行的语言特性。</p><p id="a0d2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一种编程语言的感知复杂性不仅仅是它有多少种语言特性或者有多少种方法来完成同样的任务的函数。在这两个指标中，Rust接近C++，但语言复杂性并不是Rust的主要流行批评之一。虽然Rust通常被批评为难以学习和编写缓慢(这都是其内存管理模型的副作用)，但大多数对C++的批评都与功能过多或某个特定功能使程序不太清晰有关。Python和Rust一样，是一种非常有特色的语言，通常不认为它很复杂。这部分是因为它的目标用例；低级程序员比大多数Python开发人员更有理由关心简单性。然而，不考虑社区，Python也因为其语言设计比C++更复杂而受到更少的批评。</p><p id="715b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Rust和Python的复杂性比C++的危害更小，因为新特性的实现要小心得多，所以即使有多种方法来完成同一任务，其中一种方法显然更好。Rust尤其迫使开发者走上一条统一的道路，使用自己的模型。</p><p id="a604" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从<a class="ae hv" href="https://exercism.io" rel="noopener ugc nofollow" target="_blank">习题</a>中抽取以下问题:</p><blockquote class="jt ju jv"><p id="2c26" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">变位词是重新排列字母以形成一个新单词。给定一个单词和一个候选单词列表，选择给定单词的字谜子列表。</p><p id="8430" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><em class="hy">给定“listen”和类似“enlists”“Google”“inlets”“banana”的候选列表，程序应该返回一个包含“inlets”的列表。</em></p></blockquote><p id="8641" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最新的C++解决方案(只有相关的方法和一个助手)是:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="8c47" class="kj kk hy kf b fi kl km l kn ko">vector&lt;string&gt; anagram::matches (vector&lt;string&gt; candidates)<br/>{<br/>    vector&lt;string&gt; res;<br/><br/>    for (auto&amp; candidate: candidates)<br/>    {<br/>        string candidate_lower = candidate;<br/>        std::transform (candidate.begin(), candidate.end(), candidate_lower.begin(), ::tolower);<br/>        if(match(candidate_lower)) {<br/>            res.push_back(candidate);<br/>        }<br/>    }<br/><br/>    return res;<br/>}<br/>bool anagram::match (std::string word){<br/>    return is_permutation(input.begin(),input.end(),word.begin()) &amp;&amp; word.size() == length &amp;&amp; word != input;<br/>}</span></pre><p id="e08b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我看来，这是相当合理的，即使你是C++新手，这也是很容易理解的。</p><p id="9a17" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是顶级解决方案的相关方法(<code class="du kp kq kr kf b">is_anagram</code>与上面的<code class="du kp kq kr kf b">anagram::match</code>非常相似)</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="6893" class="kj kk hy kf b fi kl km l kn ko">std::vector&lt;std::string&gt; matches(std::vector&lt;std::string&gt; candidates) {<br/>    std::vector&lt;std::string&gt; matched;<br/>    std::copy_if(std::begin(candidates), std::end(candidates), std::back_inserter(matched), [this](auto candidate) { <br/>            std::string loweredCandidate;<br/>            std::transform(std::begin(candidate), std::end(candidate), std::back_inserter(loweredCandidate), ::tolower);<br/>            return is_anagram(this-&gt;m_str, loweredCandidate); <br/>    });<br/>    return matched;<br/>}</span></pre><p id="9e32" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它简短，简洁，难以理解。不过，我相当肯定作者不会用实际的代码库来写这篇文章。和往常一样，一旦理解了代码的各个部分，就很容易理解发生了什么，但是C++笨拙的迭代器和lambda实现意味着大多数C++开发人员避免使用它们，因此不能很快理解这些代码。这个问题的许多C++解决方案只对<code class="du kp kq kr kf b">std::is_permutation</code>使用迭代器，很少使用匿名函数。</p><p id="736a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">针对同一问题的顶级Rust解决方案是:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="c0e3" class="kj kk hy kf b fi kl km l kn ko">pub fn anagrams_for&lt;'a&gt;(word: &amp;str, candidates: &amp;'a [&amp;'a str]) -&gt; Vec&lt;&amp;'a str&gt; {<br/>  let word = word.to_lowercase();<br/>  let sorted_word = sort(&amp;word);<br/>  candidates<br/>    .iter()<br/>    .cloned()<br/>    .filter(|&amp;candidate| {<br/>      let can = candidate.to_lowercase();<br/>      sort(&amp;can) == sorted_word &amp;&amp; can != word<br/>    })<br/>    .collect::&lt;Vec&lt;&amp;'a str&gt;&gt;()<br/>}</span></pre><p id="63b6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个解决方案也使用迭代器/匿名函数，我点击的五六个解决方案中的每一个都是如此。迭代器和闭包在Rust中非常符合人体工程学；它们易于阅读，使得处理借用检查器有时更容易，而且最重要的是，迭代器通常比普通的循环更快。</p><p id="9fa2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">针对is_anagram(移除了注释)的顶级Python解决方案是:</p><pre class="ka kb kc kd fd ke kf kg kh aw ki bi"><span id="4770" class="kj kk hy kf b fi kl km l kn ko">def detect_anagrams(original, candidates):<br/>	return [candidate for candidate in candidates if is_an_anagram(original, candidate)]<br/><br/>def is_an_anagram(original, candidate):<br/>	original = original.lower()<br/>	candidate = candidate.lower()<br/>	return original != candidate and sorted(original) == sorted(candidate)</span></pre><p id="4afe" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">几乎每个Python解决方案都使用相同的过程。当然，Python隐藏了大部分复杂性。</p><p id="be10" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些<code class="du kp kq kr kf b">is_anagram</code>解决方案展示了每种语言的一些重要方面。虽然C++有一个简短的方法来解决这个问题，但是几乎没有人使用理解它所需要的特性，即迭代器。出于这个原因，大多数C++开发人员会选择主要使用普通的For循环来解决is_anagram。</p><p id="f9d1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一方面，Rust也有迭代器，几乎每个人都用它们来解决问题。Python有更多的方法来解决问题，但几乎每个人都只是使用列表理解。</p><p id="aa93" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一方面，有像C和Go这样的语言，它们强调简单胜过其他任何东西。围棋只有一种解决问题的方法；要做出一个对其他围棋开发者来说不透明的解决方案，需要进行有意的混淆。</p><p id="88ea" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让一门编程语言变得太复杂的不是它拥有的功能数量，而是这种语言拥有但人们没有使用的功能数量。</p><blockquote class="jt ju jv"><p id="0703" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><em class="hy">在C++中，有一种更小、更简洁的语言正在努力发展。——比雅尼·斯特劳斯特鲁普，C++的创始人</em></p></blockquote></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="8119" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">原载于2020年8月4日</em><a class="ae hv" href="https://mkhan45.github.io/2020/08/04/What-makes-a-programming-language-too-complicated.html" rel="noopener ugc nofollow" target="_blank"><em class="jw">https://mkhan 45 . github . io</em></a><em class="jw">。</em></p></div></div>    
</body>
</html>