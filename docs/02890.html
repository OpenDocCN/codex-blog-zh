<html>
<head>
<title>Web design patterns — SSR, SSG, and SPA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网页设计模式——SSR、SSG和SPA</h1>
<blockquote>原文：<a href="https://medium.com/codex/web-design-patterns-ssr-ssg-and-spa-fadad7673dfe?source=collection_archive---------0-----------------------#2021-08-10">https://medium.com/codex/web-design-patterns-ssr-ssg-and-spa-fadad7673dfe?source=collection_archive---------0-----------------------#2021-08-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4d9d6e95e5344eb193690bc33ebce8f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jENCl58kohUgigFq"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">马库斯·斯皮斯克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="397f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现代web开发有时看起来很复杂。SSR、SSG和SPA这些术语通常出现在绝大多数内容中。当我第一次听到这些名字时，我确实很困惑。那些是什么？用哪个？什么时候选择一个而不是另一个？同一个app可以用多种模式吗？我将为你分解这些问题。希望在本文结束时，您将对它们有更好的理解，并有更好的能力为您的下一个项目做出更好的架构决策。</p><h1 id="6899" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">服务器端渲染</h1><p id="1732" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在SSR中，当网页被请求时，它被呈现在服务器上，提供给客户机，最后由客户机呈现。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/76baa9c9970803011fa7a94e90770258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfxPb1S-oXM49yIS8HLHuQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:<a class="ae iu" href="https://www.blog.duomly.com/client-side-rendering-vs-server-side-rendering-vs-prerendering/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/client-side-rendering-vs-server-side-rendering-vs-prerender/</a></figcaption></figure><p id="f2b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这为什么有用？想象一个模板系统，比如Django模板系统，其中有如下所示的动态数据。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="7978" class="lg ju hi lc b fi lh li l lj lk">Hello {{user.name}}!</span></pre><p id="2b06" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用SSR，HTML的动态内容在<strong class="ix hj">运行时</strong>根据服务器状态进行评估，并返回给客户端。所以发送给用户的HTML实际上是:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="cac2" class="lg ju hi lc b fi lh li l lj lk">Hello John!</span></pre><p id="739d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">浏览器(客户端)只需将页面呈现到DOM中，瞧，这就是页面。</p><h1 id="9aea" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">SSG(静态现场发电)</h1><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/cbe7e14d970b4a29ba1e47ecca09fddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnrcYDCjuFw2hIx_iPY06g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:<a class="ae iu" href="https://www.blog.duomly.com/client-side-rendering-vs-server-side-rendering-vs-prerendering/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/client-side-rendering-vs-server-side-rendering-vs-prerendering/</a></figcaption></figure><p id="6195" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">SSG与SSR有相似之处。页面也在服务器中生成，<em class="ll">但是，</em>页面在<strong class="ix hj">构建时</strong>呈现。因此，页面已经呈现在服务器上，等待提供给客户端，而不是在收到请求时在服务器上呈现页面。我将讨论这种方法的优点和缺点，并在下面进一步将其与SSR进行比较。</p><h1 id="51c6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">单页应用程序</h1><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/b73f82f056ed51de1318495a9a5e8876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36IFEjGt4C6DsnFY-uW-yw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:<a class="ae iu" href="https://www.blog.duomly.com/client-side-rendering-vs-server-side-rendering-vs-prerendering/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/client-side-rendering-vs-server-side-rendering-vs-pre rendering/</a></figcaption></figure><p id="0fa3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与前两种方法相比，这种方法相对较新。这是过去二十年来互联网、软件和硬件行业快速发展的结果。通过SPA，服务器为用户提供了一个<strong class="ix hj">空HTML </strong>页面和<strong class="ix hj"> Javascript </strong>。后者是奇迹发生的地方。当浏览器收到HTML + Javascript时，它会加载Javascript。一旦加载完毕，JS就会发生，并通过DOM中的一组操作将必要的组件呈现给页面。然后，路由由浏览器本身处理，而不会影响服务器。这通常是通过前端框架(或库)完成的，如React、Vue或Angular。</p><h1 id="11ad" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">服务器端渲染(SSR和SSG)与客户端渲染(SPA)</h1><p id="64b5" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><em class="ll">注:在本节中，当我提到SSR时，我指的是SSR和SSG，CSR指的是SPA。</em></p><ul class=""><li id="5b18" class="lm ln hi ix b iy iz jc jd jg lo jk lp jo lq js lr ls lt lu bi translated"><strong class="ix hj"> SSR允许更好的SEO </strong>(搜索引擎优化)因为内容不需要像CSR中那样由Javascript加载，所以搜索引擎的网络爬虫可以直接解析信息。</li><li id="a35c" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated"><strong class="ix hj"> SSR更适合慢速连接</strong>，因为HTML会立即提供，而在CSR中，用户会看到一个空白页面，直到加载Javascript并呈现页面内容。</li><li id="2cad" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated"><strong class="ix hj"> SSR允许查看禁用Javascript的内容</strong>。我知道这听起来很奇怪，但是，用户可以有意无意地禁用它。参见此<a class="ae iu" href="https://kryogenix.org/code/browser/everyonehasjs.html" rel="noopener ugc nofollow" target="_blank">链接</a>，此处揭露了其中一些情况。</li><li id="1e02" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated"><strong class="ix hj"> SSR首次加载通常更快</strong>，因为它不需要像CSR那样在Javascript包中获取整个网站(可以在CSR中进行一些性能优化以减少这种负载，如动态导入)。</li><li id="0d84" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated"><strong class="ix hj"> CSR在第一次加载后速度更快</strong>，因为没有服务器请求改变页面，这使得它快得惊人。</li><li id="ca91" class="lm ln hi ix b iy lv jc lw jg lx jk ly jo lz js lr ls lt lu bi translated"><strong class="ix hj"> CSR提供了更好的UX(用户体验)</strong>因为它给页面带来了原生应用的感觉。</li></ul><h1 id="b7ec" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">SSR vs SSG</h1><p id="7958" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这两者的区别在于，在SSR中，服务器需要在将页面发送给用户之前渲染页面(在<strong class="ix hj">运行时</strong>渲染)，而在SSG中这是不必要的，因为这是在<strong class="ix hj">构建时</strong>完成的。你可能会觉得“那我到底为什么要用SSR呢？”。很简单:大多数网站通常都有动态的、有状态的数据(例如:用户登录时navbar上的用户电子邮件/徽标)。这意味着我们不能用这些数据在构建时预渲染模板，所以让SSG拥有这些数据的唯一方法是通过Javascript导入(这将违背SSG的核心目的)。</p><h1 id="991c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么时候用什么？</h1><p id="b4a4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这三种方法各有利弊。总的来说没有更好的选择了。您可以在同一个项目中使用所有这三种方法。在这一节，我会给你一些实际案例的例子。</p><h2 id="3139" class="lg ju hi bd jv ma mb mc jz md me mf kd jg mg mh kh jk mi mj kl jo mk ml kp mm bi translated">文档网站</h2><p id="f2e6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">假设您正在构建React的文档。你想在里面放什么？当然,<strong class="ix hj">可访问性</strong>对广大受众，包括网速慢的用户和禁用事件javascript的用户。<strong class="ix hj"> SEO </strong>也是一个问题(当用户搜索与React相关的东西时，你会希望用户点击文档)。有了这个，我们可以把范围缩小到SSR或者SSG。选哪个？<strong class="ix hj">我会选SSG </strong>。文档没有动态内容，因此根据请求在服务器上呈现它们既多余又慢。有了SSG，我们可以快速将内容交付给客户。</p><p id="5443" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ll">补充说明:React确实使用SSG作为他们的文档(他们使用Gastby)。</em></p><h2 id="3a70" class="lg ju hi bd jv ma mb mc jz md me mf kd jg mg mh kh jk mi mj kl jo mk ml kp mm bi translated">博客</h2><p id="d808" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">博客有定期插入的数据。SEO和可访问性都是一个成功博客的必要条件。因此，我们将在SSR和SSG之间做出决定。这一次，<strong class="ix hj">我会选择SSR </strong>。这是因为我们经常插入动态数据，我们希望为用户提供最新的数据。</p><h2 id="51ed" class="lg ju hi bd jv ma mb mc jz md me mf kd jg mg mh kh jk mi mj kl jo mk ml kp mm bi translated">客户关系经理</h2><p id="a2a7" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">CRM有不同的要求。<strong class="ix hj"> SEO不是问题</strong>，因为大多数页面都在登录之后，因此搜索引擎无法到达那里。用户通常在一个稳定的环境中访问CRM(通常在办公室，有很好的网速和一台电脑)。因此，使用<strong class="ix hj"> SPA将是我的选择</strong>。它将提供一种用户会喜欢的原生应用程序的感觉。请注意，我们可以在同一个项目中使用其他渲染方法。例如，我们可以把SSG放在登录和常见问题页面上。</p><h1 id="27aa" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">最后的想法</h1><p id="e1ba" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">暴露的技术是现代网络的日常基础。对它们的深刻理解有助于开发人员做出更好的架构决策，为最终用户提供更好的体验并创造更好的价值，这是我们的最终目标。</p><p id="ad52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望这篇文章有助于理解这些概念。有任何问题，随时通过LinkedIn联系我！</p></div></div>    
</body>
</html>