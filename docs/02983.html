<html>
<head>
<title>Parallel Programming in Python — Lesson 3. Synchronization primitives</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的并行编程——第3课。同步原语</h1>
<blockquote>原文：<a href="https://medium.com/codex/parallel-programming-in-python-lesson-3-synchronization-primitives-78ac09befc43?source=collection_archive---------14-----------------------#2021-08-13">https://medium.com/codex/parallel-programming-in-python-lesson-3-synchronization-primitives-78ac09befc43?source=collection_archive---------14-----------------------#2021-08-13</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><figure class="hi hj fa fc hk hl es et paragraph-image"><div role="button" tabindex="0" class="hm hn di ho bf hp"><div class="es et hh"><img src="../Images/e528ebd9f3ea1a80ff179c57af1bbe8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpEYnHZPiK7cpnFloHeusQ.jpeg"/></div></div></figure><div class=""/><p id="bb55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">这是系列课程的第三部分，涵盖了Python编程语言为并行编程提供的各种工具以及使用每种工具的动机。在之前的课程中，我们探索了<em class="jp">事件驱动</em>设计的应用需求，并学习了如何区分真正需要并行代码的需求(例如通过多线程)。然后，我们详细研究了Python线程工具。在本课中，我们将继续探索同步的应用需求(线程之间)以及Python对同步的支持。</p><p id="a7a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">本课章节:</em></p><ol class=""><li id="55bb" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">“生产者/消费者”——问题领域</li><li id="9921" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">(代码的)关键部分</li><li id="10bc" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">锁:基本的同步原语</li><li id="3201" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">条件变量</li><li id="5203" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">事件</li><li id="8a8f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">封装消息</li><li id="6ea2" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">信息排队</li><li id="50d9" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">什么时候用？</li><li id="1459" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">发布/订阅</li><li id="6510" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">套接字I/O作为同步原语</li><li id="ab5f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">附加同步原语</li><li id="58c4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">作业:尾部服务器</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="48db" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">1.“生产者/消费者”——问题领域</h2><p id="7d02" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated"><em class="jp">问题:</em>信息以离散的<em class="jp">“消息”</em>流的形式从其来源发出，目标是在指定端显示(或其他处理)，要求紧密同步:(1)消息以正确的顺序到达，以及(2)消息不会在途中丢失。</p><p id="c6f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">解决方案指南:</em>这个<em class="jp">面向对象的</em>解决方案区分了两个对象类:<em class="jp">生产者</em>(一个或多个类和对象)专门负责<em class="jp">生产</em>和<em class="jp">消费者</em>(一个或多个类和对象)专门负责<em class="jp">消费。</em>(我们尽量不要把这两种功能混在一起。我们不希望同一个对象既生产又消费，除了可以理解的例外，比如acknowledge)。将功能封装在不同的类中使它们相对简单，将设计简化为管理它们之间的通信。事件驱动的设计被邀请，为了<em class="jp">把</em>消费者和生产者分开(反之亦然)。生产者制造数据并根据某种协议发送出去，消费者消费现成的数据，(根据相同的协议)。尽管这里很少要求同时性(生产者和消费者在完全相同的时间执行各自的工作)，但是<em class="jp">并行</em>是！如果我们希望将公共资源的生产和消费分离到不同的对象，尽可能地松散耦合，那么每个对象都必须以不同的方式发送——一端是生产循环，另一端是消费循环——设计挑战就简化为<em class="jp">同步</em>两个(或更多)循环。</p><p id="5cd8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">我们从原型和“老式”的解决方案开始:多线程。(稍后，我们将考虑通过“合作”编程来减少多线程开销的更现代的解决方案)。</p><p id="4ed6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">为了简单起见，我们将我们的示例限制为一个生产者和一个消费者。(多生产者/消费者解决方案自然更复杂，但不会引入完全不同的设计习语)。生产者每两秒发出列举的文本消息<em class="jp">，</em>由消费者显示，希望以相同的顺序。启动器原型使用一个<em class="jp">全局变量</em>来存储当前消息。(不可否认，这不是最佳实践，但教科书中的例子总是这样开始的……)。显然，生产者和消费者生活在不同的线程上。</p><p id="406c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">这里是Python (3.9)的一个入门原型，后面是注释和示例输出:</em></p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="5ab4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注(对应评论号):</em></p><ol class=""><li id="95d1" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">当前消息的全局容器。</li><li id="f43c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者类遵循与前面课程中举例说明的线程类相同的模式。(详见第二课第一个例子)。</li><li id="3d02" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者每两秒发出一条枚举消息(覆盖全局变量)。</li><li id="1f50" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">作为专有协议的一部分，生产者使用全局消息，也作为消费者停止的指令。这样的捷径在交流中很常见。另一种方法是为此目的指定另一个全局变量(布尔值)。</li><li id="b86f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">制片人还没起床。(由仍然为空的消息指示)。(要做的是:用一个合适的解决方案取代这种耗费CPU资源的解决方案。程序可能会毫无理由地每秒钟进入和退出循环数千次。睡眠不是一个选项，因为它会扰乱两秒钟的速率)。</li><li id="1768" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">协议的消费者一方。显示“停止”的消息被解释为退出消耗循环的指令(不显示)。</li><li id="163d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">它的工作完成后，消费者打印出一个最终消息，这样我们就可以验证测试程序了。</li><li id="f8be" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序创建消费者和生产者，并启动它们。(在这个非同步原型中，启动的顺序很重要)。然后等待20秒钟(这样可以传递10条消息，每两秒钟一条)。</li><li id="f1be" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序向制作人发出停止的信号。(没有必要示意消费者停下来。这个已经由制作人负责了)。</li><li id="b6a0" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序加入<em class="jp">消费者</em>，因为它是最后一个完成的线程。</li></ol><p id="4cd1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:</em></p><pre class="ll lm ln lo fe lr ls lt lu aw lv bi"><span id="dd20" class="kl km hu ls b fj lw lx l ly lz">Round 1 <br/>Round 1 <br/>Round 2 <br/>Round 4 <br/>Round 4 <br/>Round 6 <br/>Round 7 <br/>Round 8 <br/>Round 9 <br/>Round 9 <br/>Round 10 <br/>[End of input]</span></pre><p id="1453" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">哎呀！输出还有一些需要改进的地方…很明显，这个设计一定是缺少了一些关于问题领域的基本东西！</p><p id="8de6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">我们可以很容易地证明这种设计的错误前提，下面的例子介绍了对消费者逻辑的简单改进。(它仍然没有解决问题，但它给出了其来源的线索)。</p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="1199" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">注释:<br/> </em> 1。这一次，我们<em class="jp">捕获了此时的状态</em>(在局部变量“message”中)。对“消息”的进一步引用检索捕获的状态。(相反，在最初的设计中，如果全局变量在之间<em class="jp">发生变化，那么每次对全局“theMessage”的引用都会检索同一个对象当时的状态，从而产生不一致的值——就我们所见，它确实发生了变化，而且至少发生了三次——参见上面输出中的missing和double项)。</em></p><p id="cee6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">为什么会这样呢？程序化<em class="jp">功能</em>是按照书写的顺序实现的一系列功能。好消息是，这种行为在函数调用级别(也称为“线程”)得到了保证，就像我们习惯的那样。坏消息是，这在<em class="jp">程序级别上是没有保证的！</em>(或者计算机水平，就此而言)。操作系统可以在任何合适的时间点自由地持有线程(通常是在阻塞I/O时，但并不仅限于此)，并将对CPU的控制权交给另一个线程。(在多核平台中，您可以<em class="jp">将您的线程与特定的内核</em>关联，但即使这样也不能保证对它的独占访问)。因此，很有可能(也很有可能)，操作系统会释放生产者来执行两个表达式(确切地说，是从它们编译而来的二十几个机器指令)，保持它，释放消费者来执行一个表达式，保持它，将控制传递给另一个线程，等等。</p><p id="e370" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">士气:</em>不仅不能保证你线程中的指令会在其他编写的<em class="jp">中执行，在计算机层面上，</em>可能会出现完全相反的情况。多线程设计必须从认识到线程在世界上并不孤单开始！现在应该很明显，这里应该避免一些编程实践。特别是，在并行编程中，通过<em class="jp">未受保护的</em>全局变量进行通信(这是一个快速而肮脏的编程技巧),会招致灾难！虽然对全局内存的引用有时是不可避免的(如在与<em class="jp">内存映射设备</em>通信的情况下)，但不保护对它的<em class="jp">访问</em>是糟糕的编程实践。(一般来说，没有什么糟糕的编程实践是<em class="jp">并行性</em>所独有的。并行编程有一个令人讨厌的习惯，那就是强调糟糕的编程实践，这种实践在其他地方可能会以某种方式逃脱惩罚……)</p><p id="4ae6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">我们现在将讨论解决保护公共资源问题的各种方法，这些方法都可以归结为下列方法之一:</p><ol class=""><li id="f45c" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">为了<em class="jp">保护</em>(访问)全局资源。</li><li id="fc6c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">完全避免全球资源媒介(通过其他媒介交流)。</li></ol><p id="c3de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:</em></p><pre class="ll lm ln lo fe lr ls lt lu aw lv bi"><span id="9d39" class="kl km hu ls b fj lw lx l ly lz">Round 1 <br/>Round 2 <br/>Round 3 <br/>Round 3 <br/>Round 5 <br/>Round 6 <br/>Round 7 <br/>Round 8 <br/>Round 9 <br/>Round 10 <br/>[End of input]</span></pre><p id="26ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">问题:</em>对公共数据的访问——消费者认为是自己的输入，生产者认为是自己的输出——不是<em class="jp">同步的</em>,这就产生了所谓的<em class="jp">竞争条件:</em>双方都在争夺相同的资源，从而导致随机结果。(取决于哪个马头碰巧第一个冲过终点线——“por una cabeza”)。具体来说，这里有三种出错的方式:</p><ol class=""><li id="0398" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">消息在被(使用者)处理时可能会(由生产者)更改。</li><li id="47f4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者可能会错过新消息(由于过早地轮询其容器)，从而重复旧消息。</li><li id="c3a9" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者可能会跳到下一条消息(等待时间有点长)。</li></ol><p id="d435" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">为什么这个例子会引入竞争条件，而不像上一课的“文件监视器”例子？嗯，另一个例子是定制的，以避免竞争条件，使它简单(但不太现实…)</p><ol class=""><li id="7c31" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">我们给了文件监视器足够的时间来享受它的输入(平均两次半的探测——每次两秒，一条消息保持完整五秒)。</li><li id="109e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">文件监视器没有打开输入的内容。它只是注意到了它的变化这一事实。</li></ol><p id="0fb6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">在这样的有利条件下，很难输！但是，现实世界中可靠的生产者/消费者架构需要<em class="jp">同步</em>，这将在下面讨论</p></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="7c37" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">2.(代码的)关键部分</h2><p id="d4aa" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">让我们用一个<em class="jp">负面需求来面对这个问题:</em>保持公共数据(我们的消息)的完整性和真实性，需要<em class="jp">来防止数据在还没有准备好的时候就被使用。</em>具体来说:</p><ul class=""><li id="80e7" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ma jw jx jy bi translated">在产生下一个输入时阻止消费者(访问其输入)。</li><li id="c0d4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">当生产者的最新产出被消耗时，阻止生产者发布其产出。</li></ul><p id="eae2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">为什么含糊不清？为什么这么复杂？我们不能只保存数据<em class="jp">吗？数据是无生命的物质，可以被程序操纵。在过程化编程中，人们不能将责任分配给数据(在并行环境中，原子整数是个例外，它太简单了，在这里帮不上什么忙)。我们只能(1)找到负责数据的相关程序(一系列功能，等待实现),以及(2)当它们可能干扰(对等线程的并行展开)时，阻止它们执行！在这个解决方案中，我们有两个必须遵守的关键过程:一个在生产者内部，另一个在消费者内部。这种过程被称为临界段(代码的临界段，根据请求保存)。</em></p><p id="535e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">临界区是根据从外部确定的条件<em class="jp">可以持有的功能中的一系列能力。(与内部确定的条件相反，例如<em class="jp"> if </em>、<em class="jp"> while </em>等。)</em></p><p id="c51b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">你可能熟悉临界区<em class="jp">同步原语</em>(Python不支持)。它确实有两种方法:进入临界区和退出临界区。顾名思义，这两个函数调用界定了临界区。</p><p id="ad2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">在程序设计中，同步可以简化为以下设计决策:</p><ol class=""><li id="0e2f" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">以识别不同的关键部分。</li><li id="4568" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">来选择支撑它们的条件。(通常是标准库中的现成工具)。(如果您需要，没有人会阻止您基于这些原语设计更智能的同步机制。但是想出完全新颖的东西是不太可能的，因为这些设施与操作系统和硬件密切相关，超出了普通程序员的能力范围。</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="ead5" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">3.锁:基本的同步原语</h2><p id="1154" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">Python <em class="jp">锁</em>(在其他语言和平台中以“互斥”、“临界区”、“二进制信号量”等名称调用)是最基本的同步原语。它很少单独使用(我们很快就会发现)，并且是我们稍后将探讨的其他同步原语的基础。这里，我们将使用一个锁来界定我们的两个关键部分(生产者网络生产和消费者网络消费)。</p><p id="ec6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">一个锁响应<em class="jp">获取</em>和<em class="jp">释放</em>请求。通过<em class="jp">获取</em>，一个线程请求进入临界区的独占权限。自然地，这个权利只会在还没有被给予其他人的情况下被给予请求线程！</p><ul class=""><li id="fd75" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ma jw jx jy bi translated">当不是这种情况时(另一个线程已经获得了锁，并且现在正在临界区的深处进行)，请求线程被阻塞(通过调用<em class="jp"> acquire </em>，其中<em class="jp">没有返回</em>给它)并且被排队。</li><li id="3493" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">当当前线程<em class="jp">释放</em>锁时，下一个挂起的线程被提取，现在持有锁并可以自由进入临界区(其对<em class="jp"> acquire </em>的挂起调用最终返回)。</li><li id="5c15" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">当然，在获取一个空闲锁的小例子中，对<em class="jp"> acquire </em>的调用会立即返回，线程可以自由地继续执行(可能会阻塞其他可能出现在中间的线程)。</li></ul><p id="77ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">这是一个重构的入门原型，后面是注释和输出示例:</em></p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="f71f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="7acb" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">除了<em class="jp">线程</em>之外，<em class="jp">线程</em>内置库还包括一系列有用的线程相关同步原语。</li><li id="b13d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">锁是一个全局对象，因为它保存了生产者和消费者的公共状态。默认情况下，它是初始化的。(一个典型的错误，每个有自尊的实时程序员都必须经历的一种成人礼，就是试图用两个<em class="jp">本地</em>锁来同步消费者和生产者。这些锁中的每一个都在保护自己的虚拟资源，但肯定不是公共的物理资源！)</li><li id="bbf9" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">with块定义了生成器端的临界区。Lock是一个“上下文管理器”,这赋予它在进入和退出块时添加一些动作的特权。实际上，锁是在进入with块时获得的，在退出with块时被释放。</li><li id="dafd" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">另一个<em class="jp">和</em>模块定义了用户侧的关键部分。</li><li id="437a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">空白消息被忽略(生产者尚未准备好)。(要做的事情:修复这个占用大量CPU资源的工作区)。</li><li id="ffd7" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序不受生产者/消费者协议改进的影响。</li></ol><p id="c467" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:</em></p><pre class="ll lm ln lo fe lr ls lt lu aw lv bi"><span id="cb8a" class="kl km hu ls b fj lw lx l ly lz">Round 1 <br/>Round 2 <br/>Round 3 <br/>Round 3 <br/>Round 5 <br/>Round 5 <br/>Round 6 <br/>Round 8 <br/>Round 8 <br/>Round 10 <br/>Round 10 <br/>[End of input]</span></pre><p id="91fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">哎呀！还没完呢！</p><p id="ee8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">问题:</em>在这个例子中，锁确实保证了临界区不会交错:生产者在消费者检索消息时不会干涉，而消费者在生产者准备消息时也不会干涉。但是这仍然留下了两个必须注意的竞争条件:</p><ol class=""><li id="a5f2" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">消费者在生产者之前重新获得锁(再次接收旧消息)！</li><li id="cadf" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者在消费者之前重新获得锁(并且当前消息丢失)！</li></ol><p id="22cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">解决方案:</em>协议应具有<em class="jp">确认</em>(简称“ack”)。生产者应仅在消费者确认处理消息(即发出ack信号)时进入临界区。这最终解决了剩余的竞争条件。</p><p id="1393" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">这是一个重构的原型，后面是注释和示例输出:</em></p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="df88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="4e7d" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">另一个全局变量:布尔ack。</li><li id="19f5" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">只要使用者没有确认处理挂起的消息，生产者就会避开临界区。(要做的事情:修复这个占用大量CPU资源的工作区)。</li><li id="995f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">它的工作完成后，生产者关闭确认。球现在在消费者的领域。</li><li id="042a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">只要消费者自己的ack仍然未决，消费者就避开临界区。(制作人还没完)。(要做的事情:修复这个占用大量CPU资源的工作区)。</li><li id="0d1f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">避免空消息(生产者尚未准备好)。(要做的事情:修复这个占用大量CPU资源的工作区)。</li><li id="cc7e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">它的工作完成后，消费者承认生产者继续进行，但不是在两者都延迟两秒钟之前。(在这个具体配置上，是消费者定了步调！)</li><li id="e62f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序不受协议变化的影响。</li></ol><p id="b679" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:</em></p><pre class="ll lm ln lo fe lr ls lt lu aw lv bi"><span id="d02d" class="kl km hu ls b fj lw lx l ly lz">Round 1 <br/>Round 2 <br/>Round 3 <br/>Round 4 <br/>Round 5 <br/>Round 6 <br/>Round 7 <br/>Round 8 <br/>Round 9 <br/>Round 10 <br/>[End of input]</span></pre><p id="a84f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">额外的Python锁功能:</em></p><ul class=""><li id="7943" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ma jw jx jy bi translated">使用锁作为上下文管理器<em class="jp"> (with-block) </em>是常见的方式。最重要的是，它防止了过早退出临界区的常见错误，忽略了释放锁，这使得程序<em class="jp">无限期地停滞在</em>中。然而，没有人阻止你显式地调用<em class="jp">获取</em>和<em class="jp">释放</em>，如果这需要的话。(例如，为了指定超时)。</li><li id="cb51" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">可以获得锁<em class="jp">非阻塞</em>(使用布尔自变量)。对acquire的调用返回布尔成功状态——现在您是否控制了锁。(当然，尽管失败，继续进行，协议无效！)</li><li id="949e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">可以获得锁<em class="jp">阻塞</em>(默认)，但是超时(默认为无限)。(咨询结果状态)。一个常见的做法是<em class="jp">在获取</em>时用一个短的超时进行迭代(防止你的线程因为对方的疏忽而卡住)。</li><li id="ef90" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">虽然Python锁只是操作系统锁的包装器，但是有一些限制:(1)Python锁受限于进程范围。不能给它命名(从另一个进程控制)。(2) <em class="jp">释放</em>可以从任何线程调用(而不仅仅是从获得锁的线程)。</li><li id="b603" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">RLock(用于“可重入”锁)解决了递归尝试从同一个线程获取锁的问题。正常情况下，这会使当前线程陷入死锁，导致程序停滞，因为线程现在持有自己，将永远不会再释放它。相反，可重入版本增加了一个获取计数器(通过当前线程)。因此，当当前持有锁的线程试图再次获取锁时，计数会增加(而不是持有线程),并且当前线程的每个释放请求都会减少该计数。当计数达到零时，可重入锁最终被释放。在递归算法中使用RLock。</li></ul></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="7f41" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">4.条件变量</h2><p id="93dc" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">Python已经有了封装锁和条件的同步原语。因此，我们可以用它来简化前面的原型(此外，还可以解决它的性能问题)。</p><p id="ff33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">条件(也称为条件变量)将临界区(由锁分隔)与类似于事件(见下一节)的等待/通知能力相关联，通常(但不一定)与布尔测试一起。该条件的独特之处在于,<em class="jp">等待</em>(等待资源持有者释放它)在临界区“打了一个洞”,并允许另一方获得锁，继续进行任何需要的操作(例如，准备公共资源)。当另一端<em class="jp">通知</em>时，条件重新获得锁，控制进入临界区的剩余部分。这使得它成为一个灵活且非常通用的同步解决方案。(相反，试图从由裸锁限定的临界区内显式同步会导致死锁！)</p><p id="596e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">这里是重构后的原型，后面是notes(输出保持不变):</em></p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="ecb1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="daea" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">这个同步原语也是从线程库中导入的</li><li id="21b3" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">默认情况下，接收条件是全局初始化的。</li><li id="7e04" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">条件(锁在其中)界定了生产临界区。</li><li id="4977" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">指示结束时，生产者释放消费者并退出生产循环。</li><li id="0324" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">它的循环工作完成后，生产者放行消费者接收。</li><li id="55a0" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">在这里，制作人设定节奏(这更合适)。睡觉发生在临界区之外！请注意，该生成器每两秒钟发出一条消息<em class="jp">，而不考虑另一端</em>。(与本课中的其他解决方案相反，它不等待ack)！因为这个消费者做的很少，所以这个设计是可行的。试着减少睡眠时间(几分之一秒)，它不会崩溃。这将需要很高的利率，使消费者松散的信息。(在这种情况下，ack可能会到期返回)。</li><li id="7ed1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">条件的(锁定)限定了消耗临界区。</li><li id="b8d5" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">该示例使用消息更改验证来交换来自接收方的<em class="jp"> ack </em>。(假设，在这个协议中，没有两个连续的消息是相同的！)</li><li id="f5ef" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">在周期结束时，消费者记录当前消息。</li><li id="90a8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序不受同步方法改变的影响。</li></ol><p id="518d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">附加条件功能:</em></p><ul class=""><li id="b9cc" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ma jw jx jy bi translated">可以将多个条件与同一个锁相关联(在构造时指定)。默认情况下，条件会创建自己的锁。</li><li id="abd6" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated"><em class="jp"> Wait_for </em>接受谓词(函数、显式或lambda)和(可选)超时，并等待通知<em class="jp">，而</em>谓词返回false。(实际上，我们并不期望它只执行一次)。当然你也可以自己写循环，调用<em class="jp"> wait </em>代替。测试条件是一个惯例。原则上，你可以无条件等待，使用条件作为带锁事件。</li><li id="2c21" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">对<em class="jp"> notify </em>的调用释放了一个等待线程(这是我们在这里得到的全部)。要释放多个等待线程，要么指定它们的数量，要么使用<em class="jp"> notify_all </em>。</li></ul></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="c255" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">5.事件</h2><p id="b4ac" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated"><em class="jp">事件</em>看起来像没有条件和锁的条件变量(只剩下<em class="jp">等待/通知</em>功能)。事实上，这比它早了几十年。新的条件变量通常作为过时事件的改进版本进行销售(例如，参见C++x11的文档)。但是，它仍然是Python(和其他语言)线程基础设施的一部分，所以请自行判断！</p><p id="c2c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp"> Event </em>是一个全局<em class="jp"> Boolean </em>，除了像任何Boolean一样被<em class="jp">轮询</em>以获取真理之外，它还拥有<em class="jp">持有</em>感兴趣的线程的能力(直到真)。当“复位”(假)时，它保持所有<em class="jp">等待</em>的线程的执行。当第三方给<em class="jp">发信号</em>(设置为真)时，事件让他们离开(等待的调用<em class="jp">将</em>返回给他们每个人)。</p><p id="0c88" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">在下面的例子中，使用两个事件(一个控制发送，另一个控制接收)限定了临界区，并且消除了对锁的需要。</p><p id="7e63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">这里是重构后的原型，后面是notes(输出保持不变):</em></p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="4fac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="8f28" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">这个同步原语也是从线程库中导入的</li><li id="5b7c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">接收和发送事件是全局变量(默认情况下为false)。</li><li id="4d23" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">在生成器初始化时启用发送，以启用第一条消息。</li><li id="1fe5" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">在每个周期的开始，生产者等待发送许可。没有锁。临界区由事件界定(在等待和清除之间)。(待办事项:指定超时。等待失败时:错误)。</li><li id="9f75" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">指示停止，生产者中和事件并退出循环。</li><li id="8fdd" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">在每个周期结束时，生产者允许接收并保持发送。</li><li id="13fa" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">速度由生产者决定，在每个周期结束时等待2秒钟。(消费者同时被事件持有)。</li><li id="fdd7" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">在每个周期的开始，消费者等待接收许可。没有锁。临界区由事件界定(在等待和清除之间)。(待办事项:指定超时。等待失败时:错误)。</li><li id="de51" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">在每个周期结束时，消费者允许发送并保持接收。</li><li id="57e0" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序不受同步方法改变的影响。</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="3ccf" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">6.封装消息</h2><p id="7d2f" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">在本课的开始，我郑重声明“数据是无生命的物质”，不会被过程所欺负，并且(因此)同步原语的唯一目的是界定操纵它(数据)的代码的关键部分。这确实代表了当前的技术水平。然而，使用<em class="jp">面向对象的</em>编程，我们可以通过将同步原语与数据封装在一起并添加用于激活它们的<em class="jp">方法</em>，将<em class="jp">的同步责任分配给数据</em>。结果是消息<em class="jp">对象</em>必须是<em class="jp">发送的消息</em>(以面向对象的方式)，对其自身的完整性负责。</p><p id="4567" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">下面的例子重构了第5节中的例子，用消息封装了两个<em class="jp">事件</em>(以前是<em class="jp">全局</em>):</p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="20ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="d44c" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">整个<em class="jp">同步消息</em>功能现在是一个类</li><li id="e535" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">类同步消息封装了以前的全局消息相关人员。</li><li id="6311" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">阻塞<em class="jp">获取</em>消息。请求者(显然是生产者)必须等待<em class="jp">发送</em>确认。(待办事项:超时)。</li><li id="83f0" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">阻塞<em class="jp">设置</em>消息。请求者(显然是消费者)必须等待“接收”确认。(待办事项:超时)。</li><li id="d9d3" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">其他发送/接收事件功能被赋予了具有应用程序重要名称的方法。</li><li id="69af" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">使用消息初始化生成器。(它不再是全球性的)。</li><li id="93ef" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生成器将消息重置为发送状态。</li><li id="d2ea" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者设置消息，阻止(直到被消费者释放)。</li><li id="e51e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">这个请求中隐含的等待是多余的，但是，在当前的上下文中，我们可以确定事件无论如何都是有信号的。</li><li id="c660" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生成器将消息设置为启用发送和禁用接收。</li><li id="9487" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">使用消息初始化使用者。</li><li id="9dc0" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者得到消息，阻塞(直到被生产者释放)。这个习语(获得承诺的值，可能被承诺者阻止)是<em class="jp">未来</em>设计模式的特征。</li><li id="bc07" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者将消息设置为禁用接收和启用发送。</li><li id="2326" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">过去是全局的消息，现在对于主程序来说是局部的，并被传递给生产者和消费者。</li></ol><p id="3455" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">下面的例子重构了第4节中的例子，用消息封装了<em class="jp">条件</em>(以前是<em class="jp">全局</em>)，并为其提供接口:</p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="efe9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="9a06" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">同步消息实现了<em class="jp">上下文管理器</em>接口，以模拟条件行为。</li><li id="b59e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">同步消息实现了有用的条件接口，委托给内部的条件。</li><li id="c911" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">该消息用于界定生产者的临界区。消息中请求同步。</li><li id="9e29" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">这种解决方案不考虑消息的信息隐藏，也不支持阻塞get和set。</li><li id="174b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">该消息用于界定消费者的关键部分。消息中请求同步。</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="fc8f" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">7.信息排队</h2><p id="e9da" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">到目前为止，所有的同步原语解决方案(锁、条件变量和事件)都以各种方式专门用于<em class="jp">保护对生产者和消费者双方都可用的单一资源</em>(在我们的例子中是一个全局字符串对象)的访问。尽管程序发出了一系列的信息，但在程序内部，只有一条信息会在每一轮被覆盖(巧妙地避免了竞争情况)。</p><p id="cc32" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">另一个策略是<em class="jp">首先在内部序列化</em>输出。在这里，<em class="jp">没有任何东西被覆盖！</em>在每一轮中，在内部创建一个新消息，并在<em class="jp">中排队。</em>生产者不用担心消息的完整性(除了<em class="jp">用消费者消化不了的消息淹没</em>队列)。消费者有责任<em class="jp">按时从队列中提取</em>未决消息。</p><p id="4382" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">虽然序列化(生产者和消费者之间的通信)更耗费资源，内部也更复杂，但它简化了程序员的工作(没有关键部分需要处理)并减少了竞争条件。(当然是处理得当的话)。</p><p id="4fb5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">有两种序列化策略:</p><ol class=""><li id="427e" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">使用队列将消费者与生产者分开。生产者以自己的速度将消息写入队列。消费者以自己的速度从队列中提取消息。生产者不知道消息是否被消费(它不等待来自另一端的ack)。这种体系结构适合于向多个消费者多播消息。例如，当您的web浏览器从远程网站服务器获得一个页面时，服务器(生产者)根本不关心您(一个随机的消费者)对该页面做了什么，以及它一开始是否是完整的。这里唯一关心的是验证队列不会溢出。(消息传递基础设施倾向于限制队列的大小！).此外，队列必须满足外部强加的吞吐量要求(如果有)。</li><li id="7c28" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">将队列用作某种“带备份的事件”。在推送下一条消息之前，生产者确实等待来自消费者的ack。虽然这也可以简单地通过附加的“ack”消息(以及可能的专用队列)来实现，但是Python队列(与UNIX队列一致)可选地提供类似事件的功能:您可以加入它(即等待来自发送方的信号)并向它发送信号(释放接收方，就像我们在下面的例子中所做的那样)。这种架构支持多个生产者(以及一个或多个消费者)。多个生产者可以将他们的消息发送给同一个消费者，而不会阻塞它。各种消息在消费者的队列中累积，消费者有责任根据需要依次确认每个生产者。这种架构在实时软件中很常见。</li></ol><p id="5fd6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">这里是重构后的原型，后面是notes(输出保持不变):</em></p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="5c86" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="b922" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">消息队列功能位于单独的库中(不是线程库的一部分)。</li><li id="f97e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者接收要写入的队列(即消费者的队列)。</li><li id="bede" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者将当前消息发送到其输出队列。</li><li id="6912" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者等待(消费者的信号)。</li><li id="00a4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者打开一个队列(用于输入)。</li><li id="d510" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者从队列中提取待处理的消息(如果有的话，在消息到达之前一直被阻塞。(待办事项:指定超时并检查错误)。</li><li id="bb22" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">在退出之前，消费者使用队列来释放生产者。</li><li id="be5b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消息被读取和打印后，消费者使用队列来释放生产者。</li><li id="c9c3" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序首先初始化消费者，然后使用消费者的消息队列初始化生产者。这种严格的分工保证了<em class="jp">信息隐藏的措施！</em>(主程序不知道消息是如何传递的，生产者也不知道消息发送到哪里)。</li></ol><p id="577e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">附加消息队列功能:</em></p><ul class=""><li id="bcfe" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ma jw jx jy bi translated">查询队列状态:当前队列中的消息数量/为空，已满。</li><li id="bf1a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">阻塞put(满时)，可选超时。</li><li id="d31a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">非阻塞get，带有可选超时。</li><li id="3afb" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated"><em class="jp">优先级队列</em>，其中消息按优先级顺序(分配的编号)检索。</li><li id="9882" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated"><em class="jp"> LIFO队列</em>(即<em class="jp">堆栈</em>)，其中消息以相反的顺序检索。</li></ul></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="e879" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">8.什么时候用？</h2><p id="2106" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">正如本系列介绍中所讨论的，在<em class="jp">非阻塞输入存在的情况下，邀请<em class="jp">并行设计</em>。</em>我们有一个函数“A”产生输出，另一个函数“B”消耗这个输入(可能是同一个对象。不同之处在于视角)，但是——由于各种原因——这两者在程序上可能不是有序的(<em class="jp"/>)，例如(1)另一个函数“C”调用“A”然后“B”，(2)“A”在结尾调用“B”，(3)“B”在开始调用“A”，等等。因此，设计必须求助于一个<em class="jp">不连续的过程:</em>这两个功能看起来不相关，但是，由于它们仍然是<em class="jp">数据耦合的</em>，它们执行的<em class="jp">顺序</em>和它们之间的<em class="jp">数据传输</em>由更微妙的编程设备处理——专有(或标准，或第三方)通信<em class="jp">协议</em>。例如，这些功能可以在不同的线程上执行，由上面讨论的一些原语同步。</p><p id="cd35" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">涉及非阻塞输入的设计问题的解决方案依赖于消费者的数量(竞争这个输入)、生产者的数量(被消费者阻塞，如果有的话)、双方涉及的速率、服务质量(消息会丢失吗？秩序必须保持吗？)以及生产者和消费者义务的其他任务。<em class="jp">以下是一些简要的指导方针:</em></p><ul class=""><li id="c2b9" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ma jw jx jy bi translated">本课中的简单示例涉及(1)一个生产者和一个消费者,( 2)没有任何义务,( 3)转移率由生产者单独决定。这个简单的用例可以使用公共资源的单个实例，通过条件变量进行同步(如上面的示例4)。可以添加ack来保护消费者免受过高的传输速率。</li><li id="fb5b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">多个消费者(由一个生产者提供)可能仍然使用单一的全局资源，但是可能需要更紧密的同步。举几个常见的限制:(1)只要未被(所有消费者)完全消费，公共资源就必须持续存在，以及(2)消费者不得改变公共资源。默认的同步原语(条件、事件、空锁)可能仍然有效，因为它们是为支持多线程而构建的。</li><li id="8b4b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">多个生产者(为一个消费者提供食物)需要序列化(例如消息队列)。虽然保持多个全局资源(和它们的锁)是可能的，但这将带来维护上的麻烦并限制可扩展性。最好是在从队列中检索下一条消息之后，立即将复杂性集中在调度逻辑中。</li><li id="26aa" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">条件和事件是消费者阻止生产者的手段(在当前电流尚未被消耗时保持下一个输出)。如果传输速率要求生产者在消费者可以接受之前产生下一个输出(但消息绝不能丢失)，则应进行序列化(例如，通过消息队列)。</li><li id="97f7" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">在<em class="jp">轮询</em>用例中，同步可以放松，其中生产者(例如，在专用硬件上)以高速率输出，而消费者以某个间隔对输出进行采样。在这种情况下，预先约定一些数据将会丢失。当输入被缓冲时，仍然可以观察到一些同步，例如通过用信号通知读取的持续时间(或者相反——写入的持续时间),以防止消费者得到不一致的(部分重写的)数据。这种架构在实时软件中很常见。</li></ul></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="9f11" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">9.发布/订阅</h2><p id="d53c" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">上面讨论的<em class="jp">消息队列</em>具体定义为<em class="jp">点对点</em>消息队列。尽管生产者并没有直接向消费者发送消息(上帝保佑！)，它会将它们发送到一个代表、属于(很可能是由)消费者的队列中。两个消费者邀请两个消息队列。如果两个消费者使用同一个队列进行输入(这是合法的)，那么其中一个将会挨饿(它将会了解到一条消息，但是，当它到达队列时，这条消息可能已经被它的对等方取走了)。</p><p id="4cab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">对于简单的点对点消息队列之外的下一个逻辑步骤，我们超越了标准Python产品，进入了“发布/订阅”的世界。<em class="jp">发布/订阅</em>消息传递基础设施，例如<em class="jp"> RabbitMQ </em>、<em class="jp"> Kafka </em>，长期以来一直以其<em class="jp">日志</em>功能而闻名，但最近已经成为<em class="jp">服务</em>(或微服务)应用框架中的关键组件，甚至在<em class="jp">嵌入式和硬实时应用中也是如此，</em>代表了一种成熟的技术(显然是对实际需求的响应！)</p><p id="2298" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">发布/订阅基础设施将消息队列的概念发挥到了极致，它将消费者和生产者永远分离开来。生产者尽可能多地发布一个命名的主题，(实际上是一个消息队列，但是对任何知道其名称的人开放)。消费者注册感兴趣的主题(按名称)，并在新消息到达时得到通知。因为同步(以及成熟平台中的低级通信和协议)由消息传递平台负责，所以系统中的消费者被简化为事件处理程序—服务(或分布式环境中的微服务)。生产者也被简化了(通过底层自动化)，但程度较低。</p><p id="c323" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">此外，任何人(有权访问系统)都可以从该主题<em class="jp">数据库</em>中查询和检索。消息是否仍然可用(一旦所有注册的消费者已经查看了它们)是可配置的，并且可以用于诸如日志记录、内存数据库、测试和模拟之类的目的(例如，通过从外部注入消息，实际激活适当的消费者和生产者，以便重新运行记录的或想象的用例，并且记录结果用于验证，例如，通过自动工具)。</p><p id="17e7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">虽然Python没有对发布/订阅的内置支持，但是有许多第三方产品。在这个例子中，我们使用<em class="jp"> pypubsub </em>(用<em class="jp"> pip等安装。</em>)，相当成熟的软件。它仅限于进程范围，并具有严格而简单的同步协议(如果您能接受的话)，可用于将应用程序简化为简单的事件驱动设计，并具有可扩展性和可维护性的所有好处。</p><p id="62a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">发布是通过发送一个<em class="jp">消息</em>到一个<em class="jp">主题</em>来完成的。(没有指定的<em class="jp">发布者——任何人都可以发布任何主题)。消费是通过<em class="jp">注册回调</em>完成的。(功能—消费不需要封装)。发布/订阅协议很简单<em class="jp">同步</em>。发送消息<em class="jp">阻塞发送方</em>并逐个调用所有注册的监听方<em class="jp">，阻塞，</em>处理消息。(pypubsub不支持<em class="jp">异步</em>处理。你可以用显而易见的方式实现异步消费，通过减少你的监听器到中断服务例程，这些例程只是<em class="jp">通知</em>真正的消费者，可能复制消息对象——它们是<em class="jp">弱引用的— </em>从那里获得，但是在它们自己的线程中。</em></p><p id="4294" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">在下面的例子中，消费者不再是一个线程(只是注册了一个回调)，但是生产者仍然是一个线程，以保持当前的逻辑。</p><p id="66d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">这里是重构后的原型，后面是notes(输出保持不变):</em></p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="9b11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="8f5a" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">从<em class="jp"> pubsub </em>库导入。</li><li id="b79e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">指示结束后，生产者<em class="jp">向“EnumeratedMessages”主题发布</em>一条结束消息，参数名为“message”。end代码被扩展和澄清(从仅仅“[STOP]”到尊贵的“[END-ENUMERATED-MESSAGES]”，以使其在分布式的对所有人开放的环境中存活。</li><li id="ef2a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">循环工作完成后，生产者<em class="jp">向“EnumeratedMessages”主题发布</em>一个枚举消息，参数名为“message”。</li><li id="b96b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">在这种设计中，消费者不需要成为线程。</li><li id="6bc4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者注册一个对“EnumeratedMessages”主题的侦听器回调。顺便提一下，这创建了主题并定义了听者的签名。</li><li id="5438" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">侦听器回调采用一个参数，称为“message”。</li><li id="c59f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">侦听器使用单个消息(无事件循环),并且没有同步。</li><li id="5113" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">或者，生成器不必是单独的线程。在这种情况下，调用<em class="jp"> start </em>会阻塞主程序。但这不会有太大的效果。为了维持现在的逻辑，主程序应该先启动一个定时器线程(20秒后停止生产者)。所以需要第二个线程，无论如何！此外，这样的设计很难使用多个生产者。</li><li id="8862" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序加入制作程序。(因为消费者已经不是一根线了)。</li></ol><p id="01ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">附加发布/订阅功能:</em></p><ol class=""><li id="22d4" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated"><em class="jp"> pypubsub </em>库支持多个生产者和多个消费者以及一个分层的主题数据库，所以它比上面介绍的要多得多。请查阅其文档以了解更多详细信息。</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="068c" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">10.套接字I/O作为同步原语</h2><p id="a469" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">并行设计绝不局限于内置线程库提供的那半打原语。任何支持<em class="jp">阻塞</em>和<em class="jp">通知</em>功能的平台都允许(并且通常<em class="jp">会邀请</em>)并行设计，例如本课中介绍的。</p><p id="7ab8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">例如，考虑使用套接字通过TCP/IP进行通信的生产者和消费者。在这个(相当简化的)例子中，使用<em class="jp">阻塞发送</em>和<em class="jp">接收</em>以明显的方式处理同步</p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="58ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="5789" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">使用<em class="jp">插座</em>库</li><li id="f8bd" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">使用IP地址初始化生成器。</li><li id="ea44" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者在所提供的IP地址上为自己打开一个网络节点(“套接字”)。这是一个<em class="jp">服务器插座</em>(它不<em class="jp">连接</em>到外部世界——外部世界被邀请连接到它)。(待办事项:验证套接字确实已被授予。可能的错误:“端口已被使用”等。).</li><li id="a2fe" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">套接字<em class="jp">异步监听</em>到这个地址<em class="jp">的连接请求。</em>(它在后台默默地为我们打开一个轮询网络的线程)。</li><li id="0ef8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者响应第一个(也是唯一的)连接请求，<em class="jp">阻塞</em>，产生另一个套接字(用于连接)。(待办事项:指定超时，并决定失败时要做什么。可选地，首先检查连接请求是否未决)。</li><li id="2f42" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者检索“就绪”消息，该消息持续正好5个字节，阻塞。(待办事项:指定超时。确认消息确实显示“就绪”)。</li><li id="27a8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">当该停止时，生产者发送“停止”消息(在<em class="jp">字节</em>中)。末尾的额外空格确保了消费者，等待7个字节(不少于！)，确实心领神会。</li><li id="ae95" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者通过套接字发送下一条消息(编码为字节)。(待办事项:使用返回的数字验证所有字节确实都已发送)。</li><li id="06e9" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">它的工作完成后，生产者关闭套接字(服务器和连接)。</li><li id="1c51" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者打开一个<em class="jp">客户端套接字</em>，连接到生产者的IP地址(由应用程序提供)。(待办事项:指定超时并检查错误)。</li><li id="8a27" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者发送“就绪”消息。(待办事项:验证五个字节确实已经发送)。</li><li id="0c7b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者提取下一条消息，预期正好8个字节，阻塞。(待办事项:指定超时等。).</li><li id="582e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">工作完成后，消费者关闭(客户端)套接字。</li><li id="4f64" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序用本地计算机的(虚构的)地址(“localhost”)端口8899(希望它没有被使用)初始化生产者和消费者。除此之外，主程序逻辑保持不变。</li></ol><h2 id="7433" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">11.附加同步原语</h2><p id="6963" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">Python还支持以下线程级同步原语:</p><ol class=""><li id="2955" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated"><em class="jp">旗语。</em>原始同步原语。允许预定义数量的线程进入，然后阻塞额外的请求，直到有一个被释放。不适用于我们的生产者/消费者示例。我们使用的简单的<em class="jp">锁</em>也被定义为“二进制”信号量(例如在vxWorks中)，因为它允许一个线程进入，然后阻塞第二个线程。</li><li id="d360" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated"><em class="jp">屏障</em>。阻塞预定义数量的线程(单独注册),直到满足该数量。似乎不适用于我们的生产者/消费者示例。典型的应用是等待所有参与者完成准备，准备开始。例如，一个应用程序框架启动如此多的任务。由于任务之间的依赖性，所有任务在被允许开始它们的事件循环之前完成它们的所有准备(“结束-初始化”)是很重要的。例如，当队列在另一端还没有为输入开放时，为某个任务的输出开放队列是错误的。在这种情况下，所有任务都应该在end-initialize期间打开它们的输入队列。然后，在另一侧打开它们进行输出变得安全。这里有一个<em class="jp">屏障</em>是很方便的:给定任务数，它作为结束初始化和服务开始之间的屏障(在系统级)。</li><li id="65d6" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated"><em class="jp">“concurrent . futures”。</em>线程/进程<em class="jp">池</em>基础设施，主要由*async/await*设施使用(待讨论)。这个工具专门在线程(或进程)中启动一次性函数并收集它们的结果。这似乎不适用于我们的生产者/消费者的例子，在这个例子中，两个并行的任务永久地交换消息(并继续存在)。</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="09b0" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">12.练习:尾部服务器</h2><p id="eb4f" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">为了简单起见，在本课中，我们将设计的范围限制为一个生产者为一个消费者提供食物。这足以展示裸露的设施。幸运的是，扩展逻辑以考虑涉及<em class="jp">多样性</em>的用例的挑战并没有从根本上改变设计，但需要密切关注同步，并使协议防火。<em class="jp">具体来说:</em></p><ul class=""><li id="9dda" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ma jw jx jy bi translated">一个生产者养活多个消费者。</li><li id="d623" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">一个消费者被多个生产者养活。</li><li id="c1c8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">我的多个生产者养活了多个消费者。</li></ul><p id="bced" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp"> Starter prototype: </em>在上一课中，您被要求扩展文件监视器示例，以提供类似UNIX的尾部功能。使用文件名初始化尾部，并以固定的时间间隔继续打印附加到该文件的行(假设该文件仅在末端更新)。</p><p id="cd9f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">这是教科书解决方案(没有同步):</em></p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="1040" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">挑战:</em>这种设计的特点是由应用程序启动并输出到控制台的单个Tail函数。将其扩展到一个Tail服务器，该服务器将多个Tail(针对多个文件)的结果输出到控制台。应用程序动态请求要结尾的文件。尝试上面建议的同步工具。</p><p id="f53b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">设计亮点:</em></p><ul class=""><li id="df45" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ma jw jx jy bi translated">启动尾<em class="jp">线程:</em>由应用程序委托(同步)的尾服务器的职责。</li><li id="1d62" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">打印变更消息(异步):尾部服务器的责任。(尾数只<em class="jp">通知！</em>)</li><li id="6d41" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">为了<em class="jp">终止</em>尾部服务器及其线程(优雅地！)</li></ul></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="7bb2" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated"><em class="mb">接下来呢？</em></h2><p id="40b4" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">在接下来的课程中，我们将考虑Python中多线程的替代并行解决方案:多处理、使用拉和推迭代器的协作处理以及基于分派的协作处理(<em class="jp">异步</em>调用)。</p><ol class=""><li id="5fbb" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated"><a class="ae mc" rel="noopener" href="/codex/parallel-programming-in-python-lesson-1-introduction-210e33d02ea6?source=friends_link&amp;sk=5273e19224913fbd6a3b74f41871a754">简介</a></li><li id="acc9" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated"><a class="ae mc" rel="noopener" href="/codex/parallel-programming-in-python-lesson-2-the-thread-b3986e215d4f?source=friends_link&amp;sk=5ad6a9c99ce8947be53af4949ce6f086">螺纹</a></li><li id="81e8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">同步原语(多线程)——<em class="jp">(你来了！)</em></li><li id="9c84" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">同步原语(多处理)</li><li id="9ae8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">协作处理—同步</li><li id="4691" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">协作处理—异步</li></ol></div></div>    
</body>
</html>