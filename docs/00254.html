<html>
<head>
<title>Making Your Own JavaScript Linter (part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制作您自己的JavaScript Linter(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/making-your-own-javascript-linter-part-1-ee9f91dc49d8?source=collection_archive---------1-----------------------#2021-01-09">https://medium.com/codex/making-your-own-javascript-linter-part-1-ee9f91dc49d8?source=collection_archive---------1-----------------------#2021-01-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b904" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">综合教程</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/48cb02389bb3877823dbd5a0675ff8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YH_ZI53d0riPk78dkuyiDQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">奔跑的棉绒</figcaption></figure><p id="3f63" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这是关于构建JavaScript linter的综合教程的第一部分。linter是一个检查源代码的工具。我们将看到用JavaScript编写的基本概念和源代码，包括复杂部分的T2算法。</p><p id="15a9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">注:<a class="ae kk" href="https://github.com/JoanaBLate/dirtyrat" rel="noopener ugc nofollow" target="_blank"> <em class="kj"> dirtyrat </em> </a>是用来制作本教程的棉绒。</p><h1 id="e0d8" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">棉绒内部是如何工作的</h1><p id="d120" class="pw-post-body-paragraph jn jo hi jp b jq ld ij js jt le im jv jw lf jy jz ka lg kc kd ke lh kg kh ki hb bi translated">我们怎样才能让一台计算机如此聪明地理解用复杂的JavaScript规则编写的一千行文件呢？如何应对这样的复杂性？答案总是一样的。</p><blockquote class="li"><p id="d972" class="lj lk hi bd ll lm ln lo lp lq lr ki dx translated"><em class="ls">我们将大的复杂系统分解成小的、简单的组件，这些组件与其他组件有简单的关系。</em></p></blockquote><p id="917d" class="pw-post-body-paragraph jn jo hi jp b jq lt ij js jt lu im jv jw lv jy jz ka lw kc kd ke lx kg kh ki hb bi translated">在棉绒的情况下，这些小而简单的部件被称为<strong class="jp hj"> <em class="kj">记号</em> </strong>。所以林挺的第一步是从文本中产生一个记号集合。这正是我们人类阅读文本的方式。不同的是，我们说<em class="kj">单词</em>、<em class="kj">数字</em>和<em class="kj">标点符号</em>，而不是<em class="kj">记号</em>。</p><p id="750f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">通常从文本中产生标记的模块被称为<em class="kj">标记器</em>。它可以产生原始令牌或过滤它们，并且只提供有意义的令牌。它可以一次对整个文件进行令牌化，也可以按需逐个生成令牌。</p><p id="ae69" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们看一个例子。在下面的代码中，第一行有多少个原始标记？</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="7c29" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你猜是5吗？嗯，不仅仅是看上去的那样。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ma"><img src="../Images/ab63edd97d8a13e0a47f9b247d3cf110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*8u4EkpfMKBAfdMF9QlNZ1g.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">原始代币</figcaption></figure><p id="17f1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">考虑到有些种类被命名为“=”和“；”而不是<em class="kj">赋值</em>和<em class="kj">分号</em>，你可能会意识到<em class="kj"> dirtyrat </em>这个名字有些贴切。</p><p id="659e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">除了生成所有原始令牌，tokenizer(或另一个模块)还消除了无意义的令牌——空行、备注和空格。</p><p id="a12e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">尽早消除无用令牌的意义在于，它极大地简化了要做的检查。看下面的部分例子。它们都有有效的语法用于开始<em class="kj"> if </em>语句。它们都归结为相同的两个有意义的记号(关键字<em class="kj"> if </em>和左括号)。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="6efa" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当linter正在分析过滤后的(仅有意义的)令牌，并且它看到一个带有关键字<em class="kj"> if </em>的令牌时，就可以说“现在给我一个内容为'('的令牌，否则我会喊'错误'！”。</p><p id="a2f2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当记号赋予器不过滤记号时……好吧，我不愿意想象这个linter在内部会是多么臃肿、丑陋和混乱！</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="a3e3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">什么样的标记是无用的取决于目标文本的编程语言的规则。c不关心EOLs(行尾)，它依赖分号。Python在每一行的开头计算空格来结束代码块。</p><p id="1a23" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果linter正在检查样式，那么必须保留空白标记。如果标记器是文档工具的一部分，则必须保留注释。记号赋予器不仅仅是为了linters和其他工具。编译器和解释器也有一个。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="9ef8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以，基本上，林挺就是从源代码中创建一个有意义的令牌列表，然后分析每个令牌与其下一个邻居的关系。</p><h1 id="0aba" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">令牌对象</h1><p id="1a3f" class="pw-post-body-paragraph jn jo hi jp b jq ld ij js jt le im jv jw lf jy jz ka lg kc kd ke lh kg kh ki hb bi translated">对于一个过敏者来说，完美地发现错误是不够的。它应该指出每个错误发生的确切位置以及错误是什么。“where”部分很简单，只要我们注册每个标记的位置(文件名、行名和列名)。“是什么”的部分很难，因为有太多的可能性要涵盖；这就是为什么简单通用的错误消息<strong class="jp hj"> <em class="kj">意外令牌</em> </strong>被广泛使用的原因。</p><p id="e100" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">因此，记号赋予器的工作不仅仅是将一个大字符串(源代码)转化为一系列小字符串(记号)。令牌化器必须创建一个<em class="kj">令牌对象</em>的列表。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="3fe5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">字段<em class="kj">种类</em>特别有用。通常，linter不会检查字段<em class="kj">的值</em>。如果它在等待一个数字，那么这个数字是0、33还是44都无关紧要。令牌的类型为“数字”就足够了。</p><p id="a9af" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在本教程中，从现在开始，<em class="kj"> token </em>(单独)表示一个<em class="kj"> token对象</em>。</p><h1 id="8bcd" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">记号赋予器如何工作</h1><p id="f84a" class="pw-post-body-paragraph jn jo hi jp b jq ld ij js jt le im jv jw lf jy jz ka lg kc kd ke lh kg kh ki hb bi translated">记号赋予器基本上是一个大循环。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="eb1e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">注意，函数<em class="kj"> eatCharacter </em>是记号赋予器的核心，因为记号赋予器是linter的核心。除了服务于下一个字符的基本职责之外，这个小而简单的函数还控制行尾、文件尾、有效字符和标记的位置。</p><p id="0fb2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">修复为什么不可能有两个连续的空白标记。一旦<em class="kj"> createWhiteSpaceToken </em>开始，它只在源代码中的下一个字符不是空白时停止。这是一个非常简单的案例。其他函数如<em class="kj"> createStringToken、createNumberToken、createNameToken </em>等。更加复杂，但基本功能是相同的。</p><p id="8b71" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">没有函数<em class="kj"> createKeywordToken </em>。函数<em class="kj"> createNameToken </em>检查token.value是否属于关键字列表。</p><p id="02e8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">上面的部分代码不处理符号有多个字符的情况，比如等号(" == ")。如果你想了解更多细节，可以在GitHub 上找到dirtyrat的<a class="ae kk" href="https://github.com/JoanaBLate/dirtyrat" rel="noopener ugc nofollow" target="_blank">源代码。</a></p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="d64a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">关于字符串插值，有三种处理方法。</p><ul class=""><li id="6b9d" class="mi mj hi jp b jq jr jt ju jw mk ka ml ke mm ki mn mo mp mq bi translated">好方法是:tokenizer忽略插值，并提供一个标准的字符串标记。稍后将在特殊模块中处理插值。</li><li id="2c16" class="mi mj hi jp b jq mr jt ms jw mt ka mu ke mv ki mn mo mp mq bi translated">坏的方面:为了产生插值的所有记号，函数<em class="kj"> createStringToken </em>的复杂性和大小大大增加。</li><li id="5c4c" class="mi mj hi jp b jq mr jt ms jw mt ka mu ke mv ki mn mo mp mq bi translated">可怕的方式:tokenizer忽略插值，传递一个标准的字符串令牌。但是，我们没有创建一个特殊的模块来处理插值，而是将插值视为一个源代码文件本身，并且(<a class="ae kk" href="https://joanaborgeslate.medium.com/repeat-yourself-sometimes-it-is-a-good-thing-141179c11dad" rel="noopener">试图遵守DRY原则</a>)我们重构了令牌化器，以便能够处理这个“源代码文件”。真是一团糟！</li></ul></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="0051" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可能会认为，如果有一个变量来记忆源代码中当前字符的位置，而不是吃掉(缩小)一个大字符串(源代码)的数百倍，程序会更有性能。这是可行的，但是会使代码变得复杂。</p><p id="9fb8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">事实上，dirtyrat使用了第三种方法，将简单性和性能结合起来:首先将代码分成几行，然后逐行进行标记。</p><h1 id="48c5" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">扫描仪</h1><p id="01ea" class="pw-post-body-paragraph jn jo hi jp b jq ld ij js jt le im jv jw lf jy jz ka lg kc kd ke lh kg kh ki hb bi translated">记号赋予器创建一个有意义的记号列表。现在我们必须分析记号之间的关系。这是在模块解析器(及其助手模块)中完成的。由于解析表达式和函数体有点复杂，我们创建了模块<em class="kj"> scanner </em>，它包含一些简单但非常有用的函数，目的是向其他模块提供令牌。让我们来看看其中的一些功能。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="bc5a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">扫描仪里所有的函数名都是以“看”或者“吃”开头的。当我们需要知道下一个令牌，但现在不打算使用它时，可以使用“see”函数。</p><p id="90d7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">函数<em class="kj">seeEndOfBlockOrTrueEndOfLine</em>甚至不返回令牌！它只是检查下一个令牌是否符合某些条件。</p><p id="c1db" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">那么，什么样的终点不是真正的终点呢？分号("；").</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="94b9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">扫描器是准备就绪后访问令牌列表的唯一模块。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="6fda" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当发现一个错误时，Dirtyrat <em class="kj">总是退出执行，否则它可能会指出几十个实际上并不存在的错误，仅仅因为第一个错误破坏了后面几行代码的结构。例如，<em class="kj"> eatString </em>返回一个字符串标记，或者linter在显示正确的错误消息后退出。</em></p><h1 id="db36" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">模块错误</h1><p id="78e9" class="pw-post-body-paragraph jn jo hi jp b jq ld ij js jt le im jv jw lf jy jz ka lg kc kd ke lh kg kh ki hb bi translated">既然我们已经讨论了错误，让我们看看模块<em class="kj">错误</em>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="5970" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">正如你所看到的，这个想法是每个模块都很简单，并使其他模块变得非常容易。比如，当模块<em class="kj">表达式</em>发现一个坏令牌，它要做的就是说<em class="kj">意外(令牌)</em>。并将显示一条精确的错误消息。</p><p id="4966" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">注意:在dirtyrat中，模块<em class="kj">错误</em>是模块<em class="kj">助手</em>的一部分。</p><h1 id="7db1" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">待续</h1><p id="ef8b" class="pw-post-body-paragraph jn jo hi jp b jq ld ij js jt le im jv jw lf jy jz ka lg kc kd ke lh kg kh ki hb bi translated">你可以在这里阅读教程的<a class="ae kk" rel="noopener" href="/codex/making-your-own-javascript-linter-part-2-288841612f4d">第二部分。</a></p></div></div>    
</body>
</html>