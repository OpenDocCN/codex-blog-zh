<html>
<head>
<title>(Go)ing Generic: Writing type-free functions in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(Go)ing泛型:用Go编写无类型函数</h1>
<blockquote>原文：<a href="https://medium.com/codex/go-ing-generic-writing-type-free-functions-in-go-40c736c422e5?source=collection_archive---------5-----------------------#2022-10-29">https://medium.com/codex/go-ing-generic-writing-type-free-functions-in-go-40c736c422e5?source=collection_archive---------5-----------------------#2022-10-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c898" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你熟悉C++，你可能听说过模板。模板。模板背后的简单思想是将数据类型作为参数传递，这样我们就不必为不同的数据类型编写相同的代码。Golang中的泛型也是如此，它们被表示为以下三种类型:</p><p id="89af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">类型参数:</strong></p><p id="ae18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们编写一个简单的函数，它将两个整数作为参数，并返回这两个数字中的最小值:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="371e" class="jm jn hi ji b fi jo jp l jq jr">package main</span><span id="a24a" class="jm jn hi ji b fi js jp l jq jr">import "fmt"</span><span id="2efe" class="jm jn hi ji b fi js jp l jq jr">func main() {<br/>fmt.Println(min(1, 2))<br/>}</span><span id="5f27" class="jm jn hi ji b fi js jp l jq jr">func min(a int, b int) int {<br/>if a &lt; b {<br/>return a<br/>}<br/>return b<br/>}</span></pre><p id="9f51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数返回最小值1:</p><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jt"><img src="../Images/6f25c6fa49fd026afae2c62264c397bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WOuJC1Kscy9mppugpv0BQQ.png"/></div></div></figure><p id="ea41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是如果我们将1.1作为其中一个值传递给这个函数，它会给我们一个编译时错误:</p><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kb"><img src="../Images/4946c0177646eff6fa866dd41cfa64ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6llvjMXS4J5f588ZSG90Ag.png"/></div></div></figure><p id="1051" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为该函数预期接收的是int而不是float。我们如何解决这个问题？这就是类型参数发挥作用的地方:</p><p id="d2ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们将暂时使用一个单独的函数，稍后将返回到最小函数:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="99d3" class="jm jn hi ji b fi jo jp l jq jr">func returnNum[T any](a T, b T) T {<br/>return b<br/>}</span></pre><p id="286c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以这样称呼:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="e9df" class="jm jn hi ji b fi jo jp l jq jr">func main() {<br/>fmt.Println(returnNum[int32](1, 2))<br/>}</span></pre><p id="e82d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数返回给它的任何类型。</p><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kc"><img src="../Images/1918eb13926ea6b77e8c309ae0dfe315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nE8tduNFQgwzuf-WJzQ47Q.png"/></div></div></figure><p id="8a97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是类型参数允许我们在Go中传递任何类型给函数的方式。</p><p id="b103" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要讨论的第二种类型是:</p><p id="0aaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">式推断:</strong></p><p id="5079" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这基本上是处理底层类型，例如在下面这段代码中，我们声明了一个新的类型fakeInt32，它基本上是Int32，但是我们的函数不接受fakeInt32，因为它不完全是int32:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="4626" class="jm jn hi ji b fi jo jp l jq jr">func main() {<br/>type fakeInt32 int32<br/>var number fakeInt32 = 23<br/>fmt.Println(returnNum[int32](number, 2))<br/>}</span><span id="77e4" class="jm jn hi ji b fi js jp l jq jr">func returnNum[T int32](a T, b T) T {<br/>return b<br/>}</span></pre><p id="802a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这给了我们一个编译时错误:</p><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kd"><img src="../Images/79c874283fd1be24a6b24622a1729c6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g9mkzDnWS_4dyotS6yEzxQ.png"/></div></div></figure><p id="4294" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，类型推理帮助我们处理这个问题，我们只需要在期望的类型前面添加一个“~”操作符，这将确保所有以int32作为基础类型的类型也被接受。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="3991" class="jm jn hi ji b fi jo jp l jq jr">func returnNum[T ~int32](a T, b T) T {<br/>return b<br/>}</span></pre><p id="f4d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，现在的输出将是:</p><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ke"><img src="../Images/557cabfbb8ffc88d7773f0f547be4113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MC3lhiwTOfpitvholF6xSQ.png"/></div></div></figure><p id="6d1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是预期的输出。</p><p id="0370" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，把我们的注意力转向:</p><p id="fab8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">类型设定:</strong></p><p id="ad90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们回到min函数:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="b3c8" class="jm jn hi ji b fi jo jp l jq jr">func min[T any](a T, b T) T {<br/>if a &lt; b {<br/>return a<br/>}<br/>return b<br/>}</span></pre><p id="742e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将导致编译时错误，因为没有为所有类型定义</p><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kf"><img src="../Images/7d6f661a8259c904995cf33ba0198c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*03ikk0FVMceQYnAUXVKdKg.png"/></div></div></figure><p id="abbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类型集可以帮助我们做到这一点，我们可以这样定义一个类型集:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="23b3" class="jm jn hi ji b fi jo jp l jq jr">type typeSet interface {<br/>~int32 | float32<br/>}</span></pre><p id="fba0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，这定义了一个包含支持</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="8e1a" class="jm jn hi ji b fi jo jp l jq jr">func min[T typeSet](a T, b T) T {<br/>if a &lt; b {<br/>return a<br/>}<br/>return b<br/>}</span></pre><p id="cdbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它给出了预期的输出:</p><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kg"><img src="../Images/d6b589c9732be5f1f75ecae730597aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*617EibCIpcHuMZY0dXlrUQ.png"/></div></div></figure><p id="046a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，这就是Go中的泛型。</p></div></div>    
</body>
</html>