<html>
<head>
<title>Translating the NATO Alphabet to Plain Text</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将北约字母表翻译成纯文本</h1>
<blockquote>原文：<a href="https://medium.com/codex/translating-the-nato-alphabet-to-plain-text-1f821e830b19?source=collection_archive---------5-----------------------#2022-12-16">https://medium.com/codex/translating-the-nato-alphabet-to-plain-text-1f821e830b19?source=collection_archive---------5-----------------------#2022-12-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="9feb" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">引用</h2><div class=""/><div class=""><h2 id="5139" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated"><em class="jg">出自</em> <a class="ae jh" href="https://www.manning.com/books/tiny-c-projects?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=book_gookin_tiny_9_29_21" rel="noopener ugc nofollow" target="_blank"> <em class="jg">微型C项目</em> </a> <em class="jg">出自丹·古金</em></h2></div><p id="3d07" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">在本文中，我们将讨论北约音标，以及如何编写一个简单的程序将它翻译成纯文本。</em></p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="45dc" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在<a class="ae jh" href="https://www.manning.com/books/tiny-c-projects?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=book_gookin_tiny_9_29_21" rel="noopener ugc nofollow" target="_blank">manning.com</a>结账时将<strong class="jk hs"> fccgookin </strong>输入折扣代码框，即可享受35%的折扣。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="9a34" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果你从来没有在电话里拼写过你的名字，那你应该感到幸运。或者你的名字叫玛丽·史密斯，但是你住在一条街上或一个城市里，你必须不断地大声拼写。如果是这样，你可以求助于你自己的拼写字母，比如“Nancy”中的N或者“knife”中的K作为一名程序员，你可以通过阅读本章来减轻这种挫折感，在这一章中，你</p><ul class=""><li id="2905" class="km kn hi jk b jl jm jo jp jr ko jv kp jz kq kd kr ks kt ku bi translated">理解北约的音标，以及他们为什么要这么麻烦。</li><li id="b947" class="km kn hi jk b jl kv jo kw jr kx jv ky jz kz kd kr ks kt ku bi translated">将单词翻译成拼写字母表。</li><li id="2b06" class="km kn hi jk b jl kv jo kw jr kx jv ky jz kz kd kr ks kt ku bi translated">阅读文件将单词翻译成音标。</li><li id="1173" class="km kn hi jk b jl kv jo kw jr kx jv ky jz kz kd kr ks kt ku bi translated">倒过来把北约字母表翻译成单词。</li><li id="381d" class="km kn hi jk b jl kv jo kw jr kx jv ky jz kz kd kr ks kt ku bi translated">阅读文件翻译北约字母表。</li><li id="29e9" class="km kn hi jk b jl kv jo kw jr kx jv ky jz kz kd kr ks kt ku bi translated">了解日本的纳豆是一种美味的发酵豆酱。</li></ul><p id="441d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">最后一点在本章中没有涉及。我只是喜欢吃纳豆，现在我可以把它记为业务费用。</p><p id="51ef" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">总之。</p><p id="a929" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这场混乱的辉煌结局是，不仅学习了一些新的编程技巧，还自豪地大声拼写单词，说“十一月”而不是“南希”。</p><h2 id="8bfa" class="la lb hi bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt ho bi translated"><strong class="ak">北约字母表</strong></h2><p id="ec1e" class="pw-post-body-paragraph ji jj hi jk b jl lu is jn jo lv iv jq jr lw jt ju jv lx jx jy jz ly kb kc kd hb bi translated">除了是任何一个叫纳撒尼尔的人的昵称，NATO还代表北大西洋公约组织。这是一群国家，他们是共同防御条约的成员。例如，如果另一个国家(我不知道，比如俄罗斯，没有任何特殊原因)攻击像波兰这样的北约国家(同样，没有任何原因)，所有其他北约国家都应该联合起来保卫波兰。谢天谢地，这种情况从未发生过。</p><p id="753c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">第二次世界大战后，北约成立了。我可以继续说下去，但关键是北约需要成员国之间有一些共同点。你知道，当汉斯缺少弹药时，皮埃尔可以给他子弹，子弹可以装进枪里。诸如此类的东西。</p><p id="7e70" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">北约国家之间的一个共同点是大声说出事情的方式。这样，汉斯就不需要说，“子弹！那是香肠中最好。你就是那个尤伯。我是指皮短裤。"诸如此类。相反，汉斯说:“太棒了，制服，利马，利马，回声，探戈。”这样，皮埃尔就能在所有的枪炮声中听懂汉斯的话。</p><p id="5869" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">表1列出了北约的音标，用相应的单词描述了每个字母。选择的词语是独特的，不容易被误解。其中两个单词(Alfa和Juliett)是故意拼错的，以避免书面形式中的混淆。</p><figure class="ma mb mc md fd me er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es lz"><img src="../Images/eb9c45c2a89f2d22ac57d5db1f7527aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DRF1efL3hZLnRN36z3jWWg.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">表1。北约音标。</figcaption></figure><p id="0fa3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">NATO不是唯一的语音字母，但可能是最常用的。重点是一致性。作为程序员，你不需要记住这些单词中的任何一个，尽管作为一个书呆子你可能会。尽管如此，这个程序可以输出北约代码——或者把它翻译成文字，这取决于你如何编写你的C代码。奥斯卡·基洛。</p><h2 id="58c1" class="la lb hi bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt ho bi translated"><strong class="ak">北约翻译计划</strong></h2><p id="4801" class="pw-post-body-paragraph ji jj hi jk b jl lu is jn jo lv iv jq jr lw jt ju jv lx jx jy jz ly kb kc kd hb bi translated">您编写的任何NATO翻译程序都必须有一个字符串数组，如下所示:</p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="d533" class="la lb hi mq b fi mu mv l mw mx">char *nato[] = {<br/>     "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot",<br/>     "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima",<br/>     "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo",<br/>     "Sierra", "Tango", "Uniform", "Victor", "Whiskey",<br/>     "Xray", "Yankee", "Zulu"<br/> };</span></pre><p id="24f2" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">数组的符号<code class="du my mz na mq b">*nato[]</code>意味着一个指针数组，这就是编译器在内存中构建这种结构的方式。数组的数据类型是<em class="ke"> char* </em>，所以指针引用存储在内存中的字符数组——字符串。分类不变，<em class="ke">const</em>；您不想弄乱以这种方式声明的任何字符串——这在这段代码中没有问题。<code class="du my mz na mq b">*nato[]</code>数组填充了这些地址，即字符串的存储位置，如图1所示。</p><figure class="ma mb mc md fd me er es paragraph-image"><div class="er es nb"><img src="../Images/f6a0c3d89d678b9df7219474e655907f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*1kzyIAZmdeZyyxXZ.png"/></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">图一。指针数组如何引用内存中的字符串。</figcaption></figure><p id="013f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">例如，在图中，字符串<em class="ke"> Alfa </em>(以空字符<code class="du my mz na mq b">\0</code>结束)存储在地址0x404020。这个内存位置存储在<code class="du my mz na mq b">nato[]</code>数组中，而不是字符串本身。是的，字符串出现在数组的声明中，但是它在运行时存储在内存的其他地方。同样的结构适用于数组中的所有元素:每个元素对应一个字符串的存储位置，从Alfa到Zulu。</p><p id="9ba8" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><code class="du my mz na mq b">nato[]</code>数组的美妙之处在于内容是连续的，匹配从<code class="du my mz na mq b">'A'</code>到<code class="du my mz na mq b">'Z'</code>的ASCII值。这种巧合使得提取与NATO单词相对应的字符非常容易。</p><h2 id="400c" class="la lb hi bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt ho bi translated"><strong class="ak">编写北约翻译器</strong></h2><p id="2d46" class="pw-post-body-paragraph ji jj hi jk b jl lu is jn jo lv iv jq jr lw jt ju jv lx jx jy jz ly kb kc kd hb bi translated">清单1显示了一个简单的NATO翻译器。它提示输入，使用<em class="ke"> fgets() </em>函数从标准输入中收集一个单词。一个<em class="ke">同时</em>循环一个字母一个字母地搅动这个单词。在此过程中，任何字母字符都会被<em class="ke"> isalpha() </em>函数检测到。如果找到，该字母将被用作对<code class="du my mz na mq b">nato[]</code>数组的引用。结果是北约拼音字母术语输出。</p><p id="9e7f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单1 nato01.c </strong></p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="6e8b" class="la lb hi mq b fi mu mv l mw mx">#include &lt;stdio.h&gt;<br/> #include &lt;ctype.h&gt;<br/>  <br/> int main()<br/> {<br/>     const char *nato[] = {<br/>         "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot",<br/>         "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima",<br/>         "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo",<br/>         "Sierra", "Tango", "Uniform", "Victor", "Whiskey",<br/>         "Xray", "Yankee", "Zulu"<br/>     };<br/>     char phrase[64];<br/>     char ch;<br/>     int i;<br/>  <br/>     printf("Enter a word or phrase: ");<br/>     fgets(phrase,64,stdin);    #A<br/>  <br/>     i = 0;<br/>     while(phrase[i])    #B<br/>     {<br/>         ch = toupper(phrase[i]);    #C<br/>         if(isalpha(ch))    #D<br/>             printf("%s ",nato[ch-'A']);    #E<br/>         i++;<br/>         if( i==64 )    #F<br/>             break;<br/>     }<br/>     putchar('\n');<br/>  <br/>     return(0);<br/> }</span></pre><p id="8c4b" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A存储进位置</strong> <code class="du my mz na mq b">phrase</code> <strong class="jk hs"> 63个字符(加上空字符)来自</strong> <code class="du my mz na mq b">stdin</code> <strong class="jk hs">，标准输入</strong></p><p id="bf25" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B循环，直到在字符串中找到空字符</strong></p><p id="e730" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #C将</strong> <code class="du my mz na mq b">ch</code> <strong class="jk hs">转换为大写</strong></p><p id="a975" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #D真当字</strong> <code class="du my mz na mq b">ch</code> <strong class="jk hs">是字母</strong></p><p id="2604" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #E </strong> <code class="du my mz na mq b">ch-‘A’</code> <strong class="jk hs">将字母转换为0到25的值，匹配相应的数组元素。这个表达式有效，因为<em class="ke"> char </em>变量被认为是整数。</strong></p><p id="5629" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #F一个长字符串不能有空字符，所以当达到缓冲区大小时抛出</strong></p><p id="f582" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">构建和运行时，程序会提示输入。无论键入什么文本，都会被翻译并以音标输出。例如，“你好”变成了:</p><p id="200f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">奥斯卡威士忌三角洲扬基酒店</p><p id="fb0e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">键入较长的短语，如“你好，世界！”产量:</p><p id="f8f6" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">利马回声酒店利马奥斯卡威士忌奥斯卡罗密欧利马三角洲</p><p id="b499" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">因为代码中忽略了非字母字符，所以不会生成它们的输出。</p><p id="512d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">用这种代码翻译成另一种音标很容易。你所要做的就是用你自己的拼音字母替换<code class="du my mz na mq b">nato[]</code>数组。例如，以下是可用于执法拼音字母的数组:</p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="0854" class="la lb hi mq b fi mu mv l mw mx">const char *fuzz[] = {<br/>     "Adam", "Boy", "Charles", "David", "Edward", "Frank",<br/>     "George", "Henry", "Ida", "John", "King", "Lincoln",<br/>     "Mary", "Nora", "Ocean", "Paul", "Queen", "Robert",<br/>     "Sam", "Tom", "Union", "Victor", "William",<br/>     "X-ray", "Young", "Zebra"<br/> };</span></pre><h2 id="2919" class="la lb hi bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt ho bi translated"><strong class="ak">读取和转换文件</strong></h2><p id="e7db" class="pw-post-body-paragraph ji jj hi jk b jl lu is jn jo lv iv jq jr lw jt ju jv lx jx jy jz ly kb kc kd hb bi translated">我不确定是否有必要将文件中的所有文本翻译成北约音标。这是一个你可以承担的C项目，主要是为了练习，但实际上来说，这没有什么意义。我的意思是，听三个小时完全用北约字母表制作的《安东尼与克利奥帕特拉》( Anthony and Cleopatra )( T42)会很乏味，不过如果你是戏剧/IT双学位，不妨一试。</p><p id="0014" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">清单2展示了吞噬一个文件并将每个字符翻译成对应的NATO拼音字母的代码。文件名在命令提示符下提供。如果没有，程序会抛出一条适当的错误消息。否则，类似于<code class="du my mz na mq b">nato01.c</code>中的代码，代码一次一个字符地搅动文件，吐出匹配的NATO单词。</p><p id="f2cb" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单2。nato02.c </strong></p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="d4a2" class="la lb hi mq b fi mu mv l mw mx">#include &lt;stdio.h&gt;<br/> #include &lt;stdlib.h&gt;<br/> #include &lt;ctype.h&gt;<br/>  <br/> int main(int argc, char *argv[])<br/> {<br/>     const char *nato[] = {<br/>         "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot",<br/>         "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima",<br/>         "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo",<br/>         "Sierra", "Tango", "Uniform", "Victor", "Whiskey",<br/>         "Xray", "Yankee", "Zulu"<br/>     };<br/>     FILE *n;<br/>     int ch;<br/>  <br/>     if( argc&lt;2 )    #A<br/>     {<br/>         fprintf(stderr,"Please supply a text file argument\n");<br/>         exit(1);<br/>     }<br/>  <br/>     n = fopen(argv[1],"r");    #B<br/>     if( n==NULL )<br/>     {<br/>         fprintf(stderr,"Unable to open '%s'\n",argv[1]);<br/>         exit(1);<br/>     }<br/>  <br/>     while( (ch=fgetc(n))!=EOF )     #C<br/>     {<br/>         if(isalpha(ch))     #D<br/>             printf("%s ",nato[toupper(ch)-'A']);     #E<br/>     }<br/>     putchar('\n');<br/>  <br/>     fclose(n);<br/>  <br/>     return(0);<br/> }</span></pre><p id="f1ea" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A如果出现的参数少于两个，则缺少文件名选项</strong></p><p id="039c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B打开在命令提示符下提供的文件名，引用为argv[1] </strong></p><p id="036f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">从文件中一次读取一个字符，存储在变量ch中。EOF标志着文件的结束</p><p id="17ae" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #D只处理文本字符</strong></p><p id="deb6" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #E使用字符的大写版本，减去‘A’的值来索引nato[]数组</strong></p><p id="84e5" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">当处理文件中的文本时，记得使用整数变量。标志文件结束的<code class="du my mz na mq b">EOF</code>标志是一个<em class="ke"> int </em>值，而不是一个<em class="ke"> char </em>值。代码中的<em class="ke"> while </em>语句小心翼翼地从文件中提取一个字符，并评估该字符以确定操作何时结束。</p><p id="30f8" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">要运行该程序，请在程序名后键入文件名参数。首选文本文件。输出显示为单行文本，反映了文件中每个dang doodle字符的拼音字母单词。</p><p id="f6cb" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为了在Macintosh上获得更多乐趣，可以通过<em class="ke"> say </em>命令来传输程序的输出:</p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="3445" class="la lb hi mq b fi mu mv l mw mx">nato02 anthony_and_cleopatra.txt | say</span></pre><p id="18cf" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这样，给定文件的语音字母内容就可以由Mac从头到尾大声读出。坐下来享受吧。</p><h2 id="7af6" class="la lb hi bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt ho bi translated"><strong class="ak">从北约到英语</strong></h2><p id="54b6" class="pw-post-body-paragraph ji jj hi jk b jl lu is jn jo lv iv jq jr lw jt ju jv lx jx jy jz ly kb kc kd hb bi translated">音标翻译应该在你的头脑中进行。有人拼写他们的家乡:印度塞拉，塞拉，阿尔法，魁北克，统一，阿尔法，酒店。听者知道如何写下单词，并正确拼写。这个单词是<em class="ke"> Issaquah，</em>这是我曾经生活过的一个城市。我不得不经常拼写这个名字。这个操作的美妙之处在于，由于首字母，即使一个不知道北约字母表的人也能理解正在拼写的内容。</p><p id="4f07" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">然而，更困难的是编写代码来扫描语音字母单词并将它们翻译成正确的单个字符。这个过程包括解析输入并逐字检查，看其中一个词是否与词典中的某个词匹配。</p><h2 id="f86c" class="la lb hi bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt ho bi translated"><strong class="ak">将北约输入转换为字符输出</strong></h2><p id="4af4" class="pw-post-body-paragraph ji jj hi jk b jl lu is jn jo lv iv jq jr lw jt ju jv lx jx jy jz ly kb kc kd hb bi translated">要确定一个拼音字母术语是否出现在一个文本块中，您必须解析该文本。字符串被分成单词块。只有你把单词拉出来之后，才能和音标术语进行对比。</p><p id="edce" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为了完成繁重的工作，使用<em class="ke"> strtok() </em>函数来解析文本流中的单词。我假设函数名翻译成“字符串标记器”和“字符串到千克”，这没有意义。</p><p id="d7cf" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke"> strtok() </em>函数根据一个或多个分隔符将字符串解析成块。在<code class="du my mz na mq b">string.h</code>头文件中定义的<em class="ke"> man </em>页面格式为:</p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="fd6e" class="la lb hi mq b fi mu mv l mw mx">char *strtok(char *str, const char *delim);</span></pre><p id="d90d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">第一个参数<code class="du my mz na mq b">str</code>是要扫描的字符串。第二个参数<code class="du my mz na mq b">delim</code>是一个包含单个字符的字符串，这些字符可以分隔或分隔要解析的字符块。返回的值是一个引用找到的字符块的<em class="ke"> char </em>指针。例如:</p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="8db8" class="la lb hi mq b fi mu mv l mw mx">match = strtok(string," ");</span></pre><p id="2de0" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">该语句扫描缓冲区<code class="du my mz na mq b">string</code>中保存的字符，当遇到空格字符时停止。是的，第二个参数是一个完整的字符串，即使只需要一个字符。<em class="ke"> char </em>指针<code class="du my mz na mq b">match</code>保存找到的单词(或文本块)的地址，以一个空字符结束，否则就是空格或另一个分隔符。一无所获时返回<code class="du my mz na mq b">NULL</code>常量。</p><p id="d631" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为了继续扫描相同的字符串，第一个参数被替换为<code class="du my mz na mq b">NULL</code>常量:</p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="972f" class="la lb hi mq b fi mu mv l mw mx">match = strtok(NULL," ");</span></pre><p id="7953" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">清单3中显示的代码演示了如何让<em class="ke"> strtok() </em>函数工作。</p><p id="7ca3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单3。word_parse01.c </strong></p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="d5b8" class="la lb hi mq b fi mu mv l mw mx">#include &lt;stdio.h&gt;<br/> #include &lt;string.h&gt;<br/>  <br/> int main()<br/> {<br/>     char sometext[64];<br/>     char *match;<br/>  <br/>     printf("Type some text: ");<br/>     fgets(sometext,64,stdin);<br/>  <br/>     match = strtok(sometext," ");    #A<br/>     while(match)    #B<br/>     {<br/>         printf("%s\n",match);<br/>         match = strtok(NULL," ");    #C<br/>     }<br/>  <br/>     return(0);<br/> }</span></pre><p id="1640" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A初始调用<em class="ke"> strtok() </em>，用字符串进行搜索。</strong></p><p id="762b" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B循环只要返回值不是</strong> <code class="du my mz na mq b">NULL</code> <strong class="jk hs">。</strong></p><p id="7fc1" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #C在对<em class="ke"> strtok() </em>，</strong> <code class="du my mz na mq b">NULL</code> <strong class="jk hs">的第二次调用中，用于保持搜索同一个字符串。</strong></p><p id="b95f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在这段代码中，用户被提示输入一个字符串。<em class="ke"> strtok() </em>函数从字符串中提取单词，使用一个空格作为分隔符。下面是一个运行示例:</p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="875c" class="la lb hi mq b fi mu mv l mw mx">Type some text: <strong class="mq hs">This is some text</strong><br/> This<br/> is<br/> some<br/> text</span></pre><p id="e21f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">当字符串中出现空格以外的分隔符时，它们将包含在字符块匹配中:</p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="4678" class="la lb hi mq b fi mu mv l mw mx">Type some text: <strong class="mq hs">Hello, World!</strong><br/> Hello,<br/> World!</span></pre><p id="563a" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为了避免捕获标点字符，您可以设置以下分隔符字符串:</p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="4a05" class="la lb hi mq b fi mu mv l mw mx">match = strtok(sometext," ,.!?:;\"'");</span></pre><p id="322d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这里，第二个参数列出了常见的标点符号。结果是分隔的单词被截断，如:</p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="96cf" class="la lb hi mq b fi mu mv l mw mx">Type some text: <strong class="mq hs">Hello, World!</strong><br/> Hello<br/> World</span></pre><p id="45bf" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">您可能会在程序输出中发现一些尾随空行。这些额外的换行符很适合匹配文本，因为空行无论如何都不会匹配任何内容。</p><p id="26a6" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">要创建一个拼音字母输入翻译器，您需要修改此代码来执行与NATO拼音字母术语数组的字符串比较。<em class="ke"> strcmp() </em>函数处理这个任务，但是必须考虑两件事情。</p><p id="4491" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">首先，<em class="ke"> strcmp() </em>是区分大小写的。一些C库有一个<em class="ke"> strcasecmp() </em>函数，它执行不区分大小写的比较，尽管这个函数不是C标准的一部分。(例如，MinGW编译器就没有这个功能。)</p><p id="64f0" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">第二，字符串长度可能不同。例如，如果您选择不计算<em class="ke"> strtok() </em>函数中的标点字符(<code class="du my mz na mq b">" ,.!?:;\"'"</code>)，或者当出现意外的标点字符时，比较将失败。</p><p id="81b7" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">考虑到这两种情况，我认为最好设计一个独特的字符串比较函数，专门用来检查已解析的单词是否与音标匹配。清单4显示了这个函数<em class="ke">istem()</em>。</p><p id="75ae" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单4。<em class="ke">istem()</em>函数</strong></p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="c1da" class="la lb hi mq b fi mu mv l mw mx">char isterm(char *term)<br/> {<br/>     const char *nato[] = {<br/>         "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot",<br/>         "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima",<br/>         "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo",<br/>         "Sierra", "Tango", "Uniform", "Victor", "Whiskey",<br/>         "Xray", "Yankee", "Zulu"<br/>     };<br/>     int x;<br/>     const char *n ;<br/>     char *t;<br/>  <br/>     for( x=0; x&lt;26; x++)<br/>     {<br/>         n = nato[x];    #A<br/>         t = term;    #B<br/>         while( *n!='\0' )    #C<br/>         {<br/>             if( (*n|0x20)!=(*t|0x20) )    #D<br/>                 break;    #E<br/>             n++;    #F<br/>             t++;    #F<br/>         }<br/>         if( *n=='\0' )    #G<br/>             return( *nato[x] );    #H<br/>     }<br/>     return('\0');<br/> }</span></pre><p id="d280" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A设置指针n指向当前北约字</strong></p><p id="ab1f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B指针t引用已通过的术语</strong></p><p id="34b0" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #C循环直到北约任期结束</strong></p><p id="88c5" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #D逻辑上把每个字母转换成大写，比较。关于这个和其他ASCII技巧的更多信息，请参考第5章。</strong></p><p id="25d7" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #E不匹配，循环中断，比较</strong> <code class="du my mz na mq b">nato[]</code> <strong class="jk hs">中的下一项</strong></p><p id="1f64" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #F通过每个字母递增</strong></p><p id="0113" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #G当指针n为空字符时，项已匹配</strong></p><p id="f90c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #H返回北约术语的第一个字母</strong></p><p id="ab25" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">istem()</em>函数接受一个单词作为它的参数。如果单词与NATO音标匹配，则返回值是单个字符；否则，返回空字符。</p><p id="0987" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">要创建新的NATO翻译程序，请将<em class="ke">istem()</em>函数添加到源代码文件中。您必须包含<code class="du my mz na mq b">stdio.h</code>和<code class="du my mz na mq b">string.h</code>头文件。然后添加下面的<em class="ke"> main() </em>函数来构建一个新的程序，<code class="du my mz na mq b">nato03.c</code>:</p><p id="8ae7" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单5。nato03.c，main()函数</strong></p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="c065" class="la lb hi mq b fi mu mv l mw mx">int main()<br/> {<br/>     char phrase[64];<br/>     char *match;<br/>     char ch;<br/>  <br/>     printf("NATO word or phrase: ");<br/>     fgets(phrase,64,stdin);<br/>  <br/>     match = strtok(phrase," ");<br/>     while(match)<br/>     {<br/>         if( (ch=isterm(match))!='\0' )<br/>             putchar(ch);<br/>         match = strtok(NULL," ");<br/>     }<br/>     putchar('\n');<br/>  <br/>     return(0);<br/> }</span></pre><p id="4402" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">该代码扫描输入行，查找任何匹配的拼音字母术语。函数<em class="ke">istem()</em>处理这个任务。匹配的字符被返回并输出。下面是一个运行示例:</p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="7e59" class="la lb hi mq b fi mu mv l mw mx">NATO word or phrase: india tango whiskey oscar romeo kilo sierra<br/> ITWORKS</span></pre><p id="5594" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">没有匹配字符的输入句子输出一个空行。混合字符的输出如下:</p><pre class="ma mb mc md fd mp mq mr ms aw mt bi"><span id="ded3" class="la lb hi mq b fi mu mv l mw mx">NATO word or phrase: Also starring Zulu as Kono<br/> Z</span></pre><p id="8827" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果您想添加代码来翻译特殊字符，如标点符号，您可以自己完成。请记住，北约音标缺少带标点符号的术语。不过，如果你正在创建自己的文本翻译程序，可能需要检查特殊字符。</p><p id="b188" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">本文到此为止。如果你想了解这本书的更多信息，请点击<a class="ae jh" href="https://www.manning.com/books/tiny-c-projects?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=book_gookin_tiny_9_29_21" rel="noopener ugc nofollow" target="_blank">这里</a>查看。</p></div></div>    
</body>
</html>