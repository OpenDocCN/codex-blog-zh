# Python 中的面向对象编程—第 1 课。可替代性和继承性

> 原文：<https://medium.com/codex/object-oriented-programming-in-python-lesson-1-substitutability-and-inheritance-e5c6661dfca5?source=collection_archive---------4----------------------->

![](img/db150015c62a9d2cc7c7b546d8cfe04a.png)

这是一系列文章中的第一篇，讨论了面向对象编程所响应的实际需求，以及面向对象语言为支持这些需求而提供的通用工具，重点介绍了 Python 实现和方法。在第一课中，我介绍了面向对象的范例，作为对经常需要功能可替代性的回应，并解释了为什么经常使用 T2 继承来实现 it 基础设施。

## 本课中的部分:

1.  扫描异类集合
2.  信息范式
3.  共性和差异
4.  输入继承！
5.  抽象类
6.  对象初始化

## 1.扫描异类集合

面向对象编程讲的是*功能可替代性*。可替代性，顾名思义，是用一种东西代替另一种东西而不发生显著变化的能力。我们用什么来代替？出于什么目的？如何判断替代的尝试是否成功？是谁不应该注意到替换，以及它是如何被“愚弄”的？好的。我们谈论的是一种可替代的*能力*(做某事的能力)。在某个阶段，我们需要一种我们可以很好定义的能力(根据它应该为我们做什么)，然而可能有许多方法来实现这一点，我们很幸运地允许它们中的任何一种。确切地说:我们正在讨论这样一个用例，其中可供选择的方法范围是 *open* ，选择是 *automatic* 。(而不是局限于从一个明确的和最终的选项列表中进行选择，例如在 if-then-else 中)。让适合这个场合的幸运方法——无论它是什么——从这里接管！

有各种实现功能可替代性的编程设备，例如作为参数传递给另一个函数的函数、委托、状态机等等。面向对象的范例与由*类型*确定的可替代性有关，其中每个能力与一个*对象*相关联，该对象与一个确定方法的类相关联。这听起来并不简单，我知道，这是故意的！因为编程界面简单直观(或者看起来是这样)，所以特别重要的是要精确地了解这里的情况，否则你可能会迷失方向！面向对象中最常见的(也是最直观的)可替换性是一对多。例如，扫描一个*容器*(比如 list 或 dictionary)，其中存储的对象可能属于*不同的类型*，但它们都具有我们需要的相同的——可替换但正确的——功能。在面向对象的术语中，我们说所有被检索的对象*响应相同的消息，*而不管类！我们如何依赖它(容器中的所有对象都响应正确的消息，以及它们是否真的响应)并不重要。Python 允许您将任何消息传递给任何对象。最坏的情况是(当对象的类不支持该方法时)，您会得到一个运行时错误。

*例如(假设适当类圆和矩形，此处不列):*

*输出:*

```
Circle at 55:212\. Area: 7853 
Rectangle at 20:20\. Area: 15000
```

这个容器存储了两个不同类型的对象——一个*圆形*和一个*矩形*——但是都知道如何*计算面积*和*获得位置*(但是就我们所知，每个都适合它的方法)。

如这个简单的例子所示，面向对象的可替代性适用于发送给*对象*的*消息*，其行为由*类*定义。列表中的每次迭代都检索一个新的对象，这个对象可能属于另一个类，也可能不属于另一个类，但是如果对象响应消息“compute*area】*(也就是说，它的类，不管它是什么，都实现了“compute area”的方法)，这与我们无关。

顺便提一句，我更喜欢不常用但却准确的术语“可替代性”，而不是更流行的术语“*多态性”*。(除了明显参考*可替代性原则*，将在本课程结束时讨论)。好吧，将这种编程实践描述为*多态*(“有许多形式”，即*随意替换形式*的能力)是误导！如果多态的意思是一个对象能够改变它的形式，也就是改变它的类，那么这个多态就不是这个情况。扫描一个*异构集合*的情况为该集合提供了一个窗口，该窗口可以在每次迭代中反映一个(可能)不同类的不同对象。因此，可以说在每次迭代中提供方法的类被替换了，不多也不少！尽管如此，没有人改变形式，也没有对象改变类！

面向对象可替代性的使用需要基础设施——面向对象*设计*。我们必须提前准备好这么多类，这些类为同一个消息选择器提供了方法(也就是说，用那个名字定义方法，这些方法接受正确数量的参数并返回正确的类型)。我们刚刚考虑了一个简单的例子，需要两个可替换的能力(来自列表中的每个对象)，但是通常，可替换的对象能力出现在更大的组中。因此，许多几何应用程序期望所有形状不仅获得位置和计算面积，而且还计算周长、检测与点的相交等。这一功能要求也被称为接口的*通用性。(我们这里说的是对接口的一般要求，不要误认为是编程式的*接口*，是由一些面向对象的编程语言实现的——Python*不在其中*——回应这个)。*

*以下是圆形和矩形类的定义(如上所述):*

*脚注:*

1.  Circle 实现了返回点(作为二元组)的位置
2.  Circle 还实现了一个方法来*计算返回整数的面积*。
3.  矩形和圆形一样，也实现了一个方法*得到位置*。
4.  矩形和圆形一样，也实现了*计算面积*的方法。

正如这里所强调的，在 Python 中，对象可以被发送任何消息。(从对象的类中)检索适当的方法被推迟到运行时，承认这种方法可能找不到。这是众所周知的，特别是在解释型语言中，称为弱类型化。(与典型的编译语言中的*强*类型相反，编译时会验证类型兼容性)。Python 程序员传统上不喜欢这两个术语，因为 python 哲学将所需的功能与对象在实践中能够提供的东西联系起来，而不是与其声明的类型联系起来。因此，一些 Python 开发人员喜欢带着典型的 Python 式幽默，将 Python 版本定义为“*Duck Typing”*。如果这个任务需要一只鸭子(准确地说:鸭子*功能*，那么如果候选人*看起来像鸭子*，*像鸭子一样叫*，并且*像鸭子一样走路*(如果这就是我们对它的全部要求)，那么，据我们所知，*它就是一只鸭子！*(哪怕生下来就是猪)。

## 2.信息范式

正如开始时提到的，面向对象版本的可替代性并不是唯一可编程的选项。但如果处理得当，它是简单、直观且非常灵活的。例如，将异类形状系列与一些自制的替代产品进行比较:

老派过程语言中函数可替代性的一个常见解决方案是——期望一个*标记的记录*或*标记的联合* —首先查询对象的类型，然后相应地选择显式方法。

要深入研究这个设计中出现的所有问题，将需要一个单独的讲座。以下是一些亮点:

1.  所有候选方法都提前透露，即使不采取！
2.  所有候选形状类型都是预先指定的，因此*关闭了*添加其他可能也支持该功能的类型的可能性。当在程序的一部分填充容器，而在另一部分进行扫描时，这(添加形状类型的可能性)是至关重要的。这两个函数没有理由在确切的类型范围上保持一致(假设支持通用功能)！然后，当(不可避免的)需要添加另一种形状(比如三角形)时，我们必须*通过添加另一个显式分支到选择树来打破*这个代码。我们说代码被破坏了，直到所有的测试用例都运行了一夜，并证明仍然像预期的那样工作。
3.  这个解决方案不考虑它显示的形状的*信息隐藏*。与期望客户机从对象请求信息的面向对象的解决方案不同(使用消息范例)，在这里，客户机实现所有不同的方法。它知道圆形和矩形是如何制作的，以及如何计算它们的面积。这种智慧不属于这里！(这里隐藏的唯一智慧是如何扫描容器和如何将文本显示到屏幕上，不多也不少)。将这个逻辑和数据封装在一个类中是一个更好的选择(在这种情况下)。
4.  这种编程风格需要大量的代码冗余。假设(非常现实地)我们必须在其他地方重复这个逻辑，我们也需要一个类似的代码来扫描一组形状并显示它们的周长，测试它们是否与一个点相交，等等。我们刚刚制造了一些维护噩梦！每次添加形状类型时(或者现有形状的内容或逻辑发生变化时)，我们必须将更正传播到重复代码的所有出现处。首先，这是一件令人高兴的事情，我们知道这些事件发生在哪里。例如，如果我们开发了供其他人使用的基本软件，我们现在必须联系他们每个人并通知他们变化(如果他们能在第一时间找到变化，希望他们真的能找到时间来修改他们的代码，等等)。

当然，像上面这样的代码并不完全是无用和糟糕的。(如果是这样的话，语言中就不会有`elif` 关键字了)。如果问题域确保只有这两种可能性(圆形和矩形)，并且它们的内部结构和逻辑简单明了，不需要改变(这样暴露和重复就不是问题了)，那么简单的备选列表就可以了(面向对象的解决方案是多余的)。然而，这通常适用于简单的基于基本类型的替代列表，如枚举和字符串，而不是具有重要逻辑的复杂数据结构。

实现功能可替代性的另一个过程实践是将每个候选对象转换为通用表示类型(当然，如果存在并适用的话)。因此，就方法而言，不存在可替代性(该方法过去和现在都是*强类型*)。然而，操纵的对象在到达之前已经被转换(即被替换)。

因此，假设所有形状都有一个*字符串表示*(即*可转换*为字符串)，并且这(转换为字符串)满足我们的功能需求，那么我们可以将当前形状转换为字符串，然后显示它。 *print* 函数需要一个字符串，但得到了一个。它不关心字符串来自哪里。(实际上，默认情况下，内置的 print 会负责转换，但这不会改变示例)。

一个更实际的用例是涉及两个不同类型数字的算术运算(例如，将整数加到浮点上)。这一功能需求在大多数编程语言中是这样实现的:首先*将*精度较低的*数字转换为*精度较高的*类型，然后自然地对同一类型的两个对象执行算术运算符(返回精度较高的数字类型的实例)。*

但是这种情况并不常见，我们的形状也不适合。形状意味着以图形方式呈现并用于几何计算。将形状转换为字符串没有任何应用意义(除了 dump 用于调试和序列化的技术用途(用户不可见)之外)。

这给我们留下了“面向对象”的解决方案。以构建基础设施(具有接口通用性的类)为代价，它确实很好地服务于功能可替代性的目的，并且是*开放*(对于*扩展*，至少在附加形状类型的维度上，如果保持接口的通用性)，同时是*关闭*(对于*修改*。用例—例如，异构集合扫描—保持不变，即使添加了新的类，只要接口保持不变)。

范例是面向"*对象"*"的，因为方法(如何执行动作)是由*对象*-动作的接收者(如对象的语法定义)决定的。相反，在*过程化*编程中(如在显式选择列表中)，方法由*动词*决定。你所做的正是你所陈述的，而不考虑遭受结果的对象(或要求结果的主体)。

**“消息”范例:**对一个对象的操作(不管它是改变对象还是仅仅从对象中提取信息)是通过(1) *向对象传递一个“消息”*来执行的，它由*消息选择器*和可选的参数组成。(2)*接收者*对象*通过应用*“方法”*“响应”*消息，由它的*类*实现。

**可替代性:**无论接收方是什么对象；它的*类*必须实现*方法！*

![](img/b0cdc35e77e551145b1d38a6f30f2934.png)

该图描述了*后期绑定*(消息选择器到方法)的编程机制。给定消息选择器和接收者对象，并检索对象的类，我们从由消息选择器键控的类中检索适当的方法，并将其应用于对象(“self”参数)。

简单地说，*面向对象的*对*的解释“我们知道必须做什么，但是有许多方法去做……”*继续进行“*……并且它(如何做)取决于对象的类型(动作的接收者)——所以让对象，不管它可能是什么，为我们做吧！”。准确地说:面向对象的范例用更简单的挑战*处理*一个可替代的*对象*来代替*激活*一个可替代的*能力*的挑战。这个所谓的*“左手多态性”*(稍后将讨论)是简单的，自我解释的，并且非常有效地以编程方式实现。(不要问令人尴尬的问题，比如显式的 switch/case 结构)。当然，只要在*内使用它的*问题域。什么？在面向对象的问题领域*之外有用例*吗？嗯，有一些，我们将在第三课讨论其中的一些。*

*数据字典:*

1.  **所需接口。**消息选择器数组。
2.  **阶级。**(除了别的以外)，方法数组(对应于一个或多个必需的接口)。
3.  **消息。**涉及接收者对象、消息(通常是方法名)和可选参数的程序性构造。
4.  **法。**类的对象如何响应消息选择器。
5.  **装订**(也叫分派)。给定对象和消息选择器，找到方法(在对象的类中)。
6.  **可替代性**(也叫多态性)。向未知类的对象发送消息的能力(但符合已知接口)。
7.  **后期绑定**(也叫运行时调度，动态调度)。用于(透明地)实现可替代性的编程机制。

## 共性和差异

所有的形状类型*共享一个公共的*接口(即相同的方法名)，一些公共的数据和一些公共的实现，但是*在额外的数据和计算面积的方法上*有所不同

*脚注:*

1.  数据的共性:中心点(x 和 y)。
2.  数据差异:特定属性—半径、宽度、高度。
3.  界面通用性:获取位置。
4.  实现的共性:如何获得位置的方法。
5.  界面的通用性:计算面积。
6.  实施差异:面积的计算方法

## 4.输入继承！

*继承*是一种方便的机制，用于从一系列类中分离出公共行为(方法)和数据，这些类在一些需要公共接口的典型用例中是功能上可替换的(受到一些限制，有待讨论)。但是要强调的是，在 Python 中，继承是很好的(但不是必须的)！与其他一些面向对象语言不同，Python 不需要继承作为可替换性的先决条件——还记得 *duck typing 吗！*

*脚注:*

1.  类形状排除了有用的形状类型(圆形和矩形)的通用性，以及(希望)后面引入的其他形状类型的通用性。
2.  数据的共性(中心点)。数据的方差(半径、宽度和高度)被排除。
3.  实现的通用性。如何获得位置的方法是在图形中实现的。
4.  预期实现的差异。“Shape”是一个*抽象*类，并不意味着创建真实的对象，因为(至少)实际上计算面积的方法是特定的，不能被分解。尽管我们不能阻止任何人创建形状，但我们确信要求蹩脚的形状计算面积会导致错误。
5.  Circle 类现在是 Shape 的*子类*(同样，*从*派生而来)。我们将超类“Shape”作为参数发送给 Circle 类的初始化。结果是，这里没有定义或实现的任何东西——数据、接口和方法——都是从抽象形状中“继承”。
6.  尽管形状并不意味着独立存在，但它*确实存在*，作为圆的一部分，也必须被初始化。(Python 似乎有一个奇怪的语法来做这件事——有待讨论)。
7.  数据的方差。圆也有半径(除了从形状继承的中心点)。
8.  实施差异。圈出*“覆盖”*计算面积的能力，用方法完成。
9.  矩形也是 Shape 的子类。
10.  数据的方差。矩形还具有宽度和高度(除了从形状继承的中心点之外)。
11.  实施差异。矩形也*“覆盖”*计算面积的能力，用方法完成。
12.  Triangle 从 Shape 继承了一切——行为、数据和实现。它只是增加了数据——三个方面。
13.  要求三角形计算面积，这是它没有的方法。是吗？

*输出:*

```
7853
Abstract method “calcArea” not implemented!
```

*继承的类图符号。*

![](img/be81bc1ce2e7c6fafa43db8641d65d11.png)

该图还展示了两种常见的用法*惯例*。(1)将超类*置于其子类*之上，以及(2)统一通向超类的关联弧。

传承既是福也是祸。对于我们的目的来说，一个继承层次结构，无论多么密集和大量投资，在我们拥有的如此多的用例中(以及——希望——在维护期间积累的用例中)只是功能可替代性的基础设施。避免*【语义层次】*谬误！(可能对其他用途有用，但和软件设计的实际需求关系不大)！出于某种原因，许多人——包括一些写教科书的人——倾向于通过一般和想象的场景来解释*程序化*继承——例如，包括狗和猫以及它们发出的声音——与*软件*(所有事物)的任何商业用例无关。将遗传与一些哲学或其他特征联系起来是你的特权，如果这有助于你记住相关的术语。但是，如果你不想加入那些对面向对象的范例感到沮丧的人(通过他们自己的错误解释)，请记住，我们正在处理的是一种由编程工件(类、对象、消息)组成的编程机制，并且在缺乏对功能可替代性的实质性挑战的情况下，这种机制提供了可疑的用法！

## 5.抽象类

与许多其他面向对象的语言不同，出于某种原因，Python 没有*抽象*关键字。但是，由于将确保抽象类的抽象性(并迫使子类覆盖抽象方法)的任务留给用户也不是一个特别聪明的想法，因此在某个时候，内置库中添加了一种机制来完成这一任务——“ABC”(抽象基类)模块。使用 ABC 确保(在运行时)( 1)抽象类的对象不允许初始化,( 2)抽象类的子类确实覆盖了它们继承的抽象方法。后一种检查是在对象初始化时完成的，这是对我们的用户定义解决方案的改进(它允许我们创建 lame 对象，但只有在需要缺失方法时才会失败)。

*脚注:*

1.  从“abc”模块导入。
2.  Class Shape 继承自 ABC，这使得它成为一个*抽象类*——让我们拭目以待。
3.  计算面积的方法被修饰为*抽象方法*，注意不覆盖该方法的形状和子类的对象将不会成功初始化。
4.  该代码试图初始化 Shape 对象。会成功吗？
5.  该代码试图初始化一个三角形对象。会成功吗？

*输出:*

```
3631
Can’t instantiate abstract class Shape with abstract method calcArea
Can’t instantiate abstract class Triangle with abstract method calcArea
```

圈子做的很好！但是初始化 Shape 和 Triangle 对象的尝试引起了错误。我们还被告知缺少哪种方法！

Python 对面向对象的可替代性的实现简单而优雅，使功能的继承和覆盖变得直观。尤其是与其他一些语言相比，由于复杂实现的限制(由于其他义务)，这些语言的行为有时是反直觉的。

首先，Python 对象的消息选择器(在运行时)在它的类提供的字典中查找。因此，我们不必为诸如表、指针、内存偏移量之类的技术细节以及这种实现不可避免地产生的意想不到的复杂性而烦恼(最臭名昭著的是在 C++中)。在 Python 中，如果你知道自己在可替代性和继承性方面做了什么(这很简单)，你就永远不会对自己程序的行为感到困惑，也不会诉诸反直觉的技巧来强迫你的代码按照你的方式做事。长话短说:给定一个消息选择器(方法名——一个字符串), Python 使用这个名称作为键来查找属性字典并检索方法(如果可用的话),然后调用对象上的方法(“*self”*参数)。(原则上)就是这样。更简单的是，Python 对象只有一个属性字典，其中所有的方法都已经被覆盖并绑定到 self，所有的数据都已经被初始化器序列加载。这种特殊的实现有两个深刻的含义:一方面(1)，初始化一个对象可能要花很长时间(为可替换性做准备)(2)，继承，无论多深，都不会反映在消息传递上(找到方法所需的一切都已经存在了)！

顺便提一下，这个架构解释了为什么初始化器*超级调用*(初始化一个人的超类部分)必须被转发到基类(一个*对象*)，像在`MyBase.__init__(self)`中一样，是未绑定的。对象的属性字典指向自己的初始化器(如果被覆盖)，绑定到 self，这不是我们想要的(我们已经在那里了)。为了获得超类的初始化器，我们必须求助于超类中的未绑定方法(通过名称全局可用)并通过 self 调用它。(稍后将详细介绍绑定和未绑定方法)。

## 6.对象初始化

在下面的例子中，超类和子类都有初始化器(构造函数)。重写子类中的初始化式就是这样做的:它替换(“重写”)对象属性字典中继承的初始化式，然后就永远丢失了！因此，当这样的子类对象被初始化时，它的超类部分将不会被初始化，从而导致例如本应被继承的数据的丢失。无可否认，这种行为在设计上是反直觉的，并且不像编译的面向对象语言的行为，在面向对象语言中，成员数据被指定为类的一部分，而不是初始化过程的一部分。但是一旦你进行了范式转换，Python 的行为就变得一致和可预测了(直觉符合它)。

*脚注:*

1.  用一种草率的方式指出什么应该是一个*抽象*方法。
2.  糟糕，Circle 忘记初始化它的形状部分(并忽略中心点参数)！
3.  如何获得外接矩形的 Circle 方法理所当然地认为它应该继承 Shape 的中心点。

*输出:*

```
’Circle’ object has no attribute ‘y’
```

如果你覆盖了初始化器，不要忘记初始化你的超类部分(如果需要的话)。事实上，在下面的例子中，超类和子类都有正确使用的初始化器。(与原始继承示例一样)

*脚注:*

1.现在超类部分被初始化了。初始化器超调用自然位置在设置子类状态之前*(因为后者自然*依赖于前者*)。但这是一个惯例。与其他一些面向对象的语言不同，Python 不限制在哪里初始化超类部分(或者，正如我们已经看到的，根本不限制是否初始化它)。*

*输出:*

```
((5, 5), (25, 25))
```

但是当子类没有显式初始化器时，超类初始化器被用来填补这个空白。(而且，因为子类没有额外的数据，所以没有什么可做的)。这是属性字典架构的结果。该对象继承了它的超类的初始化式，因为它不关心覆盖它，这就是它得到的。

例如，Point 是一个没有显著尺寸的形状(但仍然从 shape 继承中心点)，因此没有什么需要初始化的。

*脚注:*

1.这个点没有我们可以看到的初始化器，所以它是在没有参数的情况下初始化的，这就引发了一个错误！

输出:

```
Shape.__init__() missing 2 required positional arguments: ‘x’ and ‘y’
```

现在，用正确的参数初始化这个点(到它的形状部分初始化器)。

*输出:*

```
((10, 15), (10, 15))
```

## 接下来呢？

在第一课中，我们已经考虑了面向对象的范例，作为在某个(但是频繁的)应用上下文中对*功能可替代性*的需求的响应。然后，我们看到了为什么*继承*经常被用来为它构建基础设施(以及为什么它确实有用——但是*在 Python 中不是必需的*)。这提供了基础。但是，不建议从这里自行出发(至少，不要构建非同小可的商业应用)！面向对象— *惊喜，惊喜！* —不是万能的！不幸的是，面向对象编程既有快乐的实践者，也有失望的实践者(但无论如何，它将继续——并且肯定会继续——被广泛使用)！经验表明，面向对象编程的好处是与根据通用的设计习惯、模式和架构来应用它联系在一起的。因此，本课程的其余部分将致力于展示这些常识中的一些更重要的知识，在下一课中，我们将从展示面向对象编程的强大功能的一些重量级设计模式开始。(在接下来的课程中，我们将尝试解决不那么迷人的一面)。

## 本课程中的课程:

1.  **可替代性与继承性** *(你来了！)*
2.  面向对象可替代性的荣耀:“复合”模式
3.  面向对象可替代性的限制:“访问者”模式
4.  一些无聊的设计模式
5.  继承的限制