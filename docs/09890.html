<html>
<head>
<title>Managing Software Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理软件复杂性</h1>
<blockquote>原文：<a href="https://medium.com/codex/managing-software-complexity-afbe9084f8e0?source=collection_archive---------8-----------------------#2022-11-17">https://medium.com/codex/managing-software-complexity-afbe9084f8e0?source=collection_archive---------8-----------------------#2022-11-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e4b0ffbe20e9ea7be393a3f9645102cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1iIUjyTg9gOYOGvzGyQAw@2x.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://pixabay.com/users/johnny_gutierrez-15803161/" rel="noopener ugc nofollow" target="_blank">约翰尼·古铁雷斯</a>创作的玩具-玩耍-塑料-滑稽-蚁人获得了<a class="ae iu" href="https://pixabay.com/service/license/" rel="noopener ugc nofollow" target="_blank"> Pixabay许可</a>的许可</figcaption></figure><p id="5fa0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有两个软件代码库是相同的。但可以肯定的是，它们都有不断变化、规模不断扩大、相互依赖程度不断提高的特征。这种相互依赖，或者也称为耦合，导致了每个开发人员最大的挫折之一——副作用。</p><p id="2789" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我很清楚我在做什么。让我来改变这个小东西。哦！那里到底发生了什么事？我们都经历过。很多次。</p><p id="e346" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它可能以僵化的形式出现，在这种情况下，需要进行的一系列变革被揭露出来，以适应眼前的变化。或者脆弱性，即在代码的某个不相关的部分出现一些奇异且耗时的bug。无论哪种方式，它都让生活变得不可预测，并且总是比我们最初想象的要多。</p><p id="30e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么这个怎么处理呢？</p><h2 id="18db" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">分解和抽象</h2><p id="f38a" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">复杂性的第一个挑战是理解它。任何稍微复杂的认知负荷对我们来说都太大了。因此，面对一个复杂的大问题，我们会立即将它分解成许多更小更简单的问题。这导致了抽象的层次。我们可以看到任何一段特定的代码，大部分的复杂性都从我们这里抽象出来了。这限制了认知负荷，让我们能够理解它。</p><h2 id="75db" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">再用</h2><p id="191c" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">复杂性源于不断的进化。我们在已经存在的基础上进行建设。拿技术来说。当我们创造新的东西时，它集合了许多过去的创新。我们正站在巨人的肩膀上。没有轮子的出现，没有制造橡胶、玻璃和石油的过程，汽车就不可能出现。冶金、电力、内燃机和其他一千多项创新。</p><p id="bc7a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">软件开发也不例外。我们不写机器码。我们不会通过编写操作系统或数据库来开始一个新的代码库。我们使用高级语言和它们的标准库。我们使用框架。我们从stackoverflow和package managers。重用是灌输给我们所有人的首要原则之一。不要重新发明轮子！</p><h2 id="7f22" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">复制</h2><p id="a41d" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">与重用密切相关的一个问题是重复。不要复制粘贴！还是干原则——不要重复自己。当我们删除重复时，我们降低了复杂性，因为这些重复中的每一个都代表一个单独的路径，并且可以独立地改变。消除重复通常更有效。拥有一个单一的表示使改变更加可靠和容易。</p><p id="4abd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是复制并不总是坏事。因为它使独立性成为可能，而且在一个日益复杂的时代，消除依赖性往往是至关重要的。因此，使用微服务架构的自治团队可能更喜欢复制代码，而不是将自治权让给外部团体。相对于传统关系数据库中规范化数据的一致性和存储效率，大规模NoSQL数据库更喜欢非规范化，以提高性能和可用性。</p><h2 id="5d7e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">内聚力</h2><p id="717f" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">初露头角的软件工程师学到的另一个口头禅是高内聚和低耦合。而且如果你实现了其中一个，你很可能会得到另一个。这是为什么呢？</p><p id="9b2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">凝聚力是指你把有很强依赖性的东西放在一起。换句话说，消除摩擦来获得和控制你最依赖的东西。拿智能手机来说。它不仅仅是一部手机。一台电视、一台收音机、一份报纸、一家商店、一台游戏机、一个手电筒、一个卫星导航系统，等等。但它真正的超能力是它能做所有这些事情，并且能装进你的口袋。这意味着它可以不断接近和可用。你有没有去某个地方旅行，然后意识到你忘了带手机？然后借别人的手机打电话给你手机附近的人，让他们启动一个应用程序，然后试图记住你的密码，因为你总是使用你的指纹？痛苦。就像不断变化的软件严重依赖于其他类中的东西，或者更糟的是在另一个团队拥有的另一个服务中。</p><p id="45e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">内聚的另一个好处是它鼓励专注(单一责任原则),因此它所依赖的东西的数量，传出耦合，被限制，风险被包含。</p><h2 id="8228" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">包装</h2><p id="fd8c" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">一旦我们有了内聚的东西，比如一组功能和数据，我们就可以把它封装在一个接口后面。任何依赖于它的东西现在都将与稳定接口交互，而它后面的所有东西都被封装起来，不能直接访问。这极大地减少了可能依赖的表面，只要满足接口，允许封装的所有东西更容易改变。这为诸如重构之类的变更提供了灵活性。</p><p id="89c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在绕过封装时应该小心。比如反射，将私有方法公开，或者公开getters(德米特定律)。封装有助于在进行更改的同时提高稳定性。</p><h2 id="2c14" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">稳定方向</h2><p id="784a" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在稳定依赖原则中，罗伯特·马丁指出我们应该“依赖于稳定的方向”</p><p id="5c6e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑这个问题的另一种方式是使用传入耦合，这是依赖于你正在改变的软件的东西的数量。</p><p id="f935" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你的软件可能一开始只是一个主文件。当这种情况发生变化时，风险就包含在自身之中，因为没有任何东西依赖于它。如果出了问题，答案就在你面前，在你的掌控之中。</p><p id="fc8e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是当你不断地添加软件和抽象时，一个层次结构就形成了，一些更深层次的软件开始被更广泛地重用。它们的稳定性变得更加重要，因为它们有许多传入依赖性。现在，当你改变时，你会产生连锁反应，影响到其他地方，并可能以多种方式表现出来。</p><p id="d19d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，当你使用最广泛的代码时，它需要依赖更稳定的代码，比如标准库函数。</p><p id="7c55" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似的事情也发生在API开发中，其中总是要考虑向后兼容(即稳定性)。API经常被发布以供在许多情况下使用。它们可以通过互联网公开访问。同样，我们有一个高传入耦合的情况，需要高稳定性。</p><p id="5d7c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在复杂性科学中，当你高度依赖时，会导致一种叫做锁定的现象。变革的成本过高，意味着即使有更好的选择，也无法变革。一个这样的例子是qwerty键盘。</p><p id="379e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么如果我们的代码变得如此广泛地被使用，以至于被锁定了呢？那我们该怎么办？</p><h2 id="68a6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">不可改变的选择</h2><p id="7f64" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在软件开发中，变化是不可避免的。但是，我们可以做的是，对哪些地方会发生变化，哪些地方不会发生变化做出审慎的选择。还记得封装是如何支持重构的吗？我们创建一个接口来依赖和保护我们封装的代码免受外部依赖。现在当我们重构时，我们已经创建了一个界面对任何外部依赖都是稳定的情况。但是它背后封装的代码是可以自由更改的。</p><p id="91e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们考虑一个我们认为可能会被“锁定”的类。我们可以使用依赖倒置原则，这样它只依赖于抽象的而不是具体的实现(即稳定的接口)。这使我们能够满足开放封闭的原则，即我们对变化是封闭的，但对修改是开放的。我们已经接近改变班级了。但是它包含的接口意味着，通过将我们的类(通过类似依赖注入的东西)与现有依赖的更新或符合现有接口的全新依赖相结合，可以修改整体行为。</p><p id="e6bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这真的能保护我们免受未来变化的影响吗？毕竟，我们无法预测无数的未来需求。这是真的。但是组合有迎合难以置信的多样性的习惯。想想DNA。</p><p id="16d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是我们仍然需要在我们的依赖项中编写新的代码，我们已经更改了调用代码来重新组合它们。那么我们得到了什么？</p><p id="5d38" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住引用。调用代码位于调用栈的更高层，因此根据稳定依赖原则，它比我们的类具有更少的传入耦合，因此更改的风险更小。</p><p id="5e52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">依赖性反转是我们可以用来实现组合和重用方法的许多技术之一。有设计模式，如装饰、组合、策略和适配器。或者是管道和过滤器设计，这与您链接命令的Unix管道非常相似。这也类似于函数式编程的概念，函数式编程因其无副作用的行为而被吹嘘。</p><p id="279e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们不得不编写新的依赖项来处理我们的“锁定”类，这是怎么回事？这是避免复杂性风险的另一个有用的方法，因为当我们创造新的东西时，它保证了零传入耦合。怎么可能是别的呢？一分钟前它还不存在。</p><p id="6a4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种创造新事物而不是修改现有事物的偏好可以在许多其他方法中看到。</p><p id="7946" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如对象状态的不变性，这提供了诸如在多线程环境中线程安全使用的好处。</p><p id="a72b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，在分布式系统中，Kafka等工具或event sourcing等技术总是通过添加新项目而不是修改现有内容来实现其可靠性和可伸缩性。</p><p id="9f80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有这些方法的共同点是有意选择使某些东西可变，而另一些东西不可变。更好地管理复杂性和风险。</p><h2 id="91b9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">简单</h2><blockquote class="kt ku kv"><p id="8160" class="iv iw kw ix b iy iz ja jb jc jd je jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated">“简单是最复杂的”莱昂纳多·达·芬奇</p></blockquote><p id="4ef0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">弗雷德·布鲁克斯对本质复杂性和我们试图解决的问题所固有的复杂性进行了有益的区分；以及偶然的复杂性，这种复杂性是我们做出的所有技术和设计决策的结果。简单是通过关注前者而避免后者来实现的。</p><p id="b2d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么我们如何避免意外的复杂性呢？</p><p id="4ee9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">避免过度工程化。有时候我们可能太草率而无法抽象。抽象有增加间接性和复杂性的缺点。这方面有一些有趣的指导原则，比如“三法则”，你可以推迟删除重复，直到你看到一个模式出现三次，而不是正常的两次。</p><p id="8d8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">设计模式也可能是问题的来源。应用一个模式的关键是识别它有用的环境。任何模式都没有普遍性。没有经验的开发人员经常随意应用它们，混淆代码。</p><p id="3472" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有时候，随着我们了解的越来越多，我们可能会意识到早期的抽象是一个错误的选择。不要让骄傲成为障碍。逆转它。Sandi Metz很好地证明了这一点。</p><div class="la lb ez fb lc ld"><a href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction" rel="noopener  ugc nofollow" target="_blank"><div class="le ab dw"><div class="lf ab lg cl cj lh"><h2 class="bd hj fi z dy li ea eb lj ed ef hh bi translated">错误的抽象——桑迪·梅茨</h2><div class="lk l"><h3 class="bd b fi z dy li ea eb lj ed ef dx translated">我一直在思考“错误抽象”的后果我的RailsConf 2014“所有小事”讲座…</h3></div><div class="ll l"><p class="bd b fp z dy li ea eb lj ed ef dx translated">sandimetz.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr io ld"/></div></div></a></div><p id="5770" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">TDD的红绿重构循环也有助于我们避免不必要的抽象。Red，写一个失败的测试来精确地说明你想要达到的目标(什么是基本的)。绿色，做最简单的事来实现我们的目标。最后，重构代码，从而将抽象限制到一个经过验证的工作解决方案。在这一点之前抽象是过度工程化的一条道路。没有经验的开发人员可能会开始关注抽象、模式、框架和闪亮的技术。以至于他们已经完全忘记了当初为什么要写代码。正如他们所说的YAGNI。</p><p id="dcd4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但最重要的是，如果我们想要简单，我们需要非常清晰地关注本质的复杂性。我们试图解决的问题。谁将从它的解决中获得价值。为什么与我们正在创建的解决方案进行交互会满足这些需求。</p><p id="4deb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">领域驱动设计是实现这一点的一个很好的方法。它通过发展直接翻译成代码的领域语言和领域模型，使开发人员沉浸在我们客户的需求中。领域模型只关注业务问题、业务规则和约束。它被紧密封装，并与持久性、消息传递和其他基础设施领域等技术问题分开。对保持领域模型纯净的关注感觉就像你接近本质复杂性一样。</p><h2 id="c258" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">反馈</h2><p id="cfda" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在所有这些之后，我们的故障安全仍然是持续的快速反馈。</p><p id="e869" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">即使在本书中的每一个管理复杂性的技巧之后，我们单独的分析总是会被认知负荷和不完整的知识所破坏。偏见、疲劳、情绪和无数其他隐藏在我们易犯错误中的小缺点。</p><p id="7a0e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，进行测试驱动开发，不断测试我们的解决方案是否如预期的那样工作，没有副作用。</p><p id="4add" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">进行持续集成，这样我们就可以避免在branch hell中的另一个复杂的蠕虫罐。</p><p id="4456" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">进行持续交付，将我们的解决方案逐步交付到客户手中。不仅仅是为了测试它在野外的工作情况。这永远不够。而是测试我们的解决方案满足预期需求并在下一级复杂性中增加价值的假设。市场力量。一系列顾客。以及社会的变幻莫测和千变万化。</p><h2 id="955a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">参考</h2><p id="308e" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">敏捷原则、模式和实践——罗伯特·马丁</p><p id="73eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">干净的建筑——罗伯特·马丁</p><p id="b836" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">领域驱动设计–Eric Evans</p><p id="5a59" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">AddDot播客:软件设计中的平衡耦合—<a class="ae iu" href="https://play.acast.com/s/6114808e7cabda001215fd53/62be625278ab770013f89a1d" rel="noopener ugc nofollow" target="_blank">https://play . acast . com/s/6114808 e 7 cabda 001215 FD 53/62be 625278 ab 770013 f 89 a1d</a></p></div></div>    
</body>
</html>