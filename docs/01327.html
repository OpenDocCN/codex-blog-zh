<html>
<head>
<title>Tip of the Day: Modular AI Waypoint System in Unity3D</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">日积月累:Unity3D中的模块化AI航路点系统</h1>
<blockquote>原文：<a href="https://medium.com/codex/tip-of-the-day-modular-ai-waypoint-system-in-unity3d-9c14ca30a1ef?source=collection_archive---------12-----------------------#2021-04-19">https://medium.com/codex/tip-of-the-day-modular-ai-waypoint-system-in-unity3d-9c14ca30a1ef?source=collection_archive---------12-----------------------#2021-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b2c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在你的游戏中，很多时候你希望你的敌人在两个或更多点之间的某个区域巡逻，也许让他们在移动到下一个路点之前停一会儿。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/2e8c37a9b0df8ac81b34f6b4cb75b480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GoP_EVAr0XU-Ya-9PzRC5A.jpeg"/></div></div></figure><blockquote class="jp jq jr"><p id="e241" class="if ig js ih b ii ij ik il im in io ip jt ir is it ju iv iw ix jv iz ja jb jc hb bi translated">让我们看看如何实现这一点！</p></blockquote><p id="7453" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们开始为敌人AI创建一个新的C#脚本，它将负责移动你的敌人。(这种方法取决于你的游戏在你的关卡中使用导航网，在你的敌人身上使用导航网代理。)</p><p id="0b86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在获取NavMeshAgent并创建一个包含航路点的列表。</p><pre class="je jf jg jh fd jw jx jy jz aw ka bi"><span id="5a7e" class="kb kc hi jx b fi kd ke l kf kg">[SerializeField] private List&lt;Transform&gt; _waypoints;</span><span id="8795" class="kb kc hi jx b fi kh ke l kf kg">NavMeshAgent _agent;</span><span id="aa16" class="kb kc hi jx b fi kh ke l kf kg">private void Awake()<br/>    {<br/>        _agent = GetComponent&lt;NavMeshAgent&gt;();<br/>    }</span></pre><p id="74d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，让我们创建一个int“_ current target”并将其设置为0。这将代表我们创建的列表的索引。因此，在开始时，当前航点索引为0，这是第一个航点。</p><pre class="je jf jg jh fd jw jx jy jz aw ka bi"><span id="c9bf" class="kb kc hi jx b fi kd ke l kf kg">private int _currentTarget = 0;</span></pre><p id="031f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑一下我们将在更新方法中应用的逻辑。</p><ol class=""><li id="6e29" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kn ko kp kq bi translated">我们需要检查检查器中是否设置了航路点</li><li id="6a7b" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">如果有航路点，那么我们告诉navMeshAgent将敌人移动到_currentTarget索引(开始时将为0)</li><li id="c73a" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">我们需要知道敌人是否在目标航路点的一定距离内，那么他已经到达了目标</li><li id="18f6" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">我们需要知道下一个航路点是什么</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kw"><img src="../Images/9f3bb24014ae26bc63529016c1b386aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oOqab2SNn-5NQNyBGUGsHQ.png"/></div></div></figure><p id="8eeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了知道下一个航路点，我们将创建一个协程“WaitBeforeMoving”。<em class="js">这里的逻辑是什么？</em></p><ol class=""><li id="8ba6" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kn ko kp kq bi translated">让我们创建一个bool并调用is _reverse，以便让敌人在路点之间正确循环。</li><li id="bf34" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">如果AI是第一个和最后一个点，我们让他等一会儿(如果你想让他在每个点都停下来，你可以改变这一点)</li><li id="424a" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">如果他没有倒车，我们增加航路点索引</li><li id="fe6a" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated">如果他在倒车，我们就减少航路点索引。</li></ol><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/8669fa62ffe685e4b97c0157035bf521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kng4Sbf4kH9SkyubQUT9KQ.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/5d69f4bda9009170b09e09ea52e32d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*ejzoIdmwXaQST9bbsjlD5g.jpeg"/></div></figure><p id="e717" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这里，你可以很容易地扩展这个方法，例如有一个警告状态，或者基本上你想要的任何东西。这只是骨干。</p></div></div>    
</body>
</html>