<html>
<head>
<title>Big O in Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编程界的大O</h1>
<blockquote>原文：<a href="https://medium.com/codex/big-o-in-programming-c86803b01532?source=collection_archive---------15-----------------------#2022-05-24">https://medium.com/codex/big-o-in-programming-c86803b01532?source=collection_archive---------15-----------------------#2022-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0ff2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">程序执行需要时间和内存，它取决于执行程序的计算机的处理速度。在我的机器上执行一段代码可能需要1秒，而同样的代码在另一台机器上可能需要或多或少的时间，这取决于它的处理能力。这意味着我们不能根据执行时间来衡量代码性能，它应该独立于机器资源。</p><p id="46eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的代码有两个品质:</p><ul class=""><li id="9a7a" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><em class="jm">可读性</em></li><li id="4c95" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><em class="jm">可扩展性</em></li></ul><p id="6576" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">可读性</strong>意味着代码对开发人员来说是可读且易于理解的。这通常意味着代码应该有适当的编码风格、格式、命名约定和注释，这样其他开发人员就可以很容易地使用您的代码。</p><p id="ec4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">可伸缩性</strong>意味着代码应该易于扩展以适应更大的输入，并且不应该中断。例如，如果一个应用程序目前有一千个用户，在未来，用户群增长到数百万，应用程序应该工作相同。为了开发可扩展的应用程序，需要对代码进行大O分析，尽可能提高代码的效率。</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="fb94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">大O符号</strong>用于根据<strong class="ih hj">空间和时间复杂度</strong>评估代码的性能矩阵。它通过估计执行时间和空间来判断代码在较大输入下的执行情况，而不考虑它在什么硬件上执行。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es jz"><img src="../Images/89ce91cfb9d2b5a4936bc96f6e874616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgqmgxAUeiKbUFYmnrUpsw.jpeg"/></div></div></figure><blockquote class="kl km kn"><p id="dfa6" class="if ig jm ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated"><strong class="ih hj">时间复杂度:</strong> <em class="hi">预计执行所需的时间</em></p></blockquote><p id="777b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下几点将帮助您如何计算代码的大O时间复杂度:</p><ul class=""><li id="f70b" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">=，+，-，*，/，%的大O是0(1)</li><li id="09eb" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">loop的大O是O(N ),其中N是循环执行的次数</li><li id="8bd4" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">大O总是估计最坏的情况</li><li id="ad8f" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">一般O(1) + O(1) + … = O(1)和O(N) + O(N) +…= O(N)</li><li id="7439" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">此外，我们忽略了常数项和赋值，只计算循环和昂贵的运算。</li><li id="b655" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">嵌套循环的大O是O(N) * O(N) = O(N)</li><li id="ed69" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">对于嵌套循环的不同输入，O(N) * O(M) = O(N*M) = O(P)</li></ul><p id="5ac8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑以下代码:</p><pre class="ka kb kc kd fd kr ks kt ku aw kv bi"><span id="0af9" class="kw kx hi ks b fi ky kz l la lb">def TwoSum(numbers, target):</span><span id="bc80" class="kw kx hi ks b fi lc kz l la lb">    mapValues = {}                                     O(1)</span><span id="ec3c" class="kw kx hi ks b fi lc kz l la lb">    for i in range(len(numbers)):                      O(N):N=length</span><span id="b698" class="kw kx hi ks b fi lc kz l la lb">        currentVal = mapValues.get(numbers[i], None)   O(1)</span><span id="4bc4" class="kw kx hi ks b fi lc kz l la lb">        if(currentVal is not None):                    O(1)</span><span id="d7b5" class="kw kx hi ks b fi lc kz l la lb">            return [currentVal, i]                     O(1)</span><span id="6de8" class="kw kx hi ks b fi lc kz l la lb">        else:</span><span id="9471" class="kw kx hi ks b fi lc kz l la lb">            numberToFind = target - numbers[i]         O(1)</span><span id="f495" class="kw kx hi ks b fi lc kz l la lb">            mapValues[numberToFind] = i                0(1)</span><span id="92a2" class="kw kx hi ks b fi lc kz l la lb">    return None                                        O(1)</span><span id="2e31" class="kw kx hi ks b fi lc kz l la lb"><br/>Note: Statements inside loop will execute N=length of numbers times, so their complexity will be multiplied with O(N)</span><span id="5f74" class="kw kx hi ks b fi lc kz l la lb">Big O = O(1) + O(N)*(O(1) + O(1) + O(1) + O(1) + O(1)) + O(1)</span><span id="b286" class="kw kx hi ks b fi lc kz l la lb">As O(1) + O(1) +O(1) + ... = O(1), so<br/>      = O(1) + O(N)*(O(1) + O(1)</span><span id="41e0" class="kw kx hi ks b fi lc kz l la lb">Also O(1) + O(N) = O(N) and O(1)*O(N) = O(N)<br/>      = O(1) + O(N) + O(1)<br/>      = O(N) </span></pre><blockquote class="kl km kn"><p id="b65c" class="if ig jm ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated">O(N)是一个通用术语，其中N代表大数。当N太大时，我们可以估计N/2，N/3等于N。</p></blockquote><p id="893b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以看到，最终，复杂度取决于循环执行的次数，对于像计算和赋值这样的小操作，一般不计算复杂度。</p><blockquote class="kl km kn"><p id="c06f" class="if ig jm ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated"><strong class="ih hj">空间复杂度:</strong> <em class="hi">预计程序需要的内存量</em></p></blockquote><p id="920f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">空间复杂度是根据程序内部的变量初始化来计算的。空间复杂度取决于:</p><ul class=""><li id="4545" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">变量</li><li id="e866" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">数据结构</li><li id="8473" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">函数调用</li><li id="970d" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">分配</li></ul><p id="492a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更好地理解，请考虑下面的示例:</p><pre class="ka kb kc kd fd kr ks kt ku aw kv bi"><span id="1911" class="kw kx hi ks b fi ky kz l la lb">newArray = []                O(1)<br/>for i in range(n):<br/>    newArray.append(i);      O(N)</span><span id="e742" class="kw kx hi ks b fi lc kz l la lb">Big O = O(1) + O(N) = O(N)</span></pre><p id="b49c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的空间复杂度是O(N ),因为新的内存被分配给数组N次。</p><blockquote class="kl km kn"><p id="3a6b" class="if ig jm ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated">对于大O计算，通常估计输入的数量非常大，因此可以忽略小操作，只考虑重复操作。</p></blockquote></div></div>    
</body>
</html>