<html>
<head>
<title>TiDB Operator Source Code Reading (III): The Component Control Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TiDB操作符源代码阅读(三):组件控制循环</h1>
<blockquote>原文：<a href="https://medium.com/codex/tidb-operator-source-code-reading-iii-the-component-control-loop-81d51c6884c5?source=collection_archive---------15-----------------------#2021-08-04">https://medium.com/codex/tidb-operator-source-code-reading-iii-the-component-control-loop-81d51c6884c5?source=collection_archive---------15-----------------------#2021-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0d5c7aff75029d590778b7dfb8da7de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n8e1vce4gw8IPISo.jpg"/></div></div></figure><p id="ac95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">作者:</strong> <a class="ae jo" href="https://github.com/handlerww" rel="noopener ugc nofollow" target="_blank">陈一文</a>(TiDB运营委员，PingCAP软件工程师)</p><p id="8944" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Transcreator: </strong> <a class="ae jo" href="https://github.com/ran-huang" rel="noopener ugc nofollow" target="_blank">黄然</a>；编辑:汤姆·万德</p><blockquote class="jp jq jr"><p id="5833" class="iq ir js is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated">本系列以前的文章:</p></blockquote><ul class=""><li id="81b9" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated"><a class="ae jo" rel="noopener" href="/geekculture/tidb-operator-source-code-reading-i-overview-cf1891f1fd90"> <em class="js"> TiDB运算符源代码阅读(一):概述</em> </a></li><li id="8005" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><a class="ae jo" rel="noopener" href="/geekculture/tidb-operator-source-code-reading-ii-operator-pattern-67ddaf90983a"> <em class="js"> TiDB运算符源代码阅读(二):运算符模式</em> </a></li></ul><p id="cc4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的上一篇文章中，我介绍了我们如何设计和实现<code class="du kk kl km kn b">tidb-controller-manager</code>和控制器的内部逻辑，以及每个控制器如何接收和处理变化。这次，我将描述我们如何实现组件控制器。</p><p id="b0e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kk kl km kn b">TidbCluster</code>控制器管理TiDB中主要组件的生命周期。我以<code class="du kk kl km kn b">TidbCluster</code>为例介绍一下组件控制回路的设计。<strong class="is hj">您将了解在TiDB集群生命周期管理期间如何编排控制循环事件，以及这些事件如何管理资源。</strong></p><p id="44f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文只是对过程和定义的一般性介绍。每个组件的具体应用将在下一篇文章中讨论。现在，让我们开始吧。</p><h1 id="c2bf" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">调用组件控制循环</h1><p id="de17" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">在<a class="ae jo" href="https://pingcap.com/blog/tidb-operator-source-code-reading-2-operator-pattern#controllers-internal-logic" rel="noopener ugc nofollow" target="_blank">控制器内部逻辑</a>部分，我提到了<code class="du kk kl km kn b">TidbCluster</code>控制器的<code class="du kk kl km kn b">updateTidbCluster</code>功能，它位于<code class="du kk kl km kn b">pkg/controller/tidbcluster/tidb_cluster_control.go</code>。作为TiDB组件生命周期管理的入口，该功能调用一系列生命周期管理功能:</p><ul class=""><li id="ce28" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated"><code class="du kk kl km kn b">c.reclaimPolicyManager.Sync(tc)</code></li><li id="e7f7" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><code class="du kk kl km kn b">c.orphanPodsCleaner.Clean(tc)</code></li><li id="db3d" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><code class="du kk kl km kn b">c.discoveryManager.Reconcile(tc)</code></li><li id="ad52" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><code class="du kk kl km kn b">c.ticdcMemberManager.Sync(tc)</code></li><li id="3531" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><code class="du kk kl km kn b">c.tiflashMemberManager.Sync(tc)</code></li><li id="55e8" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><code class="du kk kl km kn b">c.pdMemberManager.Sync(tc)</code></li><li id="ed40" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><code class="du kk kl km kn b">c.tikvMemberManager.Sync(tc)</code></li><li id="fd89" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><code class="du kk kl km kn b">c.pumpMemberManager.Sync(tc)</code></li><li id="4234" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><code class="du kk kl km kn b">c.tidbMemberManager.Sync(tc)</code></li><li id="6467" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><code class="du kk kl km kn b">c.metaManager.Sync(tc)</code></li><li id="3164" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><code class="du kk kl km kn b">c.pvcCleaner.Clean(tc)</code></li><li id="9129" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><code class="du kk kl km kn b">c.pvcResizer.Resize(tc)</code></li><li id="73e6" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><code class="du kk kl km kn b">c.tidbClusterStatusManager.Sync(tc)</code></li></ul><p id="7c22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些功能分为两类:</p><ul class=""><li id="2c98" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated"><strong class="is hj">实现TiDB组件</strong>的控制回路，如PD、TiDB、TiKV、TiFlash、TiCDC、Pump和Discovery。</li><li id="2481" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated"><strong class="is hj">TiDB组件</strong>使用的Kubernetes资源的管理和<strong class="is hj">其他组件</strong>的生命周期管理，如维护PV的回收策略，清理孤儿Pods，维护Kubernetes资源的元信息，清理和扩展PVC，管理<code class="du kk kl km kn b">TidbCluster</code>对象的状态。</li></ul><h1 id="878c" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">TiDB组件的生命周期管理流程</h1><p id="9e2f" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">TiDB主要组件的控制循环代码位于目录<code class="du kk kl km kn b">pkg/manager/member</code>和以<code class="du kk kl km kn b">_member_manager.go</code>结尾的文件中，如<code class="du kk kl km kn b">pd_member_manager.go</code>。这些文件引用实现缩放和升级特性的其他文件，例如<code class="du kk kl km kn b">_scaler.go</code>和<code class="du kk kl km kn b">_upgrader.go</code>。</p><p id="6a11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从组件的<code class="du kk kl km kn b">_member_manager.go</code>文件中，我们可以识别通用实现:</p><pre class="lr ls lt lu fd lv kn lw lx aw ly bi"><span id="946e" class="lz kp hi kn b fi ma mb l mc md">// Sync Service<br/>if err := m.syncServiceForTidbCluster(tc); err != nil {<br/>    return err<br/>}</span><span id="802e" class="lz kp hi kn b fi me mb l mc md">// Sync Headless Service<br/>if err := m.syncHeadlessServiceForTidbCluster(tc); err != nil {<br/>    return err<br/>}</span><span id="b464" class="lz kp hi kn b fi me mb l mc md">// Sync StatefulSet<br/>return syncStatefulSetForTidbCluster(tc)</span><span id="835f" class="lz kp hi kn b fi me mb l mc md">func syncStatefulSetForTidbCluster(tc *v1alpha1.TidbCluster) error {<br/>    if err := m.syncTidbClusterStatus(tc, oldSet); err != nil {<br/>        klog.Errorf("failed to sync TidbCluster: [%s/%s]'s status, error: %v", ns, tcName, err)<br/>    }</span><span id="be35" class="lz kp hi kn b fi me mb l mc md">    if tc.Spec.Paused {<br/>        klog.V(4).Infof("tidb cluster %s/%s is paused, skip syncing for statefulset", tc.GetNamespace(), tc.GetName())<br/>        return nil<br/>    }</span><span id="e2ce" class="lz kp hi kn b fi me mb l mc md">    cm, err := m.syncConfigMap(tc, oldSet)</span><span id="1fb2" class="lz kp hi kn b fi me mb l mc md">    newSet, err := getnewSetForTidbCluster(tc, cm)</span><span id="0bfb" class="lz kp hi kn b fi me mb l mc md">    if err := m.scaler.Scale(tc, oldSet, newSet); err != nil {<br/>        return err<br/>    }</span><span id="434e" class="lz kp hi kn b fi me mb l mc md">    if err := m.failover.Failover(tc); err != nil {<br/>        return err<br/>    }</span><span id="5d82" class="lz kp hi kn b fi me mb l mc md">    if err := m.upgrader.Upgrade(tc, oldSet, newSet); err != nil {<br/>        return err<br/>    }</span><span id="d0b7" class="lz kp hi kn b fi me mb l mc md">    return UpdateStatefulSet(m.deps.StatefulSetControl, tc, newSet, oldSet)<br/>}</span></pre><p id="3674" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码执行两个主要任务:</p><ul class=""><li id="51e1" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">同步服务:为TiDB组件创建或同步服务资源。</li><li id="c7ea" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">同步状态集:</li></ul><p id="90d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同步组件状态。</p><p id="ad12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">检查<code class="du kk kl km kn b">TidbCluster</code>是否停止同步。</p><p id="f4e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同步配置映射。</p><p id="75eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据<code class="du kk kl km kn b">TidbCluster</code>中的配置生成新的StatefulSet，并对新的StatefulSet执行相关操作，如滚动更新、向外扩展、向内扩展和故障转移。</p><p id="4702" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建或更新StatefulSet。</p><p id="ec5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">组件控制循环重复执行上述任务，以确保组件保持最新。</p><p id="3f9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下各节介绍控制回路中完成的具体工作。</p><h2 id="345e" class="lz kp hi bd kq mf mg mh ku mi mj mk ky jb ml mm lc jf mn mo lg jj mp mq lk mr bi translated">同步服务</h2><p id="b5a4" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">当组件协调开始时，服务协调也开始。<strong class="is hj">该过程创建并同步组件</strong>使用的服务，例如<code class="du kk kl km kn b">cluster1-pd</code>和<code class="du kk kl km kn b">cluster1-pd-peer</code>。</p><p id="e0db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">控制循环函数调用<code class="du kk kl km kn b">getNewServiceForTidbCluster</code>函数，该函数根据<code class="du kk kl km kn b">TidbCluster</code>自定义资源(CR)中记录的信息创建一个新的服务模板。如果服务不存在，控制循环函数创建一个服务；如果服务存在，它将新旧服务规范进行比较，并确定是否更新服务对象。</p><p id="23da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既有服务，也有允许其他人访问组件的无头服务。</p><ul class=""><li id="4971" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">如果组件不需要知道它正在与哪个实例对话，并且如果组件支持负载平衡，比如当TiKV和TiDB访问布局驱动程序(PD)时，组件使用服务。</li><li id="8452" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">如果组件需要知道哪个Pod正在提供服务，它使用一个无头服务通过<a class="ae jo" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id" rel="noopener ugc nofollow" target="_blank"> Pod DNS </a>进行通信。例如，当TiKV启动时，它公开其Pod DNS作为广告地址，以便其他Pod可以通过Pod DNS访问TiKV。</li></ul><h2 id="3865" class="lz kp hi bd kq mf mg mh ku mi mj mk ky jb ml mm lc jf mn mo lg jj mp mq lk mr bi translated">同步状态集</h2><p id="4544" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">服务同步后，组件将连接到集群网络，因此它们可以访问集群，也可以从集群内部被访问。控制循环进入<code class="du kk kl km kn b">syncStatefulSetForTidbCluster</code>功能，并开始协调状态集。</p><p id="8a9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">协调StatefulSet的第一步是通过运行<code class="du kk kl km kn b">syncTidbClusterStatus</code>函数来同步组件状态。然后，根据状态信息，将执行其他操作，如升级、向内扩展、向外扩展和故障转移。</p><p id="f8ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">同步组件状态</strong></p><p id="432e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TiDB操作员的关键操作之一是同步组件状态。状态信息包含:</p><ul class=""><li id="f485" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">Kubernetes的组件信息，包括集群中副本的数量、更新状态和映像版本。TiDB操作符还检查StatefulSet是否在更新过程中。</li><li id="183d" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">TiDB的内部集群信息。TiDB操作员同步来自PD的信息，包括关于PD成员、TiKV存储和TiDB成员的信息。TiDB操作员还对TiDB执行运行状况检查。</li></ul><p id="4d1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">检查TiDB集群是否暂停同步</strong></p><p id="5b46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同步状态后，TiDB操作员通过检查<code class="du kk kl km kn b">tc.Spec.Paused</code>来确定集群是否停止同步。如果同步暂停，TiDB运算符将跳过更新StatefulSet的所有后续操作。</p><p id="31a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">同步配置图</strong></p><p id="9c0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同步状态后，<code class="du kk kl km kn b">syncConfigMap</code>函数更新ConfigMap，它包含组件的配置文件和启动脚本。</p><p id="7710" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">配置文件是从YAML文件的<code class="du kk kl km kn b">Spec</code>中的<code class="du kk kl km kn b">Config</code>项提取的。TiDB运营商支持直接使用TOML配置(推荐)或从YAML转换配置。</p><p id="593a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">启动脚本包含组件所需的启动参数，并使用这些参数启动组件进程。</p><p id="8729" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当组件需要从TiDB操作符获得启动参数时，信息处理在发现组件中执行。例如，当PD需要使用参数来确定它应该初始化一个节点还是加入一个节点时，它使用wget来访问Discovery并获取参数。通过从启动脚本中获取参数，TiDB Operator避免了在StatefulSet被更新时出现意外的滚动更新。这可能会影响在线服务。</p><p id="6357" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">生成新的StatefulSet </strong></p><p id="efff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kk kl km kn b">getNewPDSetForTidbCluster</code>函数获取一个新的StatefulSet模板，它包含新生成的服务和ConfigMap的引用。该功能使用最新的状态和规格生成其他项目，如<code class="du kk kl km kn b">env</code>、<code class="du kk kl km kn b">container</code>和<code class="du kk kl km kn b">volume</code>。</p><p id="838f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，这个新的StatefulSet经历三个过程:滚动更新、扩展和故障转移。最后，<code class="du kk kl km kn b">UpdateStatefulSet</code>函数比较现有的StatefulSet和新的stateful set，并决定是否更新现有的stateful set。</p><ul class=""><li id="8af2" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">滚动更新</li></ul><p id="11f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kk kl km kn b">m.upgraded.Upgrade</code>函数执行与滚动更新相关的操作，主要更新StatefulSet中的<code class="du kk kl km kn b">UpgradeStrategy.Type</code>和<code class="du kk kl km kn b">UpgradeStrategy.Partition</code>。</p><p id="5a0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">滚动更新操作使用StatefulSet中的滚动更新策略来执行。当组件被协调时，它将StatefulSet的更新策略设置为滚动更新。在Kubernetes中，可以通过配置<code class="du kk kl km kn b">UpgradeStrategy.Partition</code>来控制滚动更新进度。StatefulSet仅更新之前未更新且ID大于或等于<code class="du kk kl km kn b">UpgradeStrategy.Partition</code>值的pod。TiDB运营商使用这种机制来确保每个Pod仅在能够正常地向外部应用提供服务之后才被滚动更新。</p><p id="8eb5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当集群未被更新或正处于更新的开始阶段时，组件协调将<code class="du kk kl km kn b">UpgradeStrategy.Partition</code>设置为状态集中最大的Pod ID。这可以防止任何Pod被更新。更新开始后，当Pod更新并在重启后提供服务时，Pod被视为成功升级。TiDB操作员然后递减<code class="du kk kl km kn b">UpgradeStrategy.Partition</code>值并更新下一个Pod。</p><ul class=""><li id="9568" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">放大和缩小</li></ul><p id="3bff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kk kl km kn b">m.scaler.Scale</code>缩放组件。它的主要任务是更新StatefulSet中组件的<code class="du kk kl km kn b">Replicas</code>。</p><p id="f47b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kk kl km kn b">m.scaler.Scale</code>函数一个一个地缩放组件，一次一步。它将<code class="du kk kl km kn b">TidbCluster</code> CR(例如<code class="du kk kl km kn b">tc.Spec.PD.Replicas</code>)中某个组件的<code class="du kk kl km kn b">Replicas</code>号与当前的<code class="du kk kl km kn b">Replicas</code>号进行比较。在此基础上，它确定是向外扩展还是向内扩展组件，并在一个副本上执行扩展操作。然后进入下一轮组件协调。通过多轮对账，<code class="du kk kl km kn b">m.scaler.Scale</code>完成所有缩放需求。</p><p id="d717" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在缩放过程中，PD需要转移Leader，TiKV需要删除门店。这些操作使用PD APIs。对账时，<code class="du kk kl km kn b">m.scaler.Scale</code>函数使用PD APIs执行操作，并检查操作是否成功。如果是，它将移动到下一个缩放操作。</p><ul class=""><li id="4b84" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">故障切换</li></ul><p id="1f8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kk kl km kn b">m.failover.Failover</code>功能执行与灾难恢复相关的操作，包括发现故障、记录故障状态和从故障中恢复。</p><p id="4a89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果在部署TiDB操作员时启用<code class="du kk kl km kn b">AutoFailover</code>，TiDB操作员将监控组件故障状态。当发现一个时，TiDB操作员将故障信息记录到<code class="du kk kl km kn b">FailureStores</code>或<code class="du kk kl km kn b">FailureMembers</code>。接下来，它启动一个新的组件Pod来接管故障Pod的工作负载。在发生故障的Pod恢复后，TiDB Operator修改StatefulSet中的副本数量，以便在新的Pod中进行扩展。</p><p id="6de5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当TiDB Operator为TiKV和TiFlash执行故障切换时，默认情况下不会扩展新创建的Pod。您需要配置<code class="du kk kl km kn b">spec.tikv.recoverFailover: true</code>来启用自动放大。</p><p id="5729" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">更新现有的StatefulSet </strong></p><p id="d335" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在最后一个阶段，创建新的StatefulSet。控制循环现在进入<code class="du kk kl km kn b">UpdateStatefulSet</code>函数，该函数将新的StatefulSet与现有的stateful set进行比较。如果两个StatefulSet不一致，该函数将更新现有的stateful set。</p><p id="931f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该函数还检查是否存在不受TiDB操作符管理的StatefulSets。因为TiDB Operator的早期版本使用Helm Chart来部署TiDB，所以TiDB Operator需要向这些旧的StatefulSets添加依赖标记，并将它们包含在生命周期管理中。</p><p id="6c72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成上述操作后，<code class="du kk kl km kn b">TidbCluster</code> CR的状态更新为最新版本。相关的服务和配置映射已创建。生成新的StatefulSet，它执行滚动更新、伸缩和故障转移。组件协调继续进行，监控组件的生命周期，并对生命周期状态变化和用户指定的变化做出响应。整个集群运行正常。</p><h2 id="0d2f" class="lz kp hi bd kq mf mg mh ku mi mj mk ky jb ml mm lc jf mn mo lg jj mp mq lk mr bi translated">其他生命周期管理任务</h2><p id="3f15" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">除了TiDB中主要组件的协调之外，其他生命周期管理操作由以下功能执行:</p><ul class=""><li id="07a3" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">发现配置PD启动参数和TiDB仪表板代理。它为组件提供动态信息以供使用，从而避免修改可能导致Pod滚动更新的ConfigMap。</li><li id="1841" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">回收策略管理器同步<code class="du kk kl km kn b">tc.Spec.PVReclaimPolicy</code>的配置。默认情况下，PV回收策略设置为<code class="du kk kl km kn b">Retain</code>，以降低数据丢失的风险。</li><li id="fd55" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">孤立单元清理程序在PVC创建失败时清理单元。然后StatefulSet控制器再次尝试创建pod和相应的PVC。</li><li id="de06" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">PVC清洁剂清除标记为可删除的PVC。</li><li id="767b" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">PVC尺寸调整器横向扩展。在云上运行TiDB Operator时，可以通过修改<code class="du kk kl km kn b">TidbCluster</code>中的存储配置来改变PVC的大小。</li><li id="ba77" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">Meta Manager将<code class="du kk kl km kn b">StoreIDLabel</code>、<code class="du kk kl km kn b">MemberIDLabel</code>和<code class="du kk kl km kn b">NamespaceLabel</code>同步到pod、PVC和PV的标签。</li><li id="984e" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">TiDBCluster状态管理器同步与<code class="du kk kl km kn b">TidbMonitor</code>和TiDB仪表板相关的信息。</li></ul><h1 id="a547" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">摘要</h1><p id="d77c" class="pw-post-body-paragraph iq ir hi is b it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn hb bi translated">至此，您已经了解了TiDB组件控制回路的设计，包括:</p><ul class=""><li id="e108" class="jw jx hi is b it iu ix iy jb jy jf jz jj ka jn kb kc kd ke bi translated">协调功能如何遵循其相应的过程来检查组件资源</li><li id="b033" class="jw jx hi is b it kf ix kg jb kh jf ki jj kj jn kb kc kd ke bi translated">协调功能如何将用户期望的状态转变为实际的组件状态</li></ul><p id="88a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TiDB操作符中几乎所有的控制循环都符合本文描述的设计逻辑。在以后的文章中，我将进一步解释如何将这个逻辑应用于每个组件来管理组件的生命周期。</p><p id="0f89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您对TiDB运营商有任何问题或想法，欢迎<a class="ae jo" href="https://slack.tidb.io/invite?team=tidb-community&amp;channel=sig-k8s&amp;ref=pingcap-blog" rel="noopener ugc nofollow" target="_blank">加入我们的Slack频道</a>或在<a class="ae jo" href="https://github.com/pingcap/tidb-operator" rel="noopener ugc nofollow" target="_blank"> pingcap/tidb-operator </a>参与我们的讨论！</p></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><p id="0274" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="js">原载于www.pingcap.com</em><a class="ae jo" href="https://en.pingcap.com/blog/tidb-operator-source-code-reading-3-component-control-loop" rel="noopener ugc nofollow" target="_blank"><em class="js"/></a><em class="js">2021年7月21日</em></p></div></div>    
</body>
</html>