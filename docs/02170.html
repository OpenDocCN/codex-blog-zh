<html>
<head>
<title>Dealing with emulator issues and Android UI test failures on CI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在CI上处理仿真器问题和Android UI测试失败</h1>
<blockquote>原文：<a href="https://medium.com/codex/dealing-with-emulator-issues-and-android-ui-test-failures-on-ci-7895694d58c8?source=collection_archive---------7-----------------------#2021-07-05">https://medium.com/codex/dealing-with-emulator-issues-and-android-ui-test-failures-on-ci-7895694d58c8?source=collection_archive---------7-----------------------#2021-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f270" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">注:</em>文章原载于</strong> <a class="ae je" href="https://blog.bitrise.io/post/how-to-deal-with-emulator-issues-and-android-ui-test-failures-on-ci" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Bitrise博客</strong> </a> <strong class="ih hj">。<br/>本文是关于Android测试的系列文章的一部分，请在这里找到该系列文章的完整列表:<br/> </strong> <a class="ae je" href="https://richrdbogdn.medium.com/a-guide-to-write-your-tests-for-your-android-apps-d4272424cb23" rel="noopener"> 1。<strong class="ih hj"> </strong>为你的Android应用编写测试的指南</a> <br/> <a class="ae je" href="https://richrdbogdn.medium.com/write-your-tests-for-your-android-libraries-and-plugins-3ec4b5da2faf" rel="noopener"> 2。为你的Android库和Gradle插件编写你的测试。</a> <br/> <a class="ae je" href="https://richrdbogdn.medium.com/dealing-with-emulator-issues-and-android-ui-test-failures-on-ci-7895694d58c8" rel="noopener">四上考词。在CI上处理仿真器问题和Android UI测试失败</a></p><p id="9196" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上一篇文章中，我介绍了如何在配置项上设置测试，以及当出现问题时，通过提取调试测试所需的信息，您可以做些什么来使您的工作变得更容易。现在，我将更深入地探讨后一个主题，并将重点放在仿真器和UI测试相关的问题上。</p><h1 id="de82" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">缓解策略</h1><p id="081b" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">当我声称插装测试(尤其是UI测试)是不可靠的时候，我很确定每个人都能从他们自己的经历中回忆起一件事情。或者如果没有，你很可能真的很幸运，但至少你听说有人认识一个经历过的人。遗憾的是，没有防止剥落的灵丹妙药，但是和所有事情一样，我们可以做很多事情来防止大部分剥落。这里有三组策略:</p><ol class=""><li id="8684" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc kn ko kp kq bi translated"><strong class="ih hj">预防性</strong></li><li id="afe5" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated"><strong class="ih hj">无功</strong></li><li id="1d67" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc kn ko kp kq bi translated"><strong class="ih hj">支持性</strong></li></ol><p id="1816" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看每一个。</p><h1 id="8e82" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">1.预防性试验剥落缓解</h1><p id="7da3" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">顾名思义，这些策略包含了在启动测试之前您可以做的所有事情，并使您能够防止古怪行为的发生。这听起来相当模糊，但是我现在将尝试给出更多的例子和细节。</p><h1 id="a801" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">页面对象模式</h1><p id="1e4b" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">你熟悉“编码模式”这个术语吗？你知道并使用其中的一些吗？如果你对这两个问题的回答都是肯定的，那么我想当你听到测试也有它的模式，页面对象模式就是其中之一时，你不会感到惊讶。</p><p id="b415" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种模式在你做UI测试时很有用，例如用<a class="ae je" href="https://developer.android.com/training/testing/espresso" rel="noopener ugc nofollow" target="_blank"> Espresso </a>或<a class="ae je" href="https://developer.android.com/training/testing/ui-automator" rel="noopener ugc nofollow" target="_blank"> UIAutomator </a>。最初，这种模式是由web UI测试人员使用的，所以这就是“页面对象”这个名称的由来。虽然从名称上可以假定，您只能为页面或屏幕创建页面对象；但事实上，它们也可以用于较小的项目(例如片段或不同的视图)。页面对象模式的目标是在测试用例与在UI上执行动作/访问元素所需的代码之间引入一个解耦层。这将是页面对象。对于视觉思考者来说，这是一张概览图:</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es kw"><img src="../Images/67ec8554a80e9e0b784ba45c4cf91e8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/0*CxVLh7x_3EwE8Se8.png"/></div></figure><p id="adaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见:</p><ul class=""><li id="88fc" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc le ko kp kq bi translated">您可以在单个设备上运行多个测试类</li><li id="9b5c" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc le ko kp kq bi translated">给定的测试类可以使用一个或多个UI组件(例如，活动、片段)</li><li id="359d" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc le ko kp kq bi translated">每个UI组件都有一个页面对象</li><li id="101c" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc le ko kp kq bi translated">一个测试用例可以使用一个或多个页面对象</li></ul><p id="54d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">付诸实践:<br/> ‍ <br/> </strong>让我们想象你有一个简单的待办事项应用程序的UI测试，它列出了一些待办事项，你可以添加、编辑和删除它们。从测试的角度来看，您不会关心给定按钮和视图的资源名称，因为您很可能会测试不同的行为。因此，如果您将所有这些代码都放在page对象中，测试用例会变得更简单、更简短。此外，如果UI中的某些行为发生了变化，例如，以前您有一个按钮用于删除每一项，而现在变成了滑动它们来删除，您将需要更新每个测试用例。你应该把这个逻辑放在页面对象中，如果你必须改变，你只需要在一个地方更新它。继续这个例子，在page对象中应该有一个类似“deleteItem”的方法。总而言之，使用页面对象模式有以下优点:</p><ul class=""><li id="f955" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc le ko kp kq bi translated">避免代码重复，因为所有的访问器、动作等都可以在同一个地方</li><li id="d744" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc le ko kp kq bi translated">更可读的代码</li><li id="445e" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc le ko kp kq bi translated">你必须在一个地方改变代码，以防行为改变</li><li id="b691" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc le ko kp kq bi translated">您可以将它与其他模式/技术相结合，例如，如果您将它与fluent API相结合，它会变得更加紧凑</li></ul><p id="ee36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">现在，举例时间:</strong></p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="c2cf" class="lk jg hi lg b fi ll lm l ln lo">@Test<br/>public void fragmentStateTest() {<br/>   final IndexActivityScreen indexActivityScreen = <br/>          new IndexActivityScreen(uiDevice);</span><span id="4f4c" class="lk jg hi lg b fi lp lm l ln lo">   final MainActivityScreen mainActivityScreen = <br/>               indexActivityScreen.launchUiTests();<br/>   mainActivityScreen<br/>           .showParentFragment()<br/>           .showChildFragment();<br/>}</span></pre><p id="aae1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">注意:如您所见，我在命名中使用了“屏幕”一词，而不是“页面”。原因是它对移动用户界面更具描述性，页面在网页或桌面术语中更容易理解。</em></p><p id="8105" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">上面的例子展示了一个简单的UiAutomator测试用例，在这里我们做了以下事情:</strong></p><p id="494f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> a. </strong>用IndexActivity启动应用程序</p><p id="68ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> b. </strong>使用launchUiTests()方法在IndexActivityScreen中启动MainActivity</p><p id="f47a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> c. </strong> MainActivity显示一个片段(ParentFragment)</p><p id="71ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> d. </strong> ParentFragment显示另一个片段(ChildFragment)</p><p id="4111" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多亏了页面对象模式，这样做的代码非常短，可读性很强。如您所见，我将page对象模式与fluent API结合起来，使其更加简洁。</p><p id="978d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看起来不错，但是这将如何帮助防止测试剥落？</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es lq"><img src="../Images/31c3dbfad2f0af07bec48342d2e32c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/0*M0zLR2SoCYTRsNSx.jpeg"/></div></figure><p id="de9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能在过去经历过不稳定的UI测试，因为您团队中的某个人忘记给给定的视图元素添加一些等待时间。这种情况时有发生，因为我们是人，会犯错误/忘记事情。好的一面是，如果你使用页面对象模式，你将编写一次等待逻辑，你可以在不同的测试用例中重用它，因为它在你的屏幕对象中。所以你添加等待逻辑的时间越少，你忘记添加的机会就越少。此外，可读代码有助于避免人为错误，对吗？</p><p id="a0ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能会说页面对象模式不是解决/减轻上述问题的唯一方法，你是对的。我在这里的观点是，它是缓解这些问题的一个很好的选择，因为它解决了这些问题以及它的好处。</p><p id="2557" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将为UiAutomator提供一个例子。这是我的屏幕类查找IndexActivity的方式:</p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="3cf5" class="lk jg hi lg b fi ll lm l ln lo">/**<br/>* Screen class for {@link IndexActivity}.<br/>*/<br/>public class IndexActivityScreen extends BaseScreen {</span><span id="4e85" class="lk jg hi lg b fi lp lm l ln lo">   private static final BySelector uiTestsButton = <br/>       By.res(id + "btn_ui_tests");<br/>   private static final BySelector networkTestsButton = <br/>       By.res(id + "btn_network_tests");</span><span id="a469" class="lk jg hi lg b fi lp lm l ln lo">   /**<br/>    * Constructor for class.<br/>    *<br/>    * @param uiDevice the UiDevice that launches the test cases.<br/>    */<br/>   public IndexActivityScreen(@NonNull final UiDevice uiDevice) {<br/>       super(uiDevice);<br/>   }</span><span id="fb4b" class="lk jg hi lg b fi lp lm l ln lo">   /**<br/>    * Clicks on the UI tests button and launches the {@link MainActivity}.<br/>    *<br/>    * @return the created {@link MainActivityScreen}.<br/>    */<br/>   @NonNull<br/>   public MainActivityScreen launchUiTests() {<br/>       click(uiTestsButton);<br/>       return new MainActivityScreen(uiDevice);<br/>   }</span><span id="1a5f" class="lk jg hi lg b fi lp lm l ln lo">   /**<br/>    * Clicks on the Network tests button and launches the {@link NetworkActivity}.<br/>    *<br/>    * @return the created {@link NetworkActivityScreen}.<br/>    */<br/>   @NonNull<br/>   public NetworkActivityScreen launchNetworkTests() {<br/>       click(networkTestsButton);<br/>       return new NetworkActivityScreen(uiDevice);<br/>   }</span><span id="2ea1" class="lk jg hi lg b fi lp lm l ln lo">   @Override<br/>   public void waitTillLoad() {<br/>       uiDevice.wait(Until.findObject(uiTestsButton), DEFAULT_TIMEOUT);<br/>       uiDevice.wait(Until.findObject(networkTestsButton), DEFAULT_TIMEOUT);<br/>   }<br/>}</span></pre><p id="c79d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，我们有:</p><p id="f71d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">答:</strong>我们作为成员变量与之交互的UI元素</p><p id="c8ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> b. </strong>作为成员方法的可用交互</p><p id="199d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和一个名为waitTillLoad()的方法，当我们开始与它们交互时，它将确保所有需要的元素都显示在屏幕上</p><p id="13ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">为了全面了解情况，请看一下这个IndexActivityScreen类的父类:</strong></p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="0a37" class="lk jg hi lg b fi ll lm l ln lo">public abstract class BaseScreen {</span><span id="f0b5" class="lk jg hi lg b fi lp lm l ln lo">   /**<br/>    * The given UiDevice that runs the tests.<br/>    */<br/>   @NonNull<br/>   protected final UiDevice uiDevice;</span><span id="06b4" class="lk jg hi lg b fi lp lm l ln lo">   /**<br/>    * The id prefix to find resources by id.<br/>    */<br/>   @NonNull<br/>   protected static final String id =<br/>      InstrumentationRegistry.getInstrumentation()<br/>         .getTargetContext()<br/>         .getPackageName() <br/>         + ":id/";</span><span id="989d" class="lk jg hi lg b fi lp lm l ln lo">   /**<br/>    * The default value for timeouts.<br/>    */<br/>   protected long DEFAULT_TIMEOUT = 10000;</span><span id="2ccf" class="lk jg hi lg b fi lp lm l ln lo">   /**<br/>    * The number of times the test will try to click on a given BySelector before failing the test.<br/>    */<br/>   private static final int numberOfClickAttempts = 3;</span><span id="7ad9" class="lk jg hi lg b fi lp lm l ln lo">   /**<br/>    * Constructor for class.<br/>    *<br/>    * @param uiDevice the UiDevice that launches the test cases.<br/>    */<br/>   public BaseScreen(@NonNull final UiDevice uiDevice) {<br/>       this.uiDevice = uiDevice;<br/>       waitTillLoad();<br/>   }</span><span id="9003" class="lk jg hi lg b fi lp lm l ln lo">   /**<br/>    * Searches for the given {@link BySelector} on the active UI.<br/>    *<br/>    * @param by the given BySelector to search for.<br/>    * @return the {@link UiObject2} if found, {@code null} otherwise.<br/>    */<br/>   @Nullable<br/>   public UiObject2 find(@NonNull final BySelector by) {<br/>       return uiDevice.wait(Until.findObject(by), DEFAULT_TIMEOUT);<br/>   }</span><span id="cfbf" class="lk jg hi lg b fi lp lm l ln lo">   /**<br/>    * Performs a click action on the given {@link BySelector}. Attempts to find the given BySelector 3 times. This<br/>    * is needed for cases when the UI is not ready.<br/>    *<br/>    * @param by the given BySelector.<br/>    */<br/>   public void click(@NonNull final BySelector by) {<br/>       for (int i = 0; i &lt; numberOfClickAttempts; i++) {<br/>           final UiObject2 uiObject2 = find(by);<br/>           if (uiObject2 != null) {<br/>               uiObject2.click();<br/>               break;<br/>           } else {<br/>               Log.i(BaseUiTest.UI_TEST_TAG, String.format("Could not find selector with name %s, retrying %s",<br/>                       by.toString(), i));<br/>           }<br/>       }<br/>   }<br/></span><span id="a1ce" class="lk jg hi lg b fi lp lm l ln lo">   /**<br/>    * Waits till the given screen is loaded.<br/>    */<br/>   public abstract void waitTillLoad();</span></pre><p id="6736" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">从上面的代码看事情:</strong></p><ul class=""><li id="1f0f" class="ki kj hi ih b ii ij im in iq kk iu kl iy km jc le ko kp kq bi translated">像点击/查找这样的交互只需编写一次</li><li id="74ab" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc le ko kp kq bi translated">父类的构造函数将调用waitTillLoad()方法，所以所有子类都将从它们的构造函数中调用super(uiDevice)来做同样的事情</li><li id="c788" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc le ko kp kq bi translated">waitTillLoad()是抽象的，每个非抽象子类都必须定义它，所以你不太可能忘记它</li><li id="783b" class="ki kj hi ih b ii kr im ks iq kt iu ku iy kv jc le ko kp kq bi translated">超时、重试是统一的，它们在一个地方定义</li></ul><h1 id="84dd" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">接管</h1><p id="7440" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">以一种可读、紧凑和富于表现力的方式编写你的测试，这将省去你很多麻烦。页面对象模式是一个很好的选择。</p><h1 id="3e74" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">2.反应测试剥落缓解</h1><p id="9078" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">继续讨论减轻UI测试剥落，反应策略涉及到你在运行测试时可以做的所有事情，并使你能够防止剥落行为的发生。</p><h1 id="f2eb" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">处理系统事件</h1><p id="772e" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">系统事件可能在你的测试运行期间发生，其中之一是当Android没有响应时(简称ANR)，你会得到一个关于它的对话框。当我启动一个API级别为30的模拟器时，我经常会看到它们。</p><figure class="kx ky kz la fd lb er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lr"><img src="../Images/673dfda10a76fc716fced97d18dfeded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u9Fmlqk0_ltGUX34.jpeg"/></div></div></figure><p id="4759" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有没有发生过你的UI测试因为Android抛出系统对话框而失败的情况？如果答案是肯定的，我敢打赌你的感受和下图类似。</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es lw"><img src="../Images/ad11902eb914324a3e53c55212f356d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/0*GahZiG62QJlIgLrP.jpeg"/></div></figure><p id="b5cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使你的应用程序非常快，响应速度也很快，在CI上也会出现这样的对话框，因为正如我们在以前的帖子中了解到的，CI机器的性能是有限的。显然，你必须对这些对话框做些什么。</p><p id="d1fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果没有其他要求，在大多数情况下，您可以通过单击“等待”或“关闭应用程序”按钮来关闭它们。使用第一种方法要简单一些，因为正如我所说的，即使你的应用程序也可能没有响应。</p><p id="fe02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么解决方案是什么呢？创建一个观察器，在测试运行期间观察这些对话框。听起来很合理。我有好消息和坏消息。先说不好的:浓缩咖啡里没有这种东西。好消息是UiAutomator中有一个观察器，即使你有浓缩咖啡测试，这也会帮助你。</p><p id="7903" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个如何做的例子。正如我所说的，我们需要一个观察者，UiAutomator有<a class="ae je" href="https://developer.android.com/reference/androidx/test/uiautomator/UiWatcher" rel="noopener ugc nofollow" target="_blank"> UiWatcher </a>。实现这一目标的步骤是:</p><p id="f9f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> a .创建一个注册观察者的方法</strong></p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="7e5a" class="lk jg hi lg b fi ll lm l ln lo">private static final String anrText = "isn't responding";</span><span id="10cb" class="lk jg hi lg b fi lp lm l ln lo">private static void registerANRWatcher() {<br/>   uiDevice.registerWatcher("ANR", () -&gt; {<br/>       final UiObject anrDialog = <br/>           uiDevice.findObject(new UiSelector()<br/>               .packageName("android")<br/>               .textContains(anrText));</span><span id="e315" class="lk jg hi lg b fi lp lm l ln lo">       return checkForAnrDialogToClose(anrDialog);<br/>   });<br/>}</span></pre><p id="e4e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，对话框将显示类似“<application>没有响应”的内容，我们应该搜索该文本。只是为了确保我们不会从一个不同的应用程序中获得相同的文本，将包过滤到“android”。</application></p><p id="8d8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> b .检查是否有ANR对话框</strong></p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="31d3" class="lk jg hi lg b fi ll lm l ln lo">private static boolean checkForAnrDialogToClose(@NonNull final UiObject anrDialog) {<br/>   return anrDialog.exists() &amp;&amp; closeAnrWithWait(anrDialog);<br/>}</span></pre><p id="ceda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单一步，不多解释。</p><p id="340b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> c .当itt出现时，点击“等待”按钮</strong></p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="5a29" class="lk jg hi lg b fi ll lm l ln lo">private static boolean closeAnrWithWait(@NonNull final UiObject anrDialog) {<br/>   Log.i(UI_TEST_TAG, "ANR dialog detected!");<br/>   try {<br/>       uiDevice.findObject(new UiSelector().text("Wait").className("android.widget.Button").packageName(<br/>               "android")).click();<br/>       final String anrDialogText = anrDialog.getText();<br/>       final String appName = anrDialogText.substring(0, anrDialogText.length() - anrText.length());<br/>       Log.i(UI_TEST_TAG, String.format("Application \"%s\" is not responding!", appName));<br/>   } catch (final UiObjectNotFoundException e) {<br/>       Log.i(UI_TEST_TAG, "Detected ANR, but window disappeared!");<br/>   }<br/>   Log.i(UI_TEST_TAG, "ANR dialog closed: pressed on wait!");<br/>   return true;<br/>}</span></pre><p id="dc17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，如果我们有一个ANR对话框，我们点击“等待”按钮让它消失。你可以做额外的事情，例如我记录哪个应用程序有ANR，如果我检查日志，它可能是有趣的信息。</p><p id="2744" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> d .注册观察者</strong></p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="37cb" class="lk jg hi lg b fi ll lm l ln lo">@BeforeClass<br/>public static void setUpBeforeClass() {<br/>   uiDevice = UiDevice.getInstance(getInstrumentation());<br/>   registerANRWatcher();<br/>}</span></pre><p id="02f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">带注释的方法是一个很好的例子。</p><p id="fc20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将省去你许多头痛。正如我所承诺的，当你做浓缩咖啡测试时，我会告诉你该怎么做。嗯，我确信也有不同的方法，但是没有什么可以阻止你使用相同的代码，你只需要依靠UiAutomator和这段代码来进行测试。一个好的方法是创建一个包含这个的抽象父测试类，您的测试可以扩展这个类。这样你就不会有代码重复，实际的测试类不需要包含这些代码，所以它看起来几乎是一样的，它只是把你从那些讨厌的ANR对话框中拯救出来。基于此，你也可以为其他情况编写自己的观察器，万岁！</p><h1 id="b4b4" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">接管</h1><p id="dcfe" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">用<strong class="ih hj"> UiWatchers </strong>关闭那些ANR对话框和其他不必要的东西。</p><h1 id="11fa" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">3.支持性测试剥落缓解</h1><p id="37ca" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">最后一组关于UI测试剥落缓解，支持性策略包括所有你能做的事情来帮助减少你的测试的剥落，但是它不能防止剥落行为的发生。</p><h1 id="176f" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">更好的硬件</h1><p id="c7ae" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">如果因为超时而导致测试不稳定，你可以做一件小事，你可以购买/租用更快的硬件，你可能想做也可能不想做。当然，这将有所帮助，但是正如我所说的，不会阻止它，因为测试可能需要的性能没有上限(想象一下拥有最新/最快的机器，并且同时启动10个或更多模拟器，我不会对没有一些性能问题下很大赌注)。</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es lx"><img src="../Images/6dd870f2cae01dc73c4072bd00b1a08c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*fUpv1pbILPFzlqUY.jpeg"/></div></figure><h1 id="3a7b" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">UI测试事件的屏幕截图</h1><p id="36f7" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">在某些情况下，如果你有一个设备的屏幕截图，当一个给定的UI测试用例失败时，这可能是一个很大的帮助，可以更好地理解是什么导致了它。例如，截图帮助我发现，有时ANR对话框出现在我的UI测试运行中，导致间歇性的测试失败。当然，这对于非间歇性/易发性故障来说很方便。</p><figure class="kx ky kz la fd lb er es paragraph-image"><div class="er es ly"><img src="../Images/4967de26ffc937442b1a29b1e7b27d0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/0*D5zIsItrMcldNs0t.jpeg"/></div></figure><p id="9331" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了截屏，您必须创建一个<a class="ae je" href="https://junit.org/junit4/javadoc/4.12/org/junit/rules/TestWatcher.html" rel="noopener ugc nofollow" target="_blank"> TestWatcher </a>并实现您想要的给定事件的动作。有关TestWatcher拥有的完整事件集，请查看它的文档。我将向您展示如何在测试即将开始且失败时截图:</p><p id="a045" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">答(可选):创建一个测试规则，以获取当前活动测试用例的名称。</strong></p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="cbe4" class="lk jg hi lg b fi ll lm l ln lo">@Rule<br/>public TestName testName = new TestName();</span></pre><p id="5b8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将在创建那些截图文件时派上用场，并且稍后您将更容易将截图与测试用例相匹配。最简单的方法就是使用<a class="ae je" href="https://junit.org/junit4/javadoc/4.12/org/junit/rules/TestName.html" rel="noopener ugc nofollow" target="_blank">测试名</a>。</p><p id="5637" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b .创建您的TestWatcher </p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="79ab" class="lk jg hi lg b fi ll lm l ln lo">public class TestDataCollectionRule extends TestWatcher {</span><span id="8051" class="lk jg hi lg b fi lp lm l ln lo">   @Override<br/>   protected void starting(@NonNull final Description description) {<br/>       super.starting(description);<br/>       Log.i(UI_TEST_TAG, "Test started: " + testName.getMethodName());<br/>       takeScreenShot(TestEvent.START);<br/>   }</span><span id="7c6f" class="lk jg hi lg b fi lp lm l ln lo">   @Override<br/>   protected void succeeded(@NonNull final Description description) {<br/>       super.succeeded(description);<br/>       Log.i(UI_TEST_TAG, "Test success: " + testName.getMethodName());<br/>   }</span><span id="dd95" class="lk jg hi lg b fi lp lm l ln lo">   @Override<br/>   protected void failed(@NonNull final Throwable e, @NonNull final Description description) {<br/>       super.failed(e, description);<br/>       Log.i(UI_TEST_TAG, "Test failed: " + testName.getMethodName());<br/>       takeScreenShot(TestEvent.FAIL);<br/>   }<br/>}</span></pre><p id="67e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">专业提示:logcat输出中的一些日志也会有所帮助。唯一需要解释的是TestEvent enum。这是我创建的一个内部枚举类，我用它来指示哪个测试事件触发了截图。如果您不想创建自己的类，可以为此使用不同的类。</p><p id="9075" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> c .添加创建截图的方法</strong></p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="ba3e" class="lk jg hi lg b fi ll lm l ln lo">protected void takeScreenShot(@NonNull final TestEvent testEvent) {<br/>   final Bitmap screenshotBitmap = getScreenShotBitmap();<br/>   final String screenShotFileName = getTestReportFileBaseName(testEvent);</span><span id="77b4" class="lk jg hi lg b fi lp lm l ln lo">   storeScreenshot(screenshotBitmap, screenShotFileName);<br/>}</span><span id="4ea7" class="lk jg hi lg b fi lp lm l ln lo">private Bitmap getScreenShotBitmapWithScreenShotApi() {<br/>   return getInstrumentation().getUiAutomation().takeScreenshot();;<br/>}</span><span id="ec26" class="lk jg hi lg b fi lp lm l ln lo">private Bitmap getScreenShotBitmapWithUiAutomator() {<br/>   return Screenshot.capture().getBitmap();<br/>}</span></pre><p id="4d5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，您可以使用<a class="ae je" href="https://developer.android.com/reference/androidx/test/runner/screenshot/Screenshot" rel="noopener ugc nofollow" target="_blank">屏幕截图API </a>或<a class="ae je" href="https://developer.android.com/reference/android/app/UiAutomation#takeScreenshot()" rel="noopener ugc nofollow" target="_blank">ui automation . take screen shot()</a>方法来完成。我把这个选择留给读者。</p><p id="2f30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> d .添加给截图起个好名字的方法</strong></p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="36e0" class="lk jg hi lg b fi ll lm l ln lo">private String getTestReportFileBaseName(@NonNull final TestEvent testEvent) {<br/>   final SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyyMMdd_hhmmss");<br/>   final String timeStamp = simpleDateFormat.format(Calendar.getInstance().getTime());<br/>   return timeStamp + "_" + testName.getMethodName() + "_" + testEvent;<br/>}</span></pre><p id="5409" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于开发人员来说，什么是好的是相当主观的，在我的例子中，我将时间戳与测试用例的名称和给定的测试事件连接起来(例如，20210520 _ 120000 _ myUiTest _ FAILURE)</p><p id="a3fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> e .最后，也可能是最重要的一步，我们需要将它保存到设备上</strong></p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="c744" class="lk jg hi lg b fi ll lm l ln lo">private ContentResolver getContentResolver() {<br/>   return InstrumentationRegistry.getInstrumentation()<br/>                                 .getTargetContext()<br/>                                 .getApplicationContext()<br/>                                 .getContentResolver();<br/>}</span><span id="1e31" class="lk jg hi lg b fi lp lm l ln lo">private void storeScreenshot(@NonNull final Bitmap screenShotBitmap, @NonNull final String screenShotFileName) {<br/>   final ContentResolver contentResolver = getContentResolver();<br/>   final String UiTestScreenShotsDirName = "UiTestScreenShots";</span><span id="943b" class="lk jg hi lg b fi lp lm l ln lo">   try {<br/>       if (android.os.Build.VERSION.SDK_INT &gt;= 29) {<br/>           storeWithMediaStore(new ContentValues(), contentResolver, screenShotFileName,<br/>                   UiTestScreenShotsDirName, screenShotBitmap);<br/>       } else {<br/>           storeWithFileOutputStream(new ContentValues(), contentResolver, screenShotFileName,<br/>                   UiTestScreenShotsDirName, screenShotBitmap);<br/>       }<br/>       Log.i(UI_TEST_TAG, "Created screenshot " + screenShotFileName);<br/>   } catch (final IOException e) {<br/>       Log.e(UI_TEST_TAG, "Failed to take screenshot!", e);<br/>       e.printStackTrace();<br/>   }<br/>}</span></pre><p id="2ab0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，我在这里也添加了一些日志，在存储截图的过程中，我使用了传统的<a class="ae je" href="https://developer.android.com/reference/android/content/ContentResolver" rel="noopener ugc nofollow" target="_blank">内容解析器</a>。由于<a class="ae je" href="https://developer.android.com/training/data-storage#scoped-storage" rel="noopener ugc nofollow" target="_blank">的限制和API级</a>的更新，我们需要一种不同的方法。在这里你可以查看我的例子:</p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="17fd" class="lk jg hi lg b fi ll lm l ln lo">@RequiresApi(Build.VERSION_CODES.Q)<br/>private void storeWithMediaStore(@NonNull final ContentValues contentValues,<br/>                                @NonNull final ContentResolver contentResolver,<br/>                                @NonNull final String screenshotFileName,<br/>                                @NonNull final String screenshotLocation,<br/>                                @NonNull final Bitmap screenshotBitmap) throws IOException {<br/>   applyBaseScreenshotContentValues(contentValues);<br/>   contentValues.put(MediaStore.MediaColumns.DISPLAY_NAME, screenshotFileName + ".jpeg");<br/>   contentValues.put(MediaStore.Images.Media.RELATIVE_PATH,<br/>           Environment.DIRECTORY_PICTURES + "/" + screenshotLocation);</span><span id="f1c7" class="lk jg hi lg b fi lp lm l ln lo">   final Uri uri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues);<br/>   if (uri != null) {<br/>       try (final OutputStream outputStream = contentResolver.openOutputStream(uri)) {<br/>           saveScreenshotToStream(screenshotBitmap, outputStream);<br/>       }<br/>       contentResolver.update(uri, contentValues, null, null);<br/>   }<br/>}</span><span id="e8e5" class="lk jg hi lg b fi lp lm l ln lo">@RequiresPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)<br/>private void storeWithFileOutputStream(@NonNull final ContentValues contentValues,<br/>                                      @NonNull final ContentResolver contentResolver,<br/>                                      @NonNull final String screenshotFileName,<br/>                                      @NonNull final String screenshotLocation,<br/>                                      @NonNull final Bitmap screenshotBitmap) throws IOException {<br/>   final File picturesDir = new File("/sdcard/Pictures/" + screenshotLocation);<br/>   final File screenshotFile = new File(picturesDir, screenshotFileName + ".jpg");<br/>   screenshotFile.mkdirs();<br/>   if (screenshotFile.exists()) {<br/>       screenshotFile.delete();<br/>   }</span><span id="5173" class="lk jg hi lg b fi lp lm l ln lo">   try (final FileOutputStream outputStream = new FileOutputStream(screenshotFile)) {<br/>       saveScreenshotToStream(screenshotBitmap, outputStream);<br/>   }</span><span id="9d43" class="lk jg hi lg b fi lp lm l ln lo">   applyBaseScreenshotContentValues(contentValues);<br/>   contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues);<br/>}</span><span id="7f71" class="lk jg hi lg b fi lp lm l ln lo">private void saveScreenshotToStream(@NonNull final Bitmap screenshotBitmap,<br/>                                   @NonNull final OutputStream outputStream) {<br/>   screenshotBitmap.compress(Bitmap.CompressFormat.JPEG, SCREENSHOT_COMPRESSION, outputStream);<br/>}</span></pre><p id="4424" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不会深入细节，因为这是一个不同的主题，我的文章永远不会结束，但也许我会更新这篇文章的链接，如果我决定在未来写关于Android上的数据存储。你唯一需要知道的是，这将把截图存储在SD card/Pictures/uitest snapshot s/目录下。不要忘记授予低于API级的应用的写权限。最简单的方法是使用<strong class="ih hj"/><a class="ae je" href="https://developer.android.com/reference/androidx/test/rule/GrantPermissionRule" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">GrantPermissionrule</strong>。</a></p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="8d97" class="lk jg hi lg b fi ll lm l ln lo">@Rule<br/>public GrantPermissionRule mRuntimePermissionRule = GrantPermissionRule.grant(<br/>       Manifest.permission.WRITE_EXTERNAL_STORAGE);</span></pre><h1 id="a558" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">接管</h1><p id="d73c" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">创建不同测试事件的<strong class="ih hj">截图，它可以帮助您发现导致失败的问题。</strong></p><h1 id="6170" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">转储视图层次结构</h1><p id="d5b4" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">创建截图在某些情况下非常有用，但如果我们不想要更多的代码细节，我们就不是开发人员。可能有看起来相似的视图，特别是在转换期间，所以在某些情况下，当我们调试一个测试失败时，一些资源名称和ID将意味着整个世界。如标题所示，我们也可以将视图层次结构转储到一个文件中。这是你可以做到的。</p><p id="9238" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> a. </strong>创建您的TestWatcher(参见屏幕截图Ui测试事件)</p><p id="e452" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> b. </strong>创建一个方法，用于转储视图层次结构并将其存储在设备上</p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="b58e" class="lk jg hi lg b fi ll lm l ln lo">private void dumpWindowHierarchy(@NonNull final TestEvent testEvent) {<br/>   try {<br/>       final String hierarchyReportFileName = getTestReportFileBaseName(testEvent) + "_hierarchy";<br/>       if (android.os.Build.VERSION.SDK_INT &gt;= 29) {<br/>           uiDevice.dumpWindowHierarchy(getOutputStreamForViewHierarchyFile(hierarchyReportFileName));<br/>       } else {<br/>           uiDevice.dumpWindowHierarchy(createViewHierarchyFile(hierarchyReportFileName));<br/>       }<br/>   } catch (final IOException e) {<br/>       Log.i(UI_TEST_TAG, "Failed to dump view hierarchy.", e);<br/>       throw new IllegalStateException(e);<br/>   }<br/>}</span></pre><p id="1e89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，对于Espresso，您可以使用<a class="ae je" href="https://developer.android.com/reference/androidx/test/espresso/util/TreeIterables" rel="noopener ugc nofollow" target="_blank"> TreeIterables </a>来创建视图层次。类似地，就像截图一样，我们必须使用不同的方法来存储API级别29的文件。</p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="7bc0" class="lk jg hi lg b fi ll lm l ln lo">@RequiresApi(Build.VERSION_CODES.Q)<br/>private OutputStream getOutputStreamForViewHierarchyFile(@NonNull final String hierarchyReportFileName)<br/>       throws FileNotFoundException {<br/>   final ContentValues values = new ContentValues();<br/>   values.put(MediaStore.Downloads.DISPLAY_NAME, hierarchyReportFileName);<br/>   values.put(MediaStore.Downloads.RELATIVE_PATH, "Download/UiTestHierarchy");<br/>   values.put(MediaStore.Downloads.MIME_TYPE, "text/xml");<br/>   values.put(MediaStore.Downloads.IS_PENDING, 1);</span><span id="221f" class="lk jg hi lg b fi lp lm l ln lo">   final ContentResolver resolver = getContentResolver();<br/>   final Uri contentUri = MediaStore.Downloads.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY);<br/>   final Uri itemUri = resolver.insert(contentUri, values);</span><span id="a2f2" class="lk jg hi lg b fi lp lm l ln lo">   if (itemUri != null) {<br/>       resolver.openFileDescriptor(itemUri, "w");<br/>       values.clear();<br/>       values.put(MediaStore.Downloads.IS_PENDING, 0);<br/>       resolver.update(itemUri, values, null, null);<br/>       return resolver.openOutputStream(itemUri);<br/>   }<br/>   return null;<br/>}</span><span id="5e89" class="lk jg hi lg b fi lp lm l ln lo">@NonNull<br/>private File createViewHierarchyFile(@NonNull final String hierarchyReportFileName) {<br/>   final File hierarchyDump = new File("/sdcard/Download/UiTestHierarchy", hierarchyReportFileName + ".xml");<br/>   hierarchyDump.mkdirs();<br/>   if (hierarchyDump.exists()) {<br/>       hierarchyDump.delete();<br/>   }</span><span id="519f" class="lk jg hi lg b fi lp lm l ln lo">   return hierarchyDump;<br/>}</span></pre><p id="4c73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> c. </strong>如上面的代码所示，这些方法将视图层次结构文件存储在文件夹/SD card/Download/uitesthierchy/下。请注意，在截图部分已经介绍了一些帮助函数，你可以在那里找到它们。</p><h1 id="925e" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">外卖食品</h1><p id="abf2" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">您可以在UI测试的不同阶段创建<strong class="ih hj">视图</strong> <strong class="ih hj">层次转储</strong>，这可以帮助您调试测试失败。</p><h1 id="8ded" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">从设备中提取保存的数据</h1><p id="adae" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">当您在本地机器上工作时，您可以通过使用Android Studio中的<strong class="ih hj">设备文件浏览器</strong>轻松查看收集的测试数据。只需搜索给定的文件并双击打开它，或者你甚至可以下载到你的机器上，只需右键单击和左键单击“另存为”。</p><figure class="kx ky kz la fd lb er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lz"><img src="../Images/87ed640bd21c576a44f1987c9f04f424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*163ODhftLRhTuTXr.png"/></div></div></figure><p id="6364" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在CI上要复杂得多，因为它可能不会存储给定虚拟设备的数据。例如，这就是<strong class="ih hj">位上升</strong>的情况。在构建完成之前，我们必须从设备中取出这些文件，并上传到某个地方。幸运的是，通过一个简单的<a class="ae je" href="https://www.bitrise.io/integrations/steps/script" rel="noopener ugc nofollow" target="_blank">脚本步骤</a>，我们可以很容易地做到这一点，当收集的数据准备就绪时，只需将以下代码添加到您的bitrise.yml中:</p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="f768" class="lk jg hi lg b fi ll lm l ln lo">- script@1:<br/>   title: save_collected_test_data<br/>   is_always_run: true<br/>   description: |-<br/>     Pulls from the virtual device and moves it to the build reports dir the following things:<br/>     1. screenshots of UI tests<br/>     2. view hierarchy xmls of UI tests<br/>   inputs:<br/>     - content: |-<br/>         #!/usr/bin/env bash<br/>         # fail if any commands fails<br/>         set -e<br/>         # debug log<br/>         set -x</span><span id="ea91" class="lk jg hi lg b fi lp lm l ln lo">         echo "Listing files in /sdcard/Pictures/UiTestScreenShots/"<br/>         adb shell ls /sdcard/Pictures/UiTestScreenShots/ || true</span><span id="84a6" class="lk jg hi lg b fi lp lm l ln lo">         echo</span><span id="ae0b" class="lk jg hi lg b fi lp lm l ln lo">         echo "Listing files in /sdcard/Download/UiTestHierarchy/"<br/>         adb shell ls /sdcard/Download/UiTestHierarchy/ || true</span><span id="033a" class="lk jg hi lg b fi lp lm l ln lo">         echo "Pulling test data files"<br/>         mkdir -p /bitrise/src/trace-test-application/build/reports/screenshots/<br/>         adb pull /sdcard/Pictures/UiTestScreenShots/ /bitrise/src/trace-test-application/build/reports/screenshots/<br/>         mkdir -p /bitrise/src/trace-test-application/build/reports/viewhierarchy/<br/>         adb pull /sdcard/Download/UiTestHierarchy/ /bitrise/src/trace-test-application/build/reports/viewhierarchy/</span></pre><p id="ef58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，在将文件拖到给定应用程序的build/reports目录之前，我打印出了用于调试目的的文件列表。现在我们只需要把它上传到我们能找到的地方。前面的例子我已经在CI 文章的<strong class="ih hj">测试中展示过，用<a class="ae je" href="https://www.bitrise.io/integrations/steps/deploy-to-bitrise-io" rel="noopener ugc nofollow" target="_blank"> Deploy to Bitrise.io步骤</a>上传它。</strong></p><h1 id="f36e" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">接管</h1><p id="22b7" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">使用<strong class="ih hj"> adb pull </strong>命令提取收集的数据，并将其存储在某处。</p><h1 id="c4e4" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">检查您设备的健康状况</h1><p id="db4f" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">有时虚拟设备启动会导致失败。它们甚至会在您的构建运行期间死亡，这可能会让您无法理解，为什么您的测试运行会以失败告终。一个简单而有用的技巧是用adb devices命令检查设备的健康状况。例如，如果您收到“离线”结果，您应该知道您的设备没有响应或当时没有连接。详情请参见<a class="ae je" href="https://developer.android.com/studio/command-line/adb" rel="noopener ugc nofollow" target="_blank">文档</a>。<br/>在Bitrise中，只需添加一个脚本步骤来进行设备健康检查。</p><pre class="kx ky kz la fd lf lg lh li aw lj bi"><span id="d9b1" class="lk jg hi lg b fi ll lm l ln lo">- script@1:<br/>   inputs:<br/>     - content: |-<br/>         #!/usr/bin/env bash<br/>         # fail if any commands fails<br/>         set -e<br/>         # debug log<br/>         set -x</span><span id="c705" class="lk jg hi lg b fi lp lm l ln lo">         adb devices<br/>         sdkmanager --list<br/>   title: Log emulators and installed SDK packages</span></pre><p id="87fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:我更喜欢列出已安装的SdkManager包，当一个奇怪的问题发生时，它会有所帮助，而且这是谷歌方面的已知问题。</p><h1 id="6553" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">摘要</h1><p id="5a6d" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">您可以在运行测试之前、期间和之后做一些事情来帮助减轻剥落问题。希望你喜欢我的文章，让我知道你的想法和问题。</p></div></div>    
</body>
</html>