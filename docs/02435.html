<html>
<head>
<title>What is boxing and unboxing in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是C#中的装箱和拆箱</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-is-boxing-and-unboxing-in-c-1512f13ed907?source=collection_archive---------11-----------------------#2021-07-20">https://medium.com/codex/what-is-boxing-and-unboxing-in-c-1512f13ed907?source=collection_archive---------11-----------------------#2021-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/590d66faa944252429ffb03d0d1640f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5eb6IphsPQ00UbrG9M9VA.jpeg"/></div></div></figure><p id="28c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">C#中的数据类型通常可以分为两种类型，即。值类型和引用类型。引用类型保存存储值的地址，但值类型保留项本身。</p><p id="d720" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">值类型包括int、float、double、decimal、bool、char等，引用类型包括object、string、array等。在处理这些数据类型时，您经常需要将值类型转换为引用类型，反之亦然。</p><p id="f592" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为它们具有不同的特性，并且以不同的方式存储在内存中。NET必须执行一些内部工作来将它们从一种类型转换成另一种类型。装箱和取消装箱是这些转换过程的工具。所以让我们快速了解一下什么是C#中的装箱和拆箱。</p><p id="eaac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录</strong></p><ol class=""><li id="7e85" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">C#中的装箱是什么？</li><li id="972e" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">C#中的装箱示例</li><li id="ba67" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">为什么这个概念被命名为拳击？</li><li id="8009" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">C#中什么是拆箱？</li><li id="c19a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">C#中取消装箱的示例</li><li id="26c1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">C#中装箱和取消装箱的主要区别</li><li id="7d1e" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">结论</li></ol><h1 id="9c6d" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">C#中的装箱是什么？</h1><p id="7ceb" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">装箱是将值类型转换为引用类型的隐式转换类型。它涉及将值类型转换为类型对象或由该值类型实现的任何接口类型。CLR将值类型包含在对象实例中，并在装箱时将其保存在托管堆中。</p><p id="07ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在垃圾收集堆中，使用装箱来存储值类型。当对值类型进行装箱时，它会在堆上创建一个新的对象实例，并将值复制到其中。</p><p id="62b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一个简单的例子:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/c56fcdf5675cd3524690b10a9325799d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/0*D5bNCmkXRHiuRmW6"/></div></figure><p id="eb4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">声明一个整数类型的值类型变量(num ),并为其赋值。创建对象引用类型(obj)并应用显式操作，这将导致num值类型被复制并保存在对象引用类型obj中，如下所示:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/48a8bb835c7e929c081da84c4c95940b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/0*sEkYfcgDRxrtjmdH"/></div></figure><h1 id="1937" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">C#中的装箱示例</h1><p id="1e07" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">下面是用C#描述装箱的程序:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/056eaa7430a2ed59e719ceafc6918845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uyWg28B5C68EoMcH"/></div></div></figure><p id="c030" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出:</strong></p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/7204c152d1f2cf17e29f44b7624e5c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/0*uyW4WTqON1xAjips"/></div></figure><h1 id="0095" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">为什么这个概念被命名为拳击？</h1><p id="33ee" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">您可能很清楚，所有保存在堆上的引用类型都包含值的地址。值类型只是放在堆栈上的一个实际值。Int I现在被分配给对象o(如第一个例子所示)。对象o必须是地址而不是值。因此，CLR创建了一个新的系统来装箱值类型。整个过程被称为“装箱”,因为CLR在存储该项的堆上构造了一个盒子。</p><h1 id="df36" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">C#中什么是拆箱？</h1><p id="807f" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">顾名思义，unboxing与boxing正好相反。它是引用类型到值类型的转换。从引用类型中提取值，并通过取消装箱将其赋给值类型。拆箱行为是显而易见的。这就需要进行特殊的铸造。</p><p id="dbac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">换句话说，从类型对象到值类型的显式转换，或者从接口类型到实现该接口的值类型的显式转换，称为取消装箱。拆包操作需要以下步骤:</p><ul class=""><li id="a054" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn ln ju jv jw bi translated">确保对象实例是否是指定值类型的装箱值。</li><li id="c851" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated">实例的值被复制到值类型变量中。</li></ul><p id="bd06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一个简单的例子:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/a4fb06c759cd0856d0e8003cc79b913a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qJlU0Mg_aMAXEF1d"/></div></div></figure><p id="8798" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">声明一个整型的值类型变量(num ),存储一个值。现在创建一个引用对象类型(obj)。显式装箱过程创建一个I类型的整数值，并使用强制转换方法。然后，堆上引用的类型被复制到堆栈，如下图所示:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/e4ddf7aeaefaa71712050d53c6df276d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/0*xsini5rjXCCUzyoy"/></div></figure><h1 id="7849" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">C#中取消装箱的示例</h1><p id="6f7c" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">以下是C#中取消装箱的示例:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/baa5f21601ed35f1372ee3b53a8de06c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*smi91cRzgz_J1kgH"/></div></div></figure><p id="02ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出:</strong></p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/a7cb9e4b796cb62f0c3231a773a48ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/0*KMPNqo5gHlH8uXqq"/></div></figure><h1 id="ab08" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">C#中装箱和取消装箱的主要区别</h1><h2 id="af56" class="ls kd hi bd ke lt lu lv ki lw lx ly km jb lz ma kq jf mb mc ku jj md me ky mf bi translated">拳击</h2><ul class=""><li id="598c" class="jo jp hi is b it la ix lb jb mg jf mh jj mi jn ln ju jv jw bi translated">它用于将值类型转换为对象类型</li><li id="3056" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated">拳击是一种隐式转换的形式</li><li id="106d" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated">堆栈上的值被复制到堆内存上的对象中</li></ul><p id="1852" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">拳击的例子-</p><pre class="lg lh li lj fd mj mk ml mm aw mn bi"><span id="8866" class="ls kd hi mk b fi mo mp l mq mr">// C# program to illustrate Boxing using System; public class example { static public void Main() { ​ int value = 20; ​ // Boxing ​ object obj = value; ​ // Change the value of val ​ value = 30; ​ Console.WriteLine("Value type of value is {0}", value); ​ Console.WriteLine("Object type of value is {0}", obj); } }</span></pre><p id="426b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出</strong></p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/3af6a9143cc2e09bdd23427624e33856.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/0*ldfX9qA9Sp6d4JEH"/></div></figure><h2 id="354f" class="ls kd hi bd ke lt lu lv ki lw lx ly km jb lz ma kq jf mb mc ku jj md me ky mf bi translated">拆箱</h2><ul class=""><li id="a626" class="jo jp hi is b it la ix lb jb mg jf mh jj mi jn ln ju jv jw bi translated">它将对象类型转换为值类型</li><li id="b3b8" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated">取消装箱是显式转换的一种形式</li><li id="32f9" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated">堆内存中的项被复制到堆栈内存中的值</li></ul><p id="6b72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">C#中取消装箱的示例</p><pre class="lg lh li lj fd mj mk ml mm aw mn bi"><span id="e34c" class="ls kd hi mk b fi mo mp l mq mr">// C# program to illustrate Unboxing using System; public class example { static public void Main() { ​ int value = 20; ​ // Boxing ​ object obj = value; ​ // Unboxing ​ int a = (int)obj; ​ Console.WriteLine("Value of object is {0}", obj); ​ Console.WriteLine("Value of a is {0}", a); }</span></pre><p id="31b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">}</p><p id="67e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出</strong></p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/4ef16cabac86b9699bf58d386da4945d.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/0*lkJha14Ps04jCUEf"/></div></figure><h1 id="f2b6" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="0f3f" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">可以这样想——对于不需要int值作为对象来操作的应用程序，Int值只是32位数字。将值类型视为对象的能力弥补了大多数语言中值类型和引用类型之间的差距。对于需要int值表现得像对象一样的程序，可以按需访问该功能。</p></div><div class="ab cl mu mv gp mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hb hc hd he hf"><p id="85f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="nb">原发布于</em><a class="ae nc" href="https://www.partech.nl/nl/publicaties/2021/07/what-is-boxing-and-unboxing-in-c-sharp" rel="noopener ugc nofollow" target="_blank"><em class="nb">https://www . partech . nl</em></a><em class="nb">。</em></p></div></div>    
</body>
</html>