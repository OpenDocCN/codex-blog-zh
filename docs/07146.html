<html>
<head>
<title>Adding LaTeX Rendering to Our Website, Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向我们的网站添加LaTeX渲染，第1部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/adding-latex-rendering-to-our-website-part-1-cedd84a24baa?source=collection_archive---------13-----------------------#2022-06-01">https://medium.com/codex/adding-latex-rendering-to-our-website-part-1-cedd84a24baa?source=collection_archive---------13-----------------------#2022-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="36c7" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">文章</h2><div class=""/><div class=""><h2 id="ac7e" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">从<a class="ae jg" href="https://www.manning.com/books/hugo-in-action?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_jain_hugo_9_24_19" rel="noopener ugc nofollow" target="_blank">雨果在行动</a>由阿蒂沙·贾因</h2></div><p id="6a14" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">这篇文章是关于给一个用Hugo构建的静态网站添加LaTeX渲染的。</p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="299a" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">在<a class="ae jg" href="https://www.manning.com/?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_jain_hugo_9_24_19" rel="noopener ugc nofollow" target="_blank">manning.com</a>结账时，将<strong class="jj hs"> fccjain </strong>输入折扣代码框，即可享受<a class="ae jg" href="https://www.manning.com/books/hugo-in-action?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_jain_hugo_9_24_19" rel="noopener ugc nofollow" target="_blank">T3【雨果在行动T5】的六折优惠。</a></p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="7d6e" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">Acme公司致力于数字造型。形状与几何是相互联系的，我们需要进入数学符号库来更好地表达和理解形状。LaTeX是科学论文中表示数学符号最常用的方式。在撰写本文时，Hugo本身并不支持LaTeX渲染。</p><p id="5c59" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">一个名为math jax(https://www.mathjax.org/)的JavaScript库支持在web浏览器中呈现基于LaTeX的数学符号。这个库相当受欢迎，它被互联网上大多数需要数学符号的网站所使用。该库在网页上扫描基于LaTeX的数学表达式，并用等效的SVG再现替换它们。虽然直接使用MathJax是在我们的网站上获得数学符号的最简单的解决方案，但它也有一些缺点。</p><ul class=""><li id="f4c4" class="kl km hi jj b jk jl jn jo jq kn ju ko jy kp kc kq kr ks kt bi translated">MathJax相当大。尽管它会进行代码分割，并试图获得最小的有效负载来呈现所需的内容，但它仍然是一个额外的JavaScript，需要下载并在每个客户的机器上运行。</li><li id="6e8d" class="kl km hi jj b jk ku jn kv jq kw ju kx jy ky kc kq kr ks kt bi translated">MathJax没有给我们的网站增加任何交互性。输出是静态图像，在浏览器中这样做没有什么好处。在服务器上渲染数学比增加额外的跳跃来下载这个库，然后执行计算和更新图像更高效和更快。</li><li id="1a2f" class="kl km hi jj b jk ku jn kv jq kw ju kx jy ky kc kq kr ks kt bi translated">客户端上的MathJax不是缓存友好的。因为它需要按需完成所有的工作，所以我们不能为我们的数学符号预先生成图像并保存它们。</li></ul><p id="f40f" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">如果我们能够将数学渲染移动到服务器，并在页面加载甚至网站重建时缓存结果，这将是一种卓越的用户体验。因为Hugo不直接与MathJax接口，所以我们需要通过使用外部API来扩展Hugo来执行这项任务。首先，我们创建一个云函数并托管它。该函数采用LaTeX表达式并返回相应的SVG图像。接下来，我们在网站编译期间从Hugo调用它，并将搜索结果放在我们的网站中。</p><h2 id="6bc7" class="kz la hi bd lb lc ld le lf lg lh li lj jq lk ll lm ju ln lo lp jy lq lr ls ho bi translated"><strong class="ak">子进程vs API</strong></h2><p id="5681" class="pw-post-body-paragraph jh ji hi jj b jk lt is jm jn lu iv jp jq lv js jt ju lw jw jx jy lx ka kb kc hb bi translated">理论上，将与项目相关的额外代码作为子流程运行更容易，这已经成为与其他工具交互的首选机制。Hugo通过命令行调用像AsciiDoc这样的外部助手以及像PostCSS这样的工具，但是该特性不能用于一般用途。子进程有一个不好的习惯，那就是获得启动它们的父进程的完全凭证和控制权。这意味着任何恶意软件都可以很容易地隐藏在模块或一些示例源代码中，如果通过子进程运行，会对系统造成巨大的破坏。</p><p id="d3b9" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">通过HTTP访问的API由于运行在不同的机器上而被沙箱化。这使得Hugo生态系统更加安全。虽然你需要小心运行<code class="du ly lz ma mb b">npm install</code>以确保你不会碰到恶意软件，但是运行Hugo命令不太可能对你的机器造成任何损害。Hugo不能在<code class="du ly lz ma mb b">public</code>目录之外写东西，这使得一切都很安全。另外，创建API促进了跨多个系统的重用，因为这些API形成了松散耦合的微服务，不仅可以在编译时使用，也可以在运行时使用。</p><h2 id="ab5c" class="kz la hi bd lb lc ld le lf lg lh li lj jq lk ll lm ju ln lo lp jy lq lr ls ho bi translated"><strong class="ak">编写代码渲染LaTeX </strong></h2><p id="0b1a" class="pw-post-body-paragraph jh ji hi jj b jk lt is jm jn lu iv jp jq lv js jt ju lw jw jx jy lx ka kb kc hb bi translated">因为MathJax是用JavaScript编写的，所以我们使用node.js与它接口。我们首先安装MathJax的node.js版本，作为我们网站的依赖项。这可以通过在<code class="du ly lz ma mb b">package.hugo.json</code>中添加<code class="du ly lz ma mb b">mathjax</code>作为依赖项来实现。注意，我们使用<code class="du ly lz ma mb b">dependency</code>而不是<code class="du ly lz ma mb b">package.hugo.json</code>中的<code class="du ly lz ma mb b">devDependency</code>属性，因为实时生产代码需要依赖关系。对于本文，我们使用MathJax的3.1.2版本。</p><pre class="mc md me mf fd mg mb mh mi aw mj bi"><span id="042c" class="kz la hi mb b fi mk ml l mm mn">// package.hugo.json<br/> {<br/>  "dependencies": {<br/>    "mathjax": "3.1.2"<br/>  }<br/> }</span></pre><p id="bd1e" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">接下来我们需要通过hugo重新生成package.json，然后将其作为依赖项安装。</p><pre class="mc md me mf fd mg mb mh mi aw mj bi"><span id="589c" class="kz la hi mb b fi mk ml l mm mn">hugo mod npm pack<br/> npm install</span></pre><p id="9de4" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">这将下载MathJax作为我们网站的依赖项。接下来，我们创建一个tex2svg文件夹，其中包含将LaTeX转换为svg的代码。这包括初始化MathJax，将LaTeX字符串和可用于执行SVG转换的参数作为输入，然后将输出作为字符串返回。我们将API代码保存到一个名为<code class="du ly lz ma mb b">api</code>的文件夹中，该文件夹下有一个名为tex2svg的子文件夹，它公开了这个函数。在这个文件中，我们有一个名为index.js的文件，它将这个文件公开为一个云函数。</p><p id="15b5" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">对于这个方法，我们使用AWS Lambda和Netlify函数使用的<code class="du ly lz ma mb b">exports.handler = async function(event, context){}</code>格式。这个函数有两个参数，事件和上下文。<code class="du ly lz ma mb b">event</code>是包含以下属性的对象:</p><ul class=""><li id="fc57" class="kl km hi jj b jk jl jn jo jq kn ju ko jy kp kc kq kr ks kt bi translated">path:请求的路径(例如/latex2svg)</li><li id="970b" class="kl km hi jj b jk ku jn kv jq kw ju kx jy ky kc kq kr ks kt bi translated">httpMethod:传入请求的方法名(GET、POST、PUT等。)</li><li id="00b3" class="kl km hi jj b jk ku jn kv jq kw ju kx jy ky kc kq kr ks kt bi translated">头:传入的请求头(例如{ ' Content-Type ':' application/JSON ' })</li><li id="ce6f" class="kl km hi jj b jk ku jn kv jq kw ju kx jy ky kc kq kr ks kt bi translated">queryStringParameters:查询字符串参数(例如{tex: '\frac{1}{2}'})</li><li id="bf04" class="kl km hi jj b jk ku jn kv jq kw ju kx jy ky kc kq kr ks kt bi translated">body:请求负载的JSON字符串。(GET请求中为空)</li><li id="775f" class="kl km hi jj b jk ku jn kv jq kw ju kx jy ky kc kq kr ks kt bi translated">isBase64Encoded:一个布尔标志，指示适用的请求有效负载是否以Base64格式编码。</li></ul><p id="7f09" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">这个脚本的代码在本文的参考资料(<a class="ae jg" href="https://github.com/hugoinaction/%20hugoinaction/tree/ch11-resources/2" rel="noopener ugc nofollow" target="_blank">https://github.com/hugoinaction/·胡戈因action/tree/ch11-resources/2</a>)中共享。</p><p id="24ec" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated"><strong class="jj hs">清单1。将LaTeX转换为SVG的云函数的源代码。</strong></p><pre class="mc md me mf fd mg mb mh mi aw mj bi"><span id="256d" class="kz la hi mb b fi mk ml l mm mn">// api/latex2svg.js<br/> const MathjaxModule = require("mathjax");  ❶<br/> let MathJax = null;<br/> module.exports = {<br/>  /**<br/>   * Function to handle calls to the API endpoint of the cloud function.<br/>   */<br/>  async handler(event, context) {<br/>    if (!event.queryStringParameters || !event.queryStringParameters.tex) { ❷<br/>      return {<br/>        statusCode: 400,<br/>        headers: {'Content-Type': 'application/json'},<br/>        body: JSON.stringify({<br/>          error: "The required `tex` parameter not supplied.",<br/>        })<br/>      }<br/>    }<br/>    if (!MathJax) { ❸<br/>      MathJax = await MathjaxModule.init({<br/>        loader: { load: ['input/tex', 'output/svg'] }<br/>      });<br/>    }<br/> <br/>    const svg = MathJax.tex2svg(event.queryStringParameters.tex, { ❹<br/>        display: event.queryStringParameters.display,<br/>        em: event.queryStringParameters.em,<br/>        ex: event.queryStringParameters.ex,<br/>        containerWidth:  event.queryStringParameters.containerWidth,<br/>        lineWidth: event.queryStringParameters.lineWidth,<br/>        scale: event.queryStringParameters.scale<br/>      });<br/>    return {    ❺<br/>      statusCode: 200,<br/>      headers: {'Content-Type': 'application/json'},<br/>      body: JSON.stringify({<br/>        data: MathJax.startup.adaptor.outerHTML(svg)<br/>      })<br/>    };<br/>  },<br/> }</span></pre><p id="a8bc" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">❶ <strong class="jj hs">导入MathJax依赖项</strong></p><p id="cfa4" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">❷ <strong class="jj hs">确保tex参数可用。</strong></p><p id="4eb0" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">❸ <strong class="jj hs">仅在需要时初始化MathJax。它将输入作为LaTeX并输出SVG </strong></p><p id="c7b2" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">❹ <strong class="jj hs">将查询字符串中的所有参数传递给MathJax </strong></p><p id="a815" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">❺以JSON的形式返回200个结果。</p><p id="abc7" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">我们有意输出JSON字符串而不是原始SVG，以便通过GetJSON在Hugo中将它作为JSON对象，并在需要时能够对它进行后期处理。如果需要，我们可以在响应JSON中将附加信息传递给Hugo。</p><p id="e903" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">这些代码现在可以部署到FAAS解决方案中，如AWS Lambda或Netlify函数，以便在任何地方使用。对于PAAS解决方案，我们需要做更多的工作。</p><h2 id="97c5" class="kz la hi bd lb lc ld le lf lg lh li lj jq lk ll lm ju ln lo lp jy lq lr ls ho bi translated"><strong class="ak">添加一个HTTP服务器来调用这个函数</strong></h2><p id="cdde" class="pw-post-body-paragraph jh ji hi jj b jk lt is jm jn lu iv jp jq lv js jt ju lw jw jx jy lx ka kb kc hb bi translated">虽然我们有将LaTeX转换成SVG的代码，但是我们还没有在本地测试它。FAAS提供商提供诸如Netlify Dev、AWS SAM或Firebase function emulator等工具，在本地运行云功能，以进行验证和单元测试。对于本文，我们不使用专门的工具，而是编写一些启动器代码来与这个函数交互。这段代码还允许我们与平台a服务解决方案(在我们的例子中是Heroku)进行交互，该解决方案不需要函数，而是需要一个完整的node.js程序来运行。</p><p id="741a" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">我们在项目的根目录下创建一个新的文件api.js(在api文件夹中创建它使Netlify把它当作一个函数),它有一个简单的基于node.js的HTTP服务器，响应HTTP请求并调用这个方法。(<a class="ae jg" href="https://github.com/hugoinaction/hugoinaction/tree/ch11-resources/3" rel="noopener ugc nofollow" target="_blank">https://github . com/hugoin action/hugoin action/tree/ch11-resources/3</a>)。</p><p id="4fba" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated"><strong class="jj hs">清单2。创建一个基于node.js的HTTP服务器，它可以将请求路由到正确的函数，以便在PAAS解决方案中进行处理</strong></p><pre class="mc md me mf fd mg mb mh mi aw mj bi"><span id="f6ff" class="kz la hi mb b fi mk ml l mm mn">const http = require('http');<br/> const querystring = require('querystring');<br/> const latex2svg = require('./api/latex2svg');<br/> const port = process.env.PORT || 3000;   ❶<br/> const server = http.createServer().listen(port);<br/> server.on('request', async function (req, res) {    ❷<br/>    const url = new URL(req.url, `http://${req.headers.host}`);<br/>    const queryStringParameters = url.search &amp;&amp;<br/> querystring.parse(url.search.slice(1));<br/>    const request = {    ❸<br/>      queryStringParameters,<br/>      path: url.pathname,<br/>      httpMethod: req.method,<br/>      headers: req.headers,<br/>      body: req.body<br/>    }<br/>    let response = {  ❹<br/>      statusCode: 404,<br/>      headers: { 'Content-Type': 'application/json'},<br/>      body: JSON.stringify({error: "Page not found"})<br/>    }<br/>    try {<br/>      switch (url.pathname) {    ❺<br/>        case '/latex2svg':<br/>          response = await latex2svg.handler(request);<br/>          break;<br/>      }<br/>    } catch(e) {                 ❻<br/>      response.statusCode = 500;<br/>      response.body = JSON.stringify(e);<br/>    }<br/>    res.writeHead(response.statusCode, response.headers);  ❼<br/>    res.end(response.body);<br/> })</span></pre><p id="8913" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">❶ <strong class="jj hs">从环境变量中询问端口或者默认为3000。</strong></p><p id="be5c" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">❷ <strong class="jj hs">设置一个HTTP服务器。</strong></p><p id="c201" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">❸ <strong class="jj hs">创建一个与AWS Lambda兼容的请求对象。</strong></p><p id="c0a6" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">❹ <strong class="jj hs">创建默认响应。</strong></p><p id="e049" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">❺ <strong class="jj hs">制造出一款轻型路由器</strong></p><p id="5a89" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">❻ <strong class="jj hs">优雅地处理异常</strong></p><p id="f1fa" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">❼ <strong class="jj hs">向客户端发回响应</strong></p><p id="1a30" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">我们可以通过调用项目根目录下的<code class="du ly lz ma mb b">node api</code>来运行这段代码。我们可以导航到http://localhost:3000/latex 2 SVG？tex=%5Cfrac%7Ba%7D%7Bb%7D来获取<code class="du ly lz ma mb b">\frac{a}{b}</code> LaTeX字符串的内联版本的JSON输出。我们可以添加<code class="du ly lz ma mb b">&amp;display=true</code>来获得显示版本。</p><p id="bc82" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">此时，我们应该更新package.json的“main”条目，使其指向<code class="du ly lz ma mb b">api.js</code>，从而允许在JavaScript生态系统中作为有效项目运行。我们还在编写<code class="du ly lz ma mb b">npm start</code>时添加了一个启动脚本来启动我们的API服务器。我们需要通过更新<code class="du ly lz ma mb b">package.hugo.json</code>和运行<code class="du ly lz ma mb b">hugo mod npm pack</code>的相同路线。</p><pre class="mc md me mf fd mg mb mh mi aw mj bi"><span id="c25c" class="kz la hi mb b fi mk ml l mm mn">// package.hugo.json<br/> {<br/>  "main": "api.js",<br/>  "scripts": {<br/>    "start": "node api.js"<br/>  }<br/> }</span></pre><figure class="mc md me mf fd mp er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es mo"><img src="../Images/6271ee48aa46f9a21f133e4bdb969d65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Km0iVHxUDH1UVfHi.jpg"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx translated">图一。LaTeX到SVG转换API的JSON响应。</figcaption></figure><h2 id="ce3a" class="kz la hi bd lb lc ld le lf lg lh li lj jq lk ll lm ju ln lo lp jy lq lr ls ho bi translated"><strong class="ak">增加一些安全性以防止未经授权的访问</strong></h2><p id="6e61" class="pw-post-body-paragraph jh ji hi jj b jk lt is jm jn lu iv jp jq lv js jt ju lw jw jx jy lx ka kb kc hb bi translated">如果我们通过启动器脚本或直接发布我们的函数，我们会因为开放一个整个互联网都可以访问的未经认证的端点而增加风险。如果其他人在没有向我们付费的情况下使用它，这可能会产生巨大的成本。虽然我们无法在不添加身份验证系统或防火墙的情况下阻止我们的端点，但我们可以让任何没有密码的人无法使用它。轻量级安全解决方案可以通过在构建系统和API提供程序中嵌入密码来添加，并通过这两个地方的环境变量来公开它。因为我们的密码不进入客户端，所以它是安全的，只要我们使用好的密码，并且我们的服务提供商是安全的，简单的密码认证机制就可以工作。</p><p id="74c3" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">在latex2svg.js内部，在检查<code class="du ly lz ma mb b">tex</code>查询参数之前，我们应该检查<code class="du ly lz ma mb b">password</code>查询参数，如果没有提供，则返回unauthorized。</p><p id="81fb" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated"><strong class="jj hs">清单3。向我们的API添加密码以防止未经授权的访问</strong></p><pre class="mc md me mf fd mg mb mh mi aw mj bi"><span id="d7a3" class="kz la hi mb b fi mk ml l mm mn">// api/latex2svg.js<br/> ...<br/> async handler(event, context) {<br/>  if (!event.queryStringParameters ||<br/>      !process.env.LATEX2SVG_PASSWORD ||    ❶<br/>      event.queryStringParameters.password !== process.env.LATEX2SVG_PASSWORD) {   <br/>    return {<br/>      statusCode: 401,        ❷<br/>      headers: {'Content-Type': 'application/json'},<br/>      body: JSON.stringify({<br/>        error: "Access Denied.",<br/>      })<br/>    }<br/>  }<br/>  ...<br/> }</span></pre><p id="bf78" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">❶ <strong class="jj hs">不允许空白LATEX2SVG_PASSWORD </strong></p><p id="30ba" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">❷:如果密码错误，我们会使用HTTP 401。如果密码正确，而用户仍然没有访问权限，则HTTP 403是正确的错误代码。</p><p id="15e5" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">对于本地测试，我们可以通过系统上的环境变量公开LATEX2SVG_PASSWORD，因为我们配置云提供商将它传递给Hugo和我们的函数。</p><h2 id="39c8" class="kz la hi bd lb lc ld le lf lg lh li lj jq lk ll lm ju ln lo lp jy lq lr ls ho bi translated"><strong class="ak">部署网络功能</strong></h2><p id="959a" class="pw-post-body-paragraph jh ji hi jj b jk lt is jm jn lu iv jp jq lv js jt ju lw jw jx jy lx ka kb kc hb bi translated">因为我们已经以Netlify理解的方式构建了这个函数，所以不需要做很多工作就可以将它部署到Netlify。我们需要做的第一步是告诉Netlify functions文件夹的位置。要为网络功能设置文件夹，请转到<strong class="jj hs">站点设置</strong> &gt; <strong class="jj hs">功能</strong> &gt; <strong class="jj hs">部署设置</strong>并点击<strong class="jj hs">编辑设置</strong>。</p><figure class="mc md me mf fd mp er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es na"><img src="../Images/ce6a675369e9e83a7550bf5bd71f5727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p8YnmGQyui9xgPUn.jpg"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx translated">图二。用于指定网站源代码所在文件夹位置的网络功能设置。</figcaption></figure><p id="a873" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">接下来指定<code class="du ly lz ma mb b">api</code>并点击保存。</p><figure class="mc md me mf fd mp er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es nb"><img src="../Images/e10142b83a62799785f28c3aba305e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZHpAvCdeejjmp4eU.jpg"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx translated">图3。在部署设置中指定网络功能的目录</figcaption></figure><p id="8c0d" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">我们还需要在构建环境中添加LATEX2SVG_PASSWORD变量。步骤是转到<strong class="jj hs">站点设置</strong> &gt; <strong class="jj hs">构建&amp;部署</strong> &gt; <strong class="jj hs">环境</strong> &gt; <strong class="jj hs">环境变量</strong>。点击<strong class="jj hs">编辑变量</strong> &gt; <strong class="jj hs">新建变量</strong>。为LATEX2SVG_PASSWORD添加一个复杂的密码，然后单击Save。该密码仅需要在部署后测试网络功能。你不需要记住这个密码。</p><figure class="mc md me mf fd mp er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es ca"><img src="../Images/8da8d6d3ee030412c67027382928a0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EeH0HspDVqlshjJF.jpg"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx translated">图4。存储密码以限制对我们功能的未授权访问。环境变量是防止密码进入我们代码库的好方法。</figcaption></figure><p id="e979" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">接下来，我们可以将代码推送到Netlify来测试Netlify函数。代码上线后，我们可以调用<code class="du ly lz ma mb b">https://&lt;endpoint&gt;/.netlify/functions/latex2svg?tex=%5Cfrac%7Ba%7D%7Bb%7D&amp;password=&lt;password&gt;</code>来获得与之前本地运行时相同的响应。</p><p id="a6d6" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">我们还可以在Netlify网站的functions选项卡中看到我们的函数，从这里我们可以获得调试日志，以了解每次调用时发生了什么。任何抛出的错误也会被报告。我们可以将<code class="du ly lz ma mb b">console.log</code>语句放在我们的JavaScript代码中，并在这个摘要页面中查看我们所做的所有日志记录。</p><figure class="mc md me mf fd mp er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es nc"><img src="../Images/6b5888987d10d76300db9194c2abe2d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cD5L_TTAL83bJReA.jpg"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx translated">图5。访问网络功能的日志。Netlify中的“功能”选项卡提供了对Netlify功能的访问，这些功能可用于查看我们网站中所有活动的功能以及与其相关的调试错误。</figcaption></figure></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><figure class="mc md me mf fd mp er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es nd"><img src="../Images/3259c963a6a6cd64e641864bbc5b09a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2mZM5cZM4htfd-qe.jpg"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx translated">图6。Netlify中的每个功能都有详细的日志。</figcaption></figure></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="ed9a" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated"><strong class="jj hs">代码检查点:</strong>现场直播<a class="ae jg" href="https://ch11-1.hugoinaction.com/" rel="noopener ugc nofollow" target="_blank">https://ch11-1.hugoinaction.com</a>。源代码在<a class="ae jg" href="https://github.com/hugoinaction/hugoinaction/tree/ch11-1" rel="noopener ugc nofollow" target="_blank">https://github.com/hugoinaction/hugoinaction/tree/ch11-1</a></p><p id="b72a" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">请继续关注第二部，我们将在那里部署到Heroku。</p><p id="56c5" class="pw-post-body-paragraph jh ji hi jj b jk jl is jm jn jo iv jp jq jr js jt ju jv jw jx jy jz ka kb kc hb bi translated">本文到此为止。如果你想了解这本书的更多内容，可以在曼宁的liveBook平台上查看<a class="ae jg" href="https://livebook.manning.com/book/hugo-in-action?origin=product-look-inside&amp;utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_jain_hugo_9_24_19" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>