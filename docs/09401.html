<html>
<head>
<title>OOPs Under the Hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哎呀引擎盖下</h1>
<blockquote>原文：<a href="https://medium.com/codex/oops-under-the-hood-5297561619a5?source=collection_archive---------10-----------------------#2022-10-18">https://medium.com/codex/oops-under-the-hood-5297561619a5?source=collection_archive---------10-----------------------#2022-10-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="62a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种新的编程范式可以用编程风格的变化来解释。这就要求我们重新审视程序执行过程中的内存分配过程。</p><p id="c241" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正在运行的程序的典型内存布局可以分为四个部分。</p><ul class=""><li id="8547" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><code class="du jm jn jo jp b"><strong class="ih hj">Text</strong></code>:存储正在执行的代码</li><li id="f1ec" class="jd je hi ih b ii jq im jr iq js iu jt iy ju jc ji jj jk jl bi translated"><code class="du jm jn jo jp b"><strong class="ih hj">Data</strong></code>:包含全局变量，分为初始化的和未初始化的。</li><li id="223f" class="jd je hi ih b ii jq im jr iq js iu jt iy ju jc ji jj jk jl bi translated"><code class="du jm jn jo jp b"><strong class="ih hj">Stack</strong></code>:存储局部变量。</li><li id="e370" class="jd je hi ih b ii jq im jr iq js iu jt iy ju jc ji jj jk jl bi translated"><code class="du jm jn jo jp b"><strong class="ih hj">Heap</strong></code>:程序员分配的动态内存</li></ul><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es jv"><img src="../Images/6684f2122c87109d16af31fd62419a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*VIWuammZ_uLPi6_zP3gK-w.png"/></div></figure><h1 id="1eb9" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">堆栈:</h1><p id="88b6" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">堆栈段靠近内存顶部，地址高。每当调用一个函数时，都会为该函数分配一些堆栈内存来存储变量。这种分配使堆栈向下增长。</p><p id="75b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当函数返回时，它的堆栈内存被释放，因此存储在那里的值可能不会保持不变。堆栈帧内存的分配和释放是在运行时自动完成的。</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="lg lh l"/></div></figure><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/a7aa564952af400ac4c1cc51e63968eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fb_-ktnH4kIAyV-y5tbbAA.gif"/></div></div></figure><p id="8f08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">一个常见的错误是返回与局部变量相关的堆栈内存的地址。</strong>调用者得到这个指针后，无效的堆栈内存随时可以被新的函数调用覆盖。</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="8421" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的程序中，变量d保存了一个对已经释放的堆栈内存位置的引用。每当从主函数中再次调用其他函数时，主函数中变量d所指向的内存位置就会被覆盖，从而产生一个垃圾值。</p><h1 id="e2ed" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">堆:</h1><p id="e438" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">与堆栈内存不同，堆内存是显式分配的，只有在显式释放后才能释放。malloc函数或new关键字可用于在C/C++或Java中的堆区域中分配内存。它们返回指向堆中某处的第一个字节的地址作为返回值。</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="lg lh l"/></div></figure><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ln"><img src="../Images/e35ee2f897d5c67b34efd10111bcaaff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T23JAWAva_A7iq9Mi8Lchw.jpeg"/></div></div></figure></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="f45c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过将函数调用堆栈框架移动到堆中，由函数声明的局部变量甚至可以在函数返回后继续存在。</p><p id="998d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这导致函数的名称被重命名为构造函数，因为它们的核心目的是将动态内存分配到堆中，局部变量成为实例变量，而嵌套函数成为方法。</p><p id="b306" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这导致了多态性的发现，多态性只不过是指向函数的<strong class="ih hj">指针的应用。</strong></p><h1 id="3455" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">那么OO到底是什么？</h1><ul class=""><li id="0d39" class="jd je hi ih b ii lb im lc iq lv iu lw iy lx jc ji jj jk jl bi translated">“<strong class="ih hj">数据和函数的结合</strong>”经常被引用作为答案，但它并不令人满意，因为它暗示了o.f()在某种程度上不同于f(o)。</li><li id="5534" class="jd je hi ih b ii jq im jr iq js iu jt iy ju jc ji jj jk jl bi translated">这个问题的另一个常见答案是"<strong class="ih hj">面向对象编程是一种编程方式，它使程序员能够像对待现实生活中的实体一样进行思考</strong>"，这对于我们理解OO是什么毫无帮助。</li><li id="3efd" class="jd je hi ih b ii jq im jr iq js iu jt iy ju jc ji jj jk jl bi translated">最后但同样重要的是，常见的答案是"<strong class="ih hj">OO范式支持</strong> <em class="ly">封装</em> <strong class="ih hj">，</strong> <em class="ly">继承</em> <strong class="ih hj">，以及</strong> <em class="ly">多态</em>"</li></ul><p id="923b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们依次检查每一个概念，看看对于OO世界来说是否有什么新的东西。</p><h1 id="2c26" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">封装:</h1><p id="e5af" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">封装被认为是OO定义的一部分，因为OO语言提供了简单有效的数据和方法封装。因此，可以在数据和功能之间划一条线。在这条线之外，数据是隐藏的，只有一些函数是已知的。我们将这一概念视为一个类的私有数据成员和公共方法。</p><p id="f7df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是面向对象所独有的，在C或C++这样的结构化语言中也可以实现。</p><p id="363b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个例子:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="lg lh l"/></div></figure><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="lg lh l"/></div></figure><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="534e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不可能在上面示例的main函数中访问struct Pair的成员。可以调用<strong class="ih hj"> make_pair </strong>和<strong class="ih hj"> distance </strong>函数，但是我们不知道pair数据结构或函数是如何实现的。在非OO语言中，这是一种完美的封装。</p><h1 id="699e" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">继承:</h1><p id="1870" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">面向对象语言中的封装并不新鲜，所以继承肯定是，对吧？嗯，<strong class="ih hj">没有</strong>。</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="lg lh l"/></div></figure><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="d119" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的程序中，我们声明了一个称为元组的新数据结构，它有一个额外的成员字段，即名称。<strong class="ih hj">元组</strong>数据结构充当<strong class="ih hj">对</strong>数据结构的超集。</p><p id="2e27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它可以伪装成Pair数据结构，因为它维护了对应于Pair的成员的顺序。我们可以轻松地将元组指针类型转换为对指针类型，并可以使用距离和toString函数。因此，我们可以说，即使在非面向对象语言中，我们也有一种继承。</p><h1 id="6578" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">多态性:</h1><p id="10a1" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">我们在非面向对象语言中也有多态行为吗？是的，我们已经有了。</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="a883" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的示例中，我们有两个记录器，一个将数据记录到文件，另一个将数据记录到控制台。我们使用相同的函数名，即<strong class="ih hj"> log </strong>输出两种不同的行为。这被称为多态代码。</p><p id="efb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多态性只不过是指向函数的<strong class="ih hj">指针的应用。这是面向对象中多态性的基础。</strong></p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><blockquote class="lz ma mb"><p id="3abc" class="if ig ly ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated">OO语言可能没有给我们带来什么新的东西，但是它们让一些事情变得微不足道。至少是继承和多态性部分。使用指针需要记住一系列标准和约定。面向对象语言试图消除这些约定。</p></blockquote><h1 id="9196" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">多态性的力量:</h1><p id="d2d4" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">多态性的使用支持基于插件的架构。在我们的代码库中，我们可以改变底层日志记录器的行为，而无需任何代码更改。我们甚至不需要重新编译现有的或主程序。为什么？因为主程序的源代码不依赖于logger实现的源代码。</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">通用日志数据结构，包含对不同记录器的引用</figcaption></figure><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">文件记录器实现</figcaption></figure><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">控制台记录器实现</figcaption></figure><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">主程序</figcaption></figure><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mj"><img src="../Images/2b31be454e944ba29e5ecf48304f0908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3xsaFMzmIkQWMKts1LthFQ.png"/></div></div></figure><p id="592d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的<strong class="ih hj">文件记录器</strong>和<strong class="ih hj">控制台记录器</strong>可以互换使用，作为我们主程序的插件。</p><h1 id="5b5c" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">依赖性倒置:</h1><p id="5c3b" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">如果没有多态性，在典型的调用树中，主函数调用高级函数，高级函数调用中级函数，以此类推。为了调用我们的依赖项，现在每个调用者都必须提到包含被调用者的模块的名称。</p><p id="95dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，系统的行为决定了控制流，而控制流决定了源代码的依赖性。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es mk"><img src="../Images/43a0a590c6c3a4a5ee122644c0ccc107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hn7_dvm2NVowp3-8dg9Og.png"/></div></div></figure><p id="bc4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们使用多态性时，会发生一些不同的事情。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es ml"><img src="../Images/eb9599dbf879d8edca7ea15ab483a935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*69D8E3c38P0OZNbDxoe30g.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">依赖性颠倒了</figcaption></figure><p id="84fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，模块HL1调用模块ML1中的F()函数。使用多态性，我们可以在运行时注入不同的F()实现。源代码依赖ML1和函数声明指向与控制流相反的<strong class="ih hj">方向。这就叫<strong class="ih hj"> <em class="ly">依存倒置</em> </strong>。</strong></p><p id="b155" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过使用这种方法，程序员可以完全控制所有的源代码依赖关系。依赖性不再受控制流的限制。无论哪个模块进行调用，哪个模块被调用，程序员都可以将源代码依赖指向任一方向。<strong class="ih hj">这就是OO提供的力量。</strong></p><h1 id="0d36" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">依赖性反转的用例:</h1><p id="e8d2" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">例如，在典型的web服务中，我们可以重新安排系统的源代码依赖关系，以便数据库和UI层依赖于业务规则，而不是相反。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es mm"><img src="../Images/b878263366164e97e477b3a39b6e2516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*JauiUe8zA6Fp5NAoE_y3Kg.png"/></div></figure><p id="e68d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，UI和数据库可以是业务规则的插件。对用户界面或数据库的更改不需要影响业务规则。</p><h1 id="2fc6" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="dda0" class="pw-post-body-paragraph if ig hi ih b ii lb ik il im lc io ip iq ld is it iu le iw ix iy lf ja jb jc hb bi translated">OO是通过使用多态来获得对系统中每个源代码依赖的完全控制的能力。这样，可以设计一个基于插件的系统。</p><p id="4585" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我很想收到你的来信。如有任何疑问、反馈或只是想进行讨论，您可以通过以下渠道联系我:<em class="ly">在</em><a class="ae mn" href="https://www.linkedin.com/in/akash6019/" rel="noopener ugc nofollow" target="_blank"><em class="ly">Linkedin</em></a><em class="ly">上给我留言，或在akash.codingforliving@gmail.com给我发邮件</em></p></div></div>    
</body>
</html>