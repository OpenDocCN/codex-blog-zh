# Android 视图幕后绑定

> 原文：<https://medium.com/codex/android-view-binding-behind-the-scenes-d2cfa3fe5914?source=collection_archive---------3----------------------->

“我喜欢在空闲时间写东西”，从来没有一个开发者这样说过。事实上，视图绑定极大地改善了布局文件和*活动/片段*之间的桥梁。但是我发现开发人员经常使用视图绑定，但是不知道幕后到底发生了什么。本文帮助您理解视图绑定是如何实现的，以便您可以充分利用它的特性。我们开始吧！

![](img/21d396bcb078847262fb4e96a54cd0f6.png)

照片由 [pixabay](https://www.pexels.com/photo/binding-books-color-colorful-273034/) 拍摄

# 基本用法

为了让我们熟悉一下，让我们看看一个示例布局，比较一下通过使用视图绑定和不使用视图绑定，我们将如何从一个*活动*中与它进行交互。

我们的示例 xml 布局有一个`TextView`和一个`Button`组件。有一个小问题，`Button`只存在于大屏幕中，所以我们将定义如下两种布局:

![](img/b8c39724a37ddc434dff08e050c56f71.png)

小型(简化)布局如下:

而大的(简化的)布局将是:

如果不使用视图绑定，在`TextView`中设置一条消息，在`MainActivity`中设置一个`Button`的监听器，如下所示:

在使用视图绑定时，我们可以这样做:

# 绑定类

启用了[视图绑定的模块中的任何布局](https://developer.android.com/topic/libraries/view-binding)都有自己的绑定类，这是一个针对与 Kotlin 的互操作性而优化的 Java 类。简而言之，

> binding 类用于扩展布局，绑定其子视图，并以安全的方式将它们作为属性公开。

我们将剥离上例中为`activity_main`生成的`ActivityMainBinding`类，看看它是如何工作的。

# 公开视图

不管运行设备`activity_main.xml`的屏幕宽度如何，我们都保证有一个`ConstrainLayout`的`TextView`子元素，所以我们的绑定类将这些视图公开为不可空的属性。然而，`Button`组件只在设备有足够大的屏幕时才存在，所以在我们的 Kotlin 代码中，为了安全访问，它被公开为一个可空属性。

实际上，请注意，我们使用安全调用操作符仅在`sampleButton`不为空的情况下设置点击监听器(即设备的屏幕足够大)。然而，通过直接使用`findViewById`，我们将总是试图设置监听器，因此当在较小的屏幕设备上运行应用程序时会出现运行时错误，因为这些应用程序的`activity_main`布局不包括`Button`。

简而言之，

> 视图绑定为给定布局中存在的每个视图公开了一个正确类型的属性，这有助于我们避免在构建应用程序之前访问视图时出现错误。

除了有助于避免可空性问题，这种方法还有助于避免其他常见的错误，这些错误可能会因为将不正确的参数传递给`findViewById`而发生。例如，构建过程会成功，但在以下情况下应用程序会在运行时崩溃:

*   我们将一个不存在的 id 传递给`findViewById`；
*   我们将存在于另一个布局中但不在当前展开的布局中的 id 传递给`findViewById`；
*   我们传递了一个有效的 id，但是错误的数据类型给了`findViewById`。

# 扩大布局

现在我们各退一步。我们知道如何使用`binding`对象访问视图，但是我们首先是如何获得这个对象的呢？我们通过调用来自`ActivityMainBinding`的`inflate`静态方法并传递我们活动的`layoutInflater`来创建它。

`inflate`方法膨胀相应的布局并绑定视图。这是该类的一个关键部分，因为它检查每个子视图是否为空，并保证不应该为空的视图不会为空。

太好了，我们已经膨胀了布局，但是我们还没有将膨胀的布局链接到我们的活动。注意，在上面的`ActivityMainBinding`构造函数中，我们传递了一个展开的根视图的引用，可以通过公共的根属性访问它。

这意味着我们现在可以使用 Kotlin 的属性访问语法从活动中调用`setContentView(binding.root)`。

*现在快速声明:为了简单起见，上面的代码是对实际生成代码的简化。实际代码针对字节码性能进行了优化，但是逻辑保持不变。*

# 布局内部的布局

到目前为止，我们知道视图绑定有助于减少任何 xml 布局中容易出错的代码和样板代码。最棒的是，它还灵活地支持布局内的布局，等等…

例如，假设我们在`inner.xml`中有任何 xml 布局。然后我们可以有另一个名为`outer.xml`的 xml 布局，它包含了`inner`:

然后`OuterBinding`类会将一个`InnerBinding`对象作为属性公开，你可以在两个布局中使用所有的视图绑定特性，以及任何其他递归包含的布局，以同样的方式。

但是，请注意，这只是因为我们在包含的布局中添加了一个 id。就像视图绑定需要一个 id 来为绑定类中的常规视图(`TextView`、`Button` …)生成属性一样，它也需要 id 来将任何包含的布局作为属性公开。

感谢阅读！我希望这篇文章揭示了视图绑定是如何在幕后发挥其魔力的，以及它是如何在布局和视图组件之间提供一个更干净、更少出错的桥梁的。

如果你喜欢的内容，不要忘记鼓掌，并关注更多！