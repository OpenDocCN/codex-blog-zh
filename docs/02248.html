<html>
<head>
<title>Using Hilt in the network module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在网络模块中使用Hilt</h1>
<blockquote>原文：<a href="https://medium.com/codex/using-hilt-in-the-network-module-6ff8c50027d6?source=collection_archive---------13-----------------------#2021-07-09">https://medium.com/codex/using-hilt-in-the-network-module-6ff8c50027d6?source=collection_archive---------13-----------------------#2021-07-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e1f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Google发布了Dagger，与其他依赖注入框架不同，它提供了严格生成的实现(无反射),这意味着它可以很容易地在Android应用程序中使用。</p><p id="d70e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用像Dagger这样的框架进行依赖注入有助于在很大程度上减少样板代码，并帮助开发人员加快开发过程。依赖注入(DI)允许你使代码非常模块化，从而使单元测试更加有效。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/7a6c39884e52f59651349a85b520f895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FctpjpYOL_sKHIDJ"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">伊戈尔·菲格雷多在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="ju jv jw"><p id="1164" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">Hilt提供了一种将Dagger依赖注入整合到Android应用程序中的标准方法。Hilt试图为Android应用程序简化Dagger相关的基础设施，并提供一种简单的方法来为各种构建类型(例如测试、调试或发布)提供不同的绑定。</p></blockquote></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="8030" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个博客系列中，我们将了解如何使用Hilt来创建网络模块，以避免在Android中为联网编写重复的代码。</p><p id="b28b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意，本系列包含用Kotlin编写的代码。</strong></p></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="95a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以从这里跳到这个系列的任何部分</p><div class="ki kj ez fb kk kl"><a rel="noopener follow" target="_blank" href="/@priyansh-kedia/creating-the-network-module-with-hilt-3eefc54b72"><div class="km ab dw"><div class="kn ab ko cl cj kp"><h2 class="bd hj fi z dy kq ea eb kr ed ef hh bi translated">中等</h2><div class="ks l"><h3 class="bd b fi z dy kq ea eb kr ed ef dx translated">创建网络模块</h3></div></div></div></a></div><div class="ki kj ez fb kk kl"><a rel="noopener follow" target="_blank" href="/@priyansh-kedia/creating-viewmodel-dependencies-using-hilt-ff8005488910"><div class="km ab dw"><div class="kn ab ko cl cj kp"><h2 class="bd hj fi z dy kq ea eb kr ed ef hh bi translated">中等</h2><div class="ks l"><h3 class="bd b fi z dy kq ea eb kr ed ef dx translated">创建视图模型依赖项</h3></div></div></div></a></div></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><h2 id="507c" class="kt ku hi bd kv kw kx ky kz la lb lc ld iq le lf lg iu lh li lj iy lk ll lm ln bi translated">了解我们的网络模块的结构</h2><p id="2d14" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">我们从在android中添加对Hilt的依赖开始。所有这些依赖都可以在<a class="ae jt" href="https://developer.android.com/training/dependency-injection/hilt-android#setup" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="7678" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们创建应用程序类。Android的应用程序类是包含所有其他组件的应用程序中的基类。在android生命周期中，<strong class="ih hj">应用程序类</strong>在任何其他<strong class="ih hj">类</strong>之前被实例化。</p><pre class="je jf jg jh fd lt lu lv lw aw lx bi"><span id="c6fd" class="kt ku hi lu b fi ly lz l ma mb">@HiltAndroidApp<br/>class MyApp: Application() {</span><span id="1387" class="kt ku hi lu b fi mc lz l ma mb">    override fun onCreate() {<br/>        super.onCreate()<br/>        instance = this<br/>    }<br/><br/>    companion object {<br/>        lateinit var instance: MyApp<br/>            private set<br/>    }<br/>}</span></pre><p id="eded" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们创建了一个类，并将其扩展到Application类。然后在<strong class="ih hj"> onCreate </strong>中创建并实例化我们类的私有实例。</p><p id="df67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后创建一个公共静态(Kotlin中的伴生对象)来访问应用程序的实例。</p></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="f764" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们模块的目录结构</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es md"><img src="../Images/0a3ac6b617f1cd6d395412d805ac3b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*yi0rAj_8EDHYTVSSpufjIA.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">我们的网络模块的目录结构</figcaption></figure><p id="aa95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将彻底理解每个文件的内容。</p></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><h2 id="62fc" class="kt ku hi bd kv kw kx ky kz la lb lc ld iq le lf lg iu lh li lj iy lk ll lm ln bi translated">应用模块</h2><pre class="je jf jg jh fd lt lu lv lw aw lx bi"><span id="360e" class="kt ku hi lu b fi ly lz l ma mb">@Module<br/>@InstallIn(ApplicationComponent::class)<br/>class ApplicationModule {<br/><br/>    @Provides<br/>    @Singleton<br/>    fun provideApp(): Application {<br/>        return MyApp.instance<br/>    }<br/>}</span></pre><p id="8178" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> @Module </strong>用于在DI中注释贡献对象图的类。</p><p id="3f81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> @InstallIn </strong>指定模块将安装在哪个类中。我们使用<strong class="ih hj"> ApplicationComponent </strong>在应用程序的整个生命周期中安装模块。</p><p id="079b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> @Provides </strong>标注方法创建提供者方法绑定。</p><p id="391d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> @Singleton </strong>用于指定始终只创建该类的一个实例。</p><p id="23f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，这个方法将用于提供我们在应用程序类中实例化的应用程序类的实例。该方法不会直接用于网络模块。</p><p id="e3e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将了解网络模块。在这里阅读<a class="ae jt" rel="noopener" href="/@priyansh-kedia/creating-the-network-module-with-hilt-3eefc54b72">。</a></p></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="da41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献</strong></p><div class="ki kj ez fb kk kl"><a href="https://dagger.dev/hilt/" rel="noopener  ugc nofollow" target="_blank"><div class="km ab dw"><div class="kn ab ko cl cj kp"><h2 class="bd hj fi z dy kq ea eb kr ed ef hh bi translated">柄</h2><div class="ks l"><h3 class="bd b fi z dy kq ea eb kr ed ef dx translated">Hilt提供了一种将Dagger依赖注入整合到Android应用程序中的标准方法。剑柄的目标…</h3></div><div class="me l"><p class="bd b fp z dy kq ea eb kr ed ef dx translated">匕首.开发</p></div></div></div></a></div></div></div>    
</body>
</html>