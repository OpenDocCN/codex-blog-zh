<html>
<head>
<title>Coordinators, the back button problem and a simple way to fix it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协调员，返回按钮问题和一个简单的方法来解决它</h1>
<blockquote>原文：<a href="https://medium.com/codex/coordinators-the-back-button-and-how-to-solve-it-d336877a6d29?source=collection_archive---------0-----------------------#2021-02-17">https://medium.com/codex/coordinators-the-back-button-and-how-to-solve-it-d336877a6d29?source=collection_archive---------0-----------------------#2021-02-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="2b0a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">背景</h1><p id="0765" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最近，协调器模式在处理iOS应用程序导航时变得越来越流行，而不需要紧密耦合不同的视图控制器。</p><p id="c48f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">有很多很棒的文章解释了这种模式的各种风格，所以我不会再重复同样的细节。</p><p id="4e79" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">然而，有一个地方会给这些实现带来问题，这个问题就是<code class="du kg kh ki kj b">UINavigationController</code>的后退按钮。</p><p id="809b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">理想情况下，我们应该让协调器直接处理所有的导航交互，但是后退按钮不允许修改它的动作，因为它直接绑定到导航控制器。</p><p id="27a1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">当在由协调器管理的第一个视图控制器上按下back按钮时，这会导致一个问题。如果没有按钮按下的处理程序，就没有机会将协调器从其父对象中移除，因此会泄漏内存。</p><p id="6fa8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">Soroush Khanlou的一篇关于这个主题的博客文章解释了这个问题的两个可能的解决方案:</p><ul class=""><li id="cd94" class="kl km hi jf b jg kb jk kc jo kn js ko jw kp ka kq kr ks kt bi translated">第一个是布莱恩·伊拉斯的方法。这包括实现<code class="du kg kh ki kj b">UINavigationControllerDelegate</code>方法来检测视图控制器的弹出，找到其对应的协调器，并在必要时移除它。</li><li id="0d9c" class="kl km hi jf b jg ku jk kv jo kw js kx jw ky ka kq kr ks kt bi translated">提到的第二个解决方案是伊恩·麦卡勒姆的方法。这也利用了<code class="du kg kh ki kj b">UINavigationControllerDelegate</code>，但是将它包装在一个<code class="du kg kh ki kj b">Router</code>对象中，以解耦导航控制器和<code class="du kg kh ki kj b">Coordinator</code>。</li></ul><p id="8b2c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">不幸的是，这两种解决方案都引入了大量的boiler plate代码来对按下back按钮做出反应。</p><p id="bcab" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">理想情况下，当一个视图控制器不再需要它的协调器时，这个协调器就会被释放。</p></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="39d2" class="if ig hi bd ih ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc bi translated">一种新的解决方案…</h1><p id="5ffa" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我发现解决这个问题的一个办法是颠倒协调者的所有权。通过允许视图控制器保持它们的协调器活动，当最后一个视图控制器被移除时，协调器也被移除。</p><p id="ec3e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们从一个简单的协调协议开始:</p><figure class="ll lm ln lo fd lp"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="eb1a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">从这里我们可以添加一个具体的实现:</p><figure class="ll lm ln lo fd lp"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="89fb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这里需要注意的是，第一个视图控制器有意强引用了<code class="du kg kh ki kj b">InitialCoordinator</code>。这意味着<code class="du kg kh ki kj b">SceneDelegate</code>不需要引用<code class="du kg kh ki kj b">InitialCoordinator</code>，所以当视图控制器被释放时，协调器也将被释放。</p><p id="ee98" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为了呈现<code class="du kg kh ki kj b">ChildCoordinator</code>,我们简单地实例化它并调用它的<code class="du kg kh ki kj b">start</code>方法。这和在<code class="du kg kh ki kj b">SceneDelegate</code>中启动<code class="du kg kh ki kj b">InitialCoordinator</code>是一样的:</p><figure class="ll lm ln lo fd lp"><div class="bz dy l di"><div class="lq lr l"/></div></figure></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="f2ef" class="if ig hi bd ih ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc bi translated">结论</h1><p id="c374" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个问题的解决方案引入了很少甚至没有锅炉板代码，并利用Swift的自动引用计数来处理不再需要的协调器的处置。</p><p id="1597" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在下面的github repo中可以找到一个更加完整的项目，包括如何处理模态表示:</p><div class="ls lt ez fb lu lv"><a href="https://github.com/oconnelltoby/Coordinator" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hj fi z dy ma ea eb mb ed ef hh bi translated">奥康纳·托比/协调员</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">一个没有众所周知的后退按钮问题的协调模式的简单例子</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">github.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj mk lv"/></div></div></a></div></div></div>    
</body>
</html>