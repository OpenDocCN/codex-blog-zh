# 代码可读性>效率:原因如下

> 原文：<https://medium.com/codex/code-readability-efficiency-heres-why-725f017cfee9?source=collection_archive---------12----------------------->

【2023 年 2 月 2 日更新

![](img/65992a025a8d35a00095bf9c6edfe1a6.png)

这到底是干什么的？(作者[андрейсизов](https://unsplash.com/@alpridephoto?utm_source=medium&utm_medium=referral)

开发人员培训教会我们如何编写高效的代码。我们学习如何最小化 UI 重绘，如何避免内存中的重复结构，以及为什么使用快速排序比冒泡排序更好。

因此，一个好的开发人员会写出高效的代码。但是如果你想要代码经得起时间的考验，那么它也必须是*可读的*。根据我的经验，为了可读性，牺牲一些效率更好。

# 像书一样可读

这里有一个例子。代码是打字稿，但我要说的话当然对任何语言都成立。假设我们有一个人员列表，我们希望找到:

*   谁未成年
*   谁的名字以 T 开头

这是我们的起点。一些数据:

```
interface Person {
  name: string;
  age: number;
}

const people: Person[] = [
  { name: "Tom", age: 22 },
  { name: "Dick", age: 33 },
  { name: "Harry", age: 44 },
  ...
];
```

这里有一个可读的方法来找到未成年人，以及名字以 T 开头的人:

```
const underage = people.filter(
    (person) => person.age < 18
);

const namesBeginningWithT = people.filter(
    (person) => person.name.startsWith("T")
);
```

为什么这个*是可读的*？因为它与我们的自然语言不谋而合。从左到右阅读，你会明白未成年人变量设置为“筛选出的查找年龄小于 18 岁的人的列表”。它读起来几乎和评论一样清晰。

没有必要遵循任何代码循环。不需要向后或向前跳。甚至不需要完全熟悉“过滤器”功能——如果你只是略读代码，你已经有足够的知识来理解它的功能。

但是，效率不高。为什么？因为它在人员列表中循环两次——一次是查找未成年用户，另一次是查找“T”名。

以下是相同代码的更高效版本:

```
const underAge = new Array<Person>();
const namesBeginningWithT = new Array<Person>();

for (const person of people) {
    if (person.age < 18) {
        underAge.push(person);
    }
    else if (person.name.startsWith("T")) {
        namesBeginningWithT.push(person);
    }
}
```

请注意，我们现在只遍历列表一次。

但是，可读性如何呢？不是很大，肯定没有上面那么大。你必须阅读并理解“for”条件，并弄清楚循环中的代码是做什么的。只有这样，您才能跳回到变量定义，并弄清楚它们将包含什么数据。

它不能像书一样从左到右，从上到下阅读。也许你将不得不多次阅读一些位，以了解它们是如何全部到位的。

# 可读性=样板文件更少=错误更少

上面可读的代码实际上只有 2 行。没有样板文件——样板文件越少，出错的可能性就越小。

比如**注意到上面**高效代码的 bug 了吗？也许你这样做了——但是如果这段代码隐藏在你正在阅读的 10，000 行代码中，我就不会指望你这样做了。

错误在样板文件中。这一行:

```
else if (person.name.startsWith("T")) {
```

…应该是:

```
if (person.name.startsWith("T")) {
```

有了这个小错误(错误的 **else** ),如果‘T’人也是未成年人，代码就不会正确识别他们。

这里可读的代码更紧凑，所以它有更少的活动部分。bug 会更明显。

可读代码更紧凑并不总是正确的。有时候，一个可读性最好的代码实际上有更多的行。但是，如果把它写在更多的行上是为了使它更易读，那么它包含的任何错误仍然会更明显。

# 可读=更安全

类似上述的细微错误导致了许多安全问题。

开发安全性代码的一个重要部分是审计过程，在这个过程中，审计员/评审员会检查您的代码。你的代码能更好地传达它所做的事情，审计员就会更有效率。他们将能够更好地挑出错误，因为它们会从对代码的自然语言阅读中弹出。

当然，对于您自己的代码审计来说也是如此。写得越直截了当，你就越有机会发现自己的安全缺陷——或者最好不要把它们放在第一位。

# 可读性=维护成本更低

回到我们上面的代码示例。假设一个新开发人员的任务是改变“未成年”的定义:我们现在需要挑选 21 岁以下的人，而不是 18 岁。

对于我们代码的可读版本来说，这是一件极其简单的事情。任何初级开发人员都能够看到“(person) => person.age < 18”这一条件，并理解需要如何对其进行更改。这个条件是完全独立的——它周围没有代码，只有最少的样板文件——所以不用担心这样的改变会扰乱其他代码。并且只需要很少的测试或审核就可以确认变更是否成功。

我们代码的有效版本也有同样的情况，但是它也出现在处理其他事情的代码中。具体来说，这是一个处理未成年人和“T”人的循环——但在现实世界中可能会有更多。一个好的开发人员会想回顾循环的其余部分，以真正理解发生了什么，然后才能自信地做出改变。

显然，在这里，具体的差异是最小的，但是随着项目的扩展，这些分钟变成了数周、数月甚至数年的额外工作，伴随着巨大的相关成本。

因此，可读代码在现在和将来都可以节省时间和金钱。

# 当效率高于可读性时

可读性并不是在任何情况下都胜过效率。如果你正在为一个游戏编写一个物理引擎，那么你需要从你的代码中挤出每一个可能的效率下降，否则要维持一个高的 FPS。如果你是一个处理千兆字节数据的后端开发人员，那么你如何对它进行排序就真的很重要。

我们在上面已经假设‘people’数组的长度是合理的。如果它真的有可能包含 1000 万个项目，那么一切都会改变。每项操作都很重要，效率至关重要。为了可读性，在 100 个项目中循环两次是可以的，但不是 1000 万个。

那么，如果效率是关键，你能做些什么来保持可读性呢？

写评论！注释正是为此目的而存在的。不要听信那些说自己从来不用的人:评论非常非常重要。如果你的代码不能像书一样被阅读，那么添加(并维护)一两个注释来帮助你。

这是我们的高效循环(这次修复了错误)，并附有注释:

```
const underAge = new Array<Person>();
const namesBeginningWithT = new Array<Person>();

//Loop through people to extract underage and those whose name begin with T

for (const person of people) {
    if (person.age < 18) {
        underAge.push(person);
    }
    if (person.name.startsWith("T")) {
        namesBeginningWithT.push(person);
    }
}
```

那一条评论是神奇的。我们(稍微)不可读的代码现在又可以像书一样被阅读了。对于略读的读者来说，不用遵循循环就能清楚地知道它在做什么。对于代码审核员来说，很清楚你的*意味着*让循环去做什么——这样他们就可以检查它，看看它是否真的是这样。

如果一个评论者在没有评论的情况下发现了上面的“else”错误，那么它是否真的是一个错误或者代码是否应该对未成年的“T”人产生影响就不会立即清楚了。一个评论完全澄清了这一点。

注释的唯一问题是它们必须像代码一样被维护。如果有一天你想改变未成年人的行为，那么评论也需要相应改变。这不应该太麻烦——开发人员应该养成对他们维护的代码进行评论的习惯，并在必要时进行更新。

所以，总而言之:好的开发人员写出高效的代码，但是**伟大的**开发人员知道什么时候为了可读性而牺牲效率。

可读代码不容易出现错误和安全缺陷，审计和维护成本更低。

*Tom Colvin 是*[*Conseal Security*](http://www.consealsecurity.com/)*的 CTO，手机 app 安全测试专家；以及*[*app taura*](http://www.apptaura.com/)*，app 开发专员。* [*联系*](http://www.linkedin.com/in/tdcolvin) *如果我能为任何移动安全或开发项目提供帮助！*