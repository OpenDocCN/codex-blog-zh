# 案例研究:当并行调用多个实例时，Web 服务调用超时

> 原文：<https://medium.com/codex/web-service-is-timing-out-when-multiple-instances-is-called-in-parallel-361454ad4d6d?source=collection_archive---------15----------------------->

最近，我遇到了一种情况，当并行调用多个实例时，ASP.NET Web 服务(ASMX)超时。我想分享我的旅行经验来解决这个问题。

让我们从问题陈述“ASP。并行调用多个实例时，NET Web 服务(ASMX)超时”。控制台应用程序，开发于。运行在服务器 A 上的. NET Core 2.1 向服务器 b 上的 ASP.NET Web 服务发出 200–300 个请求。同时，20 个线程使用 IHttpClientFactory 和 System.Threading.Tasks 并行向 Web 服务发出请求。对于 20–30 个请求，向服务发出请求与控制台应用程序收到响应之间的时间间隔超过 100 秒。当向服务连续发出请求时，它会在不到一秒的时间内返回响应。另外一条信息是，Web 服务调用第三方服务作为其流程的一部分。

最初，我们认为以下任何一个都可能是这个问题的原因。

1.  服务器 A 中的系统资源争用导致了启动请求的延迟。
2.  网络延迟了到达服务器 B 的请求
3.  服务器 B 中的系统资源争用导致 IIS 中的性能问题
4.  应用程序中的内存泄漏导致 IIS 工作进程挂起
5.  第三方服务需要时间来响应
6.  Web 服务无法处理多个实例

根据以下足迹，在此分析的早期阶段，上述原因中的一些已从列表中删除。

控制台应用程序日志中记录的请求时间与服务器 b 的 IIS 日志中记录的请求时间之间没有差距。这表明服务器 A 中不存在系统资源问题，并且服务器 A 和服务器 b 之间没有网络延迟

我们查看了服务器 B 中的 IIS 日志和 Web 服务应用程序跟踪，IIS 中的请求时间和服务跟踪中的服务方法启动时间之间存在巨大差距。(注意:方法开始时间记录在 Web 服务方法的第一行中)。这种延迟大约占请求和响应之间总时间的 95%到 98%。

当 IIS 接收到请求的第一个字节时，它会记录请求的开始时间，并且在 IIS 完全接收到请求之前不会花费太多时间。当请求很大时，它将被分割成多个块。由于网络中的延迟，接收几个请求块时可能会有延迟，但第一个请求块可能会按时收到。我们检查了请求和响应的大小，它们并不大(< 1000 bytes).

What so worth we checked the time between request and response of third-party service, it is always in sub-seconds.

Next, We thought about the resource contention in Server B. We collected few performance counters from Server B.

*   **处理器**(所有实例— %处理器时间):进程的 CPU 消耗
*   **内存**(可用兆字节):Windows Server 中的可用内存
*   **HTTP 服务请求队列**(CurrentQueueSize):IIS 队列中的请求数

我们在收集的性能计数器中没有发现任何问题。在这个阶段，很明显，服务器 B 系统资源中不存在争用，应用程序中存在内存泄漏。六个原因中有五个已经从列表中删除了。在确认系统资源没有问题之后，IIS 和服务执行之间的延迟是如此奇怪。我们也没有从互联网上获得足够的信息。

我们从网上得到一个建议，增加工作进程可以解决这个问题。性能计数器没有显示任何问题，IIS 也没有显示工作进程中的高 CPU 或内存问题。因此，我们认为增加工作进程数没有帮助。

我们得到了一个额外的信息，ASMX 不能处理多线程(多个实例),最好将服务改为 REST API。由于这将导致大量的开发工作，并需要时间来完成，我们暂时搁置这一选择，并继续寻找其他解决方案。

在这个阶段，唯一悬而未决的问题是 ASMX Web 服务不能处理多个实例，我们必须解决这个问题，而不是将其重新开发为 REST API。

我们最后一次检查了代码，有一件事让我们印象深刻( **enableSessionState = true** )。为 Web 服务方法启用了会话状态，20 个并行请求来自同一个应用程序。因为所有的请求都来自同一个客户端，所以有可能第一个请求持有会话锁，而其余的请求等待会话。这使得多线程进程以单线程方式运行。同样，我们知道会话状态在 ASP.NET 是默认启用的，我们的应用程序出于任何原因都不需要它。我们尝试禁用 Web 服务方法的会话状态，它真的很神奇！！！。

结论是，即使一个未被注意到的默认设置也会对应用程序的行为产生巨大的影响。检查默认设置并根据我们的应用程序需要更改它们总是更好。我非常享受解决这个特殊案件的过程。我希望你也喜欢阅读这篇文章。如果您认为应该以不同的方式分析这个问题，或者我们遗漏了任何其他可能的原因，请随时分享您的想法。感谢你阅读这篇文章。喜欢请分享。