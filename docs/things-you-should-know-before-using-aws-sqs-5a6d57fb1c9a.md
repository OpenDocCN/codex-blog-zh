# 使用自动气象站 SQS 之前您应该知道的事情

> 原文：<https://medium.com/codex/things-you-should-know-before-using-aws-sqs-5a6d57fb1c9a?source=collection_archive---------1----------------------->

## 需要注意几个问题，这样您就可以毫无意外地享受 SQS 的可扩展性

![](img/25e49540840837acd377367b46a49e7d.png)

沃洛季米尔·赫里先科在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

# SQS

由于 SQS 是无服务器架构的一部分——AWS 使您可以轻松地扩展发送数百或数千或更多的消息，忘记为 message broker 选择实例大小。但这是有代价的，你应该在孤注一掷之前知道这些棘手的事情。

## 棘手的#1: sendMessage()不是“同步的”

即使函数调用完成，也不能保证下面的 receiveMessage()会收到您刚刚发送的消息。整个 SQS 系统是一个分布式系统，所以在时间上没有任何保证。然而，长时间的等待可能很少，大多数时候你会很快得到消息。尽管如此，即使您设置了很长的接收消息等待时间，这种延迟仍然可能发生。将等待时间设置为最长 20 秒也不能完全避免这种情况——你会惊讶地发现，长时间的 20 秒仍然不足以让 SQS 在队列中准备好你的消息。

建议:使用轮询来确保消息最终得到处理

## 棘手的#2:队列中的消息是不确定的

很难确定一个队列在给定的时间点是否真的是“空”的。即使停止发送消息，也不容易确定队列是否被完全清空。AWS 文档建议您持续轮询队列 10 分钟，如果有几个统计数据始终为零，那么您就可以确保队列被完全清空。

建议:如果您真的需要知道队列是否被清空，那么使用数据库来跟踪记录。

## 棘手的# 3:FIFO 队列中的阻塞问题

使用 SQS 时，首先要决定的几件事之一是选择标准或 FIFO 队列类型。虽然 FIFO 队列为您提供了排序保证，但它也有一定的成本和一些关键的限制。

当您调用 receiveMessage()并决定“将消息放回队列”时，问题就出现了——唯一的方法是不删除它并忽略该消息。该消息将等待`visibilityTimeout`秒，然后它将再次出现在队列中。在等待过程中，当新的消息进来时会发生什么？当然——为了保持 FIFO 的顺序，SQS 有效地阻塞了整个队列，不让 receiveMessage()调用访问任何消息。

推荐:根据需要选择 MessageGroupId，这样当某个 Id 的消息被阻止时，队列仍然可以传递其他 id 的消息。或者，如果您的消息不依赖于先前的消息，您可以只使用标准类型队列。

这就是所有棘手的部分。一旦您找到了解决它们的方法，就可以轻而易举地享受 SQS 提供的高吞吐量和简单性，相比之下，RabbitMQ 等其他选项需要您运行 24/7 服务器实例。