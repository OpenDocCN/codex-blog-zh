<html>
<head>
<title>C++ Multithreading, the simple way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++多线程，简单的方法</h1>
<blockquote>原文：<a href="https://medium.com/codex/c-multithreading-the-simple-way-95aa1f7304a2?source=collection_archive---------1-----------------------#2021-01-25">https://medium.com/codex/c-multithreading-the-simple-way-95aa1f7304a2?source=collection_archive---------1-----------------------#2021-01-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="b7c9" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">抄本</a></h2><div class=""/><figure class="ev ex ip iq ir is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es io"><img src="../Images/51c2aa4e0c92a56b0f2da2d364f7e22c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bZP8rmpKETV4xM0U"/></div></div><figcaption class="iz ja et er es jb jc bd b be z dx translated">由<a class="ae jd" href="https://unsplash.com/@borisdunand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Boris Dunand </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4971" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">多线程是当今几乎所有计算机处理器最强大和最重要的功能之一。多线程允许软件在同一个程序中同时执行不同的代码。如果没有多线程，Web服务器、web浏览器、数据库、移动应用程序以及几乎任何生产级软件都无法正常工作。</p><p id="6ba7" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">多线程通常以困难著称。与软件开发中的其他概念相比，人们当然可以提出这样的理由。然而，多线程与一般的编程并没有太大的不同。这只是潜在的更危险。不过，学会防范危险可以让你实现比单线程方式更强大的算法和程序。</p><p id="3d3f" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">要理解多线程，最好从最不危险的概念开始，然后向潜在最危险的概念前进。这使得人们能够适应线程化，并朝着更关键、更谨慎的代码编写前进。</p><h1 id="7f69" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">并发</h1><p id="fd73" class="pw-post-body-paragraph je jf hi jg b jh lb jj jk jl lc jn jo jp ld jr js jt le jv jw jx lf jz ka kb hb bi translated">也许威胁最小的多线程形式是并发。并发通常意味着多个线程同时运行，但不共享任何资源。这意味着线程之间不共享数据结构、内存或其他内容。并发性通常用于可以在线程之间拆分并独立处理的任务。</p><p id="c4aa" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">为了说明这一点，让我们来看一个例子，每个线程都有一个指向一个整数的指针，线程递增这个整数，然后停止。每个线程开始运行，直到它将数字增加几百次。然后，这些线程，通常称为“工作线程”，被主线程加入。所有线程同时工作。</p><figure class="lg lh li lj fd is"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="1511" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果您是多线程新手，这段代码的一些部分可能没有意义。<code class="du lm ln lo lp b">join()</code>方法大概就是其中之一。关于启动新线程需要理解的一个重要细节是，它们的工作和功能完全独立于主线程，即从<code class="du lm ln lo lp b">main()</code>开始的线程。因为他们是完全分开的，所以我们必须决定一个点，在这个点上我们希望等待他们完成分配给他们的工作。</p><p id="e5cf" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">想想类似的情况，两个人可能会分开做他们各自的任务，然后再“结合”在一起。如果你和朋友一起旅行或去某个地方，你不想放弃他们！理想情况下，你应该等待他们再次赶上。线程也是同样的逻辑。任何时候创建额外的线程，都有义务指导你希望中央主线程如何按照它们来行动。</p><h2 id="6a32" class="lq ke hi bd kf lr ls lt kj lu lv lw kn jp lx ly kr jt lz ma kv jx mb mc kz ho bi translated">派遣</h2><p id="c79d" class="pw-post-body-paragraph je jf hi jg b jh lb jj jk jl lc jn jo jp ld jr js jt le jv jw jx lf jz ka kb hb bi translated">你总是要加入线程吗？不。事实上，还有一个选择。就像朋友的例子一样，一个朋友可能想走自己的路回家，而不是和你见面。对于线程来说，这叫做分离。分离一个线程意味着允许它独立于主线程工作并完成它的工作。但是，这可能是危险的。举下面的例子，非常类似于<code class="du lm ln lo lp b">join()</code>的例子。</p><figure class="lg lh li lj fd is"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="efcb" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这里的第一个风险是在被删除后使用堆分配。与<code class="du lm ln lo lp b">join()</code>不同，<code class="du lm ln lo lp b">detach()</code>不会让调用线程停止或等待任何东西。这意味着一旦对<code class="du lm ln lo lp b">detach()</code>的第三次调用结束，调用线程将删除<code class="du lm ln lo lp b">numbers</code>数组。如果创建的线程还没有完成它们的工作，它们将写入一个被删除的数组，这会破坏内存。</p><p id="9b24" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这里的第二个风险是，如果创建的线程的工作没有完成，即使在主线程完成之后，它们也可以继续运行。或者他们可能一结束就被杀死。根据C++标准，这是未定义的行为。不管特定的编译器能保证什么，未定义的行为是应该避免的。<code class="du lm ln lo lp b">detach()</code>有一些有效的用例，但是它们都需要线程间某种其他形式的同步才是可靠的。</p><h1 id="665d" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">共享资源</h1><figure class="lg lh li lj fd is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es md"><img src="../Images/865b9431210c673364fcaa43eea0887a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kLTuy16m17Qw7hKJ"/></div></div><figcaption class="iz ja et er es jb jc bd b be z dx translated">阿瑟·埃德尔曼在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a74c" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">两个不同的线程可以访问同一个内存地址的资源称为共享资源。请务必注意对<em class="kc">地址</em>的强调。在此处所示的前一个示例中，多个线程访问同一个数组，这不是共享资源，因为没有两个线程从同一个内存地址读取或写入。数组可能只是四个独立的整数指针，数组本身没有任何东西使它成为共享资源。</p><p id="5142" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">与并发性不同，当希望线程在相同的数据或对象上执行工作时，会使用共享资源。这意味着对象没有被分配到一个线程自己的堆栈上，只有一个对象对其他线程可见。让这一点变得难以理解的是，尽管两个线程都可以访问某些资源，但它们永远看不到其他线程访问该资源。</p><p id="5351" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">现实生活中共享资源的一个很好的例子是晚上的机场跑道。跑道上有闪烁的灯光，帮助引导飞机准备着陆时对准跑道。但是由于黑暗和飞行速度，其他飞机在晚上很难甚至不可能看到对方。如果一架飞机试图与另一架飞机同时降落在跑道上，那将是灾难性的。飞机避免这种碰撞的唯一方法是通过空中交通管制进行协调。</p><p id="e7cf" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">线程的工作方式是一样的，因为它们依赖同步机制来协调对资源的访问，比如不在完全相同的时间写入资源。我们将在这里讨论的机制，可能是最常见的一个，是互斥。类型为<code class="du lm ln lo lp b">std::mutex</code>的互斥锁允许线程获取<em class="kc">锁。</em>锁是一种控制形式，一次只允许一个线程处理一段代码。让我们看看这个例子。</p><figure class="lg lh li lj fd is"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="69e0" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在上面的例子中，当调用线程在与队列相关的互斥体上构造一个锁时，类的<code class="du lm ln lo lp b">push()</code>和<code class="du lm ln lo lp b">pop()</code>方法都会发生。这个锁最好用作RAII样式的对象，它只在某些代码范围内有效。一旦程序完成了这个作用域，锁保护对象就被销毁，允许另一个线程构造并获取互斥体上的锁。这种模式继续满足一次只有一个线程可以修改队列的条件。</p><h1 id="de34" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">互斥锁仍然有潜在的危险</h1><p id="89f4" class="pw-post-body-paragraph je jf hi jg b jh lb jj jk jl lc jn jo jp ld jr js jt le jv jw jx lf jz ka kb hb bi translated">即使它们听起来非常简洁和直接，互斥锁仍然是危险的。当一个线程获得一个互斥锁时，它负责释放或销毁这个锁，这样其他线程也可以访问代码的安全范围。如果一个线程没有释放它所获得的锁，会发生什么？很糟糕的事情。</p><p id="66da" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">一个<em class="kc">泄漏锁</em>是当一个线程锁定了一个互斥锁，但是由于某种原因这个锁永远不能被解锁。如果发生这种情况，所有的线程都将阻塞并无限期地等待互斥体，没有任何进展或做任何工作。</p><p id="d377" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">互斥体的经验法则是仔细地、批判性地思考线程在给互斥体加锁时会做什么。至关重要的是，线程只有在绝对需要单线程访问时才会锁定，并且在这样做的同时，尽可能快地工作。虽然互斥锁提供了一种安全访问同一资源的方法，但它们是以性能为代价的。</p><p id="ebb6" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">有没有其他方法来防止非法的，多线程之间的双重访问资源？是的。但这是另一篇文章的主题。</p></div></div>    
</body>
</html>