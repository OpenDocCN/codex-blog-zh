<html>
<head>
<title>Scrub Up! Cleaning Your PHP Application With PHPStan</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">擦洗干净！用PHPStan清理PHP应用程序</h1>
<blockquote>原文：<a href="https://medium.com/codex/scrub-up-cleaning-your-php-application-with-phpstan-6d1c17ddd272?source=collection_archive---------1-----------------------#2022-02-16">https://medium.com/codex/scrub-up-cleaning-your-php-application-with-phpstan-6d1c17ddd272?source=collection_archive---------1-----------------------#2022-02-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7982fdbb60eeec47f1d536814d552d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNHwMRJnRIqegjlf0L_Wjw.png"/></div></div></figure><p id="1825" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我做PHP开发人员期间，我们编写和发布代码的方式发生了巨大的变化。在早期的Symfony T1和T2 Zend Framework T3应用程序中，T4 PHP-FIG T5并不存在，编码标准由编写它的人决定。这些年来，我们已经看到PSR标准被广泛采用，坚如磐石的静态分析工具已经变得有些零碎。也就是直到现在，随着PHPStan1.0版本的<a class="ae jo" href="https://phpstan.org/blog/phpstan-1-0-released" rel="noopener ugc nofollow" target="_blank">发布。让我们通过浏览它的一些特性来庆祝这一时刻吧！</a></p><h1 id="789d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">编译语言，你先发制人的bug squasher</h1><p id="c665" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">使用编译语言(比如Java或C#)的一个很大的好处是，如果你的代码不是强制标准的类型安全的，编译时将会完全失败(尽管这对我来说很容易，因为现在不是凌晨2点，我已经喝了晚上的第10杯咖啡了)。由于PHP是一种解释语言，我们没有同样的奢侈。</p><h1 id="538b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">解释为编译:CI +工具</h1><p id="d80d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">由于在现代web开发和静态分析中我们可以使用大量的DevOps工具，事情是这样的<em class="ks">我们确实有相同的工具，但是通过不同的方式</em>。既然是这样，我不能提倡<strong class="is hj">多少</strong>我建议你有一些类似的环境，我将展示出来。那么你为什么想要这个工具呢？让我们看一个例子。</p><h1 id="a882" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">场景</h1><p id="4911" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">当涉及到像这样的工具时，尝试选择一个有趣的或适用于您所写内容的主题是很常见的。但是，在这篇文章中，我将向您展示一个我个人在机构环境中多次遇到的场景:</p><p id="4ec0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">“救命啊！别人建立了我的PHP应用程序，我需要有人来拯救它并接管它的维护，因为X/Y/Z功能需要建立，但A/B/C功能甚至不能很好地工作！”</strong></p><p id="86c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接管别人的代码库/项目总是一件完全碰运气的事。如果你接管它是因为它需要新的功能，而它已经是一个科技债务缠身的烂摊子，你知道你必须在接触其他任何东西之前解决这个问题。更糟糕的是，很多这样的项目(以我的经验来看)在到达时都没有测试来自我记录代码。考虑一个经典的例子，我已经看过很多次了:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="a2ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您没有编写实体类或存储库方法。他们没有类型提示，因为这是用PHP5.3编写的，或者开发者没有使用任何类型提示。如果你的ORM返回相同实体的数组，这没什么，但是一个bug，一个null结果在<code class="du kz la lb lc b">findAllBySomething()</code>和<code class="du kz la lb lc b">doTheThing()</code>的返回值中会抛出一个致命的错误。</p><p id="258f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是时候在上面设置<a class="ae jo" href="https://github.com/phpstan/phpstan" rel="noopener ugc nofollow" target="_blank"> PHPStan </a>了。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/28f3200b85a5c3a27b633357e8c7c522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9WiKpHLQDzK2iHpH4t7LvQ.jpeg"/></div></div></figure><p id="d99f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然说“使用PHPStan”很容易，但如果您有一个遗留的或技术债务沉重的应用程序，您将需要一个策略，而不是只是把东西扔在那里看看会发生什么。首先，您需要熟悉规则级别。</p><h2 id="fb0d" class="le jq hi bd jr lf lg lh jv li lj lk jz jb ll lm kd jf ln lo kh jj lp lq kl lr bi translated">规则级别</h2><p id="3087" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">PHPStan的结构是以给定的规则级别运行，编号从0到9:</p><ol class=""><li id="bba3" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma bi translated">基本检查，未知的类，未知的函数，在<code class="du kz la lb lc b">$this</code>上调用的未知方法，传递给这些方法和函数的参数数量错误，总是未定义的变量</li><li id="e56e" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">可能是未定义的变量，未知的魔法方法，以及带有<code class="du kz la lb lc b">__call</code>和<code class="du kz la lb lc b">__get</code>的类的属性</li><li id="051c" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">对所有表达式(不仅仅是<code class="du kz la lb lc b">$this</code>)检查未知方法，验证PHPDocs</li><li id="266d" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">返回类型，分配给属性的类型</li><li id="442a" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">基本死代码检查—总是假的<code class="du kz la lb lc b">instanceof</code>和其他类型检查，死的<code class="du kz la lb lc b">else</code>分支，返回后不可达的代码；等等。</li><li id="6629" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">检查传递给方法和函数的参数类型</li><li id="1a3b" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">报告缺失的类型提示</li><li id="0b13" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">报告部分错误的联合类型——如果您调用一个只存在于联合类型中的某些类型上的方法，级别7开始报告这种情况；其他可能不正确的情况</li><li id="68ff" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">报告调用方法和访问可空类型的属性</li><li id="e0ec" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn lx ly lz ma bi translated">对<code class="du kz la lb lc b">mixed</code>类型要严格——唯一允许的操作是将它传递给另一个<code class="du kz la lb lc b">mixed</code></li></ol><p id="a3f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是为什么你的策略很重要。如果你有一个别人写的遗留项目，而你在第9级启动了PHPStan任务运行器，你可能会被它产生的结果淹没。一切都坏了！为了重构，我建议如下:</p><ul class=""><li id="2b5c" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn mg ly lz ma bi translated">为你自己设定每一级的里程碑，从小处着手。</li><li id="89fd" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn mg ly lz ma bi translated">长期投资最终会有回报(我们很快会谈到管道)，但在你自己的“完成的定义”下，设定你在归类“修复技术债务”时愿意达到的最高水平</li><li id="084c" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn mg ly lz ma bi translated">遗留项目的一个好的实际目标是通过规则级别6。正是在这一点上，您的代码库可能会从“危险”状态过渡到“正确”状态。这将使第6级规则<a class="ae jo" href="https://phpstan.org/user-guide/baseline" rel="noopener ugc nofollow" target="_blank">成为你的基线</a>。</li><li id="986c" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn mg ly lz ma bi translated"><strong class="is hj">这一点非常重要</strong>:确保分配时间(冲刺，受虐者的分解吉拉门票)来<em class="ks">修复【PHPStan在每个规则级别标记的内容。在许多情况下，解决技术债务并不容易，你也不知道在你的应用程序中会出现什么样的业务领域逻辑错误。</em></li><li id="33a1" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn mg ly lz ma bi translated">在为规则级别设置增量目标时，确保在提交更改之前设置好您的<a class="ae jo" href="https://gist.github.com/DanyF-github/aa1bf6bb04b617570d521dd883a343a7#pipeline" rel="noopener ugc nofollow" target="_blank">管道</a>，以便在重构时不会引入任何新的代码味道。建立你的管道需要你建立<a class="ae jo" href="https://phpstan.org/user-guide/baseline" rel="noopener ugc nofollow" target="_blank">你的基线</a>，我们会谈到的。</li></ul><h2 id="e4d2" class="le jq hi bd jr lf lg lh jv li lj lk jz jb ll lm kd jf ln lo kh jj lp lq kl lr bi translated">管道</h2><p id="c095" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在DevOps的世界中，有大量的工具选项可以用来解决您的问题。对于这个实例，我只提供了一种方法，但是它没有其他可用的方法复杂。一旦你建立了你的策略，是时候建立你的管道了，这样我们就不会提交任何没有先通过PHPStan的新代码。</p><h2 id="0aec" class="le jq hi bd jr lf lg lh jv li lj lk jz jb ll lm kd jf ln lo kh jj lp lq kl lr bi translated">防御壁垒:本地与服务器端</h2><p id="3059" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我喜欢引入工具来消除任何单点故障的可能性，由于这种愤世嫉俗的态度，我强烈建议您在本地开发人员的机器上运行静态分析<em class="ks">以及在您的存储库中运行</em>服务器端CI检查。</p><p id="b28e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ks">本地</em></p><ul class=""><li id="6857" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn mg ly lz ma bi translated">作曲家+ PHPStan</li></ul><p id="371e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，您需要在项目中安装PHPStan。我们将使用<a class="ae jo" href="https://getcomposer.org/" rel="noopener ugc nofollow" target="_blank"> composer </a>来完成这项工作，假设您的遗留代码确实使用了包管理。如果没有，你可以<a class="ae jo" href="https://getcomposer.org/doc/00-intro.md#installation-linux-unix-macos" rel="noopener ugc nofollow" target="_blank">安装作曲家</a>并使用<code class="du kz la lb lc b">composer init</code>创建一个新项目。</p><p id="0f08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要安装PHPStan，请运行以下命令:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="7631" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们添加<code class="du kz la lb lc b">--dev</code>是因为我们在生产中不需要它(理论上！).</p><ul class=""><li id="b399" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn mg ly lz ma bi translated">配置:建立基线</li></ul><p id="e274" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是PHPStan的一个非常好的特性。你的基线建立了你的应用程序的“地面零点”,这样在你选择的规则级别内存在的任何当前错误都会被忽略<em class="ks">,直到你决定处理它们</em>,但同时<em class="ks">可以为提交的任何新更改强制执行一个规则级别</em>。该战略中概述的一个明智的方法是在规则级别6设定一个基线:</p><ul class=""><li id="cb15" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn mg ly lz ma bi translated">提交给项目的所有新代码都需要处于规则级别6</li><li id="cbd9" class="ls lt hi is b it mb ix mc jb md jf me jj mf jn mg ly lz ma bi translated">然后，你可以根据你的战略目标，设定较低层次的科技债务目标。</li></ul><p id="4f71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要创建基线，请运行以下命令:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="0e7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您将在指定的文件(<code class="du kz la lb lc b">phpstan.neon</code>)中设置您的基线配置，这将保存每个文件的错误的详细概述。</p><p id="c721" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您会希望PHPStan在将提交推送到您的源代码之前，阻止提交到您的存储库。为此，我们使用Git钩子。</p><ul class=""><li id="133e" class="ls lt hi is b it iu ix iy jb lu jf lv jj lw jn mg ly lz ma bi translated">Git挂钩</li></ul><p id="32af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不知何故，我花了几年时间才意识到，git实际上在<code class="du kz la lb lc b">git init</code>上的一个新的git存储库中安装了钩子作为标准。你可以在这里阅读更多关于git钩子的内容。我们将要编辑<code class="du kz la lb lc b">pre-commit</code>钩子。只要您以前没有接触过项目中的任何钩子，您就可以通过重命名它来启用预提交钩子——从项目的根目录运行它:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="16d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在打开文件，删除内容并复制以下内容:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="9124" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在您已经启用了<code class="du kz la lb lc b">pre-commit</code>，PHPStan将在每次提交之前触发，并根据基线<em class="ks">分析在git提交</em>中已经更改的任何新文件。不再有难闻的提交代码！</p><p id="132d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您向上移动时，您可能想要调整命令行触发器，所以当它需要改变时(或者您想要启用其他PHPStan特性)，更改<code class="du kz la lb lc b">analysisResult=$(vendor/bin/phpstan analyse $gitDiffFiles)</code>行参数。</p><p id="bb50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ks">服务器端</em></p><p id="4374" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你能为你的代码做的辩护越多，就越好。作为持续集成的一部分，在推送代码之后运行PHPStan服务器端是<em class="ks">必须具备的</em>。对于本例，我们将使用Github动作，但请记住，您可以在<a class="ae jo" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>、<a class="ae jo" href="https://support.atlassian.com/bitbucket-cloud/docs/get-started-with-bitbucket-pipelines/" rel="noopener ugc nofollow" target="_blank"> Bitbucket Pipelines </a>、<a class="ae jo" href="https://docs.gitlab.com/ee/ci/" rel="noopener ugc nofollow" target="_blank"> Gitlab CI/CD </a>或<a class="ae jo" href="https://www.jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>中设置相同级别的功能。下面是一个在Github上设置的动作工作流示例，用一个<a class="ae jo" href="https://ubuntu.com/" rel="noopener ugc nofollow" target="_blank"> Ubuntu </a>容器构建您的代码:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="b856" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“Run PHPStan”下的命令可以根据您的需求进行配置，就像在本地运行PHPStan时配置该命令一样。我已经编写了这个工作流，在项目中的所有文件上以默认级别运行PHPStan(这个工作流还没有触发<code class="du kz la lb lc b">composer</code>，所以不会有在您的<code class="du kz la lb lc b">vendor</code>文件夹上运行它的不必要的和低效的步骤),所以在这里我建议引入一个配置来设置您整个项目的规则级别。</p><p id="01a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您的遗留项目现在有了一个清理代码的策略，以及在对所有现有代码的基线执行分析时阻止提交中出现新错误的管道。这种设置可以给你更多的信心投入到项目中，同时让你洞察到哪里可能需要重构来消除技术债务。</p><h1 id="78dc" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">最后，但同样重要的是:静态分析与测试</h1><p id="14f5" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我大声地说，尤其是对后面的人:PHPStan和任何其他静态分析工具都不能代替您的测试！我认为它的用法是测试套件和PHPStan <em class="ks">在评估你的代码质量时互相补充</em>。</p><p id="1b86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">认为您很少或者不需要测试套件是一种误解。这里最重要的是<strong class="is hj">静态分析不能测试你的领域逻辑</strong>。虽然这似乎是一个显而易见的声明，但值得注意的是，它可能会令人困惑，因为PHPStan <strong class="is hj">可以</strong>消除某些测试的需要。一个这样的例子是一个<code class="du kz la lb lc b">instanceOf</code>测试，它断言一个被创建的类是一个过程的最终结果。PHPStan可以消除这一需求，因为它提供了消除这一潜在缺陷所需的分析，但是它<em class="ks">并不</em>预先知道您所需的域逻辑——这是您<em class="ks">做</em>需要测试的。</p><h2 id="45a4" class="le jq hi bd jr lf lg lh jv li lj lk jz jb ll lm kd jf ln lo kh jj lp lq kl lr bi translated">记住，还有其他选择！</h2><p id="6a85" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">你试过了吗？不太喜欢吗？每个人都有自己的偏好，虽然我会对Ondřej在PHPStan上的工作大加赞赏，但值得注意的是，还有其他几个工具可以完成同样的工作，或者可以与PHPStan结合使用:</p><h2 id="ed0a" class="le jq hi bd jr lf lg lh jv li lj lk jz jb ll lm kd jf ln lo kh jj lp lq kl lr bi translated">谢谢</h2><p id="3332" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">特别感谢ondřej·米尔特斯的建议和他为发布这个令人敬畏的工具所做的努力。</p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><p id="bbe2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ks">最初发布于</em><a class="ae jo" href="https://learn.vonage.com/blog/2021/11/30/scrub-up-cleaning-your-php-application-with-phpstan/" rel="noopener ugc nofollow" target="_blank"><em class="ks">https://learn . vonage . com/blog/2021/11/30/scrub-up-cleaning-your-PHP-application-with-PHP stan/</em></a></p></div></div>    
</body>
</html>