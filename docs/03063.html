<html>
<head>
<title>Synchronous Vs Asynchronous Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同步与异步编程</h1>
<blockquote>原文：<a href="https://medium.com/codex/synchronous-vs-asynchronous-programming-4897070d640?source=collection_archive---------3-----------------------#2021-08-17">https://medium.com/codex/synchronous-vs-asynchronous-programming-4897070d640?source=collection_archive---------3-----------------------#2021-08-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0858" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">编程模型之间的主要区别</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/53eace10fc34e732fc88daf5378b1020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAgW5tJ0H_fWRWcKoLNYIQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jn">异步Vs同步</strong></figcaption></figure><h1 id="b021" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">介绍</h1><p id="4da4" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在计算的早期，单处理器系统占主导地位。许多早期的编程语言都采用了同步编程模型。随着硬件的进步，需要开发更好的编程模型。充分利用所有资源的稳健模型将是最合适的模型。这就催生了异步编程。</p><p id="c651" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">对于初学者来说，很难理解这两种编程模型之间的区别。在这篇文章中，我将试图用通俗的语言来简化和解释两者的区别。我们还将看看一个简单的Java插图。我们将理解Java中为异步编程提供的API。</p><h1 id="1004" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">现实世界的类比</h1><p id="eac7" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在深入研究编程模型之前，我们将首先看看同步和异步系统。</p><h1 id="a606" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">超市作为一个同步系统</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lg"><img src="../Images/2c9a3af447bd341cf1a703eca983ef51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YLfujJ2U3mdMteQG.png"/></div></div></figure><p id="4dd9" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们都去过超市购买日常用品。每个人都用手推车收集物品，然后去柜台。柜台的那个家伙会扫描所有的商品，准备账单，接受付款，最后给收据。对于每个客户来说，这都是一个耗时的过程。此外，所花费的时间与商品的数量、任何技术故障以及寻找变化的时间(现金支付)成比例。</p><p id="67c0" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">想象一下，如果这是一个假日季节，超市正在大减价，会发生什么。顾客将不得不花很多时间排队，从而加重他们的挫折感。以下是每个顾客的恰当反应:-</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lh"><img src="../Images/fb36dd8682f8976e133a5bf11d96caea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XN2cKVeKuTLodgWz.png"/></div></figure><p id="8fe1" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">在上面的例子中，你可以把收银员想象成一个CPU &amp;把顾客想象成一个编程函数。类似于编程功能，每个客户都需要不同的时间，并有不同的要求。收银员处理顾客的请求，根据顾客的购买和付款方式花费不同的时间。</p><p id="f9b9" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">每个顾客都被阻止，直到收银员释放他们的收据。他们做不了别的，只能排队等候。如果顾客可以把订单交给收银员，去别的地方看看，然后再回到超市，那就太好了。这将意味着减少客户的挫折感。</p><p id="4537" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">在同步系统中，我们等待一个任务完成&amp;然后处理下一个任务。正如我们所见，它会导致瓶颈并降低系统的吞吐量。</p><h1 id="2e22" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">麦当劳作为一个异步系统</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es li"><img src="../Images/27965590133910bbc8c0752905652ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_Fs_1ypbJ946vnmP.png"/></div></div></figure><p id="f730" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">麦当劳有自助服务亭终端。客户可以下订单并完成支付。付款完成后，收据将与订单号一起分发。订单准备就绪后，订单编号会显示在屏幕上。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/e2aad8e40e4a4d784d1f538eec83816f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rFf1IwEDXtbHfwYy.png"/></div></div></figure><p id="7e15" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">在准备食物时，顾客可以同时做多件事情。他们不会被准备订单的人挡住，因此商店可以避免拥挤。客户不会按顺序收到订单。一个人可能会在另一个人之前收到他的食物，即使他会在另一个人之后点菜。这是异步系统的一个例子。</p><p id="064b" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">异步系统不会等待任务完成。当给定的任务正在进行时，它移动到另一个任务。让我们来看一个编程例子。</p><h1 id="f100" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">同步编程</h1><p id="3b65" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在同步编程中，每行代码都是按顺序执行的。在网络或文件IO调用的情况下，执行线程会阻塞。让我们看一个同步代码执行的例子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/7e0df4b91d62ab6f610ad0cd31abda72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g6sMKtPIN-HR65R4.png"/></div></div></figure><p id="c53c" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们将举一个电子商务系统的例子。假设我们有一个函数，它获取给定订单的所有商品。然后，它为项目创建一个CSV文件并存储它。此外，它通过电子邮件向客户发送订单状态信息。在上面的例子中，我们的代码将按顺序执行，即第10、11和12行。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/c2542bf856a0eba1caa91aa6a77c5bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8fEMXBAuokBNw22X.png"/></div></div></figure><p id="abaa" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><code class="du lm ln lo lp b"><strong class="kh hj">fetchItems</strong></code>函数执行数据库调用。数据库调用很昂贵，因为它是一个IO调用。我们一调用<code class="du lm ln lo lp b"><strong class="kh hj">fetchItems</strong></code>方法，主线程就会阻塞。一旦所有项目都从数据库成功返回，它就会恢复。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lq"><img src="../Images/27a7bf05d3f95e75d64edc3ede77f776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YC8DF1hZYzzYhEJt.png"/></div></div></figure><p id="2c2b" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><code class="du lm ln lo lp b"><strong class="kh hj">createCsvFileForItems</strong></code>函数处理项目并生成一个CSV文件。这个函数再次将主线程置于等待状态。一旦文件创建成功，函数将返回。此外，它将调用<code class="du lm ln lo lp b"><strong class="kh hj">sendOrderStatus</strong></code>方法。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/b43db0fc1c5cfc153125d2c37bf69c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d6bNKO9IYL9kd9-u.png"/></div></div></figure><p id="0ebd" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">方法<code class="du lm ln lo lp b"><strong class="kh hj">sendOrderStatus</strong></code>使用电子邮件客户端。它使用电子邮件地址并将订单状态发送给客户。</p><p id="183e" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">假设每个函数花费的时间如下</p><ul class=""><li id="f387" class="ls lt hi kh b ki lb kl lc ko lu ks lv kw lw la lx ly lz ma bi translated"><code class="du lm ln lo lp b"><strong class="kh hj">fetchItems</strong></code> - 5毫秒</li><li id="b083" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><code class="du lm ln lo lp b"><strong class="kh hj">createCsvFileForItems</strong></code> - 10毫秒</li><li id="30bb" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><code class="du lm ln lo lp b"><strong class="kh hj">sendOrderStatus</strong></code> - 8毫秒</li></ul><p id="12f6" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">程序完成的总时间是23毫秒。15毫秒后会调用<code class="du lm ln lo lp b"><strong class="kh hj">sendOrderStatus</strong></code>函数。这个函数独立于获取和处理项目。不过还是要等前面两个功能完成。我们可以先给<code class="du lm ln lo lp b"><strong class="kh hj">sendOrderStatus</strong></code>打电话。但是在这种情况下，<code class="du lm ln lo lp b"><strong class="kh hj">createCsvFileForItems</strong></code>函数将不得不等待8毫秒。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/688d9bf852c4d51ee400b84f16e6944c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l8eSX763gRuDJ5EEOgyVuA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jn">每个功能花费的时间</strong></figcaption></figure><p id="ec54" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">此外，当函数被调用时，主线程会阻塞。当线程进入等待状态时，它不能做任何有用的工作。如果应用运行在多核CPU上，那么只有一个CPU得到利用。这将导致其他CPU闲置。</p><p id="8854" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">通过在不同的线程中执行独立的任务，我们可以充分利用所有的CPU内核。在上面的例子中，这可以通过并行运行<code class="du lm ln lo lp b"><strong class="kh hj">fetchItems</strong></code>和<code class="du lm ln lo lp b"><strong class="kh hj">sendOrderStatus</strong></code>来完成。完成后，我们可以使用结果&amp;然后调用<code class="du lm ln lo lp b"><strong class="kh hj">createCsvFileForItems</strong></code>。</p><h1 id="406e" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">异步编程</h1><p id="14ea" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在异步编程中，独立的任务在不同的线程上并行执行。一旦任务完成并返回一个结果，一个依赖任务就会作为回调被调用。独立任务不会阻塞主线程，我们可以利用CPU的所有内核。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/f604404a779bdb17df5640c0f358f86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XX1ftqlVCWi11cWN.png"/></div></div></figure><p id="4c6c" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">在上面的代码中，我们有每个方法的异步版本。代码没有按顺序执行第32、33和34行。它将调用<code class="du lm ln lo lp b"><strong class="kh hj">fetchItemsAsync</strong></code>方法并将其卸载到其中一个线程。随后，它将调用<code class="du lm ln lo lp b"><strong class="kh hj">sendOrderStatusAsync</strong></code>方法，而不等待第一个函数完成。该方法将在不同CPU上的单独线程上运行。在第33行，<code class="du lm ln lo lp b"><strong class="kh hj">fetchItemsAsync</strong></code>方法返回一个未来值。主线程将在第35行等待这个future并获取它的值。</p><p id="f7f6" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">该功能的执行如下图所示</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/507cf353001c7b35bf518edce30eafd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nA4HJ0RiDPXD2usQyCWEJg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jn">异步功能执行</strong></figcaption></figure><h1 id="01e7" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">Java中的异步编程</h1><p id="9996" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">Java提供了<code class="du lm ln lo lp b"><strong class="kh hj">CompletionStage</strong></code>接口和<code class="du lm ln lo lp b"><strong class="kh hj">CompletableFuture</strong></code>类来实现异步编程。一个<code class="du lm ln lo lp b"><strong class="kh hj">Future</strong></code>或一个<code class="du lm ln lo lp b"><strong class="kh hj">CompletableFuture</strong></code>代表未来计算的结果。例如:-你可以调用一个异步方法来返回一个未来值。调用此方法后，您可以继续执行代码。我们使用API来获得未来的计算结果。以下是一个简单的例子</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es li"><img src="../Images/d765af59199ec5bee5b76256516cf461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8ehFtUa-VS80CsIW.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/adbac951f76b255141051132c969e4d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BfYYj8IzVeZR7RHx.png"/></div></div></figure><p id="273c" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">在上面的例子中，方法<code class="du lm ln lo lp b"><strong class="kh hj">fetchItemsAsync</strong></code>返回一个包含项目列表的未来。此方法定义并初始化CompletableFuture。在Executor API的帮助下，它将执行任务卸载到一个新线程上。一旦计算完成，它完成未来(第48行)然后返回它。</p><p id="52e5" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">由于<code class="du lm ln lo lp b"><strong class="kh hj">fetchItemsAsync</strong></code>是异步的，主线程可以同时调用<code class="du lm ln lo lp b"><strong class="kh hj">sendOrderStatus </strong></code>方法。因此，它不需要等待前一个方法完成。然后，它将在将来使用get方法来获得最终结果。主线程将在调用get方法时阻塞，并在结果可用时恢复。</p><p id="a445" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们可以避免上面的样板代码&amp;利用CompletableFuture的API。CompletableFuture提供了方法<code class="du lm ln lo lp b"><strong class="kh hj">supplyAsync</strong></code>和<code class="du lm ln lo lp b"><strong class="kh hj">runAsync</strong></code>。前者采用供应商接口，而后者使用runnable。供应商接口是一个不带任何参数的函数接口。它返回一个参数化类型的值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mk"><img src="../Images/3716bd1865608445889b43f0f3029059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3M9TDwHNVQdb8ijjS9Xug.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jn">使用可完成期货</strong></figcaption></figure><p id="f54f" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们在上面的代码片段中使用了<code class="du lm ln lo lp b"><strong class="kh hj">supplyAsync</strong></code>函数。在内部，这个函数将在java中的ForkJoinPool的一个线程中执行代码。<code class="du lm ln lo lp b"><strong class="kh hj">thenApply</strong></code>构造处理异步计算阶段的结果。</p><p id="5658" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">如上所示，<code class="du lm ln lo lp b"><strong class="kh hj">fetchItems</strong></code>调用异步返回一个项目列表。然后将结果反馈给<code class="du lm ln lo lp b"><strong class="kh hj">createCsvFileForItems</strong></code>函数。这个函数作为一个回调函数，一旦<code class="du lm ln lo lp b"><strong class="kh hj">fetchItems</strong></code>函数完成就会被调用。程序开始执行<code class="du lm ln lo lp b"><strong class="kh hj">sendOrderStatus</strong></code> <strong class="kh hj">、</strong>功能，而不等待第一阶段计算完成。因此，我们使用异步编程分离了两个独立的任务。</p><h1 id="4277" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">同步编程的利与弊</h1><h2 id="84c9" class="ml jp hi bd jn mm mn mo jt mp mq mr jx ko ms mt jz ks mu mv kb kw mw mx kd my bi translated">赞成的意见</h2><ul class=""><li id="42ce" class="ls lt hi kh b ki kj kl km ko mz ks na kw nb la lx ly lz ma bi translated">同步编程简单明了，易于实现。</li><li id="2c44" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">它是CPU密集型任务的理想选择。</li><li id="8c94" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">更适合简单的系统。</li><li id="64fb" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">调试同步系统很容易。</li></ul><p id="c5cb" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">缺点</strong></p><ul class=""><li id="964c" class="ls lt hi kh b ki lb kl lc ko lu ks lv kw lw la lx ly lz ma bi translated">它不适合IO绑定的任务。CPU内核未得到充分利用。</li><li id="f7b5" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">它在两个任务之间引入了相关性。一个任务可以阻止另一个任务的执行。</li><li id="d651" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">不适合高吞吐量和低延迟系统</li></ul><p id="d3df" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">异步编程的优点&amp;缺点</strong></p><p id="e40d" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">优点</strong></p><ul class=""><li id="cec2" class="ls lt hi kh b ki lb kl lc ko lu ks lv kw lw la lx ly lz ma bi translated">独立的任务可以并行启动。它充分利用了所有的计算资源。</li><li id="334f" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">有利于IO相关的任务。</li><li id="b8c1" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">可扩展，适合高吞吐量工作负载。</li></ul><p id="f46c" class="pw-post-body-paragraph kf kg hi kh b ki lb ij kk kl lc im kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hj">缺点</strong></p><ul class=""><li id="350d" class="ls lt hi kh b ki lb kl lc ko lu ks lv kw lw la lx ly lz ma bi translated">需要很多回调函数。调试有时会变得很困难。</li><li id="116c" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">不利于CPU密集型任务。</li><li id="0c11" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">在一些编程语言中难以实现。</li></ul><h1 id="e99b" class="jo jp hi bd jn jq jr js jt ju jv jw jx io jy ip jz ir ka is kb iu kc iv kd ke bi translated">参考</h1><ul class=""><li id="abe5" class="ls lt hi kh b ki kj kl km ko mz ks na kw nb la lx ly lz ma bi translated"><a class="ae nc" href="https://pyxis.nymag.com/v1/imgs/4db/9a9/78f0f50285dd11bef4946bc47283e49281-pills-lede.rhorizontal.w1200.jpg" rel="noopener ugc nofollow" target="_blank">封面图片</a></li><li id="597c" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae nc" href="https://www.makeuseof.com/synchronous-asynchronous-programming-different/" rel="noopener ugc nofollow" target="_blank">同步和异步编程</a></li><li id="aa52" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae nc" href="https://dev.to/hardy613/asynchronous-vs-synchronous-programming-23ed" rel="noopener ugc nofollow" target="_blank">开发条款</a></li><li id="802a" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae nc" href="https://www.koyeb.com/blog/introduction-to-synchronous-and-asynchronous-processing" rel="noopener ugc nofollow" target="_blank">同步介绍&amp;异步编程</a></li><li id="168c" class="ls lt hi kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae nc" href="https://www.baeldung.com/java-asynchronous-programming" rel="noopener ugc nofollow" target="_blank"> Java异步编程</a></li></ul></div></div>    
</body>
</html>