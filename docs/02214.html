<html>
<head>
<title>7 quick useful techniques in Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django的7个快速有用的技术</h1>
<blockquote>原文：<a href="https://medium.com/codex/7-quick-useful-techniques-in-django-29fc201aea78?source=collection_archive---------0-----------------------#2021-07-08">https://medium.com/codex/7-quick-useful-techniques-in-django-29fc201aea78?source=collection_archive---------0-----------------------#2021-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6ca1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">让我们看看django中的7个快速有用的技术，它们可以帮助我们节省时间！！！！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a10a56bedb71ae92e8a680724fd9a3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3jx8Dnv6uOumJB7f"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Tatiana Rodriguez 在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="881a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如在官方网站上所说，django是一个为有截止日期的<strong class="jq hj">完美主义者设计的web框架，不深入陈述，Django是一个用于快速web开发的强大web框架。说到博客，让我们看看7个有用的技术，它们可以帮助我们解决一些与django相关的问题，有时还可以节省时间。</strong></p><p id="ac25" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以下是这些技术将涉及的类别:</p><ol class=""><li id="4cab" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">查询集上的过滤器</li><li id="3c40" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">用户相关的对象创建</li><li id="c047" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">对象引用的不同方式</li></ol></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h2 id="d021" class="lf lg hi bd lh li lj lk ll lm ln lo lp jx lq lr ls kb lt lu lv kf lw lx ly lz bi translated">好了，现在让我们深入研究一下技术😃,</h2><h1 id="6995" class="ma lg hi bd lh mb mc md ll me mf mg lp io mh ip ls ir mi is lv iu mj iv ly mk bi translated">1.从输入值列表中筛选:</h1><ol class=""><li id="7221" class="kk kl hi jq b jr ml ju mm jx mn kb mo kf mp kj kp kq kr ks bi translated">我们看到，当给定一系列输入参数时，我们可以如何过滤对象:</li></ol><p id="6daa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">假设我们的数据库中有用户模型和各自的用户对象。我们可以从内置的django auth模型中导入用户模型，如下所示:</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="9d86" class="lf lg hi mr b fi mv mw l mx my">from django.contrib.auth.models import User</span></pre><p id="d1aa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，假设我们得到一个值为的<strong class="jq hj">输入列表，需要根据该列表来过滤用户，例如，我们可能希望根据一个包含<strong class="jq hj">用户id</strong>或用户名或名字或其他信息的列表来过滤<strong class="jq hj">用户</strong>，为简单起见，假设我们有一个包含<strong class="jq hj">活动用户</strong>的列表，如下所示:</strong></p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="8673" class="lf lg hi mr b fi mv mw l mx my">#list of active users.<br/>active_users_list = [1,2,55,21,63,76,88]</span></pre><p id="1666" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们只想要具有这些用户id的用户对象(它们是活动的用户对象)，这可以使用以下方法来实现:</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="c3d6" class="lf lg hi mr b fi mv mw l mx my">#list of active users.<br/><strong class="mr hj">active_users_list </strong>= [1,2,55,21,63,76,88]<br/># we are interested in filtering only the active users from all the users, so we can do the following:<br/><strong class="mr hj">active_users</strong> = User.objects.filter(id__in=active_users_list)</span></pre><p id="caee" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此<strong class="jq hj"> active_users </strong>根据输入过滤器给出一个活动用户的查询集。因此，要获得值列表的通用过滤方法，可以如下所示</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="86cc" class="lf lg hi mr b fi mv mw l mx my">#Model Posts be the a dummy model with name, user etc<br/>value_list = [val1, val2, val3, val4]    #input list<br/>filtered_value = Posts.objects.filter(Field__in=value_list)</span></pre><h1 id="4541" class="ma lg hi bd lh mb mc md ll me mf mg lp io mh ip ls ir mi is lv iu mj iv ly mk bi translated">2.常见问题— F和Q表达式，查询集上的过滤器:</h1><p id="d1a2" class="pw-post-body-paragraph jo jp hi jq b jr ml ij jt ju mm im jw jx mz jz ka kb na kd ke kf nb kh ki kj hb bi translated">F表达式，假设我们有一个情况，需要比较一个模型上一个字段的值和同一个模型中另一个字段的值，那么F表达式就发挥作用了。</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="793e" class="lf lg hi mr b fi mv mw l mx my"># We can import F expressions as following<br/>from django.db.models import <strong class="mr hj">F</strong></span></pre><p id="df34" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">假设有社交媒体应用并且有帖子，让我们如下定义帖子的模型:</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="71f3" class="lf lg hi mr b fi mv mw l mx my">class post(models.Model):<br/>    image = imageField() ##dummy one<br/>    likes = int field<br/>    shares = int field</span></pre><p id="8a70" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以定义一个简单的条件，比如如果<strong class="jq hj">的点赞数</strong>多于<strong class="jq hj">的分享数</strong>或者类似的东西，就可以制作一个帖子<strong class="jq hj">的趋势</strong>。<strong class="jq hj"> </strong>要做到这一点我们可以用F表达式。</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="54f1" class="lf lg hi mr b fi mv mw l mx my"># we have already imported F expression, to get the posts which are trending, we have the following filter:<br/><strong class="mr hj">trending_post </strong>= posts.objects.filter(likes__gt=F('shares')))</span></pre><h1 id="5ad5" class="ma lg hi bd lh mb mc md ll me mf mg lp io mh ip ls ir mi is lv iu mj iv ly mk bi translated">3.来自单个对象(一个对象)的外键(其他表)对象引用(多对一关系):</h1><p id="9ae6" class="pw-post-body-paragraph jo jp hi jq b jr ml ij jt ju mm im jw jx mz jz ka kb na kd ke kf nb kh ki kj hb bi translated">为了定义<strong class="jq hj">多对一关系</strong>，我们在django模型中使用<strong class="jq hj">外键</strong>，这意味着一个表中的一个条目与数据库中的多个表相关。通过外键访问相关元素可以有多种方式，其中一种方式是自己调用模型，用不同的参数过滤所需的对象。另一个简单的方法是直接从作为外键的模型中调用。</p><p id="3e20" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们通过一个例子来看看，假设我们有模型<strong class="jq hj">博客，</strong>的描述，标题和作者字段。一般来说，我们看到每个用户有不止一个博客，所以我们可以将<strong class="jq hj">用户</strong>定义为博客模型的外键。假设我们已经像以前一样导入了用户模型，我们可以如下定义博客模型:</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="e321" class="lf lg hi mr b fi mv mw l mx my">from django.contrib.auth.models import User<br/>from django.db import models</span><span id="86f1" class="lf lg hi mr b fi nc mw l mx my">class blog(models.Model):<br/>    title = models.CharField(max_length=100)<br/>    description = models.TextField(null=True, blank=True)<br/>    user = models.ForeignKey(User, related_name='blogs',        on_delete=models.CASCADE)</span></pre><p id="7a75" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用户是博客模型的外键，因为一个用户可以写多个博客。因此，让我们看看如何引用一个用户的博客可以做到这一点。我们可以用两种方法来做，一种方法是过滤所有有用户的博客，如下所示:</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="8f46" class="lf lg hi mr b fi mv mw l mx my">from .models import blog</span><span id="fc75" class="lf lg hi mr b fi nc mw l mx my">def user_blogs(user):<br/>    user_blogs = blog.objects.filter(user=user)<br/>    return user_blogs</span></pre><p id="4457" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第二种方法是使用博客模型中提供的相关名称直接从用户本身引用用户博客。</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="976b" class="lf lg hi mr b fi mv mw l mx my">#assuming user is user object of some user<br/>.... code before<br/>user = User.objects.get(pk=1)   # assuming user object with 1 exits.<br/>user_blogs = user.blogs.all()   #gives all the blog object</span></pre><p id="863c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">外键对象的引用在我们可以细化与用户相关的对象的访问的情况下会很有用。例如，如上所示，我们可以尝试删除对象是否属于用户的检查，例如用户的博客(user_id = 1)只被该用户访问，其他人不能直接访问。</p><h1 id="1ffd" class="ma lg hi bd lh mb mc md ll me mf mg lp io mh ip ls ir mi is lv iu mj iv ly mk bi translated">4.对查询集的Or运算:</h1><p id="e1bf" class="pw-post-body-paragraph jo jp hi jq b jr ml ij jt ju mm im jw jx mz jz ka kb na kd ke kf nb kh ki kj hb bi translated">我们经常需要根据不同的标准过滤查询集，然后对查询集进行逻辑运算。例如，假设我们有一个需求，要求所有的帖子都有一个特定的“标题”,或者赞数大于某个数字，那么我们可以简单地首先根据标题过滤我们的模型对象，然后根据赞数过滤另一个模型对象，并对其进行or运算。</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="dec5" class="lf lg hi mr b fi mv mw l mx my">from django.contrib.auth.models import User<br/>from django.db import models</span><span id="3284" class="lf lg hi mr b fi nc mw l mx my">class blog(models.Model):<br/>    title = models.CharField(max_length=100)<br/>    description = models.TextField(null=True, blank=True)<br/>    user = models.ForeignKey(User, related_name='blogs',        on_delete=models.CASCADE)<br/>    likes = models.ForeignKey(likes, related_name='blogs',                 on_delete=models.CASCADE)</span><span id="7970" class="lf lg hi mr b fi nc mw l mx my">class likes(models.Model):<br/>    count = models.IntegerField()<br/>    <br/>#Suppose blog has title as filed, and likes as foreign key then,<br/>Total_blogs_with_title="title"_or_has_likes&gt;500 can be done as following:</span><span id="e24a" class="lf lg hi mr b fi nc mw l mx my">from django.db.models import Max, Q<br/>blogs_with_title = blog.objects.filter(title="title")<br/>blogs_with_count = blog.objects.filter(Q(likes_count&gt;500))<br/>Total_blogs = (blogs_with_title | blogs_with_count).distinct()</span></pre><p id="15c8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以将“<strong class="jq hj">和“</strong>操作包含在过滤器本身中，如下所示:</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="a7ab" class="lf lg hi mr b fi mv mw l mx my">Total_blogs= blog.objects.filter(title="title", Q(likes_count&gt;500))</span></pre><h1 id="2aec" class="ma lg hi bd lh mb mc md ll me mf mg lp io mh ip ls ir mi is lv iu mj iv ly mk bi translated">5.django的用户创建:</h1><p id="5bcf" class="pw-post-body-paragraph jo jp hi jq b jr ml ij jt ju mm im jw jx mz jz ka kb na kd ke kf nb kh ki kj hb bi translated">django最好的一点是用户管理已经内置在它的系统中，我们可以扩展它或者使用现有的。通常，当创建模型对象时，我们倾向于使用nameofmodel.object.create(参数)。但是到了用户模型就没什么不同了，我们需要用户的create_user方法而不是create()方法。更多细节我们可以参考<a class="ae jn" href="https://stackoverflow.com/questions/11544398/user-manager-methods-create-and-create-user" rel="noopener ugc nofollow" target="_blank">stack overflow上的这个</a>回答。</p><p id="16b5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，要创建新用户，我们可以采用以下方式:</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="b1f8" class="lf lg hi mr b fi mv mw l mx my">from django.contrib.auth.models import User</span><span id="8010" class="lf lg hi mr b fi nc mw l mx my">credentials = {'usernam': 'name_of_the_user',<br/>               'password': 'password_provided',<br/>               'email': 'mailid.provided'.}<br/>User.objects.create_user(**credentials)</span></pre><h1 id="16fb" class="ma lg hi bd lh mb mc md ll me mf mg lp io mh ip ls ir mi is lv iu mj iv ly mk bi translated">6.使用filter和first()代替get:</h1><p id="31fe" class="pw-post-body-paragraph jo jp hi jq b jr ml ij jt ju mm im jw jx mz jz ka kb na kd ke kf nb kh ki kj hb bi translated">通常我们倾向于使用。get()方法来获取一个对象，我可以观察到的是，我们使用model.object.get(id=id)或其他一些参数来获取一个特定的对象。但是在某些情况下或者在编写单元测试时，当我们倾向于通过get方法或者索引来访问元素时。如果有元素存在，那么我们不会有任何问题，但如果元素被偶然删除，或者在稍后阶段，当我们试图通过它们的id或任何其他字段访问元素时，我们的程序可能会崩溃。为了避免这种情况，并有一个故障安全机制，我们可以使用过滤器和第一方法。我们可以这样做:</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="4170" class="lf lg hi mr b fi mv mw l mx my">#using get method. assuming user with id-6 exists<br/>user = User.objects.get(pk=6)</span><span id="6585" class="lf lg hi mr b fi nc mw l mx my">#using filter and first methods<br/>user = User.objects.filter(pk=6).first()</span></pre><p id="be20" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在第一种情况下，如果碰巧id为6的用户对象不存在，我们会得到一个错误，说没有id为6的对象，但在第二种情况下，过滤器会给出一个空的查询集，第一个方法不会给出任何值，也不会使我们的程序崩溃。</p><h1 id="53b9" class="ma lg hi bd lh mb mc md ll me mf mg lp io mh ip ls ir mi is lv iu mj iv ly mk bi translated">7.虚假迁移:</h1><p id="9a89" class="pw-post-body-paragraph jo jp hi jq b jr ml ij jt ju mm im jw jx mz jz ka kb na kd ke kf nb kh ki kj hb bi translated">当数据已经存在于表中，但是看起来好像没有应用迁移时，假迁移就开始起作用了。我们可以看到使用以下命令应用的迁移</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="f02d" class="lf lg hi mr b fi mv mw l mx my">python manage.py showmigrations</span></pre><p id="ac7d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当数据库在开发人员之间共享时，或者当数据库转储存在并且想要填充我们的db时，这可能会发生，当我们假装迁移时，数据库模式没有发生变化，但是在数据库中创建了一个条目。</p><p id="8f1a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们给migrate命令一个<strong class="jq hj"> —假的</strong>标志。</p><pre class="iy iz ja jb fd mq mr ms mt aw mu bi"><span id="015b" class="lf lg hi mr b fi mv mw l mx my">python .\manage.py migrate --fake #fake all the migrations.</span></pre><p id="5bd4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我们因为表已经存在于数据库中而不能应用初始迁移时，伪初始是使用的另一个标志。在这种情况下，我们可以在migrate命令中使用<strong class="jq hj"> — fake-initial </strong>标志来伪造初始迁移。</p><p id="7dca" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">django中还有许多其他有用的命令，可以节省时间并提供解决问题的方法，如get_object_or_404、transaction.atomic等，这些命令非常有用。感谢您的耐心阅读。希望可能有用。再次感谢。😄</p><p id="44ac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">再次感谢你阅读这篇文章，如果你想支持我，你可以给<a class="ae jn" href="https://www.buymeacoffee.com/gautham.dasu" rel="noopener ugc nofollow" target="_blank">我买杯咖啡</a>，这让我有动力提高自己的技能，并提供尽可能好的内容。</p></div></div>    
</body>
</html>