<html>
<head>
<title>What is NHibernate and how is it different from Entity Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是NHibernate，它与实体框架有什么不同</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-is-nhibernate-and-how-is-it-different-from-entity-framework-29edf365fc50?source=collection_archive---------7-----------------------#2021-08-16">https://medium.com/codex/what-is-nhibernate-and-how-is-it-different-from-entity-framework-29edf365fc50?source=collection_archive---------7-----------------------#2021-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bb1d69384fce1c148b25aa952caf18e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IqtnjaBX1RA-E5tNdzHU4g.png"/></div></div></figure><p id="6934" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在开发任何软件或产品时，对数据库的无缝访问起着非常关键的作用。因此，精心制作连接至关重要。这是ORM(对象关系映射)派上用场，因为它可以帮助他们轻松地访问数据。使用ORM库有助于提高应用程序开发的速度。同时，它简化并巩固了实现。</p><p id="dfda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">中使用了许多流行的ORM库。NET世界如实体框架、NHibernate、Dapper、LLBLGen Pro、RepoDB等。由于有多种选择，所以选择最有效但最合适的ORM至关重要，其中之一就是NHibernate。</p><p id="baec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我们将介绍NHibernate以及它与实体框架的不同之处。</p><p id="b866" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录</strong></p><ol class=""><li id="8808" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">什么是NHibernate？</li><li id="537f" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">NHibernate建筑</li><li id="cf1f" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">使用NHibernate的优势</li><li id="d221" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">NHibernate项目的组成</li><li id="9cdc" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">NHibernate和实体框架的区别</li><li id="f0e9" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">结论</li></ol><h1 id="b7e0" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是NHibernate？</h1><p id="7019" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">它被吹捧为Java到the.NET框架的Hibernate核心的一个端口。它管理普通文件的传输。NET对象与关系数据库之间的相互转换。NHibernate基于实体和关系的XML描述创建SQL来加载和存储对象。</p><p id="3270" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简单来说，NHibernate可以被认为是一个数据库管理系统。它是-</p><ul class=""><li id="a92c" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lf ju jv jw bi translated">ORM框架</li><li id="8022" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">开源</li><li id="0137" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">专为用作。基于对象关系映射技术的. Net框架。</li></ul><p id="4680" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它使用代码来构建数据库对象的“虚拟表示”。使用这种技术解决了类和关系数据库和表之间的阻抗不匹配。</p><h1 id="0643" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">NHibernate建筑</h1><p id="1c61" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">现在许多系统都是用分层体系结构开发的；NHibernate也不例外，可以完美地使用它。分层体系结构将系统分成几个组，每个组包含解决特定问题领域的代码。这些组被称为层。大多数企业级应用都有一个三层的高级应用架构:</p><ul class=""><li id="f15e" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lf ju jv jw bi translated">表示层</li><li id="3e59" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">业务层</li><li id="dbd9" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">持久层</li></ul><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/1a252a2b87fcbf3f6561d6e595535e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/0*SBXJfNNfmbazMFFR"/></div></figure><p id="96f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上图显示了一个简单的NHibernate架构以及NHibernate应用程序的高级视图。为了持久化，应用程序代码使用了NHibernate ISession和IQuery APIs。它只需要管理数据库事务，这应该使用NHibernate ITransaction API来完成。</p><h1 id="cc2b" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">使用NHibernate的优势</h1><ul class=""><li id="51a3" class="jo jp hi is b it la ix lb jb ll jf lm jj ln jn lf ju jv jw bi translated">对象保存在关系数据库中，在那里它可以用于所有的CRUD活动。</li><li id="9a37" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">所有数据库工作都由NHibernate处理。</li><li id="bd67" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">不再需要SQL语句或创建已保存的查询。</li><li id="e397" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">所有的数据访问逻辑都可以包含在应用程序中。</li><li id="480a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">由于数据制图，我们的查询不仅有效，而且还会被编译器验证。因此，如果底层表的结构发生变化，编译器会通知我们需要修改查询！</li><li id="8263" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">不需要为任何创建、检索、更新或删除(CRUD)操作编写SQL查询。</li></ul><h1 id="02bb" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">NHibernate项目的组成</h1><p id="dd6a" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">NHibernate项目由多个元素组成，例如:</p><ol class=""><li id="5a63" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">XML映射文件(hbm.xml)。</li><li id="9d00" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">Hibernate配置文件:hibernate.cfg</li><li id="c270" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">普通旧CLR对象(POCOs)。</li><li id="f0d5" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">Web.config(一个XML文件)。</li><li id="04c3" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">带有数据访问对象(DAO)的数据库。</li><li id="4d03" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">网页/ WebForm / MVC:视图(Razor)。</li></ol><p id="0e9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一方面，一个简单的NHibernate项目由下面列出的四个关键部分组成</p><p id="e8bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Hibernate映射文件:将数据映射到POCOs </strong></p><ul class=""><li id="3c01" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lf ju jv jw bi translated">指导NHibernate如何建立或不建立数据库。</li><li id="98d9" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">要通知NHibernate您想要获取或存储到数据库中的数据，请使用数据访问方法。</li><li id="4b08" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">你需要一个POCO来处理数据。尽管XML映射文件经常在NHibernate项目中使用，但它们并不是将数据映射到POCOs的唯一方法。</li></ul><p id="bfa4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Hibernate配置文件:hibernate.cfg </strong></p><ul class=""><li id="db36" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lf ju jv jw bi translated">提供有关数据库连接配置、SQL查询方言、会话工厂类等的详细信息。</li><li id="811b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">“sessionFactory”是每个应用程序生命周期创建一次的线程安全对象，它是NHibernate的基础。</li><li id="323c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">一个Hibernate映射文件，根据配置控制数据库表如何映射到C#对象。换句话说，哪个属性对应于哪个数据库表列。</li><li id="3120" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">hibernate映射XML文件。</li></ul><p id="0271" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">普通旧CLR对象(POCO) </strong></p><ul class=""><li id="57d9" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lf ju jv jw bi translated">在C#或VB.NET中，构建一个类。</li><li id="2395" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">一个类中只能有一个属性被指定为虚拟的(它帮助hibernate创建一个代理)。</li><li id="2a84" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">它可以选择拥有一个默认的函数对象(){[本机代码] }。</li></ul><p id="ddaf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">aspx中的主类/视图页面:- </strong></p><ul class=""><li id="79a3" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lf ju jv jw bi translated">使用会话，以获取数据并将其设置到会话中，以便将其保存到数据库中。</li><li id="054a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">使用进程从数据库中获取数据，并将其显示在ASPX页面或视图页面上。</li></ul><h1 id="1654" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">NHibernate和实体框架的区别</h1><p id="d4a2" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">以下是使用NHibernate优于Entity Framework的一些区别和优势。</p><ul class=""><li id="92b8" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lf ju jv jw bi translated">实体框架需要额外的连接来处理MSSQL之外的数据库，这是nHibernate提供的。</li><li id="67be" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">在数据加载、SQL生成、自定义列类型、自定义集合等方面，NHibernate都可以修改。然而，实体框架的扩展点有限。</li><li id="000b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">实体框架不支持BLOB和CLOB等标量属性的延迟加载，但是nHibernate支持。</li><li id="3600" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">只有在NHibernate中支持以级联方式删除行。</li><li id="af66" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">NHibernate中还提供了预加载、后加载、更新和删除功能。</li><li id="26d4" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">NHibernate提供二级缓存支持。</li><li id="e097" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">唯一的缺点是——由于元数据的准备，nHibernate比实体框架需要更长的启动时间。</li></ul><h1 id="20bc" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="a7b7" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">NHibernate是一个用于the.NET框架的开源对象关系映射器，它不断发展，功能丰富。数以千计的成功项目采用了它，并在这些年里取得了成功。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="a21f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lv">原载于</em><a class="ae lw" href="https://www.partech.nl/en/publications/2021/08/what-is-nhibernate-and-how-is-it-different-from-entity-framework" rel="noopener ugc nofollow" target="_blank"><em class="lv">https://www . partech . nl</em></a><em class="lv">。</em></p></div></div>    
</body>
</html>