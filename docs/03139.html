<html>
<head>
<title>A simple lesson in coding: testing first!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码的一个简单教训:测试第一！</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-simple-lesson-in-coding-testing-first-91b3da7b9925?source=collection_archive---------22-----------------------#2021-08-19">https://medium.com/codex/a-simple-lesson-in-coding-testing-first-91b3da7b9925?source=collection_archive---------22-----------------------#2021-08-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7eed5d132739e58c989761e0727c3c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYUiLUGj4z-14z7A11056A.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在阿肯色州本顿维尔的21C酒店展出的亚历山大·阿雷契亚的<strong class="bd iu"> <em class="iv">橘子树、</em> </strong> <em class="iv">。(作者照片，2021)。</em></figcaption></figure><p id="1747" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这是四篇系列文章中的第三篇，讲述了一个简单的想法是如何演变成学生第一堂数据结构课的课程计划的。第一篇文章描述了一个简单的例子，我们将在这里继续使用:一个判断字符串是否是回文的方法。<a class="ae jv" rel="noopener" href="/@leoirakliotis/a-simple-lesson-in-coding-revisited-fbc9add1e599">第二篇</a>提炼了方法，结果如下图。</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="b49d" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">代码看起来不错，但正如我们将要发现的，它仍然是不完整的。它适用于大小写混合的参数，因为<code class="du kc kd ke kf b">.toLowerCase</code>首先强制所有内容小写。代码删除了带有<code class="du kc kd ke kf b">.replace</code>的空格，将类似“赛车”的参数识别为回文。它甚至删除了标点符号和带有<code class="du kc kd ke kf b">.replaceAll</code>的数字，以处理类似“一个人，一个计划，一条运河:巴拿马”的回文。(是的，我们可以将<code class="du kc kd ke kf b">replace</code>和<code class="du kc kd ke kf b">replaceAll</code>合并成一个<code class="du kc kd ke kf b">replaceAll</code>。出于说明的目的，我将它们分开)。</p><p id="e773" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果我们编写一些简单的测试，我们甚至会对代码的准确性印象深刻:</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">对托管在名为<strong class="ak">回文的类中的方法<strong class="ak"> isPalindrome() </strong>进行简单测试。</strong></figcaption></figure><p id="476c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">所以，这是可行的，对吧？看方法告诉我们这些字符串是回文的时候我们是什么感受:<code class="du kc kd ke kf b">"5A"</code>、<code class="du kc kd ke kf b">"..."</code>、<code class="du kc kd ke kf b">"101"</code>、<code class="du kc kd ke kf b">"123"</code>、<code class="du kc kd ke kf b">"..-"</code>、<code class="du kc kd ke kf b">""</code>(空字符串)。</p><p id="3fb0" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">字符串<code class="du kc kd ke kf b">"..."</code>和<code class="du kc kd ke kf b">"101"</code>可以被认为是回文。它们是向前和向后的相同字符序列。但这不是我们的方法如何确定它们是回文。我们方法的第4行从这些字符串中删除了所有非字母字符。<code class="du kc kd ke kf b">"..."</code>和<code class="du kc kd ke kf b">"101"</code>都被还原为空字符串。空字符串的长度为0。第6行的while循环不会运行(因为条件<code class="du kc kd ke kf b">pos &lt; s.length</code>为<code class="du kc kd ke kf b">false</code>)。并且该方法返回被设置为<code class="du kc kd ke kf b">true</code>的<code class="du kc kd ke kf b">palindrome</code>的初始值。</p><p id="11bd" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">基本上，该方法为任何包含非字母字符的字符串返回<code class="du kc kd ke kf b">true</code>，例如<code class="du kc kd ke kf b">"@123.456"</code>、<code class="du kc kd ke kf b">"3.14"</code>等。而像<code class="du kc kd ke kf b">"555A"</code>这样只有一个字母的字符串，经过4号线的<code class="du kc kd ke kf b">replaceAll()</code>和<code class="du kc kd ke kf b">toLowerCase()</code>方法清洗后，会还原为<code class="du kc kd ke kf b">"a"</code>。我们的方法会将<code class="du kc kd ke kf b">"555A"</code>识别为一个回文。</p><p id="e4a2" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">最后，想象下面的代码:</p><pre class="jw jx jy jz fd kg kf kh ki aw kj bi"><span id="791c" class="kk kl hi kf b fi km kn l ko kp">String s = null;<br/>isPalindrome(s);</span></pre><p id="e51f" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这将导致空指针异常，这是我们希望避免的运行时错误。</p><p id="341b" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">早先的繁荣现在正在消退。我们的方法没有我们想象的那么酷那么牛逼。它可以处理像“一个人，一个计划，一条运河:巴拿马”这样的回文，但也会产生错误的结果。那是因为我赶着写代码，感觉<em class="ju">过- </em>对实现很有信心。我没有花时间去消化这个方法的需求，也没有计划如何测试它。让我们现在解决这个问题。</p><p id="1c0e" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">首先，让我们描述一下我们希望方法做什么:return true是一个非空字符串是一个回文。回文只包含字母。空格、字母大小写和标点符号不影响回文属性。像<code class="du kc kd ke kf b">“Race car!”</code>这样的字符串是回文。像<code class="du kc kd ke kf b">“3.14PIIP41.3”</code>这样的字符串，都不是。</p><p id="2f3a" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">接下来，让我们考虑一些更多的测试。除了前面显示的<code class="du kc kd ke kf b">assertTrue</code>调用，我们还希望我们的方法通过下面的测试。</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="e797" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">为了满足这些期望，我们必须走到谈判桌前。我们应该早点去那里，但是我们必须先吸取教训。我们需要的伪代码如下所示，它包括我们到目前为止讨论的所有三个主要条件:检查空值、检查有效内容和检查空字符串。</p><pre class="jw jx jy jz fd kg kf kh ki aw kj bi"><span id="fee9" class="kk kl hi kf b fi km kn l ko kp">boolean isPalindrome(String s)<br/>  if s is not null<br/>    <strong class="kf hj">if s has valid content<br/></strong>      remove spaces and punctuation from s<br/>      if s not empty after removal of spaces and punctuation<br/>        determine palindromic property</span></pre><p id="a2c6" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这花了我们一段时间，但我们终于在讨论我们想要评估什么样的字符串。我们只需要字母、空格和标点符号。因此，我们首先需要一个helper方法来确定我们的字符串是否是有效的输入，即只包含允许的字符。</p><p id="4391" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">编写一个助手方法似乎很容易。一个字符一个字符地取一个字符串，当我们发现一个不允许的值时，就声明它不适合我们的回文方法。但是可能有一个陷阱。这样的帮助器方法可能会取消像<code class="du kc kd ke kf b">"555A"</code>这样的字符串，因为不允许使用数字。像<code class="du kc kd ke kf b">".!!."</code>这样的字符串将被验证，因为它们包含标点符号。我们同意吗？我们需要至少有一封信吗？假设我们有。字符串必须至少有一个字母，并且不能包含除字母、空格和标点符号之外的任何内容。下面的方法<code class="du kc kd ke kf b">isValid</code>，似乎符合这个规范。</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="0ceb" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">上面的方法返回两个变量的AND:<code class="du kc kd ke kf b">hasValidCharacters</code>和<code class="du kc kd ke kf b">atLeastOneLetterPresent</code>。当字符串中的每个字符都有效时，即一个字母<em class="ju">或</em>一个标点符号<em class="ju">或</em>一个空格，第一个变量为真。当至少有一个字符串字符是字母时，第二个变量为真。第11行评估有效字符。该行检查字符是否在<em class="ju"> a </em>和<em class="ju"> z </em>之间，或者该字符是否出现在允许的字符序列中。在第12行评估至少一个字母的存在。一旦条件<code class="du kc kd ke kf b">'a' &lt;= c &amp;&amp; c &lt;= 'z'</code>评估为真，无论接下来发生什么，它都将变量<code class="du kc kd ke kf b">atLeastOneLetterPresent</code>设置为真。</p><p id="1f54" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在<code class="du kc kd ke kf b">isValid</code>的帮助下，我们现在可以完成回文方法了，如下所示。</p><figure class="jw jx jy jz fd ij"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="5c10" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><em class="ju">接下来:</em> <a class="ae jv" rel="noopener" href="/@leoirakliotis/3ef0326b6506"> <em class="ju">一堂简单的编码课:操场</em> </a> <em class="ju">。</em></p></div></div>    
</body>
</html>