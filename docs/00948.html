<html>
<head>
<title>Secrets of HOISTING in JavaScript revealed!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中提升的秘密暴露了！</h1>
<blockquote>原文：<a href="https://medium.com/codex/secrets-of-hoisting-in-javascript-revealed-429dede81aa3?source=collection_archive---------20-----------------------#2021-03-26">https://medium.com/codex/secrets-of-hoisting-in-javascript-revealed-429dede81aa3?source=collection_archive---------20-----------------------#2021-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="69db" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><figure class="ev ex ip iq ir is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es io"><img src="../Images/49e78de43e166b1ab7b3207f812b0cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZaQrSST8LqCfne-wsT_smg.png"/></div></div></figure><p id="3bc1" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">嘿访客！怎么了？让我猜猜，“为什么这不起作用？”，或者，“这是怎么做到的？”。IKR，作为JavaSript开发人员的额外津贴。但是今天我的任务是揭示JavaScript最流行的魔术之一<strong class="jb hs">提升的神秘秘密。</strong></p><p id="baaf" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">我们将深入JavaScript，所以请系好安全带，你的旅程即将开始。</p><h2 id="320a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jk ki kj kk jo kl km kn js ko kp kq ho bi translated">让我们困惑吧！</h2><p id="c04b" class="pw-post-body-paragraph iz ja hi jb b jc kr je jf jg ks ji jj jk kt jm jn jo ku jq jr js kv ju jv jw hb bi translated">请看以下三种情况，以及JavaScript对它们的不同反应。</p><ol class=""><li id="fcc5" class="kw kx hi jb b jc jd jg jh jk ky jo kz js la jw lb lc ld le bi translated">在第一种情况下，首先声明变量<code class="du lf lg lh li b">i</code>和函数<code class="du lf lg lh li b">getName</code>，然后使用。这是我们在大多数编程语言中经常做的事情。</li><li id="b42d" class="kw kx hi jb b jc lj jg lk jk ll jo lm js ln jw lb lc ld le bi translated">在第二种情况下，<code class="du lf lg lh li b">i</code>和<code class="du lf lg lh li b">getName</code>在被使用后被声明。这在其他pl中是不允许的，会导致运行时错误，但是在JavaScript中，这是允许的。请注意，<code class="du lf lg lh li b">i</code>中有值<code class="du lf lg lh li b">undefined </code>。</li><li id="6f8d" class="kw kx hi jb b jc lj jg lk jk ll jo lm js ln jw lb lc ld le bi translated">在第三种情况下，<code class="du lf lg lh li b">i</code>在程序中的任何地方都没有声明，因此存在一个引用错误，表明<strong class="jb hs"> i没有定义</strong>。</li></ol><pre class="lo lp lq lr fd ls li lt lu aw lv bi"><span id="a45e" class="jx jy hi li b fi lw lx l ly lz"><strong class="li hs">//CASE 1<br/></strong>var i = 10;<br/>function getName(){<br/>   console.log("Shivam Bhasin");<br/>}<br/>console.log(i); <strong class="li hs">//10</strong><br/>getName(); <strong class="li hs">//Shivam Bhasin</strong></span><span id="9885" class="jx jy hi li b fi ma lx l ly lz"><strong class="li hs">//CASE 2</strong><br/>console.log(i); <strong class="li hs">//undefined</strong><br/>getName(); <strong class="li hs">//Shivam Bhasin</strong><br/>var i = 10;<br/>function getName(){<br/>   console.log("Shivam Bhasin");<br/>}</span><span id="5192" class="jx jy hi li b fi ma lx l ly lz"><strong class="li hs">//CASE 3</strong><br/>console.log(i); <strong class="li hs">//Reference Err: i is not defined</strong><br/>getName();<br/>function getName(){<br/>   console.log("Shivam Bhasin");<br/>}</span></pre><p id="14ba" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在案例2中，JavaScript已经知道有一个变量<code class="du lf lg lh li b">i</code>被声明，只是它的值还没有定义，但是<code class="du lf lg lh li b">i</code>在第3行被我们初始化了。所以不知何故，JavaScript将第3行的声明移到了顶部，而没有给它赋值10。还要注意的是<code class="du lf lg lh li b">getName</code>确实被执行并打印了“Shivam Bhasin”。同样，JS在声明函数之前就知道了函数的一切。在<strong class="jb hs">情况2中的<code class="du lf lg lh li b">console.log(getName)</code>，在<code class="du lf lg lh li b">getName</code>声明之前的</strong>，将给出以下输出。这就好像JavaScript在引用中包含了函数的完整代码。</p><pre class="lo lp lq lr fd ls li lt lu aw lv bi"><span id="d106" class="jx jy hi li b fi lw lx l ly lz">f getName(){<br/>   console.log("Shivam Bhasin");<br/>}</span></pre><p id="fe2e" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">然而，在案例3中，<code class="du lf lg lh li b">i</code>在代码中的任何地方都没有被我们定义。所以JavaScript不知道它，因此在我们面前抛出一个错误‘嘿，伙计！“这个‘我’从何而来？”</p><p id="0abf" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这就是大家一直称之为<strong class="jb hs">的吊装。我从W3学校得到这个:</strong></p><blockquote class="mb"><p id="74cb" class="mc md hi bd me mf mg mh mi mj mk jw dx translated">提升是JavaScript将所有声明移动到当前作用域顶部的默认行为。</p></blockquote><p id="c1f5" class="pw-post-body-paragraph iz ja hi jb b jc ml je jf jg mm ji jj jk mn jm jn jo mo jq jr js mp ju jv jw hb bi translated">好了，我们知道所有的变量和函数声明都移到了当前作用域的顶部，但问题是它们真的上移了吗？或者还有别的JavaScript在做BTS。</p><h2 id="380b" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jk ki kj kk jo kl km kn js ko kp kq ho bi translated">BTS(幕后— JavaScript)</h2><p id="fd43" class="pw-post-body-paragraph iz ja hi jb b jc kr je jf jg ks ji jj jk kt jm jn jo ku jq jr js kv ju jv jw hb bi translated">在代码开始执行之前，<strong class="jb hs"> JavaScript遍历我们所有的代码，并将内存分配给所有的变量和函数</strong>。是的，即使没有执行一行代码，JavaScript也有关于我们在代码中声明的变量和函数的信息。</p><p id="7125" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在执行之前，它创建一个<strong class="jb hs">全局执行范围</strong>，它基本上是两个阶段，<strong class="jb hs">内存阶段</strong>和<strong class="jb hs">代码阶段</strong>。我们今天对记忆阶段感兴趣。甚至在第一行代码运行之前，我们所有的变量和函数都存储在这里。它是提供给我们作为<strong class="jb hs">全局对象</strong>使用的。</p><p id="ca2f" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">内存阶段是一个键值存储。下面是这种说法的一个例证。</p><figure class="lo lp lq lr fd is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es mq"><img src="../Images/57196b5d4577c5f09a799bbd716aa122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qd3gSkeUOhrrYBBjGXi3FA.png"/></div></div><figcaption class="mr ms et er es mt mu bd b be z dx translated">图片来自开发人员</figcaption></figure><p id="b1ab" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">考虑下面的例子:</p><pre class="lo lp lq lr fd ls li lt lu aw lv bi"><span id="7a8f" class="jx jy hi li b fi lw lx l ly lz">console.log(i); <strong class="li hs">//undefined</strong><br/>getName(); <strong class="li hs">//Hey Visitor!</strong><br/>console.log(getName); <strong class="li hs">//f getName(){  console.log("Hey Visitor!"); }</strong><br/>var i = 10;<br/>function getName(){<br/>   console.log("Hey Visitor!");<br/>}</span></pre><p id="6de1" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">现在，在执行第一行代码之前，JavaScript遍历代码并创建一个对象<strong class="jb hs"> Global </strong>，如下所示:</p><pre class="lo lp lq lr fd ls li lt lu aw lv bi"><span id="6b2f" class="jx jy hi li b fi lw lx l ly lz">Global: {<br/>   i: undefined,<br/>   getName: f () { //body of the function },<br/>   //Other fields in the object<br/>}</span></pre><p id="fb10" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">你知道这个<strong class="jb hs">全局</strong>物体吧？没有吗？你用过类似<code class="du lf lg lh li b">window.alert()</code>的东西。有没有想过，这些是从哪里来的？是的，你是对的！所有这些函数都由JavaScript提供，供您在这个全局对象中使用。</p><p id="9287" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">对于变量，存储未定义的<strong class="jb hs"/>，对于函数，存储完整的<strong class="jb hs">函数体</strong>。是的，所有函数都完全存储在作用域中。对象Global，基本上就是<strong class="jb hs">全局执行范围</strong>。</p><p id="99a2" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">所以现在当JavaScript开始执行代码并遇到第1行，即<code class="du lf lg lh li b">console.log(i);</code>时，它知道<code class="du lf lg lh li b">i</code>，因为它在<strong class="jb hs">全局对象</strong>中，因此打印出<strong class="jb hs">未定义的</strong>。函数<code class="du lf lg lh li b">getName</code>也是如此，它被执行是因为它的整体存储在全局范围内。</p><p id="a198" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">现在考虑以下情况:</p><pre class="lo lp lq lr fd ls li lt lu aw lv bi"><span id="091d" class="jx jy hi li b fi lw lx l ly lz">getName(); <strong class="li hs">//Hey Visitor!</strong><br/>console.log(i); <strong class="li hs">//Reference Err: i is not defined</strong><br/>function getName(){<br/>   console.log("Hey Visitor!");<br/>}</span></pre><p id="b039" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在这种情况下，JavaScript将再次创建一个全局对象，如:</p><pre class="lo lp lq lr fd ls li lt lu aw lv bi"><span id="4ed9" class="jx jy hi li b fi lw lx l ly lz">Global: {<br/>   getName: f () { //body of the function },<br/>   //Other fields in the object<br/>}</span></pre><p id="7bbc" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这里，在执行代码时，当JavaScript遇到第2行，即<code class="du lf lg lh li b">console.log(i);</code>，它在全局范围内找不到<code class="du lf lg lh li b">i</code>，因此抛出一个错误<strong class="jb hs">I not defined</strong>，因为我们没有在代码中的任何地方声明<code class="du lf lg lh li b">i</code>，JavaScript对此一无所知。</p><h2 id="4188" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jk ki kj kk jo kl km kn js ko kp kq ho bi translated">函数呢？</h2><p id="7da1" class="pw-post-body-paragraph iz ja hi jb b jc kr je jf jg ks ji jj jk kt jm jn jo ku jq jr js kv ju jv jw hb bi translated">到目前为止，我们知道有一个全局执行范围，它包含全局范围的变量和函数。现在考虑以下情况:</p><pre class="lo lp lq lr fd ls li lt lu aw lv bi"><span id="d6ab" class="jx jy hi li b fi lw lx l ly lz">console.log(getName); <strong class="li hs">// f getName() { //body of function }</strong><br/>console.log(i); <strong class="li hs">//Reference Error: i is not defined</strong><br/>console.log(getEmail); <strong class="li hs">//Reference Error: getEmail is not defined</strong><br/>function getName(){<br/>   var i = 10;<br/>   function getEmail(){<br/>      console.log("my@email.com");<br/>   }<br/>}</span></pre><p id="2c3d" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在这种情况下，JavaScript再次遍历我们的代码并创建一个全局对象，如下所示:</p><pre class="lo lp lq lr fd ls li lt lu aw lv bi"><span id="82fd" class="jx jy hi li b fi lw lx l ly lz">Global: {<br/>   getName: f getName() { //body }<br/>   //other fields in the object<br/>}</span></pre><p id="29c8" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">但是在这种情况下，<code class="du lf lg lh li b">i</code>和<code class="du lf lg lh li b">getEmail </code>都在<strong class="jb hs"> getName执行上下文</strong>内，而不在全局范围内。这是因为JavaScript中的每个函数都有自己的执行上下文。将整个程序视为一个全局功能，放在<strong class="jb hs"> GEC </strong>下。注意，函数执行上下文是在特定函数执行期间创建的，而不是在此之前。</p><p id="898b" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">现在请看下面的场景:</p><pre class="lo lp lq lr fd ls li lt lu aw lv bi"><span id="8f45" class="jx jy hi li b fi lw lx l ly lz">console.log(getName); <strong class="li hs">//f getName() { //body of function }</strong><br/>function getName(){<br/>   console.log(i); <strong class="li hs">//10</strong><br/>   console.log(getEmail); <strong class="li hs">//f getEmail() { //body of function }</strong><br/>   var i = 10;<br/>   function getEmail(){<br/>      console.log("my@email.com");<br/>   }<br/>}</span></pre><p id="7529" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在这种情况下，创建了一个包含<code class="du lf lg lh li b">getName </code>的全局执行范围。在执行过程中，它遇到<code class="du lf lg lh li b">line 2</code>，然后创建一个新的<strong class="jb hs"> getName执行上下文</strong>。这将有它自己的<strong class="jb hs">内存阶段</strong>和它自己的全局对象，看起来像这样:</p><pre class="lo lp lq lr fd ls li lt lu aw lv bi"><span id="0420" class="jx jy hi li b fi lw lx l ly lz">getName: {<br/>   i: undefined,<br/>   getEmail: f getEmail() { //body of function }<br/>}</span></pre><p id="36f1" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这个范围仅限于<strong class="jb hs"> getName执行上下文</strong>，不能从任何其他地方访问。<code class="du lf lg lh li b">getEmail </code>功能的情况也是如此。执行时将创建一个新的EC，该EC仅限于在内部访问。</p><figure class="lo lp lq lr fd is er es paragraph-image"><div class="er es mv"><img src="../Images/73bb3f6d83b06d39ecd2eb00ca691186.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*hZaMuI7doAwAxRpisF93SA.png"/></div></figure><p id="0bc4" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">执行顺序由调用堆栈维护。在start中，JS引擎将GEC推入堆栈，并开始执行代码。当遇到一个函数时，它创建一个新的面向函数的EC，并将其推送到调用栈。当函数执行完毕时，它从调用堆栈中弹出EC，并将控制权返回给GEC。</p><p id="5c91" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">所以现在每当有人问什么是JavaScript中的提升，不要只是说这是一种向上移动声明的行为。向他们解释全局执行范围，以及JavaScript如何在开始执行代码之前给所有变量和函数分配内存。</p><p id="a1bf" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">JavaScript中的每一个魔法都有一个解释。只要有足够的好奇心去寻找真正的原因。这样事情才会真正变得明朗。</p><p id="8802" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">我希望你从这篇文章中得到价值。如果有任何疑问或讨论，请不要三思而后行。</p><p id="b708" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">下次见，访客！</p></div></div>    
</body>
</html>