<html>
<head>
<title>An identifier, by any other name, …</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个标识符，以任何其他名称，…</h1>
<blockquote>原文：<a href="https://medium.com/codex/an-identifier-by-any-other-name-c9c8f32b1477?source=collection_archive---------8-----------------------#2021-10-31">https://medium.com/codex/an-identifier-by-any-other-name-c9c8f32b1477?source=collection_archive---------8-----------------------#2021-10-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a862" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时候，我们应该如何称呼变量或方法参数是显而易见的:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="a2a7" class="jm jn hi ji b fi jo jp l jq jr">val <em class="js">radius </em>= 1<br/>val <em class="js">circumference </em>= 2 * <em class="js">radius </em>* Math.<em class="js">PI</em></span></pre><figure class="jd je jf jg fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jt"><img src="../Images/2aaeb2e932c096cfd61c546ebb4b8b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_dw8mhpywfXTmUV-UFgn-w.jpeg"/></div></div></figure><p id="6277" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是很多时候，花时间去想该如何称呼某样东西是没有意义的。为一个名字而苦恼(<em class="js">一朵玫瑰，或者其他名字</em>，等等)实际上可能会阻止我们在真正需要的时候拆分一个表情。令人费解的表达是审查者或维护者生活的祸根。例如，当我们不把他们分开时，Codacy会给我们一个轻微的警告。</p><p id="63ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，在强类型语言(比如Scala)中，变量的重要之处是什么呢？类型。我们通常很容易看到价值。但是，除非你习惯于给所有的变量添加类型注释，否则类型可能不会如此明显。那么，为什么不根据类型来命名呢？简单！</p><p id="ffef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能已经注意到这样的代码(摘自<em class="js"> Artima </em>网站:<a class="ae kb" href="https://www.artima.com/pins1ed/working-with-lists.html" rel="noopener ugc nofollow" target="_blank">使用列表</a>):</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="b80a" class="jm jn hi ji b fi jo jp l jq jr">def isort(xs: List[Int]): List[Int] =<br/>    if (xs.isEmpty) Nil<br/>    else insert(xs.head, isort(xs.tail))</span></pre><p id="8287" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<em class="js"> xs </em>用于事物序列，发音为<em class="js"> x的</em>(<em class="js">x</em>的复数)。每个人都这样做。而且，Scala语言鼓励使用短标识符。因此，我简单地整理了一组更通用的规则(实际上是指导原则)来涵盖大多数可能发生的情况，从而得到一个简洁、简短且有意义的标识符。</p><p id="1ec5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同理，<em class="js"> x </em>的一个序列(<em class="js"> Seq </em>)写成<em class="js"> xs </em>，那么<em class="js"> x </em>的一个<em class="js">未来</em>应该写成<em class="js"> xf </em>。一个<em class="js"> x </em>的<em class="js"> Try </em>可能会写成<em class="js"> xt </em>但是我要推荐稍微不同的东西(<em class="js"> xy </em>)，因为<em class="js"> t </em>对<em class="js">元组</em>有用。所以，总的方案是:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="34e7" class="jm jn hi ji b fi jo jp l jq jr">trait C[X]<br/>type A<br/>val <em class="js">ac</em>: C[A] = <em class="js">???</em></span></pre><p id="0c2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<em class="js"> C </em>是某个容器类型(不一定是这里显示的特征)，而<em class="js"> A </em>是某个类型，那么我们用<em class="js"> ac </em>表示A<em class="js">C【A】</em>。显然，这些可以这样组合，如果<em class="js"> A </em>恰好是<em class="js"> X </em>的序列(例如)，那么我们最终得到:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="6c23" class="jm jn hi ji b fi jo jp l jq jr">val <em class="js">xsc</em>: C[Seq[X]] = <em class="js">???</em></span></pre><p id="fbf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，容器/类型定义的顺序与标识符的名称相对应。所有这一切的好处是，当读者(甚至您自己)以后阅读代码时，即使没有明确显示，也可以清楚地知道标识符的类型。如果您不是通过IDE阅读代码，那么有一个类型指示将会非常有帮助。这也使得调试变得更加容易。</p><p id="ce43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了便于理解(假设<em class="js"> C </em>是一个函子，即定义了<em class="js">映射</em>)，模式/生成器看起来非常自然:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="ca47" class="jm jn hi ji b fi jo jp l jq jr">for (a &lt;- <em class="js">ac</em>) yield a</span></pre><p id="f912" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是我对缩写的建议(当然，你应该自己选择):</p><figure class="jd je jf jg fd ju er es paragraph-image"><div class="er es kc"><img src="../Images/2eadf0276266d1998cf59e93a8cb9b48.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*CWfOmy3Zo0e7LSXhlPjZfQ.png"/></div></figure><p id="c6f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时，您可能有多个相同类型的标识符，在这种情况下，您可以在单个字母后加上1、2等。或者，您可以使用单个大写字符来添加上下文，例如用<em class="js"> gD </em>表示文档字符串，用<em class="js"> gL </em>表示行字符串。你也可以决定用<em class="js"> t2 </em>来表示<em class="js">连音2 </em>等等。在我们有一个形式为<em class="js">的<em class="js">或者</em>或者【String，X】</em>或者<em class="js">或者【Throwable，X】</em>的情况下，我们简单地使用标识符<em class="js"> xe </em>，忽略左侧(险恶的)类型。</p><p id="d678" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在作为<em class="js">未来</em>的<em class="js"> f </em>和作为<em class="js">功能</em>的<em class="js"> f </em>之间可能会产生一些混淆。但是，这一点应该很清楚，因为容器位于标识符字符串的末尾。</p><p id="9107" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是一些使用这种思想的代码示例:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="625a" class="jm jn hi ji b fi jo jp l jq jr">def flatten[X](xyf: Future[Try[X]])(implicit ec: ExecutionContext): Future[X] = for (xy &lt;- xyf; x &lt;- <em class="js">asFuture</em>(xy)) yield x</span><span id="6846" class="jm jn hi ji b fi kd jp l jq jr">def asFuture[X](xy: Try[X]): Future[X] = xy match {<br/>  case <em class="js">Success</em>(x) =&gt; Future.<em class="js">successful</em>(x)<br/>  case <em class="js">Failure</em>(z) =&gt; Future.<em class="js">failed</em>(z)<br/>}</span><span id="144b" class="jm jn hi ji b fi kd jp l jq jr">def sequence[X](xos: Seq[Option[X]]): Option[Seq[X]] = xos.foldLeft(<em class="js">Option</em>(<em class="js">Seq</em>[X]())) {<br/>  (xso, xo) =&gt; for (xs &lt;- xso; x &lt;- xo) yield xs :+ x<br/>}</span></pre><p id="36e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个稍微尴尬的情况是当使用一个<em class="js"> Map </em>或者其他接受两个底层类型的容器时。我通常将第一个底层类型(在标识符中第二个出现)用大写字母表示，以试图阐明发生了什么。例如，这里有一种方法，将带有可选值的<em class="js">映射</em>展平为带有所需值的<em class="js">映射</em>。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="dcc1" class="jm jn hi ji b fi jo jp l jq jr">def flatten[K, V](voKm: Map[K, Option[V]]): Map[K, V] = for ((k, vo) &lt;- voKm; v &lt;- vo) yield k -&gt; v</span></pre><p id="22cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，一个<em class="js"> (K，V) </em>元组可能有一个名为kV或_kv_的标识符，而不是使用<em class="js"> t </em>作为某种泛型类型。或者，您可以通过使用带括号的标识符来发挥真正的创造力，例如:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="dd4e" class="jm jn hi ji b fi jo jp l jq jr">val <em class="js">`[wx]m` </em>= <em class="js">Map</em>[String,Int]()</span></pre><p id="c827" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好好享受吧。这绝对比绞尽脑汁去想一个合适的、简短的名字要好。</p></div></div>    
</body>
</html>