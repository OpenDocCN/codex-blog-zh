<html>
<head>
<title>Certificate verification in Dev for .Net</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发人员中的证书验证。网</h1>
<blockquote>原文：<a href="https://medium.com/codex/certificate-verification-in-dev-for-net-87f310dc5a3c?source=collection_archive---------5-----------------------#2022-11-03">https://medium.com/codex/certificate-verification-in-dev-for-net-87f310dc5a3c?source=collection_archive---------5-----------------------#2022-11-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="89e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">证书的主要功能是向其他人验证证书所有者的身份。web服务器证书基本上是颁发给web服务器<strong class="ih hj">的SSL证书，用于向客户端</strong>验证其身份。</p><p id="2389" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">英寸当我们向服务器发送web请求时，证书验证由操作系统和安全支持提供者接口(SSPI)共同完成。SSPI为安全的分布式应用程序提供了通用的行业标准接口。</p><p id="4315" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是有时(主要是在开发和测试中)我们想忽略这个验证，跳过它，不要让证书验证错误的请求失败。</p><p id="0b23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将向您展示实现这一目的的两个选项:</p><h2 id="c9b8" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">ServicePointManager</h2><p id="e494" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">此选项仅推荐用于。net框架(不要在。网芯)。</p><blockquote class="kd ke kf"><p id="a996" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">我们不建议您使用<code class="du kk kl km kn b">ServicePointManager</code>类进行新的开发。而是使用<a class="ae ko" href="https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=net-6.0" rel="noopener ugc nofollow" target="_blank">系统。Net.Http.HttpClient </a>类。</p></blockquote><figure class="kp kq kr ks fd kt"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="cd9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kk kl km kn b"><a class="ae ko" href="https://learn.microsoft.com/en-us/dotnet/api/system.net.servicepointmanager?view=net-6.0" rel="noopener ugc nofollow" target="_blank">ServicePointManager</a></code>是一个静态类，用于创建、维护和删除<code class="du kk kl km kn b"><a class="ae ko" href="https://learn.microsoft.com/en-us/dotnet/api/system.net.servicepoint?view=netframework-4.7.2" rel="noopener ugc nofollow" target="_blank">ServicePoint</a> </code>类的实例。</p><p id="d8ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，这将影响所有通过设置了<code class="du kk kl km kn b"><a class="ae ko" href="https://learn.microsoft.com/en-us/dotnet/api/system.net.servicepointmanager.servercertificatevalidationcallback?view=netframework-4.7.2#system-net-servicepointmanager-servercertificatevalidationcallback" rel="noopener ugc nofollow" target="_blank">ServerCertificateValidationCallback</a></code>的应用程序完成的web请求。</p><h2 id="f78c" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">HttpClientHandler</h2><p id="75c9" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">该选项与我们注入处理程序的特定<code class="du kk kl km kn b">HttpClient</code>相关，而不是与应用程序中的所有web请求相关。但是首先，让我们理解一个<code class="du kk kl km kn b">HttpClient</code>请求流的架构。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kw"><img src="../Images/401e4d42d7d4b2e43b0c51fc351ae2ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jGav7Xc4STI-iRweUtVHtA.png"/></div></div></figure><p id="1d82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个<code class="du kk kl km kn b">HttpClient </code>发送一个HTTP请求时，它通过消息处理器被处理。<em class="kg">消息处理器</em>是一个接收HTTP请求并返回HTTP响应的类。通常，一系列消息处理程序被链接在一起。第一个处理程序接收一个HTTP请求，进行一些处理，然后将请求交给下一个处理程序。在某些时候，响应被创建并返回到链上。<strong class="ih hj">这种模式被称为<em class="kg">委托</em>处理程序。</strong></p><p id="83a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kk kl km kn b">HttpClient</code>类使用消息处理器来处理请求。默认的处理程序是<code class="du kk kl km kn b"><strong class="ih hj">HttpClientHandler</strong></code>，它通过网络发送请求并从服务器获得响应。</p><p id="e603" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建<code class="du kk kl km kn b">HttpClient</code>时，有两个构造函数:</p><pre class="kp kq kr ks fd ld kn le lf aw lg bi"><span id="0d2a" class="jd je hi kn b fi lh li l lj lk">public HttpClient();</span><span id="ff18" class="jd je hi kn b fi ll li l lj lk">public HttpClient(HttpMessageHandler handler);</span></pre><p id="7dfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个构造函数创建了一个默认的<code class="du kk kl km kn b">HttpClientHandler</code>(从<code class="du kk kl km kn b">HttpMessageHandler</code>继承而来)，在第二个构造函数中我们可以注入一个<code class="du kk kl km kn b">HttpClientHandler</code> <strong class="ih hj">。</strong></p><p id="292a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<code class="du kk kl km kn b">HttpClientHandler</code>，我们可以设置一个回调方法来验证服务器证书，并通过返回<code class="du kk kl km kn b">true</code>来忽略验证。</p><figure class="kp kq kr ks fd kt"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="64ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将只影响这个<code class="du kk kl km kn b">HttpClient </code>实例发出的请求，而不是所有没有注入这个<code class="du kk kl km kn b">MessageHandler</code>的客户端。</p><h2 id="2ff1" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">其他用途</h2><p id="e506" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">我们可以使用所给出的每一个选项来不忽略验证，而是通过查看<a class="ae ko" href="https://learn.microsoft.com/en-us/dotnet/api/system.net.security.sslpolicyerrors?view=net-6.0" rel="noopener ugc nofollow" target="_blank"> SslPolicyErrors </a>参数并记录它，或者只是调试它，来获得关于证书验证失败原因的更多信息。请注意，验证失败的原因可能不止一个。</p><p id="4b72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将再次警告您，不建议在生产中干扰验证，您应该仅在开发阶段使用它。</p></div></div>    
</body>
</html>