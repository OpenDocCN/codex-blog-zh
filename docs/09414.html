<html>
<head>
<title>Drag-n-Drop with Vanilla JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用普通的JavaScript进行拖放</h1>
<blockquote>原文：<a href="https://medium.com/codex/drag-n-drop-with-vanilla-javascript-75f9c396ecd?source=collection_archive---------4-----------------------#2022-10-19">https://medium.com/codex/drag-n-drop-with-vanilla-javascript-75f9c396ecd?source=collection_archive---------4-----------------------#2022-10-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e376" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">简单的实际开发和示例</h2></div><p id="3971" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管听起来很可怕，JavaScript中的拖放功能并没有那么难。如果您对这种语言和文档对象模型(DOM)有基本的了解，那么本教程自然会向您走来。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/93a5565beea5bbd6f5a8afb5bd3d8e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nenhULXYOTgQ1uxv"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">肯尼·埃利亚松在<a class="ae kj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="68e9" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">入门指南</h1><p id="2d6d" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">让我们从一些样板HTML代码开始，我们将在整个会议中使用。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="d215" class="lm kl hi li b fi ln lo l lp lq">&lt;div class="container"&gt;<br/>  &lt;div class="draggable"&gt;I love HTML&lt;/div&gt;<br/>  &lt;div class="draggable"&gt;CSS is fun&lt;/div&gt;<br/>&lt;/div&gt;<br/>&lt;div class="container"&gt;<br/>  &lt;div class="draggable"&gt;JS is flaky&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="c324" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以随心所欲地设计这个。基本的想法是有两个独立的容器，其中有几个您希望拖动的子元素。</p><h1 id="b3f0" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">DnD的有利因素</h1><p id="db3d" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">注意: DnD是“拖放”的简称。</p><p id="405c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，元素不能自己拖放——废话。所以我们需要给每个元素附加一个属性。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="a7b6" class="lm kl hi li b fi ln lo l lp lq">&lt;div class="container"&gt;<br/>  &lt;div class="draggable" <strong class="li hj">draggable="true"</strong>&gt;I love HTML&lt;/div&gt;<br/>  &lt;div class="draggable" <strong class="li hj">draggable="true"</strong>&gt;CSS is fun&lt;/div&gt;<br/>&lt;/div&gt;<br/>&lt;div class="container"&gt;<br/>  &lt;div class="draggable" <strong class="li hj">draggable="true"</strong>&gt;JS is flaky&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="4691" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简单。我们现在已经告诉浏览器为拖放功能准备各自的元素。</p><h1 id="c584" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">可拖动元素上的触发事件</h1><p id="ac68" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">那么当元素开始拖动时应该执行什么代码呢？当用户放下元素时应该调用什么函数？我们用两个简单的事件监听器— <code class="du lr ls lt li b">dragstart</code>和<code class="du lr ls lt li b">dragend</code>配置可拖动元素。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="142d" class="lm kl hi li b fi ln lo l lp lq">// script.js</span><span id="8aa0" class="lm kl hi li b fi lu lo l lp lq">const draggables = document.querySelectorAll(".draggable")<br/>draggables.forEach(draggable =&gt; {<br/>  draggable.addEventListener("<strong class="li hj">dragstart</strong>", function() {<br/>    this.classList.add("dragging")<br/>  })</span><span id="b4d2" class="lm kl hi li b fi lu lo l lp lq">  draggable.addEventListener("<strong class="li hj">dragend</strong>", function() {<br/>    this.classList.remove("dragging")<br/>  })<br/>}</span></pre><p id="e8af" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，当用户正在拖动时，我是如何切换类名的。你可以使用CSS中的<code class="du lr ls lt li b">.draggable.dragging</code>选择器自由改变元素的样式。</p><h1 id="a2c8" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">将元素放入容器中</h1><p id="fb6c" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">现在，我们只能拖动元素，但不知道元素被放在哪里。我们现在需要在容器上集成这个功能。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="7248" class="lm kl hi li b fi ln lo l lp lq">const containers = document.querySelectorAll(".container")<br/>containers.forEach(container =&gt; {<br/>  container.addEventListener("<strong class="li hj">dragover</strong>", function() {<br/>    const draggedElement = document.querySelector(".dragging")<br/>    this.appendChild(draggedElement)<br/>  })<br/>})</span></pre><p id="5038" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当当前有一个元素被拖动到容器上时，触发<code class="du lr ls lt li b">dragover</code>函数。因为<code class="du lr ls lt li b">draggedElement</code>在DOM中只能有一个实例，所以对象先前的位置被删除。</p><h1 id="aa32" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">知道将元素放在哪里</h1><p id="0b9e" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">现在我们成功地将对象从一个地方迁移到另一个地方，我们只能将对象附加到容器的末尾；我们不一定希望如此。为了将对象放在两个不同对象的中间，我们需要计算元素的相对位置，并确定将子节点附加到容器中的什么位置。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="4779" class="lm kl hi li b fi ln lo l lp lq">const getDragAfterElement = (container, y) =&gt; {<br/>  const notDraggedCards =<br/>    [...container.querySelectorAll("<strong class="li hj">.card:not(.dragging)</strong>")]<br/>  <br/>  return notDraggedCards.reduce((closest, child) =&gt; {<br/>    const box = <strong class="li hj">child.getBoundingClientRect()</strong><br/>    const offset = y - box.top - box.height / 2</span><span id="ad61" class="lm kl hi li b fi lu lo l lp lq">    if (offset &lt; 0 &amp;&amp; offset &gt; closest.offset) {<br/>      return { offset, element: child }<br/>    } else return closest<br/>  }, { offset: Number.NEGATIVE_INFINITY }).element<br/>}</span></pre><p id="dfd8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们一行一行地分解这个函数。</p><ol class=""><li id="76fd" class="lv lw hi iz b ja jb jd je jg lx jk ly jo lz js ma mb mc md bi translated">我们正在检索当前没有被<strong class="iz hj">拖动的所有卡片。</strong></li><li id="9c40" class="lv lw hi iz b ja me jd mf jg mg jk mh jo mi js ma mb mc md bi translated">我们得到每个孩子的约束。</li><li id="e3f8" class="lv lw hi iz b ja me jd mf jg mg jk mh jo mi js ma mb mc md bi translated">利用指针的y值，我们测量从每个盒子的<em class="mj">水平中心</em>的距离。</li><li id="bb1c" class="lv lw hi iz b ja me jd mf jg mg jk mh jo mi js ma mb mc md bi translated">我们返回负的和最接近零的元素。</li></ol><p id="9d8a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们知道了我们的<code class="du lr ls lt li b">.dragging</code>在哪个元素的上面，我们可以将这个节点插入到容器中我们想要它的地方。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="6a9c" class="lm kl hi li b fi ln lo l lp lq">container.addEventListener("dragover", function(<strong class="li hj">e</strong>) {<br/>  const draggedElement = document.querySelector(".dragging")<br/>  const afterElement = <strong class="li hj">getDragAfterElement</strong>(container, e.clientY)</span><span id="e240" class="lm kl hi li b fi lu lo l lp lq">  if (afterElement == undefined)<br/>    this.appendChild(draggedElement) // add to the end<br/>  else<br/>    this.<strong class="li hj">insertBefore</strong>(draggedElement, afterElement)<br/>}</span></pre><p id="8855" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">瞧啊。我们已经非常容易地实现了DnD特性。</p><h1 id="3624" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">结论</h1><p id="6d4a" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">有时你可能认为一个特性很难实现，直到你学会如何去做。这段代码有很多改进，你可以即兴发挥。尝试各种风格，制作元素动画，与API交互，等等。</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="44ea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你喜欢读我的文章，并学到了一些东西。谢谢大家！✌️</p><p id="fd86" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">灵感来自<a class="ae kj" href="https://www.youtube.com/c/WebDevSimplified" rel="noopener ugc nofollow" target="_blank">来自网络开发简化版</a>的凯尔。</p><pre class="ju jv jw jx fd lh li lj lk aw ll bi"><span id="cf7a" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">Want to connect?</strong></span><span id="c29f" class="lm kl hi li b fi lu lo l lp lq">My <a class="ae kj" href="https://github.com/cybercoder-naj" rel="noopener ugc nofollow" target="_blank">GitHub</a> profile.<br/>My <a class="ae kj" href="https://cybercoder-naj.github.io" rel="noopener ugc nofollow" target="_blank">Portfolio</a> website.</span></pre></div></div>    
</body>
</html>