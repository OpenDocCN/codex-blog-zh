<html>
<head>
<title>Stock Trade Automation with Commodity Channel Index in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Python中的商品通道索引实现股票交易自动化</h1>
<blockquote>原文：<a href="https://medium.com/codex/automating-stock-trading-with-commodity-channel-index-in-python-212a5f996de3?source=collection_archive---------1-----------------------#2021-05-08">https://medium.com/codex/automating-stock-trading-with-commodity-channel-index-in-python-212a5f996de3?source=collection_archive---------1-----------------------#2021-05-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/6d6b0a115ca1d5a57a52d3a959ee1852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d4N3vScx_KeE_d4gTFrCBg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由<a class="ae hv" href="https://www.pexels.com/photo/white-and-black-magnifying-glass-on-white-paper-6120206/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的Nataliya Vaitkevich 拍摄</figcaption></figure><div class=""/><div class=""><h2 id="482a" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated">使用python中强大的技术指标，通过算法交易进行无缝股票交易的分步指南</h2></div><h1 id="6eb8" class="jn jo hy bd jp jq jr js jt ju jv jw jx je jy jf jz jh ka ji kb jk kc jl kd ke bi translated">介绍</h1><p id="28b2" class="pw-post-body-paragraph kf kg hy kh b ki kj iz kk kl km jc kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">随着技术发明越来越多，股票交易的方法也随之演变。当我们回顾遥远的过去，比如20世纪80年代，甚至90年代，华尔街看起来就像是交易员们忙碌的场所。我们几乎不能理解周围发生了什么，交易者会在他们之间大喊大叫，在拍卖中购买股票。你能相信股票是在拍卖会上买的吗？感谢研究人员和工程师，他们通过将股票市场引入技术世界，建立并改革了股票市场部门。</p><p id="ec8e" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">即使像高频交易平台这样的技术在一段时间内被引入，我们作为人类认为原始因素特别是情绪会影响交易，有时会导致巨大的损失。为了掩饰交易者考虑的这些个人因素，算法交易被引入。这个概念非常有效，深受交易者的喜爱。它只不过是创造了一个机器人来实现股票交易过程的自动化。这个机器人是由交易者创建和控制的，一旦给定的技术条件得到满足，它就会执行交易。举个例子，假设你正在编写一个股票交易程序。你给机器人的条件是，当股票价格低于250美元时，买入，同样，当股票价格高于400美元时，卖出。这只是算法交易如何工作的一个例子，实际上，考虑到效率水平，这些类型的条件不会被交易者通过。</p><p id="60fe" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">相反，他们使用一种叫做技术指标的工具来建立他们的条件或算法。有一篮子技术指标，但在本文中，我们将讨论一个特殊的指标，称为商品通道指数，简称CCI，以及如何用python实现它来交易股票。事不宜迟，让我们进入文章。</p><p id="3d87" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">在继续之前，如果你想在没有任何代码的情况下回溯测试你的交易策略，有一个解决方案。是<a class="ae hv" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">回测区</a>。这是一个平台，可以免费对不同类型的可交易资产的任意数量的交易策略进行回溯测试，无需编码。点击这里的链接，你可以马上使用这个工具:【https://www.backtestzone.com/<a class="ae hv" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="b1ca" class="jn jo hy bd jp jq jr js jt ju jv jw jx je jy jf jz jh ka ji kb jk kc jl kd ke bi translated">商品频道指数(CCI)</h1><p id="3f32" class="pw-post-body-paragraph kf kg hy kh b ki kj iz kk kl km jc kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">CCI是一个领先指标，衡量特定时期内当前价格与历史平均价格之间的差异，即当CCI的值显示极端正值时，则认为当前价格远高于历史平均价格。同样，当CCI的值显示极端负值时，则认为当前价格低于历史平均水平。从它的名字来看，人们可能会认为CCI只是用来交易商品的，但事实并非如此。它可以用于任何形式的市场交易，无论是股票还是外汇。CCI最一般的设置是20作为指定的周期数。以20为周期数计算CCI的公式可表示如下:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="f6ff" class="lp jo hy ll b fi lq lr l ls lt"><strong class="ll hz">CCI = (TP - SMA 20 OF TP) / (0.15 * MEAN DEVIATION)</strong></span><span id="6717" class="lp jo hy ll b fi lu lr l ls lt">where,<br/><strong class="ll hz">Typical Price (TP)</strong> = (HIGH + LOW + CLOSE) / 3<br/><strong class="ll hz">SMA 20 of TP</strong> = Typical Price / 20<br/><strong class="ll hz">Mean Deviation</strong> = Absolute values of Typical Price / 20</span></pre><p id="2cfc" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">该指标与其他领先指标不同，因为许多领先指标的值都在0到100之间，但CCI可以达到极值，就像一个无界振荡器。由于CCI的值不确定，交易者通过寻找价格反转的CCI的极值点来确定单个资产的超买和超卖水平。例如，想象外汇对欧元兑美元(EUR/USD)达到150的极端CCI水平，突然趋势发生变化(价格反转)，因此我们的欧元兑美元超买水平将是150。类似地，想象同样的货币对达到了-150的极端负CCI水平，突然趋势发生了变化，因此欧元兑美元的超卖水平将会是-150。这种确定超买和超卖水平的方法被称为反转策略。</p><p id="361c" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz">关于我们的交易策略:</strong>我们的交易策略将是一个反转策略，我们将分析脸书的CCI价值，并确定超买和超卖的水平。当脸书的前一个CCI值大于超卖水平，而当前的CCI值小于超卖水平时，该策略将显示买入信号。同样，当脸书的前CCI值小于超买水平，而当前CCI值大于超买水平时，该策略将显示卖出信号。我们的交易策略可以表述如下:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="bdb5" class="lp jo hy ll b fi lq lr l ls lt"><strong class="ll hz">IF PREVIOUS CCI &gt; OVERSOLD LEVEL AND CCI &lt; COVERSOLD LEVEL = BUY<br/>IF PREVIOUS CCI &lt; OVERBOUGHT LEVEL AND CCI &gt; COVERBOUGHT LEVEL = SELL</strong></span></pre><p id="3e97" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">现在我们已经了解了CCI的含义以及如何用它来建立交易策略。让我们使用Python来实现我们自己的基于CCI的交易策略，并对其进行回溯测试，看看它在现实市场中的表现如何。</p><p id="aa60" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">在继续之前，关于免责声明的一个注意事项:本文的唯一目的是教育人们，必须被视为一个信息，而不是投资建议等。</p><h1 id="93d3" class="jn jo hy bd jp jq jr js jt ju jv jw jx je jy jf jz jh ka ji kb jk kc jl kd ke bi translated">Python实现</h1><p id="7839" class="pw-post-body-paragraph kf kg hy kh b ki kj iz kk kl km jc kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">编码部分分为以下几个步骤:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6b92" class="lp jo hy ll b fi lq lr l ls lt"><strong class="ll hz">1. Importing Packages<br/>2. Extracting Data from Alpha Vantage<br/>3. Extracting the CCI values from Alpha Vantage<br/>4. CCI Plot<br/>5. Creating the Trading Strategy<br/>6. Plotting the Trading Lists<br/>7. Creating our Position<br/>8. Backtesting</strong></span></pre><p id="901f" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h2 id="b76a" class="lp jo hy bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">步骤1:导入包</h2><p id="bba4" class="pw-post-body-paragraph kf kg hy kh b ki kj iz kk kl km jc kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="05e5" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz"> Python实现:</strong></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="fc77" class="lp jo hy ll b fi lq lr l ls lt">import pandas as pd<br/>import numpy as np<br/>import requests<br/>from termcolor import colored as cl<br/>from math import floor<br/>import matplotlib.pyplot as plt</span><span id="3de2" class="lp jo hy ll b fi lu lr l ls lt">plt.rcParams[‘figure.figsize’] = (20, 10)<br/>plt.style.use(‘fivethirtyeight’)</span></pre><p id="1329" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">既然我们已经将所有基本的包导入到python环境中。让我们用Alpha Vantage强大的股票API提取脸书的历史数据。</p><h2 id="be02" class="lp jo hy bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">步骤2:从Alpha Vantage中提取数据</h2><p id="c70b" class="pw-post-body-paragraph kf kg hy kh b ki kj iz kk kl km jc kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在这一步，我们将使用Alpha Vantage提供的API端点提取脸书的历史数据。在此之前，关于Alpha Vantage的一个说明:Alpha Vantage提供免费的股票API，用户可以通过这些API访问各种数据，如实时更新，以及股票、货币和加密货币的历史数据。确保你在Alpha Vantage上有一个帐户，只有这样，你才能访问你的秘密API密匙(使用API提取数据的一个关键元素)。</p><p id="27dd" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz"> Python实现:</strong></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="f4bc" class="lp jo hy ll b fi lq lr l ls lt">def get_historical_data(symbol, start_date = None):<br/>    api_key = open(r'api_key.txt')<br/>    api_url = f'https://www.alphavantage.co/query?function=TIME_SERIES_DAILY_ADJUSTED&amp;symbol={symbol}&amp;apikey={api_key}&amp;outputsize=full'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df[f'Time Series (Daily)']).T<br/>    df = df.rename(columns = {'1. open': 'open', '2. high': 'high', '3. low': 'low', '4. close': 'close', '5. adjusted close': 'adj close', '6. volume': 'volume'})<br/>    for i in df.columns:<br/>        df[i] = df[i].astype(float)<br/>    df.index = pd.to_datetime(df.index)<br/>    df = df.iloc[::-1].drop(['7. dividend amount', '8. split coefficient'], axis = 1)<br/>    if start_date:<br/>        df = df[df.index &gt;= start_date]<br/>    return df<br/><br/>fb = get_historical_data('FB', '2020-01-01').iloc[:,:4]<br/>fb</span></pre><p id="f802" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz">输出:</strong></p><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mi"><img src="../Images/cbc5b77c87f71abf9592f908843afd05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I2J51C4eoM-uMfNS96FJgA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">作者图片</figcaption></figure><p id="f7a3" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz">代码解释:</strong>我们做的第一件事是定义一个名为‘get _ historical _ data’的函数，该函数将股票的符号(‘symbol’)作为必需参数，将历史数据的开始日期(‘start _ date’)作为可选参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们调用创建的函数来提取脸书从2020年开始的历史数据，并将其存储到“fb”变量中。</p><h2 id="7d1f" class="lp jo hy bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">步骤3:提取CCI值</h2><p id="db96" class="pw-post-body-paragraph kf kg hy kh b ki kj iz kk kl km jc kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在这一步中，我们将借助Alpha Vantage提供的API端点获取脸书的商品渠道指数值。这一步和我们上一步做的差不多。</p><p id="7ace" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz"> Python实现:</strong></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="5e60" class="lp jo hy ll b fi lq lr l ls lt">def get_cci(symbol, n, start_date):<br/>    api_key = open(r'api_key.txt')<br/>    url = f'https://www.alphavantage.co/query?function=CCI&amp;symbol={symbol}&amp;interval=daily&amp;time_period={n}&amp;apikey={api_key}'<br/>    raw = requests.get(url).json()<br/>    df = pd.DataFrame(raw['Technical Analysis: CCI']).T.iloc[::-1]<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    df = df.astype(float)<br/>    return df<br/><br/>fb['cci'] = get_cci('FB', 20, '2020-01-01')<br/>fb = fb.dropna()<br/>fb</span></pre><p id="4654" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz">输出:</strong></p><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mj"><img src="../Images/b3a8462f2b11710245e51863218d503d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qpaco5sAC1G8M1h5Qkdc1Q.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">作者图片</figcaption></figure><p id="72c6" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz">代码解释:</strong>首先，我们定义一个名为‘get _ cci’的函数，它将股票的符号(‘symbol’)、CCI的周期数(‘n’)和数据的开始日期(‘start _ date’)作为参数。在函数内部，我们首先分配两个名为“api_key”和“url”的变量，分别存储api键和API URL。使用Requests包提供的“get”函数，我们调用API并将响应存储到“raw”变量中。在做了一些数据操作后，我们返回CCI值。最后，我们调用这个函数来提取脸书的商品通道指数值。</p><h2 id="0080" class="lp jo hy bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">第四步:CCI情节</h2><p id="9045" class="pw-post-body-paragraph kf kg hy kh b ki kj iz kk kl km jc kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在这一步，我们将绘制提取的脸书商品通道指数值，以使其更有意义。这一部分的主要目的不是在编码部分，而是观察情节，以获得对商品渠道指数的坚实理解。</p><p id="68b1" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz"> Python实现:</strong></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="b3dd" class="lp jo hy ll b fi lq lr l ls lt">ax1 = plt.subplot2grid((10,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((10,1), (6,0), rowspan = 4, colspan = 1)<br/>ax1.plot(fb['close'])<br/>ax1.set_title('FACEBOOK SHARE PRICE')<br/>ax2.plot(fb['cci'], color = 'orange')<br/>ax2.set_title('FACEBOOK CCI 20')<br/>ax2.axhline(150, linestyle = '--', linewidth = 1, color = 'black')<br/>ax2.axhline(-150, linestyle = '--', linewidth = 1, color = 'black')<br/>plt.show()</span></pre><p id="3ef1" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz">输出:</strong></p><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mk"><img src="../Images/d29be8e9286f300974f53a8c2205ce51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5yHXrP5GnERQBMBEp-tdw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">作者图片</figcaption></figure><p id="3dba" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">上面的图表分为两个面板:上面的面板代表脸书的收盘价，下面的面板代表CCI值。作为领先指标，CCI不能绘制在与收盘价相同的面板上，因为指标值和收盘价相差很大。因此，它与收盘价(在我们的例子中低于收盘价)分开绘制。如你所见，CCI的值是如此的不确定，有时会达到极端值。你可以在CCI图上看到上下两条虚线，这是超买和超卖水平。确定波段水平是我们的选择，在我们的情况下，我们将超买水平设置为150，超卖水平设置为-150，即当CCI超过150时，股票被认为处于超买状态，同样，当CCI低于-150时，市场被认为处于超卖状态。我们将使用这些相同的水平来建立我们的交易策略。</p><h2 id="c316" class="lp jo hy bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">步骤5:创建交易策略</h2><p id="7dca" class="pw-post-body-paragraph kf kg hy kh b ki kj iz kk kl km jc kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在这一步，我们将在python中实现讨论过的CCI交易策略，超买和超卖水平分别为150和-150。</p><p id="c30a" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz"> Python实现:</strong></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="ef0c" class="lp jo hy ll b fi lq lr l ls lt">def implement_cci_strategy(prices, cci):<br/>    buy_price = []<br/>    sell_price = []<br/>    cci_signal = []<br/>    signal = 0<br/>    <br/>    lower_band = (-150)<br/>    upper_band = 150<br/>    <br/>    for i in range(len(prices)):<br/>        if cci[i-1] &gt; lower_band and cci[i] &lt; lower_band:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                cci_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                cci_signal.append(0)<br/>                <br/>        elif cci[i-1] &lt; upper_band and cci[i] &gt; upper_band:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                cci_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                cci_signal.append(0)<br/>                <br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            cci_signal.append(0)<br/>            <br/>    return buy_price, sell_price, cci_signal<br/><br/>buy_price, sell_price, cci_signal = implement_cci_strategy(fb['close'], fb['cci'])</span></pre><p id="4239" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz">代码解释:</strong>首先，我们定义一个名为‘implement _ cci _策略’的函数，它以股票价格(‘价格’)和CCI值(‘CCI’)作为参数。</p><p id="f42d" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">在这个函数中，我们创建了三个空列表(买入价格、卖出价格和cci信号),在创建交易策略时，这些值将被追加到这些列表中。</p><p id="e0a1" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">之后，我们通过for循环实施交易策略。在for循环内部，我们传递某些条件，如果条件得到满足，相应的值将被追加到空列表中。如果购买股票的条件得到满足，买入价将被追加到“buy_price”列表中，信号值将被追加为1，表示购买股票。类似地，如果卖出股票的条件得到满足，卖价将被追加到“sell_price”列表中，信号值将被追加为-1，表示卖出股票。</p><p id="484c" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">最后，我们返回附加了值的列表。然后，我们调用创建的函数并将值存储到各自的变量中。除非我们画出这些值，否则这个列表没有任何意义。所以，让我们画出创建的交易列表的值。</p><h2 id="f6e8" class="lp jo hy bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">步骤6:绘制交易信号</h2><p id="f2b5" class="pw-post-body-paragraph kf kg hy kh b ki kj iz kk kl km jc kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在这一步，我们将绘制已创建的交易列表，以使它们有意义。</p><p id="f9a2" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz"> Python实现:</strong></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="c643" class="lp jo hy ll b fi lq lr l ls lt">ax1 = plt.subplot2grid((10,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((10,1), (6,0), rowspan = 4, colspan = 1)<br/>ax1.plot(fb['close'], color = 'skyblue', label = 'FB')<br/>ax1.plot(fb.index, buy_price, marker = '^', markersize = 12, linewidth = 0, label = 'BUY SIGNAL', color = 'green')<br/>ax1.plot(fb.index, sell_price, marker = 'v', markersize = 12, linewidth = 0, label = 'SELL SIGNAL', color = 'r')<br/>ax1.set_title('FACEBOOK SHARE PRICE')<br/>ax1.legend()<br/>ax2.plot(fb['cci'], color = 'orange')<br/>ax2.set_title('FACEBOOK CCI 20')<br/>ax2.axhline(150, linestyle = '--', linewidth = 1, color = 'black')<br/>ax2.axhline(-150, linestyle = '--', linewidth = 1, color = 'black')<br/>plt.show()</span></pre><p id="8f90" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz">输出:</strong></p><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mk"><img src="../Images/204fa79ef1282a0607cd06c94d46d0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DTGSqz-lX8FW11mRhE_Q-A.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">作者图片</figcaption></figure><p id="6ace" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz">代码解释:</strong>我们在绘制商品通道指数值，以及交易策略产生的买入和卖出信号。我们可以观察到，只要CCI低于超卖水平，图表中就会出现绿色的买入信号。类似地，每当CCI越过超买水平时，图表中就会出现红色的卖出信号。</p><h2 id="1230" class="lp jo hy bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">步骤7:创建我们的职位</h2><p id="91ed" class="pw-post-body-paragraph kf kg hy kh b ki kj iz kk kl km jc kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在这一步中，我们将创建一个列表，如果我们持有股票，该列表将指示1；如果我们不拥有或持有股票，该列表将指示0。</p><p id="4809" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz"> Python实现:</strong></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="8358" class="lp jo hy ll b fi lq lr l ls lt">position = []<br/>for i in range(len(cci_signal)):<br/>    if cci_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(fb['close'])):<br/>    if cci_signal[i] == 1:<br/>        position[i] = 1<br/>    elif cci_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>cci = fb['cci']<br/>close_price = fb['close']<br/>cci_signal = pd.DataFrame(cci_signal).rename(columns = {0:'cci_signal'}).set_index(fb.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'cci_position'}).set_index(fb.index)<br/><br/>frames = [close_price, cci, cci_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy.head()</span></pre><p id="b716" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz">输出:</strong></p><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ml"><img src="../Images/03ccaabd022180600e9d04835c64483d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FTLumXFoLKDEFt3I2ZBISg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">作者图片</figcaption></figure><p id="0355" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz">代码解释:</strong>首先，我们创建一个名为‘position’的空列表。我们传递两个for循环，一个是为“位置”列表生成值，以匹配“信号”列表的长度。另一个for循环是我们用来生成实际位置值的循环。在第二个for循环中，我们对“signal”列表的值进行迭代，而“position”列表的值被附加到满足哪个条件上。如果我们持有股票，头寸的价值仍为1；如果我们卖出或不持有股票，头寸的价值仍为0。最后，我们正在进行一些数据操作，将所有创建的列表合并到一个数据帧中。</p><p id="ba3c" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">从显示的输出中，我们可以看到，在三行中，我们在股票中的头寸仍然是1(因为CCI信号没有任何变化)，但是当CCI信号代表卖出信号(-1)时，我们的头寸突然变成了0。我们的头寸将保持为0，直到交易信号发生一些变化。现在是时候实现一些回溯测试过程了！</p><h2 id="00b9" class="lp jo hy bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">步骤8:回溯测试</h2><p id="ac78" class="pw-post-body-paragraph kf kg hy kh b ki kj iz kk kl km jc kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在继续之前，有必要知道什么是回溯测试。回溯测试是查看我们的交易策略在给定股票数据上表现如何的过程。在我们的例子中，我们将对脸书股票数据的CCI交易策略实施回溯测试过程。</p><p id="92e6" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz"> Python实现:</strong></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="0f99" class="lp jo hy ll b fi lq lr l ls lt">fb_ret = pd.DataFrame(np.diff(fb['close'])).rename(columns = {0:'returns'})<br/>cci_strategy_ret = []<br/><br/>for i in range(len(fb_ret)):<br/>    returns = fb_ret['returns'][i]*strategy['cci_position'][i]<br/>    cci_strategy_ret.append(returns)<br/>    <br/>cci_strategy_ret_df = pd.DataFrame(cci_strategy_ret).rename(columns = {0:'cci_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/fb['close'][-1])<br/>cci_investment_ret = []<br/><br/>for i in range(len(cci_strategy_ret_df['cci_returns'])):<br/>    returns = number_of_stocks*cci_strategy_ret_df['cci_returns'][i]<br/>    cci_investment_ret.append(returns)<br/><br/>cci_investment_ret_df = pd.DataFrame(cci_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(cci_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = round((total_investment_ret/investment_value)*100, 2)<br/>print(cl('Profit gained from the CCI strategy by investing $100k in FB : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the CCI strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre><p id="4b8c" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz">输出:</strong></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="0ace" class="lp jo hy ll b fi lq lr l ls lt"><strong class="ll hz">Profit gained from the CCI strategy by investing $100k in FB : 16598.39</strong><br/><strong class="ll hz">Profit percentage of the CCI strategy : 16.6%</strong></span></pre><p id="2726" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated"><strong class="kh hz">代码解释:</strong>首先，我们使用NumPy包提供的‘diff’函数计算脸书股票的回报率，并将其作为dataframe存储到‘FB _ ret’变量中。接下来，我们将传递一个for循环来迭代“fb_ret”变量的值，以计算我们从CCI交易策略中获得的回报，这些回报值将被追加到“fb_strategy_ret”列表中。接下来，我们将把“CCI _策略_ret”列表转换成数据帧，并将其存储到“CCI _策略_ret_df”变量中。</p><p id="19fe" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">接下来是回溯测试过程。我们将通过投资10万美元到我们的交易策略中来回测我们的策略。首先，我们将投资金额存储到“投资值”变量中。之后，我们将使用投资金额计算我们可以购买的脸书股票数量。你可以注意到，我使用了Math软件包提供的“下限”函数，因为当投资金额除以脸书股票的收盘价时，它会输出一个十进制数。股票数量应该是整数，而不是小数。使用“底数”函数，我们可以去掉小数。请记住,“floor”函数比“round”函数要复杂得多。然后，我们传递一个for循环来寻找投资回报，随后是一些数据操作任务。</p><p id="295b" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">最后，我们打印了我们通过投资10万到我们的交易策略中得到的总回报，并且显示我们在一年中获得了大约16500美元的利润。那还不错！</p><h1 id="8d1b" class="jn jo hy bd jp jq jr js jt ju jv jw jx je jy jf jz jh ka ji kb jk kc jl kd ke bi translated">最后的想法！</h1><p id="6a55" class="pw-post-body-paragraph kf kg hy kh b ki kj iz kk kl km jc kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在前面很长的一段时间里，我们已经成功地研究了商品通道指数是什么，并且基于它的交易策略可以用python实现。但是，这篇文章仍有改进的空间:</p><ul class=""><li id="a04c" class="mm mn hy kh b ki lb kl lc ko mo ks mp kw mq la mr ms mt mu bi translated">风险管理:这是交易或投资要考虑的最重要的因素，必须采取一些措施来确保我们的交易被限制在特定的风险水平。承担风险的确是执行盈利交易的基本任务，但为了避免致命交易，在一定程度上保持这一点也同样重要。</li><li id="7594" class="mm mn hy kh b ki mv kl mw ko mx ks my kw mz la mr ms mt mu bi translated"><strong class="kh hz">策略调整:</strong>我们在本文中建立的交易策略可以被认为是最基本的，必须临时准备才能在现实市场中实施。使用算法交易进行股票交易的机构交易者通过结合各种相关特征和不同指标来过滤他们的策略，你也可以试试。我们没有涉及它，因为这篇文章的唯一目的只是教育人们CCI的含义。</li></ul><p id="43fe" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">还有一点我们在本文中没有给予更多的重视，那就是商品通道指数指标的数学部分。强烈建议仔细研究该指标背后的数学原理，因为这将有助于获得更多关于具体指标的知识，并将极大地帮助我们改进战略。此外，掌握指标背后的数学知识将帮助您增强信心，通过编程从头构建指标。所以，尽你最大的努力去跟进数学部分，即使我们在这篇文章中没有深入探讨。</p><p id="f1e5" class="pw-post-body-paragraph kf kg hy kh b ki lb iz kk kl lc jc kn ko ld kq kr ks le ku kv kw lf ky kz la hb bi translated">就是这样！您已到达文章结尾。希望你能从这篇文章中学到一些有用的东西。如果您忘记了遵循任何编码部分，不要担心。我在文章末尾提供了完整的源代码。</p><h2 id="64b1" class="lp jo hy bd jp lv lw lx jt ly lz ma jx ko mb mc jz ks md me kb kw mf mg kd mh bi translated">完整代码:</h2><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="d2f5" class="lp jo hy ll b fi lq lr l ls lt">import pandas as pd<br/>import requests<br/>import pandas_datareader as web<br/>import datetime as dt<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.rcParams['figure.figsize'] = (20, 10)<br/>plt.style.use('fivethirtyeight')<br/><br/>def get_historical_data(symbol, start_date = None):<br/>    api_key = open(r'api_key.txt')<br/>    api_url = f'https://www.alphavantage.co/query?function=TIME_SERIES_DAILY_ADJUSTED&amp;symbol={symbol}&amp;apikey={api_key}&amp;outputsize=full'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df[f'Time Series (Daily)']).T<br/>    df = df.rename(columns = {'1. open': 'open', '2. high': 'high', '3. low': 'low', '4. close': 'close', '5. adjusted close': 'adj close', '6. volume': 'volume'})<br/>    for i in df.columns:<br/>        df[i] = df[i].astype(float)<br/>    df.index = pd.to_datetime(df.index)<br/>    df = df.iloc[::-1].drop(['7. dividend amount', '8. split coefficient'], axis = 1)<br/>    if start_date:<br/>        df = df[df.index &gt;= start_date]<br/>    return df<br/><br/>fb = get_historical_data('FB', '2020-01-01')<br/>print(fb)<br/><br/>def get_cci(symbol, n, start_date):<br/>    api_key = open(r'api_key.txt')<br/>    url = f'https://www.alphavantage.co/query?function=CCI&amp;symbol={symbol}&amp;interval=daily&amp;time_period={n}&amp;apikey={api_key}'<br/>    raw = requests.get(url).json()<br/>    df = pd.DataFrame(raw['Technical Analysis: CCI']).T.iloc[::-1]<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    df = df.astype(float)<br/>    return df<br/><br/>fb['cci'] = get_cci('FB', 20, '2020-01-01')<br/>fb = fb.dropna()<br/>print(fb.tail())<br/><br/>ax1 = plt.subplot2grid((10,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((10,1), (6,0), rowspan = 4, colspan = 1)<br/>ax1.plot(fb['close'])<br/>ax1.set_title('FACEBOOK SHARE PRICE')<br/>ax2.plot(fb['cci'], color = 'orange')<br/>ax2.set_title('FACEBOOK CCI 20')<br/>ax2.axhline(150, linestyle = '--', linewidth = 1, color = 'black')<br/>ax2.axhline(-150, linestyle = '--', linewidth = 1, color = 'black')<br/>plt.show()<br/><br/>def implement_cci_strategy(prices, cci):<br/>    buy_price = []<br/>    sell_price = []<br/>    cci_signal = []<br/>    signal = 0<br/>    <br/>    lower_band = (-150)<br/>    upper_band = 150<br/>    <br/>    for i in range(len(prices)):<br/>        if cci[i-1] &gt; lower_band and cci[i] &lt; lower_band:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                cci_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                cci_signal.append(0)<br/>                <br/>        elif cci[i-1] &lt; upper_band and cci[i] &gt; upper_band:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                cci_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                cci_signal.append(0)<br/>                <br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            cci_signal.append(0)<br/>            <br/>    return buy_price, sell_price, cci_signal<br/><br/>buy_price, sell_price, cci_signal = implement_cci_strategy(fb['close'], fb['cci'])<br/><br/>ax1 = plt.subplot2grid((10,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((10,1), (6,0), rowspan = 4, colspan = 1)<br/>ax1.plot(fb['close'], color = 'skyblue', label = 'FB')<br/>ax1.plot(fb.index, buy_price, marker = '^', markersize = 12, linewidth = 0, label = 'BUY SIGNAL', color = 'green')<br/>ax1.plot(fb.index, sell_price, marker = 'v', markersize = 12, linewidth = 0, label = 'SELL SIGNAL', color = 'r')<br/>ax1.set_title('FACEBOOK SHARE PRICE')<br/>ax1.legend()<br/>ax2.plot(fb['cci'], color = 'orange')<br/>ax2.set_title('FACEBOOK CCI 20')<br/>ax2.axhline(150, linestyle = '--', linewidth = 1, color = 'black')<br/>ax2.axhline(-150, linestyle = '--', linewidth = 1, color = 'black')<br/>plt.show()<br/><br/>position = []<br/>for i in range(len(cci_signal)):<br/>    if cci_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(fb['close'])):<br/>    if cci_signal[i] == 1:<br/>        position[i] = 1<br/>    elif cci_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>cci = fb['cci']<br/>close_price = fb['close']<br/>cci_signal = pd.DataFrame(cci_signal).rename(columns = {0:'cci_signal'}).set_index(fb.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'cci_position'}).set_index(fb.index)<br/><br/>frames = [close_price, cci, cci_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>print(strategy.head())<br/><br/>fb_ret = pd.DataFrame(np.diff(fb['close'])).rename(columns = {0:'returns'})<br/>cci_strategy_ret = []<br/><br/>for i in range(len(fb_ret)):<br/>    returns = fb_ret['returns'][i]*strategy['cci_position'][i]<br/>    cci_strategy_ret.append(returns)<br/>    <br/>cci_strategy_ret_df = pd.DataFrame(cci_strategy_ret).rename(columns = {0:'cci_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/fb['close'][-1])<br/><br/>cci_investment_ret = []<br/><br/>for i in range(len(cci_strategy_ret_df['cci_returns'])):<br/>    returns = number_of_stocks*cci_strategy_ret_df['cci_returns'][i]<br/>    cci_investment_ret.append(returns)<br/><br/>cci_investment_ret_df = pd.DataFrame(cci_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(cci_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = round((total_investment_ret/investment_value)*100, 2)<br/><br/>print(cl('Profit gained from the CCI strategy by investing $100k in FB : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the CCI strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre></div></div>    
</body>
</html>