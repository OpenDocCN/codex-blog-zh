<html>
<head>
<title>Creating Middleware with httprouter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用httprouter创建中间件</h1>
<blockquote>原文：<a href="https://medium.com/codex/creating-middleware-with-httprouter-52cbc786b02a?source=collection_archive---------4-----------------------#2021-08-09">https://medium.com/codex/creating-middleware-with-httprouter-52cbc786b02a?source=collection_archive---------4-----------------------#2021-08-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d92dd167ffcb2eef9fe6ed96884851a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MlkOkFC77GxkFNVKKkZj5A.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@reskp?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">贾梅特琳·雷斯克</a>在<a class="ae iu" href="https://unsplash.com/s/photos/directions?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="908e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Go中使用基于HTTP的服务时，许多开发人员(包括我自己)喜欢使用HTTP多路复用器(mux)。多路复用器，有时也称为请求路由器，提供一系列特性和功能。最简单的形式允许用户用特定的URL模式和方法注册特定的处理函数。</p><p id="a332" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更高级的特性之一是使用HTTP多路复用器来创建“HTTP中间件”此功能允许用户在请求路由到用户定义的处理程序之前创建一个标准函数或一组已执行的函数。开发人员可以使用这些通用函数来执行许多任务，从创建标准日志程序到处理身份验证。</p><p id="ca71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天的文章将探索使用httprouter HTTP多路复用器来创建一个简单的HTTP中间件。</p><h1 id="4df3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">为什么是httprouter</h1><p id="17a1" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">有许多可用的多路复用器，常见的有<a class="ae iu" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank"> Gorilla Mux </a>、<a class="ae iu" href="https://github.com/julienschmidt/httprouter" rel="noopener ugc nofollow" target="_blank"> httprouter </a>和<a class="ae iu" href="https://github.com/go-zoo/bone" rel="noopener ugc nofollow" target="_blank"> Bone </a>。对于本文，我将探索httprouter，我经常使用它，因为我喜欢它的简单和高效。还因为有一个版本同时适用于<code class="du kw kx ky kz b">net/http</code>和<code class="du kw kx ky kz b">fasthttp</code>。我在我的各种项目中使用了这两个HTTP包。不管我使用哪一个，只要有一个HTTP多路复用器就可以使用，这有助于保持简单。</p><h1 id="99e4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">httprouter入门</h1><p id="f6f4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在开始创建HTTP中间件功能之前，我们应该首先从使用httprouter的基础开始。我们可以看看打印“Hello World”的最基本的HTTP服务来启动我们。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="a18f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码只使用了标准的<code class="du kw kx ky kz b">net/http</code>和带有标准库的默认mux。Go的一个好处是，如果您要构建基本的基于HTTP的服务，您只需要标准库。</p><p id="1b9b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是对于这篇文章，我们想做一些更高级的东西；我们希望在HTTP处理程序之前执行一个标准的HTTP中间件。</p><p id="8595" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们将httprouter添加到这个组合中。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="bd15" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上面的代码示例中可以看出，我们对代码做了一些修改。首先要调用的是，我们没有使用<code class="du kw kx ky kz b">http.HandleFunc()</code>来注册我们的<code class="du kw kx ky kz b">handler</code>函数，而是创建了一个<code class="du kw kx ky kz b">httprouter.Router</code>,并用它来为<code class="du kw kx ky kz b">/hello</code>端点注册我们的<code class="du kw kx ky kz b">handler</code>函数。</p><p id="e5f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">敏锐的眼睛可能还会注意到，使用httprouter，我们可以在不同的HTTP方法下注册我们的函数。这个特性是httprouter优于默认标准库的优秀特性之一。使用httprouter，用户可以为不同的HTTP方法注册不同的函数。在我们的示例中，在GET之外的任何方法下服务于<code class="du kw kx ky kz b">/hello</code>路由都没有意义。</p><p id="c025" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了注册<code class="du kw kx ky kz b">handler</code>函数的方式发生了变化，值得一提的是<code class="du kw kx ky kz b">handler</code>函数的签名也发生了变化。现在，除了标准的<code class="du kw kx ky kz b">http.ResponseWriter</code>和<code class="du kw kx ky kz b">http.Request</code>类型，我们的函数还接收了一个<code class="du kw kx ky kz b">httprouter.Params</code>类型。</p><p id="f6cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用httprouter，更高级的特性之一是参数化URI的能力。例如，我们可以注册<code class="du kw kx ky kz b">/hello/:name</code>，而不是注册<code class="du kw kx ky kz b">/hello</code>。我们可以要求用户在URI中输入他们的名字，比如<code class="du kw kx ky kz b">/hello/ben</code>。然后，我们可以使用提供给处理程序的<code class="du kw kx ky kz b">httprouter.Params</code>来访问该参数。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="ed73" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在有了一个使用httprouter的完全正常工作的HTTP服务；我们可以从这里开始创建我们的中间件功能。</p><h1 id="0255" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">创建我们的HTTP中间件</h1><p id="32e0" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对于本文，我们将创建一个基本的日志中间件。这个中间件旨在创建HTTP请求的一致日志，而不管HTTP处理程序执行什么。这意味着在我们的<code class="du kw kx ky kz b">handler()</code>函数执行之前，我们希望我们的中间件先运行。</p><p id="aca7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将通过创建一个包装器函数，然后在我们的<code class="du kw kx ky kz b">handler()</code>注册调用中包含这个包装器函数来实现这一点。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="9012" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上图中，我们可以看到我们的包装函数<code class="du kw kx ky kz b">middleware()</code>现在正和<code class="du kw kx ky kz b">handler()</code>函数一起注册。这种技术的名称是链接；通过用<code class="du kw kx ky kz b">middleware()</code>函数包装<code class="du kw kx ky kz b">handler()</code>函数，我们将两个函数链接在一起。首先执行<code class="du kw kx ky kz b">middleware()</code>函数，最后，<code class="du kw kx ky kz b">middleware()</code>函数本身调用我们的<code class="du kw kx ky kz b">handler()</code>函数。</p><p id="56aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">至此，我们有了一个由httprouter支持的工作的HTTP中间件。对于我们拥有的每个自定义处理程序，我们可以使用这个HTTP中间件来保持一致的日志。但是非定制处理程序呢？像<a class="ae iu" href="https://pkg.go.dev/net/http/pprof" rel="noopener ugc nofollow" target="_blank"> PProf </a>这样用标准HTTP签名构建处理程序的东西呢？</p><h1 id="728f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">向HTTP中间件注册非定制处理程序</h1><p id="4b92" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">PProf等库的一个常见做法是提供HTTP处理程序作为包接口的一部分。<code class="du kw kx ky kz b">net/http/pprof</code>包有几个遵循标准<code class="du kw kx ky kz b">net/http</code>方法签名的函数。诸如Index和Profile之类的函数，Index处理<code class="du kw kx ky kz b">/debug/pprof/</code>端点，Profile服务于<code class="du kw kx ky kz b">/debug/pprof/profile</code> CPU分析端点。</p><p id="1dc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">问题是这些函数只接受两个输入，<code class="du kw kx ky kz b">http.ResponseWriter</code>和<code class="du kw kx ky kz b">http.Request</code>。它们与我们的HTTP中间件的签名不匹配，但是我们仍然希望将我们的中间件用于这些功能。</p><p id="14af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">幸运的是，我们可以。使用<code class="du kw kx ky kz b">http.HanderFunc()</code>适配器，我们可以将这些功能转换成<code class="du kw kx ky kz b">http.Handler</code>的功能。然后，我们可以使用另一个小包装器将这个<code class="du kw kx ky kz b">http.Handler</code>与我们的中间件包装在一起。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="3a99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上面的代码中我们可以看到，我们添加了一个输入为<code class="du kw kx ky kz b">http.Handler</code>的<code class="du kw kx ky kz b">wrapper()</code>函数，这个包装函数正在用我们的中间件包装一个运行<code class="du kw kx ky kz b">http.Handler.ServeHTTP()</code>的匿名函数。</p><p id="9491" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过添加这个<code class="du kw kx ky kz b">wrapper()</code>函数，我们现在可以在任何标准的HTTP处理程序上引入我们的HTTP中间件，不管它是来自PProf还是其他库。</p><p id="7d8b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经定义了<code class="du kw kx ky kz b">wrapper()</code>函数，让我们继续添加PProf的其余部分。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="7267" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，敏锐的眼睛可能注意到在注册<code class="du kw kx ky kz b">/debug/pprof</code>路径的中途，我们停止使用<code class="du kw kx ky kz b">http.HandlerFunc()</code>适配器。相反，我们注册了一个带有各种参数的<code class="du kw kx ky kz b">pprof.Handler()</code>函数。通过返回一个<code class="du kw kx ky kz b">http.Handler</code>类型的<code class="du kw kx ky kz b">pprof.Handler()</code>函数，PProf包满足了一些路径。</p><h1 id="1852" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">摘要</h1><p id="2d4f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">有了以上内容，我们就有了一个简单的hello world应用程序，它展示了用httprouter创建HTTP中间件功能是多么容易。我们还可以看到如何使用这个中间件，甚至是PProf这样的包，其中HTTP处理程序使用不同的签名。</p><p id="c054" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您构建一个包含许多路由和不同处理程序的复杂服务，那么诸如httprouter这样的路由器可能是一个很好的工具。但是Go最好的一点是，如果你需要做的只是简单的HTTP服务，除了标准库之外，你不需要太多。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><p id="2b69" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ln">原载于</em><a class="ae iu" href="https://bencane.com/2021/09/08/creating-middleware-with-httprouter-a-golang-multiplexer/" rel="noopener ugc nofollow" target="_blank"><em class="ln"/></a><em class="ln">。</em></p></div></div>    
</body>
</html>