<html>
<head>
<title>Creating a ClojureScript App for the First Time — Pt. 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第一次创建ClojureScript App—Pt。一</h1>
<blockquote>原文：<a href="https://medium.com/codex/creating-a-clojurescript-spa-for-the-first-time-pt-1-d3012c42e622?source=collection_archive---------8-----------------------#2021-04-02">https://medium.com/codex/creating-a-clojurescript-spa-for-the-first-time-pt-1-d3012c42e622?source=collection_archive---------8-----------------------#2021-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5d02" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解堆栈并构建项目的基础</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d45de58014c73f709b96e57af33217bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Crk3PubhVWi0xwbQ"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Jaanus jagomgi在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="475b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">几年前，当我了解Nubank背后的技术时，我遇到了Clojure。尽管那时我已经有了几年的经验，但在那天之前我从未接触过任何Lisp语言。它最初令人困惑但却美丽的语法吸引了我，它本质上散发着简单。</p><p id="f92a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，从那以后，我只在Clojure上了一些速成课程，看了许多T4的演讲和YouTube视频。除此之外，缺乏关于应用程序开发的好教程和文档使得人们很难开始深入研究这个生态系统。正因为如此，我从未尝试在项目中应用它。</p><p id="0b62" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">直到现在。</p><p id="6eb4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">几周前，我决定深入Clojure生态系统，从头开始构建一个应用程序。本文是我在Clojure(脚本)的括号海洋中的冒险经历的第一部分。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="6d6c" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">应用程序</h1><p id="cc0c" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">考虑到我将学习一门新的语言、工作流程和框架，我决定最好使用一个至少有一些基本UI原型的项目；这样我就可以专注于重要的事情。</p><p id="c6c1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">去年，我参加了一个来自Rocketseat的Node.js/ReactJS/React本地训练营，我们参与的一个项目是名为GoFinance的财务管理系统。它非常简单和漂亮，非常适合我移植到ClojureScript。</p><p id="ce15" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">也就是说，我已经改了名字，改变了调色板，增加了一些额外的功能。GoBudget诞生了:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lq"><img src="../Images/710f8347aa2dd14215f8eac9dcaa62a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyRUxflxnNiok8SCFfUqIw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">主页。摘自我的Figma文件:)</figcaption></figure><p id="4b36" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">背后的想法是非常简单的。当您添加新的事务时:它们被推送到列表中；重新计算所有值；生活还在继续。对于第一个ClojureScript项目来说没有什么复杂的。</p><p id="b1ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它还包含一个简单的个人资料，注册和登录页面。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/005188ebc6045dd95e2232cafb34f03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jadf6fYm6Wp5Lui6p421QQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">一个<strong class="bd kt">非常</strong>的基本个人资料页面。摘自我的Figma文件:)</figcaption></figure><h1 id="87ff" class="kr ks hi bd kt ku ls kw kx ky lt la lb io lu ip ld ir lv is lf iu lw iv lh li bi translated">堆栈</h1><p id="6231" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">作为一个React用户，这个决定有点简单:我决定用Reagent + Re-frame。试剂如其<a class="ae jn" href="http://reagent-project.github.io" rel="noopener ugc nofollow" target="_blank"> github页面</a>所述:</p><p id="70c3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="lx">“…</em><a class="ae jn" href="https://github.com/clojure/clojurescript" rel="noopener ugc nofollow" target="_blank"><em class="lx">ClojureScript</em></a><em class="lx">和</em><a class="ae jn" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"><em class="lx">React</em></a><em class="lx">之间的极简接口。它允许你只使用简单的ClojureScript函数和数据来定义高效的React组件，这些函数和数据使用类似于</em><a class="ae jn" href="https://github.com/weavejester/hiccup" rel="noopener ugc nofollow" target="_blank"><em class="lx">Hiccup</em></a><em class="lx">的语法来描述你的UI。</em></p><p id="c0a7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Reagent的目标是使用几个基本概念来定义任意复杂的用户界面，并且在默认情况下足够快以至于你很少需要考虑性能。”</p><p id="27cb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">事实证明，有时候，因为ClojureScript利用了令人敬畏的<a class="ae jn" href="https://developers.google.com/closure/compiler/" rel="noopener ugc nofollow" target="_blank"> Google的闭包编译器，</a>一个试剂项目可以比React本身更小更快。🚀</p><p id="b416" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="https://day8.github.io/re-frame/" rel="noopener ugc nofollow" target="_blank">不要忘记重新帧:</a></p><p id="0474" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="lx">..是用于构建用户界面的ClojureScript框架。它有</em> <strong class="jq hj"> <em class="lx">面向数据，功能设计</em> </strong> <em class="lx">。它的主要焦点是程序员的高生产率和扩展到更大的单页应用程序。</em></p><p id="f2af" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="lx">虽然重新帧利用了React(通过试剂)，但它只需要React成为MVC中的V，仅此而已。re-frame走了一条不同的路，与当前流行的观点不同，即视图应该是因果的(协同定位查询、组件装载、钩子等)。在re-frame中，事件是因果的，</em> <strong class="jq hj"> <em class="lx">视图是纯反应的。</em></strong><em class="lx"/></p><p id="f207" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以，它是关于<code class="du ly lz ma mb b">data</code>和转换该数据的<code class="du ly lz ma mb b">functions</code>。而且，因为是<strong class="jq hj">反应式框架</strong>，<code class="du ly lz ma mb b">data</code>坐标<code class="du ly lz ma mb b">functions</code>，而不是反过来。</p><p id="7ec6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">喜悦的泪水从我的眼中滑落，🥳</p><h1 id="25ee" class="kr ks hi bd kt ku ls kw kx ky lt la lb io lu ip ld ir lv is lf iu lw iv lh li bi translated">ClojureScript SPA 101</h1><p id="e512" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">我必须说，由于我使用Clojure已经有一段时间了，我确实对它的基础有一些简单的了解；由于围绕Clojure(Script)语言有非常好的资源，我在这里的重点将放在理解如何用ClojureScript、Reagent和re-frame构建单页应用程序所必需的知识上。</p><h2 id="b982" class="mc ks hi bd kt md me mf kx mg mh mi lb jx mj mk ld kb ml mm lf kf mn mo lh mp bi translated">试剂</h2><p id="06df" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">React也有Jsx，它是Javascript的语法扩展，允许我们将“html”写入Javascript，Reagent使用Hiccup。Hiccup是一个在Clojure中表示HTML的库。它使用向量来表示元素，使用映射来表示元素的属性。</p><p id="4bac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与React的Jsx的主要区别在于Hiccup使用Clojure自己的数据结构来表示组件:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="744f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这只是一个Clojure向量，它将html标签<code class="du ly lz ma mb b">a</code>定义为一个关键字，同时使用Clojure映射来设置它的属性(在本例中是<code class="du ly lz ma mb b">href</code>和<code class="du ly lz ma mb b">onClick</code>)。</p><p id="ce20" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">同样，您可以使用Hiccup来组合html标签以形成更复杂的元素:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="b7e5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您甚至可以添加一些内联样式，或者稍后通过css使用类对其进行样式化:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="8fa2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">定义一个类有两种方法:要么使用Hiccup为我们提供的语法糖<code class="du ly lz ma mb b">:a.profile-avatar-link</code>，要么使用<code class="du ly lz ma mb b">:class</code>关键字；不过，后者更适合动态定义类。id属性也是如此:<code class="du ly lz ma mb b">:a#profile-avatar-link</code>将创建一个id为<code class="du ly lz ma mb b">profile-avatar-link.</code>的<code class="du ly lz ma mb b">a</code> html标签</p><p id="4c24" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">没有新的语言、模板或混合不同的结构来创建元素。这都是关于结合Clojure自己的数据结构。还有更多关于设置样式和组件的细节，但是我会在适当的时候再讨论。</p><p id="c12a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">除此之外，例如，对于表单的简单状态，我们根本不需要使用重新框架。相反，我们可以使用试剂自己版本的<code class="du ly lz ma mb b">atom</code>。它的工作方式类似于Clojure，只是在原子发生变化时添加了组件重新呈现功能:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="0eec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">柠檬榨汁机。</p><h2 id="ce18" class="mc ks hi bd kt md me mf kx mg mh mi lb jx mj mk ld kb ml mm lf kf mn mo lh mp bi translated">状态和重构</h2><p id="a871" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">应用程序的一个重要部分是它的状态和我们管理它的方式。多年来，React开发人员习惯于将状态保存在每个组件中，严重基于面向对象编程，使得应用程序状态分散在各处。</p><p id="2cf2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后Redux来了，把状态全局化，通过动作来管理。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/614bd81a37dd4537bf4995585f29220e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXnPmr-2VIFuRN361CCeYw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">摘自<a class="ae jn" href="https://www.youtube.com/watch?v=vK1DazRK_a0" rel="noopener ugc nofollow" target="_blank"> Rafal Dittwald的《用Clojure方法解决问题》</a></figcaption></figure><p id="e980" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">原来Redux背后的想法实际上来自于re-frame，这就是我要用来管理我们的应用程序状态。</p><p id="7b00" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">重建框架通过事件和订阅工作。每当我们需要改变我们的应用程序状态时，我们会分派一些事件来为我们做这件事。因此，如果应用程序的数据库是这样的:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="9095" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们有如下的事件处理程序和订阅者:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">不介意现在试着去理解这个。以后再详谈:)</figcaption></figure><p id="d8c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，我们可以调度事件并订阅数据库中的更改:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="9ecf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du ly lz ma mb b">:create-transaction</code>事件更新应用程序状态中的<code class="du ly lz ma mb b">:transaction-history</code>数据。事件会通知订阅该状态中特定信息的任何人，然后Reagent会重新呈现该组件。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="7ccb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，我们应用程序中的每个组件都是反应式的。</p><h1 id="da9d" class="kr ks hi bd kt ku ls kw kx ky lt la lb io lu ip ld ir lv is lf iu lw iv lh li bi translated">本地主机设置</h1><p id="fb1f" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">好吧，这就是事情变得棘手的地方。一开始你有很多选择。Clojure开发的圣杯是Emacs。作为一个刚开始接触Clojure世界的人，这让我害怕极了。我一生中从未使用过Emacs，那么学习一个新的工具会很麻烦。</p><p id="aa8f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">幸运的是，有一些不错的选择！就我而言，作为一名VSCode用户，我选择坚持使用它，并添加了一些不错的扩展:</p><ul class=""><li id="2fea" class="mt mu hi jq b jr js ju jv jx mv kb mw kf mx kj my mz na nb bi translated"><a class="ae jn" href="https://calva.io" rel="noopener ugc nofollow" target="_blank">卡尔瓦</a>，综合REPL。它包括内联代码评估、Paredit、代码格式化、测试运行器、语法高亮、<a class="ae jn" href="https://calva.io/linting/" rel="noopener ugc nofollow" target="_blank">林挺</a>等等；</li><li id="f67c" class="mt mu hi jq b jr nc ju nd jx ne kb nf kf ng kj my mz na nb bi translated"><a class="ae jn" href="https://marketplace.visualstudio.com/items?itemName=marcomorain.clojure-lint" rel="noopener ugc nofollow" target="_blank"> Clojure Lint: </a>这个扩展使用<a class="ae jn" href="https://github.com/clj-kondo/clj-kondo/blob/master/doc/install.md" rel="noopener ugc nofollow" target="_blank"> clj-kondo </a>对Clojure和EDN代码进行Lint。每当保存Clojure文件时，林挺将自动发生。</li><li id="5a2e" class="mt mu hi jq b jr nc ju nd jx ne kb nf kf ng kj my mz na nb bi translated"><a class="ae jn" href="https://marketplace.visualstudio.com/items?itemName=naumovs.color-highlight" rel="noopener ugc nofollow" target="_blank">颜色高亮:</a>好吧，我们将处理样式，所以没有比扩展更好的了。这个扩展设计了文档中的css/web颜色。</li></ul><p id="6cf8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">除此之外，我需要安装一个Java JDK和Node.js(以及相应的npm)。我已经用<a class="ae jn" href="https://sdkman.io" rel="noopener ugc nofollow" target="_blank"> sdkman </a>安装了openjdk的最新稳定版，超级推荐；以及通过<a class="ae jn" href="https://github.com/nvm-sh/nvm" rel="noopener ugc nofollow" target="_blank"> nvm </a>节点的LTS释放。</p><p id="a6cd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">差点忘了节目的主角:Clojure！让我们运行以下命令来安装CLI工具:</p><pre class="iy iz ja jb fd nh mb ni nj aw nk bi"><span id="ce21" class="mc ks hi mb b fi nl nm l nn no">$ brew install clojure/tools/clojure</span></pre><p id="614c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">PS:我用的是Mac OS。如果您想安装它，并且您正在使用另一个系统，请参考此处的<a class="ae jn" href="https://clojure.org/guides/getting_started" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ddaf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一切都准备好了，是时候开始动手编写代码了。</p><h1 id="ca1a" class="kr ks hi bd kt ku ls kw kx ky lt la lb io lu ip ld ir lv is lf iu lw iv lh li bi translated">设置项目</h1><p id="3ede" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">当我创建一个shadow-cljs应用程序时，有一个npm命令为我们引导一个项目:</p><pre class="iy iz ja jb fd nh mb ni nj aw nk bi"><span id="8137" class="mc ks hi mb b fi nl nm l nn no">$ npx create-cljs-app gobudget-web</span></pre><p id="9ce9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">完成后，我得到了一个类似这样的项目结构:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es np"><img src="../Images/6a5f1742ba9c45f73ae67e1563638e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*1Qlg9sLqmdiCbZ28E_fDmg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">初始项目文件夹结构</figcaption></figure><p id="5526" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">样板代码有助于您理解试剂是如何工作的，因此值得看一看。我开始着手清理这个项目。</p><h2 id="84c0" class="mc ks hi bd kt md me mf kx mg mh mi lb jx mj mk ld kb ml mm lf kf mn mo lh mp bi translated">清理东西</h2><p id="2fcb" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">我已经删除了<code class="du ly lz ma mb b">app</code>文件夹中除了<code class="du ly lz ma mb b">core.cljs</code>以外的所有文件；我也删除了<code class="du ly lz ma mb b">e2e</code>文件夹。这样我可以从一个几乎空的项目开始。</p><p id="a181" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<code class="du ly lz ma mb b">core.cljs</code>中，我删除了一些不必要的东西，所以我得到了这样一个文件:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="1661" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里要提到几件事:</p><ul class=""><li id="f2aa" class="mt mu hi jq b jr js ju jv jx mv kb mw kf mx kj my mz na nb bi translated"><code class="du ly lz ma mb b">^:export</code>是一种元数据，它使得主函数对javascript引擎可用。这样，应用程序可以从<code class="du ly lz ma mb b">index.html</code>文件中呈现出来。</li><li id="190d" class="mt mu hi jq b jr nc ju nd jx ne kb nf kf ng kj my mz na nb bi translated"><code class="du ly lz ma mb b">^:dev/after-load</code>是一个元数据，shadow-cljs使用它作为钩子，为我们的应用程序提供热重载功能。</li><li id="452b" class="mt mu hi jq b jr nc ju nd jx ne kb nf kf ng kj my mz na nb bi translated"><code class="du ly lz ma mb b">(:require [reagent.core :as r])</code>在核心名称空间中包含试剂，因此我们可以调用<code class="du ly lz ma mb b">r/render</code>将我们的应用程序呈现到DOM中。</li><li id="641b" class="mt mu hi jq b jr nc ju nd jx ne kb nf kf ng kj my mz na nb bi translated">当我们创建根组件时，我们的<code class="du ly lz ma mb b">r/render</code>调用中的<code class="du ly lz ma mb b">[]</code>将包含它。因此，reagent可以将我们的应用程序注入DOM。</li></ul><pre class="iy iz ja jb fd nh mb ni nj aw nk bi"><span id="6938" class="mc ks hi mb b fi nl nm l nn no">(r/render [app] (.getElementById js/document "app"))</span></pre><p id="447b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与以下内容非常相似:</p><pre class="iy iz ja jb fd nh mb ni nj aw nk bi"><span id="813f" class="mc ks hi mb b fi nl nm l nn no">ReactDOM.render(<br/>  &lt;App /&gt;<br/>  ,document.getElementById('app'),<br/>)</span></pre><p id="a466" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另外，我在app文件夹下创建了一个<code class="du ly lz ma mb b">db.cljs</code>文件。这个文件将包含我们的应用程序状态，这将通过重新构建事件来进一步管理。初始db将包含一些数据，因此我们可以在浏览器中可视化它们；但是现在，让我们只定义它的基本键:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="cb4c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们将一个组件传递给<code class="du ly lz ma mb b">r/render</code>试剂函数，这样我们终于可以在浏览器中看到一些东西了！创建一个名为<code class="du ly lz ma mb b">main.cljs</code>的新文件，内容如下:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="24db" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个文件在做什么非常清楚:</p><ul class=""><li id="52bb" class="mt mu hi jq b jr js ju jv jx mv kb mw kf mx kj my mz na nb bi translated">定义<code class="du ly lz ma mb b">app.main</code>名称空间；</li><li id="781a" class="mt mu hi jq b jr nc ju nd jx ne kb nf kf ng kj my mz na nb bi translated">创建一个名为root的函数，这是我们的第一个组件。它返回一个带有上面文本的<code class="du ly lz ma mb b">&lt;h1&gt;</code>标签。很酷吧。</li></ul><p id="5efb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，新文本需要在浏览器中呈现。为此，我将名称空间<code class="du ly lz ma mb b">app.main</code>导入到<code class="du ly lz ma mb b">core.cljs</code>中，通过使用<code class="du ly lz ma mb b">:refer</code>关键字引用我们的组件。然后，我将根组件作为参数传递给了<code class="du ly lz ma mb b">r/render</code>函数:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="e365" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在终端运行<code class="du ly lz ma mb b">npm start</code>，触发<code class="du ly lz ma mb b">shaddow-cljs watch app</code>命令；它构建我们的应用程序，启动应用程序，并持续监视我们的文件。这样，无论何时我做了更改，它都会自动重新加载我们的应用程序。</p><p id="d6f6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在浏览器中访问<code class="du ly lz ma mb b">http://localhost:3000/</code>应该会显示出文本:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nq"><img src="../Images/c824db8e9a8ac65b9573bbe25c65f30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*or2z52-COckn33zliChvLw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">厉害！</figcaption></figure><p id="dd01" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">更改文本会触发shadow-cljs自动构建应用程序并将其重新加载到浏览器上(不需要F5！).</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mq mr l"/></div></figure><pre class="iy iz ja jb fd nh mb ni nj aw nk bi"><span id="c8b9" class="mc ks hi mb b fi nl nm l nn no">[:app] Compiling ...<br/>[:app] Build completed. (154 files, 2 compiled, 0 warnings, 0.22s)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nq"><img src="../Images/48e1836cc6fec6cc8a2380f31f65db42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fceYeSamyfLKzzXmmaK_AQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">热重装起作用了！耶！🎉</figcaption></figure><h1 id="badf" class="kr ks hi bd kt ku ls kw kx ky lt la lb io lu ip ld ir lv is lf iu lw iv lh li bi translated">为即将到来的事情做准备</h1><p id="29b0" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">既然项目已经设置好了，下一步就是开始构建应用程序。我将为我们的应用程序创建一些基本页面，并讨论ClojureScript项目的文件夹结构:我所看到的和我决定坚持的。</p><p id="a85e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我还将使用CSS和Hiccup的内联样式做一些初步的实验。很多很酷的事情还在后面呢！</p><p id="bddf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">感谢您的到来！我会在我的ClojureScript冒险的下一章见到你！</p><p id="741f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">再见！✌🏽</p><h1 id="a604" class="kr ks hi bd kt ku ls kw kx ky lt la lb io lu ip ld ir lv is lf iu lw iv lh li bi translated">参考</h1><div class="nr ns ez fb nt nu"><a href="https://clojurescript.org" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab dw"><div class="nw ab nx cl cj ny"><h2 class="bd hj fi z dy nz ea eb oa ed ef hh bi translated">ClojureScript</h2><div class="ob l"><h3 class="bd b fi z dy nz ea eb oa ed ef dx translated">编辑描述</h3></div><div class="oc l"><p class="bd b fp z dy nz ea eb oa ed ef dx translated">clojurescript.org</p></div></div><div class="od l"><div class="oe l of og oh od oi jh nu"/></div></div></a></div><div class="nr ns ez fb nt nu"><a href="https://clojure.org" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab dw"><div class="nw ab nx cl cj ny"><h2 class="bd hj fi z dy nz ea eb oa ed ef hh bi translated">Clojure</h2><div class="ob l"><h3 class="bd b fi z dy nz ea eb oa ed ef dx translated">Clojure是一种动态的通用编程语言，结合了易用性和交互式开发…</h3></div><div class="oc l"><p class="bd b fp z dy nz ea eb oa ed ef dx translated">clojure.org</p></div></div><div class="od l"><div class="oj l of og oh od oi jh nu"/></div></div></a></div><div class="nr ns ez fb nt nu"><a href="http://reagent-project.github.io" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab dw"><div class="nw ab nx cl cj ny"><h2 class="bd hj fi z dy nz ea eb oa ed ef hh bi translated">试剂:对ClojureScript的最小反应</h2><div class="ob l"><h3 class="bd b fi z dy nz ea eb oa ed ef dx translated">试剂提供了ClojureScript和React之间的最小界面。它允许您定义有效的反应…</h3></div><div class="oc l"><p class="bd b fp z dy nz ea eb oa ed ef dx translated">reagent-project.github.io</p></div></div><div class="od l"><div class="ok l of og oh od oi jh nu"/></div></div></a></div><div class="nr ns ez fb nt nu"><a href="http://day8.github.io/re-frame/" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab dw"><div class="nw ab nx cl cj ny"><h2 class="bd hj fi z dy nz ea eb oa ed ef hh bi translated">重新框定</h2><div class="ob l"><h3 class="bd b fi z dy nz ea eb oa ed ef dx translated">用ClojureScript构建web应用程序，利用React。具有面向数据的功能设计。先进到足以拥有…</h3></div><div class="oc l"><p class="bd b fp z dy nz ea eb oa ed ef dx translated">第八天github.io</p></div></div></div></a></div><div class="nr ns ez fb nt nu"><a href="https://www.jacekschae.com" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab dw"><div class="nw ab nx cl cj ny"><h2 class="bd hj fi z dy nz ea eb oa ed ef hh bi translated">亚采克·沙</h2><div class="ob l"><h3 class="bd b fi z dy nz ea eb oa ed ef dx translated">编辑描述</h3></div><div class="oc l"><p class="bd b fp z dy nz ea eb oa ed ef dx translated">www.jacekschae.com</p></div></div></div></a></div><div class="nr ns ez fb nt nu"><a href="https://www.exoscale.com/syslog/single-page-application-with-clojurescript-and-reframe/" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab dw"><div class="nw ab nx cl cj ny"><h2 class="bd hj fi z dy nz ea eb oa ed ef hh bi translated">用ClojureScript和re-frame构建一个单页应用程序</h2><div class="ob l"><h3 class="bd b fi z dy nz ea eb oa ed ef dx translated">在这篇文章中，我们将讨论使用ClojureScript和re-frame来构建一个健壮的、可维护的…</h3></div><div class="oc l"><p class="bd b fp z dy nz ea eb oa ed ef dx translated">www.exoscale.com</p></div></div><div class="od l"><div class="ol l of og oh od oi jh nu"/></div></div></a></div></div></div>    
</body>
</html>