<html>
<head>
<title>The Server Structure — Making a MMO From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器结构——从零开始制作MMO</h1>
<blockquote>原文：<a href="https://medium.com/codex/making-a-mmo-from-scratch-the-server-structure-65ba6111b67f?source=collection_archive---------7-----------------------#2021-08-12">https://medium.com/codex/making-a-mmo-from-scratch-the-server-structure-65ba6111b67f?source=collection_archive---------7-----------------------#2021-08-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="32e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我着迷于MMO的，但从来没有真正发挥他们之前。我玩过一些PlanetSide 2，但那差不多涵盖了我对MMO的所有了解。</p><p id="c7b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我躺在床上思考一个游戏服务器如何处理大量的玩家，以及限制因素会是什么(这是一个入睡的好方法)。当我醒来时，这个想法仍然停留在我的脑海中，所以我决定在MMO服务器上读一点东西，这时候我决定做一个MMO。</p><p id="a846" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我不知道我想做什么游戏，但是一些服务器的东西很普通，所以为什么不从那里开始呢。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/88f45ce38059fe53145b5c8afe6974b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MfGjHJDZDO1I2jWT4eilKQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">希望不是运行我们MMO服务器所需的服务器机房…</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="e5f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像我说的，我没有任何编写MMO服务器的经验，事实上，除了标准的HTTP服务器，我没有任何编写任何类型的TCP/UDP服务器的经验。首先，我想开发一个小词典来描述服务器的不同部分。</p><p id="476a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务器将被分成3个部分(将来可能会更多？).服务器的3个部分被称为<strong class="ih hj">前端</strong><strong class="ih hj">后端</strong>和<strong class="ih hj">游戏状态</strong>。</p><p id="00bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">前端</strong>是客户端连接的地方，它包含UDP和TCP连接，以及反欺骗逻辑。前端要么直接更新游戏状态，要么向后端发送信息。当游戏状态发生变化时，更新客户端也是前端的工作。</p><p id="eab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">后端</strong>包含了所有的游戏逻辑。当一个敌人被杀死时，它会产生战利品。它运行所有的NPC/人工智能，并确保草生长和太阳移动。所有需要几百毫秒以上计算的东西都应该在后台运行。</p><p id="3619" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">游戏状态</strong>包含每个玩家、树、鱼或飞船的所有信息。游戏中的任何东西都处于游戏状态。游戏状态也可以用于在前端和后端之间，以及一个前端实例和其他实例之间推送消息。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ka"><img src="../Images/8f46b18cce86abe8c0e505c5e342fe5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ttlP-aLmOs1RbIGHHef3ow.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">游戏服务器(现在)</figcaption></figure><p id="8488" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“这怎么这么巧？”你可能会问。这是因为它可以利用横向扩展来适应巨大的玩家基础…至少在理论上…</p><p id="05bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个想法是，当玩家基数增长时，前端服务器的数量也会增长，如果后端被推得太远，也很容易扩展。最难衡量的是游戏状态。只有当所有后端实例和所有前端实例的游戏状态都相同时，水平缩放才有效。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kb"><img src="../Images/7dbc9d3cbbb9fd7ca9506c00f9820cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AnxP-T1UawJsHanY9Go1gg.png"/></div></div></figure><p id="8bd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在上面看到的，当更多的玩家连接时，我们可以实例化新的前端实例，当这些新玩家开始与NPC互动时，我们可以实例化更多的后端实例。我们无法衡量的是游戏状态。游戏状态可以简单地是一个MySQL数据库，但是因为很难扩展游戏状态，所以我们选择一个能够处理不同类型的压力的数据库是很重要的。</p><p id="c440" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据库应该能够:</p><ul class=""><li id="8b56" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kh ki kj kk bi translated">处理很多关系。</li><li id="2ad3" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">处理某种发布/订阅结构。</li><li id="3bdf" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">处理快速读写。</li><li id="c890" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kh ki kj kk bi translated">尽可能扩大规模。</li></ul><p id="8703" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们看起来像一个普通的SQL数据库，许多连接和Pub/Sub结构将会丢失(在大多数情况下),而且对普通数据库的读写(相对)很慢。这部分是由于大多数普通数据库读写磁盘。我们需要的是一个<strong class="ih hj">内存数据库</strong>。当数据存储在内存中时，读写速度要快得多。大多数内存数据库都有某种方法来扩展它们，而不只是向它们投入更多的计算。一种方法是使用读从节点，它总是与主节点保持同步。这使得在主节点上阅读更容易，主节点可以专注于写作。内存数据库的问题是它们有点贵，尤其是当我们有大量数据存储在内存中的时候。在电源故障或系统崩溃的情况下，这可能导致数据丢失。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="f604" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们来看看球员的移动。</p><p id="a6a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当玩家想要前进时，前端只需返回玩家的新位置，并更新游戏状态。游戏状态更新后，连接到前端实例的所有其他客户端都会收到一个包含新玩家实体位置的UDP数据包。然后后端会查看这个新的玩家位置，并检查玩家是否踩到了地雷(或类似的东西)。如果是这种情况，游戏状态将再次更新，一个新的数据包将被发送到所有监听客户端，他们应该会显示一个爆炸。简单的柠檬榨汁机…</p><ol class=""><li id="ea72" class="kc kd hi ih b ii ij im in iq ke iu kf iy kg jc kq ki kj kk bi translated">玩家移动。</li><li id="3cbd" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kq ki kj kk bi translated">前端更新游戏状态。</li><li id="5dfb" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kq ki kj kk bi translated">游戏状态推送新的数据实例。</li><li id="6c17" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kq ki kj kk bi translated">前端实例更新它们连接的客户端。</li><li id="8b16" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kq ki kj kk bi translated">后端实例检查地雷和更新游戏状态。</li><li id="74a7" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kq ki kj kk bi translated">游戏状态更新实例。</li><li id="196a" class="kc kd hi ih b ii kl im km iq kn iu ko iy kp jc kq ki kj kk bi translated">前端实例更新客户端发送爆炸。</li></ol><p id="5b4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每一步都是异步处理，由不同的实例处理。这意味着没有数据被保留等待新的信息。当玩家移动时，客户端在步骤2接收新玩家信息。在步骤4，其他玩家接收新玩家信息。这应该让游戏至少可以玩…</p><p id="dcec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在剩下要做的就是实施它…</p></div></div>    
</body>
</html>