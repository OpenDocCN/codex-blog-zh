<html>
<head>
<title>Writing a LISP-y JSON Interpreter in 115 lines of code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用115行代码编写一个LISP-y JSON解释器</h1>
<blockquote>原文：<a href="https://medium.com/codex/writing-a-lisp-y-json-interpreter-in-115-lines-of-code-862a4dd37cee?source=collection_archive---------25-----------------------#2021-08-09">https://medium.com/codex/writing-a-lisp-y-json-interpreter-in-115-lines-of-code-862a4dd37cee?source=collection_archive---------25-----------------------#2021-08-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="68b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几天前，我写了<a class="ae jd" href="https://github.com/mkhan45/javascripth" rel="noopener ugc nofollow" target="_blank">JavaScript</a>，这是一种使用JSON作为具体语法的lispy脚本语言。它是一个单相的treewalk解释器，所以它的抽象语法树也是JSON，但是从技术上讲，任何用JavaScript编写的解释器都是如此。下面是计算第10个斐波那契数的Javascripth代码示例:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/9bb3f2d06c76048853d9c7084b7953a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCjIN7mNRhC5JD2AHK5UvQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">用JavaScripth写的斐波那契</figcaption></figure><p id="968b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">挺难看的。超级慢。写它是痛苦的。但这是一种图灵完全编程语言，它的解释器只有大约一百行代码。</p><p id="33e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不记得我为什么决定写这个了。花了大约两个小时来编写解释器，然后又花了两个小时来编写Project Euler的第一个问题的解决方案。这没用，我可以用手更快地解决这个问题。不管怎样，考虑到它的紧凑性，我认为它是一个学习basic解释器的好例子。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="ba5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将从解释语言的规则开始:</p><ol class=""><li id="7552" class="kb kc hi ih b ii ij im in iq kd iu ke iy kf jc kg kh ki kj bi translated">程序是由JSON语句数组定义的，这些语句是按顺序计算的。</li><li id="b419" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">一个语句是一个JSON对象(字典/映射)或原子(数字、布尔值)，它可能有也可能没有副作用。</li><li id="119e" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">“表单”是一个JSON对象键值对。例如，在表达式{"+": [5，2]}中，"+"是形式(和函数)，[5，2]是参数列表</li><li id="98ee" class="kb kc hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">还有一些特殊的形式，包括“def”、“fn”等。如果表单不是其中之一，它将被视为函数调用</li></ol><p id="069a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">补充说明:通过JavaScript创建用户定义的表单可能非常简单，这将为该语言增加很多功能。</p><p id="d3bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们来看看解释器。几乎没有存储任何数据；只是一个包含全局变量的<code class="du kp kq kr ks b">state</code>字典。构造函数只是初始化一些内置函数。解释器的所有工作实际上都发生在<code class="du kp kq kr ks b">eval()</code>函数中。我将一个块一个块地研究这个函数。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><pre class="jf jg jh ji fd kt ks ku kv aw kw bi"><span id="14b7" class="kx ky hi ks b fi kz la l lb lc">if (typeof expr === 'number' || typeof expr === 'boolean') {<br/>            return expr;<br/>}<br/><br/>if (typeof expr === 'string') {<br/>    return this.state[expr];<br/>}<br/><br/>if (Array.isArray(expr)) {<br/>    return expr.map(s =&gt; this.eval(s));<br/>}</span></pre><p id="013f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些条件计算原子表达式。如果表达式是一个数字或布尔值，它已经被计算过了。如果它是一个字符串，它被当作一个全局变量从字典中取出，如果它是一个数组，数组中的每个表达式都被求值。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><pre class="jf jg jh ji fd kt ks ku kv aw kw bi"><span id="d73e" class="kx ky hi ks b fi kz la l lb lc">const res = Object.keys(expr).map(key =&gt; {<br/>    let args = expr[key];<br/>    ...<br/>})</span></pre><p id="e929" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果表达式是一个字典，则检查每个键，并让参数是与所述键对应的值。</p><pre class="jf jg jh ji fd kt ks ku kv aw kw bi"><span id="6b38" class="kx ky hi ks b fi kz la l lb lc">if (key === 'def') {<br/>    for (const name in args) {<br/>        this.state[name] = this.eval(args[name]);<br/>    }<br/>    return;<br/>}</span></pre><p id="a57c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个内置形式是' def '，用于定义全局变量。与其他形式不同，“def”使用一个字典作为其参数，其中每个键值对直接对应于全局变量字典。</p><pre class="jf jg jh ji fd kt ks ku kv aw kw bi"><span id="ce0f" class="kx ky hi ks b fi kz la l lb lc">if (key === 'fn') {<br/>    if (Array.isArray(args)) {<br/>        // contains argnames list<br/>        const [argnames, expr] = args;<br/>        const fn = new Fn(expr, argnames);<br/>        return fn.compile(this);<br/>    } else {<br/>        // only contains expr<br/>        const expr = args;<br/>        const fn = new Fn(expr);<br/>        return fn.compile(this);<br/>    }<br/>}</span></pre><p id="2975" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个内置形式是' fn '，用于定义匿名函数。有两种方法可以定义匿名函数；有参数名列表，其中参数必须作为列表传入，或者没有参数名列表，在这种情况下，传入参数字典。这用于命名变量和可选参数。由于有了<code class="du kp kq kr ks b">Fn</code>类，这段代码看似简单:</p><pre class="jf jg jh ji fd kt ks ku kv aw kw bi"><span id="2043" class="kx ky hi ks b fi kz la l lb lc">class Fn {<br/>    constructor(expr, argnames) {<br/>        this.expr = expr;<br/>        this.argnames = argnames;<br/>    }<br/><br/>    compile(interpreter) {<br/>        return args =&gt; {<br/>            if (this.argnames) {<br/>                let args_dict = {};<br/>                for (let i = 0; i &lt; this.argnames.length; i += 1) {<br/>                    const arg_name = this.argnames[i];<br/>                    const arg_val = args[i];<br/>                    args_dict[arg_name] = arg_val;<br/>                }<br/><br/>                args = args_dict;<br/>            }<br/><br/>            const new_interpreter = new Interpreter();<br/>            new_interpreter.state = {...interpreter.state, ...new_interpreter.state, ...args};<br/>            return new_interpreter.eval(this.expr);<br/>        }<br/>    }<br/>}</span></pre><p id="d86b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这看起来很简单，但是弄清楚函数是如何工作的花费了编写这个解释器的大部分时间。在此之前，肯定有几个不同的函数实现不起作用。代码本身相当简单。<code class="du kp kq kr ks b">compile()</code>实际上返回一个匿名函数，只有一个参数<code class="du kp kq kr ks b">args</code>。如果函数有<code class="du kp kq kr ks b">argnames</code>，那么必须使用一个参数列表按顺序调用它。在这种情况下，它通过将参数名和值压缩到一个字典中来为函数构造一个局部变量列表。如果函数没有<code class="du kp kq kr ks b">argnames</code>，这已经完成了。使用局部变量的字典，我们只需构造一个新的<code class="du kp kq kr ks b">Interpreter</code>实例，它的状态只是默认的，调用范围内的全局变量，然后是顶层的函数参数。最后，我们用这个新的范围计算表达式并返回它。这是解释器的核心，我怎么强调都不为过。没有突变，所以任何允许状态在某种意义上改变的事情都是通过函数来完成的。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><pre class="jf jg jh ji fd kt ks ku kv aw kw bi"><span id="9d7a" class="kx ky hi ks b fi kz la l lb lc">if (key === 'if') {<br/>    const cond = this.eval(args['cond']);<br/>    if (cond) {<br/>        return this.eval(args['then']);<br/>    } else {<br/>        return this.eval(args['else']);<br/>    }<br/>}<br/><br/>if (key === 'print') {<br/>    console.log(this.eval(args));<br/>    return;<br/>}</span></pre><p id="b1e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两种形式非常简单。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><pre class="jf jg jh ji fd kt ks ku kv aw kw bi"><span id="2375" class="kx ky hi ks b fi kz la l lb lc">if (args.map)<br/>    args = args.map(e =&gt; this.eval(e));<br/>else<br/>    args = this.eval(args);</span></pre><p id="fd7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这几行只是确保所有的参数在被传递到不应该被传递的地方之前都被正确地评估了。我很确定这在某些情况下是多余的，如果做得好的话，可能会让解释器快很多。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><pre class="jf jg jh ji fd kt ks ku kv aw kw bi"><span id="a481" class="kx ky hi ks b fi kz la l lb lc">if (key in this.state &amp;&amp; typeof this.state[key] === 'function') {<br/>    return this.state[key](args);<br/>}</span></pre><p id="f807" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果表单不是内置的，那么它一定是一个函数。这种语言中的函数只是匿名函数，所以我们可以正常地在参数字典上调用它。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="3dcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ld">原载于2021年8月9日</em><a class="ae jd" href="https://mkhan45.github.io/2021/08/09/json-interpreter.md.html" rel="noopener ugc nofollow" target="_blank"><em class="ld">https://mkhan 45 . github . io</em></a><em class="ld">。</em></p></div></div>    
</body>
</html>