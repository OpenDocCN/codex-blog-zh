<html>
<head>
<title>Analytics with SQL: Hunt for the nonexistent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL分析:寻找不存在的东西</h1>
<blockquote>原文：<a href="https://medium.com/codex/analytics-with-sql-hunt-for-the-nonexistent-27816d4d442f?source=collection_archive---------18-----------------------#2022-06-08">https://medium.com/codex/analytics-with-sql-hunt-for-the-nonexistent-27816d4d442f?source=collection_archive---------18-----------------------#2022-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="572a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">~使用SQL查找订阅者获取源</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ba22c148f5f271b7e102c60e6b35e7b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ria2rlkak2f1HQNF"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">沃洛季米尔·赫里先科在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="be92" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">背景故事:</h1><p id="3200" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">正如你从我以前的帖子中所知道的，我已经建立了一个邮件列表来推广我的<a class="ae jn" href="https://www.abwrites.blog/" rel="noopener ugc nofollow" target="_blank">博客</a>。在本系列的上一篇文章中，我们通过构建一个历史表来分析我的邮件列表行为，设计了一种通过数据回到过去的方法。这一次的计划是通过添加一些味道来扩展它，使我们能够回答这样的问题:人们如何看到我的邮件列表？是什么驱使他们订阅？如果他们重新订阅，是什么原因造成的？我们今天要做的事情看起来就像在黑暗中投掷飞镖，希望击中靶心，如果你问我，我认为这与生活非常相似。所以，提高你的目标，让我们开始吧！</p><h1 id="7c6c" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">问题:</h1><p id="dbb1" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">因此，上次我们能够构建自己的<em class="lc"> subscriber_feed_history </em>表，该表让我们能够深入了解用户每天的<em class="lc"> mailing_list_status </em>。现在，虽然这有助于确定用户在特定的一天是选择加入还是退出，但它并不能告诉我是什么驱使用户采取特定的行动。首先，我想知道是哪个来源导致用户订阅我的邮件列表。这有助于我选择合适的推广平台。</p><h1 id="2215" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">数据:</h1><p id="a9b8" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们从<em class="lc">subscriber _ feed _ history</em>表开始，我们在这里构建了<a class="ae jn" href="https://singhdoesdata.medium.com/analytics-with-sql-going-back-in-time-b2eeb819566a" rel="noopener">表，如下所示:</a></p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="a146" class="li jp hi le b fi lj lk l ll lm">+------+---------+---------------------+<br/>| date | user_id | mailing_list_status |<br/>+------+---------+---------------------+<br/>| 1/23 |     777 | I                   |<br/>| 1/15 |     123 | I                   |<br/>| 1/8  |     456 | I                   |<br/>| 1/4  |     789 | I                   |<br/>+------+---------+---------------------+</span></pre><p id="1655" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">我还能够使用类似的方法，从<em class="lc">点击流</em>数据中构建一个<em class="lc"> source_history </em>表，用于采集点击(类似于我们在这里使用的<a class="ae jn" rel="noopener" href="/@singhdoesdata/analytics-with-pandas-whats-working-2a29a8d70d07">)。此表是用户点击的历史记录，带有记录操作的源。该表如下所示:</a></p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="c26d" class="li jp hi le b fi lj lk l ll lm">+-------------+---------+-----------+<br/>| action_date | user_id |  source   |<br/>+-------------+---------+-----------+<br/>| 1/15        |     123 | LinkedIn  |<br/>| 1/7         |     456 | Medium    |<br/>| 1/3         |     456 | Direct    |<br/>| 1/3         |     789 | Instagram |<br/>| 1/1         |     789 | Twitter   |<br/>| 1/1         |     777 | Twitter   |<br/>+-------------+---------+-----------+</span></pre><p id="0a81" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">目的是使用这个<em class="lc"> source_history </em>来增强<em class="lc">subscriber _ feed _ history</em>的选择加入源信息，即用户是如何订阅的，或者他们是如何遇到我的博客的。此外，用户选择订阅可能有不同的原因，因此我们将尽最大努力捕捉这种效果。</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="d0fb" class="li jp hi le b fi lj lk l ll lm">+------+---------+--------+---------------+<br/>| date | user_id | status | opt_in_source |<br/>+------+---------+--------+---------------+<br/>| 1/23 |     777 | I      | ??            |<br/>| 1/15 |     123 | I      | ??            |<br/>| 1/8  |     456 | I      | ??            |<br/>| 1/4  |     789 | I      | ??            |<br/>+------+---------+--------+---------------+</span></pre><blockquote class="ls lt lu"><p id="45c7" class="kg kh lc ki b kj ln ij kl km lo im ko lv lp kr ks lw lq kv kw lx lr kz la lb hb bi translated">停下来。在阅读之前，我希望你在阅读我的方法之前，花些时间自己思考一下这个问题。</p></blockquote><h1 id="fc8d" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">我的方法:</h1><p id="e33c" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">处理用户数据的一个好方法是考虑<a class="ae jn" href="https://www.crazyegg.com/blog/customer-journey/" rel="noopener ugc nofollow" target="_blank">客户旅程</a>。在我们的例子中，有这样一个场景，一个用户在tweet上看到了我的博客，并决定查看一下。从这里开始，用户要么觉得我的博客有趣，要么决定订阅我的邮件列表。这里是“<em class="lc"> Twitter </em>将用户引向我的博客的地方，它将被视为选择加入的来源。</p><p id="be59" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">现在，要用数据实现这一点，最简单的方法是在<em class="lc">订阅者_订阅源_历史</em>和<em class="lc">来源_历史</em>之间的<em class="lc">用户_id </em>和<em class="lc">日期</em>上执行连接。这对于上面数据中的<em class="lc"> user_id=123 </em>非常有效，现在我们知道选择加入的来源是LinkedIn。</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="20e5" class="li jp hi le b fi lj lk l ll lm">+------+---------+---------------------+----------+<br/>| date | user_id | mailing_list_status |  source  |<br/>+------+---------+---------------------+----------+<br/>| 1/15 |     123 | I                   | LinkedIn |<br/>+------+---------+---------------------+----------+</span></pre><p id="44b5" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">然而，这对我们其他人没有帮助。所以让我们想想这种方法什么时候会失败。我可以考虑几个场景，比如用户在某一天看到博客，但决定在以后的某一天订阅邮件列表。这是另一个例子:一个用户在同一天通过多个来源看到这个博客，然后订阅。在这些情况下，所发生的是在<em class="lc">日期</em>字段上的连接导致了问题，因为这两个表中的日期可能不完全匹配，这看起来是上面大多数用户的情况。</p><p id="1d55" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">为了说明这一点，而不是加入期望精确匹配的<em class="lc">日期</em>字段，我们应该找到记录了与后续访问相对应的选择加入的最近日期。例如，对于在1月8日加入的<em class="lc"> user_id=456 </em>，这是两个表之间的连接:</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="a207" class="li jp hi le b fi lj lk l ll lm">+---------+-------------+--------+-------------+---------+<br/>| user_id | opt_in_date | status | action_date | source  |<br/>+---------+-------------+--------+-------------+---------+<br/>|     456 | 1/8         | I      | <strong class="le hj">1/7</strong>         | <strong class="le hj">Medium</strong>  |<br/>|     456 | 1/8         | I      | 1/3         | Direct  |<br/>+---------+-------------+--------+-------------+---------+</span></pre><p id="5134" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">在这里，我们可以清楚地说，1月8日的选择加入应归因于<em class="lc">媒介</em>，因为在1月7日有相应的访问。如果你想一想是什么让你打这个电话，是<em class="lc">选择_进入_日期</em>和<em class="lc">行动_日期</em> ( <em class="lc">增量</em>)之间的差异促使你做出决定。因此，实际上你正在寻找一个基于这个<em class="lc"> delta </em>的排名，这将有助于你进行匹配。</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="3687" class="li jp hi le b fi lj lk l ll lm">+---------+--------+--------+-------------+---------+-------+------+<br/>| user_id | opt_in | status | action_date | source  | delta | rank |<br/>+---------+--------+--------+-------------+---------+-------+------+<br/>|     456 | 1/8    | I      | <strong class="le hj">1/7 </strong>        | <strong class="le hj">Medium</strong>  |     <strong class="le hj">1</strong> |    <strong class="le hj">1</strong> |<br/>|     456 | 1/8    | I      | 1/3         | Direct  |     5 |    2 |<br/>+---------+--------+--------+-------------+---------+-------+------+</span></pre><p id="41f1" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">在你使用这个解决方案之前，让我们想一想这个问题会在哪里出现。让我们考虑一下<em class="lc"> user_id=777 </em>:</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="2ca7" class="li jp hi le b fi lj lk l ll lm">+---------+--------+--------+-------------+--------+-------+------+<br/>| user_id | opt_in | status | action_date | source | delta | rank |<br/>+---------+--------+--------+-------------+--------+-------+------+<br/>|     777 | 1/23   | I      | 1/1         | ??     |    22 |    1 |<br/>+---------+--------+--------+-------------+--------+-------+------+</span></pre><p id="6218" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">在这种情况下，用户在1号点击了一个博客，然后在近一个月后最终订阅了邮件列表。使用我们之前的方法，<em class="lc"> delta，在本例中为</em>，变成22天，假设这是唯一的访问，它的等级为1。所以你在这里说的是，用户订阅是因为一个月前与博客的互动。现在我不确定你的记忆力，但是我不能回忆起昨天在网上看到的东西，更不用说一个月了。这里我们想要限制<em class="lc">增量</em>以防止不正确的匹配。</p><p id="4722" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">让我们看看如何用代码写下来:</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="9375" class="li jp hi le b fi lj lk l ll lm">-- All opt-ins from subscriber history<br/>WITH subscriber_history AS (<br/>SELECT date AS opt_in_date, user_id<br/>FROM `<em class="lc">subscriber_feed_history`<br/></em>WHERE mailing_list_status = "I"<br/>GROUP BY date, user_id<br/>),</span><span id="cb5a" class="li jp hi le b fi ly lk l ll lm">-- User actions with source<br/>source_history AS (<br/>SELECT action_date, user_id, source<br/>FROM <em class="lc">source_history</em><br/>WHERE source &lt;&gt; "Direct"<br/>),</span><span id="e98e" class="li jp hi le b fi ly lk l ll lm">-- Delta calculation: (Opt-In date - Click date)<br/>subscriber_source_history AS (<br/>SELECT opt_in_date, user_id, source,<br/>DATE_DIFF(opt_in_date,action_date, DAY) AS delta<br/>FROM subscriber_history <br/>LEFT JOIN source_history <br/>USING(user_id)<br/>WHERE delta BETWEEN 0 AND 1<br/>)</span><span id="e509" class="li jp hi le b fi ly lk l ll lm">-- Getting the best match for the source of opt-in<br/>SELECT * EXCEPT(rnk)<br/>FROM (<br/>SELECT * EXCEPT(delta),<br/>RANK() OVER(PARTITION BY opt_in_date, user_id ORDER BY delta) AS rnk<br/>FROM subscriber_history_source<br/>) WHERE rnk = 1</span></pre><p id="d5c9" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">如果你想知道为什么<em class="lc">直接</em>来源被遗漏，阅读<a class="ae jn" href="https://useinsider.com/glossary/direct-traffic/#:~:text=Direct%20traffic%20is%20the%20amount,with%20no%20source%20or%20data." rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="94ba" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">现在，如果您对选择加入的源匹配率感到满意，您可以就此打住。如果你想要更好的匹配率，你可以试试上面的<em class="lc"> delta </em>。窗口越宽，匹配率越高，但匹配的可靠性越低。或者你可以继续阅读寻找不同的方法。</p><p id="875a" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">现在我想谈谈解决同一问题的另一种方法，它完全不依赖于日期。让我们考虑一个用户，他不确定自己是否真的想收到我的邮件，因此最终多次重新订阅。现在，对于每一次重新订阅，用户都以某种方式与博客互动，从而导致它。从点击流中，我们可以知道用户与博客互动的次数，而不考虑日期。因此，与其在日期上匹配，我们可以纯粹地在事件发生时匹配。</p><p id="bf86" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">以下是user_id=999的示例:</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="2f1a" class="li jp hi le b fi lj lk l ll lm"><em class="lc">subscriber_feed_history:<br/></em><br/>+------+---------+--------+------------+<br/>| date | user_id | status | opt_in_num |<br/>+------+---------+--------+------------+<br/>| 2/4  |     999 | I      |          5 |<br/>| 1/30 |     999 | I      |          4 |<br/>| 1/20 |     999 | I      |          3 |<br/>| 1/8  |     999 | I      |          2 |<br/>| 1/4  |     999 | I      |          1 |<br/>+------+---------+--------+------------+</span><span id="1e52" class="li jp hi le b fi ly lk l ll lm"><em class="lc">source_history:<br/></em><br/>+-------------+---------+-----------+-----------------+<br/>| action_date | user_id |  source   | interaction_num |<br/>+-------------+---------+-----------+-----------------+<br/>| 1/31        |     999 | Instagram |               5 |<br/>| 1/26        |     999 | Twitter   |               4 |<br/>| 1/13        |     999 | Medium    |               3 |<br/>| 1/5         |     999 | Twitter   |               2 |<br/>| 1/1         |     999 | Organic   |               1 |<br/>+-------------+---------+-----------+-----------------+</span></pre><p id="5ee8" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">在这种情况下，我们知道用户与博客交互了5次，并相应地订阅了邮件列表5次。因此，通过这种方法，如果选择加入的数量与互动的数量相匹配，我们将来源与选择加入的数量相匹配。</p><p id="8ff2" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">这在SQL中是这样的:</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="9d29" class="li jp hi le b fi lj lk l ll lm">-- All opt-ins with opt-in number<br/>WITH subscriber_history AS (<br/>SELECT date AS opt_in_date, user_id,<br/>RANK() OVER(PARTITION BY user_id ORDER BY date) AS optin_num<br/>FROM `<em class="lc">subscriber_feed_history`<br/></em>WHERE mailing_list_status = "I"<br/>GROUP BY date, user_id<br/>),</span><span id="c9ff" class="li jp hi le b fi ly lk l ll lm">-- User actions with source and interaction number<br/>source_history AS (<br/>SELECT user_id, source,<br/>RANK() OVER(PARTITION BY user_id ORDER BY action_date) AS intrcn_num<br/>FROM <em class="lc">source_history</em><br/>WHERE source &lt;&gt; "Direct"<br/>)</span><span id="a498" class="li jp hi le b fi ly lk l ll lm">-- Matching available user opt-ins on occurrence<br/>SELECT opt_in_date, user_id, source<br/>FROM subscriber_history sub<br/>LEFT JOIN source_history src<br/>ON sub.user_id = src.user_id<br/>AND sub.optin_num = src.intrcn_num<br/>WHERE src.intrcn_num IS NOT NULL</span></pre><p id="9392" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated"><em class="lc">注意:我们使用这里的日期来计算发生次数，但不用于实际匹配。所以现在日期没有以前那么重要了。</em></p><p id="48f9" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">最后，当你可以两者兼得的时候，为什么要选择一个呢？这里唯一的警告是，当有与这两种方法都匹配的源时，您会希望给予第一种方法比后者更高的优先级。</p><p id="5584" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">下面是在SQL中如何做到这一点:</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="98ff" class="li jp hi le b fi lj lk l ll lm">WITH subscriber_history AS (<br/>SELECT date AS opt_in_date, user_id,<br/>RANK() OVER(PARTITION BY user_id ORDER BY date) AS optin_num<br/>FROM `<em class="lc">subscriber_feed_history`<br/></em>WHERE mailing_list_status = "I"<br/>GROUP BY date, user_id<br/>),</span><span id="970c" class="li jp hi le b fi ly lk l ll lm">source_history AS (<br/>SELECT action_date, user_id, source, <br/>RANK() OVER(PARTITION BY user_id ORDER BY action_date) AS intrcn_num<br/>FROM <em class="lc">source_history</em><br/>WHERE source &lt;&gt; "Direct"<br/>),</span><span id="ce36" class="li jp hi le b fi ly lk l ll lm">subscriber_source_delta AS (<br/>SELECT opt_in_date, user_id, source,<br/>DATE_DIFF(opt_in_date,action_date, DAY) AS delta<br/>FROM subscriber_history <br/>LEFT JOIN source_history <br/>USING(user_id)<br/>WHERE delta BETWEEN 0 AND 1<br/>),</span><span id="6ee2" class="li jp hi le b fi ly lk l ll lm">-- Approach #1: With dates<br/>subscriber_source_history_delta AS (<br/>SELECT * EXCEPT(rnk), 1 AS solution_rank<br/>FROM (<br/>SELECT * EXCEPT(delta),<br/>RANK() OVER(PARTITION BY opt_in_date, user_id ORDER BY delta) AS rnk<br/>FROM subscriber_history_source<br/>) WHERE rnk = 1<br/>),</span><span id="9092" class="li jp hi le b fi ly lk l ll lm">-- Approach #2: With occurrence<br/>subscriber_source_history_occurrence AS (<br/>SELECT opt_in_date, user_id, source, 2 AS solution_rank<br/>FROM subscriber_history sub<br/>LEFT JOIN source_history src<br/>ON sub.user_id = src.user_id<br/>AND sub.optin_num = src.intrcn_num<br/>WHERE src.intrcn_num IS NOT NULL<br/>),</span><span id="0fcc" class="li jp hi le b fi ly lk l ll lm">-- Combining the two with priority for the same opt-in<br/>subscriber_source_history_combined AS (<br/>SELECT * EXCEPT(solution_rank),<br/>RANK() OVER(PARTITION BY user_id, opt_in_date ORDER BY solution_rank) AS final_solution_rank <br/>FROM (<br/>SELECT * FROM subscriber_source_history_delta<br/>UNION ALL<br/>SELECT * FROM subscriber_source_history_occurrence<br/>)<br/>)</span><span id="93e3" class="li jp hi le b fi ly lk l ll lm">-- Final source with priority #1 over #2<br/>SELECT opt_in_date, user_id, source AS opt_in_source<br/>FROM subscriber_source_history_combined<br/>WHERE final_solution_rank = 1</span></pre><h1 id="0d6b" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">思考的食粮:</h1><ul class=""><li id="70b2" class="lz ma hi ki b kj kk km kn kp mb kt mc kx md lb me mf mg mh bi translated">你还可以看看其他什么东西来增强历史数据？对于选择退出的来源，我们能做些什么？</li><li id="81d9" class="lz ma hi ki b kj mi km mj kp mk kt ml kx mm lb me mf mg mh bi translated">对于第一种方法，如果同一天有两个来自不同来源的访问，会怎么样？你如何打破平局？</li><li id="9dd4" class="lz ma hi ki b kj mi km mj kp mk kt ml kx mm lb me mf mg mh bi translated">你为什么不依赖数据中的日期？</li><li id="762c" class="lz ma hi ki b kj mi km mj kp mk kt ml kx mm lb me mf mg mh bi translated">第二种方法有什么缺点？</li><li id="7264" class="lz ma hi ki b kj mi km mj kp mk kt ml kx mm lb me mf mg mh bi translated">在这两种方法中，为什么订阅者和源历史记录之间的连接是左连接？</li><li id="5b6b" class="lz ma hi ki b kj mi km mj kp mk kt ml kx mm lb me mf mg mh bi translated">您还可以通过哪些方式来匹配订阅？</li></ul><p id="91de" class="pw-post-body-paragraph kg kh hi ki b kj ln ij kl km lo im ko kp lp kr ks kt lq kv kw kx lr kz la lb hb bi translated">让我知道你会如何处理这件事。如果你发现这很有帮助，请分享。如果你对此感兴趣，你可以在Twitter<a class="ae jn" href="https://twitter.com/abhishek27297" rel="noopener ugc nofollow" target="_blank"><em class="lc">@ abhishek 27297</em></a><em class="lc">上找到我的谈话资料。</em></p></div></div>    
</body>
</html>