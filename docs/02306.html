<html>
<head>
<title>All you need to know about Modern JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于现代JavaScript，你需要知道的</h1>
<blockquote>原文：<a href="https://medium.com/codex/all-you-need-to-know-about-modern-javascript-c4789ca22d90?source=collection_archive---------16-----------------------#2021-07-12">https://medium.com/codex/all-you-need-to-know-about-modern-javascript-c4789ca22d90?source=collection_archive---------16-----------------------#2021-07-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8f6a748e42c7559e2a23e12865df7a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGWYC3ztTyaAosMJf2ppwA.jpeg"/></div></div></figure><h1 id="22be" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">让我们直接进入ECMA脚本</h1><p id="c397" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">ECMA( <em class="km">欧洲计算机制造商协会</em>)脚本是一个官方规范，本质上是通用的。JavaScript符合ECMA脚本规范，这使得JavaScript <strong class="jq hj">可以跨web浏览器互操作</strong>。</p><p id="d9b7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">被称为TC39的ECMA文字技术委员会每年发布<em class="km">ECMA文字的</em>版本，现代浏览器每年实现<strong class="jq hj">新功能</strong>。ES6是ECMA脚本2015的版本。</p><h1 id="0705" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">JavaScript变量和块范围</h1><p id="223e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在ES2015之前，<strong class="jq hj"> JavaScript </strong>只支持<em class="km">函数级作用域</em>，不像C++/Java等其他语言有块级作用域。在ES2015中，除了函数级作用域，JavaScript <strong class="jq hj">还支持</strong>块级作用域。</p><h2 id="7a44" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">什么是块范围？</h2><p id="c875" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">块范围由一对花括号创建，即{}。它可以应用于变量、if语句和for语句。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="42c2" class="ks ir hi ll b fi lp lq l lr ls">//variable<br/>{const v=45    //Block Scope}</span><span id="99c9" class="ks ir hi ll b fi lt lq l lr ls">//if-statement<br/>if(!x){<br/>  return;      //Block Scope<br/>}</span><span id="8959" class="ks ir hi ll b fi lt lq l lr ls">//for-statement<br/>for(const x=0; x&gt;5; x++){<br/>               //Block Scope<br/>}</span></pre><h2 id="69e8" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">使用Const vs Let的变量声明</h2><p id="6b84" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">ES6附带的一个特性是增加了<code class="du lu lv lw ll b">let</code>和<code class="du lu lv lw ll b">const</code>，可以用于变量声明。那么<code class="du lu lv lw ll b">let</code>和<code class="du lu lv lw ll b">const</code>与<code class="du lu lv lw ll b">var</code>有什么不同呢？</p><p id="7231" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">变量的重新定义导致了代码中的许多错误，因为开发人员知道或不知道定义了相同的命名变量。</p><p id="6c22" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><code class="du lu lv lw ll b">let</code>和<code class="du lu lv lw ll b">const</code>阻止你重新声明，但是它们之间也有细微的差别。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/e8b5ed629ab0ef32adedd6347962013b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TblJQp4DJ6XmVzHJ5X6Zmw.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">var、const和let之间的差异</figcaption></figure></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="bc9a" class="iq ir hi bd is it mj iv iw ix mk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn bi translated">箭头功能</h1><p id="3e9e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在JavaScript中有许多定义函数的方法，但是现代规范引入了一种新的方法——箭头函数。</p><blockquote class="mo mp mq"><p id="4485" class="jo jp km jq b jr kn jt ju jv ko jx jy mr kp kb kc ms kq kf kg mt kr kj kk kl hb bi translated">这是一种不用键入关键字function而是使用箭头符号(<strong class="jq hj"> = &gt; </strong>)来定义函数的方法</p></blockquote><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="0754" class="ks ir hi ll b fi lp lq l lr ls">//Normal function definition</span><span id="41bd" class="ks ir hi ll b fi lt lq l lr ls">const a = function(){<br/>  //Code Here<br/>}</span><span id="b224" class="ks ir hi ll b fi lt lq l lr ls"><br/>//Arrow Function definition</span><span id="7d5a" class="ks ir hi ll b fi lt lq l lr ls">const b = () =&gt; {<br/>  //Code Here<br/>}</span></pre><p id="70f2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">箭头函数的最大用途是在<strong class="jq hj">延迟执行</strong>中，如事件监听器或事件处理程序。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="d8c5" class="iq ir hi bd is it mj iv iw ix mk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn bi translated">对象文字</h1><p id="fa9c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">JavaScript对象文字是用花括号括起来的逗号分隔的名称-值对列表。对象文字封装数据，将其封装在一个整洁的包中。这最大限度地减少了全局变量的使用，全局变量在组合代码时会导致问题。</p><p id="fecd" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">例子</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="85ee" class="ks ir hi ll b fi lp lq l lr ls">const myObject = {<br/>    sProp: 'some string value',<br/>    numProp: 2,<br/>    bProp: false<br/>};</span></pre><blockquote class="mu"><p id="42df" class="mv mw hi bd mx my mz na nb nc nd kl dx translated">对象文本属性值可以是任何数据类型，包括数组文本、函数和嵌套的对象文本。</p></blockquote></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="182a" class="iq ir hi bd is it mj iv iw ix mk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn bi translated">JavaScript中的去结构化赋值</h1><p id="c773" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj">去结构化赋值</strong>语法是一个JavaScript表达式，它可以将值从以下类型解包到不同的变量中:</p><ul class=""><li id="4d10" class="ne nf hi jq b jr kn jv ko jz ng kd nh kh ni kl nj nk nl nm bi translated">数组</li><li id="c09d" class="ne nf hi jq b jr nn jv no jz np kd nq kh nr kl nj nk nl nm bi translated">对象的属性</li><li id="ef6f" class="ne nf hi jq b jr nn jv no jz np kd nq kh nr kl nj nk nl nm bi translated">功能</li></ul><h2 id="750e" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">基本数组去结构化</h2><p id="d42e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果我们想从数组中提取数据，使用去结构化赋值是非常简单的。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="1b55" class="ks ir hi ll b fi lp lq l lr ls">let introduction = ["Hello", "I" , "am", "Eb"];<br/>let [greeting, pronoun] = introduction;<br/><br/>console.log(greeting);//"Hello"<br/>console.log(pronoun);//"I"</span></pre><h2 id="191a" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">对象去结构化</h2><p id="f3f0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">假设我们想从一个对象中提取数据并赋给新的变量。在ES6之前，这是如何实现的？</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="d34b" class="ks ir hi ll b fi lp lq l lr ls">const user = {<br/>    id: 42,<br/>    is_verified: true<br/>};<br/><br/>const {id, is_verified} = user;<br/><br/>console.log(id); // 42<br/>console.log(is_verified); // true</span></pre><h2 id="0683" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">用函数分解赋值</h2><p id="9003" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们也可以从函数返回的数组中提取数据。假设我们有一个函数返回一个数组，如下例所示:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="efb7" class="ks ir hi ll b fi lp lq l lr ls">function getArray() {<br/>    return ["Hello", "I" , "am", "Eb"];<br/>} <br/>let [greeting, pronoun] = getArray();</span><span id="b564" class="ks ir hi ll b fi lt lq l lr ls">console.log(greeting);//"Hello"<br/>console.log(pronoun);//"I"</span></pre></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="307b" class="iq ir hi bd is it mj iv iw ix mk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn bi translated">静止在对象分解中</h1><p id="f8fd" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">rest语法还可以用来挑选非结构化模式尚未挑选的属性键。这些键及其值被复制到一个新对象中:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="5967" class="ks ir hi ll b fi lp lq l lr ls">let person = {name: "Eb", country: "Pakistan", job: "Developer" friends: ["Miki", "Meh"]};<br/><br/>let {name, friends, ...others} = person;<br/><br/>console.log(name);//"Eb"<br/>console.log(friends);//["Miki", "Meh"]<br/>console.log(others);// {country: "Pakistan", job: "Developer"}</span></pre><p id="985b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这里的rest语法是<code class="du lu lv lw ll b">...others</code>。<code class="du lu lv lw ll b">others</code>可以重命名任何变量。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="f20d" class="iq ir hi bd is it mj iv iw ix mk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn bi translated">模板字符串</h1><p id="ec4d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">ES6 <a class="ae ns" href="https://www.chromestatus.com/feature/4743002513735680" rel="noopener ugc nofollow" target="_blank">模板字符串</a>引入了一种用特定领域语言(DSL)定义字符串的方法，带来了更好的:</p><ul class=""><li id="1fec" class="ne nf hi jq b jr kn jv ko jz ng kd nh kh ni kl nj nk nl nm bi translated">字符串插值</li><li id="007e" class="ne nf hi jq b jr nn jv no jz np kd nq kh nr kl nj nk nl nm bi translated">嵌入式表达式</li><li id="3d93" class="ne nf hi jq b jr nn jv no jz np kd nq kh nr kl nj nk nl nm bi translated">多行字符串</li><li id="aad7" class="ne nf hi jq b jr nn jv no jz np kd nq kh nr kl nj nk nl nm bi translated">字符串格式</li><li id="1c40" class="ne nf hi jq b jr nn jv no jz np kd nq kh nr kl nj nk nl nm bi translated">字符串标记的安全HTML转义，本地化和更多。</li></ul><p id="c4b9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">语法:</strong></p><p id="30a6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">模板字符串使用反勾号(<code class="du lu lv lw ll b">``</code>)，而不是我们习惯的普通字符串的单引号或双引号。因此，模板字符串可以写成如下形式:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="3abc" class="ks ir hi ll b fi lp lq l lr ls">const greeting = `Asalam!`;</span></pre><h2 id="c8df" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">使用模板字符串进行字符串替换</h2><p id="15e2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">模板字符串可以包含占位符，用于使用<code class="du lu lv lw ll b">${ }</code>语法进行字符串替换，如下所示:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="8114" class="ks ir hi ll b fi lp lq l lr ls">// Simple string substitution<br/>let name = "Eb";<br/>console.log(`Salam, ${name}!`);<!-- --> </span></pre><h2 id="c2a6" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">使用模板字符串的多行字符串</h2><p id="68a7" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">一段时间以来，JavaScript中的多行字符串需要一些巧妙的解决方法，在每个换行符前使用一个<code class="du lu lv lw ll b">\</code>(反斜杠)，或者使用字符串连接来伪造多行支持。例如:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9a0e" class="ks ir hi ll b fi lp lq l lr ls">var greeting = "Yo \<br/>World";</span><span id="b9e8" class="ks ir hi ll b fi lt lq l lr ls">var greeting = "Yo " +<br/>"World";</span></pre><p id="ab3e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">虽然这在大多数现代JavaScript引擎中应该工作得很好，但行为本身仍然有点不太好。</p><blockquote class="mo mp mq"><p id="8ecc" class="jo jp km jq b jr kn jt ju jv ko jx jy mr kp kb kc ms kq kf kg mt kr kj kk kl hb bi translated">模板字符串大大简化了多行字符串。只需在需要的地方加入换行符，瞧！</p></blockquote><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="29a3" class="ks ir hi ll b fi lp lq l lr ls">console.log(`string text line 1<br/>string text line 2`);</span></pre><p id="7cf2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">反斜杠语法中的任何空格也将被视为字符串的一部分。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="4092" class="iq ir hi bd is it mj iv iw ix mk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn bi translated">ES6中的类别</h1><p id="b5d6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">类是用于创建对象的<em class="km">模板。他们用代码封装数据来处理这些数据。</em></p><p id="159f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">JS中的类是建立在原型之上的，但是也有一些语法和语义是ES5类语义所没有的。</p><h2 id="1630" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">类声明</h2><p id="6ef7" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">定义类的一种方法是使用<strong class="jq hj">类声明</strong>。要声明一个类，可以使用带有类名的<code class="du lu lv lw ll b">class</code>关键字(这里是“Rectangle”)。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="2f3f" class="ks ir hi ll b fi lp lq l lr ls">class Rectangle {<br/>  constructor(height, width) {<br/>    this.height = height;<br/>    this.width = width;<br/>  }<br/>}</span></pre></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="e27b" class="iq ir hi bd is it mj iv iw ix mk iz ja jb ml jd je jf mm jh ji jj mn jl jm jn bi translated">带有“异步和等待”的异步编程</h1><p id="b8ca" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">JavaScript语言最近增加的是ECMAScript 2017中添加的<a class="ae ns" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">异步函数</a>和<code class="du lu lv lw ll b"><a class="ae ns" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener ugc nofollow" target="_blank">await</a></code>关键字。</p><h2 id="cc91" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">异步关键字</h2><p id="c27e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在函数声明的前面键入<code class="du lu lv lw ll b">async</code>关键字，将它变成一个<a class="ae ns" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">异步函数</a>。</p><p id="64d0" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">一个异步函数会期望使用<code class="du lu lv lw ll b">await</code>关键字来调用异步代码。</p><p id="675a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">下面是普通函数和异步函数的比较:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="e163" class="ks ir hi ll b fi lp lq l lr ls">//Normal Function<br/>function hello() { return "Hello" };<br/>hello();</span><span id="f5ab" class="ks ir hi ll b fi lt lq l lr ls">//Async Function<br/>async function hello() { return "Hello" };<br/>hello();</span></pre><h2 id="60c9" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">await关键字</h2><p id="9cd3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">异步函数只有在与<a class="ae ns" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener ugc nofollow" target="_blank"> await </a>关键字一起使用时才变得明显。<code class="du lu lv lw ll b">await</code>仅适用于常规JavaScript代码中的异步函数。</p><p id="7e75" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><code class="du lu lv lw ll b">await</code>可以放在任何基于异步承诺的函数前面，暂停代码直到承诺实现，然后返回结果值。</p><p id="e899" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这里有一个简单的例子:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="5968" class="ks ir hi ll b fi lp lq l lr ls">async function hello() {<br/>  return greeting = await Promise.resolve("Hello");<br/>};</span><span id="bb9a" class="ks ir hi ll b fi lt lq l lr ls">hello().then(alert);</span></pre></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="0bcb" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">感谢你阅读这篇文章，我希望你喜欢并且今天学到了一些新的东西。如果您有任何问题，请随时通过我的博客联系我，我将非常乐意帮助您。</p><p id="c6ea" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">保持安全和愉快的学习！</p></div></div>    
</body>
</html>