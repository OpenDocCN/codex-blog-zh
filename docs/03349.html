<html>
<head>
<title>A Pragmatic Introduction to Big-O Notation and Time-Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号和时间复杂性的实用介绍</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-pragmatic-introduction-to-big-o-notation-and-time-complexity-8f2ea8a4248c?source=collection_archive---------24-----------------------#2021-08-28">https://medium.com/codex/a-pragmatic-introduction-to-big-o-notation-and-time-complexity-8f2ea8a4248c?source=collection_archive---------24-----------------------#2021-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/103554c518fd51ffb0d1cef7f1c60799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLtWRDIe6RqpjijKIf5ltg.jpeg"/></div></div></figure><p id="3d56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">众所周知，软件无处不在，从你阅读本文的任何设备，到你头顶35000英尺高的飞机，甚至是帮助无数人生存的起搏器和呼吸机。从医学到工程学到天文学，计算机科学几乎影响了所有其他领域。事实上，我们几乎每天都在与软件进行交互，这加强了编写优秀高效代码的需要。</p><p id="b326" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大O符号是计算机科学中的一个主要概念，是迄今为止测量时间复杂性最常用的方法，即算法完全执行所需的时间与其输入大小的比值。大O不一定测量算法运行的实际时间，因为这通常取决于许多变量，包括它在什么计算机上运行，以及有多少其他标签打开，等等。大O衡量执行一个算法所需的时间如何随着输入的增长而增长。</p><h1 id="f4e0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">线性复杂度:O(n)</h1><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es km"><img src="../Images/1479609810aeb79b702becb92feb18cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/0*jQtz0j9BfNhkb7aC"/></div></figure><p id="a54a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">O(n)表示的线性复杂度本质上就是它听起来的样子。输入的大小和执行时间成线性关系。这意味着随着输入的增长，执行时间也相应地直线增长，如上所示。你们可能还记得高中代数中的线性关系，用函数y = mx + b表示，线性复杂度本质上是一样的。形象化线性时间的一个简单类比是给植物浇水。在我们的场景中，植物是输入n，每棵植物浇水需要3秒钟，每增加一棵新植物，浇水的时间(执行函数的时间)将线性增加。</p><p id="df58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">说到效率，线性时间是非常可预测的，并且可以用于较小的数据集，但是对于较大的数据集，线性时间可能非常低效。</p><p id="c23b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一个python函数中线性复杂度的例子，这个函数简单地遍历数组中的每一项:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="3592" class="kw jp hi ks b fi kx ky l kz la">a = [1,2,3,4,5]</span><span id="3faa" class="kw jp hi ks b fi lb ky l kz la">def iterate_over_array:<br/> for i in a:<br/>  print(i)</span></pre><p id="b202" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个简单的函数，遍历数组中的每一项。像这样的函数可以用来查找数组中的特定值。虽然它对像这样的小数据集工作得很好，但一旦数据集开始达到数千个甚至更多，线性复杂度就会变得非常低效。</p><h1 id="e0b0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">恒定时间复杂度:O(1)</h1><p id="edec" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">尽管恒定时间复杂度是所有复杂度中最基本的，但我选择不从它开始，因为在这种情况下，运行函数所需的时间不会随着输入的大小而改变，因此命名为恒定时间。这就是为什么恒定时间的图形总是看起来像一条狭窄的水平线，无论n的值是多少，执行时间总是保持不变:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/c7b2ccb38fc1e7bd4af8abf11889485d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/0*dyIyR5InJrX1ZKPS.png"/></div></figure><p id="d52c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">许多函数以恒定的时间运行:从简单的“Hello World”程序到获取列表第一项的函数:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="3ed3" class="kw jp hi ks b fi kx ky l kz la">a = [1,2,3,4,5]</span><span id="b0a0" class="kw jp hi ks b fi lb ky l kz la">def get_first_item():<br/>  print("the first element is: " + str(a[0]))</span></pre><p id="1bec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不管列表a是一个项目还是一百个项目，获取数组的第一个项目都要花费相同的时间。</p><h1 id="5cc6" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">二次时间复杂度:O(n ) </strong></h1><p id="9eb1" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">对于指数时间复杂度(不要与指数时间复杂度混淆:O(2^n)，执行时间与输入大小的平方成比例增长。例如，如果投入从3增长到4，增长率将从3变为4，也就是从9变为16。增长率的增量只随着投入的增加而增加。二次时间复杂度的图形如下所示:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es li"><img src="../Images/2ecd05f949fd18445df7610385fadaf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*0THDOwtRIsMYfG9l.png"/></div></figure><p id="e95e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于二次时间的指数性质，它通常不是大多数问题的有效解决方案，应该只作为最后的手段使用。</p><p id="7e11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行二次时间的算法的一个例子是这样嵌套的for循环:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="dad5" class="kw jp hi ks b fi kx ky l kz la">for x in range(5):<br/>    for y in range(5):<br/>        print x, y</span></pre><p id="73b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是二次时间，因为我们每次遍历“x”中的一个元素，都会遍历“b”中的每个元素，所以这将是5*5步，等于25步，如果我们将n增加到6，则类似地，它将变成6*6=36步，以指数方式增长。</p><h1 id="d586" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">对数时间复杂度:O(log n)</h1><p id="2b00" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">对于那些不熟悉对数或者从高中开始就被对数困扰的人来说(我也是)，这个问题可能看起来很可怕，但是对于大O，我们需要知道的是，随着输入大小变大，时间会减少。这种复杂性的执行时间与输入大小的对数成正比:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/b89cbfa5a46e3ab35fcccc69291db76e.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/0*-AEsE0MG2s3mzjaF"/></div></figure><p id="3af1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于许多任务和大型数据集，对数时间通常效率极高，甚至比线性搜索更好。许多搜索算法依赖于这种复杂性来有效地在大型数据集中移动。一个这样的例子是二分搜索法算法。由于其对数时间复杂性，该算法在许多情况下比线性搜索更优。该算法通过重复将间隔减半来搜索某个值，直到找到该值，这意味着每次迭代后花费的时间减半，呈指数下降。唯一的警告是，在应用二分搜索法之前，列表必须首先按大小排序。python中的实现如下所示:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="f77b" class="kw jp hi ks b fi kx ky l kz la">def binary_search(list, value):<br/> left_index = 0<br/> right_index = len(list) - 1</span><span id="bd60" class="kw jp hi ks b fi lb ky l kz la">while left_index &lt;= right_index:<br/>  mid_index = (left_index + right_index) / 2<br/>  if list[mid_index] == value:<br/>   print("found the value: ", list[mid_index])<br/>   return list[mid_index]<br/>  if list[mid_index] &lt; value:<br/>   left_index = mid_index + 1<br/>  elif list[mid_index] &gt; value:<br/>   right_index = mid_index - 1</span></pre><p id="ccd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先将左索引设置为数组中的第一个元素，右索引设置为数组中的最后一个元素，中间的索引是……中间的元素。然后我们根据中间的元素是小于还是大于实际值来调整左边或右边的元素，但是中间的元素是实际值，我们马上就取这个值。通过调整元素，我们每次都将数组减半，使数据集更小，从而更容易、更快地遍历。</p><p id="75bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们讨论了四种复杂性:线性、常数、二次和对数。虽然还有很多，但这些都是一些最常见和最有用的复杂情况，需要熟悉。读完这篇文章后，你将准备更深入地研究时间复杂性，并弄清楚你自己的算法和程序的复杂性。</p></div></div>    
</body>
</html>