<html>
<head>
<title>An In-Depth Look at gRPC for Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解面向Android的gRPC</h1>
<blockquote>原文：<a href="https://medium.com/codex/in-depth-look-at-grpc-for-android-d67ccd7b626f?source=collection_archive---------2-----------------------#2021-06-01">https://medium.com/codex/in-depth-look-at-grpc-for-android-d67ccd7b626f?source=collection_archive---------2-----------------------#2021-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ba63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">休息简单，容易上手。有数百个教程，在Medium上搜索会给你大量的结果，大多数开发者都在使用它。当我开始阅读gRPC时，情况并不一样。我们大多数人都是第一次使用它，有教程，但你需要浏览很多直到你找到你要找的答案，社区正在成长，但还不成熟，等等。</p><p id="b26c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文将带您了解理解gRPC所需的最重要的概念。这些概念包括从理解HTTP/2连接如何工作到学习如何正确地对协议缓冲区建模。</p><p id="2d54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到本文结束时，您将已经了解了在Android中有效使用gRPC所需的大部分知识。</p><p id="5e30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将使用以下库:</p><p id="b92d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd"> build.gradle </em> </strong></p><ul class=""><li id="2954" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.14'</code></li></ul><p id="9305" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">app/build . grdle</em></strong></p><ul class=""><li id="e9dd" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">api 'io.grpc:grpc-kotlin-stub:1.1.0'</code></li><li id="488b" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">api 'io.grpc:grpc-protobuf-lite:1.38.0'</code></li><li id="73eb" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">implementation 'io.grpc:grpc-android:1.38.0'</code></li><li id="7b3a" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><code class="du jn jo jp jq b">implementation 'io.grpc:grpc-okhttp:1.38.0'</code></li></ul><p id="5dad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里找到<a class="ae jw" href="https://github.com/victorbrndls/BlogProjects/tree/grpc-android" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><p id="0c4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">我在这里所说的一切都是指Kotlin库如何实现gPRC协议，它可能与其他库的实现方式不同。这篇文章的内容是从页面末尾列出的资源中精选出来的。</em></p><h1 id="4142" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">HTTP/2</h1><p id="d4d6" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">引入HTTP/2是为了解决HTTP/1的许多问题。主要的有:</p><ul class=""><li id="5d8a" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">HTTP/1.x客户端需要使用多个连接来实现并发，减少延迟；</li><li id="8e33" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated">HTTP/1.x不压缩请求和响应头，造成不必要的网络流量；</li><li id="54fb" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated">HTTP/1.x不允许有效的资源优先级划分，导致底层TCP连接使用不良；</li></ul><p id="14b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相比之下:</p><ul class=""><li id="f1ba" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">HTTP/2通过启用完整的请求和响应多路复用来减少延迟，</li><li id="55ad" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated">HTTP/2通过有效压缩HTTP报头字段来最小化协议开销，</li><li id="2d83" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated">HTTP/2增加了对请求优先级和服务器推送的支持。</li></ul><h1 id="a3f5" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">二进制帧层</h1><p id="86ec" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">HTTP/1传输以US-ASCII编码的信息。另一方面，HTTP/2用二进制编码它的信息。这一变化对邮件大小有很大的影响。HTTP语义(如动词、方法和头)不受影响，但它们在传输过程中的编码方式是不同的，这是通过添加二进制帧层实现的。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es la"><img src="../Images/92a66eea85690cd8e0c365e8d4a5fcd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OQAll_DVeKYklfKu"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">HTTP/2与HTTP/1.1</figcaption></figure><p id="261a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户机和服务器都必须使用新的二进制编码机制来相互理解:HTTP/1.x客户机不能理解只有HTTP/2的服务器，反之亦然。</p><p id="ff6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HTTP/2还将其消息分割成称为帧的较小部分，每个部分都以二进制格式编码。</p><h1 id="792a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">流、消息和帧</h1><p id="f5b4" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">流</em> </strong>:已建立连接内的双向字节流，可以携带一条或多条消息。每个<strong class="ih hj">流</strong>都有一个唯一的标识符。单个HTTP/2连接有一个或多个<strong class="ih hj">流</strong>。</p><p id="e268" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">消息</em> </strong>:映射到逻辑请求或响应<strong class="ih hj">消息</strong>的<strong class="ih hj">帧</strong>的完整序列。</p><p id="7bf8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">帧</em></strong>:HTTP/2中最小的通信单位，每个包含一个帧头，帧头至少标识该帧所属的<strong class="ih hj">流</strong>。最常见的头是头和数据。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lq"><img src="../Images/9658400423387c1e51835accb53e6e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ItYjPhDQ2dlR7QsI.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">HTTP/2连接</figcaption></figure><p id="44ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这只是对HTTP/2的简单解释，但对于理解下一个概念已经足够了。现在我们来看看gRPC的通道是如何利用HTTP/2的。</p><h1 id="7c35" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">频道</h1><p id="dcc8" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">通道基本上是向一个或多个服务器发送消息的接口。通道表示到端点的虚拟连接，实际上它可能由许多HTTP/2连接支持。</p><p id="02a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通道不仅仅发送消息，它们还进行名称解析、建立TCP连接(重试和退避)以及TLS握手。通道还可以处理连接和重新连接上的错误。我们将在重试部分看到这是如何发生的。</p><p id="b42d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要创建一个通道，你只需要服务器的主机和端口。<code class="du jn jo jp jq b">context</code>是可选的，但它有助于管理通道状态。</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="a838" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了给用户创建一个简单的抽象，gRPC API通过定义5种可能的状态来公开关于通道的信息:</p><h2 id="142c" class="lt jy hi bd jz lu lv lw kd lx ly lz kh iq ma mb kl iu mc md kp iy me mf kt mg bi translated">连接</h2><p id="c18e" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">通道试图建立连接，涉及的步骤有:</p><ul class=""><li id="45e0" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">名称解析—从主机名中检索IP地址；</li><li id="efb7" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated">TCP连接建立—使用三次握手过程建立连接；</li><li id="eab0" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated">使用安全连接时的TLS握手—通过协商会话中将使用的SSL/TLS版本、将对通信进行加密的密码套件等来建立安全连接。</li></ul><p id="ed00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这些步骤中的任何一个失败，通道转换到<strong class="ih hj">瞬态故障</strong>状态。</p><h2 id="7134" class="lt jy hi bd jz lu lv lw kd lx ly lz kh iq ma mb kl iu mc md kp iy me mf kt mg bi translated">瞬时故障</h2><p id="bdea" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">有些事情没有按预期进行。出现了一些故障(如TCP 3次握手超时或套接字错误)。</p><p id="c556" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">处于这种状态的通道最终将切换到连接状态，并尝试再次建立连接。您可以定义自定义重试策略来确定重试的工作方式。</p><p id="2800" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">信道花费在这种状态上的时间量随着时间的推移而增加，因为重试具有指数回退。</p><h2 id="6d26" class="lt jy hi bd jz lu lv lw kd lx ly lz kh iq ma mb kl iu mc md kp iy me mf kt mg bi translated">准备好的</h2><p id="768d" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">如果通道已经成功建立连接，它将从<strong class="ih hj">连接</strong>转换到<strong class="ih hj">就绪</strong>状态。</p><p id="1960" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是通道用于进行RPC调用时必须处于的状态。在一个理想的世界中，这将是国家频道将永远停留，但世界并不完美。如果发生某种故障，通道将转换到<strong class="ih hj">瞬态故障</strong>状态。</p><p id="ddcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使一切正常，通道可能会将其状态更改为<strong class="ih hj">空闲</strong>，让我们看看原因。</p><h2 id="d5c1" class="lt jy hi bd jz lu lv lw kd lx ly lz kh iq ma mb kl iu mc md kp iy me mf kt mg bi translated">闲置的</h2><p id="8fe3" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">这是由<code class="du jn jo jp jq b">ConnectivityStateManager</code>定义的通道的初始状态。</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="393c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果没有数据传输，保持连接打开对客户端和服务器来说都是资源浪费。</p><p id="ccb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通道转换到此状态，因为在指定的<strong class="ih hj"> IDLE_TIMEOUT </strong>内通道中没有活动。<strong class="ih hj">空闲超时</strong>的默认值为30分钟。最小值为1分钟。</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="b8f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该活动可以是新的RPC调用，也可以是尚未完成的现有调用。只有<strong class="ih hj">就绪</strong>或<strong class="ih hj">连接</strong>的通道才能切换到<strong class="ih hj">空闲</strong>。</p><p id="59fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何在信道上进行RPC的尝试都会将信道从这个状态推到<strong class="ih hj">连接</strong>。</p><p id="3fba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">信道可以从服务器接收GOAWAY，以指示信道应该转换到<strong class="ih hj">空闲</strong>以减少资源浪费。</p><h2 id="99a3" class="lt jy hi bd jz lu lv lw kd lx ly lz kh iq ma mb kl iu mc md kp iy me mf kt mg bi translated">关机</h2><p id="86fc" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">由于应用程序明确请求关闭，或者在尝试连接通信期间发生了不可恢复的错误，通道可能会进入此状态。进入这种状态的通道永远不会离开。</p><p id="e4d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何新的RPC应该立即失败。挂起的RPC可能会继续运行，直到应用程序取消它们。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es mh"><img src="../Images/2f2f9073c3e1971b20d75db386b28494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/0*7JBHfscNFGX4m9ua.png"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">通道状态</figcaption></figure><p id="918f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以调用<code class="du jn jo jp jq b">Channel#getState()</code>来检索通道状态。</p><p id="f2f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是对渠道的一个很好的概述，您知道如何创建一个简单的渠道，以及它在其生命周期中的行为。现在，我们将了解如何配置通道来改变其行为。</p><h1 id="6de2" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">重试</h1><p id="2f2f" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">意想不到的事情发生了。连接可能丢失，服务器可能突然关闭连接，等等。频道试图通过自动恢复向用户隐藏这些情况。我说尝试，是因为有些情况是不可恢复的，通道对此无能为力。</p><p id="2084" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">暂时失去连接是可以恢复的，但是如果你永久失去连接或者服务器关闭，就没有办法恢复了。</p><p id="e1f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重试时，通道从连接状态到TRANSIENT_FAILURE状态来回切换，直到连接恢复或重试过期。默认情况下，重试是通过指数补偿完成的。</p><p id="da92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有些库允许您定义自定义重试策略。Kotlin库允许您定义通道允许的最大重试次数。</p><p id="32f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，通道重试5次。如果您想更改，您可以拨打<code class="du jn jo jp jq b">AndroidChannelBuilder#maxRetryAttempts(attempts)</code></p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">向gRPC通道添加重试</figcaption></figure><p id="a2e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想要自定义其他参数，您需要创建一个自定义服务配置。该规范可以在<a class="ae jw" href="https://github.com/grpc/grpc-proto/blob/master/grpc/service_config/service_config.proto#L130" rel="noopener ugc nofollow" target="_blank"> service_config.proto </a>找到。</p><p id="3edc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原型必须被转换成Kotlin库的地图样式。你可以在这里学习如何做那个<a class="ae jw" href="https://grpc.github.io/grpc/core/md_doc_service_config.html" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="13d0" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">保持活力</h1><p id="4b33" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">您已经建立了与服务器的连接。你发送了一些消息，一切正常。突然，你试图发送另一封邮件，但失败了，这是因为与服务器的通信出现了问题。如果您启用了重试，通道将会再次尝试重新连接，但这不是最好的处理方式。</p><p id="9323" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果有一种方法可以发现下次发送消息时会发生的问题，会怎么样呢？这不是100%可能的，但是在gRPC中有一些非常接近的东西。</p><p id="8baf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Keep Alive </strong>就是让你实现这一点的功能。Keep Alive定期发送ping来检查通道是否正在工作，这是使用HTTP/2 ping完成的。如果ping在一定的超时时间内没有被对等体确认，则通道知道有问题。</p><p id="28a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下不启用保持活动，您可以通过在通道生成器上指定保持活动间隔来启用它。</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">将保持活动添加到gRPC频道</figcaption></figure><p id="a8a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码使通道每20秒向服务器发送一次ping，然后再等待5秒钟的响应。如果服务器没有确认ping，通道认为连接失败，关闭连接，并开始重新连接。</p><p id="cadc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您没有主动使用通道，但是希望它继续using服务器，那么您可能需要调用<code class="du jn jo jp jq b">AndroidChannelBuilder#keepAliveWithoutCalls(true)</code>。</p><h1 id="ebb2" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">分流道</h1><p id="c84c" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">您不太可能直接使用子通道，但是知道它们为什么存在是很有趣的。子信道主要用于负载平衡。例如，你想发送请求给<em class="jd">google.com</em>。解析器将<em class="jd">google.com</em>解析为服务于<em class="jd">google.com</em>的多个后端地址。</p><p id="1ca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，让我们假设有3台服务器服务于<em class="jd">google.com</em>。父信道将创建3个子信道，每个逻辑连接一个。您可以只使用父通道，它将处理所有的负载平衡逻辑。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es mi"><img src="../Images/0e7c1f663f6c10878cbb34683349135a.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/0*z8g39EwC1Lf80fnU.png"/></div></figure><p id="ea1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们已经了解了信道是如何工作的，以及它们是如何用来传输消息的，让我们来看看如何发送消息。</p><h1 id="0f9c" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">协议缓冲区</h1><p id="b797" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">默认情况下，gRPC使用<strong class="ih hj">协议缓冲区</strong>作为描述服务和消息的接口定义语言(IDL)。如果需要，可以使用其他替代方案。</p><p id="6060" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">协议缓冲区不像JSON那样将数据和结构放在一起。它更接近于Kotlin接口，在那里您定义一个指定方法和字段的协议。您唯一关心的是协议，协议如何实现与您无关。</p><p id="2bcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的例子中，我创建了一个协议来定义一本书。它有一个<strong class="ih hj"> id </strong>来标识每本书及其标题。</p><pre class="lb lc ld le fd mj jq mk ml aw mm bi"><span id="f1bd" class="lt jy hi jq b fi mn mo l mp mq">message Book { <br/>  int32 id = 1; <br/>  string title = 2; <br/>}</span></pre><p id="62f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">协议缓冲区定义了一个接口，为了与该接口进行交互，您需要一个目标语言的实现版本。</p><p id="10a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您正在使用<code class="du jn jo jp jq b">protobuf-gradle-plugin</code>，当您构建您的项目时，protobuf插件将被调用并在Java中为每个proto生成实现。</p><p id="9e80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，插件会在<code class="du jn jo jp jq b">app/src/main/proto</code>下寻找文件。生成的文件可以在<code class="du jn jo jp jq b">app/build/generated/source/proto/<em class="jd">buildType</em></code>找到。</p><p id="95d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于协议缓冲区还有很多我们无法在这里介绍的，如果你想了解更多，我推荐<a class="ae jw" href="https://developers.google.com/protocol-buffers/docs/kotlintutorial" rel="noopener ugc nofollow" target="_blank">协议缓冲区基础:Kotlin </a>和<a class="ae jw" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank">语言指南(proto3) </a>。</p><h1 id="ab41" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">服务</h1><p id="cd3b" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">服务是您定义方法的地方，您希望调用这些方法及其参数和返回类型。您可以使用<strong class="ih hj">协议缓冲区</strong>来定义服务的API。</p><p id="d1d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该使用<strong class="ih hj"> CamelCase </strong>作为服务名和任何RPC方法名。</p><p id="e4cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的例子中，我定义了一个允许我创建书籍(CreateBook)和列表书籍(list books)的接口。</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="e9bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用于gRPC的Kotlin库的伟大之处在于生成的类支持<strong class="ih hj"> <em class="jd">协程。</em>T19】</strong></p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="8014" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码在端口<em class="jd"> 9000 </em>上创建了一个到服务器<em class="jd"> 127.0.0.1 </em>的连接，然后这个连接被一个作为参数传递的通道用来创建服务。当<code class="du jn jo jp jq b">createBook</code>被调用时，服务将消息分派给将它发送给服务器的通道。</p><p id="ea61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不会深入研究服务器端，因为本文主要关注Android，但是我建议您深入研究。</p><h1 id="73ff" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">位置遥控(remote position control)</h1><p id="a7dd" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">我们已经了解了什么是服务，现在让我们回过头来进一步理解它。RPC实际上是普通的HTTP/2流。</p><p id="4bf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了在Kotlin中定义一个方法，我们使用了<code class="du jn jo jp jq b">fun</code>关键字。为了在gRPC中定义一个方法，我们使用了<code class="du jn jo jp jq b">rpc</code>关键字。方法签名如下:</p><pre class="lb lc ld le fd mj jq mk ml aw mm bi"><span id="2d9d" class="lt jy hi jq b fi mn mo l mp mq">rpc MethodName(Request) returns (Response) {}</span></pre><p id="16cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">gPRC有两种方法。一元流。</p><h1 id="be71" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">一元的</h1><p id="0717" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">客户端向服务器发送一个请求，然后得到一个响应，就像普通的函数调用一样。这可能是你用得最多的。它紧密地映射到REST请求/响应。</p><h1 id="9653" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">流动</h1><p id="655d" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">有3种流媒体</p><ul class=""><li id="5faa" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><strong class="ih hj">服务器流RPC</strong>客户端向服务器发送一个请求，并获得一个流来读回一系列消息。</li><li id="bb69" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><strong class="ih hj">客户端流RPC</strong>客户端编写一系列消息并发送给服务器。一旦客户端写完消息，它就等待服务器读取消息并返回响应。</li><li id="7b3f" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><strong class="ih hj">双向流RPC</strong>双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照他们喜欢的任何顺序进行读写。</li></ul><p id="959b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">gRPC保证了单个RPC调用中的消息排序。例如，如果服务器发送消息1、2、3和4，gRPC保证客户机将按相同的顺序接收它们，但不保证客户机将实际接收它们，客户机实际上可能只接收1、2和3。</p><p id="fabc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在收到第一条消息后，<strong class="ih hj">从服务器返回多条消息</strong>的流式RPC不会重试。如果传出的消息超过了客户端的最大缓冲区大小，<strong class="ih hj">向服务器发送多条消息</strong>的流式RPC将不会重试。</p><h1 id="edbe" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">一元x流</h1><p id="9d5e" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">对于较低的并发请求，两者的延迟相当。然而，对于较高的负载，一元调用的性能要高得多。</p><p id="154a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们没有明显的理由应该更喜欢流而不是一元，因为使用流会带来一些问题，如应用程序级的复杂实现和不良的负载平衡，因为客户端将与一个服务器连接，并忽略任何新的服务器，以及对网络中断的较低弹性。</p><h1 id="0d7b" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">双方都成功？</h1><p id="ba3b" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">在gRPC中，客户机和服务器都独立地在本地判断远程过程调用(RPC)是否成功。这意味着他们的结论可能不匹配！在服务器端成功完成的RPC可能会在客户端失败。</p><p id="f14c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，服务器可以发送响应，但是回复可能会在截止日期过后到达客户端。客户端将已经终止，状态为错误DEADLINE _ EXCEEDED。这应该在应用程序级别进行检查和管理。</p><h1 id="660c" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">协议缓冲区的最佳实践</h1><p id="d5a0" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">大多数语言都有一套开发人员用来提高代码质量的最佳实践。这同样适用于协议缓冲区。以下是我发现的一些:</p><p id="be22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不要使用<code class="du jn jo jp jq b">google.protobuf.Empty</code>作为请求或响应类型。如果使用Empty，那么向请求/响应中添加字段对于所有客户机和服务器来说都将是一个突破性的API变化。</p><p id="7073" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于自定义方法，它们应该有自己的XxxResponse消息，即使它们是空的，因为它们的功能很可能会随着时间的推移而增长，并且需要返回额外的数据。</p><p id="1155" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个枚举值都应以分号结束，而不是逗号。零值枚举应该是枚举本身的名称，后跟后缀UNSPECIFIED。</p><pre class="lb lc ld le fd mj jq mk ml aw mm bi"><span id="89e7" class="lt jy hi jq b fi mn mo l mp mq">enum State { <br/>  UNKNOWN = 0; <br/>  STARTED = 1; <br/>  RUNNING = 1; <br/>}</span></pre></div><div class="ab cl mr ms gp mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hb hc hd he hf"><p id="b19b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我的第一篇“大”文章。写它真的很有趣，我学到了很多关于gRPC的知识。如果您有任何问题或建议，可以在Twitter上联系我。我乐于接受新的想法，如果你想找人聊聊编程、软件架构或不同的方法，我很乐意和你聊天。感谢您阅读这篇文章。</p></div><div class="ab cl mr ms gp mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hb hc hd he hf"><h1 id="f5b8" class="jx jy hi bd jz ka my kc kd ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku bi translated">其他文章</h1><p id="a996" class="pw-post-body-paragraph if ig hi ih b ii kv ik il im kw io ip iq kx is it iu ky iw ix iy kz ja jb jc hb bi translated">【Android上有用的Kotlin扩展</p><p id="520e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jw" href="https://victorbrandalise.com/android-lifecycle-scenarios-single-and-multi-activities/" rel="noopener ugc nofollow" target="_blank"> Android生命周期场景——单个和多个活动</a></p><p id="195f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jw" href="https://victorbrandalise.com/android-lifecycle-revised/" rel="noopener ugc nofollow" target="_blank">安卓生命周期修改</a></p><h1 id="6ede" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">资源</h1><ul class=""><li id="ce27" class="je jf hi ih b ii kv im kw iq nd iu ne iy nf jc jj jk jl jm bi translated"><a class="ae jw" href="https://docs.microsoft.com/en-us/aspnet/core/grpc/retries?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank">使用gRPC重试的瞬时故障处理|微软文档</a> <a class="ae jw" href="https://grpc.io/blog/deadlines/" rel="noopener ugc nofollow" target="_blank"> gRPC和截止日期| gRPC </a></li><li id="00b1" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><a class="ae jw" href="https://john-millikin.com/effective-grpc" rel="noopener ugc nofollow" target="_blank">有效gRPC </a></li><li id="b07f" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><a class="ae jw" href="https://cloud.google.com/apis/design/design_patterns" rel="noopener ugc nofollow" target="_blank">通用设计模式|云APIs |谷歌云</a> <a class="ae jw" href="https://developers.google.com/protocol-buffers/docs/style" rel="noopener ugc nofollow" target="_blank">风格指南|协议缓冲区|谷歌开发者</a></li><li id="fc37" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><a class="ae jw" href="https://charles-thayer.medium.com/grpc-top-6-things-that-bite-newbies-dfa740ffc67d" rel="noopener"> gRPC:咬新人的六大利器|查尔斯·塞耶| Medium </a></li><li id="efd5" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><a class="ae jw" href="https://www.cncf.io/blog/2018/08/31/grpc-on-http-2-engineering-a-robust-high-performance-protocol/" rel="noopener ugc nofollow" target="_blank">HTTP/2上的gRPC:设计一个健壮的高性能协议|云本地计算基础</a></li><li id="6774" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><a class="ae jw" href="https://www.cncf.io/blog/2018/07/03/http-2-smarter-at-scale/" rel="noopener ugc nofollow" target="_blank"> HTTP/2:规模更智能|云计算基础</a><a class="ae jw" href="https://developers.google.com/web/fundamentals/performance/http2" rel="noopener ugc nofollow" target="_blank">HTTP/2简介| Web基础|谷歌开发者</a></li><li id="cf27" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><a class="ae jw" href="https://hpbn.co/http2" rel="noopener ugc nofollow" target="_blank">高性能浏览器网络|奥赖利</a></li><li id="b036" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><a class="ae jw" href="https://www.ssl.com/article/ssl-tls-handshake-overview/" rel="noopener ugc nofollow" target="_blank">SSL/TLS握手:概述</a></li><li id="5ab5" class="je jf hi ih b ii jr im js iq jt iu ju iy jv jc jj jk jl jm bi translated"><a class="ae jw" href="https://developers.google.com/protocol-buffers/docs/kotlintutorial" rel="noopener ugc nofollow" target="_blank">协议缓冲基础:Kotlin </a></li></ul><p id="fde4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jw" href="https://unsplash.com/@tvick?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">泰勒·维克</a>在<a class="ae jw" href="https://unsplash.com/s/photos/server?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的封面照片</p></div><div class="ab cl mr ms gp mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hb hc hd he hf"><p id="11f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">原载于2021年6月1日https://victorbrandalise.com</em><a class="ae jw" href="https://victorbrandalise.com/in-depth-look-at-grpc-for-android/" rel="noopener ugc nofollow" target="_blank"><em class="jd"/></a><em class="jd">。</em></p></div></div>    
</body>
</html>