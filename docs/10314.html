<html>
<head>
<title>Dynamic Thread Sharing, the design idea of SeaTunnel-TaskExecutionServer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态线程共享，SeaTunnel-TaskExecutionServer的设计思想</h1>
<blockquote>原文：<a href="https://medium.com/codex/dynamic-thread-sharing-the-design-idea-of-seatunnel-taskexecutionserver-5d51e0487166?source=collection_archive---------15-----------------------#2022-12-20">https://medium.com/codex/dynamic-thread-sharing-the-design-idea-of-seatunnel-taskexecutionserver-5d51e0487166?source=collection_archive---------15-----------------------#2022-12-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/266cf098ab65abd7d4695467b99d88ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eK2pIzFK2n74mQNBAdO6Cw.jpeg"/></div></div></figure><p id="c3d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将在本文中介绍Apache SeaTunnel的TaskExecutionServer的设计思想。</p><p id="1371" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TaskExecutionServer是执行任务的特定服务，它将在每个节点上运行一个实例。</p><p id="b1fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TaskExecutionServer不仅负责接收JobMaster下发的TaskGroup并运行其中的任务，还维护TaskID-&gt;TaskContext之间的映射关系。</p><p id="743b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TaskContext中封装了对Task的具体操作。</p><p id="cf4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Task内部持有OperationService，这意味着Task可以通过OperationService远程调用其他任务或JobMaster并与之通信。</p><h1 id="69d3" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">01任务组</h1><p id="a2fa" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">TaskGroup中的任务都在同一个节点上运行。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/1584c8fb98ba2f221d69f2d75aa74d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vvBuyLmK00i14xa7HZdYaw.png"/></div></div></figure><p id="5d35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个优化:同一任务组内的任务之间的数据通道使用本地队列，不同任务组之间的数据通道可能在不同的节点上执行，所以数据通道使用分布式队列(hazalcast Ringbuffer)。</p><h1 id="039a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">02任务设计</h1><p id="f3d6" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Task最重要的方法之一是call()方法。执行器通过调用任务的call()方法来驱动任务的操作。call()方法会有一个返回值ProgressState，通过这个返回值执行者可以判断任务是否结束，是否需要继续调用call()方法。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/7fb532a14d78c07d784273014deff0ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGTlmibUUza3Me2SAT-aCg.png"/></div></div></figure><h1 id="9c9c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">03线程共享优化</h1><p id="3b43" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">背景:在很多小任务同步的场景下，会产生很多任务。如果一个线程负责一项任务，那么将会运行多个线程，导致资源浪费。这时，如果一个线程可以运行多个任务，情况就会大大改善。但是一个线程如何同时执行多个任务呢？</p><p id="6620" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为任务是通过反复调用call()方法在内部驱动的，所以一个线程可以依次调用它所负责的所有任务的Call()方法。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/996bb4205cbdc1239978b223f77f8061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xM7JR6smTp9DnXlZcFFYZQ.png"/></div></div></figure><p id="98a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这也会带来一个问题，就是如果执行一个任务的call()方法需要很长时间，这个线程就会被占用太久，导致其他任务的延迟非常高。</p><p id="0a85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">针对这样的问题，暂提出以下两种优化方案:</p><h2 id="1546" class="kx jp hi bd jq ky kz la ju lb lc ld jy jb le lf kc jf lg lh kg jj li lj kk lk bi translated">1标记螺纹份额</h2><p id="3317" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在任务上提供一个标识符，以标识任务是否支持线程共享(线程共享)。任务实现时，用来标识任务是否支持线程共享。可以共享的任务会在一个线程中执行，不能共享的任务会独占在一个线程中执行。</p><p id="8242" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">任务是否支持线程共享是由任务的具体实现者来评估的。根据调用方法的执行时间，如果调用方法的实现是在ms级别，那么可以将任务标记为支持线程共享。</p><h2 id="6f33" class="kx jp hi bd jq ky kz la ju lb lc ld jy jb le lf kc jf lg lh kg jj li lj kk lk bi translated">2动态线程共享</h2><p id="bde9" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">上述方案1有一个根本问题，就是Call方法的执行时间往往不固定，任务本身对其Call()方法的调用时间也不是很清楚，因为Call方法的执行时间会受到不同阶段、不同数据量下等的影响。这样的任务标记为支持共享线程与否并不是很合适，因为在标记为共享线程的情况下，如果对call方法的调用执行时间很长，这将导致共享当前线程的其他任务有非常高的延迟。如果不支持共享，资源浪费的问题还是没有解决。</p><p id="2d99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">于是就有可能让任务线程共享动态化，一组任务由一个线程池执行(任务号&gt;&gt;线程号)。在执行thread1的过程中，如果Task1的call()方法的执行时间超过了设定值(100ms)，就会从线程池中取出一个thread2来执行Task2的下一个Call方法。保证其他任务的延迟不会因为Task1的执行时间过长而过高。</p><p id="28d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当Task2的call方法在超时期限内正常执行时，会将Task2放回任务队列的末尾，thread2继续从任务队列中取出Task3执行Call方法。当Task1的call方法执行完成后，thread1将被放回线程池，Task1将被标记为超时一次。当TaskCall方法的执行超时次数达到一定限制时，该任务将从共享线程任务队列中移除，一个线程将被独占使用。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/7ae5b633dff5acf663d61cc17d286f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J8mmYWZnvhJlB7Apnx-r9A.png"/></div></div></figure><p id="8ab5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">步骤1:开始执行，从线程池中取出一个线程，开始执行任务队列中的任务</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/e134ec3ebcaa1a1d464b4b2e9863aa57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*evR0EPKi5_dFr8q0OeyQEg.png"/></div></div></figure><p id="9e54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">步骤2:如果Task1的执行时间超过设定值，将使用另一个线程来执行task2，以确保其他任务的延迟不受Task1的影响</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/e2711ffec73e47d64a6bb4f71be743ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8yxLms5wE9NvA9ooGTxUw.png"/></div></div></figure><p id="446f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第三步:如果Task2正常执行，它将被放在队列的末尾，等待下一次执行。同时，Thread2将从队列中取出另一个任务来执行</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/d2bc3f229341016319c1a80f19fdfac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nijGdjRurDzMQbUm9YR08w.png"/></div></div></figure><p id="8490" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">步骤4:此时，如果Task1的执行完成，Task1将被放在队列的末尾，Thread1也将被放回线程池</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/59b136b20912506c212442c4d249d256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zFtheF-2I1Gt_xbkmPhAkw.png"/></div></div></figure><p id="41d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">步骤5:如果Task1执行多次超时，它将从任务队列中删除，并由一个线程独占执行</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/a432bd2efbe629f720be7bbbe0bb7be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7iX0vFbP5yeUa-28AtO6SA.png"/></div></div></figure><p id="ca91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">方案二已经在目前的SeaTunnel引擎中实现，未来还会继续优化，希望能给大家带来更好的体验。</p><h1 id="086b" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">关于海底隧道</h1><p id="be35" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">SeaTunnel(原Waterdrop)是一个简单易用、超高性能的分布式数据集成平台，支持海量数据的实时同步，可以稳定高效地同步每天数千亿的数据。</p><p id="9bd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们为什么需要海底隧道？</p><p id="2d3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">SeaTunnel竭尽所能解决你在同步海量数据时可能遇到的问题。</p><ul class=""><li id="e37a" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">数据丢失和重复</li><li id="081f" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">任务构建和延迟</li><li id="ba9b" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">低吞吐量</li><li id="12ab" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">从应用到生产周期长</li><li id="4ef2" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">缺乏应用程序状态监控</li></ul><p id="39ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">海底隧道使用场景</strong></p><ul class=""><li id="5df7" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">海量数据同步</li><li id="e0de" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">海量数据集成</li><li id="cc1d" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">大量数据的ETL</li><li id="b321" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">海量数据聚合</li><li id="fba4" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">多源数据处理</li></ul><p id="a125" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">海底隧道的特点</strong></p><ul class=""><li id="e9f2" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">丰富的组件</li><li id="584a" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">高可扩展性</li><li id="a891" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">使用方便</li><li id="2356" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">成熟稳重</li></ul><p id="805d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如何快速上手SeaTunnel？</strong></p><p id="efff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想快速体验海底隧道？SeaTunnel 2.1.0只需10秒钟即可启动并运行。</p><p id="fc89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lz" href="https://seatunnel.apache.org/docs/2.1.0/developement/setup" rel="noopener ugc nofollow" target="_blank">https://seatunnel.apache.org/docs/2.1.0/developement/setup</a></p><p id="171f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我能做些什么？</p><p id="dff3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们邀请所有对本地开源全球化感兴趣的合作伙伴加入SeaTunnel贡献者大家庭，共同促进开源！</p><p id="5234" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">提交问题:</p><p id="1a9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lz" href="https://github.com/apache/incubator-seatunnel/issues" rel="noopener ugc nofollow" target="_blank">https://github.com/apache/incubator-seatunnel/issues</a></p><p id="6e62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将代码贡献给:</p><p id="b969" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lz" href="https://github.com/apache/incubator-seatunnel/pulls" rel="noopener ugc nofollow" target="_blank">https://github.com/apache/incubator-seatunnel/pulls</a></p><p id="5348" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">订阅社区发展邮件列表:</p><p id="dc4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">dev-subscribe@seatunnel.apache.org</p><p id="6b95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">开发邮件列表:</p><p id="045d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">dev@seatunnel.apache.org</p><p id="b804" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">加入时差:</p><p id="3e2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lz" href="https://join.slack.com/t/apacheseatunnel/shared_invite/zt-1hso5n2tv-mkFKWxonc70HeqGxTVi34w" rel="noopener ugc nofollow" target="_blank">https://join . slack . com/t/Apache seatunnel/shared _ invite/ZT-1 HSO 5 N2 TV-mkfkwxonc 70 heqgxtvi 34 w</a></p><p id="c57a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关注Twitter:</p><p id="654d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lz" href="https://twitter.com/ASFSeaTunnel" rel="noopener ugc nofollow" target="_blank">https://twitter.com/ASFSeaTunnel</a></p><p id="226f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">来加入我们吧！</p></div></div>    
</body>
</html>