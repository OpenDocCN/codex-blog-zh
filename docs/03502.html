<html>
<head>
<title>Ruby Blocks: Meta Programming Tutorial for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby Blocks:初学者元编程教程</h1>
<blockquote>原文：<a href="https://medium.com/codex/ruby-blocks-meta-programming-made-easy-bf3053192a37?source=collection_archive---------12-----------------------#2021-09-06">https://medium.com/codex/ruby-blocks-meta-programming-made-easy-bf3053192a37?source=collection_archive---------12-----------------------#2021-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c1fd0e337d4662866e642189d2cce15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YxANz3od6K7AROhEaleR1Q.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@nvte?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">内森·达克</a>在<a class="ae iu" href="https://unsplash.com/s/photos/blocks-red?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="1bda" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">什么是积木？</h2><p id="6d13" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">在<a class="ae iu" href="https://rubyapi.org/" rel="noopener ugc nofollow" target="_blank"> Ruby </a>中，块是一个匿名函数，作为方法/函数的参数传递。通过使用块，函数和类方法可以有更多的用例。当我们调用一个块时，我们实际上是在编写一段代码，这段代码正在编写(重新调整用途)一个函数。</p><p id="974b" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">有些人可能认为这是有争议的，但是块是元编程的一个例子。它们允许我们编写一个重新定义函数源代码的程序。块防止编程冗余，而不是写一百万个不同的方法，我们可以写一个方法并传递给它无限个块。那么我们如何使用积木呢？</p><p id="cc39" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">如果你喜欢通过视频学习，看看我在blocks上制作的视频<a class="ae iu" href="https://www.youtube.com/watch?v=DuTaOGvfMdA" rel="noopener ugc nofollow" target="_blank"> <strong class="jv hj">这里</strong></a><strong class="jv hj">&amp;</strong><a class="ae iu" href="https://www.youtube.com/watch?v=XPSKvHMTRIE" rel="noopener ugc nofollow" target="_blank"><strong class="jv hj">这里</strong> </a> <strong class="jv hj">！</strong></p><h2 id="4d3f" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">使用块</h2><p id="52cc" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">编写代码块有两种方法:使用花括号语法或do/end语句。花括号语法最适用于只有一行代码的程序块，而do/end结构最适用于较长的多行程序。就像函数一样，它们也可以接受参数。参数用竖线(||)字符括起来，并用逗号分隔。</p><p id="fe9e" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated"><strong class="jv hj"> each </strong>方法允许我们迭代列表对象中的每个元素。each方法接受一个带有参数的块，在本例中，它被命名为word。这个参数将代表当前被迭代的元素，在每次迭代中我们的块将被调用。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="2717" class="iv iw hi ky b fi lc ld l le lf"># One Liner == Braces syntax </span><span id="7344" class="iv iw hi ky b fi lg ld l le lf">%w[coreys corner podcast].each {|word| puts word}</span><span id="d079" class="iv iw hi ky b fi lg ld l le lf"># Multiline == do/end </span><span id="80d1" class="iv iw hi ky b fi lg ld l le lf">%w[the best podcast around].each do |word|<br/>   puts word <br/>   puts word.capitalize<br/>   puts "#{word} includes hog!!" if word.include? "hog"<br/>end </span></pre><h2 id="0971" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><strong class="ak">基于书写块的功能</strong></h2><p id="5c2e" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">如果编写代码块是将代码传递给函数的一种方式，为什么我们不能将代码作为参数传递给函数呢？我们可以传递一行代码作为函数的参数。让我们这样做，看看会发生什么。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="4848" class="iv iw hi ky b fi lc ld l le lf">def does_not_work(code)<br/>   puts "Inside of function"<br/>   code # does not print in proper order <br/>   puts "Inside of function<br/>end<br/>does_not_work(puts "hello")</span><span id="9156" class="iv iw hi ky b fi lg ld l le lf">&gt;&gt; hello<br/>&gt;&gt; Inside of function<br/>&gt;&gt; Inside of function</span></pre><p id="a5aa" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">正如你所看到的，程序并没有像我们预期的那样运行。将代码行作为参数传递是行不通的，这也是我们需要使用块的原因之一。即使我们可以把一行代码作为参数传入，并且成功了，那也意味着我们需要为每一行代码创建一个参数，我们想用它作为参数。这种假设场景显然非常麻烦、不动态，并且可能导致错误。块使得在一个函数中动态执行多行代码成为可能。</p><p id="c28a" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">让我们写一个函数，它将一个块作为参数，在这个例子中，我们将隐式地这样做，我们的块在函数参数中不是一个命名的参数。在下面的例子中，我们使用<strong class="jv hj"> yield </strong>关键字来运行/调用/执行程序块。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="225c" class="iv iw hi ky b fi lc ld l le lf"># Implicit block with yield as call method <br/>def takes_a_block<br/>   puts "Inside of function"<br/>   yield<br/>   puts "Inside of function<br/>"end</span><span id="79d2" class="iv iw hi ky b fi lg ld l le lf">takes_a_block {puts "Inside of block"}</span><span id="dba2" class="iv iw hi ky b fi lg ld l le lf">takes_a_block do <br/>   puts "Hey I'm inside of a block'<br/>   puts "Wow this is so cool" <br/>end </span></pre><p id="12c0" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">如果我们想要明确地指定一个块作为一个命名的函数参数，我们可以简单地用&amp;符号来定义它，如下所示。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="6b00" class="iv iw hi ky b fi lc ld l le lf">def my_func(&amp;my_block) #Explicitly defined block<br/>   my_block.call # Equivalent to yield <br/>end</span></pre><p id="01ad" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">我们不使用yield来运行这个块，而是使用call方法来执行它。除了我们只能在显式定义的块上使用call方法之外，使用yield或call没有区别。</p><p id="d409" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">yield关键字可以在函数中使用任意多次。让一个块接受一个参数，我们要做的就是把它作为一个参数传递给yield。传递给yield的任何参数都将被视为我们在块中指定的参数。省略参数或包含多个参数不会导致错误，但是多余的参数将被视为nil对象。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="6311" class="iv iw hi ky b fi lc ld l le lf">def some_data_types(&amp;block)<br/>   yield :symbol<br/>   yield "string"<br/>   yield(1)<br/>   block.call([])<br/>   block.call {}<br/>end </span><span id="1de5" class="iv iw hi ky b fi lg ld l le lf"># n represents :symbol, "string" etc as our block is called</span><span id="cd5a" class="iv iw hi ky b fi lg ld l le lf">some_data_types { |n| puts "#{n} is of type #{n.class}" }</span><span id="93cb" class="iv iw hi ky b fi lg ld l le lf">some_data_types do |n, x| #extra arg does not cause error<br/>   puts "#{<em class="lh">n</em>} responds to .each_byte" if <em class="lh">n</em>.respond_to? :each_byte<br/>   puts "#{<em class="lh">n</em>}.object_id == #{<em class="lh">n</em>.object_id}"<br/>   p x # extra arg treated as nil<br/>end</span></pre><h2 id="1a0b" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">动态块</h2><p id="9893" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">block_given？方法有助于防止程序崩溃，尤其是在处理隐式块时。如果一个块被传递给我们的函数block_given返回true，否则返回false，这允许我们动态地调用yield。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="7308" class="iv iw hi ky b fi lc ld l le lf">def foo<br/>   if block_given? then yield else puts "No block given" end<br/>end</span><span id="b464" class="iv iw hi ky b fi lg ld l le lf">foo <br/>&gt;&gt; "No Block Given"</span><span id="9285" class="iv iw hi ky b fi lg ld l le lf">foo "The Corey's Corner Podcast is crazy" <br/>&gt;&gt; "The Corey's Corner Podcast is crazy"</span></pre><p id="d423" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">总而言之，我们已经知道，块是一种动态编写匿名函数并将它们作为参数传递给函数/方法的方式。它们使得Ruby语言更加灵活和动态，这使得我们更容易用高抽象级别编程。</p><p id="4730" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">外星人存在吗？看看<a class="ae iu" href="https://anchor.fm/coreys-corner" rel="noopener ugc nofollow" target="_blank">科里的角落</a>就知道了…</p><p id="51de" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated"><a class="ae iu" href="https://www.youtube.com/watch?v=gAXs3xhfHVg" rel="noopener ugc nofollow" target="_blank"> Ruby on Rails电子商务教程</a></p><p id="79ac" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated"><a class="ae iu" href="https://www.youtube.com/watch?v=CiWkUQt4YEM" rel="noopener ugc nofollow" target="_blank">用Ruby对SQL命令进行元编程</a>🔥</p><p id="cd1d" class="pw-post-body-paragraph jt ju hi jv b jw ko jy jz ka kp kc kd jg kq kf kg jk kr ki kj jo ks kl km kn hb bi translated">被束缚🍳-&gt;<a class="ae iu" href="https://thoughtsandfitness.com" rel="noopener ugc nofollow" target="_blank">https://thoughtsandfitness.com</a><br/>加德纳App开发-&gt;<a class="ae iu" href="https://gardnerappdev.com" rel="noopener ugc nofollow" target="_blank">https://gardnerappdev.com</a></p></div></div>    
</body>
</html>