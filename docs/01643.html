<html>
<head>
<title>2D Level Generation For Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2D团结一代</h1>
<blockquote>原文：<a href="https://medium.com/codex/2d-level-generation-for-unity-c7a8185b846a?source=collection_archive---------8-----------------------#2021-05-18">https://medium.com/codex/2d-level-generation-for-unity-c7a8185b846a?source=collection_archive---------8-----------------------#2021-05-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1cc738fccf2f27ce3f39a0a3e406da33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SRp8agD1hPgogKM_"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@lorenzoherrera?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Lorenzo Herrera </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="e9e3" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">介绍</h1><p id="7892" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我第一次进入Unity还没多久，甚至开始考虑随机化级别生成都让我头晕。我以为会是一些荒谬的算法或一些疯狂的工作量。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/3ceb147556a5b66694c29d8d52844512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*Lig_6BKH7VPK6h1hf592Fw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">在Unity编辑器中捕获- <em class="kw">资产记入Unity Technologies </em></figcaption></figure><p id="6d26" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">现在，对于更高级的技术和地形生成的特殊要求来说，这仍然是/可能是正确的，但是对于基础来说，它实际上非常简单，只是需要很多时间。这个想法很简单，使用我整个大学期间一直在使用的东西:嵌套循环。</p><p id="6135" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">你们中的一些人可能已经点头同意了，其他人可能被嵌套循环的使用吓到了。但是不管你的立场是什么，让我们先来看一遍，然后我们来看看结果如何。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="f9ba" class="iv iw hi bd ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js bi translated">旁注</h1><p id="a756" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我创建这个教程是基于这样一个假设:你至少使用过一点Unity，并且熟悉使用Unity编辑器、预置、精灵和脚本。并且你也已经在做一个现有的项目(也许是你的第一个游戏？).</p><p id="9784" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">如果你刚刚开始一个项目，不要从这里开始。在进行随机等级生成之前，您应该设置和配置/学习很多东西。</p><p id="bc3e" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">如果你还没有做过一些Unity教程，Unity<a class="ae iu" href="https://learn.unity.com/" rel="noopener ugc nofollow" target="_blank">Unity</a>有很多很棒的教程可以帮助你快速启动。我强烈建议做一些，即使它们看起来是重复的，这样你就可以熟悉Unity，以及根据你的项目实现相同目标的不同方法。</p><p id="3577" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated"><em class="lo">这个是我跟</em> <a class="ae iu" href="https://learn.unity.com/project/2d-roguelike-tutorial?uv=5.x" rel="noopener ugc nofollow" target="_blank"> <em class="lo">合一</em> </a> <em class="lo">学的，所以功劳归他们。如果您对资产和完整代码感兴趣，请查看链接。否则，我将浏览一下这些想法，以便您可以将它们应用到您自己的项目中。</em></p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="2353" class="iv iw hi bd ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js bi translated">编码部分</h1><pre class="ks kt ku kv fd lp lq lr ls aw lt bi"><span id="1f2d" class="lu iw hi lq b fi lv lw l lx ly">using Random = UnityEngine.Random;<br/>using System;<br/>using System.Collections;<br/>using System.Collections.Generic;<br/>using UnityEngine;</span><span id="b25b" class="lu iw hi lq b fi lz lw l lx ly">public int columns = 8;         // Number of Columns on our 2D board<br/>public int rows = 8;            // Number of Rows on our 2D board<br/>public GameObject[] gameTiles;  // Array of base Tile prefabs<br/>public GameObject[] wallTiles;  // Array of outer wall Tile prefabs<br/>public GameObject[] enemyTiles; // Array of enemy prefabs<br/>public GameObject[] pickupTiles;// Array of pick-up prefabs<br/>public GameObject   exit;       // Object for our exit</span><span id="a4a2" class="lu iw hi lq b fi lz lw l lx ly">// Use to child all our GameObjects to keep the hierarchy clean<br/>private Transform boardHolder;  </span><span id="c643" class="lu iw hi lq b fi lz lw l lx ly">// List of valid locations to place tiles upon<br/>private List&lt;Vector3&gt; gridPositions = new List&lt;Vector3&gt;();</span></pre><p id="a692" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">首先，我们要声明所有的变量。我添加了注释来简单解释一切。</p><p id="da6e" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">对<code class="du ma mb mc lq b">boardHolder</code>来说，就是把所有的游戏对象都放在它的下面，这样我们就可以折叠它们并隐藏它们，而不用填满层级。</p><p id="7801" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">对于<code class="du ma mb mc lq b">gridPositions</code>，用于跟踪板上哪些位置有效(例如。我们不想填充边缘)并跟踪板位置是否已被填充。</p><p id="4c7c" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">对于所有不同种类的牌(如<code class="du ma mb mc lq b">wallTiles</code>、<code class="du ma mb mc lq b">pickupTiles</code>等)。)，为您计划最终放入场景的不同种类的对象创建尽可能多的对象。这可以是迷你墙，路障，buffs，等等。</p><h2 id="0966" class="lu iw hi bd ix md me mf jb mg mh mi jf ke mj mk jj ki ml mm jn km mn mo jr mp bi translated">可选公共最小/最大变量</h2><p id="4be9" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我建议添加一些公共编号(或自定义类)来设置特定对象的最小和/或最大数量。尤其是当您想要在检查器中即时更改它时。例如，对于拾取，您可能希望每个级别最少1个，最多3个，所以添加一些公开跟踪的内容。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="dff5" class="iv iw hi bd ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js bi translated">为有效的对象位置创建2D数组</h1><pre class="ks kt ku kv fd lp lq lr ls aw lt bi"><span id="ee37" class="lu iw hi lq b fi lv lw l lx ly">void InitialiseList() { <br/>    // clear tiles from last generation<br/>    gridPositions.Clear(); </span><span id="8c40" class="lu iw hi lq b fi lz lw l lx ly">    // create our 2D array of valid tile locations<br/>    for (int x = 1; x &lt; columns - 1; x++) { <br/>        for (int y = 1; y &lt; rows - 1; y++) { <br/>            gridPositions.Add(new Vector3(x, y, 0f));<br/>        }<br/>    }<br/>}</span></pre><p id="b55a" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">我们使用嵌套的for循环来遍历x轴和y轴。我们将列表清除并初始化为除了外面两层之外的所有方块，因为我们希望确保玩家至少有一条路径可以到达另一个角落，尽管是最长的路径。因此，我们也有一层外部阻隔墙。</p><p id="4eee" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">在这个函数的最后，我们现在有了一个2D数组，它列出了所有可能的(有效的)位置来放置我们的游戏对象，比如敌人、硬币、资源等等。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/6750661f1d0d650de6f7d147da4f2956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*yeZwFwbKrhFmOBy3zLfTtw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们为红框中的所有东西创建一个空的2D数组，这是放置阻挡者、敌人、接应者等的所有“有效”位置。</figcaption></figure><p id="b0ce" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">接下来，我们用基础地板砖和外墙搭建我们的板。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="a4cb" class="iv iw hi bd ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js bi translated">创建底层</h1><pre class="ks kt ku kv fd lp lq lr ls aw lt bi"><span id="09e0" class="lu iw hi lq b fi lv lw l lx ly">void BoardSetup() {<br/>// Initialize our board<br/>boardHolder = new GameObject("Board").transform; </span><span id="2c13" class="lu iw hi lq b fi lz lw l lx ly">for (int x = -1; x &lt; columns + 1; x++) { <br/>    for (int y = -1; y &lt; rows + 1; y++) { <br/>        // choose a random floor tile and prepare to instantiate it<br/>        GameObject o = gameTiles[Random.Range(0, gameTiles.Length)];</span><span id="5696" class="lu iw hi lq b fi lz lw l lx ly">        // If at edges, choose from outer wall tiles instead<br/>        if (x == -1 || x == columns || y == -1 || y == rows) { <br/>            o = wallTiles[Random.Range(0, wallTiles.Length)];<br/>        } </span><span id="1e69" class="lu iw hi lq b fi lz lw l lx ly">        // Instantiate the chosen tile, at current grid position<br/>        GameObject instance = Instantiate(<br/>            o,<br/>            new Vector3(x, y, 0f),<br/>            Quaternion.identity) as GameObject </span><span id="60d6" class="lu iw hi lq b fi lz lw l lx ly">        // Set parent of our new instance object to boardHolder<br/>        instance.transform.SetParent(boardHolder);<br/>    }<br/>}<br/>}</span></pre><p id="b867" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">总而言之，在我们遍历整个2D数组的每个循环中(这次包括两个外层！)我们执行以下操作:</p><p id="ab0c" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">我们选择一个随机的地板砖(通过从0到我们在数组中的砖预制总数中选择一个随机数来完成)。</p><p id="1c86" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">如果我们碰巧在最外面的边上(当x或y等于-1或者rows/columns变量在这里是8时)，那么我们从我们的外墙数组中选择一个随机的瓷砖。</p><p id="6e5f" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">在我们选择了我们想要的图块之后，我们简单地使用Unity的Instantiate函数在Unity中当前循环的x / y坐标处为该图块创建一个gameObject。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/3ebfbcce8419908d56e039e76070d242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*oWTS_DMbGKAL69kiZK-Jzw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">这一次，我们遍历蓝色边框内的所有内容，包括红色边框内的内容，以便将我们的“基础”tileset与地面和外墙放在一起。</figcaption></figure></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="4994" class="iv iw hi bd ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js bi translated">随机组合辅助函数</h1><pre class="ks kt ku kv fd lp lq lr ls aw lt bi"><span id="3640" class="lu iw hi lq b fi lv lw l lx ly">Vector3 RandomPosition(){ <br/>// random index between 0 and total count of items in gridPositions<br/>int randomIndex = Random.Range(0, gridPositions.Count); </span><span id="ed5c" class="lu iw hi lq b fi lz lw l lx ly">// random position selected from our gridPosition using randomIndex<br/>Vector3 randomPosition = gridPositions[randomIndex] </span><span id="5234" class="lu iw hi lq b fi lz lw l lx ly">// remove the entry from gridPosition so it can't be re-used<br/>gridPositions.RemoveAt(randomIndex); </span><span id="8ee5" class="lu iw hi lq b fi lz lw l lx ly">return randomPosition;<br/>}</span></pre><p id="93f1" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">这只是一个帮助我们从有效位置列表中轻松获得一个随机位置的函数，用来在我们的棋盘上放置我们的游戏对象。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="cc75" class="iv iw hi bd ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js bi translated">用物体填充游戏板</h1><p id="4b44" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在最后一步之前，我们不会使用这个函数，所以不要担心我们将从哪里得到我们的图块数组，min或max。</p><pre class="ks kt ku kv fd lp lq lr ls aw lt bi"><span id="c277" class="lu iw hi lq b fi lv lw l lx ly">void LayoutObjectAtRandom(GameObject[] tileArray, int min, int max){<br/>// random amount to instantiate from given range <br/>int objectCount = Random.Range(min, max+1); </span><span id="5bd2" class="lu iw hi lq b fi lz lw l lx ly">// Place objects at random locations until object count limit<br/>for (int i = 0; i &lt; objectCount; i++ { <br/>    // use our helper function to get random position<br/>    Vector3 randomPosition = RandomPosition(); </span><span id="4167" class="lu iw hi lq b fi lz lw l lx ly">    // Choose a random tile (pick-up, enemy, etc.) <br/>    GameObject tileChoice = <br/>        tileArray[Random.Range(0, tileArray.Length)]; </span><span id="c7e4" class="lu iw hi lq b fi lz lw l lx ly">    // Instantiate the chosen tile at the chosen location<br/>    Instantiate(tileChoice, randomPosition, Quaternion.identity);<br/>}<br/>}</span></pre><p id="9f07" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">首先，我们在给定的最小值/最大值之间选择一个随机数。我们会循环精确的次数。这意味着此处选择的数字将是为给定图块阵列创建的对象总数。</p><p id="fc8a" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">当我们循环时，我们通过使用之前的辅助函数来选择随机的位置。然后，我们使用Unity的random选择随机牌，就像我们选择基础牌一样。</p><p id="edd7" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">最后，我们再次使用实例化我们选择的随机位置和随机瓷砖。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="f642" class="iv iw hi bd ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js bi translated">设置场景</h1><p id="d606" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">现在，让我们创建我们的设置函数，并使用我们刚刚在上面创建的函数。这将是唯一一个从外部调用的函数，它将从头开始设置整个地图。</p><pre class="ks kt ku kv fd lp lq lr ls aw lt bi"><span id="e2a4" class="lu iw hi lq b fi lv lw l lx ly">public void SetupScene(int level){<br/>// Call our function to create our outer walls and floor.<br/>BoardSetup();</span><span id="4a86" class="lu iw hi lq b fi lz lw l lx ly">// Re-create our list of valid gridPositions<br/>InitialiseList();</span><span id="0ccf" class="lu iw hi lq b fi lz lw l lx ly">// Fill a random number of pick-up tiles <br/>LayoutObjectAtRandom(pickupTiles, 1, 3)</span><span id="9726" class="lu iw hi lq b fi lz lw l lx ly">// Determine number of enemies based on current "level"<br/>// Fill a random number of creatures <br/>int enemies = (int)Mathf.Log(level, 2f);<br/>LayoutObjectAtRandom(enemyTiles, enemies, enemies); </span><span id="2a60" class="lu iw hi lq b fi lz lw l lx ly">// Put in our exit in top right <br/>Instantiate(<br/>    exit,<br/>    new Vector3 (columns -1, rows -1, 0f),<br/>    Quaternion.identity<br/>);<br/>}</span></pre><p id="3dc8" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">如果你创建了一个公众号(或者自定义类)，在我们的第一步，对于你对象的最小值/最大值，在这里使用它！</p><p id="3510" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">根据“等级”或“难度”，随意调整你想要的敌人数量我只是把它加到这里来说明你可以用一个关卡做一些特别的事情。</p><p id="3736" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">我们的出口对象也可以做同样的事情，这取决于你的角色从哪里开始，你可以随意把出口放在其他地方。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="5445" class="iv iw hi bd ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js bi translated">包扎</h1><p id="7e39" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">最后，您应该在Unity Editor explorer中选择用于级别生成的C#脚本，并将其拖动到层次结构中。你需要把你的对象的预设从浏览器拖到检查器中，在你的脚本的正确的公共变量下。</p><p id="5abe" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated"><em class="lo">提示:选择脚本后，点击右上角的锁，这样你会更轻松。确保之后保存你的脚本预置！</em></p><p id="62dd" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">剩下的唯一事情就是在一些“游戏管理器”或一些管理器脚本中调用SetupScene函数来控制你何时想要创建一个新的随机地图。这可以是许多不同的形式，取决于你的项目。在我的项目中，我为我的游戏管理器使用了单例模式。我现在可以给出的一些提示是确保使用<code class="du ma mb mc lq b">DontDestroyOnLoad</code>和标准的<code class="du ma mb mc lq b">GetComponent&lt;BoardManager&gt;();</code>，这相对简单。</p><h1 id="4208" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">最后的想法</h1><p id="4066" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">现在这是一个很长的教程，但我想确保我已经涵盖了一切，所以你可以把它作为一个模板，并将其应用到你自己的项目中，或作为一个关于你的游戏关卡生成的想法的一般演练。希望通过更详细的介绍，我能够帮助您更好地理解这个过程，这样您就可以更容易地将它集成到您的项目中。</p><p id="9963" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">我知道这个教程可能感觉相当冗长和枯燥，但我想详细一些，这样它对初学者和中间用户都有好处。</p><p id="ad06" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">我发现添加额外的细节有助于回答人们可能有的问题，并帮助他们更好地理解正在发生的事情，即使这需要额外的阅读。</p><p id="a02a" class="pw-post-body-paragraph jt ju hi jv b jw kx jy jz ka ky kc kd ke kz kg kh ki la kk kl km lb ko kp kq hb bi translated">如果你有任何问题，请随时提问！<em class="lo"> </em>我希望我能帮助你更好地理解2D的级代团结。</p></div></div>    
</body>
</html>