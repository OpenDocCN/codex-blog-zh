<html>
<head>
<title>Emergent Design with Clean Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码简洁的紧急设计</h1>
<blockquote>原文：<a href="https://medium.com/codex/emergent-design-with-clean-code-2116cec8edf1?source=collection_archive---------12-----------------------#2021-08-20">https://medium.com/codex/emergent-design-with-clean-code-2116cec8edf1?source=collection_archive---------12-----------------------#2021-08-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="34b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于<em class="jd">干净代码</em>的一个伟大的事情是，随着你阅读这本书的进展，你所涵盖的概念变得更加抽象。在我看来，这种实践反映了一个人如何更好地掌握编程艺术本身。当你开始阅读<em class="jd">干净代码</em>时，你会学到一些概念，比如变量或函数的好名字，以及一个类的最佳行数。然而，当你继续读下去的时候，Bob叔叔公司详细说明了你如何从你的代码中抽身出来，并确保它是设计良好的，你的一个同事可以在任何一天进入你的程序，并很容易理解你想要它做什么。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/6a16cbf6b3ba8aa0167c6cbfee7d5f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*sSa07nkG0yT2MSmWCHljIw.png"/></div></figure><p id="1869" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，一旦你掌握了一门语言或框架的语法和基本特性，你就能够<a class="ae jm" href="https://tomassetti.me/raising-the-level-of-abstraction-what-if-we-tried-to-do-that-bottom-up/" rel="noopener ugc nofollow" target="_blank">到代码的抽象层</a>，专注于程序的整体设计和可维护性。我这里指的是<a class="ae jm" href="https://en.wikipedia.org/wiki/Emergent_Design#Emergent_design_in_agile_software_development" rel="noopener ugc nofollow" target="_blank">紧急设计</a>，敏捷软件开发中的一个概念，它敦促开发人员专注于构建应用程序的功能，并让系统的整体设计随着时间的推移而出现。在这篇博客中，我将回顾<em class="jd">干净代码</em>促进紧急设计的一般规则(按重要性排序)，以及如何构建可读性和可维护性更强的健壮程序。</p></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h2 id="3fe7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">规则1:运行所有的测试</h2><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kp"><img src="../Images/cb35b6ecf65cd4f7c6f6a0cd3dfe285e.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*B17-DCi0JxCrQ3TC.jpg"/></div></figure><p id="b0da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然我们在之前已经<a class="ae jm" rel="noopener" href="/geekculture/reading-clean-code-week-5-unit-tests-ccbfe31b6460?source=your_stories_page-------------------------------------">讨论过测试，但它值得重复。为了使这一课简单，我将重复我在软件开发领域的导师们对我说的最常引用的一句话:</a><a class="ae jm" href="https://maurits.vanrees.org/weblog/archive/2007/10/untested-code-is-broken-code" rel="noopener ugc nofollow" target="_blank">未经测试的代码是破损的代码</a>。正如<em class="jd"> Clean Code </em>所说，一个未经测试的程序是一个不可验证的程序；也就是说，您不能检查您的代码是否始终如一地做您想要它做的事情。如果你不能检查一个系统做什么，你最好不要部署它。</p><p id="8e3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然我可能听起来像一张破唱片，但对测试进行优先排序本质上迫使我们写更干净的代码。例如，如果一个程序的所有逻辑都存在于单个文件中，那么测试将会非常困难。为了编写这种逻辑的测试，你需要将你的函数分解到单独的文件中，默认情况下更紧密地遵循<a class="ae jm" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank"> SRP </a>，最终使你的程序更小。此外，这种实践非常适合松散耦合和高内聚。因此，如果你从这篇博客文章中没有收集到任何其他信息，请收集以下信息:编写你的测试。</p></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h2 id="d362" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">规则2:重构</h2><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kq"><img src="../Images/ebf3d131587d9e6cad35f9579a1361c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/0*LOLd1N8XWqFxBJEI.gif"/></div></figure><p id="dcb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们之前也提到过<a class="ae jm" href="https://levelup.gitconnected.com/reading-c%CC%B6l%CC%B6e%CC%B6a%CC%B6n%CC%B6-c%CC%B6o%CC%B6d%CC%B6e%CC%B6-refactoring-week-4-a7abe6539eb3?source=your_stories_page-------------------------------------" rel="noopener ugc nofollow" target="_blank">重构</a>，但是和测试一样，这是一个非常重要的主题，我们应该更深入地讨论它。简而言之，重构我们的代码对于好的设计是必不可少的。事实上，关于重构的规则排在关于测试的规则之后有一个很好的理由:如果我们有好的测试，我们可以确信我们的程序做了我们想要它做的事情，<em class="jd">即使我们改变它</em>。正如Jeff Langr在<em class="jd">干净代码</em>中所写的:</p><blockquote class="kr ks kt"><p id="9e69" class="if ig jd ih b ii ij ik il im in io ip ku ir is it kv iv iw ix kw iz ja jb jc hb bi translated">我们有这些测试的事实消除了对清理代码会破坏它的担心！</p></blockquote><p id="fd11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管这可能是一个令人生畏的命题，但是增量重构我们的代码是非常重要的。在重新审视我们的逻辑时，我们给自己一个机会来采用编程最佳实践、选择更好的名称、模块化我们的逻辑等等。随着测试和重构处于紧急设计的前沿，我们可以用最后三条规则来微调我们的代码。</p></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h2 id="160a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">规则3:不要重复</h2><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kx"><img src="../Images/89367a1fac4b5e9d36f8f2077796eb1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Fr4aMmDLj9gu65oV.jpg"/></div></div></figure><p id="4972" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一点上，你可能会看到我用这篇文章总结了很多我之前的博文。虽然还有更多章节可以阅读，我也即将发表关于<em class="jd">干净代码</em>的博客文章，但这一章很好地概括了这本书，总结了许多你希望编写一个有凝聚力的软件时最重要的要点。</p><p id="cd72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重复的代码会给系统带来不必要的复杂性，伴随着这种复杂性，您的程序也有更多失败的机会。通过消除这种重复，您的代码变得更加可重用。虽然有很多方法可以让你的代码保持清晰，但是<em class="jd"> Clean Code </em>特别提到了来自极具影响力的<a class="ae jm" href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_1?dchild=1&amp;keywords=design+patterns&amp;qid=1629484668&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank"> <em class="jd">设计模式</em> </a>的<a class="ae jm" href="https://refactoring.guru/design-patterns/template-method" rel="noopener ugc nofollow" target="_blank">模板方法</a>，作为降低复杂性的一种方式。</p></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h2 id="b324" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">规则4:表现力</h2><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lc"><img src="../Images/e2f1fc0054701f26528ac7dc365ee7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*bUBHOGxh3eyyiAfu.jpg"/></div></figure><p id="af86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们都有过这种经历，试图破译不清楚的代码，煞费苦心地研究每一行，寻找出现的模式。通常，我们是最初编写难以理解的代码的程序员，这使得混乱的刺痛更加严重。正如<em class="jd"> Clean Code </em>告诉我们的，“软件项目的大部分成本都在长期维护中。”因此，我们编写团队中每个人都能理解的软件是至关重要的。</p><p id="cc0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以代码为媒介，有很多方法可以很好地表达我们自己。好的名字有助于我们编写有表现力的代码，小函数和分离关注点也是如此。此外，单元测试是使我们的代码更有表现力的另一种方式。当我们运行测试时，我们对代码的意图有了更好的理解。</p></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><h2 id="73f3" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">规则5:最小化类和方法</h2><p id="e718" class="pw-post-body-paragraph if ig hi ih b ii ld ik il im le io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">虽然遵循规则3和4很重要，但我们不想走得太远，创建数千个类和/或文件来完成我们的任务。在保持类和方法小的过程中，我们可能会制造太多的类和方法，这最终会增加代码的复杂性并降低我们的速度。事实上，编写干净的代码是一种平衡行为；在努力实现目标的过程中，你会不断地问自己这个方法是不是太大了？我的课太多了吗？这些测试很脆弱吗？</p><p id="d49a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">坦率地说，这种不确定性是编程的本质。对于大多数编码问题来说，没有固定的“正确答案”。编程是一种创造性的练习，一种永远不会完美的练习，但是在试图变得完美的过程中，我们每天都会变得更好一点。随着你技能的提高，没有“完美代码”的想法从极度恐惧到最终解脱。在尝试编写干净代码的过程中，你将作为一名程序员得到提高，你将推动你的同事提高，你将创造出令人惊叹的东西。有什么工作能比这更好呢？</p></div><div class="ab cl jn jo gp jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="hb hc hd he hf"><p id="6d30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一章的结尾，Langr提到，虽然遵循这些规则很重要，但是没有任何指导方针可以胜过从经验中获得的专业知识。尽管如此，通过关注这些原则，各种水平的程序员都增加了他们编写干净代码的可能性，并在这样做的过程中，创建优雅的软件。</p><p id="0c81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编码快乐！</p></div></div>    
</body>
</html>