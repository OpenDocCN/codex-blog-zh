<html>
<head>
<title>Big O: The ultimate pillar of Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O:编程的终极支柱</h1>
<blockquote>原文：<a href="https://medium.com/codex/big-o-the-ultimate-pillar-of-programming-f8777c898f21?source=collection_archive---------12-----------------------#2021-07-01">https://medium.com/codex/big-o-the-ultimate-pillar-of-programming-f8777c898f21?source=collection_archive---------12-----------------------#2021-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5af7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">任何人都可以编码。但是只有少数人能写出完美的代码。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/29322f309c3f9e52d48a21f81f0ca3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w3G9RVBCVgVx0JoK"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">迈克尔·泽兹奇在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="21e0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">作为一名非计算机专业的学生，每当我得到正确无误的输出时，我总是感觉世界就在我的脚下。我从不担心我在程序中使用的变量的数量和我写代码的行数。我唯一的目标是看到零错误和正确输出的控制台。</p><blockquote class="kk"><p id="1c1f" class="kl km hi bd kn ko kp kq kr ks kt kj dx translated">“糟糕的程序员担心代码。优秀的程序员担心<strong class="ak">时间复杂度</strong>和<strong class="ak">空间复杂度</strong></p></blockquote><p id="01c5" class="pw-post-body-paragraph jo jp hi jq b jr ku ij jt ju kv im jw jx kw jz ka kb kx kd ke kf ky kh ki kj hb bi translated">我的第一次编码面试让我意识到这些天来我一直是个糟糕的程序员。我想知道为什么招聘人员没有把我列入候选名单，尽管我的代码给出了期望的结果。那是因为我写了一个时间复杂度为O(n)的代码，而不是得到时间复杂度为O(1)的相同输出。哎呀。！！:-(</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kz"><img src="../Images/0159cdc63f6825bfa282ade8d39140e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tFzcJsL9WhLhhFT4"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@firdoussross?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗多斯·罗斯</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4f36" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在生活中，我们都知道有成百上千条通往成功的道路。同样，在编程中有许多方法可以找到正确的解决方案。但是我们如何找到正确的道路呢？与其努力工作，写无数行代码，不如让自己的“聪明工作”从“努力工作”手中抢夺王位。这就是“大O”发挥作用的地方。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="12bb" class="lh li hi bd lj lk ll lm ln lo lp lq lr io ls ip lt ir lu is lv iu lw iv lx ly bi translated"><strong class="ak">什么是大O？</strong></h1><p id="4d0e" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">在编程中，大O就像听起来一样强大。好的代码是可读的、可伸缩的、可T21的。大O符号允许程序员编写可扩展的代码。它让编码人员了解他们代码的性能。</p><blockquote class="mf mg mh"><p id="e55d" class="jo jp me jq b jr js ij jt ju jv im jw mi jy jz ka mj kc kd ke mk kg kh ki kj hb bi translated">大O符号通常用于从理论上衡量和比较算法的最坏情况。</p></blockquote><p id="1034" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">算法通常属于这些<strong class="jq hj"> 7大时间复杂度</strong>之一，从效率最高到最低。</p><ol class=""><li id="47de" class="ml mm hi jq b jr js ju jv jx mn kb mo kf mp kj mq mr ms mt bi translated"><strong class="jq hj"> O(1) </strong></li><li id="0c69" class="ml mm hi jq b jr mu ju mv jx mw kb mx kf my kj mq mr ms mt bi translated"><strong class="jq hj"> O(对数n) </strong></li><li id="e91c" class="ml mm hi jq b jr mu ju mv jx mw kb mx kf my kj mq mr ms mt bi translated"><strong class="jq hj"> O( <em class="me"> n </em> ) </strong></li><li id="fc5e" class="ml mm hi jq b jr mu ju mv jx mw kb mx kf my kj mq mr ms mt bi translated"><strong class="jq hj"> O(n log n) </strong></li><li id="1220" class="ml mm hi jq b jr mu ju mv jx mw kb mx kf my kj mq mr ms mt bi translated"><strong class="jq hj"> O(n ) </strong></li><li id="d0c5" class="ml mm hi jq b jr mu ju mv jx mw kb mx kf my kj mq mr ms mt bi translated"><strong class="jq hj"> O(2^n) </strong></li><li id="465d" class="ml mm hi jq b jr mu ju mv jx mw kb mx kf my kj mq mr ms mt bi translated"><strong class="jq hj"> O(n！)</strong></li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/8a20db2e7e4110bdd972914a43f9dec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kn2nATGlKL5u0VqJ.jpeg"/></div></div></figure><h2 id="3f55" class="na li hi bd lj nb nc nd ln ne nf ng lr jx nh ni lt kb nj nk lv kf nl nm lx nn bi translated"><em class="no"> 1。O(1) —常数时间</em></h2><p id="aada" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">如果一个算法无论输入大小如何都需要相同的时间，那么它就可以说是在恒定时间内运行。这意味着无论输入多大或多小，运行时间都将保持不变。例如:</p><pre class="iy iz ja jb fd np nq nr ns aw nt bi"><span id="e80b" class="na li hi nq b fi nu nv l nw nx">if (3==3):<br/>   return True<br/>else:<br/>   return False</span></pre><p id="2b38" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">具有恒定时间复杂度的算法是极好的，因为我们不需要担心输入大小。</p><h2 id="9433" class="na li hi bd lj nb nc nd ln ne nf ng lr jx nh ni lt kb nj nk lv kf nl nm lx nn bi translated"><strong class="ak"> 2。O(log n) —对数时间</strong></h2><p id="ad16" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">如果一个算法在每一步中减少了输入数据的大小，就说它具有对数时间复杂度。例如:</p><pre class="iy iz ja jb fd np nq nr ns aw nt bi"><span id="e936" class="na li hi nq b fi nu nv l nw nx">for num in range(0,len(a),2):<br/>       print(a[num])</span></pre><p id="9303" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">其中一个现实世界的应用是谷歌搜索引擎。</p><h2 id="bf7b" class="na li hi bd lj nb nc nd ln ne nf ng lr jx nh ni lt kb nj nk lv kf nl nm lx nn bi translated"><strong class="ak"> 3。O( <em class="no"> n </em> ) —线性时间</strong></h2><p id="1501" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">具有O(n)的算法的运行时间具有线性运行时间。这意味着当运行时间随着输入数据的大小最多线性增加时，算法被认为具有线性时间复杂度。例如:</p><pre class="iy iz ja jb fd np nq nr ns aw nt bi"><span id="7be2" class="na li hi nq b fi nu nv l nw nx">for num in range(100):<br/>     if (num%2==0):<br/>          print num</span></pre><p id="3513" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在上面的例子中，我们需要查看该范围内的所有数字，以找到我们要寻找的值。</p><h2 id="7444" class="na li hi bd lj nb nc nd ln ne nf ng lr jx nh ni lt kb nj nk lv kf nl nm lx nn bi translated"><strong class="ak"> 4。O(n log n) —准线性时间</strong></h2><p id="dabd" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">重复将一组数据分成两半，然后用时间复杂度为O(N)的子算法独立处理这两半的算法，总时间复杂度为O(N log N)。例如:</p><pre class="iy iz ja jb fd np nq nr ns aw nt bi"><span id="0aeb" class="na li hi nq b fi nu nv l nw nx"><strong class="nq hj">from</strong> random <strong class="nq hj">import</strong> randrange <br/>input = [10, 5, 2, 3, 7, 0, 9, 12] <br/><strong class="nq hj">def</strong> <strong class="nq hj">quicksort</strong>(arr): <br/>    <strong class="nq hj">if</strong> len(arr) &lt; 2: <br/>       <strong class="nq hj">return</strong> arr <br/>    <strong class="nq hj">else</strong>: <br/>       rand = randrange(0, len(arr))  <em class="me"># grab a random <br/>       index</em> pivot = arr.pop(rand) <br/>       less = [i <strong class="nq hj">for</strong> i <strong class="nq hj">in</strong> arr <strong class="nq hj">if</strong> i &lt;= pivot] <br/>       greater = [i <strong class="nq hj">for</strong> i <strong class="nq hj">in</strong> arr <strong class="nq hj">if</strong> i &gt; pivot] <br/>       <strong class="nq hj">return</strong> quicksort(less) + [pivot] + quicksort(greater) <br/>print(“sorted: “, quicksort(input))</span></pre><p id="4292" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">O(N log N)算法的更多例子是合并排序和堆排序。</p><h2 id="2d98" class="na li hi bd lj nb nc nd ln ne nf ng lr jx nh ni lt kb nj nk lv kf nl nm lx nn bi translated"><strong class="ak"> 5。O(n ) —二次时间</strong></h2><p id="9730" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">当运算次数变成元素数量的平方时，算法就是“二次的”。它通常出现在嵌套循环中。例如:</p><pre class="iy iz ja jb fd np nq nr ns aw nt bi"><span id="55be" class="na li hi nq b fi nu nv l nw nx">for i in range(13):<br/>   for j in range(11):<br/>       print(i*j)</span></pre><p id="394f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">冒泡排序是二次时间复杂度的一个著名例子。</p><h2 id="8d67" class="na li hi bd lj nb nc nd ln ne nf ng lr jx nh ni lt kb nj nk lv kf nl nm lx nn bi translated"><strong class="ak"> 6。O(2^n) —指数时间</strong></h2><p id="77d2" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">当运算次数随元素数量呈指数增长时，算法就是“指数型”的。考虑一种算法，其实现是计算相对于计算输出呈指数增长的斐波那契数。</p><pre class="iy iz ja jb fd np nq nr ns aw nt bi"><span id="bb4c" class="na li hi nq b fi nu nv l nw nx"><strong class="nq hj">def</strong> <strong class="nq hj">fibonacci</strong>(num):<br/>   <strong class="nq hj">if</strong> (num &lt;= 1): <br/>       <strong class="nq hj">return</strong> num <br/>   <strong class="nq hj">return</strong> fibonacci(num — 2) + fibonacci(num — 1)</span></pre><p id="a92c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这种时间复杂度通常见于蛮力算法。</p><h2 id="081b" class="na li hi bd lj nb nc nd ln ne nf ng lr jx nh ni lt kb nj nk lv kf nl nm lx nn bi translated"><strong class="ak"> 7。O(n！)—阶乘时间</strong></h2><blockquote class="mf mg mh"><p id="b625" class="jo jp me jq b jr js ij jt ju jv im jw mi jy jz ka mj kc kd ke mk kg kh ki kj hb bi translated">O(n！)==“哦不！”</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ny"><img src="../Images/6ccadd405b74b02c986e6ed47a4b8a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HRdlFYYQvC5yAIjf"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Ryan Snaadt 在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6599" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这种时间复杂度效率最低。当运算的数量随着与元素数量相关联的排列的数量而增加时，算法是“阶乘的”。例如:</p><pre class="iy iz ja jb fd np nq nr ns aw nt bi"><span id="3b1b" class="na li hi nq b fi nu nv l nw nx">def factorial(n):<br/>    if (n==1 or n==0):<br/>        return 1<br/>    else:<br/>        return n * factorial(n - 1)</span></pre><p id="0871" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">具有阶乘时间复杂性的算法的另一个很好的例子是堆算法，它用于生成所有可能的<em class="me"> n </em>对象的排列。</p></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="5301" class="lh li hi bd lj lk ll lm ln lo lp lq lr io ls ip lt ir lu is lv iu lw iv lx ly bi translated"><strong class="ak">大魔神小抄</strong></h1><p id="6d74" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">最常见的数据结构中的操作的时间复杂度在这个备忘单中给出，以使你的生活更容易。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nz"><img src="../Images/af29fbbc8aa9a25a8020ef5d8ea24f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RevnKy6jBDJPOdBf.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">数据结构操作的大O记法:<a class="ae jn" href="http://bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">http://bigocheatsheet.com/</a></figcaption></figure><p id="24fc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是另一张关于最常见排序算法的时间复杂度的表格。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oa"><img src="../Images/3bbff1bd18d0692d9859d6a2e9fdce34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OR0DewISuZXeEmfw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">数组排序算法的大O记法:【http://bigocheatsheet.com/ T2】</figcaption></figure></div><div class="ab cl la lb gp lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="hb hc hd he hf"><h1 id="d43c" class="lh li hi bd lj lk ll lm ln lo lp lq lr io ls ip lt ir lu is lv iu lw iv lx ly bi translated"><strong class="ak">底线</strong></h1><p id="4402" class="pw-post-body-paragraph jo jp hi jq b jr lz ij jt ju ma im jw jx mb jz ka kb mc kd ke kf md kh ki kj hb bi translated">我再怎么强调大O符号对所有软件开发人员的重要性也不为过。尽管你可以逃避它，或者从不关心它的表现，但在某个时候你会受到它的影响。因此，让我们改掉旧的糟糕的编码习惯，通过灌输在编码时记住时间复杂性和空间复杂性的习惯，成为更好的程序员。</p></div></div>    
</body>
</html>