<html>
<head>
<title>SQL Server query mode execution and columnstore indexes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL Server查询模式执行和列存储索引</h1>
<blockquote>原文：<a href="https://medium.com/codex/sql-server-query-mode-execution-and-columnstore-indexes-fa05152c0753?source=collection_archive---------6-----------------------#2022-03-05">https://medium.com/codex/sql-server-query-mode-execution-and-columnstore-indexes-fa05152c0753?source=collection_archive---------6-----------------------#2022-03-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5a6d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在SQL Server 2017上“无”列存储索引激活批处理模式执行的魔术！</h2></div><p id="9c93" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文介绍了两种SQL Server查询处理方法，即行模式执行和批处理模式执行。我们还将描述在SQL Server 2017上启用批处理模式执行的独特机制，即使您无法创建列存储索引。</p><h2 id="d0e3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">行模式执行</h2><p id="bc3c" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">行模式执行是一种用于传统的基于磁盘的表的查询处理方法，其中数据以行格式存储。使用这种传统存储格式的表也称为“行存储表”。当执行查询并访问行存储表中的数据时，执行树操作符和子操作符读取表模式中指定的所有列中的每个所需行。然后，SQL Server从读取的每一行中检索结果集所需的列，如SELECT语句、联接谓词或筛选谓词所引用的列。</p><p id="a81c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于OLTP场景，行模式执行非常有效，但是在扫描大量数据时，例如在数据仓库场景中，效率可能较低。</p><h2 id="1240" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">批处理模式执行</h2><p id="8279" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">批处理模式执行是一种用于同时处理多行的查询处理方法。这种方法基于向量的使用，批处理中的每一列都作为向量存储在单独的内存区域中。批处理模式执行使用针对多核CPU优化的算法，确保更高的内存吞吐量。批处理方法的第一个实现是与columnstore存储格式紧密集成和优化的，但是这是两个独立的特性。</p><p id="ca47" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当查询以批处理模式执行并访问列存储索引中的数据时，执行树操作符和子操作符一起读取列段中的多行。SQL Server只读取结果所需的列，如SELECT语句、联接谓词或筛选谓词所引用的列。批处理模式执行是非常高效的数据仓库场景，在这种场景中，要读取和聚合大量数据。</p><p id="e12f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">批处理模式执行已经随着时间的推移而扩展，因此从SQL Server 2019和Azure SQL数据库开始，它不需要使用列存储索引。这是rowstore上新的批处理执行模式，允许您在没有列存储索引的情况下在分析工作负载中同时处理多行。在SQL Server 2019和Azure SQL数据库中对rowstore执行批处理模式，可以为所有支持此功能的执行计划操作符启用批处理模式。</p><p id="025f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你们中的一些人想知道，在不添加列存储索引的情况下，是否有可能在SQL Server 2017中启用行存储的批处理执行模式…你所想的可能有一个技巧，让我们看看如何实现！</p><p id="246d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将在其上运行示例查询的数据库是兼容级别设置为SQL Server 2017 (140)的<a class="ae kt" href="https://docs.microsoft.com/en-us/sql/samples/adventureworks-install-configure?WT.mc_id=DP-MVP-4029181" rel="noopener ugc nofollow" target="_blank"> AdventureWorks2017 </a>。AdventureWorks2017数据库的这一副本包含dbo.bigTransactionHistory表，该表是由于由<a class="ae kt" href="https://www.linkedin.com/in/adammachanic" rel="noopener ugc nofollow" target="_blank">亚当·基尼克</a>开发并发表在他的文章<a class="ae kt" href="http://dataeducation.com/thinking-big-adventure/" rel="noopener ugc nofollow" target="_blank"> Thinking Big (Adventure) </a>中的脚本而添加的。该表包含很多被管理产品的交易，它包含31.263.601行！</p><p id="1fe6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑以下查询，该查询提取仓库中产品的动态库存水平，并返回根据仓库数量计算的累计。返回的数据集按产品标识符和交易标识符排序。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="1843" class="jt ju hi kz b fi ld le l lf lg">SELECT<br/>  ProductID<br/>  ,TransactionID<br/>  ,Quantity<br/>  ,SUM(Quantity) OVER(PARTITION BY ProductID ORDER BY TransactionID ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)</span><span id="a828" class="jt ju hi kz b fi lh le l lf lg">FROM<br/>  dbo.bigTransactionHistory<br/>ORDER BY<br/>  ProductID<br/>  ,TransactionID;</span></pre><p id="ae41" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为查询生成的执行计划使用并行性，IX_ProductId_TransactionDate索引被完全读取(索引扫描),因为没有过滤谓词。排序运算符按TransactionID、ProductID和数量对数据进行排序。</p><p id="17e5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">排序操作(排序任务)是执行计划中开销最大的操作，它也用警告符号(排序警告)突出显示，因为它使用tempdb系统数据库(在tempdb上溢出)。随后，在执行流中，数据按ProductID(段)进行分区，并进行聚合(流聚合)以计算Quantity列上的运行总数。</p><p id="e2f1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如下图所示，查询计划中的所有任务都是以“行模式”执行的。</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es li"><img src="../Images/efe1d75b77252ada9818f3601b87275c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFqUy2wsUtszpglrNS3vdw.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图1 —行模式执行</figcaption></figure><p id="9a2b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在测试环境中，这个查询的执行需要40秒(不返回数据)。如果以批处理模式运行，此查询将具有巨大的优势，但我们没有SQL Server 2019，并且我们不想向dbo.bigTransactionHistory表添加列存储索引，因为它会受到OLTP工作负载的影响。</p><p id="8c36" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用一个技巧:<strong class="iz hj">创建一个过滤后的columnstore索引，其过滤谓词包含一个矛盾</strong>，比如请求让TransactionID列同时等于-1和-2！过滤后的columnstore索引将为空，因此它不会给DML查询增加任何开销，同时，它将激活批处理模式处理！</p><p id="9f52" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面的T-SQL代码实现了对dbo.bigTransactionHistory表创建筛选的列存储索引。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a484" class="jt ju hi kz b fi ld le l lf lg">CREATE NONCLUSTERED COLUMNSTORE INDEX<br/>  NCCX_bigTransactionHistory_TransactionID<br/>    ON dbo.bigTransactionHistory (TransactionID)<br/>    WHERE (TransactionID = -1 AND TransactionID = -2);</span></pre><p id="f67b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们现在有了一个列存储索引(即使为空),所以启用了批处理模式执行，执行计划继续以并行性为特征，但是除了索引查找之外，操作符都以批处理模式工作。排序运算符仍然具有最高的开销，但向窗口聚合运算符提供数据，该运算符已取代了段、序列项目、窗口假脱机和流聚合运算符，如下图所示。</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lu"><img src="../Images/5319c59fb219ec662121711c057d62b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mBQqzU7xzakB6CfqAwykjQ.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图2 —批处理模式执行</figcaption></figure><p id="bead" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在测试环境中，查询的执行大约需要20秒(不返回数据)。与前一次运行相比时间减半(行模式执行)。</p><p id="997a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过在ProductID和TransactionID列上创建以下索引并包含Quantity列(在INCLUDE子句中)，可以提高查询的性能。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="7a60" class="jt ju hi kz b fi ld le l lf lg">CREATE NONCLUSTERED INDEX<br/>  IX_bigTransactionHistory_ProductID_TransactionID<br/>    ON dbo.bigTransactionHistory (ProductID, TransactionID)<br/>    INCLUDE(Quantity);</span></pre><p id="7423" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为现在查询有了一个覆盖的索引，所以我们有了有史以来最好的计划，批处理模式执行，无需对任务进行排序，如下图所示。</p><figure class="ku kv kw kx fd lj er es paragraph-image"><div class="er es lv"><img src="../Images/4b4a31297c67badba00960d38fffd82e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*eJTALRdhGKFFh_-nMWKtZA.jpeg"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图3 —无分类任务的批处理模式执行</figcaption></figure><h2 id="bad7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">摘要</h2><p id="5471" class="pw-post-body-paragraph ix iy hi iz b ja ko ij jc jd kp im jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">SQL Server 2019和Azure SQL数据库中的批处理模式执行不需要使用列存储索引。在SQL Server 2017中，可以通过创建筛选的列存储索引来激活批处理模式执行，在该索引中指定了矛盾的条件，例如(TransactionID = -1和TransactionID = -2)。以这种方式创建的筛选列存储索引没有维护成本，但是它将为支持这种处理方法的操作者激活批处理模式执行！</p><p id="e91f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">享受SQL Server和T-SQL语言！</p></div></div>    
</body>
</html>