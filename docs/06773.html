<html>
<head>
<title>How does Apache ShardingSphere implement distributed transactions?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache ShardingSphere是如何实现分布式事务的？</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-does-apache-shardingsphere-implement-distributed-transactions-48f9b7cee6d8?source=collection_archive---------8-----------------------#2022-05-12">https://medium.com/codex/how-does-apache-shardingsphere-implement-distributed-transactions-48f9b7cee6d8?source=collection_archive---------8-----------------------#2022-05-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8e67" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">随着数据量的增加和流量负载的增加，业务系统面临着巨大的挑战，对数据库系统的可扩展性有着强烈的需求。传统独立数据库如<a class="ae jf" href="https://www.oracle.com/" rel="noopener ugc nofollow" target="_blank"> Oracle </a>、<a class="ae jf" href="https://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>、<a class="ae jf" href="https://www.microsoft.com/en-us/sql-server/sql-server-downloads" rel="noopener ugc nofollow" target="_blank"> SQL Server </a>和<a class="ae jf" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>的在线扩展问题现在比以往任何时候都更加明显。在这种情况下，可以向外扩展的分布式数据库就是为了解决这些扩展挑战而设计的。所有这些都意味着分布式事务是一个必须解决的问题。</p><p id="1264" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">在这种情况下，ShardingSphere提供了一个分布式数据库计算增强引擎，该引擎可以通过一个生态系统来支持分布式事务，该生态系统由于面向插件的架构而易于扩展。</p><h1 id="c74e" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">交易处理</h1><h2 id="1fd2" class="ke jh hi bd ji kf kg kh jm ki kj kk jq is kl km ju iw kn ko jy ja kp kq kc kr bi translated"><strong class="ak">交易属性</strong></h2><p id="2415" class="pw-post-body-paragraph ih ii hi ij b ik ks im in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je hb bi translated">三个属性定义了事务:原子性、持久性、一致性和隔离性。</p><blockquote class="kx ky kz"><p id="6083" class="ih ii la ij b ik il im in io ip iq ir lb it iu iv lc ix iy iz ld jb jc jd je hb bi translated"><strong class="ij hj"> <em class="hi">原子性</em> </strong></p></blockquote><p id="d428" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">在分布式场景中，事务的操作可能分布在多个物理节点上，确保多个节点上的所有操作成功或失败。</p><blockquote class="kx ky kz"><p id="b7ff" class="ih ii la ij b ik il im in io ip iq ir lb it iu iv lc ix iy iz ld jb jc jd je hb bi translated"><strong class="ij hj"> <em class="hi">耐久性</em> </strong></p></blockquote><p id="ec4c" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">即使断电，提交的事务操作也有效。</p><blockquote class="kx ky kz"><p id="1f08" class="ih ii la ij b ik il im in io ip iq ir lb it iu iv lc ix iy iz ld jb jc jd je hb bi translated"><strong class="ij hj"> <em class="hi">一致性</em> </strong></p></blockquote><p id="bfe1" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj"> <em class="la">提示:</em> </strong>这里的“一致性”不同于CAP定理中的C。CAP中的C指的是多个副本之间的数据一致性，但这里指的是不同级别之间的一个抽象概念。</p><p id="3d72" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">从用户的角度来看，数据从一种状态传输到另一种状态，两种状态都受到一定程度的限制。例如:</p><p id="1db6" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">银行账户A有500美元，账户B有500美元，总计1000美元。A和B在一笔交易中执行转账操作后，他们的总金额仍然是1000美元。</p><blockquote class="kx ky kz"><p id="f72a" class="ih ii la ij b ik il im in io ip iq ir lb it iu iv lc ix iy iz ld jb jc jd je hb bi translated"><strong class="ij hj">隔离<em class="hi">隔离</em>隔离</strong></p></blockquote><p id="aedc" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">当事务并发执行时，可以确保数据的正确性。例如，两个事务同时修改相同的数据，以确保这两个事务按照一定的顺序执行，从而保持数据正确。</p><h2 id="0ce2" class="ke jh hi bd ji kf kg kh jm ki kj kk jq is kl km ju iw kn ko jy ja kp kq kc kr bi translated"><strong class="ak">挑战</strong></h2><p id="35d8" class="pw-post-body-paragraph ih ii hi ij b ik ks im in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je hb bi translated">与独立事务相比，分布式事务面临以下挑战:</p><ol class=""><li id="7775" class="le lf hi ij b ik il io ip is lg iw lh ja li je lj lk ll lm bi translated">原子性。对于独立事务，使用撤消日志和重做日志可以保证完全提交或完全回滚。然而，分布式事务涉及多个物理节点，每个节点都是不同的。一些节点日志可以成功写入，而另一些则失败。</li><li id="0875" class="le lf hi ij b ik ln io lo is lp iw lq ja lr je lj lk ll lm bi translated">网络不稳定。对于单机来说，通信是稳定的，任何操作都可以应答，无论成功与否。但是，在分布式场景中，网络是不稳定的，并且操作可能不被应答。因此，如何确保分布式事务的可用性(异常事务的清除和恢复等)。)是个问题。</li><li id="8e9e" class="le lf hi ij b ik ln io lo is lp iw lq ja lr je lj lk ll lm bi translated">并发控制。随着<a class="ae jf" href="https://www.postgresql.org/docs/7.1/mvcc.html" rel="noopener ugc nofollow" target="_blank"> MVCC </a>的到来，可线性化运营成为刚性需求。在独立数据库中可以很容易地增加全局事务数量，但在分布式场景中却不行。</li></ol><h2 id="9dbb" class="ke jh hi bd ji kf kg kh jm ki kj kk jq is kl km ju iw kn ko jy ja kp kq kc kr bi translated"><strong class="ak">解决方案</strong></h2><blockquote class="kx ky kz"><p id="fddf" class="ih ii la ij b ik il im in io ip iq ir lb it iu iv lc ix iy iz ld jb jc jd je hb bi translated"><strong class="ij hj"> <em class="hi">原子提交</em> </strong></p></blockquote><p id="fe51" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">原子性和网络不稳定性问题的主流解决方案是<a class="ae jf" href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol" rel="noopener ugc nofollow" target="_blank"> 2PC(两阶段提交协议)</a>，定义了两个角色，即TM(事务管理器)和RM(资源管理器)。</p><p id="4a8b" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">在分布式场景中，事务的操作可以分布在多个节点中。交易包括两个阶段。</p><p id="e84b" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj">第一阶段:</strong> RM锁定相关资源并执行特定操作，然后向TM返回成功或失败。</p><p id="8e12" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj">第二阶段:</strong>根据第一阶段RM返回的结果，TM将执行最终的提交操作(事务状态改变、锁状态删除等。)如果所有操作都成功，如果任何操作失败，则回滚。</p><p id="2520" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj"> <em class="la">注意:</em> </strong>当然也有一些需要优化的地方，比如把不涉及多个节点的事务转换成单阶段提交等等。</p><p id="b00d" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj"> <em class="la">注:</em> </strong> <em class="la"> </em>两阶段提交协议只解决提交问题。提交要么成功，要么失败。没有部分成功的中间状态。这与事务隔离级别没有必然联系。</p><blockquote class="kx ky kz"><p id="faa3" class="ih ii la ij b ik il im in io ip iq ir lb it iu iv lc ix iy iz ld jb jc jd je hb bi translated"><strong class="ij hj"> <em class="hi">并发控制</em> </strong></p></blockquote><p id="9754" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">并发控制是一种确保并发事务在特定隔离级别执行的策略。自从多版本并发控制(MVCC)出现以来，主流数据库在很大程度上放弃了以前的两阶段锁定模型。</p><p id="054d" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">并发控制本质上是控制数据读写的并发性。并发控制策略决定了隔离级别，并发控制解决了以下两个问题:</p><ol class=""><li id="2323" class="le lf hi ij b ik il io ip is lg iw lh ja li je lj lk ll lm bi translated">确定并发的粒度。比如MySQL有行锁(锁粒度是一行)和表锁(锁粒度是一个表)等等。</li><li id="14ca" class="le lf hi ij b ik ln io lo is lp iw lq ja lr je lj lk ll lm bi translated">三种并发场景:</li></ol><p id="6a65" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">a.读取并发。不需要特殊处理，因为不涉及数据更改。</p><p id="0a70" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">b.写并发。不要同时写作。，否则会发生数据损坏。</p><p id="3749" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">c.读/写并发。性能优化主要在这个场景中完成。有多种并发控制机制，其中多版本并发控制是最流行的一种。</p><h2 id="daa8" class="ke jh hi bd ji kf kg kh jm ki kj kk jq is kl km ju iw kn ko jy ja kp kq kc kr bi translated"><strong class="ak"> MVCC模式</strong></h2><p id="946e" class="pw-post-body-paragraph ih ii hi ij b ik ks im in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je hb bi translated">两种主流实现模式:</p><ol class=""><li id="6adb" class="le lf hi ij b ik il io ip is lg iw lh ja li je lj lk ll lm bi translated">基于事务ID和ReadView</li></ol><p id="c661" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">为每个事务获取事务ID，以标识事务开始的顺序。通过主动链表获取快照，用事务ID存储多个版本的数据，达到并发控制的效果。MySQL和<a class="ae jf" href="https://www.postgres-xl.org" rel="noopener ugc nofollow" target="_blank"> Postgres-XL </a>都采用这种方法。</p><p id="c722" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">2.基于时间戳</p><p id="504e" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">通过引入时间戳，可见性可以通过向数据添加时间戳相关属性并比较数据的提交(提交时间戳)和快照时间戳来确定，从而实现线性化的并发控制。那就是<a class="ae jf" href="https://research.google/pubs/pub39966/" rel="noopener ugc nofollow" target="_blank">扳手</a>所做的。</p><p id="e4e0" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">以上两种模式依赖于全局交易号的生成。常见的生成机制有TrueTime(由Spanner使用)、HLC(<a class="ae jf" href="https://www.cockroachlabs.com" rel="noopener ugc nofollow" target="_blank">cocroach db</a>使用有错误的HLC)、TSO(时间戳Oracle)。</p><h1 id="e432" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">ShardingSphere的事务设计</h1><p id="80d8" class="pw-post-body-paragraph ih ii hi ij b ik ks im in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je hb bi translated">ShardingSphere的事务特性建立在存储DB的本地事务之上，提供了三种事务模式:<code class="du ls lt lu lv b">LOCAL</code>、<code class="du ls lt lu lv b">XA</code>和<code class="du ls lt lu lv b">BASE</code>。您只需要使用本机事务模式(<code class="du ls lt lu lv b">begin</code> / <code class="du ls lt lu lv b">commit</code> / <code class="du ls lt lu lv b">roll-back</code>)来使用这三种模式，并在一致性和性能之间做出适当的权衡。</p><p id="8dc5" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj">本地</strong></p><p id="71fd" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><code class="du ls lt lu lv b">LOCAL</code>模式直接建立在存储数据库的本地事务上。它有最高的性能，尽管原子性有问题。如果你能容忍这个问题，是个不错的选择。</p><p id="51b7" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj"> XA </strong></p><p id="2b54" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">在XA模式下，XA协议基于2PC定义的一组交互协议。它定义了<code class="du ls lt lu lv b"> xa start/prepare/end/commit/rollback</code>接口。常用的实现有Narayana、Atomics和ShardingSphere集成了Narayana和Atomics的XA实现。</p><ol class=""><li id="bf4c" class="le lf hi ij b ik il io ip is lg iw lh ja li je lj lk ll lm bi translated">应用程序连接到代理，代理创建一个绑定到连接的会话对象。</li><li id="260f" class="le lf hi ij b ik ln io lo is lp iw lq ja lr je lj lk ll lm bi translated">应用程序执行<code class="du ls lt lu lv b">begin</code>。Proxy通过Narayana TM创建一个逻辑事务，并将其绑定到当前会话。</li><li id="a908" class="le lf hi ij b ik ln io lo is lp iw lq ja lr je lj lk ll lm bi translated">该应用程序执行特定的SQL。会话建立到存储数据库的连接，连接可以通过<code class="du ls lt lu lv b">Transaction.enlistResource ()</code>接口注册到事务。然后执行<code class="du ls lt lu lv b">XA START {XID}</code>启动事务，执行路由覆盖的SQL。</li><li id="9767" class="le lf hi ij b ik ln io lo is lp iw lq ja lr je lj lk ll lm bi translated">应用程序运行<code class="du ls lt lu lv b">commit</code>命令，为在事务数据库中注册的每个连接执行<code class="du ls lt lu lv b">xa prepare</code>，将事务状态更新为<code class="du ls lt lu lv b">prepared</code>，并为每个连接执行<code class="du ls lt lu lv b">xa commit</code>。如果系统返回ok，更新交易状态为<code class="du ls lt lu lv b">Committed</code>，交易提交成功。如果<code class="du ls lt lu lv b">prepare</code>进程失败，您可以运行<code class="du ls lt lu lv b">rollback</code>命令回滚数据。如果没有，后台进程将清除数据。</li><li id="9ed2" class="le lf hi ij b ik ln io lo is lp iw lq ja lr je lj lk ll lm bi translated">app运行<code class="du ls lt lu lv b">rollback</code>命令，连接存储DB的事务中注册的连接分别执行<code class="du ls lt lu lv b">xa rollback</code>。</li></ol><figure class="lx ly lz ma fd mb er es paragraph-image"><div class="er es lw"><img src="../Images/3ade25f0d2dccac8791cef72d5f73584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/0*OFU8G9IWnyOaeplZ"/></div></figure><p id="1510" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj">底座</strong></p><p id="25f8" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><a class="ae jf" href="https://phoenixnap.com/kb/acid-vs-base" rel="noopener ugc nofollow" target="_blank">基础(基本可用，柔软状态，最终一致)</a>模式。基础交易是CAP定理中C和A平衡的结果。<a class="ae jf" href="https://seata.io/en-us/" rel="noopener ugc nofollow" target="_blank"> Seata </a>的AT模式是BASE transaction的一个实现，ShardingSphere集成了Seata的AT实现。</p><ol class=""><li id="34eb" class="le lf hi ij b ik il io ip is lg iw lh ja li je lj lk ll lm bi translated">应用程序连接到代理，代理创建一个绑定到连接的会话对象。</li><li id="d460" class="le lf hi ij b ik ln io lo is lp iw lq ja lr je lj lk ll lm bi translated">应用程序执行<code class="du ls lt lu lv b">begin</code>。代理通过Seata TM创建一个逻辑事务，将其绑定到当前会话，并向Seata服务器注册。</li><li id="bb95" class="le lf hi ij b ik ln io lo is lp iw lq ja lr je lj lk ll lm bi translated">应用程序执行逻辑SQL。会话建立到存储数据库的连接。每个连接都是Seata的一个<code class="du ls lt lu lv b">ConnectionProxy</code>实例。然后解析被路由覆盖的<code class="du ls lt lu lv b">actual sql</code>并执行拦截。例如，如果是修改操作，执行<code class="du ls lt lu lv b">begin</code>获取本地锁，执行<code class="du ls lt lu lv b">SQL</code>查询，执行<code class="du ls lt lu lv b">commit</code>释放本地锁，将分支交易结果上报给Seata服务器。</li><li id="d0d9" class="le lf hi ij b ik ln io lo is lp iw lq ja lr je lj lk ll lm bi translated">app运行<code class="du ls lt lu lv b">commit</code>命令后，Seata TM in Proxy通知Seata服务器，直接返回app。Seata服务器与代理异步交互来删除事务日志。</li><li id="03f2" class="le lf hi ij b ik ln io lo is lp iw lq ja lr je lj lk ll lm bi translated">应用程序运行<code class="du ls lt lu lv b">rollback</code>命令。代理中的Seata TM通知Seata服务器后，代理直接返回app。Seata服务器与代理异步交互，执行补偿操作，并删除事务日志。</li></ol><figure class="lx ly lz ma fd mb er es paragraph-image"><div class="er es me"><img src="../Images/ab5ec5b5f576dd9c6d237f6d20bda243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/0*K98qyzGJtoVNP2UX"/></div></figure><h1 id="7454" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">例子</h1><h2 id="4994" class="ke jh hi bd ji kf kg kh jm ki kj kk jq is kl km ju iw kn ko jy ja kp kq kc kr bi translated"><strong class="ak">安装包准备</strong></h2><p id="4f98" class="pw-post-body-paragraph ih ii hi ij b ik ks im in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je hb bi translated">以一个集成了Narayana实现的具有良好支持能力的XA为例。由于Narayana许可证问题，它不能直接打包到安装包中，需要添加额外的依赖项。</p><p id="1345" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">从官网下载安装包，解压到目录<code class="du ls lt lu lv b">${ShardingSphere}</code>，将下面的<code class="du ls lt lu lv b">jar</code>包添加到目录<code class="du ls lt lu lv b">${ShardingSphere}/lib</code>。</p><p id="0415" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">(下载:https://mvnrepository.com/)</p><pre class="lx ly lz ma fd mf lv mg mh aw mi bi"><span id="432e" class="ke jh hi lv b fi mj mk l ml mm">jta-5.12.4.Final.jar<br/>arjuna-5.12.4.Final.jar<br/>common-5.12.4.Final.jar<br/>jboss-connector-api_1.7_spec-1.0.0.Final.jar                                             | ------------------------------------------------------------------------------------------------------------------------------------<br/>jboss-logging-3.2.1.Final.jar                                                    | ------------------------------------------------------------------------------------------------------------------------------------<br/>jboss-transaction-api_1.2_spec-1.0.0.Alpha3.jar                                           | ------------------------------------------------------------------------------------------------------------------------------------<br/>jboss-transaction-spi-7.6.0.Final.jar<br/>mysql-connector-java-5.1.47.jar                                                   | ------------------------------------------------------------------------------------------------------------------------------------<br/>narayana-jts-integration-5.12.4.Final.jar<br/>shardingsphere-transaction-xa-narayana-5.1.1-SNAPSHOT.jar</span></pre><h2 id="860e" class="ke jh hi bd ji kf kg kh jm ki kj kk jq is kl km ju iw kn ko jy ja kp kq kc kr bi translated"><strong class="ak"> MySQL实例准备</strong></h2><ol class=""><li id="edb8" class="le lf hi ij b ik ks io kt is mn iw mo ja mp je lj lk ll lm bi translated">准备两个MySQL实例:127.0.0.1:3306和127.0.0.1:3307。</li><li id="e144" class="le lf hi ij b ik ln io lo is lp iw lq ja lr je lj lk ll lm bi translated">为每个MySQL实例创建密码为12345678的用户root。</li><li id="26d0" class="le lf hi ij b ik ln io lo is lp iw lq ja lr je lj lk ll lm bi translated">为每个MySQL实例创建一个测试库。</li></ol><h2 id="9264" class="ke jh hi bd ji kf kg kh jm ki kj kk jq is kl km ju iw kn ko jy ja kp kq kc kr bi translated"><strong class="ak"> ShardingSphere代理配置</strong></h2><p id="0dc9" class="pw-post-body-paragraph ih ii hi ij b ik ks im in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je hb bi translated">修改<code class="du ls lt lu lv b">server.yaml</code>的交易配置</p><pre class="lx ly lz ma fd mf lv mg mh aw mi bi"><span id="392d" class="ke jh hi lv b fi mj mk l ml mm">rules:<br/>  - !AUTHORITY<br/>    users:<br/>      - root@%:root<br/>      - sharding@:sharding<br/>    provider:<br/>      type: ALL_PRIVILEGES_PERMITTED<br/>  - !TRANSACTION<br/>    defaultType: XA<br/>    providerType: Narayana</span></pre><p id="c788" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">修改<code class="du ls lt lu lv b">conf/conf-sharding.yaml</code></p><pre class="lx ly lz ma fd mf lv mg mh aw mi bi"><span id="e01c" class="ke jh hi lv b fi mj mk l ml mm">dataSources:<br/>  ds_0:<br/>    url: jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&amp;allowPublicKeyRetrieval=true&amp;useSSL=false<br/>    username: root<br/>    password: 12345678<br/>    connectionTimeoutMilliseconds: 30000<br/>    idleTimeoutMilliseconds: 60000<br/>    maxLifetimeMilliseconds: 1800000<br/>    maxPoolSize: 50<br/>    minPoolSize: 1<br/>  ds_1:<br/>    url: jdbc:mysql://127.0.0.1:3307/test?serverTimezone=UTC&amp;allowPublicKeyRetrieval=true&amp;useSSL=false<br/>    username: root<br/>    password: 12345678<br/>    connectionTimeoutMilliseconds: 30000<br/>    idleTimeoutMilliseconds: 60000<br/>    maxLifetimeMilliseconds: 1800000<br/>    maxPoolSize: 50<br/>    minPoolSize: 1<br/><br/>rules:<br/>  - !SHARDING<br/>    tables:<br/>      account:<br/>        actualDataNodes: ds_${0..1}.account${0..1}<br/>        tableStrategy:<br/>          standard:<br/>            shardingColumn: id<br/>            shardingAlgorithmName: account_inline<br/>        keyGenerateStrategy:<br/>          column: id<br/>          keyGeneratorName: snowflake<br/>    defaultDatabaseStrategy:<br/>      standard:<br/>        shardingColumn: id<br/>        shardingAlgorithmName: database_inline<br/>    defaultTableStrategy:<br/>      none:<br/><br/>    shardingAlgorithms:<br/>      database_inline:<br/>        type: INLINE<br/>        props:<br/>          algorithm-expression: ds_${id % 2}<br/>      account_inline:<br/>        type: INLINE<br/>        props:<br/>          algorithm-expression: account${id % 2}<br/><br/>    keyGenerators:<br/>      snowflake:<br/>        type: SNOWFLAKE<br/>        props:<br/>          worker-id: 123</span></pre><h2 id="fd8e" class="ke jh hi bd ji kf kg kh jm ki kj kk jq is kl km ju iw kn ko jy ja kp kq kc kr bi translated"><strong class="ak">启动ShardingSphere-Proxy </strong></h2><p id="7964" class="pw-post-body-paragraph ih ii hi ij b ik ks im in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je hb bi translated">通过运行以下命令启动代理:</p><pre class="lx ly lz ma fd mf lv mg mh aw mi bi"><span id="f70d" class="ke jh hi lv b fi mj mk l ml mm">cd ${ShardingSphere}<br/>./bin/start.sh</span></pre><h2 id="ae61" class="ke jh hi bd ji kf kg kh jm ki kj kk jq is kl km ju iw kn ko jy ja kp kq kc kr bi translated"><strong class="ak">使用ShardingSphere-Proxy </strong></h2><p id="887a" class="pw-post-body-paragraph ih ii hi ij b ik ks im in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je hb bi translated">使用MySQL客户端连接shardingSphere-Proxy进行测试，参考以下命令。</p><pre class="lx ly lz ma fd mf lv mg mh aw mi bi"><span id="af00" class="ke jh hi lv b fi mj mk l ml mm">mysql -h127.0.0.1 -P3307 -uroot -proot</span><span id="81ba" class="ke jh hi lv b fi mq mk l ml mm">mysql&gt; use sharding_db;<br/>Database changed<br/>mysql&gt; create table account(id int, balance float ,transaction_id int);<br/>Query OK, 0 rows affected (0.12 sec)<br/><br/>mysql&gt; select * from account;<br/>Empty set (0.02 sec)<br/><br/>mysql&gt; begin;<br/>Query OK, 0 rows affected (0.09 sec)<br/><br/>mysql&gt; insert into account(id, balance, transaction_id) values(1,1,1),(2,2,2);<br/>Query OK, 2 rows affected (0.53 sec)<br/><br/>mysql&gt; select * from account;<br/>+------+---------+----------------+<br/>| id  | balance | transaction_id |<br/>+------+---------+----------------+<br/>|  2 |   2.0 |       2 |<br/>|  1 |   1.0 |       1 |<br/>+------+---------+----------------+<br/>2 rows in set (0.03 sec)<br/><br/>mysql&gt; commit;<br/>Query OK, 0 rows affected (0.05 sec)<br/><br/>mysql&gt; select * from account;<br/>+------+---------+----------------+<br/>| id  | balance | transaction_id |<br/>+------+---------+----------------+<br/>|  2 |   2.0 |       2 |<br/>|  1 |   1.0 |       1 |<br/>+------+---------+----------------+<br/>2 rows in set (0.02 sec)</span></pre><h1 id="674b" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">未来计划</h1><p id="1108" class="pw-post-body-paragraph ih ii hi ij b ik ks im in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je hb bi translated">目前，ShardingSphere的分布式事务集成了第三方的2PC实现方案，以保证原子性。隔离依赖于存储数据库的隔离保证，提供可用的事务功能。</p><p id="821f" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">基于全局时间戳并结合2PC的MVCC的未来实现将为事务隔离语义提供更好的支持。</p><h1 id="3c94" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">Apache ShardingSphere项目链接:</h1><p id="6645" class="pw-post-body-paragraph ih ii hi ij b ik ks im in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je hb bi translated"><a class="ae jf" href="https://github.com/apache/shardingsphere/issues?page=1&amp;q=is%3Aopen+is%3Aissue+label%3A%22project%3A+OpenForce+2022%22" rel="noopener ugc nofollow" target="_blank"> ShardingSphere Github </a></p><p id="eed2" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><a class="ae jf" href="https://twitter.com/ShardingSphere" rel="noopener ugc nofollow" target="_blank"> ShardingSphere Twitter </a></p><p id="a910" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><a class="ae jf" href="https://join.slack.com/t/apacheshardingsphere/shared_invite/zt-sbdde7ie-SjDqo9~I4rYcR18bq0SYTg" rel="noopener ugc nofollow" target="_blank">切割球松弛</a></p><p id="35c7" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><a class="ae jf" href="https://shardingsphere.apache.org/community/cn/contribute/" rel="noopener ugc nofollow" target="_blank">投稿指南</a></p><h1 id="d63a" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">作者</h1><p id="27d8" class="pw-post-body-paragraph ih ii hi ij b ik ks im in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je hb bi translated"><strong class="ij hj">卢敬尚</strong></p><blockquote class="kx ky kz"><p id="9aa7" class="ih ii la ij b ik il im in io ip iq ir lb it iu iv lc ix iy iz ld jb jc jd je hb bi translated"><a class="ae jf" href="https://shardingsphere.apache.org" rel="noopener ugc nofollow" target="_blank"> Apache ShardingSphere </a>提交者&amp;基础设施研发工程师<a class="ae jf" href="https://www.sphere-ex.com" rel="noopener ugc nofollow" target="_blank"> SphereEx </a>。</p><p id="b045" class="ih ii la ij b ik il im in io ip iq ir lb it iu iv lc ix iy iz ld jb jc jd je hb bi translated">热衷于开源和数据库技术。</p><p id="1154" class="ih ii la ij b ik il im in io ip iq ir lb it iu iv lc ix iy iz ld jb jc jd je hb bi translated">专注于开发Apache ShardingSphere事务模块。</p></blockquote><figure class="lx ly lz ma fd mb er es paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="er es mr"><img src="../Images/9af190a01a00d7b5693921c258863fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gP4HQmZ-KX7eKz_9dtD-g.jpeg"/></div></div></figure></div></div>    
</body>
</html>