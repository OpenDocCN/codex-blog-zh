<html>
<head>
<title>Refactoring in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中的重构</h1>
<blockquote>原文：<a href="https://medium.com/codex/refactoring-in-c-531345065ade?source=collection_archive---------7-----------------------#2021-06-22">https://medium.com/codex/refactoring-in-c-531345065ade?source=collection_archive---------7-----------------------#2021-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7fc8577ad74f95f0866b94d8e4e4db0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1cF0RavNL0ilI37c4UN8w.png"/></div></div></figure><p id="11e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了实现应用程序中的任何功能，每个开发人员都有自己独特的风格。他们中的一些人编写有效且不复杂的代码，而一些人编写更复杂的代码。</p><p id="699d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，必须有一个需要维护的标准，以便代码足够灵活和易读，从而可以轻松地进行增强。但是，需要遵循的标准是在组织层面。</p><p id="563c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无论何时开发代码，都只能有两种情况——要么满足预期的标准，要么不满足。在后一种情况下，有必要修改代码，使其符合标准而不改变其功能。</p><p id="a6de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，当开发人员遇到任何技术问题(如内存泄漏和处理速度慢)时，对他们来说，分析代码并重构代码以改进代码并确保问题得到解决是非常重要的。但是什么是重构，什么时候重构呢？这个博客为你解答了所有这样的问题。</p><p id="2e2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录</strong></p><ol class=""><li id="a533" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">什么是重构？</li><li id="ad22" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">什么时候重构？</li><li id="24bf" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">不同的重构方式</li><li id="46eb" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">结论</li></ol><h1 id="2419" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是重构？</h1><p id="1e81" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">重构是通过改变代码的内部结构和外部行为来提高代码的性能、可读性和复杂性的过程。换句话说，这是一种以受控方式清理代码的有效技术。</p><p id="9c4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">重构不是重写代码，因为代码的关键(即功能)保持不变。相反，它改变了为满足标准而实现它的方式。例如，一个简单的重构就是重命名一个变量，使其成为可读的格式。</p><p id="7659" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个持续的过程，就像开发任务一样。随着新功能的引入，代码有可能被重构。所以，当代码被检入时，有必要寻找代码气味并修复它们。</p><p id="24aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">肉眼很难识别所有的代码气味。所以为了更简单，一些应用程序可以作为扩展安装在Visual Studio中。然后，这提供了可以重构的内容的建议。这使得开发人员和同行评审人员的工作更加容易。</p><p id="e438" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们详细看看什么时候重构。</p><h1 id="0262" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么时候重构？</h1><p id="e806" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">总是建议在每个开发任务完成后立即寻找代码的味道。这确保了工作被平均分配给开发人员。但是，当项目还没有准备好关注非功能性需求时，当一组新的主要特性发生变化时，执行重构是理想的。在清理代码的基础上开发产品将会很容易。</p><p id="0d05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，也建议在代码投入生产后立即进行NFR更改。这再次确保了开发人员有一些喘息的空间，任务可以按时完成。</p><h1 id="a90d" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">不同的重构方式</h1><h2 id="546c" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">作为单独的方法提取</h2><p id="0842" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">考虑一个已经存在并包含大量功能的方法。这使得程序员很难读懂，因为这个方法非常复杂。因此，有必要将方法分成不同的部分，以便功能保持不变，但同时，也便于程序员阅读。</p><p id="07c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一个例子-</p><p id="cf41" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下图有一个复杂的方法。现在让我们看看如何从中单独提取方法。</p><p id="07c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lt">注意:下面的方法故意增加了许多不必要的功能而变得复杂。这个练习的目的是解释重构是如何减少代码中不必要的复杂性的。请忽略实际代码的逻辑。</em></p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/1804dd0af58cbac190d2cf4c4d75f36e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/0*kTAgvfeUVFz9oSt6"/></div></figure><p id="eee0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要单独提取方法，请选择需要作为单独方法提取的代码行。右键单击并在给出的选项中选择“快速操作和重构…”。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/6b50d8458b03df120cc66895f0bb14b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/0*QlY2eJFulYPiAkpe"/></div></figure><p id="da24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">选择它时，Extract method选项会显示如何创建新方法的预览。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/df8d6805c13721d6286c8d4b53ec0c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*qpS7NdzH-he0RRqV"/></div></figure><h2 id="0495" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">删除未使用的指令</h2><p id="5463" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">正如我们所看到的，我们引用多个内置和外部包来完成任务。通常情况下，代码在类文件的顶部有未使用的指令。</p><p id="8868" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然只有当类内部使用指令中的特性时，才会加载指令，但是最好清除Usings，这样文件看起来会更干净。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/db97bf81d581880e22175cc6991bc01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/0*BIbbR_JQ24_WEKs8"/></div></figure><h2 id="db4e" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">提取接口</h2><p id="cfe7" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">接口有助于创建松散耦合的代码。当我们重构时，我们发现代码是紧密耦合的，需要重构为松散耦合的代码。</p><p id="6922" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，必须创建一个将由该类继承的接口。因为这个类有很多方法，所以你必须使创建包含所有方法的接口变得更容易。为此，请导航到快速操作和重构…选择一个类后，会出现一个创建接口的选项。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/289583a57b19187e109b983cd660147e.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/0*HFfjAGf89vS6XrRQ"/></div></figure><h2 id="b6c0" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">重命名变量</h2><p id="699f" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">假设一个全局变量存在于一个类中，并且在整个类中被使用。但是，变量的命名听起来不太对。因此，我们需要将变量重命名为一个合适的名称，以便它听起来有意义。</p><p id="3b3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于变量被多次使用，我们需要一种比逐个替换它更好的方法。换句话说，我们需要一种一次性替换变量名的方法。幸运的是，Visual studio中有一个选项可以解决这个问题。</p><p id="ece3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">选择需要重命名的变量，然后按Ctrl + R，Ctrl + R。这样就可以输入新变量了。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es md"><img src="../Images/8a5690ee171005d49316f10f0fbca079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/0*vbAJ2UQEvTSvu1WI"/></div></figure><p id="a32a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们应用更改后，重命名将应用于所有地方。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es me"><img src="../Images/15b6f92004765a993035ddaa8b1df7a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/0*-jTOZmH2CQ3TEtm0"/></div></figure><h1 id="9446" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="42e5" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">记住，C#中有很多重构技术没有在本文中讨论。创建这篇文章只是为了向您展示什么是重构，以及它如何帮助代码达到设定的标准和更具可读性。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="f44e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lt">原载于</em><a class="ae mm" href="https://www.partech.nl/nl/publicaties/2021/06/refactoring---c-sharp" rel="noopener ugc nofollow" target="_blank"><em class="lt">https://www . partech . nl</em></a><em class="lt">。</em></p></div></div>    
</body>
</html>