# 我不喜欢围棋的地方

> 原文：<https://medium.com/codex/things-i-dislike-about-go-4c245a74ee17?source=collection_archive---------0----------------------->

![](img/c20ef180fcd64d752490fa6bd6747824.png)

[来源](https://www.deviantart.com/quasilyte/art/Tired-gopher-783302842)

## 作为一个热爱围棋的人

我喜欢围棋。从我开始使用这门语言的第一天起，我就很快爱上了它。它提供了难以置信的简单性，同时保持了一流的类型安全性和闪电般的编译速度。执行速度非常快，并发性是一等公民(这是一种保守的说法)，标准库有一系列高级接口，可以启动任何依赖很少的应用程序，它可以直接编译成可执行文件——我还可以继续。虽然与其他 C 风格的语言相比，Go 的语法字面意义需要一些时间来适应，但在使用一点点之后，它感觉非常直观。

我来自一个 Java 背景的人，但是有丰富的 C、C++、JavaScript、TypeScript 和 Python 的经验。Go 是我学到的第一门语言，我想在任何地方做任何事情都要用到它。虽然我讨厌“产品杀手”这种陈词滥调，但作为一个专业的 Java 开发人员，Go *感觉像是一个 Java 杀手。我认为 Java 会有发展吗？大概不会。我认为围棋的受欢迎程度会超过 Java 吗？不太可能。然而，就我个人而言，我无法想象有哪种情况(除了维护太大而无法重写的遗留产品)会让我宁愿使用 Java 而不愿使用 Go。*

此时你可能在想，“这篇文章不是应该写你*不喜欢*围棋的事情吗？”这是一个完全公平的问题，我正准备回答它，但重要的是要明白我有多喜欢去欣赏我抱怨它所付出的代价。所以事不宜迟，到底有什么好批判的？

# 库函数修改它们的参数

我对 Go 的第一个抱怨是我马上注意到的:许多内置库函数修改它们的参数，而不是返回新的结果。修改函数参数模糊了输入和输出之间的界限，最终破坏了代码的表达能力。一个功能的表达能力是通过它的签名清楚地传达意思和意图的能力；意思传达得越清楚，功能的表现力就越强。表达性是可维护代码最重要的方面。很明显，有时候性能会比表达更有利于程序，但是从可维护性的角度来看，表达应该总是优先考虑的。

那 Go 为什么要这么做呢？通过修改参数而不是返回新数据，Go 编译器可以更好地跟踪给定变量的生命周期。Go 是一种垃圾收集(GC)语言，因此每当函数返回指针或由指针支持的类型(例如切片)时，它就增加了需要在堆上而不是在堆栈上分配内存的可能性。堆分配需要垃圾收集，而垃圾收集占用了程序宝贵的 CPU 周期。

避免堆分配——从而减少垃圾收集——绝对可以提高应用程序的性能。这些优化可能有利于软件渲染高 FPS 图形，但对于大多数企业应用程序和日常服务来说，最终用户的好处很可能几乎不明显。一个合理的论点是，一种语言应该最小化它自己的库的开销，但是当速度和易用性是相互竞争的目标时，需要优先考虑一个。已经有很多语言为高性能用例提供了显式内存管理(C、C++、Rust 等)。)，那么 Go 真的应该牺牲它最大的优势之一(易用性)来提供稍微少一点的 GC 周期吗？

作为一名开发人员，我希望至少有一些更具表现力、更直观的替代方案，在功能上与优化的 API 相当。尽管有这种烦恼，但 Go 远不是唯一一种对此感到内疚的语言，事实上，许多令人不快的 Go 函数在 Java 和 C++中都有几乎相同的对应物。然而，仅仅因为其他语言有先例，并不意味着 Go 应该是无可指责的，最终，这是我不喜欢这门语言的一点。

为了获得更多的分数，需要一个指针作为参数是在 Go 中请求修改的一种表达方式。为此，我将做出几点让步，尽管我仍然没有找到一种令人信服的方法来处理切片(切片通常是这种模式使用最多的部分)。

# 无商标消费品

Go 1.18 引入了泛型，所以我有点被这个事实宠坏了，我只需要为这个特性等待几个月，而许多资深的 Go 开发者已经等了好几年了。Go 的泛型实现感觉有点像 TypeScript 的，在很大程度上，这是一件好事。像 TS 一样，开发人员可以很容易地约束一个泛型类型，使其符合几种可能的已知类型或接口。但是与 TS 不同，Go 不需要处理 JavaScript 的包袱，特别是在*未定义的*和*空值*周围。

明确地说，我喜欢泛型作为一种语言特性。如果使用正确，它们可以提高代码的可重用性，从而提高一致性并降低错误的风险。当我说我不喜欢 Go 中的泛型时，我的意思是双重的:首先，Go 对泛型的实现有很多需要改进的地方，其次，语言中泛型的长期缺乏导致了许多丑陋的反模式埋藏在众多库的表面之下，包括 Go 的标准库。

为了解开第一点，Go 目前不支持方法上的泛型或作为 struct 字段的泛型。缺乏对方法的支持有点令人困惑，因为在本质上，Go 将方法视为以接收器作为第一个参数的函数。如果函数支持泛型，为什么方法不支持？Go 对嵌入的支持降低了泛型结构字段的重要性，因为泛型的大部分用途都可以通过嵌入来模仿:只需将“非泛型”字段保存在一个单独的结构中，并将同一个结构嵌入几次。尽管如此，嵌入并不是完美的替代，因为操作和方法需要为外部结构的每个变化重新实现。Go 可以通过允许泛型 struct 字段将这一责任转移给编译器，而不是开发人员，但目前我们还停留在复制和粘贴上。

由于 Go 中目前缺少泛型，许多数据结构实现不得不使用带有反射、类型检查和类型转换的笨拙的解决方法，为不同类型提供广泛的支持。这让我想到第二个抱怨。Go 作出了类型安全的承诺，然后通过使用伪泛型变通方法:`interface{}`，在它的标准库中到处破坏它。不仅 Go 的空接口用法是反模式的缩影，而且类型检查和反射经常是较慢的操作(具有讽刺意味的是，这与我之前抱怨的用表达性换取速度是不一致的)。最糟糕的是，第三方库也大量采用了空接口反模式，所以即使 Go 最终将其所有库迁移到泛型，该模式也可能在许多代码库中存在很长时间。

# make()函数

`make()`函数是 Go 对“原语类型”初始化的解决方案。大多数图元都有一个合理的*零值*，但在 Go 中，地图、切片和通道都是受益于动态初始化的图元类型。使用地图和切片的零值是完全可能的，有时甚至是合理的(例如 JSON 操作和避免零返回)，但在大多数情况下，`make()`是最好的选择。我反对`make()`的地方在于，它有两个我已经谈过的问题。

首先，`make()`缺乏表现力。它的全签名是`func make(t Type, size …IntegerSize) Type`，很少告诉我如何正确使用。即使它在技术上只是一个函数，在它从 Go 编译器得到的特殊处理和它创建通道的必要性之间，`make()`和 for-loops 一样是 Go 必不可少的一部分。采取这种思路部分地原谅了它的签名，但是提供没有歧义的`NewMap()`、`NewSlice()`和`NewChan()`函数会同样容易——如果不是更容易的话。我不打算讨论这些选择，因为我确信，对于为什么这些选择可能会有问题，有很多强烈的意见。不过，我会陷入困境的是，犯错误是多么容易(看我在那里做了什么？).

我们来看看`make()`的行动。`m := make(map[int]int, 10)`创建一个空映射，分配足够的空间来存储十个条目；`len(m)`返回 0。调用`c := make(chan int, 10)`创建一个有十个条目缓冲区的通道；`len(c)`返回 0。调用`s := make([]int, 10)`创建一个切片，其中十个条目被初始化为零值；`len(s)`返回 10。看到问题了吗？无论是在编写代码的时候，还是在审查代码的时候，都很容易不小心忽略了这个重要的区别。要获得切片的预期行为，需要一个额外的参数:`s := make([]int, 0, 10)`。`len(s)`在那种情况下实际上会返回 0。因此，Go 并没有为这些数据结构提供更具表达性的、独特的初始化器，而是提供了一个具有更大模糊性的单一函数，从而带来了更大的误用风险。

为了增加我对`make()`的想法，我对它的第二个问题是它的伪泛型。Go 一般不允许函数重载，但是`make()`得到了一个特殊的通行证来假装重载。因为这个特殊的通道，`make()`的第一个参数可以是几种类型中的一种。这同样适用于它的返回类型。对于一种十年来声称不需要泛型的语言来说，Go 必须打破许多自己的规则，才能让它最核心的功能之一在没有泛型的情况下工作。我觉得这很草率。

# 扁平包装结构

我来自 Java 世界。Java 应用程序往往有很多很多的包。在这个世界中，父包对于类的上下文来说通常和类名本身一样重要，所以对于 Go——“Java 黑仔”——来说有这样一个扁平的包结构有点不协调。这不是独一无二的。许多面向脚本的语言，比如 Python，倾向于使用更宽的深度。尽管这是一种相对常见的做法，但我想让 Go 成为 Java 的“替代者”的梦想似乎破灭了。

扁平封装结构本身没有任何问题。空目录层(或包含单个文件的目录)很少在没有为它们明确设计的语言中提供价值——不可否认，这适用于非面向对象的大多数语言。然而，如果平面语言声称解决了与嵌套语言相同的问题，那么平面语言应该为管理标识符可见性和范围提供语义上等价的机制。

Go 通过大写导出标识符的简单方法非常棒。在我团队的风格大会上，我又少了一件需要争论的事情。玩笑归玩笑，尽管我很喜欢 Go 开发者的这一选择，但是包的语义和扁平结构的惯例降低了应用程序代码这一特性的潜在价值。在库代码中，导出与否的简单概念对于定义公共 API 来说是完美的。对于大型应用程序，尤其是 web 服务器，这通常是不够的。

Web 服务器必然会有一些包，这些包从来不会被其他代码显式使用(测试除外)，而是由外部客户端和其他服务器通过 HTTP 之类的协议调用。这些包中的代码将像其他代码一样从抽象中受益，但是使用平面包结构，未导出的抽象将不可避免地对包中无权使用它们的其他区域可见。这导致了一个难题:是否应该打破平面包结构的惯例，牺牲可读性和重用以减少抽象性，或者只是让未导出的标识符在它们不应该在的地方可访问？这个问题的存在就是承认围棋有问题。当然，扁平结构是约定而不是法则，但是约定在围棋的发展中有着广泛的影响，规定了许多新的特征，使之成为语言。所以，是的，这可能不是 Go 的一个明确的特性，但它仍然是我不喜欢它的地方，因为 Go 社区非常强烈地将它作为最佳实践。

# 缺乏速记兰姆达斯

这个绝对是吹毛求疵，所以我就开门见山了:Go 没有 lambda 函数的简写。我知道已经有关于它们的提议，也有关于它们为什么没有必要的争论，但是尽管有这些考虑，事实仍然是我喜欢速记 lambdas，而 Go 没有它们。

Go 的函数语法恰好又短又简洁。此外，函数是 Go 中的类型，可以被赋给变量，这对于喜欢滥用 Java 8 中引入的“方法引用”的人来说是很熟悉的。尽管如此，当我用 Go 编写时，有时内联函数是解决问题的最合适的方法，但即使对于一行程序来说，产生的代码通常也很笨拙，尤其是当需要返回语句时。我想没有人能说服我`func(x, y int) int { return x+y }`比`(x, y) => (x+y)`更漂亮或者可读性更强。关于强类型或显式的争论尽管你想要，我还是会想念速记的兰姆达斯。

没有一种编程语言是没有缺点的——我真的希望没有一个 Haskell 人是(还是？)读到这里——而 Go 远非例外。也就是说，像任何好的软件一样，随着时间的推移，Go 会继续迭代和改进，缓解这些担忧。尽管存在这些问题，我仍然热爱 Go，它仍然是我在大多数项目中选择的语言。作为程序员，我们经常对我们最喜欢的语言的许多问题视而不见，但是反思我们对设计最学究式的关注往往会使我们的软件变得更好。

对于那些没有尝试过围棋，但正在考虑的人，不要因此而气馁；这是一个神奇的工具，几乎肯定会改善您的开发生活。对于现有的地鼠，我希望你能同情我的抱怨，但仍然像我一样享受语言。

## 脚注

本文是在 Go 1.18 是最新稳定版的时候写的。
为清晰起见，于 2022 年 6 月 21 日将“lambdas”更新为“速记 lambdas”。