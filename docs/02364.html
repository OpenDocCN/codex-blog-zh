<html>
<head>
<title>Implementing Passwordless Auth is now stupidly easy — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现无密码身份验证现在变得非常简单——第2部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/implementing-passwordless-auth-is-now-stupidly-easy-part-2-e714c932b79b?source=collection_archive---------2-----------------------#2021-07-15">https://medium.com/codex/implementing-passwordless-auth-is-now-stupidly-easy-part-2-e714c932b79b?source=collection_archive---------2-----------------------#2021-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="480f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的<a class="ae jd" rel="noopener" href="/@christopher.keogh/implementing-passwordless-auth-is-now-stupidly-easy-part-1-e2f5430a1ed3">上一篇文章</a>中，我概述了为什么我们应该考虑放弃使用密码来认证用户，而不是使用无密码认证。在第二部分中，我们将探索如何使用Dotnet core 3.1、IdentityServer4和FIDO2.NET库实现无密码认证流程。</p><p id="b66e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有这些工具都可以作为开源技术免费获得。要运行本文中使用的示例，你要么需要某种形式的<a class="ae jd" href="https://www.w3.org/TR/webauthn-1/#authenticator" rel="noopener ugc nofollow" target="_blank">认证器</a>设置，比如Windows Hello、Apple ID或Yubikey，要么你可以使用<a class="ae jd" href="https://developer.chrome.com/docs/devtools/webauthn/" rel="noopener ugc nofollow" target="_blank"> Chrome的开发工具</a>中提供的WebAuthn虚拟环境。</p><p id="cf4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我选择IdentityServer4是因为它是<a class="ae jd" href="https://openid.net/specs/openid-connect-core-1_0.html" rel="noopener ugc nofollow" target="_blank"> Open ID Connect规范</a>的成熟开源实现，并且非常容易安装和运行。本文中使用的工作示例代码<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample" rel="noopener ugc nofollow" target="_blank">可在GitHub </a>上获得，它基于IdentityServer4提供的<a class="ae jd" href="https://docs.identityserver.io/en/dev/quickstarts/0_overview.html" rel="noopener ugc nofollow" target="_blank">模板生成工具</a>。我不打算详细介绍生成IdentityServer和本文中提到的示例MvcClient的所有步骤，因为IdentityServer自己的<a class="ae jd" href="https://docs.identityserver.io/en/dev/quickstarts/0_overview.html" rel="noopener ugc nofollow" target="_blank">快速入门文档</a>已经足够详细地介绍了这些步骤。然而，如果你有兴趣从零开始，你只需要遵循第<a class="ae jd" href="https://docs.identityserver.io/en/dev/quickstarts/1_client_credentials.html" rel="noopener ugc nofollow" target="_blank">第</a>和第<a class="ae jd" href="https://docs.identityserver.io/en/dev/quickstarts/3_interactive_login.html" rel="noopener ugc nofollow" target="_blank">第三</a>教程。</p><p id="2c6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将频繁引用<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample" rel="noopener ugc nofollow" target="_blank">示例GitHub库</a>而不是遍历每一行代码，同时重点概述相关的请求流并突出任何有趣的代码。</p><h2 id="7a93" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">入门指南</h2><p id="98a3" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">首先，确保克隆<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample" rel="noopener ugc nofollow" target="_blank">passoldless auth GitHub库</a>,其中包含启动和运行所需的所有代码。在运行IdentityServer项目之前，只需运行dotnet restore和dotnet build:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ke"><img src="../Images/6b7845ec2b68f293b65d60a7601136fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nVP5agGakqY21raF92GIGg.png"/></div></div></figure><p id="1225" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确保还运行MvcClient示例应用程序:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kq"><img src="../Images/823ac3d33399628cfe68a8de8a4ebdba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7OxhQ-SK194qEDOx0eN2gw.png"/></div></div></figure><p id="6e0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的示例中，我们在HTTPS端口5010上运行IdentityServer，在HTTPS端口5002上运行MvcClient示例(我完全是随意选择端口的)。启动并运行后，您应该能够使用用户名和密码“alice”直接登录IdentityServer，并且现在应该能够登录MvcClient示例:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kr"><img src="../Images/47097159e7ae9d1d7c591db2239fe8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BB_ibhRp_j9jLVp-hYpdCg.gif"/></div></div></figure><h2 id="6dd9" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">无密码流程概述</h2><p id="80af" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">现在，在研究如何在本例中实现无密码身份验证之前，让我们先看看无密码身份验证流程及其工作原理。我基本上已经把FIDO2.NET的<a class="ae jd" href="https://github.com/passwordless-lib/fido2-net-lib/tree/master/Demo" rel="noopener ugc nofollow" target="_blank">演示</a>应用到这个项目中，做了一些小的改动。</p><p id="de1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的<a class="ae jd" rel="noopener" href="/@christopher.keogh/implementing-passwordless-auth-is-now-stupidly-easy-part-1-e2f5430a1ed3">上一篇文章</a>中，我简要概述了注册和认证过程，它们共同构成了WebAuthn规范中描述的无密码认证。让我们看看示例中这些流程的实现，从注册流程开始，它允许现有的IdentityServer用户(在这种情况下，我们坚持使用“alice”)设置无密码身份验证。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ks"><img src="../Images/37df492b7629a3f3b869da5f9ecb46db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UidrPuafZTiAbzRH8lwMwA.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">无密码注册流程实施的高级概述。</figcaption></figure><p id="f7f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到IdentityServer传递了一个凭据选项对象，浏览器使用该对象为现有IdentityServer用户创建新凭据。此凭据特定于IdentityServer的域(localhost:5010)，不能用于任何其他网站。该凭证由认证器生成，并由用户通过<a class="ae jd" href="https://www.w3.org/TR/webauthn-1/#authorization-gesture" rel="noopener ugc nofollow" target="_blank">授权手势</a>进行授权(例如，启用生物指纹扫描进行授权的Windows Hello)。凭证由公钥/私钥对组成。私钥由身份验证者存储在本地，公钥回发到IdentityServer以存储在服务器端。更深入的技术解释请见我的<a class="ae jd" rel="noopener" href="/@christopher.keogh/implementing-passwordless-auth-is-now-stupidly-easy-part-1-e2f5430a1ed3">上一篇</a>。</p><p id="9c37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，让我们看看实际的身份验证流程，一旦注册流程完成，用户就可以使用这个流程。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kx"><img src="../Images/5d235569b80e510d5615232c44d965ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZ4gz0Z0tYzZo945v1YRQg.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">无密码身份验证流程实施的高级概述。</figcaption></figure><p id="a441" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在很多方面，认证流程类似于注册流程。我们的IdentityServer实现将一组assertionOptions交给浏览器<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get" rel="noopener ugc nofollow" target="_blank">，浏览器然后向认证者请求相关的凭证</a>。在对用户进行身份验证之前，要求用户同意允许身份验证者将凭据传递回浏览器，并将此凭据发送回IdentityServer以验证它是否有效。我在这里使用了术语凭证签名，而我应该使用术语<a class="ae jd" href="https://www.w3.org/TR/webauthn-1/#assertion-signature" rel="noopener ugc nofollow" target="_blank">断言签名</a>。实际回发到IdentityServer的是验证者使用私钥/公钥算法创建的签名。私钥位于用户的认证器中，用于生成一个签名，该签名由identity server——<a class="ae jd" href="https://www.w3.org/TR/webauthn-1/#webauthn-relying-party" rel="noopener ugc nofollow" target="_blank">依赖方</a>用它存储在服务器端的相关公钥进行验证。</p><h2 id="20c6" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">启动并运行我们的无密码实现</h2><p id="fc31" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">现在我们对每个流程中实际涉及的内容有了更好的理解，让我们更仔细地看看我们的示例实现。</p><p id="130d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经添加了一个新的<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/master/src/IdentityServer/Controllers/Account/PasswordlessController.cs" rel="noopener ugc nofollow" target="_blank">无密码控制器</a>到控制器文件夹。我从FIDO2.NET库中复制并粘贴了<a class="ae jd" href="https://github.com/passwordless-lib/fido2-net-lib/blob/master/Demo/Controller.cs" rel="noopener ugc nofollow" target="_blank">演示控制器</a>，并做了一些小的改动，稍后我会回来介绍。</p><p id="6f71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还向IdentityServer项目添加了两个新视图。一个用于<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/master/src/IdentityServer/Views/Account/PasswordlessLogin.cshtml" rel="noopener ugc nofollow" target="_blank">无密码登录</a>，一个用于<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/master/src/IdentityServer/Views/Account/PasswordlessRegistration.cshtml" rel="noopener ugc nofollow" target="_blank">注册</a>。我还在<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/cfbeb3c586ab058dc8b74d51431c6fe9e31865ed/src/IdentityServer/Views/Account/Login.cshtml#L44" rel="noopener ugc nofollow" target="_blank">登录视图</a>中添加了第三个按钮，专门用于无密码登录。对于注册，我们将把它添加到<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/cfbeb3c586ab058dc8b74d51431c6fe9e31865ed/src/IdentityServer/Views/Shared/_Nav.cshtml#L30-L35" rel="noopener ugc nofollow" target="_blank">共享导航标题</a>中，并使它仅在用户登录后才可见。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ky"><img src="../Images/81c17c9f41e1d0c1a06df829bc86e85c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bd2GsrvOsj0u-w7dMRtm7Q.png"/></div></div></figure><p id="1e7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还想向帐户控制器添加两个新的端点<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/cfbeb3c586ab058dc8b74d51431c6fe9e31865ed/src/IdentityServer/Controllers/Account/AccountController.cs#L181-L189" rel="noopener ugc nofollow" target="_blank">来加载我们的</a><a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/tree/master/src/IdentityServer/Views/Account" rel="noopener ugc nofollow" target="_blank">无密码视图</a>。</p><p id="6fda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使这些工作，我们需要添加一些Javascript，将认证者、浏览器和依赖方(IdentityServer)之间的流粘合在一起。一个文件用于<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/master/src/IdentityServer/wwwroot/js/passwordless.login.js" rel="noopener ugc nofollow" target="_blank">无密码登录</a>，一个文件用于<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/master/src/IdentityServer/wwwroot/js/passwordless.register.js" rel="noopener ugc nofollow" target="_blank">注册</a>。我也从FIDO2.NET的演示中复制并粘贴了演示javascript，做了一些很小的修改。</p><p id="2b2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让我们的无密码流工作，我们需要在<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/master/src/IdentityServer/Startup.cs" rel="noopener ugc nofollow" target="_blank">启动类</a>中为FIDO2.NET库设置一些代码。FIDO2.NET需要NewtonSoftJson包才能正常工作，所以一旦安装好，我们需要添加它:</p><pre class="kf kg kh ki fd kz la lb lc aw ld bi"><span id="65ec" class="je jf hi la b fi le lf l lg lh">services.AddControllersWithViews().AddNewtonsoftJson();</span></pre><p id="682d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装程序代码的剩余部分:</p><pre class="kf kg kh ki fd kz la lb lc aw ld bi"><span id="899a" class="je jf hi la b fi le lf l lg lh">services.AddFido2(options =&gt;<br/>    {<br/>        options.ServerDomain = Configuration["fido2:serverDomain"];<br/>        options.ServerName = "IdentityServerPasswordlessTest";<br/>        options.Origin = Configuration["fido2:origin"];<br/>        options.TimestampDriftTolerance = Configuration.GetValue&lt;int&gt;("fido2:timestampDriftTolerance");<br/>        options.MDSAccessKey = Configuration["fido2:MDSAccessKey"];<br/>        options.MDSCacheDirPath = Configuration["fido2:MDSCacheDirPath"];<br/>    })<br/>    .AddCachedMetadataService(config =&gt;<br/>    {<em class="li"><br/>        </em>if (!string.IsNullOrWhiteSpace(Configuration["fido2:MDSAccessKey"]))<br/>        {<br/>            config.AddFidoMetadataRepository(Configuration["fido2:MDSAccessKey"]);<br/>        }<br/>        config.AddStaticMetadataRepository();<br/>    });</span></pre><p id="2d5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还需要appsettings.json中的一些配置设置:</p><pre class="kf kg kh ki fd kz la lb lc aw ld bi"><span id="04ba" class="je jf hi la b fi le lf l lg lh">{<br/>    "fido2": {<br/>        "serverDomain": "localhost",<br/>        "origin": "https://localhost:5010",<br/>        "timestampDriftTolerance": 300000,<br/>        "MDSAccessKey": null<br/>    }  <br/>}</span></pre><p id="30fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了节省时间，我还从<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/cfbeb3c586ab058dc8b74d51431c6fe9e31865ed/src/IdentityServer/Controllers/Account/LoginInputModel.cs#L13" rel="noopener ugc nofollow" target="_blank"> LoginInputModel </a>类的password属性中删除了<strong class="ih hj"> required </strong>属性，因为我们将重用这个类进行无密码登录。创建一个单独的无密码输入模型可能是更好的实践，但是我们将只修改已经存在的模型。</p><p id="208b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这应该是启动和运行注册所需的一切:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kr"><img src="../Images/0eb2f7574cc5cce345858eedeccc4d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rCrSA7Mcpqkt5w5vvZpFFQ.gif"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">登录，然后注册无密码身份验证流程。</figcaption></figure><p id="9ba3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">…随后，您应该能够使用无密码身份验证流程登录:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kr"><img src="../Images/39cc37eda7012813d0c7d2c07bfba442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SzK4houu9jY_BG8Oi4hk2A.gif"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">使用无密码流程登录我们的MvcSample应用程序。</figcaption></figure><h2 id="208c" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">集成FIDO2.NET和身份服务器4</h2><p id="4ca7" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">在<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/master/src/IdentityServer/Controllers/Account/PasswordlessController.cs" rel="noopener ugc nofollow" target="_blank">无密码控制器</a>中有两段重要的代码需要注意。在MakeCredentialOptions方法中，我们<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/f6b0a60e232fd182b4f8be0f30884aae26dc5301/src/IdentityServer/Controllers/Account/PasswordlessController.cs#L51-L55" rel="noopener ugc nofollow" target="_blank">检查用户是否存在于我们的IdentityServer用户存储中</a>(我们无法验证不存在的用户):</p><pre class="kf kg kh ki fd kz la lb lc aw ld bi"><span id="e536" class="je jf hi la b fi le lf l lg lh"><em class="li">// user must already exist in Identity<br/></em>var identityUser = _users.FindByUsername(username);<br/>if (identityUser == null) {<br/>    throw new Exception("User not found");<br/>}</span></pre><p id="8740" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还检查<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/f6b0a60e232fd182b4f8be0f30884aae26dc5301/src/IdentityServer/Controllers/Account/PasswordlessController.cs#L51-L55" rel="noopener ugc nofollow" target="_blank">用户是否真正通过了认证</a>:</p><pre class="kf kg kh ki fd kz la lb lc aw ld bi"><span id="ae3a" class="je jf hi la b fi le lf l lg lh">if (!HttpContext.User.IsAuthenticated())<br/>{<br/>    throw new Exception("User is not authenticated");<br/>};</span></pre><p id="dfbf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我们实际上有一个<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/f040d183364460a7035f86c534462aad042321c3/src/IdentityServer/Controllers/Account/PasswordlessController.cs#L24" rel="noopener ugc nofollow" target="_blank">单独的内存用户存储</a>，供我们的无密码用户使用，由FIDO2.NET图书馆提供，<a class="ae jd" href="https://github.com/passwordless-lib/fido2-net-lib/blob/0d3078fb5d47d51563bd17a1ad43648114c4b1fb/Src/Fido2/DevelopmentInMemoryStore.cs" rel="noopener ugc nofollow" target="_blank">DevelopmentInMemoryStore</a>。我们也许可以做些什么来将它集成到我们现有的<a class="ae jd" href="https://github.com/IdentityServer/IdentityServer4/blob/3ff3b46698f48f164ab1b54d124125d63439f9d0/src/IdentityServer4/src/Test/TestUserStore.cs" rel="noopener ugc nofollow" target="_blank"> IdentityServer用户存储</a>中，但是为了这个例子，并且为了节省时间，我们将把它们分开，并且依靠上面的检查来保持同步。</p><p id="87b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我给这个控制器添加了一个新方法，名为<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/cfbeb3c586ab058dc8b74d51431c6fe9e31865ed/src/IdentityServer/Controllers/Account/PasswordlessController.cs#L257-L270" rel="noopener ugc nofollow" target="_blank">signinodic</a>，如下所示:</p><pre class="kf kg kh ki fd kz la lb lc aw ld bi"><span id="b71a" class="je jf hi la b fi le lf l lg lh">async Task SignInOidc(string username)<br/>{<br/>    var user = _users.FindByUsername(username);<br/>    await _events.RaiseAsync(new UserLoginSuccessEvent(user.Username, user.SubjectId, user.Username));<br/><br/>    AuthenticationProperties props = new AuthenticationProperties();<br/>    <em class="li">// issue authentication cookie with subject ID and username<br/>    </em>var isUser = new IdentityServerUser(user.SubjectId)<br/>    {<br/>        DisplayName = user.Username<br/>    };<br/><br/>    await AuthenticationManagerExtensions.SignInAsync(HttpContext, isuser, props);<br/>}</span></pre><p id="7873" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该方法由<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/cfbeb3c586ab058dc8b74d51431c6fe9e31865ed/src/IdentityServer/Controllers/Account/PasswordlessController.cs#L210" rel="noopener ugc nofollow" target="_blank"> MakeAssertion </a>方法调用，该方法在认证流程中验证浏览器发回的断言签名。如果成功，<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/f6b0a60e232fd182b4f8be0f30884aae26dc5301/src/IdentityServer/Controllers/Account/PasswordlessController.cs#L242-L246" rel="noopener ugc nofollow" target="_blank">signino doc被调用</a>，它<a class="ae jd" href="https://github.com/dbfr3qs/PasswordlessAuthExample/blob/f6b0a60e232fd182b4f8be0f30884aae26dc5301/src/IdentityServer/Controllers/Account/PasswordlessController.cs#L256-L268" rel="noopener ugc nofollow" target="_blank">在</a>中给用户签名，导致身份服务器写入认证和会话cookies。</p><pre class="kf kg kh ki fd kz la lb lc aw ld bi"><span id="a65e" class="je jf hi la b fi le lf l lg lh"><em class="li">// 5. Make the assertion<br/></em>var res = await _fido2.MakeAssertionAsync(clientResponse, options, creds.PublicKey, storedCounter,<br/>    callback);<br/><br/><em class="li">// 6. Store the updated counter<br/></em>PasswordlessStore.UpdateCounter(res.CredentialId, res.Counter);<br/><br/>if (res.Status == "ok")<br/>{<br/>    var username = System.Text.Encoding.UTF8.GetString(creds.UserId);<br/>    await SignInOidc(username);<br/>}</span></pre><h2 id="6dc5" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">包扎</h2><p id="2e48" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">这就是使用IdentityServer4、Dotnet core 3.1和FIDO2.NET库启动和运行基本无密码注册和认证流程的全部内容。就我个人而言，我希望看到这种有前途的技术在互联网上得到更广泛的采用，并且我希望我已经能够提供该技术如何工作以及如何实现的入门级概述。</p><p id="6fb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">欢迎提出问题、评论和反馈，请随时联系我们。</p></div></div>    
</body>
</html>