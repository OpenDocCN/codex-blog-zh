<html>
<head>
<title>Flutter User Authentication Part 3: Persistent Login With Shared Preferences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter用户认证第3部分:共享首选项的持久登录</h1>
<blockquote>原文：<a href="https://medium.com/codex/flutter-user-authentication-part-3-persistent-login-with-shared-preferences-d0ffb64e1745?source=collection_archive---------2-----------------------#2021-08-04">https://medium.com/codex/flutter-user-authentication-part-3-persistent-login-with-shared-preferences-d0ffb64e1745?source=collection_archive---------2-----------------------#2021-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2cf138c5415ca66cebe84504e1f50193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hOQY7XfZeRbBo_kaIc3uvg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@sigmund?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae iu" href="https://unsplash.com/s/photos/settings?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="6ff3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本系列的<a class="ae iu" rel="noopener" href="/codex/flutter-user-authentication-part-1-models-and-api-acf33cf42f83">第一部分</a>中，我教了您如何构建一个<a class="ae iu" rel="noopener" href="/codex/flutter-user-authentication-part-1-models-and-api-acf33cf42f83">客户模型和一个认证API </a>，在<a class="ae iu" rel="noopener" href="/codex/flutter-user-authentication-part-2-storing-users-with-the-cubit-6d60c537ce82">第二部分</a>中，我们学习了如何使用<a class="ae iu" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank"> Cubit </a>来管理整个应用程序的<a class="ae iu" rel="noopener" href="/codex/flutter-user-authentication-part-2-storing-users-with-the-cubit-6d60c537ce82">登录状态。现在，在这个系列的最后一部分，我们将学习如何<strong class="ix hj">保持持久登录</strong>甚至<strong class="ix hj"> </strong>当我们的应用程序关闭时。我们开始吧！</a></p><p id="5e84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">科里的角落播客:<a class="ae iu" href="https://anchor.fm/coreys-corner" rel="noopener ugc nofollow" target="_blank">https://anchor.fm/coreys-corner</a></p><p id="9076" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一定要检查我的<a class="ae iu" href="https://www.youtube.com/watch?v=MZmSZWEfGBc" rel="noopener ugc nofollow" target="_blank">颤振UI教程</a>！</p><h2 id="3797" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">共享偏好</h2><p id="4978" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">根据官方文件,<a class="ae iu" href="https://pub.dev/packages/shared_preferences" rel="noopener ugc nofollow" target="_blank">共享偏好</a>是一个库</p><blockquote class="kt ku kv"><p id="ceb1" class="iv iw kw ix b iy iz ja jb jc jd je jf kx jh ji jj ky jl jm jn kz jp jq jr js hb bi translated">为简单数据包装特定于平台的持久存储(iOS和macOS上的NSUserDefaults，Android上的SharedPreferences等)。).数据可能会异步持久化到磁盘，并且不能保证写操作返回后会持久化到磁盘，<strong class="ix hj">所以这个插件不能用于存储关键数据</strong>。</p></blockquote><p id="147b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本质上，这个包将允许我们在运行我们的应用程序的设备上存储和检索信息。</p><p id="a4d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，共享首选项包明确指出，关键数据不应该以这种方式存储。我们构建的应用程序仅用于生产和演示目的。如果你想在生产环境中保持持久登录，我推荐使用<a class="ae iu" href="https://pub.dev/packages/flutter_secure_storage" rel="noopener ugc nofollow" target="_blank"> flutter_secure_storage </a>包，它的操作方式非常相似。</p><h2 id="a30d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">游戏计划</h2><p id="d2d3" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">当用户登录我们的应用程序时，我们将把他们的API令牌和ID存储到磁盘中。每次打开应用程序时，我们都会检查这些值是否存在。如果它们存在，我们将发出一个API请求，然后我们将获取数据来创建我们的客户模型实例，通过Cubit登录我们的客户。</p><h2 id="74e9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">使用共享偏好设置存储数据</h2><p id="157d" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">是时候创建一个函数来将我们客户的API令牌和ID保存到磁盘上了:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="04f8" class="jt ju hi lf b fi lj lk l ll lm">../prefs.dart<br/>import 'package:shared_preferences/shared_preferences.dart';</span><span id="d4a2" class="jt ju hi lf b fi ln lk l ll lm">/* <br/>don't forget to add shared_preferences to pubspec.yaml before following along<br/>*/</span><span id="11c5" class="jt ju hi lf b fi ln lk l ll lm">void upDateSharedPreferences(String token, int id) async {<br/>  SharedPreferences _prefs = await SharedPreferences.<em class="kw">getInstance</em>();<br/>  _prefs.setString('token', token);<br/>  _prefs.setInt('id', id);<br/>}</span></pre><p id="9793" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">共享首选项的操作就像一个映射或字典，其中包含特定于类型的键/值对。首先，我们创建一个共享偏好ie的实例。_prefs。然后，我们使用setString和sentInt方法将整数和字符串保存到磁盘。每个set函数的第一个参数是我们存储的键，而第二个参数是与每个键相关的值。</p><h2 id="f5ba" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">登录后更新共享偏好设置</h2><p id="cf5b" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">回想一下在<a class="ae iu" rel="noopener" href="/codex/flutter-user-authentication-part-1-models-and-api-acf33cf42f83">第1部分</a>中，我们是如何创建一个进行API调用的登录表单的。当API请求成功时，我们使用工厂方法从API调用返回的JSON数据中创建客户模型的实例。在成功创建了一个Customer实例之后，我们所要做的就是调用我们刚刚创建的函数，用刚刚登录的客户的ID和令牌来更新我们的共享首选项。下面是我们的登录和注册功能的示例:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="eebd" class="jt ju hi lf b fi lj lk l ll lm">../sign_in.dart</span><span id="efda" class="jt ju hi lf b fi ln lk l ll lm">Container(<br/>    width: 400,<br/>    child: customRaisedIconButton("Sign In !", Icons.<em class="kw">send</em>, context, () async {<br/>      if(_key.currentState.validate()){<br/>        try{<br/>          var req= await _authAPI.createSession(email, password);<br/>          if(req.statusCode == 202){<br/>            var customer = Customer.fromReqBody(req.body);</span><span id="b6fd" class="jt ju hi lf b fi ln lk l ll lm">//checkout part II &amp; II if you're not familiar with BlocProvider or //Cubits</span><span id="257e" class="jt ju hi lf b fi ln lk l ll lm">            BlocProvider.<em class="kw">of</em>&lt;CustomerCubit&gt;(context).login(customer);<br/>            upDateSharedPreferences(customer.token, customer.id);<br/>           Navigator.<em class="kw">push</em>(context, MaterialPageRoute(builder: (context) =&gt; MyHomePage(<br/>           )));<br/>          } else {<br/>            pushError(context);<br/>          }<br/>        } on Exception catch (e){<br/>          pushError(context);<br/>        }<br/>      }<br/>    })</span></pre><h2 id="d128" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">持续登录</h2><p id="b2db" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">这是你一直在等待的时刻…实现持久登录。在呈现我们的应用程序的根小部件(在本例中是HomePage)之前，我们需要检查共享的首选项是否存在。</p><p id="41ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将这个<a class="ae iu" href="https://dart.dev/codelabs/async-await" rel="noopener ugc nofollow" target="_blank">异步</a>函数称为checkPrefsForUser，我们再次创建了一个共享偏好的实例。然后，我们使用getString和getInt方法检索保存的数据。如果数据不存在，则没有用户登录，这些值将为null类型。</p><p id="fe91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们确定这些值是否存在，我们就发出一个API调用来完成从后端检索关于我们客户的所有JSON数据。我们再次使用一个<a class="ae iu" href="https://dart.dev/guides/language/language-tour#factory-constructors" rel="noopener ugc nofollow" target="_blank">工厂构造函数</a>来创建一个客户实例，并使用Cubit包管理全局登录状态。为了安全起见，我们用客户的ID &amp;令牌重新填充我们的共享首选项。</p><p id="e068" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只有当我们的客户BlocBuilder的状态为null时，我们才在呈现主页小部件之前运行这个函数。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="8f70" class="jt ju hi lf b fi lj lk l ll lm">class MyHomePage extends StatelessWidget {<br/>  const MyHomePage({Key key}) : super(key: key);<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    AuthAPI _authAPI = AuthAPI();<br/>    return BlocBuilder&lt;CustomerCubit, Customer&gt;(<br/>      buildWhen: (previous, current) =&gt; previous != current,<br/>        builder: (BuildContext context, Customer state){<br/>          checkPrefsForUser() async {<br/>          SharedPreferences _prefs = await          SharedPreferences.<em class="kw">getInstance</em>();<br/>          var _sharedToken = _prefs.getString('token');<br/>          var _sharedId = _prefs.getInt('id');<br/>          if(_sharedToken != null &amp;&amp; _sharedId != null){<br/>            try{<br/>              var req = await _authAPI.getUser(_sharedId, _sharedToken);<br/>              if(req.statusCode == 202){<br/>                var user = User.fromReqBody(req.body);<br/>                BlocProvider.<em class="kw">of</em>&lt;UserCubit&gt;(context).login(user);<br/>                upDateSharedPreferences(user.token, user.id);<br/>              }<br/>            }on Exception catch (e){}<br/>          }<br/>        }<br/>        if(state == null){<br/>          checkPrefsForUser();<br/>        }<br/>      return Scaffold(</span></pre><p id="f118" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注销用户</strong></p><p id="ab2d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要注销用户，我们只需要将我们的Cubit设置为nil，发出API请求，并从我们的共享首选项中删除我们之前存储的值。这是一个图标按钮的例子，我们可以用它来做这件事:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="1293" class="jt ju hi lf b fi lj lk l ll lm">IconButton(<br/>    icon: Icon(Icons.<em class="kw">exit_to_app</em>),<br/>    onPressed: () async {<br/>      SharedPreferences _prefs = await SharedPreferences.<em class="kw">getInstance</em>();<br/>      _prefs.remove('id');<br/>      _prefs.remove('token');<br/>      try {<br/>        var req = await _authAPI.destroySession(<br/>            state.id, state.token); </span><span id="c916" class="jt ju hi lf b fi ln lk l ll lm">/* note state refers to the <br/>Customer from the cubit of our bloc builder<br/>*/</span><span id="632b" class="jt ju hi lf b fi ln lk l ll lm">        if (req.statusCode == 202) {<br/>          BlocProvider.<em class="kw">of</em>&lt;CustomerCubit&gt;(context).logout();<br/>        } else {<br/>          pushError(context);<br/>        }<br/>      } on Exception catch (e) {<br/>        print(e);<br/>      }<br/>    })</span></pre><p id="062f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读，希望你学到了一些东西。要获得更多编程和应用程序开发教程，请务必查看我的YouTube频道，如果你想找乐子，请查看科里的角落播客！</p><p id="7f58" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">科里的角落播客:<a class="ae iu" href="https://anchor.fm/coreys-corner" rel="noopener ugc nofollow" target="_blank">https://anchor.fm/coreys-corner</a></p><p id="961e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">学习飞镖和红宝石:【https://www.youtube.com/channel/UCfd8A1xfzqk7veapUhe8hLQ】T2</p></div></div>    
</body>
</html>