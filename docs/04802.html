<html>
<head>
<title>Level-based logging in Go with Uber Zap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于级别的登录与优步Zap一起进行</h1>
<blockquote>原文：<a href="https://medium.com/codex/level-based-logging-in-go-with-uber-zap-a8a90aa40672?source=collection_archive---------1-----------------------#2022-01-08">https://medium.com/codex/level-based-logging-in-go-with-uber-zap-a8a90aa40672?source=collection_archive---------1-----------------------#2022-01-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="cd0b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">将日志记录带入另一个层次</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/b01f0b7d4ca11beb29dcaa1fe00a99c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YcVBLTidq861sJhIlVby5w.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">特色图像</figcaption></figure><h1 id="7214" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">目录</h1><ul class=""><li id="6f10" class="kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">记录还是不记录</li><li id="f953" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">Go的内置日志包</li><li id="7900" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">什么是基于级别的日志记录？</li><li id="98b4" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">介绍“优步Zap:闪电般的快速、结构化、分级的Go登录”</li><li id="50a7" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">Zap日志示例</li><li id="c9bb" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">摘要</li></ul><h1 id="3b42" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">记录还是不记录</h1><h2 id="3ac0" class="ky jk hi bd jl kz la lb jp lc ld le jt ki lf lg jv kk lh li jx km lj lk jz ll bi translated">日志记录的好处</h2><p id="7a3c" class="pw-post-body-paragraph lm ln hi kd b ke kf ij lo kg kh im lp ki lq lr ls kk lt lu lv km lw lx ly ko hb bi translated">科技行业的大多数web服务器都采用日志记录。对于web应用程序来说，日志记录有一些好处。</p><ul class=""><li id="bf27" class="kb kc hi kd b ke lz kg ma ki mb kk mc km md ko kp kq kr ks bi translated">日志记录帮助开发人员发现错误和性能问题</li><li id="addb" class="kb kc hi kd b ke kt kg ku ki kv kk kw km kx ko kp kq kr ks bi translated">日志可以重新构建并用于系统审计</li></ul><h2 id="f4b5" class="ky jk hi bd jl kz la lb jp lc ld le jt ki lf lg jv kk lh li jx km lj lk jz ll bi translated">应该记录什么</h2><p id="0a7f" class="pw-post-body-paragraph lm ln hi kd b ke kf ij lo kg kh im lp ki lq lr ls kk lt lu lv km lw lx ly ko hb bi translated">实际上，它是任何使发现和调试程序更容易的东西。日志消息可能包含对调试有用的信息，如时间戳、错误消息等。</p><h2 id="fd9d" class="ky jk hi bd jl kz la lb jp lc ld le jt ki lf lg jv kk lh li jx km lj lk jz ll bi translated">什么不应该被记录</h2><p id="3936" class="pw-post-body-paragraph lm ln hi kd b ke kf ij lo kg kh im lp ki lq lr ls kk lt lu lv km lw lx ly ko hb bi translated">不鼓励记录安全信息，尤其是在生产环境中。例如，您不应该记录信用卡信息、用户的个人信息等。你明白了。因为如果这些日志泄露，可能会被黑客利用。</p><h1 id="ec23" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">Go的内置日志包</h1><p id="b958" class="pw-post-body-paragraph lm ln hi kd b ke kf ij lo kg kh im lp ki lq lr ls kk lt lu lv km lw lx ly ko hb bi translated">Go为开发者提供了内置的日志包。它可以用来轻松地将任何内容记录到标准输出或文件中。</p><h2 id="cef1" class="ky jk hi bd jl kz la lb jp lc ld le jt ki lf lg jv kk lh li jx km lj lk jz ll bi translated">基本日志示例</h2><p id="7411" class="pw-post-body-paragraph lm ln hi kd b ke kf ij lo kg kh im lp ki lq lr ls kk lt lu lv km lw lx ly ko hb bi translated">下面的代码展示了用Go内置的日志库进行日志记录。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="fed7" class="ky jk hi mf b fi mj mk l ml mm">package main</span><span id="d57a" class="ky jk hi mf b fi mn mk l ml mm">import "log"</span><span id="b9bf" class="ky jk hi mf b fi mn mk l ml mm">func main() {<br/> log.Println("This is logging!")<br/>}</span></pre><p id="0631" class="pw-post-body-paragraph lm ln hi kd b ke lz ij lo kg ma im lp ki mo lr ls kk mp lu lv km mq lx ly ko hb bi translated">上面的代码向终端产生以下结果。您可以看到日志消息中有日期和时间信息。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="d7a3" class="ky jk hi mf b fi mj mk l ml mm">2022/01/08 14:17:45 This is logging!</span></pre><p id="fea5" class="pw-post-body-paragraph lm ln hi kd b ke lz ij lo kg ma im lp ki mo lr ls kk mp lu lv km mq lx ly ko hb bi translated">您还可以将消息记录到一个文件中！请复制以下代码并运行。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="bfe5" class="ky jk hi mf b fi mj mk l ml mm">package main</span><span id="41c2" class="ky jk hi mf b fi mn mk l ml mm">import (<br/> "log"<br/> "os"<br/>)</span><span id="178f" class="ky jk hi mf b fi mn mk l ml mm">func main() {<br/> logFile := openLogFile()<br/> defer logFile.Close()</span><span id="965f" class="ky jk hi mf b fi mn mk l ml mm">log.SetOutput(logFile)<br/> log.Println("This is logging!")<br/>}</span><span id="4173" class="ky jk hi mf b fi mn mk l ml mm">func openLogFile() *os.File {<br/> f, err := os.OpenFile("access.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)<br/> if err != nil {<br/>  log.Fatal(err)<br/> }<br/> return f<br/>}</span></pre><p id="96dc" class="pw-post-body-paragraph lm ln hi kd b ke lz ij lo kg ma im lp ki mo lr ls kk mp lu lv km mq lx ly ko hb bi translated">上面的代码生成了一个名为<code class="du mr ms mt mf b">access.log</code>的文件。该文件将包含一条消息“2022/01/08 14:22:51这是日志记录！”。</p><h2 id="13f0" class="ky jk hi bd jl kz la lb jp lc ld le jt ki lf lg jv kk lh li jx km lj lk jz ll bi translated">Go内置库有什么问题？</h2><p id="1920" class="pw-post-body-paragraph lm ln hi kd b ke kf ij lo kg kh im lp ki lq lr ls kk lt lu lv km lw lx ly ko hb bi translated">内置日志库的一个主要缺陷是它太简单了。当开发人员希望尽快看到结果时，这有利于快速开发。但是在生产环境中。我们通常想要更有结构的东西，而不是简单的文本信息。</p><p id="8f6f" class="pw-post-body-paragraph lm ln hi kd b ke lz ij lo kg ma im lp ki mo lr ls kk mp lu lv km mq lx ly ko hb bi translated">"<em class="mu">更有结构的东西是什么意思？</em>“你可能会问。我们可以通过将日志分为不同的级别来构建日志，这通常称为基于级别的日志记录。</p><h1 id="db5c" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">什么是基于级别的日志记录？</h1><p id="42ff" class="pw-post-body-paragraph lm ln hi kd b ke kf ij lo kg kh im lp ki lq lr ls kk lt lu lv km lw lx ly ko hb bi translated">应用程序通常打印许多类型的日志信息。可能有调试消息、错误、警告、一般信息等等。当涉及到调试或错误发现时，所有这些信息都可能会给我们带来问题。幸运的是，有一个将日志消息划分为不同严重级别的概念。当日志按级别分类时，我们可以对它们进行过滤，只查看我们想要分析的级别。</p><p id="fb30" class="pw-post-body-paragraph lm ln hi kd b ke lz ij lo kg ma im lp ki mo lr ls kk mp lu lv km mq lx ly ko hb bi translated">例如，错误消息可能比警告消息具有更高的优先级，那么我们可以过滤掉所有警告，只查看错误。</p><h1 id="bcff" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">介绍“优步Zap:闪电般的快速、结构化、分级的Go登录”</h1><p id="df4c" class="pw-post-body-paragraph lm ln hi kd b ke kf ij lo kg kh im lp ki lq lr ls kk lt lu lv km lw lx ly ko hb bi translated">Zap是由优步开发的一个开源项目。这是一个“速度极快”的日志框架。您可以从他们的<a class="ae mv" href="https://github.com/uber-go/zap" rel="noopener ugc nofollow" target="_blank">存储库</a>中看到性能和基准信息。</p><p id="e8bd" class="pw-post-body-paragraph lm ln hi kd b ke lz ij lo kg ma im lp ki mo lr ls kk mp lu lv km mq lx ly ko hb bi translated">Zap支持七种类型的日志级别，即调试、信息、警告、错误、恐慌和致命。每个级别的描述如下。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="c778" class="ky jk hi mf b fi mj mk l ml mm">const (<br/>	// DebugLevel logs are typically voluminous, and are usually disabled in<br/>	// production.<br/>	DebugLevel = <a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap@v1.20.0/zapcore" rel="noopener ugc nofollow" target="_blank">zapcore</a>.<a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap@v1.20.0/zapcore#DebugLevel" rel="noopener ugc nofollow" target="_blank">DebugLevel</a><br/>	// InfoLevel is the default logging priority.<br/>	InfoLevel = <a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap@v1.20.0/zapcore" rel="noopener ugc nofollow" target="_blank">zapcore</a>.<a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap@v1.20.0/zapcore#InfoLevel" rel="noopener ugc nofollow" target="_blank">InfoLevel</a><br/>	// WarnLevel logs are more important than Info, but don't need individual<br/>	// human review.<br/>	WarnLevel = <a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap@v1.20.0/zapcore" rel="noopener ugc nofollow" target="_blank">zapcore</a>.<a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap@v1.20.0/zapcore#WarnLevel" rel="noopener ugc nofollow" target="_blank">WarnLevel</a><br/>	// ErrorLevel logs are high-priority. If an application is running smoothly,<br/>	// it shouldn't generate any error-level logs.<br/>	ErrorLevel = <a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap@v1.20.0/zapcore" rel="noopener ugc nofollow" target="_blank">zapcore</a>.<a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap@v1.20.0/zapcore#ErrorLevel" rel="noopener ugc nofollow" target="_blank">ErrorLevel</a><br/>	// DPanicLevel logs are particularly important errors. In development the<br/>	// logger panics after writing the message.<br/>	DPanicLevel = <a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap@v1.20.0/zapcore" rel="noopener ugc nofollow" target="_blank">zapcore</a>.<a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap@v1.20.0/zapcore#DPanicLevel" rel="noopener ugc nofollow" target="_blank">DPanicLevel</a><br/>	// PanicLevel logs a message, then panics.<br/>	PanicLevel = <a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap@v1.20.0/zapcore" rel="noopener ugc nofollow" target="_blank">zapcore</a>.<a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap@v1.20.0/zapcore#PanicLevel" rel="noopener ugc nofollow" target="_blank">PanicLevel</a><br/>	// FatalLevel logs a message, then calls os.Exit(1).<br/>	FatalLevel = <a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap@v1.20.0/zapcore" rel="noopener ugc nofollow" target="_blank">zapcore</a>.<a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap@v1.20.0/zapcore#FatalLevel" rel="noopener ugc nofollow" target="_blank">FatalLevel</a><br/>)</span></pre><h1 id="5867" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">Zap日志示例</h1><p id="e8de" class="pw-post-body-paragraph lm ln hi kd b ke kf ij lo kg kh im lp ki lq lr ls kk lt lu lv km lw lx ly ko hb bi translated"><em class="mu">免责声明</em>:关于如何使用这个包，我不会深究太多细节。我想展示一些你可以用Zap做什么的基本例子。你可以在这里找到<a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap" rel="noopener ugc nofollow" target="_blank">详细文档</a>。</p><h2 id="850b" class="ky jk hi bd jl kz la lb jp lc ld le jt ki lf lg jv kk lh li jx km lj lk jz ll bi translated">使用预设记录器记录</h2><p id="b738" class="pw-post-body-paragraph lm ln hi kd b ke kf ij lo kg kh im lp ki lq lr ls kk lt lu lv km lw lx ly ko hb bi translated">通常，您必须在使用它之前配置一个记录器。如果我们只是想马上使用它呢？幸运的是，Zap提供了一个预置的记录器，方便使用。请参见下面的示例代码。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="b011" class="ky jk hi mf b fi mj mk l ml mm">package main</span><span id="0844" class="ky jk hi mf b fi mn mk l ml mm">import (<br/> "log"<br/> "os"<br/> "go.uber.org/zap"<br/>)</span><span id="cd9e" class="ky jk hi mf b fi mn mk l ml mm">func main() {<br/> logger, _ := zap.NewDevelopment()<br/> defer logger.Sync()</span><span id="6aa6" class="ky jk hi mf b fi mn mk l ml mm"> logger.Info("Hello Zap!")<br/> logger.Warn("Beware of getting Zapped! (Pun)")<br/> logger.Error("I'm out of Zap joke!")<br/>}</span></pre><p id="0276" class="pw-post-body-paragraph lm ln hi kd b ke lz ij lo kg ma im lp ki mo lr ls kk mp lu lv km mq lx ly ko hb bi translated">从上面的代码中，<code class="du mr ms mt mf b">zap.NewDevelopment()</code>返回一个预置的开发日志程序，它以人类可读的格式打印消息。之后，我们使用方法<code class="du mr ms mt mf b">Info</code>、<code class="du mr ms mt mf b">Warn</code>和<code class="du mr ms mt mf b">Error</code>来打印不同的日志级别。当您执行代码时，它会产生以下结果。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="34e4" class="ky jk hi mf b fi mj mk l ml mm">2022-01-08T15:33:54.504+0700    INFO    logging-zap/main.go:13  Hello Zap!</span><span id="7711" class="ky jk hi mf b fi mn mk l ml mm">2022-01-08T15:33:54.504+0700    WARN    logging-zap/main.go:14  Beware of getting Zapped! (Pun)<br/>main.main<br/>        /home/siraphob-wsl-ubuntu/go/src/github.com/copsterr/logging-zap/main.go:14<br/>runtime.main<br/>        /usr/local/go/src/runtime/proc.go:255</span><span id="f628" class="ky jk hi mf b fi mn mk l ml mm">2022-01-08T15:33:54.504+0700    ERROR   logging-zap/main.go:15  I'm out of Zap joke!<br/>main.main<br/>        /home/siraphob-wsl-ubuntu/go/src/github.com/copsterr/logging-zap/main.go:15<br/>runtime.main<br/>        /usr/local/go/src/runtime/proc.go:255</span></pre><p id="314d" class="pw-post-body-paragraph lm ln hi kd b ke lz ij lo kg ma im lp ki mo lr ls kk mp lu lv km mq lx ly ko hb bi translated">对于INFO，将打印一条普通的日志消息。它包含时间戳、日志级别、代码位置和消息。</p><p id="60ac" class="pw-post-body-paragraph lm ln hi kd b ke lz ij lo kg ma im lp ki mo lr ls kk mp lu lv km mq lx ly ko hb bi translated">对于警告和错误，它们也会打印出堆栈跟踪。这对于检测错误发生的位置非常有用。</p><h2 id="721d" class="ky jk hi bd jl kz la lb jp lc ld le jt ki lf lg jv kk lh li jx km lj lk jz ll bi translated">配置记录器</h2><p id="5285" class="pw-post-body-paragraph lm ln hi kd b ke kf ij lo kg kh im lp ki lq lr ls kk lt lu lv km lw lx ly ko hb bi translated">有时候，预设的记录器不适合你的需要。Zap允许你配置自己的日志。您可以在JSON或YAML文件中定义记录器配置，然后将其解析到Zap记录器中。示例如下所示。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="b511" class="ky jk hi mf b fi mj mk l ml mm">package main</span><span id="c4af" class="ky jk hi mf b fi mn mk l ml mm">import (<br/> "encoding/json"<br/> "log"<br/> "os"</span><span id="d05e" class="ky jk hi mf b fi mn mk l ml mm"> "go.uber.org/zap"<br/>)</span><span id="35f9" class="ky jk hi mf b fi mn mk l ml mm">func main() {<br/> rawJSON := []byte(`{<br/>   "level": "debug",<br/>   "encoding": "json",<br/>   "outputPaths": ["stdout"],<br/>   "errorOutputPaths": ["stderr"],<br/>   "encoderConfig": {<br/>     "messageKey": "message",<br/>     "levelKey": "level",<br/>     "levelEncoder": "lowercase"<br/>   }<br/> }`)</span><span id="ac6d" class="ky jk hi mf b fi mn mk l ml mm"> var cfg zap.Config<br/> if err := json.Unmarshal(rawJSON, &amp;cfg); err != nil {<br/>  panic(err)<br/> }<br/> logger, err := cfg.Build()<br/> if err != nil {<br/>  panic(err)<br/> }<br/> defer logger.Sync()</span><span id="1c4c" class="ky jk hi mf b fi mn mk l ml mm"> logger.Info("Hi, custom logger!")<br/> logger.Warn("Custom logger is warning you!")<br/> logger.Error("Let's do error instead.")<br/>}</span></pre><p id="c815" class="pw-post-body-paragraph lm ln hi kd b ke lz ij lo kg ma im lp ki mo lr ls kk mp lu lv km mq lx ly ko hb bi translated">上面的代码产生以下结果。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="2522" class="ky jk hi mf b fi mj mk l ml mm">{"level":"info","message":"Hi, custom logger!"}<br/>{"level":"warn","message":"Custom logger is warning you!"}<br/>{"level":"error","message":"Let's do error instead."}</span></pre><p id="c62b" class="pw-post-body-paragraph lm ln hi kd b ke lz ij lo kg ma im lp ki mo lr ls kk mp lu lv km mq lx ly ko hb bi translated">正如您所看到的，记录器生成JSON输出，所以如果我们将它们放入日志文件中会更好。我们可以通过如下所示修改记录器配置来实现这一点。</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="a2c3" class="ky jk hi mf b fi mj mk l ml mm">rawJSON := []byte(`{<br/>   "level": "debug",<br/>   "encoding": "json",<br/>   "outputPaths": ["stdout, "/my.log"],       &lt;-- This line<br/>   "errorOutputPaths": ["stderr", "/my.log"], &lt;-- This line<br/>   "encoderConfig": {<br/>     "messageKey": "message",<br/>     "levelKey": "level",<br/>     "levelEncoder": "lowercase"<br/>   }<br/> }`)</span></pre><p id="ed4e" class="pw-post-body-paragraph lm ln hi kd b ke lz ij lo kg ma im lp ki mo lr ls kk mp lu lv km mq lx ly ko hb bi translated">从上面的代码片段中，您可以看到键<code class="du mr ms mt mf b">outputPaths</code>和<code class="du mr ms mt mf b">errorOutputPaths</code>有一个文件<code class="du mr ms mt mf b">my.log</code>作为它们的值数组的元素。当您执行代码时，它将生成一个包含日志消息的<code class="du mr ms mt mf b">my.log</code>文件。</p><p id="1679" class="pw-post-body-paragraph lm ln hi kd b ke lz ij lo kg ma im lp ki mo lr ls kk mp lu lv km mq lx ly ko hb bi translated">这只是冰山一角。你可以用Zap做更多的事情。查看他们的<a class="ae mv" href="https://pkg.go.dev/go.uber.org/zap" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多信息。</p><h1 id="6331" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">摘要</h1><p id="2199" class="pw-post-body-paragraph lm ln hi kd b ke kf ij lo kg kh im lp ki lq lr ls kk lt lu lv km lw lx ly ko hb bi translated">日志记录允许开发人员检测bug和错误。基于级别的日志记录有助于仅过滤必要的信息。在这篇文章中，我已经向你展示了如何使用优步Zap登录。然而，它可能不是满足您需求的最佳记录器。有许多日志框架供您选择。正确使用记录器可以提高软件质量和开发过程的生产率。我希望这篇文章能给你一些关于如何在你的项目中进行日志记录的想法。编码快乐！</p></div></div>    
</body>
</html>