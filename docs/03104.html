<html>
<head>
<title>How To Use SQL Subqueries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用SQL子查询</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-use-sql-subqueries-ea702d899126?source=collection_archive---------15-----------------------#2021-08-18">https://medium.com/codex/how-to-use-sql-subqueries-ea702d899126?source=collection_archive---------15-----------------------#2021-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3eb0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">先决条件</h2></div><p id="7925" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要遵循并完全理解本教程，您需要具备以下条件:</p><ul class=""><li id="7c37" class="jt ju hi iz b ja jb jd je jg jv jk jw jo jx js jy jz ka kb bi translated"><a class="ae kc" href="https://arctype.com" rel="noopener ugc nofollow" target="_blank"> Arctype </a></li><li id="d9cb" class="jt ju hi iz b ja kd jd ke jg kf jk kg jo kh js jy jz ka kb bi translated">SQL的基础知识</li></ul><h1 id="c66e" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">什么是子查询？</h1><p id="851b" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">子查询是嵌套在另一个SQL查询中的SQL查询。它们帮助查询为一个<code class="du lf lg lh li b">WHERE</code>子句创建条件来过滤行并对它们执行操作。子查询可以与<code class="du lf lg lh li b">SELECT</code>、<code class="du lf lg lh li b">INSERT</code>、<code class="du lf lg lh li b">UPDATE</code>和<code class="du lf lg lh li b">DELETE</code>语句一起使用。</p><h2 id="4e8f" class="lj kj hi bd kk lk ll lm ko ln lo lp ks jg lq lr ku jk ls lt kw jo lu lv ky lw bi translated">WHERE子句中的子查询示例</h2><p id="a7f2" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">我们希望从数据库中获取交易金额大于1000美元的用户。对于我们的例子，我们将有两个表，即<code class="du lf lg lh li b">users</code>和<code class="du lf lg lh li b">transactions</code>，它们存储用户和交易信息。</p><figure class="lx ly lz ma fd mb er es paragraph-image"><div class="ab fe cl mc"><img src="../Images/90e8b5328b82fa975b83f464645727a4.png" data-original-src="https://miro.medium.com/v2/0*6eXXBQY1g8x6Ksgb"/></div></figure><p id="eb99" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以编写一个查询，从<code class="du lf lg lh li b">transactions</code>表中获取金额超过$1，000的所有行，然后使用它作为另一个查询的条件，该查询将基于第一个查询的结果从<code class="du lf lg lh li b">users</code>表中获取行。</p><p id="a3d0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该查询将如下所示:</p><pre class="lx ly lz ma fd mf li mg mh aw mi bi"><span id="c0f2" class="lj kj hi li b fi mj mk l ml mm">SELECT *<br/>FROM users<br/>WHERE id IN<br/>    (SELECT user_id<br/>     FROM transactions<br/>     WHERE amount &gt; 1000);</span></pre><h1 id="7991" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">子查询的优势</h1><ul class=""><li id="206b" class="jt ju hi iz b ja la jd lb jg mn jk mo jo mp js jy jz ka kb bi translated">与联接相比，子查询通过将它们组织成独立的部分来提高查询的可读性。</li><li id="58f6" class="jt ju hi iz b ja kd jd ke jg kf jk kg jo kh js jy jz ka kb bi translated">很容易理解和维护子查询。</li><li id="85f9" class="jt ju hi iz b ja kd jd ke jg kf jk kg jo kh js jy jz ka kb bi translated">子查询可以取代复杂的连接和联合。</li></ul><h1 id="0e71" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">子查询的缺点</h1><ul class=""><li id="f0e4" class="jt ju hi iz b ja la jd lb jg mn jk mo jo mp js jy jz ka kb bi translated">子查询不能在同一个SQL语句中修改表并从同一个表中进行选择。</li><li id="341c" class="jt ju hi iz b ja kd jd ke jg kf jk kg jo kh js jy jz ka kb bi translated">子查询是一项开销很大的任务，所以使用连接操作会更快。</li></ul><h1 id="0d99" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">运行子查询练习</h1><p id="819f" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">我们将使用<a class="ae kc" href="https://arctype.com" rel="noopener ugc nofollow" target="_blank"> Arctype </a>探索几个例子，其中我们将展示子查询，并了解它们是如何在应用程序中构造和使用的。</p><p id="e0a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要创建一个数据库，我们将在本教程中工作。为了方便起见，我创建了一个包含SQL文件的<a class="ae kc" href="https://gist.github.com/LordGhostX/13792039bd92d2120084100a3ab13b4b" rel="noopener ugc nofollow" target="_blank"> GitHub Gist </a>来构建我们的数据库模式并向其中插入虚拟数据。要使用它，我们需要执行以下操作:</p><ul class=""><li id="5872" class="jt ju hi iz b ja jb jd je jg jv jk jw jo jx js jy jz ka kb bi translated">使用Arctype连接到我们的数据库</li><li id="5764" class="jt ju hi iz b ja kd jd ke jg kf jk kg jo kh js jy jz ka kb bi translated">导航到Arctype中的查询选项卡，然后创建一个新查询</li><li id="96b1" class="jt ju hi iz b ja kd jd ke jg kf jk kg jo kh js jy jz ka kb bi translated">粘贴并运行Gist中的<a class="ae kc" href="https://gist.github.com/LordGhostX/13792039bd92d2120084100a3ab13b4b#file-create-sql" rel="noopener ugc nofollow" target="_blank"> create.sql文件</a>来创建模式</li><li id="8cae" class="jt ju hi iz b ja kd jd ke jg kf jk kg jo kh js jy jz ka kb bi translated">再次导航到“查询”选项卡以创建新的查询</li><li id="93a6" class="jt ju hi iz b ja kd jd ke jg kf jk kg jo kh js jy jz ka kb bi translated">粘贴并运行Gist中的<a class="ae kc" href="https://gist.github.com/LordGhostX/13792039bd92d2120084100a3ab13b4b#file-insert-sql" rel="noopener ugc nofollow" target="_blank"> insert.sql文件</a>，用虚拟数据填充数据库。</li></ul><figure class="lx ly lz ma fd mb er es paragraph-image"><div class="ab fe cl mc"><img src="../Images/ec89676cc04564477f2702b3c83c0acd.png" data-original-src="https://miro.medium.com/v2/0*kcWXVzHJbyaUiGhP"/></div></figure><h2 id="58a2" class="lj kj hi bd kk lk ll lm ko ln lo lp ks jg lq lr ku jk ls lt kw jo lu lv ky lw bi translated">使用子查询选择数据</h2><p id="3eae" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">让我们编写一个查询，从<code class="du lf lg lh li b">SKU_DATA</code>表中引用的<code class="du lf lg lh li b">BUYER</code>表中选择所有行。在Arctype中创建新查询，并执行以下代码:</p><pre class="lx ly lz ma fd mf li mg mh aw mi bi"><span id="cc50" class="lj kj hi li b fi mj mk l ml mm">SELECT *<br/>FROM BUYER<br/>WHERE BuyerName IN<br/>    (SELECT BUYER<br/>     FROM SKU_DATA);</span></pre><figure class="lx ly lz ma fd mb er es paragraph-image"><div class="ab fe cl mc"><img src="../Images/0bcb1c7a9b4394312e83b895ede013c3.png" data-original-src="https://miro.medium.com/v2/0*T1qhYn1DGYJCFJbr"/></div></figure><p id="eef1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们创建了一个内部查询，它从<code class="du lf lg lh li b">SKU_DATA</code>表中选择<code class="du lf lg lh li b">BUYER</code>列，然后使用它作为条件从<code class="du lf lg lh li b">BUYER</code>表中选择具有相同<code class="du lf lg lh li b">BuyerName</code>列值的行。</p><h2 id="1a69" class="lj kj hi bd kk lk ll lm ko ln lo lp ks jg lq lr ku jk ls lt kw jo lu lv ky lw bi translated">用子查询更新数据</h2><p id="4ab6" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">让我们编写一个查询，将2016年销售的所有商品的<code class="du lf lg lh li b">ORDER_ITEM</code>表中的<code class="du lf lg lh li b">Price</code>列的值增加10%。在Arctype中创建新查询，并执行以下代码:</p><pre class="lx ly lz ma fd mf li mg mh aw mi bi"><span id="81a6" class="lj kj hi li b fi mj mk l ml mm">UPDATE ORDER_ITEM<br/>SET Price=Price*1.1<br/>WHERE SKU IN<br/>    (SELECT SKU<br/>     FROM CATALOG_SKU_2016);</span></pre><figure class="lx ly lz ma fd mb er es paragraph-image"><div class="ab fe cl mc"><img src="../Images/de29467f5f15ff9b84056d9b402a4ade.png" data-original-src="https://miro.medium.com/v2/0*yGNmOtWpZbAquGOF"/></div></figure><p id="8bc6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们创建了一个内部查询，该查询从<code class="du lf lg lh li b">CATALOG_SKU_2016</code>表中选择<code class="du lf lg lh li b">SKU</code>列，以过滤我们应该在<code class="du lf lg lh li b">ORDER_ITEM</code>表中更新的行。</p><h2 id="3850" class="lj kj hi bd kk lk ll lm ko ln lo lp ks jg lq lr ku jk ls lt kw jo lu lv ky lw bi translated">删除带有子查询的数据</h2><p id="7f85" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">我们将编写一个子查询，删除存储在小于130，000平方英尺的仓库中的<code class="du lf lg lh li b">INVENTORY</code>表中的所有记录。该查询将如下所示:</p><pre class="lx ly lz ma fd mf li mg mh aw mi bi"><span id="dd85" class="lj kj hi li b fi mj mk l ml mm">DELETE<br/>FROM INVENTORY<br/>WHERE WarehouseID IN<br/>    (SELECT WarehouseID<br/>     FROM WAREHOUSE<br/>     WHERE SquareFeet &lt; 130000);</span></pre><figure class="lx ly lz ma fd mb er es paragraph-image"><div class="ab fe cl mc"><img src="../Images/daaaf33f5a10635e01e2a64796b71d04.png" data-original-src="https://miro.medium.com/v2/0*MBsDOAmilDrWFx2p"/></div></figure><h1 id="01fc" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">使用嵌套子查询</h1><p id="2a80" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">也可能在另一个子查询中包含子查询。这里有一个例子:</p><pre class="lx ly lz ma fd mf li mg mh aw mi bi"><span id="b278" class="lj kj hi li b fi mj mk l ml mm">SELECT *<br/>FROM CATALOG_SKU_2017<br/>WHERE SKU IN<br/>	(<br/>		SELECT SKU<br/>		FROM INVENTORY<br/>		WHERE WarehouseID IN<br/>		(<br/>			SELECT WarehouseID<br/>			FROM WAREHOUSE<br/>			WHERE SquareFeet &gt; 130000<br/>		)<br/>	);</span></pre><figure class="lx ly lz ma fd mb er es paragraph-image"><div class="ab fe cl mc"><img src="../Images/3a6ba2a6fdfc644ea2123e1a3cafa256.png" data-original-src="https://miro.medium.com/v2/0*mMZprLXgqRCOUBHh"/></div></figure><p id="273e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本例中，我们选择了存储在面积大于130，000平方英尺的仓库中的<code class="du lf lg lh li b">CATALOG_SKU_2017</code>表中的所有行。</p><h1 id="e289" class="ki kj hi bd kk kl km kn ko kp kq kr ks io kt ip ku ir kv is kw iu kx iv ky kz bi translated">结论</h1><p id="1d24" class="pw-post-body-paragraph ix iy hi iz b ja la ij jc jd lb im jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">在本文中，我们学习了子查询，这是一种在查询中运行查询的方式。我们还了解了它们的工作原理、优点和局限性，并使用<a class="ae kc" href="https://arctype.com" rel="noopener ugc nofollow" target="_blank"> Arctype </a>运行了数据示例。</p></div></div>    
</body>
</html>