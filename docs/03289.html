<html>
<head>
<title>Index Only Scan on Functional Indexes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">仅对函数索引进行索引扫描</h1>
<blockquote>原文：<a href="https://medium.com/codex/index-only-scan-on-functional-indexes-943eb2828fef?source=collection_archive---------10-----------------------#2021-08-26">https://medium.com/codex/index-only-scan-on-functional-indexes-943eb2828fef?source=collection_archive---------10-----------------------#2021-08-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/67421fc0433ba1e8a281336691cda5cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VPu4T8CuWB30kX-n"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">詹姆斯·哈里逊在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="fa30" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在过去的一篇<a class="ae iu" href="https://franckpachot.medium.com/index-only-access-with-oracle-mysql-postgresql-and-microsoft-sql-server-302383103998" rel="noopener">帖子</a>中，我详细介绍了最常见的RDBMS如何避免索引访问中代价最大的操作，即使用仅索引扫描查找表中分散的行。我提到了PostgreSQL的局限性，其中行的ACID可见性不存储在索引中，因此仅索引扫描仅对新清空的表有意义。还有另一个限制，很容易通过索引或表中的少量冗余存储来解决。</p><p id="142b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我目前没有索引的表:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7bb8" class="kc kd hi jy b fi ke kf l kg kh">postgres=# set enable_bitmapscan=false;<br/>SET<br/>postgres=# create table demo (id bigint, username text);<br/>CREATE TABLE<br/>postgres=# insert into demo select n,'Number'||to_hex(n) from generate_series(1,1000) n;<br/>INSERT 0 1000<br/>postgres=# vacuum demo;<br/>VACUUM<br/>postgres=# select * from demo where username='Number42';<br/> id | username<br/>----+----------<br/> 66 | Number42<br/>(1 row)</span></pre><p id="d88c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，我已经禁用了位图扫描来简化测试用例。目标是显示索引扫描与仅索引扫描。</p><p id="0a7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的目标是使用应用于列的函数进行搜索，仅返回该值(应用函数):</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="6ee6" class="kc kd hi jy b fi ke kf l kg kh">postgres=# explain analyze select * from demo <br/>           where upper(username)='NUMBER42';</span><span id="cdf9" class="kc kd hi jy b fi ki kf l kg kh">                                           QUERY PLAN<br/>--------------------------------------------------------------------<br/> Seq Scan on demo  (cost=0.00..22.00 rows=5 width=17) (actual time=0.057..0.657 rows=1 loops=1)<br/>   Filter: (upper(username) = 'NUMBER42'::text)<br/>   Rows Removed by Filter: 999</span></pre><p id="87a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我可以添加一个基于函数的索引来快速访问这些行:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="a94c" class="kc kd hi jy b fi ke kf l kg kh">postgres=# create index demo_upper on demo( (upper(username)) );<br/>CREATE INDEX<br/>postgres=# explain analyze select upper(username) from demo <br/>           where upper(username)='NUMBER42';</span><span id="2d69" class="kc kd hi jy b fi ki kf l kg kh">                                                    QUERY PLAN<br/>--------------------------------------------------------------------<br/> Index Scan using demo_upper on demo  (cost=0.28..20.38 rows=5 width=32) (actual time=0.025..0.026 rows=1 loops=1)<br/>   Index Cond: (upper(username) = 'NUMBER42'::text)</span></pre><p id="18af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这还不错，但我们可以做得更好。为什么不使用索引只扫描这里，因为我需要的所有信息(upper(username))都在索引和可见性图中(自从上次清空以来，我没有得到任何更改)？问题是查询规划器只需获取表达式，看到它有一个索引，知道我将选择“username”列并对其应用一个函数。然后，它认为它需要“username”列，而没有意识到它已经具有应用了函数的值。</p><h1 id="bd7f" class="kj kd hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">覆盖指数</h1><p id="7840" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">一个简单的解决方法是:将该列添加到索引中。这可以通过覆盖指数来实现:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="5fea" class="kc kd hi jy b fi ke kf l kg kh">postgres=# create index demo_upper_covering on demo( (upper(username))) include (username )<br/>CREATE INDEX<br/>postgres=# analyze demo;<br/>ANALYZE</span><span id="66dd" class="kc kd hi jy b fi ki kf l kg kh">postgres=# explain analyze select upper(username) from demo <br/>           where upper(username)='NUMBER42';</span><span id="621c" class="kc kd hi jy b fi ki kf l kg kh">                                                           QUERY PLAN<br/>--------------------------------------------------------------------<br/> Index Only Scan using demo_upper_covering on demo  (cost=0.28..4.38 rows=5 width=32) (actual time=0.027..0.029 rows=1 loops=1)<br/>   Index Cond: ((upper(username)) = 'NUMBER42'::text)<br/>   Heap Fetches: 0</span></pre><p id="12e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我唯一的索引扫描。但是，索引稍微大了一点，这意味着共享缓冲区和文件系统缓存中的页面更少了。</p><h1 id="008e" class="kj kd hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">计算列</h1><p id="8623" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">从PG12开始的另一种可能性是在表中添加this (upper(username)。最大的优点是查询将使用这个生成的列，而不必每次都编码表达式，没有where子句和select子句不一致的风险。我们会将它编入索引，这样它在索引中的存在就没有疑问了。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="9aa3" class="kc kd hi jy b fi ke kf l kg kh">postgres=# alter table demo add column upper_username text generated always as (upper(username)) stored;<br/>ALTER TABLE<br/>postgres=# create index demo_upper_stored on demo( upper_username );<br/>CREATE INDEX<br/>postgres=# analyze demo;<br/>ANALYZE</span><span id="245d" class="kc kd hi jy b fi ki kf l kg kh">postgres=# explain analyze select upper_username from demo<br/>           where upper_username='NUMBER42';</span><span id="ba75" class="kc kd hi jy b fi ki kf l kg kh">                                                         QUERY PLAN<br/>--------------------------------------------------------------------<br/> Index Only Scan using demo_upper_stored on demo  (cost=0.28..8.29 rows=1 width=9) (actual time=0.022..0.023 rows=1 loops=1)<br/>   Index Cond: (upper_username = 'NUMBER42'::text)<br/>   Heap Fetches: 1</span></pre><p id="0301" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是:对于开发人员来说易于查询，对于DBA来说易于索引，对于查询规划人员来说易于优化。这里仍然有一些冗余存储，但是在表中这是一个较小的问题(因为我们的目标不是在这里读表……)</p><h1 id="ca30" class="kj kd hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">版本和替代方案</h1><p id="da27" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">目前(PG13)仅支持存储生成的列。如果有一天允许虚拟的，可能会更好。关于兼容PostgreSQL的数据库，AWS Aurora支持所有带有预配版本的数据库。无服务器版本与PG10兼容，支持函数索引，但不支持生成的列。YugabyteDB目前与PG11兼容，因此解决方案是功能索引。CockroachDB没有基于函数的索引，但是生成了列(存储的和虚拟的，但是只有存储列上的索引不需要转到主列)</p><p id="51ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">db &lt;&gt;拨弄这个:</p><div class="ll lm ez fb ln lo"><a href="https://dbfiddle.uk/?rdbms=postgres_13&amp;fiddle=7a4dc212f126a17e4014c41dbcd78a74" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hj fi z dy lt ea eb lu ed ef hh bi translated">Postgres 13 | db小提琴</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">使用db fiddle，即表示您同意许可Creative Commons CC0提交的所有内容。创建了2137781把小提琴(22448…</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">dbfiddle.uk</p></div></div></div></a></div><p id="fb6e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">OLTP的最佳性能优化是，对于读取许多行的关键用例，避免访问表的随机读取。SSD减少了随机读取延迟，但现在对于分布式数据库，我们希望避免跨节点延迟。RDBMS有许多存储冗余数据的可能性，以保持将被一起查询的内容的聚集。而且，由于SQL(和Edgar F. Codd关系规则8和9)，这只是DDL而不需要改变代码中的DML，从而在不牺牲灵活性的情况下获得更好的可伸缩性。基于函数的索引和覆盖索引是它的关键特性，允许只扫描索引，即使是二级索引。</p></div></div>    
</body>
</html>