<html>
<head>
<title>How to Combine Audio in Swift and Programmatically Get Music From iTunes/Music Library on Mac</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift中组合音频，并以编程方式从Mac上的iTunes/音乐库获取音乐</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-combine-audio-in-swift-and-programmatically-get-music-from-itunes-music-library-on-mac-6c1df23fa679?source=collection_archive---------25-----------------------#2022-10-28">https://medium.com/codex/how-to-combine-audio-in-swift-and-programmatically-get-music-from-itunes-music-library-on-mac-6c1df23fa679?source=collection_archive---------25-----------------------#2022-10-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5847" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与Swift中的大多数东西不同，合并音轨是一个相当复杂的过程。</p><p id="794b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个很好的起点是阅读Greg Cerveny关于这个话题的文章。然而，在这篇短文中，我想说明我是如何做到的，并从我的Mac上合并MP3播放列表。<a class="ae jd" href="https://github.com/carlosmbe/Mac-iTunes-Music-Playlist-Exporter" rel="noopener ugc nofollow" target="_blank">这是完整的项目</a>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/58b5470e19eb5fe1cb03a4c74da11371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*541t2qmakKA0F7Atxudv-A.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">照片由<a class="ae jd" href="https://unsplash.com/@schluditsch?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼尔·施鲁迪</a>在<a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h2 id="fe13" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">组合音频</h2><p id="78d8" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">首先，在处理媒体时，我们会想要导入<a class="ae jd" href="https://developer.apple.com/av-foundation/" rel="noopener ugc nofollow" target="_blank"> AVFoundation </a>。</p><pre class="jf jg jh ji fd ku kv kw bn kx ky bi"><span id="7336" class="kz jv hi kv b be la lb l lc ld">import AVFoundation</span></pre><p id="13b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其次，基于Greg的代码，我们将为<strong class="ih hj">AVMutableCompositionTrack</strong>编写一个扩展，简化附加音轨。</p><pre class="jf jg jh ji fd ku kv kw bn kx ky bi"><span id="af59" class="kz jv hi kv b be la lb l lc ld">extension AVMutableCompositionTrack {<br/>  func append(url: URL) {<br/>    let newAsset = AVURLAsset(url: url)<br/>    let range = CMTimeRangeMake(start: CMTime.zero, duration: newAsset.duration)<br/>    let end = timeRange.end<br/>      if let track = newAsset.tracks(withMediaType: AVMediaType.audio).first {<br/>      try! insertTimeRange(range, of: track, at: end)<br/>       }  else{<br/>print("ERROR - Appending")<br/>       }<br/>    }<br/>}</span></pre><p id="ef69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在完成了。我们需要编写一个函数来获取音频文件并导出它们。假设您已经有了要组合的歌曲的URL列表，代码应该如下所示。</p><pre class="jf jg jh ji fd ku kv kw bn kx ky bi"><span id="f719" class="kz jv hi kv b be la lb l lc ld">var arrayOfSongPaths = [URL?]()<br/><br/>func combineSongs(){    <br/>    let composition = AVMutableComposition()<br/>    let compositionAudioTrack = composition.addMutableTrack(withMediaType: AVMediaType.audio, preferredTrackID: kCMPersistentTrackID_Invalid)<br/>    <br/>    for path in arrayOfSongPaths{<br/>        compositionAudioTrack!.append(url: path!)<br/>    }<br/>    <br/>    //Built the path like this but you can use any path you want. Just remember to handle permissions.<br/>    let documentDirectoryURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first! as NSURL<br/>    let destinationURL = documentDirectoryURL.appendingPathComponent(" resultMerge.m4a")! as URL<br/>    <br/>    if let assetExport = AVAssetExportSession(asset: composition, presetName: AVAssetExportPresetAppleM4A) {<br/>      assetExport.outputFileType = AVFileType.m4a<br/>        assetExport.outputURL = destinationURL<br/>        <br/>        assetExport.exportAsynchronously( completionHandler:    {<br/>            //You don't NEED to write these switch cases but they strongly help to debug<br/>            switch assetExport.status {<br/>                <br/>            case AVAssetExportSession.Status.failed:<br/>                print("failed \(assetExport.error)")<br/>            case AVAssetExportSession.Status.cancelled:<br/>                print("cancelled \(assetExport.error)")<br/>            case AVAssetExportSession.Status.unknown:<br/>                print("unknown\(assetExport.error)")<br/>            case AVAssetExportSession.Status.waiting:<br/>                print("waiting\(assetExport.error)")<br/>            case AVAssetExportSession.Status.exporting:<br/>                print("exporting\(assetExport.error)")<br/>                <br/>            default:<br/>                print("COMPLETED YAY!!!")<br/>                NSWorkspace.shared.open(documentDirectoryURL as URL)<br/>            }<br/>            <br/>        })<br/>    }//asset export end<br/>    <br/>}</span></pre><p id="0167" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">恭喜你。如果一切都编译和运行，Finder应该会打开，向您显示一个m4a，其中包含所有音频文件。</p><h1 id="d25f" class="le jv hi bd jw lf lg lh ka li lj lk ke ll lm ln kh lo lp lq kk lr ls lt kn lu bi translated">从Mac音乐库获取本地音乐</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lv"><img src="../Images/c68e7a0ebdca5ebcf1a118fd383f67bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1iqDCp7XeOykGOoSDQ_og.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated"><a class="ae jd" href="https://unsplash.com/@wesson?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">威森王</a>在<a class="ae jd" href="https://unsplash.com/s/photos/mac?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f4a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想将iTunes/Music中的播放列表编辑成一个音频文件。这部分是给你的。</p><p id="4fdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，导入iTunesLibrary。</p><pre class="jf jg jh ji fd ku kv kw bn kx ky bi"><span id="26a3" class="kz jv hi kv b be la lb l lc ld">import iTunesLibrary</span></pre><p id="788e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其次，我们希望获得用户库中的所有播放列表。</p><pre class="jf jg jh ji fd ku kv kw bn kx ky bi"><span id="e0b5" class="kz jv hi kv b be la lb l lc ld">let library = try! ITLibrary(apiVersion: "1.1")<br/>let playlists = library.allPlaylists</span></pre><p id="18ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您知道想要的播放列表的名称。你可以通过这个功能获得所有歌曲的网址。</p><pre class="jf jg jh ji fd ku kv kw bn kx ky bi"><span id="26b3" class="kz jv hi kv b be la lb l lc ld">func getPlaylistsData(for funcPlaylistName: String?){<br/> <br/>   guard let funcPlaylistName = funcPlaylistName else{<br/>      return<br/>    }<br/>  var stuffIWant: ITLibPlaylist {<br/>    for item in playlists{<br/>      if item.name == funcPlaylistName{<br/>          return item<br/>          }<br/>        }<br/>      return playlists[0] //Just in case in the loop fails<br/>    }<br/><br/>  for song in stuffIWant.items{<br/>    arrayOfSongPaths.append(song.location)<br/>     }<br/>}</span></pre><p id="51e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">🎊恭喜你。你完了。干杯🎉</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lw"><img src="../Images/6ebf1dfd405a097458a734cedc989bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/1*Oy4O6wRApWU-q7Jm1TUw8Q.gif"/></div></figure></div></div>    
</body>
</html>