<html>
<head>
<title>Coding arcade games in Rust: Pong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rust: Pong中编写街机游戏代码</h1>
<blockquote>原文：<a href="https://medium.com/codex/arcade-games-in-rust-pong-2f85b267ec1a?source=collection_archive---------4-----------------------#2022-02-22">https://medium.com/codex/arcade-games-in-rust-pong-2f85b267ec1a?source=collection_archive---------4-----------------------#2022-02-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0287" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经写了几篇关于在Rust中创建<a class="ae jd" rel="noopener" href="/me/stats/post/ee8f0a66ab00">刽子手</a>和在Rust中创建<a class="ae jd" rel="noopener" href="/codex/nature-of-rust-particles-40cec0a8c25e">粒子系统</a>的文章，我一直在寻找一个新的挑战…所以对我来说，下一步，在创建了一个没有输入的基于画布的项目之后，就是创建一个允许用户输入的基于画布的游戏。我能想到的最简单的方法是Pong，所以我来了。</p><h1 id="0eea" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">创建画布</h1><p id="26a7" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">该项目的第一阶段是将依赖项加载到<strong class="ih hj"> cargo.toml </strong>文件中。这样做可以确保在项目中可以接触到预制的板条箱。创建画布并允许在画布上绘制对象所需的主要两个是<strong class="ih hj"> <em class="kh"> piston </em> </strong>和<strong class="ih hj"><em class="kh">piston _ window</em></strong>。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="89a5" class="kr jf hi kn b fi ks kt l ku kv">.....<br/>[dependencies]<br/>piston = "0.53.0"<br/>piston_window = "0.120.0"</span></pre><p id="3ba2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将依赖项加载到项目中之后，下一步是绘制空白画布。下面的模板代码可以在<strong class="ih hj"> main.rs </strong>文件中使用，这也是我在任何有活塞依赖项的项目开始时经常使用的。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="a8aa" class="kr jf hi kn b fi ks kt l ku kv"><strong class="kn hj">main.rs</strong></span><span id="1c26" class="kr jf hi kn b fi kw kt l ku kv">extern crate piston_window;</span><span id="403d" class="kr jf hi kn b fi kw kt l ku kv">use piston_window::*;<br/>use piston_window::types::Color;</span><span id="12d7" class="kr jf hi kn b fi kw kt l ku kv">const WIDTH: u32 = 640;<br/>const HEIGHT: u32 = 480;<br/>const BACKGROUND_COLOUR: Color = [0.5, 0.5, 0.5, 1.0];</span><span id="0072" class="kr jf hi kn b fi kw kt l ku kv">fn main() {<br/>    let mut window: PistonWindow = WindowSettings::new("Rusty Pong",<br/>                                                  [WIDTH, HEIGHT])<br/>        .exit_on_esc(true)<br/>        .build()<br/>        .unwrap();</span><span id="6557" class="kr jf hi kn b fi kw kt l ku kv">    while let Some(event) = window.next() {<br/>        window.draw_2d(&amp;e, |context, graphics, _device| {<br/>            clear(BACKGROUND_COLOUR, graphics);<br/>        });</span><span id="f713" class="kr jf hi kn b fi kw kt l ku kv">    }</span><span id="73d0" class="kr jf hi kn b fi kw kt l ku kv">}</span></pre><h1 id="3bd1" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">向窗户划一桨</h1><p id="5a7a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">现在游戏画布已经创建好了，是时候给它添加对象了。在Pong中有两个球拍，一个给玩家，一个给基于电脑的对手。为了制作这些桨，首先在项目的src目录中创建一个新文件<strong class="ih hj"> paddle.rs </strong>。该文件将用于创建一个名为<strong class="ih hj"> paddle </strong>的结构，该结构将跟踪在窗口上绘制Paddle的位置，并具有向窗口显示Paddle的功能。除了位置之外，Paddle struct将使用布尔(真/假)特征来跟踪它是否是用户的Paddle。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="e5cd" class="kr jf hi kn b fi ks kt l ku kv"><strong class="kn hj">paddle.rs</strong></span><span id="cd3e" class="kr jf hi kn b fi kw kt l ku kv">use piston_window::types::Color;<br/>use piston_window::{rectangle, Context, G2d};</span><span id="1205" class="kr jf hi kn b fi kw kt l ku kv">const PADDLE_COLOUR: Color = [1., 1., 1., 1.];<br/>const PADDLE_WIDTH: f64 = 10.;<br/>const PADDLE_HEIGHT: f64 = 100.;</span><span id="50d7" class="kr jf hi kn b fi kw kt l ku kv">pub struct Paddle {<br/>    pos_x: f64,<br/>    pos_y: f64,<br/>    is_user: bool,<br/>}</span><span id="af73" class="kr jf hi kn b fi kw kt l ku kv">impl Paddle {</span><span id="1cee" class="kr jf hi kn b fi kw kt l ku kv">    pub fn new(pos_x: f64, pos_y: f64, is_user: bool) -&gt; Paddle {<br/>        Paddle {<br/>            pos_x: pos_x,<br/>            pos_y: pos_y,<br/>            is_user: is_user,<br/>        }<br/>    }<br/>    <br/>    pub fn display(&amp;<em class="kh">self</em>, con: &amp;Context, g: &amp;mut G2d) {<br/>        rectangle(<br/>            PADDLE_COLOUR,<br/>            [<em class="kh">self</em>.pos_x, <em class="kh">self</em>.pos_y, <br/>             <em class="kh">PADDLE_WIDTH</em>, PADDLE_HEIGHT,<br/>            con.transform,<br/>            g<br/>        );<br/>    }</span><span id="db03" class="kr jf hi kn b fi kw kt l ku kv">}</span></pre><p id="586c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码首先从piston_window框中导入必要的属性，它们是类型Color、函数rectangle和数据类型Context和G2d。颜色数据类型用于定义PADDLE_COLOUR常量，该常量用于PADDLE的<strong class="ih hj">显示</strong>功能。上下文和G2d数据类型与上一步中在<strong class="ih hj"> main.rs </strong>文件中创建的窗口相关，并允许从piston_window导入的rectangle函数将球拍绘制到游戏画布中。</p><p id="14a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当将<strong class="ih hj"> con </strong>参数传入显示函数时，“<strong class="ih hj"> &amp; </strong>”意味着该函数是在引用对象，而不是传入对象本身。如果“<strong class="ih hj"> &amp; </strong>”没有被使用，那么原始对象将不会位于相同的内存空间中，并且不能被再次引用。</p><p id="bc2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要实现Paddle结构并将其绘制到游戏画布上，必须在<strong class="ih hj"> main.rs </strong>中导入该结构，创建一个变量来包含玩家Paddle结构和在窗口绘制循环中调用的显示函数。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="94ef" class="kr jf hi kn b fi ks kt l ku kv"><strong class="kn hj">main.rs</strong></span><span id="075c" class="kr jf hi kn b fi kw kt l ku kv">extern crate piston_window;</span><span id="58a0" class="kr jf hi kn b fi kw kt l ku kv"><strong class="kn hj">mod paddle;</strong></span><span id="2a34" class="kr jf hi kn b fi kw kt l ku kv">use piston_window::*;<br/>use piston_window::types::Color;</span><span id="23ea" class="kr jf hi kn b fi kw kt l ku kv"><strong class="kn hj">use paddle::Paddle;</strong></span><span id="4230" class="kr jf hi kn b fi kw kt l ku kv">const WIDTH: u32 = 640;<br/>const HEIGHT: u32 = 480;<br/>const BACKGROUND_COLOUR: Color = [0.5, 0.5, 0.5, 1.0];</span><span id="7771" class="kr jf hi kn b fi kw kt l ku kv">fn main() {<br/>    let mut window: PistonWindow = WindowSettings::new("Rusty Pong",<br/>                                                  [WIDTH, HEIGHT])<br/>        .exit_on_esc(true)<br/>        .build()<br/>        .unwrap();<br/>    <strong class="kn hj">let mut player = Paddle::new(0., 100., true);</strong></span><span id="2db5" class="kr jf hi kn b fi kw kt l ku kv">    while let Some(event) = window.next() {<br/>        window.draw_2d(&amp;e, |context, graphics, _device| {<br/>            clear(BACKGROUND_COLOUR, graphics);<br/>            <strong class="kn hj">player.display(&amp;context, graphics);</strong><br/>       });</span><span id="985d" class="kr jf hi kn b fi kw kt l ku kv">    }</span><span id="ec4f" class="kr jf hi kn b fi kw kt l ku kv">}</span></pre><figure class="ki kj kk kl fd ky er es paragraph-image"><div class="er es kx"><img src="../Images/345f992966d6c0dddb7ca001d8f7fc06.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*rPThd5hcl21jrfh4yWIz0g.png"/></div><figcaption class="lb lc et er es ld le bd b be z dx translated">将第一个桨添加到游戏画布</figcaption></figure><p id="4a2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建对手paddle的过程与上面的过程相同，除了分配给Paddle struct的变量将被称为对手。</p><figure class="ki kj kk kl fd ky er es paragraph-image"><div class="er es kx"><img src="../Images/e57a8fccb2e3806a2e959de3df940999.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*JLeWv1GMlvQHInhno-npaA.png"/></div><figcaption class="lb lc et er es ld le bd b be z dx translated">画有两个桨的游戏画布</figcaption></figure><h2 id="5dcb" class="kr jf hi bd jg lf lg lh jk li lj lk jo iq ll lm js iu ln lo jw iy lp lq ka lr bi translated">画和移动一个球</h2><p id="606d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">与创建球拍类似，第一步是创建一个名为<strong class="ih hj"> ball.rs </strong>的新文件。这个文件将创建一个Ball结构，它将跟踪它的x和y位置，以及x和y平面上的速度和画布的宽度和高度。除了Ball结构实现中的新函数之外，还有另外两个函数:display(将球绘制到画布上)和update(移动球)。更新功能将检查球的位置是否在画布的边界之外，如果球的位置在y平面之外，则球的方向被反转。如果球在x平面中的画布之外，那么它的位置被重置为画布的中心，并且方向被反转。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="8425" class="kr jf hi kn b fi ks kt l ku kv"><strong class="kn hj">ball.rs</strong></span><span id="1cb5" class="kr jf hi kn b fi kw kt l ku kv">use piston_window::types::Color;<br/>use piston_window::{ellipse, Context, G2d};</span><span id="2483" class="kr jf hi kn b fi kw kt l ku kv">const BALL_COLOUR: Color = [1., 1., 1., 1.];<br/>const RADIUS: f64 = 10.;</span><span id="1ba5" class="kr jf hi kn b fi kw kt l ku kv">pub struct Ball {<br/>    pos_x: f64,<br/>    pos_y: f64,<br/>    vel_x: f64,<br/>    vel_y: f64,<br/>    width: f64,<br/>    height: f64,<br/>}</span><span id="2de7" class="kr jf hi kn b fi kw kt l ku kv">impl Ball {<br/>    pub fn new(pos_x: f64, pos_y: f64, <br/>               canvas_dim: [f64; 2]) -&gt; Ball {<br/>        Ball {<br/>            pos_x: pos_x,<br/>            pos_y: pos_y,<br/>            vel_x: 5.,<br/>            vel_y: 5.,<br/>            width: canvas_dim[0],<br/>            height: canvas_dim[1],<br/>       }<br/>    }<br/>    <br/>    pub fn display(&amp;mut <em class="kh">self</em>, con: &amp;Context, g: &amp;mut G2d) {<br/>        <em class="kh">self</em>.update();<br/>        ellipse(<br/>            BALL_COLOUR,<br/>            [<em class="kh">self</em>.pos_x, <em class="kh">self</em>.pos_y, RADIUS, RADIUS],<br/>            con.transform, g<br/>        );<br/>    }</span><span id="4701" class="kr jf hi kn b fi kw kt l ku kv">    fn update(&amp;mut <em class="kh">self</em>) {<br/>        if (<em class="kh">self</em>.pos_y &lt;= 0.) | (<em class="kh">self</em>.pos_y &gt;= <em class="kh">self</em>.height) {<br/>            <em class="kh">self</em>.vel_y *= -1.;<br/>        }<br/>        if (<em class="kh">self</em>.pos_x &lt;= 0.) | (<em class="kh">self</em>.pos_x &gt;= <em class="kh">self</em>.width) {<br/>            <em class="kh">self</em>.vel_x *= -1.;<br/>            <em class="kh">self</em>.pos_x = <em class="kh">self</em>.width / 2.;<br/>            <em class="kh">self</em>.pos_y = <em class="kh">self</em>.height / 2.;<br/>        }<br/>       <em class="kh">self</em>.pos_x += <em class="kh">self</em>.vel_x;<br/>       <em class="kh">self</em>.pos_y += <em class="kh">self</em>.vel_y;<br/>    }<br/>}</span></pre><p id="a030" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要将球添加到画布上，可以使用与Paddle相同的方法，只是在这种情况下，会将额外的参数传递给Ball::new函数，该函数包含画布宽度和高度的数组。</p><h2 id="c41e" class="kr jf hi bd jg lf lg lh jk li lj lk jo iq ll lm js iu ln lo jw iy lp lq ka lr bi translated"><strong class="ak">移动播放器桨</strong></h2><p id="28bd" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">对我来说，这可能有点复杂。然而，这是我从基本原则出发实现它的方式。在main.rs文件中创建了两个额外的变量，一个用于跟踪是否持有一个键，这是一个布尔值。另一个是char类型，将记录key_pressed作为单个字符(“u”表示向上，“d”表示向下)。</p><p id="f823" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了分配key_pressed，press_args函数的piston_window事件用于获取键。如果该键与向上箭头或向下箭头匹配，那么key_pressed将分别被赋予“u”或“d”。此外，held变量被设置为true。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="dabc" class="kr jf hi kn b fi ks kt l ku kv"><strong class="kn hj">main.rs</strong></span><span id="e37b" class="kr jf hi kn b fi kw kt l ku kv">...<br/>while let Some(event) = window.next() {<br/>    if let Some(Button::Keyboard(key)) = event.press_args() {<br/>        held = true;<br/>        match key {<br/>            Key::Up =&gt; {<br/>                key_pressed = 'u';<br/>            }<br/>            Key::Down =&gt; {<br/>                key_pressed = 'd';<br/>            }<br/>            _ =&gt; {}<br/>        }<br/>    }<br/>    ...<br/>}</span></pre><p id="e9ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了跟踪一个键被释放的时间，监视事件函数release_args。如果它被触发，那么held被设置为false，key_pressed被设置为“n”(表示无)。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="cf91" class="kr jf hi kn b fi ks kt l ku kv"><strong class="kn hj">main.rs</strong></span><span id="068e" class="kr jf hi kn b fi kw kt l ku kv">...<br/>while let Some(event) = window.next() {<br/>    ...<br/>    if let Some(Button::Keyboard(key)) = event.release_args() {<br/>        held = true;<br/>        key_pressed = 'n';<br/>    }<br/>    ...<br/>}</span></pre><p id="4376" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了一种方法来跟踪向上或向下箭头是否在主游戏循环中被按下，现在在paddle结构中需要有一个函数来更新Paddle。这将被称为update_player，并根据球拍应该在屏幕上向上还是向下移动来增加或减少玩家的位置。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="c771" class="kr jf hi kn b fi ks kt l ku kv"><strong class="kn hj">paddle.rs</strong></span><span id="8e4d" class="kr jf hi kn b fi kw kt l ku kv">impl Paddle {<br/>    ...<br/>    pub fn update_player(&amp;mut self, key, held) {<br/>        if (key == 'u') &amp; (pressed) {<br/>            self.pos_y -= 5.;<br/>        }<br/>        if (key == 'd') &amp; (pressed) {<br/>            self.pos_y += 5.;<br/>        }<br/>    }<br/>}</span></pre><p id="6aaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在main.rs中，update_player函数在player.display函数之前被调用，以确保每次刷新帧时，画板在画布上绘制之前被移动。</p><h2 id="fe07" class="kr jf hi bd jg lf lg lh jk li lj lk jo iq ll lm js iu ln lo jw iy lp lq ka lr bi translated">移动对手的球拍</h2><p id="4276" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">移动对手的球拍将基于球相对于右手球拍中心的垂直位置。如果球在球拍顶部的四分之一以上，那么对手将通过从位置y中减去而在画布上向上移动。如果球在球拍底部的四分之一以下，那么它将通过增加位置y而在画布上向下移动。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="ddaa" class="kr jf hi kn b fi ks kt l ku kv"><strong class="kn hj">paddle.rs<br/></strong></span><span id="825e" class="kr jf hi kn b fi kw kt l ku kv">impl Paddle {<br/>    ...<br/>    pub fn update_opponent(&amp;mut self, ball_pos_y:f64) {<br/>        if <em class="kh">self</em>.is_user == false {<br/>            if <em class="kh">self</em>.pos_y + (3. * PADDLE_HEIGHT / 4.) &lt; ball_pos_y {<br/>                <em class="kh">self</em>.pos_y += 3.;<br/>            } else if <em class="kh">self</em>.pos_y + PADDLE_HEIGHT / 4. &lt; ball_pos_y }<br/>                <em class="kh">self</em>.pos_y -= 3.;<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h2 id="c65d" class="kr jf hi bd jg lf lg lh jk li lj lk jo iq ll lm js iu ln lo jw iy lp lq ka lr bi translated">重建游戏结构</h2><p id="3256" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了监控球是否被球拍击中，第一步是创建一个名为<strong class="ih hj"> Game </strong>的新结构。这将用于初始化和包含游戏的现有方面，将它们从main.rs文件中取出。除了追踪球拍和球之外，游戏还将为玩家和对手提供两个分数属性。除了初始化游戏结构的新功能，还有一个<strong class="ih hj">更新_游戏</strong>的功能，它将运行球和桨的更新和显示功能。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="3d3d" class="kr jf hi kn b fi ks kt l ku kv"><strong class="kn hj">game.rs</strong></span><span id="c8fa" class="kr jf hi kn b fi kw kt l ku kv">use piston_window::{Context, G2d};</span><span id="5809" class="kr jf hi kn b fi kw kt l ku kv">use crate::ball::Ball;<br/>use crate::paddle::Paddle;</span><span id="7e53" class="kr jf hi kn b fi kw kt l ku kv">pub struct Game {<br/>    ball: Ball,<br/>    player_paddle: Paddle,<br/>    player_score: u16,<br/>    opponent_paddle: Paddle,<br/>    opponent_score: u16,<br/>    canvas_dim: [f64; 2],<br/>}</span><span id="af01" class="kr jf hi kn b fi kw kt l ku kv">impl Game {<br/>    pub fn new(canvas_dim: [f64; 2]) -&gt; Game {<br/>        Game {<br/>            ball: Ball::new(canvas_dim[0] / 2., canvas_dim[1] / 2., <br/>                            canvas_dim),<br/>            player_paddle: Paddle::new(0., 200., true),<br/>            player_score: 0,<br/>            opponent_paddle: Paddle::new(canvas_dim[0] - 10., <br/>                                         200., false),<br/>            opponent_score: 0,<br/>           canvas_dim: canvas_dim,<br/>        }<br/>    }</span><span id="a5c6" class="kr jf hi kn b fi kw kt l ku kv">    pub fn update_game(&amp;mut <em class="kh">self</em>, con: &amp;Context, g: &amp;mut G2d, <br/>                       key_pressed: char, held: bool) {<br/>        <em class="kh">self</em>.player_paddle.update_player(key_pressed, held);<br/>        <em class="kh">self</em>.player_paddle.display(&amp;con, g);<br/>        <em class="kh">self</em>.opponent_paddle.update_opponent(<em class="kh">self</em>.ball.pos_y);<br/>        <em class="kh">self</em>.opponent_paddle.display(&amp;con, g);<br/>        <em class="kh">self</em>.ball.display(&amp;con, g);<br/>        <em class="kh">self</em>.hits_ball();<br/>    }</span><span id="f4a9" class="kr jf hi kn b fi kw kt l ku kv">}</span></pre><p id="bc00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在可以简化main.rs文件，以便对游戏结构进行初始化，并在绘制循环中调用update_game函数。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9c8c" class="kr jf hi kn b fi ks kt l ku kv"><strong class="kn hj">main.rs</strong></span><span id="f43e" class="kr jf hi kn b fi kw kt l ku kv">mod game;<br/>use game::Game;<br/>...<br/>fn main() {<br/>    ...<br/>    let mut game: Game = Game::new([WIDTH as f64, HEIGHT as f64]);<br/>    ...<br/>    <br/>    window.draw_2d(&amp;event, |context, graphics, _device| {<br/>        clear(BACKGROUND, graphics);<br/>        game.update_game(&amp;context, graphics, key_pressed, held);<br/>    });<br/>    ...</span><span id="ed0d" class="kr jf hi kn b fi kw kt l ku kv">}</span></pre><h2 id="22d1" class="kr jf hi bd jg lf lg lh jk li lj lk jo iq ll lm js iu ln lo jw iy lp lq ka lr bi translated">把球从球拍上反弹回来</h2><p id="3e79" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在上一节创建的游戏结构中，需要一个函数来监控球到达游戏画布的任意一端时是否击中了球拍。函数(hits_ball)将查看球的位置何时在距离屏幕左边缘或右边缘10个像素(球拍的宽度)以内。如果满足这个标准，那么球的y位置将与合适的球拍进行比较。如果球的y轴位置在球拍覆盖的范围内，那么球的x轴速度就会反转。这确保了球在被击中时会返回画布。当球到达画布的末端而被球拍错过时，分数应该更新以反映这一点。在球结构中，更新函数处理球在未命中后的重置。</p><p id="606e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在球更新之前，在Game::update_game函数中调用函数<strong class="ih hj"> hits_ball </strong>，以确保在球的方向因失误而改变之前，可以更新分数。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="7d22" class="kr jf hi kn b fi ks kt l ku kv"><strong class="kn hj">game.rs</strong></span><span id="6d37" class="kr jf hi kn b fi kw kt l ku kv">....<br/>impl Game {<br/>...</span><span id="24c4" class="kr jf hi kn b fi kw kt l ku kv">fn hits_ball(&amp;mut <em class="kh">self</em>) {<br/>    if <em class="kh">self</em>.ball.pos_x &lt;= 10. {<br/>        if (<em class="kh">self</em>.ball.pos_y &gt;= <em class="kh">self</em>.player_paddle.pos_y)<br/>         &amp; (<em class="kh">self</em>.ball.pos_y &lt;= <em class="kh">self</em>.player_paddle.pos_y + 100.) {<br/>            <em class="kh">self</em>.ball.vel_x *= -1.;<br/>        }<br/>    } else if <em class="kh">self</em>.ball.pos_x &lt;= 0. {<br/>        <em class="kh">self</em>.opponent_score += 1;</span><span id="77fe" class="kr jf hi kn b fi kw kt l ku kv">        println!("Player: {} | Opponent: {}, self.player_score,<br/>                  self.opponent_score);<br/>    }<br/>    if <em class="kh">self</em>.ball.pos_x &gt;= <em class="kh">self</em>.canvas_dim[0] - 10. {<br/>        if (<em class="kh">self</em>.ball.pos_y &gt;= <em class="kh">self</em>.opponent_paddle.pos_y)<br/>         &amp; (<em class="kh">self</em>.ball.pos_y &lt;= <em class="kh">self</em>.opponent_paddle.pos_y + 100.) {<br/>            <em class="kh">self</em>.ball.vel_x *= -1.;<br/>        }<br/>    } else if <em class="kh">self</em>.ball.pos_x &gt;= <em class="kh">self</em>.canvas_dim[0] {<br/><em class="kh">        self</em>.player_score += 1;<br/>        println!("Player: {} | Opponent: {}, self.player_score,<br/>                  self.opponent_score);<br/>    }<br/>}<br/>...</span></pre><p id="44ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">加入打印！线，如果球错过了，让分数在控制台上进行监测，而游戏正在运行。现在需要做的就是在终端中使用下面的命令构建并运行程序:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="89bb" class="kr jf hi kn b fi ks kt l ku kv">$cargo run</span></pre><figure class="ki kj kk kl fd ky er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ls"><img src="../Images/0724652cc4d988214e5b2e9e236ea16e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dFikSA5YK_BZqMSXT6hluw.gif"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">乒乓球比赛镜头</figcaption></figure><h2 id="5daa" class="kr jf hi bd jg lf lg lh jk li lj lk jo iq ll lm js iu ln lo jw iy lp lq ka lr bi translated">结论</h2><p id="184d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">对我自己来说，这是一个具有挑战性的项目，从学习如何在使用piston_window时接受输入，到如何构建游戏和幕后必要的逻辑。如果你想自己运行这个，代码可以在我的<a class="ae jd" href="https://github.com/Jack-Sim/rust_pong" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。请让我知道，如果你在评论中给这一去，喜欢和关注我更多的内容。</p><p id="b6cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非常感谢您的阅读:)</p></div></div>    
</body>
</html>