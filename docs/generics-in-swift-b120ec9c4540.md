# Swift 中的泛型

> 原文：<https://medium.com/codex/generics-in-swift-b120ec9c4540?source=collection_archive---------2----------------------->

## 深入探究受约束和不受约束的泛型

![](img/520e783dd5bf9aa98dabc2b018db992b.png)

照片由[卢卡·布拉沃](https://unsplash.com/@lucabravo?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

这个故事就有点长了。请原谅我。我将确保在这里传递关于泛型的最佳知识。到这个故事结束的时候，我们将会学到以下的东西。如何编写泛型代码
2？如何用协议约束泛型
3。如何使用等价、可比和可散列的协议
4。如何创建高度可重用的类型

## 我们开始吧！

## 什么是泛型？

在之前，我们学习什么是泛型。我们将会看到什么是多态性概念。解码`Polymorphism`的词义，我们可以了解到**多态**的意思是:
**聚** =多
**语素** =形式

> 所以多态等于很多形式。

例如，我们将考虑锁门的场景。
**我们有多少种方法可以锁门？**

![](img/83a2245a70343725710256077b02982c.png)![](img/b5c8c0f25efc5252ac47ed848f30ec67.png)![](img/79f2172a44d010bc0beaf1978fd97a48.png)

手动钥匙锁、生物识别锁、自动锁等。锁门有很多种方法。但是结果总是一样的锁上门或者是锁上门的过程。在编程中，我们可以编写一个中央锁定函数，而不考虑锁的类型。无论你遇到什么样的锁，你的中控锁功能都会帮你搞定。这就是多态性的含义。简而言之，我们可以说多态是一种允许相似操作以相同名称分组的方式。继承让我们从另一个类继承属性和方法。多态性使用这些方法来执行不同的任务。

`Generics`对于创建多态代码至关重要。一旦你开始使用`Generics`，你会看到你的代码库变得精简，你会写出非常优雅和高度可重用的代码。

## 让我们创建第一个泛型函数。

我们将首先编写一个简单的非泛型函数来查找数组的第一项和最后一项。

这里你可以看到我们有一个函数`getFirstLast`，它接受一个整数数组输入并返回一个元组，元组中的第一个元素作为数组的第一个元素，元组中的第二个元素作为数组的最后一个元素。现在，让我们假设你的需求已经做了一点调整，我们将有一个字符串数组作为输入和(String，String)作为函数返回，而不是整数数组输入。你将如何处理这件事？你将不得不用[String]输入和(String，String)输出编写一个不同的函数。

在这些场景中，泛型可以提供帮助。在这里，我将展示泛型是如何帮助我们的。

将非泛型函数转换为泛型函数是一个简单的过程。
我们将在函数参数中添加一个通用的`<T>`类型参数。现在，一旦我们为函数引入了一个泛型，我们就可以很容易地在函数的其余部分引用它。
举例:`array: [T]`及其返回类型`(T, T)`
这里的 **T** 只是一个抽象。我们用 T，U 或 V 等。，作为惯例。你可以用任何单词代替 t。

现在我们将看到我们的泛型函数如何与其他类型一起工作。

结果:

```
Nikhil Vinod
1 2
1.0 2.0
```

## 具有自定义类型的泛型

我们也可以在泛型中传递自定义类型。例如

结果:

```
Dog(name: “Snow”) Dog(name: “Snowy”)
```

不像`Any`在运行时没有向下转换。编译器在编译时声明一切。

## 用协议约束泛型

我们看到了一个简单的`T`是如何成为任何事物的。这意味着我们的`T`上面的例子是无约束的泛型。我们可以通过用协议约束来限制泛型应该表示什么。
比如:
我们写一个函数，返回一个输入数组中的最低值。既然我们已经学会了如何编写通用代码，我们将编写如下代码。

但不幸的是，我们的代码会抛出一个错误。

```
error: binary operator '<' cannot be applied to two 'T' operands
      return first < second
```

是因为我们的`T`还不够成熟，不能进行比较运算。我们将使用协议解决此问题。

## 等价的、可比较的和可散列的协议

什么是`Protocols`？协议只不过是一套规则。那么协议如何帮助我们完成我们的`lowest`功能呢？协议定义了泛型工作的规则。符合`Protocol`的类需要在类中定义该协议所需的所有功能和变量。这对我们来说是一个众所周知的事实。同样，我们将在`lowest`函数中为`T`定义`Protocols`来完成它。

在`lowest`函数中，问题是比较器不与`T`一起工作。所以我们有一个`Comparable`救援协议。

**可比** 可比协议有几个静态函数用于以下操作:`<` `<=` `>=` `>`
现在来完成我们的`lowest`功能。我们将通过使`T`符合`Comparable`来给`lowest`补充助推器

既然我们知道输入数组中的所有项都可以进行比较，那么我们可以通过编写下面的代码来完成最低层的函数:

等价协议允许我们检查两个类型是否相等。
等价协议有一个用于操作`==`的静态函数，它和我们之前看到的可比协议一样简单。

例如:
我们将尝试创建一个可以接受整数输入作为值的结构。我们还将创建几个带有一些值的结构对象，检查它们是否相等。如果我们用非泛型结构对对象进行比较，编译器会抛出一个错误。让我们使它符合一个等价的协议。

这里`AlienInteger`符合等价协议，我们可以使用`==`操作符。

结果:

```
true, false
```

**Hashable** Hashable 协议定义了一种方法，该方法接受一个哈希器来产生一个整数哈希值。然后，具有 Hashable 类型的泛型可以将值提供给哈希函数。
可散列类型可用作字典键或集合的一部分。
很多`Equatable`的内置类型也是`Hashable`。

当您定义一个没有关联值的枚举时，它会自动获得`Hashable`一致性，并且您可以通过实现`hash(into:)`方法将`Hashable`一致性添加到您的其他定制类型中。
对于存储属性都是`Hashable`的结构，以及具有 all- `Hashable`关联值的枚举类型，编译器能够自动提供`hash(into:)`的实现。

例如:
一名教师想要将他/她的班级学生的详细信息从一个大列表输入到她的班级数据库中，该列表也有重复项。所有学生都将拥有一个唯一的 ID。现在，老师必须将唯一的学生输入到新列表中。让我们来解决这个问题。

为了解决重复的问题，我们将保留一批学生。因为`Student`型是 hashable，所以可以成套使用。

我们通过提供一个`==`操作函数并实现`hash(into:)`方法，将`Student`类型变成了`Hashable`。
本例中的`hash(into:)`方法将学生的`name`和`id`属性输入到提供的哈希函数中。这些属性与用于测试`==`运算符函数中的相等性的属性相同。既然`Student`符合`Hashable`协议，我们可以创建一组 currentList。

结果:

```
New student added (Snow, 2).
```

我们已经到了这个故事的结尾。我希望你已经理解了泛型和多态的概念。接下来是**泛型和子类型 Swift 中的子类型和不变性概念**

如果你喜欢这个故事，请分享并关注更多这样的故事。如果你有任何疑问或建议，请告诉我。感谢你阅读❤️