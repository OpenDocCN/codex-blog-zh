# Python 中的并行编程——第 3 课。同步原语

> 原文：<https://medium.com/codex/parallel-programming-in-python-lesson-3-synchronization-primitives-78ac09befc43?source=collection_archive---------14----------------------->

![](img/e528ebd9f3ea1a80ff179c57af1bbe8b.png)

这是系列课程的第三部分，涵盖了 Python 编程语言为并行编程提供的各种工具以及使用每种工具的动机。在之前的课程中，我们探索了*事件驱动*设计的应用需求，并学习了如何区分真正需要并行代码的需求(例如通过多线程)。然后，我们详细研究了 Python 线程工具。在本课中，我们将继续探索同步的应用需求(线程之间)以及 Python 对同步的支持。

*本课章节:*

1.  “生产者/消费者”——问题领域
2.  (代码的)关键部分
3.  锁:基本的同步原语
4.  条件变量
5.  事件
6.  封装消息
7.  信息排队
8.  什么时候用？
9.  发布/订阅
10.  套接字 I/O 作为同步原语
11.  附加同步原语
12.  作业:尾部服务器

## 1.“生产者/消费者”——问题领域

*问题:*信息以离散的*“消息”*流的形式从其来源发出，目标是在指定端显示(或其他处理)，要求紧密同步:(1)消息以正确的顺序到达，以及(2)消息不会在途中丢失。

*解决方案指南:*这个*面向对象的*解决方案区分了两个对象类:*生产者*(一个或多个类和对象)专门负责*生产*和*消费者*(一个或多个类和对象)专门负责*消费。*(我们尽量不要把这两种功能混在一起。我们不希望同一个对象既生产又消费，除了可以理解的例外，比如 acknowledge)。将功能封装在不同的类中使它们相对简单，将设计简化为管理它们之间的通信。事件驱动的设计被邀请，为了*把*消费者和生产者分开(反之亦然)。生产者制造数据并根据某种协议发送出去，消费者消费现成的数据，(根据相同的协议)。尽管这里很少要求同时性(生产者和消费者在完全相同的时间执行各自的工作)，但是*并行*是！如果我们希望将公共资源的生产和消费分离到不同的对象，尽可能地松散耦合，那么每个对象都必须以不同的方式发送——一端是生产循环，另一端是消费循环——设计挑战就简化为*同步*两个(或更多)循环。

我们从原型和“老式”的解决方案开始:多线程。(稍后，我们将考虑通过“合作”编程来减少多线程开销的更现代的解决方案)。

为了简单起见，我们将我们的示例限制为一个生产者和一个消费者。(多生产者/消费者解决方案自然更复杂，但不会引入完全不同的设计习语)。生产者每两秒发出列举的文本消息*，*由消费者显示，希望以相同的顺序。启动器原型使用一个*全局变量*来存储当前消息。(不可否认，这不是最佳实践，但教科书中的例子总是这样开始的……)。显然，生产者和消费者生活在不同的线程上。

*这里是 Python (3.9)的一个入门原型，后面是注释和示例输出:*

*备注(对应评论号):*

1.  当前消息的全局容器。
2.  生产者类遵循与前面课程中举例说明的线程类相同的模式。(详见第二课第一个例子)。
3.  生产者每两秒发出一条枚举消息(覆盖全局变量)。
4.  作为专有协议的一部分，生产者使用全局消息，也作为消费者停止的指令。这样的捷径在交流中很常见。另一种方法是为此目的指定另一个全局变量(布尔值)。
5.  制片人还没起床。(由仍然为空的消息指示)。(要做的是:用一个合适的解决方案取代这种耗费 CPU 资源的解决方案。程序可能会毫无理由地每秒钟进入和退出循环数千次。睡眠不是一个选项，因为它会扰乱两秒钟的速率)。
6.  协议的消费者一方。显示“停止”的消息被解释为退出消耗循环的指令(不显示)。
7.  它的工作完成后，消费者打印出一个最终消息，这样我们就可以验证测试程序了。
8.  主程序创建消费者和生产者，并启动它们。(在这个非同步原型中，启动的顺序很重要)。然后等待 20 秒钟(这样可以传递 10 条消息，每两秒钟一条)。
9.  主程序向制作人发出停止的信号。(没有必要示意消费者停下来。这个已经由制作人负责了)。
10.  主程序加入*消费者*，因为它是最后一个完成的线程。

*输出:*

```
Round 1 
Round 1 
Round 2 
Round 4 
Round 4 
Round 6 
Round 7 
Round 8 
Round 9 
Round 9 
Round 10 
[End of input]
```

哎呀！输出还有一些需要改进的地方…很明显，这个设计一定是缺少了一些关于问题领域的基本东西！

我们可以很容易地证明这种设计的错误前提，下面的例子介绍了对消费者逻辑的简单改进。(它仍然没有解决问题，但它给出了其来源的线索)。

*注释:* 1。这一次，我们*捕获了此时的状态*(在局部变量“message”中)。对“消息”的进一步引用检索捕获的状态。(相反，在最初的设计中，如果全局变量在之间*发生变化，那么每次对全局“theMessage”的引用都会检索同一个对象当时的状态，从而产生不一致的值——就我们所见，它确实发生了变化，而且至少发生了三次——参见上面输出中的 missing 和 double 项)。*

为什么会这样呢？程序化*功能*是按照书写的顺序实现的一系列功能。好消息是，这种行为在函数调用级别(也称为“线程”)得到了保证，就像我们习惯的那样。坏消息是，这在*程序级别上是没有保证的！*(或者计算机水平，就此而言)。操作系统可以在任何合适的时间点自由地持有线程(通常是在阻塞 I/O 时，但并不仅限于此)，并将对 CPU 的控制权交给另一个线程。(在多核平台中，您可以*将您的线程与特定的内核*关联，但即使这样也不能保证对它的独占访问)。因此，很有可能(也很有可能)，操作系统会释放生产者来执行两个表达式(确切地说，是从它们编译而来的二十几个机器指令)，保持它，释放消费者来执行一个表达式，保持它，将控制传递给另一个线程，等等。

*士气:*不仅不能保证你线程中的指令会在其他编写的*中执行，在计算机层面上，*可能会出现完全相反的情况。多线程设计必须从认识到线程在世界上并不孤单开始！现在应该很明显，这里应该避免一些编程实践。特别是，在并行编程中，通过*未受保护的*全局变量进行通信(这是一个快速而肮脏的编程技巧),会招致灾难！虽然对全局内存的引用有时是不可避免的(如在与*内存映射设备*通信的情况下)，但不保护对它的*访问*是糟糕的编程实践。(一般来说，没有什么糟糕的编程实践是*并行性*所独有的。并行编程有一个令人讨厌的习惯，那就是强调糟糕的编程实践，这种实践在其他地方可能会以某种方式逃脱惩罚……)

我们现在将讨论解决保护公共资源问题的各种方法，这些方法都可以归结为下列方法之一:

1.  为了*保护*(访问)全局资源。
2.  完全避免全球资源媒介(通过其他媒介交流)。

*输出:*

```
Round 1 
Round 2 
Round 3 
Round 3 
Round 5 
Round 6 
Round 7 
Round 8 
Round 9 
Round 10 
[End of input]
```

*问题:*对公共数据的访问——消费者认为是自己的输入，生产者认为是自己的输出——不是*同步的*,这就产生了所谓的*竞争条件:*双方都在争夺相同的资源，从而导致随机结果。(取决于哪个马头碰巧第一个冲过终点线——“por una cabeza”)。具体来说，这里有三种出错的方式:

1.  消息在被(使用者)处理时可能会(由生产者)更改。
2.  消费者可能会错过新消息(由于过早地轮询其容器)，从而重复旧消息。
3.  消费者可能会跳到下一条消息(等待时间有点长)。

为什么这个例子会引入竞争条件，而不像上一课的“文件监视器”例子？嗯，另一个例子是定制的，以避免竞争条件，使它简单(但不太现实…)

1.  我们给了文件监视器足够的时间来享受它的输入(平均两次半的探测——每次两秒，一条消息保持完整五秒)。
2.  文件监视器没有打开输入的内容。它只是注意到了它的变化这一事实。

在这样的有利条件下，很难输！但是，现实世界中可靠的生产者/消费者架构需要*同步*，这将在下面讨论

## 2.(代码的)关键部分

让我们用一个*负面需求来面对这个问题:*保持公共数据(我们的消息)的完整性和真实性，需要*来防止数据在还没有准备好的时候就被使用。*具体来说:

*   在产生下一个输入时阻止消费者(访问其输入)。
*   当生产者的最新产出被消耗时，阻止生产者发布其产出。

为什么含糊不清？为什么这么复杂？我们不能只保存数据*吗？数据是无生命的物质，可以被程序操纵。在过程化编程中，人们不能将责任分配给数据(在并行环境中，原子整数是个例外，它太简单了，在这里帮不上什么忙)。我们只能(1)找到负责数据的相关程序(一系列功能，等待实现),以及(2)当它们可能干扰(对等线程的并行展开)时，阻止它们执行！在这个解决方案中，我们有两个必须遵守的关键过程:一个在生产者内部，另一个在消费者内部。这种过程被称为临界段(代码的临界段，根据请求保存)。*

临界区是根据从外部确定的条件*可以持有的功能中的一系列能力。(与内部确定的条件相反，例如 *if* 、 *while* 等。)*

你可能熟悉临界区*同步原语*(Python 不支持)。它确实有两种方法:进入临界区和退出临界区。顾名思义，这两个函数调用界定了临界区。

在程序设计中，同步可以简化为以下设计决策:

1.  以识别不同的关键部分。
2.  来选择支撑它们的条件。(通常是标准库中的现成工具)。(如果您需要，没有人会阻止您基于这些原语设计更智能的同步机制。但是想出完全新颖的东西是不太可能的，因为这些设施与操作系统和硬件密切相关，超出了普通程序员的能力范围。

## 3.锁:基本的同步原语

Python *锁*(在其他语言和平台中以“互斥”、“临界区”、“二进制信号量”等名称调用)是最基本的同步原语。它很少单独使用(我们很快就会发现)，并且是我们稍后将探讨的其他同步原语的基础。这里，我们将使用一个锁来界定我们的两个关键部分(生产者网络生产和消费者网络消费)。

一个锁响应*获取*和*释放*请求。通过*获取*，一个线程请求进入临界区的独占权限。自然地，这个权利只会在还没有被给予其他人的情况下被给予请求线程！

*   当不是这种情况时(另一个线程已经获得了锁，并且现在正在临界区的深处进行)，请求线程被阻塞(通过调用 *acquire* ，其中*没有返回*给它)并且被排队。
*   当当前线程*释放*锁时，下一个挂起的线程被提取，现在持有锁并可以自由进入临界区(其对 *acquire* 的挂起调用最终返回)。
*   当然，在获取一个空闲锁的小例子中，对 *acquire* 的调用会立即返回，线程可以自由地继续执行(可能会阻塞其他可能出现在中间的线程)。

*这是一个重构的入门原型，后面是注释和输出示例:*

*备注:*

1.  除了*线程*之外，*线程*内置库还包括一系列有用的线程相关同步原语。
2.  锁是一个全局对象，因为它保存了生产者和消费者的公共状态。默认情况下，它是初始化的。(一个典型的错误，每个有自尊的实时程序员都必须经历的一种成人礼，就是试图用两个*本地*锁来同步消费者和生产者。这些锁中的每一个都在保护自己的虚拟资源，但肯定不是公共的物理资源！)
3.  with 块定义了生成器端的临界区。Lock 是一个“上下文管理器”,这赋予它在进入和退出块时添加一些动作的特权。实际上，锁是在进入 with 块时获得的，在退出 with 块时被释放。
4.  另一个*和*模块定义了用户侧的关键部分。
5.  空白消息被忽略(生产者尚未准备好)。(要做的事情:修复这个占用大量 CPU 资源的工作区)。
6.  主程序不受生产者/消费者协议改进的影响。

*输出:*

```
Round 1 
Round 2 
Round 3 
Round 3 
Round 5 
Round 5 
Round 6 
Round 8 
Round 8 
Round 10 
Round 10 
[End of input]
```

哎呀！还没完呢！

*问题:*在这个例子中，锁确实保证了临界区不会交错:生产者在消费者检索消息时不会干涉，而消费者在生产者准备消息时也不会干涉。但是这仍然留下了两个必须注意的竞争条件:

1.  消费者在生产者之前重新获得锁(再次接收旧消息)！
2.  生产者在消费者之前重新获得锁(并且当前消息丢失)！

*解决方案:*协议应具有*确认*(简称“ack”)。生产者应仅在消费者确认处理消息(即发出 ack 信号)时进入临界区。这最终解决了剩余的竞争条件。

*这是一个重构的原型，后面是注释和示例输出:*

*备注:*

1.  另一个全局变量:布尔 ack。
2.  只要使用者没有确认处理挂起的消息，生产者就会避开临界区。(要做的事情:修复这个占用大量 CPU 资源的工作区)。
3.  它的工作完成后，生产者关闭确认。球现在在消费者的领域。
4.  只要消费者自己的 ack 仍然未决，消费者就避开临界区。(制作人还没完)。(要做的事情:修复这个占用大量 CPU 资源的工作区)。
5.  避免空消息(生产者尚未准备好)。(要做的事情:修复这个占用大量 CPU 资源的工作区)。
6.  它的工作完成后，消费者承认生产者继续进行，但不是在两者都延迟两秒钟之前。(在这个具体配置上，是消费者定了步调！)
7.  主程序不受协议变化的影响。

*输出:*

```
Round 1 
Round 2 
Round 3 
Round 4 
Round 5 
Round 6 
Round 7 
Round 8 
Round 9 
Round 10 
[End of input]
```

*额外的 Python 锁功能:*

*   使用锁作为上下文管理器 *(with-block)* 是常见的方式。最重要的是，它防止了过早退出临界区的常见错误，忽略了释放锁，这使得程序*无限期地停滞在*中。然而，没有人阻止你显式地调用*获取*和*释放*，如果这需要的话。(例如，为了指定超时)。
*   可以获得锁*非阻塞*(使用布尔自变量)。对 acquire 的调用返回布尔成功状态——现在您是否控制了锁。(当然，尽管失败，继续进行，协议无效！)
*   可以获得锁*阻塞*(默认)，但是超时(默认为无限)。(咨询结果状态)。一个常见的做法是*在获取*时用一个短的超时进行迭代(防止你的线程因为对方的疏忽而卡住)。
*   虽然 Python 锁只是操作系统锁的包装器，但是有一些限制:(1)Python 锁受限于进程范围。不能给它命名(从另一个进程控制)。(2) *释放*可以从任何线程调用(而不仅仅是从获得锁的线程)。
*   RLock(用于“可重入”锁)解决了递归尝试从同一个线程获取锁的问题。正常情况下，这会使当前线程陷入死锁，导致程序停滞，因为线程现在持有自己，将永远不会再释放它。相反，可重入版本增加了一个获取计数器(通过当前线程)。因此，当当前持有锁的线程试图再次获取锁时，计数会增加(而不是持有线程),并且当前线程的每个释放请求都会减少该计数。当计数达到零时，可重入锁最终被释放。在递归算法中使用 RLock。

## 4.条件变量

Python 已经有了封装锁和条件的同步原语。因此，我们可以用它来简化前面的原型(此外，还可以解决它的性能问题)。

条件(也称为条件变量)将临界区(由锁分隔)与类似于事件(见下一节)的等待/通知能力相关联，通常(但不一定)与布尔测试一起。该条件的独特之处在于,*等待*(等待资源持有者释放它)在临界区“打了一个洞”,并允许另一方获得锁，继续进行任何需要的操作(例如，准备公共资源)。当另一端*通知*时，条件重新获得锁，控制进入临界区的剩余部分。这使得它成为一个灵活且非常通用的同步解决方案。(相反，试图从由裸锁限定的临界区内显式同步会导致死锁！)

*这里是重构后的原型，后面是 notes(输出保持不变):*

*备注:*

1.  这个同步原语也是从线程库中导入的
2.  默认情况下，接收条件是全局初始化的。
3.  条件(锁在其中)界定了生产临界区。
4.  指示结束时，生产者释放消费者并退出生产循环。
5.  它的循环工作完成后，生产者放行消费者接收。
6.  在这里，制作人设定节奏(这更合适)。睡觉发生在临界区之外！请注意，该生成器每两秒钟发出一条消息*，而不考虑另一端*。(与本课中的其他解决方案相反，它不等待 ack)！因为这个消费者做的很少，所以这个设计是可行的。试着减少睡眠时间(几分之一秒)，它不会崩溃。这将需要很高的利率，使消费者松散的信息。(在这种情况下，ack 可能会到期返回)。
7.  条件的(锁定)限定了消耗临界区。
8.  该示例使用消息更改验证来交换来自接收方的 *ack* 。(假设，在这个协议中，没有两个连续的消息是相同的！)
9.  在周期结束时，消费者记录当前消息。
10.  主程序不受同步方法改变的影响。

*附加条件功能:*

*   可以将多个条件与同一个锁相关联(在构造时指定)。默认情况下，条件会创建自己的锁。
*   *Wait_for* 接受谓词(函数、显式或 lambda)和(可选)超时，并等待通知*，而*谓词返回 false。(实际上，我们并不期望它只执行一次)。当然你也可以自己写循环，调用 *wait* 代替。测试条件是一个惯例。原则上，你可以无条件等待，使用条件作为带锁事件。
*   对 *notify* 的调用释放了一个等待线程(这是我们在这里得到的全部)。要释放多个等待线程，要么指定它们的数量，要么使用 *notify_all* 。

## 5.事件

*事件*看起来像没有条件和锁的条件变量(只剩下*等待/通知*功能)。事实上，这比它早了几十年。新的条件变量通常作为过时事件的改进版本进行销售(例如，参见 C++x11 的文档)。但是，它仍然是 Python(和其他语言)线程基础设施的一部分，所以请自行判断！

*Event* 是一个全局 *Boolean* ，除了像任何 Boolean 一样被*轮询*以获取真理之外，它还拥有*持有*感兴趣的线程的能力(直到真)。当“复位”(假)时，它保持所有*等待*的线程的执行。当第三方给*发信号*(设置为真)时，事件让他们离开(等待的调用*将*返回给他们每个人)。

在下面的例子中，使用两个事件(一个控制发送，另一个控制接收)限定了临界区，并且消除了对锁的需要。

*这里是重构后的原型，后面是 notes(输出保持不变):*

*备注:*

1.  这个同步原语也是从线程库中导入的
2.  接收和发送事件是全局变量(默认情况下为 false)。
3.  在生成器初始化时启用发送，以启用第一条消息。
4.  在每个周期的开始，生产者等待发送许可。没有锁。临界区由事件界定(在等待和清除之间)。(待办事项:指定超时。等待失败时:错误)。
5.  指示停止，生产者中和事件并退出循环。
6.  在每个周期结束时，生产者允许接收并保持发送。
7.  速度由生产者决定，在每个周期结束时等待 2 秒钟。(消费者同时被事件持有)。
8.  在每个周期的开始，消费者等待接收许可。没有锁。临界区由事件界定(在等待和清除之间)。(待办事项:指定超时。等待失败时:错误)。
9.  在每个周期结束时，消费者允许发送并保持接收。
10.  主程序不受同步方法改变的影响。

## 6.封装消息

在本课的开始，我郑重声明“数据是无生命的物质”，不会被过程所欺负，并且(因此)同步原语的唯一目的是界定操纵它(数据)的代码的关键部分。这确实代表了当前的技术水平。然而，使用*面向对象的*编程，我们可以通过将同步原语与数据封装在一起并添加用于激活它们的*方法*，将*的同步责任分配给数据*。结果是消息*对象*必须是*发送的消息*(以面向对象的方式)，对其自身的完整性负责。

下面的例子重构了第 5 节中的例子，用消息封装了两个*事件*(以前是*全局*):

*备注:*

1.  整个*同步消息*功能现在是一个类
2.  类同步消息封装了以前的全局消息相关人员。
3.  阻塞*获取*消息。请求者(显然是生产者)必须等待*发送*确认。(待办事项:超时)。
4.  阻塞*设置*消息。请求者(显然是消费者)必须等待“接收”确认。(待办事项:超时)。
5.  其他发送/接收事件功能被赋予了具有应用程序重要名称的方法。
6.  使用消息初始化生成器。(它不再是全球性的)。
7.  生成器将消息重置为发送状态。
8.  生产者设置消息，阻止(直到被消费者释放)。
9.  这个请求中隐含的等待是多余的，但是，在当前的上下文中，我们可以确定事件无论如何都是有信号的。
10.  生成器将消息设置为启用发送和禁用接收。
11.  使用消息初始化使用者。
12.  消费者得到消息，阻塞(直到被生产者释放)。这个习语(获得承诺的值，可能被承诺者阻止)是*未来*设计模式的特征。
13.  消费者将消息设置为禁用接收和启用发送。
14.  过去是全局的消息，现在对于主程序来说是局部的，并被传递给生产者和消费者。

下面的例子重构了第 4 节中的例子，用消息封装了*条件*(以前是*全局*)，并为其提供接口:

*备注:*

1.  同步消息实现了*上下文管理器*接口，以模拟条件行为。
2.  同步消息实现了有用的条件接口，委托给内部的条件。
3.  该消息用于界定生产者的临界区。消息中请求同步。
4.  这种解决方案不考虑消息的信息隐藏，也不支持阻塞 get 和 set。
5.  该消息用于界定消费者的关键部分。消息中请求同步。

## 7.信息排队

到目前为止，所有的同步原语解决方案(锁、条件变量和事件)都以各种方式专门用于*保护对生产者和消费者双方都可用的单一资源*(在我们的例子中是一个全局字符串对象)的访问。尽管程序发出了一系列的信息，但在程序内部，只有一条信息会在每一轮被覆盖(巧妙地避免了竞争情况)。

另一个策略是*首先在内部序列化*输出。在这里，*没有任何东西被覆盖！*在每一轮中，在内部创建一个新消息，并在*中排队。*生产者不用担心消息的完整性(除了*用消费者消化不了的消息淹没*队列)。消费者有责任*按时从队列中提取*未决消息。

虽然序列化(生产者和消费者之间的通信)更耗费资源，内部也更复杂，但它简化了程序员的工作(没有关键部分需要处理)并减少了竞争条件。(当然是处理得当的话)。

有两种序列化策略:

1.  使用队列将消费者与生产者分开。生产者以自己的速度将消息写入队列。消费者以自己的速度从队列中提取消息。生产者不知道消息是否被消费(它不等待来自另一端的 ack)。这种体系结构适合于向多个消费者多播消息。例如，当您的 web 浏览器从远程网站服务器获得一个页面时，服务器(生产者)根本不关心您(一个随机的消费者)对该页面做了什么，以及它一开始是否是完整的。这里唯一关心的是验证队列不会溢出。(消息传递基础设施倾向于限制队列的大小！).此外，队列必须满足外部强加的吞吐量要求(如果有)。
2.  将队列用作某种“带备份的事件”。在推送下一条消息之前，生产者确实等待来自消费者的 ack。虽然这也可以简单地通过附加的“ack”消息(以及可能的专用队列)来实现，但是 Python 队列(与 UNIX 队列一致)可选地提供类似事件的功能:您可以加入它(即等待来自发送方的信号)并向它发送信号(释放接收方，就像我们在下面的例子中所做的那样)。这种架构支持多个生产者(以及一个或多个消费者)。多个生产者可以将他们的消息发送给同一个消费者，而不会阻塞它。各种消息在消费者的队列中累积，消费者有责任根据需要依次确认每个生产者。这种架构在实时软件中很常见。

*这里是重构后的原型，后面是 notes(输出保持不变):*

*备注:*

1.  消息队列功能位于单独的库中(不是线程库的一部分)。
2.  生产者接收要写入的队列(即消费者的队列)。
3.  生产者将当前消息发送到其输出队列。
4.  生产者等待(消费者的信号)。
5.  消费者打开一个队列(用于输入)。
6.  消费者从队列中提取待处理的消息(如果有的话，在消息到达之前一直被阻塞。(待办事项:指定超时并检查错误)。
7.  在退出之前，消费者使用队列来释放生产者。
8.  消息被读取和打印后，消费者使用队列来释放生产者。
9.  主程序首先初始化消费者，然后使用消费者的消息队列初始化生产者。这种严格的分工保证了*信息隐藏的措施！*(主程序不知道消息是如何传递的，生产者也不知道消息发送到哪里)。

*附加消息队列功能:*

*   查询队列状态:当前队列中的消息数量/为空，已满。
*   阻塞 put(满时)，可选超时。
*   非阻塞 get，带有可选超时。
*   *优先级队列*，其中消息按优先级顺序(分配的编号)检索。
*   *LIFO 队列*(即*堆栈*)，其中消息以相反的顺序检索。

## 8.什么时候用？

正如本系列介绍中所讨论的，在*非阻塞输入存在的情况下，邀请*并行设计*。*我们有一个函数“A”产生输出，另一个函数“B”消耗这个输入(可能是同一个对象。不同之处在于视角)，但是——由于各种原因——这两者在程序上可能不是有序的(*)，例如(1)另一个函数“C”调用“A”然后“B”，(2)“A”在结尾调用“B”，(3)“B”在开始调用“A”，等等。因此，设计必须求助于一个*不连续的过程:*这两个功能看起来不相关，但是，由于它们仍然是*数据耦合的*，它们执行的*顺序*和它们之间的*数据传输*由更微妙的编程设备处理——专有(或标准，或第三方)通信*协议*。例如，这些功能可以在不同的线程上执行，由上面讨论的一些原语同步。*

*涉及非阻塞输入的设计问题的解决方案依赖于消费者的数量(竞争这个输入)、生产者的数量(被消费者阻塞，如果有的话)、双方涉及的速率、服务质量(消息会丢失吗？秩序必须保持吗？)以及生产者和消费者义务的其他任务。*以下是一些简要的指导方针:**

*   *本课中的简单示例涉及(1)一个生产者和一个消费者,( 2)没有任何义务,( 3)转移率由生产者单独决定。这个简单的用例可以使用公共资源的单个实例，通过条件变量进行同步(如上面的示例 4)。可以添加 ack 来保护消费者免受过高的传输速率。*
*   *多个消费者(由一个生产者提供)可能仍然使用单一的全局资源，但是可能需要更紧密的同步。举几个常见的限制:(1)只要未被(所有消费者)完全消费，公共资源就必须持续存在，以及(2)消费者不得改变公共资源。默认的同步原语(条件、事件、空锁)可能仍然有效，因为它们是为支持多线程而构建的。*
*   *多个生产者(为一个消费者提供食物)需要序列化(例如消息队列)。虽然保持多个全局资源(和它们的锁)是可能的，但这将带来维护上的麻烦并限制可扩展性。最好是在从队列中检索下一条消息之后，立即将复杂性集中在调度逻辑中。*
*   *条件和事件是消费者阻止生产者的手段(在当前电流尚未被消耗时保持下一个输出)。如果传输速率要求生产者在消费者可以接受之前产生下一个输出(但消息绝不能丢失)，则应进行序列化(例如，通过消息队列)。*
*   *在*轮询*用例中，同步可以放松，其中生产者(例如，在专用硬件上)以高速率输出，而消费者以某个间隔对输出进行采样。在这种情况下，预先约定一些数据将会丢失。当输入被缓冲时，仍然可以观察到一些同步，例如通过用信号通知读取的持续时间(或者相反——写入的持续时间),以防止消费者得到不一致的(部分重写的)数据。这种架构在实时软件中很常见。*

## *9.发布/订阅*

*上面讨论的*消息队列*具体定义为*点对点*消息队列。尽管生产者并没有直接向消费者发送消息(上帝保佑！)，它会将它们发送到一个代表、属于(很可能是由)消费者的队列中。两个消费者邀请两个消息队列。如果两个消费者使用同一个队列进行输入(这是合法的)，那么其中一个将会挨饿(它将会了解到一条消息，但是，当它到达队列时，这条消息可能已经被它的对等方取走了)。*

*对于简单的点对点消息队列之外的下一个逻辑步骤，我们超越了标准 Python 产品，进入了“发布/订阅”的世界。*发布/订阅*消息传递基础设施，例如 *RabbitMQ* 、 *Kafka* ，长期以来一直以其*日志*功能而闻名，但最近已经成为*服务*(或微服务)应用框架中的关键组件，甚至在*嵌入式和硬实时应用中也是如此，*代表了一种成熟的技术(显然是对实际需求的响应！)*

*发布/订阅基础设施将消息队列的概念发挥到了极致，它将消费者和生产者永远分离开来。生产者尽可能多地发布一个命名的主题，(实际上是一个消息队列，但是对任何知道其名称的人开放)。消费者注册感兴趣的主题(按名称)，并在新消息到达时得到通知。因为同步(以及成熟平台中的低级通信和协议)由消息传递平台负责，所以系统中的消费者被简化为事件处理程序—服务(或分布式环境中的微服务)。生产者也被简化了(通过底层自动化)，但程度较低。*

*此外，任何人(有权访问系统)都可以从该主题*数据库*中查询和检索。消息是否仍然可用(一旦所有注册的消费者已经查看了它们)是可配置的，并且可以用于诸如日志记录、内存数据库、测试和模拟之类的目的(例如，通过从外部注入消息，实际激活适当的消费者和生产者，以便重新运行记录的或想象的用例，并且记录结果用于验证，例如，通过自动工具)。*

*虽然 Python 没有对发布/订阅的内置支持，但是有许多第三方产品。在这个例子中，我们使用 *pypubsub* (用 *pip 等安装。*)，相当成熟的软件。它仅限于进程范围，并具有严格而简单的同步协议(如果您能接受的话)，可用于将应用程序简化为简单的事件驱动设计，并具有可扩展性和可维护性的所有好处。*

*发布是通过发送一个*消息*到一个*主题*来完成的。(没有指定的*发布者——任何人都可以发布任何主题)。消费是通过*注册回调*完成的。(功能—消费不需要封装)。发布/订阅协议很简单*同步*。发送消息*阻塞发送方*并逐个调用所有注册的监听方*，阻塞，*处理消息。(pypubsub 不支持*异步*处理。你可以用显而易见的方式实现异步消费，通过减少你的监听器到中断服务例程，这些例程只是*通知*真正的消费者，可能复制消息对象——它们是*弱引用的—* 从那里获得，但是在它们自己的线程中。**

*在下面的例子中，消费者不再是一个线程(只是注册了一个回调)，但是生产者仍然是一个线程，以保持当前的逻辑。*

**这里是重构后的原型，后面是 notes(输出保持不变):**

**备注:**

1.  *从 *pubsub* 库导入。*
2.  *指示结束后，生产者*向“EnumeratedMessages”主题发布*一条结束消息，参数名为“message”。end 代码被扩展和澄清(从仅仅“[STOP]”到尊贵的“[END-ENUMERATED-MESSAGES]”，以使其在分布式的对所有人开放的环境中存活。*
3.  *循环工作完成后，生产者*向“EnumeratedMessages”主题发布*一个枚举消息，参数名为“message”。*
4.  *在这种设计中，消费者不需要成为线程。*
5.  *消费者注册一个对“EnumeratedMessages”主题的侦听器回调。顺便提一下，这创建了主题并定义了听者的签名。*
6.  *侦听器回调采用一个参数，称为“message”。*
7.  *侦听器使用单个消息(无事件循环),并且没有同步。*
8.  *或者，生成器不必是单独的线程。在这种情况下，调用 *start* 会阻塞主程序。但这不会有太大的效果。为了维持现在的逻辑，主程序应该先启动一个定时器线程(20 秒后停止生产者)。所以需要第二个线程，无论如何！此外，这样的设计很难使用多个生产者。*
9.  *主程序加入制作程序。(因为消费者已经不是一根线了)。*

**附加发布/订阅功能:**

1.  **pypubsub* 库支持多个生产者和多个消费者以及一个分层的主题数据库，所以它比上面介绍的要多得多。请查阅其文档以了解更多详细信息。*

## *10.套接字 I/O 作为同步原语*

*并行设计绝不局限于内置线程库提供的那半打原语。任何支持*阻塞*和*通知*功能的平台都允许(并且通常*会邀请*)并行设计，例如本课中介绍的。*

*例如，考虑使用套接字通过 TCP/IP 进行通信的生产者和消费者。在这个(相当简化的)例子中，使用*阻塞发送*和*接收*以明显的方式处理同步*

**备注:**

1.  *使用*插座*库*
2.  *使用 IP 地址初始化生成器。*
3.  *生产者在所提供的 IP 地址上为自己打开一个网络节点(“套接字”)。这是一个*服务器插座*(它不*连接*到外部世界——外部世界被邀请连接到它)。(待办事项:验证套接字确实已被授予。可能的错误:“端口已被使用”等。).*
4.  *套接字*异步监听*到这个地址*的连接请求。*(它在后台默默地为我们打开一个轮询网络的线程)。*
5.  *生产者响应第一个(也是唯一的)连接请求，*阻塞*，产生另一个套接字(用于连接)。(待办事项:指定超时，并决定失败时要做什么。可选地，首先检查连接请求是否未决)。*
6.  *生产者检索“就绪”消息，该消息持续正好 5 个字节，阻塞。(待办事项:指定超时。确认消息确实显示“就绪”)。*
7.  *当该停止时，生产者发送“停止”消息(在*字节*中)。末尾的额外空格确保了消费者，等待 7 个字节(不少于！)，确实心领神会。*
8.  *生产者通过套接字发送下一条消息(编码为字节)。(待办事项:使用返回的数字验证所有字节确实都已发送)。*
9.  *它的工作完成后，生产者关闭套接字(服务器和连接)。*
10.  *消费者打开一个*客户端套接字*，连接到生产者的 IP 地址(由应用程序提供)。(待办事项:指定超时并检查错误)。*
11.  *消费者发送“就绪”消息。(待办事项:验证五个字节确实已经发送)。*
12.  *消费者提取下一条消息，预期正好 8 个字节，阻塞。(待办事项:指定超时等。).*
13.  *工作完成后，消费者关闭(客户端)套接字。*
14.  *主程序用本地计算机的(虚构的)地址(“localhost”)端口 8899(希望它没有被使用)初始化生产者和消费者。除此之外，主程序逻辑保持不变。*

## *11.附加同步原语*

*Python 还支持以下线程级同步原语:*

1.  **旗语。*原始同步原语。允许预定义数量的线程进入，然后阻塞额外的请求，直到有一个被释放。不适用于我们的生产者/消费者示例。我们使用的简单的*锁*也被定义为“二进制”信号量(例如在 vxWorks 中)，因为它允许一个线程进入，然后阻塞第二个线程。*
2.  **屏障*。阻塞预定义数量的线程(单独注册),直到满足该数量。似乎不适用于我们的生产者/消费者示例。典型的应用是等待所有参与者完成准备，准备开始。例如，一个应用程序框架启动如此多的任务。由于任务之间的依赖性，所有任务在被允许开始它们的事件循环之前完成它们的所有准备(“结束-初始化”)是很重要的。例如，当队列在另一端还没有为输入开放时，为某个任务的输出开放队列是错误的。在这种情况下，所有任务都应该在 end-initialize 期间打开它们的输入队列。然后，在另一侧打开它们进行输出变得安全。这里有一个*屏障*是很方便的:给定任务数，它作为结束初始化和服务开始之间的屏障(在系统级)。*
3.  **“concurrent . futures”。*线程/进程*池*基础设施，主要由*async/await*设施使用(待讨论)。这个工具专门在线程(或进程)中启动一次性函数并收集它们的结果。这似乎不适用于我们的生产者/消费者的例子，在这个例子中，两个并行的任务永久地交换消息(并继续存在)。*

## *12.练习:尾部服务器*

*为了简单起见，在本课中，我们将设计的范围限制为一个生产者为一个消费者提供食物。这足以展示裸露的设施。幸运的是，扩展逻辑以考虑涉及*多样性*的用例的挑战并没有从根本上改变设计，但需要密切关注同步，并使协议防火。*具体来说:**

*   *一个生产者养活多个消费者。*
*   *一个消费者被多个生产者养活。*
*   *我的多个生产者养活了多个消费者。*

**Starter prototype:* 在上一课中，您被要求扩展文件监视器示例，以提供类似 UNIX 的尾部功能。使用文件名初始化尾部，并以固定的时间间隔继续打印附加到该文件的行(假设该文件仅在末端更新)。*

**这是教科书解决方案(没有同步):**

**挑战:*这种设计的特点是由应用程序启动并输出到控制台的单个 Tail 函数。将其扩展到一个 Tail 服务器，该服务器将多个 Tail(针对多个文件)的结果输出到控制台。应用程序动态请求要结尾的文件。尝试上面建议的同步工具。*

**设计亮点:**

*   *启动尾*线程:*由应用程序委托(同步)的尾服务器的职责。*
*   *打印变更消息(异步):尾部服务器的责任。(尾数只*通知！*)*
*   *为了*终止*尾部服务器及其线程(优雅地！)*

## **接下来呢？**

*在接下来的课程中，我们将考虑 Python 中多线程的替代并行解决方案:多处理、使用拉和推迭代器的协作处理以及基于分派的协作处理(*异步*调用)。*

1.  *[简介](/codex/parallel-programming-in-python-lesson-1-introduction-210e33d02ea6?source=friends_link&sk=5273e19224913fbd6a3b74f41871a754)*
2.  *[螺纹](/codex/parallel-programming-in-python-lesson-2-the-thread-b3986e215d4f?source=friends_link&sk=5ad6a9c99ce8947be53af4949ce6f086)*
3.  *同步原语(多线程)——*(你来了！)**
4.  *同步原语(多处理)*
5.  *协作处理—同步*
6.  *协作处理—异步*