<html>
<head>
<title>Leetcode 300: Longest Increasing Subsequence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Leetcode 300:最长递增子序列</h1>
<blockquote>原文：<a href="https://medium.com/codex/leetcode-300-longest-increasing-subsequence-b5eaba41e407?source=collection_archive---------0-----------------------#2021-06-12">https://medium.com/codex/leetcode-300-longest-increasing-subsequence-b5eaba41e407?source=collection_archive---------0-----------------------#2021-06-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="fc8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定一个整数数组<code class="du jd je jf jg b">nums</code>，返回最长严格递增子序列的长度。</p><p id="d855" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">子序列</strong>是可以通过删除一些元素或不删除元素而不改变剩余元素的顺序从数组中导出的序列。例如，<code class="du jd je jf jg b">[3,6,2,7]</code>是数组<code class="du jd je jf jg b">[0,3,1,6,2,2,7]</code>的子序列</p><p id="97af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">举例:</strong></p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="bad2" class="jp jq hi jg b fi jr js l jt ju"><strong class="jg hj">Input:</strong> nums = [2, 1, 0, 3, 2, 3]<br/><strong class="jg hj">Output:</strong> 3<br/><strong class="jg hj">Explanation:</strong> The longest increasing subsequence is [1, 2, 3], therefore the length is 3</span><span id="5b05" class="jp jq hi jg b fi jv js l jt ju">Note that there can be multiple longest increasing subsequences of same length</span></pre></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="0dd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个练习递归和动态编程的好问题。我将展示如何使用这两种方法在Go中编写解决方案。</p><p id="d679" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">方法1:递归——强力方法</strong></p><p id="3628" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当面对一个复杂的问题时，想出一个强力的解决方案是一个很好的起点。这种方法有助于对问题有一个清楚的了解。一旦暴力解决方案被正确编码，人们就可以思考该解决方案暴露了什么样的模式，并相应地提出最佳解决方案。</p><p id="1a57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了用蛮力方法解决它，我可以用一个稍微不同的问题来表达原来的问题。如果我能找到从特定索引开始的最长递增子序列的长度会怎样？我可以用这些信息把原来的问题重新表述为—</p><blockquote class="kd ke kf"><p id="bae0" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">找出从每个索引开始的LIS长度，并处理这些结果，以得出原始问题所需的解决方案。</p></blockquote><p id="cb06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了从输入数组中的每个位置开始的LIS以及相应的长度。</p><figure class="jh ji jj jk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kk"><img src="../Images/b80000516475689d2a0ccee600c9db96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4tn4aGZreSwrVHGtYltggA.jpeg"/></div></div></figure><p id="81e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们获得了与每个索引相对应的LIS长度信息，我们就可以对它们进行处理，以找到最终结果，在本例中，就是找到所有这些LIS长度中的最大值。下面的代码片段说明了这一点。</p><figure class="jh ji jj jk fd kl"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="4c4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，问题变成了如何找出从特定索引开始的LIS长度。这可以用递归来简单地编码。使用递归时，必须仔细考虑会破坏递归的基本情况。也就是说，基本情况的解决方案是琐碎的，必须进行编码。这种情况下的基本情况是找到从输入的最后一个索引开始的序列的LIS长度。这个值就是1，不需要递归就可以返回。</p><figure class="jh ji jj jk fd kl"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="1dfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样。在程序中连接这两个代码片段应该是可行的。然而，这个解决方案会非常慢。这是因为我们一次又一次地解决同样的子问题，也就是说，我们在重复同样的工作。可以通过使用一种叫做动态编程(DP)的编程范式来改进这个解决方案。使用动态规划技术解决问题是非常令人满意的，如果我们遵循系统的方法，这并不困难。一般来说，在DP中有两种方法您会经常遇到。这些是—</p><ul class=""><li id="acc9" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">自顶向下的方法—这种技术缓存中间结果以避免重新计算</li><li id="98b6" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">自下而上的方法——这种技术以自下而上的方式构建最终解决方案(即首先解决较小的子问题，然后使用这些结果来计算较大的子问题的解决方案)</li></ul><p id="f31c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在看到这个问题的DP解决方案之前，让我们看一下方法2，它也是一种强力方法，但是解决它的方式几乎没有什么不同。</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="0fa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">方法2递归—强力方法</strong></p><p id="bafd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在方法1中，我们将原始问题表述如下:</p><blockquote class="kd ke kf"><p id="e757" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">找出从每个索引开始的LIS长度，并处理这些结果以得出所需的解决方案</p></blockquote><p id="843e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，我们也可以用下列术语来表达它:</p><blockquote class="kd ke kf"><p id="0de5" class="if ig kg ih b ii ij ik il im in io ip kh ir is it ki iv iw ix kj iz ja jb jc hb bi translated">找出在每个索引处结束的LIS长度，并处理这些结果以得出所需的解</p></blockquote><p id="64ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了输入中每个位置的LIS结尾的详细信息以及相应的长度。</p><figure class="jh ji jj jk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es li"><img src="../Images/2b007aca6091e105ad3e5e57bcfffac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQlka-luirRLM3a7Zv9BYw.jpeg"/></div></div></figure><p id="3d04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，我们可以很容易地编写顶层函数，如下所示。</p><figure class="jh ji jj jk fd kl"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="0d9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编写计算以特定索引结尾的LIS长度的函数也非常类似于方法1。这里的基本情况是检查结束索引是否为0，并跳出递归。它的代码显示在下面的要点。</p><figure class="jh ji jj jk fd kl"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="88bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与方法1相比，这个版本的程序在速度上没有什么不同。我这样做的原因是为了展示如何将这个想法应用到代码中。另外，我在方法3中通过使用动态编程改进了这个解决方案。</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="36f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">方法3动态规划自下而上求解</strong></p><p id="d6e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我前面提到的，DP有两种风格——自顶向下的方法和自底向上的方法。我将在这里展示如何使用自底向上的技术来解决这个问题。自底向上方法的思想很简单。我们先解决较小实例的问题，然后用这些结果来解决较大的子问题。我们使用一个表来存储子问题的结果。</p><p id="01a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一步是创建一个表(即一个数组)，并用容易解决的子问题初始化它。下面的代码片段就是这样做的。</p><figure class="jh ji jj jk fd kl"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="aadb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是计算所有不断增长的子问题的LIS长度。</p><figure class="jh ji jj jk fd kl"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="cc67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了计算每个<code class="du jd je jf jg b">dp[i]</code>，我将使用先前计算的较小子问题的结果。这些值可从<code class="du jd je jf jg b">dp[0 to i-1]</code>的表格中获得。</p><p id="26c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了了解如何做到这一点，让我们假设我已经计算了。LIS结束于索引0、1、2、3、4，我需要计算结束于索引5的LIS。下图是细节。</p><figure class="jh ji jj jk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lj"><img src="../Images/03052daf0e49da60d120a51cedf2f319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nZDeVFXWjbdnSWNhBqfgkw.jpeg"/></div></div></figure><figure class="jh ji jj jk fd kl"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="762b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，代码中的内部循环是先前计算的结果被用来寻找当前子问题的解决方案的地方，这个子问题由索引<code class="du jd je jf jg b">i</code>标记。</p><p id="ae88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读。我希望你喜欢这篇文章。</p></div></div>    
</body>
</html>