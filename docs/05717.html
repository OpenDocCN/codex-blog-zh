<html>
<head>
<title>Big O Notation — Keeping it simple.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号——保持简单。</h1>
<blockquote>原文：<a href="https://medium.com/codex/big-o-notation-keeping-it-simple-8be5699fe9c?source=collection_archive---------4-----------------------#2022-03-24">https://medium.com/codex/big-o-notation-keeping-it-simple-8be5699fe9c?source=collection_archive---------4-----------------------#2022-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e09a665096d99bfd844f0b5fc2c041c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQCLiy7Kj739_4_MxhoNKA.jpeg"/></div></div></figure><p id="f5b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated">数据结构和算法的学习之旅总是从<em class="jx">大O符号</em>开始。那么真正的大O是什么，为什么它是一件大事？</p><p id="7491" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编写一个给定问题的解决方案并不难，难的是编写一个<strong class="is hj">可扩展的</strong>解决方案，当输入大小增加时<em class="jx">该解决方案工作良好。</em></p><p id="c3bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Big O帮助我们做到了这一点——通过<strong class="is hj"> <em class="jx">衡量其可扩展性</em> </strong>来告诉我们一个解决方案有多棒。大O并没有告诉我们一个解决方案需要多长时间，相反，它给了我们一个通过增加输入来增加操作的想法。</p><p id="bcc6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看各种常见的大O符号—</p><ol class=""><li id="4c1e" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">O(1) —最佳。</li><li id="52cd" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">O(log n) —更好。</li><li id="0dbd" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">好的。</li><li id="c2f0" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">O(n ) —不好。</li></ol><p id="9f6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有几个比如O(n！)这是可怕的<strong class="is hj"/>，我们很少遇到这种情况，因此让我们将它们排除在本文范围之外。</p><h1 id="a08d" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">O(1) —恒定时间。</h1><p id="11c8" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">在下面的代码中，操作的数量是恒定的——这意味着无论输入有多大，代码都会执行恒定数量的操作。如果数组包含5个元素，代码将执行一次，如果数组大小增加到50，000个元素，代码仍将只执行一次。这是O(1)的一个例子。</p><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><blockquote class="lv lw lx"><p id="329d" class="iq ir jx is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">这里要注意的一点是，如果在上面的函数中有3个操作，而不是只有1个，那么大的O将是O(3)。这意味着，不管输入大小如何，代码总是执行3个操作。</p></blockquote><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/c95e3321a15136acc097ae4a8cb54a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ILNBJW_v5JruchfsX09BA.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">上图显示，无论输入大小如何，操作次数<strong class="bd ko">保持不变</strong>。</figcaption></figure><h1 id="8c86" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">O(log n) —对数时间。</h1><p id="d6a0" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">当我们采用分而治之的解决方案时，复杂度为O(log n)。二分搜索法是O(log n)复杂度的一个很好的例子。</p><p id="10d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的二分搜索法代码中，我们反复将数组中可能包含我们要搜索的项目的部分分成两半，直到我们将可能的位置缩小到只有一个。</p><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b593bf700f5a91f9f0024d18dcd34b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VLt4j8OP76i565Gx8L0KTQ.jpeg"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">上图显示了操作是如何随着输入大小的增加而对数增长的。</figcaption></figure><h1 id="bc9f" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">O(n) —线性时间。</h1><p id="d70b" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">在下面的代码中，运算次数是<strong class="is hj">线性</strong>——也就是说，<em class="jx">运算会根据输入大小</em>线性增加<strong class="is hj"><em class="jx"/></strong><em class="jx">。如果数组包含5个元素，下面代码中的for循环将运行5次，如果数组大小增加到50，000个元素，循环将运行50，000次。</em></p><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/9f8bfb118a056911629870938ebfdcba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1pYzBwEL4bTF-uve2JCDQ.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">上图显示了操作如何随着输入大小的增加而线性增加。</figcaption></figure><h1 id="3e4a" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">O(n ) —二次时间。</h1><p id="8ad2" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">在下面的代码中，运算次数为<strong class="is hj">二次</strong>——也就是说，<em class="jx">运算会根据输入大小</em>将 <strong class="is hj"> <em class="jx">增加二次</em> </strong> <em class="jx">。代码中有两个循环。对于输入数组中的每一项，将执行两个For循环。因此，如果数组大小为2，总操作数将为4，如果数组大小为3，总操作数将为9。</em></p><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="lt lu l"/></div></figure><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/5340f4ae1e35fca92542c9e919e408da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f_TRiAyHcxu63UVupXPpAA.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">上图显示了操作如何随着输入大小的增加而二次增加。</figcaption></figure></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><p id="e540" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望你觉得这篇文章有用，请在评论中发表你的问题/反馈，我将很乐意回应。如果你喜欢这篇文章，你可以考虑在<a class="ae mp" rel="noopener" href="/@dwivedi.2512_6282">媒体</a>上关注我，并在<a class="ae mp" href="https://www.linkedin.com/in/abhishek-dwivedi-25a45b225/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>