<html>
<head>
<title>Cleaning Up Laravel Controllers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">清理Laravel控制器</h1>
<blockquote>原文：<a href="https://medium.com/codex/cleaning-up-laravel-controllers-a2934b7bf1c?source=collection_archive---------1-----------------------#2021-06-25">https://medium.com/codex/cleaning-up-laravel-controllers-a2934b7bf1c?source=collection_archive---------1-----------------------#2021-06-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5971a346715b5a91110e07d6139517d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zZNJV6927FosfK1C.png"/></div></div></figure><h1 id="ed28" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="7ff7" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">控制器在任何基于<a class="ae km" href="https://www.guru99.com/mvc-tutorial.html" rel="noopener ugc nofollow" target="_blank"> MVC </a>(模型视图控制器)的项目中扮演着巨大的角色。它们实际上是“粘合剂”，接受用户的请求，执行某种逻辑，然后返回响应。如果你曾经做过任何相当大的项目，你会注意到你会有很多控制器，它们会在你没有意识到的情况下很快变得混乱。在这篇文章中，我们将看看如何在<a class="ae km" href="https://laravel.com" rel="noopener ugc nofollow" target="_blank"> Laravel </a>中清理臃肿的控制器。</p><h1 id="4969" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">臃肿的控制器的问题</h1><p id="b24d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">臃肿的控制器会给开发人员带来几个问题。他们可以:</p><ol class=""><li id="fe90" class="kn ko hi jq b jr kp jv kq jz kr kd ks kh kt kl ku kv kw kx bi translated"><strong class="jq hj">使追踪特定的代码或功能变得困难。</strong>如果你想在一个臃肿的控制器中处理一段特定的代码，你可能需要花一些时间来追踪这个方法实际上在哪个控制器中。当使用逻辑上分离的干净控制器时，这要容易得多。</li><li id="a884" class="kn ko hi jq b jr ky jv kz jz la kd lb kh lc kl ku kv kw kx bi translated">使发现错误的准确位置变得困难。正如我们将在后面的代码示例中看到的，如果我们在一个地方处理授权、验证、业务逻辑和响应构建，可能很难准确定位错误。</li><li id="2a3e" class="kn ko hi jq b jr ky jv kz jz la kd lb kh lc kl ku kv kw kx bi translated">为更复杂的请求编写测试变得更加困难。有时为复杂的控制器方法编写测试会很困难，这些方法有很多行，并且做许多不同的事情。清理代码使测试变得更加容易。如果你有兴趣了解如何让你的Laravel应用程序更具可测试性<a class="ae km" href="https://ashallendesign.co.uk/blog/how-to-make-your-laravel-app-more-testable" rel="noopener ugc nofollow" target="_blank">，请查看这篇文章。</a></li></ol><h1 id="a5e8" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">臃肿的控制器</h1><p id="5810" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对于本文，我们将使用一个例子<code class="du ld le lf lg b">UserController</code>:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="db6b" class="lp ir hi lg b fi lq lr l ls lt">class UserController extends Controller<br/>{<br/>    public function store(Request $request): RedirectResponse<br/>    {<br/>        $this-&gt;authorize('create', User::class);</span><span id="c7a7" class="lp ir hi lg b fi lu lr l ls lt">        $request-&gt;validate([<br/>            'name'     =&gt; 'string|required|max:50',<br/>            'email'    =&gt; 'email|required|unique:users',<br/>            'password' =&gt; 'string|required|confirmed',<br/>        ]);</span><span id="25f7" class="lp ir hi lg b fi lu lr l ls lt">        $user = User::create([<br/>            'name'     =&gt; $request-&gt;name,<br/>            'email'    =&gt; $request-&gt;email,<br/>            'password' =&gt; $request-&gt;password,<br/>        ]);</span><span id="226d" class="lp ir hi lg b fi lu lr l ls lt">        $user-&gt;generateAvatar();<br/>        $this-&gt;dispatch(RegisterUserToNewsletter::class);</span><span id="c2d3" class="lp ir hi lg b fi lu lr l ls lt">        return redirect(route('users.index'));<br/>    }</span><span id="d826" class="lp ir hi lg b fi lu lr l ls lt">    public function unsubscribe(User $user): RedirectResponse<br/>    {<br/>        $user-&gt;unsubscribeFromNewsletter();</span><span id="0181" class="lp ir hi lg b fi lu lr l ls lt">        return redirect(route('users.index'));<br/>    }<br/>}</span></pre><p id="5f4c" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">为了让事情看起来简单明了，我没有在控制器中包含<code class="du ld le lf lg b">index()</code>、<code class="du ld le lf lg b">create()</code>、<code class="du ld le lf lg b">edit()</code>、<code class="du ld le lf lg b">update()</code>和<code class="du ld le lf lg b">delete()</code>方法。但是我们将假设它们在那里，并且我们也使用下面的技术来清理那些方法。在本文的大部分时间里，我们将专注于优化<code class="du ld le lf lg b">store()</code>方法。</p><h1 id="4f35" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">1.将验证和授权提升到表单请求</h1><p id="f63b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们可以对控制器做的第一件事是将任何验证和授权从控制器中取出，放入一个<a class="ae km" href="https://laravel.com/docs/8.x/validation#form-request-validation" rel="noopener ugc nofollow" target="_blank">表单请求</a>类中。所以，让我们来看看如何为控制器的<code class="du ld le lf lg b">store()</code>方法做这件事。</p><p id="73f2" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">我们将使用下面的Artisan命令创建一个新的表单请求:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="7c86" class="lp ir hi lg b fi lq lr l ls lt">php artisan make:request StoreUserRequest</span></pre><p id="fd9f" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">上面的命令将创建一个新的<code class="du ld le lf lg b">app/Http/Requests/StoreUserRequest.php</code>类，如下所示:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="0e83" class="lp ir hi lg b fi lq lr l ls lt">class StoreUserRequest extends FormRequest<br/>{<br/>    /**<br/>     * Determine if the user is authorized to make this request.<br/>     *<br/>     * <a class="ae km" href="http://twitter.com/return" rel="noopener ugc nofollow" target="_blank">@return</a> bool<br/>     */<br/>    public function authorize()<br/>    {<br/>        return false;<br/>    }</span><span id="66c6" class="lp ir hi lg b fi lu lr l ls lt">    /**<br/>     * Get the validation rules that apply to the request.<br/>     *<br/>     * <a class="ae km" href="http://twitter.com/return" rel="noopener ugc nofollow" target="_blank">@return</a> array<br/>     */<br/>    public function rules()<br/>    {<br/>        return [<br/>            //<br/>        ];<br/>    }<br/>}</span></pre><p id="dac7" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">我们可以使用<code class="du ld le lf lg b">authorize()</code>方法来决定是否允许用户执行请求。如果可以，该方法应该返回<code class="du ld le lf lg b">true</code>，如果不能，应该返回<code class="du ld le lf lg b">false</code>。我们还可以使用<code class="du ld le lf lg b">rules()</code>方法来指定应该在请求体上运行的任何验证规则。在我们运行控制器方法中的任何代码之前，这两个方法都会自动运行，而不需要我们手动调用它们中的任何一个。</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="ef0e" class="lp ir hi lg b fi lq lr l ls lt">class StoreUserRequest extends FormRequest<br/>{<br/>    /**<br/>     * Determine if the user is authorized to make this request.<br/>     *<br/>     * <a class="ae km" href="http://twitter.com/return" rel="noopener ugc nofollow" target="_blank">@return</a> bool<br/>     */<br/>    public function authorize(): bool<br/>    {<br/>        return Gate::allows('create', User::class);<br/>    }</span><span id="4d11" class="lp ir hi lg b fi lu lr l ls lt">    /**<br/>     * Get the validation rules that apply to the request.<br/>     *<br/>     * <a class="ae km" href="http://twitter.com/return" rel="noopener ugc nofollow" target="_blank">@return</a> array<br/>     */<br/>    public function rules(): array<br/>    {<br/>        return [<br/>            'name'     =&gt; 'string|required|max:50',<br/>            'email'    =&gt; 'email|required|unique:users',<br/>            'password' =&gt; 'string|required|confirmed',<br/>        ];<br/>    }<br/>}</span></pre><p id="e7d3" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">我们的控制器现在看起来也应该像这样:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="a417" class="lp ir hi lg b fi lq lr l ls lt">class UserController extends Controller<br/>{<br/>    public function store(StoreUserRequest $request): RedirectResponse<br/>    {<br/>        $user = User::create([<br/>            'name'     =&gt; $request-&gt;name,<br/>            'email'    =&gt; $request-&gt;email,<br/>            'password' =&gt; $request-&gt;password,<br/>        ]);</span><span id="1837" class="lp ir hi lg b fi lu lr l ls lt">        $user-&gt;generateAvatar();<br/>        $this-&gt;dispatch(RegisterUserToNewsletter::class);</span><span id="cee1" class="lp ir hi lg b fi lu lr l ls lt">        return redirect(route('users.index'));<br/>    }</span><span id="baaa" class="lp ir hi lg b fi lu lr l ls lt">    public function unsubscribe(User $user): RedirectResponse<br/>    {<br/>        $user-&gt;unsubscribeFromNewsletter();</span><span id="98ac" class="lp ir hi lg b fi lu lr l ls lt">        return redirect(route('users.index'));<br/>    }<br/>}</span></pre><p id="2ec2" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated"><strong class="jq hj">注意</strong>:为了自动工作，你需要确保你的控制器正在使用<code class="du ld le lf lg b">\Illuminate\Foundation\Auth\Access\AuthorizesRequests</code>和<code class="du ld le lf lg b">\Illuminate\Foundation\Validation\ValidatesRequests</code>特征。这些自动包含在Laravel为您提供的全新安装的控制器中。因此，如果您正在扩展控制器，您就可以开始了。如果没有，请确保将这些特征包含到您的控制器中。</p><h1 id="50fe" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">2.将通用逻辑移动到动作或服务中</h1><p id="f224" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们可以采取的清理<code class="du ld le lf lg b">store()</code>方法的另一个步骤是将我们的“业务逻辑”转移到一个单独的动作或服务类中。</p><p id="d30c" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">在这个特定的用例中，我们可以看到<code class="du ld le lf lg b">store()</code>方法的主要功能是创建一个用户，生成他们的头像，然后分派一个队列作业，将用户注册到时事通讯中。在我个人看来，一个动作比一个服务更适合这个例子。我更喜欢用行动来完成只做特定事情的小任务。而对于可能长达数百行并执行多项任务的大量代码，它更适合于服务。</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="3502" class="lp ir hi lg b fi lq lr l ls lt">class StoreUserAction<br/>{<br/>    public function execute(Request $request): void<br/>    {<br/>        $user = User::create([<br/>            'name'     =&gt; $request-&gt;name,<br/>            'email'    =&gt; $request-&gt;email,<br/>            'password' =&gt; $request-&gt;password,<br/>        ]);</span><span id="469b" class="lp ir hi lg b fi lu lr l ls lt">        $user-&gt;generateAvatar();<br/>        $this-&gt;dispatch(RegisterUserToNewsletter::class);<br/>    }<br/>}</span></pre><p id="8439" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">现在我们可以更新我们的控制器来使用动作:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="ed35" class="lp ir hi lg b fi lq lr l ls lt">class UserController extends Controller<br/>{<br/>    public function store(StoreUserRequest $request, StoreUserAction $storeUserAction): RedirectResponse<br/>    {<br/>        $storeUserAction-&gt;execute($request);</span><span id="c678" class="lp ir hi lg b fi lu lr l ls lt">        return redirect(route('users.index'));<br/>    }</span><span id="72f0" class="lp ir hi lg b fi lu lr l ls lt">    public function unsubscribe(User $user): RedirectResponse<br/>    {<br/>        $user-&gt;unsubscribeFromNewsletter();</span><span id="e175" class="lp ir hi lg b fi lu lr l ls lt">        return redirect(route('users.index'));<br/>    }<br/>}</span></pre><p id="e43a" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">正如您所看到的，我们现在已经能够将业务逻辑从控制器方法中提升到操作中。这很有用，因为正如我之前提到的，控制器本质上是我们请求和响应的“粘合剂”。所以，我们通过保持代码逻辑上的分离，减少了理解一个方法做什么的认知负荷。例如，如果我们想要检查授权或验证，我们知道要检查表单请求。如果我们想检查对请求数据做了什么，我们可以检查操作。</p><p id="dde0" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">将代码抽象成这些独立的类的另一个巨大好处是，它可以使测试变得更加容易和快速。我在我过去的文章<a class="ae km" href="https://ashallendesign.co.uk/blog/how-to-make-your-laravel-app-more-testable" rel="noopener ugc nofollow" target="_blank">中简单地谈到了这一点，如何让你的Laravel应用程序更具可测试性</a>；所以，如果你还没有读过，我强烈建议你读一读。</p><h1 id="3e5a" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">将dto与操作一起使用</h1><p id="74fb" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">将业务逻辑提取到服务和类中的另一个好处是，您现在可以在不同的地方使用该逻辑，而无需复制代码。例如，假设我们有一个处理传统web请求的<code class="du ld le lf lg b">UserController</code>和一个处理API请求的<code class="du ld le lf lg b">Api\UserController</code>。为了便于讨论，我们可以假设这些控制器的<code class="du ld le lf lg b">store()</code>方法的一般结构是相同的。但是，如果我们的API要求我们不使用<code class="du ld le lf lg b">email</code>字段，而是使用<code class="du ld le lf lg b">email_address</code>字段，我们该怎么办？我们不能将我们的请求对象传递给<code class="du ld le lf lg b">StoreUserAction</code>类，因为它期望一个具有<code class="du ld le lf lg b">email</code>字段的请求对象。</p><p id="591c" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">为了解决这个问题，我们可以使用<a class="ae km" href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="noopener ugc nofollow" target="_blank">dto</a>(数据传输对象)。这是一种非常有用的解耦数据的方法，可以在系统代码中传递数据，而不会与任何东西(在本例中是请求)紧密耦合。要将dto添加到我们的项目中，我们将使用Spatie的<code class="du ld le lf lg b">spatie/data-transfer-object</code> <a class="ae km" href="https://github.com/spatie/data-transfer-object" rel="noopener ugc nofollow" target="_blank">包</a>，并使用以下Artisan命令安装它:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="b95e" class="lp ir hi lg b fi lq lr l ls lt">composer require spatie/data-transfer-object</span></pre><p id="a9a5" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">现在我们已经安装了这个包，让我们在我们的<code class="du ld le lf lg b">App</code>文件夹中创建一个新的<code class="du ld le lf lg b">DataTransferObjects</code>文件夹，并创建一个新的<code class="du ld le lf lg b">StoreUserDTO.php</code>类。然后，我们需要确保我们的d to扩展<code class="du ld le lf lg b">Spatie\DataTransferObject\DataTransferObject</code>。我们可以这样定义我们的三个字段:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="ee7e" class="lp ir hi lg b fi lq lr l ls lt">class StoreUserDTO extends DataTransferObject<br/>{<br/>    public string $name;<br/>    <br/>    public string $email;<br/> <br/>    public string $password;<br/>}</span></pre><p id="305b" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">现在我们已经完成了，我们可以在前面的<code class="du ld le lf lg b">StoreUserRequest</code>中添加一个新方法来创建并返回一个<code class="du ld le lf lg b">StoreUserDTO</code>类，如下所示:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="b35a" class="lp ir hi lg b fi lq lr l ls lt">class StoreUserRequest extends FormRequest<br/>{<br/>    /**<br/>     * Determine if the user is authorized to make this request.<br/>     *<br/>     * <a class="ae km" href="http://twitter.com/return" rel="noopener ugc nofollow" target="_blank">@return</a> bool<br/>     */<br/>    public function authorize(): bool<br/>    {<br/>        return Gate::allows('create', User::class);<br/>    }</span><span id="eba2" class="lp ir hi lg b fi lu lr l ls lt">    /**<br/>     * Get the validation rules that apply to the request.<br/>     *<br/>     * <a class="ae km" href="http://twitter.com/return" rel="noopener ugc nofollow" target="_blank">@return</a> array<br/>     */<br/>    public function rules(): array<br/>    {<br/>        return [<br/>            'name'     =&gt; 'string|required|max:50',<br/>            'email'    =&gt; 'email|required|unique:users',<br/>            'password' =&gt; 'string|required|confirmed',<br/>        ];<br/>    }<br/>  <br/>    /**<br/>     * Build and return a DTO.<br/>     *<br/>     * <a class="ae km" href="http://twitter.com/return" rel="noopener ugc nofollow" target="_blank">@return</a> StoreUserDTO<br/>     */<br/>    public function toDTO(): StoreUserDTO<br/>    {<br/>        return new StoreUserDTO(<br/>            name: $this-&gt;name,<br/>            email: $this-&gt;email,<br/>            password: $this-&gt;password,<br/>        );<br/>    } <br/>}</span></pre><p id="a09e" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">我们现在可以更新控制器，将DTO传递给动作类:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="0eaf" class="lp ir hi lg b fi lq lr l ls lt">class UserController extends Controller<br/>{<br/>    public function store(StoreUserRequest $request, StoreUserAction $storeUserAction): RedirectResponse<br/>    {<br/>        $storeUserAction-&gt;execute($request-&gt;toDTO());</span><span id="2d3e" class="lp ir hi lg b fi lu lr l ls lt">        return redirect(route('users.index'));<br/>    }</span><span id="afab" class="lp ir hi lg b fi lu lr l ls lt">    public function unsubscribe(User $user): RedirectResponse<br/>    {<br/>        $user-&gt;unsubscribeFromNewsletter();</span><span id="e65f" class="lp ir hi lg b fi lu lr l ls lt">        return redirect(route('users.index'));<br/>    }<br/>}</span></pre><p id="265a" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">最后，我们需要更新动作的方法，以接受d to作为参数，而不是请求对象:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="8dd7" class="lp ir hi lg b fi lq lr l ls lt">class StoreUserAction<br/>{<br/>    public function execute(StoreUserDTO $storeUserDTO): void<br/>    {<br/>        $user = User::create([<br/>            'name'     =&gt; $storeUserDTO-&gt;name,<br/>            'email'    =&gt; $storeUserDTO-&gt;email,<br/>            'password' =&gt; $storeUserDTO-&gt;password,<br/>        ]);</span><span id="9a45" class="lp ir hi lg b fi lu lr l ls lt">        $user-&gt;generateAvatar();<br/>        $this-&gt;dispatch(RegisterUserToNewsletter::class);<br/>    }<br/>}</span></pre><p id="2733" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">作为完成所有这些工作的结果，我们现在已经将我们的操作与请求对象完全分离了。这意味着我们可以在整个系统的多个地方重用这个动作，而不必绑定到特定的请求结构。我们现在还能够在CLI环境或不依赖于web请求的队列作业中使用这种方法。例如，如果我们的应用程序具有从CSV文件导入用户的功能，我们将能够从CSV数据构建dto并将其传递给操作。</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="3a81" class="lp ir hi lg b fi lq lr l ls lt">class StoreUserAPIRequest extends FormRequest<br/>{<br/>    /**<br/>     * Determine if the user is authorized to make this request.<br/>     *<br/>     * <a class="ae km" href="http://twitter.com/return" rel="noopener ugc nofollow" target="_blank">@return</a> bool<br/>     */<br/>    public function authorize(): bool<br/>    {<br/>        return Gate::allows('create', User::class);<br/>    }</span><span id="e867" class="lp ir hi lg b fi lu lr l ls lt">    /**<br/>     * Get the validation rules that apply to the request.<br/>     *<br/>     * <a class="ae km" href="http://twitter.com/return" rel="noopener ugc nofollow" target="_blank">@return</a> array<br/>     */<br/>    public function rules(): array<br/>    {<br/>        return [<br/>            'name'          =&gt; 'string|required|max:50',<br/>            'email_address' =&gt; 'email|required|unique:users',<br/>            'password'      =&gt; 'string|required|confirmed',<br/>        ];<br/>    }<br/>  <br/>    /**<br/>     * Build and return a DTO.<br/>     *<br/>     * <a class="ae km" href="http://twitter.com/return" rel="noopener ugc nofollow" target="_blank">@return</a> StoreUserDTO<br/>     */<br/>    public function toDTO(): StoreUserDTO<br/>    {<br/>        return new StoreUserDTO(<br/>            name: $this-&gt;name,<br/>            email: $this-&gt;email_address,<br/>            password: $this-&gt;password,<br/>        );<br/>    } <br/>}</span></pre><h1 id="420d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">3.使用资源或单一用途控制器</h1><p id="82ac" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">保持控制器干净的一个好方法是确保它们要么是"<a class="ae km" href="https://laravel.com/docs/8.x/controllers#resource-controllers" rel="noopener ugc nofollow" target="_blank">资源控制器</a>要么是"<a class="ae km" href="https://laravel.com/docs/8.x/controllers#single-action-controllers" rel="noopener ugc nofollow" target="_blank">单用途控制器</a>"。在我们进一步尝试更新我们的示例控制器之前，让我们看看这两个术语的含义。</p><p id="fc77" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">资源控制器是基于特定资源提供功能的控制器。因此，在我们的例子中，我们的资源是<code class="du ld le lf lg b">User</code>模型，我们希望能够在这个模型上执行所有的<a class="ae km" href="https://www.codecademy.com/articles/what-is-crud" rel="noopener ugc nofollow" target="_blank"> CRUD </a>(创建、更新、更新、删除)操作。一个资源控制器通常包含<code class="du ld le lf lg b">index()</code>、<code class="du ld le lf lg b">create()</code>、<code class="du ld le lf lg b">store()</code>、<code class="du ld le lf lg b">show()</code>、<code class="du ld le lf lg b">edit()</code>、<code class="du ld le lf lg b">update()</code>和<code class="du ld le lf lg b">destroy()</code>方法。它不一定要包括所有这些方法，但是它不会有任何不在这个列表中的方法。通过使用这些类型的控制器，我们可以使我们的路由RESTful。关于REST和RESTful路由的更多信息，<a class="ae km" href="https://www.codecademy.com/articles/what-is-rest" rel="noopener ugc nofollow" target="_blank">点击这里查看本文</a>。</p><p id="1075" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">单一用途控制器是只有一个公共<code class="du ld le lf lg b">__invoke()</code>方法的控制器。如果你有一个不适合RESTful方法的控制器，这些真的很有用。</p><p id="63b4" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">因此，让我们使用以下Artisan命令创建一个新的控制器:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="2f9e" class="lp ir hi lg b fi lq lr l ls lt">php artisan make:controller UnsubscribeUserController -i</span></pre><p id="00dd" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">注意我们是如何将<code class="du ld le lf lg b">-i</code>传递给命令的，这样新的控制器将是一个可调用的、单一用途的控制器。我们现在应该有一个类似这样的控制器:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="d7f9" class="lp ir hi lg b fi lq lr l ls lt">class UnsubscribeUserController extends Controller<br/>{<br/>    public function __invoke(Request $request)<br/>    {<br/>        //<br/>    }<br/>}</span></pre><p id="25ff" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">我们现在可以移动我们方法的代码，并从我们的旧控制器中删除<code class="du ld le lf lg b">unsubscribe</code>方法:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="c21d" class="lp ir hi lg b fi lq lr l ls lt">class UnsubscribeUserController extends Controller<br/>{<br/>    public function __invoke(Request $request): RedirectResponse<br/>    {<br/>        $user-&gt;unsubscribeFromNewsletter();</span><span id="f586" class="lp ir hi lg b fi lu lr l ls lt">        return redirect(route('users.index'));<br/>    }<br/>}</span></pre><h1 id="f20c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="5e37" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">希望这篇文章能让你深入了解在Laravel项目中清理控制器的不同方法。请记住，虽然我在这里使用的技术只是我个人的意见。我确信还有其他开发者会使用完全不同的方法来构建他们的控制器。最重要的部分是保持一致，使用适合你(和你的团队)工作流程的方法。</p><p id="1345" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">我很想在评论中听到你使用什么类型的技术来编写干净的控制器。</p><p id="e732" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">如果你也觉得这篇文章有用，请随意<a class="ae km" href="https://ashallendesign.co.uk/blog" rel="noopener ugc nofollow" target="_blank">注册我的时事通讯</a>，这样每当我发布类似这篇文章的新帖子时，你都能得到通知。</p><p id="76f8" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated">继续建造令人敬畏的东西！🚀</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><p id="e501" class="pw-post-body-paragraph jo jp hi jq b jr kp jt ju jv kq jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl hb bi translated"><em class="mf">原载于</em><a class="ae km" href="https://ashallendesign.co.uk/blog/cleaning-up-laravel-controllers" rel="noopener ugc nofollow" target="_blank"><em class="mf">https://ashallendesign.co.uk</em></a><em class="mf">。</em></p></div></div>    
</body>
</html>