<html>
<head>
<title>Object-Oriented Programming Concepts JAVA-Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象编程概念JAVA-第1部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/object-oriented-programming-concepts-43eed85b7ea7?source=collection_archive---------8-----------------------#2022-03-17">https://medium.com/codex/object-oriented-programming-concepts-43eed85b7ea7?source=collection_archive---------8-----------------------#2022-03-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="757c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是课？</h1><p id="d4b6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">类是创建对象的蓝图。例如，有两只狗，一只是黑色的勒布拉犬，另一只是金毛猎犬。两者都可以被认为是从单个蓝图狗创建的真实世界对象。</p><h1 id="bdab" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是对象？</h1><p id="7b5f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">编程中的对象类似于现实世界中的对象。对象具有以变量形式存储的状态和以方法形式与状态交互的行为。隐藏内部状态并通过对象方法执行所有交互被称为数据封装。借助对象构建代码的好处:</p><ul class=""><li id="5657" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">模块化→ 一个对象的源代码可以独立于其他对象的源代码来编写和维护。</li><li id="99b1" class="kb kc hi jf b jg kn jk ko jo kp js kq jw kr ka ki kj kk kl bi translated"><em class="km">信息隐藏</em> →通过只与一个对象的方法交互，它的内部实现细节对外界保持隐藏。</li><li id="f090" class="kb kc hi jf b jg kn jk ko jo kp js kq jw kr ka ki kj kk kl bi translated"><em class="km">代码重用</em> →如果一个对象已经存在，你可以在你的程序中使用那个对象。</li></ul><h1 id="0e59" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">JAVA中的访问说明符</h1><p id="f29c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">JAVA中有四种访问说明符，按照严格程度降序排列，它们是:</p><ol class=""><li id="8530" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ks kj kk kl bi translated"><strong class="jf hj"> <em class="km">私有:</em> </strong>声明为私有的方法和数据成员只能在类内部访问。</li><li id="beba" class="kb kc hi jf b jg kn jk ko jo kp js kq jw kr ka ks kj kk kl bi translated"><strong class="jf hj"> <em class="km">默认:</em> </strong>如果我们没有用我们的方法或数据变量指定任何访问说明符，它们被认为是默认的访问修饰符。只能在同一个包中访问默认成员。</li><li id="c3f6" class="kb kc hi jf b jg kn jk ko jo kp js kq jw kr ka ks kj kk kl bi translated"><strong class="jf hj"> <em class="km">受保护:</em> </strong>受保护的数据成员和方法只能在同一个包内访问，并且只能在使用受保护的成员和方法继承该类的类内访问。</li><li id="6ea0" class="kb kc hi jf b jg kn jk ko jo kp js kq jw kr ka ks kj kk kl bi translated"><strong class="jf hj"> <em class="km"> public: </em> </strong>它们可以用在任何类的任何地方，任何包里。</li></ol><p id="1b05" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">按照惯例，我们应该使用最严格的访问修饰符来对我们的变量执行健全性检查，并控制谁可以修改它。</p><h1 id="e13a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak"> <em class="kw">本关键词</em> </strong></h1><p id="e427" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当我们使用同一个类的不同对象调用一个类的方法时，这些方法如何知道调用来自哪个对象呢？在后台，对对象的引用在内部传递给这个关键字中的函数。</p><h1 id="f8fa" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">最终关键字</h1><p id="56fa" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">final关键字类似于其他语言中的const关键字。这个关键字可以与类、方法和变量一起使用，为每一个提供不同的用例。</p><p id="e707" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated"><strong class="jf hj"> <em class="km">带变量的最终关键字</em> </strong></p><p id="f120" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">有三种类型的变量:局部变量、类变量和实例变量。让我们看看他们每个人的最终用例。</p><ul class=""><li id="4dd2" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated"><em class="km">局部变量→ </em>最终局部变量不能重新初始化；否则，编译器将抛出错误。</li><li id="2b81" class="kb kc hi jf b jg kn jk ko jo kp js kq jw kr ka ki kj kk kl bi translated"><em class="km">实例变量→ </em>最终的实例变量将不得不通过使用初始化器块、构造函数或在声明时进行初始化，然后它就不能被重新初始化了。如果第一次没有使用上述三种方法中的任何一种进行初始化，编译器将显示一个错误。对于该类的每个实例，都有一个最终的实例变量。</li><li id="3a57" class="kb kc hi jf b jg kn jk ko jo kp js kq jw kr ka ki kj kk kl bi translated"><em class="km">类变量→ </em>在类内部用关键字final和static声明的变量是一个类变量。它对于该类的每个实例都保持不变。它就像其他语言(如C++和C)中的全局变量。最终的类变量值对于每个类实例都保持不变，并且不能重新初始化。作为最后一个实例变量，需要在其声明或类内初始化器块中初始化。</li></ul><p id="3aad" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated"><strong class="jf hj"> <em class="km">如何在实例变量的情况下初始化初始化器块中的最终变量，在类变量的情况下初始化类初始化器块？</em> </strong></p><p id="e87f" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">这个概念可能很多读者都知道，但是由于它对我来说是一个新概念，我将为不了解它的读者提供一个示例代码。</p><p id="6d12" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">每当初始化类时，在调用构造函数之前，都会执行初始化块。</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es kx"><img src="../Images/4a0b5c04478fcb3843cf3c6d60696648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBARxRB-pz1pG5YkkzrA0g.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">初始化程序块</figcaption></figure><p id="3ceb" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kt jq jr js ku ju jv jw kv jy jz ka hb bi translated">类初始化器块是静态初始化器块。</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es ln"><img src="../Images/d6a832d167f1bcf26c12ebd2261e6bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N1RNlPD6Wc3dImzt84biBw.png"/></div></div><figcaption class="lj lk et er es ll lm bd b be z dx translated">类初始值设定项块</figcaption></figure></div></div>    
</body>
</html>