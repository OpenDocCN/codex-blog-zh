<html>
<head>
<title>Why Functional Programming?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么是函数式编程？</h1>
<blockquote>原文：<a href="https://medium.com/codex/why-functional-programming-e2edfd3658c7?source=collection_archive---------4-----------------------#2021-10-17">https://medium.com/codex/why-functional-programming-e2edfd3658c7?source=collection_archive---------4-----------------------#2021-10-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4c0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们先举一个例子:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">命令式风格</figcaption></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">声明式风格</figcaption></figure><p id="994f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有2个程序打印奇数到控制台。这些编程范例之间的区别在于我们如何读写代码的本质。这两个范例是命令式的和声明式的。</p><h2 id="8d1e" class="jo jp hi bd jq jr js jt ju jv jw jx jy iq jz ka kb iu kc kd ke iy kf kg kh ki bi translated">命令式:</h2><ul class=""><li id="794b" class="kj kk hi ih b ii kl im km iq kn iu ko iy kp jc kq kr ks kt bi translated">命令式代码是指主要关注<strong class="ih hj">如何按照指令/程序做某事</strong>的代码。由于这种风格的<strong class="ih hj">如何</strong>本质，我们的大脑需要在理解其目的之前在精神上执行代码。我们不能简单地看一眼代码就立刻理解特定的代码段在做什么。</li></ul><h2 id="7b62" class="jo jp hi bd jq jr js jt ju jv jw jx jy iq jz ka kb iu kc kd ke iy kf kg kh ki bi translated">声明性:</h2><ul class=""><li id="df3a" class="kj kk hi ih b ii kl im km iq kn iu ko iy kp jc kq kr ks kt bi translated">在声明式风格<strong class="ih hj">中</strong>如何<strong class="ih hj">不</strong>重要，重要的是<strong class="ih hj">是什么。</strong>以这种方式，程序根据<strong class="ih hj">表达式</strong>指定<strong class="ih hj">需要做什么</strong>。函数式编程本质上更具有声明性。</li></ul><p id="bb2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于哪些代码是声明性的或命令性的，没有确切的标记。这是相对的。如果你正在使用汇编语言进行低级编程，或者直接用0或1进行编码哈哈，然后如果你看到for循环或If语句，你会说哇，这是如此的声明性，然后如果你将其与一些函数式风格进行比较，相同的代码将开始看起来像命令式的。这完全是关于我们所处的抽象层次。</p><p id="51d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们编写一些代码，强迫人们在头脑中执行这些代码，这样他们就能理解这些代码，这些代码就更难理解、维护、改进和修复。因此，我们的目标是将读者的注意力从命令性转移到声明性，这样更容易理解。</p><h1 id="f2ce" class="ku jp hi bd jq kv kw kx ju ky kz la jy lb lc ld kb le lf lg ke lh li lj kh lk bi translated">什么是函数式编程？</h1><p id="59d2" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq ll is it iu lm iw ix iy ln ja jb jc hb bi translated">在函数式编程范例中，我们只使用纯函数来构造程序。为了使函数纯净，它应该是<strong class="ih hj">引用透明的。</strong>稍后我会解释<strong class="ih hj"> referential transparent </strong>是什么意思，但首先，我们要理解在函数式编程的精神下，函数的实际定义是什么。</p><h2 id="afeb" class="jo jp hi bd jq jr js jt ju jv jw jx jy iq jz ka kb iu kc kd ke iy kf kg kh ki bi translated">什么是纯函数？</h2><blockquote class="lp lq lr"><p id="c930" class="if ig lo ih b ii ij ik il im in io ip ls ir is it lt iv iw ix lu iz ja jb jc hb bi translated">按照函数式编程的精神，纯函数的正确定义是</p></blockquote><ul class=""><li id="3a50" class="kj kk hi ih b ii ij im in iq lv iu lw iy lx jc kq kr ks kt bi translated">一个函数不仅需要一些输入，还必须返回一些输出。下面的例子不符合函数的条件，因为它不返回任何输出，而是通过打印到控制台导致<strong class="ih hj">副作用</strong>。</li></ul><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><ul class=""><li id="6b13" class="kj kk hi ih b ii ij im in iq lv iu lw iy lx jc kq kr ks kt bi translated">如果函数名能够描述输入和输出的语义关系，那么函数<strong class="ih hj">会更好</strong>。</li></ul><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="13b9" class="jo jp hi lz b fi md me l mf mg">f(r) = π * r * r</span><span id="e361" class="jo jp hi lz b fi mh me l mf mg">In the above example, areaOfCircle perfectly describe the semantic relationship b/w function input and output.</span></pre><ul class=""><li id="8bf1" class="kj kk hi ih b ii ij im in iq lv iu lw iy lx jc kq kr ks kt bi translated">在函数中，输入和输出应该是直接的。函数调用应该独立于程序的其他部分来完成它的任务。它应该不会引起任何副作用。在下面的例子中，输入和输出都是间接的，在程序执行的过程中会发生变化。</li></ul><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><ul class=""><li id="1015" class="kj kk hi ih b ii ij im in iq lv iu lw iy lx jc kq kr ks kt bi translated">一个函数可以有间接输入，只要它们没有变异或改变。间接输入应该在整个项目过程中保持不变。这里pi永远不变，因此变量pi作为间接输入是有效的。</li></ul><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><ul class=""><li id="2a92" class="kj kk hi ih b ii ij im in iq lv iu lw iy lx jc kq kr ks kt bi translated">一个函数调用在被调用的任何时候都应该返回相同的输出</li></ul><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="780e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的代码示例中，areaOfCircle和areaOfCylinder函数调用都是引用透明的，因为我们可以用计算出的值替换相同输入的函数调用，而不会影响程序的任何其他部分。</p><p id="fbcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于引用的透明性，我们保证函数调用的输出是透明的，因此语言编译器可以利用这一点，记忆给定输入的函数调用的结果，并在任何地方替换它的值，而不是再次计算相同的值。就像求解内部表达式，然后把它的结果代入现在求解的更大的表达式，等等。</p><p id="c424" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也给了代码的读者一个优势，如果我们也可以做同样的代入，以便快速理解并得到结果，求解表达式。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="016c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的解释中，我也使用了“副作用”这个术语。那么它们是什么呢？</p><p id="6f39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">副作用只不过反映了变化或易变性。副作用的例子有:</p><ul class=""><li id="6ea4" class="kj kk hi ih b ii ij im in iq lv iu lw iy lx jc kq kr ks kt bi translated">任何类型的I/O操作</li><li id="c747" class="kj kk hi ih b ii mi im mj iq mk iu ml iy mm jc kq kr ks kt bi translated">网络通话</li><li id="10cd" class="kj kk hi ih b ii mi im mj iq mk iu ml iy mm jc kq kr ks kt bi translated">数据库写入</li><li id="9725" class="kj kk hi ih b ii mi im mj iq mk iu ml iy mm jc kq kr ks kt bi translated">时间戳生成</li><li id="45aa" class="kj kk hi ih b ii mi im mj iq mk iu ml iy mm jc kq kr ks kt bi translated">值可变性，例如，改变数据结构，即推入数组或从中弹出。</li></ul><blockquote class="lp lq lr"><p id="104a" class="if ig lo ih b ii ij ik il im in io ip ls ir is it lt iv iw ix lu iz ja jb jc hb bi translated">因此，为了防止值的可变性，我们创建了一个新的克隆，而不是修改它，使更改生效。你可能会想，这会导致CPU和内存开销，因为我们会一遍又一遍地复制相同的数据，这就是我们从不可变数据结构库中获得帮助的地方，例如<strong class="ih hj"> Immutable.js和Google Guava </strong>。他们从我们的业务逻辑上下文中抽象出这些东西，并以一种更具性能的方式来处理这些事情。<strong class="ih hj">在另一篇博客</strong>中有更多关于他们是如何做到的。</p></blockquote><p id="a992" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不可能有一个没有任何副作用的实用程序。所以问题不是要有0副作用，而是要把副作用降到最低，要么把它包含在局部范围内，要么把它提取出来放在大家都知道的地方。最小化这些副作用将使我们调试得更快，并且将帮助我们将来在哪里寻找错误，因为错误更可能发生在有副作用和状态突变发生的地方。</p><p id="1395" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这篇博客能帮助你理解函数式编程背后的原因。函数式编程还有更多的内容，例如局部应用、currying、函数组合。稍后将详细介绍。看阿雅！！。T3】</p></div></div>    
</body>
</html>