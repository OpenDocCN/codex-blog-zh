<html>
<head>
<title>Classloaders and Reflection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类加载器和反射</h1>
<blockquote>原文：<a href="https://medium.com/codex/classloaders-and-reflection-ba60a886528a?source=collection_archive---------2-----------------------#2022-01-26">https://medium.com/codex/classloaders-and-reflection-ba60a886528a?source=collection_archive---------2-----------------------#2022-01-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="9163" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">文章</h2><div class=""/><div class=""><h2 id="b3c8" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated"><em class="jg">摘自本杰明·埃文斯、杰森·克拉克和马丁·韦尔伯格的《扎实的Java开发者》第二版</em>  <em class="jg"/></h2></div><p id="9392" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">本文讨论Java中的类加载器和反射。</em></p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="c83c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在manning.com<a class="ae jh" href="https://www.manning.com/?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_evans2_wellgrounded_12_8_20" rel="noopener ugc nofollow" target="_blank"/>结账时，在折扣码框中输入<strong class="jk hs"> fccevans2 </strong>，即可享受37%的折扣。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="bd7d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">Java是一个具有动态运行时的基本面向对象的系统。其中一个方面是，Java的类型在运行时是活跃的，并且可以修改与运行的Java平台一起使用的类型系统——特别是通过添加新的类型。</p><p id="7ef3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这意味着组成Java程序的类型在运行时对未知类型的扩展是开放的(除非它们是<code class="du km kn ko kp b">final</code>或新的<code class="du km kn ko kp b">sealed</code>类之一)。</p><p id="fb97" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">类加载功能对用户是公开的——Java类和可以修改类型系统的加载器本身就是Java类型。在现代Java环境中，所有的类装入器都是模块化的——装入类总是在模块的上下文中完成。</p><p id="5476" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">该平台附带了许多典型的类加载器，这些类加载器用于在平台的启动和正常操作期间执行不同的工作。</p><p id="6457" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><code class="du km kn ko kp b">BootstrapClassLoader</code>又名原始类加载器——这是在启动虚拟机的早期实例化的——通常最好把它看作是虚拟机的一部分。它通常用于加载绝对基本系统-<code class="du km kn ko kp b">java.base</code>。</p><p id="b11e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><code class="du km kn ko kp b">PlatformClassLoader</code>–在最小系统被引导之后，平台类加载器加载应用程序所依赖的平台模块。这个类装入器是访问任何平台类的主要接口——不管它是由这个装入器还是由引导程序装入的。</p><p id="f469" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">应用程序类加载器——这是使用最广泛的类加载器。这将加载应用程序类，并完成大多数现代Java环境中的大部分工作。在模块化环境中，应用程序类加载器不再是<code class="du km kn ko kp b">URLClassLoader</code>的一个实例(就像在Java 8和之前的版本中一样)，而是一个内部类的实例。</p><p id="0783" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们通过向<code class="du km kn ko kp b">wgjd.discovery</code>模块添加一个名为<code class="du km kn ko kp b">DisplayClassloaders</code>的类来看看这些新的类加载器的运行情况:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="86f0" class="ky kz hi kp b fi la lb l lc ld">package wgjd.discovery;<br/>  <br/> import com.sun.tools.attach.VirtualMachineDescriptor;<br/>  <br/> public class DisplayClassloaders {<br/>     public static void main(String[] args) {<br/>         var clThis = DisplayClassloaders.class.getClassLoader();<br/>         System.out.println(clThis);<br/>         var clObj = Object.class.getClassLoader();<br/>         System.out.println(clObj);<br/>         var clAttach = VirtualMachineDescriptor.class.getClassLoader();<br/>         System.out.println(clAttach);<br/>     }<br/> }</span></pre><p id="db6d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这会产生以下输出:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="a67a" class="ky kz hi kp b fi la lb l lc ld">$ java --add-exports=jdk.internal.jvmstat/sun.jvmstat.monitor=wgjd.discovery --module-path=out -m wgjd.discovery/wgjd.discovery.DisplayClassloaders<br/> jdk.internal.loader.ClassLoaders$AppClassLoader@5fd0d5ae<br/> null<br/> <a class="ae jh" href="mailto:jdk.internal.loader.ClassLoaders$AppClassLoader@5fd0d5ae" rel="noopener ugc nofollow" target="_blank">jdk.internal.loader.ClassLoaders$AppClassLoader@5fd0d5ae</a></span></pre><p id="615e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">注意，<code class="du km kn ko kp b">Object</code>(在<code class="du km kn ko kp b">java.base</code>中)的类加载器报告为<code class="du km kn ko kp b">null</code>。这是一个安全特性——引导类加载器不验证，并提供对它加载的每个类的完全安全访问。因此，在Java运行时中表示和提供类加载器是没有意义的——太多潜在的错误和/或滥用。</p><p id="a00f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">除了它们的核心角色之外，类加载器还经常用于从JAR文件或类路径上的其他位置加载资源(不是类的文件，比如图像或配置文件)。</p><p id="6e24" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这通常出现在与try-with-resources结合产生如下代码的模式中:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="b93a" class="ky kz hi kp b fi la lb l lc ld">try (var is = TestMain.class.getResourceAsStream("/resource.csv");<br/>      var br = new BufferedReader(new InputStreamReader(is));) {<br/>      // ...<br/> }<br/> // Exception handling elided</span></pre><p id="3117" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">类加载器以几种不同的形式提供这种机制——返回一个<code class="du km kn ko kp b">File</code>或一个<code class="du km kn ko kp b">InputStream</code>,但不幸的是不是一个<code class="du km kn ko kp b">Path</code>。</p><h2 id="07a1" class="ky kz hi bd le lf lg lh li lj lk ll lm jr ln lo lp jv lq lr ls jz lt lu lv ho bi translated"><strong class="ak">自定义类加载</strong></h2><p id="0941" class="pw-post-body-paragraph ji jj hi jk b jl lw is jn jo lx iv jq jr ly jt ju jv lz jx jy jz ma kb kc kd hb bi translated">在更复杂的环境中，通常有许多额外的<em class="ke">自定义类加载器</em>——子类化<code class="du km kn ko kp b">java.lang.ClassLoader</code>的类(直接或间接)。这是可能的，因为classloader类不是最终的，事实上，开发人员被鼓励编写他们自己的类加载器来满足他们的个人需求。</p><p id="4713" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">定制的类加载器被表示为Java类型，它们需要由一个类加载器加载——通常被称为它们的<em class="ke">父类加载器</em>。这不应该与类继承和父类混淆——相反，类装入器通过一种形式的<em class="ke">委托</em>联系起来。</strong></p><p id="2688" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在图1中，您可以看到类装入器的委托层次结构，以及不同装入器之间的关系。在一些特殊的情况下，一个定制的类加载器可能有一个不同的类加载器作为它们的父类，但是通常的情况是加载类加载器。</p><figure class="kq kr ks kt fd mc er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mb"><img src="../Images/c5851217a7a9bb508b8a9430f06b3e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3za8UkWXhX_d10yf.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx translated">图一。类加载器层次结构</figcaption></figure><p id="cfe9" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">自定义机制的关键是在<code class="du km kn ko kp b">ClassLoader</code>上定义的方法<code class="du km kn ko kp b">loadClass()</code>和<code class="du km kn ko kp b">findClass()</code>。主入口点是<code class="du km kn ko kp b">loadClass()</code>，ClassLoader '中相关代码的简化形式是:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="aeca" class="ky kz hi kp b fi la lb l lc ld">protected Class&lt;?&gt; loadClass(String name, boolean resolve)<br/>         throws ClassNotFoundException<br/>     {<br/>         synchronized (getClassLoadingLock(name)) {<br/>             // First, check if the class has already been loaded<br/>             Class&lt;?&gt; c = findLoadedClass(name);<br/>             if (c == null) {<br/>                 // ...<br/>                 try {<br/>                     if (parent != null) {<br/>                         c = parent.loadClass(name, false);<br/>                     } else {<br/>                         c = findBootstrapClassOrNull(name);<br/>                     }<br/>                 } catch (ClassNotFoundException e) {<br/>                     // ClassNotFoundException thrown if class not found<br/>                     // from the non-null parent class loader<br/>                 }<br/>  <br/>                 if (c == null) {<br/>                     // If still not found, then invoke findClass in order<br/>                     // to find the class.<br/>                     // ...<br/>                     c = findClass(name);<br/>  <br/>                     // ...<br/>                 }<br/>             }<br/>             // ...<br/>  <br/>             return c;<br/>         }<br/>     }</span></pre><p id="754a" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这意味着<code class="du km kn ko kp b">loadClass()</code>机制查看类是否已经被加载，然后询问它的父类加载器。如果该类加载失败(注意围绕对<code class="du km kn ko kp b">parent.loadClass(name, false)</code>的调用的try-catch ),那么加载过程将委托给<code class="du km kn ko kp b">findClass()</code>。<code class="du km kn ko kp b">java.lang.ClassLoader</code>中<code class="du km kn ko kp b">findClass()</code>的定义很简单——它抛出一个<code class="du km kn ko kp b">ClassNotFoundException</code>。</p><p id="ee0e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在，让我们回到文章开始时提出的一个问题，探索在类加载过程中可能遇到的一些异常和错误类型。</p><h2 id="e506" class="ky kz hi bd le lf lg lh li lj lk ll lm jr ln lo lp jv lq lr ls jz lt lu lv ho bi translated"><strong class="ak">类加载异常</strong></h2><p id="19c7" class="pw-post-body-paragraph ji jj hi jk b jl lw is jn jo lx iv jq jr ly jt ju jv lz jx jy jz ma kb kc kd hb bi translated">首先,<code class="du km kn ko kp b">ClassNotFoundException</code>的意思相对简单——类加载器试图加载指定的类，但是无法完成。在请求加载时，这个类对JVM是未知的——JVM也找不到它。</p><p id="e0c3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">接下来是<code class="du km kn ko kp b">NoClassDefFoundError</code>——注意这是一个<em class="ke">错误</em>而不是一个异常。这个错误表明JVM知道所请求的类的存在，但是没有在其内部元数据中找到它的定义。</p><p id="12e6" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们快速看一个例子:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="87d9" class="ky kz hi kp b fi la lb l lc ld">public class ExampleNoClassDef {<br/>  <br/>     public static class BadInit {<br/>         private static int thisIsFine = 1 / 0;<br/>     }<br/>  <br/>     public static void main(String[] args) {<br/>         try {<br/>             var init = new BadInit();<br/>         } catch (Throwable t) {<br/>             System.out.println(t);<br/>         }<br/>         var init2 = new BadInit();<br/>         System.out.println(init2.thisIsFine);<br/>     }<br/> }</span></pre><p id="2cb1" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">当它运行时，我们得到如下输出:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="2f70" class="ky kz hi kp b fi la lb l lc ld">$ java ExampleNoClassDef<br/> java.lang.ExceptionInInitializerError<br/> Exception in thread "main" java.lang.NoClassDefFoundError: Could not initialize class ExampleNoClassDef$BadInit<br/>         at ExampleNoClassDef.main(ExampleNoClassDef.java:13)</span></pre><p id="046b" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这表明JVM试图加载<code class="du km kn ko kp b">BadInit</code>类，但是没有成功。然而，程序捕捉到了异常并试图继续运行。当第二次遇到该类时，JVM的内部元数据表显示该类已经被看到——但是没有加载有效的类。</p><p id="7ce4" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">JVM在失败的类加载尝试上有效地实现了<em class="ke">负缓存</em>——加载不会重试，而是抛出一个错误(<code class="du km kn ko kp b">NoClassDefFoundError</code>)。</p><p id="ca29" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">另一个常见错误是<code class="du km kn ko kp b">UnsupportedClassVersionError</code>——当类加载操作试图加载由比运行时版本更高版本的Java源代码编译器编译的类文件时，就会触发该错误。</p><p id="73fc" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">例如，考虑一个用Java 11编译的类，我们试图在Java 8上运行:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="9f15" class="ky kz hi kp b fi la lb l lc ld">$ java ScratchImpl<br/> Error: A JNI error has occurred, please check your installation and try again<br/> Exception in thread "main" java.lang.UnsupportedClassVersionError: ScratchImpl has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0<br/>         at java.lang.ClassLoader.defineClass1(Native Method)<br/>         at java.lang.ClassLoader.defineClass(ClassLoader.java:763)<br/>         at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)<br/>         at java.net.URLClassLoader.defineClass(URLClassLoader.java:468)<br/>         at java.net.URLClassLoader.access$100(URLClassLoader.java:74)<br/>         at java.net.URLClassLoader$1.run(URLClassLoader.java:369)<br/>         at java.net.URLClassLoader$1.run(URLClassLoader.java:363)<br/>         at java.security.AccessController.doPrivileged(Native Method)<br/>         at java.net.URLClassLoader.findClass(URLClassLoader.java:362)<br/>         at java.lang.ClassLoader.loadClass(ClassLoader.java:424)<br/>         at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)<br/>         at java.lang.ClassLoader.loadClass(ClassLoader.java:357)<br/>         at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)</span></pre><p id="4481" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">Java 11格式的字节码中可能有运行时不支持的特性，继续尝试加载它是不安全的。注意，因为这是Java 8运行时，所以在堆栈跟踪中没有模块化条目。</p><p id="a6e8" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">最后，我们还应该提到<code class="du km kn ko kp b">LinkageError</code>——它是包含<code class="du km kn ko kp b">NoClassDefFoundError</code>、<code class="du km kn ko kp b">VerifyError</code>和<code class="du km kn ko kp b">UnsatisfiedLinkError</code>以及其他几种可能性的层次结构的基类。</p><h2 id="78c0" class="ky kz hi bd le lf lg lh li lj lk ll lm jr ln lo lp jv lq lr ls jz lt lu lv ho bi translated"><strong class="ak">第一个定制的类加载器</strong></h2><p id="143c" class="pw-post-body-paragraph ji jj hi jk b jl lw is jn jo lx iv jq jr ly jt ju jv lz jx jy jz ma kb kc kd hb bi translated">定制类加载的最简单形式是子类化<code class="du km kn ko kp b">ClassLoader</code>并覆盖<code class="du km kn ko kp b">findClass()</code>。这允许我们重用前面讨论过的<code class="du km kn ko kp b">loadClass()</code>逻辑，并降低我们的类加载器的复杂性。</p><p id="67d4" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们的第一个例子是<code class="du km kn ko kp b">SadClassLoader</code>——它不做任何事情，但确保你知道它在技术上参与了这个过程，它祝你一切顺利。</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="7b5c" class="ky kz hi kp b fi la lb l lc ld">public class LoadSomeClasses {<br/>  <br/>     public static class SadClassloader extends ClassLoader {<br/>         public SadClassloader() {<br/>             super(SadClassloader.class.getClassLoader());<br/>         }<br/>  <br/>         public Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {<br/>             System.out.println("I am very concerned that I couldn't find the class");<br/>             throw new ClassNotFoundException(name);<br/>         }<br/>     }<br/>  <br/>     public static void main(String[] args) {<br/>         if (args.length &gt; 0) {<br/>             var loader = new SadClassloader();<br/>             for (var name : args) {<br/>                 System.out.println(name +" ::");<br/>                 try {<br/>                     var clazz = loader.loadClass(name);<br/>                     System.out.println(clazz);<br/>                 } catch (ClassNotFoundException x) {<br/>                     x.printStackTrace();<br/>                 }<br/>             }<br/>         }<br/>     }<br/> }</span></pre><p id="ef06" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在我们的示例中，我们设置了一个简单的类加载器和一些代码，使用它来尝试加载可能已经加载的类。</p><p id="6b6b" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">自定义类加载器的一个常见约定是提供一个void构造函数，该构造函数调用超类构造函数并提供加载类加载器作为参数(成为父类)。</p><p id="8222" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">许多定制的类加载器并不比我们的例子复杂多少——它们覆盖了<code class="du km kn ko kp b">findClass()</code>来提供特定的所需功能。例如，这可以包括在网络上查找课程。在一个令人难忘的案例中，一个定制的类加载器通过JDBC连接到一个数据库，并访问一个加密的二进制列来获取将要使用的字节，从而加载类。这是为了在高度管控的环境中满足敏感代码的静态加密要求。</p><p id="fd04" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">除了覆盖<code class="du km kn ko kp b">findClass()</code>，还可以做更多的事情。例如，<code class="du km kn ko kp b">loadClass()</code>不是final，它可以被覆盖，事实上，一些定制的类加载器覆盖它，正是为了改变我们前面遇到的一般逻辑。</p><p id="3c08" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">最后，还有在<code class="du km kn ko kp b">ClassLoader</code>上定义的方法<code class="du km kn ko kp b">defineClass()</code>。</p><p id="2c3d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这个方法是类加载的关键——因为它是执行我们在本文前面描述的“加载和链接”过程的用户可访问的方法。它接受一个字节数组，并将它们转换成一个类对象。这是用于在运行时加载类路径中不存在的新类的主要机制。</p><p id="47af" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">对<code class="du km kn ko kp b">defineClass()</code>的调用只有在传递了正确的JVM类文件格式的字节缓冲区时才起作用——如果没有，那么它将无法加载——因为加载或验证步骤都会失败。</p><p id="5b3f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">该方法可用于高级技术，如加载运行时生成的没有源代码表示的类。这种技术就是lambda表达式机制在Java中的工作方式。</strong></p><p id="814f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><code class="du km kn ko kp b">defineClass()</code>方法既是受保护的也是最终的，它在<code class="du km kn ko kp b">java.lang.ClassLoader</code>上被定义为只能被<code class="du km kn ko kp b">ClassLoader</code>的子类访问。定制类加载器总是可以访问<code class="du km kn ko kp b">defineClass()</code>的基本功能，但是不能篡改验证或其他低级类加载逻辑。最后一点很重要——不能改变验证算法是一个有用的安全特性，因为这意味着一个写得很差的定制类加载器不能损害JVM提供的基本平台安全性。</p><p id="141d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在HotSpot虚拟机的情况下(这是目前最常见的Java VM实现)，<code class="du km kn ko kp b">defineClass()</code>委托给本地方法<code class="du km kn ko kp b">defineClass1()</code>，该方法执行一些基本的检查，然后调用一个名为<code class="du km kn ko kp b">JVM_DefineClassWithSource()</code>的C函数。</p><p id="eaac" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这个函数是JVM的入口点——它提供了对HotSpot的C++代码的访问。HotSpot使用C++ <code class="du km kn ko kp b">SystemDictionary</code>通过C++方法<code class="du km kn ko kp b">ClassFileParser::parseClassFile()</code>加载新类。这是运行大部分链接过程的代码，尤其是验证算法。</p><p id="bc93" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">一旦类加载完成，方法的字节码就被放入Hotspot的表示方法的元数据对象中(它们被称为<em class="ke"> methodOops </em>)。然后字节码解释器就可以使用它们了。这在概念上可以被认为是一个方法缓存，尽管出于性能原因，字节码被内联保存在methodOops中。</p><p id="1fc3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们已经见过了<code class="du km kn ko kp b">SadClassloader</code>，但是让我们看看另外两个定制类加载器的例子，首先看看如何使用类加载来实现<em class="ke">依赖注入</em> (DI)。</p><h2 id="af24" class="ky kz hi bd le lf lg lh li lj lk ll lm jr ln lo lp jv lq lr ls jz lt lu lv ho bi translated"><strong class="ak">示例:依赖注入框架</strong></h2><p id="eef9" class="pw-post-body-paragraph ji jj hi jk b jl lw is jn jo lx iv jq jr ly jt ju jv lz jx jy jz ma kb kc kd hb bi translated">DI理念的核心是两个主要概念:</p><ul class=""><li id="29ac" class="mn mo hi jk b jl jm jo jp jr mp jv mq jz mr kd ms mt mu mv bi translated">系统中的功能单元具有依赖关系和配置信息，它们依赖这些信息来正常运行。</li><li id="5ea9" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">许多对象系统具有难以表达或难以表达的依赖关系。</li></ul><p id="70af" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">你头脑中的图像应该是包含行为的类，以及对象外部的配置和依赖。后一部分通常被称为对象的<em class="ke">运行时连接</em>。</p><p id="165f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在这个例子中，我们将讨论一个假想的DI框架如何利用类加载器来实现运行时连接。我们将采用的方法类似于Spring框架原始实现的简化版本。</p><p id="4300" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现代的DI框架经常使用另一种方法，这种方法具有更高的编译时安全性——但是这种方法的复杂性和理解的认知负荷要高得多。我们的示例仅用于演示目的。</p><p id="ca7a" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们先来看看如何在我们想象的DI框架下启动一个应用程序:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="b19a" class="ky kz hi kp b fi la lb l lc ld">java -cp &lt;CLASSPATH&gt; org.wgjd.DIMain /path/to/config.xml</span></pre><p id="8717" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">类路径必须包含DI框架的JAR文件，以及config.xml文件中引用的任何类(以及它们的任何依赖项)。</p><p id="f64c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为了在DI下进行管理，您还需要一个配置文件，如下所示:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="60f3" class="ky kz hi kp b fi la lb l lc ld">&lt;beans&gt;<br/>  <br/>   &lt;bean id="dao" class="wgjd.ch03.PaymentsDAO"&gt;<br/>     &lt;constructor-arg index="0" value="jdbc:postgresql://db.wgjd.org/payments"/&gt;<br/>     &lt;constructor-arg index="1" value="org.postgresql.Driver"/&gt;<br/>   &lt;/bean&gt;<br/>  <br/>   &lt;bean id="service" class="wgjd.ch03.PaymentService"&gt;<br/>     &lt;constructor-arg index="0" ref="dao"/&gt;<br/>   &lt;/bean&gt;<br/>  <br/> &lt;/beans&gt;</span></pre><p id="765e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在这种技术中，DI框架使用配置文件来决定构建哪些对象。这个例子需要制作<code class="du km kn ko kp b">dao</code>和<code class="du km kn ko kp b">service</code>bean，框架调用每个bean的构造函数。</p><p id="3fa1" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这意味着类加载发生在两个独立的阶段。第一阶段(由应用程序类加载器处理)加载类DIMain及其引用的任何类。然后DIMain开始运行，并接收配置文件的位置作为<code class="du km kn ko kp b">main()</code>的参数。</p><p id="8823" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">此时，框架已经在JVM中启动并运行，但是在<code class="du km kn ko kp b">config.xml</code>中指定的用户类还没有被触及。事实上，在<code class="du km kn ko kp b">DIMain</code>检查配置文件之前，框架无法知道哪些类将被加载。</p><p id="a8db" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">这个例子是假设性的和说明性的——完全有可能构建一个简单的DI框架，完全按照描述的方式工作。实际上，真正的DI系统的实现通常更加复杂。</strong></p><p id="bd24" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">要调出<code class="du km kn ko kp b">config.xml</code>中指定的应用程序配置，需要进行第二阶段的类加载。这使用了一个定制的类加载器。</p><p id="1738" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">首先，检查<code class="du km kn ko kp b">config.xml</code>文件的一致性，确保它没有错误。然后，如果一切正常，自定义类加载器尝试从<code class="du km kn ko kp b">CLASSPATH</code>加载类型。如果其中任何一个失败，整个过程都会中止，从而导致运行时错误。</p><p id="69ff" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果成功，DI框架就可以按照正确的顺序实例化所需的对象，并在创建的实例上调用任何setter方法。最后，如果所有这些都完成了，应用程序上下文就启动了，可以开始运行了。</p><h2 id="670c" class="ky kz hi bd le lf lg lh li lj lk ll lm jr ln lo lp jv lq lr ls jz lt lu lv ho bi translated">示例:检测类加载器</h2><p id="6d37" class="pw-post-body-paragraph ji jj hi jk b jl lw is jn jo lx iv jq jr ly jt ju jv lz jx jy jz ma kb kc kd hb bi translated">考虑一个类加载器，它在加载类时改变类的字节码，以添加额外的插装信息。当测试用例针对转换后的代码运行时，插装代码记录测试用例测试了哪些方法和代码分支。由此，开发人员可以看到对一个类的单元测试有多彻底。</p><p id="f6de" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这种方法是EMMA测试覆盖工具的基础，该工具仍然可以从<a class="ae jh" href="http://emma.sourceforge.net/" rel="noopener ugc nofollow" target="_blank">http://emma.sourceforge.net/</a>获得，尽管它现在已经相当过时，并且没有跟上现代Java版本的发展。</p><p id="6a2b" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">尽管如此，经常会遇到框架和其他代码使用专门的类加载器，在加载字节码时转换字节码。</p><p id="4e36" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">在加载字节码时修改字节码的技术也出现在<em class="ke"> java代理</em>方法中，该方法用于性能监控、可观察性和其他目标——由New Relic等工具实现。</strong></p><p id="87fe" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们已经简要介绍了定制类加载的几个用例。Java技术领域的许多其他领域都是类加载器和相关技术的大用户。以下是一些最著名的例子:</p><ul class=""><li id="eb2f" class="mn mo hi jk b jl jm jo jp jr mp jv mq jz mr kd ms mt mu mv bi translated">插件架构</li><li id="f436" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">框架(无论是供应商的还是自己开发的)</li><li id="5a42" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">从异常位置(不是文件系统或URL)检索类文件</li><li id="9da5" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">Java EE</li><li id="4725" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">在JVM进程已经开始运行之后，可能需要添加新的未知代码的任何情况</li></ul><p id="aebc" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们继续讨论模块系统是如何影响类加载和修改我们已经解释过的经典图片的。</p><h2 id="20b0" class="ky kz hi bd le lf lg lh li lj lk ll lm jr ln lo lp jv lq lr ls jz lt lu lv ho bi translated"><strong class="ak">模块和类加载</strong></h2><p id="0ef6" class="pw-post-body-paragraph ji jj hi jk b jl lw is jn jo lx iv jq jr ly jt ju jv lz jx jy jz ma kb kc kd hb bi translated">模块系统被设计成在不同于类加载的层次上运行，类加载是平台中相对较低层次的机制。模块是关于程序单元之间大规模的依赖关系，而类加载是关于小规模的依赖关系，但是理解这两种机制如何交叉以及程序启动的变化是很重要的，这些变化是由模块的到来引起的。</p><p id="d4bf" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">回想一下，当运行在一个模块化的JVM上，然后执行一个程序时，运行时首先计算一个模块图并试图满足它。这被称为<em class="ke">模块解析</em>，它导出根模块及其依赖关系的传递闭包。</p><p id="4c34" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在此过程中，会执行额外的检查(例如，没有重名的模块、没有拆分的包等)。模块图的存在意味着预计运行时类加载问题会更少——因为模块路径上丢失的jar现在甚至可以在进程完全开始之前就被检测到。</p><p id="e1e6" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">除此之外，在大多数情况下，模块系统不会改变类加载。一些高级的可能性是存在的，比如通过使用反射来动态加载服务提供者接口的模块化实现，但是这些不太可能被大多数开发人员遇到。</p><h2 id="f179" class="ky kz hi bd le lf lg lh li lj lk ll lm jr ln lo lp jv lq lr ls jz lt lu lv ho bi translated"><strong class="ak">倒影</strong></h2><p id="30d9" class="pw-post-body-paragraph ji jj hi jk b jl lw is jn jo lx iv jq jr ly jt ju jv lz jx jy jz ma kb kc kd hb bi translated">一个基础良好的Java开发人员应该掌握的关键技术之一是<em class="ke">反射</em>。这是一个极其强大的功能，但是许多开发人员一开始都很纠结——因为这似乎与大多数Java开发人员思考代码的方式格格不入。</p><p id="c655" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">反射是查询或<em class="ke">自省</em>对象并在运行时发现(和使用)它们的能力的能力。根据上下文，它可以被认为是几种不同的东西:</p><ul class=""><li id="629d" class="mn mo hi jk b jl jm jo jp jr mp jv mq jz mr kd ms mt mu mv bi translated">一种编程语言API</li><li id="d1ca" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">编程风格或技术</li><li id="cde4" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">支持该技术的运行时机制</li><li id="201a" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">语言类型系统的一个属性</li></ul><p id="cc9a" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">面向对象系统中的反射是指编程环境可以将程序的类型和方法表示为对象。这只有在运行时支持它的语言中才有可能——这是语言的一个基本动态方面。</p><p id="0e6b" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">当使用反射式编程时，根本不用静态类型就可以操作对象。这似乎是一种倒退，但是如果我们可以在不需要知道对象的静态类型的情况下处理对象，那么这意味着我们可以构建能够处理任何类型的库、框架和工具——包括在编写处理代码时不存在的类型。</p><p id="2453" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">当Java还是一门年轻的语言时，反射是它带给主流的关键技术创新之一。尽管其他语言(特别是Smalltalk)更早就引入了它，但在Java发布时，它并不是许多语言的共同部分。</p><h2 id="73eb" class="ky kz hi bd le lf lg lh li lj lk ll lm jr ln lo lp jv lq lr ls jz lt lu lv ho bi translated"><strong class="ak">引入反射</strong></h2><p id="6b46" class="pw-post-body-paragraph ji jj hi jk b jl lw is jn jo lx iv jq jr ly jt ju jv lz jx jy jz ma kb kc kd hb bi translated">对反射的抽象描述经常看起来令人困惑或难以理解。让我们看看JShell中的一些简单示例，以尝试更具体地了解什么是反射:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="44e8" class="ky kz hi kp b fi la lb l lc ld">jshell&gt; Object o = new Object();<br/> o ==&gt; java.lang.Object@a67c67e<br/>  <br/> jshell&gt; Class&lt;?&gt; clz = o.getClass();<br/> clz ==&gt; class java.lang.Object</span></pre><p id="0f1f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是我们第一次看到反射——类型<code class="du km kn ko kp b">Object</code>的类对象。事实上，<code class="du km kn ko kp b">clz</code>的实际类型是<code class="du km kn ko kp b">Class&lt;Object&gt;</code>，但是当我们从classloading或<code class="du km kn ko kp b">getClass()</code>中获得一个类对象时，我们必须在泛型中使用未知类型<code class="du km kn ko kp b">?</code>来处理它:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="3fde" class="ky kz hi kp b fi la lb l lc ld">jshell&gt; Class&lt;Object&gt; clz = Object.class;<br/> clz ==&gt; class java.lang.Object<br/>  <br/> jshell&gt; Class&lt;Object&gt; clz = o.getClass();<br/> |  Error:<br/> |  incompatible types: java.lang.Class&lt;capture#1 of ? extends java.lang.Object&gt; cannot be converted to java.lang.Class&lt;java.lang.Object&gt;<br/> |  Class&lt;Object&gt; clz = o.getClass();<br/> |                      ^----------^</span></pre><p id="480d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是因为反射是一种动态的运行时机制，真正的类型<code class="du km kn ko kp b">Class&lt;Object&gt;</code>对于源代码编译器来说是未知的。这给使用反射带来了不可减少的额外复杂性——因为我们不能依赖Java类型系统来帮助我们。</p><p id="f970" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">另一方面，这种动态性是反射的关键点——如果我们在编译时不知道某个东西是什么类型。我们必须用一种通用的方式来对待它，这种方式可以为构建一个开放的、可扩展的系统创造灵活性..反射产生了一个基本上开放的系统，这可能会与Java模块试图带给平台的更多封装的系统发生冲突。</strong></p><p id="b557" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">许多熟悉的框架和开发工具严重依赖反射来实现它们的功能，比如调试器和代码浏览器。插件架构、交互式环境和REPLs也广泛使用反射。事实上，如果没有反射子系统，JShell是无法用语言构建的。</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="c969" class="ky kz hi kp b fi la lb l lc ld">jshell&gt; class Pet {<br/>    ...&gt;   public void feed() {<br/>    ...&gt;     System.out.println("Feed the pet");<br/>    ...&gt;   }<br/>    ...&gt; }<br/> |  created class Pet<br/>  <br/> jshell&gt; var clz = Pet.class;<br/> clz ==&gt; class Pet</span></pre><p id="0793" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在我们有了一个表示Pet的类类型的对象，我们可以用它来做其他的动作，比如创建一个新的实例:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="3ed5" class="ky kz hi kp b fi la lb l lc ld">jshell&gt; Object o = clz.newInstance();<br/> o ==&gt; Pet@66480dd7</span></pre><p id="6c52" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">问题是<code class="du km kn ko kp b">newInstance()</code>返回<code class="du km kn ko kp b">Object</code>——这不是一个有用的类型。我们可以将<code class="du km kn ko kp b">o</code>转换回<code class="du km kn ko kp b">Pet,</code>，但是这需要我们提前知道我们正在处理什么类型——这与反射的动态本质相悖；让我们试试别的:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="ff6a" class="ky kz hi kp b fi la lb l lc ld">jshell&gt; import java.lang.reflect.Method;<br/>  <br/> jshell&gt; Method m = clz.getMethod("feed", new Class[0]);<br/> m ==&gt; public void Pet.feed()</span></pre><p id="ff00" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在我们有了一个表示方法<code class="du km kn ko kp b">feed()</code>的对象——但是它把它表示为抽象元数据——它不附属于任何特定的实例。</p><p id="d6a5" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">对于表示方法的对象，最自然的做法是调用它。类<code class="du km kn ko kp b">java.lang.reflect.Method</code>定义了一个方法<code class="du km kn ko kp b">invoke()</code>，它的作用是调用<code class="du km kn ko kp b">Method</code>对象所代表的方法。</p><p id="c6a2" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在JShell中工作时，我们避免了大量的异常处理代码。当编写使用反射的常规Java代码时，您需要以某种方式处理可能的异常类型。</p><p id="8962" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为了使这个调用成功，我们必须提供正确数量和类型的参数。该参数列表必须包括反射调用方法的<em class="ke">接收器对象</em>(假设该方法是实例方法)。在我们的简单示例中，情况如下:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="b3ce" class="ky kz hi kp b fi la lb l lc ld">jshell&gt; Object ret = m.invoke(o);<br/> Feed the pet<br/> ret ==&gt; null</span></pre><p id="6134" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">除了<code class="du km kn ko kp b">Method</code>对象，反射还提供了表示Java类型系统和语言中其他基本概念的对象——比如字段、注释和构造函数。这些类可以在<code class="du km kn ko kp b">java.lang.reflect</code>包中找到——其中一些(比如<code class="du km kn ko kp b">Constructor</code>)是泛型类型。</p><p id="4290" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">反射子系统必须升级以处理模块。因为类和方法可以被反射地对待，所以也需要一个反射API来处理模块。不出所料，key类是<code class="du km kn ko kp b">java.lang.Module</code>，它可以直接从<code class="du km kn ko kp b">Class</code>对象中访问:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="283f" class="ky kz hi kp b fi la lb l lc ld">var module = String.class.getModule();<br/> var descriptor = module.getDescriptor();</span></pre><p id="e892" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">模块的描述符属于ModuleDescriptor类型，并提供关于模块的元数据的只读视图，相当于module-info.class的内容。</p><p id="3e64" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在新的反射API中，诸如模块发现之类的动态功能也是可能的。这是通过ModuleFinder之类的接口实现的，但是如何使用模块系统进行反射式工作的详细描述超出了本文的范围。</p><h2 id="131d" class="ky kz hi bd le lf lg lh li lj lk ll lm jr ln lo lp jv lq lr ls jz lt lu lv ho bi translated"><strong class="ak">结合类加载和反射</strong></h2><p id="ccab" class="pw-post-body-paragraph ji jj hi jk b jl lw is jn jo lx iv jq jr ly jt ju jv lz jx jy jz ma kb kc kd hb bi translated">让我们看一个结合了类加载和反射的例子。我们不需要遵循通常的<code class="du km kn ko kp b">findClass()</code>和<code class="du km kn ko kp b">loadClass()</code>协议的完整的类加载器。相反，我们将子类化<code class="du km kn ko kp b">ClassLoader</code>来访问受保护的<code class="du km kn ko kp b">defineClass()</code>方法。</p><p id="f3fd" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">main方法接受一个文件名列表，如果它们是Java类，则使用反射依次访问每个方法，并检测它是否是本机方法:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="6a90" class="ky kz hi kp b fi la lb l lc ld">public class NativeMethodChecker {<br/>  <br/>     public static class EasyLoader extends ClassLoader {<br/>         public EasyLoader() {<br/>             super(EasyLoader.class.getClassLoader());<br/>         }<br/>  <br/>         public Class&lt;?&gt; loadFromDisk(String fName) throws IOException {<br/>             var b = Files.readAllBytes(Path.of(fName));<br/>             return defineClass(null, b, 0, b.length);<br/>         }<br/>     }<br/>  <br/>     public static void main(String[] args) {<br/>         if (args.length &gt; 0) {<br/>             var loader = new EasyLoader();<br/>             for (var file : args) {<br/>                 System.out.println(file +" ::");<br/>                 try {<br/>                     var clazz = loader.loadFromDisk(file);<br/>                     for (var m : clazz.getMethods()) {<br/>                         if (Modifier.isNative(m.getModifiers())) {<br/>                             System.out.println(m.getName());<br/>                         }<br/>                     }<br/>                 } catch (IOException | ClassFormatError x) {<br/>                     System.out.println("Not a class file");<br/>                 }<br/>             }<br/>         }<br/>     }<br/> }</span></pre><p id="05ea" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这些类型的例子对于探索Java平台的动态本质和学习反射API如何工作是很有趣的，但是对于一个有良好基础的Java开发人员来说，意识到在进行反射工作时可能出现的局限性和偶尔的挫折是很重要的。</p><h2 id="6231" class="ky kz hi bd le lf lg lh li lj lk ll lm jr ln lo lp jv lq lr ls jz lt lu lv ho bi translated"><strong class="ak">反射问题</strong></h2><p id="e346" class="pw-post-body-paragraph ji jj hi jk b jl lw is jn jo lx iv jq jr ly jt ju jv lz jx jy jz ma kb kc kd hb bi translated">反射API从1.1 (1996)开始就是Java平台的一部分，在这25年中，出现了许多问题和弱点。这些不便之处包括:</p><ul class=""><li id="9671" class="mn mo hi jk b jl jm jo jp jr mp jv mq jz mr kd ms mt mu mv bi translated">这是一个老的API——到处都是数组类型(它早于Java集合)</li><li id="0c71" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">确定调用哪个方法重载是很痛苦的</li><li id="8e8d" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">API有两种不同的方法<code class="du km kn ko kp b">getMethod()</code>和<code class="du km kn ko kp b">getDeclaredMethod()</code>来反射性地访问方法</li><li id="3da0" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">API提供了可以用来忽略访问控制的<code class="du km kn ko kp b">setAccessible()</code>方法</li><li id="80de" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">反射调用的异常处理是复杂的——被检查的异常被提升为运行时异常</li><li id="b75f" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">装箱和取消装箱是进行传递或返回原语的反射调用所必需的</li><li id="dafd" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">原始类型需要占位符类对象，例如<code class="du km kn ko kp b">int.class</code>—<code class="du km kn ko kp b">Class&lt;Integer&gt;</code>类型</li><li id="626a" class="mn mo hi jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated"><code class="du km kn ko kp b">void</code>方法需要引入<code class="du km kn ko kp b">java.lang.Void</code>类型</li></ul><p id="00c6" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">除了API中各种尴尬的角落，Java反射总是遭受性能不佳的困扰——原因有几个，包括对JVM的JIT编译器不友好。</p><p id="5fa4" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">解决反射调用性能的问题是添加方法句柄API的主要原因之一。</p><p id="8328" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">反射的最后一个问题仍然存在，这可能更像是一个哲学问题(或反模式):开发人员经常遇到反射，这是他们在Java中升级时遇到的第一个真正高级的技术之一。</p><p id="b309" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">因此，它可能会被过度使用，或者成为一种<em class="ke">金锤</em>技术——用于实现过度灵活的系统，或者显示不需要的内部微型框架的系统(有时被称为<em class="ke">内部框架</em>反模式)。这种系统通常是可配置的，但代价是将领域模型编码到配置中，而不是直接编码到领域类型中。</p><p id="f442" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">反射是一项伟大的技术，是基础良好的Java开发人员应该拥有的工具箱中的一项技术，但是它并不适合每种情况，大多数开发人员可能只需要谨慎地使用它。</p><p id="4c96" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">目前就这些。如果你想了解这本书的更多信息，你可以在曼宁的liveBook平台<a class="ae jh" href="https://livebook.manning.com/book/the-well-grounded-java-developer-second-edition?origin=product-look-inside&amp;utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_evans2_wellgrounded_12_8_20" rel="noopener ugc nofollow" target="_blank">这里</a>查看。</p></div></div>    
</body>
</html>