<html>
<head>
<title>Overcoming the Limitations of Client-Side Form Tracking With Webhooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Webhooks克服客户端表单跟踪的局限性</h1>
<blockquote>原文：<a href="https://medium.com/codex/overcoming-the-limitations-of-client-side-form-tracking-with-webhooks-1e5081e3e032?source=collection_archive---------12-----------------------#2021-10-13">https://medium.com/codex/overcoming-the-limitations-of-client-side-form-tracking-with-webhooks-1e5081e3e032?source=collection_archive---------12-----------------------#2021-10-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/680f58b7885d213d1e5a9ecd576814df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JCkyqjs9qhLYgeLAYD5B-w.png"/></div></div></figure><p id="3fc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上周，我们强调了如何使用我们的<a class="ae jo" href="https://docs.rudderstack.com/stream-sources/webhook-source" rel="noopener ugc nofollow" target="_blank"> Webhook源</a>为Salesforce传输事件。在关于如何在RudderStack中使用Webhook源代码的系列文章的第2部分中，我们将带您了解如何将网站的表单数据提交给RudderStack，而不会受到客户端脚本阻塞工具的影响。</p><h1 id="9cda" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">你为什么需要这个？</h1><p id="92a7" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">您网站上的用户运行浏览器扩展或其他第三方工具来阻止客户端JavaScript启动的情况并不少见。在这些场景中，通过RudderStack Track和Identify调用发送的表单客户端数据可能会被阻塞(以及您正在收集的任何其他客户端数据)。对于作为静态文档部署的现代<a class="ae jo" href="https://jamstack.org/" rel="noopener ugc nofollow" target="_blank"> JAMStack </a>网站，或者使用Marketo或HubSpot等第三方嵌入表单的网站，这尤其具有挑战性。</p><p id="f665" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为数据工程师，我们的部分工作是确保关键数据在任何情况下的交付，因此当涉及到营销网站上的销售线索表单时，问题可能会给营销和销售带来重大痛苦。</p><p id="f1b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用RudderStack的数据工程师利用一个简单的过程来确保即使客户端数据被阻塞，关键事件也能通过。在这个例子中，我们将使用Basin、表单端点和RudderStack webhooks。</p><p id="fa0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当表单数据提交到Basin时，它使用标准的http get或post协议作为编码的html进行传递，因此不容易受到客户端拦截器的影响。一旦接收到，Basin会立即将表单的全部内容以及一些额外的元数据转发给RudderStack中的webhook源。RudderStack然后可以将这些提交路由到一些下游工具，如Customer.io、Salesforce、Slack和Snowflake。</p><h1 id="961d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">关键数据有冗余是好事</h1><p id="145b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">客户端跟踪非常有效，所以有些人可能会说，对于大多数网站访问者来说，额外的管道是不必要的。然而，对于关键数据来说，冗余是好的——对于许多公司来说，营销线索是业务的命脉。此外，工具的易于实现性和成本使得确保没有线索从缝隙中溜走变得不需要动脑筋。</p><p id="d51c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是创建该数据流的分步指南。</p><h1 id="e3c0" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤1:创建你的Webhook源和目的地</h1><p id="d113" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">查看<a class="ae jo" href="https://docs.rudderstack.com/stream-sources/webhook-source" rel="noopener ugc nofollow" target="_blank"> RudderStack文档</a>了解细节，但这很简单，只需在RudderStack中创建一个新源并选择Event Streams下的Webhook选项。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/0aa2837371835bb13f755edc9998a495.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/0*ggT1tK8I2RxvK4pa.png"/></div></figure><p id="40e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">命名后，您可以在“设置”选项卡上找到您的webhook的特定URL:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/ad7db300373d3319703f34af438475f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PEb1_5H1v3Y7pEN8.png"/></div></div></figure><p id="5808" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据面板URL可以在主连接页面的顶部找到。</p><p id="1779" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦你有了你的webhook的URL，记录下来，因为你需要在接下来的几个步骤中在Basin设置中设置它。</p><p id="79c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当连接webhook的下游目的地时，重要的是要考虑您将从各种来源接收什么类型的有效载荷。正如我们提到的，Webhooks没有过滤器，你收到的数据在转发到你的目的地之前可能不是正确的格式。用户转换是一个很好的工具，可以过滤不必要的事件，并将有效负载修改为每个特定目的地的正确格式。</p><h1 id="398d" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤2:设置你的盆地形式</h1><p id="f79a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">您可以按照<a class="ae jo" href="https://www.usebasin.com/docs/setup/getting-started" rel="noopener ugc nofollow" target="_blank"> Basin文档</a>中的这些步骤来创建一个帐户并创建您的第一个端点。您的端点将生成一个URL，您希望将它粘贴到您网站的HTML表单的操作命令中。您的表单将如下所示:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/35d21c461087e1d3a43b1a28931866aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zfgQHm91SG_NeBN4.png"/></div></div></figure><h1 id="7e6e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">第3步:创建盆地网钩</h1><p id="40d3" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">创建并配置了Basin端点以接收提交的表单数据后，下一步是配置Basin将提交的表单数据转发到新的RudderStack Webhook源。从顶部菜单中，选择集成选项:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/b40d16eac7a512a2507d0aec56ebab15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pGIAvZrBXdzzZpdA.png"/></div></div></figure><p id="37e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">滚动到屏幕底部，输入步骤1中RudderStack Webhook源代码的URL，并将其粘贴到URL窗口中。选择JSON作为有效负载格式:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/6ec182e6336aa2010c547f7f71b31294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xEyOaNTpjEv0xnEl.png"/></div></div></figure><p id="3d3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">单击保存更改按钮，您就可以开始接收事件了。</p><h1 id="635b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤4:用户转换</h1><p id="9bf7" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">既然您已经准备好开始通过我们的Webhook接收事件，您可能会发现创建一个用户转换来提高有效负载的质量是非常有用的。这些包括将事件类型从跟踪调用(所有webhook源事件都是跟踪调用)更改为识别调用和/或将事件名称重命名为其他名称，因为所有webhook事件都以通用的“webhook事件”事件名称传递</p><h2 id="84ec" class="lb jq hi bd jr lc ld le jv lf lg lh jz jb li lj kd jf lk ll kh jj lm ln kl lo bi translated">将有效负载更改为识别呼叫</h2><p id="51fb" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">您可以调用入站事件的元数据，根据webhook的源id过滤或转换事件。</p><pre class="kt ku kv kw fd lp lq lr ls aw lt bi"><span id="403e" class="lb jq hi lq b fi lu lv l lw lx">export async function transformEvent(event, metadata) {<br/>  <br/>        // Use the Data Governance API to get the Source ID<br/>        <br/>        if (metadata(event).sourceId == 'Your Source ID') {<br/>            event.type = 'identify';<br/>            let traits = {<br/>                email: event.properties.email,<br/>                firstName: event.properties.firstName,<br/>                lastName: event.properties.lastName,<br/>                description: event.properties.message<br/>            }<br/>            if (event.properties.company) { traits.company = event.properties.company }<br/>            if (event.properties.jobTitle) { traits.title = event.properties.jobTitle }<br/>            traits = Object.assign(traits, leadSources(event.properties.form_id))<br/>            event.context = { traits: traits};<br/>            delete event.properties;<br/>            return event;<br/>        }<br/>    <br/>    return;<br/>}</span></pre><h2 id="2f77" class="lb jq hi bd jr lc ld le jv lf lg lh jz jb li lj kd jf lk ll kh jj lm ln kl lo bi translated">更新事件。Webhook源的名称</h2><p id="fa4b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">默认情况下，通过webhook源接收的所有事件都是跟踪调用，并且都具有相同的名称“WEBHOOK_SOURCE_EVENT”。如果您只有一个webhook源，这是没问题的，但是如果您有多个，所有的事件都将被插入到数据仓库的同一个webhook_source_event表中。这可能会令人困惑，尤其是如果源没有区分的有效负载。</p><p id="3908" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用与上面的identify调用类似的解决方案，只是基于硬编码的映射来重命名事件，但是我们决定创建一个RudderStack转换库来调用数据治理API，我们可以从该API映射事件元数据中的源id，以找到重命名事件的源名称。</p><p id="26ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本例中，我们创建了一个库操作来调用数据治理API本身。在您开始之前，我们鼓励您查看我们的<a class="ae jo" href="https://docs.rudderstack.com/data-governance/rudderstack-data-governance-api" rel="noopener ugc nofollow" target="_blank">数据治理API文档。</a></p><p id="94f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">调用数据治理API: </strong></p><pre class="kt ku kv kw fd lp lq lr ls aw lt bi"><span id="0057" class="lb jq hi lq b fi lu lv l lw lx">export async function getSourceName(encodedWorkspaceToken, sourceId) {</span><span id="f382" class="lb jq hi lq b fi ly lv l lw lx">  const resp = await fetch(<br/>      'https://api.rudderlabs.com/workspaceConfig',<br/>      { headers: { Authorization: `Basic ${encodedWorkspaceToken}Og==` } }<br/>  )<br/>  <br/>  const sourceDisplayName = resp.sources.find(source =&gt; source.id === sourceId).name<br/>  <br/>  return sourceDisplayName<br/>}</span></pre><p id="9d0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着库的创建，我们现在可以创建我们的转换或者将它添加到一个现有的转换中。</p><p id="c035" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您将需要检索Rudderstack实例的工作空间令牌，该令牌可以在主连接屏幕上找到。它还需要被编码为Base64加密(你可以用第二个库来做这件事，但是因为在这种情况下它是静态的，你可以使用像https://www.base64encode.net/<a class="ae jo" href="https://www.base64encode.net/" rel="noopener ugc nofollow" target="_blank">这样的网站来编码它。)</a></p><pre class="kt ku kv kw fd lp lq lr ls aw lt bi"><span id="5390" class="lb jq hi lq b fi lu lv l lw lx">import { getSourceName } from 'getSourceDisplayName'<br/>import { base64 } from 'base64'</span><span id="1a6c" class="lb jq hi lq b fi ly lv l lw lx">export async function transformEvent(event, metadata) {<br/>  // Enter your base64 encrypted workspace token here below<br/>  const WORKSPACE_TOKEN = 'YOUR WORKSPACE TOKEN'<br/>  <br/>  // Get the id of the source that you want the display name of<br/>  const SOURCE_ID = metadata(event).sourceId <br/>  <br/>  const SOURCE_NAME = await getSourceName(base64(WORKSPACE_TOKEN), SOURCE_ID)<br/>  <br/>  event.event = SOURCE_NAME<br/>  <br/>  return event;<br/>}</span></pre><p id="dc07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以看到，在几个步骤中，我们已经检索了上面创建的Webhook示例的源名称。如果您确实想将所有webhook事件发送到仓库中的同一个表，但是需要一种方法来区分它们，那么这也可以作为一个属性来传递。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/301ad81491d0e4961df3f99afd935107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z1-OSttb_5uqSLdg.png"/></div></div></figure><h1 id="b7aa" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Webhook解决方案的替代方案</h1><p id="98e3" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">是的，还有其他方法可以解决客户端脚本被阻塞的问题。最直接的方法是托管您自己的数据层，并从您自己的防火墙后面调用sdk。另一种选择是通过CloudFlare worker来代理请求，正如obstructive Analytics最近的帖子<a class="ae jo" href="https://www.obsessiveanalytics.com/blog/making-rudder-stack-ad-blocker-proof-in-66-lines-of-code" rel="noopener ugc nofollow" target="_blank">中所概述的，用66行代码证明RudderStack广告拦截器。</a></p><p id="994b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里真正的要点是RudderStack专注于交付支持工程师的灵活产品。要了解RudderStack如何支持您的数据堆栈，请查看我们的<a class="ae jo" href="https://rudderstack.com/video-library/" rel="noopener ugc nofollow" target="_blank">视频库</a>，或<a class="ae jo" href="https://app.rudderlabs.com/signup?type=freetrial" rel="noopener ugc nofollow" target="_blank">免费注册</a>立即试驾该产品。</p><p id="e852" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本帖最初发布于:<br/><a class="ae jo" href="https://rudderstack.com/blog/overcoming-the-limitations-of-client-side-form-tracking-with-webhooks" rel="noopener ugc nofollow" target="_blank">https://rudder stack . com/blog/overrising-the-limits-of-client-side-form-tracking-with-web hooks</a></p></div></div>    
</body>
</html>