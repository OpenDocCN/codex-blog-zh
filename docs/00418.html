<html>
<head>
<title>Beyond Matplotlib and Seaborn: Python Data Visualization Tools That Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超越Matplotlib和Seaborn:有效的Python数据可视化工具</h1>
<blockquote>原文：<a href="https://medium.com/codex/beyond-matplotlib-and-seaborn-python-data-visualization-tools-that-work-3ef7f8d1500e?source=collection_archive---------0-----------------------#2021-02-01">https://medium.com/codex/beyond-matplotlib-and-seaborn-python-data-visualization-tools-that-work-3ef7f8d1500e?source=collection_archive---------0-----------------------#2021-02-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/6e826f5331348b88d5e63136fd301c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bMRBGf7eXxdAPgCn"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">卢克·切瑟在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="4690" class="hw hx hy bd b fp hz ia ib ic id ie dx if translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">抄本</a></h2><div class=""/><blockquote class="je jf jg"><p id="b648" class="jh ji jj jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这篇文章是我的同名会议演讲的延伸，包含来自<a class="ae hv" href="https://github.com/skirmer/new-py-dataviz" rel="noopener ugc nofollow" target="_blank">https://github.com/skirmer/new-py-dataviz</a>的内容。要查看所有代码和其他可视化示例，请访问repo。如果你更想在视频/直播上看到这些内容，<a class="ae hv" href="https://skirmer.github.io/events.html" rel="noopener ugc nofollow" target="_blank">欢迎参加离群值会议或ODSC东部2021！</a></p><p id="b8fd" class="jh ji jj jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hb bi translated">这篇文章反映了我的观点，而不是任何雇主的观点。</p></blockquote><p id="33e0" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated"><strong class="jk ii">我要坦白:我是一个Python dataviz投诉者。</strong>从R生态系统来到Python，我被漂亮、简单的可视化工具宠坏了很多年，从ggplot2 的<a class="ae hv" href="https://ggplot2.tidyverse.org/" rel="noopener ugc nofollow" target="_blank">基础开始，包括由</a><a class="ae hv" href="https://github.com/thomasp85" rel="noopener ugc nofollow" target="_blank"> Thomas Lin Pedersen </a>和其他人开发的所有壮观的库。</p><p id="6f3f" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">因此，转向Python进行机器学习对我来说一直是一场斗争。当Python中的所有可视化选项一片混乱时，我如何可视化我的数据、评估我的模型性能并呈现我的输出？像许多人一样，我经常是一个视觉学习者，看到一个情节可以帮助我点击一些东西，如果它只是一个表格或一个段落，我永远不会完全理解。</p><p id="7fcf" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">在多次抱怨之后，也从其他人那里听到了这种抱怨，我开始怀疑我对Python dataviz的最初印象是否仍然正确。我最终决定，如果我要继续说Python dataviz是一场垃圾大火，我需要仔细看看Python中的可视化工具，并实际测试它们。</p><p id="2e85" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated"><strong class="jk ii">剧透:我错了，Python中有一些不错的dataviz工具。不过R的工具包还是比较好的。</strong></p><h1 id="e4cb" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">开始</h1><p id="806b" class="pw-post-body-paragraph jh ji hy jk b jl lh jn jo jp li jr js kg lj jv jw kh lk jz ka ki ll kd ke kf hb bi translated">大多数从零开始使用Python中的dataviz的人都会被指向Matplotlib。如果他们幸运的话，有人会说“哦，试试Seaborn，结果看起来更好。”然而，这些都是Python中最没用和用户友好的可视化工具。Python dataviz糟糕的名声很大程度上是因为从这里起步的人糟糕的经历。</p><p id="24e1" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">让我们看看更好的选择。为了公平起见，我将展示Matplotlib和Seaborn的一些情节，但是请相信我:除非这些库是创建您想要的情节的唯一方式(它们很可能不是)，否则请跳过它们。</p><h1 id="4198" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">标准</h1><p id="0eca" class="pw-post-body-paragraph jh ji hy jk b jl lh jn jo jp li jr js kg lj jv jw kh lk jz ka ki ll kd ke kf hb bi translated">我意识到，这些观点可能会让我对“实际上很好”的人群敞开心扉，所以让我来设定一些基本规则。当我在寻找一个好的数据可视化库时，我有一些标准。就可视化工具而言，这些可能对你来说并不重要，这没关系！你做你的。</p><h2 id="ab69" class="lm kk hy bd kl ln lo lp kp lq lr ls kt kg lt lu kx kh lv lw lb ki lx ly lf ie bi translated">学习曲线</h2><p id="7cb0" class="pw-post-body-paragraph jh ji hy jk b jl lh jn jo jp li jr js kg lj jv jw kh lk jz ka ki ll kd ke kf hb bi translated">拥有丰富库经验的超级用户通常可以用不太好的工具完成很多工作。这很好，但这不是我们应该对新用户期望或要求的。强迫人们学习使用一个困难的工具(当有更好的选择时)是挫败用户并让他们转向其他工具的好方法。</p><h2 id="01d0" class="lm kk hy bd kl ln lo lp kp lq lr ls kt kg lt lu kx kh lv lw lb ki lx ly lf ie bi translated">语法</h2><p id="c901" class="pw-post-body-paragraph jh ji hy jk b jl lh jn jo jp li jr js kg lj jv jw kh lk jz ka ki ll kd ke kf hb bi translated">一旦用户学会了基础知识，我希望他们能够根据常识即兴发挥。如果<code class="du lz ma mb mc b">set_title</code>适用于散点图，那么它也应该适用于柱状图。为什么不会呢？(看着你，Seaborn)。当你不能开始建立基础知识时，那么学习过程就像是死记硬背。这就是每个人都觉得英语动词难学的原因——不规则在语言中不是一件好事。</p><h2 id="e3fe" class="lm kk hy bd kl ln lo lp kp lq lr ls kt kg lt lu kx kh lv lw lb ki lx ly lf ie bi translated">灵活性</h2><p id="9357" class="pw-post-body-paragraph jh ji hy jk b jl lh jn jo jp li jr js kg lj jv jw kh lk jz ka ki ll kd ke kf hb bi translated">所以这个库可以让你很快启动并运行，这很好——但是你将需要一些特别的、定制的或者很快改变的东西。如果，当用户出去寻找“我如何改变X”的时候，得到的答案是你不能改变X，或者你必须建立一个全新的工具包来做这件事，这是一个大问题。如果这个工具很容易使用，但是没有完整的功能，它就不够好。</p><h2 id="d2cd" class="lm kk hy bd kl ln lo lp kp lq lr ls kt kg lt lu kx kh lv lw lb ki lx ly lf ie bi translated">质量输出</h2><p id="fdfc" class="pw-post-body-paragraph jh ji hy jk b jl lh jn jo jp li jr js kg lj jv jw kh lk jz ka ki ll kd ke kf hb bi translated">我们有时会陷入极端，要么花上数不清的时间让情节变得有吸引力，调整每个微小的细节，要么我们放弃并决定美学不重要(想想你看到的所有普通的白色幻灯片和黑色Calibri字体——许多人只是放弃了体面的设计)。我想要一个好的dataviz库来帮助我们找到一个中间地带。如果用户不付出大量的努力，没有理由认为一个默认的情节不具有合理的吸引力。</p><h1 id="6f50" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">竞争者</h1><ul class=""><li id="c7b9" class="md me hy jk b jl lh jp li kg mf kh mg ki mh kf mi mj mk ml bi translated">2003年，https://matplotlib.org/</li><li id="adec" class="md me hy jk b jl mm jp mn kg mo kh mp ki mq kf mi mj mk ml bi translated"><a class="ae hv" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank">西博恩:2012年，https://seaborn.pydata.org/</a></li><li id="2b2c" class="md me hy jk b jl mm jp mn kg mo kh mp ki mq kf mi mj mk ml bi translated"><a class="ae hv" href="https://bokeh.org/" rel="noopener ugc nofollow" target="_blank">散景:2012年，https://bokeh.org/</a></li><li id="b36c" class="md me hy jk b jl mm jp mn kg mo kh mp ki mq kf mi mj mk ml bi translated"><a class="ae hv" href="https://altair-viz.github.io/" rel="noopener ugc nofollow" target="_blank">牛郎星:2016，https://altair-viz.github.io/</a></li><li id="318b" class="md me hy jk b jl mm jp mn kg mo kh mp ki mq kf mi mj mk ml bi translated"><a class="ae hv" href="https://plotnine.readthedocs.io/" rel="noopener ugc nofollow" target="_blank">剧情九:2017年，https://plotnine.readthedocs.io/</a></li><li id="bdd1" class="md me hy jk b jl mm jp mn kg mo kh mp ki mq kf mi mj mk ml bi translated"><a class="ae hv" href="https://plotly.com/python/" rel="noopener ugc nofollow" target="_blank">剧情:2013年，https://plotly.com/python/</a></li></ul><h1 id="d905" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">试验</h1><p id="4004" class="pw-post-body-paragraph jh ji hy jk b jl lh jn jo jp li jr js kg lj jv jw kh lk jz ka ki ll kd ke kf hb bi translated">为了使我的评价尽可能公正，我选择了五种类型的情节，并在六个库中分别进行了渲染，试图在不做大量改动的情况下，使它们尽可能地相似，尽可能地吸引人。</p><p id="15a4" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">我选择这些图是为了了解这些库如何处理不同的数据类型和分组。当然，我们可能经常使用无数的绘图类型，但这些通常是基于一些可视化类型的核心基础。我们将使用几种不同的分组方法来查看点、线和条，我们还将查看数字、分类和日期时间数据类型。</p><ul class=""><li id="aef7" class="md me hy jk b jl jm jp jq kg mr kh ms ki mt kf mi mj mk ml bi translated">柱状图</li><li id="4bf7" class="md me hy jk b jl mm jp mn kg mo kh mp ki mq kf mi mj mk ml bi translated">散点图</li><li id="5245" class="md me hy jk b jl mm jp mn kg mo kh mp ki mq kf mi mj mk ml bi translated">分面散点图</li><li id="4eff" class="md me hy jk b jl mm jp mn kg mo kh mp ki mq kf mi mj mk ml bi translated">分组条形图</li><li id="228b" class="md me hy jk b jl mm jp mn kg mo kh mp ki mq kf mi mj mk ml bi translated">时间序列线</li><li id="1885" class="md me hy jk b jl mm jp mn kg mo kh mp ki mq kf mi mj mk ml bi translated">额外奖励:3D散点图</li></ul><h1 id="128c" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">Matplotlib</h1><p id="6c4f" class="pw-post-body-paragraph jh ji hy jk b jl lh jn jo jp li jr js kg lj jv jw kh lk jz ka ki ll kd ke kf hb bi translated">在Matplotlib中，方法是创建一个初始的plot对象，然后在其上覆盖数据系列——这是一种常见的模式，我们在浏览这些库时会很熟悉。然而，最初的情节对象是一件复杂的事情，并对新用户构成了直接的挑战。</p><figure class="mu mv mw mx fd hk"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="mu mv mw mx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es na"><img src="../Images/473848736e6849fe36527d5fa7be7ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-UyCOTmRp0E8B39HtLjU1g.png"/></div></div></figure><p id="72fd" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated"><code class="du lz ma mb mc b">fig, ax = plt.subplots()</code>几乎总是Matplotlib中绘图的第一行，它表示图形(fig)是与轴(ax)不同的对象。这已经对用户的认知理解提出了挑战，用户可能会想知道这个框架中的图形到底是什么。一个不擅长视觉设计的开发人员或数据科学家在这里可能会特别沮丧。</p><p id="9474" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">值得称赞的是，Matplotlib开发人员确实有大量的文档和教程材料来帮助新用户——但是，对于大多数用户来说，这种需要大量解释的工具真的是最好的选择吗？这不就是“不直观”的定义吗？</p><p id="d4ac" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">就视觉设计而言，Matplotlib产生了非常独特的情节，而且不是以一种好的方式。渲染很难从美学角度定制，分辨率不够清晰，应用主题或有序的配色方案也很费功夫。</p><figure class="mu mv mw mx fd hk"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="mu mv mw mx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nb"><img src="../Images/fb274b539b06358e2420e9e0445b50c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ZdIlb1giksN-Fr8dByg_w.png"/></div></div></figure><p id="db48" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">还值得注意的是，Matplotlib是为NumPy数组设计的，并没有承诺它将如何处理其他数据类型，如pandas对象。</p><h1 id="0c3f" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">海生的</h1><p id="e4e9" class="pw-post-body-paragraph jh ji hy jk b jl lh jn jo jp li jr js kg lj jv jw kh lk jz ka ki ll kd ke kf hb bi translated">Seaborn是基于Matplotlib的改编，旨在改善一些功能和结果质量，但仍然受到Matplotlib的挑战。它肯定比Matplotlib更容易使用，但必须牺牲一些语法一致性，因为它是为了与Matplotlib兼容。</p><figure class="mu mv mw mx fd hk"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="mu mv mw mx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nc"><img src="../Images/8736766e2f19b543f695635ce839f646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZX73qqtcBoR5NuIi3jvgw.png"/></div></div></figure><p id="cd71" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">你不一定需要从Matplotlib的令人困惑的元素如<code class="du lz ma mb mc b">plt.subplots()</code>开始，但是你可以很快进入必须使用Matplotlib层元素来获得你想要的情节的情况。正如官方文档会告诉你的，“虽然你可以只使用seaborn函数来提高效率，但是你的图形的完全定制需要一些matplotlib的概念和API的知识。”<a class="ae hv" href="https://seaborn.pydata.org/introduction.html" rel="noopener ugc nofollow" target="_blank">文件</a></p><figure class="mu mv mw mx fd hk"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="mu mv mw mx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nc"><img src="../Images/320847a3fe51792a48be009f92bb6372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zs0V85loejjM4VBCnT_YJg.png"/></div></div></figure></div><div class="ab cl nd ne gp nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="hb hc hd he hf"><p id="cf47" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">根据我们所了解的，让我们来讨论四个完全不同的备选库。这些库有自己的语法和框架，如果不是完全独立于Matplotlib的话，大部分也是如此。</p><h1 id="7c63" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">散景</h1><p id="1b28" class="pw-post-body-paragraph jh ji hy jk b jl lh jn jo jp li jr js kg lj jv jw kh lk jz ka ki ll kd ke kf hb bi translated">总的来说，散景的语法很有意义，非常适合新用户的即兴创作。在散景中，你从指定你的输出类型(笔记本或文件)开始，然后添加一个包含许多整体美学参数的“图形”对象。之后，你在上面覆盖数据系列，并可能在最后添加一些设计调整。</p><figure class="mu mv mw mx fd hk"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="mu mv mw mx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nk"><img src="../Images/a7062eee6ce1cfdcdb9d3543981c0451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QV5dwzGDY-Ghamp2V4ZYkQ.png"/></div></div></figure><p id="70f5" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">虽然这不是一个真正有趣或复杂的任务，但我很惊讶地看到散景在渲染直方图时有多么特别和独特。它要求用户在NumPy中用数字生成直方图界限，然后用户在图上创建一个矩形覆盖图来呈现直方图的图像。如果Matplotlib的认知开销很高，我认为这个特定的散景例子在所需的精神体操中有点荒谬。</p><figure class="mu mv mw mx fd hk"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="mu mv mw mx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nl"><img src="../Images/fb3395d412a74e99b2cfa7584bcd3d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L63cjUbtDsEDkss7PqALrQ.png"/></div></div></figure><p id="c5f8" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">然而，我不想听起来像是我对散景很失望——对于它可以制作的几乎所有其他类型的情节，它是可用的顶级库之一。它拥有华丽、犀利的剧情，对剧情的交互性(比如缩放)真的是得心应手。也许部分是因为视觉效果，散景图在Jupyter中加载很慢，有时直到你在一个块上点击两次Run才会出现。</p><figure class="mu mv mw mx fd hk"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="mu mv mw mx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nm"><img src="../Images/acbc63793ac128d8a08a247ec8ec8778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rGAEfBZ8ENnCvu0mhxuy4A.png"/></div></div></figure><p id="c8e0" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">偶尔会出现预绘制数据操作令人困惑的情况——有时您必须提前完成所有数据操作，有时散景会为您完成——但我认为这对图书馆来说是一个自然的挑战，对此我不会太苛刻。</p><h1 id="17ca" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">阿尔泰尔</h1><p id="c456" class="pw-post-body-paragraph jh ji hy jk b jl lh jn jo jp li jr js kg lj jv jw kh lk jz ka ki ll kd ke kf hb bi translated">像散景一样，Altair为设计剧情带来了清晰易懂的语法和方案。在Altair中，用户从一个“图表”对象开始，然后在此基础上添加图表类型(如“条形图”)，然后设置编码来指示属于每个轴的数据。设计元素通常是最后添加的，在“属性”调用中。如果您愿意，可以将这些不同的步骤链接在一起(尽管这可能会使代码的可读性变得有些困难。)</p><figure class="mu mv mw mx fd hk"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="mu mv mw mx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nn"><img src="../Images/881e61bacb0b368cef1727766f4ed1d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PyTFBs4XZrWG9Tyw_UwWAA.png"/></div></div></figure><p id="9637" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">牛郎星有一个很大的差距，但是，不能忽视。它强烈建议用户不要使用超过5，000行的数据集。诚然，大量的数据可能会使任何可视化渲染缓慢，特别是如果有交互功能或JSON后端。然而，与这里的所有其他库不同，Altair在超过5000行时会产生一个失败错误，而不是用户预期的性能损失，您可以冒险覆盖这个错误。因此，对于我所做的测试，我使用了下采样，这使得图在许多情况下信息量较少。</p><figure class="mu mv mw mx fd hk"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="mu mv mw mx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es no"><img src="../Images/81c5974f05e43bc4bdb11c5de82af8ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yb5e58u1Gp9wTkOVn_LzCQ.png"/></div></div></figure><p id="bdd9" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">如果您忽略了这个错误，Altair的性能会严重下降。考虑到性能下降，我可以理解为什么开发人员设置了这个错误消息，但似乎找到一些解决性能下降的方案是更好的计划。这可能不太可能，但是就目前的情况来看，尽管我非常喜欢它的语法和结果，我还是不太推荐Altair，除非你有小的数据集或者可以预聚合你的数据。</p><p id="5911" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">但是不要搞错了——Altair的输出很漂亮，语法也非常容易和一致！</p><h1 id="8740" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">普洛特宁</h1><p id="df2c" class="pw-post-body-paragraph jh ji hy jk b jl lh jn jo jp li jr js kg lj jv jw kh lk jz ka ki ll kd ke kf hb bi translated">Plotnine只是将ggplot2库移植到Python中，并试图在Python中尽可能多地复制ggplot2 API。这确实是一个令人印象深刻的壮举，因为R和Python是完全不同的语言，ggplot2的语法显然是非Python的，但这个库成功了。ggplot2用户会发现这非常熟悉且易于使用。</p><figure class="mu mv mw mx fd hk"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="mu mv mw mx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es np"><img src="../Images/e9939259b47ef0739c45972338dc9517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4B_VbjCrakQGXegAjCwsHg.png"/></div></div></figure><p id="b9b2" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">不幸的是，Plotnine的视觉输出类似于Matplotlib，因为Plotnine是建立在Matplotlib的基础上的。值得庆幸的是，Plotnine的语法与Matplotlib没有任何相似之处，但输出无法像Altair或Bokeh那样清晰或漂亮，因为这一点。</p><figure class="mu mv mw mx fd hk"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="mu mv mw mx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nq"><img src="../Images/66ad74f8ee634c270cae7b49d5b6cbb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ez5_W-qJgzUrt4aNnagu2A.png"/></div></div></figure><p id="4d88" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">我有偏见，非常清楚:我喜欢ggplot2，我认为它是一个好工具，所以我认为将API移植到Python是一件好事。有些人会发现plotnine非常不符合pythonic(他们是对的)，这对他们来说是一个不可逾越的障碍。没关系，这是合理的批评。然而，对于R用户来说，Python的数据可视化失败是学习和有效使用它的最后一个主要障碍，这是一个非常有用的工具。它很可能不会成为任何数据可视化的终极目标，但它允许R用户在Python中充分发挥生产力，而不必首先学习新的可视化语法。</p><h1 id="3070" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">Plotly</h1><p id="c3ee" class="pw-post-body-paragraph jh ji hy jk b jl lh jn jo jp li jr js kg lj jv jw kh lk jz ka ki ll kd ke kf hb bi translated">Python中的Plotly有两种不同的语法——Plotly Express和Plotly Graph Objects。Plotly Express被描述为“Plotly的易于使用的高级界面”，推荐给新用户使用。另一方面，Graph Objects既是Plotly Express下的框架，也是提供更多灵活性和选项的独立模块。我的经验是，Plotly Express是一个合理的起点，但是许多(如果不是大多数的话)用户将达到它的极限，并希望以后过渡到图形对象——然而，这种过渡将是困难的，因为语法不一致。</p><figure class="mu mv mw mx fd hk"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="mu mv mw mx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es na"><img src="../Images/6c0e73eb313336562307ae6cd95c41af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y5TX1-YYpA07MOTtR5_iDA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">一个巧妙表达例子</figcaption></figure><p id="5416" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">尽管我有这样的抱怨，但我坚信Plotly是Python中任何3D或交互的最佳工具——散景提供了一些交互性，但Plotly在这方面做得更好，用户干预更少，并且绘图加载更快。我喜欢展示我的3D散点图来解释这些事情做得有多好，因为这是一个非常令人印象深刻的结果，但它并不容易建立。</p><figure class="mu mv mw mx fd hk"><div class="bz dy l di"><div class="my mz l"/></div></figure><figure class="mu mv mw mx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nr"><img src="../Images/b16317c4243d93ecdad14d4e15981d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93B067xkqkQfFGLtrKPrYg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">一个图形对象示例(在jupyter笔记本中，它可以向各个方向旋转)</figcaption></figure><p id="075b" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">Plotly Express有点缺乏定位，部分原因是Plotly输出在默认情况下没有吸引力。对于在Plotly Express中可以轻松构建的非常简单的情节，语法很简单，但在其他库中(如Bokeh)结果会更好看(也同样容易)。对于复杂的东西，Plotly可能有独特的能力，你需要在图形对象中工作。</p><h1 id="a38d" class="kj kk hy bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">现在怎么办？</h1><p id="be33" class="pw-post-body-paragraph jh ji hy jk b jl lh jn jo jp li jr js kg lj jv jw kh lk jz ka ki ll kd ke kf hb bi translated">所以，在我测试了所有这些情节后，你已经阅读了我所有的意见，现在你正试图为你的需要选择正确的库。我不能保证有一种灵丹妙药可以解决所有问题，但是这里有一些建议:</p><ul class=""><li id="8004" class="md me hy jk b jl jm jp jq kg mr kh ms ki mt kf mi mj mk ml bi translated">如果你需要非常复杂的交互和/或3D图形，使用Plotly。</li><li id="4b41" class="md me hy jk b jl mm jp mn kg mo kh mp ki mq kf mi mj mk ml bi translated">如果你是一个进入Python世界的R用户，使用plotnine。</li><li id="af7d" class="md me hy jk b jl mm jp mn kg mo kh mp ki mq kf mi mj mk ml bi translated">如果数据量很小，可以考虑Altair。</li><li id="4338" class="md me hy jk b jl mm jp mn kg mo kh mp ki mq kf mi mj mk ml bi translated">如果你需要一个以后不需要切换的万能工具，使用散景。它在许多不同的领域都有相当强的表现。</li></ul><p id="02b5" class="pw-post-body-paragraph jh ji hy jk b jl jm jn jo jp jq jr js kg ju jv jw kh jy jz ka ki kc kd ke kf hb bi translated">老实说，如果你有选择任何生态系统的自由，并且你非常关心可视化？使用\_(ツ)_/</p></div></div>    
</body>
</html>