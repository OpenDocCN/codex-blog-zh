<html>
<head>
<title>Optimization Techniques for your React App for better Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React应用程序的优化技术可提高性能</h1>
<blockquote>原文：<a href="https://medium.com/codex/optimization-techniques-for-your-react-app-for-better-performance-143c86663776?source=collection_archive---------6-----------------------#2021-02-11">https://medium.com/codex/optimization-techniques-for-your-react-app-for-better-performance-143c86663776?source=collection_archive---------6-----------------------#2021-02-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/9b27ae8e244fefac74e4c0564bfade16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*e6NTaitL3f9pflbGwXDmdQ.png"/></div></figure><p id="bee4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们都知道<strong class="io hj"> <em class="jk"> React </em> </strong>是著名的用于web开发的javascript框架之一。使用React开发的网络应用以其<em class="jk">速度</em>和<em class="jk">高效性能</em>而闻名。</p><p id="63f1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">虽然React提供了比其他可用框架更好的速度和效率，但我们可以通过一些简单的<strong class="io hj">优化</strong>技术为我们的应用程序增加一些效率。</p><p id="39ab" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们避免和防止<em class="jk">不必要的渲染</em>，web应用的<strong class="io hj">速度</strong>和<strong class="io hj">性能</strong>可以得到提高。</p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="81f3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们先找出父子组件中重渲染的原因。</p><p id="1e48" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">1)组件的<strong class="io hj">本地状态</strong>被<strong class="io hj">改变/更新</strong>。</p><p id="d2d5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2)传递给组件的<strong class="io hj">道具</strong>被<strong class="io hj">改变/更新</strong>。</p><p id="e7ee" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3)调用组件中的<strong class="io hj"> forceUpdate </strong></p><p id="7065" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">第三点完全取决于用户需要调用forceUpdate的用例及场景，这种用例不在我们的控制范围内，但第一点和第二点在我们的控制范围内，可以进行优化。</p><p id="a380" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们来看一个不想要的重新渲染场景</p><p id="7232" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们有两个组件，分别是<em class="jk">计数器</em> &amp; <em class="jk">计数器</em>。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es js"><img src="../Images/57c54d23415e8305c26b9f2496ef866d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*Oj-K4e7DDlNco9Rqo2N__Q.png"/></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">反控制器和反显示器</figcaption></figure><p id="3c3c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jk">计数器控制器</em>有本地状态来维持<em class="jk">计数器</em>的值。以及增加计数值的成员函数<em class="jk"> incrementCount </em>。我们已经把这个函数传递给了按钮的<em class="jk"> onClick </em>事件。</p><p id="6f4b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">计数器显示是一个显示静态字符串的简单组件。因此<em class="jk">计数器显示</em>与我们的<em class="jk">计数器控制器</em>的状态无关，不应受其状态变化的影响。</p><p id="9ec7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们已经在子组件ie中添加了一个控制台日志。<em class="jk">计数器显示</em>组件，以检查其何时被重新渲染。因此，当我们单击按钮来增加计数状态时，我们会在控制台中看到“<em class="jk">计数器显示正在重新呈现</em>”。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kb"><img src="../Images/bb37e3ab806f3eab114d31cb1fa4cac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*H9tt4mUfXI3wt5nGBDp1mQ.png"/></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">计数器显示多次重新渲染</figcaption></figure><p id="4d48" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以这是我们的反显示组件的<strong class="io hj">不想要的重新渲染</strong>。这个组件可能会在我们的应用程序中的许多地方使用，这将影响我们的应用程序性能。</p><p id="c03a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那么如何才能避免这种不必要的渲染呢？</p><p id="721e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的救星来了！</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kc"><img src="../Images/c1eb275809632f33c4fce2f84fe24b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*RsewJ8y0OsDw2m_edutPag.png"/></div></figure><blockquote class="kd ke kf"><p id="c7ed" class="im in jk io b ip iq ir is it iu iv iw kg iy iz ja kh jc jd je ki jg jh ji jj hb bi translated">在计算中，<em class="hi">内存化</em>或<em class="hi">内存化</em>是一种优化技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序。</p></blockquote></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="4c5e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">React为我们提供了一些内部使用<strong class="io hj">记忆化</strong>概念的特性。我们可以使用这个特性来防止不必要的渲染。</p><p id="06a3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">其中一个特色就是<strong class="io hj"> React.memo() </strong></p><p id="8bb7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 1) </strong> <strong class="io hj"> React.memo() </strong></p><p id="9292" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以将我们的功能组件包装在<em class="jk"> React.memo()中。</em></p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kj"><img src="../Images/082e10fe33393e3664ad377bc58c4701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*bsTD_qOpHJ-sU0lZ3m-RiA.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">备忘录包装的柜台展示</figcaption></figure><p id="b5cd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jk"> React.memo() </em>采用两个参数。要记忆的组件和其他参数是可选的比较函数。(默认情况下做一个简单的比较)</p><p id="e42a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们使用<em class="jk"> React.memo() </em>来包装我们的<em class="jk"> CounterDisplay </em>组件并检查控制台日志。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/e910cad39a6e0bbf6e66f1a90aead881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*P3tPzYVDXVd9pE0D6ztLJg.png"/></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">防止了不必要的反显示渲染。</figcaption></figure><p id="fe44" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">哇！我们可以看到，每次单击add按钮时，组件都不会重新呈现。</p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="ee5f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2)使用备忘录()</p><p id="8126" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">与React.memo()类似的是<strong class="io hj"> useMemo </strong>钩子。很多时候，我们通过执行一些数据操作操作来计算功能组件中的一些复杂的T21值，每当我们的组件或包含这个计算值的容器被重新呈现时，这个复杂的值就会被再次计算。</p><p id="19db" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这会影响性能，如果我们<strong class="io hj">减少</strong>计算复数值的次数，性能会得到优化。这可以使用useMemo钩子来完成</p><p id="195c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">useMemo hook的语法与useEffect非常相似。我们在依赖数组中传递依赖关系。必须重新计算复数值的更改值在依赖数组中传递。</p><p id="79e4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看一个使用备忘录的例子</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/6212aecdd11a3a456fd9c5ff69ebe420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*cz7rnr5vXQhfKvtc6u7-TQ.png"/></div></figure><p id="e441" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以在上面的例子中，当我们的<em class="jk">计数器显示</em>组件重新渲染时，我们的<em class="jk">魔术数字</em>总是被重新计算。但是如果我们看到<em class="jk"> magicalNumber </em>的值只依赖于count prop。因此只有当计数器属性发生变化时，才应该重新计算它。</p><p id="7097" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们将这个<em class="jk">神奇的数字</em>包装在使用备忘录中</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kq"><img src="../Images/3cea9d36fe1cb8ebd4ffb2b725922ef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9IL3VOHc-AKkBgftJMaNWQ.png"/></div></div></figure><p id="0cf2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果相关性没有改变或更新，则存储并使用先前计算的值。这减少了组件不必要的重新计算和重新渲染。</p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><p id="4613" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 3)使用回调</strong></p><p id="037a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们看一个带有额外组件的相同示例。我们将创建一个新的<em class="jk">重置计数器</em>组件，它将重置计数器状态。</p><p id="ec23" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们在父组件<em class="jk">反控制器</em>中定义<em class="jk">重置计数</em>函数，并将其作为prop传递给子组件<em class="jk">重置计数</em>。在<em class="jk">重置计数器</em>组件中添加一个控制台日志，以检查它何时被重新渲染。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/9a8a05e9ecc8e389198942c58f9363e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*dgCoBteyy51xRYXJRZqJ_A.png"/></div></figure><p id="d9c1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以看到，在增加计数时，我们的<em class="jk"> ResetCounter </em>组件得到了不必要的重新呈现。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/144e3381dce3baa5038ce79088f0fa37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*G5ozODNgcmHTSRNpVY2nFQ.png"/></div></figure><p id="8cf6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以通过使用react ie提供的另一个特性来避免这种情况。<strong class="io hj">使用回调</strong></p><p id="c348" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的子组件被不必要地重新呈现，因为每当父组件被重新呈现时，一个新的成员函数引用被创建，该引用被进一步传递给子组件。每次重新渲染时，都会创建新的引用，它会强制子组件重新渲染。</p><p id="06c1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> useCallback </strong>通过记忆函数引用来避免这种情况，只有当它的任何一个依赖项被更新时，函数才会被重新创建。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/6111faaef000d415aea445e6d376f0fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*Fwu4fiNeZGXyMgFRjAFUdQ.png"/></div></figure><p id="b7d9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在包装了useCallback之后，我们可以看到我们的子组件在计数改变时没有被重新呈现。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es ku"><img src="../Images/68ec5ee7f97d6fd16ab50073a203f8b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*q3pw3ik_0OBTu8_L3Ag_1w.png"/></div></figure><p id="3c2d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">答对了。！我们通过避免不必要的重新渲染优化了应用性能。</p><p id="a3c3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，遵循编码实践，我们可以提高应用程序的性能。但是正如我们所知，每样东西都有它自己的缺点，所以我们应该准确地使用这个特性，否则它可能会给我们带来不必要的错误。</p><p id="dd9f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">今天到此为止。谢谢大家！</p></div></div>    
</body>
</html>