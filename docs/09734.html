<html>
<head>
<title>Write production-ready optimized Dockerfile for Spring Boot application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Spring Boot应用程序编写生产就绪的优化docker文件</h1>
<blockquote>原文：<a href="https://medium.com/codex/write-production-ready-optimized-dockerfile-for-spring-boot-application-8fec0906a894?source=collection_archive---------5-----------------------#2022-11-06">https://medium.com/codex/write-production-ready-optimized-dockerfile-for-spring-boot-application-8fec0906a894?source=collection_archive---------5-----------------------#2022-11-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b073976143386efaa24117b2ad5ee57b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DB_MrUJLMmXD7Fmr"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@carrier_lost?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊恩·泰勒</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="e3f4" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">Dockerfile文件</h1><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">优化的多级Dockerfile文件</figcaption></figure><h1 id="f60a" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">第一阶段—建造者</h1><p id="e64c" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我使用多阶段Docker构建来创建图像。在第一阶段，我使用<code class="du kx ky kz la b">maven-3.8.3-openjdk-17</code>作为我的基本映像，并将pom.xml和代码库复制到映像中。使用<code class="du kx ky kz la b">mvn package</code>命令，我构建了一个超级jar，在一个JAR文件中包含了包<em class="lb">和</em>及其所有依赖项。</p><p id="7e2c" class="pw-post-body-paragraph jz ka hi kb b kc lc ke kf kg ld ki kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">这个超级jar可以轻松达到400MB或更多。这意味着对于每一次新的构建，甚至是应用程序中最简单的代码更改:</p><ul class=""><li id="12ce" class="lh li hi kb b kc lc kg ld kk lj ko lk ks ll kw lm ln lo lp bi translated">将创建一个新的400MB层</li><li id="6bd1" class="lh li hi kb b kc lq kg lr kk ls ko lt ks lu kw lm ln lo lp bi translated">该图层将上传到您的OCI注册表中</li><li id="a770" class="lh li hi kb b kc lq kg lr kk ls ko lt ks lu kw lm ln lo lp bi translated">当Kubernetes将最新的图像拉至运行容器的节点时，将需要拉取整个400 MB的层。</li></ul><p id="d3ca" class="pw-post-body-paragraph jz ka hi kb b kc lc ke kf kg ld ki kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">这将发生在每次代码更改和映像重建时。事实上，只有很小一部分编译后的代码发生了变化。Dockerfile将每个新行视为一个新层，因此将第三方依赖项放在它们自己的层中，并将我们的自定义代码放在自己的层中会更有意义。从2.3开始，Spring boot提供了一种将jar分解成层的方法。</p><h1 id="d026" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">分层</h1><p id="3d59" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">代替<em class="lb">运行</em>Spring Boot应用程序，将参数<code class="du kx ky kz la b">-Djarmode=layertools list</code>传递给java命令将简单地列出对Spring Boot应用程序有意义的层。在我们的案例中，这些是:</p><ul class=""><li id="30c3" class="lh li hi kb b kc lc kg ld kk lj ko lk ks ll kw lm ln lo lp bi translated"><strong class="kb hj">依赖关系</strong>——Spring Boot和其他框架基于发布的依赖关系。这些只有在我们升级到Spring Boot版本或第三方框架版本时才会改变。</li><li id="48ef" class="lh li hi kb b kc lq kg lr kk ls ko lt ks lu kw lm ln lo lp bi translated"><strong class="kb hj"> Spring Boot加载器</strong>——这是将我们的Spring Boot应用程序加载到JVM中的代码，以管理bean的生命周期，等等。这也很少改变。</li><li id="be21" class="lh li hi kb b kc lq kg lr kk ls ko lt ks lu kw lm ln lo lp bi translated"><strong class="kb hj">快照依赖关系</strong> —这些依赖关系的变化更加频繁。有可能在每个新版本中，我们都需要获取最新的快照。因此，这一层最接近我们的应用程序代码。</li><li id="ec33" class="lh li hi kb b kc lq kg lr kk ls ko lt ks lu kw lm ln lo lp bi translated"><strong class="kb hj">应用</strong> —这是我们来自<code class="du kx ky kz la b">src/main/java</code>的应用代码(对于maven来说)。</li></ul><p id="1751" class="pw-post-body-paragraph jz ka hi kb b kc lc ke kf kg ld ki kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">使用<code class="du kx ky kz la b">Djarmode=layertools extract</code>命令将图层提取到目标目录。</p><h1 id="4003" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">第二阶段— Spring Boot应用</h1><p id="2432" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在下一个阶段，我们使用openjdk-17作为基础图像，并将前一阶段的图层逐个复制到当前阶段的图像。由于Dockerfile中的每一行都创建了一个可以缓存的单独层，这在下一次只有代码更改而没有依赖关系更改时会有所帮助，这意味着Docker可以重用旧的依赖关系缓存层。这有助于优化构建时间。</p><p id="8e4d" class="pw-post-body-paragraph jz ka hi kb b kc lc ke kf kg ld ki kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">此后，我公开了Spring Boot将运行的端口，并切换到一个非root用户。最后一行加载并运行Spring Boot应用程序。</p><h1 id="08cb" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">自定义图层</h1><p id="ab11" class="pw-post-body-paragraph jz ka hi kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我有自己的一组依赖项，不属于Spring提供的依赖项。例如，我有一个连接到文件存储服务的自定义库。将这样的依赖项提取到它们自己的层中是有意义的，因为它比Spring依赖项更频繁地变化。为此，我创建了一个自定义层配置:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">在Spring Boot创建自定义图层</figcaption></figure><p id="55b7" class="pw-post-body-paragraph jz ka hi kb b kc lc ke kf kg ld ki kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">始终以这样的方式对层进行排序，即变化最小的层在开始，变化较频繁的层在最后。</p><p id="2028" class="pw-post-body-paragraph jz ka hi kb b kc lc ke kf kg ld ki kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated">要在应用中应用该配置，将<code class="du kx ky kz la b">spring-boot-maven-plugin</code>指向自定义层配置:</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/a95eb23154a1d3cc487118a460e59158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k5Gk6mibyd8opwcQv_JgJg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在Spring Boot maven插件中包含自定义层文件</figcaption></figure></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="8dca" class="pw-post-body-paragraph jz ka hi kb b kc lc ke kf kg ld ki kj kk le km kn ko lf kq kr ks lg ku kv kw hb bi translated"><em class="lb">如果你喜欢这篇文章，请花点时间为我鼓掌👏(可以多次鼓掌)，跟着我，甚至给我买杯咖啡</em><a class="ae iu" href="https://www.buymeacoffee.com/abhiandy" rel="noopener ugc nofollow" target="_blank">https://www.buymeacoffee.com/abhiandy</a></p></div></div>    
</body>
</html>