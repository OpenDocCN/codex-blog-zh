<html>
<head>
<title>C# — Object-Oriented Programming (OOP)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C# —面向对象编程(OOP)</h1>
<blockquote>原文：<a href="https://medium.com/codex/c-object-oriented-programming-oop-2d92a5cd336f?source=collection_archive---------1-----------------------#2022-10-27">https://medium.com/codex/c-object-oriented-programming-oop-2d92a5cd336f?source=collection_archive---------1-----------------------#2022-10-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a62d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用C#解释面向对象编程的基本概念</h2></div><p id="893a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">人类思考面向对象。他们从桌子、椅子、人等物体的角度来思考问题。面向对象的编程语言模仿人类思维，包含对象的抽象。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/24831e3f2c5b032df49c301ebc9fa117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2zaVQgYpZO5yUjkR_uZflQ.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated"><a class="ae kj" href="https://unsplash.com/photos/DuHKoV44prg" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/DuHKoV44prg</a></figcaption></figure><p id="5593" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kk">向我的兄弟和导师</em> <a class="ae kj" rel="noopener" href="/@tobias.streng"> <strong class="iz hj"> <em class="kk">托比亚斯·斯特兰</em></strong></a><em class="kk">——</em><br/><em class="kk">如果你喜欢这篇文章，并想在。</em> <strong class="iz hj"> <em class="kk">网</em> </strong> <em class="kk">和</em> <strong class="iz hj"> <em class="kk">角</em> </strong> <em class="kk">，请关注我们:P </em></p><h1 id="677e" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">内容:</h1><ul class=""><li id="02a3" class="ld le hi iz b ja lf jd lg jg lh jk li jo lj js lk ll lm ln bi translated">类别和对象</li><li id="8dcd" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated">方法</li><li id="7adf" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated">构造函数和析构函数</li><li id="07d9" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated">包装</li><li id="c432" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated">访问修饰符</li><li id="6040" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated">Getters和Setters</li><li id="1710" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated">代表</li><li id="0742" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated">遗产</li><li id="2ff6" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated">无商标消费品</li><li id="25be" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated">抽象类和接口</li><li id="ae37" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated">静态类和静态方法</li></ul><h1 id="06d8" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">类别和对象:</h1><p id="dace" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">面向对象描述了一种更好地可视化编写的源代码的方法。它是软件开发中的一个视角，使用对象描述复杂的系统，并为此使用类和方法。<br/>所以类的实例就是对象。为了更精确地说明一个类的这个原理，这个人作为一个例子。所有人都有某些特征，比如名字或出生日期。每个特别的人都是一件物品。如果现在将属性分配给人物类，例如姓名、年龄、身高和性别，则人物的表面形象逐渐显现。创建类时，指定的属性还没有任何值，因为这里只通过指定相应属性所源自的数据类型来确定后面的对象应该具有哪些属性。在这里，用一种蓝图来定义一个人是什么。<br/>如果需要单个对象，可以使用new()命令创建一个Person类的实例。构造函数被调用，开发人员有机会赋值。例如，这里我们可以创建名为Peter的人，年龄41岁，身高1.82，性别男。Peter是Person类的实例/有形体。一个对象也可以包含方法。<strong class="iz hj">一个例子显示了“方法”后的图片</strong></p><h1 id="dfa4" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">方法:</h1><p id="29a8" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">方法可以理解为一种“子程序”,其中可以组合程序的某些功能。定义方法有不同的方式。使用 <strong class="iz hj"> public和private </strong>关键字，可以使方法<strong class="iz hj">对项目中的其他全局类可见或不可见。也可以定义一个<strong class="iz hj">返回数据类型</strong>，例如，当方法被调用时，它可以被赋值为一个变量。这在方法体中用关键字<em class="kk"> return </em>返回，并在方法头中作为各自的数据类型提供，例如integer。如果这不是必需的，关键字<strong class="iz hj"> void </strong>被写在方法头的相同位置。此外，方法可以包含和使用参数。一个方法可以被绑定到一个对象，方法不被定义为静态的，而是在定义对象蓝图的类中被创建。例如，在前面的Person示例中，您可以添加go()方法。如果该方法不是静态的，则只有在使用类实例(即对象)后面的点标记进行调用时，才能调用该方法。但是，如果要调用的方法没有绑定到对象，可以用关键字static将其定义为static。</strong></p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lw"><img src="../Images/203a9a3be43c409fbe9033cdcac9ba83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVuzErC7PvF1gursxWEsLA.png"/></div></div></figure><h2 id="8702" class="lx km hi bd kn ly lz ma kr mb mc md kv jg me mf kx jk mg mh kz jo mi mj lb mk bi translated">下面是一些基本的例子:</h2><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es ml"><img src="../Images/71be24cf647b5088bfac6f32e9a5a268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u1HAeBUvhI2EQR5dh4pMyw.png"/></div></div></figure><h1 id="a064" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">构造函数和析构函数:</h1><p id="89b8" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated"><strong class="iz hj">构造函数</strong>是一个特殊的函数，在初始化一个类时被调用。构造函数的名字总是对应于类名。该函数没有返回值(甚至没有void ),因为构造函数返回新初始化的对象。如果类中没有创建构造函数，那么总会有一个所谓的默认构造函数，它不执行任何进一步的操作。默认构造函数没有参数。但是，这可以在实现自己的构造函数时进行更改。也可以重载构造函数。重要的是要知道，一旦在类中声明了构造函数，C#自动创建的默认构造函数就不再存在。构造函数的访问修饰符通常是公共的。如果private被用作访问修饰符，那么这个类的对象初始化就不再可能。因此，私有构造函数用于防止只包含静态函数的类的对象初始化。</p><p id="e7bb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">析构函数</strong>与构造函数相反，因为当对象被销毁/删除时，析构函数被调用。如前所述，一旦对象的。NET Framework再也找不到引用。如果程序当前没有要处理的进程或者存储空间很关键，垃圾收集器(GC)会自动删除这些对象。此外，还可以使用GC类的静态函数Collect()手动触发未引用对象的删除。析构函数的名称也与类名相同，但以波浪符号为前缀。此外，不能为析构函数指定访问修饰符和返回值</p><h1 id="5b72" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">封装:</h1><p id="e46f" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">封装被定义为将数据包装成一个单元。它是将代码和它所处理的数据绑定在一起的机制。另一方面，封装是一个保护屏障，防止屏障之外的代码访问数据。</p><p id="6122" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从技术上讲，在封装中，一个类的变量或数据对任何其他类都是隐藏的，只能通过声明它们的类的任何成员函数来访问。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mm"><img src="../Images/9274ddc99f77d2d0ab1c8a2e9bba16bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H3YbX4P_AdmdDHAyj2xZjg.png"/></div></div></figure><h1 id="4d09" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">访问修饰符:</h1><p id="7c61" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">所有类型和类型成员都有一个可访问性级别。可访问性级别控制它们是否可以从您的程序集中的其他代码或其他程序集中使用。一个<a class="ae kj" href="https://learn.microsoft.com/en-us/dotnet/standard/glossary#assembly" rel="noopener ugc nofollow" target="_blank">组件</a>就是一个<em class="kk">。dll </em>或<em class="kk">。exe </em>通过编译一个或多个<em class="kk">创建。cs </em>文件进行单次编译。在声明类型或成员时，使用下列访问修饰符指定其可访问性:</p><ul class=""><li id="7de4" class="ld le hi iz b ja jb jd je jg mn jk mo jo mp js lk ll lm ln bi translated"><a class="ae kj" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/public" rel="noopener ugc nofollow" target="_blank"> public </a>:该类型或成员可以被同一程序集中的任何其他代码或引用它的另一个程序集中的任何其他代码访问。类型的公共成员的可访问性级别由类型本身的可访问性级别控制。</li><li id="4976" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated"><a class="ae kj" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private" rel="noopener ugc nofollow" target="_blank"> private </a>:该类型或成员只能被同一个<code class="du mq mr ms mt b">class</code>或<code class="du mq mr ms mt b">struct</code>中的代码访问。</li><li id="8d77" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated"><a class="ae kj" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected" rel="noopener ugc nofollow" target="_blank">受保护的</a>:该类型或成员只能由同一个<code class="du mq mr ms mt b">class</code>中的代码访问，或者由该<code class="du mq mr ms mt b">class</code>派生的<code class="du mq mr ms mt b">class</code>中的代码访问。</li><li id="1e32" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated"><a class="ae kj" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/internal" rel="noopener ugc nofollow" target="_blank">内部</a>:该类型或成员可以被同一程序集中的任何代码访问，但不能从另一个程序集中访问。换句话说，<code class="du mq mr ms mt b">internal</code>类型或成员可以从属于同一编译的代码中访问。</li><li id="8ea2" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated"><a class="ae kj" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected-internal" rel="noopener ugc nofollow" target="_blank">受保护的内部</a>:类型或成员可以被声明它的程序集中的任何代码访问，或者从另一个程序集中的派生<code class="du mq mr ms mt b">class</code>中访问。</li><li id="bf94" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated"><a class="ae kj" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private-protected" rel="noopener ugc nofollow" target="_blank"> private protected </a>:该类型或成员可以被从<code class="du mq mr ms mt b">class</code>派生的类型访问，这些类型在其包含的程序集中声明。</li></ul><h1 id="62d1" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">Getters和Setters:</h1><p id="73dd" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">访问器方法，也称为getter和setter方法，是允许访问变量的方法，从而提供对变量的值进行控制的能力。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mu"><img src="../Images/857e26c4480f7009b050fac6f96bc717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thTYJDXiPxueWHaV2xQkxw.png"/></div></div></figure><p id="1e23" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">它们是允许类的属性被使用或改变的方法</strong></p><h2 id="0f16" class="lx km hi bd kn ly lz ma kr mb mc md kv jg me mf kx jk mg mh kz jo mi mj lb mk bi translated">如果我不设置getters和setters会怎么样？</h2><p id="e3b7" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">在这种情况下，设置属性<strong class="iz hj">不是属性而是字段。</strong></p><h2 id="3f42" class="lx km hi bd kn ly lz ma kr mb mc md kv jg me mf kx jk mg mh kz jo mi mj lb mk bi translated">字段与属性:</h2><p id="872a" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">一个<strong class="iz hj">字段</strong>将数据存储为一个变量。它可以被公开，然后通过类调用，但是限制和隐藏尽可能多的数据是一个好主意。通过确保某人只能通过该类的一个公共方法来访问数据，这给了您更多的控制并避免了意外的错误。</p><p id="abe4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个<strong class="iz hj">属性</strong>公开了字段。直接使用属性而不是字段提供了一个抽象层次，在这个层次上，您可以修改字段，而不会影响使用您的类的对象访问它们的外部方式。属性还允许您在设置字段值或确保数据有效之前执行计算</p><h1 id="3e0f" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">代表们:</h1><p id="7450" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">委托是一种表示对具有特定参数列表和返回类型的方法的引用的类型。实例化委托后，可以将该实例与任何具有兼容签名和返回类型的方法相关联。您可以通过委托实例调用方法。<br/> <strong class="iz hj">或者简单点说:<br/>委托是在变量中存储一个或多个方法的一种方式。</strong></p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mv"><img src="../Images/ac7f9f16c04af2076f0f782c54cfc873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxzTDHivIhBpAYJ_ZkZ3ww.png"/></div></div></figure><p id="a70b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">如你所见，我们还被允许在一个委托中添加多个方法。</strong></p><h1 id="0d2f" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">继承:</h1><p id="fa64" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">在继承中，子类继承其父类的所有属性(数组和方法——即结构和行为),并添加自己的单独属性或重写父类的方法。父类的属性不必在子类的规范中重复。据说子类是从父类派生出来的。因此，继承的原则简单地说明了类中所有可以从超类继承的属性和方法。下图说明了继承的原理:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mw"><img src="../Images/6adcaae72810f19ca1204aa32e2b0344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cjHxZc8E5PAJnooWlpO59g.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated"><a class="ae kj" href="https://blog.4d.com/object-oriented-programming-in-4d-manage-class-inheritance/" rel="noopener ugc nofollow" target="_blank">https://blog . 4d . com/object-oriented-programming-in-4d-manage-class-inheritance/</a></figcaption></figure><p id="37bf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以看出，教师和学生也是人，但他们被定义为一个独立的阶层。因为两者都需要超类Person及其方法的所有属性，所以这里使用了继承。通过使用继承，两个子类都不必实现在超类中实现的属性和方法，而是可以从Person类中继承它们并为自己所用。此外，子类中还可以使用其他属性和方法。自上而下的过程因此被称为<strong class="iz hj">专业化</strong>，而自下而上的过程被称为<strong class="iz hj">一般化</strong>。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mx"><img src="../Images/d275b16ef2762a03b539dd6f2e755d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H3WeqcCdtIAlt6fWQVq_cw.png"/></div></div></figure><h1 id="6e1b" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">仿制药:</h1><p id="df41" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">在C#中，可以使用泛型创建映射到其他数据类型的数据类型。当您希望创建一个足够灵活的数据类型来处理不同的数据类型时，这很有用。例如，您可以创建一个包含任何数据类型项目的列表。当您想要创建包含不同数据类型的对象列表时，这很有用。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es my"><img src="../Images/6ff555e3234ac0ca3fbc822ce25b2c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*9YdYdHOsui2Tjhpe3yEt5Q.png"/></div></figure><h1 id="3a9b" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">抽象类和接口</h1><p id="cbe2" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated"><strong class="iz hj">关于接口的更多具体信息，请查看我的文章</strong> <a class="ae kj" rel="noopener" href="/@sebastianstreng96/net-c-clean-architecture-dependency-inversion-principle-7ea64f586c58"> <strong class="iz hj">清洁架构&amp;依赖倒置</strong> </a></p><h2 id="44de" class="lx km hi bd kn ly lz ma kr mb mc md kv jg me mf kx jk mg mh kz jo mi mj lb mk bi translated">抽象类:</h2><p id="fab7" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">在编程中，抽象类是不能为其创建对象实例的类。例如，当应用继承时，这种行为变得相关。正如已经解释过的，各种子类从超类继承而来。作为一名程序员，您可以选择自己调用超类，尽管它是一般化的，并没有给开发人员任何关于该类的专门见解。在这种情况下，可以创建Person类的一个<strong class="iz hj">实例，尽管它从来不需要</strong>。唯一需要的实例是教师或学生类型的。使用<em class="kk">抽象</em>关键字将超类定义为抽象类，这意味着<strong class="iz hj">不能再创建更多的实例</strong>。只有<strong class="iz hj">子类可以继续创建实例</strong>，这可以显著降低开发中出错的可能性。</p><h2 id="7572" class="lx km hi bd kn ly lz ma kr mb mc md kv jg me mf kx jk mg mh kz jo mi mj lb mk bi translated">接口:</h2><p id="e198" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">接口也代表抽象。接口首先充当实现该接口的类的一种模板。定义了方法，也可能定义了属性，但是它们没有值或功能。这样做的目的是指示实现该接口的类应该使用哪些方法。为了更准确地理解这个原理，你可以使用一个带有数据库的程序。假设源代码定义了一个读取数据库的部分、一个处理数据库中的条目的部分和一个输出处理过的数据的部分，那么在之后改变数据库<strong class="iz hj">可能会有问题。然而，如果从一开始就定义了选择类的必需方法，<strong class="iz hj">剩余的类独立于这个类</strong>。在其他类中，已经定义的方法和以前一样被调用。在选择类中定义的方法满足接口指定的准则的条件下，开发人员可以选择将数据库替换为另一个数据库，而无需在源代码的其他地方进行更改。例如，方法的准则可以是参数、返回值或通过关键字public和private的全局可访问性。实现接口的类必须包含接口的所有属性和方法，但它也可以使用其他方法或属性。与继承的不同之处在于，方法是空的，并且<strong class="iz hj">只是作为一个模板。</strong> <br/>在面向对象语言中，实现一个接口的类也可以通过接口直接调用，这也是为什么它们也被称为接口的原因。这里用到的原理是<strong class="iz hj"> </strong> <a class="ae kj" rel="noopener" href="/@sebastianstreng96/net-c-clean-architecture-dependency-inversion-principle-7ea64f586c58"> <strong class="iz hj">依赖反转原理</strong> </a>。正如已经解释过的，接口的使用促进了类的独立性，也确保了整个项目更少的错误敏感性，更好的软件架构和干净的编程。</strong></p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mz"><img src="../Images/64010fff3c5a27244859fb49b3ab1830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1OIt0URGx_GmuhLvWAIjSw.png"/></div></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es na"><img src="../Images/353b8091166d3006b68bad56833457fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBIrhxjRrCprydUll7FnAg.png"/></div></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es nb"><img src="../Images/e80485c7f78fc4f6270613724d5a35fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Brs5ELgatVaVBndBcidFdw.png"/></div></div></figure><h1 id="b19d" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">静态类和静态方法:</h1><p id="31c9" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">static是一个关键字，可以用来标识类、方法等等。声明为静态。静态意味着您不能实例化(创建一个对象)这种类型。所以不能创建静态类的对象，也不能访问静态成员(字段、属性、方法等。)通过一个对象。相反，您可以通过类名来访问成员。</p><h1 id="779d" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">结论:</h1><p id="b916" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">总而言之，面向对象的概念对于程序员来说是非常有用的。它可以让初学者更好地理解编程。即使是有经验的程序员也会从OOP的使用中受益匪浅。我希望你喜欢这篇文章，并订阅我的频道</p><h1 id="778c" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">请查看我的其他文章:</h1><ul class=""><li id="579a" class="ld le hi iz b ja lf jd lg jg lh jk li jo lj js lk ll lm ln bi translated"><a class="ae kj" rel="noopener" href="/codex/linq-how-to-avoid-nested-loops-in-c-ed4ae19886e4">LINQ——如何避免C#中的嵌套循环</a></li><li id="16cd" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated"><a class="ae kj" rel="noopener" href="/dev-genius/net-c-clean-architecture-dependency-inversion-principle-7ea64f586c58">。Net C# —干净的架构&amp;依赖-反转-原则</a></li><li id="ac7c" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated"><a class="ae kj" rel="noopener" href="/dev-genius/programming-paradigms-a-very-short-brief-5324908640bd">编程范例—简介</a></li><li id="d258" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated"><a class="ae kj" rel="noopener" href="/@sebastianstreng96/c-single-responsibility-easily-explained-e3fabbf0d877"> C# —简单解释的单一责任</a></li><li id="6694" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated"><a class="ae kj" rel="noopener" href="/@sebastianstreng96/ocp-what-really-matters-610159d600dc">OCP——真正重要的是什么</a></li><li id="495a" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated"><a class="ae kj" rel="noopener" href="/@sebastianstreng96/top-8-tips-to-improve-your-motivation-as-programmer-be63b2baaf7e">提高程序员积极性的8大技巧</a></li><li id="01cb" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated"><a class="ae kj" rel="noopener" href="/codex/a-brief-insight-into-networks-2171f1e9aea1">对网络的简要了解</a></li><li id="335f" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated"><a class="ae kj" rel="noopener" href="/codex/send-receive-the-7-layer-osi-model-e475829b999">发送&amp;接收—7层OSI模型</a></li><li id="5cf3" class="ld le hi iz b ja lo jd lp jg lq jk lr jo ls js lk ll lm ln bi translated"><a class="ae kj" rel="noopener" href="/@sebastianstreng96/7-layer-network-protocols-easily-explained-e11e3e09f34d">七层网络协议浅显易懂</a></li></ul><h1 id="bec1" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">来源:</h1><div class="nc nd ez fb ne nf"><a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hj fi z dy nk ea eb nl ed ef hh bi translated">访问修饰符- C#编程指南</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">所有类型和类型成员都有一个可访问性级别。可访问性级别控制是否可以从…使用它们</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">learn.microsoft.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt kd nf"/></div></div></a></div><div class="nc nd ez fb ne nf"><a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hj fi z dy nk ea eb nl ed ef hh bi translated">委托- C#编程指南</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">委托是一种表示对具有特定参数列表和返回类型的方法的引用的类型。当你…</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">learn.microsoft.com</p></div></div><div class="no l"><div class="nu l nq nr ns no nt kd nf"/></div></div></a></div><div class="nc nd ez fb ne nf"><a href="https://www.das-grosse-computer-abc.de/CSharp/Objektorientierung/Konstruktor-Destruktor" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hj fi z dy nk ea eb nl ed ef hh bi translated">计算机基础知识</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">构造函数是一个特殊的函数，我们将它初始化为一个类…</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">www.das-grosse-computer-abc.de</p></div></div><div class="no l"><div class="nv l nq nr ns no nt kd nf"/></div></div></a></div></div></div>    
</body>
</html>