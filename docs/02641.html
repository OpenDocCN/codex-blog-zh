<html>
<head>
<title>The UseEffect() Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UseEffect()挂钩</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-useeffect-hook-261b0cafaf1e?source=collection_archive---------21-----------------------#2021-07-29">https://medium.com/codex/the-useeffect-hook-261b0cafaf1e?source=collection_archive---------21-----------------------#2021-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/7633de8d848e5ea2c596a3ed9e30e442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BOr3jQIpiGcTuMwL"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">由<a class="ae hv" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ferenc Almasi </a>在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="ee60" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated">在处理代码中的副作用时，如何实现React.useEffect()</h2></div><p id="fae3" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你好！今天我想把事情稍微改变一下，回顾一下其中一个更令人困惑的React钩子。没错，读者们，我说的是<code class="du kj kk kl km b"><em class="kn">React.useEffect()</em></code> <em class="kn"> </em>及其对DOM更新后需要运行的效果的处理方式。我今天在这里帮助你看到这个钩子实际上很容易使用，它的多功能性是没有什么可怕的。让我们直接跳进来吧！</p><h1 id="e082" class="ko kp hy bd kq kr ks kt ku kv kw kx ky je kz jf la jh lb ji lc jk ld jl le lf bi translated">反应钩</h1><p id="0e5f" class="pw-post-body-paragraph jn jo hy jp b jq lg iz js jt lh jc jv jw li jy jz ka lj kc kd ke lk kg kh ki hb bi translated">正如我们所知，React在16.8版本中发布了钩子，让开发人员社区想知道基于类的组件是否会成为过去。基于函数的组件现在有办法声明和更新状态，而不需要原型继承或将事件处理程序绑定到构造函数。显然，事情并没有那样发展，但是使用钩子的基于功能的组件仍然是管理状态的可靠方法。</p><p id="d99d" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">基于函数的组件可能有一种用<code class="du kj kk kl km b">useState</code>钩子初始化和更新状态的方法，但是如果不使用另一个React钩子<code class="du kj kk kl km b">useEffect</code>，它们仍然没有暴露给它们的生命周期方法。<code class="du kj kk kl km b">useEffect</code>钩子只不过为我们的代码提供了一种在DOM更新后处理副作用的方法。React.js文档提供了一个全面的场景，其中<code class="du kj kk kl km b">useEffect</code>可以在DOM更新后更新一个值。在示例中，<code class="du kj kk kl km b">useEffect</code>取代了生命周期方法<code class="du kj kk kl km b">componentDidMount</code>和<code class="du kj kk kl km b">componentDidUpdate</code>，这两个方法分别在初始渲染和后续重新渲染时执行。下面的例子展示了一个简单的<code class="du kj kk kl km b">useEffect</code>实现，它将状态集成到DOM中，并从DOM中取消订阅。</p><figure class="ll lm ln lo fd hk"><div class="bz dy l di"><div class="lp lq l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">使用useEffect更新用户的在线状态(来自<a class="ae hv" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> React Hooks文档</a></figcaption></figure><p id="5e19" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">React中的Effect hook提供了一个解决方案，用于利用基于函数的组件中的副作用，包括对事件处理程序的控制，该事件处理程序将在初始呈现后侦听依赖项值的变化。组件初始渲染后，朋友状态的任何变化都会触发<code class="du kj kk kl km b">useEffect</code>订阅他们的在线状态。上面的例子包含了第二个参数。使用这个作为第二个参数传递的空依赖数组，以便<code class="du kj kk kl km b">useEffect</code>仅在初始渲染之后执行，而不是在任何重新渲染期间执行。</p><h1 id="0700" class="ko kp hy bd kq kr ks kt ku kv kw kx ky je kz jf la jh lb ji lc jk ld jl le lf bi translated">依赖数组</h1><p id="8a2e" class="pw-post-body-paragraph jn jo hy jp b jq lg iz js jt lh jc jv jw li jy jz ka lj kc kd ke lk kg kh ki hb bi translated">依赖数组用于提供一个监听源，该监听源将在组件最初渲染时和任何重新渲染后触发<code class="du kj kk kl km b">useEffect</code>。如果这个值在以后发生变化，这将导致组件的重新呈现，并且由<code class="du kj kk kl km b">useEffect</code>返回的函数将执行来清除这个副作用(在上面的例子中，它将取消订阅一个朋友的状态变化)。如果没有这个依赖数组，<code class="du kj kk kl km b">useEffect</code>将执行它的默认行为，每次重新渲染时都会发生。缺乏必要的依赖会导致代码中的无限循环，所以让我们避免这种情况。</p><p id="aed8" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">今天到此为止！查看下面的相关资源列表，包括一些关于useEffect及其功能的视频。非常感谢您的阅读！下次见！</p><h1 id="992c" class="ko kp hy bd kq kr ks kt ku kv kw kx ky je kz jf la jh lb ji lc jk ld jl le lf bi translated">引用的消息来源</h1><blockquote class="lr ls lt"><p id="6e7c" class="jn jo kn jp b jq jr iz js jt ju jc jv lu jx jy jz lv kb kc kd lw kf kg kh ki hb bi translated">拉森，约翰。<em class="hy"> React Hooks in Action:带悬疑并发模式</em>。第三版。，曼宁出版公司，2020年，第98–110页。</p><p id="7ae2" class="jn jo kn jp b jq jr iz js jt ju jc jv lu jx jy jz lv kb kc kd lw kf kg kh ki hb bi translated">网络忍者。"全反应教程# 14——使用效果钩子(基础)."<em class="hy"> Youtube </em>，Youtube，2021年1月6日，<a class="ae hv" href="https://www.youtube.com/watch?v=gv9ugDJ1ynU." rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=gv9ugDJ1ynU.</a></p><p id="3fa3" class="jn jo kn jp b jq jr iz js jt ju jc jv lu jx jy jz lv kb kc kd lw kf kg kh ki hb bi translated">— -."完整反应教程# 15——使用效果依赖."<em class="hy"> Youtube </em>，Youtube，2021年1月7日，<a class="ae hv" href="https://www.youtube.com/watch?v=jQc_bTFZ5_I." rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=jQc_bTFZ5_I.</a></p><p id="b071" class="jn jo kn jp b jq jr iz js jt ju jc jv lu jx jy jz lv kb kc kd lw kf kg kh ki hb bi translated">"使用效果挂钩—反应."<em class="hy">React——一个用于构建用户界面的JavaScript库</em>，<a class="ae hv" href="https://reactjs.org/docs/hooks-effect.html." rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-effect.html.</a>2021年7月27日访问。</p></blockquote></div></div>    
</body>
</html>