<html>
<head>
<title>Write Clean Code with SOLID Design Principles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用可靠的设计原则编写干净的代码</h1>
<blockquote>原文：<a href="https://medium.com/codex/write-clean-code-with-solid-design-principles-65fb225139d7?source=collection_archive---------11-----------------------#2022-10-29">https://medium.com/codex/write-clean-code-with-solid-design-principles-65fb225139d7?source=collection_archive---------11-----------------------#2022-10-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/73f41c87bbb518633c1fb3b726fd7793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lwAMcZVGL8xSLPAy7pzvDw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="http://andrew-thornton.blogspot.com/2011/06/weekly-word-solid.html" rel="noopener ugc nofollow" target="_blank">固体</a></figcaption></figure><h2 id="f788" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">介绍</h2><p id="8f2e" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated"><strong class="jv hj"> SOLID </strong>实际上是一个首字母缩写词，代表5种不同的软件设计原则，由Robert C. Martin(又名Bob叔叔)提出。我们应该研究它们的原因是，这些设计原则在设计模式文献中经常被引用。所以这些原则是:</p><ul class=""><li id="44a6" class="ko kp hi jv b jw kq ka kr jg ks jk kt jo ku kn kv kw kx ky bi translated">单一责任原则</li><li id="54a7" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated"><strong class="jv hj"> O: </strong>开闭原理</li><li id="315e" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated"><strong class="jv hj"> L: </strong>利斯科夫替代原理</li><li id="895e" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated"><strong class="jv hj"> I: </strong>界面偏析原理</li><li id="5f2e" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated"><strong class="jv hj"> D: </strong>依存倒置原则</li></ul><p id="7da8" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">它们非常受欢迎，因为当我们设计软件系统时，它们非常重要。这些不是你需要知道的唯一的设计原则，但是这些绝对是最重要的原则之一。这些原则的顺序并不重要，缩写只是记忆这些原则的一种方式，因为它们非常重要。让我们开始一个一个地看这些原则。</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h2 id="287b" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">单一责任原则</h2><blockquote class="lo"><p id="81f1" class="lp lq hi bd lr ls lt lu lv lw lx kn dx translated">每个类应该只有一个唯一的目的，不要充满过多的功能。</p></blockquote><p id="8bfe" class="pw-post-body-paragraph jt ju hi jv b jw ly jy jz ka lz kc kd jg ma kf kg jk mb ki kj jo mc kl km kn hb bi translated">为了演示单一责任原则，我创建了一个简单的java程序，我们可以用它来计算形状列表的总面积。</p><p id="3999" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated"><strong class="jv hj">球体</strong>定义球体的类。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="3d33" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated"><strong class="jv hj">立方体</strong>定义立方体的类。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="fc4d" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated"><strong class="jv hj"> AreaCalculator </strong>类具有<code class="du mj mk ml mm b">sum</code>方法，该方法返回我们提供给该方法的不同形状列表的总面积。在这种情况下，我们只有<code class="du mj mk ml mm b">Sphere</code> &amp; <code class="du mj mk ml mm b">cube</code>形状。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="db01" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">在<code class="du mj mk ml mm b"><strong class="jv hj">Main</strong></code>类的<code class="du mj mk ml mm b"><strong class="jv hj">main</strong></code>方法中，我们创建了一个<code class="du mj mk ml mm b"><strong class="jv hj">AreaCalculator</strong></code>类的实例来调用<code class="du mj mk ml mm b">sum</code>方法，并打印了我们提供给<code class="du mj mk ml mm b"><strong class="jv hj">sum</strong></code>方法的不同形状列表的返回面积总和。(在java中,<strong class="jv hj"> main </strong>方法是运行程序的入口点)</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="f26a" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">现在，假设我们想要向<code class="du mj mk ml mm b"><strong class="jv hj">AreaCalculator</strong></code>类添加另一个方法，该方法具有将<code class="du mj mk ml mm b">sum</code>方法的结果打印为JSON字符串格式的功能。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="6c19" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">在<code class="du mj mk ml mm b">main</code>方法中，使用同一个<code class="du mj mk ml mm b">calculator</code>实例调用<code class="du mj mk ml mm b">json</code>方法，以JSON字符串的形式获取<code class="du mj mk ml mm b">sum</code>方法的结果并打印出来。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="0e68" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">这将工作得很好。但是现在我们可以意识到我们已经打破了单一责任的规则。根据单一责任，一个<strong class="jv hj">类应该只有一个单一目的</strong>。这里的<code class="du mj mk ml mm b">AreaCalculator</code>类顾名思义负责计算不同形状列表的面积，这个责任是由我们在类中声明的<code class="du mj mk ml mm b">sum</code>方法完成的。但问题是，我们后来声明的<code class="du mj mk ml mm b">json</code>方法只是打印与<code class="du mj mk ml mm b">AreaCalculator</code>类的职责不匹配的JSON字符串。所以要解决这个问题，我们应该去掉这个不属于<code class="du mj mk ml mm b">AreaCalculator</code>类的叫做<code class="du mj mk ml mm b">json</code>的多余功能，并把它添加到一个与其职责相符的单独的类中。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="aa82" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">并相应地重构主类。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="0831" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">再次运行后，你可以看到它的工作方式完全相同，但现在我们有一个专门的类来处理每个形状的面积总和的格式。因此<code class="du mj mk ml mm b"><strong class="jv hj">ShapesPrinter</strong></code>类有责任将每个形状的面积总和格式化成JSON、CSV等格式。<code class="du mj mk ml mm b"><strong class="jv hj">AreaCalculator</strong></code>班级有责任计算不同形状的面积总和。所以现在每个职业只有一个单一的责任，那就是单一责任原则。</p><h2 id="1d15" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><strong class="ak"> O </strong>笔关闭原理</h2><blockquote class="lo"><p id="9a87" class="lp lq hi bd lr ls lt lu lv lw lx kn dx translated">类应该对扩展开放，对修改关闭。换句话说，您不应该为了实现新特性而重写现有的类。</p></blockquote><p id="282c" class="pw-post-body-paragraph jt ju hi jv b jw ly jy jz ka lz kc kd jg ma kf kg jk mb ki kj jo mc kl km kn hb bi translated">现在让我们说，我们决定添加另一个新的形状到我们的程序中，比如<strong class="jv hj">长方体</strong>来扩展这个程序<strong class="jv hj">的能力。</strong>此时该程序只能计算出<strong class="jv hj">球体</strong>和<strong class="jv hj">立方体</strong>形状的面积。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="fa70" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">现在我们有<strong class="jv hj">长方体</strong>类。所以如果我们想计算立方体的面积，我们需要对类做一些修改。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="8167" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">但在这里，我们刚刚打破了开闭原则。<strong class="jv hj">类应该对扩展开放，对修改关闭</strong>。我们在这里做的是修改这个<code class="du mj mk ml mm b">AreaCalculator</code>类。所以每次我们有一个新的形状，我们就增加一个新的if语句。如果我们有10个额外的形状，我们将有一堆不同的If语句。所以这是不好的做法，我们需要纠正。</p><p id="7221" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">为了解决这个问题，首先我要创建一个名为<strong class="jv hj"> Shape </strong>的新接口，并定义一个名为<strong class="jv hj"> area </strong>的抽象方法。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="a48d" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">在所有形状类(球体、立方体、长方体)中实现创建的<code class="du mj mk ml mm b">Shape</code>接口作为它们的父类，并通过覆盖它为<strong class="jv hj">区域</strong>抽象方法提供每个形状类自己的实现。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="91c2" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">从<code class="du mj mk ml mm b">AreaCalculator</code>类中去掉所有<strong class="jv hj">打开修改行为</strong>。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="5951" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">所以现在我们<strong class="jv hj">通过添加一个新的形状来扩展</strong>T3，但是我们不<strong class="jv hj">修改</strong>它。这就是在这里使用接口的好处。如果我们想在将来添加一个新的形状，我们所要做的就是添加一个新的形状类，它实现了<code class="du mj mk ml mm b">Shape</code>接口，并通过覆盖它们为从接口继承的抽象方法提供了自己的实现。<code class="du mj mk ml mm b">AreaCalculator</code>班不会有什么变化。这基本上是开闭原则。</p><h2 id="3870" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">利斯科夫替代原理</h2><blockquote class="lo"><p id="b779" class="lp lq hi bd lr ls lt lu lv lw lx kn dx translated">每个子类或派生类都应该可以替换它的基类或父类。</p></blockquote><p id="b038" class="pw-post-body-paragraph jt ju hi jv b jw ly jy jz ka lz kc kd jg ma kf kg jk mb ki kj jo mc kl km kn hb bi translated">假设我们决定将<strong class="jv hj">三角形</strong>形状添加到我们的形状列表中，以便计算三角形的面积。我们还决定添加另一个抽象方法<code class="du mj mk ml mm b">volume</code>来计算每个形状的<strong class="jv hj">体积</strong>以及<strong class="jv hj">面积</strong>。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="f4a4" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">尽管三角形有面积，但它没有体积，不像我们目前定义的其他形状。所以请注意，在<code class="du mj mk ml mm b">Triangle</code>类中，我们抛出了一个<strong class="jv hj"> IllegalStateException </strong>用于实现<code class="du mj mk ml mm b">volume</code>方法。由于我们通过实现<code class="du mj mk ml mm b">Shape</code>接口认为<code class="du mj mk ml mm b">triangle</code>是一个<strong class="jv hj">形状</strong>，我们必须实现从父接口继承的所有抽象方法。这就是原因。</p><p id="c9c7" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">创建<code class="du mj mk ml mm b">VolumeCalculator</code>类，负责为不同的形状列表计算<strong class="jv hj">体积</strong>的总和，就像为<strong class="jv hj">区域</strong>创建<code class="du mj mk ml mm b">AreaCalculator</code>类一样。并调整<code class="du mj mk ml mm b">main</code>方法，以便计算和打印体积<strong class="jv hj">。</strong></p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="0565" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">因此，如果我们在程序中添加一个三角形对象，并调用<code class="du mj mk ml mm b">VolumeCalculator</code>类中的<code class="du mj mk ml mm b">sum</code>方法来计算每个形状的体积总和，它将调用<code class="du mj mk ml mm b">Triangle</code>类中的<code class="du mj mk ml mm b">volume</code>方法。然后，因为没有这样的实现来计算体积，但抛出一个异常。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="9a92" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">无法计算没有体积的三角形的体积。我们通过将<code class="du mj mk ml mm b">Triangle</code>类定义为<code class="du mj mk ml mm b">Shape</code>类的子类，打破了Liskov替换规则。<code class="du mj mk ml mm b">Triangle</code>类不可替代<code class="du mj mk ml mm b">Shape</code>类。我们可以定义<code class="du mj mk ml mm b">Triangle</code>是一个<code class="du mj mk ml mm b">Shape</code>，但是它不能计算体积，也不能遵守这个<code class="du mj mk ml mm b">Shape</code>父接口的契约。所以我们违反了规则。<code class="du mj mk ml mm b">Shape</code>父接口有我们必须实现的方法。<code class="du mj mk ml mm b">Triangle</code>可以实现一些，不能实现另一些。所以它永远无法替代它的父节点<code class="du mj mk ml mm b">Shape</code>。</p><p id="f931" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">作为一个解决方案，我们可以为3D形状创建一个单独的界面，它有一个<strong class="jv hj">体积</strong>，并将<code class="du mj mk ml mm b">shape</code>界面中的<code class="du mj mk ml mm b">volume</code>行为替换到其中。并为具有<strong class="jv hj">区域</strong>的两个2D &amp; 3D形状保留<code class="du mj mk ml mm b">shape</code>界面中的<code class="du mj mk ml mm b">area</code>行为。然后制作有<strong class="jv hj">面积</strong>实现<code class="du mj mk ml mm b">Shape</code>接口的形状类和既有<strong class="jv hj">面积</strong> &amp; <strong class="jv hj">体积</strong> <code class="du mj mk ml mm b">implements</code>又有<code class="du mj mk ml mm b">Shape</code> &amp; <code class="du mj mk ml mm b">ThreeDimensionalShape</code>接口的形状类。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="8c6f" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">重构<code class="du mj mk ml mm b">VolumeCalculator</code> &amp; <code class="du mj mk ml mm b">main</code>方法也一样。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><h2 id="fe24" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><strong class="ak"> I </strong>界面偏析原理</h2><blockquote class="lo"><p id="084b" class="lp lq hi bd lr ls lt lu lv lw lx kn dx translated">接口不应该强迫类实现它们不能做的事情。大的接口要分成小的。</p></blockquote><p id="96e0" class="pw-post-body-paragraph jt ju hi jv b jw ly jy jz ka lz kc kd jg ma kf kg jk mb ki kj jo mc kl km kn hb bi translated">当我们用Liskov替换原则清理代码时，我们已经用接口分离原则调整了代码。</p><ul class=""><li id="534c" class="ko kp hi jv b jw kq ka kr jg ks jk kt jo ku kn kv kw kx ky bi translated"><strong class="jv hj">接口不应该强制类实现它们不能做的事情</strong> : 2D shape类像<code class="du mj mk ml mm b">Triangle</code>不能实现<code class="du mj mk ml mm b">Shape</code>接口，而它有像<code class="du mj mk ml mm b">volume</code>的行为。这是三角形做不到的。因此将<code class="du mj mk ml mm b">Shape</code>接口的<code class="du mj mk ml mm b">volume</code>抽象行为替换为新创建的<code class="du mj mk ml mm b">ThreeDimensionalShape</code>接口，并使立方体、球体等3D形状类实现了对<code class="du mj mk ml mm b">Shape</code>接口的<code class="du mj mk ml mm b">ThreeDimensionalShape</code>接口添加。这样2D就不会强迫像<code class="du mj mk ml mm b">Triangle</code>这样的类去实现他们确实不能做的事情。</li><li id="ee14" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated"><strong class="jv hj">大的接口应该分成小的</strong>:为了解决上述问题，我们将大的<code class="du mj mk ml mm b">Shape</code>接口分成小的独立接口，称为<code class="du mj mk ml mm b">Shape</code> &amp; <code class="du mj mk ml mm b">ThreeDimensionalShape</code>及其行为。</li></ul><h2 id="cc47" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">从属倒置原则</h2><blockquote class="lo"><p id="6761" class="lp lq hi bd lr ls lt lu lv lw lx kn dx translated">组件应该依赖于抽象，而不是具体化。也就是说，我们应该真正实现接口。</p></blockquote><p id="e69b" class="pw-post-body-paragraph jt ju hi jv b jw ly jy jz ka lz kc kd jg ma kf kg jk mb ki kj jo mc kl km kn hb bi translated">让我们看看我们之前实现的<code class="du mj mk ml mm b">ShapesPrinter</code>类。在这个类中，我们创建了一个<code class="du mj mk ml mm b">AreaCalculator</code>类的实例，以便在<code class="du mj mk ml mm b">ShapesPrinter</code>中调用<code class="du mj mk ml mm b">sum</code>方法。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="1dbe" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">因此，我们实际上打破了两个坚实的原则。我认为如果我们对<code class="du mj mk ml mm b">AreaCalculator</code>类做了更改，那么我们实际上就违反了<strong class="jv hj">开闭原则。同样在这里，我们依赖于实际的具体类(<code class="du mj mk ml mm b">AreaCalculator</code>)而不是抽象类。这意味着打破<strong class="jv hj">依赖倒置原则</strong>也。</strong></p><p id="09d1" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">为了使我们的代码符合这些原则，我们创建了<code class="du mj mk ml mm b">IAreaCalculator</code>接口，并让我们的<code class="du mj mk ml mm b">AreaCalculator</code>类实现它。在<code class="du mj mk ml mm b">IAreaCalculator</code>接口中定义了<code class="du mj mk ml mm b">sum</code>抽象方法，该方法已经在<code class="du mj mk ml mm b">AreaCalculator</code>中实现。并且重构<code class="du mj mk ml mm b">ShapesPrinter</code>类以依赖于<code class="du mj mk ml mm b">IAreaCalculator</code>接口而不是<code class="du mj mk ml mm b">AreaCalculator</code>类。不要依赖具体的，要依赖抽象的接口。这里我们使用<strong class="jv hj">依赖注入</strong>。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="2aec" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">同样，相应地重构主类。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="9bee" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">运行程序后，将输出相同的结果。</p><p id="96c3" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">将来，如果我们想扩展<code class="du mj mk ml mm b">ShapesPrinter</code>类，我们不会修改这个类。我们所做的就是创建一个实现<code class="du mj mk ml mm b">IAreaCalculator</code>接口的新类。</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="6920" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated"><strong class="jv hj">感谢你留到本文结束。如果你喜欢看，请按那个按钮👏几次，留下评论，如果你认为这篇文章也能帮助别人，请分享。</strong></p><p id="65eb" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">如果你对更多类似的文章感兴趣，请关注我的Medium！</p></div></div>    
</body>
</html>