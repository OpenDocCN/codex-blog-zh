<html>
<head>
<title>Unix Domain Sockets in .NET 6 — Basics and Real-World Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unix域套接字。NET 6 —基础知识和现实世界的例子</h1>
<blockquote>原文：<a href="https://medium.com/codex/unix-domain-sockets-in-net-6-basics-and-real-world-examples-8982898ab293?source=collection_archive---------1-----------------------#2022-02-09">https://medium.com/codex/unix-domain-sockets-in-net-6-basics-and-real-world-examples-8982898ab293?source=collection_archive---------1-----------------------#2022-02-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9a86" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在中使用Unix域套接字。NET 6服务器和客户端应用程序</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c30c81d9e90469bee4b29fd44ee88fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uAUe5JNVCd01AvxyyYt5yA.png"/></div></div></figure><p id="5b48" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">使用创建支持跨平台的API。NET变得更加容易。NET 6。基于ASP.NET构建的API通常使用特定的接口和端口，通过TCP/IP为应用程序提供服务。这是有意义的，因为API会定期通过网络进行交互。你已经想过改变这种行为了吗？</p><p id="fe99" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在某些情况下，存在更高性能的解决方案，尤其是当应用程序需要交换数据并在同一台机器上运行时。如果您面临这种类型的场景，Unix域套接字可能是默认行为的合适替代方式。本文展示了如何使用？NET应用程序来服务和消费基于Unix域套接字的API。文末的用例基于实际例子阐明用法。</p><h1 id="32dd" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">什么是Unix域套接字？</h1><p id="f29f" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">在深入研究代码示例之前，让我们先简要了解一下Unix域套接字(或Unix套接字)以及它们与TCP/IP套接字的区别。</p><p id="3b10" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Unix域套接字是一种进程间通信机制，允许多个应用程序之间进行双向数据交换。像基于Unix的操作系统上的几乎所有东西一样，Unix套接字是基于文件的。因此，可以通过文件系统权限来控制访问，并且通信仅限于在同一台机器上运行的应用程序。</p><blockquote class="lc"><p id="26ac" class="ld le hi bd lf lg lh li lj lk ll ke dx translated">当应用程序在同一台基于Unix的主机上运行时，应该首选Unix域套接字，因为它们比TCP/IP套接字更轻量级、更快。</p></blockquote><p id="ace0" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">相反，TCP/IP套接字允许应用程序之间通过网络进行通信。通过使用环回接口，通信也可以在同一台机器上进行。由于机器间通信的目的，TCP/IP套接字必须考虑路由等操作。这就是为什么它们没有Unix域套接字那么快和轻量级。</p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="6175" class="kf kg hi bd kh ki ly kk kl km lz ko kp io ma ip kr ir mb is kt iu mc iv kv kw bi translated">通过Unix套接字提供. NET最小API</h1><p id="a3e0" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">基于ASP.NET的应用程序通过名为Kestrel的内置跨平台web服务器提供服务。默认情况下，Kestrel基于TCP/IP套接字使用不同环境变量中指定的参数进行设置，例如使用<em class="md"> ASPNETCORE_URLS </em>进行接口和端口绑定。这很有意义，因为API通常是为应用程序之间通过网络进行通信而创建的。</p><p id="82dc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但这只是默认。通过精心设计的界面调整配置非常容易。通过几行代码，您可以构建并运行一个使用Unix域套接字而不是基于ASP.NET的TCP/IP套接字的API。我们将在本文的后面查看一些实际的用例。</p><p id="5590" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但是现在，我们将浏览服务器和客户机应用程序代码，演示如何使用Unix套接字。为了开始我们的第一个服务器应用程序，我们使用dotnet CLI创建了一个新的最小API:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="97c2" class="mj kg hi mf b fi mk ml l mm mn">dotnet new webapi -minimal -o SocketDemo</span></pre><p id="c910" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后，我们使用下一个代码片段替换<em class="md"> Program.cs </em>文件的全部内容。在这段代码摘录中，常量<em class="md"> UnixSocketPath </em>定义了用于在文件系统上创建套接字的路径。经过一些完整性检查后，建议Kestrel通过<em class="md"> ListenUnixSocket </em>使用已定义的套接字文件。通过这一行简单的代码，所有TCP/IP堆栈相关设置的预定义注册都被替换。使用创建最小API时，代码片段的其余部分遵循通用语法。网</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="1158" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了在基于Windows的系统上运行这个例子，我推荐WSL 2。Visual Studio和Visual Studio代码具有出色的远程集成，因此您可以直接从开发环境中运行代码。</p><div class="mq mr ez fb ms mt"><a rel="noopener follow" target="_blank" href="/codex/using-wsl-2-in-enterprises-d9cef1f60c73"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hj fi z dy my ea eb mz ed ef hh bi translated">在企业中使用WSL 2</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">在企业环境中安装、配置和分发WSL 2</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh jh mt"/></div></div></a></div><p id="fb08" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面的屏幕截图显示了之前在Visual Studio代码WSL 2远程会话中执行的示例。左侧终端窗口显示了通过<code class="du ni nj nk mf b">dotnet run</code>执行的运行中的ASP.NET应用程序，确认我们正在使用定义的Unix套接字提供API。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nl"><img src="../Images/2ecedd7c8bc0ec57de1d1b99c463fbad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SmegcrECt4jFlNivcorDww.png"/></div></div><figcaption class="nm nn et er es no np bd b be z dx translated">运行。使用WSL2远程会话直接从Visual Studio代码中调用</figcaption></figure><p id="a55c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">右边的终端窗口显示了一个使用curl命令<code class="du ni nj nk mf b">curl -w "\n" --unix-socket /tmp/foo.sock <a class="ae nq" href="http://localhost/" rel="noopener ugc nofollow" target="_blank">http://localhost/</a></code>的客户端请求。输出代表了我们的服务器应用程序的预期响应。</p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="6d13" class="kf kg hi bd kh ki ly kk kl km lz ko kp io ma ip kr ir mb is kt iu mc iv kv kw bi translated">使用Unix域套接字消费API</h1><p id="99cf" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">使用命令行工具<em class="md"> curl </em>我们刚刚看到了从我们的服务器应用程序请求数据的许多可能性之一。在本节中，您将学习如何构建。NET客户端可以从我们基于Unix套接字的后端消费数据。我们将讨论几种导致相同结果的方法。</p><h2 id="8b7c" class="mj kg hi bd kh nr ns nt kl nu nv nw kp js nx ny kr jw nz oa kt ka ob oc kv od bi translated">使用基于. NET 6的控制台应用程序</h2><p id="f1e2" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">在我们的第一个例子中，我们从一个简单的控制台应用程序开始，它代表了从后端请求数据的“硬方法”。它使用框架中包含的<a class="ae nq" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.socket?view=net-6.0" rel="noopener ugc nofollow" target="_blank">套接字</a>类。</p><p id="91b8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面的代码块显示了我称之为“硬方法”的原因。在使用<a class="ae nq" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.unixdomainsocketendpoint?view=net-6.0" rel="noopener ugc nofollow" target="_blank">UnixDomainSocketEndpoint</a>类创建端点之后，我们必须从头开始构建所需的请求消息，然后使用之前实例化的套接字发送它。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="a3db" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但是。NET framework确实提供了更多基于套接字请求数据的可能性。第二个控制台应用程序使用<a class="ae nq" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.socketshttphandler?view=net-6.0" rel="noopener ugc nofollow" target="_blank"> SocketsHttpHandler </a>类来表示“优雅的方式”。</p><p id="e1aa" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">通过这种方法，我们使用了更高层次的抽象。首先，我们必须创建一个<a class="ae nq" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.socketshttphandler?view=net-6.0" rel="noopener ugc nofollow" target="_blank"><em class="md">SocketsHttpHandler</em></a><em class="md"/>的实例。通过<em class="md"> ConnectCallback </em>属性，可以建立到我们的Unix域套接字的连接。为此，使用<a class="ae nq" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.unixdomainsocketendpoint?view=net-6.0" rel="noopener ugc nofollow" target="_blank">UnixDomainSocketEndpoint</a>类创建一个<em class="md"> NetworkStream </em>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="b39a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">通过使用<a class="ae nq" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.socketshttphandler?view=net-6.0" rel="noopener ugc nofollow" target="_blank"><em class="md">SocketsHttpHandler</em></a>，<em class="md"> </em>使用HTTP消息传递管道处理请求。管道中的每个消息处理程序接收一个HTTP请求并返回一个HTTP响应。管道通常包含多个链接在一起的处理程序。HTTP消息处理程序提供了从<a class="ae nq" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=net-6.0" rel="noopener ugc nofollow" target="_blank"> HttpClient </a>接口的优势中获益的可能性。因此，在发送请求之前，不需要手动构建消息。如上面的代码片段所示，通过使用HttpClient的<code class="du ni nj nk mf b">GetAsync</code>方法，我们可以很容易地从后端请求数据。</p><h2 id="aecc" class="mj kg hi bd kh nr ns nt kl nu nv nw kp js nx ny kr jw nz oa kt ka ob oc kv od bi translated">使用带有Refit的ASP.NET应用程序</h2><p id="aa86" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">在用ASP.NET开发web应用程序的情况下，我们可以从嵌入式依赖注入和改装中受益。这种组合允许集中配置我们的端点，因此在Unix套接字上使用外部API时不需要特定于API的知识。</p><blockquote class="lc"><p id="a94a" class="ld le hi bd lf lg lh li lj lk ll ke dx translated">Refit是一个自动类型安全的REST库。NET Core、Xamarin和。NET将你的REST API变成一个动态接口。(<a class="ae nq" href="https://github.com/reactiveui/refit" rel="noopener ugc nofollow" target="_blank">https://github.com/reactiveui/refit</a>)</p></blockquote><p id="0b75" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">在下一个代码片段中，我们将通过ASP.NET和Refit来看看基于Unix套接字的API的配置和使用。该代码片段包含以下步骤:</p><ol class=""><li id="31d6" class="oe of hi jl b jm jn jp jq js og jw oh ka oi ke oj ok ol om bi translated">创建一个代表API的接口<br/>API是由一个接口描述的。方法表示通过附加属性配置的单个端点。在我们的例子中，<code class="du ni nj nk mf b">IFooApi</code>接口代表了我们最小的API后端。使用属性<code class="du ni nj nk mf b">[Get("/")]</code>将API的特定端点映射到接口方法。</li><li id="53f9" class="oe of hi jl b jm on jp oo js op jw oq ka or ke oj ok ol om bi translated">通过调用扩展方法<code class="du ni nj nk mf b">AddRefitClient</code>注册改装客户端嵌入式依赖注入(DI)容器<br/>，所有需要的依赖都在DI容器中注册。为此对NuGet包<a class="ae nq" href="https://www.nuget.org/packages/Refit.HttpClientFactory/" rel="noopener ugc nofollow" target="_blank">进行改装。HttpClientFactory </a>必须预先安装。</li><li id="338d" class="oe of hi jl b jm on jp oo js op jw oq ka or ke oj ok ol om bi translated">配置主HTTP消息处理程序<br/>下一步，建议Refit使用<a class="ae nq" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.socketshttphandler?view=net-6.0" rel="noopener ugc nofollow" target="_blank"><em class="md">SocketsHttpHandler</em></a><em class="md"/>类作为主HTTP消息处理程序，这与我们之前的控制台应用程序示例中的实现相同。因此，所有使用注册接口的API调用都使用HTTP消息传递管道进行处理。</li><li id="87a8" class="oe of hi jl b jm on jp oo js op jw oq ka or ke oj ok ol om bi translated">配置HTTP客户端<br/>最后，应该进行HTTP客户端的设置。在下面的例子中，配置被简化为我们后端的基地址。因为我们关注的是Unix域套接字，当然，这是localhost。</li></ol><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="889a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有了这个基本配置，就可以通过接口<code class="du ni nj nk mf b">IFooApi</code>调用API。可以使用ASP.NET机制注入接口，这意味着在每个由DI创建的实例中，例如，控制器。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es os"><img src="../Images/63d1f6a4260c0d7780e0f07ab4d403be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SUEWlcIb41Lyfhw4Z8uzag.png"/></div></div><figcaption class="nm nn et er es no np bd b be z dx translated">使用ASP.NET在Unix域套接字上使用API，并在WSL2远程会话中进行改装</figcaption></figure></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="b85b" class="kf kg hi bd kh ki ly kk kl km lz ko kp io ma ip kr ir mb is kt iu mc iv kv kw bi translated">实际使用案例</h1><p id="bc42" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">在上面几节中，您已经看到了一些在。基于. NET的应用程序。所以现在是时候看一些真实世界的例子了，在这些例子中这是非常有用的。</p><h2 id="2160" class="mj kg hi bd kh nr ns nt kl nu nv nw kp js nx ny kr jw nz oa kt ka ob oc kv od bi translated">用例# 1——在之间交换数据。NET和Python</h2><p id="fc03" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated"><strong class="jl hj">挑战</strong> <br/>想一个应用来预测一些惊人的事情。一般前端和后端部分在ASP.NET实现。一些预测算法是基于Python的。因此，基本上这两个组件可以彼此分开使用，或者像在这个用例中一样，在一个基于Linux的Docker映像中一起使用。</p><p id="8ca3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">可能的解决方案<br/> </strong>应用程序之间交换数据的方式多种多样。使用命名管道、套接字、文件或。净语境<a class="ae nq" href="https://github.com/pythonnet/pythonnet" rel="noopener ugc nofollow" target="_blank">Python.NET</a>。另一种方法基于gRPC。这项技术允许使用设计良好的契约在两个应用程序部分之间进行交换。gRPC可以轻松实现各种通信方式，如一元呼叫、客户端流、服务器流或两种双向流的组合。</p><div class="mq mr ez fb ms mt"><a rel="noopener follow" target="_blank" href="/codex/distributed-services-using-grpc-100743363c6b"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hj fi z dy my ea eb mz ed ef hh bi translated">使用gRPC的分布式服务</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">gRPC实用指南及其使用方法。NET和Python</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="ot l ne nf ng nc nh jh mt"/></div></div></a></div><p id="3a9f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">由于整个应用程序都在同一个Docker映像中，Unix域套接字是启动运行中的应用程序的轻量级和最快的选项。</p><p id="bddc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">实现<br/> </strong>构建和使用gRPC的基础知识。NET和Python可以在我上面链接的文章中找到。对于这个特定的用例，我想说明的是，gRPC除了TCP/IP套接字之外，还可以与Unix域套接字一起使用。以下示例显示了一个使用Unix套接字的基于Python的gRPC服务器。在基于. NET的gRPC客户端中，执行一元调用。当然，角色也可以互换。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="5430" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如带有改装样本的ASP.NET所示，gRPC客户端也依赖于<a class="ae nq" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.socketshttphandler?view=net-6.0" rel="noopener ugc nofollow" target="_blank"><em class="md">SocketsHttpHandler</em></a>。使用这个处理程序，可以创建gRPC通信通道。在最后一步中，对Python中托管的gRPC服务器执行一元调用。在这个示例中，代码被包装在一个. NET Minimal API中，因此可以很容易地被触发(这只是为了演示，不要为单个请求重新创建整个通信栈)。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="4827" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当在Visual Studio代码WSL 2远程会话中运行示例的所有提到的部分时，我们可以使用<em class="md"> curl </em>查询API。结果显示在下图中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ou"><img src="../Images/00fc27ece9abaa06ca63c01512db951b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y4zHJ27OM5hWF-amE0oMMQ.png"/></div></div></figure><h2 id="3770" class="mj kg hi bd kh nr ns nt kl nu nv nw kp js nx ny kr jw nz oa kt ka ob oc kv od bi translated">用例2—从ctrlX核心超紧凑控件请求数据</h2><p id="2331" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated"><strong class="jl hj">挑战<br/> </strong> <a class="ae nq" href="https://apps.boschrexroth.com/microsites/ctrlx-automation/en/portfolio/ctrlx-core/" rel="noopener ugc nofollow" target="_blank"> ctrlX CORE </a>是博世力士乐提供的一款超紧凑型自动化控制系统。其中一个特性是可以开发第三方应用程序，并通过ctrlX商店分发它们。这些应用程序可以使用各种编程语言开发，并使用Snap技术打包。该平台提供了各种REST接口，用于与用户管理或许可系统等无缝集成。为了从平台特性中获益，必须使用这些API。</p><p id="4779" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">可能的解决方案<br/> </strong>当然，其余的接口可以使用常规的HTTP调用来寻址。在ctrlX核心的情况下，所有端点都实施HTTPS，并需要一个承载令牌来防止未经允许的访问。对于非交互式场景，例如，应用程序需要请求许可证数据，此令牌不可用。但是如何在这些场景下实现集成呢？解决方案几乎是显而易见的。</p><p id="f89d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">卡扣式容器可以通过插槽和插头相互连接。ctrlX CORE上的许可服务提供了这样一个插件:</p><pre class="iy iz ja jb fd me mf mg mh aw mi bi"><span id="fd1f" class="mj kg hi mf b fi mk ml l mm mn">plugs:<br/>  licensing-service:<br/>    interface: content<br/>    content: licensing-service<br/>    target: $SNAP_DATA/licensing-service</span></pre><p id="dac9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，第三方应用程序可以通过Unix域套接字<code class="du ni nj nk mf b">$SNAP_DATA/licensing-service/licensing-service.sock</code>从许可系统API请求数据。这个套接字只能由运行在同一系统上的应用程序访问。因此，请求不需要使用HTTPS，并且不再需要承载令牌。</p><p id="695f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">实现<br/> </strong>让我们来看看实现用例的一些细节。我们不会讨论为ctrlX CORE创建. NET应用程序所需的所有方面。也许我会在以后的文章中写这个。-)</p><p id="5a28" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">快照由名为<em class="md"> snapcraft.yaml </em>的文件描述。这个文件是Snapcraft的主要入口点(更多细节请参见<a class="ae nq" href="https://snapcraft.io/docs/snapcraft-format" rel="noopener ugc nofollow" target="_blank">官方文档</a>)。要访问另一个快照提供的Unix套接字，必须扩展该文件。对于ctrlX核心，可能如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="0612" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">将插头添加到我们的<em class="md"> snapcraft.yaml </em>文件中的已知插头列表后，我们现在可以访问特定的Unix域插座。因为我们仍然在我们的技术堆栈中，所以上面提到的方法也可以用在这种情况下。接下来的代码摘录展示了这个栈在所描述的用例中的应用。它主要包括</p><ul class=""><li id="4bf1" class="oe of hi jl b jm jn jp jq js og jw oh ka oi ke ov ok ol om bi translated"><em class="md"> Startup </em> <br/>一个负责把所有应用程序部件放在一起的类。这包括例如依赖注入容器中组件的注册和配置。与套接字相关的接口和类的过程遵循我们以前学过的模式。</li><li id="65f9" class="oe of hi jl b jm on jp oo js op jw oq ka or ke ov ok ol om bi translated">这个接口描述了许可Api。每个方法都用一个特定于Refit的属性来修饰。在样本代码中，仅示例性地示出了获取许可的方法。</li><li id="35fb" class="oe of hi jl b jm on jp oo js op jw oq ka or ke ov ok ol om bi translated">CtrlXLicenseValidator  <br/>一个负责与许可证管理相关的应用程序特定逻辑的类。它使用<em class="md"> ICtrlXLicenseApi </em>接口，通过<em class="md"> Startup </em>类提供的配置来访问驻留在ctrlX内核上的Api。</li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mo mp l"/></div></figure></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="5cd4" class="kf kg hi bd kh ki ly kk kl km lz ko kp io ma ip kr ir mb is kt iu mc iv kv kw bi translated">包扎</h1><p id="bd42" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">在本文中，介绍了在。NET的应用程序进行了解释。实际例子进一步说明了这种用法。我们可以说，像HTTP消息处理程序这样的集成机制使得为运行在同一台机器上的服务建立轻量级的快速通信变得非常简单。与其他库(如Refit)结合使用，大多数与通信相关的初始化都可以从生产代码中分离出来。</p><p id="6997" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在GitHub上，有一个完整的工作示例应用程序。它涵盖了使用Unix域套接字进行通信的客户机和服务器应用程序。此外，还提供了gRPC示例的代码。(<a class="ae nq" href="https://github.com/fzankl/dotnet-unix-sockets" rel="noopener ugc nofollow" target="_blank">示例如何使用？网6 </a></p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="0033" class="kf kg hi bd kh ki ly kk kl km lz ko kp io ma ip kr ir mb is kt iu mc iv kv kw bi translated">参考资料和更多链接</h1><div class="mq mr ez fb ms mt"><a href="https://docs.microsoft.com/de-de/dotnet/api/system.net.http.socketshttphandler?view=net-6.0" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hj fi z dy my ea eb mz ed ef hh bi translated">SocketsHttpHandler Klasse(系统。Net.Http)</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">在http客户端的标准中。NET Core 2.1和her verwendet wird。公共引用…</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">docs.microsoft.com</p></div></div><div class="nc l"><div class="ow l ne nf ng nc nh jh mt"/></div></div></a></div><div class="mq mr ez fb ms mt"><a href="https://github.com/reactiveui/refit" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hj fi z dy my ea eb mz ed ef hh bi translated">GitHub - reactiveui/refit:的自动类型安全REST库。NET Core、Xamarin和。网络…</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">的自动类型安全REST库。NET Core、Xamarin和. NET。深受Square的改造库的启发…</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">github.com</p></div></div><div class="nc l"><div class="ox l ne nf ng nc nh jh mt"/></div></div></a></div><div class="mq mr ez fb ms mt"><a href="https://boschrexroth.github.io/ctrlx-automation-sdk/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hj fi z dy my ea eb mz ed ef hh bi translated">ctrlX AUTOMATION SDK -软件开发工具包</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">ctrlX自动化软件开发工具包</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">boschrexroth.github.io</p></div></div></div></a></div></div></div>    
</body>
</html>