<html>
<head>
<title>Testing Kubernetes Operators using GitHub Actions and Kind</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitHub动作和种类测试Kubernetes操作符</h1>
<blockquote>原文：<a href="https://medium.com/codex/testing-kubernetes-operators-using-github-actions-and-kind-c4086d37dd30?source=collection_archive---------7-----------------------#2021-09-14">https://medium.com/codex/testing-kubernetes-operators-using-github-actions-and-kind-c4086d37dd30?source=collection_archive---------7-----------------------#2021-09-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/23f9a379f8f47eebbcb9ada9cd38f78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uLCnSHO6OFxxsCYW"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae iu" href="https://unsplash.com/@scienceinhd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科学高清</a>拍摄的照片</figcaption></figure><p id="4176" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">自动化测试是任何管理良好的存储库的重要特征。它为每个人提供验证，以确保代码质量和功能。</p><p id="f234" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将涵盖林挺、单元测试、集成测试和docker构建。我们还将介绍一个在Github中管理秘密的好策略。</p><h1 id="2fc0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">设置</h1><p id="3597" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在目录的根目录下，创建以下目录结构和文件。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="397f" class="lf ju hi lb b fi lg lh l li lj">.github/<br/>  |- workflows/<br/>    |- linting.yaml<br/>    |- testing.yaml<br/>    |- docker-build.yaml<br/>Makefile</span></pre><p id="cd5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#about-yaml-syntax-for-workflows" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>通过读取<code class="du lk ll lm lb b">.github</code>目录的内容来工作。</p><h1 id="39c6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">林挺</h1><p id="b914" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">代码林挺是静态代码分析，用于标记编程错误、bug、风格错误和可疑结构。</p><p id="1529" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du lk ll lm lb b">linting.yaml</code>中增加以下内容。这将在您创建或更新拉取请求时运行工作流。如果它发现任何林挺错误，它会在您的PR上留下代码注释供您解决。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><ul class=""><li id="bfe3" class="lp lq hi ix b iy iz jc jd jg lr jk ls jo lt js lu lv lw lx bi translated"><a class="ae iu" href="https://github.com/golangci/golangci-lint-action" rel="noopener ugc nofollow" target="_blank"> Golang CI Lint Github动作</a></li><li id="0524" class="lp lq hi ix b iy ly jc lz jg ma jk mb jo mc js lu lv lw lx bi translated"><a class="ae iu" href="https://github.com/golangci/golangci-lint" rel="noopener ugc nofollow" target="_blank"> golangci-lint工具</a></li></ul><h1 id="cd2c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">单元测试</h1><p id="65a0" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们将在下一个工作流程中实现单元测试和集成测试工作。首先，是单元测试。</p><p id="cb32" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du lk ll lm lb b">testing.yaml</code>中，添加以下内容。这将在您创建或更新拉取请求时运行工作流。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="94d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们安装特定版本的Golang，因为我们不能确定默认运行程序ubuntu-latest将使用什么版本。最后，我们使用Makefile <em class="md">运行我们的单元测试。</em>下面是Makefile的一个例子。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6f55" class="lf ju hi lb b fi lg lh l li lj"># Run tests<br/>unit-test: fmt vet <br/>  go test ./pkg/... -coverprofile cover.out </span><span id="3280" class="lf ju hi lb b fi me lh l li lj">integration-test: fmt vet <br/>  go test ./controllers/... -coverprofile cover.out</span><span id="10b4" class="lf ju hi lb b fi me lh l li lj"># Run go fmt against code<br/>fmt: <br/>  go fmt ./... </span><span id="e865" class="lf ju hi lb b fi me lh l li lj"># Run go vet against code<br/>vet: <br/>  go vet ./...</span></pre><p id="8277" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以调整<code class="du lk ll lm lb b">go unit-test</code>将要瞄准的路径。在这个例子中，它在<code class="du lk ll lm lb b">pkg</code>目录中寻找<code class="du lk ll lm lb b">*_test.go</code>文件。进行额外的验证。<code class="du lk ll lm lb b">go fmt</code>和<code class="du lk ll lm lb b">go vet</code>也在运行。</p><h1 id="3c27" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">集成测试</h1><p id="aa0a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">接下来是集成测试。集成测试很可能需要与需要认证的系统进行交互。我们将添加secrets作为环境变量来满足这一需求。</p><p id="f5a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">修改<code class="du lk ll lm lb b">testing.yaml</code>，在底部添加一个新任务。下面是完整文件的样子。注意在<em class="md">任务下增加了<em class="md">集成测试</em>。</em></p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="e06a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们启动一个<a class="ae iu" href="https://kind.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank">类</a>集群来运行我们的操作符。我们正在测试Kubernetes版本1.20.7。当它开始运行时，它会自动在GitHub Action Runner中设置Operator-SDK将用来运行的<em class="md"> kube配置</em>。</p><blockquote class="mf mg mh"><p id="89b0" class="iv iw md ix b iy iz ja jb jc jd je jf mi jh ji jj mj jl jm jn mk jp jq jr js hb bi translated">Kind是一个使用Docker容器“节点”运行本地Kubernetes集群的工具。Kind主要是为测试Kubernetes本身而设计的，但也可以用于本地开发或CI。</p></blockquote><p id="6d3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们从Azure Key Vault中安全地获取我们的运营商需要的任何秘密。你可以在这里阅读更多关于<em class="md">Azure/get-key vault-secrets</em>Github Action<a class="ae iu" href="https://docs.microsoft.com/en-us/azure/developer/github/github-key-vault" rel="noopener ugc nofollow" target="_blank">。稍后，我们将讨论为什么我们会以这种方式获得秘密。</a></p><p id="a5f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们安装我们正在使用的Operator-SDK版本。</p><p id="ced5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们通过调用<code class="du lk ll lm lb b">make integration-test</code>来运行集成测试</p><h1 id="03fa" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">码头工人建造</h1><p id="48e0" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们将创建的最后一个工作流是为了测试我们是否能够成功地构建我们的操作员的容器映像。将以下内容添加到<code class="du lk ll lm lb b">docker-build.yaml</code>。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="05a2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">高效管理GitHub机密</h1><p id="74f7" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">你可以给Github添加秘密，并使用<code class="du lk ll lm lb b">${{ secrets.MY_SECRET_NAME }}</code>在动作中调用它们。这种方法很好，也很简单，但是在管理多个秘密时，这就变得令人头疼了。如果你有一个服务主体，它需要定期进行秘密轮换，你必须记住在任何地方都要改变它，包括GitHub。此外，存储机密的位置越多，黑客的攻击面就越大。</p><p id="fb95" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，如果您从Azure Key Vault动态检索秘密值，您只需要担心在一个地方管理秘密轮换和安全性。这就是为什么<em class="md">Azure/get-key vault-secrets</em>这么牛逼的原因。</p><h1 id="0916" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">包扎</h1><p id="6033" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">设置这些工作流程后，请确保在合并PR之前要求它们通过。您可以通过为<em class="md"> main </em>创建一个分支保护规则并选择“合并前要求通过状态检查”来在存储库设置中实现这一点。然后列出我们在上面创建的工作流的名称。</p><p id="5cad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，您的基于Operator-SDK的应用程序已经准备好进行自动化测试了！如果您有任何问题或意见，请联系我们！</p><p id="e1cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">干杯。</p></div></div>    
</body>
</html>