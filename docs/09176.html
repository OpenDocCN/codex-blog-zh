<html>
<head>
<title>Leveraging Templates to Make Reusable Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用模板制作可重用的组件</h1>
<blockquote>原文：<a href="https://medium.com/codex/leveraging-templates-to-make-reusable-components-b561fb9b33d2?source=collection_archive---------2-----------------------#2022-09-30">https://medium.com/codex/leveraging-templates-to-make-reusable-components-b561fb9b33d2?source=collection_archive---------2-----------------------#2022-09-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="e986" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">文章节选</h2><div class=""/><div class=""><h2 id="8a1e" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated"><em class="jg">节选自克里斯·塞恩蒂</em>的<a class="ae jh" href="https://www.manning.com/books/blazor-in-action?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=book_sainty_blazor_10_7_20" rel="noopener ugc nofollow" target="_blank"><em class="jg">Blazor in Action</em></a><em class="jg"/></h2></div><p id="8562" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">本文涵盖</em></p><p id="21a7" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">使用模板定义UI的特定区域</em></p><p id="ae4e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">用泛型增强模板</em></p><p id="db8d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果你是一个全栈C#和。NET web开发人员，他想了解更多关于Blazor的知识。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="00ae" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在<a class="ae jh" href="https://www.manning.com/books/blazor-in-action?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=book_sainty_blazor_10_7_20" rel="noopener ugc nofollow" target="_blank">manning.com</a>的结账处，将<strong class="jk hs"> fccsainty </strong>输入折扣代码框，即可享受<em class="ke"/><a class="ae jh" href="https://www.manning.com/books/blazor-in-action?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=book_sainty_blazor_10_7_20" rel="noopener ugc nofollow" target="_blank"><em class="ke">Blazor in Action</em></a>八五折优惠。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="69b9" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在本文中，我们将把可重用性提升到一个新的层次。我们将学习如何利用模板和泛型来制作最终的可重用组件。为了给我们一个实际的例子，我们将用一个组件来增强一个名为Blazing Trails的网站的主页，该组件允许用户在网格和表格之间切换布局(图1)。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es km"><img src="../Images/bf9df6371755d95407b77465c64fc8b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IltlRZRyNJX-hGGO.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">图1显示了我们将在本章构建的最后一个<code class="du lc ld le lf b">ViewSwitcher</code>组件的首页。该组件允许用户在可用踪迹的网格视图和表格视图之间切换。</figcaption></figure><p id="9312" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">一旦我们构建了我们的<code class="du lc ld le lf b">ViewSwitcher</code>组件，我们将通过学习Razor类库(RCL)来结束这一章。RCLs允许我们捆绑任何公共组件，并在应用程序之间共享它们。这可以通过一个项目引用来完成，或者rcl可以通过NuGet打包和运输——就像任何其他方式一样。NET库。</p><h2 id="d27d" class="lg lh hi bd li lj lk ll lm ln lo lp lq jr lr ls lt jv lu lv lw jz lx ly lz ho bi translated"><strong class="ak">定义模板</strong></h2><p id="d383" class="pw-post-body-paragraph ji jj hi jk b jl ma is jn jo mb iv jq jr mc jt ju jv md jx jy jz me kb kc kd hb bi translated">在构建可重用组件时，模板是一个强大的工具。它们允许我们指定由消费者提供的标记块，然后我们可以将它们输出到任何我们想要的地方。在前几章构建<code class="du lc ld le lf b">FormSection</code>和<code class="du lc ld le lf b">FormFieldSet</code>组件时，我们已经使用了一些基本的模板。在这些组件中，我们定义了一个类型为<code class="du lc ld le lf b">RenderFragment</code>名称为<code class="du lc ld le lf b">ChildContent</code>的参数。</p><pre class="kn ko kp kq fd mf lf mg mh aw mi bi"><span id="7cf0" class="lg lh hi lf b fi mj mk l ml mm">[Parameter] public RenderFragment ChildContent { get; set; }</span></pre><p id="e8a5" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是一个特殊的惯例。用这个特定的名称和类型定义一个参数允许我们捕获在组件的开始和结束标记之间指定的任何标记。然而，对于我们的<code class="du lc ld le lf b">ViewSwitcher</code>组件，我们需要更高级的东西。</p><p id="ca54" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><code class="du lc ld le lf b">ViewSwitcher</code>组件允许用户在可用轨迹的卡片视图和表格视图之间切换。为了使这个组件尽可能地可重用，我们不想对网格或表格视图的标记进行硬编码。相反，我们希望将它们定义为模板，允许组件的消费者自己定义这些区域。</p><p id="2f3c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们看看<code class="du lc ld le lf b">ViewSwitcher</code>组件的初始标记。现在，我们将在客户端项目中的Features &gt; Home &gt; Shared下创建这个组件。请参见下面的清单。</p><p id="8c45" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单1 ViewSwitcher.razor:初始代码</strong></p><pre class="kn ko kp kq fd mf lf mg mh aw mi bi"><span id="bd76" class="lg lh hi lf b fi mj mk l ml mm">&lt;div&gt;<br/>     &lt;div class="mb-3 text-right"&gt;<br/>         &lt;div class="btn-group"&gt;<br/>             &lt;button @onclick="@(() =&gt;<br/> [CA]_mode = ViewMode.Grid)" title="Grid View" type="button"<br/> [CA]class="btn @(_mode == ViewMode.Grid ? "btn-secondary"<br/> [CA]: "btn-outline-secondary")"&gt;    #A<br/>                 &lt;i class="bi bi-grid-fill"&gt;&lt;/i&gt;<br/>             &lt;/button&gt;<br/>             &lt;button @onclick="@(() =&gt;<br/> [CA]_mode = ViewMode.Table)" title="Table View" type="button"<br/> [CA]class="btn @(_mode == ViewMode.Table ? "btn-secondary"<br/> [CA]: "btn-outline-secondary")"&gt;     #A<br/>                 &lt;i class="bi bi-table"&gt;&lt;/i&gt;<br/>             &lt;/button&gt;<br/>         &lt;/div&gt;<br/>     &lt;/div&gt;<br/>  <br/>     @if (_mode == ViewMode.Grid)<br/>     {<br/>         @GridTemplate    #B<br/>     }<br/>     else if (_mode == ViewMode.Table)<br/>     {<br/>         @TableTemplate    #C<br/>     }<br/> &lt;/div&gt;<br/>  <br/> @code {<br/>     private ViewMode _mode = ViewMode.Grid;<br/>  <br/>     [Parameter, EditorRequired]<br/>     public RenderFragment GridTemplate { get; set; }<br/> [CA]= default!;    #D<br/>     [Parameter, EditorRequired]<br/>     public RenderFragment TableTemplate { get; set; }<br/> [CA]= default!;    #E<br/>  <br/>     private enum ViewMode { Grid, Table }    #F<br/> }</span></pre><p id="b99c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A这两个按钮允许用户在组件提供的两个视图之间切换。</strong></p><p id="e441" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B指定消费者为GridTemplate提供的标记应该输出到哪里</strong></p><p id="e165" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #C指定消费者为TableTemplate提供的标记应该输出到哪里</strong></p><p id="d967" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #D定义GridTemplate参数</strong></p><p id="7b87" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #E定义了TableTemplate参数</strong></p><p id="d103" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #F枚举定义了两种视图模式，避免使用神奇字符串。</strong></p><p id="fbce" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">该组件从呈现两个按钮的一些标记开始。这些按钮允许用户在组件提供的两种视图之间切换。为此，我们将<code class="du lc ld le lf b">_mode</code>的值设置为<code class="du lc ld le lf b">Grid</code>或<code class="du lc ld le lf b">Table</code>。<code class="du lc ld le lf b">_mode</code>字段在代码块中定义，默认为<code class="du lc ld le lf b">Grid</code>。这些按钮还使用一个简单的表达式来应用不同的CSS类，以突出显示当前处于活动状态的模式。</p><p id="4aee" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">根据激活的模式，组件呈现代码块中定义的两个模板之一，<code class="du lc ld le lf b">GridTemplate</code>或<code class="du lc ld le lf b">TableTemplate</code>。模板只是一个类型为<code class="du lc ld le lf b">RenderFragment</code>的参数。</p><p id="b88b" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们还将为组件添加一些样式。我们将添加一个名为ViewSwitcher.razor.scss的新文件，并添加以下代码。</p><p id="d692" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单2 ViewSwitcher.razor.scss </strong></p><pre class="kn ko kp kq fd mf lf mg mh aw mi bi"><span id="b82a" class="lg lh hi lf b fi mj mk l ml mm">.grid {    #A<br/>     display: grid;<br/>     grid-template-columns: repeat(3, 288px);<br/>     grid-column-gap: 123px;<br/>     grid-row-gap: 75px;<br/> }<br/>  <br/> table {    #B<br/>     width: 100%;<br/>     margin-bottom: 1rem;<br/>     color: #212529;<br/>     border-collapse: collapse;<br/>  <br/>     ::deep th, ::deep td {<br/>         padding: .75rem;<br/>         vertical-align: middle;<br/>     }<br/>  <br/>     ::deep thead tr th {<br/>         border-bottom: 4px solid var(--brand);<br/>         border-top: none;<br/>     }<br/>  <br/>     ::deep tbody tr:nth-of-type(odd) {<br/>         background-color: rgba(0,0,0,.05);<br/>     }<br/> }</span></pre><p id="90c5" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这个类定义了网格视图的样式。</p><p id="9bb9" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这个类定义了表格视图的样式。</p><p id="5191" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这就是我们目前所需要的。让我们跳到<code class="du lc ld le lf b">HomePage.razor</code>并实现<code class="du lc ld le lf b">ViewSwitcher</code>。然后我们可以运行应用程序，看看一切是什么样子。我们将用下面清单中显示的代码替换当前呈现轨迹网格的代码。</p><p id="c79d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单3 HomePage.razor:使用ViewSwitcher </strong></p><pre class="kn ko kp kq fd mf lf mg mh aw mi bi"><span id="d6b0" class="lg lh hi lf b fi mj mk l ml mm">&lt;ViewSwitcher&gt;<br/>     &lt;GridTemplate&gt;    #A<br/>         &lt;div class="grid"&gt;<br/>             @foreach (var trail in _trails)<br/>             {<br/>                 &lt;TrailCard Trail="trail" OnSelected="HandleTrailSelected" /&gt;<br/>             }<br/>         &lt;/div&gt;<br/>     &lt;/GridTemplate&gt;<br/>     &lt;TableTemplate&gt;    #B<br/>         &lt;table class="table table-striped"&gt;<br/>             &lt;thead&gt;<br/>                 &lt;tr&gt;<br/>                     &lt;th&gt;Name&lt;/th&gt;<br/>                     &lt;th&gt;Location&lt;/th&gt;<br/>                     &lt;th&gt;Length&lt;/th&gt;<br/>                     &lt;th&gt;Time&lt;/th&gt;<br/>                     &lt;th&gt;&lt;/th&gt;<br/>                 &lt;/tr&gt;<br/>             &lt;/thead&gt;<br/>             &lt;tbody&gt;<br/>                 @foreach (var trail in _trails)<br/>                 {<br/>                     &lt;tr&gt;<br/>                         &lt;th scope="col"&gt;@trail.Name&lt;/th&gt;<br/>                         &lt;td&gt;@trail.Location&lt;/td&gt;<br/>                         &lt;td&gt;@(trail.Length)km&lt;/td&gt;<br/>                         &lt;td&gt;@trail.TimeFormatted&lt;/td&gt;<br/>                         &lt;td class="text-right"&gt;<br/>                             &lt;button @onclick="@(() =&gt;<br/> [CA]HandleTrailSelected(trail))" title="View" class="btn btn-primary"&gt;<br/>                                 &lt;i class="bi bi-binoculars"&gt;&lt;/i&gt;<br/>                             &lt;/button&gt;<br/>                             &lt;button @onclick="@(() =&gt; NavManager<br/> [CA].NavigateTo($"/edit-trail/{trail.Id}"))" title="Edit"<br/> [CA]class="btn btn-outline-secondary"&gt;<br/>                                 &lt;i class="bi bi-pencil"&gt;&lt;/i&gt;<br/>                             &lt;/button&gt;<br/>                         &lt;/td&gt;<br/>                     &lt;/tr&gt;<br/>                 }<br/>             &lt;/tbody&gt;<br/>         &lt;/table&gt;<br/>     &lt;/TableTemplate&gt;<br/> &lt;/ViewSwitcher&gt;</span></pre><p id="bb8e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A定义了GridTemplate的标记</strong></p><p id="5bf1" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B定义TableTemplate的标记</strong></p><p id="c13c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为了指定特定模板的标记，我们定义了与参数名匹配的子元素。在我们的例子中，那就是<code class="du lc ld le lf b">GridTemplate</code>和<code class="du lc ld le lf b">TableTemplate</code>。我们上面为<code class="du lc ld le lf b">GridTemplate</code>和<code class="du lc ld le lf b">TableTemplate</code>定义的标记将由<code class="du lc ld le lf b">ViewSwitcher</code>输出，这里我们指定了<code class="du lc ld le lf b">@GridTemplate</code>和<code class="du lc ld le lf b">@TableTemplate</code>表达式。</p><p id="0fc2" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们现在可以运行应用程序，看看一切看起来像什么。图2显示了这两个视图的并排比较。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es mn"><img src="../Images/c318bf20fd2e1624914a36504b2cceda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rHhL1FWluiz_ypNh.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">图2显示了由<code class="du lc ld le lf b">ViewSwitcher</code>组件提供的网格和表格视图</figcaption></figure><p id="3917" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">太好了！我们现在已经有了组件的初始版本。接下来，我们将向<code class="du lc ld le lf b">ViewSwitcher</code>介绍泛型。</p><h2 id="8ab4" class="lg lh hi bd li lj lk ll lm ln lo lp lq jr lr ls lt jv lu lv lw jz lx ly lz ho bi translated"><strong class="ak">用泛型增强模板</strong></h2><p id="1326" class="pw-post-body-paragraph ji jj hi jk b jl ma is jn jo mb iv jq jr mc jt ju jv md jx jy jz me kb kc kd hb bi translated">目前，我们的组件运行良好。它允许我们为表格和网格视图定义标记，并允许用户在它们之间切换。然而，我认为我们可以做一些改进。现在，当我们使用组件时，我们必须在<code class="du lc ld le lf b">HomePage</code>中定义很多标记。我们在网格模板中的<code class="du lc ld le lf b">foreach</code>块周围定义了一个带有<code class="du lc ld le lf b">.grid</code>类的div。然后对于表格模板，我们为表格提供整个标记。</p><p id="c5be" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">因为我们知道我们将显示一个网格或一个表格，我们可以将一些样板标记放入组件中。然后，当我们使用组件时，我们只需指定特定于该用法的标记和数据。为此，我们将把泛型引入到我们的<code class="du lc ld le lf b">ViewSwitcher</code>组件中。下面的清单显示了更新后的代码。</p><p id="6b03" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单4 ViewSwitcher.razor:更新为使用泛型</strong></p><pre class="kn ko kp kq fd mf lf mg mh aw mi bi"><span id="e778" class="lg lh hi lf b fi mj mk l ml mm">@typeparam TItem    #A<br/> // code omitted<br/> @if (_mode == ViewMode.Grid)<br/> {<br/>     &lt;div class="grid"&gt;<br/>         @foreach (var item in Items)<br/>         {<br/>             @GridTemplate(item)    #B<br/>         }<br/>     &lt;/div&gt;<br/> }<br/> else if (_mode == ViewMode.Table)<br/> {<br/>     &lt;table&gt;<br/>         &lt;thead&gt;    #B<br/>             &lt;tr&gt;    #B<br/>                 @HeaderTemplate    #B<br/>             &lt;/tr&gt;    #B<br/>         &lt;/thead&gt;    #B<br/>         &lt;tbody&gt;<br/>             @foreach (var item in Items)<br/>             {<br/>                 &lt;tr&gt;<br/>                     @RowTemplate(item)    #C<br/>                 &lt;/tr&gt;<br/>             }<br/>         &lt;/tbody&gt;<br/>     &lt;/table&gt;<br/> }<br/> // code omitted<br/> @code {<br/>     private ViewMode _mode = ViewMode.Grid;<br/>  <br/>     [Parameter, EditorRequired]<br/>     public IEnumerable&lt;TItem&gt; Items { get; set; }<br/> [CA]= default!;    #D<br/>     [Parameter, EditorRequired]<br/>     public RenderFragment&lt;TItem&gt; GridTemplate { get;<br/> [CA]set; } = default!;    #C<br/>     [Parameter, EditorRequired]<br/>     public RenderFragment HeaderTemplate { get; set; }<br/> [CA]= default!;    #B<br/>     [Parameter, EditorRequired]<br/>     public RenderFragment&lt;TItem&gt; RowTemplate { get;<br/> [CA]set; } = default!;    #C<br/>     // code omitted<br/> }</span></pre><p id="57ed" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">使用typeparam指令指定类型参数。</p><p id="8efc" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们现在只要求在使用组件时指定标题单元格，而不是表格标题的所有标记。</p><p id="0f70" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">使用类型参数定义RenderFragments允许消费者在定义模板时使用该类型的属性。</p><p id="0ed1" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #D组件现在接受要显示的项目列表。</strong></p><p id="ce19" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们首先向组件引入一个类型参数。我们使用<code class="du lc ld le lf b">@typeparam</code>指令来完成这项工作。一旦我们这样做了，我们就可以在代码块中定义模板参数时引用类型参数。我们现在声明<code class="du lc ld le lf b">GridTemplate</code>和<code class="du lc ld le lf b">RowTemplate</code>将包含<code class="du lc ld le lf b">TItem</code>类型的项目。当我们在标记部分调用这些<code class="du lc ld le lf b">RenderFragments</code>时，我们可以传入一个类型为<code class="du lc ld le lf b">TItem</code>的对象。这些项目来自我们创建的新的<code class="du lc ld le lf b">Items</code>参数。当我们更新<code class="du lc ld le lf b">HomePage</code>时，我们会更详细地看到它的好处，但是通过用一个类型定义我们的模板参数，我们将能够在定义模板时访问那个类型的属性。</p><p id="625f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们去更新<code class="du lc ld le lf b">HomePage</code>，以配合我们对<code class="du lc ld le lf b">ViewSwitcher</code>所做的更改。下面的清单显示了<code class="du lc ld le lf b">HomePage.razor</code>的更新代码。</p><p id="a3b9" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单5 HomePage.razor:替换现有的ViewSwitcher代码</strong></p><pre class="kn ko kp kq fd mf lf mg mh aw mi bi"><span id="f3e2" class="lg lh hi lf b fi mj mk l ml mm">&lt;ViewSwitcher Items="_trails"&gt;    #A<br/>     &lt;GridTemplate&gt;     #B<br/>         &lt;TrailCard Trail="context"<br/> [CA]OnSelected="HandleTrailSelected" /&gt;    #C<br/>     &lt;/GridTemplate&gt;<br/>     &lt;HeaderTemplate&gt;    #D<br/>         &lt;th&gt;Name&lt;/th&gt;<br/>         &lt;th&gt;Location&lt;/th&gt;<br/>         &lt;th&gt;Length&lt;/th&gt;<br/>         &lt;th&gt;Time&lt;/th&gt;<br/>         &lt;th&gt;&lt;/th&gt;<br/>     &lt;/HeaderTemplate&gt;<br/>     &lt;RowTemplate&gt;<br/>         &lt;th scope="col"&gt;@context.Name&lt;/th&gt;    #C<br/>         &lt;td&gt;@context.Location&lt;/td&gt;    #C<br/>         &lt;td&gt;@(context.Length)km&lt;/td&gt;    #C<br/>         &lt;td&gt;@context.TimeFormatted&lt;/td&gt;    #C<br/>         &lt;td class="text-right"&gt;<br/>             &lt;button @onclick="@(() =&gt;<br/> [CA]HandleTrailSelected(context))" title="View"<br/> [CA]class="btn btn-primary"&gt;    #C<br/>                 &lt;i class="bi bi-binoculars"&gt;&lt;/i&gt;<br/>             &lt;/button&gt;<br/>             &lt;button @onclick="@(() =&gt;<br/> [CA]NavManager.NavigateTo($"/edit-trail/{context.Id}"))"<br/> [CA]title="Edit" class="btn btn-outline-secondary"&gt;    #C<br/>                 &lt;i class="bi bi-pencil"&gt;&lt;/i&gt;<br/>             &lt;/button&gt;<br/>         &lt;/td&gt;<br/>     &lt;/RowTemplate&gt;<br/> &lt;/ViewSwitcher&gt;</span></pre><p id="5aa6" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A轨迹列表现在被传递到ViewSwitcher中，而不必在模板中定义foreach循环。</strong></p><p id="83a4" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">GridTemplate现在更清晰了，因为我们不再需要定义网格和foreach循环。</p><p id="7153" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在使用RenderFragment &lt; T &gt;的模板中，我们现在可以通过一个名为context的变量来访问对象的属性。这允许在构建我们的标记时有很大的灵活性。</p><p id="a2f8" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">标题模板允许我们定义表格需要的列，但是没有我们以前所有的样板文件。</p><p id="59ad" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">轨迹列表现在通过<code class="du lc ld le lf b">Items</code>参数传递到<code class="du lc ld le lf b">ViewSwitcher</code>中。这意味着我们不再需要像以前一样担心在各种模板中定义<code class="du lc ld le lf b">foreach</code>循环。这样就把<code class="du lc ld le lf b">GridTemplate</code>整理了很多。我们现在只需要为单个项目定义标记。</p><p id="8480" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">由于<code class="du lc ld le lf b">GridTemplate</code>被定义为<code class="du lc ld le lf b">RenderFragment&lt;T&gt;</code>，我们可以在模板中访问<code class="du lc ld le lf b">T</code>的任何属性。我们通过一个名为<code class="du lc ld le lf b">context</code>的特殊参数来访问它们。由于<code class="du lc ld le lf b">TrailCard</code>组件需要一个<code class="du lc ld le lf b">Trail</code>的实例，我们可以将<code class="du lc ld le lf b">context</code>传递给<code class="du lc ld le lf b">Trail</code>参数。<code class="du lc ld le lf b">RowTemplate</code>在更大程度上显示了对<code class="du lc ld le lf b">T</code>属性的访问。</p><p id="49d0" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们做的另一个改变是添加了一个<code class="du lc ld le lf b">HeaderTemplate</code>,这样我们就可以定义我们的表的列，而不需要我们以前所有的额外的样板标记。如您所见，我们现在只需要定义单个单元格。这大大减少了我们需要编写的代码量。</p><p id="43c5" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这看起来很棒，但是我们还可以做一个小的改进来提高代码的可读性——<code class="du lc ld le lf b">context</code>参数。如果我们正在扫描一个组件，我们必须暂停一秒钟来理解上下文在这个场景中的含义。在我们的例子中，<code class="du lc ld le lf b">context</code>是一个<code class="du lc ld le lf b">Trail</code>。如果只是叫<code class="du lc ld le lf b">trail</code>代替岂不是很棒？我也这么认为好消息是，我们可以给它起任何我们喜欢的名字！下面的清单显示了带有重命名的上下文参数的<code class="du lc ld le lf b">HomePage</code>上的<code class="du lc ld le lf b">ViewSwitcher</code>。</p><p id="9eb7" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单6 HomePage.razor:重命名上下文变量</strong></p><pre class="kn ko kp kq fd mf lf mg mh aw mi bi"><span id="d999" class="lg lh hi lf b fi mj mk l ml mm">&lt;ViewSwitcher Items="_trails"&gt;<br/>     &lt;GridTemplate Context="trail"&gt;    #A<br/>         &lt;TrailCard Trail="trail"<br/> [CA]OnSelected="HandleTrailSelected" /&gt;    #B<br/>     &lt;/GridTemplate&gt;<br/>     &lt;HeaderTemplate&gt;<br/>         &lt;th&gt;Name&lt;/th&gt;<br/>         &lt;th&gt;Location&lt;/th&gt;<br/>         &lt;th&gt;Length&lt;/th&gt;<br/>         &lt;th&gt;Time&lt;/th&gt;<br/>         &lt;th&gt;&lt;/th&gt;<br/>     &lt;/HeaderTemplate&gt;<br/>     &lt;RowTemplate Context="trail"&gt;    #A<br/>         &lt;th scope="col"&gt;@trail.Name&lt;/th&gt;<br/>         &lt;td&gt;@trail.Location&lt;/td&gt;    #B<br/>         &lt;td&gt;@(trail.Length)km&lt;/td&gt;    #B<br/>         &lt;td&gt;@trail.TimeFormatted&lt;/td&gt;    #B<br/>         &lt;td class="text-right"&gt;<br/>             &lt;button @onclick="@(() =&gt;<br/> [CA]HandleTrailSelected(trail))" title="View"<br/> [CA]class="btn btn-primary"&gt;    #B<br/>                 &lt;i class="bi bi-binoculars"&gt;&lt;/i&gt;<br/>             &lt;/button&gt;<br/>             &lt;button @onclick="@(() =&gt;<br/> [CA]NavManager.NavigateTo($"/edit-trail/{trail.Id}"))"<br/> [CA]title="Edit" class="btn btn-outline-secondary"&gt;    #B<br/>                 &lt;i class="bi bi-pencil"&gt;&lt;/i&gt;<br/>             &lt;/button&gt;<br/>         &lt;/td&gt;<br/>     &lt;/RowTemplate&gt;<br/> &lt;/ViewSwitcher&gt;</span></pre><p id="b431" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A可使用上下文属性重命名上下文参数。</strong></p><p id="a05e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B一旦重命名，新名称可以在模板内用来引用对象。</strong></p><p id="94db" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们可以使用模板上的<code class="du lc ld le lf b">Context</code>属性重命名<code class="du lc ld le lf b">context</code>参数。仅当模板被定义为<code class="du lc ld le lf b">RenderFragment&lt;T&gt;</code>时才可用。重命名后，新名称可用于引用模板中显示的对象。如您所见，这使得代码可读性更强，一目了然。</p><p id="2ff3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们可以更进一步。我们可以在组件级重命名<code class="du lc ld le lf b">context</code>参数，所有的模板都会自动继承这个名称。请参见下面的清单。</p><p id="a23d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单7 HomePage.razor:在组件级别重命名上下文</strong></p><pre class="kn ko kp kq fd mf lf mg mh aw mi bi"><span id="7f67" class="lg lh hi lf b fi mj mk l ml mm">&lt;ViewSwitcher Items="_trails" Context="trail"&gt;    #A<br/>     &lt;GridTemplate&gt;<br/>         &lt;TrailCard Trail="trail"<br/> [CA]OnSelected="HandleTrailSelected" /&gt;    #B<br/>     &lt;/GridTemplate&gt;<br/>     &lt;HeaderTemplate&gt;<br/>         &lt;th&gt;Name&lt;/th&gt;<br/>         &lt;th&gt;Location&lt;/th&gt;<br/>         &lt;th&gt;Length&lt;/th&gt;<br/>         &lt;th&gt;Time&lt;/th&gt;<br/>         &lt;th&gt;&lt;/th&gt;<br/>     &lt;/HeaderTemplate&gt;<br/>     &lt;RowTemplate&gt;<br/>         &lt;th scope="col"&gt;@trail.Name&lt;/th&gt;<br/>         &lt;td&gt;@trail.Location&lt;/td&gt;    #B<br/>         &lt;td&gt;@(trail.Length)km&lt;/td&gt;    #B<br/>         &lt;td&gt;@trail.TimeFormatted&lt;/td&gt;    #B<br/>         &lt;td class="text-right"&gt;<br/>             &lt;button @onclick="@(() =&gt;<br/> [CA]HandleTrailSelected(trail))" title="View"<br/> [CA]class="btn btn-primary"&gt;    #B<br/>                 &lt;i class="bi bi-binoculars"&gt;&lt;/i&gt;<br/>             &lt;/button&gt;<br/>             &lt;button @onclick="@(() =&gt;<br/> [CA]NavManager.NavigateTo($"/edit-trail/{trail.Id}"))"<br/> [CA]title="Edit" class="btn btn-outline-secondary"&gt;    #B<br/>                 &lt;i class="bi bi-pencil"&gt;&lt;/i&gt;<br/>             &lt;/button&gt;<br/>         &lt;/td&gt;<br/>     &lt;/RowTemplate&gt;<br/> &lt;/ViewSwitcher&gt;</span></pre><p id="4db8" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A上下文参数在组件级被重命名。</strong></p><p id="a033" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B一旦重命名，新名称可以在模板内用来引用对象。</strong></p><p id="4627" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">通过在组件级别重命名<code class="du lc ld le lf b">context</code>参数，我们可以从每个模板中删除单独的名称。</p><p id="c878" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">本文到此为止。感谢阅读。</p></div></div>    
</body>
</html>