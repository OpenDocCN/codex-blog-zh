<html>
<head>
<title>Journey to MIT 6.824 — Lab 2A Raft Leader Election</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">麻省理工学院之旅6.824——实验室2A筏领导选举</h1>
<blockquote>原文：<a href="https://medium.com/codex/journey-to-mit-6-824-lab-2a-raft-leader-election-974087a55740?source=collection_archive---------4-----------------------#2021-07-14">https://medium.com/codex/journey-to-mit-6-824-lab-2a-raft-leader-election-974087a55740?source=collection_archive---------4-----------------------#2021-07-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bfda2f769404d8a9691459bc74b495e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d32VhSaalJwJWI_d"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@glencarrie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格伦·凯莉</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="9e1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">距离实验一已经有一段时间了，这次我将讲述我是如何完成实验二Raft实现的。如果你对实验室一感兴趣，请查看这个<a class="ae iu" rel="noopener" href="/codex/journey-to-mit-6-824-lab-1-mapreduce-ebe58800ef9e">https://medium . com/codex/journey-to-MIT-6-824-la b-1-MapReduce-ebe 58800 ef9 e</a>。</p><h1 id="c4ea" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">筏板概述</h1><p id="fdfe" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">首先，我们来对Raft做一个概述。Raft是管理复制日志的一致算法。我理解的Raft的核心思想是:</p><ul class=""><li id="556d" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">任何时候只有一个领导者才能避免大脑分裂的问题。</li><li id="385e" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">提交的日志保证被大多数人复制，因此它们不会丢失。</li><li id="f390" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">Raft非常好理解，可以用来构建现实世界的系统。<code class="du lk ll lm ln b">etcd</code>在k8s中是使用Raft算法进行容错的。</li></ul><p id="95aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文<a class="ae iu" href="https://www.usenix.org/system/files/conference/atc14/atc14-paper-ongaro.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> <em class="lo">寻找可理解的共识算法</em> </strong> </a> <em class="lo"> </em>涵盖了你需要了解的关于Raft的每一个细节，我强烈推荐仔细阅读多次。</p><p id="9ceb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本实验分为四个部分:a)领导者选举，b)日志，c)持续，d)日志压缩，我将逐一讲解。</p><h1 id="c1da" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">2A工党领袖选举</h1><p id="3ed0" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在整个实验2中，我们只需要在文件<code class="du lk ll lm ln b">raft.go</code>中编写代码。A部分是关于领导者选举的，测试将创建多个服务器，并在超时前断言预期的领导者选举。</p><h2 id="6f53" class="lp ju hi bd jv lq lr ls jz lt lu lv kd jg lw lx kh jk ly lz kl jo ma mb kp mc bi translated">设计概述</h2><p id="8642" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">让我们回顾一下上面的文章在高层次上介绍的领导人是如何选举产生的。</p><p id="28f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，在集群初始化时，所有服务器都作为从服务器启动。每个服务器将启动一个随机选择时间的计时器。当这个计时器触发时，服务器将自己从跟随者变成候选人。与此同时，它增加期限，并向所有对等方发送消息请求投票，然后等待回复。</p><p id="ea5a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当服务器收到投票请求时，它仅在以下情况下投票:</p><ul class=""><li id="1678" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">候选人有更高的任期</li><li id="cc8d" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">如果候选人有相同的术语，但日志至少是最新的。</li></ul><p id="28df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">否则，投票请求将被拒绝。一个对等体只能为一个任期的候选人投票，但当它收到另一个任期比它投票的候选人更长的投票请求时，它将放弃以前的投票。</p><p id="62b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果候选人在下一次计时器启动前没有获得足够的选票，当前的投票将无效，候选人将开始新的任期更长的选举。</p><p id="3cf0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦候选人收到大多数同伴的投票，它就从候选人变成领导者，并立即广播权威以阻止其他服务器开始领导者选举。领导者将定期广播该信息。</p><p id="4634" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是关于设计的概述，现在让我们深入研究一下实现。</p><h2 id="1972" class="lp ju hi bd jv lq lr ls jz lt lu lv kd jg lw lx kh jk ly lz kl jo ma mb kp mc bi translated">数据结构</h2><p id="e59b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对于第2部分，我们需要实现两个RPC调用:<code class="du lk ll lm ln b">RquestVote</code>和<code class="du lk ll lm ln b">AppendEntries</code>以及请求投票或追加条目的ticker，以及支持它们的数据结构。</p><p id="7a58" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">先说数据结构。根据上面的设计评审，除了实验室提供的字段，我们还需要:</p><ul class=""><li id="4888" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated"><code class="du lk ll lm ln b">currentTerm</code>表示本服务器的当前期限</li><li id="6bf6" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><code class="du lk ll lm ln b">votedFor</code>表明这个仆人在选举中投票给了谁</li><li id="68e7" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><code class="du lk ll lm ln b">leaderId</code>说出谁是现任领导人</li><li id="dac3" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><code class="du lk ll lm ln b">state</code>表示服务者是追随者、候选人还是领导者</li><li id="884b" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><code class="du lk ll lm ln b">electionTimer</code>开始新的选举</li><li id="efa6" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><code class="du lk ll lm ln b">heartbeatTicker</code>定期追加领导条目</li><li id="8bae" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><code class="du lk ll lm ln b">logs</code>表示服务器拥有的日志条目</li></ul><p id="59e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，筏形结构看起来如下:</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="6473" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">请求投票</strong></p><p id="8cff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们实现请求投票RPC。在实验室提供的框架中，每个服务器实例已经有了一个<code class="du lk ll lm ln b">ticker()</code>函数，而<code class="du lk ll lm ln b">elelctionTimer</code>应该在Make()函数中初始化。根据这篇论文，计时器应该是一个仔细选择的随机值。在本实验中，我们使用300毫秒到450毫秒之间的随机值来避免分裂投票问题。</p><p id="3c44" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">即使在实验说明中，也不建议使用定时器和go的ticker，因为定时器本身有一些微妙的技巧。我仍然相信使用它们利大于弊。</p><p id="a408" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在ticker()中添加当<code class="du lk ll lm ln b">electionTimer</code>触发时的处理程序:</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="679e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们深入探讨一下当这个计时器触发时应该做些什么。</p><p id="0a43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，每当计时器触发时，我们需要用一个新值重置计时器，这样计时器就可以重复触发。如果服务器状态是leader，则什么都不做并返回，否则将服务器状态设置为候选并递增<code class="du lk ll lm ln b">currentTerm</code>。</p><p id="3247" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，服务器应该将<code class="du lk ll lm ln b">requestVote</code>消息发送给它的所有对等点。消息参数应该包含服务器的当前术语、候选id、最后一个日志索引(即<code class="du lk ll lm ln b">len(rf.logs)</code>)和最后一个日志的术语(在2A实验室中始终为0)。注意，这些RPC消息应该并行发送，所以我们为每个RPC调用启动一个goroutine，并创建一个通道来接收对等体的投票结果。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="bafa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有消息发出后，它会一直监听结果通道来统计投票结果。如果成功接收到响应并检查投票是否被授权，否则，认为投票未被授权(或者，服务器可以继续发送请求投票，直到接收到响应)。</p><p id="624b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果收到多数人的投票，服务器就声称它赢得了选举，并向当局广播。但在此之前，有一个角落的情况下，服务器的状态被改为追随者，因为当它正在计算投票结果，另一个服务器已经赢得了选举。在这种情况下，服务器除了终止选举之外什么也不做。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="1c54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是服务器请求投票的方式。现在让我们看看服务器如何响应投票请求。</p><p id="eac7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果请求中的项较小，这是一个过时的选举，请求应该被拒绝。</p><p id="ace6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果请求中的术语高于服务器的术语，这意味着正在进行新的选举，如果服务器曾经对以前的术语投过票，服务器应该重置其投票。</p><p id="e61c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">否则，如果服务器没有投票，或者服务器已经投票给了这个候选人(如果RPC响应没有到达候选人，并且RPC被重试)，服务器应该对这两种情况中的任何一种进行投票:</p><ul class=""><li id="8d60" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">候选人的上一任期高于服务器的上一任期。</li><li id="8036" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">候选项的最后一项等于服务器的最后一项，但候选项的日志等于或多于服务器。</li></ul><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><h2 id="6901" class="lp ju hi bd jv lq lr ls jz lt lu lv kd jg lw lx kh jk ly lz kl jo ma mb kp mc bi translated">追加条目</h2><p id="4488" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">一旦服务器被选为领导者，它应该在<code class="du lk ll lm ln b">AppendEntries</code> RPC调用中广播它的权限。在lab2a中，没有日志，但是<code class="du lk ll lm ln b">AppendEntries</code>仍然作为心跳被周期性地调用。服务器在实验室框架提供的<code class="du lk ll lm ln b">Make()</code>函数中初始化心跳ticker，并在<code class="du lk ll lm ln b">ticker()</code>函数中处理ticker fires信号。注意:在本实验中，测试预计每秒不超过10次心跳，因此最小心跳间隔为100毫秒。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="6f25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm ln b">sendAppendEntries</code>只是使用go例程发送RPC消息，包括领导者的当前任期、领导者id和日志(lab2a中为空)。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="606a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在lab2a中，响应<code class="du lk ll lm ln b">AppendEntries</code>也很简单。如果领导任期更小，就返回false。否则，服务器确保其保持为追随者状态，重置其选举计时器，并为其状态分配领导者的任期和领导者id。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="6a2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经实现了lab2a的大部分内容，但是我们还必须实现<code class="du lk ll lm ln b">GetState</code>来让所有的测试都通过，这将返回当前的术语和一个bool值，表明这个服务器是否认为它是领导者。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="a55d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们运行测试，我们应该看到所有测试都通过了:</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/832ef254d830e88eb6d398740c303a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*EJV27IdyE2fax0pAXzjfkw.png"/></div></figure><h2 id="a49c" class="lp ju hi bd jv lq lr ls jz lt lu lv kd jg lw lx kh jk ly lz kl jo ma mb kp mc bi translated">诀窍和提示</h2><p id="bf56" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这个实验室在<code class="du lk ll lm ln b">util.go</code>文件中提供了一个有用的记录器。但是，时间戳和打印的日志在分钟级别停止，这对于调试来说是不够的。我们可以很容易地让它打印出带有微秒时间戳的日志，以便于调试，这在测试由于奇怪的原因失败时帮了我很大的忙。</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="fc26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你像我一样使用<code class="du lk ll lm ln b">time.Timer</code>，很可能你的程序会在测试中永远挂起。原因是与定时器相关联的信道的竞争条件。通常情况下，定时器的用法如下:</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="04d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住<code class="du lk ll lm ln b">ticker()</code>功能也读取频道，所以有可能频道在<code class="du lk ll lm ln b">ticker()</code>内被耗尽，但是定时器没有完全停止。如果我们再次重置计时器，它将停留在从该频道读取。要解决这个问题，稍微修改一下停止计时器的代码:</p><figure class="md me mf mg fd ij"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="72ee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种情况下，如果在定时器停止之前通道已经排空，它将什么也不做。</p><p id="903f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这部分的完整代码可以在<a class="ae iu" href="https://github.com/QingpingMeng/mit6.824/pull/2" rel="noopener ugc nofollow" target="_blank">https://github.com/QingpingMeng/mit6.824/pull/2</a>找到。感谢阅读！</p></div></div>    
</body>
</html>