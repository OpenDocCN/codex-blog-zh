<html>
<head>
<title>How (and Why) You Should Split Your .bashrc or .zshrc Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该如何(以及为什么)分割你的。巴沙尔或者。zshrc文件</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-and-why-you-should-split-your-bashrc-or-zshrc-files-285e5cc3c843?source=collection_archive---------2-----------------------#2021-12-19">https://medium.com/codex/how-and-why-you-should-split-your-bashrc-or-zshrc-files-285e5cc3c843?source=collection_archive---------2-----------------------#2021-12-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="94d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只有几行代码的可伸缩Bash/Zsh启动脚本</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/6e80d5881bf4a1161cf8f326d03d0f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7rW0yPshlj-wLowL"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae jt" href="https://unsplash.com/@jeremythomasphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰瑞米·托马斯</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="e5b7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">目标</h1><ul class=""><li id="c8f6" class="ks kt hi ih b ii ku im kv iq kw iu kx iy ky jc kz la lb lc bi translated">要将我们的<code class="du ld le lf lg b">.bashrc</code> / <code class="du ld le lf lg b">.zshrc</code>拆分成多个文件，放在<code class="du ld le lf lg b">zshrc</code>文件夹中，然后逐个加载:</li></ul><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="4cdc" class="ll jv hi lg b fi lm ln l lo lp">for FILE in ~/<strong class="lg hj">zshrc</strong>/*; do<br/>    <strong class="lg hj">source</strong> $FILE<br/>done</span></pre><h1 id="3f7c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">背景</h1><p id="7ec8" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated"><code class="du ld le lf lg b">.bashrc</code> / <code class="du ld le lf lg b">.zshrc</code>主要在我们启动终端app的时候执行。通常，它包含我们的自定义别名/快捷方式、函数/命令、外壳变量和环境变量，以帮助我们的工作流。</p><p id="855e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，随着时间的推移，当我们修补各种框架、实用程序或项目时，这很容易变得混乱。甚至在工作中，我们可能需要自动化重复的任务/命令来提高生产力/效率。因此，我们会不时更新这些文件。起初的小花园可能会演变成更难维持的茂密森林。</p><h2 id="2240" class="ll jv hi bd jw lt lu lv ka lw lx ly ke iq lz ma ki iu mb mc km iy md me kq mf bi translated">拆分Vim设置</h2><p id="3b42" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">我之前有一个长度<code class="du ld le lf lg b">.vimrc</code> / <code class="du ld le lf lg b">init.vim</code>的设置，所以我把它拆分成更模块化的，这样主加载程序甚至可以自动检测/加载新文件。使<a class="ae jt" href="https://github.com/ranelpadon/configs/tree/master/nvim" rel="noopener ugc nofollow" target="_blank">我的设置</a>更具可扩展性:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="9666" class="ll jv hi lg b fi lm ln l lo lp">runtime settings.vim                             <br/>runtime plugins.vim<br/>runtime mappings.vim                                                          </span><span id="4363" class="ll jv hi lg b fi mg ln l lo lp">" `!` is needed to load all files in the folder.                             runtime! themes/*.vim                             <br/>runtime! plugins-config/*.vim</span></pre><h2 id="6089" class="ll jv hi bd jw lt lu lv ka lw lx ly ke iq lz ma ki iu mb mc km iy md me kq mf bi translated">拆分Zsh设置</h2><p id="7a51" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">同样，我之前的<code class="du ld le lf lg b">.zshrc</code>中有超过<strong class="ih hj">1500</strong>行，现在的<a class="ae jt" href="https://github.com/ranelpadon/configs/blob/master/.zshrc" rel="noopener ugc nofollow" target="_blank">只有几行</a>。下面将解释它的简化版本。大多数人也会有更简单的用例。</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="ea1e" class="ll jv hi lg b fi lm ln l lo lp">CONFIGS=$HOME/dev/configs                                                           <strong class="lg hj">source</strong> $CONFIGS/zshrc/init.sh                                                                                    </span><span id="a0e1" class="ll jv hi lg b fi mg ln l lo lp">FILES_STR=$(fd --glob '*.sh' --exclude 'init.sh' $CONFIGS/zshrc)<br/>FILES=($(echo $FILES_STR | tr '\n' ' '))                                                                                      </span><span id="6cf2" class="ll jv hi lg b fi mg ln l lo lp">for FILE in <strong class="lg hj">$FILES</strong>; do                                 <br/>    <strong class="lg hj">source</strong> $FILE                             <br/>done</span></pre><h2 id="f111" class="ll jv hi bd jw lt lu lv ka lw lx ly ke iq lz ma ki iu mb mc km iy md me kq mf bi translated">利益</h2><p id="e06d" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">模块化设置是一种很好的做法，原因如下:</p><ul class=""><li id="2684" class="ks kt hi ih b ii ij im in iq mh iu mi iy mj jc kz la lb lc bi translated">相关内容将被分组在一起，这意味着更好地分离关注点。</li><li id="a565" class="ks kt hi ih b ii mk im ml iq mm iu mn iy mo jc kz la lb lc bi translated">系统将更具可扩展性，因为未来的分割文件也将自动加载，无需更新<code class="du ld le lf lg b">.zshrc</code>。</li><li id="b3ef" class="ks kt hi ih b ii mk im ml iq mm iu mn iy mo jc kz la lb lc bi translated">首先将内容分开会迫使你一个接一个地检查你所有的设置，并发现过时的、未使用的或重复的设置。这也将迫使你学习更多关于shell脚本的知识，因为你会注意到有重复的模式，它们可以被提取出来以便更好地重用代码。最终结果是一个更精简的系统。请注意，根据最新的StackOverflow调查，shell脚本是<a class="ae jt" href="https://insights.stackoverflow.com/survey/2021#section-top-paying-technologies-top-paying-technologies" rel="noopener ugc nofollow" target="_blank">收入最高的技术之一。</a></li></ul><h1 id="4fe4" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">分布式源</h1><p id="18f7" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">这里的命令主要假设使用<code class="du ld le lf lg b">zsh</code> ( <code class="du ld le lf lg b">.zshrc</code>)，但是即使使用<code class="du ld le lf lg b">bash</code> ( <code class="du ld le lf lg b">.bashrc</code> / <code class="du ld le lf lg b">.bash_profile</code>或者其他shells，思路也是一样的。</p><h2 id="ff62" class="ll jv hi bd jw lt lu lv ka lw lx ly ke iq lz ma ki iu mb mc km iy md me kq mf bi translated">1.创建脚本文件夹</h2><p id="6e7e" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">我们需要创建目标文件夹来包含分割的文件。为了简单起见，我们可以创建<code class="du ld le lf lg b">~/zshrc</code>文件夹(即没有一个点来区分它和主<code class="du ld le lf lg b">~/.zshrc</code>文件)。</p><h2 id="7b2d" class="ll jv hi bd jw lt lu lv ka lw lx ly ke iq lz ma ki iu mb mc km iy md me kq mf bi translated">2.创建脚本文件</h2><p id="5718" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">我们可以开始查看<code class="du ld le lf lg b">.zshrc</code>文件的内容。然后，像下面的文件一样将每个主题的相关内容分组。注意，文件扩展名无关紧要，<code class="du ld le lf lg b">source</code> shell命令只关心文件内容。我只是使用<code class="du ld le lf lg b">.sh</code>作为<code class="du ld le lf lg b">zsh</code>和<code class="du ld le lf lg b">bash</code>外壳的通用/总括术语:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="4052" class="ll jv hi lg b fi lm ln l lo lp">~/zshrc<br/>  ├── git.sh<br/>  ├── js.sh <br/>  ├── python.sh<br/>  ├── django.sh<br/>  ├── docker.sh<br/>  ├── general.sh<br/>  ├── init.sh</span></pre><p id="d033" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样我们就有了两个特殊的文件:</p><ul class=""><li id="6b07" class="ks kt hi ih b ii ij im in iq mh iu mi iy mj jc kz la lb lc bi translated"><code class="du ld le lf lg b">init.sh</code>包含外壳(<code class="du ld le lf lg b">zsh</code>)需要的东西，比如初始化器、插件、主题等等。</li><li id="23a5" class="ks kt hi ih b ii mk im ml iq mm iu mn iy mo jc kz la lb lc bi translated"><code class="du ld le lf lg b">general.sh</code>包含所有不属于当前分割文件的内容，太少以至于不能保证一个专用文件。这将是不容易分类的东西的默认文件。</li></ul><h2 id="0ead" class="ll jv hi bd jw lt lu lv ka lw lx ly ke iq lz ma ki iu mb mc km iy md me kq mf bi translated">3.更新主加载程序</h2><p id="403a" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">然后，我们的<code class="du ld le lf lg b">~/.zshrc</code>可以简单地加载/获取文件夹中所有的<code class="du ld le lf lg b">.sh</code>分割文件。更具体地说，你可以使用<code class="du ld le lf lg b">*.sh</code>而不是仅仅<code class="du ld le lf lg b">*</code>:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="f799" class="ll jv hi lg b fi lm ln l lo lp">for FILE in ~/<strong class="lg hj">zshrc</strong>/*; do<br/>    <strong class="lg hj">source</strong> $FILE<br/>done</span></pre><p id="b867" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们会有这样的逻辑结构:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="610f" class="ll jv hi lg b fi lm ln l lo lp">~/.zshrc<br/>~/zshrc<br/>  ├── git.sh<br/>  ├── js.sh <br/>  ├── python.sh<br/>  ├── django.sh<br/>  ├── docker.sh<br/>  ├── general.sh<br/>  ├── init.sh</span></pre><h2 id="0d6a" class="ll jv hi bd jw lt lu lv ka lw lx ly ke iq lz ma ki iu mb mc km iy md me kq mf bi translated">未来更新</h2><p id="2b1d" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">我们现在有了一个可扩展的系统。对于未来的变化:</p><ul class=""><li id="e01f" class="ks kt hi ih b ii ij im in iq mh iu mi iy mj jc kz la lb lc bi translated">检查新的别名/命令/envvar是否可以放入公共分割文件中(例如在<code class="du ld le lf lg b">git.sh</code>、<code class="du ld le lf lg b">python.sh</code>等)并放在那里</li><li id="0a7c" class="ks kt hi ih b ii mk im ml iq mm iu mn iy mo jc kz la lb lc bi translated">如果它不属于任何地方，就把它放在<code class="du ld le lf lg b">general.sh</code>作为默认目的地</li><li id="c8ee" class="ks kt hi ih b ii mk im ml iq mm iu mn iy mo jc kz la lb lc bi translated">一旦<code class="du ld le lf lg b">general.sh</code>中已经有了大量的相关内容，你可以把它们放在一个新的专用/分割文件中。</li></ul><p id="a0b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它的美妙之处在于<code class="du ld le lf lg b">~/.zshrc</code>甚至会自动加载新添加的文件。因此，不需要更新它的内容。</p><h1 id="1f54" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">关键来源</h1><p id="1ffd" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">其他人可能会在这一点上停止，如果他们对<code class="du ld le lf lg b">~/.zshrc</code>中的上述命令没有意见的话。但是有时有些脚本需要在其他脚本之前先加载，您可以将它们放在<code class="du ld le lf lg b">init.sh</code>中。</p><p id="ef95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有各种策略可以解决这个问题，但最简单的一个是:</p><ul class=""><li id="a518" class="ks kt hi ih b ii ij im in iq mh iu mi iy mj jc kz la lb lc bi translated">先装上<code class="du ld le lf lg b">init.sh</code></li><li id="e32c" class="ks kt hi ih b ii mk im ml iq mm iu mn iy mo jc kz la lb lc bi translated">然后，加载其他脚本</li></ul><h2 id="264d" class="ll jv hi bd jw lt lu lv ka lw lx ly ke iq lz ma ki iu mb mc km iy md me kq mf bi translated">使用“查找”实用程序</h2><p id="74ff" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">我们可以像这样:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="ca60" class="ll jv hi lg b fi lm ln l lo lp"># Load the 'init.sh'.<br/><strong class="lg hj">source</strong> ~/zshrc/init.sh</span><span id="ea0e" class="ll jv hi lg b fi mg ln l lo lp"># Find all '.sh' files in ~/zshrc, exclude 'init.sh'.<br/>FILES_STR=$(find ~/zshrc -name '*.sh' -not -name 'init.sh')</span><span id="b96f" class="ll jv hi lg b fi mg ln l lo lp"># `tr` is a find-and-replace utility.<br/># Outer () will convert the output of $() to array.<br/>FILES=($(echo $FILES_STR | tr '\n' ' '))</span><span id="7a0a" class="ll jv hi lg b fi mg ln l lo lp">for FILE in <strong class="lg hj">$FILES</strong>; do<br/>    <strong class="lg hj">source</strong> $FILE<br/>done</span></pre><h2 id="7e3d" class="ll jv hi bd jw lt lu lv ka lw lx ly ke iq lz ma ki iu mb mc km iy md me kq mf bi translated">使用“fd”实用程序</h2><p id="6f74" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">如果你像我一样是<code class="du ld le lf lg b"><a class="ae jt" href="https://github.com/sharkdp/fd" rel="noopener ugc nofollow" target="_blank">fd</a></code>的粉丝，它是<code class="du ld le lf lg b">find</code>的现代/更快版本，你只需要改变<code class="du ld le lf lg b">FILES_STR</code>的值:</p><pre class="je jf jg jh fd lh lg li lj aw lk bi"><span id="63e7" class="ll jv hi lg b fi lm ln l lo lp"># Load the 'init.sh'.<br/><strong class="lg hj">source</strong> ~/zshrc/init.sh</span><span id="c5fb" class="ll jv hi lg b fi mg ln l lo lp"># Find all .sh files in ~/zshrc, exclude 'init.sh'.<br/>FILES_STR=$(fd --glob '*.sh' --exclude 'init.sh' ~/zshrc)</span><span id="747f" class="ll jv hi lg b fi mg ln l lo lp"># 'tr' is a find-and-replace utility.<br/># Outer () will convert the output of $() to array.<br/>FILES=($(echo $FILES_STR | tr '\n' ' '))</span><span id="c162" class="ll jv hi lg b fi mg ln l lo lp">for FILE in <strong class="lg hj">$FILES</strong>; do<br/>    <strong class="lg hj">source</strong> $FILE<br/>done</span></pre><h1 id="0113" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">关键要点</h1><ul class=""><li id="6119" class="ks kt hi ih b ii ku im kv iq kw iu kx iy ky jc kz la lb lc bi translated">Shell启动脚本对于提高我们的效率非常有用。</li><li id="ac30" class="ks kt hi ih b ii mk im ml iq mm iu mn iy mo jc kz la lb lc bi translated">从单个<code class="du ld le lf lg b">.zshrc</code> / <code class="du ld le lf lg b">.bashrc</code>或者从其分割的文件中获取资源在性能上没有明显的区别。</li><li id="20ae" class="ks kt hi ih b ii mk im ml iq mm iu mn iy mo jc kz la lb lc bi translated">分割文件将意味着更好的模块化、关注点分离和可伸缩性。未来的更新将更加容易和易于管理。</li><li id="ca8c" class="ks kt hi ih b ii mk im ml iq mm iu mn iy mo jc kz la lb lc bi translated">每个文件的范围越小，意味着越容易发现过时和未使用的内容，或者会迫使您重构它们的重叠使用。这个过程可以增强您的shell脚本技能。</li><li id="d31f" class="ks kt hi ih b ii mk im ml iq mm iu mn iy mo jc kz la lb lc bi translated">我们可以先加载关键文件，然后加载其他非关键文件。我们可以使用<code class="du ld le lf lg b">find</code> / <code class="du ld le lf lg b">fd</code> CLI实用程序来查找/排除文件。</li></ul></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="6b99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi mw translated">感谢您的阅读。如果你发现了一些价值，请关注我，或者为文章鼓掌/评论，或者<a class="ae jt" href="https://ko-fi.com/ranelpadon" rel="noopener ugc nofollow" target="_blank">请我喝杯咖啡</a>。这对我意义重大，鼓励我创作更多高质量的内容。</p></div></div>    
</body>
</html>