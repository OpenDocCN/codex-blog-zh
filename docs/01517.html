<html>
<head>
<title>Best practices with Entity Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实体框架的最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/codex/best-practices-with-entity-framework-567ac9d5493a?source=collection_archive---------0-----------------------#2021-05-09">https://medium.com/codex/best-practices-with-entity-framework-567ac9d5493a?source=collection_archive---------0-----------------------#2021-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4ca1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实体框架为开发人员提供了很多便利，但在某些情况下，也会给用户带来性能损失。开发人员的工作就是充分利用实体框架，同时保持良好的用户体验。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a077b95af347c3d9e961a64d40cea201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dsMhvjq7FAhUwLW35icrkw.png"/></div></div></figure><p id="8be0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我曾经很长一段时间使用SQL查询编写代码。但是在转移到实体框架之后，我无法想象回去。模型对象中整个数据库表的抽象使得管理数据库和推出更新变得非常容易，而不用担心破坏任何功能。</p><p id="62b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你像我一样，喜欢将大多数数据库操作放在应用程序代码中，而不是放在数据库中(存储过程、触发器等)。)，你可能也遇到过实体框架的性能问题。根据使用情况，在大多数情况下，性能损失可以忽略不计。例如，如果您插入、更新或删除单个记录，这种差异通常不明显。但是，在执行批量操作时，实体框架可能会导致严重的延迟。</p><p id="dccc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些年来，我学到了一些避免性能损失的最佳实践，同时仍然保持实体框架的能力。</p><h1 id="c437" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">永远不要使用RemoveRange！</h1><p id="38b7" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">有时，您需要根据条件删除多条记录，EntityFramework提供的默认方法是RemoveRange。</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="c910" class="kx jq hi kt b fi ky kz l la lb">db.Table.RemoveRange(db.Table.Where(a =&gt; a.Price &lt;= 0).ToList())</span></pre><p id="8a39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述方法的问题是，它为底层查询返回的每一条记录触发一个删除查询。例如，如果查询<code class="du lc ld le kt b">db.Table.Where(a =&gt; a.Price &lt;= 0)</code> <em class="lf"> </em>产生20条记录，那么实体框架将向数据库触发20次删除查询。这是非常低效的，应该完全避免(如果数字是20可能还可以，但是到了2000就不行了！).有一个名为<em class="lf">Z . entity framework . extensions</em>的<strong class="ih hj"> <em class="lf"> Nuget </em> </strong>包，使得这个更加健壮。使用这个扩展包，您可以编写如下查询:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="9897" class="kx jq hi kt b fi ky kz l la lb">db.Table.Where(a =&gt; a.Price &lt;= 0).DeleteFromQuery()</span></pre><p id="59a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个扩展有一个免费版本，支持DeleteFromQuery和许多其他方法。要安装免费的<strong class="ih hj"> <em class="lf"> Nuget </em> </strong>，在Nuget包管理器中搜索<em class="lf"> z.entity </em>。</p><h1 id="95f0" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">不要在DbContext实例中循环！</h1><p id="9310" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">通常，当您启动DbContext实例时，它看起来像这样:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="ffb5" class="kx jq hi kt b fi ky kz l la lb">using (AppDbContext db = new AppDbContext())<br/>{<br/>   // your code here<br/>}</span></pre><p id="02e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个实例中放一个for/while循环从来都不是一个好主意，如果循环中的<strong class="ih hj"><em class="lf"/></strong>有一些Db操作正在进行。基本上发生的是，每次迭代，实体框架保持跟踪实体(即使你在循环中调用SaveChanges)。随着迭代次数的增加，运算时间会不断增加。如果您的循环迭代1000次，您的第1000次迭代时间可能会比第一次迭代多10000倍(这不是经过测试或测量的数字，只是指示影响的粗略估计)。</p><p id="d2b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，最好在循环中实例化DbContext的新实例:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="2bd4" class="kx jq hi kt b fi ky kz l la lb">foreach(var x in items)<br/>{<br/>   using (AppDbContext db = new AppDbContext())<br/>   {<br/>       // your code here<br/>   }<br/>}</span></pre><p id="2f59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">。NET Core users </strong>:如果您使用DbContext作为依赖注入，那么避免使用DbContext实例进行批量/循环操作可能是个好主意。创建DbContext类的另一个构造函数，您可以使用上面显示的 语句用<strong class="ih hj"> <em class="lf">直接调用它。</em></strong></p><h1 id="d486" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">仅在必要时使用ExecuteSqlCommand</h1><p id="17da" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">ExecuteSqlCommand相当于对数据库执行原始SQL查询，其中实体框架不执行任何实体跟踪/验证。</p><p id="bf80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，在某些情况下，您可能无法避免使用它。例如，您可能需要归档表中超过6个月的记录。在这种情况下，运行单个查询并更新相关的列比在EF中提取记录并逐个更新更容易。一个例子可能是:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="c47a" class="kx jq hi kt b fi ky kz l la lb">using (AppDbContext db = new AppDbContext())<br/>{<br/>   string command = "UPDATE Table1 SET Archived=1 <br/>                     WHERE DateCreated &lt; DATEADD(MONTH, -12, GETUTCDATE())";<br/>   db.Database.ExecuteSqlCommand(command);<br/>}</span></pre><p id="97fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我在开始时提到的，上面的命令是一个原始查询，因此很容易出错。如果数据库模式发生变化，例如，如果您重命名<strong class="ih hj"> <em class="lf"> Table1 </em> </strong>或重命名任意列<strong class="ih hj"> <em class="lf"> Archived </em> </strong>或<strong class="ih hj"> <em class="lf"> DateCreated </em> </strong>，上述代码将在运行时中断。但是，您的代码仍然可以很好地编译(查询只是一个文本字符串)。</p><p id="b5cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了避免这样的失败，在应用程序中用惟一的标识符标记这样的代码块是一个好主意，比如添加一个注释<code class="du lc ld le kt b">//RAW_QUERY</code>。使用这样的注释，您可以在每次更新DB模式并在查询中进行必要的更改时，在整个应用程序中查找并检查所有这样的情况。</p><h1 id="6b11" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">避免在模型类上定义外键</h1><p id="fc2a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">根据EF文档，建议在数据库级别维护您的外键。如果您使用代码优先迁移，那么您可能需要在模型类上定义外键关系，以便迁移可以自动为您创建它们。我还是建议不要这样。如果数据库模式相对较小，比如少于20–30个表，建议在数据库中手动创建FK，并将模型仅作为表列及其数据类型的表示。</p><p id="1fd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在模型类中定义fk本身会带来很多复杂性(比如延迟加载)，这超出了本文的范围。即使您这样做了，实体框架也无法确保您的数据不违反任何外键。</p><p id="d594" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，让数据库通过维护关系、键、索引等来维护数据完整性。尽可能只对CRUD操作使用实体框架。</p><h1 id="fc73" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">给你的桌子命名</h1><p id="2d90" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">实体框架遵循多元化模式，从模型类名派生数据库表名。例如，名为<code class="du lc ld le kt b">Customer</code>的模型类将被解释为<code class="du lc ld le kt b">Customers</code>表。这并非不可预测，但对我个人来说感觉模糊不清。例如，一个表名<code class="du lc ld le kt b">CustomerInfo</code>不会变成<code class="du lc ld le kt b">CustomerInfos</code>，但会变成<code class="du lc ld le kt b">CustomerInfoes</code>。另一个问题是你的DbSet名称可以完全不同，EF仍然基于模型类名查询数据库。考虑这个例子:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="dc1c" class="kx jq hi kt b fi ky kz l la lb">//Model Class<br/>public class <strong class="kt hj">Customer </strong><br/>{<br/>   public int Id {get; set;}<br/>   public string Name {get; set;}<br/>}</span><span id="3e17" class="kx jq hi kt b fi lg kz l la lb">//DbSet<br/>public virtual DbSet&lt;<strong class="kt hj">Customer</strong>&gt; <strong class="kt hj">Clients</strong> {get; set;}</span></pre><p id="b17b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到，在上面的示例中，模型名称(客户)、数据库集名称(客户)和实际数据库表名称(客户)可以是3个不同的值。您可能会问，为什么会在数据库集中出现像“Clients”这样的名称。它发生了，当你在一个项目上工作了几个月或几年，并且发生了许多变化，这很可能会发生。相信我，我是凭经验说的。</p><p id="a2dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，为了解决这个问题。</p><p id="089b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以指示DbContext根本不使用复数。但是在这种情况下，您的模型类名应该与数据库表名相同。这似乎不是正确的方法。</p><p id="0353" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对我来说，最好的方法是在模型类的顶部声明表名:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="84f2" class="kx jq hi kt b fi ky kz l la lb">[Table("Customers")]<br/>public class Customer <br/>{<br/>   public int Id {get; set;}<br/>   public string Name {get; set;}<br/>}</span></pre><p id="624a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，当您启动一个实体框架命令时，您可以100%确定在数据库中查询的是什么表名。</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="cbd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些是我在过去多年开发的基础上，对实体框架的最高认识和最佳实践。</p><p id="b4af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请在评论中告诉我你的不同意见、改进或想法。</p><blockquote class="lo lp lq"><p id="cba2" class="if ig lf ih b ii ij ik il im in io ip lr ir is it ls iv iw ix lt iz ja jb jc hb bi translated">软件永远不会完成，只会被抛弃。</p></blockquote></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="e822" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了阅读我所有的故事，以及媒体上成千上万的其他作家，考虑选择媒体会员。如果你<a class="ae lu" href="https://prashantio.medium.com/membership" rel="noopener">使用我的链接</a>加入，我将从你的加入费中获得佣金。祝你好运！</p></div></div>    
</body>
</html>