<html>
<head>
<title>On replacing componentDidUpdate and other React life cycle methods with hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用钩子替换componentDidUpdate和其他React生命周期方法</h1>
<blockquote>原文：<a href="https://medium.com/codex/on-replacing-componentdidupdate-and-other-react-life-cycle-methods-with-hooks-a18f1b109f5e?source=collection_archive---------7-----------------------#2021-09-08">https://medium.com/codex/on-replacing-componentdidupdate-and-other-react-life-cycle-methods-with-hooks-a18f1b109f5e?source=collection_archive---------7-----------------------#2021-09-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="63d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://joshgoestoflatiron.medium.com/april-2-intervals-and-event-listeners-when-working-with-react-hooks-14bc069affe0" rel="noopener">我以前在这个博客上讨论过React的生命周期</a>,因为它是许多开发人员急性神经崩溃的常见原因…</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/30ae2e8172fcce90b996f3a343d3dc35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PRYhPSgToiL4dKcv6n1O-w.gif"/></div></div></figure><p id="dbcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于一名React工程师来说，对组件生命周期的深刻理解就像你是一名篮球运动员多长了15英寸一样。当<strong class="ih hj">将基于类的组件重构为功能组件时，这尤其有帮助——这是我在2021年作为一名React工程师几乎整天都在做的事情。大部分只是调整语法的问题，但是<strong class="ih hj">像</strong> <code class="du jq jr js jt b"><strong class="ih hj">componentDidUpdate</strong></code> <strong class="ih hj">或者</strong> <code class="du jq jr js jt b"><strong class="ih hj">componentWillUnmount</strong></code> <strong class="ih hj">这样的生命周期方法呢？</strong></strong></p><p id="cf48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从我的工作中举一个真实的例子:一个<code class="du jq jr js jt b">class Calculator</code>，当我完成它时，它将是<code class="du jq jr js jt b">function Calculator()</code>。它有很多活动部件:</p><pre class="jf jg jh ji fd ju jt jv jw aw jx bi"><span id="2b4c" class="jy jz hi jt b fi ka kb l kc kd">import { connect } from 'react-redux';<br/>import { fetchPerformance } from '...redux actions...';</span><span id="875f" class="jy jz hi jt b fi ke kb l kc kd">class Calculator extends Component {</span><span id="b79d" class="jy jz hi jt b fi ke kb l kc kd">  state = {<br/>    isModalOpen: false,<br/>    selectedDateRangePrices: []<br/>    <em class="kf">...more delicious state here...<br/>  </em>};</span><span id="dfdf" class="jy jz hi jt b fi ke kb l kc kd">  componentDidUpdate = ( previousProps, previousState ) =&gt; {<br/>    if ( ...something about state/props changes ) {<br/>      this.setState( {<br/>        isModalOpen: true,<br/>        <em class="kf">...more nice juicy state...<br/>      </em>} );<br/>    }<br/>  };</span><span id="548c" class="jy jz hi jt b fi ke kb l kc kd">  render () {<br/>    return (<br/><em class="kf">      ...a beautiful calculator component...<br/></em>    );<br/>  }</span><span id="3f39" class="jy jz hi jt b fi ke kb l kc kd">}</span><span id="4191" class="jy jz hi jt b fi ke kb l kc kd">const mapStateToProps = (state) =&gt; ( {<br/>  start_date: state.closedEnds.start_date,<br/>  end_date: state.closedEnds.end_date,<br/>  starting_price: state.closedEnds.starting_price,<br/>  ending_price: state.closedEnds.ending_price,<br/>  ttl_return: state.closedEnds.ttl_return,<br/>  avg_annual: state.closedEnds.avg_annual,<br/>  time_calculated: state.closedEnds.time_calculated<br/>} );</span><span id="de12" class="jy jz hi jt b fi ke kb l kc kd">export default connect( mapStateToProps, { fetchPerformance } )( Calculator );</span></pre><p id="ff2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du jq jr js jt b">render()</code> we <code class="du jq jr js jt b">return</code> <code class="du jq jr js jt b">input</code>字段中，<code class="du jq jr js jt b">button</code> s，以及一个显示一些有用信息的模态，根据状态中设置的布尔标志隐藏或显示。我们还必须处理来自Redux商店的一些数据和我们本地的<code class="du jq jr js jt b">state</code>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kg"><img src="../Images/1b7e89c09aa10a4d34ebd984d42df5bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*_O8MX5wABk0c9Jk7eDXSOQ.gif"/></div></figure><p id="2bb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只有当<code class="du jq jr js jt b">props</code>和<code class="du jq jr js jt b">state</code>的某些属性改变时，我才需要将那个<code class="du jq jr js jt b">isModalOpen</code>标志切换到<code class="du jq jr js jt b">true</code>；因此，在基于类的React中，我自然使用<code class="du jq jr js jt b">previousProps</code>和<code class="du jq jr js jt b">previousState</code>在<code class="du jq jr js jt b">componentDidUpdate</code>中编写逻辑。但是……将它重构为基于钩子的React并不是简单的逐字符翻译。</p><p id="2f8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> React的文档在这里并不是很有帮助</a>:他们告诉我们<strong class="ih hj">“可以把</strong> <code class="du jq jr js jt b"><strong class="ih hj">useEffect</strong></code> <strong class="ih hj">想成</strong> <code class="du jq jr js jt b"><strong class="ih hj">componentDidMount</strong></code> <strong class="ih hj">、</strong> <code class="du jq jr js jt b"><strong class="ih hj">componentDidUpdate</strong></code> <strong class="ih hj">和</strong> <code class="du jq jr js jt b"><strong class="ih hj">componentWillUnmount</strong></code> <strong class="ih hj">的组合……”</strong>但是<code class="du jq jr js jt b">useEffect</code>并没有像<code class="du jq jr js jt b">previousProps</code>一样给我们任何有帮助或者熟悉的东西。<em class="kf">那么该怎么办呢？</em></p><p id="2ac0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是React文档<em class="kf">应该</em>解释的内容:本质上，<strong class="ih hj">在一个组件的生命周期中，在挂载/更新/卸载/s之间发生的任何事情，都可以被描述为该组件的“副作用”或者仅仅是“影响”</strong>(因此得名)。基于类的React用<code class="du jq jr js jt b">Component</code>方法和引用参数来处理这些副作用——有点笨拙，不太具有声明性。Functional React在一个钩子<code class="du jq jr js jt b">useEffect()</code>中处理所有副作用，在另一个钩子<code class="du jq jr js jt b">useRef()</code>中处理所有引用。更优雅更有反应力。</p><p id="8394" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到我的<code class="du jq jr js jt b">class Calculator</code>，假设每当<code class="du jq jr js jt b">selectedDateRangePrices</code>在我的组件的本地<code class="du jq jr js jt b">state</code>中发生变化时，我想要打开模态:</p><pre class="jf jg jh ji fd ju jt jv jw aw jx bi"><span id="3b4d" class="jy jz hi jt b fi ka kb l kc kd">// The modal opens if state.selectedDateRangePrices has changed</span><span id="f509" class="jy jz hi jt b fi ke kb l kc kd">componentDidUpdate = ( prevProps, prevState ) =&gt; {<br/>  if ( this.state.<!-- -->selectedDateRangePrices<!-- --> !== prevState.<!-- -->selectedDateRangePrices<!-- --> ) {<br/>    this.setState( { isModalOpen: true } );<br/>  }<br/>}</span></pre><p id="7e7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很容易将此转化为基于钩子的反应。用<code class="du jq jr js jt b">useState</code>吊钩注意状态；然后，在回调函数体中添加一个打开模态的<code class="du jq jr js jt b">useEffect</code>，并将<code class="du jq jr js jt b">state.selectedDateRangePrices</code>添加到它的依赖数组中:</p><pre class="jf jg jh ji fd ju jt jv jw aw jx bi"><span id="5d49" class="jy jz hi jt b fi ka kb l kc kd">function Calculator( { <em class="kf">...props galore...</em> } ) {</span><span id="c153" class="jy jz hi jt b fi ke kb l kc kd">  const [ state, setState ] = useState( { <br/>    isModalOpen: false,<br/>    selectedDateRangePrices: []<br/>    <em class="kf">...state, wonderful state... <br/>  </em>}<em class="kf"> </em>);</span><span id="311f" class="jy jz hi jt b fi ke kb l kc kd">  const { start_date, end_date, starting_price, ending_price, ttl_return, avg_annual, time_calculated } = useSelector( state =&gt; state.openEnds );</span><span id="8a3b" class="jy jz hi jt b fi ke kb l kc kd">  useEffect( () =&gt; setState( { ...state, isModalOpen: true } ), [ state.selectedDateRangePrices ] );</span><span id="9525" class="jy jz hi jt b fi ke kb l kc kd">}</span></pre><p id="deba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就变得更棘手了:如果我只想设置状态，并在Redux的道具改变时打开该模态，该怎么办？更棘手的情况呢，比如只有当三个或更多的改变时才打开它？还是两个特定的都改变了？</p><pre class="jf jg jh ji fd ju jt jv jw aw jx bi"><span id="d0ce" class="jy jz hi jt b fi ka kb l kc kd">// The modal only opens if both ttl_return and avg_annual have changed</span><span id="c988" class="jy jz hi jt b fi ke kb l kc kd">componentDidUpdate = ( prevProps, prevState ) =&gt; {<br/>  if ( this.props.ttl_return !== prevProps.ttl_return &amp;&amp; this.props.avg_annual !== prevProps.avg_annual ) {<br/>    this.setState( { isModalOpen: true } );<br/>  }<br/>}</span></pre><p id="e8d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们没有来自<code class="du jq jr js jt b">componentDidUpdate</code>的<code class="du jq jr js jt b">prevProps</code>引用，所以要把这样的组件翻译成钩子，我用React的<code class="du jq jr js jt b">useRef</code>钩子做我自己的引用。<a class="ae jd" href="https://javascript.plainenglish.io/july-7-triggering-file-uploads-downloads-without-a-back-end-in-react-6438cb77859" rel="noopener ugc nofollow" target="_blank">我不是第一个也不是唯一一个</a>说出来的:<code class="du jq jr js jt b"><strong class="ih hj">useRef</strong></code> <strong class="ih hj">是React hooks的无名英雄。</strong>把refs想象成一个小小的存储盒，里面存放着任何东西——<code class="du jq jr js jt b">fetch</code>结果、DOM元素和其他变量——工程师(你)可以使用属性<code class="du jq jr js jt b">.current</code>调用它们。当我们用组件副作用之外的元素或数据来微调组件的生命周期时，引用非常有用:</p><pre class="jf jg jh ji fd ju jt jv jw aw jx bi"><span id="6ba6" class="jy jz hi jt b fi ka kb l kc kd">function Calculator( { <em class="kf">...props galore...</em> } ) {</span><span id="9a54" class="jy jz hi jt b fi ke kb l kc kd">  const [ state, setState ] = useState( { <br/>    isModalOpen: false,<br/>    selectedDateRangePrices: []<br/>    <em class="kf">...state, wonderful state... <br/>  </em>}<em class="kf"> </em>);</span><span id="fae6" class="jy jz hi jt b fi ke kb l kc kd">  const { start_date, end_date, starting_price, ending_price, ttl_return, avg_annual, time_calculated } = useSelector( state =&gt; state.openEnds );</span><span id="3f90" class="jy jz hi jt b fi ke kb l kc kd">  const previousRef = useRef();</span><span id="06dc" class="jy jz hi jt b fi ke kb l kc kd">  useEffect( () =&gt; {<br/>    if ( previousRef.current ) {<br/>      if ( ttl_return !== previousRef.current.ttl_return &amp;&amp; avg_annual !== previousRef.current.avg_annual ) {<br/>        setState( { ...state, isModalOpen: true } )<br/>      }<br/>    }<br/>    return () =&gt; {<br/>      previousRef.current = { ttl_return, avg_annual };<br/>    };<br/>  } );</span><span id="9a7b" class="jy jz hi jt b fi ke kb l kc kd">}</span></pre><p id="7125" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是怎么回事？</p><ul class=""><li id="4d50" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">我们从定义<code class="du jq jr js jt b">previousRef</code>开始。</li><li id="6691" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">我们编写了一个<code class="du jq jr js jt b">useEffect()</code>，当一个组件第一次挂载或者更新的时候运行。在内部，回调函数检查我们的条件是否满足——也就是说，当前的两个Redux属性是否等于它们在<code class="du jq jr js jt b">previousRef.current</code>中的对应属性。我们还要检查<code class="du jq jr js jt b">previousRef.current</code>是否是<code class="du jq jr js jt b">undefined</code>，这样我们就不会在页面第一次加载时打开我们的模态。</li><li id="5de3" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">这个<code class="du jq jr js jt b">useEffect()</code> <code class="du jq jr js jt b">return</code>是一个<strong class="ih hj">清理功能，</strong>定义了在组件卸载/更新之前需要运行的任何逻辑——相当于<code class="du jq jr js jt b">componentWillUnmount</code>。这个清理函数更新了我们的<code class="du jq jr js jt b">previousRef</code>，所以组件可以像使用<code class="du jq jr js jt b">previousProps</code>一样挂在引用上。</li><li id="5491" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">我们定义的逻辑和清理函数意味着我们不需要依赖数组。</li></ul><p id="b2e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你也可以创建一个内部带有<code class="du jq jr js jt b">useRef</code>的定制钩子——也许叫做<code class="du jq jr js jt b">usePrevious</code>——但是1)这是不必要的，2)这需要放弃很多使<code class="du jq jr js jt b">useRef</code>如此强大的控制和特性。</p><p id="06df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一点上，考虑你自己的警告:<code class="du jq jr js jt b"><strong class="ih hj">useRef</strong></code> <strong class="ih hj">不是好的React设计的替代品！</strong>超出从父母到孩子的正常流程<code class="du jq jr js jt b">props</code>是很棒的……<strong class="ih hj">但是，如果超出太多</strong>，你最终会发现一些非常古怪的错误，或者至少是<em class="kf">，</em>难以理解的代码，编辑起来是一场噩梦。每一个引用都应该有清晰的逻辑和令人信服的存在理由——缺少这两者都是在组件的副作用中找到你需要的东西，或者考虑重组你的代码。</p></div></div>    
</body>
</html>