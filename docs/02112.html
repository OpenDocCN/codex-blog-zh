<html>
<head>
<title>Intro to PostgreSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL简介</h1>
<blockquote>原文：<a href="https://medium.com/codex/intro-to-postgresql-c8da31335c34?source=collection_archive---------7-----------------------#2021-07-01">https://medium.com/codex/intro-to-postgresql-c8da31335c34?source=collection_archive---------7-----------------------#2021-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0926" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">创建和查询Postgres数据库</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/6000d2d2e344ec8c9e294f91623893cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/0*epnKnkKuLx2RAajt"/></div></figure><h2 id="4f0a" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">为什么是Postgres</h2><p id="eed9" class="pw-post-body-paragraph kd ke hi kf b kg kh ij ki kj kk im kl jq km kn ko ju kp kq kr jy ks kt ku kv hb bi translated">当开始一个新项目时，在选择数据库时有许多选择。您可以使用基于JavaScript的MongoDB，它将数据存储为文档。虽然您可以在MongoDB中将相关数据链接到文档，但是如果您希望运行复杂的查询，使用基于关系的数据库可能是更好的选择。</p><p id="4389" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated">Postgres使用代表结构化查询语言的SQL。这是一种人类可读的语言，能够获得非常具体的结果。Postgres、MySQL、SQLite和Oracle都是以类似表格的格式存储信息的SQL数据库。</p><p id="7921" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated">Postgres的一个优点是可以使用JSON作为数据类型。当您希望拥有一个可以存储各种内容类型(如视频、投票、图像等)的列时，这很有帮助。选择Postgres的另一个原因是它的可伸缩性和与NodeJS上运行的应用程序的兼容性。</p><h2 id="abb1" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">创建数据库和表</h2><p id="bb9d" class="pw-post-body-paragraph kd ke hi kf b kg kh ij ki kj kk im kl jq km kn ko ju kp kq kr jy ks kt ku kv hb bi translated">按照<a class="ae lb" href="https://www.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank">步骤下载并安装</a>Postgres后，您可以在终端中键入“psql”进入CLI。下面是Postgres CLI中使用的常用命令列表，这些命令允许您查看现有的表和对数据库所做的更改。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="a83f" class="jf jg hi ld b fi lh li l lj lk">\c database_name to connect</span><span id="e606" class="jf jg hi ld b fi ll li l lj lk">\l shows all databases</span><span id="0bcd" class="jf jg hi ld b fi ll li l lj lk">\d shows all tables in database</span><span id="3150" class="jf jg hi ld b fi ll li l lj lk">\? shows all commands</span><span id="1067" class="jf jg hi ld b fi ll li l lj lk">\h shows queries you can use</span><span id="9dae" class="jf jg hi ld b fi ll li l lj lk">q will allow to leave the list / quit</span></pre><p id="30ad" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated">正如我前面提到的，SQL可读性很强。创建数据库就像输入“创建数据库”一样简单。虽然你不需要将所有的关键字都大写，但是这样做是很常规的。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="9074" class="jf jg hi ld b fi lh li l lj lk">CREATE DATABASE database_name_here; <br/>//remember to always end with semicolon</span><span id="010e" class="jf jg hi ld b fi ll li l lj lk">CREATE TABLE users (user_id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY, username VARCHAR (25) UNIQUE NOT NULL;</span></pre><p id="3830" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated">上面的代码将创建一个数据库和一个名为users的表。每个用户都有一个唯一的整数id。该id将作为创建时自动生成的主键。如果您使用过MongoDB，那么主键相当于_id。它用于创建独立数据表之间的关系。VARCHAR是一种数据类型，指的是我们可以设置最大值的文本。如果我们不需要限制这个数据，我们可以使用文本类型来代替。通过包含UNIQUE NOT NULL，我们明确表示如果用户名不唯一，将会抛出错误，并且不会保存。</p><p id="40ea" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated">要向新创建的表中添加用户，我们可以使用INSERT INTO关键字，后跟表名、列和这些列的值。这些值应该用单引号括起来，不要用双引号。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="ad43" class="jf jg hi ld b fi lh li l lj lk">INSERT INTO users (username) VALUES ('codingchamp');</span></pre><h2 id="07f8" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">选择和查询子句</h2><p id="e1b0" class="pw-post-body-paragraph kd ke hi kf b kg kh ij ki kj kk im kl jq km kn ko ju kp kq kr jy ks kt ku kv hb bi translated">我们运行的每个查询都将以关键字SELECT开始。如果你想从一个表中选择所有的数据，你可以像这样运行…</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="7e04" class="jf jg hi ld b fi lh li l lj lk">SELECT * FROM users;</span></pre><p id="fc1b" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated">要获得更具体的数据，可以使用子句。子句是附加的关键字，比如WHERE和ORDER BY，它允许我们进一步深入到表数据中，并减少它，只返回我们当前需要的内容。这里有一个例子。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="9eff" class="jf jg hi ld b fi lh li l lj lk">SELECT user_id, username FROM users ORDER BY username DESC LIMIT 10;</span></pre><p id="613e" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated">这将返回users表中按用户名降序排序的前十个结果的主键和用户名。结果的默认顺序是升序，所以如果不包含DESC子句，就会得到这个结果。</p><p id="6264" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated">从句的顺序很重要。尽管您可能不需要一次使用所有这些子句，但在查询时，以下是可接受的操作顺序。</p><ol class=""><li id="5f68" class="lm ln hi kf b kg kw kj kx jq lo ju lp jy lq kv lr ls lt lu bi translated">从，包括连接</li><li id="6f34" class="lm ln hi kf b kg lv kj lw jq lx ju ly jy lz kv lr ls lt lu bi translated">在哪里</li><li id="7acc" class="lm ln hi kf b kg lv kj lw jq lx ju ly jy lz kv lr ls lt lu bi translated">分组依据</li><li id="68f4" class="lm ln hi kf b kg lv kj lw jq lx ju ly jy lz kv lr ls lt lu bi translated">拥有</li><li id="a36e" class="lm ln hi kf b kg lv kj lw jq lx ju ly jy lz kv lr ls lt lu bi translated">窗口功能</li><li id="1eaf" class="lm ln hi kf b kg lv kj lw jq lx ju ly jy lz kv lr ls lt lu bi translated">挑选</li><li id="26ad" class="lm ln hi kf b kg lv kj lw jq lx ju ly jy lz kv lr ls lt lu bi translated">明显的</li><li id="4033" class="lm ln hi kf b kg lv kj lw jq lx ju ly jy lz kv lr ls lt lu bi translated">联盟</li><li id="8efd" class="lm ln hi kf b kg lv kj lw jq lx ju ly jy lz kv lr ls lt lu bi translated">以...排序</li><li id="15d7" class="lm ln hi kf b kg lv kj lw jq lx ju ly jy lz kv lr ls lt lu bi translated">极限和偏移</li></ol><p id="da18" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated">你可以在这里阅读更多关于这些条款及其用例的信息<a class="ae lb" href="https://www.eversql.com/sql-order-of-operations-sql-query-order-of-execution/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="de4f" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">更新和删除</h2><p id="ce86" class="pw-post-body-paragraph kd ke hi kf b kg kh ij ki kj kk im kl jq km kn ko ju kp kq kr jy ks kt ku kv hb bi translated">更改表中的值就像定义我们想要设置的新值并查询我们想要更改的数据一样简单。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="0005" class="jf jg hi ld b fi lh li l lj lk">UPDATE users SET username = 'codequeen' WHERE user_id = 2;</span></pre><p id="e420" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated">删除也一样简单。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="e318" class="jf jg hi ld b fi lh li l lj lk">DELETE FROM users WHERE user_id = 2;</span></pre><h2 id="74b7" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">外键</h2><p id="b63e" class="pw-post-body-paragraph kd ke hi kf b kg kh ij ki kj kk im kl jq km kn ko ju kp kq kr jy ks kt ku kv hb bi translated">请记住，SQL数据库的美妙之处在于它们是关系型的，我们可以建立连接。在我们的用户表示例中，我们有一个主键，它总是在创建用户时生成，并且总是惟一的。我们可以将该主键映射到另一个表来引用该用户实例。这被称为外键。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="71b9" class="jf jg hi ld b fi lh li l lj lk">CREATE TABLE comments (</span><span id="4a9e" class="jf jg hi ld b fi ll li l lj lk">comment_id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,</span><span id="31a5" class="jf jg hi ld b fi ll li l lj lk">user_id INT REFERENCES users(user_id) ON DELETE CASCADE,</span><span id="2cad" class="jf jg hi ld b fi ll li l lj lk">comment TEXT NOT NULL</span><span id="41aa" class="jf jg hi ld b fi ll li l lj lk">);</span></pre><p id="4799" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated">在新的comments表中，user_id被定义为一个INT引用数据类型，作为外键将user_id链接到特定的comment实例。ON DELETE CASCADE告诉Postgres删除与特定用户相关联的所有注释(如果该用户已被删除)。这有助于我们保留不再有用的数据。</p><h2 id="6963" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">连接表格</h2><p id="da4f" class="pw-post-body-paragraph kd ke hi kf b kg kh ij ki kj kk im kl jq km kn ko ju kp kq kr jy ks kt ku kv hb bi translated">现在注释表上有了一个外键，我们可以实现一个连接表。连接表允许我们显示相关数据。它们通过将数据从一个表拖到另一个表来帮助我们遵循单一真实来源的编码原则，而不是手动添加数据，手动添加会导致冲突。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="05d0" class="jf jg hi ld b fi lh li l lj lk">SELECT</span><span id="9f22" class="jf jg hi ld b fi ll li l lj lk">comment_id, comments.user_id, users.username</span><span id="8e6c" class="jf jg hi ld b fi ll li l lj lk">FROM</span><span id="3477" class="jf jg hi ld b fi ll li l lj lk">comments</span><span id="cf97" class="jf jg hi ld b fi ll li l lj lk">INNER JOIN</span><span id="afd6" class="jf jg hi ld b fi ll li l lj lk">users</span><span id="1a88" class="jf jg hi ld b fi ll li l lj lk">ON</span><span id="20d4" class="jf jg hi ld b fi ll li l lj lk">comments.user_id = users.user_id;</span></pre><p id="ebe6" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated">上面的代码将创建一个包含评论id、用户id和用户名的表。它从comments表和users表中提取这些信息。它们由注释的外键(comments.user_id)连接，该外键与用户的主键(users.user_id)相匹配。</p><p id="3da3" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated">内部连接只是几个连接表中的一个。最常用的连接表是inner、left和right。选择正确的连接表将取决于所需信息的存储位置。下面是对可用的连接表类型的简要描述。</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="4ec8" class="jf jg hi ld b fi lh li l lj lk">INNER: must have a match on both tables, else don’t include it in table</span><span id="70b5" class="jf jg hi ld b fi ll li l lj lk">LEFT: include anything from the left table whether it has a match on right table</span><span id="ddb0" class="jf jg hi ld b fi ll li l lj lk">RIGHT: opposite of left</span><span id="573e" class="jf jg hi ld b fi ll li l lj lk">OUTER: only join things that don’t have matches on either table</span><span id="ec05" class="jf jg hi ld b fi ll li l lj lk">FULL OUTER: join everything from both tables</span><span id="4889" class="jf jg hi ld b fi ll li l lj lk">CROSS JOIN: creates every possible combination of joining data from both tables (cartesian product)</span><span id="a130" class="jf jg hi ld b fi ll li l lj lk">*careful with CROSS JOIN bc it will likely be a massive amount of data</span></pre><p id="0a22" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated">我发现这个<a class="ae lb" href="https://commons.wikimedia.org/wiki/File:SQL_Joins.svg" rel="noopener ugc nofollow" target="_blank">图</a>对于理解每种类型的连接表之间的差异也很有用。</p><h2 id="dc98" class="jf jg hi bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">额外资源</h2><p id="1eb4" class="pw-post-body-paragraph kd ke hi kf b kg kh ij ki kj kk im kl jq km kn ko ju kp kq kr jy ks kt ku kv hb bi translated">我们只接触了Postgres的基本功能和特性。我希望这激起了您对SQL数据库的好奇心。这里有一些有用的资源，可以帮助你更好地适应这个神奇的工具。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><p id="7be6" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated"><a class="ae lb" href="https://btholt.github.io/complete-intro-to-databases/" rel="noopener ugc nofollow" target="_blank">数据库的完整介绍</a></p><p id="7198" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated"><a class="ae lb" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> Postgres官方文件</a></p><p id="2b0c" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated"><a class="ae lb" href="https://www.w3schools.com/sql/" rel="noopener ugc nofollow" target="_blank">免费SQL教程</a></p><p id="2b06" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated"><a class="ae lb" href="https://www.pgadmin.org/" rel="noopener ugc nofollow" target="_blank"> PG管理GUI </a></p><p id="affc" class="pw-post-body-paragraph kd ke hi kf b kg kw ij ki kj kx im kl jq ky kn ko ju kz kq kr jy la kt ku kv hb bi translated"><a class="ae lb" href="https://www.ibm.com/cloud/learn/relational-databases" rel="noopener ugc nofollow" target="_blank">关系数据库讲解</a></p></div></div>    
</body>
</html>