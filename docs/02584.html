<html>
<head>
<title>Linguistic Modelling Techniques with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python语言建模技术</h1>
<blockquote>原文：<a href="https://medium.com/codex/linguistic-modelling-techniques-with-python-de3baf4bb752?source=collection_archive---------2-----------------------#2021-07-27">https://medium.com/codex/linguistic-modelling-techniques-with-python-de3baf4bb752?source=collection_archive---------2-----------------------#2021-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e180e6a933bdf62294fdd729b0dc16b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oJidBz6Oaf1a3hPo"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">爱德华·乔佩蒂亚在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="4a87" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">什么是语言建模？</h2><p id="174c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">语言建模是一种系统或模型，可以处理语言输入，并给出类似于人类语言处理输出的东西。</p><ul class=""><li id="a2ab" class="ko kp hi jv b jw kq ka kr jg ks jk kt jo ku kn kv kw kx ky bi translated">找到一些语言数据(例如语料库数据)</li><li id="0fec" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">发展一些假设</li><li id="a937" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">测试假设。</li></ul><h2 id="b6e0" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">为什么我们需要语言模型？</h2><p id="bc10" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">简单来说，一些基本原因是:</p><ul class=""><li id="8155" class="ko kp hi jv b jw kq ka kr jg ks jk kt jo ku kn kv kw kx ky bi translated">更容易识别特定的分析。</li><li id="9d18" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">我们可以找出它的预测，排除替代分析。</li><li id="91e4" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">形式理论可以由计算机处理。</li></ul><p id="1374" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">语言建模中还包括一些常用术语。</p><p id="608f" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated"><strong class="jv hj">句法:</strong>在语言学中，句法是指某种特定语言中定义句子结构的一些规则。它包括语序、语法、层次结构、一致、次范畴化。</p><p id="b91c" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated"><strong class="jv hj">短语结构:</strong>当单词的组合形成一个短语时，可以定义短语结构。可以是名词短语(NP)、动词短语(VP)、介词短语(PP)等。</p><p id="cd0b" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated"><strong class="jv hj">选区&amp;依存:</strong>选区由单词或单词序列组成。依赖是指一个单词依赖于另一个单词。例如，限定词(DT)和形容词(ADJ)可以依赖于名词(N)。</p><p id="1991" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated"><strong class="jv hj">句法分析:</strong>句法分析向我们展示了单词或记号之间的联系。这是通过某种计算算法完成的。将讨论Python的一些自然语言处理(NLP)包用于语法分析。</p><p id="7f86" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">由于相同单词的不同句子结构可以产生不同的含义，句法分析可以帮助理解文本。</p><h2 id="ede6" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">词性标注</h2><p id="098a" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">众所周知，词性标注是语言建模的第一个核心部分。这可以通过以下两个简单的步骤来实现:</p><ul class=""><li id="a115" class="ko kp hi jv b jw kq ka kr jg ks jk kt jo ku kn kv kw kx ky bi translated">通过识别标点符号将文本分割成句子。</li><li id="1150" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">标记化:在单词边界分割句子。</li></ul><p id="6979" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated"><strong class="jv hj">单词的词类或词汇类别</strong></p><ul class=""><li id="7843" class="ko kp hi jv b jw kq ka kr jg ks jk kt jo ku kn kv kw kx ky bi translated">实词(公开课):名词、动词、形容词、副词</li><li id="2478" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">虚词(封闭类):限定词、代词、形容词、连词、虚拟语气</li></ul><p id="36a2" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">根据单词的形式，不同的单词可以归入不同的词性类别。</p><h2 id="ec2a" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">使用自然语言处理工具进行词性标注</h2><p id="f071" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">这里，我们将在NLTK包的帮助下使用python编程在给定的句子中进行词性标注。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="8cf3" class="iv iw hi lm b fi lq lr l ls lt"># import of nltk<br/>import nltk</span><span id="69ab" class="iv iw hi lm b fi lu lr l ls lt"># some further components for segementation, tokenization<br/>nltk.download('punkt')<br/>nltk.download('averaged_perceptron_tagger')</span><span id="3697" class="iv iw hi lm b fi lu lr l ls lt"># download the universal tagset<br/>nltk.download('universal_tagset')</span><span id="f77a" class="iv iw hi lm b fi lu lr l ls lt"># import the word_tokenize class<br/>from nltk.tokenize import word_tokenize</span><span id="8501" class="iv iw hi lm b fi lu lr l ls lt"># apply the word-tokenizer to a text string and find the POS tag</span><span id="af6f" class="iv iw hi lm b fi lu lr l ls lt">nltk.pos_tag(word_tokenize("In the present study, we examine the outcomes of such a period of no exposure on the neurocognition of L2 grammar:"), tagset='universal')</span></pre><h2 id="79c1" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">短语结构语法</h2><p id="55bd" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">在不改变句子意思的情况下替换一系列单词。并且该单词序列将被认为是一个成分。一些基本规则是:</p><ul class=""><li id="a046" class="ko kp hi jv b jw kq ka kr jg ks jk kt jo ku kn kv kw kx ky bi translated">NP -&gt; DET N</li><li id="2d0e" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">VP -&gt; V NP</li><li id="1fde" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">S -&gt; NP VP</li></ul><p id="2a85" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">一些具体规则:</p><ul class=""><li id="bfb7" class="ko kp hi jv b jw kq ka kr jg ks jk kt jo ku kn kv kw kx ky bi translated">NP -&gt; (Det)(AdjP+) N</li><li id="6e72" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">NP -&gt; NP (PP+)</li><li id="5dd7" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">NP -&gt; PP CP</li><li id="c8bf" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">AdjP--&gt;(AdvP)Adj</li><li id="735a" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">AdvP--&gt;(AdvP)Adv</li><li id="12e5" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">PP -&gt; P NP</li><li id="4fff" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">VP -&gt; V</li><li id="51ac" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">VP -&gt; (AdvP+) V (AdvP+)</li><li id="372e" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">VP-&gt;(AdvP+)V(NP)(NP)(AdvP+)(PP+)(AdvP+)</li></ul><p id="9a35" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">“+”号表示一次或多次出现。</p><h2 id="52ce" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">绘制语法树</h2><p id="3f3b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">为了绘制句子结构的语法树，遵循自底向上的方法。这些步骤是:</p><ul class=""><li id="6d27" class="ko kp hi jv b jw kq ka kr jg ks jk kt jo ku kn kv kw kx ky bi translated">为一个句子中的所有单词分配词性标签。</li><li id="1ed1" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">找到短语</li><li id="5ee9" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">反向构建树。</li><li id="8d11" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">用规则检查树。</li></ul><p id="9e06" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">例如，下面给出了以下句子的语法树:<em class="lv">彼得更喜欢丹佛</em>的航班:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="b4f2" class="iv iw hi lm b fi lq lr l ls lt">Peter -&gt; NP<br/>prefers -&gt; V<br/>the -&gt; Det<br/>flight -&gt; N<br/>from -&gt; P<br/>Denver -&gt; NP<br/>NP -&gt; Det N<br/>NP -&gt; NP PP<br/>PP -&gt; P NP<br/>VP -&gt; V NP<br/>S -&gt; NP VP</span></pre><p id="9f20" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">使用NLTK检查解决方案:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="4342" class="iv iw hi lm b fi lq lr l ls lt">import nltk<br/>from nltk import Production, CFG</span><span id="c569" class="iv iw hi lm b fi lu lr l ls lt"># grammar<br/>cgrammar = nltk.CFG.fromstring("""<br/>S -&gt; NP VP<br/>VP -&gt; V NP<br/>PP -&gt; P NP<br/>NP -&gt; NP PP | Det N | 'Peter' | 'Denver'<br/>V -&gt; 'prefers'<br/>P -&gt; 'from'<br/>N -&gt; 'flight'<br/>Det -&gt; 'the'<br/>""")</span><span id="89b0" class="iv iw hi lm b fi lu lr l ls lt"># print grammar<br/>print(cgrammar, '\n')</span><span id="e6e2" class="iv iw hi lm b fi lu lr l ls lt">sent = ['Peter', 'prefers', 'the', 'flight', 'from', 'Denver']</span><span id="a868" class="iv iw hi lm b fi lu lr l ls lt"># Using Chart Parser<br/>cparser = nltk.ChartParser(cgrammar)</span><span id="e11b" class="iv iw hi lm b fi lu lr l ls lt">for tree in cparser.parse(sent):<br/>  print(tree)</span><span id="629b" class="iv iw hi lm b fi lu lr l ls lt"># drawing trees<br/>import svgling<br/>svgling.draw_tree(tree)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/4f6430be9be7cb6e6c4bd21f62cb8cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*S75t7uNnBqtVqWf1cuO9ZQ.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">语法树的输出</figcaption></figure><h2 id="27f2" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">模糊语法</h2><p id="8e0e" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">不同类型的歧义可以出现在一个句子中。比如:</p><ul class=""><li id="e2cd" class="ko kp hi jv b jw kq ka kr jg ks jk kt jo ku kn kv kw kx ky bi translated">词汇歧义</li><li id="de3c" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">词性歧义</li><li id="0098" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">结构歧义</li><li id="8a41" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">依恋歧义</li><li id="8897" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">配位歧义</li></ul><p id="e043" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">NLTK可以用来检测两个不同的歧义句子树。这里的句子<em class="lv">我射杀了一只穿着睡衣的大象</em>被用来证明这种歧义。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="bc98" class="iv iw hi lm b fi lq lr l ls lt">import nltk</span><span id="69a1" class="iv iw hi lm b fi lu lr l ls lt">a_grammar = nltk.CFG.fromstring("""<br/>S -&gt; NP VP<br/>PP -&gt; P NP<br/>NP -&gt; Det N | Det N PP | 'I'<br/>VP -&gt; V NP | VP PP<br/>Det -&gt; 'an' | 'my'<br/>N -&gt; 'elephant' | 'pajamas'<br/>V -&gt; 'shot'<br/>P -&gt; 'in'<br/>""")</span><span id="c3f8" class="iv iw hi lm b fi lu lr l ls lt">sent = ['I', 'shot', 'an', 'elephant', 'in', 'my', 'pajamas']</span><span id="2a48" class="iv iw hi lm b fi lu lr l ls lt">parser = nltk.ChartParser(a_grammar)</span><span id="3820" class="iv iw hi lm b fi lu lr l ls lt">for tree in parser.parse(sent):<br/>  print(tree)</span></pre><p id="1576" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">产出是:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="5ad7" class="iv iw hi lm b fi lq lr l ls lt">(S<br/> (NP I)<br/> (VP<br/>  (VP (V shot) (NP (Det an) (N elephant)))<br/>  (PP (P in) (NP (Det my) (N pajamas)))))</span><span id="1336" class="iv iw hi lm b fi lu lr l ls lt">(S<br/> (NP I)<br/> (VP<br/>  (V shot)<br/>  (NP (Det an) (N elephant) (PP (P in) (NP (Det my) (N pajamas))))))</span></pre><p id="50b0" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">要绘制树:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="d47c" class="iv iw hi lm b fi lq lr l ls lt">import os<br/>import svgling<br/>from nltk.tree import Tree<br/>from nltk.draw.tree import TreeView</span><span id="3aa0" class="iv iw hi lm b fi lu lr l ls lt"># using the string format<br/>t1 = Tree.fromstring('(S(NP/I)(VP(VP(V/shot)(NP(Det/an)(N/elephant)))(PP(P/in)(NP(Det/my)(N/pajamas)))))')</span><span id="efdc" class="iv iw hi lm b fi lu lr l ls lt">svgling.draw_tree(t1)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/aea1116d5f7967a86fe5d10f74ce1e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*6Y3JsYGBf_rJgytfWUhwfg.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">第一棵树的输出</figcaption></figure><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="353e" class="iv iw hi lm b fi lq lr l ls lt">t2 = Tree.fromstring('(S(NP/I)(VP(V/shot)(NP(Det/an)(N/elephant)(PP(P/in)(NP(Det/my)(N/pajamas))))))')</span><span id="46e2" class="iv iw hi lm b fi lu lr l ls lt">svgling.draw_tree(t2)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/e4b5969cf2209894098c311149ef9394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*yLldQ2K420gkwxAzk3cElA.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">第二棵树的输出</figcaption></figure><h2 id="34ca" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">上下文无关文法</h2><p id="7e56" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">上下文无关语法是在像英语这样的自然语言中建模成分结构的最广泛使用的形式系统，例如，它们也被称为短语结构语法。</p><p id="3cd2" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">以下是句子的上下文无关语法的规则生成:</p><ul class=""><li id="3a5d" class="ko kp hi jv b jw kq ka kr jg ks jk kt jo ku kn kv kw kx ky bi translated"><em class="lv">男人写了一封信，女孩买了一件礼物。</em></li><li id="2443" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">祖母烤了一个蛋糕和一个面包。</li></ul><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="ac1b" class="iv iw hi lm b fi lq lr l ls lt">S -&gt; S CONJ S | NP VP<br/>NP -&gt; Det N | NP CONJ NP<br/>VP -&gt; V NP<br/>Det -&gt; "the" | "a"<br/>N -&gt; "man" | "letter" | "girl" | "present" | "grandmother" | "cake" | "bread"<br/>V -&gt; "wrote" | "bought" | "baked"<br/>CONJ -&gt; "and"</span></pre><h2 id="f70e" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">解析CFG</h2><p id="23ea" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">有两种方法可以从给定的语法中解析字符串。</p><ul class=""><li id="0d60" class="ko kp hi jv b jw kq ka kr jg ks jk kt jo ku kn kv kw kx ky bi translated">自上而下</li><li id="33f8" class="ko kp hi jv b jw kz ka la jg lb jk lc jo ld kn kv kw kx ky bi translated">自下而上</li></ul><p id="fc5a" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">在自上而下的方法中，我们从S开始，逐步推导出句子。另一方面，我们从句子开始，通过使用自底向上方法中的逆向归约方式来得到S。</p><p id="65d5" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated"><strong class="jv hj"> Shift Reduce解析器:</strong>Shift Reduce解析器在NLTK中实现，类似于自底向上的解析器。它分两步工作。它移动堆栈中的一个输入，并用一个单独的项替换顶部的项。它将继续下去，直到找到s为止。Shift Reduce解析器的局限性是它不能解析一个有歧义的句子。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="3de2" class="iv iw hi lm b fi lq lr l ls lt">import nltk<br/>from nltk import CFG</span><span id="f166" class="iv iw hi lm b fi lu lr l ls lt">grammar = nltk.CFG.fromstring("""<br/>S -&gt; S CONJ S | NP VP<br/>NP -&gt; Det N | NP CONJ NP<br/>VP -&gt; V NP<br/>Det -&gt; "the" | "a"<br/>N -&gt; "man" | "letter" | "girl" | "present" | "grandmother" | "cake" | "bread"<br/>V -&gt; "wrote" | "bought" | "baked"<br/>CONJ -&gt; "and"<br/>""")</span><span id="d7fb" class="iv iw hi lm b fi lu lr l ls lt">sr_parser = nltk.ShiftReduceParser(grammar, trace=2)</span><span id="4c12" class="iv iw hi lm b fi lu lr l ls lt">sent1 = 'the man wrote a letter and the girl bought a present'.split()</span><span id="841d" class="iv iw hi lm b fi lu lr l ls lt">sent2 = 'the grandmother baked a cake and a bread'.split()</span><span id="74f0" class="iv iw hi lm b fi lu lr l ls lt">print('sent1:')</span><span id="2eb9" class="iv iw hi lm b fi lu lr l ls lt">for tree in sr_parser.parse(sent1):<br/>  print(tree)</span><span id="4516" class="iv iw hi lm b fi lu lr l ls lt">print('sent2:')</span><span id="cbe7" class="iv iw hi lm b fi lu lr l ls lt">for tree in sr_parser.parse(sent2):<br/>  print(tree)</span></pre><p id="efa7" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">如果我们运行上面的代码，我们将看到解析器能够完美地解析第一句话。但是它不能解析第二个句子，因为它是一个歧义句。它不能回头去寻找替代的解决方案。在找到NP和VP之后，它简单地简化为S，而不是找到其他的可能性。</p><p id="5332" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">为了克服这个问题，可以使用<strong class="jv hj">图表解析器</strong>。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="d723" class="iv iw hi lm b fi lq lr l ls lt">import nltk<br/>from nltk import CFG</span><span id="9492" class="iv iw hi lm b fi lu lr l ls lt">grammar = nltk.CFG.fromstring("""<br/>S -&gt; S CONJ S | NP VP<br/>NP -&gt; Det N | NP CONJ NP<br/>VP -&gt; V NP<br/>Det -&gt; "the" | "a"<br/>N -&gt; "man" | "letter" | "girl" | "present" | "grandmother" | "cake" | "bread"<br/>V -&gt; "wrote" | "bought" | "baked"<br/>CONJ -&gt; "and"<br/>""")</span><span id="c502" class="iv iw hi lm b fi lu lr l ls lt">chart_parser = nltk.BottomUpChartParser(grammar, trace=2)</span><span id="558d" class="iv iw hi lm b fi lu lr l ls lt">sent1 = 'the man wrote a letter and the girl bought a present'.split()</span><span id="f2b7" class="iv iw hi lm b fi lu lr l ls lt">sent2 = 'the grandmother baked a cake and a bread'.split()</span><span id="ff3f" class="iv iw hi lm b fi lu lr l ls lt">print('sent1:')</span><span id="7131" class="iv iw hi lm b fi lu lr l ls lt">for tree in chart_parser.parse(sent1):<br/>  print(tree)</span><span id="35d9" class="iv iw hi lm b fi lu lr l ls lt">print('sent2:')</span><span id="9c32" class="iv iw hi lm b fi lu lr l ls lt">for tree in chart_parser.parse(sent2):<br/>  print(tree)</span></pre><h2 id="376d" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">概率分析</h2><p id="86d6" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">概率解析是另一种克服多重解析造成的歧义的方法。这与CFG非常相似，只是每个规则都有一个概率。特定短语(名词短语、动词短语等)的总概率。)必须是1.0。</p><p id="99ad" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">NLTK中定义了两种PCFGs(概率CFG)算法。维特比PCFG分析器以更高的概率考虑结果。内部图表解析器显示不同概率的所有结果。</p><p id="e689" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">NLTK中已经定义了一些PCFGs。我们可以很容易地装载它们。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="7885" class="iv iw hi lm b fi lq lr l ls lt">from nltk.grammar import PCFG, induce_pcfg, toy_pcfg1, toy_pcfg2</span><span id="cb43" class="iv iw hi lm b fi lu lr l ls lt"># Printing toy PCFG that is already in NLTK<br/>print(toy_pcfg1)</span><span id="fc6a" class="iv iw hi lm b fi lu lr l ls lt"># Viterbi Parser<br/>from nltk.parse import ViterbiParser</span><span id="9fab" class="iv iw hi lm b fi lu lr l ls lt">tokens = "I saw the man with the telescope".split()</span><span id="f30d" class="iv iw hi lm b fi lu lr l ls lt">viterbi_parser = nltk.ViterbiParser(toy_pcfg1, trace=2)</span><span id="f16e" class="iv iw hi lm b fi lu lr l ls lt">for tree in viterbi_parser.parse(tokens):<br/>  print('Viterbi Parser:',tree)</span><span id="ceb3" class="iv iw hi lm b fi lu lr l ls lt"># Inside Chart Parser with queue ordering<br/>from nltk.parse import pchart</span><span id="2dd3" class="iv iw hi lm b fi lu lr l ls lt">inch_parser = nltk.InsideChartParser(toy_pcfg1, trace=2)</span><span id="5c38" class="iv iw hi lm b fi lu lr l ls lt">for tree in inch_parser.parse(tokens):<br/>  print('InsideChartParser:',tree)</span></pre><p id="e7f5" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">我们也可以创建自己的光子晶体光纤。我们只需要使用nltk。PCFG.fromstring()的功能类似于我们使用nltk的方式。CFG.fromstring()。唯一的区别是这次语法会有一个概率。改变概率也会改变解析结果。</p><h2 id="bebe" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">依存句法分析</h2><p id="8b19" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">这个概念背后的主要思想是，在一个句子中总是有一些依赖和独立的成分。例如，名词可以优于限定词或形容词。JetBlue取消了我们今天早上已经晚点的航班。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="2fed" class="iv iw hi lm b fi lq lr l ls lt">from nltk.grammar import DependencyGrammar<br/>from nltk.parse import NonprojectiveDependencyParser</span><span id="4a0d" class="iv iw hi lm b fi lu lr l ls lt">grammar = DependencyGrammar.fromstring("""<br/>'canceled' -&gt; 'JetBlue' | 'flight' | 'morning'<br/>'flight' -&gt; 'our' | 'was'<br/>'morning' -&gt; 'this'<br/>'was' -&gt; 'which' | 'late'<br/>'late' -&gt; 'already'<br/>""")</span><span id="c234" class="iv iw hi lm b fi lu lr l ls lt"># initialize Parser<br/>dp = NonprojectiveDependencyParser(grammar)</span><span id="5378" class="iv iw hi lm b fi lu lr l ls lt"># parse sequence of words<br/>g, = dp.parse(['JetBlue', 'canceled', 'our', 'flight', 'this', 'morning', 'which', 'was', 'already', 'late'])</span><span id="d845" class="iv iw hi lm b fi lu lr l ls lt"># print root element<br/>print('Root: ', g.root['word'], '\n')</span><span id="5a67" class="iv iw hi lm b fi lu lr l ls lt"># traverse tree and print dependents<br/>for _, node in sorted(g.nodes.items()):<br/>  if node['word'] is not None:<br/>    print('{address} {word}: {d}'.format(d=node['deps'][''],**node))</span><span id="04ab" class="iv iw hi lm b fi lu lr l ls lt"># print tree<br/>print('\n Tree: \n',g.tree())</span></pre><h2 id="4f1b" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">为什么解析很重要？</h2><p id="4d02" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">由于句法分析的任务是根据句子的语法找到句子的正确表示，因此它可以用于处理或生成句子结构的正确性。</p><p id="9f55" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">一个常见的NLP任务是确定句子中正确的词性。例如，我们认为这两句话“<em class="lv">睡眠应保持</em>”和“<em class="lv">我们睡得早</em>”。</p><p id="cad5" class="pw-post-body-paragraph jt ju hi jv b jw kq jy jz ka kr kc kd jg le kf kg jk lf ki kj jo lg kl km kn hb bi translated">单词“<em class="lv"> sleeping </em>”在第一句中是名词，但在第二句中是动词。为了确定正确的词性标签，可以使用句法分析，例如短语结构分析和依存性分析。这种解析可以确定单词之间的正确关系，从而确定正确的词性。</p></div></div>    
</body>
</html>