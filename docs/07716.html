<html>
<head>
<title>Customized Implementation of MVVM Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVVM架构的定制实施</h1>
<blockquote>原文：<a href="https://medium.com/codex/customized-implementation-of-mvvm-architecture-565dfd78671a?source=collection_archive---------10-----------------------#2022-06-23">https://medium.com/codex/customized-implementation-of-mvvm-architecture-565dfd78671a?source=collection_archive---------10-----------------------#2022-06-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d665c2691837ca57f78308dc5e577a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NvQ0kKDzCOuaS3vSsQZQOw.jpeg"/></div></div></figure><p id="08c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大家好，今天我想谈谈MVVM建筑，这是最著名的建筑模式。这个架构是每个在移动平台上工作的人都知道的，因此我将深入研究这个架构，并添加一些不同于谷歌推荐的架构的定制。先来个小提醒。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/30f33a1c31fe642c5c8c97630671d9c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Pb7oyFJQq4Mw681gXBVM1Q.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图1</figcaption></figure><p id="bf74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如图1所示，这个架构有三个主要组件。视图是与用户相联系的组件，视图的另一面称为UI。视图模型提供了视图和模型之间的联系。根据视图向视图模型发送的事件，视图模型向本地数据库或web服务发送请求。模型表示应用程序的数据和业务逻辑。</p><p id="71ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">按照大家的理解，我们来谈谈这个架构会增加什么。新增内容列表如下所示:</p><p id="2020" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> </strong>通过依赖注入通过匕首查看模型注入</p><p id="14f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> </strong>通用数据绑定初始化</p><p id="7984" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> </strong>查看状态</p><p id="0e28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在开始申请过程之前，我强烈建议你和我一起编码，但如果你不想编码，我附上下面的应用程序。每次提交代表上面给出的一个主题。</p><h1 id="3925" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">依赖注入</h1><p id="6265" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">Dagger是“一个用于Java、Kotlin和Android的完全静态的编译时<a class="ae la" href="http://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>框架。它是由<a class="ae la" href="http://square.github.io/" rel="noopener ugc nofollow" target="_blank"> Square </a>开发的<a class="ae la" href="https://github.com/square/dagger" rel="noopener ugc nofollow" target="_blank">早期版本</a>的改编版，现在由谷歌维护。<strong class="is hj"/></p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/3db829389f4cdec1dec8b09906ec9ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*oqzJmJSJCpAjKUEIUMwOMw.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图2</figcaption></figure><p id="0dfa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，您的目录层次结构应该如图2所示。Di文件夹代表了关于dagger的类。AppComponent类将所有模块引入项目。组件注释是写模块名的地方。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">应用程序组件</figcaption></figure><p id="5394" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在此步骤中，将创建BaseApplication和Main Application，然后创建模块。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">基本应用和主要应用</figcaption></figure><p id="f8e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基础应用程序是dagger首先创建的类。创建两个类后，您应该将主应用程序引入到应用程序中，并在清单文件中添加一行代码。此外，主应用程序的引入如图3所示。“android:name”是应用程序标签的属性，它引入了类。DaggerApplication是一个抽象类，它扩展了Application类，并注入其成员，可用于注入附加到它的活动、片段、服务、广播接收者和内容提供者。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/1342dae6a715e563062d2bed4e59c2f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uz5udm0KUTRz_PHwJOHARw.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图3</figcaption></figure><p id="43de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是讨论模块的时候了。模块也有依赖关系。DaggerAppComponent将内部的属性注入到类中。让我们说得更清楚些。正如您在下面的代码中看到的，“AndroidInjection.inject(this)”开始注入。Dagger搜索有" ContributesInjector "注释的类。ActivityBuilder具有包含此批注的提供程序。当Dagger找到与注入类返回相同类型的提供者时，它会进入提供者的模块列表。该类的所有依赖项都是从模块列表中收集的。在ActivityBuilder类之后，您会看到一个模块的示例。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">活动构建器</figcaption></figure><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">视图模型模块</figcaption></figure><p id="80f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显然，安卓推荐的一种方式也可以，这是你的选择。在我看来，当视图模型在其构造函数中带参数时，用dagger进行依赖注入更容易注入视图模型。</p><h1 id="0802" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">数据绑定初始化</h1><p id="a456" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">初始化是创建一个新的对象，这个对象有一个特定的类型。所有页面都有自己的绑定类型，因此绑定类型必须是通用的。泛型参数在活动或片段的定义中给出。即使绑定的类型是已知的，绑定初始化也需要布局id。因此，抽象函数是在活动或片段中声明的。在图3中，您可以看到通用数据绑定初始化的例子。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">基础活动</figcaption></figure><h1 id="fd54" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">视图状态</h1><p id="026e" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">我们将在基本文件夹中创建一个名为BaseState的接口。这个接口提供了在BaseActivity和BaseFragment中创建通用函数的机会，因此，这个通用函数可以在所有活动和片段中使用。然后，一个状态变量将被放置在基本视图模型中，如下所示。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/a1b78d6e59f55773caf617726eb959dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*DRWqX3Othj7SK2nWGYYjBg.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图4</figcaption></figure><p id="90fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你准备好最后阶段了吗？让我们完成这项工作。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">基础活动版本2</figcaption></figure><p id="4cff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当状态变量的值在viewmodel中改变时,“stateChange”函数将起作用。按照你的流程，你可以在函数里面做。下面的代码是viewmodel和activity之间的连接。众所周知，数据绑定提供了另一种改变用户界面的方法。两种方式都可以使用。</p><p id="ef8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在下面的链接中找到完整的代码。</p><div class="lg lh ez fb li lj"><a href="https://github.com/DogukanGun/MvvmArchitectureExample" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab dw"><div class="ll ab lm cl cj ln"><h2 class="bd hj fi z dy lo ea eb lp ed ef hh bi translated">GitHub-DogukanGun/mvvmarchitecture示例</h2><div class="lq l"><h3 class="bd b fi z dy lo ea eb lp ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="lr l"><p class="bd b fp z dy lo ea eb lp ed ef dx translated">github.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx io lj"/></div></div></a></div><p id="4b63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我只是想给MVVM建筑增加更多的特色。希望这对你有帮助。</p></div></div>    
</body>
</html>