<html>
<head>
<title>Demystifying Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘递归</h1>
<blockquote>原文：<a href="https://medium.com/codex/demystifying-recursion-b567930c03a?source=collection_archive---------3-----------------------#2021-04-14">https://medium.com/codex/demystifying-recursion-b567930c03a?source=collection_archive---------3-----------------------#2021-04-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="2d18" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">理解递归</h2><div class=""/><div class=""><h2 id="8e3c" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">帮助你真正理解递归如何工作的新方法</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/968a9d452560557f72bdfbf127c5c362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7CXpH0I-BtncQT9oKSySvw.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">Christophe Hautier 在<a class="ae jw" href="https://unsplash.com/s/photos/inception?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1acf" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><strong class="jz hs">递归是编程中一个非常重要的概念</strong>，在编写算法和解决问题时，为了高效地处理数据结构，你必须掌握这个概念。</p><p id="000c" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">然而，我们中的许多人发现递归的概念很难，并且在完全理解它之前挣扎了很久。</p><p id="3ea6" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">但是当一切都开始运转时，处理递归变得如此有趣和令人兴奋。</p><p id="6733" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">现在，如何让递归“只需点击一下”就能实现呢？</p><p id="90b6" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">在这篇文章中，我将介绍一种有趣的(新的)看待递归的方式来帮助你掌握它。如果你不喜欢递归，并且想尽可能避免编写递归函数(就像我以前一样)，我的目标是让你从现在开始甚至在睡觉的时候也想编写递归函数！</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h1 id="c3a8" class="la lb hi bd lc ld le lf lg lh li lj lk ix ll iy lm ja ln jb lo jd lp je lq lr bi translated"><strong class="ak">递归与迭代</strong></h1><p id="b502" class="pw-post-body-paragraph jx jy hi jz b ka ls is kc kd lt iv kf kg lu ki kj kk lv km kn ko lw kq kr ks hb bi translated">让我们先回顾一下我们已经知道的。什么是递归？</p><p id="529b" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">→简单来说，递归就是一个循环。</p><p id="11fc" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">递归几乎总是被比作迭代，迭代也是一个循环。如果递归和迭代都是循环，它们有什么不同？</p><p id="e87d" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">让我们来看看递归和迭代之间的两个最显著的区别:</p><ol class=""><li id="5f6f" class="lx ly hi jz b ka kb kd ke kg lz kk ma ko mb ks mc md me mf bi translated"><strong class="jz hs">递归占用额外的堆栈空间</strong> —我们知道递归为每个递归调用占用额外的内存堆栈空间，因此与迭代相比，潜在地具有更大的空间复杂度。</li><li id="95d9" class="lx ly hi jz b ka mg kd mh kg mi kk mj ko mk ks mc md me mf bi translated"><strong class="jz hs">递归使得代码更干净，可读性更强</strong>——尽管需要更多的空间，使用递归可以让你的代码比迭代更具可读性。</li></ol><p id="ee75" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">但是我们已经知道了这些区别，它们并没有真正帮助我们理解递归是如何工作的，对吗？</p><p id="e48f" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><em class="ml">递归和迭代之间真正的、最重要的区别是什么，可以让我们更全面地理解递归是如何工作的？</em></p><p id="d14e" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">要回答这个问题，我们需要理解递归的两个阶段。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h1 id="50fe" class="la lb hi bd lc ld le lf lg lh li lj lk ix ll iy lm ja ln jb lo jd lp je lq lr bi translated"><strong class="ak">递归的两个阶段</strong></h1><p id="1743" class="pw-post-body-paragraph jx jy hi jz b ka ls is kc kd lt iv kf kg lu ki kj kk lv km kn ko lw kq kr ks hb bi translated">注意，我们要看的两个阶段，不是我们熟悉的递归的两种情况:</p><ul class=""><li id="ea71" class="lx ly hi jz b ka kb kd ke kg lz kk ma ko mb ks mm md me mf bi translated">基本情况</li><li id="2a64" class="lx ly hi jz b ka mg kd mh kg mi kk mj ko mk ks mm md me mf bi translated">递归情况</li></ul><p id="44fb" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">递归是一个以较小的形式重复调用自己的函数，其思想是通过解决同一问题的较小版本，可以更容易地解决复杂的问题。</p><p id="43fb" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">递归所做的是重复调用越来越小的自身版本，直到你有最小的可能情况，小到你可以简单地立即解决它→这个最小的情况是基础情况。然后你用这个基础案例的答案来回答下一个最小的问题，然后下一个，然后下一个，等等，直到你回到最初的问题。</p><p id="0490" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><em class="ml">你注意到递归的两个阶段了吗？</em></p><ul class=""><li id="e969" class="lx ly hi jz b ka kb kd ke kg lz kk ma ko mb ks mm md me mf bi translated">我们有一个向基本情况发展的阶段。</li><li id="de68" class="lx ly hi jz b ka mg kd mh kg mi kk mj ko mk ks mm md me mf bi translated">我们有另一个阶段从基础案例中返回。</li></ul><p id="ac41" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">从原始递归调用到基础用例的第一阶段被称为<strong class="jz hs">调用阶段</strong>。</p><p id="2a3b" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">从基本情况返回到原始递归调用的第二阶段被称为<strong class="jz hs">返回阶段</strong>。</p><blockquote class="mn mo mp"><p id="a335" class="jx jy ml jz b ka kb is kc kd ke iv kf mq kh ki kj mr kl km kn ms kp kq kr ks hb bi translated">这是递归和迭代的主要区别:</p><p id="fcc3" class="jx jy ml jz b ka kb is kc kd ke iv kf mq kh ki kj mr kl km kn ms kp kq kr ks hb bi translated"><strong class="jz hs"> <em class="hi">迭代只有调用阶段，递归有调用阶段和返回阶段。</em>T11】</strong></p></blockquote><p id="5d14" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">最初难以完全理解递归的原因是递归循环有两个阶段，这使得很难看到每个递归调用的结果在最终结果中的完全组合效果。</p><p id="47c2" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">对于迭代来说，这很简单，因为循环是单向的→你只需在每个迭代周期中做同样的事情。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mt"><img src="../Images/20cc069df241e1b7ab8d1eb20b50f726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_o8vJeAYPvVYHapQL2JjxA.png"/></div></div></figure><p id="0db1" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">请注意，在上图中，我为每次迭代标记了“op ”,以表明每次迭代执行的操作会立即反映在代码中。</p><p id="28f2" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">对于递归，我用问号表示“op”。这是因为在递归中，我们有两个阶段，递归调用的操作可以在调用阶段执行，也可以在返回阶段执行，这取决于递归函数是如何设计的。</p><ul class=""><li id="cf11" class="lx ly hi jz b ka kb kd ke kg lz kk ma ko mb ks mm md me mf bi translated"><em class="ml">当在调用阶段执行操作时，递归调用一完成就执行操作</em>。这类似于迭代的工作方式。首先完成操作，然后进行其内部递归调用。</li><li id="b2cb" class="lx ly hi jz b ka mg kd mh kg mi kk mj ko mk ks mm md me mf bi translated"><em class="ml">当在返回阶段执行操作时，首先进行递归调用</em>。当进行递归调用时，它首先调用它的内部递归调用，内部递归调用调用它自己的内部递归调用，以此类推，直到进行带有基本用例的最后一个递归调用。然后，当递归返回到原始递归调用时，现在执行已经等待前一递归调用操作终止的每个递归调用的操作。</li></ul><p id="0c8f" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><em class="ml">这里是全面理解每个递归调用的结果如何组合成最终结果的关键</em> : <strong class="jz hs">我们需要理解每个递归调用的操作是在什么时候执行的</strong>。</p><p id="df10" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">在深入研究递归如何在代码中工作之前，让我们花点时间通过一个有趣的类比从概念上更全面地掌握递归及其两个阶段。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h1 id="e9c9" class="la lb hi bd lc ld le lf lg lh li lj lk ix ll iy lm ja ln jb lo jd lp je lq lr bi translated">递归就像盗梦空间一样</h1><p id="3b2f" class="pw-post-body-paragraph jx jy hi jz b ka ls is kc kd lt iv kf kg lu ki kj kk lv km kn ko lw kq kr ks hb bi translated">如果你看过电影<em class="ml">盗梦空间</em>，你会注意到递归和盗梦空间之间惊人的相似。梦里的梦里的梦和递归调用里的递归调用里的递归调用。</p><p id="cbc7" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><em class="ml">心中有了一个明确的目标，你就设计一个梦想，然后去实现它。在那个梦里，你创造了另一个梦并进入其中，然后在那个梦里又有另一个梦，如此下去，直到你进入一个最深处的梦。这是呼唤阶段，或进入梦想阶段。内心深处的梦想是最基本的情况。</em></p><p id="8854" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">现在，为了实现你的目标，回到现实中过上幸福的生活，你必须走出梦境。你必须首先从内心最深处的梦中醒来，然后是上面的梦，然后是上面的梦，如此类推，直到你最终回到现实中。这是回归阶段，或回到现实阶段。</p><p id="6c6d" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">如何获得递归的最终结果取决于每个递归调用的操作是如何执行的。</p><p id="034e" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">有两种方法可以通过《盗梦空间》实现你的目标。</p><ul class=""><li id="a5a7" class="lx ly hi jz b ka kb kd ke kg lz kk ma ko mb ks mm md me mf bi translated"><em class="ml">当你进入最深处的梦</em>时，你可以对每个梦进行必要的操作。当你到达内心深处的梦想时，你已经为每个梦想做了所有必要的操作。你现在需要做的就是从每个梦里醒来，就像嘭嘭嘭一样，直到你回到现实中。<strong class="jz hs">注意目标实现的顺序:最外层梦想的目标首先实现，最内层梦想的目标最后实现</strong>。</li><li id="ca6e" class="lx ly hi jz b ka mg kd mh kg mi kk mj ko mk ks mm md me mf bi translated"><em class="ml">或者，你可以通过进入所有的梦，首先进入最里面的梦，然后在你从梦中醒来时执行必要的操作</em>。在实现内心深处的梦想后，你从梦中醒来。在下一个梦里，你再次执行你必要的操作并实现你的梦的目标。你将为每个梦继续这些操作，直到你从你开始的最后一个梦中醒来，并回到现实中。注意目标实现的顺序:最里面的梦想的目标首先实现，最外面的梦想最后实现。</li><li id="98c3" class="lx ly hi jz b ka mg kd mh kg mi kk mj ko mk ks mm md me mf bi translated"><em class="ml">你也可以把这两种方式结合起来</em>。你可以在进入内在梦想的途中进行一些操作，当你从梦想中出来时再进行一些其他的操作。例如，你可以在进入最深层梦境的途中在梦中设置一些炸弹，然后当你从梦中醒来并在离开现实的途中再次到达这个梦境时，你可以触发炸弹爆炸。</li></ul><p id="15d8" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">在这个先启类比中，你可以注意到，先启是如何设计的(或者递归是如何设计的)会影响你的目标是如何实现的。换句话说，您的初始或递归函数应该以特定的方式设计，包括操作的时间，以实现您的预期目标。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><h1 id="bc79" class="la lb hi bd lc ld le lf lg lh li lj lk ix ll iy lm ja ln jb lo jd lp je lq lr bi translated"><strong class="ak">代码中的递归</strong></h1><p id="4e2f" class="pw-post-body-paragraph jx jy hi jz b ka ls is kc kd lt iv kf kg lu ki kj kk lv km kn ko lw kq kr ks hb bi translated">现在，让我们看看递归在代码中是如何工作的。</p><p id="3846" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我将使用的例子是JavaScript，但是这种语言对于理解递归是如何工作的并不重要。</p><h2 id="d6a4" class="mu lb hi bd lc mv mw mx lg my mz na lk kg nb nc lm kk nd ne lo ko nf ng lq ho bi translated"><strong class="ak">迭代</strong></h2><p id="141b" class="pw-post-body-paragraph jx jy hi jz b ka ls is kc kd lt iv kf kg lu ki kj kk lv km kn ko lw kq kr ks hb bi translated">首先，让我们考虑下面的迭代函数:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="f8d3" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这是一个迭代循环，将执行一个操作(打印<code class="du nj nk nl nm b">n</code>)，从<code class="du nj nk nl nm b">n = 6</code>开始，每次递减<code class="du nj nk nl nm b">n</code>，直到<code class="du nj nk nl nm b">n &gt; 0</code>。当<code class="du nj nk nl nm b">n = 0</code>出现时，循环中断，迭代完成。</p><blockquote class="mn mo mp"><p id="208b" class="jx jy ml jz b ka kb is kc kd ke iv kf mq kh ki kj mr kl km kn ms kp kq kr ks hb bi translated">这个while循环的结果将是:<code class="du nj nk nl nm b">6 5 4 3 2 1</code>。</p></blockquote><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nn"><img src="../Images/e1432fdc488f71e3ad31f8d3bf5843bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*byIVzVg0_nNhXoJ97z3h6A.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">迭代追踪</figcaption></figure><h2 id="8787" class="mu lb hi bd lc mv mw mx lg my mz na lk kg nb nc lm kk nd ne lo ko nf ng lq ho bi translated"><strong class="ak">尾部递归</strong></h2><p id="72d1" class="pw-post-body-paragraph jx jy hi jz b ka ls is kc kd lt iv kf kg lu ki kj kk lv km kn ko lw kq kr ks hb bi translated">使用递归可以实现相同的结果，如下所示:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="6924" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">用<code class="du nj nk nl nm b">recursion(6)</code>进行第一次递归调用。只要<code class="du nj nk nl nm b">n &gt; 0</code>，它就会打印<code class="du nj nk nl nm b">n</code>，然后调用下一个递归调用。<code class="du nj nk nl nm b">recursion(6)</code>打印<code class="du nj nk nl nm b">6</code>然后调用<code class="du nj nk nl nm b">recursion(5)</code>。这个调用将打印<code class="du nj nk nl nm b">5</code>然后调用<code class="du nj nk nl nm b">recursion(4)</code>。该过程将持续到调用<code class="du nj nk nl nm b">recursion(0)</code>为止。当<code class="du nj nk nl nm b">recursion(0)</code>被调用时，<code class="du nj nk nl nm b">n = 0</code>，所以递归调用终止，不执行任何操作。由于<code class="du nj nk nl nm b">recursion(0)</code>已经终止，我们现在回到<code class="du nj nk nl nm b">recursion(1)</code>调用，它在调用<code class="du nj nk nl nm b">recursion(0)</code>之前已经执行了它的操作(打印<code class="du nj nk nl nm b">1</code>)。由于<code class="du nj nk nl nm b">recursion(1)</code>的两个操作(<code class="du nj nk nl nm b">console.log(1)</code> &amp; <code class="du nj nk nl nm b">recursion(0)</code>)现在都已完成，<code class="du nj nk nl nm b">recursion(1)</code>终止，我们现在回到<code class="du nj nk nl nm b">recursion(2)</code>调用。这一直持续到我们返回到<code class="du nj nk nl nm b">recursion(6)</code>，之后我们的递归就完成了。</p><blockquote class="mn mo mp"><p id="d669" class="jx jy ml jz b ka kb is kc kd ke iv kf mq kh ki kj mr kl km kn ms kp kq kr ks hb bi translated">递归的结果将是:<code class="du nj nk nl nm b">6 5 4 3 2 1</code>。</p></blockquote><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es no"><img src="../Images/cd14a7253544706ba86aabd7ad05df04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pwXKvCRLXWL_yUMlcMzw2A.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">尾部递归追踪</figcaption></figure><p id="72d2" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">注意，当我们到达基本情况递归调用<code class="du nj nk nl nm b">recursion(0)</code>时，所有必要的操作都已经执行了。所有操作都在调用阶段执行。当我们从返回阶段的基本情况返回时，除了简单地终止每个递归调用之外，实际上没有做任何其他事情。</p><p id="c00e" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这是一个尾部递归的例子。<strong class="jz hs">尾递归是递归的一种，递归调用是递归函数的最后一个操作</strong>，如上例。在尾部递归中，所有操作都在调用阶段执行，在返回阶段除了简单地终止调用之外什么也不做。</p><blockquote class="mn mo mp"><p id="b466" class="jx jy ml jz b ka kb is kc kd ke iv kf mq kh ki kj mr kl km kn ms kp kq kr ks hb bi translated">尾部递归类似于迭代。</p><p id="3720" class="jx jy ml jz b ka kb is kc kd ke iv kf mq kh ki kj mr kl km kn ms kp kq kr ks hb bi translated">当你有一个尾部递归时，把代码写成一个迭代会更有效率，因为它们基本上以同样的方式工作，但是迭代有更好的空间复杂度。 </p></blockquote><p id="278a" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">记住所有的递归函数都可以以迭代的形式编写，反之亦然，但是在某些情况下，以迭代的形式编写递归函数更困难。</p><p id="aaca" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">尾部递归是递归的一个例子，可以很容易地以迭代的形式编写，在这种情况下，您应该明确地以迭代的形式编写代码，以节省内存空间。</p><h2 id="6429" class="mu lb hi bd lc mv mw mx lg my mz na lk kg nb nc lm kk nd ne lo ko nf ng lq ho bi translated"><strong class="ak">头部递归</strong></h2><p id="2f6f" class="pw-post-body-paragraph jx jy hi jz b ka ls is kc kd lt iv kf kg lu ki kj kk lv km kn ko lw kq kr ks hb bi translated">现在，让我们以上面的例子为例，改为头递归，其中所有操作都在返回阶段执行:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="7673" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">请注意，除了两个递归case操作的顺序(<code class="du nj nk nl nm b">console.log(n)</code>和<code class="du nj nk nl nm b">recursion(n — 1)</code>)之外，一切都是一样的。</p><p id="8b80" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">在这个递归中，进行第一个递归调用<code class="du nj nk nl nm b">recursion(6)</code>。自从<code class="du nj nk nl nm b">n = 6 &gt; 0</code>，<code class="du nj nk nl nm b">recursion(5)</code>被制造出来。请注意，<code class="du nj nk nl nm b">console.log(5)</code>只能在<code class="du nj nk nl nm b">recursion(5)</code>呼叫完全处理后执行。<code class="du nj nk nl nm b">recursion(5)</code>必须调用<code class="du nj nk nl nm b">recursion(4)</code>，T6必须调用<code class="du nj nk nl nm b">recursion(3)</code>以此类推，直到<code class="du nj nk nl nm b">recursion(0)</code>被调用。因为n现在等于0，所以到达基本情况，并且<code class="du nj nk nl nm b">recursion(0)</code>终止而不做任何事情。现在我们回到<code class="du nj nk nl nm b">recursion(1)</code> call。这里，注意我们还没有执行<code class="du nj nk nl nm b">console.log(1)</code>操作，因为我们需要首先等待<code class="du nj nk nl nm b">recursion(0)</code>调用终止。随着<code class="du nj nk nl nm b">recursion(0)</code>现在被完全处理，执行<code class="du nj nk nl nm b">console.log(1)</code>操作。<code class="du nj nk nl nm b">1</code>已打印。<code class="du nj nk nl nm b">recursion(1)</code>现在终止，我们回到<code class="du nj nk nl nm b">recursion(2)</code>呼叫。还是那句话，我们还没有执行<code class="du nj nk nl nm b">console.log(2)</code>，所以现在执行。<code class="du nj nk nl nm b">2</code>已打印。<code class="du nj nk nl nm b">recursion(2)</code>现在结束了，我们回到了<code class="du nj nk nl nm b">recursion(3)</code>。这一直持续到我们回到<code class="du nj nk nl nm b">recursion(6)</code>，它打印<code class="du nj nk nl nm b">6</code>并且递归完成。</p><blockquote class="mn mo mp"><p id="1c99" class="jx jy ml jz b ka kb is kc kd ke iv kf mq kh ki kj mr kl km kn ms kp kq kr ks hb bi translated">这种递归的结果是:<code class="du nj nk nl nm b">1 2 3 4 5 6</code>。</p></blockquote><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es np"><img src="../Images/cdfa91ffb9a497ca572cddb762de87f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KRWwLNYM_dXrQB4uGA2nsA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">头部递归跟踪</figcaption></figure><p id="236a" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这是一个头部递归。<strong class="jz hs">头递归是递归调用是递归函数的第一个操作</strong>的一种递归。在head递归中，所有操作都在返回阶段执行。</p><p id="1fb6" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><strong class="jz hs">与尾部递归不同，头部递归不容易转换成迭代</strong>。</p><p id="1d0d" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">如果我们要以迭代的形式编写这个头部递归，我们需要以这样一种方式编写，结果将是<code class="du nj nk nl nm b">1 2 3 4 5 6</code>。</p><p id="4283" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">如果我们以完全相同的顺序以迭代形式编写上面的head递归代码，我们将得到以下结果:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="2337" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">上述迭代函数的结果将是:<code class="du nj nk nl nm b">5 4 3 2 1 0</code>。这不是我们想要的。</p><p id="bd6a" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">为了得到<code class="du nj nk nl nm b">1 2 3 4 5 6</code>，我们必须找到一种不同的方法来编写迭代函数:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nh ni l"/></div></figure><blockquote class="mn mo mp"><p id="bb6b" class="jx jy ml jz b ka kb is kc kd ke iv kf mq kh ki kj mr kl km kn ms kp kq kr ks hb bi translated">上面的迭代将给出期望的结果:<code class="du nj nk nl nm b">1 2 3 4 5 6</code>。</p></blockquote><p id="0102" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">但是，与尾部递归不同，以迭代形式编写头部递归更加困难，尽管这是可能的。</p><h2 id="61a2" class="mu lb hi bd lc mv mw mx lg my mz na lk kg nb nc lm kk nd ne lo ko nf ng lq ho bi translated">一个更复杂的递归例子</h2><p id="8b8f" class="pw-post-body-paragraph jx jy hi jz b ka ls is kc kd lt iv kf kg lu ki kj kk lv km kn ko lw kq kr ks hb bi translated">现在，让我们看看下面的递归函数:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="4f51" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这里，我们有一个在调用阶段和返回阶段执行的操作的组合。</p><p id="ea8b" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这种递归肯定更复杂，但是利用我们对递归的两个阶段中执行的操作的理解，我们可以理解这种递归如何返回最终结果。</p><blockquote class="mn mo mp"><p id="9524" class="jx jy ml jz b ka kb is kc kd ke iv kf mq kh ki kj mr kl km kn ms kp kq kr ks hb bi translated">以下是递归函数中的操作何时执行的简单规则:</p><p id="906d" class="jx jy ml jz b ka kb is kc kd ke iv kf mq kh ki kj mr kl km kn ms kp kq kr ks hb bi translated"><strong class="jz hs"> <em class="hi"> 1。递归调用之前的任何事情都在调用阶段</em> </strong>执行</p><p id="01a5" class="jx jy ml jz b ka kb is kc kd ke iv kf mq kh ki kj mr kl km kn ms kp kq kr ks hb bi translated"><strong class="jz hs"> <em class="hi"> 2。递归调用之后的任何事情都在返回阶段</em> </strong>执行</p></blockquote><p id="2d40" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">在上例中，<code class="du nj nk nl nm b">console.log(n)</code>是在调用阶段执行的。</p><p id="e221" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">+ n</code>和<code class="du nj nk nl nm b">result</code>变量初始化到<code class="du nj nk nl nm b">recursion(n — 1) + n</code>和<code class="du nj nk nl nm b">return result</code>都在返回阶段进行。</p><p id="3b1f" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><strong class="jz hs">第一部分和我们之前看到的尾部递归例子基本相同:</strong></p><p id="fec8" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">console.log(n)</code>是在调用阶段执行的，所以当我们到达基础用例调用<code class="du nj nk nl nm b">recursion(0)</code>时，我们的递归函数应该已经打印了:<code class="du nj nk nl nm b">6 5 4 3 2 1</code>。</p><p id="ad80" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><strong class="jz hs">现在，我们要看看在返回阶段执行的操作:</strong></p><ul class=""><li id="6cab" class="lx ly hi jz b ka kb kd ke kg lz kk ma ko mb ks mm md me mf bi translated">在<code class="du nj nk nl nm b">recursion(0)</code>，从<code class="du nj nk nl nm b">n = 0</code>开始，执行递归程序块之外的基本情况操作:<code class="du nj nk nl nm b">return 0</code>。<code class="du nj nk nl nm b">recursion(0)</code>的返回值是<code class="du nj nk nl nm b">0</code>。</li><li id="f20f" class="lx ly hi jz b ka mg kd mh kg mi kk mj ko mk ks mm md me mf bi translated">现在我们回到<code class="du nj nk nl nm b">recursion(1)</code>。因为我们现在有了来自<code class="du nj nk nl nm b">recursion(1 — 1) = recursion(0)</code>的返回值，也就是<code class="du nj nk nl nm b">0</code>，所以我们有:</li></ul><p id="e996" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">const result = 0 + 1 = 1</code>。</p><p id="e02c" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">return result = return 1</code>。<code class="du nj nk nl nm b">recursion(1)</code>的返回值为<code class="du nj nk nl nm b">1</code>。</p><ul class=""><li id="a26a" class="lx ly hi jz b ka kb kd ke kg lz kk ma ko mb ks mm md me mf bi translated">现在我们回到<code class="du nj nk nl nm b">recursion(2)</code>。</li></ul><p id="b217" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">const result = 1 + 2 = 3</code>。</p><p id="e496" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">return result = return 3</code>。<code class="du nj nk nl nm b">recursion(2)</code>的返回值为<code class="du nj nk nl nm b">3</code>。</p><ul class=""><li id="abd0" class="lx ly hi jz b ka kb kd ke kg lz kk ma ko mb ks mm md me mf bi translated">现在我们回到<code class="du nj nk nl nm b">recursion(3)</code>。</li></ul><p id="abc9" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">const result = 3 + 3 = 6</code>。</p><p id="4155" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">return result = return 6</code>。<code class="du nj nk nl nm b">recursion(3)</code>的返回值是<code class="du nj nk nl nm b">6</code>。</p><ul class=""><li id="388e" class="lx ly hi jz b ka kb kd ke kg lz kk ma ko mb ks mm md me mf bi translated">现在我们回到<code class="du nj nk nl nm b">recursion(4)</code>。</li></ul><p id="14c5" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">const result = 6 + 4 = 10</code>。</p><p id="5562" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">return result = return 10</code>。<code class="du nj nk nl nm b">recursion(4)</code>的返回值是<code class="du nj nk nl nm b">10</code>。</p><ul class=""><li id="4647" class="lx ly hi jz b ka kb kd ke kg lz kk ma ko mb ks mm md me mf bi translated">现在我们回到<code class="du nj nk nl nm b">recursion(5)</code>。</li></ul><p id="9212" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">const result = 10 + 5 = 15</code>。</p><p id="3295" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">return result = return 15</code>。<code class="du nj nk nl nm b">recursion(5)</code>的返回值为<code class="du nj nk nl nm b">15</code>。</p><ul class=""><li id="c800" class="lx ly hi jz b ka kb kd ke kg lz kk ma ko mb ks mm md me mf bi translated">现在我们回到<code class="du nj nk nl nm b">recursion(6)</code>。</li></ul><p id="f9e9" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">const result = 15 + 6 = 21</code>。</p><p id="4298" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">return result = return 21</code>。<code class="du nj nk nl nm b">recursion(6)</code>的返回值为<code class="du nj nk nl nm b">21</code>。</p><p id="a62f" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们完成了。</p><blockquote class="mn mo mp"><p id="fecd" class="jx jy ml jz b ka kb is kc kd ke iv kf mq kh ki kj mr kl km kn ms kp kq kr ks hb bi translated">上述递归函数的最终结果是:</p><p id="9464" class="jx jy ml jz b ka kb is kc kd ke iv kf mq kh ki kj mr kl km kn ms kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">6 5 4 3 2 1</code> <em class="hi">(在调用阶段执行)</em></p><p id="fe9c" class="jx jy ml jz b ka kb is kc kd ke iv kf mq kh ki kj mr kl km kn ms kp kq kr ks hb bi translated"><code class="du nj nk nl nm b">21</code> <em class="hi">(返回环节操作的最终结果)</em></p></blockquote><p id="c208" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这不是很简单吗？</p><p id="85c2" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">通过将递归分为调用阶段和返回阶段，并逐个查看每个阶段中执行的操作，我们可以更容易地跟踪递归是如何实现的。</p><p id="8112" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">当然，还有更复杂的递归形式，包括<strong class="jz hs">树递归</strong>、<strong class="jz hs">间接递归</strong>和<strong class="jz hs">嵌套递归</strong>，但是如果你只记得递归有在调用阶段执行的操作和在返回阶段执行的操作，并且如果你只是一个接一个地跟踪每个操作，你应该能够理解整个递归是如何被实现来返回最终结果的。</p><p id="d79a" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我希望这篇文章有助于更好地理解递归是如何工作的！感谢您的阅读，并祝您所有的编程工作好运。</p><p id="e66f" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">编码快乐！</p></div></div>    
</body>
</html>