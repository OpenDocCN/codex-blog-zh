<html>
<head>
<title>Implementing A Univariate Linear Regression Model In Java To Predict House Pricing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Java实现一元线性回归模型预测房价</h1>
<blockquote>原文：<a href="https://medium.com/codex/coding-a-univariate-linear-regression-model-in-java-to-predict-house-pricing-f2a412bbc91e?source=collection_archive---------16-----------------------#2022-06-29">https://medium.com/codex/coding-a-univariate-linear-regression-model-in-java-to-predict-house-pricing-f2a412bbc91e?source=collection_archive---------16-----------------------#2022-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2b2801362108beb211ed39cfc89f63f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AEJTh0nfyZv0SZNu"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">沙哈达特·拉赫曼在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6b3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本周的帖子将会与往常有所不同。虽然我们通常在这里谈论网络，但今天我们将深入研究一下机器学习算法——更具体地说，如何实现一个线性回归模型，使我们能够根据单个变量(每1000平方英尺的大小)预测房屋价格。我们可以开始了吗？</p><p id="d1b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">简介</strong></p><p id="08fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在机器学习中我们可以利用的训练模型的方法主要有两种——<strong class="ix hj"><em class="jt">监督学习</em> </strong>和<strong class="ix hj"> <em class="jt">非监督学习</em> </strong>。</p><p id="c2a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在监督学习中，我们通常将正确标记的数据提供给算法。也就是说，我们明确地告诉算法什么是“正确的”答案。例如，如果我们正在使用<strong class="ix hj"><em class="jt"/></strong>(一种监督学习的类型)，我们通知算法一张图片(<em class="jt">输入值</em>或<em class="jt">特征</em>)是否包含一辆汽车、一只猫或一只蜥蜴(<em class="jt">目标</em>)。基于训练集，模型能够预测未来图片中的元素是猫、汽车还是蜥蜴。</p><p id="6d76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，在一个<strong class="ix hj"><em class="jt"/></strong>模型(也是另一种监督学习)中，我们提供输入(比如每1000平方英尺的房子大小)及其对应的目标值(房子的成本)。使用这些信息，该算法只需输入一个信息(房子的大小)，就可以正确预测训练集之外的房价。</p><p id="9363" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回归模型和分类模型的主要区别在于，回归模型的预测范围可以是无限的，而分类模型的预测值相比之下要有限得多。</p><p id="4f48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不会过多地研究无监督学习，因为这超出了本文的范围，但这种类型的机器学习算法会查看提供的数据，并根据观察到的常见模式得出结论(而不是我们告诉它我们到底在寻找什么)。无监督学习的一些例子包括<em class="jt">聚类</em>、<em class="jt">异常检测</em>、<strong class="ix hj">、</strong>和<em class="jt">维度缩减</em>。</p><p id="1307" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">入门</strong></p><p id="8137" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将实现一个算法，该算法将获取每1000平方英尺的房屋大小，并根据训练集生成其相应的价格。</p><p id="88a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更具体地说，我们将使用<strong class="ix hj">线性回归模型</strong>。线性回归模型通常在数据集的正中间“画”一条线，并试图根据这条线进行预测。</p><p id="d62e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要知道几个等式来实现它:</p><p id="bd65" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">线性回归模型方程</strong> = <em class="jt"> f </em> (x)=w*x + b <strong class="ix hj">或</strong> <em class="jt"> f w，b = w*x + b </em></p><p id="976d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个等式将在数据中间画一条线。</p><p id="aad8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">成本函数方程</strong>=<em class="jt">j</em>(x)= 1/2m * mσI = 1(<em class="jt">f</em>(x)^(i)-y^(i))</p><p id="5bce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个等式计算了我们的线性回归模型的<em class="jt">成本</em>。也就是说，它告诉我们预测值(ŷ或模型预测的值)与目标值(我们明确输入算法的值)之间的差异。</p><p id="4bed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">梯度下降算法</strong></p><p id="9e3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将允许我们通过不断迭代w和b的值来减少<em class="jt"> J( </em> x <em class="jt"> ) </em>的<em class="jt">成本</em>，直到成本最小。</p><p id="3cba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">重复直到收敛(意味着直到每个未来迭代对w和b的值的影响最小){</p><p id="3244" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">w = w- <em class="jt"> α(学习率)* 1/m *</em>mσI = 1(f(x)^(i)——y^(i))x^(i)</p><p id="e938" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">b = w- <em class="jt"> α(学习率)* 1/m *</em>mσI = 1(f(x)^(i)——y^(i))</p><p id="5113" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">}</p><p id="0c43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">实施</strong></p><p id="f9ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将使用Java作为我的编程语言，BlueJ作为我的IDE。你可以使用Python或者任何你觉得舒服的语言。使用的语法将根据所使用的语言而有所不同。</p><p id="8f3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我将创建一个名为PricePredictor的新类。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ju"><img src="../Images/72e711ae081f2ecf56655f7ac1b6cd03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6GmTr5-SXDgVqBday5YZQ.png"/></div></div></figure><p id="b903" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我将为PricePredictor类分配一些字段，并创建一个构造函数。</p><p id="2ce4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> x_train </strong>是一个数组，包含每1000平方英尺房屋大小的输入值。</p><p id="de70" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">y_train 是一个包含房屋价格目标值的数组。</p><p id="7549" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.0平方英尺是300.0美元，而2.0平方英尺是500.0美元(理论上)。</p><p id="36cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> w </strong>来自w*x+b</p><p id="103f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> b </strong>来自w*x+b</p><p id="35a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> m </strong>是代表训练集中行数的变量。我将m的值指定为x_train.length，这将返回数组中元素的数量(2)。</p><p id="97fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们不知道w和b的最佳值应该是多少，才能得到完全符合数据的线性回归模型，所以我们将w和b初始化为0作为起点。</p><p id="f657" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，这种实现主要是演示性的——在现实世界的场景中，您很少对训练集进行硬编码。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/ccff7ce87b2a9f1aaf08d0afba1ac508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8SSx0KeCf-6HzYceFymFg.png"/></div></div></figure><p id="8f3d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我将实现一个名为<em class="jt"> CostFunction </em>的公共double方法，它将表示我们的成本函数<em class="jt">j</em>(x)= 1/2m * mσI = 1(<em class="jt">f</em>(x)^(i)-y^(i)。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/be791d777f5c44fc410b62904566b61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGAHIyAE8-6iZVD20A3sfg.png"/></div></div></figure><p id="6d64" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我创建一个名为<strong class="ix hj"> cost </strong>的变量，并将其初始化为0。</p><p id="beb8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我运行一个for循环，其中<em class="jt"> i </em>从0开始，到m-1结束(实际上是<em class="jt"> m </em>次)。</p><p id="ed4b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将变量<strong class="ix hj"> f_wb </strong>赋给w*x_train[i] + b，其中I代表迭代次数。</p><p id="fb87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> f_wb </strong>是我们对特征x^(i的预测值，假设w和b当前为0。</p><p id="f22c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我将<strong class="ix hj"> cost_i </strong>赋值给(f_wb — y_train[i])。</p><p id="2459" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> cost_i </strong>表示预测值(f_wb给定x^( <em class="jt"> i </em>且w=0，b=0)与实际目标值(y_train at <em class="jt"> i </em>)的平方之间的成本。</p><p id="d83d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，对于每次迭代，我将变量<strong class="ix hj">成本</strong>加上<strong class="ix hj">成本_i </strong>。</p><p id="5990" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有迭代完成后，我退出循环，我创建一个名为<strong class="ix hj"> total_cost </strong>的变量，将<strong class="ix hj"> cost </strong>乘以1/2m并赋值给它，就像等式中一样。</p><p id="5e66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我通过让它返回变量<strong class="ix hj"> total_cost </strong>来完成这个方法。</p><p id="4519" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们将计算成本函数J相对于w和b的偏导数。更具体地说，我们将找到括号中以粗体显示的运算值。方法<em class="jt"> GradientValues </em>将具有参数w和b，并将返回一个double类型的数组。</p><p id="d216" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">w = w-<em class="jt">α*</em><strong class="ix hj"><em class="jt">(1/m *</em>mσI = 1(f(x)^(i)—y^(i))x^(i))</strong></p><p id="e77c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">b = w-<em class="jt">α*</em><strong class="ix hj"><em class="jt">(1/m * mσI = 1(f(x)^(i)—y^(i)))</em></strong></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kb"><img src="../Images/bce358ce21021163e3680a9ae6a4fe4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hDmqdo0zyyz_4yEe30ad2w.png"/></div></div></figure><p id="e3e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将<strong class="ix hj"> dj_dw </strong>和<strong class="ix hj"> dj_db </strong>初始化为0。</p><p id="1596" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建一个for循环，就像前面的方法一样，它将运行m次。</p><p id="07ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> f_wb </strong> = w*x_train[i] + b得到预测值或ŷ.</p><p id="3758" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> cost_i </strong>获得ŷ和目标值之间的差异(y)。</p><p id="9ccb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> dj_dw_i </strong>将给出成本函数J相对于参数w的导数(因为它乘以x_train[i])，而我们可以只使用<strong class="ix hj">成本_i </strong>作为成本函数J相对于参数b的导数。</p><p id="3341" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以将这些值分别添加到dj_dw和dj_db中。</p><p id="0af2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们脱离了循环，我们就可以像等式中那样将其乘以(1/m)。</p><p id="c0db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我将创建一个double类型的数组<strong class="ix hj"> gv </strong>，在其中存储<strong class="ix hj"> dj_dw </strong>和<strong class="ix hj"> dj_db </strong>，并返回<strong class="ix hj"> gv </strong>，以便稍后可以使用这些值。</p><p id="623f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，方法<em class="jt"> GradientFinal </em>返回一个double类型的数组，带有参数int <em class="jt"> inters </em>(迭代次数)和<em class="jt"> alpha </em>(学习速率)。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/b603944b67b60e7ebef09181724d6fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rqjCZBO-WiAhxGyWUEv8Rg.png"/></div></div></figure><p id="603c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将从迭代<em class="jt"> inters </em>乘以<em class="jt">的for循环开始。</em>在循环内部，我们将调用我们之前构造的方法<em class="jt"> GradientValues </em>来获得成本函数J相对于之前存储在数组中的w和b的导数，并将它们赋给gv。</p><p id="bd51" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在将更新w和b的值，就像等式中一样。</p><p id="183c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">w = w- (alpha * gv[0](存储在<strong class="ix hj"> gv </strong>中的成本函数J相对于w的导数)</p><p id="8c20" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">b= b- (alpha* gv[1](存储在<strong class="ix hj"> gv </strong>中的成本函数J相对于b的导数)</p><p id="a2c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在循环执行了<em class="jt"> inters </em>次之后，让我们退出循环，然后将这些新更新的值存储在一个名为<strong class="ix hj"> gf </strong>的新数组中，并将其返回<strong class="ix hj">。</strong></p><p id="5f48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，我们做了所有这些工作，我们不确定是否一切都是正确的。让我们通过创建一个名为<strong class="ix hj"> tester </strong>的新类来测试它。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/110f889849685c580910f04bcf6aa00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KjtIk04mknOnT30_awZr_w.png"/></div></div></figure><p id="10bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个类中，我创建了一个名为testgf的void方法:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/608e9fe167386057444f1fd1e8e261ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWuu3xZTdDroPVUBrdSsCg.png"/></div></div></figure><p id="e72c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将创建PricePredictor的一个新实例，调用GradientFinal方法，进行10000次迭代，学习率(alpha)为1.0e-2或大约0.010。</p><p id="e640" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我将遍历数组gf中的每个值，以获得我们的线性回归模型的w和b的优化值，并将它们打印出来。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ke"><img src="../Images/eaf4cbced8b16344a52d8a52b333c1cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*4OtGPqLbZPb-VSOkZGhgXQ.png"/></div></div></figure><p id="530e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，经过10000次迭代后，w的优化值大约为199.992，b的优化值大约为100.0011。让我们把这些值代入我们的等式，看看我们是否能得到我们的目标输出。<br/>f(x)= w * x+b<br/>300 = w *(1.0)+b&gt;&gt;300 =(199.99)* 1+(100.011)= 300<br/>500 = w *(2.0)+b&gt;&gt;500 =(199.99)* 2+(100.011)= 499.997(基本上500</p><p id="fa79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">恭喜你！我们现在已经找到了w和b的值，这将使我们的线性回归模型非常适合数据。</p><p id="bebc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，让我们创建一个将作为迷你程序运行的方法，并将所有这些概念放在一起:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kf"><img src="../Images/6a819e8e8895c139d2f7c44d0ba83779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Unh_s7Djwl3gPh9nwF2IfQ.png"/></div></div></figure><p id="d3a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个程序中，我们将询问用户每1000平方英尺的房屋大小，调用GradientFinal来计算w和b的最佳值，插入这些值，预测房屋的价格，并将其打印出来。如果用户输入的不是数字，我们将显示一条错误消息，并允许用户再试一次。<br/>让我们运行它，看看它看起来像什么:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kg"><img src="../Images/0999eaf344288d770a4509795e1bf057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TXj4EihiDT15iQL98J7J2A.png"/></div></div></figure><p id="01af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将输入1.2作为我的尺寸，然后是1和2(这是我们的目标值)。</p><p id="c7d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，我们得到的预测价格是340美元。我们知道它是正确的，因为当我们输入1或2时，预测值确实与我们的目标值一致。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kh"><img src="../Images/1612c32595017ad61c37ed41e025bdb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YnSPbM2Mq_0hNKCFTlyUAA.png"/></div></div></figure><p id="02ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们尝试使用一些非数字字符:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ki"><img src="../Images/81b9425bce4e48311839016bd8c8861e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5iqQTVifMlArDvq9-hDgHQ.png"/></div></div></figure><p id="d722" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如您所看到的，提示符只是按计划重新启动。现在让我们键入“exit”退出程序。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kj"><img src="../Images/e3dc496c44db83582ada90d39048a0a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5rerS4Cn3vlPgDSuBjyr7A.png"/></div></div></figure><p id="5df9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如你所看到的，程序已经停止运行，我们得到一个“下次见”的消息。</p><p id="b689" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">恭喜你！您刚刚使用Java实现了一个单变量线性回归模型，根据面积来预测房价。</p><p id="f182" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想要一个更具预测性和适用性的模型，您必须修改代码，以便使用具有真实数据的训练集，并添加更多变量(浴室数量、地板等。)那会促成除了房子大小以外的最终定价。本教程只是展示了如何实现它的粗略轮廓。</p><p id="7844" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为深度学习大声呐喊。人工智能和斯坦福创造了机器学习专业化。本教程深受其启发(尽管最初的课程使用Python而不是Java)。</p><p id="3bbf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">想了解更多？请访问:</p><p id="60cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://www.coursera.org/specializations/machine-learning-introduction" rel="noopener ugc nofollow" target="_blank">https://www . coursera . org/specializations/机器学习-简介</a></p></div></div>    
</body>
</html>