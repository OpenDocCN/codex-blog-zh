<html>
<head>
<title>Decorator Design Pattern With Lambdas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Lambdas的装饰设计模式</h1>
<blockquote>原文：<a href="https://medium.com/codex/decorator-design-pattern-with-lambdas-9fbe1f03551c?source=collection_archive---------14-----------------------#2021-04-17">https://medium.com/codex/decorator-design-pattern-with-lambdas-9fbe1f03551c?source=collection_archive---------14-----------------------#2021-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="45a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天，让我们尝试在Java Lambda表达式的帮助下实现装饰设计模式。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0cae1c14a7e789a447912323617c4fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PsX7ABco7Iqe0EGm"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">马文·迈耶在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="8cad" class="jz ka hi jv b fi kb kc l kd ke">public static void printit(int n, String msg, Function&lt;Integer, Integer&gt; func){<br/>    System.<em class="kf">out</em>.println(n+" " + msg+" : "+func.apply(n));<br/>}</span></pre><p id="5021" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一个打印输出的方法。它接受函数接口作为参数。函数接口是包含单个方法的接口。函数接口的美妙之处在于它可以和Lambda表达式一起使用，产生令人惊叹的结果。</p><p id="9c95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何执行上述方法？</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="cad8" class="jz ka hi jv b fi kb kc l kd ke"><em class="kf">printit</em>(5, "printing incremented value .. ", e -&gt; e + 1 );</span></pre><p id="f1ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这里所做的是创建一个函数接口的实现来给定值加1。为了使它更具可读性，让我们把它重写为</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="9411" class="jz ka hi jv b fi kb kc l kd ke">Function&lt;Integer, Integer&gt; incremented = e -&gt; e + 1;<br/><em class="kf">printit</em>(5, "printing incremented value .. ", incremented);</span></pre><p id="d88a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们创建了incremented类，并将其传递给printit方法。如果你不熟悉这个lambda表达式，这是传统的编码。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="d9a1" class="jz ka hi jv b fi kb kc l kd ke">Function&lt;Integer, Integer&gt; incremented = new Function&lt;Integer, Integer&gt;() {<br/>    @Override<br/>    public Integer apply(Integer e) {<br/>        return e+1;<br/>    }<br/>};<br/><em class="kf">printit</em>(5, "printing incremented value ..", incremented);</span></pre><p id="643d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望你清楚我们正在做的代码。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="11ba" class="jz ka hi jv b fi kb kc l kd ke">import java.util.function.Function;</span><span id="0e23" class="jz ka hi jv b fi kg kc l kd ke">public class DecoratorDP {<br/>    public static void main(String[] args) {<br/>        Function&lt;Integer, Integer&gt; incremented = e -&gt; e+1;<br/>        <em class="kf">printit</em>(5, "incremented", incremented);<br/>    }</span><span id="c906" class="jz ka hi jv b fi kg kc l kd ke">    public static void printit(int n, String msg, Function&lt;Integer,  Integer&gt; func){<br/>        System.<em class="kf">out</em>.println(n+" " + msg+" : "+func.apply(n));<br/>    }<br/>}</span></pre><h2 id="aa2a" class="jz ka hi bd kh ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">问题</h2><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="b7db" class="jz ka hi jv b fi kb kc l kd ke">Function&lt;Integer, Integer&gt; incremented = e -&gt; e+1;<br/><em class="kf">printit</em>(5, "incremented", incremented);</span></pre><p id="a876" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将给定值加1。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="5e85" class="jz ka hi jv b fi kb kc l kd ke">Function&lt;Integer, Integer&gt; doubled = e -&gt; e * 2;<br/><em class="kf">printit</em>(5, "doubled", doubled);</span></pre><p id="9757" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将使给定值加倍。</p><p id="d643" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们假设我们需要增加这个值，然后加倍它。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="2255" class="jz ka hi jv b fi kb kc l kd ke">Function&lt;Integer,Integer&gt; incAndDouble = e -&gt; (e + 1) * 2;<br/><em class="kf">printit</em>(5, "incAndDouble", incAndDouble);</span></pre><p id="6458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，这将工作，实施没有问题。但是代码重用呢？如果我们决定将增量逻辑改变两个而不是一个呢？我们将不得不在两个地方更改代码。当代码变得复杂时，代码维护将变得困难，对吗？</p><h2 id="c198" class="jz ka hi bd kh ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">解决办法</h2><p id="b2e9" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">装饰设计模式可以在这里帮助我们！</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="459b" class="jz ka hi jv b fi kb kc l kd ke"><em class="kf">printit</em>(5,"incAndDouble ", incremented.andThen(doubled));</span></pre><p id="ed9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这里做了什么？我们使用了函数接口的<strong class="ih hj">和</strong>方法来连接两个函数！Java框架将在递增的基础上应用双精度接口。您可以继续添加更多as，然后返回相同的函数对象。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="e360" class="jz ka hi jv b fi kb kc l kd ke">import java.util.function.Function;</span><span id="fb56" class="jz ka hi jv b fi kg kc l kd ke">public class DecoratorDP {</span><span id="e2be" class="jz ka hi jv b fi kg kc l kd ke">    public static void main(String[] args) {<br/>        Function&lt;Integer, Integer&gt; incremented = e -&gt; e+1;<br/>        <em class="kf">printit</em>(5, "incremented", incremented);</span><span id="1818" class="jz ka hi jv b fi kg kc l kd ke">        Function&lt;Integer, Integer&gt; doubled = e -&gt; e * 2;<br/>        <em class="kf">printit</em>(5, "doubled", doubled);</span><span id="54ea" class="jz ka hi jv b fi kg kc l kd ke"><em class="kf">        printit</em>(5,"incAndDouble ", incremented.andThen(doubled));</span><span id="6a92" class="jz ka hi jv b fi kg kc l kd ke">    }</span><span id="cbda" class="jz ka hi jv b fi kg kc l kd ke">    public static void printit(int n, String msg, Function&lt;Integer,  Integer&gt; func){<br/>        System.<em class="kf">out</em>.println(n+" " + msg+" : "+func.apply(n));<br/>    }<br/>}</span></pre><h2 id="b25e" class="jz ka hi bd kh ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">结论</h2><p id="f390" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">在这段代码中，当我们需要增量和双倍代码时，我们没有复制代码逻辑。我们重用了相同的旧代码逻辑。这就是使用这种设计的好处。这使得代码维护更容易，代码也更具可扩展性。</p><p id="123b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果我们需要先将代码加倍，然后再递增，该怎么办？(在本例中，输出不会改变)</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="7e30" class="jz ka hi jv b fi kb kc l kd ke"><em class="kf">printit</em>(5,"print ... ", doubled.andThen(incremented));</span></pre><p id="0685" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们需要增加一倍，然后再增加一倍呢？</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="3a90" class="jz ka hi jv b fi kb kc l kd ke"><em class="kf">printit</em>(5,"..", incremented.andThen(doubled).andThen(incremented));</span></pre><p id="7be2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">快乐编码…</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h2 id="e9ef" class="jz ka hi bd kh ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">另一个例子</h2><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="3915" class="jz ka hi jv b fi kb kc l kd ke">import java.awt.*;<br/>import java.util.Optional;<br/>import java.util.function.Function;<br/><br/>public class CameraExample {<br/>    public static void main(String[] args) {<br/>        <em class="kf">printit</em>(new Camera(e -&gt; e));<br/>        <em class="kf">printit</em>(new Camera(Color::brighter));<br/>        <em class="kf">printit</em>(new Camera(Color::darker));    <br/>        <em class="kf">printit</em>(new Camera(Color::brighter,Color::brighter));<br/>    }<br/>    public static void printit(Camera camera){<br/>        System.<em class="kf">out</em>.println(camera.snap(new Color(100,100,100)));<br/>    }<br/>}<br/><br/>class Camera{<br/>    Function&lt;Color, Color&gt; filter;<br/>    public Camera(Function&lt;Color,Color&gt;... filters) {<br/>        filter = e -&gt; e;<br/><br/>        for(Function&lt;Color, Color&gt; aFilter: filters)<br/>            filter = filter.andThen(aFilter);<br/>    }<br/><br/>    public Color snap(Color input) {<br/>        return filter.apply(input);<br/>    }<br/>}</span></pre><p id="bd91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出将是</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="dd98" class="jz ka hi jv b fi kb kc l kd ke">java.awt.Color[r=100,g=100,b=100]<br/>java.awt.Color[r=142,g=142,b=142]<br/>java.awt.Color[r=70,g=70,b=70]<br/>java.awt.Color[r=202,g=202,b=202]</span></pre><p id="df0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这段代码中，我们将为相机添加滤镜，以模拟真实世界中相机滤镜的使用。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="cc6e" class="jz ka hi jv b fi kb kc l kd ke"><em class="kf">printit</em>(new Camera(Color::darker));</span></pre><p id="9617" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码将创建一个camera类，通过传入代码使颜色变深。在摄像机构造函数中，默认类由</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="f58d" class="jz ka hi jv b fi kb kc l kd ke">filter = e -&gt; e;</span></pre><p id="5d4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后基于构造函数参数添加过滤器</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="1484" class="jz ka hi jv b fi kb kc l kd ke">filter = filter.andThen(aFilter)</span></pre><p id="0215" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这时，增加了使颜色变深的滤镜。当printit方法调用时，代码在执行。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="6010" class="jz ka hi jv b fi kb kc l kd ke">camera.snap(new Color(100,100,100))</span></pre><p id="b43c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们一直在创建执行代码的类。在snap方法中，我们真正传递参数并获得输出。</p><p id="1bc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们使用了一系列的构造函数，我们可以添加许多滤镜来使颜色变得更暗或更亮，就像我们在这里做的那样。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="3b7b" class="jz ka hi jv b fi kb kc l kd ke"><em class="kf">printit</em>(new Camera(Color::brighter,Color::brighter));</span></pre><p id="0aba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个代码使颜色变亮两倍。</p><h2 id="d66d" class="jz ka hi bd kh ki kj kk kl km kn ko kp iq kq kr ks iu kt ku kv iy kw kx ky kz bi translated">代码改进</h2><p id="27e1" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">相机构造函数可以重写为</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="2fa6" class="jz ka hi jv b fi kb kc l kd ke">filter = Stream.<em class="kf">of</em>(filters)<br/>        .reduce(e-&gt;e,(aFilter,result)-&gt;result.andThen(aFilter));</span></pre><p id="01f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再次改写为</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="9270" class="jz ka hi jv b fi kb kc l kd ke">filter = Stream.<em class="kf">of</em>(filters)<br/>        .reduce(Function.<em class="kf">identity</em>(),Function::andThen);</span></pre><blockquote class="lm ln lo"><p id="a8f9" class="if ig kf ih b ii ij ik il im in io ip lp ir is it lq iv iw ix lr iz ja jb jc hb bi translated">Java 8身份函数<strong class="ih hj"> Function.identity() </strong>返回一个<code class="du ls lt lu jv b"><strong class="ih hj">Function</strong></code>，它总是返回它的输入参数。</p></blockquote><p id="82cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后…</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="a5da" class="jz ka hi jv b fi kb kc l kd ke">public class CameraExample {<br/>    public static void main(String[] args) {<br/>        <em class="kf">printit</em>(new Camera(Color::brighter,Color::brighter));<br/>    }<br/><br/>    public static void printit(Camera camera){<br/>        System.<em class="kf">out</em>.println(camera.snap(new Color(100,100,100)));<br/>    }<br/>}<br/><br/>class Camera{<br/>    Function&lt;Color, Color&gt; filter;<br/>    public Camera(Function&lt;Color,Color&gt;... filters) {<br/><br/>        filter = Stream.<em class="kf">of</em>(filters)<br/>                .reduce(Function.<em class="kf">identity</em>(),Function::andThen);<br/><br/>    }<br/><br/>    public Color snap(Color input) {<br/>        return filter.apply(input);<br/>    }<br/>}</span></pre></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><p id="ef07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你感兴趣，这是我其他博客的链接…</p><div class="lv lw ez fb lx ly"><a href="https://nuwanzen.medium.com/java-blogs-bb6e034ba1cb" rel="noopener follow" target="_blank"><div class="lz ab dw"><div class="ma ab mb cl cj mc"><h2 class="bd hj fi z dy md ea eb me ed ef hh bi translated">Java博客</h2><div class="mf l"><p class="bd b fp z dy md ea eb me ed ef dx translated">nuwanzen.medium.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml jn ly"/></div></div></a></div></div></div>    
</body>
</html>