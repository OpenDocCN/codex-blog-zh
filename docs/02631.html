<html>
<head>
<title>Interfaces vs Abstract Classes in PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP中的接口与抽象类</h1>
<blockquote>原文：<a href="https://medium.com/codex/interfaces-vs-abstract-classes-in-php-d2c9d34b599?source=collection_archive---------11-----------------------#2021-07-29">https://medium.com/codex/interfaces-vs-abstract-classes-in-php-d2c9d34b599?source=collection_archive---------11-----------------------#2021-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c51f571208bcfdf6f20b9d61417d8fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-UJep5tWNIU_ZaHP.png"/></div></div></figure><h1 id="02cd" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="5fe3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我最近发表了一篇博文，谈到了<a class="ae km" href="https://ashallendesign.co.uk/blog/using-interfaces-to-write-better-php-code" rel="noopener ugc nofollow" target="_blank">如何使用接口</a>编写更好的PHP代码。它涵盖了什么是接口、它们能做什么以及如何使用它们使PHP代码更具可扩展性和可维护性的基础知识。</p><p id="4f5b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我在帖子上得到的一个主要评论来自开发者，他们想知道“什么时候我会使用接口而不是抽象类？”。所以我想我应该写这篇文章来解释PHP中抽象类和接口之间的区别，并简要概述何时应该使用它们中的任何一个。</p><h1 id="59d9" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">什么是接口？</h1><p id="a21e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">用基本术语来说，接口应该描述实现它们的类将如何构建，它们就像描述它们应该包含的公共方法和常量的蓝图。</p><p id="87da" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">接口<strong class="jq hj">可以是:</strong></p><ul class=""><li id="75cb" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl kx ky kz la bi translated">用于定义类的公共方法签名。</li><li id="e716" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">用于定义类的常数。</li></ul><p id="272f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">接口<strong class="jq hj">不能</strong>是:</p><ul class=""><li id="09ba" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl kx ky kz la bi translated">自行实例化。</li><li id="b849" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">用于为类定义私有或受保护的方法。</li><li id="06b7" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">用于定义类的属性。</li></ul><p id="dfb1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">接口用于定义一个类应该包含的公共方法。重要的是要记住，一个接口总是要由一个类来实现的，所以在这里你只需要定义一个方法的签名，例如:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="1805" class="lp ir hi ll b fi lq lr l ls lt">interface HomeInterface<br/>{<br/>    const MATERIAL = 'Brick';<br/><br/>    public function openDoor(): void;<br/><br/>    public function getRooms(): array;<br/><br/>    public function hasGarden(): bool;<br/>}</span></pre><p id="5d05" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">而不是像这样:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="cecc" class="lp ir hi ll b fi lq lr l ls lt">interface HomeInterface<br/>{<br/>    public string $material = 'Brick';<br/><br/>    public function openDoor(): void<br/>    {<br/>        // Open the door here...<br/>    }<br/>    <br/>    public function getRooms(): array<br/>    {<br/>        // Get the room data here...<br/>    }<br/> <br/>    public function hasGarden(): bool<br/>    {<br/>        // Determine if the home has a garden...<br/>    }<br/>}</span></pre><p id="e82c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">根据php.net的说法，接口有两个主要用途:</p><ol class=""><li id="52d5" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl lu ky kz la bi translated">允许开发人员创建可互换使用的不同类的对象，因为它们实现相同的一个或多个接口。一个常见的例子是多个数据库访问服务、多个支付网关或不同的缓存策略。不同的实现可以交换，而不需要对使用它们的代码进行任何更改。</li><li id="92c2" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lu ky kz la bi translated">允许函数或方法接受符合接口的参数并对其进行操作，而不关心对象还可以做什么或如何实现。这些接口通常被命名为Iterable、Cacheable、Renderable等等，以描述行为的重要性。</li></ol><p id="cc22" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">使用我们上面的接口并坚持房子的类比，我们可以创建实现<code class="du lv lw lx ll b">HomeInterface</code>的不同类，比如<code class="du lv lw lx ll b">House</code>、<code class="du lv lw lx ll b">Flat</code>或<code class="du lv lw lx ll b">Caravan</code>。通过使用接口，我们可以确保我们的类包含了3个必要的方法，并且都使用了正确的方法签名。例如，我们可以有一个看起来像这样的<code class="du lv lw lx ll b">House</code>类:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="047c" class="lp ir hi ll b fi lq lr l ls lt">class House implements HomeInterface<br/>{<br/>    public function openDoor(): void<br/>    {<br/>        // Open the door here...<br/>    }<br/>    <br/>    public function getRooms(): array<br/>    {<br/>        // Get the room data here...<br/>    }<br/> <br/>    public function hasGarden(): bool<br/>    {<br/>        // Determine if the home has a garden...<br/>    }<br/>}</span></pre><h1 id="d602" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">什么是抽象类？</h1><p id="0464" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">抽象类非常类似于接口；它们并不是被设计成独立实例化的，而是为您提供一个基本的实现来进行扩展。</p><p id="aa37" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">以我们上面的家为例，如果一个界面是你的蓝图，那么一个抽象类就是你的展示室模型。它很好用，是一个很好的家居范例，但你仍然需要布置和装饰它，让它成为你自己的家。</p><p id="3e7b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">抽象类<strong class="jq hj">可以是:</strong></p><ul class=""><li id="5c5b" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl kx ky kz la bi translated">用于使用“抽象”方法(类似于接口)为类定义方法签名。</li><li id="1527" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">用于定义方法。</li><li id="dc2f" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">用于定义类的常数。</li><li id="53d2" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">用于定义类的属性。</li><li id="7bf5" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl kx ky kz la bi translated">由子类扩展。</li></ul><p id="0449" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">抽象类<strong class="jq hj">不能</strong>是:</p><ul class=""><li id="dd4e" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl kx ky kz la bi translated">自行实例化。</li></ul><p id="5454" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">为了理解这意味着什么，让我们看一个抽象类的例子:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="56e3" class="lp ir hi ll b fi lq lr l ls lt">abstract class House<br/>{<br/>    const MATERIAL = 'Brick';<br/>  <br/>    abstract public function openDoor(): void;<br/>    <br/>    public function getRooms(): array<br/>    {<br/>        return [<br/>            'Bedroom',<br/>            'Bathroom',<br/>            'Living Room',<br/>            'Kitchen',<br/>        ];  <br/>    }<br/> <br/>    public function hasGarden(): bool<br/>    {<br/>        return true;<br/>    }<br/>}</span></pre><p id="3638" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们的<code class="du lv lw lx ll b">House</code>类是抽象的，这意味着我们不能直接实例化其中的一个。为了能够使用它，我们需要继承它。例如，让我们创建一个扩展我们的<code class="du lv lw lx ll b">House</code>抽象类的<code class="du lv lw lx ll b">MyHouse</code>类:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="bf40" class="lp ir hi ll b fi lq lr l ls lt">class MyHouse extends House<br/>{  <br/>    public function openDoor(): void<br/>    {<br/>        // Open the door...<br/>    }<br/>    <br/>    public function getRooms(): array<br/>    {<br/>        return [<br/>            'Bedroom One',<br/>            'Bedroom Two',<br/>            'Bathroom',<br/>            'Living Room',<br/>            'Kitchen',<br/>        ];  <br/>    }<br/>}</span><span id="6e7f" class="lp ir hi ll b fi ly lr l ls lt">// This will not work:<br/>$house = new House();<br/><br/>// This will work:<br/>$house = new MyHouse();</span></pre><p id="1e29" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">你可能已经注意到，在<code class="du lv lw lx ll b">House</code>类中，我们声明了一个名为<code class="du lv lw lx ll b">openDoor()</code>的抽象公共方法。这基本上允许我们定义一个子类应该包含的方法的签名，就像我们定义一个接口一样。如果您想与您的子类共享一些功能，但又想强制它们包含自己的一些方法的实现，这确实很方便。</p><p id="3002" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在这个特殊的例子中，子类可以像往常一样覆盖<code class="du lv lw lx ll b">getRooms()</code>和<code class="du lv lw lx ll b">hasGarden()</code>方法，但是不需要包含它们。为了展示这一点，我们重写了<code class="du lv lw lx ll b">getRooms()</code>方法，以展示如何在子类中改变它的行为。</p><h1 id="0b30" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">如何决定使用哪一个</h1><p id="56f6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这真的取决于你的目标是什么。为了保持我们的房子类比，如果你正在创建蓝图，可以用于以后设计不同类型的房子，那么你需要一个界面。</p><p id="19f8" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果你建造了一所房子，现在你需要定制副本，那么你需要一个抽象类。</p><p id="006d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">让我给你举几个例子:</p><h1 id="40fe" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">何时使用界面</h1><p id="1f58" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了帮助我们理解什么时候使用接口，让我们看一个例子。假设我们有一个包含<code class="du lv lw lx ll b">buildHome()</code>方法的<code class="du lv lw lx ll b">ConstructionCompany</code>类，如下所示:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="221c" class="lp ir hi ll b fi lq lr l ls lt">class ConstructionCompany<br/>{<br/>    public function buildHome($home)<br/>    { <br/>        // Build the home here...<br/>	  <br/>        return $home;<br/>    }<br/>}</span></pre><p id="21da" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">现在，假设我们有3个不同的类，我们希望能够构建并传递给<code class="du lv lw lx ll b">buildHome()</code>方法:</p><ol class=""><li id="127e" class="ks kt hi jq b jr kn jv ko jz ku kd kv kh kw kl lu ky kz la bi translated"><code class="du lv lw lx ll b">class MyHouse implements HomeInterface extends House</code></li><li id="41da" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lu ky kz la bi translated"><code class="du lv lw lx ll b">class MyCaravan implements HomeInterface</code></li><li id="4a41" class="ks kt hi jq b jr lb jv lc jz ld kd le kh lf kl lu ky kz la bi translated"><code class="du lv lw lx ll b">class MyFlat implements HomeInterface</code></li></ol><p id="31a3" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们可以看到，<code class="du lv lw lx ll b">MyHouse</code>类扩展了<code class="du lv lw lx ll b">House</code>抽象类；从概念的角度来看，这是完全合理的，因为房子就是房子。然而，从抽象类扩展出<code class="du lv lw lx ll b">MyCaravan</code>或<code class="du lv lw lx ll b">MyFlat</code>类是没有意义的，因为它们都不是房子。</p><p id="86b9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">因此，因为我们的建筑公司能够建造房屋、大篷车和公寓，这就排除了us type暗示<code class="du lv lw lx ll b">buildHome()</code>方法中的<code class="du lv lw lx ll b">$home</code>参数是<code class="du lv lw lx ll b">House</code>的实例。</p><p id="3cdf" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">然而，这将是一个完美的地方，我们可以键入hint我们的方法，只允许实现了<code class="du lv lw lx ll b">HomeInterface</code>的类被传递。例如，我们可以将该方法更新为:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="0f35" class="lp ir hi ll b fi lq lr l ls lt">class ConstructionCompany<br/>{<br/>    public function buildHome(HomeInterface $home)<br/>    { <br/>        // Build the home here...<br/>	  <br/>        return $home;<br/>    }<br/>}</span></pre><p id="fe29" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这样做的结果是，我们可以确信，无论我们经过一所房子、一辆大篷车还是一套公寓，我们的<code class="du lv lw lx ll b">ConstructionCompany</code>类都将拥有它所需要的信息，因为传入的home对象将总是包含我们所需要的必要方法。</p><p id="377b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">你可能也在想“为什么我们不创建一个抽象类而不是一个接口呢？”。然而，重要的是要记住PHP只支持单一继承，一个类不能扩展一个以上的父类。所以，如果你想在将来扩展你的一个类，这会变得非常困难。</p><h1 id="51cc" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">何时使用抽象类</h1><p id="65e3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们看一个类似于上面例子的场景。让我们想象一下，我们有一个与我们的<code class="du lv lw lx ll b">ConstructionCompany</code>相似的<code class="du lv lw lx ll b">HouseConstructionCompany</code>。但是，在这个例子中，我们将假设<code class="du lv lw lx ll b">HouseConstructionCompany</code>只建造房屋，其他什么都不建造。</p><p id="9203" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">因为我们知道我们只需要能够建造房屋，我们可以键入hint我们的方法只接受扩展了<code class="du lv lw lx ll b">House</code>抽象类的类。这真的很有用，因为我们可以始终确保我们不会将任何其他类型的房屋传递给建筑公司没有建造的方法。例如:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="1dd1" class="lp ir hi ll b fi lq lr l ls lt">class HouseConstructionCompany<br/>{<br/>    public function buildHouse(House $house)<br/>    { <br/>        // Build the house here...<br/>	  <br/>        return $house;<br/>    }<br/>}</span></pre><h1 id="b9f9" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="9160" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">希望这篇文章能让你深入了解PHP中接口和抽象类的区别。它还应该给你一个不同场景的简要概述，当你应该使用其中任何一个。</p><p id="83e7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果这篇文章对你有所帮助，我很乐意听听。同样，如果你对这篇文章有任何改进的反馈，我也很乐意听到。</p><p id="a49b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">对于我的Laravel开发者读者来说，如果他们想进一步了解关于接口的内容，可以在这里阅读Laravel 中关于如何使用接口来<a class="ae km" href="https://ashallendesign.co.uk/blog/using-the-bridge-pattern-in-laravel" rel="noopener ugc nofollow" target="_blank">使用策略模式的内容。</a></p><p id="af8b" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果你有兴趣在我每次发布新帖子时得到更新，请随意<a class="ae km" href="https://ashallendesign.co.uk/blog" rel="noopener ugc nofollow" target="_blank">在这里注册我的时事通讯</a>。</p><p id="e5ab" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">非常感谢<a class="ae km" href="https://www.linkedin.com/in/james-mahy-84524615/" rel="noopener ugc nofollow" target="_blank"> James Mahy </a>、<a class="ae km" href="https://www.linkedin.com/in/aditya-kadam-77a594134/" rel="noopener ugc nofollow" target="_blank"> Aditya Kadam </a>和<a class="ae km" href="https://www.linkedin.com/in/andrew-palfrey/" rel="noopener ugc nofollow" target="_blank"> Andrew Palfrey </a>校对这篇文章并给我反馈！我推荐看看詹姆斯正在建立的一个很酷的社交网络:<a class="ae km" href="https://sosa.net/" rel="noopener ugc nofollow" target="_blank"> SoSa </a>，一个有趣、友好、隐私至上的社区，让在线社交变得简单而有趣！</p><p id="9f6f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">也非常感谢<a class="ae km" href="https://www.linkedin.com/in/jessica-pickup-481030186/" rel="noopener ugc nofollow" target="_blank"> Jess Pickup </a>一如既往地创造了另一个很酷的博文图片！</p><p id="0d45" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">继续建造令人敬畏的东西！🚀</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="c8a7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><em class="mg">原载于</em><a class="ae km" href="https://ashallendesign.co.uk/blog/interfaces-vs-abstract-classes-in-php" rel="noopener ugc nofollow" target="_blank"><em class="mg">https://ashallendesign.co.uk</em></a><em class="mg">。</em></p></div></div>    
</body>
</html>