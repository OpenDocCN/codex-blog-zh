<html>
<head>
<title>Designing a user notification system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计用户通知系统</h1>
<blockquote>原文：<a href="https://medium.com/codex/user-notification-system-744dfd0a237c?source=collection_archive---------1-----------------------#2022-07-26">https://medium.com/codex/user-notification-system-744dfd0a237c?source=collection_archive---------1-----------------------#2022-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c161" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通知您的用户</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/fc91dffe116093e9e3b90fdede7604ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O1kx-xfgBX2oDEV4"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://unsplash.com/@firmbee" rel="noopener ugc nofollow" target="_blank"> Firmbee </a>在<a class="ae jn" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="32c1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">到目前为止，我在职业生涯中遇到的主要系统工程任务之一是实现一个异步通信机制，该机制将遵守以下要求:</p><ul class=""><li id="dbeb" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">系统必须是可伸缩的(多个SignalR实例、多个代理监听器、多个Redis底板服务器)</li><li id="8970" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">通信必须是异步的</li><li id="dfc4" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">系统必须是无状态的(我们可以在不同的服务器上有多个signalR客户端，在其他服务器上有publisher，我们必须确保它们之间没有耦合)</li></ul></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h2 id="8d45" class="lf lg hi bd lh li lj lk ll lm ln lo lp jx lq lr ls kb lt lu lv kf lw lx ly lz bi translated">要求:</h2><ul class=""><li id="6c73" class="kk kl hi jq b jr ma ju mb jx mc kb md kf me kj kp kq kr ks bi translated">发送用户通知将到达订阅该通知的所有用户设备上的特定用户</li><li id="cda6" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">从向代理发布通知的那一刻起，直到用户的端点(所有设备)，通知必须是可跟踪的</li></ul><p id="889d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我的技术堆栈如下:</p><p id="e285" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> SignalR，RabbitMQ，Redis </strong></p><p id="c70e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要了解有关此<a class="ae jn" href="https://docs.microsoft.com/en-us/aspnet/core/signalr/redis-backplane?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank">的更多信息，请访问https://docs . Microsoft . com/en-us/aspnet/core/signalr/redis-back plane？view=aspnetcore-5.0 </a></p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h2 id="0290" class="lf lg hi bd lh li lj lk ll lm ln lo lp jx lq lr ls kb lt lu lv kf lw lx ly lz bi translated">设计</h2><p id="3339" class="pw-post-body-paragraph jo jp hi jq b jr ma ij jt ju mb im jw jx mf jz ka kb mg kd ke kf mh kh ki kj hb bi translated">一个简单的原理图(原谅我的设计，我没有上过绘图系统架构的课)</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/0240542a7036f1a40fc55e3a53eb2a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*81cdrUV_JUewgFL1.jpg"/></div></div></figure><p id="f477" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该框架将提供创建用户通知系统所需的机制，并将基于Redis的消息构造为控制器和动作，使其更容易使用。</p><p id="256a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这种机制(将是一种既有信号集线器又有监听器来接收用户通知的服务)。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h2 id="acd2" class="lf lg hi bd lh li lj lk ll lm ln lo lp jx lq lr ls kb lt lu lv kf lw lx ly lz bi translated">图书馆</h2><p id="924e" class="pw-post-body-paragraph jo jp hi jq b jr ma ij jt ju mb im jw jx mf jz ka kb mg kd ke kf mh kh ki kj hb bi translated">您可以在以下位置找到该库:</p><div class="mj mk ez fb ml mm"><a href="https://github.com/ramihamati/hubnotificationsystem/tree/main/Digitteck.HubNotificationSystem/Digitteck.HubNotificationSystem" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">hub notification system/digit Teck。hub notification system/digit Teck。中枢通知系统在主…</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">一个使用带有redis背板的signalR创建用户通知系统的库。…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">github.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na jh mm"/></div></div></a></div></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h2 id="043a" class="lf lg hi bd lh li lj lk ll lm ln lo lp jx lq lr ls kb lt lu lv kf lw lx ly lz bi translated">流动</h2><ol class=""><li id="fc50" class="kk kl hi jq b jr ma ju mb jx mc kb md kf me kj nb kq kr ks bi translated">当用户通过身份验证后，他将使用sinalR连接到<code class="du nc nd ne nf b">the service</code>。然后，该服务将在内存中存储这对<code class="du nc nd ne nf b">userId-connectionId</code>。每个用户可以有多个连接，但每对都是唯一的。</li><li id="cdc7" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj nb kq kr ks bi translated">对于每个独特的用户，该服务将订阅其Redis频道。在用户的redis通道中流动的消息具有相同的结构，它是一个交换模型，包含消息体以及关于控制器名称和消息的信息。通过控制器处理redis消息，然后通过signalR推送的示例</li></ol><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="2060" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">保持用户连接活动的集线器，如果需要，将发送用户通知。每个signalR实例将搜索用户可能拥有的所有连接</p><p id="d90a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">将侦听Redis的通知更新的侦听器。Redis就像一个发布订阅机制。它被用作所有sinalR集线器的背板。Redis发布-订阅包含每个用户作为一个通道。</p><p id="3b35" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">为什么是redis？</strong>在速度优势的背后……我使用了pub sub机制，虽然它也可以与其他pub/sub机制一起工作，但Redis pub sub非常简单快速，它可以启动并忘记。我们不会在内存中保存任何东西。消息被立即推送给任何活动订户(如果有的话)。在Redis中发布和订阅一个频道，计算成本很小，这才是我们真正需要的。</p><p id="8eee" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">3.工人:</p><p id="f58c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">工人指的是一个项目，这个项目让消费者听一个代理(例如RabbitMQ)。它不是框架的一部分，但是框架提供了一个<code class="du nc nd ne nf b">notification publisher</code>,用于通过某些redis路由向某个用户发布消息。</p><p id="23f7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">为什么出版要先交给经纪人？</strong></p><p id="28c1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为我们不想堵塞系统。我们可以在Rabbit中实现一个time to live，一个接一个地处理所有消息。</p><h1 id="d690" class="ni lg hi bd lh nj nk nl ll nm nn no lp io np ip ls ir nq is lv iu nr iv ly ns bi translated">例子</h1><p id="c25f" class="pw-post-body-paragraph jo jp hi jq b jr ma ij jt ju mb im jw jx mf jz ka kb mg kd ke kf mh kh ki kj hb bi translated">我们的解决方案有两个项目:</p><ul class=""><li id="5744" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">NotificationManager(通知。系统更新):signalR和redis监听器</li><li id="2981" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">NotificationPublisher(通知。将消息发布到redis</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nt"><img src="../Images/fd34e0df2aa329daf0d09940f5ea933b.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*oElMcjAyNo4TBN54UqecCg.png"/></div></figure><h2 id="23fa" class="lf lg hi bd lh li lj lk ll lm ln lo lp jx lq lr ls kb lt lu lv kf lw lx ly lz bi translated">通知经理</h2><p id="f362" class="pw-post-body-paragraph jo jp hi jq b jr ma ij jt ju mb im jw jx mf jz ka kb mg kd ke kf mh kh ki kj hb bi translated">注册服务:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ng nh l"/></div></figure><ul class=""><li id="0ea0" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">RegisterController:这个系统使用类似控制器的方法来处理发布到redis的各种消息。这里我们注册一个控制器类型。</li><li id="bbcd" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">RegisterTopology:用于密钥创建</li></ul><p id="0422" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">IHubUserPushback和HubUserPushback正在使用操作定义signalR hub</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="1e9b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于signal R hub，我们只需要声明接口方法(客户端回调)，订阅和取消订阅在后台处理。我们只需要创建一个从<code class="du nc nd ne nf b">NotificationHub</code>派生的hub</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="2129" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">库类NotificationHub将实现subscribe和unsubscribe方法，您只需要从from端连接到Hub。要了解有关从typescript客户端发送不记名令牌的更多信息，请阅读下面的<a class="ae jn" href="https://docs.microsoft.com/en-us/aspnet/core/signalr/authn-and-authz?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/aspnet/core/signalr/authn-and-authz？view=aspnetcore-5.0 </a></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="8ed8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Redis控制器的作用是</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="a25b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当收到包含正确路由信息的redis消息时，将自动调用该控制器。(参见发布者部分)</p><h2 id="426d" class="lf lg hi bd lh li lj lk ll lm ln lo lp jx lq lr ls kb lt lu lv kf lw lx ly lz bi translated">通知发布者</h2><p id="9563" class="pw-post-body-paragraph jo jp hi jq b jr ma ij jt ju mb im jw jx mf jz ka kb mg kd ke kf mh kh ki kj hb bi translated">这个工作者监听一个代理(在我的例子中，我选择了RabbitMQ和MassTransit ),当收到一条消息时，我们使用发布者将消息推送到Redis(由管理器获取并推送到用户的设备)</p><p id="2289" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注册服务:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="80c9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里我们明确地注册了所有的路由(因为我们需要将这些信息添加到Redis交换模型中</p><p id="8266" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">经纪人的消费者</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ng nh l"/></div></figure></div></div>    
</body>
</html>