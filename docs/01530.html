<html>
<head>
<title>Bitcoin Trade Automation with Awesome Oscillator in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的Awesome振荡器实现比特币交易自动化</h1>
<blockquote>原文：<a href="https://medium.com/codex/bitcoin-trade-automation-with-awesome-oscillator-in-python-51f2c52c5b25?source=collection_archive---------5-----------------------#2021-05-10">https://medium.com/codex/bitcoin-trade-automation-with-awesome-oscillator-in-python-51f2c52c5b25?source=collection_archive---------5-----------------------#2021-05-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="68db" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">实施并回溯测试基于AO的强大交易策略，以便用python进行比特币交易</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/860ebb6ce881188a874dda522e39502c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_6Fb9JLYOjM8HRswH3NBQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://www.behance.net/gallery/58382501/Bloomberg-BusinessweekBitcoin-explainer?tracking_source=search_projects_recommended%7Cbitcoin" rel="noopener ugc nofollow" target="_blank">图片由西尔维亚·布玛儿·杨拍摄</a></figcaption></figure><p id="a088" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最近几天，围绕比特币或加密货币的炒作只增不减，从未出现势头下降。虽然比特币正在达到创纪录的高度，但许多投机者认为这只是另一个泡沫，随时可能破裂。此外，在分析比特币突然涨价背后的原因时，人类的心态和贪婪似乎起了至关重要的作用。考虑到这些事实，我们可以说比特币市场是最不稳定、风险最大的交易市场之一。幸运的是，在算法交易的帮助下，我们可以通过自动化交易来安全地应对这个动荡的市场。在本文中，我们将使用一个名为Awesome Oscillator (AO)的强大技术指标，并基于它创建一个交易策略，以使用python进行自动比特币交易。</p><p id="b96b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在继续之前，如果你想在没有任何代码的情况下回溯测试你的交易策略，有一个解决方案。这是<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">回测区</a>。这是一个平台，可以免费对不同类型的可交易资产的任意数量的交易策略进行回溯测试，无需编码。点击这里的链接，你可以马上使用这个工具:【https://www.backtestzone.com/ T4】</p><h1 id="54ad" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">超棒振荡器(AO)</h1><p id="efec" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">Awesome振荡器(AO)是一个领先的技术指标，用于识别市场趋势或衡量市场动力。Awesome振荡器以直方图的形式绘制，当前棒线高于前一棒线时显示绿色棒线，类似地，当前棒线低于前一棒线时显示红色棒线。作为一个振荡器，Awesome振荡器的值在零线上下波动。</p><p id="79ab" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要了解AO是如何计算的，有必要了解简单移动平均线(SMA)的一些知识。SMA不过是特定时期的平均价格。Awesome振荡器的计算方法是从5周期简单移动平均线中减去34周期简单移动平均线。SMAs不是根据股票的收盘价计算的，而是根据中间价计算的。计算Awesome振荡器的方法可表示如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="1634" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">AO = SMA 5 OF MEDIAN PRICE - SMA 34 OF MEDIAN PRICE</strong></span></pre><p id="d26e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经了解了什么是超棒的振荡器。让我们对我们的交易策略建立一些直觉。</p><p id="a34b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">关于我们的交易策略:</strong>基于AO的交易策略有很多种，但在本文中，我们将探讨一种叫做零线交叉的基本策略。当AO从下面穿越到零线上面时，我们的交易策略产生买入信号。当AO从零线上方穿过时，显示卖出信号。Ou交易策略可以表示如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="7ff0" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">IF PREVIOUS AO &lt; 0 AND CURRENT AO &gt; 0 =&gt; BUY SIGNAL<br/>IF PREVIOUS AO &gt; 0 AND CURRENT AO &lt; 0 =&gt; SELL SIGNAL </strong></span></pre><p id="95de" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经了解了AO的含义以及如何用它来建立交易策略。让我们使用Python来实现我们自己的基于AO的交易策略，并对其进行回溯测试，看看它在现实市场中的表现如何。</p><p id="db71" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">在继续之前，免责声明:本文的唯一目的是教育人们，必须被视为一个信息，而不是投资建议等。</strong></p><h1 id="a5c1" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">Python实现</h1><p id="74d4" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">编码部分分为以下几个步骤:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="19f4" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">1. Importing Packages<br/>2. Extracting Data from Alpha Vantage<br/>3. Awesome Oscillator Calculation<br/>4. AO Plot<br/>5. Creating the Trading Strategy<br/>6. Plotting the Trading Signals<br/>7. Creating our Position<br/>8. Backtesting</strong></span></pre><p id="dd62" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h2 id="be6e" class="lm kl hi bd km lr ls lt kq lu lv lw ku jx lx ly kw kb lz ma ky kf mb mc la md bi translated">步骤1:导入包</h2><p id="4839" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="d77f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="96e1" class="lm kl hi li b fi ln lo l lp lq">import pandas as pd<br/>import requests<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.rcParams['figure.figsize'] = (20, 10)<br/>plt.style.use('fivethirtyeight')</span></pre><p id="0edd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">既然我们已经将所有基本的包导入到python环境中。让我们继续用Alpha Vantage强大的crypto API提取比特币的历史数据。</p><h2 id="2c73" class="lm kl hi bd km lr ls lt kq lu lv lw ku jx lx ly kw kb lz ma ky kf mb mc la md bi translated">步骤2:从Alpha Vantage中提取数据</h2><p id="f9ba" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将使用Alpha Vantage提供的API端点来提取比特币的历史数据。在此之前，关于Alpha Vantage的一个说明:Alpha Vantage提供免费的股票API，用户可以通过这些API访问各种数据，如实时更新，以及股票、货币和加密货币的历史数据。确保你在Alpha Vantage上有一个帐户，只有这样，你才能访问你的秘密API密匙(使用API提取数据的一个关键元素)。</p><p id="3642" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="bb74" class="lm kl hi li b fi ln lo l lp lq">def get_crypto_price(symbol, exchange, start_date = None):<br/>    api_key = open(r'api_key.txt')<br/>    api_url = f'https://www.alphavantage.co/query?function=DIGITAL_CURRENCY_DAILY&amp;symbol={symbol}&amp;market={exchange}&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['Time Series (Digital Currency Daily)']).T<br/>    df = df.rename(columns = {'1a. open (USD)': 'Open', '2a. high (USD)': 'High', '3a. low (USD)': 'Low', '4a. close (USD)': 'Close', '5. volume': 'Volume'})<br/>    for i in df.columns:<br/>        df[i] = df[i].astype(float)<br/>    df.index = pd.to_datetime(df.index)<br/>    df = df.iloc[::-1].drop(['1b. open (USD)', '2b. high (USD)', '3b. low (USD)', '4b. close (USD)', '6. market cap (USD)'], axis = 1)<br/>    if start_date:<br/>        df = df[df.index &gt;= start_date]<br/>    return df<br/><br/>btc = get_crypto_price(symbol = 'BTC', exchange = 'USD', start_date = '2020-01-01')<br/>btc</span></pre><p id="6b7f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/77ed2b038dd19917a01ebccbfcb38896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bm07ccS3oHBAMi1HjrWYQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="080e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们做的第一件事是定义一个名为“get_historical_data”的函数，它将加密的符号(' symbol ')、加密交换(' exchange ')作为必需参数，将历史数据的开始日期(' start_date ')作为可选参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们正在调用创建的函数，从2020年开始以美元作为交换拉取比特币的历史数据，并将其存储到' btc '变量中。</p><h2 id="5d3e" class="lm kl hi bd km lr ls lt kq lu lv lw ku jx lx ly kw kb lz ma ky kf mb mc la md bi translated">步骤3:出色的振荡器计算</h2><p id="44d7" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将按照之前讨论的公式计算Awesome振荡器的值。</p><p id="a8b6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="52ef" class="lm kl hi li b fi ln lo l lp lq">def sma(price, period):<br/>    sma = price.rolling(period).mean()<br/>    return sma<br/><br/>def ao(price, period1, period2):<br/>    median = price.rolling(2).median()<br/>    short = sma(median, period1)<br/>    long = sma(median, period2)<br/>    ao = short - long<br/>    ao_df = pd.DataFrame(ao).rename(columns = {'Close':'ao'})<br/>    return ao_df<br/><br/>btc['ao'] = ao(btc['Close'], 5, 34)<br/>btc = btc.dropna()<br/>btc.tail()</span></pre><p id="b515" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mf"><img src="../Images/f968f5f62afa228f4609a3373e575f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0pJhZDhD9b_TEM0FsrnhA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="1384" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>该代码可分为两部分:SMA计算和AO计算。在第一部分中，我们定义了一个名为“sma”的函数，它将加密价格(“price”)和周期数(“period”)作为参数。在函数内部，我们使用Pandas包提供的“滚动”函数来计算给定周期数的SMA。我们将计算出的值存储到“sma”变量中并返回它。</p><p id="a08d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在第二部分中，我们定义了另一个名为“ao”的函数，它将加密价格(“price”)、短长度SMA(“period 1”)和长长度SMA(“period 2”)作为参数。在函数中，我们首先使用Pandas软件包提供的“滚动”和“中值”函数计算给定加密价格的中值。接下来，我们定义两个名为“short”和“long”的变量来存储使用我们之前创建的函数计算的短长度和长长度SMA。为了计算Awesome振荡器的值，我们从短长度SMA中减去长长度SMA，并将其存储到“ao”变量中。然后，我们将“ao”变量转换为dataframe并返回它。最后，我们调用函数来存储比特币的AO值。</p><h2 id="bd7d" class="lm kl hi bd km lr ls lt kq lu lv lw ku jx lx ly kw kb lz ma ky kf mb mc la md bi translated">步骤4:出色的振荡器图</h2><p id="cec2" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将绘制出计算出来的比特币令人敬畏的振荡器值，以更好地理解它。这一部分的主要目的不是在编码部分，而是观察情节，以获得对Awesome振荡器的坚实理解。</p><p id="67d7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="fa99" class="lm kl hi li b fi ln lo l lp lq">ax1 = plt.subplot2grid((10,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((10,1), (6,0), rowspan = 4, colspan = 1)<br/>ax1.plot(btc['Close'])<br/>ax1.set_title('BITCOIN CLOSING PRICE')<br/>for i in range(len(btc)):<br/>    if btc['ao'][i-1] &gt; btc['ao'][i]:<br/>        ax2.bar(btc.index[i], btc['ao'][i], color = '#f44336')<br/>    else:<br/>        ax2.bar(btc.index[i], btc['ao'][i], color = '#26a69a')<br/>ax2.set_title('BITCOIN AWESOME OSCILLATOR 5,34')<br/>plt.show()</span></pre><p id="0a64" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/3b5d610b64d2fb26baeb97ef9a192293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-3ztVEjb0DGaDziYr8sKQ.png"/></div></div></figure><p id="1a3c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的图表分为两个面板:上面的面板代表比特币的收盘价，下面的面板以直方图的形式绘制了AO值。如您所见，每当当前棒线大于前一棒线时，图表上会绘制绿色棒线，每当当前棒线小于前一棒线时，图表上会绘制红色棒线。</p><p id="e7af" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">市场动能:通过观察柱状图的长度，可以很容易地确定市场的动能。你可以在上面的图表中看到，在最初的十个月中，比特币的价格波动不是很大，你也可以看到AO柱状图的柱线很小，表明市场的势头很差。另一方面，过去几个月对比特币来说相当不错，你可以看到AO柱状图的柱线更大，显示了更大的市场动力。</p><p id="4f02" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">市场趋势:</strong>就像市场的动量可以很容易地用AO的柱状图来识别一样，它也有助于了解标记的趋势，是下跌还是上涨。当Awesome振荡指标的值大于零线时，市场被认为处于上升趋势，同样，当Awesome振荡指标的值小于零线时，市场处于下降趋势。</p><h2 id="2c14" class="lm kl hi bd km lr ls lt kq lu lv lw ku jx lx ly kw kb lz ma ky kf mb mc la md bi translated">步骤5:创建交易策略</h2><p id="55b0" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将在python中实现讨论过的Awesome振荡器交易策略。</p><p id="dd95" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="d960" class="lm kl hi li b fi ln lo l lp lq">def implement_ao_crossover(price, ao):<br/>    buy_price = []<br/>    sell_price = []<br/>    ao_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(ao)):<br/>        if ao[i] &gt; 0 and ao[i-1] &lt; 0:<br/>            if signal != 1:<br/>                buy_price.append(price[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                ao_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                ao_signal.append(0)<br/>        elif ao[i] &lt; 0 and ao[i-1] &gt; 0:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(price[i])<br/>                signal = -1<br/>                ao_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                ao_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            ao_signal.append(0)<br/>    return buy_price, sell_price, ao_signal<br/><br/>buy_price, sell_price, ao_signal = implement_ao_crossover(btc['Close'], btc['ao'])</span></pre><p id="121d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为‘implement _ ao _ strategy’的函数，它将股票价格(‘price’)和AO值(‘AO’)作为参数。</p><p id="884e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在该函数中，我们创建了三个空列表(buy_price、sell_price和ao_signal ),在创建交易策略时，将在这些列表中追加值。</p><p id="aa46" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之后，我们通过for循环实施交易策略。在for循环内部，我们传递某些条件，如果条件得到满足，相应的值将被追加到空列表中。如果购买股票的条件得到满足，买入价将被追加到“buy_price”列表中，信号值将被追加为1，表示购买股票。类似地，如果卖出股票的条件得到满足，卖价将被追加到“sell_price”列表中，信号值将被追加为-1，表示卖出股票。</p><p id="5132" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们返回附加了值的列表。然后，我们调用创建的函数并将值存储到各自的变量中。除非我们画出这些值，否则这个列表没有任何意义。所以，让我们画出创建的交易列表的值。</p><h2 id="4919" class="lm kl hi bd km lr ls lt kq lu lv lw ku jx lx ly kw kb lz ma ky kf mb mc la md bi translated">步骤6:绘制交易信号</h2><p id="0de2" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将绘制已创建的交易列表，以使它们有意义。</p><p id="7817" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="4c21" class="lm kl hi li b fi ln lo l lp lq">ax1 = plt.subplot2grid((10,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((10,1), (6,0), rowspan = 4, colspan = 1)<br/>ax1.plot(btc['Close'], label = 'BTC', color = 'skyblue')<br/>ax1.plot(btc.index, buy_price, marker = '^', markersize = 12, color = '#26a69a', linewidth = 0, label = 'BUY SIGNAL')<br/>ax1.plot(btc.index, sell_price, marker = 'v', markersize = 12, color = '#f44336', linewidth = 0, label = 'SELL SIGNAL')<br/>ax1.legend()<br/>ax1.set_title('BITCOIN CLOSING PRICE')<br/>for i in range(len(btc)):<br/>    if btc['ao'][i-1] &gt; btc['ao'][i]:<br/>        ax2.bar(btc.index[i], btc['ao'][i], color = '#f44336')<br/>    else:<br/>        ax2.bar(btc.index[i], btc['ao'][i], color = '#26a69a')<br/>ax2.set_title('BITCOIN AWESOME OSCILLATOR 5,34')<br/>plt.show()</span></pre><p id="fa74" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/4ceee628b4c769a9a3d8112b43a1a7d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCYjOI9GVX65KWuRGgbfGg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="be91" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们正在绘制出色的振荡指标值，以及交易策略产生的买入和卖出信号。我们可以观察到，每当牛逼的振荡指标从零线以下到零线以上，图表中就会出现绿色的买入信号。类似地，每当Awesome振荡指标从零线上方到下方时，图表中就会出现红色的卖出信号。</p><h2 id="c8ec" class="lm kl hi bd km lr ls lt kq lu lv lw ku jx lx ly kw kb lz ma ky kf mb mc la md bi translated">步骤7:创建我们的职位</h2><p id="5db2" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将创建一个列表，如果我们持有股票，该列表将指示1；如果我们不拥有或持有股票，该列表将指示0。</p><p id="aeee" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="f7b9" class="lm kl hi li b fi ln lo l lp lq">position = []<br/>for i in range(len(ao_signal)):<br/>    if ao_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(btc['Close'])):<br/>    if ao_signal[i] == 1:<br/>        position[i] = 1<br/>    elif ao_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>ao = btc['ao']<br/>close_price = btc['Close']<br/>ao_signal = pd.DataFrame(ao_signal).rename(columns = {0:'ao_signal'}).set_index(btc.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'ao_position'}).set_index(btc.index)<br/><br/>frames = [close_price, ao, ao_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy</span></pre><p id="eeef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/52d51b65ba26fcfacae7719f06d6a65b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KzBN_JwBt3h1eFUzj3yzaQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="0c1c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们创建一个名为‘position’的空列表。我们传递两个for循环，一个是为“位置”列表生成值，以匹配“信号”列表的长度。另一个for循环是我们用来生成实际位置值的循环。在第二个for循环中，我们对“signal”列表的值进行迭代，而“position”列表的值被附加到满足哪个条件上。如果我们持有股票，头寸的价值仍为1；如果我们卖出或不持有股票，头寸的价值仍为0。最后，我们正在进行一些数据操作，将所有创建的列表合并到一个数据帧中。</p><p id="98a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从显示的输出中，我们可以看到，在前两行中，我们在股票中的位置保持为1(因为AO信号没有任何变化)，但是当AO信号代表卖出信号(-1)时，我们的位置突然变为0。我们的头寸将保持为0，直到交易信号发生一些变化。现在是时候实现一些回溯测试过程了！</p><h2 id="00fe" class="lm kl hi bd km lr ls lt kq lu lv lw ku jx lx ly kw kb lz ma ky kf mb mc la md bi translated">步骤8:回溯测试</h2><p id="2c19" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在继续之前，有必要知道什么是回溯测试。回溯测试是查看我们的交易策略在给定股票数据上表现如何的过程。在我们的案例中，我们将针对比特币股票数据实施AO交易策略的回溯测试流程。</p><p id="0b64" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="52e0" class="lm kl hi li b fi ln lo l lp lq">btc_ret = pd.DataFrame(np.diff(btc['Close'])).rename(columns = {0:'returns'})<br/>ao_strategy_ret = []<br/><br/>for i in range(len(btc_ret)):<br/>    returns = btc_ret['returns'][i]*strategy['ao_position'][i]<br/>    ao_strategy_ret.append(returns)<br/>    <br/>ao_strategy_ret_df = pd.DataFrame(ao_strategy_ret).rename(columns = {0:'ao_returns'})<br/>investment_value = 200000<br/>number_of_stocks = floor(investment_value/btc['Close'][-1])<br/>ao_investment_ret = []<br/><br/>for i in range(len(ao_strategy_ret_df['ao_returns'])):<br/>    returns = number_of_stocks*ao_strategy_ret_df['ao_returns'][i]<br/>    ao_investment_ret.append(returns)<br/><br/>ao_investment_ret_df = pd.DataFrame(ao_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(ao_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = round((total_investment_ret/investment_value)*100, 2)<br/>print(cl('Profit gained from the AO strategy by investing $200k in BTC : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the AO strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre><p id="b263" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="ae13" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">Profit gained from the AO strategy by investing $200k in BTC : 122545.53</strong><br/><strong class="li hj">Profit percentage of the AO strategy : 61.27%</strong></span></pre><p id="c356" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们使用NumPy包提供的“diff”函数计算脸书股票的回报率，并将其作为数据帧存储到“btc_ret”变量中。接下来，我们将传递一个for循环来迭代' btc_ret '变量的值，以计算我们从AO交易策略中获得的回报，这些回报值将被追加到' btc_strategy_ret '列表中。接下来，我们将“ao_strategy_ret”列表转换为数据帧，并将其存储到“ao_strategy_ret_df”变量中。</p><p id="ad76" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是回溯测试过程。我们将通过投资20万美元到我们的交易策略中来回测我们的策略。首先，我们将投资金额存储到“投资值”变量中。之后，我们正在计算使用投资金额可以购买的比特币数量。你可以注意到，我使用了Math软件包提供的“下限”函数，因为当投资金额除以比特币的收盘价时，它会输出一个十进制数。密码的数目应该是整数，而不是小数。使用“底数”函数，我们可以去掉小数。请记住,“floor”函数比“round”函数要复杂得多。然后，我们传递一个for循环来寻找投资回报，随后是一些数据操作任务。</p><p id="af5d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们打印了我们通过投资20万到我们的交易策略中得到的总回报，显示我们在一年中获得了大约12万美元的利润，利润率为61.27%。那还不错！其实很棒！</p><h1 id="5c79" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">其他AO策略</h1><p id="ee53" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">正如我之前提到的，有许多其他基于Awesome振荡器的交易策略，现在我们将探索一些AO策略，除了我们已经实现的。</p><ul class=""><li id="6347" class="mi mj hi jq b jr js ju jv jx mk kb ml kf mm kj mn mo mp mq bi translated"><strong class="jq hj">碟中谍策略:</strong>这个策略是我的最爱之一，很容易实现。当Awesome振荡器在零线以上时，这个策略揭示了买入信号，AO柱状图有两个连续的红色柱，其中第二个红色柱小于第一个红色柱，柱状图的第三个柱是绿色的。同样，当Awesome振荡指标低于零线时，策略显示卖出信号，AO柱状图有两个连续的绿色柱，其中第二个绿色柱小于第一个绿色柱，柱状图的第三个柱是红色的。该策略可以表示如下:</li></ul><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="c03d" class="lm kl hi li b fi ln lo l lp lq">1.<strong class="li hj"> </strong>IF <strong class="li hj">AO &gt; 0 </strong>AND <strong class="li hj">First red AO bar &gt; Second red AO bar</strong> AND<strong class="li hj"> Third bar = Green</strong> --&gt; <strong class="li hj">BUY THE STOCK</strong></span><span id="2bf7" class="lm kl hi li b fi mr lo l lp lq">2. IF <strong class="li hj">AO &lt; 0 </strong>AND <strong class="li hj">First green AO bar &gt; Second green AO bar</strong> AND<strong class="li hj"> Third bar = Red </strong>--&gt; <strong class="li hj">SELL THE STOCK</strong></span></pre><ul class=""><li id="ca74" class="mi mj hi jq b jr js ju jv jx mk kb ml kf mm kj mn mo mp mq bi translated"><strong class="jq hj">双峰策略:</strong>像飞碟策略一样，这种交易策略是一种强有力的策略，当可怕的振荡指标在零线以下时，会显示出买入信号，在零线以下形成两个动量峰，其中第二个峰高于第一个峰，第二个峰低点后的柱状图为绿色。当Awesome振荡器在零线以上时，该策略显示卖出信号，在零线以上形成两个动量峰，其中第二个峰低于第一个峰，第二个峰高之后的直方图为红色。双峰策略可以表示如下:</li></ul><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="a0af" class="lm kl hi li b fi ln lo l lp lq">1. IF <strong class="li hj">AO &lt; 0</strong> AND <strong class="li hj">Second momentum peak &gt; First momentum peak</strong> AND <strong class="li hj">Histogram after second peak low = Green</strong> -- &gt; <strong class="li hj">BUY THE STOCK</strong></span><span id="ed52" class="lm kl hi li b fi mr lo l lp lq">2. IF <strong class="li hj">AO &gt; 0</strong> AND <strong class="li hj">Second momentum peak &lt; First momentum peak</strong> AND <strong class="li hj">Histogram after second peak high = Red </strong>-- &gt; <strong class="li hj">SELL THE STOCK</strong></span></pre><p id="e0e5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">还有其他几种策略也可以实现，但是这两种和我们用python实现的一种是标准的基于AO的策略。熟悉这些之后，你就可以开始创建自己的定制振荡器策略，并在现实市场中实施。</p><h1 id="4d1c" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后的想法！</h1><p id="023c" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这篇文章中，我们几乎涵盖了Awesome Oscillator的所有内容，但改进的可能性很多。你可以调整交易策略，用机器学习模型选择正确的密码，等等，但是，在进行算法交易时，一定要确保你的风险水平不会超出一定范围。当我们作为人类交易密码时，我们有一定的认知技能和直觉来识别我们的交易是否风险太大。然而，我们创造的交易机器人只是执行我们的交易策略的程序，而没有任何情绪来处理涉及风险因素的情况。</p><p id="ca15" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在进行算法交易时，处理风险的一种方法是计算每笔交易的风险水平，忽略风险水平超过特定界限的交易。我们还没有实现这一步，但这并不意味着它不重要。你可以尝试在程序中增加一个步骤，用一些基本的数学和编程来计算风险的大小，这样你就可以在现实市场中交易了。</p><p id="826e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就是这样！希望你能从这篇文章中学到一些新的有用的东西。如果您忘记了遵循任何编码部分，不要担心。我在文章末尾提供了完整的源代码。</p><h2 id="66bc" class="lm kl hi bd km lr ls lt kq lu lv lw ku jx lx ly kw kb lz ma ky kf mb mc la md bi translated">完整代码:</h2><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="3945" class="lm kl hi li b fi ln lo l lp lq">import pandas as pd<br/>import requests<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.rcParams['figure.figsize'] = (20, 10)<br/>plt.style.use('fivethirtyeight')<br/><br/>def get_crypto_price(symbol, exchange, start_date = None):<br/>    api_key = open(r'api_key.txt')<br/>    api_url = f'https://www.alphavantage.co/query?function=DIGITAL_CURRENCY_DAILY&amp;symbol={symbol}&amp;market={exchange}&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['Time Series (Digital Currency Daily)']).T<br/>    df = df.rename(columns = {'1a. open (USD)': 'Open', '2a. high (USD)': 'High', '3a. low (USD)': 'Low', '4a. close (USD)': 'Close', '5. volume': 'Volume'})<br/>    for i in df.columns:<br/>        df[i] = df[i].astype(float)<br/>    df.index = pd.to_datetime(df.index)<br/>    df = df.iloc[::-1].drop(['1b. open (USD)', '2b. high (USD)', '3b. low (USD)', '4b. close (USD)', '6. market cap (USD)'], axis = 1)<br/>    if start_date:<br/>        df = df[df.index &gt;= start_date]<br/>    return df<br/><br/>btc = get_crypto_price(symbol = 'BTC', exchange = 'USD', start_date = '2020-01-01')<br/>print(btc)<br/><br/>def sma(price, period):<br/>    sma = price.rolling(period).mean()<br/>    return sma<br/><br/>def ao(price, period1, period2):<br/>    median = price.rolling(2).median()<br/>    short = sma(median, period1)<br/>    long = sma(median, period2)<br/>    ao = short - long<br/>    ao_df = pd.DataFrame(ao).rename(columns = {'Close':'ao'})<br/>    return ao_df<br/><br/>btc['ao'] = ao(btc['Close'], 5, 34)<br/>btc = btc.dropna()<br/>print(btc.tail())<br/><br/>ax1 = plt.subplot2grid((10,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((10,1), (6,0), rowspan = 4, colspan = 1)<br/>ax1.plot(btc['Close'])<br/>ax1.set_title('BITCOIN CLOSING PRICE')<br/>for i in range(len(btc)):<br/>    if btc['ao'][i-1] &gt; btc['ao'][i]:<br/>        ax2.bar(btc.index[i], btc['ao'][i], color = '#f44336')<br/>    else:<br/>        ax2.bar(btc.index[i], btc['ao'][i], color = '#26a69a')<br/>ax2.set_title('BITCOIN AWESOME OSCILLATOR 5,34')<br/>plt.show()<br/><br/>def implement_ao_crossover(price, ao):<br/>    buy_price = []<br/>    sell_price = []<br/>    ao_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(ao)):<br/>        if ao[i] &gt; 0 and ao[i-1] &lt; 0:<br/>            if signal != 1:<br/>                buy_price.append(price[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                ao_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                ao_signal.append(0)<br/>        elif ao[i] &lt; 0 and ao[i-1] &gt; 0:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(price[i])<br/>                signal = -1<br/>                ao_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                ao_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            ao_signal.append(0)<br/>    return buy_price, sell_price, ao_signal<br/><br/>buy_price, sell_price, ao_signal = implement_ao_crossover(btc['Close'], btc['ao'])<br/><br/>ax1 = plt.subplot2grid((10,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((10,1), (6,0), rowspan = 4, colspan = 1)<br/>ax1.plot(btc['Close'], label = 'BTC', color = 'skyblue')<br/>ax1.plot(btc.index, buy_price, marker = '^', markersize = 12, color = '#26a69a', linewidth = 0, label = 'BUY SIGNAL')<br/>ax1.plot(btc.index, sell_price, marker = 'v', markersize = 12, color = '#f44336', linewidth = 0, label = 'SELL SIGNAL')<br/>ax1.legend()<br/>ax1.set_title('BITCOIN CLOSING PRICE')<br/>for i in range(len(btc)):<br/>    if btc['ao'][i-1] &gt; btc['ao'][i]:<br/>        ax2.bar(btc.index[i], btc['ao'][i], color = '#f44336')<br/>    else:<br/>        ax2.bar(btc.index[i], btc['ao'][i], color = '#26a69a')<br/>ax2.set_title('BITCOIN AWESOME OSCILLATOR 5,34')<br/>plt.show()<br/><br/>position = []<br/>for i in range(len(ao_signal)):<br/>    if ao_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(btc['Close'])):<br/>    if ao_signal[i] == 1:<br/>        position[i] = 1<br/>    elif ao_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>ao = btc['ao']<br/>close_price = btc['Close']<br/>ao_signal = pd.DataFrame(ao_signal).rename(columns = {0:'ao_signal'}).set_index(btc.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'ao_position'}).set_index(btc.index)<br/><br/>frames = [close_price, ao, ao_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>print(strategy)<br/>print(strategy[20:25])<br/><br/>btc_ret = pd.DataFrame(np.diff(btc['Close'])).rename(columns = {0:'returns'})<br/>ao_strategy_ret = []<br/><br/>for i in range(len(btc_ret)):<br/>    returns = btc_ret['returns'][i]*strategy['ao_position'][i]<br/>    ao_strategy_ret.append(returns)<br/>    <br/>ao_strategy_ret_df = pd.DataFrame(ao_strategy_ret).rename(columns = {0:'ao_returns'})<br/>investment_value = 200000<br/>number_of_stocks = floor(investment_value/btc['Close'][-1])<br/>ao_investment_ret = []<br/><br/>for i in range(len(ao_strategy_ret_df['ao_returns'])):<br/>    returns = number_of_stocks*ao_strategy_ret_df['ao_returns'][i]<br/>    ao_investment_ret.append(returns)<br/><br/>ao_investment_ret_df = pd.DataFrame(ao_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(ao_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = round((total_investment_ret/investment_value)*100, 2)<br/>print(cl('Profit gained from the AO strategy by investing $200k in BTC : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the AO strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre></div></div>    
</body>
</html>