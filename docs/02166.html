<html>
<head>
<title>The true cost of ConfigureAwait(false) in application-facing code.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向应用程序的代码中configurewait(false)的真实开销。</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-true-cost-of-configureawait-false-in-application-facing-code-35f668fef292?source=collection_archive---------3-----------------------#2021-07-05">https://medium.com/codex/the-true-cost-of-configureawait-false-in-application-facing-code-35f668fef292?source=collection_archive---------3-----------------------#2021-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b0dd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用configurewait(false)并不是提高WPF应用程序性能的好方法。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3703628cf77a97a46f8d7916db7149ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9czXkABwYyPwauLv"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@wocintechchat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜@ wocintechchat.com</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3a08" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">过去一年我一直在开发一个WPF应用程序，最近，我开始注意到一个有趣的函数<code class="du kk kl km kn b">ConfigureAwait(false)</code>出现在异步函数调用中。有人告诉我这是为了提高应用程序的性能，所以我想我应该更深入地研究一下这个简单的函数调用究竟是如何提高性能的。在所有有趣的阅读深入到像<code class="du kk kl km kn b">SynchronizationContext</code>这样的概念和<code class="du kk kl km kn b">async/await</code>如何在幕后工作之后，我得出的结论是<code class="du kk kl km kn b">ConfigureAwait(false)</code>不仅是不必要的，而且在面向应用的代码中是危险的。在这篇文章中，我解释了为什么…</p><blockquote class="ko"><p id="dbc8" class="kp kq hi bd kr ks kt ku kv kw kx kj dx translated"><code class="du kk kl km kn b">ConfigureAwait(false)</code>在面向应用的代码中不仅是不必要的，而且是危险的。</p></blockquote><h1 id="1903" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">同步上下文</h1><p id="357f" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">在我们进入讨论的实质之前，重要的是我们要探索一个对异步编程至关重要的构造。Net，一个叫做<code class="du kk kl km kn b">SynchronizationContext</code>的类。简单地说，<code class="du kk kl km kn b">SychronizationContext</code>代表代码可能运行的位置。它通过公开一个接受委托运行的<code class="du kk kl km kn b">Post</code>方法来做到这一点。</p><p id="0ef2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在异步编程中，当我们将一个工作单元委托给另一个线程时，我们将剩余的代码捕获为一个延续块。这样做是为了如果我们需要控制延续块在哪里运行，我们可以使用<code class="du kk kl km kn b">SynchronizationContext</code>到<code class="du kk kl km kn b">Post</code>延续块到我们希望它运行的任何位置。UI框架经常创建自己版本的<code class="du kk kl km kn b">SynchronizationContext</code>来覆盖<code class="du kk kl km kn b">Post</code>方法。这使得它们能够确保需要在特定线程上运行的特定代码在该特定线程上运行。WPF实现了一个<code class="du kk kl km kn b">DispatcherSychronizationContext</code>，它覆盖了<code class="du kk kl km kn b">Post</code>方法来调用<code class="du kk kl km kn b">Dispatcher.BeginInvoke</code>来运行延续块。这确保了在UI线程上开始的代码在UI线程上继续。</p><h1 id="5925" class="ky kz hi bd la lb lc ld le lf lg lh li io lv ip lk ir lw is lm iu lx iv lo lp bi translated">Async/Await和SychronizationContext</h1><p id="86ae" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">我们需要理解的另一个重要概念是<code class="du kk kl km kn b">async/await</code>以及它与<code class="du kk kl km kn b">SychronizationContext</code>的关系。简单地说，<code class="du kk kl km kn b">async/await</code>提供了异步编程的抽象，允许你写异步代码，读起来像普通的同步代码。这是通过将在<code class="du kk kl km kn b">await</code>关键字之后运行的代码注册为由<code class="du kk kl km kn b">await</code>语句返回的<code class="du kk kl km kn b">Task</code>对象的延续来实现的。也就是说，在异步程序中，当我们将一个工作单元委托给另一个线程时，我们首先通过将当前环境存储在<code class="du kk kl km kn b">SycnhronizationContext</code>的一个实例中并将其放在<code class="du kk kl km kn b">Task</code>对象上来捕获它。在运行延续块之前，我们首先检查是否有与<code class="du kk kl km kn b">Task</code>相关联的同步上下文。然后我们使用<code class="du kk kl km kn b">SynchronizationContext</code>的<code class="du kk kl km kn b">Post</code>方法运行continuation，如果它存在，或者在异步代码被处理的位置运行它。默认情况下，线程池中的线程有一个为<code class="du kk kl km kn b">null</code>的<code class="du kk kl km kn b">SychronizationContext</code>，UI线程有一个被设置为<code class="du kk kl km kn b">SynchronizationContext</code>类的某个实现的<code class="du kk kl km kn b">SynchronizationContext</code>。这是因为UI线程通常是唯一被允许操作UI的线程。因此，任何操纵它的代码都需要在UI线程上运行。在UI线程上设置<code class="du kk kl km kn b">SynchronizationContext</code>使我们能够从任何其他线程中为UI线程编写<code class="du kk kl km kn b">Post</code>代码。如果只能在UI线程上运行的代码在不同的线程上运行，则会抛出异常<code class="du kk kl km kn b">System.InvalidOperationException: 'The calling thread cannot access this object because a different thread owns it.'</code>。</p><p id="98c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我在<a class="ae jn" href="https://hamidmosalla.com/2018/06/24/what-is-synchronizationcontext/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中找到了关于<code class="du kk kl km kn b">SynchronizationContext</code>和<code class="du kk kl km kn b">asyc/await</code>如何联系的最佳解释。它提供了异步编程如何在C#中工作的一个简化版本，而没有像<code class="du kk kl km kn b">async/await</code>那样的语法糖。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h2 id="7e08" class="ma kz hi bd la mb mc md le me mf mg li jx mh mi lk kb mj mk lm kf ml mm lo mn bi translated">什么是ConfigureAwait？</h2><p id="7f6d" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">在不深入细节的情况下，<code class="du kk kl km kn b">ConfigureAwait(continueOnCapturedContext: false)</code>是一个用结构<code class="du kk kl km kn b">ConfigureTaskAwaitable</code>和为<code class="du kk kl km kn b">continueOnCapturedContext</code>传递的布尔值包装等待的<code class="du kk kl km kn b">Task</code>对象的方法。这意味着不是在原始的<code class="du kk kl km kn b">Task</code>对象上调用<code class="du kk kl km kn b">Task.GetAwaiter</code>(<code class="du kk kl km kn b">async/await</code>模式的一部分)，而是在包装对象上调用<code class="du kk kl km kn b">GetAwaiter</code>方法。这提供了一种方法来改变awaiter如何注册<code class="du kk kl km kn b">Task</code>对象的延续块的默认行为。下面显示了上述代码如何被一个<code class="du kk kl km kn b">if</code>语句包装的简化版本，该语句使用传递给<code class="du kk kl km kn b">ConfigureAwait</code>的<code class="du kk kl km kn b">continueOnCapturedContext</code>参数进行评估。这意味着通过使用<code class="du kk kl km kn b">ConfigureAwait(false)</code>，延续块在处理异步代码的线程上运行，而不管是否有捕获的<code class="du kk kl km kn b">SynchronizationContext</code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div></figure></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><h1 id="48a6" class="ky kz hi bd la lb mv ld le lf mw lh li io mx ip lk ir my is lm iu mz iv lo lp bi translated">configurewait(false)如何提高性能？</h1><p id="8bf0" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">在他的优秀文章回答关于<code class="du kk kl km kn b">ConfigureAwait</code>的常见问题中，斯蒂芬解释说<code class="du kk kl km kn b">ConfigureAwait(false)</code>可以通过两种方式提高性能。如果上面的<code class="du kk kl km kn b">RestOfMethod</code>方法中的代码不需要在UI线程上运行，那么…</p><ol class=""><li id="2afb" class="na nb hi jq b jr js ju jv jx nc kb nd kf ne kj nf ng nh ni bi translated">使用<code class="du kk kl km kn b">Post</code>方法可以节省注册回调的成本。这是因为注册回调比简单地调用它成本更高。</li><li id="268d" class="na nb hi jq b jr nj ju nk jx nl kb nm kf nn kj nf ng nh ni bi translated">我们可以对<code class="du kk kl km kn b">RestOfMethod</code>的运行方式进行运行时优化，因为它是被直接调用的，而不是被注册为回调。如果<code class="du kk kl km kn b">RestOfMethod</code>的运行是由某个任意抽象的实现来处理的，那么应用运行时优化是很困难的。当我们确切知道回调将如何被调用时，可以做更多的优化。</li></ol><p id="e1da" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一种节省性能的方法是，如果<code class="du kk kl km kn b">RestOfMethod</code>包含一些长时间运行的阻塞代码，我怀疑这是大多数人使用它的原因。考虑下面包含<code class="du kk kl km kn b">SomeLongRunningBlockingMethod</code>的<code class="du kk kl km kn b">RestOfMethod</code>的实现。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="f9c2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果<code class="du kk kl km kn b">RestOfMethod</code>不需要在UI线程上运行，那么UI线程会在<code class="du kk kl km kn b">SomeLongRunningBlockingMethod</code>的持续时间内被不必要地阻塞，从而导致应用程序感觉“缓慢”和用户体验不佳。</p><h1 id="3094" class="ky kz hi bd la lb lc ld le lf lg lh li io lv ip lk ir lw is lm iu lx iv lo lp bi translated"><strong class="ak">那么configurewait(false)有什么问题呢？</strong></h1><p id="92fb" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">在像WPF这样的UI框架中使用<code class="du kk kl km kn b">ConfigureAwait(false)</code>的主要问题是，它违反了软件开发的基本原则之一；接吻(简单点，傻逼)。当编写应用程序时，尤其是使用框架时，通常希望保持默认行为(这就是为什么它是默认行为)。偏离默认行为可能会产生意想不到的副作用，最终导致可能比您最初打算解决的问题代价更高的问题。在<code class="du kk kl km kn b">ConfigureAwait(false)</code>的例子中，这里有一个到目前为止我看到的问题列表。</p><h2 id="adfe" class="ma kz hi bd la mb mc md le me mf mg li jx mh mi lk kb mj mk lm kf ml mm lo mn bi translated">它不一定做你可能认为它做的事情。</h2><p id="408e" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">也许<code class="du kk kl km kn b">ConfigureAwait(false)</code>最狡猾的地方在于，它不一定保证<code class="du kk kl km kn b">await</code>关键字之后的代码不会在最初捕获的上下文中运行。考虑下面<code class="du kk kl km kn b">SomethingAsync</code>的实现。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="b81f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">尽管在一个等待的任务上使用<code class="du kk kl km kn b">ConfigureAwait(false)</code>保证了延续不会排队回到原始上下文中，但这并不能保证延续不会在原始上下文中运行。在一个已经完成的any上调用<code class="du kk kl km kn b">await</code>会导致代码在<code class="du kk kl km kn b">await</code>之后同步运行，而不会强制任何东西在任何上下文中排队。这意味着通过以上<code class="du kk kl km kn b">SomethingAsync</code>的实现，<code class="du kk kl km kn b">RestOfMethod</code>以及<code class="du kk kl km kn b">SomeLongRunningBlockingMethod</code>将在UI线程上运行。抓住你了。</p><h2 id="fa5d" class="ma kz hi bd la mb mc md le me mf mg li jx mh mi lk kb mj mk lm kf ml mm lo mn bi translated">这使得代码僵化而脆弱</h2><p id="c9a6" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">下一个关于<code class="du kk kl km kn b">ConfigureAwait(false)</code>的问题来自于大多数人首先使用它的原因。上面的讨论已经非常清楚地表明了这样一个事实:当且仅当<code class="du kk kl km kn b">RestOfMethod</code>不需要在UI线程上运行时，<code class="du kk kl km kn b">ConfigureAwait(false)</code>才会工作。这给了开发人员额外的脑力任务，即跟踪哪个线程<code class="du kk kl km kn b">RestOfMethod</code>需要运行。应用程序逻辑的简单改变可以导致在<code class="du kk kl km kn b">RestOfMethod</code>中发生一些UI操作，或者甚至在由<code class="du kk kl km kn b">RestOfMethod</code>调用的方法调用的方法中发生(深度嵌套的函数调用并不少见)。这迫使开发人员要么通过强制执行一条规则来使代码变得僵化，这条规则是:“<em class="no">任何UI操作代码都不应放在</em> <code class="du kk kl km kn b"><em class="no">RestOfMethod</em></code> <em class="no">中”，要么通过让开发人员决定<code class="du kk kl km kn b">RestOfMethod</code>中的某段代码是否需要在UI线程中运行来使代码变得脆弱，如果需要，则移除<code class="du kk kl km kn b">ConfigureAwait(false)</code>或找到另一种变通方法。这是一个很大的额外的精神负担，当我们可以遵循KISS设计原则并使用默认行为时，这很可能会导致错误和UI损坏！</em></p><h2 id="dd35" class="ma kz hi bd la mb mc md le me mf mg li jx mh mi lk kb mj mk lm kf ml mm lo mn bi translated">有一个更好的方法来解决你的性能问题</h2><p id="4e08" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">你可能会问自己如何用运行<code class="du kk kl km kn b">SomeLongRunningBlockingMethod</code>的UI线程解决上面的问题，那么使用<code class="du kk kl km kn b">ConfigureAwait(false)</code>是不是一个坏主意。还好，<code class="du kk kl km kn b">Task</code> API为这个问题提供了一个简单的解决方案。考虑下面<code class="du kk kl km kn b">RestOfMethod</code>的实现。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="0aa2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个实现使用静态方法<code class="du kk kl km kn b">Task.run</code>在线程池中运行<code class="du kk kl km kn b">SomeLongRunningBlockingMethod</code>。如果需要的话，甚至可以通过简单地将<code class="du kk kl km kn b">RestOfMethod</code>转换为<code class="du kk kl km kn b">RestOfMethodAsync</code>来等待<code class="du kk kl km kn b">SomeLongRunningBlockingMethod</code>的返回值。我认为这个解决方案更清楚地说明了代码的意图，以及在不脱离默认实现<code class="du kk kl km kn b">async/await</code>的情况下应该在哪里运行。</p><h1 id="aa17" class="ky kz hi bd la lb lc ld le lf lg lh li io lv ip lk ir lw is lm iu lx iv lo lp bi translated">结论</h1><blockquote class="ko"><p id="5a5b" class="kp kq hi bd kr ks kt ku kv kw kx kj dx translated">如果你正在编写应用级代码，不要使用<code class="du kk kl km kn b">ConfigureAwait(false)</code>。</p></blockquote><p id="f9e7" class="pw-post-body-paragraph jo jp hi jq b jr np ij jt ju nq im jw jx nr jz ka kb ns kd ke kf nt kh ki kj hb bi translated">我理解提高应用程序性能的需要，但我不认为使用<code class="du kk kl km kn b">ConfigureAwait(false)</code>是这样做的正确方法。它引入了不必要的精神负担和可能破坏用户界面的潜在陷阱。此外，它要解决的问题可以很容易地解决，而不需要脱离<code class="du kk kl km kn b">async/await</code>的默认行为，即一旦<code class="du kk kl km kn b">Task</code>完成，就将控制返回给调用线程。我认为Stephen在他的文章中说的很对，他说<strong class="jq hj">如果你正在编写应用程序级代码，那么<em class="no">不要使用</em></strong> <code class="du kk kl km kn b">ConfigureAwait(false)</code>。</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><p id="7a52" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你觉得<code class="du kk kl km kn b">ConfigureAwait(false)</code>怎么样？请随时与我进一步讨论这个话题。我很乐意接受更多这方面的教育😅</p></div></div>    
</body>
</html>