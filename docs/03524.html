<html>
<head>
<title>Git and GitHub In One Go!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git和GitHub一气呵成！</h1>
<blockquote>原文：<a href="https://medium.com/codex/all-you-need-to-know-about-git-and-github-5bc7276094b8?source=collection_archive---------10-----------------------#2021-09-07">https://medium.com/codex/all-you-need-to-know-about-git-and-github-5bc7276094b8?source=collection_archive---------10-----------------------#2021-09-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1a36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章将帮助你如何在你的项目中使用Git &amp; GitHub，有助于开源，没有先决条件。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/03539003856652cb18b42fbddc85b5ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sxTyGS_co8BU_2l9tY4yAg.png"/></div></div></figure><p id="b26b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从Git &amp; GitHub的基础知识开始，涵盖所有基本命令，包括分支、拉请求、分叉等概念。我们还将涵盖其他概念，如挤压、解决合并冲突、保持代码同步等等。</p><p id="51af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你已经有了GitHub的账号。如果没有，请创建一个。</p><p id="7c41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们开始吧！</strong></p><p id="f12e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">下载git </strong></p><p id="047f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请参考下面的链接，该链接详细介绍了如何在多个操作系统中安装Git:<br/><a class="ae jp" href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">https://Git-SCM . com/book/en/v2/Getting-Started-Installing-Git</strong></a></p><p id="6516" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要验证是否安装了Git，请在命令提示符下使用下面的命令:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="78f4" class="jv jw hi jr b fi jx jy l jz ka">$ <!-- -->git --version</span></pre><p id="48a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一次在系统中使用git时，使用以下命令设置全局配置:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="fbe1" class="jv jw hi jr b fi jx jy l jz ka">$ git config —-global user.name “[firstname lastname]”<br/>$ git config --global user.email “[valid-email]”</span></pre><p id="e5b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为您的项目创建一个文件夹。让我们将项目文件夹称为GitPractice。我用的是git bash，所有的命令都可以用。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="1512" class="jv jw hi jr b fi jx jy l jz ka">$ mkdir GitPractice // Create a file<br/>$ cd GitPractice // Change directory</span></pre><p id="587c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我目前在GitPractice目录/文件夹中。</p><p id="9691" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.<strong class="ih hj"> git init </strong>命令将本地git存储库添加到项目中。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="8a72" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git init // Initialises an existing directory as Git repository(local repository)</span><span id="58e3" class="jv jw hi jr b fi kb jy l jz ka">GitPractice$ ls -a // Shows hidden files (starting with .files)</span><span id="3ff9" class="jv jw hi jr b fi kb jy l jz ka">GitPractice$ ls .git //shows git files</span></pre><p id="e26f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.现在让我们添加一些小代码。</p><p id="c7fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在GitPractice文件夹中创建一个名为gitdemo.txt的文件。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="d968" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ touch gitdemo.txt //touch command creates files</span></pre><p id="c62c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于本文的主要焦点是Git，而不是任何特定的编程语言，为了使事情更简单，我们将用纯文本而不是实际代码进行演示。</p><p id="39f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.准备和提交代码。</p><p id="e808" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提交</strong>是将代码添加到本地存储库的过程。在提交之前，代码必须在临时区域中。</p><p id="75c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">暂存区</strong>跟踪所有要提交的文件。</p><p id="5b2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何未添加到临时区域的文件都不会被提交。这使得开发人员可以控制哪些文件需要提交。</p><p id="b219" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">分段——使用git添加命令</strong></p><p id="ee4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将gitdemo.txt添加到临时区域，然后提交它。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="0341" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git add gitdemo.txt //gitdemo.txt is now added to the staging area</span></pre><p id="5dd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果要将项目文件夹中的所有文件添加到临时区域，请使用以下命令:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="da9f" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git add .</span></pre><p id="c98e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想将多个文件添加到临时区域，</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="d2de" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git add file1 file2 file3</span></pre><p id="1f7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提交—使用git提交命令</strong></p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="024e" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git commit -m "added gitdemo.txt"</span></pre><p id="fba5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“added gitdemo.txt”是这里的提交消息。输入相关的提交消息，以指示在此特定提交中进行了哪些代码更改。</p><p id="1585" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> git stash </strong></p><p id="63fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">git add命令将文件添加到临时区域，然后使用git commit命令提交文件。有时，如果我们想从暂存区移除文件或变更，我们使用<strong class="ih hj"> git stash </strong>命令。</p><p id="9a49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设登台区是一个舞台。有时，当文件在暂存区域时，我们不想提交它们。在这种情况下，我们可以使用<strong class="ih hj"> git stash </strong>命令从暂存区中删除文件。(认为stage中的文件将被移到后台)。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="26ea" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git stash //files not committed will be removed from the staging area.</span></pre><p id="fb58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时，您需要后台的那些文件:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="5cbe" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git stash pop //backstage to staging area</span></pre><p id="73c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时候，你需要从后台删除这些文件:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="fa33" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git stash clear //remove from backstage</span></pre><p id="0d46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，通过添加一些内容来修改文件<strong class="ih hj"> gitdemo.txt </strong>:</p><p id="32ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(假设我将下面的内容添加到gitdemo.txt中)</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="2729" class="jv jw hi jr b fi jx jy l jz ka">GitHub...yep, that's it.</span></pre><h1 id="ac80" class="kc jw hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Git状态和Git日志</h1><h2 id="47e1" class="jv jw hi bd kd kz la lb kh lc ld le kl iq lf lg kp iu lh li kt iy lj lk kx ll bi translated">状态</h2><p id="30cd" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">使用git status命令找出关于修改了哪些文件以及暂存区中有哪些文件的信息——它还显示了其他信息，我们现在可以忽略这些信息。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="567a" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git status</span></pre><p id="0f74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">状态显示<strong class="ih hj"> gitdemo.txt </strong>被修改，还不在暂存区。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="7cd4" class="jv jw hi jr b fi jx jy l jz ka">Changes not staged for commit:</span><span id="d9b4" class="jv jw hi jr b fi kb jy l jz ka">(use “git add &lt;file&gt;…” to update what will be committed)</span><span id="cae3" class="jv jw hi jr b fi kb jy l jz ka">(use “git restore &lt;file&gt;…” to discard changes in working directory)</span><span id="ddcc" class="jv jw hi jr b fi kb jy l jz ka">modified: gitdemo.txt</span><span id="89d9" class="jv jw hi jr b fi kb jy l jz ka">no changes added to commit (use “git add” and/or “git commit -a”)</span></pre><p id="6d28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们将<strong class="ih hj"> gitdemo.txt </strong>添加到暂存区，并使用以下命令提交它:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="384b" class="jv jw hi jr b fi jx jy l jz ka">git add gitdemo.txt git commit -m "gitdemo.txt file modified"</span></pre><p id="1e87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以像以前一样，用一个命令或分别添加和提交更改。</p><h1 id="d19b" class="kc jw hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">原木</h1><p id="1227" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">使用git log命令打印出所有已经完成的提交。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="379b" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git log</span></pre><p id="3da2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该日志显示了每次提交的作者、提交日期和提交消息。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="45b8" class="jv jw hi jr b fi jx jy l jz ka">commit 593f2aa80f7410b0c24154e9d0b7831c3ebabd7c (<strong class="jr hj">HEAD -&gt; feature2</strong>, <strong class="jr hj">origin/feature2</strong>, <strong class="jr hj">feature</strong>)</span><span id="d512" class="jv jw hi jr b fi kb jy l jz ka">Date:   Mon Aug 2 09:40:56 2021 +0530</span><span id="677e" class="jv jw hi jr b fi kb jy l jz ka">modified names.txt file</span><span id="bf84" class="jv jw hi jr b fi kb jy l jz ka">commit 08f04ab5b07e8262ca8671e0cf1ce1170c3c3543 (<strong class="jr hj">origin/feature</strong>, <strong class="jr hj">master</strong>)</span><span id="fa76" class="jv jw hi jr b fi kb jy l jz ka">Date:   Mon Aug 2 09:38:21 2021 +0530</span><span id="731d" class="jv jw hi jr b fi kb jy l jz ka">file added</span></pre><p id="3a68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个提交都建立在其他提交的基础上。而且，每个提交都有一个唯一的散列ID。</p><p id="9499" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设有3个提交c1、c2和c3。要删除提交，请使用reset命令。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="dd58" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git reset &lt;hashid_c3&gt; //removes all commits above c3 (c1 and c2 are removed)</span><span id="1adb" class="jv jw hi jr b fi kb jy l jz ka">GitPractice$ git commit</span></pre><h1 id="893e" class="kc jw hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">分支</h1><p id="8135" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">默认情况下，Git提交进入<strong class="ih hj">主</strong>分支。</p><h2 id="45ac" class="jv jw hi bd kd kz la lb kh lc ld le kl iq lf lg kp iu lh li kt iy lj lk kx ll bi translated">什么是分支？</h2><p id="c992" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">分支只不过是指向Git存储库中最新提交的指针。所以目前我们的主分支是指向第二次提交“gitdemo.txt文件修改”的指针。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="e337" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git branch new_feature //created a new branch named new_feature</span></pre><h2 id="eab2" class="jv jw hi bd kd kz la lb kh lc ld le kl iq lf lg kp iu lh li kt iy lj lk kx ll bi translated">为什么需要多个分支？</h2><p id="dd2d" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">需要多个分支来支持并行开发。</p><p id="5d50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，main是所有人使用的代码。如果一个人把有bug的代码推到主页面，也会影响到其他用户。所以，最好创建一个新的分支。</p><p id="26f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">头(指针)最初指向主体。(master被重命名为main)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lr"><img src="../Images/e35243fa3804044c156997f834e64126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9hlfstyYgmEA84bDGqAtjQ.png"/></div></div></figure><p id="fafe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个分支后，要将头切换到new_feature分支，请检出new_feature分支。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="4189" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git checkout new_feature</span></pre><p id="49c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">头指向new_feature分支。当head指向new_feature分支时，提交将被添加到new_feature分支。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="dd5c" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git branch //lists out all branches in local</span></pre><h2 id="31e9" class="jv jw hi bd kd kz la lb kh lc ld le kl iq lf lg kp iu lh li kt iy lj lk kx ll bi translated">在新分支中执行一些提交</h2><p id="78a1" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">通过添加以下代码片段来修改gitdemo.txt:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="b049" class="jv jw hi jr b fi jx jy l jz ka">new branch created...</span></pre><p id="3c00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，使用一个命令准备并提交:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="da1c" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git commit -am "new Branch Commit"</span></pre><p id="f27e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该提交是在新特征分支中完成的，现在新特征分支比主分支领先1个提交，因为新特征分支还包括来自主分支的2个提交。</p><p id="569b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住，永远不要在main上提交，创建自己的分支。</p><p id="b685" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用以下命令验证测试分支中的提交历史记录:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="715b" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git log</span></pre><h1 id="9c43" class="kc jw hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">合并</h1><p id="3733" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">目前，new_feature分支领先于主分支1个提交。假设现在我们想要合并new_feature分支中的所有代码，并将其带回主分支。</p><p id="79db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先回到主分支:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="9a47" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git checkout master</span></pre><p id="6995" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后使用合并命令:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="d1b2" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git merge new_feature</span></pre><p id="9fec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，合并应该成功了。在本例中，没有冲突。</p><p id="a36c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是在实际的项目中，当合并正在进行时会有冲突。</p><p id="ab90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">冲突是手动解决的。解决冲突是需要经验的，所以随着你更多地使用Git，你将能够找到解决冲突的窍门。</p><p id="7f08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在运行git log，您会注意到master也有3次提交。</p><h1 id="b3b7" class="kc jw hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak"> GitHub远程仓库</strong></h1><p id="1c71" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">创建一个存储库并从GitHub获取url。</p><p id="aea6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以便将所有代码从本地存储库推送到远程存储库。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="fe2b" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git remote add origin [repository url]</span><span id="ea49" class="jv jw hi jr b fi kb jy l jz ka">GitPractice$ <!-- -->git remote remove origin //remove remote</span></pre><h1 id="6b28" class="kc jw hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak"> Git推送</strong></h1><p id="f2e0" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">为了将所有代码从本地存储库推送到主分支远程存储库，使用git push命令。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="c9ab" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git push -u origin master //head points on master</span></pre><p id="290e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Git已经移除了对密码认证的支持，所以我们需要使用个人访问令牌。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="60bb" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- --> <br/>git push https://$(git_token)@github.com/user_name/repo_name</span></pre><h1 id="64a4" class="kc jw hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak"> Git Pull </strong></h1><p id="ee66" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">要将最新的变更从远程存储库拉入本地存储库，可以使用git pull命令。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="25d6" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git pull origin master</span></pre><h2 id="2145" class="jv jw hi bd kd kz la lb kh lc ld le kl iq lf lg kp iu lh li kt iy lj lk kx ll bi translated">Git克隆</h2><p id="0710" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">要将现有的远程存储库克隆到您的计算机中，请使用git clone命令。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="3765" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git clone [repository url]</span></pre><h1 id="6d3a" class="kc jw hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">重设基础</strong></h1><p id="85f5" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">要返回一次提交，请使用rebase命令。</p><h1 id="3264" class="kc jw hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">在推送到Git之前组合多个提交</strong></h1><p id="bd98" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">如果您有很多提交，而您只想压缩最后的X个提交，那么找到您想要开始压缩的提交的提交ID。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="2d32" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git rebase -i &lt;commit_hash_id&gt;</span></pre><p id="4ca1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设有四个提交，c1、c2、c3、c4，c1位于所有提交的顶部。因此，给定上面命令中的c1 hashid，c2、c3、c4提交将合并为c1提交(使用git log命令查看所有提交)。</p><p id="bd32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种方法:</p><p id="92f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Git中的squash意味着将多个提交合并成一个。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="6df1" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git rebase -i commithashid</span></pre><p id="5b58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将打开您的文本编辑器(<code class="du ls lt lu jr b">-i</code>代表“交互式”)和一个如下所示的文件:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="a989" class="jv jw hi jr b fi jx jy l jz ka">pick 16b5fcc Code in, tests not passing<br/>pick c964dea Getting closer<br/>pick 06cf8ee Something changed<br/>pick 396b4a3 Tests pass<br/>pick 9be7fdb Better comments<br/>pick 7dba9cb All done</span></pre><p id="d9d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将所有的<code class="du ls lt lu jr b">pick</code>更改为<code class="du ls lt lu jr b">squash</code>(或<code class="du ls lt lu jr b">s</code>)，将所有提交的提交消息合并成一个大的提交消息:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="2469" class="jv jw hi jr b fi jx jy l jz ka">pick 16b5fcc Code in, tests not passing<br/>squash c964dea Getting closer<br/>squash 06cf8ee Something changed<br/>pick 396b4a3 Tests pass<br/>squash 9be7fdb Better comments<br/>squash 7dba9cb All done</span></pre><p id="a93e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建了两个大的提交。提交<code class="du ls lt lu jr b">c964dea</code>和<code class="du ls lt lu jr b">06cf8ee</code>合并为<code class="du ls lt lu jr b">16b5fcc</code>，<code class="du ls lt lu jr b">9be7fdb</code>和<code class="du ls lt lu jr b">7dba9cb</code>合并为<code class="du ls lt lu jr b">396b4a3</code>。</p><h1 id="3805" class="kc jw hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">分叉</strong></h1><p id="2c9b" class="pw-post-body-paragraph if ig hi ih b ii lm ik il im ln io ip iq lo is it iu lp iw ix iy lq ja jb jc hb bi translated">这对于开源贡献是有用的。</p><p id="f7c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GitHub fork是一个存储库的副本，它位于您的帐户中，而不是您获取数据的帐户。一旦您分叉了一个存储库，您就拥有了您的分叉副本，并且您可以编辑分叉存储库的内容，而不会影响父存储库。</p><p id="2e6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">来源</strong> —指您自己的网址</p><p id="0dfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">上游</strong> —指分叉所有者url(从它分叉的地方)。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="dd4f" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git remote add upstream [repository url]</span></pre><p id="8025" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">吉特拉</strong></p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="adf1" class="jv jw hi jr b fi jx jy l jz ka">git pull origin master</span></pre><p id="1750" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您已经进行了更改，并且希望避免添加新的合并提交，请使用git pull — rebase。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="0c62" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git pull — rebase origin master</span></pre><p id="0451" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">git pull——rebase</strong>将会工作，即使你没有做任何改变，这可能是你最好的选择。</p><p id="3059" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Git推送</strong></p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="a7ca" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ <!-- -->git push -u upstream master //fails to push as you don't have the owner access.</span></pre><p id="86e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，您将无权推送至上游URL/存储库。</p><p id="6e5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，首先将代码推送到您的本地存储库。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="4688" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git push origin branch_name</span></pre><p id="24ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您正在推送至现有分支，请使用强制推送。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="2a0a" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git push origin branch_name -f</span></pre><p id="d7ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要推送到上游，请创建一个拉取请求。(你会在GitHub的分叉库上找到这个按钮)</p><p id="1c9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上游url的所有者将审查和合并拉请求(PR)。</p><p id="3076" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一个分支已经有一个相关联的拉请求，则不允许另一个拉请求。在这种情况下，创建另一个分支并发出一个拉请求。</p><p id="573e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了确保工作是分布式的，gitHub添加了这个约束。</p><p id="9bdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，一个分支，一个拉请求。</p><p id="3b4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果上游得到更新，我们的远程分叉存储库将不会自动更新。在我们的远程存储库中，将有按钮<strong class="ih hj">“获取上游”</strong>来更新。</p><p id="558b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种方法是，</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="ec1d" class="jv jw hi jr b fi jx jy l jz ka">GitPractice$ git fetch --all --prune (local files will be updated as the upstream remote)</span></pre><p id="9c84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">删除标签</strong> —在获取之前，删除任何不再存在于遥控器上的远程跟踪引用。</p><p id="072d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更多命令请参考<a class="ae jp" href="https://github.com/priyasdamodharan/CheatSheet/blob/main/git-cheat-sheet-education.pdf" rel="noopener ugc nofollow" target="_blank"> Git备忘单</a>。</p><p id="ee05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在您已经知道了如何使用Git的基本知识，继续探索更多吧！</p><p id="57f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="lv">希望有帮助:)</em> </strong></p><p id="c26c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢，</p><p id="c74a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">普丽娅。</p></div></div>    
</body>
</html>