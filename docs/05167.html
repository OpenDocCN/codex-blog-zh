<html>
<head>
<title>Sargable predicates and NULLs in SQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL Server中的可搜索谓词和空值</h1>
<blockquote>原文：<a href="https://medium.com/codex/sargable-predicates-and-null-values-in-sql-server-c43ec3d8b108?source=collection_archive---------4-----------------------#2022-02-05">https://medium.com/codex/sargable-predicates-and-null-values-in-sql-server-c43ec3d8b108?source=collection_archive---------4-----------------------#2022-02-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9526" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">将不可搜索谓词转换为可搜索谓词</h2></div><p id="8cf1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我将讨论被称为可搜索性的概念，用一些关于空值的考虑来丰富它。在Itzik Ben-Gan举办的一次会议上，我有机会研究sargable谓词，这给了我灵感。</p><p id="b4d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">维基百科是这样定义<a class="ae jt" href="https://en.wikipedia.org/wiki/Sargable" rel="noopener ugc nofollow" target="_blank">可搜索性</a>的:“在关系数据库中，如果DBMS引擎可以利用索引来加速查询的执行，则查询中的条件(或谓词)被称为可搜索的。该术语是由Search ARGument ABLE的缩写而来。无法进行搜索的查询称为非搜索查询，通常会对查询时间产生负面影响，因此查询优化的一个步骤是将它们转换为搜索查询。其效果类似于在没有索引的书中搜索特定术语，每次从第一页开始，而不是跳到索引中确定的特定页面列表。”</p><p id="5b9c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为什么编写可搜索查询很重要？可以认为查询的执行时间与读取的页数成比例。对特定索引页的访问降低了读取受活动事务影响、由活动事务锁定的记录的可能性。读取的页面越少，并发性就越大！</p><p id="1ed8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑下面的查询，它从采购中提取采购订单。并返回按ExpectedDeliveryDate列升序排序的数据。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="fb34" class="kd ke hi jz b fi kf kg l kh ki">SELECT<br/>  PurchaseOrderID, ExpectedDeliveryDate<br/>FROM<br/>  Purchasing.PurchaseOrders<br/>ORDER BY<br/>  ExpectedDeliveryDate;</span></pre><p id="67fd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，将首先提取ExpectedDeliveryDate设置为NULL的行，这是T-SQL语言的一种实现选择，在这种情况下，它认为NULL小于任何日期。</p><p id="6699" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于这个查询，我们希望颠倒排序，我们希望将ExpectedDeliveryDate不等于NULL的行按升序排列，然后将Expected Delivery Date设置为NULL的行。</p><p id="29b9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们能做什么？一个可能的解决方案是在ORDER BY子句中应用CASE表达式，如以下查询所示。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="683d" class="kd ke hi jz b fi kf kg l kh ki">SELECT<br/>  PurchaseOrderID, ExpectedDeliveryDate<br/>FROM<br/>  Purchasing.PurchaseOrders<br/>ORDER BY<br/>  CASE<br/>    WHEN (ExpectedDeliveryDate IS NOT NULL) THEN 0 ELSE 1<br/>  END;</span></pre><p id="386e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该查询不是可搜索的，它对ExpectedDeliveryDate列使用IX _ Purchasing _ purchase orders _ ExpectedDeliveryDate索引，对该列执行索引扫描而不是优化索引查找。</p><p id="87d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下图显示了(非可搜索的)查询执行计划。</p><figure class="ju jv jw jx fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kj"><img src="../Images/6255321fd155c734c0e4f9cf6e3124a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJkQnepV_GFe_Qp3c0FC3A.jpeg"/></div></div></figure><p id="682b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们如何在保持排序的前提下使这个查询可搜索？</p><p id="6708" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以将查询拆分为两个查询，第一个查询将提取ExpectedDeliveryDate中值不为NULL的行，第二个查询将提取ExpectedDeliveryDate中值为NULL的行。UNION ALL子句将允许您合并数据集，随后的ORDER BY子句将应用所需的排序。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="933c" class="kd ke hi jz b fi kf kg l kh ki">SELECT<br/>  PurchaseOrderID, ExpectedDeliveryDate, SortOrder = 0<br/>FROM<br/>  Purchasing.PurchaseOrders<br/>WHERE<br/>  ExpectedDeliveryDate IS NOT NULL</span><span id="8ef8" class="kd ke hi jz b fi kr kg l kh ki">UNION ALL</span><span id="830b" class="kd ke hi jz b fi kr kg l kh ki">SELECT<br/>  PurchaseOrderID, ExpectedDeliveryDate, SortOrder = 1<br/>FROM<br/>  Purchasing.PurchaseOrders<br/>WHERE<br/>  ExpectedDeliveryDate IS NULL<br/>ORDER BY<br/>  SortOrder, ExpectedDeliveryDate;</span></pre><p id="beea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们运行该查询，我们将注意到IX _ Purchasing _ purchase orders _ ExpectedDeliveryDate索引被访问了两次，以读取特定范围的行(索引查找)。第一次访问将在ExpectedDeliveryDate中返回具有非空值的行。第二次访问将返回在ExpectedDeliveryDate列中具有NULL值的行。如下图所示，使用合并连接运算符连接这两个数据集。查询是可搜索的。</p><figure class="ju jv jw jx fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es ks"><img src="../Images/a170e813536196b07bba41dc043a7244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2N9h3w1Iv96mwq20G2792g.jpeg"/></div></div></figure><p id="67c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们希望实现一个存储过程，它能够提取具有特定交付日期的采购订单和交付日期未定义(NULL)的采购订单。以下T-SQL代码实现了采购架构中的sp_undefined_deliverydate存储过程。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="232d" class="kd ke hi jz b fi kf kg l kh ki">CREATE PROCEDURE Purchasing.sp_undefined_deliverydate<br/>(@DeliveryDate Date)<br/>AS BEGIN<br/>  SELECT<br/>    PurchaseOrderID, ExpectedDeliveryDate<br/>  FROM<br/>    Purchasing.PurchaseOrders<br/>  WHERE<br/>    ExpectedDeliveryDate = @DeliveryDate;<br/>END;</span></pre><p id="cf9b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果在@DeliveryDate参数设置为NULL的情况下执行存储过程，会发生什么情况？</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="1bd2" class="kd ke hi jz b fi kf kg l kh ki">EXEC Purchasing.sp_undefined_deliverydate @DeliveryDate = NULL;</span></pre><p id="2c72" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ANSI_NULLS选项设置为on(每个连接的默认值)时使用的比较运算符“=”将计算每个不同于任何其他空值的空值。当它计算表达式NULL = NULL(？)它将返回false。</p><p id="3c7b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">返回的数据集将为空。从性能的角度来看，该查询是可搜索的，但是必须对其进行修改以正确处理空值。你们中的一些人可能想过使用T-SQL ISNULL函数，如果遇到空值，它将返回指定的值。以下版本的存储过程使用ISNULL函数。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="6c91" class="kd ke hi jz b fi kf kg l kh ki">ALTER PROCEDURE Purchasing.sp_undefined_deliverydate<br/>(@DeliveryDate Date)<br/>AS BEGIN<br/>  SELECT<br/>    PurchaseOrderID, ExpectedDeliveryDate<br/>  FROM<br/>    Purchasing.PurchaseOrders<br/>  WHERE<br/>    ISNULL(ExpectedDeliveryDate, '99991231') = ISNULL(@DeliveryDate, '99991231');<br/>END;</span></pre><p id="46ea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当在@DeliveryDate参数设置为NULL的情况下执行存储过程时，返回的数据集是正确的，但内部查询不可搜索，如以下执行计划所示。</p><figure class="ju jv jw jx fd kk er es paragraph-image"><div class="er es kt"><img src="../Images/2157bf98098ac467eb3f1a4bb243ced1.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*mhqgk8OewUiz45mBWbUPbQ.jpeg"/></div></figure><p id="62e5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们能否通过优雅而有效的方式使查询可搜索来优化它？答案是肯定的！我们可以使用<a class="ae jt" href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/set-operators-except-and-intersect-transact-sql?WT.mc_id=DP-MVP-4029181" rel="noopener ugc nofollow" target="_blank"> T-SQL INTERSECT </a>操作符。INTERSECT返回由left和right输入查询运算符输出的不同行。顾名思义，返回输入中提供的数据集的交集。存储过程以这种方式进行修改..</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="9d60" class="kd ke hi jz b fi kf kg l kh ki">ALTER PROCEDURE Purchasing.sp_undefined_deliverydate<br/>(@DeliveryDate Date)<br/>AS BEGIN<br/>  SELECT<br/>    PurchaseOrderID, ExpectedDeliveryDate<br/>  FROM<br/>    Purchasing.PurchaseOrders<br/>  WHERE<br/>    EXISTS(SELECT ExpectedDeliveryDate<br/>           INTERSECT<br/>           SELECT @DeliveryDate);<br/>END;</span></pre><p id="8ac8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">重复存储过程的执行..</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="ce9e" class="kd ke hi jz b fi kf kg l kh ki">EXEC Purchasing.sp_undefined_deliverydate @DeliveryDate = NULL;</span></pre><p id="169b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下图所示的执行计划现在显示了应用于IX _ Purchasing _ purchase orders _ ExpectedDeliveryDate索引的索引Seek运算符，该查询是sargable！</p><figure class="ju jv jw jx fd kk er es paragraph-image"><div class="er es ku"><img src="../Images/d6804bd34ee21bc55f46f8a53d268516.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*npDIadjBdNx9V6dhRAEXaQ.jpeg"/></div></figure><h2 id="7148" class="kd ke hi bd kv kw kx ky kz la lb lc ld jg le lf lg jk lh li lj jo lk ll lm ln bi translated">摘要</h2><p id="e19f" class="pw-post-body-paragraph ix iy hi iz b ja lo ij jc jd lp im jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">查询优化过程中的一个步骤是将不可搜索的谓词转换为可搜索的谓词。空值的处理总是值得检查，特别是当使用传递给函数或存储过程的参数时。当需要相交两个数据集时，即使数据集为空，INTERSECT运算符也非常有用。</p><p id="dd26" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽情享受吧！</p></div></div>    
</body>
</html>