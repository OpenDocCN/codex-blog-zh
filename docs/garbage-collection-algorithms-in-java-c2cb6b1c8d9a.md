# Java 中的垃圾收集算法

> 原文：<https://medium.com/codex/garbage-collection-algorithms-in-java-c2cb6b1c8d9a?source=collection_archive---------10----------------------->

![](img/cba8d518970ecd3f4125b7c8d201ff49.png)

肯尼·埃利亚松在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

Java 是一种在堆中收集垃圾的语言。操作系统正在堆中为 JVM 进程分配内存。JVM 将堆分成几代。两代是永和老一代。年轻一代存储新对象，老一代存储旧对象。当对象变老时，对象从年轻一代移动到老一代。当老一代不再有足够的空间来存储对象时，垃圾收集器就会移除旧对象。

垃圾收集是一种高效的内存管理机制。移除堆中不需要的和未使用的对象，为新对象腾出内存空间。

许多垃圾收集算法是通过基于时间的内存分配矩阵来实现的。这些算法用收益和行为相互比较。下面是许多算法的特点。

减少回收内存的时间

减少浪费的内存

减少内存以执行收集

减少收集过程中的暂停时间

## 标记和扫描算法

垃圾收集算法中的基本算法。在这个过程中的某个时刻，算法会停止工作，因为内存已满。当程序停止时，算法清理空间。

这个过程从标记开始。对象有一个标记位，用于标识标记期间访问的对象。校验位可以是 0 或 1。收集器遍历所有根，更新标记位。

然后扫描步骤开始。它在内存中穿行，只保留未标记的对象。

## G1 垃圾收集器算法

G1 垃圾收集算法在具有多处理器机器的大内存上工作。该算法优于并行生成扫描算法，因为它具有更好的性能。这个算法可以在 JDK 4 和更高版本中找到。

G1 收集器将堆分成大小相等的区域。它执行垃圾收集，并在整个过程中使用并发全局标记阶段来标记对象。当标记结束时，大部分空白区域被识别。G1 收集器首先扫描那些确定的区域。由于这个原因，该算法也被称为“垃圾优先”。

## 垃圾收集器

Z 垃圾收集器是一个实验级算法，包含在 Java 11 版本中。该算法是为 Linux 设计的，在 JDK 14 之后，它将在 windows 和 Mac OS 中可用。

许多新引入的功能。它在更短的时间内并发工作，具有更好的性能。

该算法在内存空间已满时工作。该算法通过引用链找到应用程序可以访问的对象，释放不能访问的引用。该算法监视堆中行为对象的状态。监控是为了发现应用程序可以通过引用访问对象。垃圾回收器正在移除无法作为引用访问的。

## 比较

作为一个优势，标记和扫描算法是一个循环工作的永无止境的过程，而且，在算法的执行时间之间没有开销。该算法的缺点是程序运行时算法运行多次。

G1 垃圾收集算法非常有效，并且适用于多处理器机器。此外，该算法在暂停时间目标的方式上是有效的。该算法不适用于严格的吞吐量操作。它与应用程序和垃圾收集同时共享资源。资源共享影响性能。

Z 垃圾收集器算法在不中断不超过 10ms 的情况下执行并发执行。在堆划分的区域中，该算法可以调整大小。该算法使用动态内存分配来指向替代区域以释放堆。此外，它还提供多重映射服务，即虚拟内存中有一个地址指向同一个物理内存。这些是算法用来释放空间的更有效的方法。缺点是开发者不能控制算法的运行时间开销。对于需要大量内存空间的大规模应用来说，这是一个问题。

标记和清扫算法是应用程序中最常用的垃圾收集器。Z 垃圾收集器在释放空间方面更有效，但它仍处于实验阶段。G1 垃圾收集器更适合大内存和多处理系统。

## 参考

[1]“JVM 垃圾收集器”，baeldung.com[https://www.baeldung.com/jvm-garbage-collectors](https://www.baeldung.com/jvm-garbage-collectors)(访问时间:2022 年 6 月 9 日)。

[2]“在 Java 中选择最佳垃圾收集算法以获得更好的性能”，LinkedIn。[https://www . LinkedIn . com/pulse/chopping-best-garbage-collection-algorithm-better-Java-Prasad/](https://www.linkedin.com/pulse/choosing-best-garbage-collection-algorithm-better-java-prasad/)(访问时间:2022 年 6 月 9 日)。

[3]拜尔斯·里克。"垃圾收集算法。"