<html>
<head>
<title>Dynamic Programming: Saving Time on Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态编程:节省递归时间</h1>
<blockquote>原文：<a href="https://medium.com/codex/dynamic-programming-memoization-22aa7bfbf167?source=collection_archive---------7-----------------------#2021-11-08">https://medium.com/codex/dynamic-programming-memoization-22aa7bfbf167?source=collection_archive---------7-----------------------#2021-11-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7767aa2ba4e714ef9a70e06c0401c83a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VM9nNpzQ4bgZska1Zd2qEw.jpeg"/></div></div></figure><p id="f236" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">动态编程可能是学习数据结构和算法中最难的概念之一，这不是因为理解使用动态编程模式编写的解决方案特别困难，而是因为很难识别可以通过动态编程解决的问题，然后执行该解决方案。通常，DP解决方案的一个可能性是编写递归解决方案的能力。然而，并不是所有的递归问题都可以用动态编程来改进，所以递归解决方案的存在并不是一个完美的提示。</p><p id="dfbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要使用动态规划的递归解，必须满足两个条件:最优子结构和重叠子问题。为了探讨动态编程，我想先解释一下这些条件是什么意思，以及如何知道它们是否满足。</p><h1 id="ba0e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">最优子结构</h1><p id="9032" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">一个问题有最优子结构意味着什么？这意味着可以通过组合子问题的最优解来找到问题的最优解。这是动态编程的一部分，使得递归成为一条线索。因为递归，就其本质而言，要求子问题解决方案组合起来产生整体解决方案，所以递归解决方案是问题具有最优子结构的线索。</p><p id="4efc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">符合这个标准的一个例子是斐波那契数列，我在前面的<a class="ae kr" rel="noopener" href="/codex/an-introduction-to-recursion-in-javascript-1f3c8e6055da">中已经提到过它作为递归的一个例子。因为斐波那契数列的<em class="ks">第n个</em>数是前两个斐波那契数之和，符合动态规划的最优子结构约束。</a></p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/3d3199b53301dd365b8212718133dcae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-nk6_w-RQ-U5g3oKBfPug.jpeg"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">一个递归斐波纳契数生成器的图表，展示了它是如何符合最优子结构标准的。</figcaption></figure><h1 id="c88a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">重叠子问题</h1><p id="a328" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">这种可以通过动态规划解决的问题的约束比最优子结构更难理解。它本质上意味着，给定一个问题的强力递归解决方案，随着整体函数生成最终解决方案，相同的子问题将被重复解决。这可以从上面斐波纳契数列的第n个<em class="ks">数</em>的递归解图表中看出:生成函数求解fibo(4)两次，fibo(3)三次，fibo(2)五次，依此类推(求解的次数本身就是斐波纳契数列的函数)。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/3b29e02395998c0a373f5a922d7e601b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*57bOy1kiuoQpSvb8KqbDlA.jpeg"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">递归斐波纳契数生成器的相同图表，用符号表示每个重叠的子问题，以显示它被解决了多少次。</figcaption></figure><p id="3b0e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于像斐波纳契数列的第六个数字这样的简单问题，这种递归在计算时间方面并没有花费太多。然而，当我们要求越来越大的斐波那契数时，递归解决方案真的开始增加计算的复杂性。这个问题具有时间复杂性——我将在本系列的后续文章中介绍，但可以阅读O(2^n的<a class="ae kr" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">和</a><a class="ae kr" href="https://www.geeksforgeeks.org/analysis-algorithms-big-o-analysis/" rel="noopener ugc nofollow" target="_blank">文章，这被认为是极其糟糕的性能。动态编程试图通过只解决每个子问题一次来消除重叠子问题的重复，从而消除许多递归解决方案的高时间复杂性。</a></p><h1 id="313a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">简单的问题</h1><p id="c2b5" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在本文的其余部分，我将使用下面的问题(可以在<a class="ae kr" href="https://leetcode.com/problems/triangle/" rel="noopener ugc nofollow" target="_blank"> Leetcode </a>上找到)来演示动态编程:</p><blockquote class="lc ld le"><p id="e54c" class="iq ir ks is b it iu iv iw ix iy iz ja lf jc jd je lg jg jh ji lh jk jl jm jn hb bi translated">给定一个<code class="du li lj lk ll b">triangle</code>数组，返回<em class="hi">从上到下的最小路径和</em>。对于每一步，您可以移动到下一行的相邻数字。更正式地说，如果您在当前行的索引<code class="du li lj lk ll b">i</code>上，您可以移动到下一行的索引<code class="du li lj lk ll b">i</code>或索引<code class="du li lj lk ll b">i + 1</code>。</p></blockquote><pre class="ku kv kw kx fd lm ll ln lo aw lp bi"><span id="fa5f" class="lq jp hi ll b fi lr ls l lt lu">Example 1:</span><span id="2b52" class="lq jp hi ll b fi lv ls l lt lu">Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br/>Output: 11<br/>Explanation: The triangle looks like:<br/>   <strong class="ll hj"><em class="ks">2</em></strong><br/>  <strong class="ll hj"><em class="ks">3</em></strong> 4<br/> 6 <strong class="ll hj"><em class="ks">5</em></strong> 7<br/>4 <strong class="ll hj"><em class="ks">1</em></strong> 8 3<br/>The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (bolded above).</span><span id="4634" class="lq jp hi ll b fi lv ls l lt lu">Example 2:</span><span id="f8fb" class="lq jp hi ll b fi lv ls l lt lu">Input: triangle = [[-10]]<br/>Output: -10</span></pre><p id="b2df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这显然可以递归解决。这里有一个蛮力或幼稚的递归解决方案。如果这是在Leetcode上提交的，它将不会通过，因为它超过了给定测试用例数量的时间限制。但是，可以通过在沙箱中输入各种测试用例来手工测试。确实有效。</p><pre class="ku kv kw kx fd lm ll ln lo aw lp bi"><span id="7305" class="lq jp hi ll b fi lr ls l lt lu">var minimumTotal = function(triangle, idx = 0, height = 0) {<br/>    <br/>    if(height === triangle.length - 1){<br/>        return triangle[height][idx]<br/>    }<br/>    <br/>    let sum = 0;<br/>    let path1 = minimumTotal(triangle, idx, height + 1)<br/>    let path2 = minimumTotal(triangle, idx + 1, height + 1)<br/>    <br/>    sum = triangle[height][idx] + Math.min(path1, path2)<br/>    return sum<br/>}</span></pre><p id="c719" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个问题符合动态编程的条件吗？首先，它有最优子结构吗？由于它要求一条路径，我们可以说“是”——该路径必须是连接的(距离前一个数字在I或i + 1的特定距离内),并且该路径必须穿过整个三角形(包括数组的所有行)。因此，子问题的解决方案应该产生整体问题的解决方案。它有最佳的子结构。</p><p id="febc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">朴素递归解法中是否存在重叠的子问题？在这种情况下，答案是简单的“是”如果我们检查上面代码片段中的代码，我们可以清楚地看到，函数的每次运行都在重新计算path1和path2，一个数字的path1将与前一个数字的path2相同，依此类推。有相当多的重叠。</p><p id="ff43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于问题符合通过动态编程进行返工的条件，我们现在可以讨论如何改变递归解决方案，以便子问题只解决一次，从而节省大量求解时间。</p><h1 id="b519" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">通过列表的动态规划</h1><p id="72dc" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">有两种基本方法可以用来降低递归解的复杂性:记忆和列表。记忆化可以被认为是解决递归问题的“自顶向下”的方法。虽然它保留了原始解决方案中的一些递归，但它通过递归向下传递先前子问题的解决方案，直到构建出一个解决方案。虽然这比纯递归节省了时间，但许多工程师认为它不同于实际的动态编程。一种常见的动态编程技术，称为制表，工作方式几乎相反。制表不是自上而下的工作，而是在一个问题中自下而上的逆向工作。在这个问题中的三角形数组的情况下，列表解从三角形的底部向顶部进行。</p><p id="c4f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是上述三角形数组最小和问题的列表解决方案示例:</p><pre class="ku kv kw kx fd lm ll ln lo aw lp bi"><span id="fea6" class="lq jp hi ll b fi lr ls l lt lu">var minimumTotal = function(triangle) {<br/>    for(let row = triangle.length - 2; row &gt;= 0; row--){<br/>        for(let col = 0; col &lt; triangle[row].length; col++){<br/>            triangle[row][col] += Math.min(triangle[row + 1][col], triangle[row + 1][col + 1])<br/>        }<br/>    }<br/>    return triangle[0][0]<br/>};</span></pre><p id="8d34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个相当聪明的解决方案(我并不认为这是我的功劳——这要归功于<a class="ae kr" href="https://gist.github.com/ChippyChoppy/577b4a63a3c59016a2240493bc0ae8e7" rel="noopener ugc nofollow" target="_blank"> ChippyChoppy </a>，也就是我的朋友Becca)使用三角形数组本身来保存许多基于路径的解决方案，直到到达三角形的顶部。从“底部”(三角形数组的倒数第二个子数组)上面的行开始，该函数将“下面”的两个路径中较小的一个添加到数组中的当前数字。然后，它向上移动到下一行，进行相同的操作，直到它返回三角形的顶部数字，这是现在的最小路径和。下面的伪代码更清楚地显示了正在发生的事情:</p><pre class="ku kv kw kx fd lm ll ln lo aw lp bi"><span id="e1f7" class="lq jp hi ll b fi lr ls l lt lu">// Test array: [[2],[3,4],[6,5,7],[4,1,8,3]]<br/>// Starting on the [6,5,7] row, we add the smaller of the two<br/>// numbers below each to that number<br/>// [6,5,7] becomes [6+1,5+1,7+3] or [7,6,10]<br/>// Moving up to the [3,4] row we do the same<br/>// [3,4] becomes [3+6,4+6] or [9,10]<br/>// And now we add to the 'top' or zeroth row<br/>// [2] becomes [2+9] or 11<br/>// return the top row, only number, which is now the sum, 11</span></pre><p id="91ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与2^n时间复杂的递归解决方案相反，这种通过制表的动态规划解决方案的时间复杂性仅为O(n)，因为它通过一对嵌套的循环来获得完整大小的输入数据集(n)。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="8d62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然这肯定不是可以通过动态编程解决的所有问题的完整概述，也不是所涉及的每种技术，但我当然希望这是对该主题的一个有价值的介绍。动态编程是降低问题的时间复杂度的一个很好的方法，这些问题可以通过递归的暴力来解决。</p></div></div>    
</body>
</html>