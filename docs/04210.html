<html>
<head>
<title>10 Features PHP 8.1 has to offer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP 8.1必须提供的10个特性</h1>
<blockquote>原文：<a href="https://medium.com/codex/10-features-php-8-1-has-to-offer-176e856d29d7?source=collection_archive---------2-----------------------#2021-11-08">https://medium.com/codex/10-features-php-8-1-has-to-offer-176e856d29d7?source=collection_archive---------2-----------------------#2021-11-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b4ff5f01ef01cdc3c220d7860b3869d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BArFhH06luyAZvti5oXOnw.jpeg"/></div></div></figure><p id="184d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">PHP的新版本(8.1)将于11月25日发布。它可以提供许多新功能，越来越接近更现代的语言。</p><p id="8289" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里列出了PHP 8.1中添加的10大新特性。</p><h1 id="37ca" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">1.交叉点类型</h1><p id="d982" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">PHP 8.1将支持交集类型，这与并集类型相反(允许任何声明的类型)。交集类型允许声明属性、参数或返回类型，并强制该值属于所有声明的类/接口类型。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="6801" class="la jp hi kw b fi lb lc l ld le">function drink_and_wash(<strong class="kw hj"><em class="lf">Drinkable&amp;Washable</em></strong> $drink) {<br/>    ...<br/>}</span></pre><p id="bca4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码中，<strong class="is hj"> $drink </strong>必须是一个同时实现了<strong class="is hj">可饮用</strong>和<strong class="is hj">可清洗</strong>的类中的对象——否则，将会引发类型错误。</p><h2 id="4e68" class="la jp hi bd jq lg lh li ju lj lk ll jy jb lm ln kc jf lo lp kg jj lq lr kk ls bi translated">仅类和接口</h2><p id="5c3b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">交集成员只能是类和接口，所以不允许标量类型、数组、void、callable、never、iterable、null、mixed等。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="adf9" class="la jp hi kw b fi lb lc l ld le">function foo(<strong class="kw hj"><em class="lf">string</em>|<em class="lf">int</em></strong> $val) {}</span><span id="a273" class="la jp hi kw b fi lt lc l ld le"><em class="lf">// Type Error<br/></em><em class="lf">Fatal error: Type string cannot be part of an intersection type in ... on line ...</em></span></pre><h1 id="c9c6" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">2.从不—一种新的返回类型</h1><p id="9570" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">PHP 8.1中出现了一种新的返回类型——<em class="lf">never</em>。当声明一个返回类型为<strong class="is hj"> never </strong>的函数时，你基本上可以说它将<strong class="is hj">永不返回值</strong>并且<strong class="is hj">返回一个异常</strong>或者<strong class="is hj">用一个die/exit调用终止它</strong>。</p><p id="c58d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ide可以安全地假设代码的其余部分不会执行，并将其范围扩大。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e576" class="la jp hi kw b fi lb lc l ld le">function no_value_returned(<em class="lf">string</em> $params): <strong class="kw hj"><em class="lf">never</em></strong> {<br/>    ... // code<br/>    exit();<br/>}</span></pre><p id="5ba5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果函数没有抛出异常或者终止程序，PHP将抛出一个TypeError异常。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="b363" class="la jp hi kw b fi lb lc l ld le">function does_not_follow_the_rules(): <strong class="kw hj"><em class="lf">never</em></strong> {<br/>    echo 'I do not abide the rules!'<br/>}</span><span id="76f0" class="la jp hi kw b fi lt lc l ld le">// Type Error<br/><em class="lf">TypeError: dispatch(): never-returning function must not implicitly return</em></span></pre><h1 id="3902" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">3.只读属性</h1><p id="f5aa" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">终于！声明为只读的类属性<strong class="is hj">只能初始化一次</strong>，不允许进一步更改。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="c4c3" class="la jp hi kw b fi lb lc l ld le">class Human {<br/>    public <strong class="kw hj">readonly</strong> string $dna;</span><span id="2a4d" class="la jp hi kw b fi lt lc l ld le">    public function __construct(string $dna) {<br/>        $this-&gt;dna = $dna;<br/>    }<br/>}</span><span id="4633" class="la jp hi kw b fi lt lc l ld le">$human = new Human("...");</span></pre><p id="c2c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更重要的是，只读属性<strong class="is hj">只能在类</strong>中设置，无论是从构造函数还是从另一个方法。</p><h2 id="2749" class="la jp hi bd jq lg lh li ju lj lk ll jy jb lm ln kc jf lo lp kg jj lq lr kk ls bi translated">和睦相处</h2><p id="69ab" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">虽然readonly是一个保留关键字，但是它允许用readonly来声明函数，因为一些PHP框架声明了它们自己的readonly函数</p><h2 id="43f1" class="la jp hi bd jq lg lh li ju lj lk ll jy jb lm ln kc jf lo lp kg jj lq lr kk ls bi translated">什么是不允许的？</h2><ul class=""><li id="922e" class="lu lv hi is b it km ix kn jb lw jf lx jj ly jn lz ma mb mc bi translated">只读属性只能设置一次。第二次(以及更多次)尝试将导致错误</li><li id="d9b2" class="lu lv hi is b it md ix me jb mf jf mg jj mh jn lz ma mb mc bi translated">在类的范围之外初始化只读属性<strong class="is hj"/></li><li id="ca52" class="lu lv hi is b it md ix me jb mf jf mg jj mh jn lz ma mb mc bi translated">你不能直接设置一个值，增加它，引用和做数组操作，因为一旦设置好，PHP不允许你修改它</li><li id="ce0d" class="lu lv hi is b it md ix me jb mf jf mg jj mh jn lz ma mb mc bi translated">您不能取消设置只读属性</li><li id="2592" class="lu lv hi is b it md ix me jb mf jf mg jj mh jn lz ma mb mc bi translated">没有类型的声明(仅支持类型化属性)</li></ul><h1 id="47a0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">4.新函数—数组列表</h1><p id="3d8c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">该函数<strong class="is hj">返回true或false，并检查给定数组是否是值的语义列表</strong>——这意味着:</p><ul class=""><li id="296e" class="lu lv hi is b it iu ix iy jb mi jf mj jj mk jn lz ma mb mc bi translated">密钥必须是整数</li><li id="46e9" class="lu lv hi is b it md ix me jb mf jf mg jj mh jn lz ma mb mc bi translated">两者之间没有间隙</li><li id="8fa2" class="lu lv hi is b it md ix me jb mf jf mg jj mh jn lz ma mb mc bi translated">密钥从0开始</li></ul><p id="fc47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，该函数将在空数组上返回true。</p><p id="d264" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> array_is_list </strong> <strong class="is hj">返回true </strong>时的例子:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e293" class="la jp hi kw b fi lb lc l ld le">array_is_list([]); <em class="lf">// true</em><br/>array_is_list([1, 2, 3]); <em class="lf">// true</em><br/>array_is_list(['text', 2, 3]); <em class="lf">// true</em><br/>array_is_list(['text', 'sentence']); <em class="lf">// true</em><br/>array_is_list([0 =&gt; 'text', 'sentence']); <em class="lf">// true</em></span></pre><p id="5e20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当<strong class="is hj"> array_is_list返回false </strong>时的示例:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="a999" class="la jp hi kw b fi lb lc l ld le"><em class="lf">// Key does not start with 0</em><br/>array_is_list([1 =&gt; 'text', 'sentence']); <em class="lf">// false</em><br/><br/><em class="lf">// Keys are not in order</em><br/>array_is_list([1 =&gt; 'text', 0 =&gt; 'sentence']); <em class="lf">// false</em><br/><br/><em class="lf">// Non-integer keys</em><br/>array_is_list([0 =&gt; 'text', 'foo' =&gt; 'bar']); false<br/><br/><em class="lf">// Non-sequential keys</em><br/>array_is_list([0 =&gt; 'text', 2 =&gt; 'bar']); false</span></pre><h1 id="14a7" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">5.枚举</h1><p id="2769" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">增加的一个额外特性是支持<strong class="is hj">枚举</strong>。一个例子是用枚举来表示<strong class="is hj">状态</strong>:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="57ac" class="la jp hi kw b fi lb lc l ld le"><strong class="kw hj">enum</strong> Status {<br/>    <strong class="kw hj">case</strong> Active;<br/>    <strong class="kw hj">case</strong> InProgress;<br/>    <strong class="kw hj">case</strong> Finished;<br/>}</span></pre><p id="5cc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以在函数中接受值时强制类型:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="c098" class="la jp hi kw b fi lb lc l ld le">function set_status(<strong class="kw hj">Status</strong> $status) { }<br/>...</span><span id="f941" class="la jp hi kw b fi lt lc l ld le">set_status(<strong class="kw hj">Status::Finished</strong>);</span></pre><h1 id="7ab1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">6.新的类常量— final(关键字)</h1><p id="7972" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">现在，您可以将<strong class="is hj"> final </strong>添加到类常量中。在PHP类中，你可以覆盖它们子类中的常量。</p><p id="fe6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在可以使用<strong class="is hj"> final </strong>关键字禁止这种情况:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="65df" class="la jp hi kw b fi lb lc l ld le">class Example {<br/>    <strong class="kw hj">final</strong> public const MYCONSTANT = 1;<br/>}</span><span id="6cac" class="la jp hi kw b fi lt lc l ld le">class SubExample extends Example{<br/>    public const MYCONSTANT = 2;<br/>}</span><span id="45d7" class="la jp hi kw b fi lt lc l ld le"><em class="lf">Fatal error: SubExample::MYCONSTANT cannot override final constant Example::MYCONSTANT in %s on line %d</em></span></pre><p id="2f4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，给私有常量添加一个<strong class="is hj"> final </strong>标志是行不通的，因为私有属性首先不能在类之外被访问。</p><h1 id="d6e1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">7.一级可调用语法</h1><p id="dbd0" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">引入了新的语法来创建可调用的。</p><p id="9146" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不使用<em class="lf"> Closure::fromCallable </em>(它返回一个<strong class="is hj">可调用的</strong>，Closure对象)，下面是新语法的样子:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="785c" class="la jp hi kw b fi lb lc l ld le">// OLD SYNTAX<br/>$callable = <strong class="kw hj">Closure::fromCallable('strtoupper')</strong>;<br/>echo $callable('foo'); <em class="lf">// FOO</em></span><span id="5482" class="la jp hi kw b fi lt lc l ld le">// NEW SYNTAX<br/>$callable = <strong class="kw hj">strtoupper(...)</strong>;<br/>echo $callable('foo'); // FOO</span></pre><p id="ed7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Callable，后跟<strong class="is hj"> (…) </strong>使得一级callable。</p><h1 id="1da1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">8.纤维</h1><p id="e03d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">PHP的一个新版本(可能被认为是一个比它实际上更重要的版本)增加了一个<strong class="is hj">机制来管理并行性</strong>。虽然您可能不会直接使用它，但是一些框架会大量使用它们。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8127" class="la jp hi kw b fi lb lc l ld le">$fiber = new Fiber(function (): void {     <br/>    $valueAfterResuming = Fiber::suspend('after suspending'); </span><span id="f637" class="la jp hi kw b fi lt lc l ld le">    /<em class="lf">/ … </em> <br/>});   </span><span id="0089" class="la jp hi kw b fi lt lc l ld le">$valueAfterSuspending = $fiber-&gt;start();   <br/>$fiber-&gt;resume('after resuming');</span></pre><p id="6469" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这应该会给PHP带来一个轻量级的、期待已久的<strong class="is hj">并发</strong>。<strong class="is hj">纤程</strong>基本上维持自己的堆栈，有四种状态:</p><ul class=""><li id="d491" class="lu lv hi is b it iu ix iy jb mi jf mj jj mk jn lz ma mb mc bi translated">出发</li><li id="53f4" class="lu lv hi is b it md ix me jb mf jf mg jj mh jn lz ma mb mc bi translated">运转</li><li id="e8f6" class="lu lv hi is b it md ix me jb mf jf mg jj mh jn lz ma mb mc bi translated">暂停的</li><li id="cc55" class="lu lv hi is b it md ix me jb mf jf mg jj mh jn lz ma mb mc bi translated">终止的</li></ul><h1 id="b6fa" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">9.数组解包</h1><p id="a068" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">是的，我知道，<strong class="is hj">这在PHP以前的版本</strong>中已经被允许了…但是，它<strong class="is hj">只适用于数字键</strong>。</p><p id="5cc3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之前不支持字符串键的主要原因是，对于如何合并数组副本还没有达成共识。</p><p id="1f84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">RFC通过使用<strong class="is hj"> array_merge </strong>的语义解决了这个问题:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="4b06" class="la jp hi kw b fi lb lc l ld le">$array1 = ["x" =&gt; 1];  <br/>$array2 = ["y" =&gt; 2]; <br/> <br/>$array = ["x" =&gt; 0, ...$array1, ...$array2]; <br/> <br/>var_dump($array); <em class="lf">// ["x" =&gt; 1, "y" =&gt; 2]</em></span></pre><h1 id="5303" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">10.fsync和fdatasync功能</h1><p id="1812" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">著名的<strong class="is hj"> fflush() </strong>函数和这两个新的坏男孩有一些相似之处。</p><p id="ceee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">fflush() 在写操作之后使用，以确保PHP的内部缓冲区被刷新到操作系统。</p><p id="a89c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> fsync() </strong> —同步对文件的更改(包括元数据)。非常类似于<em class="lf"> fflush </em>，但是它也指示写入存储介质。</p><p id="8220" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> fdatasync() </strong> —将数据(但不是元数据)同步到文件。</p><h2 id="c5e7" class="la jp hi bd jq lg lh li ju lj lk ll jy jb lm ln kc jf lo lp kg jj lq lr kk ls bi translated">使用</h2><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="9aa5" class="la jp hi kw b fi lb lc l ld le">$file = 'test.txt';<br/><br/>$fh = fopen($file, 'w');<br/>fwrite($fh, 'test data');<br/>fwrite($fh, "\r\n");<br/>fwrite($fh, 'additional data');<br/><br/>fsync($fh);<br/>fclose($fh);</span></pre><h1 id="69ad" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="3ca9" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">PHP 8.1提供了许多有趣的特性。如果你问我，我甚至会称之为一个主要的版本变化。从过去的几个版本更新来看，PHP看起来越来越像任何其他现代语言，在性能和语法方面都得到了改进，同时仍然保持了其代码库、社区支持和稳定性。</p><p id="eddc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">干得好！</p></div></div>    
</body>
</html>