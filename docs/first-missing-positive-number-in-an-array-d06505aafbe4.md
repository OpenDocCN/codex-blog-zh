# 数组中第一个缺失的正数

> 原文：<https://medium.com/codex/first-missing-positive-number-in-an-array-d06505aafbe4?source=collection_archive---------9----------------------->

![](img/3c8eec7bfb23c79546ffa2c843ae5c84.png)

最近在一次技术面试中，我被要求解决以下问题:

编写一个函数，查找不在给定的非负非重复整数数组中的最小非负整数

我认为这是一个非常好的问题，因为起初它似乎非常简单，但随着你深入研究，几乎肯定会有许多方法来改进你最初提出的解决方案。让我们现在就开始吧。

# 蛮力

当我做这类问题时(特别是在面试环境中，当面试你的人在看你写代码时，有一个时间因素)，我喜欢从屏幕上的一些东西开始，然后得到一个答案。

做到这一点的最好方法是想出强力解决方案，然后在你有了一个工作函数后对其进行优化，并且可以更深入地研究逻辑。

在我们的例子中，最简单的强力解决方案是嵌套循环。外部循环将从 0 开始向上计数(因为 0 是最小的非负整数),并一直向上计数，直到找到我们要寻找的数字。

内部循环将扫描整个数组，寻找外部循环给出的数字。如果找到那个号码，它将继续，如果没有，我们有我们的号码，它将返回它。

让我们把它付诸实践:

```
const smallest = function(nums){
  for (let i = 0; i<Infinity; i++){
    if (!nums.includes(i)) return i
  }
  return nums.length
}
```

简单有效。这将遍历所有的数字，直到无穷远，直到我们找到一个不在数组中的数字。的。includes()方法为我们处理内部循环。

现在我们的空间复杂度是很大的 O(1)，但是我们的时间复杂度不是最好的 O(N)

# 整理

我的下一个直觉是，如果我们对数组进行排序，理论上我们可以大大减少运行时间，因为我们最多只需要遍历数组一次，只是检查整数的顺序是否正确。在最坏的情况下，我们一直到达数组的末尾，没有发现一个缺口，并且我们知道下一个最小的数就是数组的长度(例如，在[0，1，2，3]的数组中，没有出现的最小数是 4，这也是数组的长度)。

其代码如下:

```
const smallest = function(nums){
  nums = nums.sort()

  if (nums[0] !== 0) return 0

  for(let i = 0; i< nums.length; i++){
     if (nums[i+1] - nums[i] !== 1){
       return nums[i] + 1
     }
   }
  return nums.length
}
```

我们的 For 循环现在只对数组的每个元素运行一次，所以它是 O(N)。然而，自从我们的。sort()方法以 O(N log N)时间复杂度运行，与我们的线性循环相比，它实际上是更大的因素。所以我们的时间复杂度 O(N log N + N)降低到(O N log N)。

好吧，我们越来越接近了，但我们可以做得更好。

# 哈希表

我的下一个直觉是使用散列表。使用哈希表以增加内存来换取速度，这通常是我们要做的一个权衡。

```
const smallest = function(nums){ hash = {} nums.forEach(num => {
    hash[num] = true
  })for (let i =0; i<nums.length+1; i++){
    if (!hash[i]) return i 
  } return nums.length
}
```

你会在这里看到一个模式，如果我们遍历所有代码，这意味着不在数组中的最小数是数组的长度，这意味着数组包含了从 0 到其大小的所有数。

我们的第一个循环遍历数组，为数组中的每个数字创建一个键值对，并将其存储在 hash 中。

然后，我们的第二个循环从 0 开始迭代，直到数组的长度，检查每个数字在 hash 中是否有对应的键。如果没有，我们就打破循环，返回号码。

有两个循环，但是因为它们没有嵌套，所以将它们的运行时间相加，而不是相乘，这样我们得到的时间复杂度为 O(N + N)或 O(2N ),我们可以将其简化为 O(N ),称之为线性。然而，我们的空间复杂度现在是 O(N ),而不是常数，因为我们使用的是散列。

这是我在面试中所能得到的，但是我的面试官给了我两个主要的线索，并告诉我继续寻找解决方案。这两条线索是:

1.  记住输入是唯一的和非负的
2.  当从 0 到 size 的每个数字都存在时，数组中迭代次数的最坏情况发生，因此最大迭代次数为 N

# 线性时间和常数空间解

绞尽脑汁了几个小时，最后一步一步走了，我终于想到了解决办法。

由于这些数字都是正数(或零)，我们可以利用这一事实，创建一种“就地检查表”，能够在线性时间内跟踪数字，而无需创建新的数组。

我们可以通过使用每个数字的值，在相应的索引处“划掉”该数字来实现这一点。这是什么意思？我来解释一下:

让我们使用数组[3，1，5，2，0]作为例子。

当我们到达数组[0]时，值是 3。我们现在知道 3 出现了。我们可以将数组修改为“划掉”3，并通过转到数组[3]并将那里的数字改为负数来标记它的存在。

我们的数组现在是[3，1，5，-2，0]

我们将继续这个模式，直到到达数组的末尾。在我们的例子中，最终的数组看起来像[-3，-1，-5，-2，0]

现在我们可以循环，看看哪些数字不是负的。如果它们都是，我们将知道所有的数字都存在，但如果不是，我们遇到的第一个数字的索引将是我们要寻找的数字。

现在你可能已经注意到了我们例子中的一个问题。我们寻找的答案是 4，因为这是最小的非负数。但是在我们的数组[4]中，vale 既不是负数也不是正数。它是零。因此，我们必须在代码中编写一个特例来处理这种情况。

下面来看看:

```
cosnt smallest = function(nums) {
  let len = nums.length
    for (let i=0; i<len; i++){
      let idx = Math.abs(nums[i])
    if (nums[idx] === undefined){
      nums[idx] = 1
    }
    if (nums[idx] === 0){
      nums[0] *= -1
      nums[idx] = -1
    } else {
      nums[idx] *= -1
    }
  }

  for (let i=0; i<nums.length; i++){
    if (nums[i] > 0 ) return i
  }
  return nums.length
};
```

现在我们在这里处理一些边缘案件。第一个是我提到的数组中有一个 0。我们不能像其他数字一样乘以-1，因为它仍然是零。我们也不能将 if 语句调整为 if nums[i] > 0 返回 I，因为在某些情况下，0 的索引可能已经被计算，也可能没有被计算。我们无从得知。

我们必须发挥创造力，如果我们得到一个值为 0 的数，那么转到索引 0，乘以-1，然后把 0 变成负 1。这样，我们就不会在得到 0 之前把它变成负数，从而破坏了在索引 0 处“划掉”数字的能力。

此外，您将看到我们在数组的开头创建了一个变量“len”。这是因为有时如果数组中有更大的数，我们函数的设置方式是，当 num[idx]未定义时，我们将它存储为 1。例如，如果我们的数组是[1，2，50，3]。当我们到达值为 50 的索引 3 时，我们知道索引 50 并不存在，因此我们先将 array[50]设置为 1，然后将其设为负值，在数组中对其进行计数。因为这会导致我们的数组增长，如果我们在 for 循环中使用 nums.length，我们将会比我们想要的运行更多次，并且会迭代一堆空格。将 len 设置为等于原始数组长度可以解决这个问题。

最后，在我们的 else 条件中，我们需要考虑这样的情况:我们已经将 0 更改为-1，但是它还没有被我们的 for 循环访问。如果发生这种情况，我们可能会意外地将索引 1 处的数字改回正数，而它已经变成负数了。

这段代码通过在将数字改为负数之前确保它是正数来解决这个问题:

```
} else {
  if (nums[idx] > 0){
    nums[idx] *= -1
  }
}
```

我们的最终代码如下所示:

```
cosnt smallest = function(nums) {
  let len = nums.length
    for (let i=0; i<len; i++){
      let idx = Math.abs(nums[i])
    if (nums[idx] === undefined){
      nums[idx] = 1
    }
    if (nums[idx] === 0){
      nums[0] *= -1
      nums[idx] = -1
    } else {
      if (nums[idx] > 0){
        nums[idx] *= -1
      }
    }
  }

  for (let i=0; i<nums.length; i++){
    if (nums[i] > 0 ) return i
  }
  return nums.length
};
```

今天就到这里。请随意尝试自己的解决方案，看看您是否能找到任何边缘案例。