<html>
<head>
<title>Catching Back Button Presses on Android using Navigator 2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Navigator 2.0捕捉Android上的按键</h1>
<blockquote>原文：<a href="https://medium.com/codex/flutter-case-study-catching-back-button-presses-on-android-when-using-navigator-2-0-d4d42e4718f6?source=collection_archive---------6-----------------------#2021-12-28">https://medium.com/codex/flutter-case-study-catching-back-button-presses-on-android-when-using-navigator-2-0-d4d42e4718f6?source=collection_archive---------6-----------------------#2021-12-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="96db" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">颤振案例研究</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e3d90752d3dfd9008ae376e47fd85190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u881uHvpllLIScqxeXXRSg.jpeg"/></div></div></figure><p id="1436" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">欢迎阅读颤振新系列文章的第一篇。我最近开始浏览与颤振相关的StackOverflow，也许我可以回答这个问题，以帮助初露头角的颤振爱好者。时不时地，我会遇到一个问题，我觉得需要一篇文章来解释这个问题和解决方案，也许还需要一些细节来解释为什么会出现这个问题。我将这些文章命名为<strong class="jl hj">案例研究</strong>，我期待着深入挖掘我遇到的有趣的、晦涩的或过于普通的问题。废话少说，让我们开始我们的第一个案例研究。</p><p id="bd91" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你觉得这篇文章的标题值得一读，那么毫无疑问，你已经在Flutter pre-1<em class="kg">Navigator 2.0</em>中体验过在Android上捕捉按钮按压，但是这里有一点复习。我们简单地将小部件树包装在一个<code class="du kh ki kj kk b">WillPopScope</code>小部件中，并提供一个<code class="du kh ki kj kk b">onWillPop</code>回调。这里有一个例子，捕捉后退按钮的按下，并提供一个<code class="du kh ki kj kk b">AlertDialog</code>来确认应用程序退出。</p><pre class="iy iz ja jb fd kl kk km kn aw ko bi"><span id="d841" class="kp kq hi kk b fi kr ks l kt ku">WillPopScope(<br/>  onWillPop: () async {<br/>    final shouldPop = await showDialog&lt;bool&gt;(<br/>      context: context,<br/>      builder: (context) {<br/>        return AlertDialog(<br/>          title: Text('Exit App'),<br/>          content: Text('Are you sure you want to leave the app?'),<br/>          actions: [<br/>            TextButton(<br/>              child: Text('Cancel'),<br/>              onPressed: () =&gt; Navigator.pop(context, false),<br/>            ),<br/>            TextButton(<br/>              child: Text('Confirm'),<br/>              onPressed: () =&gt; Navigator.pop(context, true),<br/>            ),<br/>          ],<br/>        );<br/>      },<br/>    );</span><span id="dded" class="kp kq hi kk b fi kv ks l kt ku">    // if the dialog is dismissed by tapping outside of the barrier<br/>    // the result is null, so we return false<br/>    return shouldPop ?? false;<br/>  },<br/>  child: // continue with widget tree here<br/>)</span></pre><p id="ab3e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如你所看到的，用户在<code class="du kh ki kj kk b">AlertDialog</code>中的输入会告诉我们他们是否真的想离开应用程序，我们可以将结果传递给<code class="du kh ki kj kk b">WillPopScope</code>小部件。</p><p id="b835" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您在使用<em class="kg"> Navigator 2.0 </em>时尝试过这种方法，那么您会发现<code class="du kh ki kj kk b">WillPopScope</code>不再捕捉按钮按压。这是因为在<em class="kg"> Navigator 2.0 </em>中，<code class="du kh ki kj kk b">RouterDelegate</code>的<code class="du kh ki kj kk b">popRoute</code>方法负责处理操作系统弹出当前路径的请求(后退按钮按下)，我们可以在方法的文档中看到:</p><blockquote class="kw kx ky"><p id="cbd7" class="jj jk kg jl b jm jn ij jo jp jq im jr kz jt ju jv la jx jy jz lb kb kc kd ke hb bi translated">该方法应该返回一个boolean [Future]来指示该委托是否处理该请求。返回false将弹出整个应用程序。</p></blockquote><p id="22e0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">按下后退按钮后，设计实现会立即弹出整个应用程序。因此，我们必须在扩展<code class="du kh ki kj kk b">RouterDelegate</code>类时覆盖它，并根据我们的需要处理后退按钮按压。</p><pre class="iy iz ja jb fd kl kk km kn aw ko bi"><span id="1aaf" class="kp kq hi kk b fi kr ks l kt ku">@override<br/>Future&lt;bool&gt; popRoute() async {<br/>  // check if we have pages in the stack to pop before<br/>  // attempting app exit<br/>  if (_pages.length &gt; 1) {<br/>    // handle popping the current page off of the stack<br/>    return Future.value(true);<br/>  }</span><span id="c3b0" class="kp kq hi kk b fi kv ks l kt ku">  final result = await showDialog&lt;bool&gt;(<br/>    // get the context from the navigatorKey defined<br/>    // in your RouterDelegate class<br/>    context: navigatorKey!.currentContext!,<br/>    builder: (context) {<br/>      return AlertDialog(<br/>        title: const Text('Exit App'),<br/>        content: const Text('Are you sure you want to exit the app?'),<br/>        actions: [<br/>          TextButton(<br/>            child: const Text('Cancel'),<br/>            onPressed: () =&gt; Navigator.pop(context, true),<br/>          ),<br/>          TextButton(<br/>            child: const Text('Confirm'),<br/>            onPressed: () =&gt; Navigator.pop(context, false),<br/>          ),<br/>        ],<br/>      );<br/>    },<br/>  );</span><span id="fda4" class="kp kq hi kk b fi kv ks l kt ku">  // if the dialog is dismissed by tapping outside of the barrier<br/>  // the result is null, so we return false<br/>  return shouldPop ?? false;<br/>}</span></pre><p id="f58b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您不需要按后退按钮在应用程序中向后导航，而需要一直显示退出应用程序对话框，您可以省略第一个<em class="kg"> if语句。</em></p><p id="3346" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">注意:</strong>您可能已经注意到，在这两种方法中，对话框的结果是相反的。这是因为当使用<code class="du kh ki kj kk b">WillPopScope</code>时，我们告诉小部件它是否应该从<code class="du kh ki kj kk b">Navigator</code>弹出范围(<em class="kg">真=弹出，假=不弹出</em>)。当使用<em class="kg"> Navigator 2.0 </em>时，我们告诉<code class="du kh ki kj kk b">Router</code>我们是否已经处理了请求(<em class="kg">真=已处理，假=未处理</em>)。当我们报告自己没有处理时，<code class="du kh ki kj kk b">Router</code>通过退出app来处理。</p><p id="1cab" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就是全部了。通过将您的逻辑从<code class="du kh ki kj kk b">WillPopScope</code>的<code class="du kh ki kj kk b">onWillPop</code>回调转移到<code class="du kh ki kj kk b">RouterDelegate</code>的<code class="du kh ki kj kk b">popRoute</code>方法，您可以在使用<em class="kg"> Navigator 2.0 </em>时轻松处理后退按钮按压。</p><p id="cccb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你想更深入地研究<em class="kg"> Navigator 2.0 </em>并获得关于将应用程序转换为<em class="kg"> Navigator 2.0 </em>的深入教程，请查看我的从<a class="ae kf" rel="noopener" href="/geekculture/a-simpler-guide-to-flutter-navigator-2-0-part-i-70623cedc93b"> <em class="kg">开始的3部分系列:更简单的Flutter Navigator 2.0指南:第一部分</em> </a>。</p><p id="6440" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">感谢您的阅读！如果您觉得这篇文章很有帮助，并且想阅读更多的案例研究，请鼓掌并关注。编码快乐！</p></div></div>    
</body>
</html>