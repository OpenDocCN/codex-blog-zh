<html>
<head>
<title>Number (part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">号码(第一部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/number-part-1-c98313903714?source=collection_archive---------7-----------------------#2021-08-10">https://medium.com/codex/number-part-1-c98313903714?source=collection_archive---------7-----------------------#2021-08-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/8cc1389c36992b55f44bf247c48ceb60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QNbflUnaHqHD_HMX"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae hv" href="https://unsplash.com/@scienceinhd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科学高清</a>拍摄的照片</figcaption></figure><div class=""/><p id="68fb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我刚开始编程的时候(60年代后期)，我想知道为什么科学/数学计算经常出错。在那些日子里，我们没有双精度数字，所以实际误差可能会增加。另一方面，我们能够把人送上月球，所以显然有些人知道如何处理这个问题。但是我不知道有什么通用的方法来跟踪数字计算中可能出现的错误。好像少了点什么。我想我迟早会解决这个问题。大约在2002年，我确实开始开发一套Java库来跟踪错误<em class="jt">和</em>单元。但是Java有足够多的问题和限制，尽管它运行得很好，我还是停止了对它的改进。</p><p id="3715" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我第一次听说Scala的时候，似乎我可以修复一些Java的问题，因为有了增强的类型系统。事实上这是真的。所以，这篇文章(第一部分)是关于<em class="jt">数字</em>的模糊性。我们如何使一个类型模糊？嗯，<em class="jt"> Fuzzy[X] </em>是赋予类型<em class="jt"> X </em>模糊性的特征。因为它是一个类型类，我们不必拥有<em class="jt"> X </em>，甚至不必在本地的任何地方拥有它的源。这是Scala支持这类事情的最重要的特性之一。</p><p id="f2b1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，举个例子怎么样？假设有一个case类叫做<em class="jt"> Color </em>。你不是自己写的，但它看起来像这样:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="eb40" class="kd ke hy jz b fi kf kg l kh ki">case class Color(r: Short, g: Short, b: Short) {<br/>  def difference(x: Color): Color = <em class="jt">Color</em>(math.<em class="jt">abs</em>(r - x.r), math.<em class="jt">abs</em>(g - x.g), math.<em class="jt">abs</em>(b - x.b))<br/><br/>  def whiteness: Double = math.<em class="jt">sqrt</em>(r * r + g * g + b * b) / 255<br/>}</span></pre><p id="e992" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过计算两种颜色的差值，然后得出结果的白度，来了解这两种颜色有多接近。如果是零，那么我们两个颜色是一样的。但是如果我们甚至不能感知颜色的微小差异呢？让我们添加模糊性。但是，首先我们最好定义一下我们的模糊特征:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="830e" class="kd ke hy jz b fi kf kg l kh ki"><em class="jt">/**<br/>  * Type class which adds fuzzy behavior to a type X.<br/>  *<br/>  * </em><strong class="jz hz"><em class="jt">@tparam X </em></strong><em class="jt">the type to be made fuzzy.<br/>  */<br/></em>trait Fuzzy[X] {<br/><br/>  <em class="jt">/**<br/>    * Method to determine if x1 and x2 can be considered the same with a probability of p.<br/>    *<br/>    * </em><strong class="jz hz"><em class="jt">@param p  </em></strong><em class="jt">a probability between 0 and 1 -- 0 would always result in true; 1 will result in false unless x1 actually is x2.<br/>    * </em><strong class="jz hz"><em class="jt">@param x1 </em></strong><em class="jt">a value of X.<br/>    * </em><strong class="jz hz"><em class="jt">@param x2 </em></strong><em class="jt">a value of X.<br/>    * </em><strong class="jz hz"><em class="jt">@return </em></strong><em class="jt">true if x1 and x2 are considered equal with probability p.<br/>    */<br/>  </em>def same(p: Double)(x1: X, x2: X): Boolean<br/>}</span></pre><p id="d28b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，这里只有一种方法。它被称为<em class="jt"> same </em>，它采用两个参数集:<em class="jt"> p </em>(一个<em class="jt"> Double </em>表示概率)和一对<em class="jt"> X </em> s，得到的<em class="jt"> Boolean </em>表示<em class="jt"> x1 </em>和<em class="jt"> x2 </em>是否应该被视为相同。这就是这个最普遍的情况。当我们有数值时，我们会发现模糊性更有用，但我们稍后会谈到。</p><p id="e272" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们看看如何给<em class="jt">颜色</em>添加一些模糊:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="223a" class="kd ke hy jz b fi kf kg l kh ki">object Color {<br/>  def apply(r: Int, g: Int, b: Int): Color = <em class="jt">Color</em>(r.toShort, g.toShort, b.toShort)<br/><br/>  trait FuzzyColor extends Fuzzy[Color] {<br/>    def same(p: Double)(x1: Color, x2: Color): Boolean = -math.<em class="jt">log</em>(x1.difference(x2).whiteness) / 3 &gt; p<br/>  }<br/><br/>  implicit object FuzzyColor extends FuzzyColor<br/>}</span></pre><p id="27e2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如你所看到的，如果两种颜色的白度差值的(负)对数的三分之一大于<em class="jt"> p </em>，我们就武断地认为这两种颜色是相同的。使用这个定义，颜色(255，255，255)和颜色(242，242，242)被认为是相同的，有80%的置信度。如果我们需要100%的置信度(<em class="jt"> p </em> = 1)，那么只有完全相同的颜色才被认为是相同的。对于0%的置信度，所有颜色都是一样的。这个相当人工的例子到此为止。现在，让我们看看它是如何考虑数字的。</p><p id="c1d5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了数字的名义值，我们还存储了一些(可选的)模糊性。当没有模糊时，我们的数字是精确的。只有当两个精确的数字实际上相等时，它们才能被认为相等。但模糊数可以根据它们的不同而“相等”:既有标称值，也有概率分布函数(pdf)。</p><p id="88a0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在不深入研究这些pdf的数学的情况下，我们注意到，如果一个名义值在pdf的范围内，那么这个值就有可能是真实值。假设pdf是一个阶跃函数。它从零开始(对于非常负的值)；当它到达某个值时，概率密度变成1/ <em class="jt"> a </em>(其中<em class="jt"> a </em>是可能值的范围，也称为“容差”)；这沿着数值轴继续一段距离<em class="jt">a</em>；此后(对于更大的正值)再次以零概率。我称这个pdf为“盒子”当然，这是一个假设的pdf。但是它可能来自于例如形成随机长度(具有均匀分布)的钢钉的过程。超出公差的钉子(太短或太长)被丢弃并熔化。出现的钉子将会有一个他们的长度的pdf，像上面描述的盒子。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kj"><img src="../Images/f502cac06abff5465bfbe4fcd01fca11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9MXgxezMrTq0vioq0EPykg.png"/></div></div></figure><p id="7dc0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当两个模糊数(<em class="jt"> x +- a </em>和<em class="jt"> y +- b </em>)相减(或相加)时，得到的pdf如下所示:</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kj"><img src="../Images/d03d0e14022f670d0ab8ed9b759111d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLPGH8iNfWzEOT32eA0Bpw.png"/></div></div></figure><p id="4477" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有些武断的是，<em class="jt">号</em>没有使用这样的梯形pdf。相反，如果我们将两个数字相加，我们将它们的pdf近似为高斯(“正态”)分布。那是因为组合这样的分布是非常容易的:平均值是平均值的和(或者差，如果我们减去的话)；方差是方差的总和。</p><p id="02a0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一方面，如果我们将两个具有箱式模糊的数字相乘(或相除),如果pdf是相对于标称值的，而不是绝对的，则结果具有类似箱式的分布(宽度由输入框宽度之和给出)。这是根据简单的微积分得出的。</p><p id="2560" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，我们有四种类型的数字模糊性:绝对的或相对的；箱形或高斯形。一般来说，一旦我们将模糊数组合在一起，它们的pdf通常是高斯形式。此外，物理常数也以高斯pdf开始，例如，引力常数<em class="jt"> G: </em></p><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es kk"><img src="../Images/703dbbf1eb523793dbdbcd59f43548bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*XCo8TvDQQ88B2pa3MUPb2Q.png"/></div></figure><p id="a05c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“15”周围的括号表示最后两位小数为高斯分布，平均值为30，标准偏差为15。我将在下面描述如何输入模糊数字。在<em class="jt">常量</em>类型中定义了包括<em class="jt"> G </em>在内的多个常量。其定义如下:<em class="jt">编号(" 6.67430(15)E-11") </em>，即使用<em class="jt">应用</em>方法之一。</p><p id="357a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于二元运算(特别是乘法和乘幂)，相对pdf是最方便的。对于一元运算(例如自然对数)或加法，绝对pdf更方便。但是，当然，所有的转换和卷积都由<em class="jt">号</em>代码自动处理。</p><p id="88d7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，我们如何实现上述的<em class="jt">相同的</em>方法呢？我们取两个标称值的差，并确定该数字(<em class="jt"> x </em>)是否可以被认为是零，给出结果pdf。对于一个框型pdf(通常，只有当一个模糊数与一个精确数比较时才会产生)，我们基本上忽略了<em class="jt"> p </em>值(除非它是0或1 ),如果数字<em class="jt"> x </em>在框内，则简单地返回true(即相同)。对于高斯分布，我们使用“逆erf”函数(我们将互补概率，即1- <em class="jt"> p </em>，传递给该函数)。这有效地将高斯pdf转换成一个盒子。</p><p id="40fe" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看待这个行列式的另一种方式是，<em class="jt"> p </em>对应于零属于<strong class="ix hz">模糊集</strong>(如洛特菲·扎德的“<a class="ae hv" href="https://en.wikipedia.org/wiki/Fuzzy_logic" rel="noopener ugc nofollow" target="_blank">模糊逻辑</a>”)的概率，模糊集包含所有可能的模糊数。</p><p id="170b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我将在第2部分中描述的，一个数的名义值要么是整数，要么是有理数(基于一个<em class="jt"> BigInt </em>除以一个<em class="jt"> BigInt </em>)，要么是双精度值。如果我们必须将一个整数或有理数转换成一个双精度数，我们会在现有的模糊性上添加少量的(相对)模糊性:(1.6E-16)。</p><p id="3191" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，我们如何处理在计算中引入模糊性呢？嗯，首先，我们不随意添加模糊性。一个数字，比如黄金分割率<em class="jt"> phi </em>，是这样定义的:Number(“1.618033988749894”)。结果具有值为0.5E-15的盒子形状的绝对模糊度。这是根据定义中给出的15位小数得出的。按照惯例，只有一两位小数的字符串被认为是精确的(就像是美元和美分一样)。但是，您可以简单地通过在字符串后面加上“*”或“…”来否决这种约定。此外，如果你有一个实际上精确的数的十进制表示，那么把它表示成一个负指数的整数(至少现在，我们必须在“E”前面加一个小数点)。或者，更简单地说，只需在字符串末尾加上“00”。</p><p id="30bf" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以通过在十进制字符串后加上“[x]”或“[xx]”来使盒形模糊显式化，其中<em class="jt"> x </em>或<em class="jt"> xx </em>代表任何一个方向上的最大可能偏差。类似地，对于高斯模糊性(正如我们在上面用常数G展示的那样)，我们在十进制字符串后面加上“(x)”或“(xx)”在这种情况下,<em class="jt"> x </em>或<em class="jt"> xx </em>代表所示数字中可能差异的标准偏差。顺便说一下，模糊性必须先于任何指数。</p><p id="44d4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我下次会解释，数字π和<em class="jt"> e </em>是精确的。所以，比如你计算<em class="jt"> atan(tan(π)) </em>，结果会正好是π。同样的，如果你计算<em class="jt">e^(ln(e)】</em>结果会正好是e，然而√2这种更一般的无理数是无法精确表示的。但是，正如我在文章<strong class="ix hz"> Composable Matchers </strong>中提到的，如果你计算√2 √2，或者你将确切地返回2，但是这是通过一个叫做<strong class="ix hz"> ExpressionMatchers </strong>的机制实现的，它不在这里描述的低级别数字上操作。稍后，在第2部分中会有更多的介绍。</p><p id="e77e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，这一切有什么意义呢？在最简单的层面上，假设你有一个钟摆，比如<a class="ae hv" href="https://en.wikipedia.org/wiki/Foucault_pendulum" rel="noopener ugc nofollow" target="_blank">福柯的钟摆</a>。它非常高，测量它的长度会非常困难。然而，你可以很容易地用秒表测量周期。确定摆锤长度<em class="jt"> l </em>的公式为:</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es kl"><img src="../Images/7510aa97a42dca74355e6b7a2e8783a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*R25ws57av0fV5DQ0e5ujBQ.png"/></div></figure><p id="540a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中<em class="jt"> g </em>是摆所在位置的重力加速度。到小数点后两位，<em class="jt"> g </em> = 9.81米/秒。</p><p id="2932" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第一个场景中，我们有一个精确的秒表，但是我们忽略了百分之一秒。我们的代码如下所示:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="6f10" class="kd ke hy jz b fi kf kg l kh ki">import com.phasmidsoftware.number.core.{Expression, Number}<br/>import Number._<br/><br/>val g = <em class="jt">Number</em>("9.81*")<br/>val t = <em class="jt">Number</em>("16.5*")<br/>val length: Number = g * ((t / <em class="jt">twoPi</em>) ^ 2)</span></pre><p id="329b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要输入带星号的字符串，因为它们有一个和两个小数位，否则会被解释为精确的。我们得到的长度结果是67.65[44]。这意味着我们对前两个有效数字(67)几乎有把握，但实际值可能在67.21和68.09之间。让我们看看如何从<em class="jt"> g </em>和<em class="jt"> t </em>的不确定性中计算贡献。</p><p id="e549" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们看看两个不确定量相乘的误差界的一般公式，其中<em class="jt"> f = x y </em>(这直接来自于对<em class="jt"> f </em>的求导):</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es km"><img src="../Images/88c6f99e9ddf28b98e7068bda9eb517f.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*-kCtEQf6DC_3l_iRZ7STVQ.png"/></div></figure><p id="2680" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们将两边除以f，我们得到:</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es kn"><img src="../Images/6b48bb5e7521dd4e184f17d9aaa5a574.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*RDRW8NeyBn801t-DbFkQmQ.png"/></div></figure><p id="18ec" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着我们简单地将<em class="jt"> x </em>和<em class="jt"> y </em>的相对误差界限相加，以获得<em class="jt"> f </em>的相对误差界限。在我们上面的例子中，我们有三项:<em class="jt"> g </em>和<em class="jt"> t </em>(因为它是平方的所以是两次)。<em class="jt"> g </em>的相对误差约为0.0005，<em class="jt"> t </em>的相对误差约为0.003。因此<em class="jt"> l </em>的相对误差约为0.0065。</p><p id="1d0f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个更现实的情况是，当我们记录下钟摆摆动1000次，然后计算平均值和标准差。假设平均值为16.487，标准差为0.041秒。我们把这个量写成16.487(41)。我们现在得到的结果是67.54(35)，也就是说我们有68%的把握真实长度在67.19到67.89米之间。</p><p id="8266" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个<strong class="ix hz">号</strong>包正在开发中。这里描述的是1.0.10版本。你可以在https://github.com/rchillyard/Number找到它。在第二部分中，我将描述惰性求值机制，该机制旨在尽可能避免不必要的精度损失，例如在表达式(√3+1)(√3–1)的情况下，我们知道该表达式的精确值为2。</p></div></div>    
</body>
</html>