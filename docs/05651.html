<html>
<head>
<title>Caching — Quick Response(s)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存—快速响应</h1>
<blockquote>原文：<a href="https://medium.com/codex/caching-for-quick-response-s-d164e130a131?source=collection_archive---------7-----------------------#2022-03-19">https://medium.com/codex/caching-for-quick-response-s-d164e130a131?source=collection_archive---------7-----------------------#2022-03-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/1e3f79a331200a222c22b6ebb00bec4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jGM-Reogc6eMcBpy3ERewg.png"/></div></div></figure><div class=""/><p id="ea6c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大规模数据系统通常会收到多个获取数据的请求。这些数据可以存储在内存中，并在需要时随时检索，而不是使用数据库。如果这些数据本质上是可变的，那么它在内存中的版本很快就会过时，可能需要更新。</p><blockquote class="jo jp jq"><p id="5fcf" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">为了保持内存和数据库中数据的最终正确性，两者应保持同步。</p></blockquote><p id="f9a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有多种方法可以使这两个数据存储保持同步，并通过确保数据不陈旧来确保依赖于存储在缓存中的数据的应用程序做出正确的决策。下面描述了一些广泛使用且易于识别的模式。</p><h1 id="9be6" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">缓存在一边</h1><p id="e4e5" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">当使用<strong class="is hu">缓存在</strong>旁边时，只有当数据不在缓存中时，才从数据库中提取数据；并且随后也被推送到高速缓存，以确保对相同数据的新读取请求的快速访问。</p><blockquote class="jo jp jq"><p id="2b97" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">当使用<strong class="is hu">缓存备用</strong>策略时，应用程序享有对数据访问和存储的完全控制。</p></blockquote><figure class="kz la lb lc fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ky"><img src="../Images/b39818763453366feeb69274cc9205b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79aBEZ1eSfqj_AssmZwv_w.png"/></div></div></figure><p id="97c4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果有适当的缓存失效机制作为补充，缓存和数据库将与该策略保持完全同步。它非常适合读取量大的应用程序，在这些应用程序中，很少对数据库进行新的写入操作。</p><h1 id="8001" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">通读</h1><p id="dc17" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated"><strong class="is hu">通读</strong>策略将控制权从应用程序转移到缓存提供商。当应用程序请求数据时，缓存提供者必须返回数据。在缓存未命中的情况下，缓存提供者从数据库中检索它，更新缓存并将其返回给应用程序。<strong class="is hu">通读</strong>策略适用于读取量大的应用。</p><figure class="kz la lb lc fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/e10024d411ec871a9e71ac0807abb0a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJ58zuzLF9-iu1w-HatnrA.png"/></div></div></figure><h1 id="2070" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">直写</h1><p id="5325" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated"><strong class="is hu">直写</strong>策略将控制权从应用程序转移到缓存提供商。写入新数据的请求被发送到缓存提供程序，缓存提供程序将数据添加到缓存中，随后也添加到数据库中。在使用“直写”策略时，数据一致性仍处于检查状态，但它也会将每次写入应用到缓存中，这是许多应用程序的过度使用，尤其是那些写入量大的应用程序。</p><figure class="kz la lb lc fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es le"><img src="../Images/945daa17e32144b04b02c097225f1034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MthwP00gIANyeC8F-g-wYw.png"/></div></div></figure><blockquote class="jo jp jq"><p id="4a1a" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">根据实施情况，如果没有基于时间的驱逐机制，该策略可能还需要等效的存储。如果建立了驱逐机制，<strong class="is hu">读通</strong>策略可以有效地补充<strong class="is hu">写通</strong>并提供更好的数据一致性。两者都由缓存提供商控制，一个负责读取，另一个负责写入。</p></blockquote><h1 id="5800" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">四处写</h1><p id="6aa1" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated"><strong class="is hu">绕写</strong>策略是对<strong class="is hu">直写策略的扩展，</strong>只有当缓存中存在该数据的先前版本时，缓存中的数据才会更新。</p><blockquote class="jo jp jq"><p id="1dce" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">与<strong class="is hu">读通</strong>一起使用的<strong class="is hu">写绕</strong>策略是一个很好的选择，因为它提供了一个很好的机制来管理缓存无效和更新，这是<strong class="is hu">读通</strong>中所缺少的。</p></blockquote><figure class="kz la lb lc fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lf"><img src="../Images/b94c784bb6be944bb3c0f65eab5a40c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hlzqDi7orY2vKOXTWhYaQg.png"/></div></div></figure><h1 id="5f59" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">回复</h1><p id="8c63" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated"><strong class="is hu">写回</strong>策略是<strong class="is hu">写通</strong>的另一个扩展，不同之处在于数据是如何以批处理和机会方式被推送到数据库的。数据会立即存储在缓存中，但只有在一批写操作准备就绪时才会被推送到数据库。</p><blockquote class="jo jp jq"><p id="cd7d" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">与缓存相比，数据库中的一些数据不存在或过时，只有在数据库更新时才能被视为一致。如果在数据库上执行批量操作之前缓存关闭，也会有丢失一些数据的风险。</p></blockquote><figure class="kz la lb lc fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lg"><img src="../Images/f48f1ab984ceb2167bd85e530f6f5763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TO67ivmpCGM9HVI1v1uWug.png"/></div></div></figure><h1 id="e6f9" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">写入无效</h1><p id="0ec4" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">当数据库中的数据更新时，<strong class="is hu">写无效</strong>策略删除缓存条目。它通过管理缓存失效过程来补充<strong class="is hu">缓存备用</strong>策略。duo可以一起使用，以确保数据在两个数据存储中最终保持一致。</p><figure class="kz la lb lc fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lh"><img src="../Images/0b060d51b4ca3f708c92ca51b26f378b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_JmQyJVe7s9-vu4qn04r7A.png"/></div></div></figure></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="7544" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很大程度上取决于数据是如何被访问的？谁在访问它？从哪里来的？虽然使用像<strong class="is hu">读通</strong>和<strong class="is hu">写通</strong>这样的策略消除了编写boiler plate代码的需要，但它们也限制了应用程序对数据管理的完全控制。另一方面,<strong class="is hu">缓存备用</strong>策略为应用程序提供了更多的控制，同时从开发的角度来看需要执行更多的工作。</p><p id="e9e9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有时需要应用验证，验证哪些数据可以从缓存中存储和访问，以及由谁来访问。还可能需要在缓存中以多种格式存储相同的数据。在这种情况下，最好将控制保持在应用程序级别。</p><p id="bc0a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在缓存中保存同一数据的多个版本也是有可能的，也有一些用例。虽然有些缓存实现提供了现成的这种功能，但其他实现需要包装器来完成。我们将在另一篇文章中更多地讨论它，因为它需要自己的讨论。</p></div></div>    
</body>
</html>