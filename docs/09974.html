<html>
<head>
<title>Leetcode[36]: Valid Sudoku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Leetcode[36]:有效的数独</h1>
<blockquote>原文：<a href="https://medium.com/codex/leetcode-valid-sudoku-35e94d524823?source=collection_archive---------11-----------------------#2022-11-23">https://medium.com/codex/leetcode-valid-sudoku-35e94d524823?source=collection_archive---------11-----------------------#2022-11-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a25d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">今日报价</h2></div><blockquote class="ix"><p id="59b4" class="iy iz hi bd ja jb jc jd je jf jg jh dx translated">我是那个该死的时候就会死的人，所以让我以自己喜欢的方式生活吧。</p></blockquote><figure class="jj jk jl jm jn jo er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es ji"><img src="../Images/7ad298ef1ca9fa7e6be4fbf71be8759b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ITuJe8-5uDYPleRl"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">照片由<a class="ae jz" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ed27" class="pw-post-body-paragraph ka kb hi kc b kd ke ij kf kg kh im ki kj kk kl km kn ko kp kq kr ks kt ku jh hb bi translated">确定<code class="du kv kw kx ky b">9 x 9</code>数独板是否有效。根据以下规则，仅需要验证填充的单元格<strong class="kc hj">:</strong></p><ol class=""><li id="bdf7" class="kz la hi kc b kd ke kg kh kj lb kn lc kr ld jh le lf lg lh bi translated">每行必须包含数字<code class="du kv kw kx ky b">1-9</code>，不能重复。</li><li id="1471" class="kz la hi kc b kd li kg lj kj lk kn ll kr lm jh le lf lg lh bi translated">每一列必须包含数字<code class="du kv kw kx ky b">1-9</code>，不能重复。</li><li id="953b" class="kz la hi kc b kd li kg lj kj lk kn ll kr lm jh le lf lg lh bi translated">网格的九个<code class="du kv kw kx ky b">3 x 3</code>子框必须包含数字<code class="du kv kw kx ky b">1-9</code>，不能重复。</li></ol><p id="4a37" class="pw-post-body-paragraph ka kb hi kc b kd ke ij kf kg kh im ki kj kk kl km kn ko kp kq kr ks kt ku jh hb bi translated"><strong class="kc hj">注:</strong></p><ul class=""><li id="6b0a" class="kz la hi kc b kd ke kg kh kj lb kn lc kr ld jh ln lf lg lh bi translated">数独棋盘(部分填充)可能是有效的，但不一定是可解的。</li><li id="5367" class="kz la hi kc b kd li kg lj kj lk kn ll kr lm jh ln lf lg lh bi translated">只有填充的单元格需要根据上述规则进行验证。</li></ul><h2 id="c7ac" class="lo lp hi bd lq lr ls lt lu lv lw lx ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated">解决办法</h2><p id="e601" class="pw-post-body-paragraph ka kb hi kc b kd mj ij kf kg mk im ki kj ml kl km kn mm kp kq kr mn kt ku jh hb bi translated">我们可以把它分成三个任务</p><ol class=""><li id="d478" class="kz la hi kc b kd ke kg kh kj lb kn lc kr ld jh le lf lg lh bi translated">验证<strong class="kc hj">行</strong>(每行必须只包含一次从0到9的值)</li><li id="d252" class="kz la hi kc b kd li kg lj kj lk kn ll kr lm jh le lf lg lh bi translated">验证<strong class="kc hj">列</strong>(每个列只能包含一次从0到9的值)</li><li id="3136" class="kz la hi kc b kd li kg lj kj lk kn ll kr lm jh le lf lg lh bi translated">验证3x3 <strong class="kc hj">框</strong>(每个3x3框只能包含一次0-9的值)</li></ol><p id="d9ce" class="pw-post-body-paragraph ka kb hi kc b kd ke ij kf kg kh im ki kj kk kl km kn ko kp kq kr ks kt ku jh hb bi translated">因为我们知道棋盘中的每一个元素要么是(。)表示一个空格或“0–9”中的任何数字字符。</p><p id="411b" class="pw-post-body-paragraph ka kb hi kc b kd ke ij kf kg kh im ki kj kk kl km kn ko kp kq kr ks kt ku jh hb bi translated">所以如果我们遇到“.”我们不在乎，如果我们遇到数字字符，我们会检查我们之前是否遇到过。</p><p id="3279" class="pw-post-body-paragraph ka kb hi kc b kd ke ij kf kg kh im ki kj kk kl km kn ko kp kq kr ks kt ku jh hb bi translated">我们可以使用HashSet来检查被访问的数字字符，但是我们可以使用大小为10的布尔数组，因为我们知道每个数字字符都是“0–9”。</p><p id="eed6" class="pw-post-body-paragraph ka kb hi kc b kd ke ij kf kg kh im ki kj kk kl km kn ko kp kq kr ks kt ku jh hb bi translated">现在我们必须从数字字符中提取索引，这里我们使用一些技巧来得到它。</p><p id="7c91" class="pw-post-body-paragraph ka kb hi kc b kd ke ij kf kg kh im ki kj kk kl km kn ko kp kq kr ks kt ku jh hb bi translated">我们知道字符数字在ASCII格式中是连续的。</p><p id="bd15" class="pw-post-body-paragraph ka kb hi kc b kd ke ij kf kg kh im ki kj kk kl km kn ko kp kq kr ks kt ku jh hb bi translated">因此，如果我们尝试减去ASCII值，我们将得到相应的数字。</p><p id="a6cf" class="pw-post-body-paragraph ka kb hi kc b kd ke ij kf kg kh im ki kj kk kl km kn ko kp kq kr ks kt ku jh hb bi translated">现在让我们看看代码-</p><pre class="mo mp mq mr fd ms ky mt bn mu mv bi"><span id="0707" class="mw lp hi ky b be mx my l mz na">class Solution {<br/>    public boolean isValidSudoku(char[][] board) {<br/>        <br/>        int rowSize = 9;<br/>        int colSize = 9;<br/>        <br/>        // validate rows<br/>        for(int i=0;i&lt;rowSize;i++) {<br/>            <br/>            if(!isValidRow(board, i, colSize))<br/>                return false;<br/>        }<br/>        <br/>        // validate cols<br/>        for(int i=0;i&lt;colSize;i++) {<br/>            <br/>            if(!isValidCol(board, i, rowSize))<br/>                return false;<br/>        }<br/>        <br/>        // validate boxes<br/>        for(int i=0;i&lt;9;i+=3) {<br/>            for(int j=0;j&lt;9;j+=3) {<br/>                // i and j are the starting index of the box<br/>                if(!isValidBox(board, i, j)) <br/>                    return false;<br/>            }<br/>        }<br/>        <br/>        return true;<br/>    }<br/>    <br/>    public boolean isValidRow(char[][] board, int row, int colSize) {<br/>        <br/>        boolean[] visited = new boolean[colSize+1];<br/>        <br/>        for(int i=0;i&lt;colSize;i++) {<br/>            <br/>            if(board[row][i] == '.') continue;<br/>            <br/>            int ind = board[row][i]-'0';<br/>            <br/>            if(visited[ind]) return false;<br/>            <br/>            visited[ind] = true;<br/>        }<br/>        <br/>        return true;<br/>    }<br/>    <br/>    public boolean isValidCol(char[][] board, int col, int rowSize) {<br/>        <br/>        boolean[] visited = new boolean[rowSize+1];<br/>        <br/>        for(int i=0;i&lt;rowSize;i++) {<br/>            <br/>            if(board[i][col] == '.') continue;<br/>            <br/>            int ind = board[i][col]-'0';<br/>            <br/>            if(visited[ind]) return false;<br/>            <br/>            visited[ind] = true;<br/>        }<br/>        <br/>        return true;<br/>    }<br/>    <br/>    public boolean isValidBox(char[][] board, int row, int col) {<br/>        <br/>        boolean[] visited = new boolean[10]; // 0 - 9<br/>        <br/>        for(int i=0;i&lt;3;i++) {<br/>            for(int j=0;j&lt;3;j++) {<br/>                <br/>                if(board[row+i][col+j] == '.') continue;<br/>                <br/>                int ind = board[row+i][col+j]-'0';<br/>                <br/>                if(visited[ind]) return false;<br/>                <br/>                visited[ind] = true;<br/>            }<br/>        }<br/>        <br/>        return true;<br/>    }<br/>}</span></pre><h2 id="112e" class="lo lp hi bd lq lr ls lt lu lv lw lx ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated">摘要</h2><p id="cf9c" class="pw-post-body-paragraph ka kb hi kc b kd mj ij kf kg mk im ki kj ml kl km kn mm kp kq kr mn kt ku jh hb bi translated">在整个代码中，只有一件事对我来说很重要，那就是使用布尔数组来检查以前访问过的字符。(仅我的观点)。</p></div><div class="ab cl nb nc gp nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hb hc hd he hf"><h2 id="d8e6" class="lo lp hi bd lq lr ls lt lu lv lw lx ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated">谢谢大家(来自一个非常内向的男孩)</h2></div></div>    
</body>
</html>