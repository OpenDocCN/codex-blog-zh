<html>
<head>
<title>A Complete Beginners Guide for React.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React.js初学者完全指南</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-complete-beginners-guide-for-react-js-852d3e4bae85?source=collection_archive---------12-----------------------#2021-03-30">https://medium.com/codex/a-complete-beginners-guide-for-react-js-852d3e4bae85?source=collection_archive---------12-----------------------#2021-03-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="fa55" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">10分钟内开始使用React.js</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/501c2dd07c1ef3f2e797f550032abd91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2VEFJtXT6-JBhxC0rcmNiA.jpeg"/></div></div></figure><h1 id="c103" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">目录</h1><ol class=""><li id="d52b" class="kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><em class="kt">什么是反应？</em></li><li id="ac05" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko kp kq kr ks bi translated"><em class="kt">为什么学反应？</em></li><li id="88d5" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko kp kq kr ks bi translated"><em class="kt">入门指南！！</em></li><li id="188d" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko kp kq kr ks bi translated"><em class="kt">文件夹结构</em></li><li id="2092" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko kp kq kr ks bi translated"><em class="kt">你需要知道的基本概念</em></li><li id="07bc" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko kp kq kr ks bi translated"><em class="kt">结论</em></li></ol></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="dff9" class="jj jk hi bd jl jm lg jo jp jq lh js jt io li ip jv ir lj is jx iu lk iv jz ka bi translated">什么是反应？</h1><ul class=""><li id="abc3" class="kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko ll kq kr ks bi translated"><em class="kt"> React是一个开源的</em> <strong class="kd hj"> <em class="kt">库</em> </strong> <em class="kt">用于构建用户界面。</em></li><li id="88e9" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated"><em class="kt"> React不是一个</em> <strong class="kd hj">框架</strong> <em class="kt">。</em></li><li id="1794" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated"><em class="kt">其唯一的重点是开发</em> <strong class="kd hj"> <em class="kt"> UI </em> </strong> <em class="kt">界面。</em></li><li id="b340" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated">React不支持路由或HTTP请求，因为它只关注UI。但是React可以毫不费力地与提供所需特性的其他库集成。</li><li id="82b2" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated"><em class="kt"> React由</em> <strong class="kd hj"> <em class="kt">脸书</em> </strong> <em class="kt">创建并维护，拥有庞大的社区。</em></li></ul><h1 id="e3a4" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">为什么要反应？</h1><ul class=""><li id="7e09" class="kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko ll kq kr ks bi translated">React有一个基于组件的架构。</li><li id="151a" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated">React对于编写可重用代码非常有用。</li><li id="79c3" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated">React本质上是声明性的，这意味着我们从不与DOM交互，当我们改变状态时，UI会更新。</li><li id="8fd1" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated"><em class="kt"> React可以轻松集成到任何应用程序中。</em></li><li id="bb15" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated"><em class="kt"> React可用于开发单个组件、页面或整个应用程序。</em></li></ul></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="4dcb" class="jj jk hi bd jl jm lg jo jp jq lh js jt io li ip jv ir lj is jx iu lk iv jz ka bi translated"><em class="lm">‘这个’</em>关键字</h1><blockquote class="ln lo lp"><p id="fe2d" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated"><strong class="kd hj">‘this’</strong>关键字会一次又一次的不断弹出，清楚的理解react和js中的用法很重要。</p><p id="6e9a" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated"><strong class="kd hj">“this”关键字通常引用JavaScript元素，这取决于其使用的范围或上下文。</strong></p><p id="82c4" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">参考本文:<a class="ae mi" rel="noopener" href="/byte-sized-react/what-is-this-in-react-25c62c31480">https://medium . com/byte-size-react/what-is-this-in-react-25 c62c 31480</a></p></blockquote></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="1f76" class="jj jk hi bd jl jm lg jo jp jq lh js jt io li ip jv ir lj is jx iu lk iv jz ka bi translated">开始</h1><p id="fa5f" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated"><em class="kt">开始使用React你所需要的只是</em><a class="ae mi" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"><em class="kt">node . js</em></a><em class="kt">和你选择的文本编辑器。</em></p><p id="fbbd" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">开始使用React的最好方法是使用<code class="du mm mn mo mp b">create-react-app </code> npm包，它帮助你用所有必要的文件和配置建立全新的React项目。</p><pre class="iy iz ja jb fd mq mp mr ms aw mt bi"><span id="87f5" class="mu jk hi mp b fi mv mw l mx my">npm install -g create-react-app<br/>create-react-app helloworld</span><span id="1b6c" class="mu jk hi mp b fi mz mw l mx my">or</span><span id="de19" class="mu jk hi mp b fi mz mw l mx my">npx create-react-app helloworld</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es na"><img src="../Images/5260b6dffc342009b5788a8ad553c418.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*PCK1P4Jn_cr43pD1NqrfMQ.png"/></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">生成的文件</figcaption></figure><p id="9fb2" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">从创建的项目运行<code class="du mm mn mo mp b">npm start</code>来服务默认网页。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nf"><img src="../Images/306a5941c64afb80fac074c673c4381d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cpoK-USJER1KoYl-JWinRg.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">react的默认服务端口是3000</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/ad9f5f7d18ff7a57b4de19ef584892ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXSo5p3i_9nCFLhJZY6EiQ.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">create-react-app附带的默认页面</figcaption></figure></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="168b" class="jj jk hi bd jl jm lg jo jp jq lh js jt io li ip jv ir lj is jx iu lk iv jz ka bi translated">文件夹结构</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es na"><img src="../Images/5260b6dffc342009b5788a8ad553c418.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*PCK1P4Jn_cr43pD1NqrfMQ.png"/></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">生成的文件</figcaption></figure><p id="477b" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated"><strong class="kd hj"> package.json : </strong>它保存了关于项目的元数据。配置对工作区中所有项目都可用的<a class="ae mi" href="https://angular.io/guide/npm-packages" rel="noopener ugc nofollow" target="_blank"> npm包依赖关系</a>。</p><p id="0fd6" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated"><strong class="kd hj"> node_modules: </strong>安装所有需要的依赖项的地方。</p><h2 id="f361" class="mu jk hi bd jl nh ni nj jp nk nl nm jt ki nn no jv kk np nq jx km nr ns jz nt bi translated"><strong class="ak">/公共:</strong></h2><ul class=""><li id="44c8" class="kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko ll kq kr ks bi translated"><strong class="kd hj"> manifest.json : </strong>创建React App的PWA <em class="kt">(渐进式Web应用)</em>时需要这个文件。<em class="kt">(参考官方文档:</em><a class="ae mi" href="https://create-react-app.dev/docs/making-a-progressive-web-app/" rel="noopener ugc nofollow" target="_blank"><em class="kt">https://create-react-app . dev/docs/making-a-progressive-we b-app/</em></a><em class="kt">)。</em></li><li id="e36a" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated"><strong class="kd hj">index.html:</strong>它是我们网页的入口点，body标签里只有一个id='root '的div标签。它引用了React应用程序中的根组件。</li></ul><h2 id="aa96" class="mu jk hi bd jl nh ni nj jp nk nl nm jt ki nn no jv kk np nq jx km nr ns jz nt bi translated"><strong class="ak"> /src: </strong></h2><ul class=""><li id="6482" class="kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko ll kq kr ks bi translated">这是一个非常重要的文件夹，你可以在这里编写React应用的所有源代码。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nu"><img src="../Images/90d8b1a4e6c5427e65d5f484c1ec1187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zc2ZzWMx1YMcSchQAr1SdA.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">索引. js</figcaption></figure><p id="6acc" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated"><strong class="kd hj"> index.js: </strong>它是我们React应用程序的入口点，使用<code class="du mm mn mo mp b">react-dom</code>，我们在index.html文件中id为‘root’的&lt; div &gt;中呈现我们的React应用程序。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nv"><img src="../Images/013288bc9ccdc86573e111343fa40891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E5EMinJJNlSO1i-Cj7dPug.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">App.js</figcaption></figure><p id="1321" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">这是我们React应用程序的根组件。<code class="du mm mn mo mp b">create-react-app</code>我已经为你开发了一个虚拟页面。<em class="kt">(此处引用App.css文件，其中包含App组件的所有样式)。</em></p><blockquote class="ln lo lp"><p id="1476" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">你一定注意到在App.js中返回了JSX，而不是在标记中使用' class '属性，而是使用了' className '。这是因为class是React中的一个保留关键字，它用于声明一个JS类，所以用className代替，它的作用是一样的。</p></blockquote></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><blockquote class="ln lo lp"><p id="8f17" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">在开始开发你的应用程序之前，删除所有<code class="du mm mn mo mp b">create-react-app</code>生成的多余文件和代码。</p><p id="d8cf" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">删除<strong class="kd hj">logo192.png</strong>和<strong class="kd hj">logo512.png</strong>、<strong class="kd hj"> logo.svg </strong>文件及其声明&amp;清空<strong class="kd hj"> App.css </strong>并使<strong class="kd hj"> App.js </strong>文件中的函数App返回<code class="du mm mn mo mp b">&lt;div&gt;&lt;/div&gt;</code></p></blockquote></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="2398" class="jj jk hi bd jl jm lg jo jp jq lh js jt io li ip jv ir lj is jx iu lk iv jz ka bi translated">你需要知道的基本概念</h1><ul class=""><li id="2d13" class="kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko ll kq kr ks bi translated"><em class="kt"> JSX </em></li><li id="4811" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated"><em class="kt">组件:类组件&amp;功能组件</em></li><li id="e748" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated"><em class="kt">道具</em></li><li id="c730" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated"><em class="kt">状态</em></li><li id="d5f1" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated"><em class="kt">事件处理</em></li><li id="1e9d" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated"><em class="kt">绑定事件处理程序</em></li><li id="cb32" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated"><em class="kt">组件生命周期方法</em></li></ul><h1 id="1025" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">JSX</h1><p id="00eb" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated">JavaScript XML (JSX)是JavaScript语言语法的扩展，我们使用JSX来编写React中的元素和组件。</p><p id="8b6a" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">JSX不是使用React的必要条件，每个JSX元素只是调用<code class="du mm mn mo mp b">React.createElement(component, props, ...children)</code>的语法糖</p><p id="cc08" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">JSX使代码更加简洁。</p><blockquote class="ln lo lp"><p id="310f" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">参考此文件:<a class="ae mi" href="https://reactjs.org/docs/react-without-jsx.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/react-without-jsx.html</a></p></blockquote></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="0ae4" class="jj jk hi bd jl jm lg jo jp jq lh js jt io li ip jv ir lj is jx iu lk iv jz ka bi translated">成分</h1><p id="04bb" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated">组件代表用户界面的一部分，组件就像返回React元素的JavaScript函数。我们构建的所有组件都包含在根组件中。</p><p id="efe3" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">带有App function的App.js表示根组件，它导出由index.js文件导入并声明为<code class="du mm mn mo mp b"><strong class="kd hj">&lt;App/&gt;</strong></code>的App组件，该组件由App函数返回的JSX替换。</p><h2 id="22d1" class="mu jk hi bd jl nh ni nj jp nk nl nm jt ki nn no jv kk np nq jx km nr ns jz nt bi translated"><strong class="ak">功能组件或无状态组件</strong></h2><p id="4155" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated">顾名思义，它本质上是无状态的，工作方式类似于JavaScript函数，它可能需要一些输入并返回描述UI的JSX。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nw"><img src="../Images/0c48f81cb00bdca177a88ddad11d2ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*IwMYZuNZDastOekzLQfaKA.png"/></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">在src文件夹中创建一个文件<strong class="bd jl"> HelloFunction.js </strong></figcaption></figure><p id="96e6" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">这个HelloFunction()返回<code class="du mm mn mo mp b">&lt;h1&gt;My First React App.&lt;/h1&gt;</code>，在App.js中导入这个函数并添加标签<code class="du mm mn mo mp b">&lt;HelloFunction/&gt;</code></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nx"><img src="../Images/f408c1441405362dccf93606c1238057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*UaE4c4PuF42I3u_Nd71UgQ.png"/></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">App.js</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ny"><img src="../Images/54e2ede49134315e91ca5243adf96d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EndV0nGRArMJlU_HFV-ReQ.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">线代表由<HelloFunction/>引起的变化</figcaption></figure><blockquote class="ln lo lp"><p id="e097" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">功能组件是无状态的，这意味着它们不能记忆或保留并反映数据的变化，响应只反映功能输入的变化。</p><p id="05d4" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">从React 16.8版本开始，React钩子被添加进来，为功能组件提供一些状态。参考:<a class="ae mi" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-intro.html</a></p></blockquote><h2 id="b9f3" class="mu jk hi bd jl nh ni nj jp nk nl nm jt ki nn no jv kk np nq jx km nr ns jz nt bi translated"><strong class="ak">类组件或有状态组件</strong></h2><p id="5f86" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated">顾名思义，它本质上是有状态的，这意味着它有一些独立的状态，状态通常代表数据。这是一个JS类，扩展了React。组件类，并且必须包含返回JSX的呈现方法。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nz"><img src="../Images/ca5f0435da7b9276b41050bceba12691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*9NOL0qkxdYF0xpqoFdB3pw.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">在sr文件夹中创建HelloClassComponent.js</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oa"><img src="../Images/ab5e1a0b16f7aa77e66d8a814c8bb85e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*OoUP70UxxBy_lSpqfhIfvQ.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">在App.js中导入HelloClassComponent</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ob"><img src="../Images/310cbe7485e6baa3182748df8f150018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Xxq88xSibKpjdWr4pcl6A.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">第二行代表由<HelloClassComponent/>引起的变化</figcaption></figure></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="dc7d" class="jj jk hi bd jl jm lg jo jp jq lh js jt io li ip jv ir lj is jx iu lk iv jz ka bi translated"><strong class="ak">道具</strong></h1><p id="0cce" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated">Props是指传递给函数或类组件的参数。道具本质上是不可变的。组件是在考虑可重用性的情况下构建的，所以如果你复制粘贴<code class="du mm mn mo mp b">&lt;HelloFunction/&gt;</code> 10次，你会看到“我的第一个React应用”10次作为输出。</p><p id="425d" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">但是你可能想在不同的时间打印不同的文本，因此props进入图片，我们只需将文本作为props传递给组件，它将由该组件呈现。这将节省大量的时间，因为你不必创建10个不同的组件，这是相同的，但不同的数据。</p><p id="70d7" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">Props可以作为属性传递给组件的标签。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oc"><img src="../Images/0ca8f476ad701e96e50e0972de3c589d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxvuGQ5cPnw_il7W8ZNwPw.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">向组件添加属性msg和message。</figcaption></figure><p id="67c2" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">现在，在传递了props之后，需要在组件中处理它。功能组件直接接收函数的参数。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es od"><img src="../Images/319742a89630189d248beba1af4349c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*Cz5Eh0Vyb3ExdZBBf5nz1A.png"/></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">在功能组件中处理道具。</figcaption></figure><blockquote class="ln lo lp"><p id="62cd" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">花括号{}是计算JavaScript表达式的特殊JSX语法，因此,<code class="du mm mn mo mp b">props.message</code>的值被计算并替换为表达式。</p></blockquote><p id="3e4f" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">在类组件中，属性是在构造函数中接收的，当我们扩展React时，必须从构造函数中调用super(props)。组件类。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oe"><img src="../Images/c723715892cf1b3a52a1f70c8e8b7999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*w9stvfIYa85Z8YWAIM6srw.png"/></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">处理类组件中的道具。</figcaption></figure><blockquote class="ln lo lp"><p id="9e92" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">“this”关键字用于访问类组件的props对象。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es of"><img src="../Images/438cff5c76be4ea1e4daa0bb74480dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xt9DaRegrwpv-a1SvHTzAA.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">通过道具后输出。</figcaption></figure></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="84f3" class="jj jk hi bd jl jm lg jo jp jq lh js jt io li ip jv ir lj is jx iu lk iv jz ka bi translated"><strong class="ak">状态</strong></h1><p id="0ad3" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated">状态在组件中被管理，本质上是不可变的，用于存储可变数据，状态只是影响组件中UI的数据。</p><p id="bb0d" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">状态使得React成为一个非常强大的工具。理解状态对于React非常重要，因为一切都是围绕它旋转的。</p><p id="63de" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">在类组件中State对象可以在构造函数中初始化，State是Json对象的键值对数据，它一旦初始化就只能通过<strong class="kd hj"> setState函数来改变。</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="og oh l"/></div></figure><blockquote class="ln lo lp"><p id="e7f2" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">我们必须在div中包含两个h3标记的原因是因为在React中只能返回一个元素。</p><p id="de01" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">多余的“div”标签很麻烦，因为它毫无理由地增加了复杂性，因为这个<code class="du mm mn mo mp b">&lt;React.Fragment&gt;</code>标签可以用来包含所有元素，而不需要DOM的额外节点。</p><p id="195c" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">参考号:<a class="ae mi" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/fragments.html</a></p></blockquote><p id="89b6" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">让我们添加一个按钮来更改状态值(React中的事件处理将在下一节中适当解释。)</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="og oh l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oi"><img src="../Images/5536d6182a8c3e40f0845fa40dec9a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/1*R5eqRU9mOksMwyGiHrOX_Q.gif"/></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">输出</figcaption></figure><blockquote class="ln lo lp"><p id="bfbf" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">状态也可以在函数组件中使用，使用React 16.8更新中引入的钩子，你可以在<a class="ae mi" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-intro.html</a>上找到更多</p></blockquote></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="7890" class="jj jk hi bd jl jm lg jo jp jq lh js jt io li ip jv ir lj is jx iu lk iv jz ka bi translated"><strong class="ak">事件处理</strong></h1><p id="d3d7" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated">React中的事件处理非常简单，您可以声明一个需要调用的函数，并将该函数分配给标签中的事件，让我们看看功能组件和类组件的按钮中的<strong class="kd hj"> click </strong> event。</p><h2 id="4c96" class="mu jk hi bd jl nh ni nj jp nk nl nm jt ki nn no jv kk np nq jx km nr ns jz nt bi translated"><strong class="ak">在功能组件</strong>中</h2><p id="52cb" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated">我们将创建一个新的函数组件EventFunction.js，它返回一个按钮</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oj"><img src="../Images/36a1c709d3fca5aa11d1dc44cf7aa227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*DqjNiAwsjyE_L8o_Ws5D-Q.png"/></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">事件函数. js</figcaption></figure><p id="6a22" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">创建一个新的函数handleClick()，它将在按钮单击时被调用，然后将按钮标记的属性“on click”赋给“handleClick”</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="og oh l"/></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">不要忘记在App.js文件中导入和添加EventFunction</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ok"><img src="../Images/48f5c9706df516c0cd69fce32502bda8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eYW8F-h3ph1TF2VVFdBPWw.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">按钮点击处理记录</figcaption></figure><blockquote class="ln lo lp"><p id="9494" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">注意:在将函数传递或分配给事件<code class="du mm mn mo mp b">&lt;button <strong class="kd hj">onClick={handleClick}</strong>&gt;Click Me&lt;/button&gt;</code>时不要加括号，<strong class="kd hj"> handleClick </strong>是对将被分配给onClick事件并分别调用的函数的引用，而<strong class="kd hj"> handleClick() </strong>是在加载时自己调用该函数，因此您会发现在页面加载时已经记录了消息。</p><p id="fec5" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">React也遵循基于<strong class="kd hj"> camelCasing </strong>命名convection hense它的onclick而不是onClick</p></blockquote><h2 id="c760" class="mu jk hi bd jl nh ni nj jp nk nl nm jt ki nn no jv kk np nq jx km nr ns jz nt bi translated"><strong class="ak">在类组件</strong></h2><p id="5b3d" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated">事件处理的过程是相同的，但是要引用handleFunction，我们必须使用'<strong class="kd hj"> this </strong>'关键字。</p><p id="e35d" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated"><code class="du mm mn mo mp b"><strong class="kd hj">&lt;button onClick={this.handleClick}&gt;Click Me&lt;/button&gt;</strong></code></p></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="87fc" class="jj jk hi bd jl jm lg jo jp jq lh js jt io li ip jv ir lj is jx iu lk iv jz ka bi translated">事件绑定处理程序</h1><p id="cc2d" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated">React类组件中事件绑定的原因完全是由于JS中的“this”关键字行为。</p><p id="2d78" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">简而言之，当我们需要从被调用的函数中访问类上下文(“this”关键字)时，就必须用类上下文本身来调用函数。因此，在将事件处理程序分配给事件之前，我们需要将它们与类本身绑定在一起。</p><p id="e41b" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">在src文件夹中创建一个新文件EventClassComponent.js，并将其添加到App.js中。</p><p id="07fd" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated"><strong class="kd hj">有3种方法可以绑定一个函数。</strong></p><ul class=""><li id="631a" class="kb kc hi kd b ke ls kg lu ki ol kk om km on ko ll kq kr ks bi translated">在呈现方法本身中绑定方法。</li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="og oh l"/></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">点击按钮时，消息将变为“点击处理”</figcaption></figure><blockquote class="ln lo lp"><p id="0d0c" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">缺点:对于每个状态变化，render函数在React中被调用，React又创建一个新的有界函数，并将其分配给事件。随着项目规模的增长，这种开销会很麻烦。</p></blockquote><ul class=""><li id="f851" class="kb kc hi kd b ke ls kg lu ki ol kk om km on ko ll kq kr ks bi translated">使用箭头函数作为类属性</li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="og oh l"/></div></figure><blockquote class="ln lo lp"><p id="6287" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">改变声明函数的方式，这是React文档指南推荐的方法，并且非常简单</p></blockquote><ul class=""><li id="6f33" class="kb kc hi kd b ke ls kg lu ki ol kk om km on ko ll kq kr ks bi translated">构造函数本身的绑定</li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="og oh l"/></div></figure><blockquote class="ln lo lp"><p id="323d" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">但是这里仍然有一个问题，如果你想传递参数给函数呢</p></blockquote><ul class=""><li id="2948" class="kb kc hi kd b ke ls kg lu ki ol kk om km on ko ll kq kr ks bi translated">调用箭头函数体中的事件处理程序</li></ul><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="og oh l"/></div></figure><blockquote class="ln lo lp"><p id="b306" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">注意函数的括号是存在的，通过这个方法你不需要调用事件。绑定(this)函数，甚至可以向函数传递参数。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oo"><img src="../Images/54181b23b2d93513542ec9476dd11658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*d9tRAg7kiGucqQkNNMB7bQ.gif"/></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">输出</figcaption></figure></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="b4eb" class="jj jk hi bd jl jm lg jo jp jq lh js jt io li ip jv ir lj is jx iu lk iv jz ka bi translated">组件生命周期方法</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es op"><img src="../Images/396218d609300477f924fc6a7d9711aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9-lNAR9xLMhjG9HJSL6rCQ.png"/></div></div><figcaption class="nb nc et er es nd ne bd b be z dx translated">组件生命周期</figcaption></figure><p id="b2ba" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">每个组件都有几个“生命周期方法”,您可以根据组件的生命周期状态，将它们覆盖到运行代码的位置。组件的生命周期可以分为三个部分1。安装2。更新3。卸载</p><h2 id="9e55" class="mu jk hi bd jl nh ni nj jp nk nl nm jt ki nn no jv kk np nq jx km nr ns jz nt bi translated"><strong class="ak">安装</strong></h2><p id="d26b" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated">当一个组件的实例被创建并插入DOM时</p><ul class=""><li id="e6e3" class="kb kc hi kd b ke ls kg lu ki ol kk om km on ko ll kq kr ks bi translated">构造函数()</li><li id="cc00" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated">静态getDerivedStateFromProps()</li><li id="4afa" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated">渲染()</li><li id="a105" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated">componentDidMount()</li></ul><blockquote class="ln lo lp"><p id="af7b" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated"><strong class="kd hj">构造函数、呈现函数</strong>和<strong class="kd hj">组件装载函数</strong>通常被覆盖，<strong class="kd hj">构造函数</strong>被覆盖以允许道具和初始化状态和其他变量，<strong class="kd hj">呈现函数</strong>被覆盖以返回JSX元素，<strong class="kd hj">组件装载函数</strong>该方法在组件成功装载/加载时被调用，这是发出HTTP请求的最佳时机</p></blockquote><h2 id="e606" class="mu jk hi bd jl nh ni nj jp nk nl nm jt ki nn no jv kk np nq jx km nr ns jz nt bi translated"><strong class="ak">更新</strong></h2><p id="9cfc" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated">当道具或状态发生一些变化时，就会触发更新</p><ul class=""><li id="8112" class="kb kc hi kd b ke ls kg lu ki ol kk om km on ko ll kq kr ks bi translated">静态getDerivedStateFromProps()</li><li id="5932" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated">shouldComponentUpdate()</li><li id="96b6" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated">渲染()</li><li id="3571" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated">getSnapshotBeforeUpdate()</li><li id="a53b" class="kb kc hi kd b ke ku kg kv ki kw kk kx km ky ko ll kq kr ks bi translated">componentDidUpdate()</li></ul><blockquote class="ln lo lp"><p id="e05b" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated"><strong class="kd hj"> render </strong>和<strong class="kd hj"> componentDidUpdate </strong>函数通常会被覆盖，<strong class="kd hj"> render </strong>被覆盖以返回更新后的JSX元素，<strong class="kd hj"> componentDidUpdate </strong>该方法在组件成功更新并且可以执行包括HTTP请求在内的更新后流程时被调用。</p></blockquote><h2 id="8c9f" class="mu jk hi bd jl nh ni nj jp nk nl nm jt ki nn no jv kk np nq jx km nr ns jz nt bi translated"><strong class="ak">卸载</strong></h2><p id="f41d" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated">当组件从DOM中移除时。</p><ul class=""><li id="d9ea" class="kb kc hi kd b ke ls kg lu ki ol kk om km on ko ll kq kr ks bi translated">componentWillUnmount()</li></ul><blockquote class="ln lo lp"><p id="b4c7" class="lq lr kt kd b ke ls ij lt kg lu im lv lw lx ly lz ma mb mc md me mf mg mh ko hb bi translated">当组件从DOM中移除时，调用此方法。用这种方法可以释放变量、取消订阅服务、停止线程。</p></blockquote></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><h1 id="9e42" class="jj jk hi bd jl jm lg jo jp jq lh js jt io li ip jv ir lj is jx iu lk iv jz ka bi translated"><em class="lm">结论</em></h1><p id="7808" class="pw-post-body-paragraph lq lr hi kd b ke kf ij lt kg kh im lv ki mj ly lz kk mk mc md km ml mg mh ko hb bi translated"><em class="kt"> React是一个非常棒的UI开发库，</em> <strong class="kd hj"> <em class="kt">它将一直存在，</em> </strong> <em class="kt"> React非常稳定，并被许多公司列为科技公司，如优步、Airbnb、网飞，当然还有脸书:)，它的灵活性和易于集成使其成为首选。</em></p><p id="3af6" class="pw-post-body-paragraph lq lr hi kd b ke ls ij lt kg lu im lv ki lx ly lz kk mb mc md km mf mg mh ko hb bi translated">我希望这篇文章能帮助你开始React.js之旅。</p><h2 id="71e7" class="mu jk hi bd jl nh ni nj jp nk nl nm jt ki nn no jv kk np nq jx km nr ns jz nt bi translated"><strong class="ak"> <em class="lm">留一拍手</em> </strong>👏<strong class="ak"> <em class="lm">，跟随更多</em> </strong>🔥<strong class="ak"> <em class="lm">和</em>保持学习</strong>🤓</h2></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><div class="iy iz ja jb fd oq"><a href="https://mayankpatel99.medium.com/node-js-express-a-beginners-guide-edf205316ae9" rel="noopener follow" target="_blank"><div class="or ab dw"><div class="os ab ot cl cj ou"><h2 class="bd hj fi z dy ov ea eb ow ed ef hh bi translated">Node.js + Express |初学者指南</h2><div class="ox l"><h3 class="bd b fi z dy ov ea eb ow ed ef dx translated">在10分钟内编写第一个Node.js服务器应用程序</h3></div><div class="oy l"><p class="bd b fp z dy ov ea eb ow ed ef dx translated">mayankpatel99.medium.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe jh oq"/></div></div></a></div></div></div>    
</body>
</html>