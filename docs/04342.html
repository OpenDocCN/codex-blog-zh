<html>
<head>
<title>Make your query better</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你的查询更好</h1>
<blockquote>原文：<a href="https://medium.com/codex/make-your-query-better-4c1ae9cc2b7e?source=collection_archive---------9-----------------------#2021-11-22">https://medium.com/codex/make-your-query-better-4c1ae9cc2b7e?source=collection_archive---------9-----------------------#2021-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="385e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">SQL性能提示和技巧</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/0cddea44232075e3084da2773601a86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oCOD7CFCHI8MqP0p"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">伊恩·巴塔格利亚在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="92f3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">SQL代表结构化查询语言。这种查询语言允许您访问和操作数据库。</p><p id="4bc9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将执行不同的查询来获取所需的数据。</p><p id="ff9b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">每一个应用程序或项目，甚至是一个小项目，都将其数据存储在一些数据库中。数据库很容易成为应用程序的性能瓶颈。</p><p id="c76e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本文中，我将介绍几种快速简单的方法，让您的查询更快。</p><p id="f921" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本文中，我假设您正在使用PostgreSQL数据库，但是所有这些技巧都可以在任何关系数据库中很好地执行，并且适用于SQL和数据库标准。</p><h2 id="a89c" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated"><strong class="ak">我们将在本文中看到的提示是:</strong></h2><ul class=""><li id="398a" class="lf lg hi jq b jr lh ju li jx lj kb lk kf ll kj lm ln lo lp bi translated">用<strong class="jq hj">解释检查自己。</strong></li><li id="894f" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">SQL子句<strong class="jq hj">的执行顺序。</strong></li><li id="1511" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">表<strong class="jq hj">分区</strong>。</li><li id="b67c" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated"><strong class="jq hj">索引</strong>您的数据。</li><li id="ebaa" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated"><strong class="jq hj">窗口功能</strong>。</li><li id="d9f5" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">特殊<strong class="jq hj">数据类型</strong>。</li></ul><h1 id="e5f5" class="lv kl hi bd km lw lx ly kq lz ma mb ku io mc ip kx ir md is la iu me iv ld mf bi translated">总是检查你的疑问</h1><p id="1c61" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx mg jz ka kb mh kd ke kf mi kh ki kj hb bi translated">在编写完查询之后，甚至在开始修复SQL和表结构之前对一个有性能问题的旧查询进行处理，您可能想知道DB究竟是如何一步一步地运行这个查询的。</p><p id="e689" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">EXPLAIN语句应该就是这样做的。EXPLAIN语句返回PostgreSQL规划器为给定语句生成的执行计划。</p><p id="b5d7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该语句显示了如何通过索引扫描或顺序扫描来扫描表，以及使用了哪些表，将使用哪种连接算法，等等。</p><p id="8be2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">EXPLAIN语句返回的一些有用数据是开始成本(在返回结果之前)、查询的总成本、扫描执行计划中每个阶段的估计行数以及这些行的加载大小。</p><p id="629a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="mj">例如:</em></p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="4093" class="kk kl hi ml b fi mp mq l mr ms">EXPLAIN SELECT * FROM film;</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mt"><img src="../Images/b64858dcb1abb23eb59ef754cb04c88d.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*I1PQd5vb3p6PNlFKlVB-Cg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">简单扫描示例</figcaption></figure><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="69b7" class="kk kl hi ml b fi mp mq l mr ms">EXPLAIN SELECT * FROM film WHERE film_id = 100;</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mu"><img src="../Images/ab12a70856c81e25f176219e5b8adeb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*4Rg3ETJGuQlIhuZYCakLcw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">简单扫描示例</figcaption></figure><h1 id="fedd" class="lv kl hi bd km lw lx ly kq lz ma mb ku io mc ip kx ir md is la iu me iv ld mf bi translated">提高性能的SQL执行顺序</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mv"><img src="../Images/420243242ba3d0876a5d9ff3f95d24b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*WlPyDCeErgvT6cx7H9HGoA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">条款执行顺序</figcaption></figure><p id="c671" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">SQL有很多子句，每个子句执行不同的功能，例如:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mw"><img src="../Images/d959bc9677ce6d18d04354112959a202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*1vz3oxb1hdyrov0H17IAvg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">子句命令表</figcaption></figure><p id="19de" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">子句函数以特定的顺序执行，并对到目前为止收集的数据执行。</p><p id="99e9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了获得更好的性能，我们希望在尽可能少的行上执行每个子句函数。</p><p id="1eb3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，我们希望在过滤后对数据进行排序，以便减少数据行的排序。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mx"><img src="../Images/77b0c29ff863fbcf6248b5383c4973ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B5IVKA4k67VIL4ECMLHsYw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">条款执行顺序</figcaption></figure><p id="3076" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">FROM和JOIN首先执行，因为它们收集我们在查询中处理的整个数据集。然后WHERE子句应该过滤数据，只留给我们相关的数据。只有这样，我们才能选择并排序我们想要返回的数据。</p><h1 id="282d" class="lv kl hi bd km lw lx ly kq lz ma mb ku io mc ip kx ir md is la iu me iv ld mf bi translated">对数据进行分区</h1><p id="88a0" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx mg jz ka kb mh kd ke kf mi kh ki kj hb bi translated">您的表可以存储大量数据，并且非常大，但通常在大型表上，您只需要这些数据的特定部分。</p><p id="f0bb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们假设您有一个GPS跟踪表，并且您想每次只查询您所在城市的GPS轨迹，但仍然存储所有其他数据。在这种情况下，您的查询将加载所有的表，然后过滤数据，但是如果过滤器是经常使用的，并且表非常大，为什么我们每次都要加载整个表，对于这种情况，我们可以使用分区。</p><p id="367f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我们将表分割成分区，一个用于我们的城市，另一个用于其他城市，从现在起，每次运行查询时，它将只加载数据少得多的特定分区。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es my"><img src="../Images/5c637dc4bd1adefa46a28fa476d1519a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*S2WUo_vmIR3GaTsYP6Cvyg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">使用分区示例创建表</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mz"><img src="../Images/93bcf00e27f611e5701fb124403dbad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*2vk62nqgw-rHWgbvHMvKwg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">创建表分区示例</figcaption></figure><p id="f589" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过分区，DB将一个大表分割成更小的物理块。</p><h2 id="1457" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated"><strong class="ak">分区提供了几个好处:</strong></h2><ul class=""><li id="e6bd" class="lf lg hi jq b jr lh ju li jx lj kb lk kf ll kj lm ln lo lp bi translated">在某些情况下，通过减小索引大小，可以显著提高查询性能</li><li id="da9e" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">当查询或更新经常(大量使用)使用单个分区时，可以通过利用对该分区的顺序扫描而不是访问整个表来提高性能。</li><li id="7b88" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">批量加载和删除可以通过添加或删除分区来完成，比批量操作要快。这些命令(add partition和removing one)也完全避免了由批量删除导致的真空开销。</li><li id="0a15" class="lf lg hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">很少使用的数据可以迁移到更便宜、更慢的存储介质上(如s3)。</li></ul><h1 id="d764" class="lv kl hi bd km lw lx ly kq lz ma mb ku io mc ip kx ir md is la iu me iv ld mf bi translated">索引您的数据</h1><p id="fe0a" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx mg jz ka kb mh kd ke kf mi kh ki kj hb bi translated">索引是提高数据库性能的常用方法。索引允许DB服务器更快地查找和检索特定的行。但是索引也会增加整个数据库系统的开销，所以应该明智地使用它们。</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="515f" class="kk kl hi ml b fi mp mq l mr ms">EXPLAIN SELECT * FROM film WHERE film_id = 100;</span></pre><p id="0373" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们来看一下这个查询，如果您在没有任何索引的情况下运行这个查询，DB将逐行扫描整个电影表，以找到所有匹配的条目。</p><p id="f320" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果胶片台有许多行，效率可能会很低。</p><p id="6d41" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是，如果您通过film_id列对表进行索引，DB可能只在搜索树的几个级别中找到条目。</p><h2 id="bce7" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated"><strong class="ak">工作原理</strong></h2><p id="c813" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx mg jz ka kb mh kd ke kf mi kh ki kj hb bi translated">索引是选定列数据的副本，旨在实现高效搜索。索引通常包括指向被复制的原始数据行的链接，以便有效地检索该行。</p><p id="e770" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">没有索引的常规搜索是线性搜索，在一般情况下需要O (n)，索引是一种提高查找性能的数据结构。有许多不同的数据结构可用于此目的，它们在许多方面都不同，并且可能具有不同的折衷，例如查找性能、索引大小和索引更新性能。这些数据结构中的许多被设计为O (log (n))查找效率，并且在一些场景中，它们中的一些可能达到O (1)性能。</p><h1 id="a71a" class="lv kl hi bd km lw lx ly kq lz ma mb ku io mc ip kx ir md is la iu me iv ld mf bi translated">窗口函数</h1><p id="f3c8" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx mg jz ka kb mh kd ke kf mi kh ki kj hb bi translated">窗口函数或分析函数是使用一行或多行中的值为每一行返回值的函数。</p><p id="3336" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一方面，聚合函数(如group by和sum)会为多行返回一个值。</p><h2 id="fd7b" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated"><strong class="ak">何时使用</strong></h2><p id="d1c3" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx mg jz ka kb mh kd ke kf mi kh ki kj hb bi translated">当您需要对数据执行一些聚合，但仍必须扫描整行以进行更多分析或显示时。</p><p id="f967" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您尝试使用常规聚合函数进行这种操作，您将不得不使用子查询来再次扫描数据，这将损害查询性能并使其更加复杂。</p><p id="6f16" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们来看一个简单的窗口函数，它可以帮助我们将员工的工资与其所在部门的平均工资进行比较</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="129d" class="kk kl hi ml b fi mp mq l mr ms"><strong class="ml hj">SELECT</strong> depname, empno, salary, avg(salary) <strong class="ml hj">OVER</strong> (<strong class="ml hj">PARTITION</strong> <strong class="ml hj">BY</strong> depname) <strong class="ml hj">FROM</strong> empsalary;</span></pre><p id="2637" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> OVER </strong>关键字向我们揭示了这是一个窗口函数。</p><p id="d098" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该查询的结果将是:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es na"><img src="../Images/99c4bd43885cf8caeb26b8a518e3931e.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*1nXey4Uy0OHXgKHlOUOX0Q.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">窗口函数结果示例</figcaption></figure><p id="96e5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">窗口函数在聚集之后被评估。</p><h1 id="218d" class="lv kl hi bd km lw lx ly kq lz ma mb ku io mc ip kx ir md is la iu me iv ld mf bi translated">特殊数据类型</h1><p id="f756" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx mg jz ka kb mh kd ke kf mi kh ki kj hb bi translated">在本节中，我们将了解一些数据类型，如果您正确对待它们，您将获得更好的性能和更好的功能。</p><h2 id="da03" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated"><strong class="ak">地理:</strong></h2><p id="27cb" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx mg jz ka kb mh kd ke kf mi kh ki kj hb bi translated">当涉及到地理数据时，您需要做的就是存储点的集合，您甚至可以将它存储为包含此数据的文本或JSON，但这样会损害您的性能，并且您会失去许多功能。</p><p id="b21b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于这种情况，每个现代数据库都有一个特殊的geo类型，可以索引点数据以获得更好的性能，并允许您使用geo libs实现复杂的功能，如联合、计算面积等。</p><p id="f05f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在PostgreSQL中，您将使用点/线/面数据类型，并且可能会添加PostGIS扩展。</p><h2 id="630f" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated"><strong class="ak"> JSON: </strong></h2><p id="c210" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx mg jz ka kb mh kd ke kf mi kh ki kj hb bi translated">将JSON存储在数据库中有时会很有帮助或者很有必要。很多时候，作为开发人员，我们将JSON数据作为字符串/文本，但是当涉及到将它存储在DB中时，这不是最好的方法。</p><p id="df9d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">每个现代数据库都有一个特殊的JSON数据类型，支持JSON的索引和压缩，甚至支持查询JSON中的嵌套对象。</p><p id="6eee" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，在PostgreSQL中，您可以将JSON数据存储为文本数据类型，但您无法查询该JSON中的嵌套属性，您可以将其存储为JSON数据类型，但它不会压缩和索引，这可能会损害您的性能并填满您的存储，在PostgreSQL中存储JSON数据的最佳方式是在JSONB数据类型中，它包含所有功能、索引、压缩和查询嵌套属性。</p><h1 id="af30" class="lv kl hi bd km lw lx ly kq lz ma mb ku io mc ip kx ir md is la iu me iv ld mf bi translated">简单地</h1><p id="0900" class="pw-post-body-paragraph jo jp hi jq b jr lh ij jt ju li im jw jx mg jz ka kb mh kd ke kf mi kh ki kj hb bi translated">数据库和SQL查询是任何现代应用程序的主要业务的一部分，现在任何应用程序都必须具有出色的性能。在这篇文章中，我们来看看一些让你的查询更快的方法。</p><p id="0629" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最重要的部分是了解您的查询和数据库，未知的查询和错误配置可能会导致性能问题。</p><p id="2ea9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">希望你喜欢阅读这篇文章，它将帮助你写更好的代码，并使你的更好。</p></div></div>    
</body>
</html>