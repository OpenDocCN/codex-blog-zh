<html>
<head>
<title>Enums Cases as Protocol Witnesses and the Open-Closed Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">列举案例作为协议证人和开闭原则</h1>
<blockquote>原文：<a href="https://medium.com/codex/enums-cases-as-protocol-witnesses-and-the-open-closed-principle-f622c284f881?source=collection_archive---------10-----------------------#2021-07-24">https://medium.com/codex/enums-cases-as-protocol-witnesses-and-the-open-closed-principle-f622c284f881?source=collection_archive---------10-----------------------#2021-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a3a6f0c073abb6b7514b57117e271d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Fsy_krMDnRuKe9k2sFO6Q.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片由<a class="ae iu" href="https://unsplash.com/@andreiamza2000" rel="noopener ugc nofollow" target="_blank">阿姆扎·安德烈</a>拍摄</figcaption></figure><h1 id="e50d" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">背景</h1><p id="875f" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">最近，我在一个客户的应用程序中实现了许多分析事件。标记这个应用程序(它有大量的UI)总是一件费力的事情，所以我希望设计一个人机工程学的API来与之交互。</p><p id="80e3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在决定接口时，我记得Swift 5.3的特性允许<a class="ae iu" href="https://github.com/apple/swift-evolution/blob/main/proposals/0280-enum-cases-as-protocol-witnesses.md" rel="noopener ugc nofollow" target="_blank"> enum案例用作协议见证</a>。这成了我正在配对的低年级学生的一个很好的教学机会。简而言之，一个需要返回<code class="du kw kx ky kz b">Self</code>的<code class="du kw kx ky kz b">static</code>函数的<code class="du kw kx ky kz b">protocol</code>可以由一个具有关联值的<code class="du kw kx ky kz b">enum</code> <code class="du kw kx ky kz b">case</code>来满足。此外，协议中任何类型为<code class="du kw kx ky kz b">Self</code>的<code class="du kw kx ky kz b">static</code>变量都可以由没有相关值的<code class="du kw kx ky kz b">enum</code> <code class="du kw kx ky kz b">case</code>来满足。</p><p id="e48e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">假设我们有以下协议:</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="b09a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们可以用下面的结构来满足它:</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="d0d4" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">此外，我们还可以用这个枚举来满足协议:</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="e538" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">对于API消费者来说，这两者看起来是一样的，因为它们被完全相同地调用:</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><h1 id="66ea" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">开闭原则</h1><p id="7dc1" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">启闭原理</a>是5个<a class="ae iu" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">实体</a>设计原理之一。它声明“软件实体应该对扩展开放，但对修改关闭。”这意味着，我们的API应该是可扩展的，而不必改变原始源代码。</p><h1 id="1297" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><strong class="ak">枚举vs结构</strong></h1><p id="4580" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">开闭原则是一个容易出错的地方。它们不能被扩展来包含额外的<code class="du kw kx ky kz b">case</code>，所以每次一个新的事件类型被添加到我们的协议中，我们都需要修改原始的<code class="du kw kx ky kz b">enum</code> s源。对于可以跨多个文件扩展的<code class="du kw kx ky kz b">struct</code>，情况并非如此。</p><p id="9987" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">另一个考虑因素是协议的大小。目前有两个事件，但是当要跟踪的事件数量激增时会发生什么呢？如果我们有大约60个屏幕，每个屏幕有2-5个事件，我们最终会有大约210个<code class="du kw kx ky kz b">enum</code> <code class="du kw kx ky kz b">case</code>，这些都必须放在同一个文件中，对于我们的<code class="du kw kx ky kz b">name</code>变量，我们也会有一个巨大的<code class="du kw kx ky kz b">switch</code>语句。</p><p id="0c61" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在后端分析系统只能处理某些事件的情况下，通过使用<code class="du kw kx ky kz b">enum</code>来防止任何未知和未处理的事件溜走可能是完全有意义的，但总的来说，我认为<code class="du kw kx ky kz b">struct</code>模式在这种情况下工作得最好。</p><h1 id="4a74" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论</h1><p id="e9ef" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">使用<code class="du kw kx ky kz b">enum</code> <code class="du kw kx ky kz b">case</code> s作为协议见证是对Swift语言的一个很酷的补充，但是我们仍然需要考虑<code class="du kw kx ky kz b">enum</code> s是否是手头工作的最佳工具。和往常一样，当你有了一把闪亮的新锤子，很容易把所有东西都当成钉子，但总是值得后退一步，评估API &amp;的需求及其持续使用的人体工程学。</p></div></div>    
</body>
</html>