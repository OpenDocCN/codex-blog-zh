<html>
<head>
<title>Getting Started with Server-Sent Events and understanding when to use Polling, WebSockets, and SSE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始使用服务器发送的事件并了解何时使用轮询、WebSockets和SSE</h1>
<blockquote>原文：<a href="https://medium.com/codex/getting-started-with-server-sent-events-and-understanding-when-to-use-polling-websockets-and-sse-87465f3bcf63?source=collection_archive---------2-----------------------#2021-07-03">https://medium.com/codex/getting-started-with-server-sent-events-and-understanding-when-to-use-polling-websockets-and-sse-87465f3bcf63?source=collection_archive---------2-----------------------#2021-07-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="270f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">互联网上的数据共享如何随着HTTP轮询、WebSockets和SSE的实时用例而发展的简史。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/45e9808c78f9e59d5c097d139f9fa9dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uhyy4ibIFZFFXBib"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">帕万·特里库塔姆在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="5299" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在这篇文章中，我将描述互联网上的数据共享是如何随着新兴需求的发展而发展的背景故事。我将向您介绍SSE，并解释您应该在哪些用例中使用SSE并避免web套接字的开销。</p><p id="0b59" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在下一篇文章中，我将向您解释我的项目中需要使用SSE的一个用例，我将带您完成一个使用<strong class="jx hj"> Spring Boot </strong>和<strong class="jx hj">反应</strong>开发的POC来演示这个想法。</p><p id="d5cc" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">这就是我所说的用例:“在文件上传时，显示一个实时进度条，显示服务器到目前为止已经处理了多少，而不会在进度条中重复点击端点。”</strong></p><h1 id="d870" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">互联网数据共享简史</h1><p id="b7b1" class="pw-post-body-paragraph jv jw hi jx b jy lj ij ka kb lk im kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">这一切都始于请求和响应的HTTP协议。一个实体打开一个连接并请求一个资源或服务，然后另一个实体做出响应，要么是请求的资源，要么是错误响应(如果它不可用)。在每个请求-响应周期之后，连接被关闭。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lo"><img src="../Images/10a84b18bddbbcdb5a7bcef7cb81c9b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*flQFi39mZQVfKDyrc-Db-A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">HTTP请求-响应周期</figcaption></figure><p id="b4ea" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><em class="lp">HTTP是一种无状态协议，如果相同的两个实体需要再次通信，则通过新的连接进行。</em></p><blockquote class="lq lr ls"><p id="2c5b" class="jv jw lp jx b jy jz ij ka kb kc im kd lt kf kg kh lu kj kk kl lv kn ko kp kq hb bi translated">这是这种交流的弊端之一。对于事件驱动的应用程序来说，HTTP——以其自然的形式——并不能完全满足它。</p></blockquote><p id="ea4d" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">以股票定价为例。该应用程序将向数据提供商请求当前的股票价格，并在HTTP场景中将其显示在网页上。<em class="lp">但是，HTTP land中不存在“更新”的概念。</em>如果应用程序需要更新的数据，合乎逻辑的步骤是刷新页面并发出新的HTTP请求。虽然它模糊地完成了工作，但是频繁地发送请求对于实现这一点来说并不理想，并且也是能量密集型的。</p><p id="d949" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">为了实现这些实时通信，让我们看看有哪些选择。</strong></p><h2 id="629c" class="lw ks hi bd kt lx ly lz kx ma mb mc lb ke md me ld ki mf mg lf km mh mi lh mj bi translated">HTTP轮询/短轮询</h2><p id="0d77" class="pw-post-body-paragraph jv jw hi jx b jy lj ij ka kb lk im kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated"><em class="lp">短轮询</em>是一个基于AJAX的定时器，以固定的延迟调用。这里使用REST端点不断向服务器发出请求，以查看是否有新信息到达。因此，基本上，客户端以固定的频率发出请求，这会导致大量的请求，而服务器通常会返回相同的“陈旧”响应。所以，它不是那么有益。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mk"><img src="../Images/1e5dfc86805b844e436dac72bd7a7426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ynUzCOGdx2uN2v4984yhA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">HTTP轮询</figcaption></figure><p id="f968" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><em class="lp">这里是你在JavaScript中如何做这件事。</em></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">HTTP轮询</figcaption></figure><h2 id="2f3a" class="lw ks hi bd kt lx ly lz kx ma mb mc lb ke md me ld ki mf mg lf km mh mi lh mj bi translated">HTTP长轮询</h2><p id="da6e" class="pw-post-body-paragraph jv jw hi jx b jy lj ij ka kb lk im kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">HTTP轮询的一个改进是HTTP长轮询。这里，只有当新数据出现时，才会返回对请求的响应，这是通过保持连接实现的。</p><p id="397c" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">就客户端而言，与基本轮询的唯一区别是，执行基本轮询的客户端可能会故意在每个请求之间留出一个小的时间窗口，以减少其在服务器上的负载，并且它可能会以与不支持长轮询的服务器不同的假设来响应超时。对于长轮询，客户端可以配置为在侦听响应时允许更长的超时时间(通过<code class="du mn mo mp mq b">Keep-Alive</code>头)——这通常是可以避免的，因为超时时间通常用于指示与服务器的通信问题。</p><p id="8ac8" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">所以这几乎是一回事，我们每次都必须打开新的HTTP请求来获取新数据，这根本不是双向的。</p><p id="a383" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">有关其局限性的更多详细信息，请访问-<a class="ae jn" href="https://stackoverflow.com/questions/21676324/hard-downsides-of-long-polling" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/21676324/hard-down sides-of-long-polling</a></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/127317e503eab5fbe50c178e30d124ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SydrgWJaX5F_7i_d3efjOA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">HTTP长轮询</figcaption></figure><h2 id="7b27" class="lw ks hi bd kt lx ly lz kx ma mb mc lb ke md me ld ki mf mg lf km mh mi lh mj bi translated">HTTP流</h2><p id="e0aa" class="pw-post-body-paragraph jv jw hi jx b jy lj ij ka kb lk im kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">HTTP流是一种推式数据传输技术，它允许web服务器通过一个保持无限开放的HTTP连接向客户端连续发送数据。从技术上来说，这违背了HTTP约定，但是HTTP流是在服务器和客户机之间传输各种动态或可流数据的有效方法，而无需重新发明HTTP。</p><p id="f630" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">SSE建立在HTTP流之上，HTTP流是以前“松散定义”的HTTP流的标准化。它还引入了更简单的浏览器API来处理这个问题。它使用JavaScript<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource" rel="noopener ugc nofollow" target="_blank">event source API</a>来订阅任何流行浏览器中的数据流。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/9b0deca4c83ae5994342d6c39ca698ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZiuYoLQ9IsglYfjcrQ7YA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">HTTP流</figcaption></figure><h2 id="734b" class="lw ks hi bd kt lx ly lz kx ma mb mc lb ke md me ld ki mf mg lf km mh mi lh mj bi translated">Web套接字</h2><p id="065a" class="pw-post-body-paragraph jv jw hi jx b jy lj ij ka kb lk im kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">WebSocket连接在传输层使用TCP/IP来提供全双工连接。通信双方现在可以同时双向发送消息。该连接是持久的，这意味着只要应用程序运行，它就保持打开。连接也是有状态的——服务器可以发起消息，反之亦然。</p><p id="524a" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><strong class="jx hj">用例- </strong></p><ul class=""><li id="11f6" class="mt mu hi jx b jy jz kb kc ke mv ki mw km mx kq my mz na nb bi translated">消息应用程序</li><li id="4492" class="mt mu hi jx b jy nc kb nd ke ne ki nf km ng kq my mz na nb bi translated">多人游戏</li><li id="c38a" class="mt mu hi jx b jy nc kb nd ke ne ki nf km ng kq my mz na nb bi translated">协作编辑/编码</li><li id="3d64" class="mt mu hi jx b jy nc kb nd ke ne ki nf km ng kq my mz na nb bi translated">基于位置的应用</li></ul><p id="f5e3" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我鼓励你通读一下<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" rel="noopener ugc nofollow" target="_blank"> MDN </a> doc，它详细解释了WebSocket。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nh"><img src="../Images/7e6331bb8776908fa8fd7d76a26fe445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7R0vfZaiDe8HOQUlA45xjA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">WebSockets</figcaption></figure></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="ae31" class="kr ks hi bd kt ku ni kw kx ky nj la lb io nk ip ld ir nl is lf iu nm iv lh li bi translated">服务器发送事件简介</h1><p id="c86f" class="pw-post-body-paragraph jv jw hi jx b jy lj ij ka kb lk im kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">虽然WebSockets解决了大部分实时用例，但有时它可能有些过头了。就像在我们不需要双向通信的场景中一样，SSE可能是一个不错的选择。</p><blockquote class="lq lr ls"><p id="7988" class="jv jw lp jx b jy jz ij ka kb kc im kd lt kf kg kh lu kj kk kl lv kn ko kp kq hb bi translated">SSE是HHTP流之上的一个轻量级协议，它允许客户端拥有超轻量级的仅订阅功能。与WebSockets不同，SSE不提供双向通信的能力，但是可以被服务器用来实时地将数据推送到客户端。</p></blockquote><p id="25b2" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">服务器发送事件(SSE)是一种服务器推送技术，使客户端能够通过HTTP连接从服务器接收自动更新。W3C将服务器发送的事件EventSource API标准化为HTML5的一部分。</p><p id="e33d" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">它提供了XHR流的内存高效实现。与原始XHR连接不同，它会缓冲收到的全部响应，直到连接断开，SSE连接可以丢弃已处理的消息，而不会将它们全部累积到内存中。</p><p id="8e2d" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">SSE被设计为使用JavaScript EventSource API，以便在任何流行的浏览器中订阅数据流。通过这个接口，客户端请求一个特定的URL来接收事件流。SSE通常用于向浏览器客户端发送消息更新或连续数据流。</p><p id="2949" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">简而言之，服务器发送事件是指从服务器向浏览器推送(而不是拉取或请求)更新。</p><h2 id="11a3" class="lw ks hi bd kt lx ly lz kx ma mb mc lb ke md me ld ki mf mg lf km mh mi lh mj bi translated"><strong class="ak">用例:</strong></h2><p id="a4be" class="pw-post-body-paragraph jv jw hi jx b jy lj ij ka kb lk im kd ke ll kg kh ki lm kk kl km ln ko kp kq hb bi translated">当客户端只对订阅数据流感兴趣，而不需要在同一个连接中与服务器通信时，可以特别使用SSE。</p><ul class=""><li id="319e" class="mt mu hi jx b jy jz kb kc ke mv ki mw km mx kq my mz na nb bi translated">订阅加密货币或股票价格的订阅源</li><li id="c4ae" class="mt mu hi jx b jy nc kb nd ke ne ki nf km ng kq my mz na nb bi translated">订阅Twitter feed</li><li id="a81a" class="mt mu hi jx b jy nc kb nd ke ne ki nf km ng kq my mz na nb bi translated">接收实况体育比分</li><li id="a955" class="mt mu hi jx b jy nc kb nd ke ne ki nf km ng kq my mz na nb bi translated">新闻更新或提醒</li></ul><p id="040a" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">欲了解更多详情，请访问SSE上的这篇<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" rel="noopener ugc nofollow" target="_blank"> MDN文章</a>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nn"><img src="../Images/0fcbc4b6d768151db78ca09d35e388cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IpawgiAl7RQpcD47HqEu4w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">服务器发送的事件</figcaption></figure><p id="90e7" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">这个博客到此为止。感谢阅读！</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="a18b" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">这是我前面提到的POC的演示。</p><blockquote class="lq lr ls"><p id="a427" class="jv jw lp jx b jy jz ij ka kb kc im kd lt kf kg kh lu kj kk kl lv kn ko kp kq hb bi translated"><a class="ae jn" rel="noopener" href="/codex/implementation-of-server-sent-events-and-eventsource-live-progress-indicator-using-react-and-723596f35225">使用React和Spring Boot </a>实现服务器发送的事件和event source——实时进度指示器，通过代码演练详细解释了POC。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es no"><img src="../Images/70dcf02ad53ebfc2ea3145c9a8730987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2ato7dGklnwxuupvApQbOQ.gif"/></div></div></figure><p id="039b" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">如果你喜欢这个博客，请在<a class="ae jn" href="https://arpan-banerjee7.medium.com/" rel="noopener"> Medium </a>、<a class="ae jn" href="https://www.linkedin.com/in/banerjee-arpan7/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>和<a class="ae jn" href="https://github.com/arpan-banerjee7" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我，了解更多类似的博客。</p></div></div>    
</body>
</html>