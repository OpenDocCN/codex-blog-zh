<html>
<head>
<title>Database Migration When Your Service Is Running in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当您的服务在Kubernetes中运行时的数据库迁移</h1>
<blockquote>原文：<a href="https://medium.com/codex/database-migration-when-your-service-is-running-in-kubernetes-abbe9697421d?source=collection_archive---------2-----------------------#2022-09-04">https://medium.com/codex/database-migration-when-your-service-is-running-in-kubernetes-abbe9697421d?source=collection_archive---------2-----------------------#2022-09-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/570d45cd680356b7ff92964768f6b7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*F0s0uJfRIl2whFI-H9afYQ.png"/></div></figure><p id="2c4d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">只要服务需要永久的持久层，数据库迁移就是每个开发人员都必须面对的话题。对于关系数据库，模式是必需的，并且通常会随着时间的推移而发展，因为需要持久性的服务会发生变化。因此，人们将面临数据库迁移的挑战。</p><p id="de0f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最常见的方法是使用迁移工具(或从头开始)，这将创建一个包含数据库版本的附加表。运行迁移时，通常会应用某种类型的数据库锁来避免并行执行迁移。</p><p id="1a62" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在Kubernetes上下文中运行服务会使数据库迁移变得棘手。</p><p id="989e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们来看一下在何时何地运行迁移的可能解决方案。</p><h1 id="2a98" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">选项1:在服务启动期间</h1><p id="0c94" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">许多迁移工具都以库的形式提供，可以在您喜欢的语言的代码中使用。</p><p id="a28e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最简单的方法是在服务的启动阶段运行数据库迁移。</p><p id="b171" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">优点是设置简单，不需要额外的配置。然而，问题是，一旦您运行多个pod服务，您就会遇到困难。一个单元将尝试启动和运行迁移，但由于另一个单元已经在运行它而失败。这将导致服务无法启动，因此会在集群中引发错误事件，并强制多次重新启动，直到另一个pod完成迁移。另一个问题可能是超过设置的启动时间限制的大型迁移，导致Kubernetes集群认为您的服务无法启动。</p><h1 id="4417" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">选项2:使用initContainers运行迁移</h1><p id="c0ff" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">Kubernetes提供了一个名为<a class="ae kn" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" rel="noopener ugc nofollow" target="_blank"> <em class="ko"> initContainers </em> </a>的功能，可用于部署。InitContainers在每个pod开始之前执行一次(在进行部署时)。在initContainer成功完成之前，部署的pod不会启动。如果initContainer没有成功完成，它将重新启动，直到成功。</p><p id="322c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们在initContainer中运行数据库迁移，它将在服务启动之前单独执行。这具有将服务从数据库迁移逻辑中分离出来的优点。然而，由于一个pod获得一个initContainer，我们遇到了与选项1相同的问题。一旦我们同时部署多个单元，一次只能有一个单元运行迁移过程。其他的将会失败并重新启动多次。</p><h1 id="b0b3" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">选项3:在触发部署之前，在CD管道中运行迁移</h1><p id="3f2b" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">如今，大多数开发人员使用某种CI/CD管道来构建他们的服务，并将它们部署到Kubernetes集群中。考虑到这一点，也可以在Kubernetes部署之前，将迁移工具作为连续部署管道中的一个步骤来运行。</p><p id="3037" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是一个可行的解决方案，但是，由于数据库只能从Kubernetes集群内部访问，所以可能无法实现。这也意味着CD管道需要访问数据库机密，因此它们可能必须保存在两个位置，而不是一个中心位置(取决于CI/CD解决方案)。</p><h1 id="b40e" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">选项4:作为Kubernetes的工作运行数据库迁移</h1><p id="02b4" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">在选项2中，我们介绍了作为在pod启动前运行迁移的解决方案的initContainers。除了使用initContainers，我们还可以使用Kubernetes作业来达到同样的目的。然而，这带来了一点复杂性，因为Kubernetes没有提供在启动pods之前等待任务执行的原生功能。</p><p id="9c7f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了克服这个问题，可以使用<a class="ae kn" href="https://github.com/groundnuty/k8s-wait-for" rel="noopener ugc nofollow" target="_blank">服务</a>作为initContainer，不断检查迁移工作是否成功完成。只有在作业完成之后，initContainer才会成功地完成它的执行，并使pod能够启动。</p><p id="7dcb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">注意</strong>:对于这个用例，正在运行的initContainers需要访问权限来读取迁移作业的状态。</p><p id="4637" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">设置initContainers和k8作业的教程可以在本文中找到<a class="ae kn" rel="noopener" href="/@jonastm/database-migration-with-a-kubernetes-job-and-initcontainers-d196dec8ac96">:</a></p><div class="kp kq ez fb kr ks"><a rel="noopener follow" target="_blank" href="/@jonastm/database-migration-with-a-kubernetes-job-and-initcontainers-d196dec8ac96"><div class="kt ab dw"><div class="ku ab kv cl cj kw"><h2 class="bd hj fi z dy kx ea eb ky ed ef hh bi translated">使用Kubernetes作业和initContainers进行数据库迁移</h2><div class="kz l"><h3 class="bd b fi z dy kx ea eb ky ed ef dx translated">本文展示了如何使用Kubernetes作业和initContainers进行数据库迁移。YAML配置示例如下…</h3></div><div class="la l"><p class="bd b fp z dy kx ea eb ky ed ef dx translated">medium.com</p></div></div><div class="lb l"><div class="lc l ld le lf lb lg ik ks"/></div></div></a></div><p id="9361" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ko">如果你在Kubernetes上使用技术，可能会有更简单的解决方案，例如Helm，在完全没有initContainers的情况下，使用</em><a class="ae kn" href="https://itnext.io/database-migrations-on-kubernetes-using-helm-hooks-fb80c0d97805" rel="noopener ugc nofollow" target="_blank"><em class="ko">Helm Hooks</em></a><em class="ko">也可以实现同样的效果。</em></p><h1 id="1fdf" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">其他提及</h1><p id="5b58" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">还有一些其他选项可能值得一看，但不常用:</p><ul class=""><li id="ba08" class="lh li hi io b ip iq it iu ix lj jb lk jf ll jj lm ln lo lp bi translated"><a class="ae kn" href="https://schemahero.io/" rel="noopener ugc nofollow" target="_blank"><strong class="io hj"><em class="ko">Schema hero</em></strong></a>:这使您能够将数据库模式定义为YAML的Kubernetes配置。当您更改配置时，会为您处理迁移。目前，不提供数据迁移(仅模式)。</li><li id="0255" class="lh li hi io b ip lq it lr ix ls jb lt jf lu jj lm ln lo lp bi translated"><a class="ae kn" href="https://github.com/coderanger/migrations-operator" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj"> <em class="ko">迁移-操作符</em> </strong> </a> : Kubernetes操作符，与选项4做同样的事情，但是以一种更自动化更容易配置的方式。没有企业支持。</li></ul><h1 id="aa47" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论:</h1><p id="169a" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">一般来说，如果您的应用程序运行多个实例(pods ),我不推荐使用选项1或2。在这些情况下，应首选<strong class="io hj">选项3 </strong>和<strong class="io hj"> 4 </strong>，以避免由于并行或长时间运行的迁移而导致的错误。一如既往，解决方案必须适合您的使用案例，这可能有其他先决条件和要求。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><p id="2d91" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ko">你知道另一种选择吗？分享到评论区吧！</em></p></div></div>    
</body>
</html>