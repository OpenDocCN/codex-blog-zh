<html>
<head>
<title>Updating Our Data Thread Safely</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安全更新我们的数据线程</h1>
<blockquote>原文：<a href="https://medium.com/codex/updating-our-data-thread-safely-870f8585709?source=collection_archive---------4-----------------------#2022-01-12">https://medium.com/codex/updating-our-data-thread-safely-870f8585709?source=collection_archive---------4-----------------------#2022-01-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="5317" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">文章</h2><div class=""/><div class=""><h2 id="181f" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated"><em class="jg">出自</em> <a class="ae jh" href="https://www.manning.com/books/rust-web-development?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_gruber_rust_5_21_21" rel="noopener ugc nofollow" target="_blank"> <em class="jg">锈网开发</em> </a> <em class="jg">出自巴斯蒂安·格鲁伯</em></h2></div><p id="ba40" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">本文讨论如何在Rust中安全地更新我们的数据线程。</em></p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="719e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">通过在<a class="ae jh" href="https://www.manning.com/?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_gruber_rust_5_21_21" rel="noopener ugc nofollow" target="_blank">manning.com</a>的结账处将<strong class="jk hs"> fccgruber </strong>输入折扣代码框，享受35%的折扣<a class="ae jh" href="https://www.manning.com/books/rust-web-development?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_gruber_rust_5_21_21" rel="noopener ugc nofollow" target="_blank"><em class="ke">Rust Web Development</em></a>。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="ff41" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">当操作一个异步web服务器时，我们必须意识到在同一时刻可能会有数以千计(或更多)的请求进来，并且每个请求都想要写入或读取数据。我们有一个单一的数据结构为我们提供应用程序中的状态，但是当两个或更多的请求想要写入同一个结构或从中读取时会发生什么呢？</p><p id="a780" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们必须让每个请求分别访问我们的存储，并通知另一个进程或请求等待，直到前面的读或写在<code class="du km kn ko kp b">Store</code>上完成。在这种情况下，两个(或更多)进程想要更新同一个数据结构。我们需要将其他进程放在等待列表中，一次处理一个进程来修改我们的数据。</p><p id="0a80" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">此外，Rust对所有权有独特的看法。一个实例或进程可以拥有特定变量或对象的所有权。这是为了防止竞态条件和空指针，其中引用了不再存在的数据。似乎我们必须等待一个请求完成，以便它能够将<code class="du km kn ko kp b">Store</code>的所有权返回给下一个请求。这与异步思维完全背道而驰。</p><p id="8591" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们面临两个问题:</p><ul class=""><li id="fcc1" class="kq kr hi jk b jl jm jo jp jr ks jv kt jz ku kd kv kw kx ky bi translated">我们希望防止两个或多个进程同时修改数据。</li><li id="285a" class="kq kr hi jk b jl kz jo la jr lb jv lc jz ld kd kv kw kx ky bi translated">如果需要改变数据存储，我们希望赋予每个路由处理程序对数据存储的所有权。</li></ul><p id="891f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在我们甚至可以考虑在我们的存储上设置更改数据的等待列表之前，我们首先需要确保Rust可以共享一个状态的所有权。让我们先解决第二个问题。Rust在代码中传递变量时会转移所有权。图1展示了当向另一个变量传递一个复杂值(比如一个字符串)时，如何丢弃第一个变量，以确保堆栈上只有一个指针拥有堆上这个结构的所有权，它控制着对它的所有修改。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es le"><img src="../Images/c69dae0fd3edb566ab7580659f0012ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nQ5ynMRWvFFyGd7Q.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图1:将字符串这样的复杂数据类型重新分配给另一个变量是内部将所有权转移给新变量并放弃旧变量。</figcaption></figure><p id="fb66" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这个概念现在对我们来说是个问题。Rusts的安全措施阻止我们在不同的函数和线程之间共享数据，因为每当我们传递一个值给一个新的函数时，我们就转移了这个值的所有权，并且必须等待直到我们取回它。我想到了两个选择:</p><ul class=""><li id="6a64" class="kq kr hi jk b jl jm jo jp jr ks jv kt jz ku kd kv kw kx ky bi translated">为每个路由处理程序创建一个我们的存储副本</li><li id="2b42" class="kq kr hi jk b jl kz jo la jr lb jv lc jz ld kd kv kw kx ky bi translated">等到一个路由处理程序完成后，将存储的所有权交还给下一个处理程序</li></ul><p id="06b2" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">两者都没有以适当的方式解决根本问题。第一个选项污染了我们的内存，我们仍然不能改变存储中的数据，第二个选项与我们的异步方法背道而驰。</p><p id="3da1" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">幸运的是，Rust配备了处理这些问题的设备。具体来说:</p><ul class=""><li id="6af6" class="kq kr hi jk b jl jm jo jp jr ks jv kt jz ku kd kv kw kx ky bi translated"><code class="du km kn ko kp b">Rc&lt;T&gt;</code></li><li id="1b0c" class="kq kr hi jk b jl kz jo la jr lb jv lc jz ld kd kv kw kx ky bi translated"><code class="du km kn ko kp b">Arc&lt;T&gt;</code></li></ul><p id="53ed" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><code class="du km kn ko kp b">Rc</code>或<code class="du km kn ko kp b">Arc</code>类型将底层数据结构<code class="du km kn ko kp b">T</code>放在堆上，并在堆栈上创建一个指针。现在，您可以复制引用相同数据指针。这两者的区别在于<code class="du km kn ko kp b">Rc</code>只在单线程系统上运行，而<code class="du km kn ko kp b">Arc</code>在多线程系统上运行，因此它允许你在不同的线程之间共享数据。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lu"><img src="../Images/d56b9c2b1c69e35fba9688f41fdc423b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BBN8BB9MRARX8yP7.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图2:Rust没有减少x值，而是增加了Arc计数。每当x或y超出范围时。它递减计数，直到计数为零，然后调用。要从堆中移除的drop()。</figcaption></figure><p id="3d30" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">弧类型是“原子引用计数”。它就像一个容器，将其中包装的数据移动到堆上，并在堆栈上创建一个指向它的指针。当克隆一个Arc时，克隆指向堆上相同数据结构的指针，并且在内部，Arc增加它的计数。当内部计数达到零时(当指向变量的所有变量都超出范围时)，Arc会丢弃该值。这使得在不同变量之间共享堆上的复杂数据变得安全。</p><p id="5dbf" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们运行在tokio之上，这意味着我们需要使用<code class="du km kn ko kp b">Arc&lt;T&gt;</code>并将我们的数据存储包装在其中，但这只是解决方案的一部分。读取相同的存储是好的，但我们也希望有机会改变它。一个线程上的HTTP POST请求可能会增加问题，而另一个线程上的HTTP PUT请求可能会试图改变现有的问题。因此，我们需要寻找解决办法。Rust也将我们包含在这个场景中。我们可以使用这两种类型中的任何一种:</p><ul class=""><li id="7d93" class="kq kr hi jk b jl jm jo jp jr ks jv kt jz ku kd kv kw kx ky bi translated"><code class="du km kn ko kp b">Mutex</code></li><li id="ff17" class="kq kr hi jk b jl kz jo la jr lb jv lc jz ld kd kv kw kx ky bi translated"><code class="du km kn ko kp b">RwLock</code></li></ul><p id="55f2" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">它们都确保读者或作者对底层数据的访问是唯一的。一旦一个写者或读者想要访问数据，它们就锁定数据，并在前一个读者或写者完成时为下一个读者或写者解锁数据。区别在于:一个<code class="du km kn ko kp b">Mutex</code>对于一个写者或者一个读者来说都是阻塞的，而一个<code class="du km kn ko kp b">RwLock</code>同时允许许多读者，但是一次只允许一个写者。</p><p id="40d2" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们必须小心:这两种类型都在<code class="du km kn ko kp b">std::sync</code>模块的后面，这表明它们在像我们这样的异步环境中不是最好的。我们的项目中添加了一些用于异步环境的<code class="du km kn ko kp b">RwLock</code>类型的实现。</p><p id="06e5" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们选择了库<code class="du km kn ko kp b">parking_lot</code>，它在大公司的生产环境中被大量使用，因此目前得到了我们的信任。我们将库添加到我们的<code class="du km kn ko kp b">Cargo.toml</code>文件中:</p><p id="d018" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单1:将parking_lot添加到我们的项目中</strong></p><pre class="lf lg lh li fd lv kp lw lx aw ly bi"><span id="9709" class="lz ma hi kp b fi mb mc l md me">…<br/> [dependencies]<br/> warp = "0.3"<br/> <strong class="kp hs">parking_lot = "0.10.0"</strong><br/> serde = { version = "1.0", features = ["derive"] }<br/> serde_json = "1.0"<br/> tokio = { version = "1.1.1", features = ["full"] }</span></pre><p id="2749" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在一切就绪，我们可以开始相应地更新我们的代码库了。首先，我们将问题封装在一个<code class="du km kn ko kp b">Arc</code>中，将数据放入堆中，并获得指向它的多个指针。此外，我们将我们的问题结构包装在一个<code class="du km kn ko kp b">RwLock</code>中，以防止同时进行多次写入。</p><p id="f2a7" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单2:让我们的HashMap线程安全</strong></p><pre class="lf lg lh li fd lv kp lw lx aw ly bi"><span id="761b" class="lz ma hi kp b fi mb mc l md me">…<br/>  <br/> <strong class="kp hs">use std::sync::Arc;</strong><br/> <strong class="kp hs">use parking_lot::RwLock;</strong><br/>  <br/> …<br/>  <br/> #[derive(Clone)]<br/> struct Store {<br/>     questions: <strong class="kp hs">Arc&lt;RwLock&lt;</strong>HashMap&lt;QuestionId, Question&gt;<strong class="kp hs">&gt;&gt;</strong>,<br/> }<br/> …</span></pre><p id="5fa7" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们还必须更新从<code class="du km kn ko kp b">get_questions</code>函数中的<code class="du km kn ko kp b">Store</code>读取问题的方式:</p><p id="0775" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单3:调整我们阅读商店的方式</strong></p><pre class="lf lg lh li fd lv kp lw lx aw ly bi"><span id="c50a" class="lz ma hi kp b fi mb mc l md me">…<br/> async fn get_questions(store: Store) -&gt; Result&lt;impl warp::Reply, warp::Rejection&gt; {<br/>     let res: Vec&lt;Question&gt; = store.questions<strong class="kp hs">.read()</strong>.values().cloned().collect();<br/>  <br/>     Ok(warp::reply::json(&amp;res))<br/> }<br/> …</span></pre><p id="c9e7" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在<code class="du km kn ko kp b">questions</code>上的一个简单的<code class="du km kn ko kp b">.read()</code>足以请求从<code class="du km kn ko kp b">RwLock</code>读取。考虑到商店结构的更新包装，我们创建了两个新功能:更新和插入问题。</p><h2 id="66f2" class="lz ma hi bd mf mg mh mi mj mk ml mm mn jr mo mp mq jv mr ms mt jz mu mv mw ho bi translated"><strong class="ak">添加问题</strong></h2><p id="e9a6" class="pw-post-body-paragraph ji jj hi jk b jl mx is jn jo my iv jq jr mz jt ju jv na jx jy jz nb kb kc kd hb bi translated">我们以线程安全的方式解决了处理状态的问题，现在我们可以继续实现剩下的API路由，并探索如何从HTTP请求解析主体和从URL读取参数。我们添加的第一个路由是接受对/questions路径的HTTP POST请求。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es nc"><img src="../Images/a7c0d0fe64c33de53bcee1ea03ac1d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4wqsj0BkBMVCRfQV.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图3:我们期望在/questions路径上的HTTP POST请求的主体中有新的问题。</figcaption></figure><p id="008b" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">清单4展示了我们的<code class="du km kn ko kp b">add_question</code>路由处理程序。我们期望存储被传递给我们的函数，和一个问题。然后我们可以利用我们在商店上实现的<code class="du km kn ko kp b">RwLock</code>，并使用方法<code class="du km kn ko kp b">.write()</code>请求对它的写访问。无论何时我们得到它，我们都可以访问底层的<code class="du km kn ko kp b">HashMap</code>，并带着我们的问题调用<code class="du km kn ko kp b">.insert</code>。</p><p id="8823" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单4:添加路由处理程序，用于将问题添加到存储中</strong></p><pre class="lf lg lh li fd lv kp lw lx aw ly bi"><span id="22b2" class="lz ma hi kp b fi mb mc l md me">…<br/>  <br/> async fn add_question(store: Store, question: Question) -&gt; Result&lt;impl warp::Reply, warp::Rejection&gt; {<br/>     store.questions.write().insert(question.clone().id, question);<br/>  <br/>     Ok(warp::reply::with_status(<br/>         "Question added",<br/>         StatusCode::OK,<br/>     ))<br/> }<br/>  <br/> …</span></pre><p id="68f2" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">insert方法有两个参数:HashMap的索引和我们希望存储在它旁边的值。我们还可以在这里发现Rusts所有权原则:我们在第一个参数中访问问题的id，因此将问题的所有权传递给<code class="du km kn ko kp b">HashMap</code>的<code class="du km kn ko kp b">.insert</code>方法。如果我们不再在其他任何地方使用这个问题，这就很好了，但是第二个参数接受这个问题并将其存储在<code class="du km kn ko kp b">HashMap</code>中。</p><p id="771c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">因此我们在第一个参数中<code class="du km kn ko kp b">.clone</code>问题创建一个副本，然后把初始问题的所有权从函数参数交给<code class="du km kn ko kp b">the .insert</code>方法。</p><p id="5fb6" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单5:为/questions添加发布路线</strong></p><pre class="lf lg lh li fd lv kp lw lx aw ly bi"><span id="df37" class="lz ma hi kp b fi mb mc l md me">…<br/>  <br/> #[tokio::main]<br/> async fn main() {<br/>     …<br/>  <br/>     let get_questions = warp::get()<br/>         .and(warp::path("questions"))<br/>         .and(warp::path::end())<br/>         .and(store_filter.clone())<br/>         .and_then(get_questions);<br/>         .and_then(update_question);<br/>  <br/> <strong class="kp hs">    let add_question = warp::post() #A</strong><br/> <strong class="kp hs">        .and(warp::path("questions")) #B</strong><br/> <strong class="kp hs">        .and(warp::path::end()) #C</strong><br/> <strong class="kp hs">        .and(store_filter.clone()) #E</strong><br/> <strong class="kp hs">        .and(warp::body::json()) #F</strong><br/> <strong class="kp hs">        .and_then(add_question); #G</strong><br/>  <br/>     let routes = get_questions.<strong class="kp hs">or(add_question).</strong>with(cors)<strong class="kp hs">.recover(return_error);</strong>         warp::serve(routes)          .run(([127, 0, 0, 1], 3030))          .await;  }</span></pre><p id="a6f8" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A我们创建一个新变量，这次使用warp::post()来过滤HTTP POST请求</strong></p><p id="04f8" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B我们仍然监听相同的根路径，/questions </strong></p><p id="15d5" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #C我们关闭路径定义</strong></p><p id="7c14" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #E我们将我们的商店添加到该路线，以便稍后将其传递给路线处理程序</strong></p><p id="929b" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #F我们提取JSON体，它也被添加到参数中</strong></p><p id="5ce9" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #G我们用store和json体作为参数调用add _ question</strong></p><p id="4f14" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们添加了两条新路线，并将它们添加到我们的route变量中。请注意，我们在<code class="du km kn ko kp b">get_questions</code>过滤器的末尾移除了单个的<code class="du km kn ko kp b">.recover</code>，并将其添加到路由的末尾，因为现在我们在恢复未找到的路径之前尝试不同的路由。</p><p id="f340" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">目前就这些。在曼宁的liveBook平台<a class="ae jh" href="https://livebook.manning.com/book/rust-web-development?origin=product-look-inside&amp;utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_gruber_rust_5_21_21" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多关于这本书的信息。</p></div></div>    
</body>
</html>