<html>
<head>
<title>Upgrading dependencies doesn’t have to suck</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">升级依赖关系不一定很糟糕</h1>
<blockquote>原文：<a href="https://medium.com/codex/upgrading-dependencies-doesnt-have-to-suck-8d5b2b767d58?source=collection_archive---------2-----------------------#2021-12-12">https://medium.com/codex/upgrading-dependencies-doesnt-have-to-suck-8d5b2b767d58?source=collection_archive---------2-----------------------#2021-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4502" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个轻松、自动化的依赖性升级过程</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/3e97fe9efc176e3c4d45c9c7bad9bd18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/0*rcTaMHHJapBQ1mrZ"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><a class="ae jp" href="https://www.istockphoto.com/vector/concept-of-computer-hacking-binary-code-floating-digits-and-skull-with-bones-on-gm1043114224-279236907" rel="noopener ugc nofollow" target="_blank">链接</a></figcaption></figure><p id="b0d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">针对最近的<a class="ae jp" href="https://www.google.com/amp/s/www.bleepingcomputer.com/news/security/new-zero-day-exploit-for-log4j-java-library-is-an-enterprise-nightmare/amp/" rel="noopener ugc nofollow" target="_blank"> log4j安全漏洞</a>；我认为谈论保持依赖关系最新的过程是特别恰当的。除了(明显的)安全隐患之外，让库接近最新发布的版本还有其他好处，例如:</p><ul class=""><li id="3af9" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">允许您利用内部优化来提高性能</li><li id="5ce2" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">允许您使用新功能</li><li id="f7a1" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">确保您有bug修复，以便您的软件按预期工作</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es ke"><img src="../Images/a2a5806b905506c30781bbab38dbd3cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0pjP18pCjrCD8LjqcXl-g.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">有人真的喜欢让依赖关系保持最新吗？(<a class="ae jp" href="https://www.amazon.com/Sketch-Journal-Composition-Notebook-Children/dp/1719577366" rel="noopener ugc nofollow" target="_blank">链接</a>)</figcaption></figure><p id="412f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是说实话，<strong class="ih hj">保持依赖关系最新是一件痛苦的事情</strong>。因此，我的第一个建议是通过使用托管服务(如lambda)来减少应用程序的攻击面，并尽量减少项目中包含的库的数量。然而，无论你的应用程序设计多么简约，几乎每个组件都至少有一个包含库(你的服务必须做些什么，对吗？).因此，使这些保持最新的过程成为一个关键的(但不可否认是枯燥的)任务。本文的其余部分总结了用Java(用gradle)实现这一点的简单方法，并且这些概念也可以推广到其他语言。</p><h1 id="124b" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">履行</h1><p id="1908" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">将此块添加到build.gradle的根目录，以指定您希望激活依赖项锁定</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="8300" class="lr kk hi ln b fi ls lt l lu lv">dependencyLocking <strong class="ln hj">{<br/>   </strong>lockAllConfigurations()<br/><strong class="ln hj">}</strong></span></pre><p id="34be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">如果您选择</em>，您可以只为一个配置(如实施)指定此选项</p><p id="8863" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更改您声明依赖项版本的方式，使用动态<a class="ae jp" href="https://docs.gradle.org/current/userguide/dynamic_versions.html" rel="noopener ugc nofollow" target="_blank">版本控制</a>(使用通配符)而不是在build.gradle中硬编码版本</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es lx"><img src="../Images/28982d10e654051fbef8305bc7b3a8a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mcyUNs8IiHhJ4aSB9sE0fw.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">就这样，你完了！</figcaption></figure></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h1 id="12cd" class="kj kk hi bd kl km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg bi translated">运行升级过程</h1><p id="29a8" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">若要重新计算(并锁定)要包含在此版本中的版本，请运行以下命令。<strong class="ih hj">这将锁定每个后续构建的版本，直到该命令再次运行</strong></p><blockquote class="mk ml mm"><p id="5b2b" class="if ig lw ih b ii ij ik il im in io ip mn ir is it mo iv iw ix mp iz ja jb jc hb bi translated">。/gradlew依赖项—写锁</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es mq"><img src="../Images/b0edad62675b5a2b90f4906dafc1d7fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L8r3PyPllbwla1N5QRCZCA.png"/></div></div></figure><p id="5401" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这创建了一个<strong class="ih hj"> gradle.lockfile </strong>(类似于npm中的package-lock.json)，它“锁定”依赖项的版本。<strong class="ih hj">这些版本将被使用，直到命令再次运行</strong>，这确保您有一个确定性的构建。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es mr"><img src="../Images/2c7ff6a54b32dfbd7efbde7feac0da80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnBpXvx1fay_akE2xLKMpA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">生成的gradle.lockfile的示例</figcaption></figure><h1 id="6438" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">过程</h1><p id="0f15" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">虽然这个技术设置很酷，<strong class="ih hj">但除非定期执行，否则毫无价值</strong>。以下是我们为确保依赖性升级不会半途而废而实施的流程:</p><ul class=""><li id="c99b" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">设置一个每夜批处理作业来升级依赖项并从中创建一个pr(脚本包含在下面)</li><li id="0e66" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">我们团队中的“轮换”成员每天早上都来检查是否有包含升级的pr</li><li id="8065" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">如果有一个pr但是合并检查失败了(通常是由于编译错误),我们会在本周或下周添加一个故事来解决编译问题</li><li id="47ef" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">如果pr通过了合并检查，那么轮换人员将依赖升级合并到主线，我们的管道将变更一直部署到*生产</li></ul><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="28d5" class="lr kk hi ln b fi ls lt l lu lv">git clone &lt;repoNameHere&gt;<br/>./gradlew dependencies --write-locks<br/>if [[ $(git status --porcelain) ]]; then<br/>  git checkout -b "upgrade-dev-dependencies-$(date)"<br/>  git add .<br/>  git commit -m "auto upgrade dependencies"<br/>  git push -u origin HEAD<br/>  gh pr create --title "upgrade dependencies" --body "upgrade dependencies"<br/>else<br/>  echo dependencies are at newest version so no need for upgrades<br/>fi</span></pre><p id="0684" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有强大的测试、监控、警报、金丝雀部署和自动回滚级别，所以我们可以将代码合并到主线中，并假设它可以工作，除非我们收到一条slack消息告诉我们它没有工作。</p><h1 id="a8e5" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">额外想法</h1><h2 id="4415" class="lr kk hi bd kl ms mt mu kp mv mw mx kt iq my mz kx iu na nb lb iy nc nd lf ne bi translated">传递依赖性</h2><p id="2234" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">上述过程负责升级直接依赖关系，但<strong class="ih hj">不负责</strong> <a class="ae jp" href="https://docs.gradle.org/current/userguide/dependency_constraints.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">传递依赖关系</strong> </a>。假设您引入了apache commons，但是apache commons还没有使用log4j的最新版本发布。旧的(易受攻击的)log4j依赖项仍将包含在您的应用程序中。为了强制升级可传递的依赖项，我建议在你的build.gradle (在配置块中)中添加下面的<strong class="ih hj">行</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es nf"><img src="../Images/da924188d5f78b95501b607e44aa97a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URPvdeV47pE4ShFvzBztTQ.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">这将强制log4j的所有可传递依赖项迁移到2.15.0(补丁版本)</figcaption></figure><p id="ff04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将这段代码合并到主线中，但是<strong class="ih hj">确保有适当的功能测试、canary部署、警报、回滚和恢复机制(如dlqs)，</strong>因为有可能<strong class="ih hj"> </strong>这会导致<strong class="ih hj"> NoClassDefFoundError </strong>(如果其中一个可传递依赖项使用与2.15.0不兼容的log4j版本)。我认为让这个触发器发出警报并知道错误正在发生要比无声无息地失败好得多，因为继续使用易受攻击的版本会让您的应用程序暴露于危险之中。在这种情况下，您可以删除依赖性，要求库的维护者削减一个新的版本(升级您的代码将会很容易，因为您已经有了一个要升级的过程)，或者作为最后的手段(如果您不能删除库并且更新不立即可用)，您可以尝试使用<a class="ae jp" href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-rules.html" rel="noopener ugc nofollow" target="_blank"> WAF规则</a>来过滤传入的流量。</p><h2 id="26e0" class="lr kk hi bd kl ms mt mu kp mv mw mx kt iq my mz kx iu na nb lb iy nc nd lf ne bi translated">多模块构建</h2><p id="1d49" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">与大多数任务不同，跑步。/gradlew dependencies —来自父项目<strong class="ih hj">的写锁不会在子项目</strong>中运行同名的任务。为此，您可以将它包含在您的顶级build.gradle中</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="6753" class="lr kk hi ln b fi ls lt l lu lv">subprojects <strong class="ln hj">{<br/>    </strong>dependencyLocking <strong class="ln hj">{<br/>        </strong>lockAllConfigurations()<br/>    <strong class="ln hj">}<br/>}<br/><br/></strong>task upgradeDependencies(type: Exec) <strong class="ln hj">{<br/>    </strong>List&lt;Object&gt; commandPartsList = new ArrayList&lt;&gt;()<br/>    commandPartsList.add("./gradlew")<br/>    getRootProject().getSubprojects().stream()<br/>                                .map(Project::getName)<br/>                                .forEach(projectName -&gt; {<br/>                                        commandPartsList.add(String.<em class="lw">format</em>("%s:dependencies", projectName))<br/>                                        commandPartsList.add("--write-locks")<br/>                                })<br/>    Object[] commandParts = commandPartsList.toArray(new Object[commandPartsList.size()])<br/>    commandLine commandParts<br/><strong class="ln hj">}</strong></span></pre><p id="aad7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您可以从项目的根目录运行该命令，以更新所有子项目中的依赖项(确保将pr脚本也更改为运行该命令)。使用这种方法，<strong class="ih hj">子模块中不需要任何改变就可以自动升级依赖关系</strong>。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="7511" class="lr kk hi ln b fi ls lt l lu lv">./gradlew upgradeDependencies</span></pre><h1 id="8e14" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">结论</h1><p id="ec4c" class="pw-post-body-paragraph if ig hi ih b ii lh ik il im li io ip iq lj is it iu lk iw ix iy ll ja jb jc hb bi translated">这篇文章向我们展示了，虽然升级库很无聊，但并不一定很痛苦。它详细介绍了一种自动化这一过程的简单方法(只需要在build.gradle中添加三行代码，并安排一个gradle任务运行)，这确保了强大的安全性，同时允许您的开发人员专注于增加业务价值。我们还增加了一个关于可传递依赖管理的额外部分，展示了当您等待其他团队削减您包含在项目中的库的发布时，如何减轻这些风险。最后，我们展示了如何通过注册一个定制任务来最小化代码重复，以便在所有子项目中运行这个任务。</p></div></div>    
</body>
</html>