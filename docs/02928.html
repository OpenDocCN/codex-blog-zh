<html>
<head>
<title>Business Apps development guide with Low coding — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">低编码商业应用开发指南—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/business-apps-development-guide-with-low-coding-part-1-40061b394d5?source=collection_archive---------17-----------------------#2021-08-11">https://medium.com/codex/business-apps-development-guide-with-low-coding-part-1-40061b394d5?source=collection_archive---------17-----------------------#2021-08-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e0aa" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">与Ernesto Diezhandino 合作撰写。</h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/36dc5ad61d545e783309c994d3405869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i9i9fybTYW28VQ5M"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">乐高汽车装配线</figcaption></figure><p id="5ca1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如何在不发疯的情况下，在一周或更短时间内构建一个商业应用<strong class="jq hj">？你可以使用像<a class="ae ix" href="https://www.mendix.com" rel="noopener ugc nofollow" target="_blank"> Mendix </a>或<a class="ae ix" href="https://powerapps.microsoft.com/" rel="noopener ugc nofollow" target="_blank"> Powerapps </a>这样的低代码平台，并支付昂贵的订阅费用，或者你可以在一点帮助(和一些代码)下构建自己的“<strong class="jq hj">低代码</strong>”解决方案</strong></p><p id="9335" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，我选择了一个<a class="ae ix" href="https://en.wikipedia.org/wiki/Low-code_development_platform" rel="noopener ugc nofollow" target="_blank">低代码</a>概念的变体，因为它拥有相同的目标，但获得它的机制非常不同，基本上是使用一个<strong class="jq hj">架构、框架和工具来帮助实现软件可靠性</strong>，只编码业务逻辑的特殊用例或“低代码”。</p><p id="c179" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这里，你可以获得可能对你有帮助的<strong class="jq hj">开源代码、技巧和见解</strong>，特别是如果你是初学者的话。当然，我花了很多年才得出这些结论，所以我希望这能帮助你。</p><p id="6c2a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可以将这些知识应用于任何编程语言，但是源代码是用。网标和<strong class="jq hj">。网5 </strong>。</p><p id="be75" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在了解更多细节之前，以下是您可以从这种低编码解决方案中获得的亮点:</p><ul class=""><li id="92b4" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">它基于开源软件，Apache许可或类似的软件。</li><li id="4336" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">它建立在各种低耦合和可配置的组件之上，使用简洁的架构。</li><li id="8f29" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">遵循坚实的原则和最佳编码实践。</li><li id="1466" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">不是黑匣子，它是你的。</li></ul></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="cb28" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="b877" class="pw-post-body-paragraph jo jp hi jq b jr lx ij jt ju ly im jw jx lz jz ka kb ma kd ke kf mb kh ki kj hb bi translated">非常重要的是要注意，这个想法的种子来自于构建业务应用程序和独立面对以下挑战的长期经验，几乎所有现有的。Net框架(来自。Net 3.5 to。Net 5，显然是几个版本；).</p><p id="51f8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是关于用低编码方法构建业务应用程序的三篇文章中的第一篇，它们是:</p><ol class=""><li id="7b32" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj mc kq kr ks bi translated">架构、最佳实践、想法和编码技巧(就在这里！).</li><li id="e9ee" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj mc kq kr ks bi translated"><a class="ae ix" rel="noopener" href="/@manueljimenezmatilla/business-apps-development-guide-with-low-coding-part-2-backend-3016eee91c10?sk=bd139dd3ece75b018aa1110a36bda2f3">后端解决方案</a>。</li><li id="0ae7" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj mc kq kr ks bi translated"><a class="ae ix" rel="noopener" href="/@manueljimenezmatilla/business-apps-development-guide-with-low-coding-part-3-ui-406694e08bc5">前端解决方案</a>。</li></ol><h1 id="8d54" class="lf lg hi bd lh li md lk ll lm me lo lp io mf ip lr ir mg is lt iu mh iv lv lw bi translated">架构、最佳实践、想法和编码技巧</h1><p id="b183" class="pw-post-body-paragraph jo jp hi jq b jr lx ij jt ju ly im jw jx lz jz ka kb ma kd ke kf mb kh ki kj hb bi translated">选择一个好的架构解决方案将帮助你进行项目组织，这在中型和大型项目中是最有价值的事情。然而，如果你在一个小的开发中使用它，也会有所帮助。</p><p id="e48c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">基于组件的六边形架构是我个人最喜欢的，但是一个干净的架构更适合低编码的解决方案，这就是为什么在这篇文章中，我将使用一个干净的架构组织，但是使用组件进行开发。</p><p id="ae65" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">选择这种方法的主要原因是组件是制作可重用和可配置代码模块的最自然的方式。</p><h1 id="ee7b" class="lf lg hi bd lh li md lk ll lm me lo lp io mf ip lr ir mg is lt iu mh iv lv lw bi translated">调解人</h1><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mi"><img src="../Images/f71c6005e0bca5291c54e8490fac73b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/0*609foEl-UG0XyspO"/></div></figure><p id="3fcc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可以从维基百科的这篇<a class="ae ix" href="https://en.wikipedia.org/wiki/Mediator_pattern" rel="noopener ugc nofollow" target="_blank">文章</a>中读到:</p><p id="a2ec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="mj">在</em> <a class="ae ix" href="https://en.wikipedia.org/wiki/Software_engineering" rel="noopener ugc nofollow" target="_blank"> <em class="mj">软件工程</em> </a> <em class="mj">中，</em> <strong class="jq hj"> <em class="mj">中介模式</em> </strong> <em class="mj">定义了一个对象，即</em> <a class="ae ix" href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)" rel="noopener ugc nofollow" target="_blank"> <em class="mj">封装了</em> </a> <em class="mj">一组对象如何交互。这种模式被认为是一种</em> <a class="ae ix" href="https://en.wikipedia.org/wiki/Behavioral_pattern" rel="noopener ugc nofollow" target="_blank"> <em class="mj">行为模式</em> </a> <em class="mj">，因为它可以改变程序的运行行为</em>。</p><p id="c273" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在后端解决方案中，我们将使用大量的组件，其中一些组件需要以严格的顺序调用，因此该模式将帮助我们:</p><ul class=""><li id="36f9" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated"><strong class="jq hj">为信息流建立唯一的路径</strong>。</li><li id="ef0e" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">在其中注册组件。</li><li id="5b1f" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">监控和审计信息流。</li></ul><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h1 id="6b94" class="lf lg hi bd lh li md lk ll lm me lo lp io mf ip lr ir mg is lt iu mh iv lv lw bi translated">坚实的原则——单一责任</h1><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mm"><img src="../Images/648c1bc33708096af4fcd6ae29d2187c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XM01RtLFUuv-wh-Jq5Lo3w.png"/></div></div></figure><p id="dd3e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">很好地掌握这些原则是很难的，当你达到时，你会觉得自己已经是一个前辈了。也许最有价值也是最难解决的问题是<strong class="jq hj">单一责任原则</strong>。从头开始牢记这一点将有助于我们使事情变得可重用、可扩展和可靠，这些软件属性是最大化项目生命周期的关键。</p><p id="5db6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">设计基于组件的软件有助于实现这个目标，因为每个组件都有一个单一的入口点，这将有助于您轻松地扩展它。举个例子:如果您为您的解决方案考虑一个通知组件，而不是调用一些助手库来发送通知，您将获得一个单一的入口点，您可以在其中轻松地添加审计功能。</p><h1 id="6563" class="lf lg hi bd lh li md lk ll lm me lo lp io mf ip lr ir mg is lt iu mh iv lv lw bi translated">命名事物</h1><p id="cfe6" class="pw-post-body-paragraph jo jp hi jq b jr lx ij jt ju ly im jw jx lz jz ka kb ma kd ke kf mb kh ki kj hb bi translated">或者选择一个好名字如何促进你的发展</p><p id="4a8c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="mj">“计算机科学只有两个硬东西:缓存失效和事物命名。”</em></p><p id="44cd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">—菲尔·卡尔顿</p><p id="c58b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">关于“命名事物”,有一个明显的部分是低年级学生用来开玩笑的，尽管它肯定不是，你可以在这篇<a class="ae ix" rel="noopener" href="/hackernoon/naming-the-things-in-programming-230590016f00">媒体文章</a>中读到它。</p><p id="af4c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是名字应该是什么样的呢？除了作为一个符合良好实践的惟一标识符(如前一篇文章所述)，它还应该遵循一种模式，这使得下一个技巧代码生成器成为可能。</p><h1 id="bfaf" class="lf lg hi bd lh li md lk ll lm me lo lp io mf ip lr ir mg is lt iu mh iv lv lw bi translated">代码生成器</h1><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es mn"><img src="../Images/0b9916aaba23bddb413a5db57b665901.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*KCUJHW0bTHrdGqshgVOctA.jpeg"/></div></figure><p id="25bb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我告诉你，你可以生成几乎所有的应用程序代码，或者至少是它的第一个版本，即使你遵循一些简单的指导方针就可以做到，你也不能全信。像许多其他工具一样，它可能真的很危险，所以有一些正确使用它的技巧:</p><ol class=""><li id="34cc" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj mc kq kr ks bi translated">永远记住可扩展的固体原理。</li><li id="35e1" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj mc kq kr ks bi translated">使用模板保持简单，避免黑盒。</li><li id="d483" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj mc kq kr ks bi translated">记录您的生成器所使用的模式。</li><li id="a60e" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj mc kq kr ks bi translated">最好把它作为一个助手，而不是代码的替代品。</li></ol><p id="1b82" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">生成器的能力利用了名称中的模式</strong>，并在此基础上应用转换。你可以用它们解决的第一件事是数据库实体模型方案，这里有很多你可能不会用到的信息。</p><p id="4ada" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可以很好地利用数据库表元数据，如:列名，数据类型，主键和外键，可空，最大长度，默认值…可以生成:</p><ul class=""><li id="9006" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">实体模型类。</li><li id="a9d7" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">验证类。</li><li id="b5fd" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">实体表单*。</li></ul><pre class="iz ja jb jc fd mo mp mq mr aw ms bi"><span id="de3c" class="mt lg hi mp b fi mu mv l mw mx">*Note: If you work with database views, probably this can bring you some valuable data for building more complex UI components, such as grids with filters, for example.</span></pre><p id="c94f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，您可以利用的是项目结构，它可以基于数据库模型层次结构，也可以位于UI路径或API路径中。这些信息可以帮助您构建或建模:</p><ul class=""><li id="4343" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">项目结构。</li><li id="00ea" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">API路线。</li><li id="2275" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">导航组件。</li></ul><p id="bfb4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">制作生成器非常简单，你可以找到一个<strong class="jq hj"> C# POCO objects builder </strong>，遵循自底向上的方法<a class="ae ix" href="https://codverter.com/src/sqltoclass" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5c99" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你也可以像<a class="ae ix" href="https://marketplace.visualstudio.com/items?itemName=SimonHughes.EntityFrameworkReversePOCOGenerator" rel="noopener ugc nofollow" target="_blank">entity framework Reverse POCO Code First Generator</a>一样使用付费库。</p><p id="454a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">也有在线生成器，这是我个人最喜欢的将<a class="ae ix" href="https://json2csharp.com" rel="noopener ugc nofollow" target="_blank"> Json转换成C# </a>的工具之一。</p><h1 id="7b81" class="lf lg hi bd lh li md lk ll lm me lo lp io mf ip lr ir mg is lt iu mh iv lv lw bi translated">隐藏物</h1><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es my"><img src="../Images/21657270a7bb446169c4c03f4e3cd15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UrDCrqNcP8JQrdGW"/></div></div></figure><p id="5a56" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用缓存存储数据是提升应用程序的最佳方式之一，开发缓存组件很简单，只要您从一开始就实现它。</p><p id="786a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有很多缓存库可以让你很快玩起来，我最喜欢的是<a class="ae ix" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>。</p><p id="dfad" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可以用几行代码构建自己的缓存组件，但是正确使用它是另一回事。</p><p id="9529" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我建议<strong class="jq hj">为您的数据库访问</strong>建立一个单一入口点，然后您可以做以下事情:</p><ul class=""><li id="a33a" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">当数据被修改时，使缓存无效。</li><li id="007d" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">读取缓存中的数据，如果不存在，则加载到缓存中。</li></ul><p id="58b5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一件重要的事情是配置“可缓存的”实体，以避免Ram过度消耗。</p><h1 id="5877" class="lf lg hi bd lh li md lk ll lm me lo lp io mf ip lr ir mg is lt iu mh iv lv lw bi translated">配置器模式</h1><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es mz"><img src="../Images/a7505309360bccdb52f8c0400e3e583d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eoo0M5K-yAhgdi2h"/></div></div></figure><p id="d72a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">组件需要配置，尽管为了解决配置问题，我们必须考虑到每个配置通常取决于外部变量，即:系统环境、用户语言、设备类型等。</p><p id="7666" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">简而言之，配置器模式应该帮助您:</p><ul class=""><li id="0a08" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated"><strong class="jq hj">整理</strong>你的组件配置参数。</li><li id="0468" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><strong class="jq hj">过载</strong>你的组件为每个外部变量配置。</li><li id="0c63" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">通过避免问题的代码类来配置组件。</li></ul><p id="096b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们用<strong class="jq hj">控制反转</strong> (IoC)技术创建一个简单的通用配置器。</p><p id="b745" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">IoC技术提供了一种为每个组件解耦多个配置的方法，但是让我先解释一下它是如何工作的:</p><ul class=""><li id="94af" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">注册类(配置)</li><li id="5559" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">寻找合适的类别(配置)</li><li id="1519" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">注射它</li></ul><p id="0c56" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要将基本的IoC控件转换成配置组件，我们需要添加:</p><ul class=""><li id="5ea0" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">具有接口的基本配置抽象类</li><li id="0c41" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">配置类属性来查找正确的配置。这些属性是查找配置所需的过滤关键字，即基于实体类型和外部变量。</li></ul><p id="48f6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，配置组件作业包括:</p><ul class=""><li id="05da" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">注册配置类型</li><li id="b092" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">根据类型和外部变量获取配置</li><li id="1613" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">调用配置界面发布的配置方法。</li></ul><p id="5d5f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们还可以使用缓存系统来存储静态配置，为了达到这个目标，我们可以简单地添加一个“可缓存的”布尔属性。</p><p id="9cd2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该组件有一个部分隐藏的功能，对于部署具有相同原始属性的不同功能非常有帮助，例如:为不同设备开发ui。在这种情况下，您可以通过拥有一个共享属性的公共库来利用此配置组件，然后在最终项目中覆盖属性来扩展它。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h1 id="e89b" class="lf lg hi bd lh li md lk ll lm me lo lp io mf ip lr ir mg is lt iu mh iv lv lw bi translated">审计员</h1><p id="d4f9" class="pw-post-body-paragraph jo jp hi jq b jr lx ij jt ju ly im jw jx lz jz ka kb ma kd ke kf mb kh ki kj hb bi translated">直到灾难降临，这个组件的相关性才被注意到。那你可能会希望你有一个。这是最可重用的组件之一，你可以编写一次代码，然后在你所有的项目中使用，或者使用像Audit.Net这样的库。</p><p id="ee3d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">审核员的任务是:</p><ul class=""><li id="6cf1" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">编译关于会话、请求和响应的信息。</li><li id="15ec" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">将这些信息写入数据库。</li></ul><p id="3e92" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个组件的技巧是使用动态类型和Json转换器。</p><p id="d5aa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，您应该在中介路径中注册这个组件，使它可以在开始时调用它，然后在结束时调用它。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="7d21" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated">结论</h1><p id="bffd" class="pw-post-body-paragraph jo jp hi jq b jr lx ij jt ju ly im jw jx lz jz ka kb ma kd ke kf mb kh ki kj hb bi translated"><strong class="jq hj">考虑长远</strong>，考虑制造可重用和可配置的组件，不要回避使用复杂的高级开发概念。听起来很奇怪，但很有效。</p><p id="2b3d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我鼓励你们把目光放在奥林匹克精神的地平线上:“hendiatris Citius，Altius，Fortius”。翻译成IT术语:<strong class="jq hj">快，用顶尖技术，做可靠产品</strong>。</p><p id="332e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">本文的第二部分将处理解决方案的核心，后端开发，您将获得更多的技巧、见解和代码:)我希望它对您有用。</p></div></div>    
</body>
</html>