<html>
<head>
<title>Terraform CI/CD using GitLab child pipelines and Jsonnet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitLab子管道和Jsonnet的Terraform CI/CD</h1>
<blockquote>原文：<a href="https://medium.com/codex/terraform-ci-cd-using-gitlab-child-pipelines-and-jsonnet-81f02a18dbe4?source=collection_archive---------4-----------------------#2021-08-02">https://medium.com/codex/terraform-ci-cd-using-gitlab-child-pipelines-and-jsonnet-81f02a18dbe4?source=collection_archive---------4-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/191b3c8ede91671e3278b24a66d260e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A0-yGzoeYGOKD_yO.png"/></div></div></figure><p id="abbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您正在阅读本文，那么您可能知道Terraform和GitLab CI功能，因此我不会在本文中涉及这些内容。如果您想了解这些主题的更多信息，关于<a class="ae jo" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>、<a class="ae jo" href="https://www.terraform.io/docs/cli/workspaces/index.html" rel="noopener ugc nofollow" target="_blank"> Terraform workspaces </a>和<a class="ae jo" href="https://about.gitlab.com/stages-devops-lifecycle/continuous-integration/" rel="noopener ugc nofollow" target="_blank"> Gitlab CI </a>概念的几个链接将是一个很好的起点。</p><p id="aa05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Gitlab CI已经可以用于您的Terraform CI/CD。实际上，只需编写几行YAML代码，就可以描述一个轻型/简单地形项目的管道，该项目将计划并应用您的代码。然而，当涉及到为几个环境编写的Terraform项目，跨越几个帐户和工作空间时，编写一个CI/CD来保持您或您的团队成员的可读性和可维护性会变得很麻烦。</p><p id="41b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">减轻和缓解上述问题的一个方法是使用YAML锚，或者Gitlab关键字extends。由于这些，您可以通过复制/粘贴一些带有移动变量的块来实现一些模板化和添加新的作业。我会说，少于5个帐户或工作区是没问题的，但是如果超过几个，你将引入大量的副本/面食，这可能导致人为错误。</p><p id="fbcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当讨论Gitlab中的模板化作业时，一个有趣的特性是父/子管道，它允许您基于一些配置作业动态或不动态地生成作业。Gitlab为一些语言提供了模板，这里我们将使用<a class="ae jo" href="https://jsonnet.org/" rel="noopener ugc nofollow" target="_blank"> Jsonnet </a>来简化编写。</p><p id="de7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，我们要建造什么？又是怎么做到的？</p><p id="e605" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们希望构建一个Gitlab CI/CD管道，它将需要尽可能少的代码行来创建必要的作业集，以运行terraform plan/apply来应用新的工作空间，方法是利用Jsonnet来动态生成几个作业。</p><h1 id="e529" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我们如何实现它？</h1><p id="cac4" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">首先，我们想描述一下我们的计划工作。使用Jsonnet，地形规划作业可以描述如下:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="8075" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，这是一项Gitlab CI工作，但我们没有像往常一样在YAML进行描述，而是在Json中进行描述。但是让我们把它分解一下:</p><ul class=""><li id="34a4" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated">这是我们将在本文后面调用的函数的名称，它有3个参数:<code class="du lh li lj lk b">cloud</code>、<code class="du lh li lj lk b">env</code>、<code class="du lh li lj lk b">workspace</code>。这些将被填充，但现在作为占位符。</li></ul><pre class="ks kt ku kv fd ll lk lm ln aw lo bi"><span id="f009" class="lp jq hi lk b fi lq lr l ls lt">plan(cloud, env, workspace)::{</span><span id="c83c" class="lp jq hi lk b fi lu lr l ls lt">}</span></pre><ul class=""><li id="9390" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated"><code class="du lh li lj lk b">image:</code>描述我们将使用的跑步者形象</li><li id="e80f" class="ky kz hi is b it lv ix lw jb lx jf ly jj lz jn ld le lf lg bi translated"><code class="du lh li lj lk b">stage: 'plan'</code>是我们管道阶段的名称</li><li id="d507" class="ky kz hi is b it lv ix lw jb lx jf ly jj lz jn ld le lf lg bi translated"><code class="du lh li lj lk b">script:</code>包含我们的跑步者运行的命令。这是动态事物发生的地方。我们在我们的环境文件夹中更改dir，运行<code class="du lh li lj lk b">terraform init</code>，选择我们的工作区并运行<code class="du lh li lj lk b">terraform plan</code>。</li><li id="4288" class="ky kz hi is b it lv ix lw jb lx jf ly jj lz jn ld le lf lg bi translated"><code class="du lh li lj lk b">rules:[]</code>表示当提交是merge_request的一部分时，或者当它针对默认分支运行时，只有在特定环境文件夹中有更改时，我们才希望运行该作业。</li><li id="e433" class="ky kz hi is b it lv ix lw jb lx jf ly jj lz jn ld le lf lg bi translated"><code class="du lh li lj lk b">artifacts:</code>描述了我们的工件，在这种情况下，我们希望使我们的计划成为apply将使用的工件。</li></ul><p id="169a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ma">一个旁注关于变量</em> <code class="du lh li lj lk b"><em class="ma">$COMMIT_REF_NAME</em></code> <em class="ma">和</em> <code class="du lh li lj lk b"><em class="ma">$DEFAULT_BRANCH</em></code> <em class="ma">。由于CI预定义变量不会从父管道传递到子管道，所以我们必须将它们显式地作为变量传递(我将在本文后面解释)。</em></p><p id="e5df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">提到申请工作，让我们看看它是什么样子的！如上所述，Terraform应用作业应写成这样:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="7cff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一些明显的区别:</p><ul class=""><li id="1d11" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated"><code class="du lh li lj lk b">stage:</code>成为适用</li><li id="4a47" class="ky kz hi is b it lv ix lw jb lx jf ly jj lz jn ld le lf lg bi translated"><code class="du lh li lj lk b">rules:when:'manual'</code>表示我们想要明确点击播放按钮来运行作业</li><li id="d694" class="ky kz hi is b it lv ix lw jb lx jf ly jj lz jn ld le lf lg bi translated"><code class="du lh li lj lk b">needs:</code>表示必须在该工作区的计划成功后运行</li></ul><p id="a3c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">恭喜你！我们现在有两个需要填充值的框架作业！</p><p id="60d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在另一个jsonnet文件中这样做，该文件用于实际生成我们需要的gitlab-ci文件。下面是配置:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div><figcaption class="mb mc et er es md me bd b be z dx translated">在gitlab-ci.jsonnet</figcaption></figure><p id="92dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lh li lj lk b">local</code>是一个Jsonnet变量。我们首先导入前面的文件，并在json对象中描述我们的参数。这是声明<code class="du lh li lj lk b">cloud</code>和<code class="du lh li lj lk b">workspace</code>占位符的地方。</p><p id="3d1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本例中，<code class="du lh li lj lk b">organization</code>模块有一个同名的工作空间，而<code class="du lh li lj lk b">staging</code>和<code class="du lh li lj lk b">production</code>有两个不同的工作空间，名为<code class="du lh li lj lk b">env-region</code>。</p><p id="986a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看如何使用我们的骨架和局部变量来实际生成工作。这是通过对变量运行函数来实现的，其中有两个嵌套的for循环:</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div><figcaption class="mb mc et er es md me bd b be z dx translated">在gitlab-ci.jsonnet</figcaption></figure><p id="5303" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在已经准备好以json的形式生成Gitlab作业了。我们预计有5个计划工作和5个应用工作。让我们试着运行<code class="du lh li lj lk b">jsonnet gitlab-ci.jsonnet &gt; generated-gitlab-ci.yml</code>，看看会有什么结果。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="404d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经可以看到，在Jsonnet的70行代码中，我们生成了将近300行工作。</p><p id="6d6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无论如何，我想现在是自动化的时候了，因为这是我们的最终目标！我们现在有两个Jsonnet文件，但是我们仍然缺少必需的。gitlab-ci.yml文件需要启动管道。</p><p id="3b15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要描述将用于生成所有作业并触发terraform子管道的父管道，如下所示:</p><ul class=""><li id="3492" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated"><code class="du lh li lj lk b">stages</code>:</li></ul><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><ul class=""><li id="8ed4" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated">我们的作业生成，我们将结果文件公开为一个<code class="du lh li lj lk b">artifact</code>:</li></ul><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><ul class=""><li id="0bd9" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated">子管道触发器:</li></ul><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="8a94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来分解最后一项工作:</p><ul class=""><li id="6deb" class="ky kz hi is b it iu ix iy jb la jf lb jj lc jn ld le lf lg bi translated"><code class="du lh li lj lk b">variables:</code>是我们将需要的预定义CI变量传递给子管道的地方</li><li id="57ff" class="ky kz hi is b it lv ix lw jb lx jf ly jj lz jn ld le lf lg bi translated"><code class="du lh li lj lk b">trigger:</code>包括两个文件:一个文件描述子管道的缓存和阶段，以及上一步生成的作业</li></ul><h1 id="e5ae" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">将碎片拼在一起</h1><p id="6067" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">一旦您将在其中一个terraform文件中提交更改，您的合并请求的分离管道应该类似于下面的管道:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/2675141874a769f0ddbb85994920a129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5F_7N5BHFXLjWzDtk0fRBw.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">terraform的merge_request中的Gitlab CI父/子管道</figcaption></figure><p id="1fce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的图像不是来自我们建立的管道，因为我正在做的Terraform项目有点不同，但是除了<code class="du lh li lj lk b">tfsec</code>的工作，你的计划管道应该是一样的。</p><p id="940d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能认为我们只是做了我们通常在一个普通的YAML <code class="du lh li lj lk b">.gitlab-ci.yml</code>文件中做的事情，但是在这个过程中添加了2个新的文件来管理。“<em class="ma">有什么意义？”</em>你可能会问。现在，您可以为一个额外的模块或工作空间运行相同的管道，只需在您的<code class="du lh li lj lk b">local conf {}</code>变量中添加一行代码。</p><p id="4a42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，还有很多其他的东西可以改进这个示例代码，但重点是让您大致了解父/子管道可以为您的Terraform管道带来什么。</p><p id="ee1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在撰写本文时，有一点需要注意的是，在MR中还不能使用terraform报告，而这恰好非常有用。但是Gitlab有一个开放的问题，让子管道工件在MR。</p><p id="3b85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的GitLab repo 中用于本文的所有代码。感谢您阅读本文，我希望它能帮助您为您的Terraform项目构建高效的GitLab CI管道！如果有，让我在评论里看看吧！</p></div></div>    
</body>
</html>