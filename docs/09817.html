<html>
<head>
<title>The design behind Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Express背后的设计</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-design-behind-express-b1da569c7e43?source=collection_archive---------8-----------------------#2022-11-11">https://medium.com/codex/the-design-behind-express-b1da569c7e43?source=collection_archive---------8-----------------------#2022-11-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a466" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">从设计角度看快速路由和中间件如何工作</h2></div><p id="b257" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每一个代码库，为了得到广泛的使用，都必须易于使用，并且在保持其健壮性和高度特性的同时，还可以扩展。</p><p id="6517" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将考察一个著名的库，以及他们如何通过开发设计好的代码来实现那些需求。我将带您了解流行的NodeJS web服务器、中间件和路由机制的设计和工作原理。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/8a22cbca4b26bb098c24444c19b434c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/0*ye7Tb0uir7q6MRNZ"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">快速缩略图</figcaption></figure><p id="b708" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，<br/>如果您不熟悉express，这是一个最小且灵活的NodeJS web应用程序框架，它为web和移动应用程序提供了一组健壮的特性。</p><p id="a668" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您没有使用express的经验，并且想尝试一下，您可以从express项目生成器命令开始:</p><pre class="ju jv jw jx fd kf kg kh ki aw kj bi"><span id="709d" class="kk kl hi kg b fi km kn l ko kp">npx express-generator</span></pre><p id="f65e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该命令将生成一个express web应用程序的示例，如您在<em class="kq"> index.js </em>页面上看到的那样，该示例包含一些路由和中间件。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kr"><img src="../Images/58685775799b51f2abb891eee892bd85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*7uuHCSsDFXf9NNBg1YgQFg.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">3快速样本索引. js</figcaption></figure><p id="59f9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个路由和中间件使用<em class="kq"> app.use </em>命令注册，可以接收路径和处理函数。handle函数有三个参数，请求、响应和下一个函数，我们可以看到，它们用于将请求转发到另一个路由或中间件来处理它。</p><p id="c8a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快速路由机制基于四人组23设计模式之一。</p><p id="13be" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你不熟悉设计模式，特别是四人组的设计模式，我将很快解释这一点。设计模式是软件设计中反复出现的问题的可重用解决方案。它不是一段完整的代码，而是一个帮助解决特定问题或一系列问题的模板。</p><p id="3e79" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">四人组的作者Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides在软件开发中提出了设计模式的概念。在他们的书中，他们提出了23种设计模式，其中一种是责任链，这种设计模式使快递路由以它的方式工作。</p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><h1 id="cefe" class="kz kl hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">责任链</h1><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lq"><img src="../Images/ed7013dbc990cc2c46bf6c2b3ed2b46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*ua8lMpS0GJEq5Oy6SqeSXA.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">链式缩略图</figcaption></figure><p id="d3d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">责任链是四人帮书中的行为模式之一。</p><p id="a13f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种模式并不经常使用设计模式，但它在著名的web服务器库Express中占有很大的比重。</p><h2 id="5a7a" class="kk kl hi bd la lr ls lt le lu lv lw li jg lx ly lk jk lz ma lm jo mb mc lo md bi translated"><strong class="ak">那么，这个模式的目标是什么:</strong></h2><p id="bb0c" class="pw-post-body-paragraph ix iy hi iz b ja me ij jc jd mf im jf jg mg ji jj jk mh jm jn jo mi jq jr js hb bi translated">这种模式的主要目标是避免将请求的发送者耦合到接收者，同时给多个对象一个处理请求的机会。</p><p id="c2b4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着该模式让您<strong class="iz hj">沿着处理程序链传递请求。</strong>当接收到一个请求时，每个处理程序决定要么处理该请求，要么将其传递给链中的下一个处理程序。</p><h2 id="4ecd" class="kk kl hi bd la lr ls lt le lu lv lw li jg lx ly lk jk lz ma lm jo mb mc lo md bi translated">它看起来会像这样:</h2><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es mj"><img src="../Images/e5de80a0295106d4fd217e2cb3948e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*5SN0RfEuN8C-tZNCVbZYVg.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">责任链UML</figcaption></figure><h2 id="c0e6" class="kk kl hi bd la lr ls lt le lu lv lw li jg lx ly lk jk lz ma lm jo mb mc lo md bi translated">工作原理:</h2><p id="ce95" class="pw-post-body-paragraph ix iy hi iz b ja me ij jc jd mf im jf jg mg ji jj jk mh jm jn jo mi jq jr js hb bi translated">现在让我们来看看这个模式的不同部分。</p><p id="2d77" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> Handler </strong>:处理请求的接口。<br/> <strong class="iz hj"> ConcreteHandler </strong>:处理程序的实现，要么将请求转发给下一个处理程序，要么作为继任者并结束处理请求。<br/> <strong class="iz hj">客户端</strong>:客户端是向处理程序发起请求的一方。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mk"><img src="../Images/4b29dd9faa4445c5255a7d45d6d4a8fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g42G5kcbSx-wYeTbJw2bcw.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">请求链场景</figcaption></figure></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><p id="39c9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经理解了责任链模式的目标和用途，让我们看看express是如何在其路由架构中实现它的。</p><p id="adf2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Express library是开源代码，这就是我们如何从它的代码中学习并了解它是如何工作的。</p><p id="1054" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也可以看看<a class="ae mp" href="https://github.com/expressjs/express" rel="noopener ugc nofollow" target="_blank"> express源代码。</a></p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es mq"><img src="../Images/43159efd80f9b3bd39ab02786fcd6f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*RGUpskVilTVNRKwY9_C6Ig.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">快速层</figcaption></figure><p id="440b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，具体的路由和中间件都是“层”。</p><p id="c453" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们所见，每一层都有路径、选项和功能。<br/>同样，我们可以看到handle函数接收三个参数(请求、响应和下一个函数)。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es mr"><img src="../Images/45766fd653c6815199614305f8d1bf93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*ne6bQhZCu2RvPy3xocI4mg.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">快速层句柄</figcaption></figure><p id="8868" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很容易看出，我们之前在创建层时应用的函数就是现在在<em class="kq"> handle_request </em>中运行的函数。</p><p id="a9ed" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是我们如何准确地创建处理程序，<br/>我们熟悉命令<em class="kq"> app .使用</em>来注册中间件或路由。</p><p id="9619" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当返回源代码时，我们将看到这个use函数的实现，在这个函数的末尾，我们可以看到Layer对象的创建，以及将该对象插入到包含所有层的堆栈数组中。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ms"><img src="../Images/8398e4b98a815041e0b863af7eccee02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*A5o3o3DJO-HmWsfc6siwSA.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">快速使用功能</figcaption></figure><p id="b27a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kq">我们将看到每个注册路由或中间件的函数都是一样的，比如路由函数。</em></p><h2 id="25a1" class="kk kl hi bd la lr ls lt le lu lv lw li jg lx ly lk jk lz ma lm jo mb mc lo md bi translated">在浏览了路线注册代码流后，我们了解到:</h2><p id="961a" class="pw-post-body-paragraph ix iy hi iz b ja me ij jc jd mf im jf jg mg ji jj jk mh jm jn jo mi jq jr js hb bi translated"><strong class="iz hj"> </strong>我们的处理程序是层对象。<br/> <strong class="iz hj"> </strong>我们看到了ConcreteHandler对象的创建。<br/> <strong class="iz hj"> </strong>并将所有的ConcreteHandler对象存储在stack属性数组中。</p><p id="66a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建处理程序是不够的，要看到链模式，我们需要查看我们设计中的“客户端”和链中的请求流。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es mt"><img src="../Images/7ebe4a1f067ffe30479d39922d51be95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*zIDw0i_Tv9jH2J_lukNMZg.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">快速处理功能</figcaption></figure><p id="cc8e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在handle函数中，我们可以看到所有参数的准备，甚至CORS飞行前流程的特殊处理选项请求，但我们关心的是最后对下一个函数的调用。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="er es mu"><img src="../Images/0234d9d594e7573c5b873145114c01ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*U4cx0_XKr18FBNgLug9uNQ.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">快速下一个功能</figcaption></figure><p id="7ebd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下一个函数中，我们检查先前初始化的局部索引变量<em class="kq"> idx </em> index是否不大于堆栈的长度，该索引是堆栈数组中当前层的索引。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es mv"><img src="../Images/2bf088e428d3878817b6b8b42ffae0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*qymMIxJ0neQ1PSYQCC0F4A.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">快速下一个功能</figcaption></figure><p id="e0ef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们看到了前面的<em class="kq">层. handle_request </em>及其所有参数，这些参数激活了我们的路由代码。</p><p id="ec41" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以现在你在问这个链是如何继续的，<em class="kq"> handle_request </em>获得了下一个函数参数，这个参数是之前的同一个下一个函数，带有当前路由的<em class="kq"> idx </em>索引，现在如果<em class="kq"> handle_request </em>层是一个后继层-ConcreteHandler，将不会使用这个下一个函数，因为这个路由是链的结束处理程序，但是如果这个路由调用了下一个函数， 我们将再次进入下一个函数，<em class="kq"> idx </em>索引将递增，并且<em class="kq"> handle_request </em>将调用链中的下一个路由。</p><p id="edc5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，这不是express中的所有代码，还有更多，比如在处理之前检查路由路径是否匹配。<br/>如果我们深入观察，我们会发现层对象设计也是一种模板方法设计模式，在同一结构中注册和调用不同的功能。</p></div><div class="ab cl ks kt gp ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hb hc hd he hf"><h1 id="9af2" class="kz kl hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">我们总结一下:</h1><p id="349d" class="pw-post-body-paragraph ix iy hi iz b ja me ij jc jd mf im jf jg mg ji jj jk mh jm jn jo mi jq jr js hb bi translated">快速路由使用责任链模式来实现中间件链处理功能。<br/>通过这种实现方式，他们用这样一个简单的API实现了路由器的主要功能。</p><h2 id="f317" class="kk kl hi bd la lr ls lt le lu lv lw li jg lx ly lk jk lz ma lm jo mb mc lo md bi translated">如果我们看看express中的模式部分:</h2><p id="851b" class="pw-post-body-paragraph ix iy hi iz b ja me ij jc jd mf im jf jg mg ji jj jk mh jm jn jo mi jq jr js hb bi translated"><strong class="iz hj">处理程序</strong>是层对象</p><p id="3881" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">具体处理程序</strong>是我们的中间件和路由</p><p id="fb95" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"/></p><p id="e524" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">客户端</strong>是启动处理程序链的调用执行流的处理函数</p><p id="06f3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">处理程序通过使用“next()”</strong>函数调用下一个ConcreteHandler函数，继续处理链中的处理程序</p><p id="bc35" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望这篇文章对你有所帮助，并且希望下次你使用一些库的时候，它能帮助你理解为什么工程师会这样设计代码。</p><p id="f98b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>