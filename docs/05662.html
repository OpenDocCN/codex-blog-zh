<html>
<head>
<title>D3.js Made Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">D3.js变得简单</h1>
<blockquote>原文：<a href="https://medium.com/codex/d3-js-made-easy-103a5c36e852?source=collection_archive---------7-----------------------#2022-03-20">https://medium.com/codex/d3-js-made-easy-103a5c36e852?source=collection_archive---------7-----------------------#2022-03-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="7f8f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">摘要</h1><blockquote class="jd je jf"><p id="96ef" class="jg jh ji jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为什么要用D3？</p><p id="f9c5" class="jg jh ji jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">逻辑结构</p><p id="f7c4" class="jg jh ji jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">1.数据—起点</p><p id="09d1" class="jg jh ji jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">2.规模——最基本的元素</p><p id="6e49" class="jg jh ji jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">3.轴-参照导向</p><p id="2121" class="jg jh ji jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">4.标记——几何图元</p></blockquote></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">D3的例子</figcaption></figure><h1 id="441d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">为什么要用D3？</h1><p id="642d" class="pw-post-body-paragraph jg jh hi jj b jk kx jm jn jo ky jq jr kz la ju jv lb lc jy jz ld le kc kd ke hb bi translated">D3或数据驱动文档是世界上最著名的开源数据可视化项目之一。简而言之，它是一个基于数据操作HTML元素的JavaScript图表库。</p><p id="130c" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">过去20年来，可视化行业的发展导致了成熟的可视化分析软件的广泛传播，如Qlik、Tableau、SAS Visual Analytics、Power BI等。这些软件通过提供极其<strong class="jj hj">简单和快速</strong>的方式来构建图表，从而迅速占领了市场。但是使用预构建的工具有一系列的缺点:</p><ul class=""><li id="28f5" class="lf lg hi jj b jk jl jo jp kz lh lb li ld lj ke lk ll lm ln bi translated">通常有付费许可证</li><li id="ccbb" class="lf lg hi jj b jk lo jo lp kz lq lb lr ld ls ke lk ll lm ln bi translated">他们的免费版本，当存在时，对所产生的图表的使用有限制</li><li id="cdc2" class="lf lg hi jj b jk lo jo lp kz lq lb lr ld ls ke lk ll lm ln bi translated">图表选择仅限于界面可选择的图表</li><li id="3178" class="lf lg hi jj b jk lo jo lp kz lq lb lr ld ls ke lk ll lm ln bi translated">同一个工具可以附带无限数量的要学习的不同应用程序(例如，参见Tableau的服务器/公共/桌面/阅读器/移动/ PrepBuilder…版本)</li><li id="c9aa" class="lf lg hi jj b jk lo jo lp kz lq lb lr ld ls ke lk ll lm ln bi translated">更多地强调商业智能方面，而不是web标准</li><li id="969d" class="lf lg hi jj b jk lo jo lp kz lq lb lr ld ls ke lk ll lm ln bi translated">难以连续编程和复制的图形</li><li id="fa25" class="lf lg hi jj b jk lo jo lp kz lq lb lr ld ls ke lk ll lm ln bi translated">无法创建非常具体的自定义数据交互</li><li id="3a2b" class="lf lg hi jj b jk lo jo lp kz lq lb lr ld ls ke lk ll lm ln bi translated">普遍缺乏对低级元素的定制</li></ul><p id="8ec0" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">另一方面，D3克服了所有这些限制，代价是更大的<strong class="jj hj">复杂性，</strong>与浏览器文档对象模型(DOM)、SVG标记语言和JavaScript的处理相关，后者通常冗长，难以学习、理解和调试。</p><p id="55f5" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">比较这两种工具并不容易，因为选择往往是强制性的:如果你不是一个Web开发人员，你可能会倾向于放弃D3，而倾向于上面提到的那些更加用户友好的解决方案。然而，所有这些都失去了一个发展个人设计和创造难以置信的独特可视化的好机会，利用一个开放的图书馆，总而言之，通过正确的指示，每个人都可以达到。</p><p id="ad21" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">所以，如果你对这个世界有更多的好奇，让我们深入了解一下吧！</p><h1 id="8ef3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">逻辑结构</h1><p id="5d92" class="pw-post-body-paragraph jg jh hi jj b jk kx jm jn jo ky jq jr kz la ju jv lb lc jy jz ld le kc kd ke hb bi translated">在本文中，我们将重点关注用这个库构建一个基本图表的主要方面，将整个过程分解为4个构建块，使其易于理解和快速执行。</p><p id="09d8" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">这4个构件是:</p><p id="6e10" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">💾<strong class="jj hj">数据</strong>数据<br/>📏<strong class="jj hj">音阶</strong>音阶<br/>📊<strong class="jj hj">坐标轴</strong>✍<br/>🏾<strong class="jj hj">标记</strong></p><p id="b460" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">我们将使用模块化方法来定义一个简单的<strong class="jj hj">逻辑结构</strong>，这将帮助我们从小处着手，并快速了解必要步骤的顺序，从而为库提供我们希望呈现的图表所需的所有信息。</p><p id="6737" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">这篇文章的全部代码可以通过以下链接获得一个可观察的实时可编辑版本:【https://observablehq.com/@danilofiumi/d3-js-made-easy<a class="ae lt" href="https://observablehq.com/@danilofiumi/d3-js-made-easy" rel="noopener ugc nofollow" target="_blank"/>。</p><blockquote class="jd je jf"><p id="d322" class="jg jh ji jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">NB: <strong class="jj hj"> Observable </strong>让我们有可能只关注代码的主要方面，而不用担心导入模块、创建外部HTML或样式表。此外，它允许我们按单元格执行JavaScript代码(即使有一些差异)，在笔记本中实时显示结果。如果你不熟悉Observable，你可以在这里找到更多信息<a class="ae lt" href="https://observablehq.com/@danilofiumi/d3-js-made-easy" rel="noopener ugc nofollow" target="_blank"/>。</p></blockquote><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lu"><img src="../Images/2b985d06d036780727733ccd5646907b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0tn_YAh-Q7AXrsjsUm9rPg.gif"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">4个构建模块</figcaption></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h1 id="740a" class="if ig hi bd ih ii mb ik il im mc io ip iq md is it iu me iw ix iy mf ja jb jc bi translated">1.数据-起点</h1><p id="8bae" class="pw-post-body-paragraph jg jh hi jj b jk kx jm jn jo ky jq jr kz la ju jv lb lc jy jz ld le kc kd ke hb bi translated">数据是任何数据驱动表示的起点。<br/>我们将在本文中考虑的数据集代表了一类学生的性别、年龄、身高和体重信息。在这个例子中，我们将分析“身高”和“体重”之间的经典关系。</p><pre class="km kn ko kp fd mg mh mi mj aw mk bi"><span id="e8a8" class="ml ig hi mh b fi mm mn l mo mp">data = FileAttachment(“CLASS.csv”).csv({ typed: true })</span><span id="cc28" class="ml ig hi mh b fi mq mn l mo mp">var_x = “Height”</span><span id="f215" class="ml ig hi mh b fi mq mn l mo mp">var_y = “Weight”</span></pre><blockquote class="jd je jf"><p id="c260" class="jg jh ji jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意:在observable中，没有必要使用var / let / const来声明变量</p></blockquote><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div></figure><h1 id="080b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">2.规模-最基本的元素</h1><p id="ee87" class="pw-post-body-paragraph jg jh hi jj b jk kx jm jn jo ky jq jr kz la ju jv lb lc jy jz ld le kc kd ke hb bi translated">音阶是D3整个语法中真正跳动的心脏。<br/>它们将某个<strong class="jj hj">域</strong>中的一个数字映射到一个视觉表示<strong class="jj hj">范围</strong>(如果你熟悉的话，这非常类似于数学上的归一化概念)。</p><p id="3fe4" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">在深入使用缩放函数之前，我们必须定义几个结构元素，这些元素允许我们定义工作面，在这个工作面上我们可以一步一步地构建模块。</p><p id="8197" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">首先，让我们定义一个包含所有维度的对象，我们将使用这些维度来构建我们的表示。</p><pre class="km kn ko kp fd mg mh mi mj aw mk bi"><span id="529e" class="ml ig hi mh b fi mm mn l mo mp">dms = {<br/>  let dms = {<br/>    width: 800,<br/>    height: 600,<br/>    marginTop: 0,<br/>    marginRight: 0,<br/>    marginBottom: 50,<br/>    marginLeft: 50<br/>  };<br/>  dms.boundedWidth = dms.width - dms.marginLeft - dms.marginRight;<br/>  dms.boundedHeight = dms.height - dms.marginTop - dms.marginBottom;</span><span id="3290" class="ml ig hi mh b fi mq mn l mo mp">return dms;<br/>}</span></pre><p id="a301" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">让我们创建一个超级简单的<strong class="jj hj"> SVG </strong>容器，它现在将作为一个空画布工作，我们随后将在其上用普通的JavaScript和D3方法进行干预。</p><pre class="km kn ko kp fd mg mh mi mj aw mk bi"><span id="2c69" class="ml ig hi mh b fi mm mn l mo mp">&lt;svg id="chart"&gt;&lt;/svg&gt;</span></pre><p id="6951" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">通过d3.select，我们可以访问具有给定id的元素，并为其分配<strong class="jj hj"> viewBox </strong>属性，以使用前一点中建立的度量来裁剪平面。我们将图表的构造函数定义如下:</p><pre class="km kn ko kp fd mg mh mi mj aw mk bi"><span id="521d" class="ml ig hi mh b fi mm mn l mo mp">chart = {<br/>  const svg = d3.select("#chart"); <br/>// select the element with id="chart"</span><span id="3e80" class="ml ig hi mh b fi mq mn l mo mp">  svg.selectAll("*").remove(); <br/>// clean all the eventual old/unwanted marks</span><span id="f396" class="ml ig hi mh b fi mq mn l mo mp">  svg.attr("viewBox", [-30, -10, dms.width, dms.height]); <br/>// define all the dimensions with some manual adjustments to better fit the screen size<br/>}</span></pre><p id="1eba" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">现在我们已经创建了如下的空白绘图框。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es mr"><img src="../Images/cac86291742dddf0de08efa5d126bb98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hl25r7P57FAXgD6OeK38kA.png"/></div></div></figure><p id="6cd7" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">现在我们终于可以定义尺度函数了。</p><pre class="km kn ko kp fd mg mh mi mj aw mk bi"><span id="5557" class="ml ig hi mh b fi mm mn l mo mp">xScale = d3<br/>  .scaleLinear()<br/>  .domain(d3.extent(data, (d) =&gt; d[var_x]))<br/>  .range([0, dms.boundedWidth])</span><span id="a869" class="ml ig hi mh b fi mq mn l mo mp">yScale = d3<br/>  .scaleLinear()<br/>  .domain(d3.extent(data, (d) =&gt; d[var_y]))<br/>  .nice()<br/>  .range([dms.boundedHeight, 0])</span></pre><p id="4d62" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">让我们以xScale为例。<strong class="jj hj"> scaleLinear </strong>函数获取var_x (Weight) <em class="ji"> </em>域的所有值，从最小50kg扩展到最大72kg，并将它们重新映射到0px到800px(像素)的连续范围内。yScale也是如此。</p><pre class="km kn ko kp fd mg mh mi mj aw mk bi"><span id="3f73" class="ml ig hi mh b fi mm mn l mo mp">// Example Function<br/>xScale(56.6kg) --&gt; 137px<br/>yScale(84cm) --&gt; 363px</span><span id="069c" class="ml ig hi mh b fi mq mn l mo mp">// Example Proportion<br/>data[1][var_x]:56.6kg = xScale(data[1][var_x]):137px<br/>data[1][var_y]:84cm = yScale(data[1][var_y]):363px</span></pre><p id="e191" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">这样，体重=56.6kg，身高=84cm的学生将在平面中被一组位置坐标(137px，363px)，<br/>识别，该坐标允许浏览器的渲染引擎将数值信息翻译并表示到viewBox空间范围中。</p><h1 id="00d2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">3.轴-参考<em class="ms">导轨</em></h1><p id="4185" class="pw-post-body-paragraph jg jh hi jj b jk kx jm jn jo ky jq jr kz la ju jv lb lc jy jz ld le kc kd ke hb bi translated">以下赋值用于声明轴:</p><pre class="km kn ko kp fd mg mh mi mj aw mk bi"><span id="2783" class="ml ig hi mh b fi mm mn l mo mp">xAxis = d3.axisBottom(xScale).ticks(15)<br/>yAxis = d3.axisLeft(yScale).ticks(15)</span></pre><p id="26bd" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated"><strong class="jj hj"> axisBottom </strong>和<strong class="jj hj"> axisLeft </strong>是D3的预建函数，从上一点定义的刻度开始，构建笛卡尔轴并将其放置在底部(xAxis)和左侧(yAxis)。</p><p id="852f" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">这些轴函数不返回值，而是生成可视的SVG元素，这些元素可以被呈现以供查看。</p><p id="d24c" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">我们可以使用许多属性来定制它们，但是现在让我们保持简单，只定义我们想要显示的最大刻度数(每个轴15个)。</p><p id="cf18" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">然后使用<strong class="jj hj">将它们添加到图表的构造函数中。调用【轴】方法后的</strong>D3选择器:</p><pre class="km kn ko kp fd mg mh mi mj aw mk bi"><span id="16e0" class="ml ig hi mh b fi mm mn l mo mp">chart = {<br/>  const svg = d3.select("#chart");<br/>  svg.selectAll("*").remove();<br/>  svg.attr("viewBox", [-30, -10, dms.width, dms.height]);</span><span id="03e3" class="ml ig hi mh b fi mq mn l mo mp">//this creates the axes elements<br/>  svg.append("g").call(xAxis);<br/>  svg.append("g").call(yAxis);<br/>}</span></pre><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">错误的轴</figcaption></figure><p id="6508" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">这就是我们得到的。总比没有好，但是xAxis完全被搞乱了！</p><p id="33e4" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">这是因为默认情况下，SVG的(0，0)原点位于左上角，而不是左下角。为了解决这个问题，我们可以简单地<strong class="jj hj">将x轴向下移动</strong>一个等于参考框高度的值。</p><pre class="km kn ko kp fd mg mh mi mj aw mk bi"><span id="c5bc" class="ml ig hi mh b fi mm mn l mo mp">chart = {<br/>  const svg = d3.select("#chart");<br/>  svg.selectAll("*").remove();<br/>  svg.attr("viewBox", [-30, -10, dms.width, dms.height]);</span><span id="d9f9" class="ml ig hi mh b fi mq mn l mo mp">//this creates the axes elements<br/>  svg.append("g")<br/>   .attr("transform",move(0,dms.boundedHeight)).call(xAxis)<br/>  svg.append("g")<br/>   .call(yAxis);<br/>}</span></pre><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">正确的轴</figcaption></figure><p id="200c" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">现在看起来刚刚好！</p><p id="c84f" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">让我们将轴调用封装在一个函数中，这样我们就可以在以后将它与下一步的绘图函数组合在一起。</p><pre class="km kn ko kp fd mg mh mi mj aw mk bi"><span id="b1fb" class="ml ig hi mh b fi mm mn l mo mp">function drawAxes(bounds) {<br/>  bounds.append("g")<br/>   .attr("transform",move(0,dms.boundedHeight)).call(xAxis);<br/>  bounds.append("g")<br/>   .call(yAxis);<br/>}</span></pre><h1 id="70ea" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">4.标记——几何图元</h1><p id="2b36" class="pw-post-body-paragraph jg jh hi jj b jk kx jm jn jo ky jq jr kz la ju jv lb lc jy jz ld le kc kd ke hb bi translated">在这一步中，我们将创建区分可视化类型的标记。为了创建这些标记，我们将利用SVGs <strong class="jj hj">基本几何图形</strong>。</p><p id="6a8a" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">在进入实际的图表之前，让我们定义几个不同的元素，看看这些SVG基本形状的用法。让我们创建1个矩形、4个半径递减的圆、1条垂直线、1个文本元素和1条沿路径的线。它们都需要一个由空间坐标定义的给定的<strong class="jj hj">位置</strong>，而其他的<strong class="jj hj">属性</strong>根据标记的类型而变化。</p><pre class="km kn ko kp fd mg mh mi mj aw mk bi"><span id="0d1a" class="ml ig hi mh b fi mm mn l mo mp">&lt;svg width="400" height="250"&gt;<br/>  &lt;rect x="0" y="0" width="50" height="250"/&gt;</span><span id="dd77" class="ml ig hi mh b fi mq mn l mo mp">  &lt;circle cx="100" cy="100" r="25"/&gt;<br/>  &lt;circle cx="100" cy="150" r="15"/&gt;<br/>  &lt;circle cx="100" cy="190" r="10"/&gt;<br/>  &lt;circle cx="100" cy="220" r="5"/&gt;</span><span id="1c14" class="ml ig hi mh b fi mq mn l mo mp">  &lt;line x1="150" y1="250" x2="150" y2="0" stroke="black"/&gt;</span><span id="8a20" class="ml ig hi mh b fi mq mn l mo mp">  &lt;text x="180" y="55" font-size="22" &gt;SVG Primitives&lt;/text&gt;</span><span id="05ac" class="ml ig hi mh b fi mq mn l mo mp">  &lt;path d="M200.5 149.5L231 117L241 130.5L268 111.5L285 192L304.5        167L322 180.5L375.5 117" stroke="black" fill="none"/&gt;<br/>&lt;/svg&gt;</span></pre><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">SVG基本形状</figcaption></figure><p id="b2be" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">通过使用这些原始几何元素，我们可以创建散点图(使用“圆”元素)、折线图(使用“线”或“路径”元素)、条形图(使用“矩形”元素)等</p><p id="0860" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">现在让我们关注一下<strong class="jj hj">“circle”</strong>元素。我们的目标是通过<strong class="jj hj">散点图</strong>来表示“身高”和“体重”之间的关系。</p><pre class="km kn ko kp fd mg mh mi mj aw mk bi"><span id="1756" class="ml ig hi mh b fi mm mn l mo mp">function drawMarks(bounds, data) {<br/>  bounds<br/>    .selectAll("circle")<br/>    .data(data)<br/>    .join("circle")<br/>    .attr("cx", (d) =&gt; xScale(d[var_x]))<br/>    .attr("cy", (d) =&gt; yScale(d[var_y]))<br/>    .attr("r", 6)<br/>    .attr("fill", "darkred")<br/>    .attr("opacity", 0.9);<br/>}</span></pre><p id="174d" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated"><strong class="jj hj">。数据</strong>和<strong class="jj hj">。join </strong>方法读取输入数据集，并创建与类中读取的观察一样多的圆形元素。</p><p id="46c4" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated"><strong class="jj hj"> cx </strong>和<strong class="jj hj"> cy </strong>属性是指圆心的位置。它们被设置为等于xScale和yScale为数据集行中的每个重量和高度数值生成的值，将它们重新映射到不同的空间坐标集。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">圆圈标记</figcaption></figure><p id="edaa" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">即使从分析和探索的角度来看完全没有意义，但是看到仅仅通过使用原语来改变图表的类型是多么容易，这是很有用的。对于本例，我们可以使用“path”元素创建一个折线图。</p><pre class="km kn ko kp fd mg mh mi mj aw mk bi"><span id="ba08" class="ml ig hi mh b fi mm mn l mo mp">function drawMarks(bounds, data) {<br/>  bounds<br/>    .append("path")<br/>    .datum(aq.from(data).orderby(var_x).objects())<br/>    .attr("fill", "none")<br/>    .attr("stroke", "darkblue")<br/>    .attr("stroke-width", 2.5)<br/>    .attr("d",d3.line()<br/>        .x((d) =&gt; xScale(d[var_x]))<br/>        .y((d) =&gt; yScale(d[var_y]))<br/>    );<br/>}</span></pre><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">线条标记</figcaption></figure><p id="d40c" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">现在我们有了所有的4个构建模块，我们终于可以组合它们来构建最终的结果了。</p><pre class="km kn ko kp fd mg mh mi mj aw mk bi"><span id="52f9" class="ml ig hi mh b fi mm mn l mo mp">chart = {<br/>  const svg = d3.select("#chart");<br/>  svg.selectAll("*").remove();<br/>  svg.attr("viewBox", [-30, -10, dms.width, dms.height]);</span><span id="c56c" class="ml ig hi mh b fi mq mn l mo mp">  drawAxes(svg);<br/>  drawMarks(svg, data);<br/>}</span></pre><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">决赛成绩</figcaption></figure></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="055a" class="pw-post-body-paragraph jg jh hi jj b jk jl jm jn jo jp jq jr kz jt ju jv lb jx jy jz ld kb kc kd ke hb bi translated">D3有这么多不同的方法可以实现相同的结果，你对这个库的经验越多，你就会发现越多人使用不同的特性、功能和代码语法。正因为如此，你有时会感到无所适从。在这种情况下，请记住这四个基本要素数据/比例/轴/标记始终是每一种表现形式的基础，从最简单到最复杂。一旦理解并正确处理，您就可以轻松地调整代码参数，立即获得显著的结果。</p><figure class="km kn ko kp fd kq"><div class="bz dy l di"><div class="kr ks l"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">更复杂的图表</figcaption></figure></div></div>    
</body>
</html>