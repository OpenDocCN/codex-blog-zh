<html>
<head>
<title>Spring Web And WebFlux Exception Handling Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Web和WebFlux异常处理最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/codex/spring-web-and-webflux-exception-handling-best-practices-b2c3cd7e3acf?source=collection_archive---------3-----------------------#2022-06-15">https://medium.com/codex/spring-web-and-webflux-exception-handling-best-practices-b2c3cd7e3acf?source=collection_archive---------3-----------------------#2022-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="7b9f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">问题</h1><p id="a963" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在web应用程序上工作，编写异常处理类只是时间问题，有很多方法可以做到这一点。特别是，我们的目标是控制我们的API客户端如何看到错误，例如从控制器抛出的异常。</p><p id="0e6f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><em class="kg">如果你真的是一个网游高手——跳到GitHub </em>  <em class="kg">上的</em> <a class="ae kh" href="https://github.com/artemptushkin/spring-web-exception-handling" rel="noopener ugc nofollow" target="_blank"> <em class="kg">示例源代码。它的结构很好，包括测试来证明这个概念。</em></a></p><h1 id="cbaf" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">代码设计期望</h1><p id="f3d0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们在这里谈谈我们真正想要达到的目标。</p><p id="5578" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">首先，我们应该定义日常工作和它添加另一个异常或跟踪当前异常的行为。</p><p id="0b13" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">第二，我们应该与客户就合同达成一致，并且，我们可能希望返回相同的数据结构，以保持所有内容的简洁。此外，我们希望将该解决方案扩展到我们公司/项目中的其他服务。</p><ul class=""><li id="3713" class="ki kj hi jf b jg kb jk kc jo kk js kl jw km ka kn ko kp kq bi translated">该解决方案应该是可扩展的，我们有一个简单的方法来添加一个管理异常</li><li id="37a1" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">应该很容易追溯出异常来自哪里</li><li id="2ce5" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">我们应该在一个文件中找到已知异常的列表及其要映射的状态代码</li><li id="3ca8" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">它应该无任何排除地映射所有发生的异常，并且后者应该在这个单独的代码位置中被控制</li></ul><h1 id="ef30" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">网</h1><p id="d349" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一般来说，有两种方法可以处理来自web的异常:</p><ul class=""><li id="c6da" class="ki kj hi jf b jg kb jk kc jo kk js kl jw km ka kn ko kp kq bi translated"><code class="du kw kx ky kz b">@ControllerAdvice</code> + <code class="du kw kx ky kz b">@ExceptionHandler</code></li><li id="c906" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">用<code class="du kw kx ky kz b">@ResponseStatus</code>标注异常类</li></ul><p id="ad7f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">第二种方法没有提供映射消息自定义的选项，最终您会采用第一种方法，这种方法更加灵活。</p><p id="f4d6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">spring中设计异常处理时最普遍的错误是，当过滤器抛出一个异常时，你不会捕捉到它<code class="du kw kx ky kz b">ExceptionHandler</code>，因为它永远不会到达<code class="du kw kx ky kz b">DispatcherServlet</code>。如果你幸运的话，你可以在网上看到这个，例如，<a class="ae kh" href="https://stackoverflow.com/a/34598356/7785738" rel="noopener ugc nofollow" target="_blank">这里的</a>是一个StackOverflow评论，已经被标记了45次，讲述了这个。</p><p id="4e13" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们应该关注过滤器的原因是:</p><ul class=""><li id="502e" class="ki kj hi jf b jg kb jk kc jo kk js kl jw km ka kn ko kp kq bi translated">改天您可能会有一个带有过滤器的启动器用于请求认证</li><li id="0fe4" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">你公司栈中的任何库都可能包含一个你不知道的过滤器，它会在另一天抛出一个你在<code class="du kw kx ky kz b">ExceptionHandler</code>中捕捉不到的异常</li></ul><p id="db7b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，这里的长期解决方案是扩展<code class="du kw kx ky kz b">OncePerRequestFilter</code>，因为它写在完全相同的<a class="ae kh" href="https://stackoverflow.com/questions/34595605/how-to-manage-exceptions-thrown-in-filters-in-spring" rel="noopener ugc nofollow" target="_blank"> StackOverflow答案</a>中，但是如果你或你的同事没有提出适当的问题，他们可能不会到达那里。当你面对一个问题并想恰当地解决它时，这个问题通常会出现。</p><h1 id="56a9" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结合</h1><p id="f76f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">后一种解决方案是以一种松散耦合的方式将<code class="du kw kx ky kz b">OncePerRequestFilter</code>和<code class="du kw kx ky kz b">ExceptionHandler</code>结合起来，以便将来能够轻松地打破这种依赖。它应该是一些<em class="kg">异常处理过滤器，</em>像:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="67b1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这个类委托给你用<code class="du kw kx ky kz b">ControllerAdvice</code>注释的异常处理程序，因此我们所有的异常都在你的代码库中的一个<strong class="jf hj">位置！</strong></p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="f024" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">剩下的就是考虑一种简单的方法来将您的异常转换成您需要的域响应，例如:</p><pre class="la lb lc ld fd lh kz li lj aw lk bi"><span id="2b4d" class="ll ig hi kz b fi lm ln l lo lp">{<br/>    "message": "I'm a demo exception from controller",<br/>    "code": 400<br/>}</span></pre><p id="ef99" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">最具伸缩性的数据结构不需要你写样板文件<em class="kg">如果</em>代码每次都是<strong class="jf hj">映射</strong>并且在Spring中你总是可以定义它为一个bean:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="a2b8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让您像这样映射您处理新异常的日常工作很简单——只需在映射中添加另一个条目！</p><h1 id="516e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Bean配置</h1><p id="d5db" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">您可以在这里找到一个示例bean配置<a class="ae kh" href="https://github.com/artemptushkin/spring-web-exception-handling/tree/master/src/main/java/io/github/artemptushkin/demo/springwebexceptionhandling/config" rel="noopener ugc nofollow" target="_blank">。请关注sprig security的这次更新，并查看</a><a class="ae kh" href="https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter" rel="noopener ugc nofollow" target="_blank"> Spring博客了解更多</a>。</p><blockquote class="lq lr ls"><p id="f5ed" class="jd je kg jf b jg kb ji jj jk kc jm jn lt kd jq jr lu ke ju jv lv kf jy jz ka hb bi translated">在Spring Security 5.7.0-M2中，我们<a class="ae kh" href="https://github.com/spring-projects/spring-security/issues/10822" rel="noopener ugc nofollow" target="_blank">弃用了</a>的<code class="du kw kx ky kz b">WebSecurityConfigurerAdapter</code>，因为我们鼓励用户转向基于组件的安全配置</p></blockquote><h1 id="164d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">WebFlux</h1><p id="c4aa" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在WebFlux中，<a class="ae kh" href="https://www.baeldung.com/spring-webflux-errors" rel="noopener ugc nofollow" target="_blank">有很多方法来处理来自web层的异常</a>。但好消息是——不需要像我们在web中那样考虑过滤器问题，您可以定义一个通用的全局异常处理程序，并在您的服务中从它开始。所有的异常都将被处理，请在我的知识库中找到验证测试。</p><p id="edf2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">以同样方式依赖于地图的WebFlux异常处理程序如下所示:</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h1 id="2fca" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">默认状态代码</h1><p id="36b3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">保持松散耦合的重要时刻是将默认状态代码外部化，以便在出现意外异常时做出响应。我们在上面的web示例中也有这种方法。</p><figure class="la lb lc ld fd le"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="fd97" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">有了这样的代码，很容易:</p><ul class=""><li id="edc3" class="ki kj hi jf b jg kb jk kc jo kk js kl jw km ka kn ko kp kq bi translated">用任何其他默认响应代码测试您的异常处理程序</li><li id="1f02" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">如果您将类移动到一个库中，您就可以让您的用户更改默认行为</li></ul><h1 id="8eeb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">摘要</h1><p id="a585" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">使用Spring实现松散耦合的代码是可能的，这将有利于:</p><ul class=""><li id="0216" class="ki kj hi jf b jg kb jk kc jo kk js kl jw km ka kn ko kp kq bi translated">测试</li><li id="ce56" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">重构</li><li id="0890" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">分解</li></ul><p id="05ab" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">总的来说，试着专注于:</p><ul class=""><li id="d087" class="ki kj hi jf b jg kb jk kc jo kk js kl jw km ka kn ko kp kq bi translated">定义接口</li><li id="df2e" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">通过构造函数传递所有内容(不要在构造函数内部初始化对象属性)</li><li id="d8f7" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">将所有东西初始化为bean</li><li id="249b" class="ki kj hi jf b jg kr jk ks jo kt js ku jw kv ka kn ko kp kq bi translated">测试</li></ul><p id="c34b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">你可以在<a class="ae kh" href="https://github.com/artemptushkin/spring-web-exception-handling" rel="noopener ugc nofollow" target="_blank"> my repository </a>中找到如何测试你的异常处理功能的例子。测试场景包括文章中描述的所有重要的具体案例。它包括web和webflux设置，以及在这两者之间切换测试的简洁方法。</p></div></div>    
</body>
</html>