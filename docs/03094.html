<html>
<head>
<title>Python and Physics: Runge-Kutta Method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python与物理学:龙格-库塔方法</h1>
<blockquote>原文：<a href="https://medium.com/codex/python-and-physics-runge-kutta-method-93d7e2105230?source=collection_archive---------5-----------------------#2021-08-18">https://medium.com/codex/python-and-physics-runge-kutta-method-93d7e2105230?source=collection_archive---------5-----------------------#2021-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b807" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在研究生院偶然发现的最常见的数学问题之一是常微分方程，也称为ODEs，其中一个让我困惑了一段时间的挑战是，我如何用Python求解ODEs？谢天谢地，我偶然发现了两种方法，Runge-Kutta方法和SciPy的内置函数。</p><h1 id="f2d1" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">龙格-库塔法</strong></h1><p id="7e0f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">龙格-库塔法是由卡尔·龙格和威廉·库塔提出的对常微分方程的数值近似。通过在一个区间内使用四个不一定落在实际解上的斜率值，并对斜率取平均值，可以得到一个非常好的近似解。对于龙格-库塔法及其变体的更详细的解释，我强烈建议使用你最喜欢的教科书/网站来研究历史、推导和应用。现在对于这个例子，我们将集中在四阶龙格-库塔方法，以帮助我们解决1D散射问题。</p><h1 id="fd79" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">编码</strong></h1><p id="c744" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">为了开始我们的代码，我们将导入一些有助于数学和可视化的包。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="cfea" class="kp je hi kl b fi kq kr l ks kt">import cmath #To help us out with the complex square root<br/>import numpy as np #For the arrays<br/>import matplotlib.pyplot as plt #Visualization</span></pre><p id="6dfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这里，我们开始定义方程的初始参数。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="811e" class="kp je hi kl b fi kq kr l ks kt">mass = 1.0 #Mass, one for simplicity<br/>hbar = 1.0 #HBar, one for simplicity<br/>v0 = 2.0 #Initial potential value<br/>alpha = 0.5 #Value for our potential equation<br/>E = 3.0 #Energy<br/>i = 1.0j #Defining imaginary number<br/>x = 10.0 #Initial x-value<br/>xf = -10.0 #Final x-value<br/>h = -.001 #Step value</span><span id="64b0" class="kp je hi kl b fi ku kr l ks kt">xaxis = np.array([], float) #Empty array to fill with out x-values</span><span id="9b44" class="kp je hi kl b fi ku kr l ks kt">psi = np.array([], complex) #Empty array to fill with the values for  the initial equation we are trying to solve, defined array as complex to fill with complex numbers</span><span id="fda2" class="kp je hi kl b fi ku kr l ks kt">psiprime = np.array([], complex) #Empty array to fill with the values for the first derivative equation we are trying to solve, defined array as complex to fill with complex numbers</span></pre><p id="8b0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们有了初始值，我们就开始研究定义我们将要用到的方程的函数。我们拥有的主方程是<em class="kv"> k(x) </em>，它是薛定谔方程的修正版本，用于求解变量<em class="kv"> k </em>，以及我们的<strong class="ih hj">ψ</strong>方程，它们将由<em class="kv"> psione(x) </em>和<em class="kv">PS inone(x)</em>定义。为了进一步探索这个方程式，麻省理工开放式课程有免费讲座，任何人都可以免费参加。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="ef57" class="kp je hi kl b fi kq kr l ks kt">def v(x): #Potential equation we will be using for this example<br/>    return v0/2.0 * (1.0 + np.tanh(x/alpha))</span><span id="dd3b" class="kp je hi kl b fi ku kr l ks kt">def k(x): #Reworked Schrödinger's equation to solve for k<br/>    return cmath.sqrt((2*mass/(hbar**2))*(E - v(x)))</span><span id="db7e" class="kp je hi kl b fi ku kr l ks kt">def psione(x): #PSI, wavefunction equation<br/>    return np.exp(i*k(x)*x)</span><span id="2e0b" class="kp je hi kl b fi ku kr l ks kt">def psitwo(x): #Derivative of the psione equation<br/>    return i*k(x)*np.exp(i*k(x)*x)</span></pre><p id="587e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们开始精彩的部分了。首先，我们需要定义一个包含初始条件波函数的数组。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="5f86" class="kp je hi kl b fi kq kr l ks kt">r = np.array([psione(x), psitwo(x)]) #Array with wavefunctions, usually this is where our initial condition equations go.</span></pre><p id="77ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的数组中设置这些方程，我们可以通过Runge-Kutta方法迭代这两个方程，这将在下面定义，并让它们给出我们为<em class="kv"> psione(x) </em>和<em class="kv">PS ione(x)定义的方程的近似解。但是在我们到达等式的主要部分之前，我们需要定义一个更重要的函数。</em></p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="c80a" class="kp je hi kl b fi kq kr l ks kt">def deriv(r,x): <br/>    return np.array([r[1],-(2.0*mass/(hbar**2) * (E - v(x))*r[0])], complex)<br/>#The double star, **, is for exponents</span></pre><p id="3cd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kv"> deriv </em>函数是龙格-库塔的输出通过的地方，这个函数从数组<em class="kv"> r </em>中获取我们的值，然后推动它通过这些条件。对于返回的第一个值，这很简单，我们的<em class="kv"> x </em>值将被输入到数组的第二个等式中。然而，第二个值将经历不同的处理。这一次，<em class="kv"> x </em>值将经历薛定谔方程的另一次迭代，其中考虑了波函数<em class="kv"> psione(x) </em>。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="0fdd" class="kp je hi kl b fi kq kr l ks kt">#While loop to iterate through the Runge-Kutta. This particular version, the Fourth Order, will have four slope values that help approximate then next slope value, from k1 to k2, k2 to k3, and k3 to k4.</span><span id="58b5" class="kp je hi kl b fi ku kr l ks kt">#This loop also appends that values, starting with the initial values, to the empty arrays that we've initialized earlier.</span><span id="b633" class="kp je hi kl b fi ku kr l ks kt">while (x &gt;= xf ):<br/>        xaxis = np.append(xaxis, x)<br/>        psi = np.append(psi, r[0])<br/>        psiprime = np.append(psiprime, r[1])<br/>        k1 = h*deriv(r,x)<br/>        k2 = h*deriv(r+k1/2,x+h/2)<br/>        k3 = h*deriv(r+k2/2,x+h/2)<br/>        k4 = h*deriv(r+k3,x+h)<br/>        r += (k1+2*k2+2*k3+k4)/6<br/>        x += h #The += in this line, and the line above, is the same thing as telling the code to x = x + h, which updates x, using the previous x with the addition of the step value.</span></pre><p id="798d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，循环几乎覆盖了龙格-库塔的整个过程。通过使用斜率的近似值，如由<em class="kv"> k </em>值定义的，每个<em class="kv"> k </em>值有助于近似下一个斜率，使我们更接近于求解<em class="kv"> f(x) </em>。此外，在获得每个斜率后，我们获得一个加权平均值，并用这些新值更新数组，为下一次迭代做好准备。这个过程将在我们定义的x轴范围内继续进行，最终将为我们绘制即将求解的ODE提供必要的值。</p><h1 id="066c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">概述</strong></h1><p id="2ec4" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">龙格-库塔方法可以很容易地适用于许多其他方程，大多数时候我们只需调整<em class="kv"> deriv </em>函数和我们的初始条件方程。其他例子包括钟摆运动微分方程和行星运动微分方程。在下面，你可以找到完整的代码，以及额外的步骤，比如求解反射和透射值的函数，以及如何绘制我们的值。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="c1d0" class="kp je hi kl b fi kq kr l ks kt">import cmath #To help us out with the complex square root<br/>import numpy as np #For the arrays<br/>import matplotlib.pyplot as plt #Visualization</span><span id="2449" class="kp je hi kl b fi ku kr l ks kt">mass = 1.0 #Mass, one for simplicity<br/>hbar = 1.0 #HBar, one for simplicity<br/>v0 = 2.0 #Initial potential value<br/>alpha = 0.5 #Value for our potential equation<br/>E = 3.0 #Energy<br/>i = 1.0j #Defining imaginary number<br/>x = 10.0 #Initial x-value<br/>xf = -10.0 #Final x-value<br/>h = -.001 #Step value</span><span id="a879" class="kp je hi kl b fi ku kr l ks kt">xaxis = np.array([], float) #Empty array to fill with out x-values</span><span id="b504" class="kp je hi kl b fi ku kr l ks kt">psi = np.array([], complex) #Empty array to fill with the values for  the initial equation we are trying to solve, defined array as complex to fill with complex numbers</span><span id="e9be" class="kp je hi kl b fi ku kr l ks kt">psiprime = np.array([], complex) #Empty array to fill with the values for the first derivative equation we are trying to solve, defined array as complex to fill with complex numbers</span><span id="6f55" class="kp je hi kl b fi ku kr l ks kt">def v(x): #Potential equation we will be using for this example<br/>    return v0/2.0 * (1.0 + np.tanh(x/alpha))</span><span id="1ffc" class="kp je hi kl b fi ku kr l ks kt">def k(x): #Reworked Schrödinger's equation to solve for k<br/>    return cmath.sqrt((2*mass/(hbar**2))*(E - v(x)))</span><span id="a631" class="kp je hi kl b fi ku kr l ks kt">def psione(x): #PSI, wavefunction equation<br/>    return np.exp(i*k(x)*x)</span><span id="842a" class="kp je hi kl b fi ku kr l ks kt">def psitwo(x): #Derivative of the psione equation<br/>    return i*k(x)*np.exp(i*k(x)*x)</span><span id="2f0a" class="kp je hi kl b fi ku kr l ks kt">r = np.array([psione(x), psitwo(x)]) #Array with wavefunctions, usually this is where our initial condition equations go.</span><span id="c842" class="kp je hi kl b fi ku kr l ks kt">def deriv(r,x): <br/>    return np.array([r[1],-(2.0*mass/(hbar**2) * (E - v(x))*r[0])], complex)<br/>#The double star, **, is for exponents</span><span id="1650" class="kp je hi kl b fi ku kr l ks kt">#While loop to iterate through the Runge-Kutta. This particular version, the Fourth Order, will have four slope values that help approximate then next slope value, from k1 to k2, k2 to k3, and k3 to k4.</span><span id="db82" class="kp je hi kl b fi ku kr l ks kt">#This loop also appends that values, starting with the initial values, to the empty arrays that we've initialized earlier.</span><span id="2f01" class="kp je hi kl b fi ku kr l ks kt">while (x &gt;= xf ):<br/>        xaxis = np.append(xaxis, x)<br/>        psi = np.append(psi, r[0])<br/>        psiprime = np.append(psiprime, r[1])<br/>        k1 = h*deriv(r,x)<br/>        k2 = h*deriv(r+k1/2,x+h/2)<br/>        k3 = h*deriv(r+k2/2,x+h/2)<br/>        k4 = h*deriv(r+k3,x+h)<br/>        r += (k1+2*k2+2*k3+k4)/6<br/>        x += h #The += in this line, and the line above, is the same thing as telling the code to x = x + h, which updates x, using the previous x with the addition of the step value.</span><span id="abdd" class="kp je hi kl b fi ku kr l ks kt">#Grabbing the last values of the arrays and redefining our x-axis<br/>psi1 = psi[20000]; psi2 = psiprime[20000]; x = 10; xf = -10</span><span id="d827" class="kp je hi kl b fi ku kr l ks kt">def reflection(x, y):<br/>    aa = (psi1 + psi2/(i*k(y)))/(2*np.exp(i*k(y)*y))<br/>    bb = (psi1 - psi2/(i*k(y)))/(2*np.exp(-i*k(y)*y))<br/>    return (np.abs(bb)/np.abs(aa))**2</span><span id="9510" class="kp je hi kl b fi ku kr l ks kt">def transmission(x,y):<br/>    aa = (psi1 + psi2/(i*k(y)))/(2.0*np.exp(i*k(y)*y))<br/>    return k(x)/k(y) * 1.0/(np.abs(aa))**2</span><span id="72dc" class="kp je hi kl b fi ku kr l ks kt">print('reflection = ',reflection(x,xf))<br/>print('transmission = ', transmission(x,xf))<br/>print('r + t = ', reflection(x,xf) + transmission(x,xf))</span><span id="2515" class="kp je hi kl b fi ku kr l ks kt">#Outputs for the print command<br/>#reflection =  0.007625630800891285<br/>#transmission =  (0.9923743691991354+0j)<br/>#r + t =  (1.0000000000000266+0j)<br/>#Ideally, r + t should give us one, a bit stumped if the precision that's present in Python can lead to the small discrepancy, without considering formatting the answer to a set amount of decimal values.</span><span id="02a3" class="kp je hi kl b fi ku kr l ks kt">#Plotting the graphs side by side, including the imaginary values.</span><span id="c14b" class="kp je hi kl b fi ku kr l ks kt">fig, ax = plt.subplots(1,2, figsize = (15,5))<br/>ax[0].plot(xaxis, psi.real, xaxis, psi.imag, xaxis, v(xaxis))<br/>ax[1].plot(xaxis, psiprime.real, xaxis, psiprime.imag, xaxis, v(xaxis))<br/>plt.show()</span></pre><figure class="kg kh ki kj fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kw"><img src="../Images/483f43b222389555790655012e724ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z5HkoTVqHEwXUjsXPE5Oug.jpeg"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">此代码的可视化输出。注意波函数在进入势垒时是如何变化的。</figcaption></figure><p id="15e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于那些对这段代码的内置SciPy版本感兴趣的人来说，可以开始了。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="6f2f" class="kp je hi kl b fi kq kr l ks kt">import cmath<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from scipy.integrate import odeint, solve_ivp</span><span id="ce49" class="kp je hi kl b fi ku kr l ks kt">E = 3; m = 1; h = 1; alpha = .5; v0=2; i = 1.0j; xi = 10; xf = -10</span><span id="f976" class="kp je hi kl b fi ku kr l ks kt">def v(x): return v0/2.0 * (1.0 + np.tanh(x/alpha))</span><span id="963c" class="kp je hi kl b fi ku kr l ks kt">def k(x): return cmath.sqrt((2*m/(h**2))*(E - v(x)))</span><span id="69c9" class="kp je hi kl b fi ku kr l ks kt">def psione(x): return np.exp(i*k(x)*x)</span><span id="380d" class="kp je hi kl b fi ku kr l ks kt">def psitwo(x): return i*k(x)*np.exp(i*k(x)*x)</span><span id="ff12" class="kp je hi kl b fi ku kr l ks kt">def deriv(x, y): return [y[1], -(2.0*m/(h**2.0) * (E - v(x))*y[0])]</span><span id="b41c" class="kp je hi kl b fi ku kr l ks kt"># solve_ivp is a built in rk45step solver<br/>values = solve_ivp(deriv, [10, -10], [psione(xi), psitwo(xi)], first_step = .001, max_step = .001)</span><span id="7d29" class="kp je hi kl b fi ku kr l ks kt">psi1 = values.y[0,20000]; psi2 = values.y[1,20000]; x = 10; xf = -10</span><span id="5b7f" class="kp je hi kl b fi ku kr l ks kt">def reflection(x, y):<br/>    aa = (psi1 + psi2/(i*k(y)))/(2*np.exp(i*k(y)*y))<br/>    bb = (psi1 - psi2/(i*k(y)))/(2*np.exp(-i*k(y)*y))<br/>    return (np.abs(bb)/np.abs(aa))**2</span><span id="d4e1" class="kp je hi kl b fi ku kr l ks kt">def transmission(x,y):<br/>    aa = (psi1 + psi2/(i*k(y)))/(2.0*np.exp(i*k(y)*y))<br/>    return k(x)/k(y) * 1.0/(np.abs(aa))**2</span><span id="3b52" class="kp je hi kl b fi ku kr l ks kt">print('reflection = ',reflection(x,xf))<br/>print('transmission = ', transmission(x,xf))<br/>print('r + t = ', reflection(x,xf) + transmission(x,xf))</span><span id="78ec" class="kp je hi kl b fi ku kr l ks kt">fig, ax = plt.subplots(1,2, figsize = (15,5))<br/>ax[0].plot(values.t, values.y[0].real, values.t, values.y[0].imag, values.t, v(values.t))<br/>ax[1].plot(values.t, values.y[1].real, values.t, values.y[1].imag, values.t, v(values.t))<br/>plt.show()</span></pre><h1 id="adeb" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">笔记</h1><p id="3f3a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">有点免责声明，大部分代码改编自我的计算类课程，该课程侧重于使用FORTRAN90而不是Python，所以代码可能不是很有效，因为我开始通过从FORTRAN转移代码来自学Python。另外，感谢麻省理工开放式课程让我对这段代码中使用的方程式和方法有一个小小的更新。</p></div></div>    
</body>
</html>