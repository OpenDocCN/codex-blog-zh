<html>
<head>
<title>Golang with Leetcode: 3Sum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Leetcode的golang:3 sum</h1>
<blockquote>原文：<a href="https://medium.com/codex/golang-with-leetcode-3sum-af8c9d6d27db?source=collection_archive---------6-----------------------#2022-02-09">https://medium.com/codex/golang-with-leetcode-3sum-af8c9d6d27db?source=collection_archive---------6-----------------------#2022-02-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="fe50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Leetcode 3Sum Golang解决方案的运行时性能优于95%的提交</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a5e7078e620cc906c9a8c6851c09a8ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RTTZGeeKGlopWlIi"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">src:<a class="ae jt" href="https://github.com/golang/go" rel="noopener ugc nofollow" target="_blank">golang/Go:Go编程语言(github.com)</a></figcaption></figure><h1 id="a8d1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Leetcode #15: 3Sum</h1><p id="354d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">难度:中等</p><p id="115c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过率:30.5%</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kx"><img src="../Images/a0a7e026a3ffdb447f813a86bd05d355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*hHXIkc66fHc-I1Dy6ekxQw.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/3ecf87efca5fa89c30acebd5850d4d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*ZECuH8w60MKUdZLK1TjFig.png"/></div></figure><h2 id="a879" class="kz jv hi bd jw la lb lc ka ld le lf ke iq lg lh ki iu li lj km iy lk ll kq lm bi translated">3汇总问题细分</h2><p id="0803" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">所以本质上，我们需要找到3个数的组合，它们的总和是0。所有的数字都来自一个单独的切片。每个数字组合都存储为一个切片，该切片存储在一个用于返回结果的二维切片中。2D切片中的每个切片都必须是唯一的，因为在中，不允许重复。</p><p id="d9da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将需要设计一些方法来确保条目之间的唯一性，处理边缘情况(例如少于3个条目的切片)，并有效地执行必要的计算。</p><h2 id="b294" class="kz jv hi bd jw la lb lc ka ld le lf ke iq lg lh ki iu li lj km iy lk ll kq lm bi translated">天真的3Sum解决方案</h2><p id="c87d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">当然，天真的方法是使用嵌套的for循环来完成这项任务。然而，在这种情况下，嵌套的for循环将执行O(n ),而不是典型的O(n)行为。</p><p id="62b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，天真的方法产生O(n)的运行时间，因为我们将跟踪3个索引，而不是2个。我们需要维护3个索引来跟踪传递的切片中的三元组组合。</p><p id="2027" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实践中，您可能希望通过某种非代码的媒介来完成这些步骤。找到优化解决方案的第一步是简单地找到一个可行的解决方案。写出算法逻辑，画出过程图，写伪代码或任何最有助于你从概念上理解你所写的算法的东西。</p><p id="99f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你做到了这一点，实现你想出的天真的解决方案。一旦你做到了这一点，重新审视你的解决方案和概念概述，并找到效率，以达到优化的解决方案。</p><h2 id="64ba" class="kz jv hi bd jw la lb lc ka ld le lf ke iq lg lh ki iu li lj km iy lk ll kq lm bi translated">优化的3Sum解决方案</h2><p id="cf6e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们将首先创建一个2D切片来保存我们的结果。之后，我们将对输入数组进行排序。如果nums片段中的条目是升序的，那么用多个指针来管理它们会更容易。这将使对重复和配对的检查在逻辑上更简单。</p><p id="293a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们开始遍历输入切片。我们循环直到i == size-2，这样我们就不会得到越界错误。索引I将是我们最左边的指针。</p><p id="81d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在第一个if语句中处理一些边缘情况。在那里，我们将检查I是否等于0或I是否大于0，以及当前的nums元素是否不等于前一个nums元素。我们检查I是否等于0，因为当I大于0时，我们还必须检查匹配的值。当I为0时，没有要检查的前一个元素。</p><p id="54b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们得到低，高，和总和。low将是第二个最左边的指针，位于紧接I之后的索引处。high变量将是最右边的指针，位于片的最后一个条目处。然后，我们将从0中减去nums[i]处的元素，得到总和。我们需要另外两个指针，低位和高位，来加总这个和。</p><p id="bd68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将开始一个while循环，在该循环中，我们将寻找相加得到所需总和的元素组合。当下限小于上限时，我们将设置循环运行的条件。如果nums[low]和nums[high]处的值加起来达到期望的总和，我们将它们和nums[i]相加到我们的结果片，因为我们已经找到了一个解决方案。</p><p id="3e45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们再进入两个循环。这些循环用于绕过重复项。当low &lt; high时，以及当前指针位置的元素等于下一个指针位置的元素时，第一个继续。我们向前移动左指针，直到找到一个唯一的元素。</p><p id="55cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用同样的逻辑在最右边的指针high处检查重复项。除了不是向前移动指针，而是向后移动。换句话说，我们向内移动两个指针。在这些循环结束后，我们跳过了所有重复的部分，我们将向内移动两个指针。</p><p id="2fae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果低和高的总和没有达到期望的总和，我们检查结果是否大于期望的总和。如果是的话，我们就往里走。我们这样做的原因是因为我们在开始时对值进行了排序，向内移动意味着移动到一个更小的值。否则，我们假设计算的总和小于期望的总和，并且我们向前移动低位指针。</p><p id="29e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是Golang针对3Sum的解决方案:</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="f6d9" class="kz jv hi lo b fi ls lt l lu lv">func threeSum(nums []int) [][]int {<br/>    res := [][]int{} <br/>    <br/>    sort.Ints(nums) <br/>    <br/>    for i := 0; i &lt; len(nums)-2; i++ { <br/>        if(i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i-1])) { <br/>            low := i+1 <br/>            high := len(nums)-1<br/>            sum := 0-nums[i]<br/>            <br/>            for (low &lt; high) { <br/>                if(nums[low] + nums[high] == sum) { <br/>                    res = append(res, []int{nums[i], nums[low], nums[high]}) <br/>                    for (low &lt; high &amp;&amp; nums[low] == nums[low+1]) <br/>                        { low++ }      <br/>                    for(low &lt; high &amp;&amp; nums[high] == nums[high-1]) <br/>                        { high-- }<br/>                    low++<br/>                    high--<br/>                } else if (nums[low] + nums[high] &gt; sum) {<br/>                    high--<br/>                } else {<br/>                    low++<br/>                }<br/>            }<br/>        }    <br/>    }<br/>    <br/>    return res<br/>    <br/>}</span></pre><h2 id="b6cd" class="kz jv hi bd jw la lb lc ka ld le lf ke iq lg lh ki iu li lj km iy lk ll kq lm bi translated">结束语</h2><p id="9c0a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">以下是我们解决方案的性能指标:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lw"><img src="../Images/643cc83a0984e72404d8bd11b07cdb4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2e5gKzgpaYhO1w0xDoo1A.png"/></div></div></figure></div></div>    
</body>
</html>