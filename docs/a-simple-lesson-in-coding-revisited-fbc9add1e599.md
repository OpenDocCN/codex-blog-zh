# 一堂简单的编程课，重温

> 原文：<https://medium.com/codex/a-simple-lesson-in-coding-revisited-fbc9add1e599?source=collection_archive---------26----------------------->

![](img/2d7b60b0fe31e3239e73b86dd487fb3a.png)

伊利诺伊州春田市伊利诺伊州游乐场牲畜棚里的马车。(作者照片，2021)。

我今天重温的这堂简单的编程课是从我的*数据结构*课第一周的课程计划开始的。该计划旨在帮助学生更新他们的入门编码技能。为此，我使用了一个简单的任务，比如[编写一个方法来评估一个字符串是否是回文](/@leoirakliotis/a-simple-lesson-in-coding-38334e9d8608)，来讨论编码实践。

左边的简单方法使用 for 循环来扫描字符串的回文属性。它从字符串的开头和结尾开始查看成对的字母，并向中间移动。只要每对中的字母彼此相等，Boolean `palindrome`就保持为真。当坏的一对出现时，布尔`palindrome`变为假。即使后续字母对中的字母相等，它也不会从这种状态中恢复。这是在第 7 行完成的，这里我们评估字母(`pairMatched`)和(`&&`)的两两相等以及`palindrome.`的当前状态

在`palindrome`的当前状态和两个字母之间的相等性之间取条件 AND 是至关重要的:它确保一旦发现字母不匹配，`palindrome`将保持为假。因为 AND 运算中的`false`值就像乘法中的零一样。一旦一个变量被乘以 0，它本身就会变成 0，不管我们用非零的数乘以多少次。

使用 **replace()** 和 **replaceAll()** 是出于说明的目的，如本系列的[上一篇文章](/@leoirakliotis/a-simple-lesson-in-coding-38334e9d8608)中所述。

在意识到 for 循环不是一个非常有效的技术之后，我们切换到 while 循环，如左图所示。有朋友注意到 7 号线可以简化。我们不再需要在评估中保留`palindrome`的当前值。我们在 for 循环版本的方法中需要它，因为我们评估了字符串`s`中的每一对字母。在 while 循环中，我们并不评估`s`中每一对可能的字母。当我们发现不匹配时，循环就结束了。因此，简化第 7 行就足够了，如下所示。

如果我们在第 7 行把`palindrome`放在评估的右边，这不是一个可怕的错误。但是有必要反思一下我们是如何结束第 7 行的:我们从使用 for 循环的方法开始。接下来，我们修改了该方法，使用 while 循环来提高效率。专注于用`while`代替`for`，我们可能忘记了 7 号线右侧的`palindrome`。这种方法在不改变那条线的情况下工作得很好。

如果我们关注新版本的方法中`palindrome`的作用，我们可以看到为什么在第 7 行的右边不需要它。该方法首先假设字符串`s`是一个回文。它继续比较字符串两端的字母对，向内移动。每次比较都会更新`palindrome`的值。当我们点击两个不同的字母时，它们的比较将产生错误。这将成为`palindrome`的值。这将导致 while 循环结束。接下来是 return 语句，将`palindrome`的 false 值推出。

或者，我们可能会进行最后一次两两比较，发现字符串`s`中的每一对字母都匹配。在这种情况下，while 循环结束，因为`pos`不再小于`s.length()/2`。`palindrome`的当前值现在为真。我们也完了！

当我完成这个例子并为第一周的课程做准备时，我还需要做两件事:将测试(和通过测试进行设计)引入讨论，并将这个例子转换成某种数据结构的应用程序。我将在下一篇文章中讨论这两件事。

*接下来:* [*一堂简单的编码课:先测试*](/@leoirakliotis/a-simple-lesson-in-coding-testing-first-91b3da7b9925) *！*