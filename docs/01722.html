<html>
<head>
<title>Break an egg!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打破一个鸡蛋！</h1>
<blockquote>原文：<a href="https://medium.com/codex/break-an-egg-64f97e476712?source=collection_archive---------4-----------------------#2021-05-24">https://medium.com/codex/break-an-egg-64f97e476712?source=collection_archive---------4-----------------------#2021-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/545dd61944c3bed716e1191680c1d8cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*lQAlKpst4T2u8Oe26IGx2Q.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">k个鸡蛋和一栋n层楼的建筑</figcaption></figure><h1 id="7b9e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">问题陈述</h1><p id="1778" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这是一个非常流行的数学难题(<a class="ae km" href="https://leetcode.com/problems/super-egg-drop/" rel="noopener ugc nofollow" target="_blank"> Leetcode </a>)。给你“k”个相同的鸡蛋，你可以进入一个有“n”层的建筑。你可以爬上这栋大楼的每一层，然后丢下一个鸡蛋。如果鸡蛋在当前楼层“x”打破，那么它将在“x”以上的所有楼层打破。如果鸡蛋破了，你必须扔掉它。如果鸡蛋没有在当前楼层“x”打破，那么它也不会在“x”以下的任何楼层打破。我们称“x”为临界楼层。你需要确定地确定‘x’<strong class="jq hj"><em class="kn">，通过采取最少数量的移动</em> </strong>。</p><p id="35dc" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">网上有许多博客文章描述了解决这个问题的方法。在这篇文章中，我想深入了解这个问题解决方案背后的数学直觉。之后，我将深入研究编程方法，分析递归关系试图完成什么。有点冗长！但是，读完这篇文章后，你会更清楚为什么这种方法有效，为什么它很棒。所以，让我们开始吧！</p><h1 id="573b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">对问题的数学直觉</h1><p id="2795" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果我们只有一个鸡蛋，这个问题就没那么有趣了。这是因为移动的最小次数将是“n”——我们需要在从1到“n”的每一层放下鸡蛋，以确定临界层。这是因为我们需要能够确定地确定临界底线<strong class="jq hj"><em class="kn"/></strong>，我们不能丢了鸡蛋去投机。</p><p id="5c97" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">假设我们有两个鸡蛋，我们还有一个多余的鸡蛋！所以，我们不必采取1对n的方法。我们需要弄清楚两件事:</p><p id="a62c" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">a)我们应该从哪一层开始？</p><p id="524a" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">b)如果鸡蛋没有打破，我们应该去哪一层？</p><p id="9cbd" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">为了回答这个问题，让我们假设“n”和“k”的简单值。考虑一个有10层楼的建筑(‘n’)，我们有2个蛋(‘k’)。比方说，我随机决定从第3层开始，以3为增量移动，即第3层-&gt;第6层-&gt;第9层-&gt;第10层。下图描述了这种配置下可能的不同移动。每个节点代表一个楼层号。“t”是指试验次数(当我们打破一个鸡蛋时)，而“tmax”是指我们可以采取的每种配置的最大移动次数。箭头上的图片显示了我们的鸡蛋数量。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kt"><img src="../Images/31539e0cc49384ec5dec60037a688776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGEwXbSjgv_NWrA3n3l3qA.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">图一。向3楼、6楼、9楼和10楼扔鸡蛋的后果</figcaption></figure><p id="e3e8" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">图二。下面重点介绍了鸡蛋在3楼和6楼打破时会发生什么。在每个节点，我们有两种可能性—如果鸡蛋打破，我们探索较低的楼层(显示在节点的右侧)，如果鸡蛋没有打破，我们探索较高的楼层(显示在当前节点的下方)。绿色突出显示的节点对应于鸡蛋打破后，我们下一步应该移动的楼层。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lc"><img src="../Images/53053bc233e07f35a5ec0728a5021176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6Svv8XtFr3cs_ITGbAcvg.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">图二。当鸡蛋被扔在第3层和第6层时，可视化最大试验次数(基于图1)</figcaption></figure><p id="0bdc" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">同理，图3。下面重点介绍了鸡蛋在第9层和第10层破裂时的事件顺序。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lc"><img src="../Images/10f0ba4e1d9e9f2eae9eadc7f45ae050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTdB15QonQNp0ak877ByKA.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">图三。当鸡蛋被扔向第9层和第10层时，可视化最大试验次数(基于图1)</figcaption></figure><p id="ac32" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">我们从图1-3中得到的是:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/32e767816e1a5c245f33d3f54a732689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*hPDtISsCoN21dKZ4WUoktA.png"/></div></figure><p id="d17d" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">我们需要走的步数取决于我们有多少个鸡蛋。当然，我们可以选择最小为3的配置。<strong class="jq hj"> <em class="kn">但这并不能帮助我们确定这是否是关键楼层</em> </strong>。我们应该寻求这样一种设置:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es le"><img src="../Images/5af2aac017861b0133977790d4e4280f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lSyJGNuFgKsGj_I7216UpA.png"/></div></div></figure><p id="14ab" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated"><strong class="jq hj"> <em class="kn">这将帮助我们确定临界楼层</em> </strong>。为了做到这一点，我们需要考虑的是，每次我们丢下一个鸡蛋，我们最终都会耗尽一次额外的尝试。所以，像以前那样等间隔是行不通的。</p><p id="ead4" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">我们再从三楼开始。但是，这一次，后续试验的间隔不是均匀间隔的，如图4所示。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lf"><img src="../Images/88e300b694b8efd755f5a43fe1088294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L4TGsJx6MQGxNfgd4mPung.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">图4。向3楼、5楼和6楼扔鸡蛋的后果</figcaption></figure><p id="1ab5" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">这绝对是比以前进步了。如果鸡蛋掉落在第3层或第5层，我们需要进行的最大尝试次数是3次。但是我们有一个问题。一旦我们把鸡蛋扔在第6层，我们已经尝试了最多3次，我们至少需要再做一次，以确定临界楼层。这种方法违背了我们想要的——使所有动作的最大尝试次数相等。所以，从三楼开始不是正确的选择。我们怎么挑一楼？</p><p id="f707" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">我们在图4中所做的。我们根据以下逻辑选择了后续楼层:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lg"><img src="../Images/04471303d5fa9133fbcfa25b1ee2fa7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xb5cTQYeKBawQ7j1DS21Bw.png"/></div></div></figure><p id="5718" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">如果我们从楼层“x”开始，并且我们总共有“n”个楼层，那么，我们需要解下面的方程来确定开始的最佳楼层:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/3e677f56727250192b4e3ba1ca58f6be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*3zqFsmpsXZQn7lxWVDJ5Bg.png"/></div></figure><p id="2903" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">这是前x个自然数的和，我们知道如何求这个和。如果我们将“n”的值代入10来解这个方程，我们得到x = 4——这将是我们的临界下限，如下所示。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es li"><img src="../Images/94d6d4684a7512745a9b1a0e6b37f11e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJiAYVOZr47Pu13aHQHXHg.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">图五。向4楼、7楼、9楼和10楼扔鸡蛋后果</figcaption></figure><p id="4f35" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">临界下限是4，我们需要进行的最大试验次数也是4。这个问题的另一个很酷的方面是，我们可以预测用4次尝试和2个鸡蛋可以探索的最大楼层数[2][3]:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lj"><img src="../Images/b12a32f83a6aa774119af85ea0960f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kY6U19fnXCj6ZtkrvOQYnw.png"/></div></div></figure><p id="c946" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">这应该被理解为选择分别具有0个卵滴、1个卵滴和2个卵滴的4次试验的方式的数量。</p><h1 id="5b11" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">编写通用解决方案</h1><p id="311e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在是时候戴上你的程序员帽子了！让我们来看看如何通过编程来解决2个鸡蛋的问题。</p><p id="e1d4" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">首先，我们有两个变量——楼层数和鸡蛋数。从概念上讲，我们可以想到一个函数“F ”,它接受这两个输入并返回临界下限:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/bd194b6e860911151ac8961e6899d704.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*7YFdrixirvfTkxCpoGcSGw.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">图六。接受蛋数和楼层数作为输入的函数的签名</figcaption></figure><p id="edee" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">总的想法是从1-n楼层开始迭代所有楼层，对于每一层，我们丢下鸡蛋并进行一次尝试。这给我们留下了两种可能性——鸡蛋破了，我们去探索较低的楼层，或者鸡蛋没破，我们去探索较高的楼层。因此，这产生了一个递归关系[4]:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ll"><img src="../Images/88231e9d9ec20cf5b1c9e52d60f66bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hhVjkHj2DA6rmmPAWdE2Lg.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">图7。用递推关系解决一般的落蛋问题</figcaption></figure><p id="e687" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">好，那么为什么我们有一个最小和最大项？这是为了<strong class="jq hj"> <em class="kn">最小化最大遗憾</em></strong>【1】。让我们通过一个例子来理解我们为什么这样做。</p><p id="2d54" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">为了简单和易于可视化，让我们考虑一种情况，其中我们有2个鸡蛋和4层楼。为上面的递归关系画递归树会得到类似这样的结果:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lm"><img src="../Images/3912cdcba04da606fbd85f1b05965fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOUNcrfs2WT3LlxqMN8HRw.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">图8。2个鸡蛋和4层的递归树</figcaption></figure><p id="8622" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">例如，如果我们能找到F(2，3)的最优解，那么结果可以外推得到F(2，4)的最优解。这表明这个问题有一个最优子结构，其中较小子问题的最优解可以产生较大问题的最优解[5]。</p><p id="2d8a" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">我们还看到，我们最终重新计算子问题的解，如F(2，1)，F(1，1)等。，一次又一次。这意味着存在重叠的子问题，函数‘F’多次解决相同的子问题[6]。</p><p id="23e8" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">这两个观察使它成为动态规划的理想候选，我们可以记忆子问题的结果来处理递归树的指数复杂性。</p><p id="4f3c" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">好，现在回到树，我们实际上知道树中许多节点的解决方案，如下所示:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ln"><img src="../Images/c6cf2131678e0772a0e3c0dc8c8b0036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qNgqr8c128Iprj3enhiC3w.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">图九。彩色节点(右下方的图例)有快速解决方案</figcaption></figure><p id="6822" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">因此，我们只需要继续递归橙色的节点。让我们评估这些值的函数，并可视化该树:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lo"><img src="../Images/fe13684b3929117bc3718c291acee94a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gXX4Erjc2qZkrw-9pP8FVA.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">图10。在所有节点上计算的函数</figcaption></figure><p id="8df6" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">从树根到树叶遍历树的任何一个分支表明这个实验的一个可能的结果:</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lp"><img src="../Images/3233a49f27bd225e310dc73014e955a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGT0_r2HA4adePeoZ6UZMw.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">图11。有2个蛋和4层楼的示例结果</figcaption></figure><p id="6ccf" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">我们在图11中看到的是(蓝色节点突出显示的路径)，我们从1楼开始并放下鸡蛋。它没有打破，所以我们移动到第二层，把鸡蛋放下。它不会破裂。现在，我们从二楼跳到四楼，然后把鸡蛋扔下去，鸡蛋就碎了。这是两个鸡蛋和四层楼可能出现的不同结果之一。</p><p id="ccea" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">图7中的最大化术语是确保一旦我们决定在给定的地板上扔鸡蛋，我们选择最坏的可能情况。这样做了之后，如果我们可以通过从当前楼层跳到不同的楼层来找到具有较少尝试的临界楼层，我们就不必坚持这个楼层。这就是最小化项帮助我们完成的。这也是确保我们不会试图从1-n开始在每一层扔鸡蛋，而是根据最小化鸡蛋打破次数的方法跳过楼层。</p><p id="8c7f" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">让我们看最后一个例子来理解最大遗憾的最小化。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lq"><img src="../Images/1c7a17336e87354a3f9742908fd3df7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ba-m7KEw7G-4d9S_GPnTmg.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">图12。最大遗憾最小化方法</figcaption></figure><p id="f631" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">聚焦绿色节点，从上到下阅读:</p><ul class=""><li id="00f9" class="lr ls hi jq b jr ko jv kp jz lt kd lu kh lv kl lw lx ly lz bi translated">我们选了一楼，鸡蛋没有破，所以我们搬到了二楼</li><li id="816e" class="lr ls hi jq b jr ma jv mb jz mc kd md kh me kl lw lx ly lz bi translated">鸡蛋没有在二楼打破。现在，我们可以选择搬到3楼或4楼。</li><li id="3b29" class="lr ls hi jq b jr ma jv mb jz mc kd md kh me kl lw lx ly lz bi translated">左下角的绿色树对应于第3层，我们在这里有2个结果——如果鸡蛋破裂，我们已经找到了我们的关键层(3 ),如果它没有破裂，我们需要探索3 (4)以上的一层。所以，额外投掷的最坏情况数是1。</li><li id="7bff" class="lr ls hi jq b jr ma jv mb jz mc kd md kh me kl lw lx ly lz bi translated">我们使用相同的逻辑来理解将鸡蛋扔向4楼的后果，最坏情况下的额外投掷次数也是1。</li><li id="9780" class="lr ls hi jq b jr ma jv mb jz mc kd md kh me kl lw lx ly lz bi translated">最后，在第2层，我们可以选择第3层或第4层，我们将选择最小的一层(在这种情况下也是一样)。</li></ul><p id="5a96" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">您可以在我的GitHub资源库中找到这个问题的自顶向下的记忆解决方案:</p><div class="mf mg ez fb mh mi"><a href="https://github.com/madhu90/CodeExamplesForBlogPosts/blob/main/EggDropProblem.cpp" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab dw"><div class="mk ab ml cl cj mm"><h2 class="bd hj fi z dy mn ea eb mo ed ef hh bi translated">madhu 90/CodeExamplesForBlogPosts</h2><div class="mp l"><h3 class="bd b fi z dy mn ea eb mo ed ef dx translated">在GitHub上创建一个帐户，为madhu 90/CodeExamplesForBlogPosts开发做贡献。</h3></div><div class="mq l"><p class="bd b fp z dy mn ea eb mo ed ef dx translated">github.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw ik mi"/></div></div></a></div><p id="579f" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated"><strong class="jq hj">参考</strong></p><p id="6b76" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">[1]https://datagenetics.com/blog/july22012/index.html<a class="ae km" href="https://datagenetics.com/blog/july22012/index.html" rel="noopener ugc nofollow" target="_blank"/></p><p id="052f" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">[2]<a class="ae km" href="https://code.oursky.com/famous-egg-dropping-puzzle-in-combinatorics/" rel="noopener ugc nofollow" target="_blank">https://code . our sky . com/namely-egg-dropping-puzzle-in-combinatorics/</a></p><p id="106c" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">[3]<a class="ae km" href="https://math.stackexchange.com/questions/2012591/eggs-and-floors-puzzle-extended-generalized#:~:text=2%20Answers&amp;text=For%20three%20eggs%20and%20100,suspicious%20floors%20at%20our%20disposal" rel="noopener ugc nofollow" target="_blank">https://math . stack exchange . com/questions/2012 591/eggs-and-floors-puzzle-extended-generalized #:~:text = 2% 20 answers&amp;text = For % 20 three % 20 eggs % 20 and % 20100，可疑% 20 floors % 20 at % 20 our % 20 disposal</a>。</p><p id="49bf" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">【4】<a class="ae km" rel="noopener" href="/@parv51199/egg-drop-problem-using-dynamic-programming-e22f67a1a7c3">https://medium . com/@ parv 51199/egg-drop-problem-using-dynamic-programming-e 22 f 67 a 1 a 7 c 3</a></p><p id="82df" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">【5】<a class="ae km" href="https://en.wikipedia.org/wiki/Optimal_substructure#:~:text=In%20computer%20science%2C%20a%20problem,greedy%20algorithms%20for%20a%20problem" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Optimal _ substructure #:~:text = In % 20计算机% 20科学% 2C % 20a %问题，贪婪% 20算法% 20for % 20a %问题</a>。</p><p id="08bb" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated">[6]<a class="ae km" href="https://en.wikipedia.org/wiki/Overlapping_subproblems" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Overlapping_subproblems</a></p><p id="106b" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz kq kb kc kd kr kf kg kh ks kj kk kl hb bi translated"><a class="ae km" href="https://spencermortensen.com/articles/egg-problem/" rel="noopener ugc nofollow" target="_blank">https://spencermortensen.com/articles/egg-problem/</a></p></div></div>    
</body>
</html>