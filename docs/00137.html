<html>
<head>
<title>Support Vector Machine with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现支持向量机</h1>
<blockquote>原文：<a href="https://medium.com/codex/support-vector-machine-with-python-in-just-100-lines-of-code-35e74707f8e1?source=collection_archive---------0-----------------------#2020-11-02">https://medium.com/codex/support-vector-machine-with-python-in-just-100-lines-of-code-35e74707f8e1?source=collection_archive---------0-----------------------#2020-11-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="af8e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">学习使用python构建分类问题的支持向量机模型</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/b7635979ad89c11d431ea41a53fa9a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XwzhFr2FWNa4u7T6O6F5qQ.png"/></div></div></figure><h1 id="ffc6" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">支持向量机</h1><p id="3946" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">SVM的工作原理是将数据映射到一个高维特征空间，以便可以对数据点进行分类，即使数据不是线性可分的。找到类别之间的分隔符，然后对数据进行转换，使得分隔符可以绘制为超平面。接下来，新数据的特征可以用于预测新记录应该属于哪个组。</p><h1 id="7d75" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">优势</h1><ul class=""><li id="a607" class="kx ky hi kd b ke kf kh ki kk kz ko la ks lb kw lc ld le lf bi translated">如果我们对数据了解不多，SVM是一个非常有用的方法。它可用于图像、文本、音频等数据。它可以用于不规则分布和未知分布的数据。</li><li id="a32c" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">有许多算法用于机器学习中的分类，但SVM比大多数其他算法更好，因为它在结果中具有更好的准确性。</li><li id="94a6" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">SVM在样本外数据上表现和推广得很好。由于这一点，因为它在泛化样本数据上表现良好，SVM证明了自己是快速的，因为确定的事实表明，在SVM中，对于一个样本的分类，对每个支持向量评估和执行核函数。</li><li id="d9b3" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">SVM通常不会遭受过度拟合的情况，并且当存在类之间分离的明确指示时表现良好。当样本总数小于维数时，可以使用SVM，它在记忆方面表现很好。</li><li id="b61e" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">支持向量机在寻找分离超平面方面是有用的，寻找超平面可以用于在不同组之间正确地分类数据。</li></ul><h1 id="7ca6" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">不足之处</h1><ul class=""><li id="ff35" class="kx ky hi kd b ke kf kh ki kk kz ko la ks lb kw lc ld le lf bi translated">支持向量机在高度倾斜/不平衡的数据集上表现不佳。这些是训练数据集，其中属于一个类的样本数量远远超过属于另一个类的样本数量。另一方面，逻辑回归擅长处理有偏差的数据集。</li><li id="b9fc" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">支持向量机也不是一个好的选择，尤其是当你有多个类的时候。最终，在这种情况下，您回到二元分类器，然后使用某种投票机制将样本分类到其中一个类别。</li><li id="7e2c" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">如果与训练样本相比，特征的数量非常大，则支持向量机是无效的。</li></ul><h1 id="05ed" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">SVM应用</h1><ul class=""><li id="6799" class="kx ky hi kd b ke kf kh ki kk kz ko la ks lb kw lc ld le lf bi translated">图像识别</li><li id="6438" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">文本类别分配</li><li id="2af2" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">垃圾邮件检测</li><li id="9a97" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">情感分析</li><li id="0543" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">基因表达分类</li><li id="cb40" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">回归</li><li id="7d8b" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">离群点检测</li><li id="a212" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">使聚集</li></ul><h1 id="4a3b" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">适用于SVM的Python</h1><p id="6725" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">完成SVM的理论部分后，我们现在准备用python来构建和训练一个SVM模型。在此之前，为什么要使用python呢？Python是一种通用且高效的语言，很容易学习。我们可以用python构建各种可行的机器学习模型。在本文中，我们将建立一个SVM模型来预测患者是否处于轻度和重度癌症阶段(良性或恶性)。就这样，让我们开始吧。</p><h1 id="8543" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">导入包</h1><p id="fe85" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">为了构建我们的SVM模型，我们的主要软件包将是scikit——学习构建和训练模型，pandas处理数据，NumPy处理数组，最后是matplotlib和seaborn进行可视化。按照代码将我们的主包导入python环境。</p><p id="7581" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated"><strong class="kd hj"> Python实现:</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><h1 id="f5a4" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">导入数据和EDA</h1><p id="6771" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在本文中，我们将使用一个包含所有细胞数据和信息的癌症数据集。按照代码导入python中的数据。</p><p id="5f6c" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated"><strong class="kd hj"> Python实现:</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="8bc3" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ls"><img src="../Images/636feef1756debd9ce393826c3ab6237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8w28izKUX5xJmmRGRdK3w.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">作者图片</figcaption></figure><p id="cbae" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">来自每个患者的细胞样本的特征包含在字段'<em class="lx">丛</em>'至'<em class="lx"> Mit </em>'中。这些值从1到10分级，1最接近良性。“<em class="lx">类</em>”字段包含由独立医疗程序确认的关于样本是良性(值= 2)还是恶性(值= 4)的诊断。</p><p id="db60" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">让我们使用python中的散点图来看看基于块厚度的类分布和像元大小的一致性。</p><p id="a3f1" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated"><strong class="kd hj"> Python实现:</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="2024" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ly"><img src="../Images/3061326e1e5135be3b0764a70bd4c9f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SqNG8jczzQA8Ff01RnF8vA.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">作者图片</figcaption></figure><h1 id="2ea8" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">数据处理</h1><p id="35bd" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">让我们先来看看癌症数据中变量的数据类型。为此，我们可以使用python中Pandas包提供的<em class="lx">‘dtypes’</em>函数。</p><p id="cbf3" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated"><strong class="kd hj"> Python实现:</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="77c7" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lz"><img src="../Images/346b4142648e9995cf719b1c7fb7a43b.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*Lfk6jmn4UcQkLkOOOGimrA.png"/></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">作者图片</figcaption></figure><p id="3677" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">看起来'<em class="lx"> BareNuc </em> <strong class="kd hj"> ' </strong>列包含非数字值。使用<em class="lx">‘as type’</em>函数和<em class="lx">‘numeric’</em>函数，我们可以将对象类型变量转换成整数变量。按照代码转换python中的值。</p><p id="e326" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated"><strong class="kd hj"> Python实现:</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="fa17" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ma"><img src="../Images/1376da7d5170cac895aac1232e2c78ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*95kIr6y99T_VCz45qRbTYQ.png"/></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">作者图片</figcaption></figure><p id="b2a5" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">我们的下一步是定义自变量和因变量，并使用它将我们的数据分成训练集和测试集。</p><h1 id="36d8" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">特征选择和训练测试分割</h1><p id="8cbb" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我之前说过，我们要定义X和Y变量。定义变量后，强烈建议将它们转换成数组，以便在构建模型时有所帮助。按照代码在python中定义变量。</p><p id="0a5e" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated"><strong class="kd hj"> Python实现:</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="4105" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/9540f968b7195fab520b62e261d14494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6dpFNMC4ZTxMJnbaulA3IQ.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">作者图片</figcaption></figure><p id="6022" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">现在，我们可以使用我们定义的X和Y变量将数据分成训练集和测试集。为此，我们可以使用python中scikit-learn提供的<em class="lx"> 'train_test_split' </em>函数。</p><p id="1557" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated"><strong class="kd hj"> Python实现:</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="fb0a" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/cce486e17520f999482dba86ff050176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*m86qGJc4lrL3_-0I_4qzrQ.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">作者图片</figcaption></figure><h1 id="21f0" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">建模和预测</h1><p id="4da4" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">SVM算法为执行其处理提供了核函数的选择。基本上，将数据映射到一个更高维的空间被称为内核化。用于变换的数学函数称为核函数，可以是不同的类型，例如:</p><ul class=""><li id="8129" class="kx ky hi kd b ke ll kh lm kk md ko me ks mf kw lc ld le lf bi translated">线性的</li><li id="d4be" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">多项式</li><li id="4667" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">径向基函数</li><li id="b535" class="kx ky hi kd b ke lg kh lh kk li ko lj ks lk kw lc ld le lf bi translated">乙状结肠的</li></ul><p id="df57" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">这些函数各有其特点、优缺点和等式，但由于没有简单的方法知道哪个函数在任何给定的数据集上表现最佳，我们通常依次选择不同的函数并比较结果。在本文中，我们将使用径向基函数(RBF)核来构建和训练我们的模型。用python来做吧！</p><p id="7e33" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated"><strong class="kd hj"> Python实现:</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="0915" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/afd761e30dda9b4b273c1d49e1455eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nbuDOexv74_aEVWKC_1i-A.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">作者图片</figcaption></figure><p id="b685" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">有了经过训练的SVM模型，我们可以将一些测试值传递给它来进行一些预测。按照代码用Python做预测。</p><p id="3382" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated"><strong class="kd hj"> Python实现:</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="d681" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/c4eca9540d4e71df1f5ecd1e2349dc82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*25tsVZ9bWdcJppBVvbzfHA.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">作者图片</figcaption></figure><h1 id="7188" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">估价</h1><p id="fbd2" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">现在，我们已经使用我们的SVM模型构建、训练并做出了一些预测。为了检查我们的模型结果的准确性，我们可以使用python中的scikit-learn提供的评估度量函数。在本文中，我们将使用<em class="lx">‘准确度_得分’</em>指标和<em class="lx">‘混淆_矩阵’</em>指标来评估我们的模型。让我们从python中的<em class="lx">‘accuracy _ score’</em>评估指标开始。</p><p id="44d0" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated"><strong class="kd hj"> Python实现:</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="aa08" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/fc8d2072c2df1ca7a76efa52d40a78ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dS4Qhu29Wr4XRNnP6Jv5Zg.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">作者图片</figcaption></figure><p id="43b1" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">我们的下一个评估指标是<em class="lx">“混淆矩阵”。</em>不仅仅是打印混淆矩阵，当它被图形化或绘制时会更有意义。即使有内置函数来做混淆矩阵图，手动绘图也会更好理解。按照代码用python制作一个混淆矩阵图。</p><p id="1e4a" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated"><strong class="kd hj"> Python实现:</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="73bd" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/2047e9989cac537508db93f4b80b9905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bbC29roMQwP8qtK8XjSHw.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">作者图片</figcaption></figure><h1 id="6a0e" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">最后的想法！</h1><p id="ab54" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在本文中，我们介绍了SVM的基本知识，它的优点和缺点。接下来，我们学会了用python编写SVM模型来处理癌症数据，并做了一些预测。最后，我们学会了使用python中的评估指标来评估我们的模型。我们唯一漏掉的是数学部分。所以，在你进入下一个概念之前，不要忘记覆盖它。此外，在本文中，我们只使用了一个内核，还有其他内核。所以确保你也用它来练习解决问题。至此，我们到了本文的结尾，我已经在文章的结尾提供了构建的SVM模型的源代码。</p><p id="bae9" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated"><strong class="kd hj">快乐的机器学习！</strong></p><p id="8e78" class="pw-post-body-paragraph kb kc hi kd b ke ll ij kg kh lm im kj kk ln km kn ko lo kq kr ks lp ku kv kw hb bi translated">完整代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lq lr l"/></div></figure></div></div>    
</body>
</html>