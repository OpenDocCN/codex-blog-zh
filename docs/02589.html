<html>
<head>
<title>How do we use Envoy to improve PHP Redis client performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何使用Envoy来提高PHP Redis客户端的性能</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-do-we-use-envoy-to-improve-php-redis-client-performance-2db81874dc67?source=collection_archive---------7-----------------------#2021-07-27">https://medium.com/codex/how-do-we-use-envoy-to-improve-php-redis-client-performance-2db81874dc67?source=collection_archive---------7-----------------------#2021-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7046" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Redis在Houzz的技术堆栈中扮演着非常重要的角色——我们将它用作键值存储、缓存层、队列系统等。</p><p id="9120" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Redis使用标准的TCP协议供客户端连接到它，要连接到单个Redis实例，客户端只需与Redis服务器建立TCP连接，并使用文本发送raw命令。您可以使用<code class="du jd je jf jg b">telnet</code>命令轻松测试到Redis服务器的连接。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="381a" class="jp jq hi jg b fi jr js l jt ju">bash-3.2$ telnet 127.0.0.1 6379<br/>Trying 127.0.0.1...<br/>Connected to 127.0.0.1.<br/>Escape character is '^]'.<br/>PING<br/>+PONG</span></pre><h1 id="950d" class="jv jq hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Redis集群</h1><p id="4983" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">和许多其他存储系统一样，Redis也有分布式模式——它被称为Redis集群。Redis从一个实例扩展到多个实例的方式依赖于密钥哈希。作为一个键值存储系统，Redis集群会尝试根据键值的CRC哈希将所有的键值分布到不同的实例中。Redis集群中的每个实例仅存储其自己的槽范围内的键，Redis集群中的所有实例将覆盖CRC散列的整个范围，即[0，16384]。</p><p id="58d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Redis还支持主/辅模式，这种模式可以提供数据冗余和独立的读取/更新操作。每个插槽范围可以有1个主实例，1个或多个复制副本实例存储相同的密钥。</p><figure class="jh ji jj jk fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es kx"><img src="../Images/ac48fbdddbcae4517df547dc27d91d07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RhUfIyl7Ws-jlQ_oACXLKQ.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx translated">Redis单实例与Redis集群</figcaption></figure><p id="3bc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单个Redis实例上的操作与Redis集群上的不同。要使用单个Redis实例，我们只需连接到单个套接字地址，要使用Redis集群，我们需要更复杂的逻辑。通常，Redis集群客户端需要支持以下特性:</p><ol class=""><li id="7371" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">自动发现集群拓扑。由于键存储在不同的Redis服务器实例中，Redis集群客户机必须知道哪个槽范围存储在哪个Redis服务器实例中(包括主/副本)。Redis cluster提供了一个<code class="du jd je jf jg b">CLUSTER SLOTS</code>命令，该命令可以返回包含插槽范围和主/副本套接字地址的服务器拓扑。要执行<code class="du jd je jf jg b">CLUSTER SLOTS</code>命令，Redis集群客户端至少需要知道Redis集群拓扑中1个节点的地址，这通常是在初始化客户端实例时作为开始探测地址传入的。</li><li id="08dd" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">按需向Redis服务器实例发送命令。当使用Redis集群客户端向Redis集群发送携带密钥参数的命令时，客户端必须确定该命令应该发送到哪个(哪些)Redis服务器实例。如何确定它们取决于上一步中的服务器拓扑获取器，计算密钥的CRC哈希，然后找到密钥所在的插槽范围，然后根据读/写策略，将命令发送到密钥所属插槽范围的主/副本Redis服务器实例。对于一些操作多个键的命令(例如，mget、mset等)，客户端必须基于键的槽范围组将单个多键命令分成几个批次，并将带有每个组的键的命令发送到相应的Redis服务器实例，并合并来自所有实例的结果。一些客户端库没有实现这个“高级”特性，因此他们声明不支持跨插槽的多键命令。</li></ol><p id="3812" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">已经有很多用不同语言开发的<a class="ae lx" href="https://redis.io/clients" rel="noopener ugc nofollow" target="_blank"> Redis客户端库</a>可以帮助减轻连接到单个Redis客户端或Redis集群的差异。在大多数场景中，程序员不会注意到使用单个Redis实例或Redis集群的区别，因为复杂性被客户端库封装了。</p><h1 id="1fad" class="jv jq hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">PHP Redis集群客户端及问题</h1><p id="05d2" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">单个Redis实例可以满足小型用例，在支持Houzz业务的规模上，我们必须使用Redis集群而不是单个Redis实例，因为我们已经将TBs数据存储在Redis中，并且必须将它分布到不同的实例中。</p><p id="ad41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">截至2021年，我们已经建立了一个包含200多个实例的Redis集群，启用了主/副本，以确保我们拥有数据冗余和从单个实例故障中恢复的能力。</p><p id="bf82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于历史原因，Houzz的主要编程语言是PHP，它仍然是web开发中最流行的编程语言之一。并且我们使用了<a class="ae lx" href="https://github.com/predis/predis" rel="noopener ugc nofollow" target="_blank"> predis </a>，一个广泛使用的支持redis集群的PHP Redis客户端，它提供了自动集群拓扑发现和按需向Redis服务器实例发送命令等功能。</p><p id="3610" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就功能性而言，我们对PHP redis客户端很满意，但是，PHP语言本身的特性在性能方面给了我们很大的挑战。</p><p id="5f85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与Java、Python或节点服务器应用程序不同，PHP进程不会在后续请求之间共享数据。一旦PHP处理了一个web请求，它将在准备好处理下一个请求之前丢弃所有数据。</p><p id="a0c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么这会损害Redis集群客户端的性能？</p><p id="4717" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，集群拓扑不会跨请求共享。假设predis首先连接到一个start probe redis服务器实例，发送<code class="du jd je jf jg b">CLUSTER SLOTS</code>命令，并在处理一个请求时得到了集群拓扑，这个拓扑通常是嵌套在内存中的<code class="du jd je jf jg b">array</code>不会在下一个请求中使用。因此，在下一个请求中，predis必须再次连接到其中一个start探测器，并再次发送<code class="du jd je jf jg b">CLUSTER SLOTS</code>来获取集群拓扑。这是非常无效的，因为redis集群拓扑很少改变(通常只有当我们关闭一些redis节点或添加新的Redis节点时，它才会改变，这将导致重新平衡)。额外的<code class="du jd je jf jg b">CLUSTER SLOTS</code>命令通常为每个请求增加4 ~ 5 ms的redis访问时间，如果在请求中，只需要1个redis操作，那么我们增加了100%的开销。</p><p id="ed41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PHP进程的另一个自然行为是，你不能在两个请求之间保持任何TCP连接。</p><figure class="jh ji jj jk fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ly"><img src="../Images/2657cd9c783d28e4823fb2473eb0515a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZcZEIDTyOEKjPgtyhAw4A.png"/></div></div></figure><p id="865e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上图所示，假设我们在一台机器上运行2个PHP进程，每个进程处理2个请求，每个请求需要连接到2个Redis服务器实例。由同一个进程处理的子请求将连接到同一个redis服务器实例，但是由于前一个请求的TCP连接被关闭，它不能被重用，所以即使它连接到(Redis服务器实例的)同一个套接字地址，它也必须创建另一个TCP连接。</p><p id="3f10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，随着PHP进程处理越来越多的请求，它会创建/关闭越来越多的到Redis集群的TCP连接。与可以在此过程中保持持久TCP连接的其他语言相比，这已经是一个很大的性能损失。</p><figure class="jh ji jj jk fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lz"><img src="../Images/815e185d62025c1bd955e9edcded2d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3q74A-IPOLo9aZNsgAjCSQ.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx translated">TCP连接状态</figcaption></figure><p id="1c63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个更关键的问题是，TCP连接的终止不是直接关闭，也不是立即释放资源。</p><p id="1d09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上图所示，在主动关闭模式下，当TCP连接发起方(在本例中是PHP redis集群客户端)开始关闭连接时，它通过TCP连接发送一个<code class="du jd je jf jg b">FIN</code>数据包，TCP连接接收方(redis集群实例)需要发回<code class="du jd je jf jg b">ACK</code> + <code class="du jd je jf jg b">FIN</code>数据包。由于TCP连接的性质，发起方将进入<code class="du jd je jf jg b">TIME_WAIT</code>状态，直到最后超时，连接最终关闭，TCP连接资源被系统回收。</p><p id="7df8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于PHP Redis集群客户端访问模式，它会不断创建到PHP Redis集群实例的新TCP连接，并在一个会话结束后立即关闭它们。由于我们的生产流量QPS为1盒，它在盒中留下了太多的<code class="du jd je jf jg b">TIME_WAIT</code> TCP连接。一旦<code class="du jd je jf jg b">TIME_WAIT</code> TCP连接堆积，新的TCP连接创建速度变慢，从而使得Redis集群客户端变慢，导致web请求响应时间增加，更多的请求被卡住。最后，它达到了Redis集群客户端未能在超时设置时间(4秒)内创建TCP连接的阈值，并将抛出一个错误，说明Redis服务器已关闭。</p><p id="6b6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从去年开始就注意到了这个问题，当时我们的访问量显著增加(从商业角度来看，这是一个非常好的迹象！)，而且我们在高峰时段看到了更多抱怨Redis服务器停机和性能下降的错误。但是Redis服务器实际上一点也不紧张，瓶颈纯粹来自客户端的TCP连接。而为了解决这个问题，每次SRE团队都要增加我们应用程序盒的实例，这是不必要的，也是对我们计算资源的浪费。</p><h1 id="e0f7" class="jv jq hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">寻找解决方案</h1><p id="008c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果你google/stackoverflow“太多TIME_WAIT tcp连接”关键词，一些博客会引出以下解决方案:启用tcp resuse功能以减少<code class="du jd je jf jg b">TIME_WAIT</code> TCP连接。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="845a" class="jp jq hi jg b fi jr js l jt ju">sysctl -w net.ipv4.tcp_tw_reuse=1</span></pre><p id="0c0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们相信这是可行的，并把这个选项添加到我们生产机器的系统默认设置中，但是，它没有帮助。处于<code class="du jd je jf jg b">TIME_WAIT</code>状态的TCP连接仍然很高。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="e6fd" class="jp jq hi jg b fi jr js l jt ju">root@web-server:/# sysctl net.ipv4.tcp_tw_reuse=1<br/>net.ipv4.tcp_tw_reuse = 1<br/>root@web-server:/# ss -tan state time-wait | grep 6379 | wc -l<br/>70145</span></pre><p id="2353" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">受<a class="ae lx" href="https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux#netipv4tcp_tw_reuse" rel="noopener ugc nofollow" target="_blank">在繁忙的Linux服务器上处理TCP时间等待状态</a>博客文章的启发，我们认为我们找到了它不起作用的原因。</p><blockquote class="ma mb mc"><p id="d7ca" class="if ig md ih b ii ij ik il im in io ip me ir is it mf iv iw ix mg iz ja jb jc hb bi translated"><em class="hi">通过启用net.ipv4.tcp_tw_reuse，如果新的时间戳严格大于为前一个连接记录的最新时间戳，Linux将为新的传出连接重用处于时间等待状态的现有连接:处于时间等待状态的传出连接可以在一秒钟后重用。</em></p></blockquote><p id="e9ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在“仅仅一秒钟”内，由于盒子的QPS在100左右，它大概会创建~ 100(avg QPS)* 50(1个请求中redis连接的avg数量)= 5000个新的TCP连接，而这5K个连接并不能在精确的一秒钟内重用完好无损的<code class="du jd je jf jg b">TIME_WAIT</code>连接。在受益于tcp重用机制之前，太多的<code class="du jd je jf jg b">TIME_WAIT</code> TCP连接阻碍了内核创建新的TCP连接，因此这没有多大帮助。</p><h1 id="8787" class="jv jq hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">特使/特使Redis组</h1><p id="7bd0" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">自2020年起，我们将Istio作为我们的服务网格解决方案引入到我们的Kubernetes集群中，它开始充当来自/去往我们的web应用程序容器的所有网络流量的代理。</p><p id="c5a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为Istio的代理实现，Envoy提供了许多特性，有助于从应用程序代码中抽象出网络逻辑。</p><p id="737d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Envoy在新版本中提供的一个鼓舞人心的功能是<a class="ae lx" href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/other_protocols/redis#redis-cluster-support-experimental" rel="noopener ugc nofollow" target="_blank"> Redis集群支持</a>，这是我们用来解决这个问题的最终解决方案。</p><blockquote class="ma mb mc"><p id="95bb" class="if ig md ih b ii ij ik il im in io ip me ir is it mf iv iw ix mg iz ja jb jc hb bi translated"><em class="hi">当使用Envoy作为Redis集群的sidecar代理时，服务可以使用以任何语言实现的非集群Redis客户端连接到代理，就像它是单节点Redis实例一样。特使代理将跟踪集群拓扑，并根据规范向集群中正确的Redis节点发送命令。Envoy代理还可以添加高级功能，如从副本中读取，而不是更新每种语言的redis客户端。</em></p><p id="4d5e" class="if ig md ih b ii ij ik il im in io ip me ir is it mf iv iw ix mg iz ja jb jc hb bi translated"><em class="hi">特使代理通过向集群中的随机节点发送周期性集群槽命令来跟踪集群的拓扑，并维护以下信息:</em></p><p id="3d3c" class="if ig md ih b ii ij ik il im in io ip me ir is it mf iv iw ix mg iz ja jb jc hb bi translated">*已知节点列表。<br/> *每个碎片的初选。<br/> *节点进入或离开集群。</p></blockquote><p id="f1eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启用该特性后，PHP Redis客户端的集群相关逻辑将由Envoy接管。PHP Redis客户端只需要创建一个到Envoy提供的代理Redis实例的连接。</p><p id="d561" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于缺少提供的示例，我们花了一段时间才弄清楚如何配置Envoy Redis集群代理。但是我们终于搞清楚了配置，首先我们需要创建一个后端集群。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="4db4" class="jp jq hi jg b fi jr js l jt ju">apiVersion: networking.istio.io/v1alpha3<br/>kind: EnvoyFilter<br/>metadata:<br/>  name: redis-cluster-backend<br/>spec:<br/>  configPatches:<br/>  - applyTo: CLUSTER<br/>    patch:<br/>      operation: INSERT_FIRST<br/>      value:<br/>        cluster_type:<br/>          name: envoy.clusters.redis<br/>          typed_config:<br/>            '@type': type.googleapis.com/google.protobuf.Struct<br/>            value:<br/>              cluster_refresh_rate: 1800s<br/>              cluster_refresh_timeout: 4s<br/>              host_degraded_refresh_threshold: 1<br/>              redirect_refresh_interval: 4s<br/>              redirect_refresh_threshold: 1<br/>        connect_timeout: 4s<br/>        dns_lookup_family: V4_ONLY<br/>        load_assignment:<br/>          cluster_name: custom-redis-cluster<br/>          endpoints:<br/>          - lb_endpoints:<br/>            - endpoint:<br/>                address:<br/>                  socket_address:<br/>                    address: &lt;redis instance 1 ip&gt;<br/>                    port_value: &lt;redis instance 1 port&gt;<br/>            - endpoint:<br/>                address:<br/>                  socket_address:<br/>                    address: &lt;redis instance 2 ip&gt;<br/>                    port_value: &lt;redis instance 1 port&gt;<br/>            - endpoint:<br/>                address:<br/>                  socket_address:<br/>                    address: &lt;redis instance 3 port&gt;<br/>                    port_value: &lt;redis instance 3 port&gt;<br/>        name: redis-cluster-backend<br/>        outlier_detection:<br/>          base_ejection_time: 20s<br/>          consecutive_5xx: 1<br/>          interval: 5s<br/>        upstream_connection_options:<br/>          tcp_keepalive:<br/>            keepalive_interval: 5<br/>            keepalive_probes: 1<br/>            keepalive_time: 30</span></pre><p id="4b02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在后端设置中，最重要的设置是<code class="du jd je jf jg b">load_assignment</code>，它基本上描述了envoy将发送<code class="du jd je jf jg b">CLUSTER SLOTS</code>命令来获取集群拓扑的startuo探测节点。</p><p id="7540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了获得更好的性能，肯定有相当多的设置值得调整:</p><ol class=""><li id="6232" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated"><strong class="ih hj"> cluster_refresh_rate </strong>:这是特使向启动探测节点发送<code class="du jd je jf jg b">CLUSTER SLOTS</code>命令的间隔。通常redis集群拓扑不会经常改变，所以我们可以将这个值设置得比默认值(5s)长得多</li><li id="9d25" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj">host _ degraded _ refresh _ threshold</strong>:在触发拓扑刷新请求之前，已降级或不正常的主机数量。这非常有帮助，因为我们会将<code class="du jd je jf jg b">cluster_refresh_rate</code>配置为尽可能长，一旦redis集群拓扑在两次刷新之间发生变化，将此配置设置为较低值(1表示最具攻击性)将立即让Envoy发送<code class="du jd je jf jg b">CLUSTER SLOS</code>命令以获取新拓扑，从而将潜在有问题的节点从连接池中删除。</li><li id="93de" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj">redirect _ refresh _ threshold</strong>:触发拓扑刷新请求前必须接收的重定向错误数。有时，当我们在Redis集群中添加/删除节点时，键会在新的集群实例之间重新平衡，这将导致一些响应成为<code class="du jd je jf jg b">MOVED</code>或<code class="du jd je jf jg b">ASK</code>，在这种情况下，我们应该让Envoy发送<code class="du jd je jf jg b">CLUSTER SLOS</code>命令来立即获得新的拓扑。</li><li id="e577" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj">离群点检测</strong> : <a class="ae lx" href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/outlier" rel="noopener ugc nofollow" target="_blank">离群点检测</a>是Envoy中检测离群上游主机的统一机制。在Envoy Redis集群中，上游指拓扑中的1个Redis集群服务器。假设一个redis集群节点突然被关闭，下面对该节点的请求将得到ERR响应。<code class="du jd je jf jg b">consecutive_5xx</code>设置是过去<code class="du jd je jf jg b">interval</code>时间内ERR响应的阈值，以便认为节点不健康。一旦节点被认为是不健康的，它将被从上游服务器中取出，并在<code class="du jd je jf jg b">base_ejection_time</code>之后试图被放回，并在随后的降级中呈指数后退。</li><li id="1e40" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj">upstream _ connection _ options</strong>:这主要用于调整Envoy和Redis集群节点之间TCP连接的保持活动设置。如果PHP客户端试图向目的节点发送命令，Envoy将按需连接到Redis集群节点，命令发送后，连接保持<code class="du jd je jf jg b">ESTABLISED</code>状态。但是如果连接保持太长时间而没有向Redis集群节点发送任何包，它可能会被Redis集群节点关闭，为了延长TCP连接的寿命，我们可以配置Envoy在连接建立后的<code class="du jd je jf jg b">keepalive_time</code>之后向Redis集群节点发送keepalive包，并将其设置为以<code class="du jd je jf jg b">keep_alive</code>间隔发送<code class="du jd je jf jg b">keepalive_probes</code>次keepalive间隔。</li></ol><p id="de19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还需要在Envoy中创建一个前端，让主容器中的PHP客户端进行连接。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="6aa4" class="jp jq hi jg b fi jr js l jt ju">apiVersion: networking.istio.io/v1alpha3<br/>kind: EnvoyFilter<br/>metadata:<br/>  name: redis-cluster-frontend<br/>spec:<br/>  configPatches:<br/>  - applyTo: LISTENER<br/>    match:<br/>      context: SIDECAR_OUTBOUND<br/>    patch:<br/>      operation: ADD<br/>      value:<br/>        address:<br/>          socket_address:<br/>            address: 127.0.10.1<br/>            port_value: 6379<br/>            protocol: TCP<br/>        filter_chains:<br/>        - filters:<br/>          - name: envoy.filters.network.redis_proxy<br/>            typed_config:<br/>              '@type': type.googleapis.com/envoy.extensions.filters.network.redis_proxy.v3.RedisProxy<br/>              prefix_routes:<br/>                catch_all_route:<br/>                  cluster: redis-cluster-backend<br/>              settings:<br/>                enable_hashtagging: true<br/>                enable_redirection: true<br/>                op_timeout: 4s<br/>                read_policy: PREFER_REPLICA<br/>              stat_prefix: redis_proxy<br/>        name: redis-cluster-frontend</span></pre><p id="22e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的配置在<code class="du jd je jf jg b">127.0.10.1:6379</code>上创建了一个Redis代理前端。除了istio-proxy之外，其他容器也可以使用该地址。最重要的配置是<code class="du jd je jf jg b">prefix_routes.catch_all_route</code>到<code class="du jd je jf jg b">redis-cluster-backend</code>群集，这正是我们之前创建的后端群集。代理前端的配置相对简单，可以调整的设置较少，一个重要的设置是<code class="du jd je jf jg b">read_policy</code>，我们选择了<code class="du jd je jf jg b">PREFER_REPLICA</code>来实现与原始PHP Redis集群客户端逻辑相同的功能——当从redis (get、mget等)读取时，总是尝试从副本节点读取，只有当插槽的所有副本节点都不可用时才从主节点读取。</p><figure class="jh ji jj jk fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mh"><img src="../Images/fe85c5279b64a29b33eeb95dd1ab08b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5_l4_rDM0CJIW242Ek0aw.png"/></div></div></figure><p id="a7ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上图直接展示了使用Envoy Redis集群代理可以节省TCP连接的神奇之处。</p><p id="cb7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之前，假设在1个请求处理过程中PHP Redis客户端需要连接到X个Redis集群实例，它必须创建从主web服务器容器到istio-proxy容器的X个TCP连接，envoy必须创建从istio-proxy容器到Redis集群实例的相应X个TCP连接。</p><p id="38d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用Envoy Redis集群代理后，PHP客户端只需要连接到istio-proxy容器中的前端代理，Envoy就会“智能”地将命令调度到代理后端，并创建到X Redis集群服务器的连接。</p><p id="35b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们为PHP进程处理的一个请求保存了X-1个TCP连接。此外，在Envoy Redis集群代理后端和真正的Redis集群服务之间创建的X连接是持久连接，它们不会在PHP进程处理完一个请求后关闭。此外，由主web服务器容器中的其他PHP进程处理的其他请求也可以重用连接，因为前端和后端是分离的。这些都导致了TCP连接的巨大节省。</p><pre class="jh ji jj jk fd jl jg jm jn aw jo bi"><span id="56dc" class="jp jq hi jg b fi jr js l jt ju">root@web-server:/# ss -tan state time-wait | grep 6379 | wc -l<br/>3108</span></pre><p id="9ff9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过这样做，我们打破了PHP语言的自然限制，我们减少了95%的tcp连接！</p><p id="5030" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们看到每个请求的平均redis连接时间大大减少，从大约5毫秒减少到近0毫秒！这是由以下因素促成的:</p><ol class=""><li id="8380" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">由于所有的命令都由PHP客户端发送到同一个前端代理，因此只需要建立一个连接。</li><li id="d881" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated">到前端的连接是通过本地网络(从主容器到istio-proxy容器)，这是非常稳定和轻量级的。</li></ol><p id="2b75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在生产k8s集群上100%部署了该解决方案，事实上，它解决了<code class="du jd je jf jg b">TIME_WAIT</code> TCP连接的瓶颈，并使我们的pod能够承载更多流量。这也导致k8s资源的一些节省。</p><h1 id="0af2" class="jv jq hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">警告</h1><p id="7da8" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">虽然我们谈到了Envoy Redis集群代理的所有优点，但使用它肯定有一些注意事项。</p><h1 id="e688" class="jv jq hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">读/写性能下降</h1><p id="b802" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们在上一章提到平均TCP连接时间从大约5毫秒减少到将近0毫秒。但是对于读/写redis操作，性能有所下降。这个很好理解。Envoy仍然需要创建到Redis集群节点的TCP连接，并且仍然需要向节点发送命令包，并接收响应，甚至添加了更多的逻辑来将命令分派到正确的节点，并聚合来自多个节点(例如mget、mset)的响应。当代理后端中的TCP连接重用没有带来太多好处时，这种退化对于稀疏请求来说更加明显。</p><p id="cd51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们注意到了这种持续的性能下降，但我们最终接受了它——与PHP代码逻辑的其余部分相比，总体平均读/写时间足够快了。</p><h1 id="b7f6" class="jv jq hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">缺乏重试逻辑</h1><p id="0c0a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在旧的PHP Redis集群客户端中有一个非常重要的特性，那就是自动重试逻辑。</p><p id="8aab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，对于Redis集群的每个碎片，它由1个主节点和2个副本节点组成。当PHP Redis集群客户端发送read命令时，它将首先随机选择一个副本来发送命令，如果命令由于网络通信问题而失败，它将重试向另一个副本节点发送命令，如果仍然失败，它将最终向主节点发送命令。</p><p id="8755" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个逻辑很简单，对于减少停机时间非常有帮助。假设我们正在对整个Redis集群进行滚动重启，通常我们将一次重启一个节点，重试逻辑将确保请求仍然可以得到正确处理。</p><p id="2bb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，内置重试逻辑仍然在2021年中期<a class="ae lx" href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/other_protocols/redis" rel="noopener ugc nofollow" target="_blank">计划的未来功能列表</a>中，当我们测试在1个碎片中放置1个副本节点时，我们注意到当我们看到来自特使的“没有上游主机”的客户端错误时，有大约10秒的停机时间。可以通过调整<code class="du jd je jf jg b">outlier_detection</code>设置来减少停机时间，当节点停机时，对特定节点的后续请求将出错，在<code class="du jd je jf jg b">outlier_detection.interval</code>时间之后，它将从上游中移除，并且特使将停止向该节点发送任何命令。</p><p id="8b41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前没有好的方法来绕过这个问题。即使我们在PHP客户端重试，PHP客户端也无法决定Envoy将连接哪个Redis集群节点。</p><p id="7614" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们忍受着缺乏重试逻辑，并依靠<code class="du jd je jf jg b">outlier_detection</code>机制来减少停机时间，我们真的希望内置的重试逻辑可以很快得到支持。</p><h1 id="3245" class="jv jq hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">太多已建立的连接</h1><p id="2b13" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是我们预见到的一个问题，在我们的PHP客户端创建到Redis集群节点的TCP连接之前，会在请求被处理后很快断开连接。“来来去去”模式实际上有一个好处，即整个Redis集群节点没有太多来自客户端的<code class="du jd je jf jg b">ESTABLISHED</code>连接。</p><p id="5c3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自从我们开始使用Envoy Redis集群代理进行测试以来，我们立即注意到来自Redis服务器节点的<code class="du jd je jf jg b">ESTABLISHED</code>连接急剧增加。增加的持久连接已经影响了连接性能-如果一个Redis集群节点已经被太多的客户端连接，新的连接将很难建立。</p><p id="423f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了改善这一点，我们在redis服务器端将redis.conf中的<code class="du jd je jf jg b">timeout</code>设置从300秒调至该值的一半，这有助于减少我们工作负载中30%的<code class="du jd je jf jg b">ESTABLISHED</code>连接。<code class="du jd je jf jg b">timeout</code>设置让Redis服务器端在客户端长时间空闲后关闭连接。然而，总有一个折衷——我们配置的<code class="du jd je jf jg b">timeout</code>设置越短，Envoy就越有可能频繁地连接到Redis集群节点，从而影响Redis客户端的整体性能。</p><p id="a653" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个解决方案是增加Redis集群节点数量，这样到1个Redis集群节点的平均连接将会下降，但是，如果每个节点上的Redis工作负载不高，这将导致不必要的资源浪费。</p></div></div>    
</body>
</html>