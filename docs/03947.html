<html>
<head>
<title>When DRY becomes an anti-pattern: Code in Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当DRY成为反模式:代码中的代码</h1>
<blockquote>原文：<a href="https://medium.com/codex/when-dry-becomes-an-anti-pattern-code-in-code-87b1caab791f?source=collection_archive---------3-----------------------#2021-10-10">https://medium.com/codex/when-dry-becomes-an-anti-pattern-code-in-code-87b1caab791f?source=collection_archive---------3-----------------------#2021-10-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="92e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，拥有可读代码没有普遍的原则。我经常在想，哪一套原则应该放在第一位:YAGNI？干？固体？。我相信最好的原则还没有被编纂。所以我想建立一个新的，可读性是最重要的(RIMI)。</p><p id="112e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以找到许多专家讨论代码可读性的重要性。这里有一个让你开始的参考:<a class="ae jd" href="https://blog.pragmaticengineer.com/readable-code/" rel="noopener ugc nofollow" target="_blank">https://blog.pragmaticengineer.com/readable-code/</a></p><p id="34c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据RIMI的主要原则，我们将探索几个明显不适用于DRY的场景。本文探讨第一种场景。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/a1c7d7ea12302f38dc62ff4c96ec82ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4owZ5XHcVh6jGX9sHppxCQ.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">像沙漠一样干燥</figcaption></figure><h1 id="8973" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">配置的相同结构功能</h1><p id="9453" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这是函数的行为根据参数而变化的地方。这可能是最不适合干燥的地方。</p><p id="a7c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑以下ETL数据场景:</p><pre class="jf jg jh ji fd kx ky kz la aw lb bi"><span id="3864" class="lc jv hi ky b fi ld le l lf lg">void ImportData(sourceQuery, tableRoot, transformQuery, loadQuery)<br/>{<br/>    var sourceData = ReadFromSource(sourceQuery);<br/>    var stagingTableName = tableRoot + "_Staging";<br/>    WriteToStaging(sourceData, stagingTableName);<br/>    TransformData(transformQuery);<br/>    LoadData(loadQuery);<br/>}<br/><br/>void Main()<br/>{<br/>    ImportData("SELECT *...", "Cars", "UPDATE Cars_Staging...", "UPSERT Cars...");<br/>    ImportData("SELECT *...", "Mechanics", "UPDATE Mechanics_Staging...", "UPSERT Mechanics...");<br/>}</span></pre><p id="c312" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SQL参数不在上下文中，您必须在ImportData中查看它们的用途。尽管完成这样的事情感觉很“聪明”，但阅读起来很困难。</p><p id="561d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它也很难修改。如果需要处理一个新表，但是需要2x转换步骤，那么ImportData函数将变得更加复杂，并且需要处理可选的空参数。这种越来越复杂的情况实际上比我的经验要糟糕得多。程序员从简单的需求中创建这种不可读的模式，但是随着时间的推移，需求总是变得更加复杂。</p><p id="8ae1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">改进后的设计如下:</p><pre class="jf jg jh ji fd kx ky kz la aw lb bi"><span id="884f" class="lc jv hi ky b fi ld le l lf lg">void Main()<br/>{<br/>    ImportCars();<br/>    ImportMechanics();<br/>}<br/><br/>void ImportCars()<br/>{<br/>    var sourceData = ReadFromSource("SELECT *...");<br/>    WriteToStaging(sourceData, "Cars_Staging");<br/>    TransformData("UPDATE Cars_Staging...");<br/>    LoadData("UPSERT Mechanics...");<br/>}<br/><br/>void ImportMechanics(sourceQuery, tableRoot, transformQuery, loadQuery)<br/>{<br/>    var sourceData = ReadFromSource("SELECT *...");<br/>    WriteToStaging(sourceData, Mechanics_Staging);<br/>    TransformData("UPDATE Mechanics_Staging...");<br/>    TransformData("UPDATE Mechanics_Staging..."); //Second transformation<br/>    LoadData("UPSERT Mechanics...");<br/>}</span></pre><p id="2af0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在ImportMechanics函数中包含了第二个转换。看到与“结构”的背离仅仅需要一行额外的代码了吗？这很好地表明了之前有问题的代码模式是“代码中的代码”反模式。</p><p id="b2d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以这显示了对DRY原则的意识形态追求是如何导致糟糕的代码设计的。</p><p id="05bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">避免这种“代码中的代码”情况的最好方法是尝试和想象几种设计，并选择最好的。你需要尝试并确定你的想法<em class="lh">是否可能</em>是代码中代码，以及替代设计是否只需要多一行代码。</p><p id="e5ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你担心创建100个相同模式的“重复”，你应该搭建你的代码。生成代码意味着您可以模板化正确的模式，使代码非常可读和可维护。</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="37b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请继续关注我，我将探索更多的情况，在这些情况下，干巴巴或什么都不做的态度会导致反模式。更新:参见<a class="ae jd" rel="noopener" href="/codex/when-dry-becomes-an-anti-pattern-abstraction-layers-540b9f0cb831">当Dry成为反模式:抽象层</a></p><p id="8f7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新:我后来发现了AHA，就是“避免草率的抽象”。你可以在维基百科上读到关于干燥的文章:<a class="ae jd" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Don%27t_repeat_yourself</a></p></div></div>    
</body>
</html>