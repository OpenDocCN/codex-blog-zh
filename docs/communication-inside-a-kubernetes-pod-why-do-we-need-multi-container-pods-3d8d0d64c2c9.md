# Kubernetes Pod 内部的通信——为什么我们需要多容器 Pod？

> 原文：<https://medium.com/codex/communication-inside-a-kubernetes-pod-why-do-we-need-multi-container-pods-3d8d0d64c2c9?source=collection_archive---------0----------------------->

## 从“进程内”和“进程外”的设计理念来探讨 pod 中的多容器模式。

为了理解对多容器容器的需求，我想后退一点，从容器不可知环境中的一般应用程序开始。

传统上，一个应用程序将由一个单一的流程组成，该流程具有业务逻辑以及横切&基础设施关注点(如日志记录、弹性、配置)。通常会有专用的 SDK 库(例如。NET Polly，这是一个错误处理库)&该应用程序是围绕这样的库实现的，主要使用依赖注入。或者有一个自定义实现。两种方法都遵循“**过程中”**设计**。**

当我们将应用程序和横切关注点放在一起时，我们将业务逻辑与运营/基础设施逻辑耦合在一起，我们正在创建一个**高耦合&低内聚设计**。

但是“过程中”的设计有它的好处—

1.  直接实施和调试。
2.  简单的部署和监控。
3.  较少的连接/移动部件会导致故障。
4.  极低的延迟。根据另一个进程运行的位置(同一台机器或远程机器)，会有一定程度的延迟。

因此，对于较简单的服务，或者当服务寿命较短时，这可能是一个很好的设计。或者当减少延迟是关键的 NFR 时。

另一方面，随着服务随着时间的推移开始增长,“过程中”设计开始出现一些问题——

1.  由于它是一个单独的进程，这意味着 SDK 的运行时必须与应用程序的运行时兼容。如果有更适合的 SDK，但需要不同的平台/运行时，这可能是一个问题。或者我们希望将应用程序迁移到 SDK 不支持的不同平台。
2.  即使其中一个外设发生变化，这种设计也需要改变代码。因此，当代码不可用或者更改代码所需的技能已经丢失时，它不是一个选项。
3.  如果一个应用程序是基于几个第三方 SDK 构建的，那么保持 SDK 的版本是一个挑战。
4.  在定制实现的情况下，应用程序代码被基础结构代码所膨胀。其可以在所有应用中重复。

作为一种选择，另一种可能性是将横切关注点提取到一个支持服务的独立流程中，从而创建一个"**流程外"**设计。其中应用程序本身只对其业务目标负责，并与不同的流程讨论横切关注点。

![](img/b8a9a7de7a9262437957bc227f60006c.png)

示例:进程内架构与进程外架构

如上图所示，进程外架构促进了可扩展的、灵活的、可伸缩的、松散耦合的架构，它有几个好处

1.  横切过程可以是任何技术，只要与主应用程序的通信是可能的。
2.  因为混合技术更容易，所以有可能为每项工作带来最适合的工具，而不是寻找一个好的通用解决方案。
3.  横切过程可以在不影响主应用程序的情况下被更新或替换。
4.  它支持自主扩展。

在 Kubernetes 的上下文中，pod 是 Kubernetes 中最小的实体，每个 pod 都有一个唯一的 IP 地址。Pod 就像是容器的虚拟机，因此容器可以访问 Pod 的网络和存储。

![](img/4f790b472831da2c2014b7dd176e700f.png)

托管在端口 4000 运行监听的容器的 Pod

一个 pod 可以有一个或多个容器。拥有多个容器的目的与**“进程外”**设计的目的相同(除了缩放，因为 Kubernetes 使用 Pod 作为最小的缩放单位)。

在 Kubernetes 环境中，有更多的理由将跨领域/基础设施问题排除在应用之外，因为我们需要最先进的工具来支持可观察性、应用安全性和合规性策略以及处理流量管理。这意味着应该可以在不改变应用程序代码的情况下切换基础设施技术。

实现这种进程外设计的常见模式是将主应用程序打包成一个独立的容器。并将助手服务打包成单独的容器。

![](img/d308cc84adcdf858d345e8713a603348.png)

示例—同一 pod 中的多个容器共享网络命名空间和存储。

例如，在上面的图像中，应用程序容器使用代理与外部世界对话，由于两个容器都在同一个网络名称空间中，代理可以作为 localhost 访问。并且日志可以由日志代理(数据拉出器)使用公共存储卷(日志代理可以将其流式传输到日志收集服务器)来收集。

本质上，主应用程序进程和助手进程位于同一位置，共同管理，并且具有相同的生存期。它们在一个 pod 中有着相同的命运&由 Kubernetes 作为一个整体来管理。此外，请注意，助手应用程序除了支持主应用程序之外没有其他用途。这种模式被称为**侧车模式**。

![](img/01856d7e0476ed51f978c5eee2a90197.png)

带边车的摩托车。边车的目的是提高摩托车的性能。没有摩托车就没有意义。照片由[菲利普·波托尼克](https://unsplash.com/@philpotophoto?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

现在，我们来谈谈**大使-边车**模式—

国家或软件的大使，是代表国家/软件对外对话的实体，代表国家/软件。

虽然 Ambassador 模式是一个独立的模式，但是，当它作为一个助手容器被实现在与主应用程序相同的 pod 中时，由于它的用途和生命周期，它是 sidecar 模式的一个专门化。

让我们花几分钟时间来欣赏这样一个代理，它在每个 pod 中作为边站与主应用程序一起运行，因为**这是一个分布式代理**(不同于中央代理)。它没有中心跳或远程代理的延迟，是监控流量和应用任何网络管理规则的好地方。

如果所有 pod 内的所有通信都通过这样的代理发生，那么所有的通信都是可观察的和可操作的。

![](img/aa94e1452b64715e4ec50d278bd715c0.png)

与主应用程序一起运行的大使边车。

**总结**

在这篇文章中，我采用了一种容器不可知的方法来描述“进程内”设计如何简化手头的任务，但却创建了一个高耦合、低内聚的设计。而“进程外”设计以复杂性为代价促进了高内聚、低耦合的设计。因此，考虑权衡以决定什么是适当的，什么是过度的，这是至关重要的。

Sidecar 是实现进程外架构的一种模式。pod 中的容器可以像 sidecar 一样工作，因为它们共享网络和存储，它们是同处一地和共同管理的。因为我们希望在不改变应用程序的情况下保持最先进的基础设施，所以它们更受欢迎。

在 pod 中使用 sidecar 代理会在集群级别产生一个分布式代理，这是服务网格利用的一个概念。

我希望你觉得这篇文章有用，请告诉我你的想法。