<html>
<head>
<title>AWS Lambda and MongoDB Atlas Microservices: From Local to Live</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda和MongoDB Atlas微服务:从本地到现场</h1>
<blockquote>原文：<a href="https://medium.com/codex/aws-lambda-and-mongodb-atlas-microservices-from-local-to-live-8967738d6f13?source=collection_archive---------4-----------------------#2021-07-19">https://medium.com/codex/aws-lambda-and-mongodb-atlas-microservices-from-local-to-live-8967738d6f13?source=collection_archive---------4-----------------------#2021-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/daf0a2d477f254911a35fecd9776fcd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K862aDM7rWt7Ce5mJLa36w.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@spacex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae iu" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="051c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于各种原因，为云构建软件令人望而生畏，特别的困难超出了选择基本方法和底层服务的范围；以确定的、可重复的方式提供良好的本地开发人员体验和供应基础设施本身也带来了相当大的挑战。</p><p id="3f4c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为我最近调查<a class="ae iu" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> MongoDB Atlas </a>的一部分，这是一个用于运行和扩展同名NoSQL数据库的托管云服务，我构建了<a class="ae iu" href="https://github.com/jamesseanwright/iot-events-api" rel="noopener ugc nofollow" target="_blank">一个REST API，用于存储和检索从物联网设备</a>发送的事件。我的目标是构建一个微服务:</p><ul class=""><li id="b9d2" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">当周期性面临不可预见的流量高峰时，自动扩展</li><li id="f10d" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">可以在本地运行，不依赖云基础架构</li><li id="702e" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">使用单一基础设施作为代码工具，在AWS和MongoDB Atlas之间提供所需的云资源</li><li id="44fc" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">在AWS和Atlas之间建立连接时，遵循安全最佳实践</li></ul><p id="4baf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章不会作为实现上述目标的一步一步的教程，而是提供我的项目的一个高层次的概述，允许人们在<a class="ae iu" href="https://github.com/jamesseanwright/iot-events-api" rel="noopener ugc nofollow" target="_blank">资源库</a>中更深入地挖掘，甚至将它部署到自己的AWS和Atlas帐户中。</p><h1 id="8228" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">该产品</h1><p id="0ff9" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">REST API提供了支持两种操作的单个<code class="du lk ll lm ln b">/events</code>端点。</p><h2 id="9bbc" class="lo ki hi bd kj lp lq lr kn ls lt lu kr jg lv lw kv jk lx ly kz jo lz ma ld mb bi translated">添加事件</h2><p id="33a9" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">冰箱和智能手表等物联网设备可以向终端发出HTTP POST请求，以报告任意事件和相关值，如当前内部温度或步数，并使用唯一的设备ID来标识自己:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h2 id="802a" class="lo ki hi bd kj lp lq lr kn ls lt lu kr jg lv lw kv jk lx ly kz jo lz ma ld mb bi translated">检索事件</h2><p id="f307" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">还可以用GET请求检索不同设备ID的事件；这主要用于前端应用程序，如监控仪表板，以及故障排除和一般审计:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h1 id="0526" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">关键技术</h1><p id="0061" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">尽管AWS Lambda和MongoDB Atlas是该解决方案的核心，但我使用了其他技术来实现上述目标，并提供良好的开发人员体验:</p><ul class=""><li id="5c57" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">Docker，to<a class="ae iu" href="https://aws.amazon.com/blogs/aws/new-for-aws-lambda-container-image-support/" rel="noopener ugc nofollow" target="_blank">container化我们的lambda函数以部署到AWS </a>并在本地运行它们，在您的机器和云中提供一致的执行环境。我们的函数是用Node.js编写的</li><li id="2ffa" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">Docker Compose，在本地开发的单个虚拟网络中运行我们的lambdas以及本地MongoDB和NGINX容器——后者用于模拟Amazon API Gateway</li><li id="7273" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">Terraform，使用一种通用的配置语言来自动化我们在AWS和MongoDB Atlas上的整个基础设施</li><li id="bdc0" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">大量的AWS服务，我将在下一节中介绍</li></ul><h1 id="988f" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">体系结构</h1><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/b02f65c714d353aab27aabec673f9179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mX92ypHcQwY6asMAZ2lFEQ.png"/></div></div></figure><p id="ef39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在详细阐述本地开发人员体验之前提供架构的概述可能看起来不太直观，但是对系统如何整合的高层次理解将更好地证明我在设计所述本地DX时所做的决定。</p><p id="4247" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">入口点是API Gateway REST API，允许用户通过HTTP抽象与私有资源间接交互；这个网关与我们的处理程序集成在一起，分别跨HTTP GET和POST动词检索和添加事件。lambdas的映像被推送到弹性容器注册中心，当它们第一次被提供时，它们被部署到它们相应的功能。除了能够使用将在云中固有地使用的相同运行时和环境在本地调用所述功能之外，容器是比传统zip文件更有效的传输机制；鉴于<a class="ae iu" href="https://dzone.com/articles/docker-layers-explained" rel="noopener ugc nofollow" target="_blank"> Docker图像层被缓存</a>，人们只需要构建并推送对图像所做的更改，而不是每次都上传所有内容。</p><p id="cb8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了与Atlas集群通信，该解决方案使用了一个VPC端点和附带的PrivateLink端点服务。正如我将在后面介绍的，我们可以将我们的Atlas实体配置为驻留在与我们所在区域相同的Atlas管理的VPC中，这意味着我们的lambdas可以与我们的数据库进行通信，而不会有任何流量离开我们的网络，更不用说通过互联网进行往返(这多酷啊？！);除了明显的性能提升，这还是一个巨大的安全胜利。端点和我们的lambdas都连接到我们的VPC内的公共子网，并具有各自的安全组，以允许这些私有资源之间的通信。</p><h1 id="8b81" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">兰姆达斯</h1><p id="1361" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">如架构图所示，该解决方案包含两个lambdas:一个用于向数据库添加事件，另一个用于检索事件。这两个函数共享一个公共的docker文件，允许将特定的处理程序内容指定为构建参数:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="7757" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了复制处理程序模块之外，生成的映像还包括<code class="du lk ll lm ln b">common</code>目录，其中存储了两个lambdas共享的代码。本质上，lambdas与MongoDB数据库交互，并基于该操作返回一些数据，正如在<code class="du lk ll lm ln b">get-events</code>函数中可以看到的:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="3765" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该函数使用<a class="ae iu" href="https://docs.mongodb.com/manual/core/aggregation-pipeline/" rel="noopener ugc nofollow" target="_blank">聚合管道</a>按照提供的日期和设备ID过滤<a class="ae iu" href="https://www.mongodb.com/blog/post/building-with-patterns-the-bucket-pattern" rel="noopener ugc nofollow" target="_blank">分桶</a>事件，并将相关事件投射到JSON-serializable数组中。</p><h1 id="ef38" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">本地开发者体验</h1><p id="cb6e" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">为我们的函数使用官方AWS Lambda容器映像的结果是，我们可以通过向提供的<code class="du lk ll lm ln b">/2015–03–31/functions/function/invocations</code>集成端点发出HTTP POST请求来本地测试它们。从健全性测试的角度来看，直接调用这个路径是好的，但是当运行多个容器化的lambdass时，证明是笨拙的，每个容器化的lambda通常暴露在单独的端口上。同样值得注意的是，这个调用URL用lambda逐字返回的数据进行响应，这是可以理解的；在我们的例子中，我们返回一个Amazon API Gateway integration响应，所以HTTP 200总是会出现，尽管<code class="du lk ll lm ln b">statusCode</code>属性可能是非2xx代码。</p><p id="f762" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个难点是，我们的函数需要一个共享的MongoDB实例，因为我们希望验证，当分别调用<code class="du lk ll lm ln b">add-event</code>和<code class="du lk ll lm ln b">get-event</code>处理程序时，我们可以端到端地读写数据库。</p><p id="82cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用<a class="ae iu" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>创建终极开发人员体验，为我们的处理程序定义服务，以及基于<a class="ae iu" href="https://hub.docker.com/_/mongo" rel="noopener ugc nofollow" target="_blank">官方MongoDB映像</a>的数据库服务和使用<a class="ae iu" href="https://hub.docker.com/_/nginx" rel="noopener ugc nofollow" target="_blank">官方NGINX映像</a>的API网关服务，所有这些都驻留在同一个网络中:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="6579" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm ln b">api-gateway</code>服务是我们进入整个应用程序的入口点，所以我们在端口8080上向主机系统公开它；其他服务不被直接调用，因此保留在内部。</p><p id="51a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于我们使用两个独立的HTTP方法(GET和POST)在单个路径(<code class="du lk ll lm ln b">/events</code>)上操作，所以我们提供了一个小的NGINX配置，它在构建时被挂载到服务的文件系统中:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="0adc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在收到对<code class="du lk ll lm ln b">/events</code>的请求时，我们将HTTP方法映射到Docker组合服务名——即主机名——它包含相应的函数。然后，我们使用JavaScript的子集<a class="ae iu" href="https://nginx.org/en/docs/njs/" rel="noopener ugc nofollow" target="_blank"> njs </a>来调用我们的内部<code class="du lk ll lm ln b">/integration</code>位置，该位置又调用函数的集成端点。njs包括标准的JavaScript <code class="du lk ll lm ln b">JSON</code> global，这对于解析Amazon API Gateway integration响应以及通过适当的HTTP响应元素显示主体和元数据(如标题和状态代码)来说是非常宝贵的:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="4423" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过一个<code class="du lk ll lm ln b">docker-compose up</code>，我们可以在本地运行整个微服务，向本地API网关发送与部署的应用兼容的请求:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="a959" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，我们的本地设置缺少生产应用程序通过各种托管服务处理的一些特性，比如请求验证；我们可以推出自己的产品，但为了当地的发展，我认为没有必要。</p><h1 id="e472" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">部署到云</h1><p id="9996" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">虽然我们可以手动供应我们的AWS和MongoDB Atlas实体，但在多个AWS帐户和Atlas组织之间复制我们的基础架构(这是预生产环境需求中常见的需求)将非常耗时且容易出错。相反，我们应该将我们的基础设施声明为代码，使它可以从单一的真实来源中重现。</p><p id="e938" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">AWS提供自己的基础设施作为代码工具，CloudFormation，但自然只支持AWS资源；因为我们的数据库基础设施位于Atlas中，所以我们需要一个能够自动化多个云平台的解决方案。有了<a class="ae iu" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>，我们可以用一种通用的配置语言集成多个提供商。除了为我们的lambdas提供IAM角色之外，我们的主模块还集成了其他四个定制模块:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="6250" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们的VPC模块(<code class="du lk ll lm ln b">./tf-modules/vpc</code>)为我们的微服务创建了一个专用的虚拟私有云，它定义了我们将AWS资源连接到的私有子网和安全组:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="202c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于我们所有的子网都是私有的，我们的任何资源都无法与更广泛的互联网通信，也无法与VPC以外的实体联系。但是，我们的lambdas需要连接到我们VPC支持的Atlas集群，因此我们创建了单独的安全组，以允许在我们整个网络的边界内实现这种连接。</p><p id="8874" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们带入主模块的下一个模块定义了我们的Atlas资源(<code class="du lk ll lm ln b">./tf-modules/atlas</code>):</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="a28c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该模块通过<a class="ae iu" href="https://registry.terraform.io/providers/mongodb/mongodbatlas/latest" rel="noopener ugc nofollow" target="_blank">官方</a> <code class="du lk ll lm ln b"><a class="ae iu" href="https://registry.terraform.io/providers/mongodb/mongodbatlas/latest" rel="noopener ugc nofollow" target="_blank">mongodbatlas</a></code> <a class="ae iu" href="https://registry.terraform.io/providers/mongodb/mongodbatlas/latest" rel="noopener ugc nofollow" target="_blank">提供方</a>创建所需的图集资源。通过将<code class="du lk ll lm ln b">"AWS"</code>指定为我们集群的<code class="du lk ll lm ln b">provider_name</code>，Atlas将在为<code class="du lk ll lm ln b">provider_region_name</code>参数指定的区域中的托管VPC上提供我们的MongoDB副本集，允许我们配置VPC端点和相应的端点服务；这些是允许我们的VPC单方面连接到Atlas VPC和查询集群而不通过更广泛的互联网路由所需要的。我应该强调的是，我们使用<a class="ae iu" href="https://registry.terraform.io/providers/hashicorp/random/latest/docs" rel="noopener ugc nofollow" target="_blank"/><code class="du lk ll lm ln b"><a class="ae iu" href="https://registry.terraform.io/providers/hashicorp/random/latest/docs" rel="noopener ugc nofollow" target="_blank">random</a></code><a class="ae iu" href="https://registry.terraform.io/providers/hashicorp/random/latest/docs" rel="noopener ugc nofollow" target="_blank">提供者</a>为数据库用户生成一个高熵密码，该密码作为模块输出返回，并被lambda模块引用。</p><p id="bbd9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">多么精彩的一幕。ECR Lambda模块(<code class="du lk ll lm ln b">./tf-modules/ecr-lambda</code>)为函数的映像声明了一个Amazon ECR存储库，该存储库随后被部署到AWS Lambda:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="0f0f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当存储库被创建时，我们使用<code class="du lk ll lm ln b">local-exec</code> provisioner为给定的函数构建和推送Docker映像；这些命令仅在第一次调配时调用，因此对映像的后续更改必须手动构建并推送到ECR。注意，我们还创建了一个<code class="du lk ll lm ln b">aws_lambda_permission</code>资源，以便我们的lambda可以被我们的Amazon API Gateway REST API调用。</p><p id="d3f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我真的太擅长这些片段了。我们最终的定制模块定义了一个API Gateway REST API，HTTP请求将被发送到该API，以便与我们的微服务(<code class="du lk ll lm ln b">./tf-modules/rest-api</code>)进行交互:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="91f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总的来说，该模块中声明的资源类似于我们的NGINX服务和本地开发设置中的配置，尽管具有请求验证和API密钥，可以在部署时提供给Terraform。</p><p id="95e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们几乎已经准备好将我们的微服务部署到云了，但是除了导出<code class="du lk ll lm ln b">MONGODB_ATLAS_PUBLIC_KEY</code>和<code class="du lk ll lm ln b">MONGODB_ATLAS_PRIVATE_KEY</code>环境变量，我们还需要为我们的根模块的输入变量提供一些值(这些可以在使用<code class="du lk ll lm ln b">-var</code>选项运行<code class="du lk ll lm ln b">terraform apply</code>时指定，但是我个人一直使用一个<a class="ae iu" href="https://www.terraform.io/docs/language/values/variables.html#variable-definitions-tfvars-files" rel="noopener ugc nofollow" target="_blank">根</a> <code class="du lk ll lm ln b"><a class="ae iu" href="https://www.terraform.io/docs/language/values/variables.html#variable-definitions-tfvars-files" rel="noopener ugc nofollow" target="_blank">.tfvars</a></code> <a class="ae iu" href="https://www.terraform.io/docs/language/values/variables.html#variable-definitions-tfvars-files" rel="noopener ugc nofollow" target="_blank">文件</a>):</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="3d81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">应用我们的配置之前的最后一步是根据ECR认证Docker:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="603b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在可以运行<code class="du lk ll lm ln b">terraform apply</code>，在此基础上，我们将看到一个Terraform将创建的资源计划，该计划将在用<code class="du lk ll lm ln b">yes</code>响应时提交给AWS和Atlas请注意，配置Atlas集群可能需要10分钟的时间。</p><p id="5dcb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完成后，我们应该会在AWS帐户中看到Terraform生成的各种原语:</p><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/64c018c6b4e75da400980f1066eaa1f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ixnv7dkJ13dCVKQnrAphRQ.png"/></div></div></figure><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/f9e6b13dc41771597f7fc7c1055559f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zeqxeDU4Hca-KMeGgpaJpg.png"/></div></div></figure><p id="7d2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还应该在Atlas项目的<em class="ml">网络访问</em>部分观察到私有端点是可用的，并且相应的端点服务为请求做好了准备:</p><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/e02b4498cbaad3d46ba7bfa61ccd29bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6RPMDjqrK-TQoI_bpondw.png"/></div></div></figure><p id="b08e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以像本地NGINX网关一样，向我们的生产API网关发送请求:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="fc3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们甚至可以通过删除查询参数和主体属性，或者通过提供一个给定属性不支持其数据类型的值来验证我们的请求验证:</p><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><figure class="mc md me mf fd ij"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h1 id="81f2" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">结束语</h1><p id="8f77" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">无服务器技术极大地降低了构建软件的成本和维护开销，并消除了管理和扩展内部服务器场的需要。相反，考虑到它们对云的依赖，在本地运行它们可能会很棘手；在这方面，官方容器映像是一个游戏改变者，因为它们提供了一个一致的执行环境，可以集成到Docker Compose配置中。也就是说，实现良好的开发人员体验并随后将新功能集成到该设置中所需的样板文件有些麻烦。</p><p id="9e29" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除此之外，AWS Lambda并不总是某些应用程序的最佳用例；承受持续稳定负载的服务可能会受益于使用一般的应用服务器来消除冷启动。另一方面，对于面临不定期、不可预测的负载的微服务，无服务器方法可能足够高效，并且成本效益更高。</p></div></div>    
</body>
</html>