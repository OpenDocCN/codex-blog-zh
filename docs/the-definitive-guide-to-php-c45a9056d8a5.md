# PHP 权威指南

> 原文：<https://medium.com/codex/the-definitive-guide-to-php-c45a9056d8a5?source=collection_archive---------11----------------------->

## 你只需要在一个地方知道

![](img/3b5dba9fa3bf0c6cc9d92ddb10237b8c.png)

马库斯·温克勒在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

在过去的 20 年里，PHP 一直是 T4 最好的编程语言之一，

其简单易用和强大的功能创造了大量成功的职业生涯。

更不用说还有 CMSs 和 PHP 框架的存在。

我说的是 WordPress 和 Laravel。

它们目前出现在大多数互联网网站上。

尽管每周都有新的流行语言诞生。

为了提高这门语言的水平，你必须知道你不知道的东西。

…然后再去练。

所以去喝杯咖啡吧，因为在这篇长文里，我会给你介绍 PHP 的所有知识。

帮你找到下一份工作。

# PHP 传记

正如今天所知，PHP 实际上是一个名为 PHP/FI 的产品的继承者。

拉斯马斯·勒德尔夫在 1994 年创造了 PHP。

PHP 的第一个化身是一组简单的**公共网关接口(CGI)。**

随着时间的推移，Rasmus 需要更多的功能，所以他重写了 PHP 工具。

产生一个更大更丰富的实现。

这个新模型能够进行数据库交互等等。

1995 年 6 月

Rasmus 向公众发布了 PHP 工具的源代码，这使得开发人员可以按照他们认为合适的方式使用它。

语法本身类似于 Perl。

事实上，

为了将代码嵌入到 HTML 文件中，开发人员必须使用 **HTML 注释**。

FI 作为一种 CGI 工具继续得到发展和接受，但仍然不是一种语言。

然而，

这在接下来的一个月开始改变。

1995 年 10 月，Rasmus 发布了完全重写的代码。

设计成在结构上类似于 C。PHP 使得熟悉 C、Perl 和类似语言的开发人员很容易采用。

该代码得到了另一个完整的改造，在 1996 年 4 月，结合过去版本的名称，

拉斯穆斯介绍了 PHP/FI。

第二代的这种实现开始形成 **PHP。**

从一套工具中，它把自己塑造成了一门独立的编程语言。

它包括对 DBM、mSQL 和 Postgres95 数据库的内置支持。

加上 cookies、用户自定义函数支持等等。

那年 6 月，PHP/FI 获得了 2.0 版本的地位。

尽管它的发展时间很短，但它仍然越来越受欢迎。

在 1997 年和 1998 年，PHP/FI 在全世界拥有数千名狂热的用户。

截止到 1998 年 5 月的一项 Netcraft 调查表明**将近 60，000 个域名**安装了 PHP。

这个数字相当于当时互联网上所有域名的 1%。

尽管有这些令人印象深刻的数字，但`PHP/FI`的成熟注定有局限性。

虽然有几个小贡献者，它仍然是由一个人开发的。

# PHP 5

在经历了漫长的故事和 Zend 引擎的创建之后，最常见的版本 PHP 5 于 2004 年 7 月发布。

它主要由其核心 Zend Engine 2.0 驱动，该引擎具有新的对象模型和许多其他新功能。

PHP 的开发团队包括数十名开发人员。

加上其他几十名从事 PHP 相关和支持项目的程序员。

项目如梨、PECL、文档、

可以肯定的是，PHP 现在已经安装在世界上数千万甚至上亿的域名中。

# PHP 7

2018 年 12 月发布，

语法上有几处改进。

这个版本和前一个版本的主要区别在于它的执行速度。

PHP 太快了，我们直接跳到了第 7 版，跳过了第 6 版。

玩笑归玩笑，

几项测试表明，在某些情况下，它处理代码的速度可以提高 50%。

使用更流行的后端语言进行缓存，比如 Python 和 NodeJs。

语法也得到了很大的改进。

核心团队专注于提高代码的可读性。

他们通过提供更多的关键字和摒弃未使用的方法来做到这一点

PHP 7.3 的更新可以分为四大类。

**新语法，弃用，然后是新特性和核心变化。**

关于新语法，我们更新了 heredoc 和`nowdoc`。它们不太严格，易于使用。

如果您喜欢经常使用 array，您会很高兴知道允许使用尾随逗号。

它不再抛出任何错误或警告。

另一个更新是关于 list 函数的。

它提供了向变量添加数组元素的可能性，即使是通过引用。

在弃用时，不能再使用*image2 BMP()*函数。

这是一个重复的`*imagewbmp()*`，已经被删除，以使语言更快。

最后，

您必须声明区分大小写的常量。

您可以通过将函数的第三个参数作为 true 传递来实现这一点。

新功能包括:

先说`json_decode()`，

在无效输入的情况下，它返回一个 *null* 变量，即使 *null* 是 JSON 解码的有效对象。

这使得调试 JSON 格式的数据非常困难。

相反，

我们可以选择让`*json_encode*`和`*json_decode*`在出错时抛出异常，

新的`*JsonException*`是`*Exception*`的子类，它是在全局名称空间中声明的。

在以前的版本中，有几个函数用于创建错误。

一个例子是 PHP 7.2 中关于脚本中不可计数元素的 *count()* 函数。

可计数元素是数组和对象，它们的类实现了*可计数*接口。

PHP 7.3 有了 *is_countable()* 函数。

它根据传递的变量返回一个布尔值。

该语言最后引入的特性是`*array_key_first()*` 和`*array_key_last()*` 函数。

他们的目标都是不言自明的，

它们允许你在不使用其他方法如`foreach`或改变索引的情况下获得一个数组的键。

PHP 7.3 语言核心的另一个变化是兼容 Perl 的正则表达式。

PHP 过去使用版本 8 的 *PCRE* 库，从 PHP 7 开始它将使用 *PCRE2* 。

必须认为 PCRE2 是一个完全不同的新库。

验证字符串模式时，PCRE2 更严格。

结果是你需要更加小心

尤其是使用`*preg_match()*`这样的函数时。

# 当前版本:PHP 8

PHP 8 于 2020 年 11 月 26 日发布

这是一个主要版本，因此有大量的变化和改进。

因为这个原因。

更新代码后。

可能有必要检查弃用的和旧的函数是否正常工作。

一个简单的解决方案是使用自动化测试。

PHP 8 还带来了几个新特性。

最重要的是:属性、`nullsafe`操作符、`match`表达式、`JIT`等等。

# 让我们来谈谈代码:构造

PHP 提供了几种结构，

**构造不是函数。**

它们不能被称为回调函数。

它们也遵循不同于函数的规则。

在这里，我将只涉及其中的一些，

用的最多的手下来是:`*echo, print, die, return, isset*` 和 `*require*`。

PHP 中的构造为广泛的目标提供了解决方案。

这对于将文件包含到另一个文件或终止应用程序非常有用。

他们还可以在浏览器上传递数据，并检查各种变量的状态。

# 变量

在 PHP 中，变量用来存储信息。

使用变量时，必须遵循几个规则。

在 PHP 中，所有的变量都以美元符号为前缀。

PHP 是一种松散类型的语言。

这意味着变量值可以在整个代码中改变。

当前值被认为是其最近的赋值。

要给变量赋值，你需要使用等号运算符( *=* )。

将名称放在左边，将值放在右边。

有两类变量。

它们既简单又复杂，在 PHP 中共有 8 种不同的变量类型。

它们是:

*   **整数**整数，不带小数点
*   **双精度浮点数**
*   这个变量可以有两个值，真或假。
*   **NULL** 默认情况下只有一个值的变量
*   **字符串**包括字符，它被引号括起来
*   **数组**复合变量是其他值的集合。
*   **对象**是另一个复合变量。它包含特定于类的值和函数。
*   **资源**是特殊变量类型。它们保存对文件或连接等资源的引用。

你可以给一个变量赋值，然后在你的代码中改变它。

您甚至可以像检查其他类型的值一样检查它们。

实际上，

PHP 在需要时自动转换类型的工作非常出色。

# 操作

在编程中经常需要做某种类型的操作。

尤其是在处理复杂系统和创建复杂计算时。

PHP 支持 5 种类型的操作。

它们是:

*   算术运算符
*   比较运算符
*   逻辑(或关系)运算符
*   赋值运算符
*   条件(或三元)运算符

# 算术运算符

此类别分为其他 7 种不同的操作，

其中大多数都很容易理解。

你实际上已经在小学学过了。

它们是加法、减法、乘法和除法。

它们的工作方式正如您所料:

你有两个变量。

通常是数字，但不是强制的。

在它们之间插入运算符以执行操作。

通常通过前面提到的赋值操作符将结果赋给另一个变量。

然后我们还有其他 3 个算术运算符，它们不太常见，解释起来有点复杂。

第一个是模数，用符号%表示。

它返回除法运算后的余数，下面是一个例子:6%4 = 2

这个类别的最后两个元素很容易理解。

它们是递增运算符和递减运算符。

要使用它们，你需要符号`++`和`—` 。

您可以在变量之前或之后使用这些运算符。

他们将执行两种不同的操作。

如果在变量前插入，操作将立即执行。

之后将对值进行评估。

在相反的情况下，

如果运算符跟随变量，则值在求值过程中保持不变。

只有在评估之后，数字才会增加或减少。

# 比较运算符

比较运算符在条件中使用，它们返回一个布尔值。

**要进行比较，您需要在两个操作数之间插入比较运算符。**

然后根据预期的结果编写代码。

最基本的操作数是等号，由两个等号一个接一个地表示，

如果两个操作数相同，返回值将为真，否则为假。

**这个操作数的反义词是不等于操作数。**

它有一个感叹号，后面跟一个等号，它的工作方式与前一个完全相反。

然后我们有小于，大于，小于或等于，大于或等于。

所有之前的都使用数学中的主要和次要符号。

最终，

**最后一个是飞船操作员，**

这让许多开发人员非常高兴，因为它帮助他们避免了只有几个字符的几行代码。

**宇宙飞船的操作符由一个外形怪异的符号** `***<=>***` ***组成。***

它类似于一艘宇宙飞船，评估两个变量的大小，

它返回三个定义值中的一个，可以是-1、0 或 1，具体取决于较大变量的位置。

# 逻辑(或关系)运算符

逻辑运算符是每种编程语言的基本组成部分，

所有这些运算符都将返回一个布尔值。

其结果将让您定义代码将要遵循的不同路径。

不同的补丁根据不同的条件你可以事先建立。

在 PHP 中，

有 4 个逻辑运算符，每个都可以用作符号或其含义的字面翻译。

它们是:

*   **和** —使用该运算符时，必须至少有两个单一条件。通过计算这些条件，您将能够检索一个布尔值。如果第一个和第二个条件都为真，则该运算符返回真
*   **或** —对于上一个操作者来说是类似的，实际上也至少要有两个条件才能起作用。即使在这种情况下，对这两个条件的评估将返回一个布尔变量，您需要使用它来执行一些操作。在他的例子中，如果两个元素中的任何一个为真，则值为真。
*   **而不是** —这非常简单，它只需要一个条件或参数。通过在它们前面加一个感叹号，我们说我们将测试相反的值
*   **Xor** -我发现这是一个棘手的问题，它考虑了两个条件。如果任一条件为真，它将返回真响应，但与 or 运算符不同，如果两个条件都测试为真，它将检查假

# 赋值运算符

属于这一类别的操作符很容易记住，

基本上大多数带有等号的运算符都属于这一类。

有时赋值运算符与算术运算符一起使用。

在某人的代码中看到一个`+=`或`-=`并不罕见。

对于乘法和除法，运算符的工作方式完全相同。

你甚至很少会遇到模数赋值运算符%=，它的工作方式与后者相同，但它的使用仅限于特定的函数。

# 条件(或三元)运算符

三元运算符是天赐之物如果你想检查简单的条件而没有时间，

该命令与问号结合使用，后跟冒号，与 if-else 语句的用法相同

条件不必写在括号内(尽管我喜欢用它们)，

然后你需要根据你通常使用的关键字 *else* 来考虑颜色。

如果条件为真，冒号前的值将被考虑。

否则，PHP 将只考虑第二个实例(冒号后面的那个)。

当您想要回显消息或根据某些条件为变量赋值时，这非常有用，现在只需一行代码即可完成

# 环

如果您需要一次又一次地执行同一个代码块，那么您需要使用循环，

**有几种类型的回路，每种回路都有其自身的特性和特征，必须根据具体情况使用。**

在 PHP 中，我们有 4 种不同类型的循环，

开始时，理解您必须为您的 web 应用程序选择哪个循环并不容易，

但是为了简单起见，每一个循环都可以描述成一个句子，这将让你明确你必须放在什么地方。

这里有几个例子。

我必须重复这个程序 *3 次*。

*当*这个条件成立时，我想让代码块重复自己。

*做*吧！然后当条件仍然为真时，重复该块 if 和*。*

T21 为名单上的每个人写下他们的名字和地址。

循环的另一个特征是它们有一个增量。

为了使循环保持可变，我们正在评估改变值的需要(或者在`foreach`的情况下结束)。

**如果你忘记在循环中插入一个增量，它将永远运行。**

**由于计算机消耗，如果不是计算机本身，这将阻塞应用程序。**

[你可以在这里看到非常详细的循环解释](http://www.anastasionico.uk/blog/php-tutorial-for-while-foreach)

不再那么困难了，不是吗？

让我们详细地看看它们

# for 循环

如果您已经知道需要重复循环多少次，那么您将需要 for 循环，

我必须重复这段代码 3 次。**for 循环有一个非常基本的语法，由 3 个元素组成:**

**初始化**是我们需要评估以创建循环的变量的初始值。

**条件**说明代码何时需要继续循环，

最后，

**增量**，正如我们在上面几行中所说的，这里是你增加或减少你为循环评估的变量的值的地方。

# while 循环

*当变量小于 10 时，我想让代码块重复自己。*

理解这个循环非常简单，

这里有一个计算变量的条件。

无法确定循环中的代码将执行多少次。

**在应用程序执行期间，我们根本不知道循环是否会被执行。**

从第一个实例开始，条件就被评估为 false，并且整个 while 循环被跳过，这种情况并不少见。

无法确定循环中的代码将执行多少次。

**在应用程序执行期间，我们根本不知道循环是否会被执行。**

从第一个实例开始，条件就被评估为 false，并且整个 while 循环被跳过，这种情况并不少见。

# 做…的同时

这个循环看起来就像上面看到的 while，它也接受一个条件，并根据它的评估执行一个循环或跳过代码，

*动手吧！然后，如果且当条件仍然为真时，重复该块。*

这里的主要区别和为什么你会选择 do…while 而不是简单的 *while* 的原因是，**这里你希望代码至少执行一次。**

第一次执行代码后，您可以决定是继续执行还是退出循环并继续应用程序。

# Foreach 循环

*对这个数组中的每个人回显其姓名和地址*

PHP 有一组绝对的类和接口，实现了该语言的几个功能。

其中一个类是名为`*Traversable*`的类。

这个类和`*IteratorAggregate*`或者迭代器类一起设置了元素在 foreach 中应该如何工作，

数组、对象和集合是最适合由 foreach 循环解析的元素。

**这种循环与其他循环的区别在于，你不知道也不能决定你要运行多少次。**

当变量内的元素结束时，循环结束。

因为有一种方法可以通过使用查询限制或使用 continue 和 break 这样的结构来控制获得的数据量，

当从数据库中检索数据时，这是一个非常有用的特性。

在 PHP 系列文章中，我写了很多关于我的[循环中的可遍历接口和其他接口的内容。](http://anastasionico.uk/blog/php-tutorial-for-while-foreach)

# 情况

你已经看到了上面的三元运算符。

以某种方式，

它可以被看作是一个条件语句。

PHP 中还有其他条件语句，它们都依赖于你预测的条件数量。

**条件将被评估为一个布尔值，并据此决定要执行的代码块。**

如果条件为真，则执行代码。

根据你选择使用的条件类型，会有不同的结果。

条件语句非常容易理解，它们都使用简单明了的语法。

PHP 中的条件列表如下:

*   **If** —只有一个条件，如果为真，代码将被执行，否则跳过；
*   **If…else** —这里有两个代码块。如果条件为真，将执行第一个，否则，要执行的块将是 else 语句下的块。如果脚本从这里通过，肯定会执行一些东西；
*   **If…elseif…else** —这通常用于 web 开发人员期望执行三个或更多可能的情况。您可以根据需要插入任意多的内容，每个内容都有自己的条件。如果都不为真，执行的代码将在 else 语句下；
*   **开关** —如果你的代码有 4 条或更多的路径可以选择，你应该考虑使用开关。它提供了一系列 case 语句和一个缺省 case，以防前面的所有条件都被评估为假；

[这里有一篇关于这些的博文，解释得非常详细](http://anastasionico.uk/blog/php-if-switch)

# 数组

数组是变量，

但是，我认为数组应该在本文中有一个单独的段落，

数组非常有用。

**数组是一种特殊类型的变量，它们被称为复合变量，这意味着它可以在单个变量中收集几个值。**

通常情况下，

数组通过使用一个称为索引的数字(它们采用数字数组的名称)或通过键/值对(关联数组)来实现。

它不限于包含标量元素。

这意味着您可以将一个数组插入到一个数组中，从而创建通常称为多维数组的东西。

这使得代码使用起来更加复杂，有时需要对循环中的循环进行解析。

**它并不理想，性能较低，但如果使用得当，它也可以被利用，使数据检索变得更加容易。**

事实上，

当一个 web 开发人员能够掌握它们时，他就可以创建一个矩阵并利用 PHP 内置的几十个函数。

[如果你想了解它们，我在我的“数组函数暴露”系列文章中介绍了很多](http://www.anastasionico.uk/blog/php-array-functions-exposed)

# 会话和 Cookies

在最后一集里，

[我已经简要介绍了会话的工作方式，](http://www.anastasionico.uk/blog/learn-php)

在这里，我们深入解释。

简而言之，会话是一种允许开发人员跨 web 应用程序的不同页面存储用户信息的方法。

为了简单起见，想想你在生活中遇到的所有带有登录系统的网站。

它们都在某个地方存储你的名字或用户名。

当您浏览网站页面时，您仍处于登录状态，您的详细信息仍显示在顶部菜单上。

在你注册的每个社交网络和任何谷歌服务中，我们都有几个这样的例子

当您开始和结束使用应用程序时，电脑必须知道您是谁。

这是因为常见的用法和安全问题。

开发者需要解决的问题是 HTTP 地址是无状态的。

**会话变量的目的是弄清这个问题。**

它通过保存用户的一些信息并使这些信息在所有其他需要认证的页面上可用来实现这一点。

这是一个全局变量，它是一个数组，下面是一个例子。

`*$_SESSION[‘username’]*`

会话变量持续到用户关闭浏览器。

与 cookie(这是下一段的主题)不同，所有可用的信息并不存储在用户的机器上。

Cookies 是一个类似的概念，但是它们实际工作的方式不同于会话，

首先，

**cookie 不是存储在浏览器上的变量，cookie 是一个实际的文件，非常小，由服务器存放在用户的机器上。**

每当同一台计算机在浏览器上请求某些页面时，cookie 也会被发送。

当您设置 cookie 时，需要的一些参数是结束日期和您想要启用 cookie 的路径(网站的页面)。

web 开发人员的工作是使用 PHP 之类的编程语言来创建新的或检索旧的 cookie 值。

# 登录示例和注销

在学习会话和 cookies 时，您可以做的一个更简单的练习是一个简单的登录和注销系统。

让我们来看看一些代码:

(上面的例子需要对 PHP 有基本的了解，并且能够使用 MySql 在数据库中创建一个表)。

```
// Creation of the table using MySqlCREATE TABLE `users` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `username` varchar(255) NOT NULL,
    `password` varchar(255) NOT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `username` (`username`)) // Pretend that a form has been created and its field is a username and password // Connection to the database — connection.php$connection = mysqli_connect(‘host’, ‘username’, ‘password’);if (!$connection){
    die(“Database Connection Failed” . mysqli_error($connection));
}$select_db = mysqli_select_db($connection, ‘test’);if (!$select_db){
    die(“Database Selection Failed” . mysqli_error($connection));
} // PHP logic for user login session_start(); require(‘connection.php’);if (isset($_POST[‘username’]) and isset($_POST[‘password’])){
     $username = $_POST[‘username’];
     $password = $_POST[‘password’]
     $query = “SELECT * FROM `users` WHERE username=’$username’ and password=’$password’”;
     $result = mysqli_query($connection, $query) or die(mysqli_error($connection));
    $count = mysqli_num_rows($result);
    if ($count == 1) {
        $_SESSION[‘username’] = $username;
    } else {
        $fmsg = “Invalid Login Credentials.”;
    }
}if (isset($_SESSION[‘username’])) {
    $username = $_SESSION[‘username’];
    echo “Hi “ . $username . “”;
} // Deletion of the current session on log-out and redirection to the login pagesession_start();session_destroy();header(‘Location: login.php’);
```

这是一个非常简单的登录和注销系统的例子，

在现实世界的应用程序中，必须准备好所有的 MySQL 语句。

它可以防止 MySQL 注入，如果表单可以用一点 CSS 样式就更好了。

根据经验法则，

你需要将每个用户都视为潜在的威胁，[MySQL 中的每个查询都必须被准备、绑定和执行](https://dev.mysql.com/doc/refman/8.0/en/sql-syntax-prepared-statements.html)

# 面向对象编程

你现在知道了 PHP 的基本概念。

**学习语法后，你将能够使用过程化编程风格创建一个完整的项目。**

但是，如果你还在阅读，这意味着你想要更多。

所以…

欢迎来到编程的第二级！

不久前，我整理了一系列文章，非常详细地定义了什么是[面向对象编程(OOP)](http://the%20complete%20guide%20to%20oop/) 。

由于这个原因，

下面我会用一个更可操作的方式来解释。

使用实际的代码示例、类的创建、多态的实际使用、继承等。

在学习一门新的编程语言时，你可以做的一个简单的项目是一个简单的任务列表，

这将非常简单，同时，它将涵盖你需要学习的所有概念。

让我们使用 PHP 中的 OOP 来创建我们的个人待办事项列表

# 创建一个类

面向对象的核心概念是对象，

对象基于[类](https://www.php.net/manual/en/book.classobj.php)。

在这个项目中，我们创建了一个待办事项列表。

什么是待办事项列表？

说白了，就是需要完成的职责清单。

待办事项清单的核心组成部分是什么？

职责或任务。

任务是如何工作的？

**通常，一个任务有一个名称，一个描述，以及一个可以完成或尚未完成的状态，**

我们假设当我们创建一个新任务时，默认情况下它处于未完成状态

因此，让我们创建一个类来表示我们将在待办项目中使用的任务。

```
// Task.phpclass Task { public $name; public $description; public $completed = false; public function __construct (String $name, String $description) { $this->name = $name; $this->description = $description; }}
```

我们已经创建了一个具有 3 个属性的类。

默认情况下，`*$completed*`的状态为`false`。

当我们创建一个新任务时，将调用构造函数方法，并将名称和描述存储在对象中。

# 创建任务类的实例

下一阶段是创建实际的对象，传递构造魔法方法所需的 2 个属性。

```
$code = new Task(‘Learn OOP’, ‘Learn the basics of Object-Oriented Programming);$rest = new Task(‘Sleep’, ‘Healthy minds need to rest, take a 5 minutes nap’);$drink = new Task(‘Eat&Drink’, ‘Where is my coffee?’);
```

这些代码行正在创建新的对象，这些对象就是任务。

它们的名称是包含在第一个参数中的字符串。

描述是第二个参数中包含的其他字符串。

当 PHP 看到新的关键字时，它将 false 值赋给刚刚创建的任务。

# 读取不同任务的对象

现在我们的项目中有几个任务，我们可以检索它们的数据。

正如您所看到的，尽管它们都属于同一个类任务，但是它们的数据内容对于每个元素都是不同的。

这就是 OOP 的超能力之一。

```
echo $code->name; // ‘Learn OOP’echo $code->description; // ‘Learn the basics of Object-Oriented Programmingecho $code->completed; // false echo $rest>name; // ‘Sleep’echo $rest>description; // ‘Healthy minds need to rest, take a 5 minutes nap’echo $rest>completed; // false echo $drink>name; // ‘Eat&Drink’echo $drink>description; // ‘Where is my coffee?’echo $drink>completed; // false
```

# 继承，不同类型的任务

正如你所想象的，可以有不同类型的任务。

它们可以是你需要在家做的家务，比如“洗衣服”或“洗碗”。

其他的是更重要的工作职责，比如“给客户打电话”。

这两种类型具有相同的结构，我们说它们继承了主类任务的结构。

为了说明这一点，我们使用关键字 extends

```
// Chore.phpclass Chore extends Task {
    public $name;
    public $description;
    public $completed = false; public function __construct (String $name, String $description)
    {
         $this->name = $name;
         $this->description = $description;
    }
}// Duty.phpclass Duty extends Task {
    public $name;public $description;
    public $completed = false; public function __construct (String $name, String $description)
    {
        $this->name = $name;
        $this->description = $description;
    }
}$chore = new Chore(‘Cook, ‘Make dinner’);
$duty = new Duty(‘Coffee, ‘Make a cappuccino’);
```

面向对象的封装概念

封装是面向对象编程(OOP)的另一个基本概念。

**它描述了捆绑数据和方法的想法，这些数据和方法在代码中作为一个单元工作，在我们的例子中是一个类。**

封装与另一个称为“信息隐藏”的概念一起工作，

这个机制非常简单。

首先，您有一个在对象外部不可用的属性。

为了获得对它的访问(写或读),你用一个公共方法连接它并隐藏它的特定信息。

由此开始了使用 setters 和 getters 方法的实践。

从名称可以清楚地看出，getter 方法检索属性，setter 方法更新属性。

您将决定一个属性是否可以被读取和/或更改，或者它是否根本不可见。

让我们改变我们的代码，让一切更清楚。

```
// Task.phpclass Task {
    private $name; … public function getName()
    {
        return $this->name;
    } public function setName($name)
    {
        $this->name = $name;
    }}
```

现在$name 变量是私有的，这意味着它不能被直接访问，因此它只能在这个类中可见。

但是可以通过创建的方法进行更新和检索，

关键字“this”是指包含当前正在执行的代码的对象。

它指定所引用的标识符是包含对象的成员。

# 多态性

OOP 的另一个原则是多态性，

**不要让这个复杂的单词吓到你，因为编程中的大多数概念名字比实际代码更糟糕。**

简单来说，它只意味着“许多形式”，

当我们使用多态性时，我们利用了自适应的好处，事实上，代码根据给定的数据改变其行为。

通常情况下，

这个原则有两种不同的使用方式，抽象类或者接口。

因为到目前为止我们还没有使用它们，所以让我们来看看接口。

```
// TaskCompletedInterface.phpinterface responsibility
{
    public function complete(Task $id);
} // Chore.phpclass Chore implements Responsibility
{
    public function complete(Task $id)
    {
        return $this->completed = 1;
    }} // Duty.php
class Duty implements Responsibility
{
    public function complete(Task $id)
    {
         SendEmailToBoss();
         UpdateAgileSpring();
         return $this->completed = 1;
    }
}
```

正如你在上面所看到的，多态性只不过是提供动作的概念。

使用相同的参考(本例中的方法)提供不同的结果。

面对的杂务很容易设置为 1，而一旦任务完成，脚本需要通知老板更新 spring 并返回值。

如果这看起来仍然太复杂，这里是这个概念的视频格式。

# 方法和属性的可见性

在这些例子中，我相信你已经注意到了几次关键词，比如 public、private 和 protected。

这些关键字显示了一个类元素的可见性，它们被用在属性和方法上。

它们其实很好理解，按顺序放开:

*   **Public** —是三者中安全性较低但最容易管理的，当一个元素是公共的时，它对所有其他类和元素都是可见的。
*   **受保护的**——这里我们稍微严格一点。类指示保护的元素可以在类的任何地方看到和编辑。也在与主类相关的其他类中。
*   **Private** —我相信你从关键字本身就明白了，私有元素在类之外是看不到的。这是用于支付系统和其他功能，更好地保持在控制之下。

# 神奇的方法

魔术方法是特殊的方法，以符号 __ 为前缀，调用时可以执行特殊的功能。

有几个，在下面的文章中，我已经描述了所有这些。

[OOP 中的魔法方法:权威指南(PHP)](http://anastasionico.uk/blog/php-magic-methods)

如果你能定义一些未来可能发生的情景或事件，当它们发生时，你的…

[anastasionico.uk](http://anastasionico.uk/blog/php-magic-methods)

# 结论

那是巨大的。

我希望在这篇文章和系列文章**的[上一篇](http://anastasionico.uk/blog/learn-php)之间，你现在已经完全理解了用 PHP 开发一个项目意味着什么。**

尽管岁月流逝，

PHP 仍然是世界上主要的编程语言之一。

有很多工作和机会可以成就一番事业。

更不用说是在 web 上部署应用程序时最容易使用的语言之一。

如果你来了这么远，你喜欢这个内容，有一个即将到来的只是关注我的帐户

*原载于*[*http://anastasionico . uk*](http://anastasionico.uk/blog/php-basics)