<html>
<head>
<title>Learn to Build Production-Grade Microservices with gRPC and Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习使用gRPC和Go构建生产级微服务</h1>
<blockquote>原文：<a href="https://medium.com/codex/learn-to-build-production-grade-microservices-with-grpc-and-go-b665243a59a8?source=collection_archive---------0-----------------------#2022-11-18">https://medium.com/codex/learn-to-build-production-grade-microservices-with-grpc-and-go-b665243a59a8?source=collection_archive---------0-----------------------#2022-11-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="bf97" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">新书</h2><div class=""/><div class=""><h2 id="b178" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated"><em class="jg">节选自侯赛因·巴贝尔</em>的《Go   <em class="jg">中的</em> <a class="ae jh" href="https://www.manning.com/books/grpc-microservices-in-go?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=book_babal_grpc_6_29_22" rel="noopener ugc nofollow" target="_blank"> <em class="jg"> gRPC微服务》</em></a></h2></div><p id="7112" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">本节选涵盖:</em></p><p id="9e28" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">Go gRPC微服务简介</em></p><p id="fe49" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">比较gRPC和REST </em></p><p id="19b6" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">了解何时使用gRPC </em></p><p id="a792" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">通过生产级用例更好地理解gRPC微服务</em></p><p id="dc22" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">如果你有Go的基础知识，想用gRPC框架构建生产级的微服务，就去读吧。</em></p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="0f9f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">通过在<a class="ae jh" href="https://www.manning.com/books/grpc-microservices-in-go?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=book_babal_grpc_6_29_22" rel="noopener ugc nofollow" target="_blank">manning.com</a>的结账处将<strong class="jk hs"> fccbabal </strong>输入折扣代码框，在Go  中享受<a class="ae jh" href="https://www.manning.com/books/grpc-microservices-in-go?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=book_babal_grpc_6_29_22" rel="noopener ugc nofollow" target="_blank"> <em class="ke"> gRPC微服务七五折优惠。</em></a></p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="fb50" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">良好的架构设计和适当的技术选择通过消除重复性工作和为软件开发和维护提供最佳工具包，对构建高质量的产品大有帮助。Go语言是构建像Kubernetes中的微服务这样的大规模高性能云原生分布式应用程序的良好候选语言。具有gRPC通信的微服务已经使许多公司能够基于他们的业务能力用小型服务实现他们的产品，并让这些服务彼此之间以及与公共世界顺畅地通信。在Go的帮助下，这些服务的分发变得更加容易，这是因为它的快速编译、生成可执行二进制文件的能力以及其他许多原因，我们将在本书中通过真实的例子详细了解这些原因。</p><p id="c006" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">gRPC是一个开源的远程过程调用框架，最初由Google在2015年开发，基本上可以帮助您连接内置支持负载平衡、跟踪、容错和安全的服务。该框架的主要优势在于能够为多种语言生成服务器和客户端存根(客户端的一个对象，实现与服务相同的方法),您可以在您的使用者项目中使用它们来调用远程服务方法，并在您的服务器项目中定义这些服务方法背后的业务逻辑。</p><p id="0fe3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">微服务架构是面向服务架构的另一种形式，它将应用程序定义为松散耦合的细粒度服务，可以独立实现、部署和扩展。</p><p id="3867" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">本书的主要目标是提供gRPC微服务的生产级最佳实践，通过这种方式，到本书结束时，您将有自信自己实现整个系统。</p><h2 id="f99f" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">gRPC微服务的优势</strong></h2><p id="f875" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">在一个典型的单块应用程序中，调用不同的业务操作，比如从结帐服务中调用支付服务，意味着在单独的模块中访问一个类方法，这非常容易。如果使用微服务，这样的通话会转换成一种网络通信。它可以是通过TCP、HTTP或某种事件队列的调用，以便在服务之间交换数据。处理网络调用比调用另一个类方法更具挑战性，这可以通过简单的错误处理机制(如try catch块)来处理。即使Monoliths在开始时很容易使用，您也可能出于几个原因需要分解它们，包括缓慢的部署和低效的资源利用，这显然会影响特性开发和产品维护。这并不意味着单片是坏的，微服务是好的；相反，微服务像服务间通信一样带来了自己的挑战。在gRPC的帮助下，微服务中的大多数挑战，如处理网络故障、将TLS(传输层安全性)应用于服务通信，都可以消除。通过使用gRPC中的内置功能，您可以通过使用Go微服务来提高产品的可靠性和整个团队的生产率。</p><h2 id="a6e7" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">表演</strong></h2><p id="55a9" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">gRPC比其他协议(如REST with JSON或XML communication)提供更好的性能和安全性，因为它使用协议缓冲区和TLS上的HTTP/2。协议缓冲区，也称为Protobuf，是一种语言和平台中立的机制，用于序列化结构化数据。这种机制使gRPC能够在服务器端和客户端快速地将消息序列化为小而紧凑的消息。同样，HTTP/2支持服务器端推送、多路复用和报头压缩。</p><h2 id="f642" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">代码生成&amp;互通</strong></h2><p id="fe00" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">假设您有结帐服务和付款服务，客户可以结帐一个篮子，并调用付款服务来支付篮子中所述的产品。要访问支付服务，您需要在某个地方拥有请求和响应模型，比如共享库，以便您可以轻松地访问它们。重用共享的请求和响应模型在微服务中似乎很方便，但实际上这并不是一个好的实践，尤其是如果您为每个微服务使用不同的语言。在Checkout服务中复制模型是更好的选择，这通常是创建另一个数据类来构建请求对象和反序列化响应对象。这一切都是为了防止错误的抽象，你可能已经听说过“一点点重复远比错误的抽象便宜”(<a class="ae jh" href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction" rel="noopener ugc nofollow" target="_blank">https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction</a>)这句话。有一种更简单的方法，那就是选择gRPC来定义您的消息并生成客户端存根，这样您就可以注入这种依赖，并在您喜欢的语言中直接使用它。</p><p id="3830" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">gRPC工具和库兼容多种平台和语言，包括Go、Java、Python、Ruby、Javascript、C#等。拥有Protobuf二进制线路格式、像在网络中一样在线路上传输的数据格式以及为几乎所有平台精心设计的代码生成，使开发人员能够在保持跨平台支持的同时构建高性能的应用程序。</p><p id="4007" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">gRPC正变得越来越流行(【https://star-history.com/#grpc/grpc】T2&amp;日期)，因为你可以很容易地生成客户端存根来提供不同语言服务的SDK。你唯一需要决定的是你需要有什么样的业务对象。一旦决定了结帐模型需要哪些字段，就可以引入各自的请求和响应模型。请记住，那些对象只是定义，它被称为IDL(接口定义语言)，独立于任何语言规范。在定义了消息规范之后，您可以生成特定于语言的实现，以便任何消费者都可以依赖于该来源。这也意味着服务器端的开发语言在客户端可以不同，因为服务器端的方法可以在客户端生成为gRPC支持的特定语言的存根。</p><p id="24ab" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">除了业务对象，您还可以定义服务方法，并以同样的方式生成实际的实现。在消费者端初始化gRPC客户端之后，可以调用这些服务功能，同样，这个客户端是开箱即用的。</p><h2 id="67c9" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">容错</strong></h2><p id="8d5f" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">容错是指尽管系统出现故障，系统仍能继续运行的能力。幂等运算是一种即使调用多次也不会产生额外效果的运算。幂等性是成功容错环境的关键，因为您需要确保，一旦在失败或没有预期状态的情况下使用相同的参数重试操作，它不应该改变实际资源的内容。例如，如果网络响应失败，我们可能希望重试用户删除操作。如果操作返回相同的结果，即使你调用它不止一次，我们说这个操作是幂等的。</p><p id="ab15" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果一个操作不适合幂等用例，那么您需要在响应消息中提供适当的验证错误，帮助您知道何时停止重试操作。一旦保证了这种幂等性或正确的验证，它就只是gRPC端重试策略的一个定义。容错还关注其他主题，如速率限制、断路器和故障注入。</p><h2 id="13c3" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">安全</strong></h2><p id="b017" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">在大多数系统中，您可能需要设置一个安全层来保护您的产品免受未验证来源的攻击。gRPC鼓励HTTP/2 over SSL/TLS对客户端和服务器之间交换的数据进行身份验证和加密。更具体地说，您可以通过使用SSL/TLS、ALTS(应用层传输安全)或基于令牌的身份验证系统来轻松设置身份验证系统。</p><h2 id="9651" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">流媒体</strong></h2><p id="fffa" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">有时，您可能需要将响应数据分成几个块，以分页的方式提供给用户，以减少带宽并快速返回给用户。而且，如果他们只对某些页面感兴趣，那么一次返回所有数据是没有意义的。在gRPC中，除了分页之外，您还可以将这些数据流式传输给消费者，而不是强迫用户进行分页来迭代获取数据。流式传输不一定在服务器端，也可以在客户端，甚至同时在两端，这就是所谓的双向流式传输。在一个典型的流用例中，您打开一次连接，数据将通过这个打开的连接进行流传输。当我们在本书中实现一个完整的应用时，您将看到不同种类的流用例。</p><h2 id="276e" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">REST vs gRPC</strong></h2><p id="3f16" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">REST(表述性状态转移)是微服务广泛采用的协议，但如果您有严格的要求，如低延迟、多语言系统支持等，您可能会开始考虑使用gRPC。REST基于HTTP 1.0协议，该协议允许您在客户机和服务器之间交换JSON或XML格式的消息。另一方面，gRPC是基于RPC(远程过程调用)的体系结构，使用协议缓冲区二进制格式通过HTTP 2.0协议交换数据。这并不意味着REST与HTTP 2.0不兼容，您可以使用自己的自定义实现来设置基于该协议的REST服务，这是gRPC中的一个内置特性。</p><p id="5d5f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">由于gRPC有内置的HTTP 2.0支持，您还可以利用客户机和服务器之间的单向和双向流，从而实现非常快速的通信。使用REST服务的默认设置，多个客户机服务器通信可能会对您的整体系统性能带来延迟。</p><p id="6085" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">也有REST比gRPC更有益的情况，例如REST协议在各种浏览器中都得到支持。由于gRPC支持非常有限，您可能需要使用某种代理层来完成HTTP 1.0和HTTP 2.0之间的转换。</p><p id="2d1e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">gRPC有很多优点，比如能够定义消息来方便地在服务之间交换数据。然而，就可读性而言，REST中JSON和XML的使用有一些优势，比如，如果对更改后的字段没有明确的业务验证，就可以自由地进行更改，而您需要遵循gRPC中的一些规则来进行更改。我们将在第五章详细解释这一点。</p><p id="48c0" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">gRPC有内置的客户端和服务器存根生成机制，您需要使用REST中的框架(如Swagger Codegen)来生成客户端模型。这一点变得至关重要，尤其是当您拥有多种服务并同时为客户维护多个SDK时。</p><p id="d879" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在我们已经了解了REST和gRPC之间的区别，让我们看看什么时候使用gRPC是有意义的。"</p><h2 id="46a2" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">何时使用gRPC </strong></h2><p id="3943" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">如果您对浏览器支持有严格的要求，那么您需要考虑使用REST，因为您将最终为HTTP/2和HTTP/1之间的转换设置另一个层。但是，您仍然可以使用gRPC进行服务间通信，并将gRPC负载平衡器(<a class="ae jh" href="https://aws.amazon.com/blogs/aws/new-application-load-balancer-support-for-end-to-end-http-2-and-grpc/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/blogs/AWS/new-application-load-balancer-support-for-end-to-end-http-2-and-gRPC/</a>)附加到该服务池，以便将API公开，从而具有REST兼容性。还有其他选择，比如Twirp(【https://github.com/twitchtv/twirp】)，一个基于Protobuf的RPC框架。Twirp允许您为gRPC服务启用REST层，您可以访问您的端点，如下例所示，发送一个带有JSON有效负载的POST请求。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="8e28" class="km kn hi lq b fi lu lv l lw lx">curl -X "POST" \<br/>       - H "Content-Type: application/json" \<br/>       -d '{"name": "dev-cluster"}' \    <a class="ae jh" href="http://localhost:8080/twirp/github.com/huseyinbabal/microservices-proto/cluster/Create" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/twirp/github.com/huseyinbabal/microservices-proto/cluster/Create</a></span></pre><p id="50c5" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">多语言开发环境是gRPC集成的最佳场所，因为能够在Checkout服务中使用Python客户端来访问使用Java编写的支付服务，很容易生成客户端存根。您可以将相同的策略应用到面向公共消费者的SDK产品中。此外，每当您更改服务定义时，客户端的测试就会开始失败，这对于您的微服务来说是一个很好的验证机制。</p><p id="7d8b" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">gRPC可能不适合非常简单的应用程序，比如只包含1-2个服务的启动项目，因为维护包含服务定义的原型文件并不容易，尤其是对于没有经验的用户。</p><p id="5696" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在内部服务之间使用gRPC通信是可以的，但是向客户公开gRPC接口可能并不理想，尤其是在没有用于gRPC服务通信的客户端SDK的情况下。如果您喜欢公开gRPC而不为您的消费者维护SDK，那么最好与他们共享您的服务定义，或者提供一个关于如何对您的gRPC服务进行gRPC调用的清晰解释。</p><p id="1ec9" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这本书包含了大量的解释、代码示例、提示和技巧，并辅以现实生活中的例子，对以下角色非常有用。</p><ul class=""><li id="a3da" class="ly lz hi jk b jl jm jo jp jr ma jv mb jz mc kd md me mf mg bi translated"><em class="ke">不了解Go或微服务的开发者</em>:可以利用先从关于Go、微服务、gRPC的入门章节开始，学习gRPC Go微服务的量产级技术。对于已经了解微服务架构的读者来说，可以用Go中描述的资源更新他们的知识，这些资源可以很容易地适应他们当前使用的任何其他语言。</li><li id="2be8" class="ly lz hi jk b jl mh jo mi jr mj jv mk jz ml kd md me mf mg bi translated"><em class="ke">工程经理:</em>通过将这里描述的最佳实践添加到他们的行动手册中，可以提高他们团队中开发人员的生产力。应用实践将在整个产品上引入良好的可见性，这将有助于新员工容易地加入团队。</li><li id="2312" class="ly lz hi jk b jl mh jo mi jr mj jv mk jz ml kd md me mf mg bi translated"><em class="ke">软件架构师:有很多方便的例子和架构设计</em>，它们是他们新产品或新特性决策的潜在参考。</li></ul><p id="7625" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">本书中会有以下格式的生产级示例。</p><ul class=""><li id="f945" class="ly lz hi jk b jl jm jo jp jr ma jv mb jz mc kd md me mf mg bi translated">本书结尾完成的项目</li><li id="69f8" class="ly lz hi jk b jl mh jo mi jr mj jv mk jz ml kd md me mf mg bi translated">代码示例可以更好地理解特定主题及其工作原理</li><li id="c7b3" class="ly lz hi jk b jl mh jo mi jr mj jv mk jz ml kd md me mf mg bi translated">自动化示例，特别是使用Github操作来减少重复操作</li><li id="ff64" class="ly lz hi jk b jl mh jo mi jr mj jv mk jz ml kd md me mf mg bi translated">为部署准备工件</li><li id="3a62" class="ly lz hi jk b jl mh jo mi jr mj jv mk jz ml kd md me mf mg bi translated">安全最佳实践</li></ul><h2 id="bb9e" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">生产级用例</strong></h2><p id="746d" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">如图1所示，我们将在本书中尝试使用Go gRPC微服务创建一个电子商务产品，该产品在一个适当的CI/CD管道中自动运行，并存在于Kubernetes环境中。在本书中，我们将访问图表的关键部分，以了解它们对于典型的开发生命周期有多重要，gRPC如何使这些部分更容易处理，以及在哪里使用哪些技术。</p><figure class="ll lm ln lo fd mn er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mm"><img src="../Images/5730cf85658589e806fbc3622331d062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KxeVazXJvuT4doWk.png"/></div></div><figcaption class="mu mv et er es mw mx bd b be z dx translated">图一。基于Kubernetes的Go微服务构建的电子商务产品的架构图，包括CI/CD流和可观察性</figcaption></figure><h2 id="1144" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">总结</strong></h2><ul class=""><li id="bea7" class="ly lz hi jk b jl lg jo lh jr my jv mz jz na kd md me mf mg bi translated">gRPC在服务间通信中表现良好，因为它对数据使用二进制序列化，并通过HTTP/2协议传输数据。</li><li id="1773" class="ly lz hi jk b jl mh jo mi jr mj jv mk jz ml kd md me mf mg bi translated">gRPC允许您进行客户端流、服务器流和双向流，允许您并行发送多个请求或接收多个响应。</li><li id="5817" class="ly lz hi jk b jl mh jo mi jr mj jv mk jz ml kd md me mf mg bi translated">由于自动代码生成，gRPC微服务中稳定的客户端-服务器交互非常容易实现。</li><li id="8d09" class="ly lz hi jk b jl mh jo mi jr mj jv mk jz ml kd md me mf mg bi translated">REST非常受欢迎，尤其是因为它有更广泛的浏览器支持，但是你仍然可以使用gRPC web代理(例如<a class="ae jh" href="https://github.com/grpc/grpc-web" rel="noopener ugc nofollow" target="_blank">https://github.com/grpc/grpc-web</a>)进行REST到gRPC的转换。</li><li id="43cf" class="ly lz hi jk b jl mh jo mi jr mj jv mk jz ml kd md me mf mg bi translated">Go是云原生应用程序的最佳语言之一，比如kubernetes中的微服务，因为它具有高度的可移植性。</li><li id="4868" class="ly lz hi jk b jl mh jo mi jr mj jv mk jz ml kd md me mf mg bi translated">在gRPC中使用HTTP/2 over SSL/TLS端到端加密连接消除了微服务的大部分安全顾虑</li><li id="7a7a" class="ly lz hi jk b jl mh jo mi jr mj jv mk jz ml kd md me mf mg bi translated">到本书结束时，你会对这一切了如指掌！</li></ul><p id="e42c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">更多信息，请点击查看本书<a class="ae jh" href="https://www.manning.com/books/grpc-microservices-in-go?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=book_babal_grpc_6_29_22" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>