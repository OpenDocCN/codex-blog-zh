<html>
<head>
<title>Running open-source software on Windows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Windows上运行开源软件</h1>
<blockquote>原文：<a href="https://medium.com/codex/running-open-source-software-on-windows-50dd1231cae9?source=collection_archive---------10-----------------------#2021-07-28">https://medium.com/codex/running-open-source-software-on-windows-50dd1231cae9?source=collection_archive---------10-----------------------#2021-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="33a5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">将面向Linux的源代码移植到Windows的7个技巧</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ebb3d6236db37554e8d98c9eae202adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jo8uM2TWGmrIrHnJfg4OEg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在Linux上开发的开源软件可以移植到Windows上(来自<a class="ae jo" href="https://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<em class="jn">图片</em></figcaption></figure><p id="8742" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我是一名化学系的学生，但是我第一次尝试编程是在我决定进入计算化学的时候。从我记事起，我就一直在使用我的旧Windows笔记本电脑。所以很自然地，我想在我的笔记本电脑上为我的项目做测试和准备工作。</p><p id="1e32" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这就是我遇到很多问题的地方。我所在领域的大多数代码都是用Linux编写的开源代码。在Windows上运行这些代码几乎总是很痛苦(要么程序无法编译，要么没有关于如何编译的说明)。没有程序需要的固有特性是Windows不能提供的。只是因为它们是在Linux上编写和测试的，所以只有Linux的函数或系统调用会渗透到源代码中。有些代码确实为Windows提供了预编译的二进制文件(例如NAMD)，但它们很少。</p><p id="7302" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">Cygwin/WSL是一个选项，但是它们很慢，特别是对于磁盘I/O。在多次尝试使用Cygwin之后，我放弃了，一头扎进了源代码。到目前为止，我已经成功地在Windows上使用原生编译器(Visual C++和Intel)修改并构建了两个软件(<a class="ae jo" href="https://www.msg.chem.iastate.edu/GAMESS/" rel="noopener ugc nofollow" target="_blank">games</a>和<a class="ae jo" href="https://mrcc.hu/" rel="noopener ugc nofollow" target="_blank"> MRCC </a>)。</p><h2 id="c086" class="kl km hi bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">为什么在Windows上构建很难？</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lg"><img src="../Images/674b8bae7ac900b24a907bed586fc0f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*szI7-lJFF0Rnd41F-6LEyA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">试图在Windows上构建一个开源软件！(图片来自<a class="ae jo" href="https://pixabay.com/vectors/laptop-error-web-warning-text-5906264/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>)</figcaption></figure><p id="af04" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在Windows上编译开源科学软件并不是什么新鲜事。问题部分在于微软本身，部分在于编写这些开源软件的开发者。微软没有让编译环境在Windows上运行变得容易。MS Visual Studio应该是主要的开发环境，但它只提供C/C++编译器；如果你需要Fortran呢？你必须要么尝试安装Intel Visual Fortran，要么安装LLVM (flang)或GNU (gfortran)等开源软件，所有这些软件的安装都很麻烦。使用命令行(cmd.exe)也很困难，因为参数解析不一致。在Linux上，shell根据一组固定的规则解析参数，然后将分离的参数提供给名为。在Windows上，命令提示符只是将整个命令发送给程序，并由单个程序来处理参数。这意味着，例如，如果您用双引号将文本括起来，它可能被一个软件视为一个参数，而被另一个软件视为多个参数。所有这些都意味着有人需要浪费大量的时间在编码之前熟悉Windows的特性。Windows也没有默认的集成构建系统，像Linux一样，在Linux中构建软件有时就像在命令行上运行<code class="du lh li lj lk b">make install</code>一样简单。</p><p id="c6a8" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">另一方面，编写软件的开发人员也不是完全没有责任——他们使用Linux独有的特性，有时是故意的，这些特性在Windows上无法编译。这在大多数情况下是不必要的，因为我所遇到的开源代码都是命令行代码，不需要操作系统特有的特性；标准库提供的功能就足够了。许多开发人员甚至拒绝考虑Windows版本。对于“为什么它在Windows上不起作用？”这个问题的标准回答是就是“你为什么不装Linux？”。</p><p id="0594" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">尽管有这些问题，我相信许多开源软件可以在Windows上编译，只需很少的改动。这是因为标准C/C++和Fortran源代码可以在Windows和Linux上编译。正如我前面提到的，大多数时候，操作系统的低级功能(对于Linux: <code class="du lh li lj lk b">unistd.h</code>，对于Windows: <code class="du lh li lj lk b">windows.h</code>)是不必要的。</p><p id="aee4" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我不是在谈论专门为Linux移植软件。这要困难得多，而且我还不是一个优秀的程序员来给出这方面的建议！不，我只是在谈论通用开源代码，它主要是一个命令行应用程序，可能是在Linux上开发的。这些可以移植到Windows上本地运行。</p><h2 id="bf28" class="kl km hi bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">将源代码移植到Windows</h2><blockquote class="ll lm ln"><p id="5666" class="jp jq lo jr b js jt ij ju jv jw im jx lp jz ka kb lq kd ke kf lr kh ki kj kk hb bi translated">1)检查编译器中的差异</p></blockquote><p id="e960" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">如果我理解正确的话，Linux系统的传统编译器是由GNU工具集提供的。所以C/C++的编译器是gcc和g++，Fortran的编译器是gfortran。这些编译器几乎总是保证在Linux上可用(或者容易安装)，所以大多数开发人员编写支持GNU编译器的代码。还可以在Linux上安装LLVM和Intel编译器。</p><p id="f160" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">对于Windows，本机C/C++编译器是微软自己的Visual C/C++编译器。它可以作为Visual Studio的一部分安装。(听说可以单独安装但不确定)。但是微软没有提供Fortran编译器。英特尔提供了Visual Fortran(及其自己的C/C++编译器),可以为Windows生成本机可执行文件。(也有GNU和LLVM编译器的端口可用。)</p><p id="dcc6" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这些编译器都有自己的特点。我注意到的一些趋势:</p><ol class=""><li id="1b5f" class="ls lt hi jr b js jt jv jw jy lu kc lv kg lw kk lx ly lz ma bi translated">编译器命令行选项都是不同的。参数格式也不同。Linux编译器将作为<code class="du lh li lj lk b">compiler -argument1 option1 -argument2 option2</code>在命令行中运行。对于Visual C++和英特尔编译器，默认样式是<code class="du lh li lj lk b">compiler /argument1:option1 /argument2:option2</code>。(然而，写作<code class="du lh li lj lk b">compiler -argument1:option1 -argument2:option2</code>有时是允许的。)</li><li id="ed53" class="ls lt hi jr b js mb jv mc jy md kc me kg mf kk lx ly lz ma bi translated">在Linux上，Fortran编译器默认运行预处理器，但对于Windows，需要通过参数<code class="du lh li lj lk b">/fpp</code>显式请求。</li><li id="6cb0" class="ls lt hi jr b js mb jv mc jy md kc me kg mf kk lx ly lz ma bi translated">在Linux上，大多数Fortran编译器按照GNU惯例，以小写形式输出符号，并在末尾加上下划线。因此，子程序名<code class="du lh li lj lk b">mysubrt</code>将被导出为<code class="du lh li lj lk b">mysubrt_</code>。在Windows上，英特尔Fortran输出不带下划线的大写符号，即<code class="du lh li lj lk b">mysubrt</code>将变成<code class="du lh li lj lk b">MYSUBRT</code>。只有当您试图将C/C++与Fortran接口时，这才是一个问题。由于这个特殊的原因，许多这样做的代码无法在Windows上编译。(然而，gfortran的Windows端口遵循GNU惯例)</li></ol><blockquote class="ll lm ln"><p id="fa07" class="jp jq lo jr b js jt ij ju jv jw im jx lp jz ka kb lq kd ke kf lr kh ki kj kk hb bi translated">Windows中的信号处理受到限制</p></blockquote><p id="0a27" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">C和C++代码具有拦截“信号”的功能，这些信号是从操作系统到软件的消息，表明发生了意外情况(例如，按下了Ctrl+C或Ctr+Break，或者发生了被零除的情况，或者程序试图访问它无法访问的内存位置等)。).信号处理的目的是让程序对如何响应异常和错误有所控制。</p><p id="2f3d" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">信号处理是通过安装特殊函数作为处理程序来完成的。当程序接收到信号时，这些函数将被调用。例如，如果我为<code class="du lh li lj lk b">SIGINT</code>安装一个处理程序，那么当Ctrl+C被按下时，程序将调用处理函数，而不是关闭程序，这是默认的动作。</p><p id="84e6" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">C标准库定义了6种信号— <code class="du lh li lj lk b">SIGABRT (abnormal termination), SIGFPE (floating point error), SIGILL (illegal instruction), SIGINT (ctrl+c signal), SIGSEGV (illegal storage access) and SIGTERM (termination request)</code>。Linux和Windows都支持这些。Windows还额外支持<code class="du lh li lj lk b">SIGBREAK (Ctrl+Break)</code>。</p><p id="3634" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">然而，在Linux上，有一大堆其他信号可以被代码拦截。如果开放源代码包括对这些信号的处理，那么它们就不能在Windows上编译。解决方案是删除对这些信号的处理(因为它们永远不会被Windows操作系统发送)，并拦截Windows中可能需要的其他信号(从上面的列表中)。幸运的是，学术开源程序很少需要标准信号以外的任何东西。</p><p id="44ec" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">同样，在Linux上，信号处理程序是由<code class="du lh li lj lk b">struct sigaction</code>设置的。处理信号的功能由<code class="du lh li lj lk b">sigaction.sa_handler</code>设定。在Windows上，只有基本的C <code class="du lh li lj lk b">signal()</code>函数存在。</p><p id="4e26" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">例如，下面的Linux代码将<code class="du lh li lj lk b">handle_sig</code>设置为SIGINT的信号处理程序:</p><pre class="iy iz ja jb fd mg lk mh mi aw mj bi"><span id="2464" class="kl km hi lk b fi mk ml l mm mn">void handle_sig(int signal) {<br/>...<br/>}</span><span id="5540" class="kl km hi lk b fi mo ml l mm mn">struct sigaction act; //act is instance of the structure sigaction</span><span id="1743" class="kl km hi lk b fi mo ml l mm mn">act.sa_handler = &amp;handle_sig; // handle_sig is the handler in act</span><span id="fd6c" class="kl km hi lk b fi mo ml l mm mn">sigaction(SIGINT, &amp;act, NULL);</span><span id="ce40" class="kl km hi lk b fi mo ml l mm mn">/* Here, structure act is installed as the sigaction structure for SIGINT, which means handle_sig becomes the signal handler*/</span></pre><p id="864a" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在Windows上，它会变成:</p><pre class="iy iz ja jb fd mg lk mh mi aw mj bi"><span id="3d82" class="kl km hi lk b fi mk ml l mm mn">void handle_sing(int signal) {<br/>...<br/>}</span><span id="cb5f" class="kl km hi lk b fi mo ml l mm mn">signal(SIGINT,handle_sig);</span></pre><p id="85d8" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">对Windows来说就是这样:简单明了。</p><blockquote class="ll lm ln"><p id="696d" class="jp jq lo jr b js jt ij ju jv jw im jx lp jz ka kb lq kd ke kf lr kh ki kj kk hb bi translated">3)小心丢失的库</p></blockquote><p id="9534" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在Linux上，大多数库在安装时会将它们的路径放入<code class="du lh li lj lk b">LD_LIBRARY_PATH</code>或其他环境变量中。当依赖于该库的源代码被编译时，它会在<code class="du lh li lj lk b">LD_LIBRARY_PATH</code>中寻找该库或者该库特定的env。可变。</p><p id="3481" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">然而，在Windows中情况并非如此。通常，库是作为归档中的<code class="du lh li lj lk b">.lib</code>和<code class="du lh li lj lk b">.dll</code>文件提供的。通常没有安装过程，所以不修改环境变量；它只是提取包含文件的归档文件。</p><p id="07d3" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在这种情况下，编译器(实际上是链接器)将无法找到这些库，编译将会失败。对于Visual C++或英特尔编译器来说，<code class="du lh li lj lk b">LNK2019 Unresolved external symbol</code>通常是由此引起的。</p><p id="23ca" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">解决方法是将编译器(或链接器)指向库文件(<code class="du lh li lj lk b">.lib</code>)。大多数开源软件在命令行上编译。对于Visual C++或英特尔编译器，库文件的路径必须添加到环境变量<code class="du lh li lj lk b">LIB</code>或提供给链接器的参数<code class="du lh li lj lk b">/libpath: </code>。在链接过程中，还必须包括库文件的名称。</p><p id="5b5c" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这相当复杂，您需要使用的确切命令取决于您需要的库和您使用的构建系统。</p><p id="3333" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">例如，如果我正在编译一个名为<code class="du lh li lj lk b">calculate.f90</code>的Fortran程序，并且我正在使用一个单独的库<code class="du lh li lj lk b">mylibrary.lib</code>提供的子程序<code class="du lh li lj lk b">mysub</code>，如下所示:</p><pre class="iy iz ja jb fd mg lk mh mi aw mj bi"><span id="e0b3" class="kl km hi lk b fi mk ml l mm mn">program calculate</span><span id="13e4" class="kl km hi lk b fi mo ml l mm mn">integer :: i,j  !some variables</span><span id="4fe8" class="kl km hi lk b fi mo ml l mm mn">!some code here</span><span id="2409" class="kl km hi lk b fi mo ml l mm mn">call mysub(i,j) !external subroutine called</span><span id="48b9" class="kl km hi lk b fi mo ml l mm mn">!some more code here</span><span id="b43c" class="kl km hi lk b fi mo ml l mm mn">end program calculate</span></pre><p id="cb50" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">然后我必须在英特尔Fortran上像这样链接:</p><pre class="iy iz ja jb fd mg lk mh mi aw mj bi"><span id="496e" class="kl km hi lk b fi mk ml l mm mn">ifort calculate.f90 /link C:\path\to\mylibrary.lib</span></pre><p id="75b2" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">或者更简单地说:</p><pre class="iy iz ja jb fd mg lk mh mi aw mj bi"><span id="7285" class="kl km hi lk b fi mk ml l mm mn">ifort calculate.f90 C:\path\to\mylibrary.lib</span></pre><p id="2c4a" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在第一种情况下，库指向链接器，在第二种情况下，编译器将文件识别为库，并自动将其传递给链接器。</p><p id="32e9" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">没有这个库，链接器会抛出<code class="du lh li lj lk b">Unresolved external symbol</code>错误。</p><p id="3bfa" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">如果你用的是GNU编译器，他们不使用微软的<code class="du lh li lj lk b">link.exe</code>链接器，所以以上不适用。</p><blockquote class="ll lm ln"><p id="64b8" class="jp jq lo jr b js jt ij ju jv jw im jx lp jz ka kb lq kd ke kf lr kh ki kj kk hb bi translated">4)仅POSIX头文件</p></blockquote><p id="01a3" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这是您在移植C/C++代码时可能偶尔遇到的最后一个噩梦。Fortran不像C语言那样有头文件，所以这在那里不适用。这是移植Fortran代码更容易的原因之一。</p><p id="939e" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">C/C++中特定于操作系统的头文件公开了操作系统的核心功能，并允许非常低级的操作。不幸的是，这意味着它们不是真正可移植的，因为Windows和Linux内核做的事情不同。幸运的是，这种类型的功能很少需要，而且在Linux和Windows之间经常有几乎完美的对等物。</p><p id="7513" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">例如，在Linux中，头文件<code class="du lh li lj lk b">unistd.h</code>提供了函数<code class="du lh li lj lk b">usleep(time)</code>，它将调用该函数的进程线程暂停<code class="du lh li lj lk b">time</code>微秒。</p><pre class="iy iz ja jb fd mg lk mh mi aw mj bi"><span id="aaf8" class="kl km hi lk b fi mk ml l mm mn">#include &lt;stdio.h&gt;<br/>#include &lt;unistd.h&gt;</span><span id="6863" class="kl km hi lk b fi mo ml l mm mn">int main(){</span><span id="9042" class="kl km hi lk b fi mo ml l mm mn">// some code here</span><span id="5504" class="kl km hi lk b fi mo ml l mm mn">usleep(1000); // pauses the program for 1000 microseconds i.e. 1 ms</span><span id="7235" class="kl km hi lk b fi mo ml l mm mn">// after 1 ms, the code starts here again</span><span id="c3e0" class="kl km hi lk b fi mo ml l mm mn">}</span></pre><p id="e54d" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">如果您试图在Windows上编译它，编译器会给出一个错误，因为Windows上不存在<code class="du lh li lj lk b">unistd.h</code>头。</p><p id="249f" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">解决方案*是用Windows C头文件提供的一个函数来替换它。快速的谷歌搜索会告诉你，在Windows上，<code class="du lh li lj lk b">Sleep()</code>函数做了类似的工作，并且不需要任何标题。然而，<code class="du lh li lj lk b">Sleep(time)</code>暂停了<code class="du lh li lj lk b">time</code>毫秒。所以，你可以把它修改成这样:</p><pre class="iy iz ja jb fd mg lk mh mi aw mj bi"><span id="6d88" class="kl km hi lk b fi mk ml l mm mn">#include &lt;stdio.h&gt;</span><span id="ba43" class="kl km hi lk b fi mo ml l mm mn">int main(){</span><span id="dc69" class="kl km hi lk b fi mo ml l mm mn">// some code here</span><span id="f76b" class="kl km hi lk b fi mo ml l mm mn">Sleep(1); // pauses for 1 ms</span><span id="5cf8" class="kl km hi lk b fi mo ml l mm mn">// resumes after 1 ms</span><span id="73af" class="kl km hi lk b fi mo ml l mm mn">}</span></pre><p id="8d10" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">*尽管您可以通过逐个检查源代码来解决丢失的头，但使用<a class="ae jo" href="http://mingw-w64.org/doku.php" rel="noopener ugc nofollow" target="_blank"> MinGW </a>要容易得多。它基本上提供了从Linux函数到Windows函数的翻译，并将其作为头文件提供。MinGW编译的程序完全是原生的Windows程序，所以你避免了必须替换丢失的头文件的问题。</p><blockquote class="ll lm ln"><p id="d3a0" class="jp jq lo jr b js jt ij ju jv jw im jx lp jz ka kb lq kd ke kf lr kh ki kj kk hb bi translated">5)查看编译器错误/构建系统错误</p></blockquote><p id="5d60" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">大多数情况下，编译器错误非常能说明问题所在。由于您不是在编写新代码，而是在移植代码，所以导致错误的几乎总是缺失的库/缺失的目标文件(即<code class="du lh li lj lk b">Unresolved externals</code>)。</p><p id="a4ea" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">虽然在一些罕见的情况下，会出现宏名冲突。宏是一些由C或Fortran预处理器读取的指令，告诉它们如何在实际编译之前修改源文件。例如，如果你在Windows上编译，几乎所有的编译器都定义了宏<code class="du lh li lj lk b">_WIN32</code>。这使得程序员可以编写Windows特有的代码，这些代码只有在定义了<code class="du lh li lj lk b">_WIN32</code>时才会被编译。</p><pre class="iy iz ja jb fd mg lk mh mi aw mj bi"><span id="dfa4" class="kl km hi lk b fi mk ml l mm mn">#if defined _WIN32</span><span id="95d1" class="kl km hi lk b fi mo ml l mm mn">// Some C++ code for Windows</span><span id="486e" class="kl km hi lk b fi mo ml l mm mn">#else</span><span id="52cb" class="kl km hi lk b fi mo ml l mm mn">// C++ code for other systems</span><span id="5011" class="kl km hi lk b fi mo ml l mm mn">#endif</span></pre><p id="8d39" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">不管怎样，软件开发人员有时会使用他们自己的自定义宏，这些宏是通过命令行参数定义的。假设我在Linux上开发了一个开源软件，用了一个名为<code class="du lh li lj lk b">_WIN32</code>的宏，这个宏会关闭某一部分代码的编译。(这是编造的例子，没有人会这么做！)现在，在Linux上，<code class="du lh li lj lk b">_WIN32</code>没有定义，所以它被当作一个用户自定义的宏。当您试图在Windows上编译该源代码时，<code class="du lh li lj lk b">_WIN32</code>总是被定义，因此部分代码永远不会被编译。</p><p id="1d05" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这种类型的宏名称冲突很难检测。大多数时候，编译器甚至不会抱怨任何出错的地方，只会编译程序。那么当程序运行时，可能会有大量的错误。有时，如果用户定义的宏与系统预定义的宏同名，可能会在头文件中出现错误。</p><p id="188d" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">构建系统错误也有助于了解哪里出错了。</p><blockquote class="ll lm ln"><p id="0e17" class="jp jq lo jr b js jt ij ju jv jw im jx lp jz ka kb lq kd ke kf lr kh ki kj kk hb bi translated">6)注意shell调用</p></blockquote><p id="d21d" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">有时，程序员在源代码中使用shell命令，主要是为了执行文件系统操作。这在C/C++中由<code class="du lh li lj lk b">system()</code>函数提供，在Fortran中由<code class="du lh li lj lk b">system()</code>子程序或<code class="du lh li lj lk b">execute_command_line</code>子程序提供。</p><p id="d123" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">例如，C中的这段代码会将Linux中的<code class="du lh li lj lk b">file1</code>复制到<code class="du lh li lj lk b">dir</code>目录:</p><pre class="iy iz ja jb fd mg lk mh mi aw mj bi"><span id="85f9" class="kl km hi lk b fi mk ml l mm mn">#include &lt;stdlib.h&gt;</span><span id="1521" class="kl km hi lk b fi mo ml l mm mn">int main(){<br/>    system("cp file1 dir/");<br/>    return 0;<br/>}<br/>// works on Linux</span></pre><p id="2bd2" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">通常，这种类型的shell调用很少见。很明显，在Windows上，同样的代码不能工作，因为<code class="du lh li lj lk b">system()</code>调用了Windows命令提示符(<code class="du lh li lj lk b">cmd.exe</code>)，它不能识别<code class="du lh li lj lk b">cp</code>命令。另外，文件系统分隔符在Windows中是反斜杠，在c中需要转义。</p><pre class="iy iz ja jb fd mg lk mh mi aw mj bi"><span id="7ad7" class="kl km hi lk b fi mk ml l mm mn">#include &lt;stdlib.h&gt;</span><span id="f563" class="kl km hi lk b fi mo ml l mm mn">int main(){<br/>    system("copy file1 dir\\"); <br/>    return 0;<br/>}<br/>// works on Windows</span></pre><blockquote class="ll lm ln"><p id="532d" class="jp jq lo jr b js jt ij ju jv jw im jx lp jz ka kb lq kd ke kf lr kh ki kj kk hb bi translated">7)经常测试</p></blockquote><p id="95de" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">所以，在所有这些修改之后，你终于设法让软件编译了。这是否意味着该软件有效？<strong class="jr hj">没有</strong>，编译器没有抛出任何错误并不代表最终的可执行文件有效。</p><p id="e827" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">幸运的是，大多数学术开源软件都带有测试。这些是示例计算，您可以运行它们来检查您的软件是否工作，以及它是否在可接受的范围内给出了正确的数字结果。</p><p id="9ff8" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">您应该总是尽可能多地运行这些测试，以确保您构建的软件实际上按预期运行。</p><h2 id="8d28" class="kl km hi bd kn ko kp kq kr ks kt ku kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">值得吗？</h2><p id="7951" class="pw-post-body-paragraph jp jq hi jr b js mp ij ju jv mq im jx jy mr ka kb kc ms ke kf kg mt ki kj kk hb bi translated">移植一个软件的所有这些麻烦值得吗？很多人会推荐转Linux，或者安装双引导。尽管有一些进步，我仍然不相信Linux适合这里的普通终端用户。很多实用软件仍然不能在Linux上运行，只能在Windows和Mac OS X上运行。对我来说，使用Windows更方便，因为我用它做其他任何事情。(也许你不同意，没关系，因为你应该选择一个对你最方便的OS。)</p><p id="1ce4" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">因此，我认为值得花时间尝试将开源代码移植到Windows。大多数时候，这比安装Linux要简单得多。</p></div><div class="ab cl mu mv gp mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hb hc hd he hf"><p id="1b57" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">感谢阅读！欢迎在回复中留下评论或问题。</p></div></div>    
</body>
</html>