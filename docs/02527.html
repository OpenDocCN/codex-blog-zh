<html>
<head>
<title>Developing scalable NodeJS apps: Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发可伸缩的NodeJS应用程序:缓存</h1>
<blockquote>原文：<a href="https://medium.com/codex/developing-scalable-nodejs-apps-caching-a6dd0d9d0d4d?source=collection_archive---------11-----------------------#2021-07-24">https://medium.com/codex/developing-scalable-nodejs-apps-caching-a6dd0d9d0d4d?source=collection_archive---------11-----------------------#2021-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7a66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您为一个访问量不大的客户创建了一个博客，流程将会非常简单——想要查看一个故事的用户只需点击一个链接，向服务器发送请求，然后服务器将从数据库中获取该特定帖子的查询，然后将其发送回用户。<em class="jd">瞧！</em></p><p id="4cb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果博客突然爆料了一个名人故事(或《T4》的内幕消息)并且突然获得了比平常高得多的流量，而服务器无法处理如此大的请求量，你的博客会如何处理这种情况？</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/270c9336b44f7429ac60d6de33c2554b.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*SVs5QWWiVdHiu7B55YPIfQ.jpeg"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated"><em class="jq"> aww备注…图片来源:</em><a class="ae jr" href="https://www.exai.com/blog/503-service-unavailable" rel="noopener ugc nofollow" target="_blank">https://www.exai.com/blog/503-service-unavailable</a></figcaption></figure><p id="5561" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述场景是您在开发大规模应用程序时将面临的一种情况，缓存提供了一种近乎万无一失的处理方式，</p><p id="8109" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">什么是缓存？</em>T13】</strong></p><p id="a938" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，缓存包括将数据存储在临时存储解决方案中，以便可以更快地提供给用户。当在短时间内被重复请求的文件被缓存时，它们可以被存储在缓存中，这使得它们可以更快地被访问，而不需要重复查询数据库(或者在我们将在下面使用的例子中，外部API调用)，并且提高了我们的应用程序的性能。</p><p id="3199" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">缓存在动作</em> </strong></p><p id="881a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">内存数据库是最常用的缓存资源。与将数据存储在磁盘上的数据库相比，它们主要依靠内存来存储数据。这减少了访问磁盘的需要，从而缩短了响应时间。最流行的内存数据库是Redis，这是我们将在示例中使用的。你需要为你的操作系统(Mac或Linux)安装Redis，或者为Windows使用云替代系统。Redis还将数据备份到磁盘，因此它可以持久保存数据，从而提供了一个出色的数据恢复功能。</p><p id="5329" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的示例中，我们将缓存从API返回的数据，因此每当我们需要数据时，它将检查我们的缓存中的数据，如果数据存在就返回数据，而不是总是调用API(其中一些可能不成功)。</p><p id="1cc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<code class="du js jt ju jv b">npm init -y</code>设置新的npm项目，并安装以下依赖项:</p><pre class="jf jg jh ji fd jw jv jx jy aw jz bi"><span id="5774" class="ka kb hi jv b fi kc kd l ke kf">npm install redis axios express</span></pre><p id="7a91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将安装Node.js Redis客户端和Axios，以便进行API调用。在文件夹的根目录下，创建一个<code class="du js jt ju jv b">redis.js</code>文件，并添加以下代码:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="kg kh l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">redis.js</figcaption></figure><p id="9bf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Redis默认监听端口6379，如果使用云提供商，应该用正确的URL替换localhost。</p><p id="4690" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，同样在根文件夹中，创建一个<code class="du js jt ju jv b">index.js</code>文件。在这里，我们将设置一个从API获取数据的路由，然后缓存这些数据。理解Redis重要性的一个简单方法是在API测试工具中记录下第一个请求的响应时间，并将其与随后的响应时间进行比较。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ki kh l"/></div></figure><p id="66dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的<code class="du js jt ju jv b">index.js</code>文件中，我们有一个获取所有国家列表并返回给用户的端点。这些是我们缓存的数据类型——通常被频繁请求且很少更改的数据。当一个新用户要注册您的应用程序时，总是可以请求一个国家列表，而一个新的国家不会每天都弹出来。</p><p id="d4c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是从API获取数据和在Redis中缓存数据所用时间的差异:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es kj"><img src="../Images/4ec260da002ebfbc1da652b6a7dacffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ejw_6vcGw-UuSDAghbmCQw.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">从API获取时大约2秒</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ko"><img src="../Images/7b36eb5ab43c812814185a2589c93d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZW_Xf15MdABMReSNePU53A.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">从我们的缓存中提取时，仅22毫秒</figcaption></figure><p id="5dee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Redis是高性能的，可以处理大量并发请求。事实上，它非常强大，可以做的不仅仅是缓存。您可以在这里看到更多使用Node.js客户端的Redis示例。</p></div></div>    
</body>
</html>