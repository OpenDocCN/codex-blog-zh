<html>
<head>
<title>iOS Interview: Dependency Injection [Types and implementation]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS访谈:依赖注入[类型和实现]</h1>
<blockquote>原文：<a href="https://medium.com/codex/ios-interview-dependency-injection-types-and-implementation-a216d182f047?source=collection_archive---------4-----------------------#2022-12-20">https://medium.com/codex/ios-interview-dependency-injection-types-and-implementation-a216d182f047?source=collection_archive---------4-----------------------#2022-12-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="686f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你开始面试一份iOS开发人员的工作时，你曾经面临过这些问题吗？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/b982ae832961d742d957d261f8f420da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SyFZzBUYDlvXfI0oSZbJvA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">国防情报部</figcaption></figure><blockquote class="jt ju jv"><p id="25cc" class="if ig jw ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">1.什么是依赖注入？</p><p id="4123" class="if ig jw ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">2.依赖注入的好处是什么？</p><p id="5533" class="if ig jw ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">3.依赖注入有哪些类型？</p></blockquote><p id="7592" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">令人惊讶的是，你在代码中的某个地方使用了依赖注入，但是你无法用这个概念来解释它。</p><p id="a6be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以让我们开始理解依赖注入。</p></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="c0aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi kh translated">依赖注入是一种软件设计模式，在这种模式中，一个对象接收它所依赖的其他实例。</p><p id="1984" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以问题来了，如果通过创建一个类的对象，然后使用属性和函数，一切都很好，为什么我们需要依赖注入？其背后的原因是，依赖注入赋予了编写更多可测试、可重用代码的能力，这有助于我们编写可维护的软件，我们可以用模拟数据执行测试，这将简化测试。它是一种设计模式，涉及为组件提供其依赖关系，而不是让组件自己创建或定位它们。这可能是有用的，原因有很多，包括:</p><ul class=""><li id="3cee" class="kq kr hi ih b ii ij im in iq ks iu kt iy ku jc kv kw kx ky bi translated"><em class="jw">它使得隔离测试组件变得更加容易，因为您可以注入模拟依赖项，而不必设置真正的依赖项。</em></li><li id="6fec" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated"><em class="jw">它允许你将组件彼此分离，使得重用和维护它们变得更加容易。</em></li><li id="1030" class="kq kr hi ih b ii kz im la iq lb iu lc iy ld jc kv kw kx ky bi translated"><em class="jw">它可以使管理复杂系统变得更容易，因为您可以在一个中心位置定义依赖关系，而不是将它们分散在代码库中。</em></li></ul></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="58e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据您的应用需求，在Swift中实施依赖注入有多种方式。一些常见的方法包括:<br/> <strong class="ih hj"> 1。构造函数注入</strong>:这涉及到将依赖项作为参数传递给组件的初始化器。下面是构造函数注入的例子。</p><pre class="je jf jg jh fd le lf lg bn lh li bi"><span id="ed13" class="lj lk hi lf b be ll lm l ln lo">class NetworkClient {<br/>  func performRequest(url: URL) {<br/>    // Perform network request<br/>  }<br/>}<br/><br/>class UserService {<br/>  let networkClient: NetworkClient<br/><br/>  init(networkClient: NetworkClient) {<br/>    self.networkClient = networkClient<br/>  }<br/><br/>  func fetchUsers() {<br/>    let url = URL(string: "url")!<br/>    networkClient.performRequest(url: url)<br/>  }<br/>}<br/><br/>let networkClient = NetworkClient()<br/>let userService = UserService(networkClient: networkClient)<br/>userService.fetchUsers()</span></pre><p id="b3e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，<code class="du lp lq lr lf b">UserService</code>依赖于<code class="du lp lq lr lf b">NetworkClient</code>来执行网络请求。通过初始化器将<code class="du lp lq lr lf b">NetworkClient</code>注入<code class="du lp lq lr lf b">UserService</code>，然后<code class="du lp lq lr lf b">UserService</code>可以使用<code class="du lp lq lr lf b">NetworkClient</code>执行请求。</p><p id="3da4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。属性注入:</strong>这包括在组件被初始化后，将组件的依赖项设置为属性。</p><pre class="je jf jg jh fd le lf lg bn lh li bi"><span id="d76e" class="lj lk hi lf b be ll lm l ln lo">class UserService {<br/>  var networkClient: NetworkClient?<br/><br/>  func fetchUsers() {<br/>    let url = URL(string: "url")!<br/>    networkClient?.performRequest(url: url)<br/>  }<br/>}<br/><br/>let networkClient = NetworkClient()<br/>let userService = UserService()<br/>userService.networkClient = networkClient<br/>userService.fetchUsers()</span></pre><p id="94f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 3。方法注入:</strong>这包括将依赖项作为参数传递给需要它们的方法。</p><pre class="je jf jg jh fd le lf lg bn lh li bi"><span id="d267" class="lj lk hi lf b be ll lm l ln lo">class UserService {<br/>  func fetchUsers(using networkClient: NetworkClient) {<br/>    let url = URL(string: "url")!<br/>    networkClient.performRequest(url: url)<br/>  }<br/>}<br/><br/>let networkClient = NetworkClient()<br/>let userService = UserService()<br/>userService.fetchUsers(using: networkClient)</span></pre><p id="6648" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 4。接口注入:</strong>这包括为依赖关系定义一个接口，并让组件实现这个接口。当组件需要使用具有相似角色但不同实现的多个依赖项时，这可能很有用。例如:</p><pre class="je jf jg jh fd le lf lg bn lh li bi"><span id="2fcd" class="lj lk hi lf b be ll lm l ln lo">protocol NetworkClient {<br/>  func performRequest(url: URL)<br/>}<br/><br/>class HTTPNetworkClient: NetworkClient {<br/>  func performRequest(url: URL) {<br/>    // Perform network request using HTTP<br/>  }<br/>}<br/><br/>class UserService {<br/>  var networkClient: NetworkClient<br/><br/>  init(networkClient: NetworkClient) {<br/>    self.networkClient = networkClient<br/>  }<br/><br/>  func fetchUsers() {<br/>    let url = URL(string: "url")!<br/>    networkClient.performRequest(url: url)<br/>  }<br/>}<br/><br/>let networkClient = HTTPNetworkClient()<br/>let userService = UserService(networkClient: networkClient)<br/>userService.fetchUsers()</span></pre><p id="14f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jw">如果您喜欢这个，点击💚尽你所能在下面为这篇文章鼓掌，这样其他人会在媒体上看到。如果您有任何疑问或建议，请随时评论或点击</em></strong><a class="ae ls" href="https://twitter.com/b_banzara" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jw">Twitter</em></strong></a><strong class="ih hj"><em class="jw">，或</em></strong><a class="ae ls" href="https://www.linkedin.com/in/rranjanchchn/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jw">Linkedin</em></strong></a></p></div></div>    
</body>
</html>