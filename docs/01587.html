<html>
<head>
<title>Understanding Hooks Part 7 — State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解钩子第7部分—状态管理</h1>
<blockquote>原文：<a href="https://medium.com/codex/understanding-hooks-part-7-state-management-84ff636834a7?source=collection_archive---------11-----------------------#2021-05-14">https://medium.com/codex/understanding-hooks-part-7-state-management-84ff636834a7?source=collection_archive---------11-----------------------#2021-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8e2a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">传说中的React钩子背后是什么？有时候，我会想。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8e42cee1f7d92219ceebab9b4725eb57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FLKP6AXotB79tG2MHWeheA.jpeg"/></div></div></figure><p id="c5b2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在第6部分中，我们研究了一个相对复杂的钩子<code class="du kf kg kh ki b">useContext</code>,看看如何使用状态来驱动元素更新。在第7部分中，我们将基于这种理解创建我们自己的状态管理。</p><p id="2e78" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们知道现在调用<code class="du kf kg kh ki b">setState</code>触发了<code class="du kf kg kh ki b">useState</code>注册的<code class="du kf kg kh ki b">Component</code>的更新。</p><p id="db65" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">先说一个<code class="du kf kg kh ki b">value</code>和<code class="du kf kg kh ki b">setValue</code>。</p><h2 id="09b7" class="kj kk hi bd kl km kn ko kp kq kr ks kt js ku kv kw jw kx ky kz ka la lb lc ld bi translated">单一的</h2><p id="826d" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">最常见的情况是在事件处理程序中使用<code class="du kf kg kh ki b">setValue</code>，比如click。</p><pre class="iy iz ja jb fd lj ki lk ll aw lm bi"><span id="5169" class="kj kk hi ki b fi ln lo l lp lq">const Single = () =&gt; {<br/>  const [value, setValue] = <strong class="ki hj">useState</strong>(1)<br/>  const onClick = () =&gt; { setValue(2) } <br/>}</span></pre><p id="f6a7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">或者您可以在<code class="du kf kg kh ki b">useEffect</code>中使用它，当您获取一个API并成功设置值时。</p><pre class="iy iz ja jb fd lj ki lk ll aw lm bi"><span id="477b" class="kj kk hi ki b fi ln lo l lp lq">const Single = () =&gt; {<br/>  const [value, setValue] = <strong class="ki hj">useState</strong>(1)<br/>  useEffect(() =&gt; { setValue(3) } <br/>}</span></pre><h2 id="089b" class="kj kk hi bd kl km kn ko kp kq kr ks kt js ku kv kw jw kx ky kz ka la lb lc ld bi translated">父母/子女</h2><p id="755a" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">您可以将<code class="du kf kg kh ki b">setValue</code>传递给一个子组件。这允许孩子向父母请求更新。</p><pre class="iy iz ja jb fd lj ki lk ll aw lm bi"><span id="2198" class="kj kk hi ki b fi ln lo l lp lq">const Parent = () =&gt; {<br/>  const [value, setValue] = <strong class="ki hj">useState</strong>(1)<br/>  return &lt;Child setValue={setValue} /&gt; <br/>}</span></pre><p id="abc0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">更常见的方法是让孩子暴露一个事件，</p><pre class="iy iz ja jb fd lj ki lk ll aw lm bi"><span id="f582" class="kj kk hi ki b fi ln lo l lp lq">const Parent = () =&gt; {<br/>  const [value, setValue] = <strong class="ki hj">useState</strong>(1)<br/>  const onChange = () =&gt; { setValue(3) }<br/>  return &lt;Child onChange={onChange} /&gt;<br/>}</span></pre><p id="7bf9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du kf kg kh ki b">Child</code>通过<code class="du kf kg kh ki b">onChange</code>通知父节点，父节点反过来设置值，从而请求更新父节点(和子节点)。</p><h2 id="61d4" class="kj kk hi bd kl km kn ko kp kq kr ks kt js ku kv kw jw kx ky kz ka la lb lc ld bi translated">祖先/子女</h2><p id="b10e" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">如果一些孩子以某种方式连接，可以创建一个<code class="du kf kg kh ki b">Context</code>并通过<code class="du kf kg kh ki b">useContext</code>从祖先传递给特定的孩子。</p><pre class="iy iz ja jb fd lj ki lk ll aw lm bi"><span id="9fb4" class="kj kk hi ki b fi ln lo l lp lq">// ancestor <br/>const Context = createContext()<br/>const Ancestor = () =&gt; {<br/>  return &lt;Context.Provider value={<strong class="ki hj">useState</strong>(1)} /&gt;<br/>}<br/>// child<br/>const Child = () =&gt; {<br/>  const [value, setValue] = useContext(Context)<br/>}<br/>// not connected child<br/>const Child2 = () =&gt; {<br/>  // does not have useContext <br/>  // or with another Context2<br/>}</span></pre><p id="6a23" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于连接到同一个<code class="du kf kg kh ki b">Context</code>的所有子节点，调用<code class="du kf kg kh ki b">setValue</code>请求立即更新祖先和所有连接的子节点。但是，它可以跳过一个孩子，不在这个网络中。</p><blockquote class="lr ls lt"><p id="69b6" class="jj jk lu jl b jm jn ij jo jp jq im jr lv jt ju jv lw jx jy jz lx kb kc kd ke hb bi translated">组件是否渲染取决于它自己的属性和状态。当祖先更新时，不在网络中的孩子仍然可以得到更新，例如，孩子可以接收改变的属性。</p></blockquote><h2 id="8513" class="kj kk hi bd kl km kn ko kp kq kr ks kt js ku kv kw jw kx ky kz ka la lb lc ld bi translated">网络</h2><p id="9726" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">以上案例传<code class="du kf kg kh ki b">setValue</code>左右。因为<code class="du kf kg kh ki b">useState</code>是在一个主机元素中定义的，按照设计，当<code class="du kf kg kh ki b">setValue</code>被调用时，它请求更新主机。无论你把它发到哪里，它仍然适用于主机。这使得去中心化变得困难。</p><p id="28a0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们退一步。与其四处传递，不如为网络中的任何组件动态创建<code class="du kf kg kh ki b">useState</code>。</p><pre class="iy iz ja jb fd lj ki lk ll aw lm bi"><span id="00ff" class="kj kk hi ki b fi ln lo l lp lq">const <strong class="ki hj">useCustomState</strong> = createUseState(1)<br/>const Component = () =&gt; {<br/>  const [value, setValue] = <strong class="ki hj">useCustomState</strong>()<br/>}</span></pre><p id="a449" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，如果我们调用<code class="du kf kg kh ki b">setValue</code>，它会请求更新<code class="du kf kg kh ki b">Component</code>。</p><pre class="iy iz ja jb fd lj ki lk ll aw lm bi"><span id="493a" class="kj kk hi ki b fi ln lo l lp lq">export default function <strong class="ki hj">createUseState</strong>(initialValue) {<br/>  const listeners = []<br/>  const value = initialValue<br/>  const setValue = v =&gt; {        <br/>    current = Object.assign({}, current, v)<br/>    listeners.forEach(listener =&gt; listener())<br/>  }</span><span id="845d" class="kj kk hi ki b fi ly lo l lp lq">  return function <strong class="ki hj">useCustomState</strong>() {<br/>    const [self, set] = useState(value)<br/>    useEffect(() =&gt; {<br/>      const update = () =&gt; {<br/>        if (self !== value) set(value)<br/>        listeners.push(update)<br/>        return () =&gt; {<br/>          listeners = listeners.filter(i =&gt; i !== update)<br/>        }<br/>      })<br/>    }<br/>    return [self, setValue]<br/>  }<br/>}</span></pre><p id="58b3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这张图片中没有主机元素，它是一个为<code class="du kf kg kh ki b">value</code>提供持久存储的网络。每次调用<code class="du kf kg kh ki b">useCustomState</code>都会创建一个新的<code class="du kf kg kh ki b">useState</code>。并且调用<code class="du kf kg kh ki b">setValue</code>更新这个<code class="du kf kg kh ki b">value</code>并触发网络内所有连接的元件。</p><h2 id="fb05" class="kj kk hi bd kl km kn ko kp kq kr ks kt js ku kv kw jw kx ky kz ka la lb lc ld bi translated">状态管理</h2><p id="71bd" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">现在我们可以在这个项目中管理一个状态的生命周期。我们可以自由地读/写它，并准确地使用它来更新显示。更何况我们可以从一个状态管理系统，比如<code class="du kf kg kh ki b">redux</code>来问。</p><p id="05f2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看能否将上述自定义状态投入到更实际的使用中<code class="du kf kg kh ki b">useUser</code>。</p><pre class="iy iz ja jb fd lj ki lk ll aw lm bi"><span id="2e7a" class="kj kk hi ki b fi ln lo l lp lq">const useUserState = createUseState()</span><span id="0e1b" class="kj kk hi ki b fi ly lo l lp lq">const <strong class="ki hj">useUser</strong> = () =&gt; {<br/>  const [user, setUser] = useUserState()<br/>  useEffect(() =&gt; { // login or fetch api<br/>    setUser(...)<br/>  }, [])<br/>  return user<br/>}</span><span id="ff56" class="kj kk hi ki b fi ly lo l lp lq">function Avatar () {<br/>  const user = <strong class="ki hj">useUser</strong>()<br/>  if (!user) return 'loading...'</span><span id="2dd0" class="kj kk hi ki b fi ly lo l lp lq">  return &lt;img src={user.avatar} /&gt;<br/>}</span></pre><p id="42e5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">尽管它是由<code class="du kf kg kh ki b">useState</code>和<code class="du kf kg kh ki b">useEffect</code>组成的，但是<code class="du kf kg kh ki b">useUser</code>看起来更像是一个数据层，就像传统的方式一样。最后，我们希望将<code class="du kf kg kh ki b">user</code>对象建模为</p><ul class=""><li id="a7e8" class="lz ma hi jl b jm jn jp jq js mb jw mc ka md ke me mf mg mh bi translated">与唯一用户同步</li><li id="93f4" class="lz ma hi jl b jm mi jp mj js mk jw ml ka mm ke me mf mg mh bi translated">当用户改变时通知所有连接的元素</li></ul><p id="a9ac" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果这一切都完美运行，最后一个问题是，这个规模？例如，如果我们有10–20个<code class="du kf kg kh ki b">useUser</code>的使用，更新会导致大量的渲染甚至是一个死循环吗？幸运的是，<code class="du kf kg kh ki b">react</code>团队解决了这个问题。</p><blockquote class="lr ls lt"><p id="dc41" class="jj jk lu jl b jm jn ij jo jp jq im jr lv jt ju jv lw jx jy jz lx kb kc kd ke hb bi translated"><em class="hi">"理解这一点的关键是，</em> <strong class="jl hj"> <em class="hi">无论你在一个React事件处理程序<em class="hi">中做多少</em> </em></strong> <code class="du kf kg kh ki b"><strong class="jl hj"><em class="hi">setState()</em></strong></code> <strong class="jl hj"> <em class="hi">调用多少个</em>组件，它们都只会在事件 </strong> <em class="hi">结束时产生一个单独的重新渲染。这对于大型应用程序中的良好性能至关重要，因为如果在处理点击事件时</em> <code class="du kf kg kh ki b"><em class="hi">Child</em></code> <em class="hi">和</em> <code class="du kf kg kh ki b"><em class="hi">Parent</em></code> <em class="hi">都调用了</em> <code class="du kf kg kh ki b"><em class="hi">setState()</em></code> <em class="hi">，那么您就不希望两次重新渲染</em> <code class="du kf kg kh ki b"><em class="hi">Child</em></code> <em class="hi">。</em> <a class="ae mn" href="https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates" rel="noopener ugc nofollow" target="_blank"> <em class="hi">丹在这张票上评论了</em> </a> <em class="hi">，这里演示了</em><a class="ae mn" rel="noopener" href="/swlh/react-state-batch-update-b1b61bd28cd2"><em class="hi"/></a><em class="hi">。</em></p></blockquote><h2 id="daa4" class="kj kk hi bd kl km kn ko kp kq kr ks kt js ku kv kw jw kx ky kz ka la lb lc ld bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="0966" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">状态管理可以用一个<code class="du kf kg kh ki b">useState</code>来完成。可以在多个位置设置和使用状态。并且在改变时，它通知所有连接的元件。</p><h1 id="b045" class="mo kk hi bd kl mp mq mr kp ms mt mu kt io mv ip kw ir mw is kz iu mx iv lc my bi translated">索引</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/d48d45c7dcf9d31d710783b3ed483803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eCw7YWkIJBxiMxQH"/></div></div><figcaption class="na nb et er es nc nd bd b be z dx translated">由<a class="ae mn" href="https://unsplash.com/@goshua13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约书亚·阿拉贡</a>在<a class="ae mn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><ul class=""><li id="1df1" class="lz ma hi jl b jm jn jp jq js mb jw mc ka md ke me mf mg mh bi translated"><a class="ae mn" href="https://windmaomao.medium.com/hook-myth-from-react-9495aa8ad7af" rel="noopener">第1部分，元素</a></li><li id="1254" class="lz ma hi jl b jm mi jp mj js mk jw ml ka mm ke me mf mg mh bi translated"><a class="ae mn" href="https://windmaomao.medium.com/hooks-part-2-useeffect-2fa1a377c124" rel="noopener">第二部分，使用效果</a></li><li id="fe0e" class="lz ma hi jl b jm mi jp mj js mk jw ml ka mm ke me mf mg mh bi translated"><a class="ae mn" href="https://windmaomao.medium.com/hooks-part-3-usestate-26a622bbe462" rel="noopener">第3部分，使用状态</a></li><li id="6b83" class="lz ma hi jl b jm mi jp mj js mk jw ml ka mm ke me mf mg mh bi translated"><a class="ae mn" href="https://windmaomao.medium.com/understanding-hooks-part-4-hook-c7a8c7185f4e" rel="noopener">第4部分，挂钩</a></li><li id="0675" class="lz ma hi jl b jm mi jp mj js mk jw ml ka mm ke me mf mg mh bi translated"><a class="ae mn" href="https://windmaomao.medium.com/understanding-hooks-part-5-custom-hook-985b83c8bfea" rel="noopener">第5部分，自定义挂钩</a></li><li id="f46c" class="lz ma hi jl b jm mi jp mj js mk jw ml ka mm ke me mf mg mh bi translated"><a class="ae mn" href="https://windmaomao.medium.com/understanding-hooks-part-6-usecontext-7ece0c0818e3" rel="noopener">第6部分，使用上下文</a></li><li id="bd0a" class="lz ma hi jl b jm mi jp mj js mk jw ml ka mm ke me mf mg mh bi translated">第七部分，状态管理你在这里</li></ul><p id="a402" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="lu">使用的代码片段和思想大量借鉴并简化自</em><a class="ae mn" href="https://github.com/pmndrs/zustand" rel="noopener ugc nofollow" target="_blank"/><a class="ae mn" href="https://swr.vercel.app/" rel="noopener ugc nofollow" target="_blank">use SWR</a><a class="ae mn" href="https://github.com/facebookexperimental/Recoil" rel="noopener ugc nofollow" target="_blank">反冲</a>。</p></div></div>    
</body>
</html>