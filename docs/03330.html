<html>
<head>
<title>Understanding The Linux Kernel Through CTF Challenges: Seccomp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过CTF挑战了解Linux内核</h1>
<blockquote>原文：<a href="https://medium.com/codex/understanding-the-linux-kernel-through-ctf-challenges-seccomp-be6ed553a97?source=collection_archive---------5-----------------------#2021-08-28">https://medium.com/codex/understanding-the-linux-kernel-through-ctf-challenges-seccomp-be6ed553a97?source=collection_archive---------5-----------------------#2021-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/8af5013801a991e44c97d6b7ec1fb7a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/0*QyBdAsRJ8FAfY-pn.jpg"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">来自:<a class="ae jc" href="https://memegenerator.net/instance/73974722/snl-stefon-new-yorks-hottest-club-is-linux-this-place-has-everything-apparmor-seccomp-cgroups-preven" rel="noopener ugc nofollow" target="_blank">https://meme generator . net/instance/73974722/SNL-stefon-new-yorks-hotest-club-is-Linux-this-place-has-everything-apparmor-sec comp-cgroups-preven</a></figcaption></figure><p id="8d63" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我是威森德，拉格纳安全公司的创始人。今天，我们将探讨Seccomp，一个Linux内核安全特性。我们将通过来自<strong class="jf hj"> UIUCTF的挑战<strong class="jf hj">不安全_秒竞争</strong>来探索这一点。</strong>我们将讨论的一些事情是:</p><ul class=""><li id="06c0" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">什么是Seccomp？</li><li id="c21b" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">为什么有用？</li><li id="750f" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">当您配置错误并且实例有漏洞时会发生什么。</li></ul><p id="b5a4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果您还没有，请继续关注我们:</p><ul class=""><li id="d6e5" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">推特:<a class="ae jc" href="https://twitter.com/ragnarsecurity" rel="noopener ugc nofollow" target="_blank"> @RagnarSecurity </a></li><li id="73fc" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">https://www.reddit.com/user/ragnarsecurity</li><li id="4cf9" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">中:<a class="kp kq ge" href="https://medium.com/u/ba9e8c03464e?source=post_page-----be6ed553a97--------------------------------" rel="noopener" target="_blank">拉格纳安全</a>。</li></ul></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="5a34" class="kr ks hi bd kt ku kv kw kx ky kz la lb jo lc ld le js lf lg lh jw li lj lk ll bi translated">什么是Seccomp？</h2><p id="1e5a" class="pw-post-body-paragraph jd je hi jf b jg lm ji jj jk ln jm jn jo lo jq jr js lp ju jv jw lq jy jz ka hb bi translated">Seccomp是Linux内核中的一个系统调用，它限制用户可以执行的其他系统调用(Seccomp在用户进行无效系统调用时使用的消息之一是<strong class="jf hj">“错误系统调用”</strong>)。它通常与Docker容器一起使用来保护实例(尤其是在Linux服务器上)。Seccomp可以在两个范围内实现:在整个机器上或在运行的程序中。我们将重点关注在应用程序级别实现Seccomp，因为这是实现<strong class="jf hj">secure _ sec comp</strong>的范围。顺便说一句:Docker提供了一种在运行时传递配置文件的方法，这样容器也有Seccomp。你可以在这里了解他们更多:<a class="ae jc" href="https://docs.docker.com/engine/security/seccomp/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/security/seccomp</a>/。</p><p id="384d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Seccomp有三种主要模式:</p><ul class=""><li id="905f" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">SECCOMP_MODE_STRICT —打开SECCOMP提供的所有安全措施</li><li id="ae7b" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">SECCOMP_MODE_FILTER —允许开发人员/用户通过过滤器限制某些操作</li><li id="d6d8" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">SECCOMP_MODE_DISABLED —禁用机器上的SECCOMP</li></ul><p id="0cad" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">今天，我们将主要讨论SECCOMP_MODE_FILTER。这种模式允许程序员/管理员使用某种过滤机制来决定允许什么系统调用。有多种方法来实现过滤器，但我们将重点放在伯克利数据包过滤器。</p><p id="527f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Berkeley包过滤是操作系统过滤数据的一种方式(主要是为网络流量创建的)。我们可以使用几个函数来建立一些Seccomp规则:</p><ul class=""><li id="ff7e" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">STMT BPF——这是我们将设定具体规则的功能。</li><li id="d5ed" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">BPF _跳转——这将用于指示规则在哪个场景(或什么功能)中有效。</li></ul><p id="eace" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">下面是一个Seccomp实现的示例:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="27ed" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这个实现中，我们可以看到一些东西。首先，在<strong class="jf hj"> configure_seccomp </strong>中设置的规则允许执行write和open系统调用。所有其他的系统调用都会杀死这个程序。BPF _跳转包含我们想要处理的系统调用，而下面的BPF_STMT决定如何处理这个系统调用。需要注意的是，这个Seccomp配置只允许用读权限调用open。如果用写或执行权限调用open，那么它将被终止。</p><p id="8213" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">另一个重要的Seccomp配置是这些行:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lt"><img src="../Images/8f42e3cd9126416a8f0843f79607605b.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*NxyzH5KLq7XQW_YIsHEllQ.png"/></div></figure><p id="0c84" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">PR_SET_NO_NEW_PRIVS告诉kernrel/running应用程序不应该设置新的Seccomp配置。例如，如果攻击者试图在正在运行的程序中添加<strong class="jf hj">系统</strong>作为有效的系统调用，内核将不会允许。</p><p id="e220" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们知道了如何使用基本的Seccomp过滤器，是时候开始解决不安全的seccomp了！</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="9b60" class="kr ks hi bd kt ku kv kw kx ky kz la lb jo lc ld le js lf lg lh jw li lj lk ll bi translated">解决不安全问题_seccomp</h2><p id="cc8d" class="pw-post-body-paragraph jd je hi jf b jg lm ji jj jk ln jm jn jo lo jq jr js lp ju jv jw lq jy jz ka hb bi translated">以下是UIUCTF提供给我们的挑战描述:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lu"><img src="../Images/3cec54351a5aa5bcfc889a992e66a1b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*VGSLEXMekkiuMKU5Zkiy0g.png"/></div></figure><p id="2310" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">通过阅读挑战描述，我们获得了以下信息:</p><ul class=""><li id="2071" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">挑战在于以某种方式向应用程序或机器的范围添加更多特权，以便我们可以访问该标志。</li><li id="648f" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">NO_NEW_PRIVS被禁用或从不设置。这意味着我们可以更改Seccomp设置/过滤器来授予自己更多的特权。</li></ul><p id="5e57" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们还得到了两份讲义:一个模拟整个环境的docker实例和一个starter文件。docker实例是一个busybox实例，有三个可执行文件:<strong class="jf hj"> exploit_me、jail和seccomp_loader </strong>。seccomp_loader接受一个命令的参数，并接受一个过滤器作为stddin。因此，这样做的想法是通过seccomp加载程序调用exploit_me，以便它给我们提供标志。代码如下:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">利用我的代码</figcaption></figure><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">seccomp_loader的代码</figcaption></figure><p id="9981" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">starter文件让我们打印一个包含我们想要的规则的BPF过滤器。</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="98f8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">根据对代码的阅读，很明显我们的目标是通过seccomp_loader调用exploit_me，从而生成一个根shell。之后，我们就能拿到旗子了！</p><p id="084b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在我尝试任何剥削之前，我尝试直接阅读旗帜；但是我没有权限。从读取Dockerfile文件来看，这个标志似乎在文件系统的根目录下，所以我去了那里并尝试对文件进行cat。不出所料，没有权限:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">挑战档案</figcaption></figure><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lv"><img src="../Images/78ef08ee7e815f329441ab5bc1730426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EuJV0ndqzyfPL0t9ZZ41Ew.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">试图在不被利用的情况下读取标志</figcaption></figure><p id="1eb7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">似乎监狱很坚固。读取该文件的唯一方法就是利用漏洞！去工作:</p><p id="e885" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最初，我认为如果我能够授予自己能够执行<strong class="jf hj"> execve </strong>的特权，那么我就能够获得这个标志；然而，事情似乎比这更复杂。下面你可以看到我为execve创建了一个过滤器，并将其传递给<strong class="jf hj"> seccomp_loader </strong>，但是当<strong class="jf hj"> seccomp_loader </strong>试图执行<strong class="jf hj"> exploit_me </strong>时，我得到了一个错误。</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lr ls l"/></div></figure><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="4951" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">基于此，我意识到在<strong class="jf hj"> exploit_me </strong>中可能有一个需要限制或允许的系统调用，以便我们可以生成shell。为了弄清楚这一点，我花了一些时间分析<strong class="jf hj"> exploit_me </strong>的代码(特别是查看系统调用如何影响程序的执行流)。</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">利用我的代码</figcaption></figure><p id="4eac" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">总共有三个:<strong class="jf hj"> faccessat、setuid和getuid </strong>。Setuid和getuid是我们需要执行的系统调用；但是，我们需要拒绝执行faccessat。由于我们不是root，faccessat会返回一个错误(也就是说<strong class="jf hj"> if(！faccessat(…)</strong>将为真条件。通过输入if语句，我们将退出程序。</p><p id="5204" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在是时候构建一个新的过滤器来设置这些权限了。为了找到faccessat要传递给Berkley包过滤器的值，我查看了unistd_64.h的内部。</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">来自unistd_64.h</figcaption></figure><p id="c8a3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">找到它后，我创建了一个过滤器，允许除faccessat之外的所有系统调用，并将它传递到程序中。然后，我试图再次阅读国旗。这一次，我有了更好的结果！</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">用于创建过滤器的代码</figcaption></figure><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lw"><img src="../Images/5e09f8743b1c6479e9a95623663a7296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2R3LtCC63wX7l-w5mFOYcQ.png"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">起动机的输出</figcaption></figure><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lx"><img src="../Images/6c8c83180a2bb71cbe9b5b83c3688497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*tLwVBCOdog4i1BEur5HG6g.png"/></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">在CTF环境下运行过滤器的输出！</figcaption></figure><p id="6de3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">利润！我们能够生成一个根shell并访问旗帜！</p><p id="6bc7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这就结束了对secure_seccomp的演练。在我们开始之前，让我们回顾一下我们所学的内容:</p><ul class=""><li id="1b51" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">我们学习了什么是seccomp以及通过Berkley数据包过滤器实现过滤器的方法。</li><li id="10c8" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">我们了解了当有人在应用程序或机器中错误地配置seccomp时会发生什么。</li><li id="8e28" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">我们利用了来自UIUCTF的不安全_seccomp挑战！</li></ul><p id="e020" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果你喜欢阅读这篇文章，请继续关注我们:</p><ul class=""><li id="9b59" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">推特:<a class="ae jc" href="https://twitter.com/ragnarsecurity" rel="noopener ugc nofollow" target="_blank"> @RagnarSecurity </a></li><li id="4a41" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">https://www.reddit.com/user/ragnarsecurity</li><li id="aa65" class="kb kc hi jf b jg kk jk kl jo km js kn jw ko ka kg kh ki kj bi translated">这里是媒体:<a class="kp kq ge" href="https://medium.com/u/ba9e8c03464e?source=post_page-----be6ed553a97--------------------------------" rel="noopener" target="_blank">拉格纳安全</a></li></ul><p id="0fc7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将很快回来，带来更多的报道！</p></div></div>    
</body>
</html>