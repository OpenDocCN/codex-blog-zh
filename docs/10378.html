<html>
<head>
<title>Auto Model Generating for DBT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DBT的自动模型生成</h1>
<blockquote>原文：<a href="https://medium.com/codex/auto-model-generating-for-dbt-97a856506534?source=collection_archive---------5-----------------------#2022-12-26">https://medium.com/codex/auto-model-generating-for-dbt-97a856506534?source=collection_archive---------5-----------------------#2022-12-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="06b4" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用于取消嵌套转移数据(红移)的简单CLI</h2></div><p id="80ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将看到如何使用Python来自动化我们的dbt模型生成步骤。</p><p id="9b59" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我研究微服务和Kubernetes已经快2周了。因此，我不能颠倒新的东西来写🫠。实际上，我已经在我正在做的项目中实现了一些新的技术栈。为了让你对未来感到兴奋，我会说我们将看到如何实现OpenSearch我们的项目来创建我们自己的搜索服务。🥸</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/9417a76af9a202161ff00e57a47734a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O9jGOIWDzAwIcstN"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">照片由<a class="ae kj" href="https://unsplash.com/@lukash?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡斯</a>在<a class="ae kj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="463f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">我的日常任务之一(有时😋)</h1><p id="1450" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">我在一家咨询公司工作，我们为我们的一个客户开发一个IT基础设施项目。客户的数据团队需要更新暂存表和数据集市，以改进他们的报告。为了更新相关的表，我需要检查嵌套的数据结构(JSON格式)并更新我的dbt模型中添加或删除的列。直到出现了一个几乎有75列的表格，我才觉得好受些。🤯那一次，我编写了一个简单的Python cli，而不是花费时间逐行转换75列。我已经在我们的VCS上发布了回购，口号如下。</p><blockquote class="lh li lj"><p id="37f3" class="ix iy lk iz b ja jb ij jc jd je im jf ll jh ji jj lm jl jm jn ln jp jq jr js hb bi translated">我创建了这个脚本，因为我懒得一行一行地写:&amp;</p></blockquote><h1 id="67d5" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">DBT模型生成器</h1><p id="17b5" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">我们的文件夹树如下所示。</p><pre class="ju jv jw jx fd lo lp lq bn lr ls bi"><span id="aa96" class="lt kl hi lp b be lu lv l lw lx">├── helpers<br/>│   ├── connection.py<br/>│   ├── __init__.py<br/>│   ├── parser.py<br/>│   └── writer.py<br/>├── README.md<br/>├── requirements.txt<br/>└── script.py</span></pre><p id="9009" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用下面的代码安装所需的包。</p><pre class="ju jv jw jx fd lo lp lq bn lr ls bi"><span id="d44b" class="lt kl hi lp b be lu lv l lw lx">pip install black SQLAlchemy sqlalchemy-redshift psycopg2-binary</span></pre><h2 id="c229" class="ly kl hi bd km lz ma mb kq mc md me ku jg mf mg kw jk mh mi ky jo mj mk la ml bi translated">连接模块</h2><p id="773d" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">通过使用下面的函数，我们可以很容易地获得数据库连接。这个函数返回数据库连接。我们将使用<code class="du mm mn mo lp b">con</code>对象来执行sql命令。</p><pre class="ju jv jw jx fd lo lp lq bn lr ls bi"><span id="ced7" class="lt kl hi lp b be lu lv l lw lx"># helpers/connection.py<br/><br/>from sqlalchemy import create_engine<br/><br/><br/>def get_engine():<br/>    """Returns Redshift engine<br/><br/>    Returns:<br/>        engine: Redshift connected engine<br/>    """<br/>    return create_engine(<br/>        "redshift+psycopg2://&lt;YOUR_URI&gt;" # ofcourse you can use env variables<br/>    )</span></pre><h2 id="cfc1" class="ly kl hi bd km lz ma mb kq mc md me ku jg mf mg kw jk mh mi ky jo mj mk la ml bi translated">分析器模块</h2><p id="6b9e" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">解析器模块帮助我们解析每一列及其类型(对于红移)。</p><pre class="ju jv jw jx fd lo lp lq bn lr ls bi"><span id="d8e0" class="lt kl hi lp b be lu lv l lw lx"># helpers/parser.py<br/><br/>import json<br/>from datetime import datetime<br/><br/><br/>class TypeChecker(object):<br/>    @staticmethod<br/>    def is_timestamp(val: str) -&gt; bool:<br/>        try:<br/>            datetime.fromisoformat(val)<br/>            return True<br/>        except:<br/>            return False<br/><br/>    @staticmethod<br/>    def is_integer(val: str) -&gt; bool:<br/>        try:<br/>            int(val)<br/>            return True<br/>        except:<br/>            return False<br/><br/>    @staticmethod<br/>    def is_decimal(val: str) -&gt; bool:<br/>        try:<br/>            float(val)<br/>            return True<br/>        except:<br/>            return False<br/><br/>    @staticmethod<br/>    def is_varchar(val: str) -&gt; bool:<br/>        try:<br/>            str(val)<br/>            return True<br/>        except:<br/>            return False<br/><br/><br/>def get_data_type(col_value: str) -&gt; str:<br/>    if TypeChecker.is_timestamp(col_value):<br/>        return "timestamp"<br/>    elif TypeChecker.is_integer(col_value):<br/>        return "integer"<br/>    elif TypeChecker.is_decimal(col_value):<br/>        return "decimal(16,2)"<br/>    elif (<br/>        TypeChecker.is_varchar(col_value) == False<br/>    ):  # if it's not varchar, it has to be examined<br/>        return "UNDEFINED"<br/>    else:<br/>        return "varchar"<br/><br/><br/>def get_parsed_data(res: str) -&gt; dict:<br/>    """Return passed data columns' types<br/><br/>    Args:<br/>        res (str): JSON format data in STR!<br/><br/>    Returns:<br/>        column_types (dict): columns are keys and data types are values<br/>    """<br/>    res = json.loads(res)<br/><br/>    column_types = {}<br/><br/>    for col in res:<br/>        column_types[col] = get_data_type(res[col])<br/><br/>    return column_types</span></pre><h2 id="2683" class="ly kl hi bd km lz ma mb kq mc md me ku jg mf mg kw jk mh mi ky jo mj mk la ml bi translated">写入模块</h2><p id="d036" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">这个模块帮助我们生成dbt模型结构(字符串),如下图所示。</p><p id="506a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mm mn mo lp b">json_identifier."col_name"::col_type as col</code></p><pre class="ju jv jw jx fd lo lp lq bn lr ls bi"><span id="a580" class="lt kl hi lp b be lu lv l lw lx"># helpers/writer.py<br/><br/>def get_dbt_formatted_sql(data: dict, json_col_id: str) -&gt; str:<br/>    rows = [<br/>        f'{json_col_id}."{col}"::{data[col]} as {col}'<br/>        for col in data<br/>        if col != "_extract_timestamp"<br/>    ]<br/>    output = ",\n".join(rows)<br/>    output += f',\n{json_col_id}."_extract_timestamp"::timestamp as _extract_timestamp'<br/>    return output</span></pre><h2 id="f64f" class="ly kl hi bd km lz ma mb kq mc md me ku jg mf mg kw jk mh mi ky jo mj mk la ml bi translated">主脚本</h2><p id="d87f" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">我们可以直接运行这个脚本来为嵌套的数据表生成dbt模型。脚本执行以下操作。</p><ul class=""><li id="09bc" class="mp mq hi iz b ja jb jd je jg mr jk ms jo mt js mu mv mw mx bi translated">从表格中选择第一行</li><li id="8bd3" class="mp mq hi iz b ja my jd mz jg na jk nb jo nc js mu mv mw mx bi translated">解析它的列名和数据类型</li><li id="d3c0" class="mp mq hi iz b ja my jd mz jg na jk nb jo nc js mu mv mw mx bi translated">生成dbt模型输出</li><li id="5ea0" class="mp mq hi iz b ja my jd mz jg na jk nb jo nc js mu mv mw mx bi translated">将输出写入文本文件</li></ul><pre class="ju jv jw jx fd lo lp lq bn lr ls bi"><span id="cfde" class="lt kl hi lp b be lu lv l lw lx"># ./script.py<br/><br/>import sys<br/>from helpers.connection import get_engine<br/>from helpers.parser import get_parsed_data<br/>from helpers.writer import get_dbt_formatted_sql<br/><br/>SCHEMA_PREFIX = "my_aws_schema"<br/>JSON_PREFIX = "json_identifier"<br/><br/><br/>def main():<br/>    global SCHEMA_PREFIX<br/>    global JSON_PREFIX<br/><br/>    table = sys.argv[1]<br/><br/>    try:<br/>        SCHEMA_PREFIX = sys.argv[2]  # if 2nd argument is passed, it is schema!<br/>    except:<br/>        print(f"pre-defined schema is =&gt; {SCHEMA_PREFIX}")<br/><br/>    try:<br/>        SCHEMA_PREFIX = sys.argv[<br/>            3<br/>        ]  # if 3rd argument is passed, it is JSON column identifier!<br/>    except:<br/>        print(f"pre-defined JSON identifier is =&gt; {JSON_PREFIX}")<br/><br/>    engine = get_engine()<br/><br/>    res = engine.execute(f"select * from {SCHEMA_PREFIX}.{table} limit 1;").fetchone()[<br/>        0<br/>    ]<br/><br/>    column_types = get_parsed_data(res)<br/><br/>    with open("raw_data.json", "w+", encoding="utf-8") as file:<br/>        file.write(str(res))<br/><br/>    with open("raw_data_column_types.json", "w+", encoding="utf-8") as file:<br/>        file.write(str(column_types))<br/><br/>    with open("dbt_model.txt", "w+", encoding="utf-8") as file:<br/>        model_txt = get_dbt_formatted_sql(column_types, JSON_PREFIX)<br/>        file.write(model_txt)<br/><br/>    print("Successfully completed!")<br/>if __name__ == "__main__":<br/>    main()</span></pre><p id="e210" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以像下面这样运行脚本。</p><p id="119e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mm mn mo lp b">python script.py table_name schema_name nested_identifier</code></p><p id="f7c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它将生成一个名为<code class="du mm mn mo lp b">dbt_model.txt</code>的输出文件。</p><pre class="ju jv jw jx fd lo lp lq bn lr ls bi"><span id="a077" class="lt kl hi lp b be lu lv l nd lx">nested_identifier."col1"::timestamp as col1,<br/>nested_identifier."col2"::varchar as col2,<br/>nested_identifier."col3"::timestamp as col3,<br/>nested_identifier."_extract_timestamp"::timestamp as _extract_timestamp # col4</span></pre><p id="21d6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，您只需要将输出复制并粘贴到您的select语句中。显然，您可以改进脚本来生成select语句。我把它留给你，🥲</p><h1 id="e1a1" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后</h1><p id="0f07" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">希望它能帮助您有一个生成自动dbt模型的想法，并让您免于一行一行地嵌套数据。</p><p id="5399" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">诚挚的问候</p></div></div>    
</body>
</html>