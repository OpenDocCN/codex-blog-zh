<html>
<head>
<title>Dynamic programming: how to solve the Longest Common Subsequence problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态规划:如何解决最长公共子序列问题</h1>
<blockquote>原文：<a href="https://medium.com/codex/dynamic-programming-how-to-solve-the-longest-common-subsequence-problem-88f2110e12c8?source=collection_archive---------3-----------------------#2021-10-13">https://medium.com/codex/dynamic-programming-how-to-solve-the-longest-common-subsequence-problem-88f2110e12c8?source=collection_archive---------3-----------------------#2021-10-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="de77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文描述了最长公共子序列问题，并推导和分析了解决该问题的算法。</p><p id="918f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最长公共子序列问题在许多领域都有应用，包括版本控制。例如，给定两个文本A和B(由单词序列表示),使得B是A的更新版本，从B中寻找保持不变和被修改的摘录归结为寻找A和B的最长公共子序列。</p><p id="e35e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图说明了上一个示例。突出显示的单词是最长公共子序列的一部分。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/4005b017f78d05444f8e738b60d06736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GdKDLzzUnThBmiIpZVPf_g.png"/></div></div></figure><p id="0b59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更正式地说，我们将大小分别为<em class="jp"> N </em>和<em class="jp"> M </em>的序列<em class="jp"> S </em>和<em class="jp">S’</em>的公共子序列定义为严格递增序列<em class="jp"> X </em>，其值在[1，…，<em class="jp">N</em>×[1，…，<em class="jp"> M </em>中，使得对于<em class="jp">的所有值(<em class="jp"> i </em>，<em class="jp"> j </em><em class="jp">增加</em>正是在<em class="jp"> a </em> ≤ <em class="jp"> c </em>和<em class="jp"> b </em> ≤ <em class="jp"> d </em>时，使用(<em class="jp"> a </em>，<em class="jp"> b </em> ) ≤ ( <em class="jp"> c </em>，<em class="jp"> d </em>)定义的关系。</em></p><p id="da05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一种简单的方法是检查第一个序列的所有可能的子序列，并检查它们是否也能在第二个序列中找到。某个序列<em class="jp"> S </em>的子序列与<em class="jp"> S </em>的索引子集一样多，即2个<em class="jp"> ⁿ </em>，其中<em class="jp"> n </em>是<em class="jp"> S </em>的长度。因此，我们需要ω(2<em class="jp">ⁿ</em>)的时间来解决这个问题——但幸运的是，我们可以使用动态编程做得更好。</p><p id="158d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在整篇文章中，我将使用缩写<em class="jp"> LCS </em>来表示<em class="jp">最长公共子序列</em>。</p><h1 id="56c5" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">LCS问题的最优子结构</h1><p id="7116" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">本节将展示我们如何推导出一个递归关系，以较小实例的解来表达LCS问题实例的解。</p><p id="123e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们考虑两个序列:尺寸为<em class="jp"> s </em>的<em class="jp"> S </em>和尺寸为<em class="jp"> t </em>的<em class="jp"> T </em>。我们让<strong class="ih hj"> Opt( <em class="jp"> a </em>，<em class="jp"> b </em> ) </strong>表示S[1]的LCS的长度..a]和T[1..b】。</p><p id="5d82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<em class="jp"> s </em> = 0或者<em class="jp"> t </em> = 0那么<em class="jp"> S </em>和<em class="jp"> T </em>正好有一个LCS，就是空序列。因此，对于所有的<em class="jp"> a </em>，LCS长度为<strong class="ih hj"> Opt(0，<em class="jp"> a </em> ) = Opt( <em class="jp"> a </em>，0) = 0 </strong>。</p><p id="1076" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设现在<em class="jp"> s </em>和<em class="jp"> t </em>都是正的。我们将考虑两种情况:要么是<em class="jp">S</em>[<em class="jp">S</em>]=<em class="jp">T</em>[<em class="jp">T</em>]，要么是S[s] ≠ T[t]。</p><p id="8c33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<em class="jp">S</em>[<em class="jp">S</em>]=<em class="jp">T</em>[<em class="jp">T</em>，那么<em class="jp"> S </em>和<em class="jp"> T </em>的每个LCS都是通过将(<em class="jp"> s </em>，<em class="jp"> t </em>)附加到<em class="jp">S</em>【1】的任意一个LCS上而构造的..<em class="jp"> s </em> -1】和<em class="jp"> T </em> [1..<em class="jp"> t </em> -1】。因此，<strong class="ih hj"> Opt( <em class="jp"> s </em>，<em class="jp"> t </em> ) = Opt( <em class="jp"> s </em> -1，<em class="jp"> t </em> -1) + 1 </strong>。</p><blockquote class="kt ku kv"><p id="5c0d" class="if ig jp ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><strong class="ih hj">证明:<br/> </strong>我们通过证明左侧小于等于右侧，反之，右侧小于等于左侧来证明等式。</p><p id="f0ae" class="if ig jp ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><strong class="ih hj">证明Opt(s-1，t-1) + 1 ≤ Opt(s，t) | </strong>设X(长度为X)是S[1]的LCS..s-1]和T[1..t-1】。那么由X'[i] = X[i]定义的长度为x + 1的序列X '当i ≤ x，X'[x + 1] = (s，T)是S和T的公共子序列，证明x + 1 ≤ Opt(s，T)。代入x，我们得到Opt(s-1，t-1) + 1 ≤ Opt(s，t)</p><p id="3184" class="if ig jp ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><strong class="ih hj">证明Opt(s，t) ≤ Opt(s-1，t-1) + 1 | </strong>设Y(长度为Y)是S和t的LCS</p><p id="4703" class="if ig jp ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">(1)如果Y[y] = (s，t)那么Y' = Y[1..y-1]是S[1]的公共子序列..s-1]和T[1..t-1】。y '的长度为y - 1 = Opt(s，t) - 1。这证明了Opt(s，t) - 1 ≤ Opt(s-1，t-1)。</p><p id="4561" class="if ig jp ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">(2)如果Y[y] = (u，v)且u ≠ s且v ≠ t，那么我们可以通过将(s，t)附加到Y上来定义长度为y + 1的Y*，从而与Y的最优性相矛盾。</p><p id="fb41" class="if ig jp ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">(3)若Y[y] = (u，t)其中u ≠ s(分别为Y[y] = (s，u)其中u ≠ t)则S[u] = S[s](分别为。T[u] = T[t])，根据公共子序列的定义。因此，我们可以用s (resp)代替u。用t)并以(1)结束。</p><p id="d75b" class="if ig jp ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">因此，Opt(s，t) = Opt(s-1，t-1) + 1。</p><p id="d8cb" class="if ig jp ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">— <em class="hi">这就完成了证明。</em></p></blockquote></div><div class="ab cl kz la gp lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hb hc hd he hf"><p id="6c61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<em class="jp">S</em>[<em class="jp">S</em>≦<em class="jp">T</em>[<em class="jp">T</em>]那么S和T的LCS与<em class="jp">S</em>【1..<em class="jp"> s </em> - 1】和T，或者与S和<em class="jp"> T </em> [1】的LCS相同..<em class="jp"> t </em> - 1】。因此，<strong class="ih hj"> Opt( <em class="jp"> s </em>，<em class="jp">t</em>)= max { Opt(<em class="jp">s</em>-1，<em class="jp"> t </em>)，Opt(s，t-1)} </strong>。</p><blockquote class="kt ku kv"><p id="943c" class="if ig jp ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated"><strong class="ih hj">证明大纲:</strong></p><p id="9f8d" class="if ig jp ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">(1)如果Y是S[1]的公共子序列..s-1]和T那么Y也是S和T的公共子序列，所以Opt(s-1，t) ≤ Opt(s，T)。</p><p id="2380" class="if ig jp ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">(2:证明S和T的LCS是<em class="hi"> S </em>的LCS[1..<em class="hi"> s </em> - 1]和T或S和<em class="hi"> T </em> [1..<em class="hi"> t </em> - 1】)设X(长度为X)是S和t的LCS，如果x = 0，证明是平凡的，所以我们假设X是非空的。设u，v := X[x]。假设暗示(u，v)≦(s，t)。假设u ≠ s(不失一般性，如果v ≠ t产生相同的结果，类似的论证)。那么X是S[1]的公共子序列..s - 1]和t .因此，x ≤ Opt(s-1，t)。</p><p id="072e" class="if ig jp ih b ii ij ik il im in io ip kw ir is it kx iv iw ix ky iz ja jb jc hb bi translated">由(1)得出Opt(s，t) = max{Opt(s-1，t)，Opt(s，t-1)}，证明X是[1]的LCS..s-1]和t。这就完成了证明。</p></blockquote><p id="1063" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用下面的循环来总结最后几段:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lg"><img src="../Images/d456a721e3d0b2f5deedf55ab9151fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jFBVMawCd9m24jtPvga4w.png"/></div></div></figure><h2 id="83b0" class="lh jr hi bd js li lj lk jw ll lm ln ka iq lo lp ke iu lq lr ki iy ls lt km lu bi translated">编写解决方案</h2><p id="34a2" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">在不使用动态规划的情况下，使用我们之前推导的公式计算两个序列的LCS长度，在最坏的情况下，将需要指数级的许多步骤。这是因为我们需要进行两次递归调用，一次是计算Opt( <em class="jp"> i </em> -1，<em class="jp"> j </em>)，另一次是计算Opt( <em class="jp"> i </em>，<em class="jp"> j </em> -1)，直到两个索引中的一个都为零。</p><p id="561a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于实际上只需要计算<em class="jp"> s </em> * <em class="jp"> t </em>个不同的值(其中<em class="jp"> s </em>和<em class="jp"> t </em>是序列的长度)，动态编程允许我们在多项式时间内解决这个问题。</p><p id="5d7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是计算两个序列的LCS长度的伪代码:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lv"><img src="../Images/fe0c81b9de10496805336443fefd1436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIdq2G0qnEShdk-SZ7b2Iw.png"/></div></div></figure><p id="ae06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次递归调用都会找到<em class="jp">S</em>【1】的最长公共子序列..<em class="jp"> i </em>和<em class="jp">T</em>【1..<em class="jp"> j </em>。当<em class="jp"> i </em> = s并且<em class="jp"> j </em> = <em class="jp"> t </em>时，即当我们已经计算了Opt( <em class="jp"> S </em>，<em class="jp"> T </em>)时，循环终止。请注意，索引从1开始。</p><p id="753a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于主循环在线性时间内运行，因此算法在θ(<em class="jp">ST</em>)时间内运行，并使用θ(<em class="jp">ST</em>)空间。</p><p id="7ffe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，当两个输入序列是S = (1，6，3，5，10，6，8，9)和T = (6，10，5，8，9)时，该算法逐行然后逐列构建以下矩阵:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/135b02d7310203ac44b88f024c9f77b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eNn9W_g0feJ9OOg-ap_YZg.png"/></div></div></figure><p id="2577" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一个LCS。它的长度为4，对应于值(6，5，8，9)。</p><h2 id="c950" class="lh jr hi bd js li lj lk jw ll lm ln ka iq lo lp ke iu lq lr ki iy ls lt km lu bi translated">构建LCS</h2><p id="50a2" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">如果我们不能明确地计算LCS，寻找最大公共子序列长度可能不是很有用。正如我们之前研究的问题一样，这可以在不改变渐近运行时间和空间复杂度的情况下完成。我们将维护一个额外的二维数组<em class="jp"> A </em>来记录我们如何构建LCS。对于所有指数I，j，A[i，j]表示S[: i]和T[: j]的LCS是否:</p><ol class=""><li id="d922" class="lw lx hi ih b ii ij im in iq ly iu lz iy ma jc mb mc md me bi translated">通过将(I，j)加到S[1]的子序列中来构造..i-1]和T[1..j-1]或</li><li id="4d87" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated">与S[1]的子序列相同..i-1]和T[1..j]或</li><li id="cf52" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated">与S[1]的子序列相同..i]和T[1..j-1】。</li></ol><p id="8fcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了保持直观，我们在第一种情况下将A[i，j]设为<code class="du mk ml mm mn b">ABOVE-LEFT</code>，在第二种情况下设为<code class="du mk ml mm mn b">ABOVE</code>，在第三种情况下设为<code class="du mk ml mm mn b">LEFT</code>。</p><p id="cb43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这给出了以下实现(修改后的行突出显示):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lv"><img src="../Images/208d112fad16677595d685f4f52afeb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0PwmdQs6c6A6-lYA006Ww.png"/></div></div></figure><p id="38db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">元素<em class="jp"> S </em> [ <em class="jp"> i </em> ](或者等价地，<em class="jp"> T </em> [ <em class="jp"> t </em> ])是LCS的一部分的唯一情况是第一种情况，即当A[i，j] = <code class="du mk ml mm mn b">ABOVE-LEFT</code>时。</p><p id="b52b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这使我们能够从数组<em class="jp"> A </em>构造一个LCS，如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lv"><img src="../Images/4499e536db14dfe2d71a42a72170fb0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dydqL8yBgZoAR2UxBxIEMA.png"/></div></div></figure></div></div>    
</body>
</html>