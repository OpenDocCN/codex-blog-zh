<html>
<head>
<title>Synchronous Communication — Queries &amp; Cache (Part 1/3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同步通信—查询和缓存(第1/3部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/synchronous-communication-queries-cache-644ffcecf1d9?source=collection_archive---------7-----------------------#2022-10-24">https://medium.com/codex/synchronous-communication-queries-cache-644ffcecf1d9?source=collection_archive---------7-----------------------#2022-10-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6d91" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这篇文章围绕查询和CQRS为实现缓存策略奠定了基础。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8ee4407a029c3c2a8c4c75da7218c9ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WOykEnywlT5U3nkF"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jn" href="https://unsplash.com/@hadijasaidi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈迪贾·赛义迪</a>拍摄</figcaption></figure><p id="dcc7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我之前的一篇<a class="ae jn" rel="noopener" href="/codex/asynchronous-communicaiton-how-much-information-do-we-pack-in-events-to-reduce-coupling-ef5749e01da8">文章</a>中，我写道，如果我们能够实现一个发布者-订阅者的通信模型，并且发布者能够将所有关于状态变化的必要信息打包到事件中，那么订阅者就有了所有可以操作的数据，并且可以避免查询。虽然发布-订阅模型通常通过将应用程序的复杂性转移到基础设施中来产生高吞吐量、可伸缩的系统，但是我们不能在所有情况下都使用发布-订阅模型。</p><p id="11cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">系统确实需要发出读取或搜索请求，因为它更好地模拟了用例，或者因为它很简单。这种获取数据的请求称为查询。</p><h2 id="3413" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated"><strong class="ak">读写路径的分离有什么帮助？</strong></h2><p id="48f2" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">任何处理数据存储的软件既可以保持更新和读取数据的相同路径，这在CRUD风格的数据访问操作中很常见，也可以将数据更新操作与数据读取操作分开。<strong class="jq hj">这种简单的分离被称为命令查询责任分离模式(CQRS)。命令负责改变状态，查询负责读取状态。</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/f870ea121233bea1e164e5a295576678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0O5ogjcB1AZR2UX6hw3YUw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">CQRS —数据更新和读取的分离</figcaption></figure><p id="997c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">出于学术兴趣，这里有几篇来自<a class="ae jn" href="https://web.archive.org/web/20101223100708/http://codebetter.com/gregyoung/2010/02/16/cqrs-task-based-uis-event-sourcing-agh/" rel="noopener ugc nofollow" target="_blank">2010</a>&amp;2012<a class="ae jn" href="https://web.archive.org/web/20160729165044/https://goodenoughsoftware.net/2012/03/02/cqrs/" rel="noopener ugc nofollow" target="_blank">2013</a>的文章，作者是<strong class="jq hj">格雷戈里·杨(他创造了CQRS这个术语)</strong>，他在文章中解释说，CQRS只是为了阅读和写作的目的，通过创建两个独立的对象来分离关注。并澄清了围绕CQRS的种种神话，这些神话往往使它看起来比预想的更复杂。</p><p id="f550" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该模式简单明了，但是它<strong class="jq hj">开启了在查询或更新数据时拥有不同认知和不对称需求的思维模式。随着这种心态应用于不同的环境，它开始发展成不同的形式。</strong></p><p id="a715" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，在域驱动设计的<strong class="jq hj">上下文中，可能一群域对象形成一个集合，并且必须一起更新以保持集合的完整性，尽管在读取时可能需要简单地从数据存储中获取一个或几个域对象。</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/a1ce565c36f773600f1ede99a0e07f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKc3v3XmfFdiKYG12jiJFw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在查询仅读取特定域对象时维护聚合边界的命令</figcaption></figure><p id="46d1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">或者在关系数据库的上下文中，其中读取路径可能使用构建在数据表之上的视图。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lm"><img src="../Images/f9dacabce812a03f269a96203cd6607c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EgxVuSXFrgWlFJmqF2h1XQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">RDBMS-命令在查询从同一物理数据库的物化视图中读取数据时更新数据表。</figcaption></figure><p id="8b90" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">或者当读取数据存储是单独的物理节点时，用于高效读取数据存储、信息隐藏或者用于不对称读取缩放要求(或者它可以是简单的读取副本)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ln"><img src="../Images/5e033fa67a19229a598411521db7e0f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OjHgQzxX_onDqaB49oxTvg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">独立物理数据存储上的CQRS</figcaption></figure><p id="51fd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">或者另一种可能性是查询数据存储建立在事件之上，而不是建立在主数据存储之上。就像这个Udi达汗的<a class="ae jn" href="https://udidahan.com/2009/12/09/clarified-cqrs/" rel="noopener ugc nofollow" target="_blank">例子</a> —</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lo"><img src="../Images/9730f17c2c0b5faf877e5a0c3496dcd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQSAmoh_ZA-E5Sjp3busRA.png"/></div></div></figure><ol class=""><li id="23d3" class="lp lq hi jq b jr js ju jv jx lr kb ls kf lt kj lu lv lw lx bi translated">发送命令来更新状态。</li><li id="76b8" class="lp lq hi jq b jr ly ju lz jx ma kb mb kf mc kj lu lv lw lx bi translated">数据库中的状态被更新，并且事件被发布。</li><li id="f9e6" class="lp lq hi jq b jr ly ju lz jx ma kb mb kf mc kj lu lv lw lx bi translated">查询存储(在本例中是一个缓存)得到更新。</li></ol></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="64a4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">根据读取模型的设计，无论是基于CRUD的数据访问还是分叉的CQRS，都有可能应用几种缓存策略中的一种。在下一篇文章中，我将讨论缓存。</p><p id="9e19" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">链接到<a class="ae jn" rel="noopener" href="/@kapoorabhinav/synchronous-communication-queries-cache-c91124a0aad0">下一部分</a></p><p id="15b1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">学分<a class="ae jn" href="https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs" rel="noopener ugc nofollow" target="_blank">https://learn . Microsoft . com/en-us/azure/architecture/patterns/cqrs</a></p></div></div>    
</body>
</html>