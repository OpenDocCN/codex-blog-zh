<html>
<head>
<title>Python Integration Tests: docker-compose vs testcontainers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python集成测试:docker-compose vs . test containers</h1>
<blockquote>原文：<a href="https://medium.com/codex/python-integration-tests-docker-compose-vs-testcontainers-94986d7547ce?source=collection_archive---------1-----------------------#2021-08-09">https://medium.com/codex/python-integration-tests-docker-compose-vs-testcontainers-94986d7547ce?source=collection_archive---------1-----------------------#2021-08-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e6aa954d5c09dde3b86f954109630025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HRZI7G_BBoU9oCsxwyYhw.jpeg"/></div></div></figure><p id="c755" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在一家成长中的初创公司开发新功能可能是一个真正的挑战，尤其是当你开始在那家公司担任软件开发人员时。在这篇文章中，我将尝试分享我的最后一次经历，它涉及了很多原则，如TDD、单元测试和集成测试。让我们开始吧。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="761b" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">什么是集成测试？</h1><p id="711c" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">有一个著名的软件测试金字塔，从单元测试到集成(或端到端，“E2E”)测试，中间的步骤被称为“集成测试”。</p><p id="d190" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">顺便说一下，在Spotify，他们改变了这种传统的方法<a class="ae ky" href="https://engineering.atspotify.com/2018/01/11/testing-of-microservices/" rel="noopener ugc nofollow" target="_blank">，用六边形(“蜂巢”)</a>取代了金字塔，专注于集成测试。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/857e98f535ca52b9c3e936c272224025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgRmUmZh2fUl5zkLOQOcrg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">传统的测试金字塔:归功于https://engineering.atspotify.com/的<a class="ae ky" href="https://engineering.atspotify.com/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/7576022a75e4435b90d67b0af6cfbdaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hBX_5lNmiF8L5zDT6s5vKw.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">蜂巢测试的功劳归于https://engineering.atspotify.com/<a class="ae ky" href="https://engineering.atspotify.com/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="e27d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是什么是集成测试，我们为什么需要它？我不会在这个定义上花太多时间，网上有大量的文献可以给出比我更好的答案……但是让我们举个例子来说明这两种测试的区别。</p><p id="4725" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来看两个函数，一个用于在数据库中插入新行，另一个将调用它:</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="6fdb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有一个<strong class="is hj">插入函数</strong>，它可能是存储库的一部分。它将在数据库会话中插入一个新行，并返回新插入行的id。</p><p id="324a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有一个<strong class="is hj"> create_new_item </strong>函数，它将创建一个新项目，向它的一个属性添加一个值，并调用<strong class="is hj"> insert </strong>函数。</p><p id="3e0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了测试这两个函数的行为，我们有两种方法:</p><p id="7b2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1)单元测试</p><p id="919b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们通过只测试create_new_item函数来实现这一点(因为第二个函数将是集成测试的一部分)。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="eff8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们简单地创建了一个新条目，通过将它作为参数传递给我们的<strong class="is hj"> create_new_item </strong>函数来给它命名。我们断言返回的项目具有与我们传递给<strong class="is hj"> create_new_item </strong>函数相同的<em class="ll"> name </em>属性。</p><p id="ebc0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2)集成测试</p><p id="87c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">前面的单元测试只关注于作为项目类实例的项目创建。但是它没有测试数据库中实际的行创建:也许我们有一些SQL约束，外键，类型不匹配，等等…我们需要测试。</p><p id="20db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们当然可以有一个<a class="ae ky" href="https://www.cosmicpython.com/book/chapter_02_repository.html#_building_a_fake_repository_for_tests_is_now_trivial" rel="noopener ugc nofollow" target="_blank">假存储库</a>来测试新项目的插入。这将使我们的单元测试更上一层楼……但是这仍然被认为是一个单元测试。</p><p id="8320" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们有一个定义了模式的真实数据库实例，并且我们在测试中写入它，那么<strong class="is hj">这是一个集成测试。</strong>因为当它与架构的第三方组件通信时，它将测试我们的应用程序行为。这第三部分将是<em class="ll">产品的一个集成部分</em>。</p><p id="fe55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们编码吧。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="9fb1" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">设置我们的环境</h1><p id="8fc8" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">我们将在本文中讨论的两种解决方案是容器化的解决方案。换句话说，在这两个版本中都需要Docker。所以确保你的系统上安装了docker(如果没有，并且<a class="ae ky" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">你不知道如何安装它以及它是什么… </a>)。</p><p id="396e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于第一个解决方案，您将需要“docker-compose”(尽管我们将看到我们可以使用普通的docker来实现该解决方案，但是对于所有比“docker run <image_name>”更多的命令来说，compose总是一种更容易的方式</image_name></p><p id="75e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于第二个解决方案，您将需要用于python 的<a class="ae ky" href="https://github.com/testcontainers/testcontainers-python" rel="noopener ugc nofollow" target="_blank"> testcontainers库，它将是您项目的依赖项的一部分(“requirement.txt”或“pipfile”或您喜欢的任何依赖项工具)。</a></p><p id="3024" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不需要精确到你将需要Python！我在这里使用3.9版本，但3.5+应该也可以。</p><p id="3cad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还需要Pytest库，它将被用作我们的测试框架(而不是内置的unittest库，主要是因为它提供的fixtures特性)。</p><p id="a2f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦所有这些都安装完毕:让我们开始吧！</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="e0cd" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">快速代码回顾:我们在测试什么！(可选但推荐)</strong></h1><p id="028c" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">如果您想关注本文的核心(docker-compose和testcontainers库之间的比较)，您可以跳过这一部分，跳到下一部分，从docker-compose解决方案开始。</p><p id="e808" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章的所有代码都可以在这里找到<a class="ae ky" href="https://github.com/jossefaz/python-integration-test" rel="noopener ugc nofollow" target="_blank"/>。这个库有两个分支，一个用于<strong class="is hj"><em class="ll">docker-compose</em></strong>示例，另一个用于<strong class="is hj"><em class="ll">test containers</em></strong>示例</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="a142" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们应用程序的入口。我们有<strong class="is hj"> setup_app </strong>函数，它将从SQL Alchemy库中调用一个<strong class="is hj">元数据</strong>实例。</p><p id="860d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一个也需要一个数据库引擎。</p><p id="6673" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们分解一下<strong class="is hj">元数据</strong>和<strong class="is hj">引擎</strong>对象。</p><p id="eb07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae ky" href="https://docs.sqlalchemy.org/en/14/core/metadata.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">元数据</strong> </a>对象将包含所有的模式声明，它的主要优点是<a class="ae ky" href="https://www.cosmicpython.com/book/chapter_02_repository.html#_inverting_the_dependency_orm_depends_on_model" rel="noopener ugc nofollow" target="_blank">没有与ORM </a>紧密耦合。</p><p id="967a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们的元数据声明。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="32e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将模式声明为一个表对象，并将其附加到元数据实例。</p><p id="3f0b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们来声明一个<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/core/engines.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">引擎</strong> </a> <strong class="is hj">。</strong></p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="5b07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用SQL Alchemy中的<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/core/engines.html?highlight=create_engine#sqlalchemy.create_engine" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">create _ engine</strong></a>函数。这个需要一个数据库URL。</p><p id="5e34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">“build _ URL”函数对于理解本文的核心非常重要，因为它将是我们讨论我们正在比较的两种测试方法之间的差异的中心点</strong>。</p><p id="96ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的<strong class="is hj">配置类</strong><strong class="is hj"/>是一个简单的单例实例，有一个get方法。get方法将从一个简单的JSON文件加载的配置对象中检索元素。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="7675" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">SingletonMeta超出了本文的范围，但是您仍然可以在源代码中查看它。它基本上确保了我们每次调用这个类时都引用相同的内存地址…</p><p id="1052" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们关注核心业务:在数据库中创建一个新行。</p><p id="fb19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们将在我们的<a class="ae ky" href="https://www.cosmicpython.com/book/chapter_02_repository.html" rel="noopener ugc nofollow" target="_blank">存储库</a>中创建我们的插入方法。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="112a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的<strong class="is hj">插入</strong>函数接收一个名称和一个会话对象。</p><p id="15e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们调用会话的execute方法，传递生成的插入查询。</p><p id="3adf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们返回新创建项目的<strong class="is hj"> lastrowid </strong>属性<strong class="is hj"> </strong>:这个新属性直到我们调用会话的commit方法才会被注册。F <a class="ae ky" href="https://www.cosmicpython.com/book/chapter_02_repository.html#_what_is_the_trade_off" rel="noopener ugc nofollow" target="_blank">遵循存储库模式</a>的原则，执行提交动作确实是调用者的责任。</p><p id="c2d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们将创建一个非常简单的服务函数，就像我们在介绍中所做的那样。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="aa65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们用数据库引擎打开会话对象。我们从存储库中调用插入函数。我们提交并最终返回新的行id。</p><p id="039d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们终于准备好编写集成测试了！当然，我们之前应该已经写了一些单元测试，但是我们还是想把这篇文章的重点放在集成测试上。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="f92d" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">如何执行集成测试，docker-compose方式</h1><p id="35c7" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">让我们编写我们的第一个集成测试。我们将在数据库中插入一行，并通过检索来确保它是被插入的。</p><p id="4aed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这一部分，我们将利用<a class="ae ky" href="https://docs.pytest.org/en/6.2.x/fixture.html#what-fixtures-are" rel="noopener ugc nofollow" target="_blank">py test fixture</a>。</p><p id="c7dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">夹具是<em class="ll">你准备测试需要的东西</em>(“安排”步骤)，并不直接是你正在测试的东西。它立刻取代了安装和拆卸功能。</p><p id="9511" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们首先创建一些装置来设置一个数据库引擎，该引擎将连接到我们实际的数据库和一个与之通信的会话(我从这里取了这个代码示例<a class="ae ky" href="https://stackoverflow.com/a/58662370/13000695" rel="noopener ugc nofollow" target="_blank">，但是它非常简单):</a></p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="d268" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们这里有三个固定装置。一个基于我们的build_url 函数创建数据库引擎<strong class="is hj">。第二个将基于该引擎创建一个<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/orm/contextual.html" rel="noopener ugc nofollow" target="_blank">范围的会话</a>。最后但同样重要的是，一个将返回(<a class="ae ky" href="https://www.guru99.com/python-yield-return-generator.html#:~:text=Summary%3A-,The%20yield%20keyword%20in%20python%20works%20like%20a%20return%20with,generator%20function%20to%20the%20caller.&amp;text=The%20main%20difference%20between%20yield,single%20value%20to%20the%20caller." rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> yield)的fixture！！</strong> </a> <strong class="is hj"> : </strong>允许在测试套件完成后进行回滚等清理动作<strong class="is hj">)</strong><strong class="is hj">会话</strong>。</strong></p><p id="5c33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我们已经准备好了设备，我们可以在测试中使用它们。Pytest有一种基于名称的依赖注入。只需添加一个与我们的fixture同名的参数，Pytest就会注入它。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="fd90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们用“pytest.mark”来“标记”我们的测试。标记是pytest的另一个非常酷的特性。它允许我们标记我们的测试，然后通过选择一些测试来运行测试套件。</p><p id="106a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在“标记”后添加任何您想要的名称，Pytest将注册它们。现在，我们可以通过运行以下命令来选择集成测试套件:</p><pre class="la lb lc ld fd lm ln lo lp aw lq bi"><span id="99c2" class="lr jw hi ln b fi ls lt l lu lv">pytest -m "integration"</span></pre><p id="99aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而且假设你再加一个类似“create_items”的标记。您可以使用以下命令选择它:</p><pre class="la lb lc ld fd lm ln lo lp aw lq bi"><span id="3d4f" class="lr jw hi ln b fi ls lt l lu lv">pytest -m "integration and create_items"</span></pre><p id="ac8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">多酷啊。！！！</p><p id="8e02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">顺便说一下，您添加的每个自定义标记都应该在一个“pytest.ini”文件中进行注册和解释，该文件可以是:</p><pre class="la lb lc ld fd lm ln lo lp aw lq bi"><span id="c963" class="lr jw hi ln b fi ls lt l lu lv">[pytest]<br/>markers =    <br/>    integration : run all integration tests<br/>    create_items : tests related to the items creations</span></pre><p id="b316" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在你得到了越来越多的测试记录！</p><p id="8914" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，我们把注意力放在其他台词上。</p><p id="8021" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们使用“db_session”设备。接下来，我们调用项目服务的create_item函数。它应该在数据库中插入该行。</p><p id="8352" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们使用db_session检索新插入的行，并断言它与给定的行同名。</p><p id="80b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们运行:</p><pre class="la lb lc ld fd lm ln lo lp aw lq bi"><span id="e78b" class="lr jw hi ln b fi ls lt l lu lv">pytest -m "integration"</span></pre><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/b55cf739ba90c7ebfd85a1fba1fcf9d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZlSaAV_pgrG2rXV1_Tb-Q.png"/></div></div></figure><p id="fa78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">哦，上帝…为什么我们的数据库没有连接…因为我们还没有一个数据库！</p><p id="ac9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但问题是:我如何得到一个测试DB？？</p><p id="4edb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，因为如果你读了这几行，你会发现它们都是关于如何获得外部组件(如数据库)来在“真实”环境中测试我们的应用程序。</p><p id="f628" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，Bob会说(我对这个名字没有任何异议):“这里没有什么太复杂的…我将在我的计算机上安装MySQL，我将把我的连接字符串写入我的配置文件并运行我的测试”。是的。没事的。这没什么不对。但是如果你需要一个更复杂的应用作为第三方呢？那么CI渠道呢？(运行在类似云的GitHub actions上的持续集成管道…那里没有数据库！).</p><p id="bdcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不，这绝对不是理想的方式。在我以前的工作中，有一个巨大的“测试数据库服务器”,每个人都将其用作集成测试的组件……但你猜怎么着:它被垃圾淹没了，任何人都想负责清理它，因为<em class="ll">聪明的</em>开发人员<strong class="is hj">在生产中使用了它</strong>(不，我不是在开玩笑:完全正确)。</p><p id="dc37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">码头工人来救援了！</p><p id="21bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们当然可以通过键入以下命令来运行普通的docker容器:</p><pre class="la lb lc ld fd lm ln lo lp aw lq bi"><span id="c957" class="lr jw hi ln b fi ls lt l lu lv">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=<!-- -->password<!-- --> -e <!-- -->MYSQL_DATABASE=items -p 3306:3306 <!-- -->-d mysql:tag</span></pre><p id="664e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是这不是真正可维护的，对吗？如果您想要添加一个卷来保存您的数据，该怎么办？</p><pre class="la lb lc ld fd lm ln lo lp aw lq bi"><span id="7fba" class="lr jw hi ln b fi ls lt l lu lv">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=<!-- -->password<!-- --> -e <!-- -->MYSQL_DATABASE=items -p 3306:3306 -v db_data:/var/lib/mysql <!-- -->-d mysql:tag</span></pre><p id="1a91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果允许这个端口呢？好吧，你明白了…改变指挥当然不是最佳方式。所以让我们来看看docker-compose文件。"</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="37f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更清楚了(至少对我来说)。我们将MySQL镜像作为一个名为“DB”的服务来运行。我们给出了一些环境变量，并映射了端口…一切看起来都很好。</p><p id="71ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们跑吧</p><pre class="la lb lc ld fd lm ln lo lp aw lq bi"><span id="54b3" class="lr jw hi ln b fi ls lt l lu lv">docker-compose up</span></pre><p id="129d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们跑吧</p><pre class="la lb lc ld fd lm ln lo lp aw lq bi"><span id="202b" class="lr jw hi ln b fi ls lt l lu lv">pytest -m "integration"</span></pre><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/051fe2d33a08d744ae02b290ce5595b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VyQAVp1qGC7w4hDMkEMRYg.png"/></div></div></figure><p id="b29e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，我们运行了第一个集成测试！太酷了。</p><p id="bb88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不过，这种方法存在一些问题/挑战:</p><p id="70c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1-您现在依赖于docker-compose文件。同样，你总是可以运行一个简单的docker命令，但是正如我们所看到的，它不容易维护。</p><p id="5c45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2-您必须检查您放入环境变量的配置是否与您放入配置文件的配置相同。虽然有很多智能解决方案，但我们在这里提供的简单解决方案却不是这样，您有一个重复的配置源。</p><p id="6d3d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3-在运行测试之前，您需要运行docker-compose命令。你不能只安装你的应用程序并运行“pytest”。因为没有数据库实例，所以它不起作用。</p><p id="b5ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于所有这些点，<strong class="is hj"> testcontainers </strong>库是你的朋友。让我们深入研究一下。</p><h1 id="fd4f" class="jv jw hi bd jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks bi translated">Testcontainers解决方案:用于运行集成测试的内置解决方案。</h1><p id="d06f" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">Testcontainers是一个最初用Java编写的库。原则是将基本的docker命令封装在一个代码API中，直接从测试套件中管理容器。</p><p id="1ac1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在幕后，这个库使用UNIX套接字向docker发送指令，但我们将在几分钟后看到这一点。</p><p id="41d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好消息是python有一个该库的<a class="ae ky" href="https://github.com/testcontainers/testcontainers-python" rel="noopener ugc nofollow" target="_blank">端口。</a></p><p id="7ac0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">他们提供了一个显然<a class="ae ky" href="https://github.com/testcontainers/testcontainers-python#basic-usage" rel="noopener ugc nofollow" target="_blank">非常简单的例子</a></p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="ef0f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，让我们在pytest夹具中试一试。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="9ce7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们用一个“<a class="ae ky" href="https://docs.pytest.org/en/6.2.x/fixture.html#autouse-fixtures-fixtures-you-don-t-have-to-request" rel="noopener ugc nofollow" target="_blank"> autouse </a>参数调用fixture，在所有其他测试之前运行这个fixture。</p><p id="aa4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，希望不再需要“docker-compose”…只需运行</p><pre class="la lb lc ld fd lm ln lo lp aw lq bi"><span id="32d9" class="lr jw hi ln b fi ls lt l lu lv">pytest -m "integration"</span></pre><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/158e7160dd0cda5ea6c246e9cb7dc133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uOra6HHbQBii0P7jgyTeog.png"/></div></div></figure><p id="b5a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的。这显然不起作用。</p><p id="00c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以检查的第一件事是:这个命令至少运行一个MySQL容器吗？</p><p id="efc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们打开一个双窗口终端，通过在docker ps命令上运行watch来检查一下</p><p id="aa77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">开头终结符</p><pre class="la lb lc ld fd lm ln lo lp aw lq bi"><span id="824e" class="lr jw hi ln b fi ls lt l lu lv">watch -n0.1 docker ps </span></pre><p id="0b36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二终端</p><pre class="la lb lc ld fd lm ln lo lp aw lq bi"><span id="3056" class="lr jw hi ln b fi ls lt l lu lv">pytest -m "integration"</span></pre><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/c8ebb677f1ada3d6b4eea41ba77c4ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RdWm0KDviTI9YBriAkDkIw.png"/></div></div></figure><p id="1fba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里没有流动的容器…</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/8db1fa6dfefb822577ae33268264d54c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7bRvF9qXfyTRUWCWtBCIA.png"/></div></div></figure><p id="5a2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">真相就在那里…</p><p id="9571" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看我们的追溯:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/658167a376b1fe4306aa555b00672012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rgQbQwXo40u9YDQDGyd-2A.png"/></div></div></figure><p id="95e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧。都是从那个“从app.app导入app”开始的。Python总是在运行其他任何东西之前首先解析导入。运行也意味着执行文件。如果您还记得，我们的服务器上有这个。py:</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="e550" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的。通过导入应用程序，我们基本上调用了</p><pre class="la lb lc ld fd lm ln lo lp aw lq bi"><span id="cb69" class="lr jw hi ln b fi ls lt l lu lv">metadata.create_all(engine)</span></pre><p id="3ddd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将需要一个数据库引擎来执行从元数据到数据库中实际表的迁移。它需要一个有效的URL(连接到一个真实的数据库实例)。但是您猜对了:由于testcontainers fixture还没有被调用，我们在这一点上仍然没有任何运行的数据库！</p><p id="74d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们删除这个导入，看看它是否改变了什么。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/c24d7a805f4ac0a8d6e316c9e0e451eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WDniKscrFrj_k7YN9JEANA.png"/></div></div></figure><p id="aa27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">耶！！我们有一个流动的容器！</p><p id="abbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是…</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/da749bd6aba2cf024755ff86266ec8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bii_2XB9XQzhqezSOrtcCw.png"/></div></div></figure><p id="e559" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为什么我们的测试又失败了？！</p><p id="e870" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们看一下docker ps的输出，我们可以看到新容器的端口不是我们期望的默认端口，即我们放在配置文件中的端口(3306):</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/927343fccb1e76ea27fe2d74527d01c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*2PSh9YWh81kmwMBprdZVfA.png"/></div></figure><p id="5b83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您重新开始，您可能会注意到每次运行都有不同的端口！</p><p id="3bd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一下testcontainers API，看看我们是否可以将新容器绑定(或者至少公开它)到我们想要的端口。</p><p id="b5c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，我们可以去阅读文档……或者跳到库的源代码中(这是我的首选方式),以便更好地理解这个上下文管理器背后发生的事情:</p><pre class="la lb lc ld fd lm ln lo lp aw lq bi"><span id="828f" class="lr jw hi ln b fi ls lt l lu lv"><em class="ll">with </em>MySqlContainer(MYSQL_DATABASE=db_config.get('database')) <em class="ll">as </em>mysql:<br/>    <em class="ll">yield </em>mysql</span></pre><p id="4ebc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ll">在Pycharm中按Ctrl+B，</em></p><p id="af0a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ll">虚拟代码中的F12</em></p><p id="5281" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ll"> Vi，nano，vim … to " &lt;你的PYTHON ENV&gt;/lib/PYTHON&lt;PYTHON版本&gt;/site-packages/test containers/MySQL . py "</em></p><p id="e5cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你到了那里:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/8ccaac74a97ba5da22d7780f3bcede78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xIt5PRMv6Ct_CYD9zjoBSg.png"/></div></div></figure><p id="7909" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们在这里看到的，没有配置端口的真正选项…现在，如果我们看一下文档，我们知道<strong class="is hj">这是故意的</strong>。</p><p id="3ef9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">来自<a class="ae ky" href="https://www.testcontainers.org/features/networking/" rel="noopener ugc nofollow" target="_blank">的文件</a>:</p><blockquote class="ml mm mn"><p id="847d" class="iq ir ll is b it iu iv iw ix iy iz ja mo jc jd je mp jg jh ji mq jk jl jm jn hb bi translated">从主机的角度来看, Testcontainers实际上在一个随机的空闲端口上公开了这一点。<strong class="is hj">这是为避免端口冲突而设计的</strong>，端口冲突可能会在本地运行软件或并行测试运行之间出现。</p></blockquote><p id="6172" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的。因此，我们需要找到一种方法来更改配置对象，以匹配testcontainers自动生成的这个新端口。</p><p id="2685" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">什么可以使用提供的方法:"<strong class="is hj"> get_connection_url() </strong>"。</p><p id="ceb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，在<strong class="is hj"> db_engine </strong> fixture中，我们可以用从testcontainers获得的url替换我们的<strong class="is hj"> build_url </strong>函数。</p><p id="214e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，我们可以注入<strong class="is hj"> mysql_instance </strong> fixture作为这个<strong class="is hj"> db_engine </strong> fixture的参数。让我们试一试:</p><p id="efe8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们从:</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="9c46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="a359" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，但是测试还是失败了</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/86feb09f3fbf736e9e844bf6be4b12dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mfmJiiVvp_EyCdnJ2auJMw.png"/></div></div></figure><p id="c4f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您还记得，5分钟前我们删除了负责调用元数据迁移的create_app函数。所以有一个DB…那很好。但是没有桌子！</p><p id="ca6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没问题…让我们创建一个新的夹具来为我们执行迁移(<strong class="is hj">剧透</strong>:非常糟糕的主意)。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="ef04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们导入元数据对象，现在我们用<strong class="is hj"> db_engine </strong> fixture执行迁移。</p><p id="fd8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们运行测试…</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/a20752bac38385d7a0f01b633de4fe77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A0TZvba5OmhjwSrU8A6BCw.png"/></div></div></figure><p id="5cc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯。为什么？嗯，这是因为，<strong class="is hj">在插入函数</strong>中，我们称引擎……但是<strong class="is hj">不是同一个</strong>。如果你记得:</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="c8be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们从依赖于“build_url”函数的DB文件夹中导入引擎。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="0bea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">嗯，我们可以解耦create_engine调用，让它接收URL作为参数…但是我们必须在测试中修补这个调用，注入我们从testcontainers接收的全新URL…好的！这不是我们想要的。我告诉过你…这是个坏主意。</p><p id="e9e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以修改配置对象，并在那里注入我们从testcontainers获得的新配置。</p><p id="6cc7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们没有在测试中执行迁移<em class="ll">(糟糕的想法…真的)，而是将迁移保持在应用程序责任级别。</em></p><p id="5c5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将创建一个简单的函数来改变数据库的配置。因为我们的配置类是单例的，每次函数调用它时，它将返回相同的配置(而不是从配置文件中初始化它)。所以如果我们改变它，它就会“处处”改变它！</p><p id="490b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们试一试:</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="5cbe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们根据testcontainers为我们“决定”的内容来更新我们的配置。让我们开始测试吧！</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/97b1f8d4f9308e2df8ee449cd4926f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oBwQWAoZVj6pO0kdR9IUMA.png"/></div></div></figure><p id="f8bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">哦，别这样！！！为什么？</p><p id="7429" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是因为我们的db_engine文件。再看一分钟:</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="f77c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从我们的conftest.py中，我们导入了“build_url ”,以便将它作为一个附件……这是一个坏主意！流程如下:</p><p id="6fce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">导入数据库引擎。=&gt;</p><p id="ffba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">执行" engine = create _ engine(build _ URL())" = &gt;</p><p id="e359" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">呼叫配置单例= &gt;</p><p id="6ee9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">获取URL(基于未更新的配置)=&gt; <strong class="is hj">将错误的URL绑定到引擎。</strong></p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="b229" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为python解释器在所有语句之前解析imports语句……所以文件被执行，引擎在它被更新之前从配置类获得它的URL！</p><p id="726a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个其他调用将返回绑定到第一个URL(而不是更新后的URL)的同一个引擎。</p><p id="fc3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们必须将引擎封装在一个函数中(并替换对该函数的每次调用)。当然有更好的方法，我们可以创建一个智能类来管理我们的引擎，并通过检查一种DB URL注册表来避免对该函数的不必要的调用…但你应该明白。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="3507" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然也要把所有的“引擎”调用都改成“get_engine()”。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="8543" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，我们再跑一次…</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/665c218998c70b250398a0ffa0389719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e_uTFVzuvpQz6yHnou4x2w.png"/></div></div></figure><p id="678f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">芜湖！它工作了。我们使用测试容器库运行我们的第一个集成测试。</p><p id="dcf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这并不像例子中描述的那么简单，但是我们做到了。</p><p id="98ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最酷的事情是你现在可以完全控制你的MySQL实例容器了！你可以停止它，重新加载它，亲吻它…所有这一切都来自你的代码库。</p><p id="94d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你也不需要“docker-compose”这样的第三方脚本。因为testcontainers是一个内置的解决方案，所以您现在需要做的就是克隆您的存储库，确保您的机器上安装了docker，并运行“pytest”。</p><p id="efb9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是testcontainers库的真正意义所在。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="5270" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结论</h1><p id="b31f" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">无论您选择docker-compose还是testcontainers，这两种解决方案都非常适合集成测试。我们将在此总结我们对这两种解决方案的想法:</p><p id="37d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Docker-compose </strong>:</p><p id="2e29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">优点:</p><ul class=""><li id="5824" class="mv mw hi is b it iu ix iy jb mx jf my jj mz jn na nb nc nd bi translated">简单的配置</li><li id="f478" class="mv mw hi is b it ne ix nf jb ng jf nh jj ni jn na nb nc nd bi translated">跑得快</li><li id="b865" class="mv mw hi is b it ne ix nf jb ng jf nh jj ni jn na nb nc nd bi translated">代码库没有变化:都是关于配置文件的</li><li id="b44b" class="mv mw hi is b it ne ix nf jb ng jf nh jj ni jn na nb nc nd bi translated">对于数据库，您可以轻松地为init.sql脚本创建一个卷(在某些情况下，这可能是数据库迁移的首选方式，尤其是如果您不是ORM的有力支持者的话)</li></ul><p id="2d24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">缺点:</p><ul class=""><li id="b4b9" class="mv mw hi is b it iu ix iy jb mx jf my jj mz jn na nb nc nd bi translated">静态的，一旦你启动它，你就不能真正地操作代码中的容器，除非使用外部调用，比如python中的“os.system”或“subprocess ”,或者像pydocker那样使用Unix套接字的端口)</li><li id="afcc" class="mv mw hi is b it ne ix nf jb ng jf nh jj ni jn na nb nc nd bi translated">您的测试套件现在依赖于第三方脚本，并且您需要在每次测试之前运行它</li></ul><p id="fce2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">测试容器:</strong></p><p id="b5f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">优点:</p><ul class=""><li id="e43c" class="mv mw hi is b it iu ix iy jb mx jf my jj mz jn na nb nc nd bi translated"><em class="ll">内置解决方案:</em>一旦配置好，就可以运行了。例如，看一下testcontainers分支的<a class="ae ky" href="https://github.com/jossefaz/python-integration-test/blob/testcontainers/.github/workflows/tests.yml" rel="noopener ugc nofollow" target="_blank"> GitHub动作工作流…并将其与docker-compose分支</a>之一的<a class="ae ky" href="https://github.com/jossefaz/python-integration-test/blob/docker-compose/.github/workflows/tests.yml" rel="noopener ugc nofollow" target="_blank">进行比较…我们在这里节省了一个步骤！因为pytest将通过调用testcontainers API直接为我们运行容器</a></li><li id="41cd" class="mv mw hi is b it ne ix nf jb ng jf nh jj ni jn na nb nc nd bi translated">从测试中控制你的容器！</li></ul><p id="1039" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">缺点:</p><ul class=""><li id="5776" class="mv mw hi is b it iu ix iy jb mx jf my jj mz jn na nb nc nd bi translated">改变你的代码库(在我看来这是一个难题):如果你的测试套件只需要一个正在运行的数据库实例…那么更喜欢docker-compose解决方案</li><li id="1285" class="mv mw hi is b it ne ix nf jb ng jf nh jj ni jn na nb nc nd bi translated">很难使它工作(在我看来)。如果一个测试库意味着改变测试范围之外的代码…这可能是因为代码不好(我并不是说我们展示的代码是远非理想的代码)…但是说实话，这是我第一次不得不做出这样的改变来让它工作。</li><li id="4ab6" class="mv mw hi is b it ne ix nf jb ng jf nh jj ni jn na nb nc nd bi translated">运行您的测试套件需要更长的时间，因为测试现在负责启动一个容器，这对于当前版本(3.4.1)来说有一点延迟</li></ul></div></div>    
</body>
</html>