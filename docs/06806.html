<html>
<head>
<title>Nitro Server with Nuxt3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nuxt3的Nitro服务器</h1>
<blockquote>原文：<a href="https://medium.com/codex/nitro-server-with-nuxt3-ac043052929f?source=collection_archive---------0-----------------------#2022-05-14">https://medium.com/codex/nitro-server-with-nuxt3-ac043052929f?source=collection_archive---------0-----------------------#2022-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ede7ecca740014c4c94ea4a4e90426b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yfe0ick-K5ZSkXj-JJKqKw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Nuxt3硝基</figcaption></figure><p id="2df4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">不</strong>——这不是在Nuxt3上克隆<em class="js"> Discord Nitro </em>的教程😜。尽管将来某一天这将是一个伟大的项目🤔。在本文中，我们将在Nuxt3上编写一些后端服务器代码。</p><blockquote class="jt ju jv"><p id="754b" class="iu iv js iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">什么？😱但是Nuxt3不是前端框架吗？我将如何以及为什么在我的前端写我的后端代码？</p></blockquote><p id="2bbd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要创建一个全栈应用，我们需要一个服务器端代码和一个客户端代码。传统的框架捆绑了它们的代码，每当用户在你的服务器上发出一个<code class="du jz ka kb kc b">GET '/'</code>请求时，这个文件就会被发送。我们可以用一个前端细长的烧瓶后端来做这件事。在试图将这两种技术结合起来时可能会出现问题。</p><blockquote class="kd"><p id="24ab" class="ke kf hi bd kg kh ki kj kk kl km jr dx translated">如果我告诉你我们可以在同一个代码库上做这件事呢？</p></blockquote><p id="4314" class="pw-post-body-paragraph iu iv hi iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr hb bi translated"><strong class="iw hj">是的</strong> — Nuxt3引入了<strong class="iw hj"> Nitro服务器</strong>，在这里你可以在你的项目中编写你的服务器端代码并部署它！</p><h1 id="53bc" class="ks kt hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">入门指南</h1><p id="a6df" class="pw-post-body-paragraph iu iv hi iw b ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr hb bi translated">像Nuxt3提供的其他特性一样，我们需要在项目的根文件夹中创建一个<code class="du jz ka kb kc b">server/</code>目录。其中的任何代码都将由后端的<strong class="iw hj"> Nitro服务器</strong>呈现。让我们创建4个不同的路线，将说明每个概念需要知道硝基的基础知识。</p><p id="104f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">1.<code class="du jz ka kb kc b">GET '/api/users/’</code>——这条路线将获取我们已经注册的所有用户。</p><p id="2740" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.<code class="du jz ka kb kc b">POST '/api/users/'</code> —此路由将创建一个用户名为的新用户。</p><p id="3bdc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.<code class="du jz ka kb kc b">PUT '/api/users/{id}'</code> —此路线将改变用户的在线状态。</p><p id="b774" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">4.<code class="du jz ka kb kc b">DELETE '/api/users/{id}'</code> —这条路线会删除用户，这是显而易见的。</p><h1 id="b7c0" class="ks kt hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">创建我们的假数据库</h1><p id="7e1c" class="pw-post-body-paragraph iu iv hi iw b ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr hb bi translated">这里我们不会处理任何本地或云数据库，所以让我们在<code class="du jz ka kb kc b">server/</code>目录<code class="du jz ka kb kc b">db/</code>中创建一个文件夹和一个名为<code class="du jz ka kb kc b">index.ts</code>的类型脚本文件</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/fb17802189d15d0256cc04d3e7af1eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*Aq0PVQLwMqLj0ozSLlCeZQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">服务器/数据库/索引. ts</figcaption></figure><h1 id="ac7f" class="ks kt hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">创建我们的服务器路由</h1><p id="77c1" class="pw-post-body-paragraph iu iv hi iw b ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr hb bi translated">基于上面列出的4条路线，我们必须创建一个类似的结构。在Nuxt3项目中，维护目录结构非常重要。</p><pre class="lw lx ly lz fd ma kc mb mc aw md bi"><span id="6ee4" class="me kt hi kc b fi mf mg l mh mi">|- server/<br/>|  |- api/<br/>|  |  |- users/<br/>|  |  |  |- [id].ts<br/>|  |  |  |- index.ts<br/>|  |- db/<br/>|  |  |- index.ts<br/>|- app.vue<br/>|- nuxt.config.ts<br/>|- package.json<br/>|- package-lock.json<br/>|- README.md<br/>|- tsconfig.json</span></pre><p id="1686" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du jz ka kb kc b">db/</code>路线是为了我们拥有的假数据库。其他文件夹稍微简单明了。使用<code class="du jz ka kb kc b">server/api/users/[id].ts</code>时<code class="du jz ka kb kc b">server/api/users/index.ts</code>调用任何与<code class="du jz ka kb kc b">/api/users</code>关联的路径，其中是路径参数<code class="du jz ka kb kc b">/api/users/{id}</code>。</p><h2 id="aa68" class="me kt hi bd ku mj mk ml ky mm mn mo lc jf mp mq lg jj mr ms lk jn mt mu lo mv bi translated">#1 —获取'/API/用户'</h2><p id="8000" class="pw-post-body-paragraph iu iv hi iw b ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr hb bi translated">对于第一条路径，我们将代码放在<code class="du jz ka kb kc b">/api/users/index.ts</code>文件中，因为它不接受任何路径参数。我们必须默认导出一个名为<code class="du jz ka kb kc b">defineEventHandler</code>的函数，它将根据目录结构处理任何传入的路由。我们有一个匿名函数，将事件作为参数传递。此事件参数包含关于传入请求的所有必需细节。</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/e08d318c3569f12650589d008afcd5a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*p9HGAsCyEF57DTdoboQLoQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">服务器/API/用户/索引. ts</figcaption></figure><p id="b3ca" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du jz ka kb kc b">e.req.method</code>获取传入的HTTP方法的名称，我们可以据此操作，即返回用户。</p><h2 id="3749" class="me kt hi bd ku mj mk ml ky mm mn mo lc jf mp mq lg jj mr ms lk jn mt mu lo mv bi translated">#2 —发布'/api/users/'</h2><p id="415f" class="pw-post-body-paragraph iu iv hi iw b ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr hb bi translated">现在，由于请求的URL是相同的，我们将处理相同的<code class="du jz ka kb kc b">index.ts</code>文件路径。</p><p id="5446" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">先决条件:</strong>您需要运行以下命令:</p><p id="b4d4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du jz ka kb kc b">npm i uuid @types/uuid</code>。</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/73c3bcf8c091ca173e8a76a22d7f4173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*L5p7zI-6hp77hLRwHOnHQg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">服务器/API/用户/索引. ts</figcaption></figure><p id="a98f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果对该URL的传入请求是POST请求，我们可以通过传递事件对象的<code class="du jz ka kb kc b">await</code>函数提取主体。代码的其余部分不言自明。username属性被断言，被推送到我们的模拟数据库，并返回用户对象。<strong class="iw hj">注意</strong>发送错误的代码。</p><h2 id="914f" class="me kt hi bd ku mj mk ml ky mm mn mo lc jf mp mq lg jj mr ms lk jn mt mu lo mv bi translated"># 3—PUT“/API/users/{ id }”</h2><p id="20c9" class="pw-post-body-paragraph iu iv hi iw b ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr hb bi translated">这需要一个路径参数，因此会转到<code class="du jz ka kb kc b">[id].ts</code>文件。我们可以从创建一个函数开始，该函数将尝试从数据库中找到用户，并返回该对象以及该对象在数组中的索引。如果没有通过ID找到用户，我们可以简单地抛出一个404 HTTP错误。</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/74c794450dc2efd87eb25889c603da8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*InhIL9CdjziPnBd1L9EPLg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">服务器/API/用户/[id]。分时（同timesharing）</figcaption></figure><p id="b0bc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这一次，我可以使用一个开关盒而不是两个<code class="du jz ka kb kc b">if</code>来编写我的代码。</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/62cf736d6c9eb078c22eecaa4e0aa342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*9auk8U3QTwZtxaoWqoUjIw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">服务器/API/用户/[id]。分时（同timesharing）</figcaption></figure><p id="bb63" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果传入的请求是一个PUT方法，我将使用<code class="du jz ka kb kc b">e.context.params</code>从事件对象中提取ID。用这个特定的ID，我用我们上面写的函数从数据库中搜索用户。<em class="js">返回给我们的用户对象永远不会是</em> <code class="du jz ka kb kc b">null</code> <em class="js">或者</em> <code class="du jz ka kb kc b">undefined</code> <em class="js">。</em>我们改变在线状态的值并返回更新后的用户对象。</p><h2 id="0267" class="me kt hi bd ku mj mk ml ky mm mn mo lc jf mp mq lg jj mr ms lk jn mt mu lo mv bi translated">#4 —删除“/api/users/{id}”</h2><p id="b14c" class="pw-post-body-paragraph iu iv hi iw b ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr hb bi translated">在同一个文件中，在<code class="du jz ka kb kc b">case "DELETE"</code>下，我们可以编写从模拟数据库中删除用户的逻辑。</p><figure class="lw lx ly lz fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/a86082c87f18e079542744ca77d4824d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*Pr2g0mFkqFyumFAQR_xgbQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">服务器/API/用户/[id]。分时（同timesharing）</figcaption></figure><p id="414e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">基于我们之前所做的，这段代码太简单了。我们找到所需用户的索引，并将其从<code class="du jz ka kb kc b">db</code>对象的数组中拼接出来。</p><p id="e053" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们已经完成了我们的服务器代码！🎉</p><p id="7078" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">如何在前端使用这个？</strong> <em class="js">简单的</em> —我们可以在您的前端使用<code class="du jz ka kb kc b">useFetch('/api/users')</code>或<code class="du jz ka kb kc b">$fetch('/api/users')</code>向这些路由发出服务器请求。</p><h1 id="5c23" class="ks kt hi bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论</h1><p id="f774" class="pw-post-body-paragraph iu iv hi iw b ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn lu jp jq jr hb bi translated">将服务器代码和客户机代码放在同一个代码基上可以最大限度地减少将两者连接起来的任何努力，并消除在部署期间Nuxt3捆绑服务器时可能出现的任何问题。目录结构提供了一个非常系统的方法，在团队工作中非常容易阅读和理解。</p></div><div class="ab cl mx my gp mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hb hc hd he hf"><p id="4ce3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">跟着我的Nuxt3教程列表，掌握使用Nuxt3的基础。谢谢你，我希望你喜欢并学到了一些东西。✌️</p><div class="ne nf ez fb ng"><div role="button" tabindex="0" class="ab bv ff cb dy nh ni bn nj io nk"><div class="nl l"><div class="ab q"><div class="l di"><img alt="Nishant Aanjaney Jalan" class="l de bw nm nn du" src="../Images/c818d35ccc9090c3e339648aaa3eff62.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*AzY7YeI5L397_VE2biGHvQ.jpeg"/><div class="dr bw l nm nn ds n aw dt"/></div><div class="gg l dw"><p class="bd b fp z dy dz ea eb ec ed ee ef dx translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" rel="noopener follow" target="_top" href="/@cybercoder.naj?source=post_page-----ac043052929f--------------------------------">尼尚·安贾尼·贾兰</a></p></div></div><div class="nq nr fg l"><h2 class="bd hj tf tg dy th ea eb ti ed ef hh bi translated">Nuxt3教程</h2></div><div class="ab q"><div class="l dw"><a class="bd b be z bi tj au tk tl tm qg tn an fx fy to tp tq gb gc gd de bk ge" rel="noopener follow" target="_top" href="/@cybercoder.naj/list/nuxt3-tutorial-8af9304349ba?source=post_page-----ac043052929f--------------------------------">View list</a></div><div class="tr l dw"><span class="bd b fp z dx">8 stories</span></div></div></div><div class="od dh oe dy ab of dw di"><div class="di nv bv nw nx"><div class="dh l"><img alt="" class="dh" src="../Images/17a759730e64b9dfea248c7a4b5176e5.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*rtPua3KGr20PAHZi"/></div></div><div class="di nv bv ny nz oa"><div class="dh l"><img alt="" class="dh" src="../Images/8bd2ce5c89f980aecad2950bed8d29d7.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*BU0Mcr8XzfYx5Yfu.png"/></div></div><div class="di bv ob oc oa"><div class="dh l"><img alt="" class="dh" src="../Images/16082fcebc18fd206c3d2d68cb1f5040.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*Yfe0ick-K5ZSkXj-JJKqKw.png"/></div></div></div></div></div></div></div>    
</body>
</html>