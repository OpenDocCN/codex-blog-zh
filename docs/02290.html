<html>
<head>
<title>How to easily do conditional querying with Spring Data JPA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Spring数据JPA轻松做条件查询</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-easily-do-conditional-querying-with-spring-data-jpa-123079aa09a6?source=collection_archive---------0-----------------------#2021-07-12">https://medium.com/codex/how-to-easily-do-conditional-querying-with-spring-data-jpa-123079aa09a6?source=collection_archive---------0-----------------------#2021-07-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3ed3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">"在与数据库对话时，利用领域驱动设计中的规范模式."</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ad2b09c99a5a81732ff6a5c0b61771dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aFwbxeqjvfW_J269hph5KQ.jpeg"/></div></div></figure></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><p id="9481" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">很难找到一个现代应用程序不使用多种数据持久性形式中的一种。无论是对数据流进行繁重而复杂的操作/分析的应用程序，还是保存用户记录及其交互方式的简单在线应用程序，当应用程序停止占用易失性内存形式的任何空间，但仍需要跟踪一些数据以供将来参考时，几乎总是有一个地方可供应用程序保存数据。</p><p id="9155" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果你碰巧在读这篇文章，你可能已经在使用Spring，并且很可能知道Spring框架背后的团队如何投入巨资创建库，以使编码更容易、更快、更干净，并且在我个人看来，更有趣。</p><p id="c3fd" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">考虑到数据持久性角色在现代开发中的重要性和生命力，您甚至不用检查就可以猜到<strong class="js hj"> <em class="km"> Spring </em> </strong>已经提供了多种方式和方法来完成这项任务。</p><p id="3ae9" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Spring Data JPA、JDBC、MongoDB、R2DBC、Redis只是其中一大堆流行的库。</p><p id="e81b" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在这里，我们研究JPA以及如何实现更高级的(动态的和有条件的)查询场景，当产品的业务逻辑或UI变得更复杂时，这是必要的。</p><p id="2d63" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我将假设您熟悉基本的数据访问概念，特别是Spring数据，比如存储库、实体和……但是，如果您需要熟悉这些概念，我会尽量至少提到一些必要的主题。</p><p id="cac7" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">好了，介绍够了；让我们看看它是如何工作的！</p></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><p id="c1a9" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">想象一下，为一家包裹保险公司开发一个假设的应用程序，为包裹从源头到目的地的整个旅程提供保险！下面是保险实体的简化版本:</p><pre class="iy iz ja jb fd kn ko kp kq aw kr bi"><span id="0301" class="ks kt hi ko b fi ku kv l kw kx">@Entity<br/><em class="km">public class </em>Insurance {</span><span id="1f71" class="ks kt hi ko b fi ky kv l kw kx">    @Id<br/>    @GeneratedValue<br/>    <em class="km">private </em>id Long;</span><span id="7e28" class="ks kt hi ko b fi ky kv l kw kx">    <em class="km">private </em>String insuranceNumber;<br/><br/>    @OneToOne(optional = <em class="km">false</em>, cascade = CascadeType.<em class="km">ALL</em>)<br/>    <em class="km">private </em>Client client;<br/><br/>    @OneToOne(optional = <em class="km">false</em>, cascade = CascadeType.<em class="km">ALL</em>)<br/>    <em class="km">private </em>Parcel parcel;<br/><br/>    @Enumerated(EnumType.<em class="km">STRING</em>)<br/>    <em class="km">private </em>Status insuranceStatus;<br/><br/>    @ManyToOne<br/>    <em class="km">private </em>Trip trip;</span><span id="6354" class="ks kt hi ko b fi ky kv l kw kx">    @ManyToOne<br/>    <em class="km">private Post</em>Company postCompany;</span><span id="33d7" class="ks kt hi ko b fi ky kv l kw kx">    @ElementCollection<br/>    <em class="km">private List</em>&lt;Damage&gt; damages = <em class="km">new </em>ArrayList&lt;&gt;();<br/><br/>    @OneToMany(mappedBy = "insurance", cascade = CascadeType.<em class="km">ALL</em>)<br/>    <em class="km">private List</em>&lt;Payment&gt; payments = <em class="km">new </em>ArrayList&lt;&gt;();</span><span id="22d6" class="ks kt hi ko b fi ky kv l kw kx"><em class="km">    protected </em>Insurance() {}<br/>    // accessors and mutators ...</span><span id="b767" class="ks kt hi ko b fi ky kv l kw kx">}</span></pre><p id="99f3" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">正如您所看到的，在面向对象的层次结构中，我们有一些与我们的保险实体相关的其他实体，因此在我们的数据库中有一些其他的表来表示它们。</p><p id="49f8" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在这样的应用程序中，显然需要搜索一堆具有特定细节的保险记录。</p><p id="53ad" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们从简单的搜索查询开始，直到更复杂和更有条件的查询。</p></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><ol class=""><li id="ca7f" class="kz la hi js b jt ju jw jx jz lb kd lc kh ld kl le lf lg lh bi translated"><strong class="js hj"> <em class="km">第一个场景:</em> </strong></li></ol><p id="8cc4" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们想要搜索所有仍然有效的保险的列表。(未归档)所以我们需要做的是基于属性<em class="km"> insuranceStatus </em>的值进行查询，尽管它没有设置为archived。</p><p id="8b1f" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这里，我们的保险存储库看起来像这样:</p><pre class="iy iz ja jb fd kn ko kp kq aw kr bi"><span id="2bee" class="ks kt hi ko b fi ku kv l kw kx"><em class="km">public interface InsuranceRepository<br/>    extends CrudRepository</em>&lt;Insurance, Long&gt;<br/>{<br/><br/>    // Some generic CRUD methods ...</span><span id="123c" class="ks kt hi ko b fi ky kv l kw kx">    List&lt;Insurance&gt; findAllByStatusNot(Insurance.Status status);<br/>}</span></pre><p id="772d" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们上面所做的是使用一种叫做<strong class="js hj"> <em class="km">派生查询方法、</em> </strong>的技术，其中你指示Spring JPA根据你写的方法名为你构建一个查询。在这个例子中，我们只是告诉JPA找到所有保险实例，它们的<strong class="js hj"> <em class="km">状态</em> </strong>属性值是<em class="km">而不是我们作为参数传递给方法的</em>。因此，它将返回一个包含所有未设置为存档的保险记录的列表。很简单，不是吗？</p><p id="04cb" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对于构建这种类型的方法，有相当多的已定义的关键字可以用来模拟数据库查询，然后JPA将在幕后为您创建这些查询。点击查看完整列表<a class="ae li" href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="8c7d" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">由于您在上面的结果中得到的是一个列表，并且取决于实际情况，该列表可以包含从几个到一千多个的内容；在大多数情况下，最好在后端处理分页和排序，而不是获取所有内容，然后在前端处理这些任务，原因很明显。</p><p id="6f2e" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在Spring JPA中，通过从<em class="km"> JpaRepository </em>而不是<em class="km"> CrudRepository </em>扩展您的存储库，然后将可分页或排序对象传递给您编写的查询方法，您可以很容易地做到这一点。(<em class="km"> JpaRepository </em>扩展了另外两个接口，其中一个是<em class="km"> PagingAndSortingRepository。我们将在本文后面讨论另一个问题。)</em></p><p id="8dfb" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">下面是我们现在使用分页的例子:</p><pre class="iy iz ja jb fd kn ko kp kq aw kr bi"><span id="1a1b" class="ks kt hi ko b fi ku kv l kw kx"><em class="km">public interface InsuranceRepository<br/>    extends JpaRepository</em>&lt;Insurance, Long&gt;<br/>{<br/><br/>    // Some generic CRUD methods ...</span><span id="e626" class="ks kt hi ko b fi ky kv l kw kx"><em class="km">    Page</em>&lt;Insurance&gt; findAllByStatusNot(Insurance.Status status,               .                                      <em class="km">Pageable </em>pageable);<br/>}</span></pre><blockquote class="lj lk ll"><p id="7a1a" class="jq jr km js b jt ju ij jv jw jx im jy lm ka kb kc ln ke kf kg lo ki kj kk kl hb bi translated">你要知道，当使用Spring JPA时，总是可以通过<em class="hi"> @Query </em>注释使用原生查询或JPQL查询直接在存储库中编写查询。在本文中，我不打算解释如何利用@Query注释来编写本机或JPQL查询，但值得注意的是，使用它会失去类型安全性，并且在更复杂和条件查询的情况下，您将最终连接多个字符串来创建最终的查询，这很容易出错，并且在将来发生任何变化的情况下很难维护。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lp"><img src="../Images/497780ee2dc3a36f56ed694eca3e6520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n37aFd9FhJHIYK2lT_v0Lg.jpeg"/></div></div></figure></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><p id="4507" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">2.<strong class="js hj"> <em class="km">第二个场景:</em> </strong></p><p id="34a2" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在，让我们扩展前面的查询，搜索包含更多条件的保险(我们的实体)列表。假设我们在数据库中寻找保险记录，除了<strong class="js hj">而不是</strong>将它们的状态设置为<em class="km">存档之外，在一些列中有</em>特定的关键字(Amsterdam ),并按保险号排序。</p><p id="857d" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">例如，包裹的来源或目的地有这个词，或者可能是客户或公司的名称，基本上是任何可能有这条信息的记录。</p><p id="1c31" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">像在第一个场景中一样，让我们编写一个<strong class="js hj"> <em class="km">派生的查询方法</em> </strong>来处理这种情况；为什么不呢？这可以很快完成，并且不需要了解太多SQL的语法，所以我们开始吧:</p><pre class="iy iz ja jb fd kn ko kp kq aw kr bi"><span id="69dc" class="ks kt hi ko b fi ku kv l kw kx"><em class="km">public interface InsuranceRepository<br/>    extends JpaRepository</em>&lt;Insurance, Long&gt;<br/>{<br/><br/>    // Some generic CRUD methods ...</span><span id="f7fb" class="ks kt hi ko b fi ky kv l kw kx">Page&lt;Insurance&gt; findAllByStatusNotAndParcelDescriptionContainingOrClientNameContainingOrTripSourceContainingOrTripDestinationContainingorPostCompnayNameContainingOrderByInsuranceNumberDesc(Insurance.Status status, String parcelDescription,String clientName, String tripSource, String tripDestination, String postCompanyName, Pageable pageable);<br/>}</span></pre><p id="ac9b" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我认为可以肯定地说，在我们大多数人的眼中，这是<strong class="js hj"> <em class="km">丑陋的</em></strong><strong class="js hj"><em class="km">不可读的</em> </strong>，以及难以维护的<strong class="js hj"><em class="km"/></strong>，因为如果你改变了你想要的查询构建方式，你需要修改方法签名，并将其应用到正在使用的代码中的所有其他地方。</p><p id="e59a" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">因此，很明显，这不应该是正确的做法，正如我们已经讨论过的，编写JPQL或SQL并不能很好地解决条件查询的问题。</p><p id="53cd" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="js hj">通过实例查询API来救援！(或者不是！)</strong></p><p id="e95d" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">正如我前面提到的，<a class="ae li" href="https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html" rel="noopener ugc nofollow" target="_blank"><strong class="js hj"><em class="km">jparestory</em></strong></a><em class="km"/>接口<em class="km"> </em>扩展了另外两个接口，其中一个是<a class="ae li" href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/PagingAndSortingRepository.html" rel="noopener ugc nofollow" target="_blank"><strong class="js hj"><em class="km">paginandsortinstory</em></strong></a><strong class="js hj"><em class="km">&lt;T，ID &gt; </em> </strong> <em class="km"> ( </em>我们试了一下<em class="km">，</em>但是</p><pre class="iy iz ja jb fd kn ko kp kq aw kr bi"><span id="6236" class="ks kt hi ko b fi ku kv l kw kx">public interface JpaRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; {}</span></pre><p id="815a" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这个接口为我们提供了各种不同但熟悉的<strong class="js hj"><em class="km">find</em></strong><em class="km"/>方法，这些方法也接受一个<a class="ae li" href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/domain/Example.html" rel="noopener ugc nofollow" target="_blank">实例的实例</a>。</p><pre class="iy iz ja jb fd kn ko kp kq aw kr bi"><span id="64a6" class="ks kt hi ko b fi ku kv l kw kx">public interface <strong class="ko hj">QueryByExampleExecutor</strong>&lt;<strong class="ko hj">T</strong>&gt; {<br/>     &lt;S extends T&gt; Optional&lt;S&gt; <strong class="ko hj">findOne</strong>(Example&lt;S&gt; var1);     <br/>     &lt;S extends T&gt; Iterable&lt;S&gt; <strong class="ko hj">findAll</strong>(Example&lt;S&gt; var1);     <br/>     &lt;S extends T&gt; Iterable&lt;S&gt; <strong class="ko hj">findAll</strong>(Example&lt;S&gt; var1, Sort var2);<br/>     &lt;S extends T&gt; Page&lt;S&gt; <strong class="ko hj">findAll</strong>(Example&lt;S&gt; var1, Pageable var2);<br/>     &lt;S extends T&gt; long <strong class="ko hj">count</strong>(Example&lt;S&gt; var1);     <br/>     &lt;S extends T&gt; boolean <strong class="ko hj">exists</strong>(Example&lt;S&gt; var1); <br/>}</span></pre><p id="8d67" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">它是如何工作的？最简单地说:<a class="ae li" href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/domain/Example.html" rel="noopener ugc nofollow" target="_blank"> <em class="km">示例</em> </a>实际上是您想要搜索的实体的一个示例，它以这样的方式构建:“<strong class="js hj">查找与我相似的实体记录！</strong>”</p><p id="1932" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当使用<a class="ae li" href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#query-by-example" rel="noopener ugc nofollow" target="_blank"> <em class="km">查询示例API </em> </a> <em class="km"> </em>时，你可以用比以前更清晰的代码做很多事情。API中融入了三个概念:<strong class="js hj"> <em class="km">探针</em> </strong>、<strong class="js hj"> <em class="km">范例匹配器、</em> </strong>和<strong class="js hj"> <em class="km">范例。</em> </strong></p><p id="4224" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="js hj">第一个</strong>是您正在查询的域对象的实际例子，其中填充了所需的字段。<strong class="js hj">第二个</strong>是如何比较和匹配与探针相关的数据库记录的指示，最后一个<strong class="js hj">是上面两个的组合，它被传递给<em class="km"> find </em>方法之一并为我们创建查询。</strong></p><p id="3f60" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">只有在没有嵌套对象的情况下，这才是一个好方法(就像我们上面所做的那样)，除了简单之外，它还带来了几个主要的限制，在决定使用这个API之前，必须考虑这些限制。</p><ul class=""><li id="d3c2" class="kz la hi js b jt ju jw jx jz lb kd lc kh ld kl lq lf lg lh bi translated">不支持嵌套或分组属性约束，如<code class="du lr ls lt ko b">firstname = ?0 or (firstname = ?1 and lastname = ?2)</code>。</li><li id="93fd" class="kz la hi js b jt lu jw lv jz lw kd lx kh ly kl lq lf lg lh bi translated">仅支持字符串的starts/contains/ends/regex匹配和其他属性类型的精确匹配。</li></ul><p id="af47" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">出于第一个原因，我们不能利用它来重现我们上面已经做过的查询。</p><p id="bd55" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">所以对于简单的对象(类似下面这个人)，可以写类似这样的东西:</p><pre class="iy iz ja jb fd kn ko kp kq aw kr bi"><span id="e09d" class="ks kt hi ko b fi ku kv l kw kx"><strong class="ko hj">public</strong> <strong class="ko hj">class</strong> <strong class="ko hj">Person</strong> {    </span><span id="49c1" class="ks kt hi ko b fi ky kv l kw kx"><strong class="ko hj">    @Id</strong>   <strong class="ko hj">private</strong> String id;<br/>    <strong class="ko hj">private</strong> String firstname;<br/>    <strong class="ko hj">private</strong> String lastname;<br/>    <strong class="ko hj">private</strong> Address address;<br/>    <em class="km">// … getters and setters omitted<br/></em> }</span><span id="567a" class="ks kt hi ko b fi ky kv l kw kx">Person person = <strong class="ko hj">new</strong> Person();                                person.setFirstname("Dave");                             ExampleMatcher matcher = ExampleMatcher.matching()         .withIgnorePaths("lastname")                            .withIncludeNullValues()                                .withStringMatcherEnding();                            Example&lt;Person&gt; example = Example.of(person, matcher);</span><span id="7aef" class="ks kt hi ko b fi ky kv l kw kx">Optional&lt;Person&gt; actual = repository.findOne(example);</span></pre><p id="27f2" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们在上面所做的是创建一个我们正在寻找的模型的实例，将它的firstName属性设置为我们正在寻找的关键字，并使用自定义的ExampleMatcher来包装整个示例，它在搜索相似记录时基本上应用了所需的行为。</p><p id="dde5" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">因此，显然<strong class="js hj"> <em class="km">查询示例API </em> </strong>在更复杂的查询中不会帮助我们，尽管它提供了动态查询创建，而不需要编写任何SQL本身，这可以根据情况派上用场。</p><p id="c3e6" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="js hj">用“规范”来做吧！</strong></p><p id="222d" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">那么，在我们的例子中，对于派生查询方法<strong class="js hj"><em class="km"/></strong>或者将SLQ字符串相互连接起来，真正的替代方法是什么呢？</p><p id="758b" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">实际上，我想解释两种可能的情况，一种是<strong class="js hj">标准API及其规范</strong>，另一种是<strong class="js hj"> QueryDSL。前者将是本文的最后一部分，而后者我将在另一篇文章中单独描述。</strong></p><p id="92de" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">规范接口源自Eric Evans的领域驱动设计书中介绍的概念。它将规范定义为实体上的谓词，这正是规范接口所代表的。</p><p id="b530" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了使用它，您必须扩展您的存储库接口，从<em class="km">JpaSpecificationExecutor</em>&lt;T&gt;:</p><pre class="iy iz ja jb fd kn ko kp kq aw kr bi"><span id="da89" class="ks kt hi ko b fi ku kv l kw kx"><em class="km">public interface InsuranceRepository<br/>    extends JpaRepository</em>&lt;Insurance, UUID&gt; ,    <em class="km">JpaSpecificationExecutor</em>&lt;Insurance&gt; {}</span></pre><p id="09ae" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这里的想法是，我们为我们想要在目标实体的记录中检查/搜索的每个条件创建动态规范，然后根据我们的需要用适当的逻辑将它们链接在一起。</p><p id="e946" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">将由单个规范链接而成的对象传递给<em class="km"> JpaSpecificationExecutor </em>接口的默认方法将会为我们完成这个任务。</p><pre class="iy iz ja jb fd kn ko kp kq aw kr bi"><span id="37f1" class="ks kt hi ko b fi ku kv l kw kx"><em class="km">public interface JpaSpecificationExecutor</em>&lt;T&gt; {<br/><em class="km"><br/>   </em>Optional&lt;T&gt; findOne(@Nullable <em class="km">Specification</em>&lt;T&gt; spec);<br/><em class="km"><br/>   List</em>&lt;T&gt; findAll(@Nullable <em class="km">Specification</em>&lt;T&gt; spec);<br/><em class="km"><br/>   Page</em>&lt;T&gt; findAll(@Nullable <em class="km">Specification</em>&lt;T&gt; spec, <em class="km">Pageable </em>pageable);<br/><em class="km"><br/>   List</em>&lt;T&gt; findAll(@Nullable <em class="km">Specification</em>&lt;T&gt; spec, Sort sort);<br/><em class="km"><br/>   long </em>count(@Nullable <em class="km">Specification</em>&lt;T&gt; spec);<br/>}</span></pre><p id="eec5" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们看看如何…我们首先为每个条件创建方法，从我们的目标模型的类中返回一个规范对象。</p><pre class="iy iz ja jb fd kn ko kp kq aw kr bi"><span id="7d56" class="ks kt hi ko b fi ku kv l kw kx"><em class="km">static Specification</em>&lt;Insurance&gt; withTripSource(@Nullable String source) {</span><span id="837b" class="ks kt hi ko b fi ky kv l kw kx"><em class="km">return </em>(root, cq, cb) -&gt; title == <em class="km">null </em>? <em class="km">null </em>: cb.like(cb.lower(root.join("trip", JoinType.<em class="km">LEFT</em>).get("source")), cb.lower(cb.literal("%" + source + "%")));</span><span id="6636" class="ks kt hi ko b fi ky kv l kw kx">}</span></pre><p id="4537" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">乍一看，这似乎很复杂，但实际上比你想象的要简单。</p><p id="1c1b" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这里，我们将方法名设置为“<em class="km"> withTripSource </em>”，以表明我们希望将trip.source内容作为查询的主题/条件之一。</p><p id="1d5c" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">下一部分非常有用，因为它给了我们自由，如果我们没有提供任何要查找的源字符串，我们可以在最终的规范对象中动态地忽略这个方法的结果。</p><p id="c5bd" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这个行为是我们拥有的关键功能，它允许我们在即将到来的请求中接受动态参数，并基于此创建一个动态查询(后台)。比方说，我们可能总是不想根据trip.source过滤我们的实体，将null传递给这个方法将会照顾到我们的意图。</p><pre class="iy iz ja jb fd kn ko kp kq aw kr bi"><span id="e5df" class="ks kt hi ko b fi ku kv l kw kx">Specification&lt;Insurance&gt; specs = Specification<br/>        .where(withStatus(status))<br/>        .and(withTripSource(source))<br/>        .and(withTripDestination(destination))<br/>        .and(withPostCompanyName(name));<br/><br/>Pageable paging = PageRequest.of(page, size);<br/><em class="km">return </em>insuranceRepository.findAll(specs, paging);</span></pre><p id="9c6a" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">使用Criteria API将为您提供很大的灵活性，让您可以根据自己的需要创建运行时动态查询(equals，contains …)。</p><p id="a8ab" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在从你想要拥有的所有规格中构建链条时，除了<strong class="js hj"> <em class="km">之外，其中</em> </strong> &amp; <strong class="js hj"> <em class="km">和</em> </strong> <em class="km">、</em> <strong class="js hj"> <em class="km">非</em> </strong>和<strong class="js hj"> <em class="km">或</em> </strong>也是可用的。</p><p id="796b" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">您可以(或者我认为您必须)做的另一件事是通过使用元数据为上面的构造添加类型安全。</p><p id="23fd" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">提供类型安全的另一种方法是QueryDSL，已经提到过了，将会有另一篇文章来描述它。</p><p id="6ec8" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">祝你好运，享受编码！</p></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><p id="542c" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">参考文献:</p><p id="ac92" class="pw-post-body-paragraph jq jr hi js b jt ju ij jv jw jx im jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><a class="ae li" href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.repositories" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-data/JPA/docs/current/reference/html/# JPA . repositories</a></p></div></div>    
</body>
</html>