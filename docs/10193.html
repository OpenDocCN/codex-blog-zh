<html>
<head>
<title>JWT Auth-101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JWT认证-101</h1>
<blockquote>原文：<a href="https://medium.com/codex/jwt-auth-101-e78aeef640c?source=collection_archive---------12-----------------------#2022-12-11">https://medium.com/codex/jwt-auth-101-e78aeef640c?source=collection_archive---------12-----------------------#2022-12-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6734" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何处理不同服务之间的认证？</h2></div><p id="a688" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在在做关于微服务的研究。实际上，我理解了一些关键点。然而，有一个模糊点，如“我如何使用auth service为我的post服务处理认证”。在本文中，我们将通过Python、Flask中的应用示例来了解如何处理不同系统之间的认证。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/42aa1662a4a66effba9767947f6e4494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x60czqSrqkSsMmUBAspk9Q.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated"><a class="ae kj" href="https://unsplash.com/@growtika?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Growtika开发商营销机构</a>在<a class="ae kj" href="https://unsplash.com/s/photos/authentication-microservices?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="e7b3" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">什么是认证和授权？</h1><p id="51fe" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">认证是识别一个<strong class="iz hj">用户在我们的系统中是否存在</strong>的过程。</p><p id="34f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">授权是确定一个<strong class="iz hj">用户是否有权限</strong>执行特定操作或访问特定资源的过程。</p><p id="6609" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">换句话说，在对用户进行身份验证并确认其身份后，授权是检查是否允许该用户执行特定操作或访问特定资源的过程。例如，用户可能已经过身份验证并登录到系统，但他们可能无权访问某些敏感信息或执行某些操作，如修改关键的系统设置。</p><h1 id="0e2f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">什么是JWT？</h1><p id="9ff9" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">JWT是一种在双方之间传输信息的紧凑且独立的方式。它通常用于身份验证和授权，并允许各方安全地交换信息，如用户身份和其他声明。JWT通常由一个JSON对象组成，该对象经过数字签名并可选地加密，并且通常作为<strong class="iz hj"> HTTP授权头</strong>中的<strong class="iz hj">承载令牌</strong>发送。</p><p id="742a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“如果你是第一次听说JWT，你可以访问jwt.io了解更多。”</p><div class="lh li ez fb lj lk"><a href="https://jwt.io/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hj fi z dy lp ea eb lq ed ef hh bi translated">JWT。超正析象管(Image Orthicon)</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">JSON Web Token (JWT)是一种简洁的、URL安全的方式，用于表示要在双方之间传输的声明。的…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">jwt.io</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly kd lk"/></div></div></a></div><h1 id="3a4a" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">理论上的JWT认证</h1><ol class=""><li id="f240" class="lz ma hi iz b ja lc jd ld jg mb jk mc jo md js me mf mg mh bi translated">用户向身份验证服务的登录端点发送请求。</li></ol><ul class=""><li id="88bc" class="lz ma hi iz b ja jb jd je jg mi jk mj jo mk js ml mf mg mh bi translated">我使用<a class="ae kj" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#authentication_schemes" rel="noopener ugc nofollow" target="_blank">“HTTP Basic”</a>发送登录请求，可以使用请求体或者其他方法。</li></ul><p id="cdd3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.服务解析请求的授权头，并检查用户是否存在于系统中。</p><ul class=""><li id="f6b8" class="lz ma hi iz b ja jb jd je jg mi jk mj jo mk js ml mf mg mh bi translated">如果没有用户，返回错误信息和<a class="ae kj" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401" rel="noopener ugc nofollow" target="_blank"> 401状态码</a>。</li><li id="ea74" class="lz ma hi iz b ja mm jd mn jg mo jk mp jo mq js ml mf mg mh bi translated">如果用户在系统中存在，则创建JWT并返回令牌。</li></ul><p id="3663" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.通过响应获得行动。</p><ul class=""><li id="1e66" class="lz ma hi iz b ja jb jd je jg mi jk mj jo mk js ml mf mg mh bi translated">如果有令牌，将令牌放入HTTP授权头(Bearer <token>)。</token></li></ul><p id="4ebc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.使用令牌请求其他服务。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es mr"><img src="../Images/f58e355634f847b57d95746130412cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*86tH1GjZRez4wve3X-lNXA.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者图|你见过的最差的图之一:)</figcaption></figure><h1 id="ac49" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">JWT认证在行动</h1><p id="dff3" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">在这一节中，我们将通过使用Flask来探索这一理论，Flask是Python生态系统的一个web框架。</p><h2 id="5018" class="ms kl hi bd km mt mu mv kq mw mx my ku jg mz na kw jk nb nc ky jo nd ne la nf bi translated">要求</h2><p id="3725" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">我们将在项目中使用以下包。</p><ul class=""><li id="33c1" class="lz ma hi iz b ja jb jd je jg mi jk mj jo mk js ml mf mg mh bi translated"><code class="du ng nh ni nj b">flask</code>:网络服务器(<code class="du ng nh ni nj b">pip install flask</code>)</li><li id="69fe" class="lz ma hi iz b ja mm jd mn jg mo jk mp jo mq js ml mf mg mh bi translated"><code class="du ng nh ni nj b">pyjwt</code>:生成令牌(<code class="du ng nh ni nj b">pip install pyjwt</code>)</li><li id="6f41" class="lz ma hi iz b ja mm jd mn jg mo jk mp jo mq js ml mf mg mh bi translated"><code class="du ng nh ni nj b">httpx</code>:向端点发出请求(<code class="du ng nh ni nj b">pip install httpx</code>)</li></ul><h2 id="3911" class="ms kl hi bd km mt mu mv kq mw mx my ku jg mz na kw jk nb nc ky jo nd ne la nf bi translated">授权服务</h2><p id="3904" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">首先，我要定义常数。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="b0eb" class="no kl hi nj b be np nq l nr ns">"""<br/># We use the snippets below to make requests<br/><br/># login post request<br/>- httpx -m POST --auth user@user.com Passw0rd http://127.0.0.1:5000/login<br/><br/># validate post request<br/>- httpx -m POST -h "Authorization" "Bearer &lt;TOKEN&gt;" http://127.0.0.1:5000/validate<br/>"""<br/>from flask import Flask, request<br/>import jwt<br/>import datetime<br/><br/>JWT_SECRET = (<br/>    "this-is-so-secret-key-to-encode-jwt-tokens"  # you should get this by using ENV<br/>)<br/>USERS_DB = [<br/>    {"username": "user@user.com", "password": "Passw0rd", "is_admin": True}<br/>]  # you should use a real db :)<br/><br/>app = Flask(__name__)</span></pre><p id="140b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ng nh ni nj b">app</code>将引用服务器。</p><p id="331f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ng nh ni nj b">JWT_SECRET</code>将在JWT创建过程中使用。</p><p id="69fc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ng nh ni nj b">USERS_DB</code>将被用作虚拟数据库。我选择这种方法是为了保持简单。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="503b" class="no kl hi nj b be np nq l nr ns"><br/><br/>@app.route("/login", methods=["POST"])<br/>def login():<br/>    print(request.headers)  # We need to get "Authorization" header of the request<br/>    print(request.authorization)  # This is automatically decode the header in Flask<br/><br/>    # handle username and password from request header (Flask does for us, it decodes)<br/>    auth = request.authorization<br/>    if not auth:<br/>        return "missing credentials", 401<br/><br/>    # filter users<br/>    users_list = [u for u in USERS_DB if u["username"] == auth.username]<br/>    # is there any user with the credentials<br/>    if len(users_list) != 1 or users_list[0]["password"] != auth.password:<br/>        return ("Missing credentials", 401)<br/>    else:<br/>        return createJWT(auth.username, JWT_SECRET, users_list[0]["is_admin"]), 200</span></pre><p id="0999" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我前面提到的，我们需要处理请求的<code class="du ng nh ni nj b">Authorization</code>头。为此，我们可以使用烧瓶中的<code class="du ng nh ni nj b">request.headers</code>。我将使用<code class="du ng nh ni nj b">httpx</code>发送一个POST请求来模拟上面的代码。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="aa9f" class="no kl hi nj b be np nq l nr ns">httpx -m POST --auth user@user.com Passw0rd http://127.0.0.1:5000/login</span></pre><p id="edd9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将得到如下输出。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="4e8e" class="no kl hi nj b be np nq l nr ns">Host: 127.0.0.1:5000<br/>Content-Length: 0<br/>Accept: */*<br/>Accept-Encoding: gzip, deflate<br/>Connection: keep-alive<br/>User-Agent: python-httpx/0.23.1<br/>Authorization: Basic dXNlckB1c2VyLmNvbTpQYXNzdzByZA==</span></pre><p id="c55a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如你看到的<code class="du ng nh ni nj b">Authorization</code>头，我们得到一个编码值。</p><blockquote class="nt nu nv"><p id="d937" class="ix iy nw iz b ja jb ij jc jd je im jf nx jh ji jj ny jl jm jn nz jp jq jr js hb bi translated">你可以查看RFC 7617 -基本的HTTP认证方案</p></blockquote><p id="14e8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过使用<code class="du ng nh ni nj b">request.authorization</code>得到它的解码值。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="758b" class="no kl hi nj b be np nq l nr ns">{'username': 'user@user.com', 'password': 'Passw0rd'}</span></pre><p id="bcb9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Flask为我们解码了授权头。我们在下面的代码块中看到了Flask解码代码。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="30c6" class="no kl hi nj b be np nq l nr ns"># Flask authorization header parser<br/>def parse_authorization_header(<br/>    value: t.Optional[str],<br/>) -&gt; t.Optional["ds.Authorization"]:<br/>    """Parse an HTTP basic/digest authorization header transmitted by the web<br/>    browser.  The return value is either `None` if the header was invalid or<br/>    not given, otherwise an :class:`~werkzeug.datastructures.Authorization`<br/>    object.<br/><br/>    :param value: the authorization header to parse.<br/>    :return: a :class:`~werkzeug.datastructures.Authorization` object or `None`.<br/>    """<br/>    if not value:<br/>        return None<br/>    value = _wsgi_decoding_dance(value)<br/>    try:<br/>        auth_type, auth_info = value.split(None, 1)<br/>        auth_type = auth_type.lower()<br/>    except ValueError:<br/>        return None<br/>    if auth_type == "basic": # We used this scheme by sending request with httpx <br/>        try:<br/>            username, password = base64.b64decode(auth_info).split(b":", 1) # httpx encodes the header for us<br/>        except Exception:<br/>            return None<br/>        try:<br/>            return ds.Authorization(<br/>                "basic",<br/>                {<br/>                    "username": _to_str(username, "utf-8"),<br/>                    "password": _to_str(password, "utf-8"),<br/>                },<br/>            )<br/>        except UnicodeDecodeError:<br/>            return None<br/>    elif auth_type == "digest":<br/>        auth_map = parse_dict_header(auth_info)<br/>        for key in "username", "realm", "nonce", "uri", "response":<br/>            if key not in auth_map:<br/>                return None<br/>        if "qop" in auth_map:<br/>            if not auth_map.get("nc") or not auth_map.get("cnonce"):<br/>                return None<br/>        return ds.Authorization("digest", auth_map)<br/>    return None</span></pre><p id="7389" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在检查系统中是否存在该用户后，我们可以使用我们的<code class="du ng nh ni nj b">createJWT</code>函数创建JWT。我们可以扩展我们想要的有效载荷。</p><blockquote class="nt nu nv"><p id="1d63" class="ix iy nw iz b ja jb ij jc jd je im jf nx jh ji jj ny jl jm jn nz jp jq jr js hb bi translated"><code class="du ng nh ni nj b">admin</code>创建有效负载的密钥是为了处理“授权”,这不在本文的讨论范围内。</p></blockquote><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="2160" class="no kl hi nj b be np nq l nr ns">def createJWT(username, secret, authz):<br/>    payload = {<br/>        "username": username,<br/>        "exp": datetime.datetime.now(tz=datetime.timezone.utc)  # expire date<br/>        + datetime.timedelta(days=1),  # token lifetime is 1 day<br/>        "iat": datetime.datetime.utcnow(),  # issued at<br/>        "admin": authz,  # is user admin<br/>    }<br/>    return jwt.encode(<br/>        payload,<br/>        secret,<br/>        algorithm="HS256",<br/>    )  # return JWT token</span></pre><p id="a857" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们成功地向我们的登录端点发出请求，我们将获得JWT令牌。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es oa"><img src="../Images/e5f42b63a51cd7b7991c5a85c6fd6cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBhmONT9qcPv6MoJiKICsA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者图片</figcaption></figure><p id="1ac1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经准备好使用我们的验证端点来验证令牌了。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="cebf" class="no kl hi nj b be np nq l nr ns">@app.route("/validate", methods=["POST"])<br/>def validate():<br/>    encoded_jwt = request.headers[<br/>        "Authorization"<br/>    ]  # handle "Authorization" header. We have to send the token in this scheme =&gt; Bearer &lt;TOKEN&gt;<br/><br/>    if not encoded_jwt:<br/>        return ("missing credentials", 401)<br/><br/>    encoded_jwt = encoded_jwt.split(" ")[1]  # get the token (exclude "Bearer")<br/><br/>    try:<br/>        decoded = jwt.decode(<br/>            encoded_jwt, JWT_SECRET, algorithms=["HS256"]<br/>        )  # decode the token<br/>    except:<br/>        return ("not authorized", 403)<br/><br/>    return (decoded, 200)</span></pre><p id="eff6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们能够成功地向我们的验证端点发出请求，我们需要解码JWT。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="8398" class="no kl hi nj b be np nq l nr ns">httpx -m POST -h "Authorization" "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXJAdXNlci5jb20iLCJleHAiOjE2NzA4NDY4NjIsImlhdCI6MTY3MDc2MDQ2MiwiYWRtaW4iOnRydWV9.Z3bA45Q414VsO9GYECsr9YO40ac1xD-EuMz5TeUOroA" http://127.0.0.1:5000/validate</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es oa"><img src="../Images/f99d96e0702175431d65a8887a7f49c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-7AhmFQuTEEfqRe6dV13w.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者图片</figcaption></figure><p id="10bb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经成功开发了我们的认证服务。现在我们需要创建我们的post服务。<strong class="iz hj">请记住，我们将使用来自post服务的验证和登录端点来验证用户。</strong></p><h2 id="d484" class="ms kl hi bd km mt mu mv kq mw mx my ku jg mz na kw jk nb nc ky jo nd ne la nf bi translated">网关服务</h2><p id="49e4" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">我们将从定义常数开始。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="9d77" class="no kl hi nj b be np nq l nr ns">"""<br/># We use the snippets below to make requests<br/><br/># login post request<br/>- httpx -m POST --auth user@user.com Passw0rd http://127.0.0.1:8080/login<br/><br/># GET Posts<br/>- httpx -m GET -h "Authorization" "Bearer &lt;TOKEN&gt;" http://127.0.0.1:8080/posts<br/><br/># POST Posts<br/>- httpx -m POST -h "Authorization" "Bearer &lt;TOKEN&gt;" -j '{"id":1, "title": "Title Text"}' http://127.0.0.1:8080/posts<br/>"""<br/>from flask import Flask, request<br/>import httpx<br/>import json<br/><br/>AUTH_SERVICE_URL = "http://127.0.0.1:5000"  # you should get this by using ENV<br/>POSTS_DB = []  # to simulate inserting<br/><br/>app = Flask(__name__)</span></pre><p id="0458" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用<code class="du ng nh ni nj b">AUTH_SERVICE_URL</code>在我们的making requests函数中设置前缀。</p><p id="12ed" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ng nh ni nj b">POSTS_DB</code>是我们的虚拟数据库。</p><p id="073a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ng nh ni nj b">app</code>是服务器。</p><blockquote class="nt nu nv"><p id="f466" class="ix iy nw iz b ja jb ij jc jd je im jf nx jh ji jj ny jl jm jn nz jp jq jr js hb bi translated">实际上，在这里我试图模拟API网关架构。但是，为了简单起见，我还将post服务合并到了gateway服务中。因此，在我的例子中，只有一个额外的服务来模拟posts &amp; gateway。</p></blockquote><p id="f511" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我将从解释posts服务中的网关功能开始。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="e475" class="no kl hi nj b be np nq l nr ns"><br/>def auth_service_login(request):<br/>    """Auth request to auth service<br/><br/>    Args:<br/>        request (request): Flask request<br/><br/>    Returns:<br/>        tuple: First item of the tuple will be the token if the request is successfull and 2nd item will be the status code<br/>    """<br/>    auth = request.authorization<br/>    if not auth:<br/>        #  if there is no "Authorization" header in the request that is coming to "gateway" service, return error<br/>        return None, ("missing credentials", 401)<br/><br/>    basicAuth = (auth.username, auth.password)<br/><br/>    # post request to auth service to get the token<br/>    response = httpx.post(f"{AUTH_SERVICE_URL}/login", auth=basicAuth)<br/><br/>    if response.status_code == 200:<br/>        return response.text, None<br/>    else:<br/>        return None, (response.text, response.status_code)</span></pre><p id="3c5a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个<code class="du ng nh ni nj b">auth_service_login</code>功能通过将post服务请求重定向到auth service来帮助我们登录。如果成功，我们将有一个JWT，没有错误。如果不成功，我们将没有令牌和错误。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="2dee" class="no kl hi nj b be np nq l nr ns">def auth_service_validate_token(request):<br/>    """Token validation in auth service<br/><br/>    Args:<br/>        request (request): Flask request<br/><br/>    Returns:<br/>        tuple: First item of the tuple will be the decoded token if the request is successfull and 2nd item will be the status code<br/>    """<br/>    if not "Authorization" in request.headers:<br/>        # if there is no "Authorization" header in the request that is coming to "gateway" service, return error<br/>        return None, ("missing credentials", 401)<br/><br/>    token = request.headers["Authorization"]<br/><br/>    if not token:<br/>        # if there is no JWT token return error<br/>        return None, ("missing credentials", 401)<br/><br/>    # post request to auth service to validate the token<br/>    response = httpx.post(<br/>        f"{AUTH_SERVICE_URL}/validate",<br/>        headers={"Authorization": token},<br/>    )<br/><br/>    # auth service returns us the token and status code<br/>    if response.status_code == 200:<br/>        return response.text, None<br/>    else:<br/>        return None, (response.text, response.status_code)</span></pre><p id="ed9a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个<code class="du ng nh ni nj b">auth_service_validate_token</code>函数将post服务请求重定向到auth服务验证端点。与<code class="du ng nh ni nj b">auth_service_login</code>功能的工作方式相同。</p><p id="1696" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经准备好实现这个服务的端点了。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="c650" class="no kl hi nj b be np nq l nr ns"><br/>@app.route("/login", methods=["POST"])<br/>def login():<br/>    # get the token by using gateway service (we can think that the request will be redirected to the auth service)<br/>    token, err = auth_service_login(request)<br/>    if not err:<br/>        return token<br/>    else:<br/>        return err<br/><br/><br/>@app.route("/posts", methods=["POST"])<br/>def post_posts():<br/>    # firstly validate the token by using gateway service. By doing that we enforce to make the user to be logged in<br/>    token, err = auth_service_validate_token(request)<br/>    if err:<br/>        return err<br/>    else:<br/>        POSTS_DB.append(request.json)<br/>        return {"msg": "success", "data": request.json}<br/><br/><br/>@app.route("/posts", methods=["GET"])<br/>def get_posts():<br/>    # firstly validate the token by using gateway service. By doing that we enforce to make the user to be logged in<br/>    token, err = auth_service_validate_token(request)<br/>    if err:<br/>        return err<br/><br/>    token = json.loads(token)  # we get decoded token<br/><br/>    return {"posts": POSTS_DB}</span></pre><p id="e875" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们准备试验网关服务。</p><h2 id="93e1" class="ms kl hi bd km mt mu mv kq mw mx my ku jg mz na kw jk nb nc ky jo nd ne la nf bi translated">网关测试</h2><p id="85ab" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">我将向网关服务的登录端点发出请求。</p><blockquote class="nt nu nv"><p id="7975" class="ix iy nw iz b ja jb ij jc jd je im jf nx jh ji jj ny jl jm jn nz jp jq jr js hb bi translated">我通过使用不同的端口号来分离服务。<code class="du ng nh ni nj b">5000</code>用于<code class="du ng nh ni nj b">auth</code>服务，<code class="du ng nh ni nj b">8080</code>用于<code class="du ng nh ni nj b">gateway</code>服务。</p></blockquote><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="a41d" class="no kl hi nj b be np nq l nr ns">httpx -m POST --auth user@user.com Passw0rd http://127.0.0.1:8080/login</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es oa"><img src="../Images/19208529dd17261868b04decdcf31010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DflRgDZgIC1kwmzwJvlH2w.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者图片</figcaption></figure></div><div class="ab cl ob oc gp od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="hb hc hd he hf"><p id="af25" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以通过使用从网关登录端点获得的令牌来获得帖子列表。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="a633" class="no kl hi nj b be np nq l nr ns">httpx -m GET -h "Authorization" "Bearer &lt;TOKEN&gt;" http://127.0.0.1:8080/posts</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es oa"><img src="../Images/2d5df493d9669ca25ef48613e29bddbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-9A0__b7D-RdVF5T93h37Q.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者图片</figcaption></figure></div><div class="ab cl ob oc gp od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="hb hc hd he hf"><p id="456b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以添加新的帖子。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="dbc1" class="no kl hi nj b be np nq l nr ns">httpx -m POST -h "Authorization" "Bearer &lt;TOKEN&gt;" -j '{"id":1, "title": "Title Text"}' http://127.0.0.1:8080/posts<br/><br/>httpx -m POST -h "Authorization" "Bearer &lt;TOKEN&gt;" -j '{"id":2, "title": "Post 2"}' http://127.0.0.1:8080/posts<br/><br/>httpx -m POST -h "Authorization" "Bearer &lt;TOKEN&gt;" -j '{"id":3, "title": "Post 3"}' http://127.0.0.1:8080/posts</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es oa"><img src="../Images/d559b3389bcdb260ca711ba84c133c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0CJNaaP-Mf3a3qidUPt8uQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者图片</figcaption></figure></div><div class="ab cl ob oc gp od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="hb hc hd he hf"><p id="792c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果一切顺利，我们应该会看到我们添加的帖子。</p><pre class="ju jv jw jx fd nk nj nl bn nm nn bi"><span id="f98e" class="no kl hi nj b be np nq l nr ns">httpx -m GET -h "Authorization" "Bearer &lt;TOKEN&gt;" http://127.0.0.1:8080/posts</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es oa"><img src="../Images/ae69eba418414ed8e5a6834ad3907306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ejImPB0sxEdncxvIi7nNJQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者图片</figcaption></figure><h1 id="10ab" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后</h1><p id="d0c3" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">希望你喜欢并觉得有帮助。我想增强自己的知识，学习身份认证的基础知识。我不再只是复制和粘贴代码来使它运行(老实说，我已经没有这样做🥲).</p></div><div class="ab cl ob oc gp od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="hb hc hd he hf"><p id="402a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以通过下面的链接找到我们在文中使用的代码。</p><div class="lh li ez fb lj lk"><a href="https://github.com/mebaysan/Auth-101" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hj fi z dy lp ea eb lq ed ef hh bi translated">GitHub - mebaysan/Auth-101:不同服务之间的基本JWT认证</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">github.com</p></div></div><div class="lt l"><div class="oi l lv lw lx lt ly kd lk"/></div></div></a></div></div><div class="ab cl ob oc gp od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="hb hc hd he hf"><p id="22d8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，你可以订阅我的Youtube频道来观看视频中的文字🤓</p><div class="lh li ez fb lj lk"><a href="https://www.youtube.com/@BaysanSoft" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hj fi z dy lp ea eb lq ed ef hh bi translated">BaysanSoft</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">本·穆罕默德·埃内斯·巴伊桑·梅尔哈巴拉尔。亚萨姆·于波。“i̇lmin…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">www.youtube.com</p></div></div><div class="lt l"><div class="oj l lv lw lx lt ly kd lk"/></div></div></a></div><p id="d2d6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">问候</p></div></div>    
</body>
</html>