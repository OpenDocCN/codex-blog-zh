<html>
<head>
<title>Extending Go Struct tags without getting (too) dirty</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扩展Go Struct标记而不变得(太)脏</h1>
<blockquote>原文：<a href="https://medium.com/codex/extending-go-struct-tags-without-getting-too-dirty-8bf14cd61d1f?source=collection_archive---------2-----------------------#2022-07-26">https://medium.com/codex/extending-go-struct-tags-without-getting-too-dirty-8bf14cd61d1f?source=collection_archive---------2-----------------------#2022-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e20f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为软件开发人员，有时我们希望扩展内置的语言特性，但通常我们会得出这样的结论:无缝地添加这些特性会非常痛苦和费力。</p><p id="9d8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们将看到如何扩展Go现有的Struct标签，而不会有太多的痛苦，同时仍然得到我们想要的回报！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/f61fcded8f1665a61aeacdfaa4ee66fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NXh9dFwSeueEofyh"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae jt" href="https://unsplash.com/@gillyberlin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">吉利</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="a1fb" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是结构标签？</h1><p id="1815" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">结构标记是一种“表示特定范围内结构字段的预期行为”的方式。</p><p id="6c39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是有史以来最好的解释，但通过一个例子会变得很清楚:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="53f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的结构中，我们使用json标记来描述每个结构字段的预期行为，即:当转换为json时它将具有的名称，以及如果该字段没有值(omitempty)该怎么办。</p><p id="31f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着，在将上述结构的一个实例编组到json之后，输出将类似于以下内容:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="f874" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，这些字段采用了我们在json标记中指定的名称。此外，因为没有提供电子邮件，并且电子邮件字段有“omitempty”关键字，所以它不会显示在结构的json表示中。</p><h1 id="629b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如何扩展功能</h1><p id="d2ed" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在，回到核心主题:“我们怎样才能不太费事地扩展标签的功能？”。让我们使用json标记作为测试主题。</p><p id="d214" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一个显而易见的功能，如果能得到支持就太好了，那就是“required”关键字。</p><p id="652d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">必需的</strong>关键字将通过在结构声明中指定哪些字段必须有一个值才能使json主体符合该结构，从而使json摄取更加干净。</p><p id="d62d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，目前还不支持它，这意味着必须对摄取的json进行额外的验证。通常通过某种验证功能。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/264ddae333394be0fb9a7fa2bda0e06e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CDCbUe8e7H4qGX8l"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@helloimnik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">你好我是Nik </a>上<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="8bf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，有几种方法可以增加这个功能，而不需要为每个结构使用我们自己的验证函数:</p><ol class=""><li id="90cb" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">创建我们自己的Go的<a class="ae jt" href="https://pkg.go.dev/encoding/json#Unmarshaler" rel="noopener ugc nofollow" target="_blank">解组器接口</a>的实现，并使用它代替默认的接口→ <em class="li">太多的工作</em>。</li><li id="f282" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated">使用json模式验证器，比如<a class="ae jt" href="https://github.com/xeipuuv/gojsonschema" rel="noopener ugc nofollow" target="_blank">这个</a> → <em class="li">很棒的东西，但是对于我们想要的一件小事来说，它仍然是你的项目的一个依赖。</em></li><li id="3f50" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated">使用反射来检测您的新关键字，并在当前支持的行为之上支持它们→😎🥳</li></ol><h1 id="af6a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">履行</h1><p id="0d3d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们的<em class="li">工作方式</em>基本上是包装Go已经提供的东西，并通过反射处理我们的新标签。</p><p id="bd32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望<strong class="ih hj">尽可能做到无缝</strong>，因此:</p><ul class=""><li id="408f" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc lo lf lg lh bi translated">像当前支持的所有其他关键字一样，required关键字将在json标记中使用。</li><li id="3a97" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc lo lf lg lh bi translated">目前支持的一切都将一如既往地继续工作。</li></ul><p id="8f26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们处理json摄取方式的唯一变化是，从现在开始，我们将使用这个新函数:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="be2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结一下这个功能</strong>中发生的事情:</p><ol class=""><li id="e3ad" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">我们用Go的默认json包进行解组，如果一切顺利，我们继续开发我们自己的新东西；</li><li id="e963" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated">我们遍历每个字段并获取json标签；</li><li id="8ea2" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated">我们深入那个标签，检查它是否包含“required”关键字；</li><li id="9715" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc le lf lg lh bi translated">如果它包含所需的关键字，并且该字段的值是该类型的“零值”,那么我们就遇到了问题，应该会失败并显示一条有意义的消息。</li></ol><h1 id="518c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">用法:之前与之后</h1><p id="4fe5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">下面你可以看到生活是如何与常见的方法<em class="li">“JSON。“解组+验证函数”</em>与我们的新方法<em class="li">“标签+改进的解组函数”</em>。</p><ul class=""><li id="e89e" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc lo lf lg lh bi translated"><strong class="ih hj">新关键字+改进的编组函数</strong></li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><ul class=""><li id="a2eb" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc lo lf lg lh bi translated"><strong class="ih hj"> json。解组+验证功能</strong></li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="aee9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的两个例子中可以看出，通过使用我们新的关键字和函数，我们现在有了一个<strong class="ih hj">可重用平台</strong>来验证json主体中的必填字段，而不是必须为我们希望包含必填字段的每个结构编写验证函数。</p><h1 id="89f1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">进一步的改进</h1><p id="6be8" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们在这一点上已经很酷了…但我们可以有更多😈。如果我们不知道在验证自定义标签时遇到的第一个问题，而是知道json主体中存在的每个问题，这不是很好吗？</p><p id="7d5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在已经掌握了这种能力:不是在发现第一个问题时返回，而是将所有问题附加到一个片上，并返回它而不是一个错误。</p><p id="16fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看下面的完整示例。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="9f1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码将返回:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lp"><img src="../Images/3fc56aa416adef4e95175f5e954fbcb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2fuuToDcImkU_x3bM2eSGA.png"/></div></div></figure><p id="345d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们以前的实现只返回发现的第一个错误:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/9bf44af25733b57842557f4948b3174c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g00Tv7xU4GQ42mtmsxEtRQ.png"/></div></div></figure><h1 id="426b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">主要要点</h1><ul class=""><li id="07f5" class="kz la hi ih b ii ks im kt iq lr iu ls iy lt jc lo lf lg lh bi translated">我们可以通过包装现有流程和使用反射来轻松扩展Go中的标签。</li><li id="d4bc" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc lo lf lg lh bi translated">我们可以很容易地使我们的代码更加紧凑，可重用和可读。</li><li id="a561" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc lo lf lg lh bi translated">除了扩展现有的标签，我们还可以为除json处理之外的场景添加对我们自己的新标签的支持。明确的用例将是格式化、修订PII、可空性检查等。</li><li id="f74b" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc lo lf lg lh bi translated">这很容易(只是增加了一个功能)，也不痛苦(我们编写代码的方式几乎是一样的)，而且我们确实获得了好处😎</li><li id="8aa8" class="kz la hi ih b ii lj im lk iq ll iu lm iy ln jc lo lf lg lh bi translated">除了增加功能之外，我们还可以通过丰富典型的操作方式来改善现状:我们不返回第一个错误，而是返回json主体中关于新标签验证的所有错误。😈</li></ul></div></div>    
</body>
</html>