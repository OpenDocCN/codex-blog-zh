<html>
<head>
<title>The cost and benefit of synchronous replication in PostgreSQL and YugabyteDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL和YugabyteDB中同步复制的成本和收益</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-cost-and-benefit-of-synchronous-replication-in-postgresql-and-yugabytedb-b0490c4d68b4?source=collection_archive---------6-----------------------#2021-10-07">https://medium.com/codex/the-cost-and-benefit-of-synchronous-replication-in-postgresql-and-yugabytedb-b0490c4d68b4?source=collection_archive---------6-----------------------#2021-10-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/087add9f3cbad11a2d115a9fcce5f772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BAsfNTpkEhRJnHfA"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">穆罕默德·拉赫马尼在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="ca71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我见过一个人比较YugabyteDB和PostgreSQL，当在一个会话中运行一个简单的测试时，对不同的吞吐量感到惊讶。分布式数据库的目的是向外扩展。当在单个节点上运行而不需要无数据丢失的高可用性时(这是一个同义反复)，一个整体数据库将总是以较低的延迟执行。因为分布式数据库旨在通过RPC(远程过程调用)而不是本地写入来确保持久性(ACID中的D)。</p><p id="5f78" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一个简单的工作负载:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="8461" class="kc kd hi jy b fi ke kf l kg kh">drop table if exists demo;<br/>create table demo(<br/> i int primary key,<br/> t timestamp default clock_timestamp()<br/>);</span><span id="8f5c" class="kc kd hi jy b fi ki kf l kg kh">\timing on</span><span id="d86a" class="kc kd hi jy b fi ki kf l kg kh">do $$ <br/> begin<br/>  truncate demo; <br/>  for i in 1..1e4 loop<br/>   insert into demo(i) values(i);<br/>   commit; <br/>  end loop; <br/> end; <br/>$$;</span><span id="eaa5" class="kc kd hi jy b fi ki kf l kg kh">select<br/> count(*)/extract(epoch from max(t)-min(t)) "rows/s",<br/> count(*),max(t)-min(t) "duration"<br/> from demo;</span></pre><h1 id="4489" class="kj kd hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">YugabyteDB</h1><p id="ade4" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">以下是当前生产(稳定)版本中的运行情况，RF=3，所有节点都在同一虚拟机上(对于此测试，为了独立于网络延迟，您不会在生产中这样做):</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="6373" class="kc kd hi jy b fi ke kf l kg kh">[postgres@yb0 ~]$ psql -p 5433</span><span id="e702" class="kc kd hi jy b fi ki kf l kg kh">yugabyte=# select version();<br/>                                                  version<br/>------------------------------------------------------------------------------------------------------------<br/> PostgreSQL 11.2-YB-2.6.1.0-b0 on x86_64-pc-linux-gnu, compiled by gcc (Homebrew gcc 5.5.0_4) 5.5.0, 64-bit</span><span id="ee4f" class="kc kd hi jy b fi ki kf l kg kh">yugabyte=# do $$ begin truncate demo; for i in 1..1e4 loop insert into demo(i) values(i); commit; end loop; end; $$;<br/>DO<br/>Time: 37130.036 ms (00:37.130)</span><span id="6c85" class="kc kd hi jy b fi ki kf l kg kh">yugabyte=# select count(*)/extract(epoch from max(t)-min(t)) "rows/s",count(*),max(t)-min(t) "duration" from demo;</span><span id="3cb8" class="kc kd hi jy b fi ki kf l kg kh">      rows/s      | count |    duration<br/>------------------+-------+-----------------<br/> 270.115078207229 | 10000 | 00:00:37.021258</span></pre><p id="7146" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数字本身并不重要。这是一个在一台虚拟机上的实验室，但是我将在同一台机器上运行所有的东西来比较吞吐量。</p><h1 id="ed87" class="kj kd hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">PostgreSQL无HA</h1><p id="cc8e" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我正在同一台服务器上启动PostgreSQL:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c202" class="kc kd hi jy b fi ke kf l kg kh">/usr/pgsql-13/bin/initdb -D /var/tmp/pgdata<br/>echo "port=5432" &gt;&gt; /var/tmp/pgdata/postgresql.conf<br/>/usr/pgsql-13/bin/pg_ctl -D /var/tmp/pgdata -l logfile start</span></pre><p id="4961" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并运行相同的:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3505" class="kc kd hi jy b fi ke kf l kg kh">[postgres@yb0 ~]$ psql -p 5432</span><span id="0ace" class="kc kd hi jy b fi ki kf l kg kh">postgres=# select version();</span><span id="63ac" class="kc kd hi jy b fi ki kf l kg kh">                                                version<br/>-------------------------------------------------------------------------------------------------------------<br/> PostgreSQL 13.4 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 8.4.1 20200928 (Red Hat 8.4.1-1), 64-bit</span><span id="f5dc" class="kc kd hi jy b fi ki kf l kg kh">postgres=# do $$ begin truncate demo; for i in 1..1e4 loop insert into demo(i) values(i); commit; end loop; end; $$;<br/>DO<br/>Time: 5533.086 ms (00:05.533)</span><span id="f0e6" class="kc kd hi jy b fi ki kf l kg kh">postgres=# select count(*)/extract(epoch from max(t)-min(t)) "rows/s",count(*),max(t)-min(t) "duration" from demo;</span><span id="a872" class="kc kd hi jy b fi ki kf l kg kh">       rows/s       | count |    duration<br/>-------------------------+-------+-----------------<br/> 1809.0359900474075 | 10000 | 00:00:05.527806</span></pre><p id="8893" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是为什么你认为PostgreSQL更快。是的，这里的每秒事务数是1:7。</p><p id="e5e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是我们是在比较苹果和橘子的弹性。YugabyteDB在复制因子RF=3的情况下运行，因此每次写入都会传播到3个副本中的2个。在RF=3的Yugabyte集群中，您可以删除一个节点，并且:</p><ul class=""><li id="f8ce" class="ll lm hi ix b iy iz jc jd jg ln jk lo jo lp js lq lr ls lt bi translated">2/3的读取和写入继续运行，就像什么都没发生一样。多亏了将桌子分割成平板电脑。</li><li id="fd13" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">1/3的读取和写入，即那些其领导者在失效节点上的读取和写入，必须等待几秒钟才能让幸存节点上的一个跟随者被选举为新的领导者(Raft协议)</li></ul><p id="4310" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一切都在继续，因为我们有法定人数。一切都是一致的。并且没有丢失任何提交的事务。唯一的后果是，在第一个节点恢复或添加新节点之前，丢失第二个节点将会停止数据库。仍然没有数据丢失。但是根据定义，RF=3只能容忍一个节点停机。</p><p id="0e8e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种保护涉及远程过程调用。让我们看看PostgreSQL在更高的可用性下会如何表现</p><h1 id="0f36" class="kj kd hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">带备用数据库的PostgreSQL</h1><p id="e4b9" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我将向我的PostgreSQL集群添加两个备用数据库:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="4b3b" class="kc kd hi jy b fi ke kf l kg kh">/usr/pgsql-13/bin/pg_basebackup -p 5432 -D /var/tmp/pgsby1 -R --slot=sby1 -C<br/>echo "port=5441" &gt;&gt; /var/tmp/pgsby1/postgresql.conf<br/>touch /var/tmp/pgsby1/recovery.signal<br/>/usr/pgsql-13/bin/pg_ctl -D /var/tmp/pgsby1 -l logfile start</span><span id="4e8f" class="kc kd hi jy b fi ki kf l kg kh">/usr/pgsql-13/bin/pg_basebackup -p 5432 -D /var/tmp/pgsby2 -R --slot=sby2 -C<br/>echo "port=5442" &gt;&gt; /var/tmp/pgsby2/postgresql.conf<br/>touch /var/tmp/pgsby2/recovery.signal<br/>/usr/pgsql-13/bin/pg_ctl -D /var/tmp/pgsby2 -l logfile start</span></pre><p id="31c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从主视图中可以看到它们:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2d3b" class="kc kd hi jy b fi ke kf l kg kh">[postgres@yb0 ~]$ psql -p 5432 -c "select * from pg_replication_slots"</span><span id="1fab" class="kc kd hi jy b fi ki kf l kg kh"> slot_name | plugin | slot_type | datoid | database | temporary | active | active_pid | xmin | catalog_xmin | restart_lsn | confirmed_flush_lsn | wal_status | safe_wal_size<br/>----------------+--------+-----------+--------+----------+-----------+--------+------------+------+--------------+-------------+---------------------+------------+---------------<br/> sby1      |        | physical  |        |          | f         | t      |     298963 |      |              | 0/5000060   |                     | reserved   |<br/> sby2      |        | physical  |        |          | f         | t      |     299054 |      |              | 0/5000060   |                     | reserved   |<br/>(2 rows)</span><span id="35ff" class="kc kd hi jy b fi ki kf l kg kh">[postgres@yb0 ~]$ psql -p 5432 -c "select * from pg_stat_replication"</span><span id="b618" class="kc kd hi jy b fi ki kf l kg kh">  pid   | usesysid | usename  | application_name | client_addr | client_hostname | client_port |         backend_start         | backend_xmin |   state   | sent_lsn  | write_lsn | flush_lsn | replay_lsn | write_lag | flush_lag | replay_la<br/>g | sync_priority | sync_state |          reply_time<br/>-------------+----------+----------+------------------+-------------+-----------------+-------------+-------------------------------+--------------+-----------+-----------+-----------+-----------+------------+-----------+-----------+----------<br/>--+---------------+------------+-------------------------------<br/> 298963 |       10 | postgres | walreceiver      |             |                 |          -1 | 2021-09-28 13:03:45.30363+00  |              | streaming | 0/5000060 | 0/5000060 | 0/5000060 | 0/5000060  |           |           |<br/>  |             0 | async      | 2021-09-28 13:04:23.662693+00<br/> 299054 |       10 | postgres | walreceiver      |             |                 |          -1 | 2021-09-28 13:03:48.668362+00 |              | streaming | 0/5000060 | 0/5000060 | 0/5000060 | 0/5000060  |           |           |<br/>  |             0 | async      | 2021-09-28 13:04:23.663322+00<br/>(2 rows)</span></pre><p id="1748" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是两个异步备用服务器，接收流式传输的数据。</p><p id="cd0a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我运行同样的小型工作负载:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="5299" class="kc kd hi jy b fi ke kf l kg kh">postgres=# do $$ begin truncate demo; for i in 1..1e4 loop insert into demo(i) values(i); commit; end loop; end; $$;<br/>select count(*)/extract(epoch from max(t)-min(t)) "rows/s",count(*),max(t)-min(t) "duration" from demo;<br/>DO<br/>Time: 6437.456 ms (00:06.437)</span><span id="f019" class="kc kd hi jy b fi ki kf l kg kh">postgres=# select count(*)/extract(epoch from max(t)-min(t)) "rows/s",count(*),max(t)-min(t) "duration" from demo;</span><span id="5d2a" class="kc kd hi jy b fi ki kf l kg kh">       rows/s       | count |    duration<br/>-------------------------+-------+-----------------<br/> 1554.5772428235664 | 10000 | 00:00:06.432617</span></pre><p id="3ef1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这还是挺快的。但是这就是高可用性吗？一点也不。是的，在主数据库完全失败的情况下，我不需要恢复备份，并且可以故障转移到其中一个备用数据库。但是:</p><ul class=""><li id="9649" class="ll lm hi ix b iy iz jc jd jg ln jk lo jo lp js lq lr ls lt bi translated">我将丢失一些提交的事务，因为我处于异步复制状态。恢复点目标是RPO&gt;0</li><li id="6785" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">由于上述原因，这不能自动化。在打开备用站点之前，您需要一个人的决策来评估数据丢失的风险，以及恢复发生故障的主站点的可能性，至少恢复带有最新事务的WAL。在实践中，人为决策意味着以小时为单位的恢复时间目标:RTO&gt;0</li></ul><p id="ba06" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是无法与YugabyteDB复制相比的，在YugabyteDB复制中，所有操作都在几秒钟内自动完成，没有数据丢失。</p><h1 id="1c38" class="kj kd hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">带同步备用的PostgreSQL</h1><p id="9bfb" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我们可以通过同步复制降低RPO:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="fe07" class="kc kd hi jy b fi ke kf l kg kh">echo "synchronous_standby_names = '*'" &gt;&gt; /var/tmp/pgdata/postgresql.conf<br/>/usr/pgsql-13/bin/pg_ctl -D /var/tmp/pgdata reload</span></pre><p id="04c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种配置确保在我们向用户返回成功的提交之前，一个备用数据库收到了覆盖事务的WAL:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7f6e" class="kc kd hi jy b fi ke kf l kg kh">[postgres@yb0 ~]$ psql -p 5432 -c "select * from pg_stat_replication"</span><span id="aa05" class="kc kd hi jy b fi ki kf l kg kh">  pid   | usesysid | usename  | application_name | client_addr | client_hostname | client_port |         backend_start         | backend_xmin |   state   | sent_lsn  | write_lsn | flush_lsn | replay_lsn | write_lag | flush_lag | replay_la<br/>g | sync_priority | sync_state |          reply_time<br/>-------------+----------+----------+------------------+-------------+-----------------+-------------+-------------------------------+--------------+-----------+-----------+-----------+-----------+------------+-----------+-----------+----------<br/>--+---------------+------------+-------------------------------</span><span id="e6a7" class="kc kd hi jy b fi ki kf l kg kh"> 298963 |       10 | postgres | walreceiver      |             |                 |          -1 | 2021-09-28 13:03:45.30363+00  |              | streaming | 0/538E3F0 | 0/538E3F0 | 0/538E3F0 | 0/538E3F0  |           |           |<br/>  |             1 | sync       | 2021-09-28 13:14:12.307231+00<br/> 299054 |       10 | postgres | walreceiver      |             |                 |          -1 | 2021-09-28 13:03:48.668362+00 |              | streaming | 0/538E3F0 | 0/538E3F0 | 0/538E3F0 | 0/538E3F0  |           |           |<br/>  |             1 | potential  | 2021-09-28 13:14:12.307294+00<br/>(</span></pre><p id="7432" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果我再次运行我的小工作量:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="06c0" class="kc kd hi jy b fi ke kf l kg kh">postgres=# do $$ begin truncate demo; for i in 1..1e4 loop insert into demo(i) values(i); commit; end loop; end; $$;<br/>DO<br/>Time: 13613.487 ms (00:13.613)</span><span id="84ca" class="kc kd hi jy b fi ki kf l kg kh">postgres=# select count(*)/extract(epoch from max(t)-min(t)) "rows/s",count(*),max(t)-min(t) "duration" from demo;</span><span id="0075" class="kc kd hi jy b fi ki kf l kg kh">      rows/s      | count |    duration<br/>-----------------------+-------+-----------------<br/> 734.861683966413 | 10000 | 00:00:13.608003</span></pre><p id="8a30" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">吞吐量被除以2。</p><p id="398f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们这里的可用性高吗？这种同步配置需要复杂的监控和管理。因为，即使在同步中，WAL的持久化也不会同时发生:首先写入并(fsync'd)然后发送(并确认)到备用数据库，然后向用户返回“提交成功”。这里没有两阶段提交。在失败的情况下，这与我们在分布式数据库中发现的一致协议非常不同。PostgreSQL数据库通常与ASYNC一起使用，这是一个非常好的DR(灾难恢复)解决方案，在手动故障转移后数据丢失最少。同步复制是可能的，但不如分布式数据库那样高的可用性。</p><p id="f856" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数字在这里并不重要。它们将依赖于您的机器和网络。分布式数据库可以在多AZ集群甚至多区域中同步。关键是单个会话的吞吐量较低。但是，因为所有节点都是活动的，所以当在所有节点上对多个会话进行负载平衡时，这种情况会向外扩展。对于只读PostgreSQL备用数据库，您无法做到这一点。</p><h1 id="5942" class="kj kd hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">YugabyteDB横向扩展</h1><p id="c207" class="pw-post-body-paragraph iv iw hi ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hb bi translated">我将在我的表中为工号添加一个“j”列:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="53b8" class="kc kd hi jy b fi ke kf l kg kh">drop table if exists demo;<br/>create table demo(<br/> j int, i int,<br/> t timestamp default clock_timestamp(),<br/> primary key(j,i)<br/>);</span></pre><p id="891d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并运行3个并行作业进行相同的插入:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="8082" class="kc kd hi jy b fi ke kf l kg kh">for i in {0..2} ; do<br/>psql -h yb$i -p 5433 -c 'do $$ begin for i in 1..1e4 loop insert into demo(j,i) values('$i',i); commit; end loop; end; $$ ; ' &amp;<br/>done ; wait</span></pre><p id="486e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果如下:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="ead7" class="kc kd hi jy b fi ke kf l kg kh">postgres=# select j, count(*)/extract(epoch from max(t)-min(t)) "rows/s",count(*),max(t)-min(t) "duration"<br/>           from demo group by j;</span><span id="069d" class="kc kd hi jy b fi ki kf l kg kh"> j |      rows/s      | count |    duration<br/>--------+------------------+-------+-----------------<br/> 0 | 181.329577731828 | 10000 | 00:00:55.148201<br/> 2 | 180.088033513951 | 10000 | 00:00:55.528398<br/> 1 | 188.044672569376 | 10000 | 00:00:53.178853<br/>(3 rows)</span></pre><p id="f589" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的3个并发会话中，我每秒插入了550个事务。再说一次，这是一个小实验室。虽然单会话短事务由于提交的分布式特性而具有有限的速率，但是它可以扩展到许多节点。如果您停留在一个虚拟机上，而没有同步复制到另一个站点，PostgreSQL会更快。分布式数据库显示其全部能力的地方是当您添加节点时，为了高可用性和负载平衡，而没有增加复杂性，因为所有的分布式协议已经存在。</p><p id="af40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个简短的测试中，还有一些你看不到的东西。PostgreSQL不能无限期地支持这些插入。共享缓冲区已满，将出现检查点，文件系统缓存将同步到磁盘。最重要的是:在某些时候，您需要在事务id回绕之前清空表，否则数据库会挂起。在PostgreSQL中，insert的前几分钟是非常乐观的，这对于短时间的活动高峰来说是没有问题的。</p><p id="76d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，我以前写过类似的关于RDS PostgreSQL和Aurora的文章。即使两者都无法横向扩展写入，Aurora中的高可用性也依赖于远程WAL同步来实现更好的高可用性(RPO=0 / RTO只需几分钟)。</p><p id="0c59" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要考虑的参数太多？不要惊慌。因为YugabyteDB与PostgreSQL有相同的API它使用相同的SQL和PL/pgSQL层以及类似的开源许可证——所以您不会被锁定在最初的决定中。你可以从PostgreSQL开始，用YugabyteDB伸缩，反之亦然。</p></div></div>    
</body>
</html>