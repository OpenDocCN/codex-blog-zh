# Linux/Unix 中的管道:快速指南。

> 原文：<https://medium.com/codex/piping-in-linux-unix-a-quick-guide-c1d79d4e90a9?source=collection_archive---------8----------------------->

![](img/dcf73b65cf159f8518d4049fb55ceb53.png)

管道基本上是重定向的一种形式，其中一个 CL 程序的标准输出作为输入发送到 linux 和类似 linux 的操作系统中的另一个 CL 程序。管道决定了多个程序如何相互关联，其中一个程序需要另一个程序的输入。命令由管道字符“|”分隔，它告诉 shell 链接输入和输出。

你可能会问，重定向和管道有什么不同。嗯，*重定向*意在将 *stdout/stderr* 写到一个文件或者从一个文件中读取 *stdin* 。

```
ls -l >list.txtls wefefwf 2> error.txt #assuming "wefefwf" doesn't exist. 
```

*管道*不同于重定向，因为管道将两个或多个命令连接成一个相关的组件，其中一个命令负责提供另一个命令期望的输入。

考虑下面的例子:

```
ls -l | less
```

*less* 命令需要一个文件名来提取要显示的内容。但是通过将它与 *ls* 命令连接在一起，可以将 *ls* 提供的输出转储为 *less* 进行显示。

以下是利用管道的几种情况。

```
ls -l | wc -l
```

在上述命令中，' *wc -l* '用于计算行数。与左半部分的' *ls -l* '一起，结合“|”，可以用来统计 *ls* 命令提供的 *stdout* 的行数。

如果需要，我们可以在上面的例子中添加重定向，将行数存储到一个文件中。它看起来会像这样:

```
ls -l | wc -l > count.txt
```

上面的命令将创建一个 *count.txt* 文件，以防它不存在，并将输出写入其中。但是如果 *count.txt* 文件存在，它将覆盖文件中存在的计数。如果你想把计数添加到文件中，你可以添加一个额外的“>”来实现。

```
ls -l | wc -l >> count.txt
```

在下面的例子中，*文件 1* 、*文件 1* 和*文件 3* 的内容被连接起来，组合输出被发送到 *wc* 命令以计算字数。

```
cat file1 file2 file3 | wc -w
```

# **三通命令。**

在上一个例子中，我们看到了如何使用管道来获得连接在一起的 3 个不同文件的字数。但是如果我们想将连接的结果保存到一个新文件中呢？您可能会认为我们可以通过执行以下命令来做到这一点:

```
cat file1 file2 file3 > new.txt  | wc -w
```

惊喜惊喜！这个命令不起作用。因为 *wc* 命令期望 *stdout* 而不是一个文件。通过执行上面的命令，连接结果已经被发送到一个文件中，对于 *wc* 命令来说没有什么剩余。那么，怎样才能得到我们想要的结果呢？

这就是" *tee* "命令的用武之地。Tee 程序使得使用一个 *stdout* 来实现我们两个的意图成为可能。 *tee* 命令的一般形式如下:

```
<command1> | tee file.txt | <command2>
```

*tee* 程序读取标准输入，并将标准输出和一个文件复制到*。这个命令非常有用，因为它使我们能够在不妨碍整个管道流的情况下捕获中间信息。*

因此，如果我们映射这些知识来从上面的例子中得到我们想要的东西，所需的命令将是，

```
cat file1 file2 file3 | tee  new.txt  | wc -w
```

嗯，这是一个超级短的管道介绍。我希望你对管道的影响有个基本的概念。下次见！