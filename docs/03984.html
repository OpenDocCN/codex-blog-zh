<html>
<head>
<title>5 Useful Features in PostgreSQL 14</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL 14中的5个有用特性</h1>
<blockquote>原文：<a href="https://medium.com/codex/5-useful-features-in-postgresql-14-9e6a7ffd619?source=collection_archive---------0-----------------------#2021-10-14">https://medium.com/codex/5-useful-features-in-postgresql-14-9e6a7ffd619?source=collection_archive---------0-----------------------#2021-10-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/400bf6882d5a6146059be8375a05d185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mpyrgqwMjfclV2oN1U2VIA.jpeg"/></div></div></figure><p id="a3f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">PostgreSQL的新版本最近出来了。一如既往，它带来了一些有趣的更新，其中一些与语法有关，其他的是新功能和性能优化。</p><p id="96d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来看看Postgres 14给我们带来了什么。</p><p id="d0bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另外，如果您有兴趣升级到新版本，您可以简单地这样做:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="2c59" class="jx jy hi jt b fi jz ka l kb kc">brew services stop postgresql<br/>brew upgrade postgresql<br/>brew postgresql-upgrade-database<br/>brew services start postgresql</span></pre><h1 id="40d9" class="kd jy hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak"> 1。无限和-无限</strong></h1><p id="f9f8" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">Postgres支持各种各样的数字类型。我们可以将它们分类为:</p><ul class=""><li id="6e1a" class="lf lg hi is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated"><strong class="is hj">整数类型</strong></li><li id="b8c6" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">任意精度类型</strong></li><li id="3727" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">浮点类型</strong></li><li id="df61" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">序列类型</strong></li></ul><p id="b586" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它们由两字节、四字节和八字节浮点数以及可选的精度小数组成。</p><p id="afd2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是受支持类型的完整列表:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="bdeb" class="jx jy hi jt b fi jz ka l kb kc">Name       | Storage Size |           Description           <br/> ------------------|--------------|--------------------------------- <br/>  smallint         | 2 bytes      | small-range integer             <br/>  integer          | 4 bytes      | typical choice for integer      <br/>  bigint           | 8 bytes      | large-range integer             <br/>  decimal          | variable     | user-specified precision, exact <br/>  numeric          | variable     | user-specified precision, exact <br/>  real             | 4 bytes      | variable-precision, inexact     <br/>  double precision | 8 bytes      | variable-precision, inexact     <br/>  smallserial      | 2 bytes      | small autoincrementing integer  <br/>  serial           | 4 bytes      | autoincrementing integer        <br/>  bigserial        | 8 bytes      | large autoincrementing integer</span></pre><p id="8ea5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了支持标准数值，从Postgres 14开始，它支持<strong class="is hj">无穷大</strong>和<strong class="is hj">-in Infinity</strong>。</p><p id="af8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在SQL命令中将这些值作为常量写入时，必须用引号将它们括起来，例如</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="c21d" class="jx jy hi jt b fi jz ka l kb kc">UPDATE table SET x = ‘-Infinity’.</span></pre><p id="86e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在输入时，这些字符串以不区分大小写的方式被识别。无穷大的值也可以拼写为inf和-inf。</p><p id="cc88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无穷大值的行为符合数学期望。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="453c" class="jx jy hi jt b fi jz ka l kb kc">Infinity + 3 = Infinity</span><span id="095c" class="jx jy hi jt b fi lt ka l kb kc">Infinity + Infinity = Infinity</span></pre><p id="d721" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，如果我们这样做:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6fe4" class="jx jy hi jt b fi jz ka l kb kc">Infinity — Infinity = NaN (not a number)</span></pre><p id="ec63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为它没有明确的解释。请注意，无穷大只能存储在无约束的数字列中，因为它名义上超过了任何有限精度限制。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="1aba" class="kd jy hi bd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz bi translated"><strong class="ak"> 2。JSONB订阅</strong></h1><p id="5b0a" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们知道Postgres在相当一段时间内支持<strong class="is hj"> JSON &amp; JSONB </strong>。JSONB数据类型支持数组样式的下标表达式来提取和修改元素。</p><p id="c25a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果JSONB值是一个数组，数字下标从零开始，负整数从数组的最后一个元素开始倒数。不支持切片表达式。订阅表达式的结果总是JSONB数据类型。</p><p id="8a3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果JSONB值是一个数组(例如jsonArray = [ ])，它的行为与许多编程语言中的行为非常相似:</p><ul class=""><li id="9bd8" class="lf lg hi is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated"><strong class="is hj">数字订阅从零开始</strong> ( jsonArray[0]可访问)</li><li id="f579" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">负整数从数组</strong>的最后一个元素开始倒数(jsonArray[-1]将访问数组的最后一个元素)</li><li id="6dae" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">切片不受支持</strong></li></ul><p id="4e43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">订阅表达式的结果属于JSONB数据类型。</p><p id="b191" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果一个下标路径对于所有受影响的值都是可遍历的，那么所有这些都将起作用。例如，如果我们想访问</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="1027" class="jx jy hi jt b fi jz ka l kb kc">jsonArray[‘a’][‘b’][‘c’]</span></pre><p id="a685" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果每个jsonArray，jsonArray['a']，jsonArray['a']['b']都是一个对象，则路径可以遍历到<em class="mg"> c </em>。</p><p id="a9c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果jsonArray['a']或jsonArray['a']['b']未定义，它将被创建为空对象，并在必要时被填充。</p><p id="66e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果jsonArray本身被定义为一个非对象，比如string、number of JSONB null，那么就会产生一个错误并中止事务。</p><p id="de93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只要存在，下标路径对于所有受影响的值都必须是可遍历的。例如，如果每个val，val['a']，val[' a '][' b '][' c ']都是一个对象，那么路径<strong class="is hj">可以一直遍历到c。如果未定义任何val['a']或val['a']['b']，它将被创建为空对象，并根据需要进行填充。</strong></p><p id="3f7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，如果任何val本身或其中一个中间值被定义为非对象(如字符串、数字或jsonb null ),遍历将无法继续，因此会引发错误并中止事务。</p><p id="d171" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">选择查询的订阅语法示例:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="a2cf" class="jx jy hi jt b fi jz ka l kb kc">— Extract array element by index<br/><strong class="jt hj">SELECT (‘[1, “2”, null]’::jsonb)[1];</strong></span></pre><p id="2101" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者，在更新表语法中:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="426d" class="jx jy hi jt b fi jz ka l kb kc">— Update object value by key. Note the quotes around ‘1’: the assigned</span><span id="7bbd" class="jx jy hi jt b fi lt ka l kb kc">— value must be of the jsonb type as well<br/><strong class="jt hj">UPDATE table_name SET jsonb_field[‘key’] = ‘1’;</strong></span></pre><h1 id="33a4" class="kd jy hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak"> 3。在触发器上添加或替换</strong></h1><p id="29ec" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">如果我们看一下触发器函数声明:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="177b" class="jx jy hi jt b fi jz ka l kb kc">CREATE [ OR REPLACE ] [ CONSTRAINT ] TRIGGER <strong class="jt hj"><em class="mg">name</em></strong> { BEFORE | AFTER | INSTEAD OF } { <strong class="jt hj"><em class="mg">event</em></strong> [ OR … ] }</span><span id="a798" class="jx jy hi jt b fi lt ka l kb kc">ON <strong class="jt hj"><em class="mg">table_name</em></strong></span><span id="4122" class="jx jy hi jt b fi lt ka l kb kc">[ FROM <strong class="jt hj"><em class="mg">referenced_table_name</em></strong> ]</span><span id="fca0" class="jx jy hi jt b fi lt ka l kb kc">[ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]</span><span id="6a11" class="jx jy hi jt b fi lt ka l kb kc">[ REFERENCING { { OLD | NEW } TABLE [ AS ] <strong class="jt hj"><em class="mg">transition_relation_name</em></strong> } [ … ] ]</span><span id="de63" class="jx jy hi jt b fi lt ka l kb kc">[ FOR [ EACH ] { ROW | STATEMENT } ]</span><span id="1d6b" class="jx jy hi jt b fi lt ka l kb kc">[ WHEN ( <strong class="jt hj"><em class="mg">condition</em></strong> ) ]</span><span id="9786" class="jx jy hi jt b fi lt ka l kb kc">EXECUTE { FUNCTION | PROCEDURE } <strong class="jt hj"><em class="mg">function_name</em></strong> ( <strong class="jt hj"><em class="mg">arguments</em></strong> )</span></pre><p id="0594" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">【或替换】</strong>被添加到触发器中，因此您不必在创建新触发器之前删除触发器。您可以通过使用关键字语法<strong class="is hj">或REPLACE </strong>简单地替换现有的触发器。</p><p id="d345" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看一个基本的例子:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="af79" class="jx jy hi jt b fi jz ka l kb kc">CREATE OR REPLACE TRIGGER check_update<br/>BEFORE UPDATE OF balance ON accounts<br/>FOR EACH ROW<br/>EXECUTE FUNCTION check_account_update();</span></pre></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="cabb" class="kd jy hi bd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz bi translated"><strong class="ak"> 4。string_to_table() </strong></h1><p id="a968" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">他们增加了一个新的函数，可以通过分隔符分割字符串，并将结果作为一组文本行返回。</p><p id="7403" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它最多接受3个参数，第一个是您要拆分的字符串，第二个是您要拆分字符串的分隔符，还有第三个可选参数，称为“null_string”，如果提供了该参数，它会用null值替换匹配的字符串。</p><p id="2b19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看一下定义:</p><p id="0f3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">string _ to _ table(<em class="mg">string</em>text，<em class="mg"> delimiter </em> text [，<em class="mg">null _ string</em>text])→setof text</strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="736f" class="jx jy hi jt b fi jz ka l kb kc"><strong class="jt hj">string_to_table(‘aa|bb|cc’, ‘|’, ‘bb’)</strong></span><span id="453a" class="jx jy hi jt b fi lt ka l kb kc">aa<br/>NULL<br/>cc</span></pre></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="1cfb" class="kd jy hi bd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz bi translated"><strong class="ak"> 5。PK，UQ和FK到系统目录</strong></h1><p id="1c88" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">系统编目是RDBMS(关系数据库管理系统)存储模式元数据的地方。</p><p id="2521" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，当您执行<strong class="is hj">创建</strong> <strong class="is hj">数据库</strong>时，postgres会在<strong class="is hj"> pg_database </strong>目录中插入一行，并在磁盘上创建数据库。系统目录只是postgres用来存储模式<strong class="is hj">元数据</strong>的常规表(比如关于表和列的信息，以及内部簿记信息)。</p><p id="fc78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您不应该手动更改系统目录。在过去，postgres函数不能做像现在这样多的事情，所以你可能需要手工做一些事情，但是随着时间的推移，它有了很大的改进。所以，使用函数真的没有什么是你不能做的，而且你特别需要更深入地去做。</p><p id="4998" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总之，您可以删除和重新创建这些表，添加或删除列，插入和更新值..但是这样做可能会严重破坏数据库和系统。</p><p id="b3eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> PostgreSQL 14 </strong>向<a class="ae mh" href="https://www.postgresql.org/docs/14/catalogs.html" rel="noopener ugc nofollow" target="_blank">系统目录</a>添加了主键、唯一约束和外键。</p><p id="8d93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">典型的系统目录表如下所示:</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="mi mj l"/></div><figcaption class="mk ml et er es mm mn bd b be z dx translated">“SELECT * FROM pg_database”的查询结果；`</figcaption></figure></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h2 id="0b10" class="jx jy hi bd ke mo mp mq ki mr ms mt km jb mu mv kq jf mw mx ku jj my mz ky na bi translated">奖励—绩效改进和监控指标</h2><p id="3e60" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">在性能和指标特性方面还有一些额外的改进，例如:</p><ul class=""><li id="1062" class="lf lg hi is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated"><strong class="is hj">改进的活动和空闲连接扩展</strong></li><li id="ed2e" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">pg _ back end _ memory _ contexts的内存使用情况</strong></li><li id="d4a8" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">用pg_stat_wal 跟踪<strong class="is hj"> WAL活动</strong></li><li id="ad06" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">监控查询id为</strong>的查询</li><li id="80d7" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">新的预定义角色<strong class="is hj">pg _ read _ all _ data</strong>/<strong class="is hj">pg _ write _ all _ data</strong>提供全局读取或写入权限</li></ul></div></div>    
</body>
</html>