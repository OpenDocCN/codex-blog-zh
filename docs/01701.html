<html>
<head>
<title>Algorithmic Trading with Average Directional Index in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的平均方向指数算法交易</h1>
<blockquote>原文：<a href="https://medium.com/codex/algorithmic-trading-with-average-directional-index-in-python-2b5a20ecf06a?source=collection_archive---------0-----------------------#2021-05-22">https://medium.com/codex/algorithmic-trading-with-average-directional-index-in-python-2b5a20ecf06a?source=collection_archive---------0-----------------------#2021-05-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="729f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">学习从零开始构建ADX指标，并用python对交易策略进行回溯测试</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/7991a94c98775352eeb0ac16585c59e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lrCqMvUKygih3Nx6"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">约翰尼斯·格罗尔在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3310" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">技术指标有四个不同的分支，但最受欢迎的是趋势指标。这些指标帮助交易者识别市场趋势的方向和强度，并根据它们进行交易。在大多数情况下，趋势类别下的指标揭示了良好的结果，除非我们有效地使用它们。</p><p id="a87d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本文中，我们将探讨最流行的趋势指标之一，平均方向指数(简称ADX)。我们将首先对ADX及其计算建立一些基本的理解，然后，继续从零开始构建指标，并用python构建基于该指标的交易策略。为了评估我们的策略，我们将首先用苹果股票对其进行回溯测试，然后为了更有意义，我们将把我们的策略回报与SPY ETF回报(一种专门设计用于跟踪标准普尔500指数走势的ETF)进行比较。</p><p id="c482" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在继续之前，如果你想在没有任何代码的情况下回溯测试你的交易策略，有一个解决方案。这是<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">的后验区</a>。这是一个平台，可以免费对不同类型的可交易资产的任意数量的交易策略进行回溯测试，无需编码。点击这里的链接，你可以马上使用这个工具:<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">https://www.backtestzone.com/</a></p><h1 id="0a82" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">平均真实距离</h1><p id="0e6d" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在继续探索ADX之前，有必要知道什么是平均真实范围(ATR ),因为它涉及到平均方向指数(ADX)的计算。</p><p id="1e1b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">平均真实范围是一个技术指标，用来衡量一项资产的平均变动幅度。这是一个滞后指标，意味着它考虑了资产的历史数据来衡量当前价值，但它不能预测未来的数据点。在使用ATR时，这不被认为是一个缺点，因为它是更准确地跟踪市场波动的指标之一。ATR是一个滞后指标，也是一个非方向性指标，意味着ATR的运动与市场的实际运动成反比。要计算ATR，必须遵循两个步骤:</p><ul class=""><li id="58ee" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated"><strong class="jq hj">计算真实范围(TR): </strong>资产的真实范围通过取三个价格差的最大值来计算，这三个价格差是:市场高点减去市场低点，市场高点减去先前的市场收盘，先前的市场收盘减去市场低点。它可以表示如下:</li></ul><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="33d2" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">MAX </strong>[ {<strong class="lr hj">HIGH - LOW</strong>}, {<strong class="lr hj">HIGH - P.CLOSE</strong>}, {<strong class="lr hj">P.CLOSE - LOW</strong>} ]</span><span id="25d7" class="lv kl hi lr b fi ma lx l ly lz">where,<br/>MAX = Maximum values<br/>HIGH = Market High<br/>LOW = Market Low<br/>P.CLOSE = Previous market close</span></pre><ul class=""><li id="5dac" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated"><strong class="jq hj">计算ATR: </strong>平均真实范围的计算很简单。我们只需对指定数量的周期取之前计算的真实范围值的平滑平均值。平滑平均线不是普通的均线或均线，而是怀尔德·怀尔斯自己创造的一种平滑平均线，但是使用其他均线没有任何限制。在本文中，为了简单起见，我们将使用SMA来计算ATR，而不是指标创始人创建的自定义移动平均线。以14作为周期数的传统设置来计算ATR可以表示如下:</li></ul><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="b658" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">ATR 14</strong> = <strong class="lr hj">SMA 14</strong> [ <strong class="lr hj">TR </strong>]</span><span id="72ae" class="lv kl hi lr b fi ma lx l ly lz">where,<br/>ATR 14 = 14 Period Average True Range<br/>SMA 14 = 14 Period Simple Moving Average<br/>TR = True Range</span></pre><p id="c06d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当使用ATR作为交易指标时，交易者必须确保他们比以往更加谨慎，因为该指标非常滞后。现在我们已经了解了平均真实范围是什么。现在让我们深入到这篇文章的主要概念，平均方向指数。</p><h1 id="ad92" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">平均方向指数</h1><p id="6047" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">ADX是一种技术指标，广泛用于衡量市场趋势的强度。现在，ADX并不衡量趋势的方向，无论是看涨还是看跌，而只是代表趋势有多强。所以，为了确定趋势的方向，ADX结合了一个正方向指数(+ DI)和一个负方向指数(- DI)。顾名思义，+ DI衡量的是市场的看涨或正趋势，同样地，- DI衡量的是市场的看跌或负趋势。所有组件的值都限制在0到100之间，因此充当振荡器。ADX的传统设置是14作为回看周期。</p><p id="63a4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了计算ADX的值，以14为回看周期，首先确定正向(+ DM)和负向(- DM)运动。通过查找当前高点和前一个高点之间的差值来计算+ DM，类似地，通过查找前一个低点和当前低点之间的差值来计算- DM。它可以表示如下:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="8e60" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">+ DM</strong> = <strong class="lr hj">CURRENT HIGH</strong> - <strong class="lr hj">PREVIOUS HIGH</strong><br/><strong class="lr hj">- DM</strong> = <strong class="lr hj">PREVIOUS LOW</strong> - <strong class="lr hj">CURRENT LOW</strong></span></pre><p id="0a11" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，计算以14为回望期的ATR。现在，使用计算的方向移动和ATR值，计算正方向指数(+ DI)和负方向指数(- DI)。要确定+ DI的值，将正向移动(+ DM)的指数移动平均线(EMA)以14作为回望期，所得值除以之前计算的14天ATR，然后乘以100。这同样适用于确定- DI，但不是采用+ DM的14日均线，而是考虑了负向移动(- DM)。计算+ DI和- DI的公式可表示如下:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="a23f" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">+ DI</strong> <strong class="lr hj">14</strong> = <strong class="lr hj">100 </strong>* [ <strong class="lr hj">EMA 14</strong> ( <strong class="lr hj">+ DM</strong> ) / <strong class="lr hj">ATR 14</strong> ]<br/><strong class="lr hj">- DI</strong> <strong class="lr hj">14 </strong>= <strong class="lr hj">100 </strong>* [ <strong class="lr hj">EMA 14</strong> ( <strong class="lr hj">- DM</strong> ) / <strong class="lr hj">ATR 14</strong> ]</span></pre><p id="b168" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下一步是使用+ DI和- DI来计算方向指数。它可以通过将+ DI和- DI之差的绝对值除以+DI和- DI之和的绝对值乘以100来确定。计算方向指数的公式可表示如下:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="d825" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">DI 14</strong> = | (<strong class="lr hj">+ DI 14</strong>) - (<strong class="lr hj">- DI 14</strong>) | / | (<strong class="lr hj">+ DI 14</strong>) + (<strong class="lr hj">- DI 14</strong>) |  * <strong class="lr hj">100</strong></span></pre><p id="5d4a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后一步是利用确定的方向指数值计算ADX本身。ADX的计算方法是，将之前的方向索引值乘以13(回望周期- 1)，再加上方向索引，然后乘以100。计算ADX值的公式可表示如下:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="dc5b" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">ADX 14</strong> = [ ( <strong class="lr hj">PREV DI 14</strong> * <strong class="lr hj">13 </strong>) + <strong class="lr hj">DI 14 </strong>] * <strong class="lr hj">100</strong></span></pre><p id="cc92" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">ADX不能按原样使用，需要进行平滑处理。自从Wilder Wiles(也是ATR的创始人)创建以来，ADX被我们之前讨论过的自定义移动平均线平滑。在计算ATR时，我们忽略了使用这种自定义移动平均线，因为可以使用其他类型的移动平均线，但在平滑ADX时使用这种移动平均线以获得精确值是必不可少的。</p><p id="b76a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是计算ADX的值的整个过程。现在，让我们讨论如何构建一个简单的基于ADX的交易策略。</p><p id="837b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">关于我们的交易策略:</strong>在本文中，我们将建立一个简单的交叉策略，每当ADX线从下方交叉到25上方，并且+ DI线在- DI线上方时，该策略就会显示买入信号。类似地，每当ADX线从下方交叉到25以上，并且- DI线在+ DI线上方时，就会产生卖出信号。我们的交易策略可以表述如下:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="b5cb" class="lv kl hi lr b fi lw lx l ly lz">IF <strong class="lr hj">P.ADX &lt; 25</strong> AND <strong class="lr hj">C.ADX</strong> &gt; <strong class="lr hj">25 </strong>AND <strong class="lr hj">+ DI LINE</strong> &gt; <strong class="lr hj">- DI LINE</strong> ==&gt; <strong class="lr hj">BUY</strong><br/>IF <strong class="lr hj">P.ADX</strong> &lt; <strong class="lr hj">25 </strong>AND <strong class="lr hj">C.ADX</strong> &gt; <strong class="lr hj">25 </strong>AND <strong class="lr hj">+ DI LINE</strong> &lt; <strong class="lr hj">- DI LINE</strong> ==&gt; <strong class="lr hj">SELL</strong></span></pre><p id="a602" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">本文的理论部分到此结束。现在，让我们从头开始编写这个指标，用python构建讨论过的交易策略，并用苹果股票进行回溯测试，看看一些令人兴奋的结果。我们还将比较我们的ADX交叉策略回报和SPY ETF的回报，以了解我们的交易策略相对于基准的表现如何。事不宜迟，让我们深入编码部分。</p><h1 id="8acc" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">用Python实现</h1><p id="c4c8" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">编码部分分为以下几个步骤:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="f0e7" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">1. Importing Packages<br/>2. Extracting Stock Data from Twelve Data<br/>3. ADX Calculation<br/>4. ADX Indicator Plot<br/>5. Creating the Trading Strategy<br/>6. Plotting the Trading Lists<br/>7. Creating our Position<br/>8. Backtesting<br/>9. SPY ETF Comparison</strong></span></pre><p id="be42" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h1 id="0d77" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">步骤1:导入包</h1><p id="1605" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="9206" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="48fe" class="lv kl hi lr b fi lw lx l ly lz">import pandas as pd<br/>import numpy as np<br/>import requests<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)</span></pre><p id="6385" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经将所有需要的包导入到python中。我们用十二数据的API端点来拉一下苹果的历史数据。</p><h2 id="78e1" class="lv kl hi bd km mb mc md kq me mf mg ku jx mh mi kw kb mj mk ky kf ml mm la mn bi translated">步骤2:从12个数据中提取数据</h2><p id="619f" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将使用twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">提供的API端点提取苹果的历史股票数据。在此之前，请注意twelvedata.com</a><a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank"/>:十二数据公司是领先的市场数据提供商之一，拥有大量适用于所有类型市场数据的API端点。它非常容易与十二数据提供的API进行交互，并且拥有有史以来最好的文档。此外，确保您在<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>上有一个帐户，只有这样，您才能访问您的API密钥(使用API提取数据的重要元素)。</p><p id="c378" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="bc62" class="lv kl hi lr b fi lw lx l ly lz">def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>aapl = get_historical_data('AAPL', '2020-01-01')<br/>aapl</span></pre><p id="e346" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/5619b9548aeaf93cbd2a5f6cfbf3540b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDcFK4R7Xx69UtxA7YmgLw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="446a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们做的第一件事是定义一个名为‘get _ historical _ data’的函数，它将股票的符号(‘symbol’)和历史数据的起始日期(‘start _ date’)作为参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们调用创建的函数来提取苹果公司从2020年开始的历史数据，并将其存储到‘AAPL’变量中。</p><h2 id="521f" class="lv kl hi bd km mb mc md kq me mf mg ku jx mh mi kw kb mj mk ky kf ml mm la mn bi translated">步骤4: ADX计算</h2><p id="3e69" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将按照之前讨论的方法计算ADX的值。</p><p id="491e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="76b3" class="lv kl hi lr b fi lw lx l ly lz">def get_adx(high, low, close, lookback):<br/>    plus_dm = high.diff()<br/>    minus_dm = low.diff()<br/>    plus_dm[plus_dm &lt; 0] = 0<br/>    minus_dm[minus_dm &gt; 0] = 0<br/>    <br/>    tr1 = pd.DataFrame(high - low)<br/>    tr2 = pd.DataFrame(abs(high - close.shift(1)))<br/>    tr3 = pd.DataFrame(abs(low - close.shift(1)))<br/>    frames = [tr1, tr2, tr3]<br/>    tr = pd.concat(frames, axis = 1, join = 'inner').max(axis = 1)<br/>    atr = tr.rolling(lookback).mean()<br/>    <br/>    plus_di = 100 * (plus_dm.ewm(alpha = 1/lookback).mean() / atr)<br/>    minus_di = abs(100 * (minus_dm.ewm(alpha = 1/lookback).mean() / atr))<br/>    dx = (abs(plus_di - minus_di) / abs(plus_di + minus_di)) * 100<br/>    adx = ((dx.shift(1) * (lookback - 1)) + dx) / lookback<br/>    adx_smooth = adx.ewm(alpha = 1/lookback).mean()<br/>    return plus_di, minus_di, adx_smooth<br/><br/>aapl['plus_di'] = pd.DataFrame(get_adx(aapl['high'], aapl['low'], aapl['close'], 14)[0]).rename(columns = {0:'plus_di'})<br/>aapl['minus_di'] = pd.DataFrame(get_adx(aapl['high'], aapl['low'], aapl['close'], 14)[1]).rename(columns = {0:'minus_di'})<br/>aapl['adx'] = pd.DataFrame(get_adx(aapl['high'], aapl['low'], aapl['close'], 14)[2]).rename(columns = {0:'adx'})<br/>aapl = aapl.dropna()<br/>aapl.tail()</span></pre><p id="f82f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/fbcc46fe235af5b5994e2e66ad410910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jMOFHnHvYVWAAUorPzgCBQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="fc6f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们首先定义一个名为“get_adx”的函数，它将股票的高点(“高点”)、低点(“低点”)和收盘数据(“收盘”)以及回望期(“回望”)作为参数。</p><p id="7b63" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在函数内部，我们首先计算+ DM和- DM，并分别存储到“正DM”和“负DM”中。接下来是atr计算，我们首先计算三个差值，并定义一个变量“TR”来存储确定的差值中的最高值，然后，我们计算ATR值并将其存储到“ATR”变量中。</p><p id="20d3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用计算出的方向移动和ATR值，我们正在计算+ DI和- DI，并将它们分别存储到“正DI”和“负DI”变量中。在前面讨论的公式的帮助下，我们正在计算方向指数值并将它们存储到“dx”变量中，并将这些值应用到ADX公式中以计算平均方向指数值。然后，我们定义了一个变量‘adx _ smooth’来存储ADX的平滑值。最后，我们将返回并调用该函数，以14作为回望周期来获取Apple的+ DI、- DI和ADX值。</p><h2 id="c527" class="lv kl hi bd km mb mc md kq me mf mg ku jx mh mi kw kb mj mk ky kf ml mm la mn bi translated">步骤4: ADX图</h2><p id="e379" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将绘制计算出的苹果公司的ADX值，以使其更有意义。这一部分的主要目的不是在编码部分，而是观察图形以获得对平均方向指数的牢固理解。</p><p id="a74c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="ce0c" class="lv kl hi lr b fi lw lx l ly lz">ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(aapl['close'], linewidth = 2, color = '#ff9800')<br/>ax1.set_title('AAPL CLOSING PRICE')<br/>ax2.plot(aapl['plus_di'], color = '#26a69a', label = '+ DI 14', linewidth = 3, alpha = 0.3)<br/>ax2.plot(aapl['minus_di'], color = '#f44336', label = '- DI 14', linewidth = 3, alpha = 0.3)<br/>ax2.plot(aapl['adx'], color = '#2196f3', label = 'ADX 14', linewidth = 3)<br/>ax2.axhline(25, color = 'grey', linewidth = 2, linestyle = '--')<br/>ax2.legend()<br/>ax2.set_title('AAPL ADX 14')<br/>plt.show()</span></pre><p id="772c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/67c4b264e54803cfc027c3ef88962011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vtA8k_rP7Aa56VUuPuPohA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="a133" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的图表分为两个面板:上面的面板显示苹果的收盘价，下面的面板显示ADX的成分。与组件一起，绘制了一条灰色虚线，它只是在水平25处绘制的ADX的阈值。正如我之前所说，ADX并不跟踪趋势的方向，而是跟踪趋势的强度，在图表中可以多次看到，当市场显示出强劲的趋势(上涨或下跌)时，ADX线会上升，当市场必然会盘整时，ADX线会下降。这与两条方向指标线的情况相同。我们可以看到，当市场表现出强劲的上升趋势时,+ DI线上升，在下降趋势时下降，反之亦然。</p><p id="2e2a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">ADX不仅用于量化市场趋势的强度，而且成为识别区间市场(股票在特定的高低水平之间来回移动，显示零动量的市场)的便捷工具。当两条线越来越近时，市场就开始波动，同样，两条线之间的距离越宽，市场就越趋向于波动。那些第一次接触ADX图表的人可能会感到困惑，因为每条线的运动与市场的运动是成正比的。</p><h2 id="5208" class="lv kl hi bd km mb mc md kq me mf mg ku jx mh mi kw kb mj mk ky kf ml mm la mn bi translated">步骤5:创建交易策略</h2><p id="2a3e" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将在python中实现所讨论的平均方向指数交易策略。</p><p id="85c0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="299c" class="lv kl hi lr b fi lw lx l ly lz">def implement_adx_strategy(prices, pdi, ndi, adx):<br/>    buy_price = []<br/>    sell_price = []<br/>    adx_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(prices)):<br/>        if adx[i-1] &lt; 25 and adx[i] &gt; 25 and pdi[i] &gt; ndi[i]:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                adx_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                adx_signal.append(0)<br/>        elif adx[i-1] &lt; 25 and adx[i] &gt; 25 and ndi[i] &gt; pdi[i]:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                adx_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                adx_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            adx_signal.append(0)<br/>            <br/>    return buy_price, sell_price, adx_signal<br/><br/>buy_price, sell_price, adx_signal = implement_adx_strategy(aapl['close'], aapl['plus_di'], aapl['minus_di'], aapl['adx'])</span></pre><p id="8880" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为‘implement _ adx _ strategy’的函数，它将股票价格(‘prices’)和ADX的组成部分(‘PDI’，‘ndi’，‘ADX’)作为参数。</p><p id="7862" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在该函数中，我们创建了三个空列表(buy_price、sell_price和adx_signal ),在创建交易策略时，将在这些列表中追加值。</p><p id="8238" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之后，我们通过for循环实施交易策略。在for循环内部，我们传递某些条件，如果条件得到满足，相应的值将被追加到空列表中。如果购买股票的条件得到满足，买入价将被追加到“buy_price”列表中，信号值将被追加为1，表示购买股票。类似地，如果卖出股票的条件得到满足，卖价将被追加到“sell_price”列表中，信号值将被追加为-1，表示卖出股票。</p><p id="890e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们返回附加了值的列表。然后，我们调用创建的函数并将值存储到各自的变量中。除非我们画出这些值，否则这个列表没有任何意义。所以，让我们画出创建的交易列表的值。</p><h2 id="f6e7" class="lv kl hi bd km mb mc md kq me mf mg ku jx mh mi kw kb mj mk ky kf ml mm la mn bi translated">步骤6:绘制交易信号</h2><p id="970c" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将绘制已创建的交易列表，以使它们有意义。</p><p id="0a98" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="e5ad" class="lv kl hi lr b fi lw lx l ly lz">ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(aapl['close'], linewidth = 3, color = '#ff9800', alpha = 0.6)<br/>ax1.set_title('AAPL CLOSING PRICE')<br/>ax1.plot(aapl.index, buy_price, marker = '^', color = '#26a69a', markersize = 14, linewidth = 0, label = 'BUY SIGNAL')<br/>ax1.plot(aapl.index, sell_price, marker = 'v', color = '#f44336', markersize = 14, linewidth = 0, label = 'SELL SIGNAL')<br/>ax2.plot(aapl['plus_di'], color = '#26a69a', label = '+ DI 14', linewidth = 3, alpha = 0.3)<br/>ax2.plot(aapl['minus_di'], color = '#f44336', label = '- DI 14', linewidth = 3, alpha = 0.3)<br/>ax2.plot(aapl['adx'], color = '#2196f3', label = 'ADX 14', linewidth = 3)<br/>ax2.axhline(25, color = 'grey', linewidth = 2, linestyle = '--')<br/>ax2.legend()<br/>ax2.set_title('AAPL ADX 14')<br/>plt.show()</span></pre><p id="0973" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/6a96c3ac168b3945430ba2321d561212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NUKxEaDgxXu2nJfjFerucA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="f980" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们正在绘制平均方向指数成分以及交易策略产生的买入和卖出信号。我们可以观察到，每当ADX线从下方交叉到25上方，并且+ DI线在- DI线上方时，图表中就会出现绿色的买入信号。类似地，每当ADX线从25以下交叉到25以上，并且+ DI线在- DI线以下时，图表中就会出现红色的卖出信号。</p><h2 id="6d8d" class="lv kl hi bd km mb mc md kq me mf mg ku jx mh mi kw kb mj mk ky kf ml mm la mn bi translated">步骤7:创建我们的职位</h2><p id="49a8" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将创建一个列表，如果我们持有股票，该列表将指示1；如果我们不拥有或持有股票，该列表将指示0。</p><p id="2628" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="6c48" class="lv kl hi lr b fi lw lx l ly lz">position = []<br/>for i in range(len(adx_signal)):<br/>    if adx_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(aapl['close'])):<br/>    if adx_signal[i] == 1:<br/>        position[i] = 1<br/>    elif adx_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = aapl['close']<br/>plus_di = aapl['plus_di']<br/>minus_di = aapl['minus_di']<br/>adx = aapl['adx']<br/>adx_signal = pd.DataFrame(adx_signal).rename(columns = {0:'adx_signal'}).set_index(aapl.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'adx_position'}).set_index(aapl.index)<br/><br/>frames = [close_price, plus_di, minus_di, adx, adx_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy</span></pre><p id="bdb0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/76ce9a83b48cbdfba73d0abb9fe7db7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SeKGBnJtF_rHEUmpGN8_3A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="ab95" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们创建一个名为‘position’的空列表。我们传递两个for循环，一个是为“位置”列表生成值，以匹配“信号”列表的长度。另一个for循环是我们用来生成实际位置值的循环。在第二个for循环中，我们对“signal”列表的值进行迭代，而“position”列表的值被附加到满足哪个条件上。如果我们持有股票，头寸的价值仍为1；如果我们卖出或不持有股票，头寸的价值仍为0。最后，我们正在进行一些数据操作，将所有创建的列表合并到一个数据帧中。</p><p id="769e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从显示的输出中，我们可以看到，在第一行中，我们在股票中的位置仍然是1(因为ADX信号没有任何变化)，但是当ADX交易信号代表卖出信号(-1)时，我们的位置突然变成-1。我们的头寸将保持为0，直到交易信号发生一些变化。现在是时候实现一些回溯测试过程了！</p><h2 id="1459" class="lv kl hi bd km mb mc md kq me mf mg ku jx mh mi kw kb mj mk ky kf ml mm la mn bi translated">步骤8:回溯测试</h2><p id="f680" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在继续之前，有必要知道什么是回溯测试。回溯测试是查看我们的交易策略在给定股票数据上表现如何的过程。在我们的例子中，我们将对苹果股票数据的平均方向指数交易策略实施回溯测试过程。</p><p id="7259" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="c1fb" class="lv kl hi lr b fi lw lx l ly lz">aapl_ret = pd.DataFrame(np.diff(aapl['close'])).rename(columns = {0:'returns'})<br/>adx_strategy_ret = []<br/><br/>for i in range(len(aapl_ret)):<br/>    returns = aapl_ret['returns'][i]*strategy['adx_position'][i]<br/>    adx_strategy_ret.append(returns)<br/>    <br/>adx_strategy_ret_df = pd.DataFrame(adx_strategy_ret).rename(columns = {0:'adx_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/aapl['close'][-1])<br/>adx_investment_ret = []<br/><br/>for i in range(len(adx_strategy_ret_df['adx_returns'])):<br/>    returns = number_of_stocks*adx_strategy_ret_df['adx_returns'][i]<br/>    adx_investment_ret.append(returns)<br/><br/>adx_investment_ret_df = pd.DataFrame(adx_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(adx_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the ADX strategy by investing $100k in AAPL : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the ADX strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre><p id="cb56" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="42ab" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">Profit gained from the ADX strategy by investing $100k in AAPL : 30375.66</strong><br/><strong class="lr hj">Profit percentage of the ADX strategy : 30%</strong></span></pre><p id="d0fd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们使用NumPy包提供的‘diff’函数计算苹果股票的回报，并将其作为数据帧存储到‘AAPL _ ret’变量中。接下来，我们将传递一个for循环来迭代' aapl_ret '变量的值，以计算我们从ADX交易策略中获得的回报，这些回报值将被追加到' adx_strategy_ret '列表中。接下来，我们将“adx_strategy_ret”列表转换为数据帧，并将其存储到“adx_strategy_ret_df”变量中。</p><p id="49d8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是回溯测试过程。我们将通过投资10万美元到我们的交易策略中来回测我们的策略。首先，我们将投资金额存储到“投资值”变量中。之后，我们正在计算使用投资金额可以购买的苹果股票数量。你可以注意到，我使用了Math软件包提供的“floor”函数，因为当投资金额除以苹果股票的收盘价时，它会输出一个十进制数。股票数量应该是整数，而不是小数。使用“底数”函数，我们可以去掉小数。请记住,“floor”函数比“round”函数要复杂得多。然后，我们传递一个for循环来查找投资回报，后面是一些数据操作任务。</p><p id="72b2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们打印了我们通过投资10万美元到我们的交易策略中得到的总回报，显示我们在一年中获得了大约3万美元的利润。那还不错！现在，让我们将我们的回报与SPY ETF(一种旨在跟踪标准普尔500股票市场指数的ETF)的回报进行比较。</p><h2 id="b1fc" class="lv kl hi bd km mb mc md kq me mf mg ku jx mh mi kw kb mj mk ky kf ml mm la mn bi translated">步骤9: SPY ETF对比</h2><p id="9333" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">这一步是可选的，但强烈推荐，因为我们可以了解我们的交易策略相对于基准(间谍ETF)的表现如何。在这一步，我们将使用我们创建的“get_historical_data”函数提取SPY ETF的数据，并将我们从SPY ETF获得的回报与我们在苹果公司的平均方向指数策略回报进行比较。</p><p id="6277" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="2894" class="lv kl hi lr b fi lw lx l ly lz">def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/><br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('ADX Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre><p id="a4dd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="8933" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">Benchmark profit by investing $100k : 21621.6</strong><br/><strong class="lr hj">Benchmark Profit percentage : 21%</strong><br/><strong class="lr hj">ADX Strategy profit is 9% higher than the Benchmark Profit</strong></span></pre><p id="7944" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>这一步中使用的代码几乎与前一个回溯测试步骤中使用的代码相似，但我们不是投资苹果，而是通过不实施任何交易策略来投资SPY ETF。从输出可以看出，我们的平均定向指数交易策略已经跑赢了SPY ETF 9%。那就好！</p><h1 id="3a56" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后的想法！</h1><p id="f627" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在粉碎理论和编码部分的漫长过程后，我们成功地了解了平均方向指数是什么，以及如何用python实现一个简单的基于ADX的交易策略。</p><p id="b96b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从我的角度来看，当ADX伴随着另一个技术指标，特别是RSI来为你的交易获得高质量的进场点和出场点时，它的全部力量就会释放出来。因此，强烈建议您尝试通过调整ADX策略以及其他技术指标来即兴撰写本文，并尽可能多地对其进行回溯测试。这样做可能有助于在现实市场中取得更好的结果。就是这样！希望你能从这篇文章中学到一些有用的东西。如果您忘记了遵循任何编码部分，不要担心。我在本文末尾提供了完整的源代码。</p><h2 id="0b6f" class="lv kl hi bd km mb mc md kq me mf mg ku jx mh mi kw kb mj mk ky kf ml mm la mn bi translated">完整代码:</h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="48d5" class="lv kl hi lr b fi lw lx l ly lz">import pandas as pd<br/>import numpy as np<br/>import requests<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)<br/><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>aapl = get_historical_data('AAPL', '2020-01-01')<br/>aapl<br/><br/>def get_adx(high, low, close, lookback):<br/>    plus_dm = high.diff()<br/>    minus_dm = low.diff()<br/>    plus_dm[plus_dm &lt; 0] = 0<br/>    minus_dm[minus_dm &gt; 0] = 0<br/>    <br/>    tr1 = pd.DataFrame(high - low)<br/>    tr2 = pd.DataFrame(abs(high - close.shift(1)))<br/>    tr3 = pd.DataFrame(abs(low - close.shift(1)))<br/>    frames = [tr1, tr2, tr3]<br/>    tr = pd.concat(frames, axis = 1, join = 'inner').max(axis = 1)<br/>    atr = tr.rolling(lookback).mean()<br/>    <br/>    plus_di = 100 * (plus_dm.ewm(alpha = 1/lookback).mean() / atr)<br/>    minus_di = abs(100 * (minus_dm.ewm(alpha = 1/lookback).mean() / atr))<br/>    dx = (abs(plus_di - minus_di) / abs(plus_di + minus_di)) * 100<br/>    adx = ((dx.shift(1) * (lookback - 1)) + dx) / lookback<br/>    adx_smooth = adx.ewm(alpha = 1/lookback).mean()<br/>    return plus_di, minus_di, adx_smooth<br/><br/>aapl['plus_di'] = pd.DataFrame(get_adx(aapl['high'], aapl['low'], aapl['close'], 14)[0]).rename(columns = {0:'plus_di'})<br/>aapl['minus_di'] = pd.DataFrame(get_adx(aapl['high'], aapl['low'], aapl['close'], 14)[1]).rename(columns = {0:'minus_di'})<br/>aapl['adx'] = pd.DataFrame(get_adx(aapl['high'], aapl['low'], aapl['close'], 14)[2]).rename(columns = {0:'adx'})<br/>aapl = aapl.dropna()<br/>aapl.tail()<br/><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(aapl['close'], linewidth = 2, color = '#ff9800')<br/>ax1.set_title('AAPL CLOSING PRICE')<br/>ax2.plot(aapl['plus_di'], color = '#26a69a', label = '+ DI 14', linewidth = 3, alpha = 0.3)<br/>ax2.plot(aapl['minus_di'], color = '#f44336', label = '- DI 14', linewidth = 3, alpha = 0.3)<br/>ax2.plot(aapl['adx'], color = '#2196f3', label = 'ADX 14', linewidth = 3)<br/>ax2.axhline(25, color = 'grey', linewidth = 2, linestyle = '--')<br/>ax2.legend()<br/>ax2.set_title('AAPL ADX 14')<br/>plt.show()<br/><br/>def implement_adx_strategy(prices, pdi, ndi, adx):<br/>    buy_price = []<br/>    sell_price = []<br/>    adx_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(prices)):<br/>        if adx[i-1] &lt; 25 and adx[i] &gt; 25 and pdi[i] &gt; ndi[i]:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                adx_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                adx_signal.append(0)<br/>        elif adx[i-1] &lt; 25 and adx[i] &gt; 25 and ndi[i] &gt; pdi[i]:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                adx_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                adx_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            adx_signal.append(0)<br/>            <br/>    return buy_price, sell_price, adx_signal<br/><br/>buy_price, sell_price, adx_signal = implement_adx_strategy(aapl['close'], aapl['plus_di'], aapl['minus_di'], aapl['adx'])<br/><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(aapl['close'], linewidth = 3, color = '#ff9800', alpha = 0.6)<br/>ax1.set_title('AAPL CLOSING PRICE')<br/>ax1.plot(aapl.index, buy_price, marker = '^', color = '#26a69a', markersize = 14, linewidth = 0, label = 'BUY SIGNAL')<br/>ax1.plot(aapl.index, sell_price, marker = 'v', color = '#f44336', markersize = 14, linewidth = 0, label = 'SELL SIGNAL')<br/>ax2.plot(aapl['plus_di'], color = '#26a69a', label = '+ DI 14', linewidth = 3, alpha = 0.3)<br/>ax2.plot(aapl['minus_di'], color = '#f44336', label = '- DI 14', linewidth = 3, alpha = 0.3)<br/>ax2.plot(aapl['adx'], color = '#2196f3', label = 'ADX 14', linewidth = 3)<br/>ax2.axhline(25, color = 'grey', linewidth = 2, linestyle = '--')<br/>ax2.legend()<br/>ax2.set_title('AAPL ADX 14')<br/>plt.show()<br/><br/>position = []<br/>for i in range(len(adx_signal)):<br/>    if adx_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(aapl['close'])):<br/>    if adx_signal[i] == 1:<br/>        position[i] = 1<br/>    elif adx_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = aapl['close']<br/>plus_di = aapl['plus_di']<br/>minus_di = aapl['minus_di']<br/>adx = aapl['adx']<br/>adx_signal = pd.DataFrame(adx_signal).rename(columns = {0:'adx_signal'}).set_index(aapl.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'adx_position'}).set_index(aapl.index)<br/><br/>frames = [close_price, plus_di, minus_di, adx, adx_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy<br/>strategy[25:30]<br/><br/>aapl_ret = pd.DataFrame(np.diff(aapl['close'])).rename(columns = {0:'returns'})<br/>adx_strategy_ret = []<br/><br/>for i in range(len(aapl_ret)):<br/>    returns = aapl_ret['returns'][i]*strategy['adx_position'][i]<br/>    adx_strategy_ret.append(returns)<br/>    <br/>adx_strategy_ret_df = pd.DataFrame(adx_strategy_ret).rename(columns = {0:'adx_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/aapl['close'][-1])<br/>adx_investment_ret = []<br/><br/>for i in range(len(adx_strategy_ret_df['adx_returns'])):<br/>    returns = number_of_stocks*adx_strategy_ret_df['adx_returns'][i]<br/>    adx_investment_ret.append(returns)<br/><br/>adx_investment_ret_df = pd.DataFrame(adx_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(adx_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the ADX strategy by investing $100k in AAPL : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the ADX strategy : {}%'.format(profit_percentage), attrs = ['bold']))<br/><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/><br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('ADX Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre></div></div>    
</body>
</html>