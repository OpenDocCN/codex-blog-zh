<html>
<head>
<title>Algorithmic Trading with the Keltner Channel in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中Keltner通道的算法交易</h1>
<blockquote>原文：<a href="https://medium.com/codex/algorithmic-trading-with-the-keltner-channel-in-python-9c272051d43d?source=collection_archive---------2-----------------------#2021-06-03">https://medium.com/codex/algorithmic-trading-with-the-keltner-channel-in-python-9c272051d43d?source=collection_archive---------2-----------------------#2021-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0edd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">对所有交易者来说，这是一个必须知道的指标</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a98fd09c1e5d5c0bdb18c79ed85b8a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-pbRN-SH63IYjiFo"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jn" href="https://unsplash.com/@max_duz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>拍照</figcaption></figure><h1 id="01cc" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">介绍</h1><p id="3dbd" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">当你在研究技术指标时，你肯定会遇到一个由精选指标组成的列表，这些指标被广泛认为是“必须知道”的指标，你需要在涉足现实市场之前学会这些指标。鉴于其在市场中的表现，我们今天要探讨的指标将添加到这个列表中。不是别人，正是凯尔特纳频道(KC)。</p><p id="6fb2" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在本文中，我们将首先讨论凯尔特纳通道是什么，以及指标背后的数学原理。然后，我们将进入编程部分，使用Python从头构建指标，基于指标构建简单的交易策略，在英特尔股票上对策略进行回溯测试，最后，将策略回报与SPY ETF(一种专门用于跟踪标准普尔500市场指数走势的ETF)的回报进行比较。</p><p id="8dee" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在继续之前，如果你想在没有任何代码的情况下回溯测试你的交易策略，有一个解决方案。这是<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">的后验区</a>。这是一个平台，可以免费对不同类型的可交易资产的任意数量的交易策略进行回溯测试，无需编码。点击这里的链接，你可以马上使用这个工具:<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">https://www.backtestzone.com/</a></p><h1 id="deba" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">平均真实距离</h1><p id="361a" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">有必要知道什么是平均真实范围(ATR ),因为它涉及到凯尔特纳通道的计算。</p><p id="62d8" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">由怀尔德怀尔斯(最受欢迎的指标RSI的创始人)创立，平均真实范围是一个技术指标，衡量资产平均移动多少。这是一个滞后指标，意味着它考虑了资产的历史数据来衡量当前价值，但它不能预测未来的数据点。在使用ATR时，这不被认为是一个缺点，因为它是更准确地跟踪市场波动的指标之一。ATR是一个滞后指标，也是一个非方向性指标，意味着ATR的运动与市场的实际运动成反比。要计算ATR，必须遵循两个步骤:</p><ul class=""><li id="775c" class="lh li hi ki b kj lc km ld kp lj kt lk kx ll lb lm ln lo lp bi translated"><strong class="ki hj">计算真实范围(TR): </strong>资产的真实范围通过取三个价格差的最大值来计算，这三个价格差是:市场高点减去市场低点，市场高点减去先前的市场收盘，先前的市场收盘减去市场低点。它可以表示如下:</li></ul><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="ddc5" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">MAX </strong>[ {<strong class="lr hj">HIGH - LOW</strong>}, {<strong class="lr hj">HIGH - P.CLOSE</strong>}, {<strong class="lr hj">P.CLOSE - LOW</strong>} ]</span><span id="aa0f" class="lv jp hi lr b fi ma lx l ly lz">where,<br/>MAX = Maximum values<br/>HIGH = Market High<br/>LOW = Market Low<br/>P.CLOSE = Previous market close</span></pre><ul class=""><li id="0e90" class="lh li hi ki b kj lc km ld kp lj kt lk kx ll lb lm ln lo lp bi translated"><strong class="ki hj">计算ATR: </strong>平均真实范围的计算很简单。我们只需对指定数量的周期取之前计算的真实范围值的平滑平均值。平滑平均线不是普通的SMA或EMA，而是怀尔德·怀尔斯自己创造的一种平滑平均线，它只不过是从指定时间段的真实范围的指数移动平均线中减去1，然后将差值乘以2。特定周期数的ATR计算可表示如下:</li></ul><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="d558" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">ATR N </strong>= <strong class="lr hj">EMA N </strong>[ <strong class="lr hj">TR </strong>] <strong class="lr hj">- 1</strong> * <strong class="lr hj">2</strong></span><span id="6740" class="lv jp hi lr b fi ma lx l ly lz">where,<br/>ATR N = Average True Range of 'N' period<br/>SMA N = Simple Moving Average of 'N' period<br/>TR = True Range</span></pre><p id="06e6" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">当使用ATR作为交易指标时，交易者必须确保他们比以往更加谨慎，因为该指标非常滞后。现在我们已经了解了平均真实范围是什么。现在让我们深入了解这篇文章的主要概念，Keltner渠道。</p><h1 id="9699" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">凯尔特纳海峡</h1><p id="b5df" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">由切斯特·凯尔特纳创建的凯尔特纳通道是一个技术指标，交易者经常用它来识别市场的波动和方向。凯尔特纳通道由三部分组成:上波段、下波段和中线。现在，让我们讨论一下每个分量是如何计算的。</p><p id="9e33" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在开始计算凯尔特纳海峡之前，有必要了解计算中涉及的三个重要输入。首先是ATR回顾期，它只是计算ATR时考虑的周期数。其次，凯尔特纳通道回望期。该输入或多或少类似于第一个输入，但在这里，我们决定了在计算Keltner通道本身时要考虑的周期数。最后的输入是乘数，它是一个确定要与ATR相乘的值。作为输入的典型值为:10为ATR回望周期，20为Keltner通道回望周期，2为乘数。记住这些输入，让我们计算一下Keltner通道组件的读数。</p><p id="d062" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">计算Keltner通道分量的第一步是确定ATR值，以10作为回望周期，可以按照前面讨论的公式计算。</p><p id="85da" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">下一步是计算凯尔特纳通道的中线。这个分量不过是股票收盘价的20天指数移动平均线。该计算可以表示如下:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="1136" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">MIDDLE LINE 20</strong> = <strong class="lr hj">EMA 20</strong> [ <strong class="lr hj">C.STOCK</strong> ]</span><span id="b5fb" class="lv jp hi lr b fi ma lx l ly lz">where,<br/>EMA 20 = 20-day Exponential Moving Average <br/>C.STOCK = Closing price of the stock</span></pre><p id="e40a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">最后一步是计算上下波段。让我们从上层乐队开始。其计算方法是，首先将股票收盘价的20天指数移动平均值乘以乘数(2)，然后乘以10天ATR。较低波段的计算和较高波段几乎相似，但是我们不是相加，而是用乘数减去20天均线。上限和下限的计算可表示如下:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="0538" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">UPPER BAND 20</strong> = <strong class="lr hj">EMA 20 </strong>[ <strong class="lr hj">C.STOCK </strong>] + <strong class="lr hj">MULTIPLIER </strong>* <strong class="lr hj">ATR 10<br/>LOWER BAND 20</strong> = <strong class="lr hj">EMA 20 </strong>[ <strong class="lr hj">C.STOCK </strong>] - <strong class="lr hj">MULTIPLIER </strong>* <strong class="lr hj">ATR 10</strong></span><span id="68d8" class="lv jp hi lr b fi ma lx l ly lz">where,<br/>EMA 20 = 20-day Exponential Moving Average <br/>C.STOCK = Closing price of the stock<br/>MULTIPLIER = 2<br/>ATR 10 = 10-day Average True Range</span></pre><p id="95e8" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这就是计算Keltner通道组件的整个过程。现在，让我们来分析一张凯尔特纳通道的图表，以加深对该指标的理解。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/77f3582610ce0226d66fee410a561030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FuDMl1GxJ8IqrpVlCoRTEw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="a4b0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">上图是英特尔的20天香奈儿凯尔特纳的图形表示。我们可以注意到，在收盘价线的两边绘制了两条波段，它们只是上下波段，两条波段之间的灰色线条是中线或20日均线。凯尔特纳通道有很多用途，但最常用的是识别市场波动和方向。</p><p id="73b5" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">市场的波动性可以由上下波段之间的空间决定。如果波段之间的空间较宽，那么市场被认为是不稳定的或显示更大的价格波动。另一方面，如果波段之间的空间很窄，则认为市场处于稳定或盘整状态。另一个流行的用法是识别市场方向。市场方向可以通过跟随中线以及上下波段的方向来确定。</p><p id="41a3" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">当看到凯尔特纳通道的图表时，它可能类似于布林线。这两个指标之间的唯一区别是它们各自的计算方式。布林线使用标准差来计算，而凯尔特纳通道使用ATR来计算读数。现在，我们来谈谈本文中我们将要实施的交易策略。</p><p id="104c" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">关于我们的交易策略:</strong>我们将实施最流行的凯尔特纳渠道交易策略，即突破策略。由于凯尔特纳通道容易暴露错误信号，我们将调整传统的突破策略。我们调整的策略将揭示一个买入信号，当收盘价线从上方穿越到下方时，当前收盘价低于股票的下一个收盘价。类似地，当收盘价线从上带下方穿越到上带上方，并且当前收盘价高于股票的下一个收盘价时，就会显示卖出信号。我们的交易策略可以表述如下:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="dbaf" class="lv jp hi lr b fi lw lx l ly lz">IF <strong class="lr hj">C.CLOSE</strong> &lt; <strong class="lr hj">C.KCLOWER</strong> AND <strong class="lr hj">C.CLOSE</strong> &lt; <strong class="lr hj">N.CLOSE</strong> ==&gt; <strong class="lr hj">BUY SIGNAL</strong><br/>IF <strong class="lr hj">C.CLOSE</strong> &gt; <strong class="lr hj">C.KCUPPER</strong> AND <strong class="lr hj">C.CLOSE</strong> &gt; <strong class="lr hj">N.CLOSE</strong> ==&gt; <strong class="lr hj">SELL SIGNAL</strong></span></pre><p id="9b5c" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">基于Keltner渠道指标，还可以实施许多其他策略，但为了便于理解，我们将采用突破策略。这就结束了我们关于凯特纳通道指标的理论部分。现在，让我们转到编程部分，我们首先要从头开始构建指标，构建我们刚刚讨论过的突破策略，然后将我们的策略的性能与Python中SPY ETF的回报进行比较。来做点编码吧！在继续之前，关于免责声明的一个注意事项:本文的唯一目的是教育人们，必须被视为一个信息，而不是投资建议等。</p><h1 id="2f7c" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">用Python实现</h1><p id="2cba" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">编码部分分为以下几个步骤:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="8764" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">1. Importing Packages<br/>2. Extracting Stock Data from Twelve Data<br/>3. Keltner Channel Calculation<br/>4. Creating the Breakout Trading Strategy<br/>5. Plotting the Trading Lists<br/>6. Creating our Position<br/>7. Backtesting<br/>8. SPY ETF Comparison</strong></span></pre><p id="5130" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h1 id="053b" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">步骤1:导入包</h1><p id="c076" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="8aec" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="55a8" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj"># IMPORTING PACKAGES<br/></strong><br/>import requests<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import pandas as pd<br/>from termcolor import colored as cl<br/>from math import floor<br/><br/>plt.rcParams['figure.figsize'] = (20,10)<br/>plt.style.use('fivethirtyeight')</span></pre><p id="253e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在我们已经将所有需要的包导入到python中。让我们用十二数据的API端点来拉一下英特尔的历史数据。</p><h1 id="d643" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">步骤2:从12个数据中提取数据</h1><p id="0a75" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这一步，我们将使用twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">提供的API端点提取英特尔的历史股票数据。在此之前，关于</a><a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>的一个说明:十二数据是领先的市场数据提供商之一，拥有大量针对所有类型市场数据的API端点。它非常容易与十二数据提供的API进行交互，并且拥有有史以来最好的文档。此外，确保您在<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>上有一个帐户，只有这样，您才能访问您的API密钥(使用API提取数据的重要元素)。</p><p id="03e7" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="15ff" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj"># EXTRACTING STOCK DATA<br/></strong><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>intc = get_historical_data('INTC', '2020-01-01')<br/>intc.tail()</span></pre><p id="bf8f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/5c94ae11b51f5ced73896ab5b4e4d214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X49FD5H6KbO31VtrSOfy2Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="6d1b" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>我们做的第一件事是定义一个名为‘get _ historical _ data’的函数，它以股票的符号(‘symbol’)和历史数据的起始日期(‘start _ date’)作为参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们调用创建的函数来提取英特尔从2020年开始的历史数据，并将其存储到‘intc’变量中。</p><h2 id="2498" class="lv jp hi bd jq md me mf ju mg mh mi jy kp mj mk ka kt ml mm kc kx mn mo ke mp bi translated">步骤3: Keltner渠道计算</h2><p id="eb8a" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这一步中，我们将按照之前讨论的方法来计算Keltner渠道指标的组成部分。</p><p id="2969" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="248b" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj"># KELTNER CHANNEL CALCULATION<br/></strong><br/>def get_kc(high, low, close, kc_lookback, multiplier, atr_lookback):<br/>    tr1 = pd.DataFrame(high - low)<br/>    tr2 = pd.DataFrame(abs(high - close.shift()))<br/>    tr3 = pd.DataFrame(abs(low - close.shift()))<br/>    frames = [tr1, tr2, tr3]<br/>    tr = pd.concat(frames, axis = 1, join = 'inner').max(axis = 1)<br/>    atr = tr.ewm(alpha = 1/atr_lookback).mean()<br/>    <br/>    kc_middle = close.ewm(kc_lookback).mean()<br/>    kc_upper = close.ewm(kc_lookback).mean() + multiplier * atr<br/>    kc_lower = close.ewm(kc_lookback).mean() - multiplier * atr<br/>    <br/>    return kc_middle, kc_upper, kc_lower<br/>    <br/>intc = intc.iloc[:,:4]<br/>intc['kc_middle'], intc['kc_upper'], intc['kc_lower'] = get_kc(intc['high'], intc['low'], intc['close'], 20, 2, 10)<br/>intc.tail()</span></pre><p id="051f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/c57d6f36d482afeff9de2779857c4439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wqCsmWvx6OGhgRvZ7NSudw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="e563" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>我们首先定义一个名为“get_kc”的函数，它将股票的高(“高”)、低(“低”)和收盘价数据(“收盘”)、凯尔特纳通道的回望期(“kc _回望”)、乘数值(“乘数”)和ATR的回望期(“atr _回望”)作为参数。函数内部的代码可以分为两个部分:ATR计算和Keltner信道计算。</p><p id="efbc" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">ATR计算:为了确定平均真实范围的读数，我们首先计算三个差值，并将它们存储到各自的变量中。然后，我们使用“concat”函数将所有三个差异合并到一个数据帧中，并从三个总体差异中取出最大值，以确定真实范围。然后，使用“ewm”和“mean”函数，我们对特定数量的周期的真实范围进行定制移动平均，以获得ATR值。</p><p id="9a85" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">凯尔特纳通道计算:利用之前计算的ATR值，我们首先计算凯尔特纳通道的中线，取特定周期数的ATR均线。然后是上下波段的计算。我们将ATR值代入之前讨论过的上限和下限公式，以获得每个值的读数。最后，我们返回并调用创建的函数来获取英特尔的Keltner渠道值。</p><h2 id="4462" class="lv jp hi bd jq md me mf ju mg mh mi jy kp mj mk ka kt ml mm kc kx mn mo ke mp bi translated">步骤4:创建交易策略</h2><p id="8c6b" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这一步，我们将使用python实现讨论过的Keltner通道指标突破交易策略。</p><p id="43d8" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="6fee" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj"># KELTNER CHANNEL STRATEGY<br/></strong><br/>def implement_kc_strategy(prices, kc_upper, kc_lower):<br/>    buy_price = []<br/>    sell_price = []<br/>    kc_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(prices)):<br/>        if prices[i] &lt; kc_lower[i] and prices[i+1] &gt; prices[i]:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                kc_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                kc_signal.append(0)<br/>        elif prices[i] &gt; kc_upper[i] and prices[i+1] &lt; prices[i]:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                kc_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                kc_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            kc_signal.append(0)<br/>            <br/>    return buy_price, sell_price, kc_signal<br/><br/>buy_price, sell_price, kc_signal = implement_kc_strategy(intc['close'], intc['kc_upper'], intc['kc_lower'])</span></pre><p id="9afe" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>首先，我们定义一个名为“implement_kc_strategy”的函数，该函数将股票价格(“prices”)和Keltner通道指标的组成部分(“kc_upper”和“kc_lower”)作为参数。</p><p id="cb3a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在该函数中，我们创建了三个空列表(buy_price、sell_price和kc_signal ),在创建交易策略时，这些值将被追加到这些列表中。</p><p id="b816" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">之后，我们通过for循环实施交易策略。在for循环内部，我们传递某些条件，如果条件得到满足，相应的值将被追加到空列表中。如果购买股票的条件得到满足，买入价将被追加到“buy_price”列表中，信号值将被追加为1，表示购买股票。类似地，如果卖出股票的条件得到满足，卖价将被追加到“sell_price”列表中，信号值将被追加为-1，表示卖出股票。</p><p id="e112" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">最后，我们返回附加了值的列表。然后，我们调用创建的函数并将值存储到各自的变量中。除非我们画出这些值，否则这个列表没有任何意义。所以，让我们画出创建的交易列表的值。</p><h2 id="c7da" class="lv jp hi bd jq md me mf ju mg mh mi jy kp mj mk ka kt ml mm kc kx mn mo ke mp bi translated">第五步:绘制交易信号</h2><p id="b242" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这一步，我们将绘制已创建的交易列表，以使它们有意义。</p><p id="8fd2" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="38a3" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj"># TRADING SIGNALS PLOT<br/></strong><br/>plt.plot(intc['close'], linewidth = 2, label = 'INTC')<br/>plt.plot(intc['kc_upper'], linewidth = 2, color = 'orange', linestyle = '--', label = 'KC UPPER 20')<br/>plt.plot(intc['kc_middle'], linewidth = 1.5, color = 'grey', label = 'KC MIDDLE 20')<br/>plt.plot(intc['kc_lower'], linewidth = 2, color = 'orange', linestyle = '--', label = 'KC LOWER 20')<br/>plt.plot(intc.index, buy_price, marker = '^', color = 'green', markersize = 15, linewidth = 0, label = 'BUY SIGNAL')<br/>plt.plot(intc.index, sell_price, marker = 'v', color= 'r', markersize = 15, linewidth = 0, label = 'SELL SIGNAL')<br/>plt.legend(loc = 'lower right')<br/>plt.title('INTC KELTNER CHANNEL 20 TRADING SIGNALS')<br/>plt.show()</span></pre><p id="ad5c" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/1b6145a2f3d23da0475ada2370755d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QQl2wfXjKfWevVU-f1il7w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="04b9" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>我们正在绘制凯尔特纳通道指标的读数，以及突破交易策略产生的买入和卖出信号。我们可以观察到，每当收盘价线从上方到下方的波段线，当前收盘价低于下一个收盘价，绿色的买入信号在图表中绘制。类似地，当收盘价线从上轨下方穿越到上轨上方，并且当前收盘价高于下一个收盘价时，图表中会显示红色的卖出信号。</p><h2 id="bcf2" class="lv jp hi bd jq md me mf ju mg mh mi jy kp mj mk ka kt ml mm kc kx mn mo ke mp bi translated">步骤6:创建我们的职位</h2><p id="4c0d" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这一步中，我们将创建一个列表，如果我们持有股票，该列表将指示1；如果我们不拥有或持有股票，该列表将指示0。</p><p id="8a97" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="17a0" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj"># STOCK POSITION<br/></strong><br/>position = []<br/>for i in range(len(kc_signal)):<br/>    if kc_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(intc['close'])):<br/>    if kc_signal[i] == 1:<br/>        position[i] = 1<br/>    elif kc_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = intc['close']<br/>kc_upper = intc['kc_upper']<br/>kc_lower = intc['kc_lower']<br/>kc_signal = pd.DataFrame(kc_signal).rename(columns = {0:'kc_signal'}).set_index(intc.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'kc_position'}).set_index(intc.index)<br/><br/>frames = [close_price, kc_upper, kc_lower, kc_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy</span></pre><p id="e15e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/26ad6776f9fe9647b376ce88df3278e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YnfwG2bu6nkkcsqvORlYeg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="aed7" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>首先，我们创建一个名为‘position’的空列表。我们传递两个for循环，一个是为“位置”列表生成值，以匹配“信号”列表的长度。另一个for循环是我们用来生成实际位置值的循环。在第二个for循环中，我们对“signal”列表的值进行迭代，而“position”列表的值被附加到满足哪个条件上。如果我们持有股票，头寸的价值仍为1；如果我们卖出或不持有股票，头寸的价值仍为0。最后，我们正在进行一些数据操作，将所有创建的列表合并到一个数据帧中。</p><p id="b632" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">从显示的输出中，我们可以看到，在第一行中，我们在股票中的位置仍然是1(因为在Keltner通道指标信号中没有任何变化)，但是当Keltner通道指标交易信号代表卖出信号(-1)时，我们的位置突然变成-1。我们的头寸将保持为0，直到交易信号发生一些变化。现在是时候实现一些回溯测试过程了！</p><h2 id="5e88" class="lv jp hi bd jq md me mf ju mg mh mi jy kp mj mk ka kt ml mm kc kx mn mo ke mp bi translated">步骤7:回溯测试</h2><p id="c079" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在继续之前，有必要知道什么是回溯测试。回溯测试是查看我们的交易策略在给定股票数据上表现如何的过程。在我们的案例中，我们将对英特尔股票数据的Keltner渠道指标交易策略实施回溯测试流程。</p><p id="d5d1" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="b781" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj"># BACKTESTING<br/></strong><br/>intc_ret = pd.DataFrame(np.diff(intc['close'])).rename(columns = {0:'returns'})<br/>kc_strategy_ret = []<br/><br/>for i in range(len(intc_ret)):<br/>    returns = intc_ret['returns'][i]*strategy['kc_position'][i]<br/>    kc_strategy_ret.append(returns)<br/>    <br/>kc_strategy_ret_df = pd.DataFrame(kc_strategy_ret).rename(columns = {0:'kc_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/intc['close'][0])<br/>kc_investment_ret = []<br/><br/>for i in range(len(kc_strategy_ret_df['kc_returns'])):<br/>    returns = number_of_stocks*kc_strategy_ret_df['kc_returns'][i]<br/>    kc_investment_ret.append(returns)<br/><br/>kc_investment_ret_df = pd.DataFrame(kc_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(kc_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the KC strategy by investing $100k in INTC : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the KC strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre><p id="53fb" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="3dcc" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">Profit gained from the KC strategy by investing $100k in INTC : 47786.65</strong><br/><strong class="lr hj">Profit percentage of the KC strategy : 47%</strong></span></pre><p id="62a1" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>首先，我们使用NumPy包提供的‘diff’函数计算英特尔股票的回报，并将其作为数据帧存储到‘intc _ ret’变量中。接下来，我们将传递一个for循环来迭代' intc_ret '变量的值，以计算我们从Keltner通道指标交易策略中获得的回报，这些回报值将被追加到' kc_strategy_ret '列表中。接下来，我们将“kc_strategy_ret”列表转换为数据帧，并将其存储到“kc_strategy_ret_df”变量中。</p><p id="5092" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">接下来是回溯测试过程。我们将通过投资10万美元到我们的交易策略中来回测我们的策略。首先，我们将投资金额存储到“投资值”变量中。之后，我们正在使用投资金额计算我们可以购买的英特尔股票数量。您可以注意到，我使用了Math软件包提供的“下限”函数，因为当投资金额除以英特尔股票的收盘价时，它会输出一个十进制数。股票数量应该是整数，而不是小数。使用“底数”函数，我们可以去掉小数。请记住,“floor”函数比“round”函数要复杂得多。然后，我们传递一个for循环来查找投资回报，后面是一些数据操作任务。</p><p id="1d5e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">最后，我们打印了我们通过投资10万到我们的交易策略中所得到的总回报，并且显示我们在一年中大约获得了47000美元的利润。那还不错！现在，让我们将我们的回报与SPY ETF(一种旨在跟踪标准普尔500股票市场指数的ETF)的回报进行比较。</p><h2 id="0f33" class="lv jp hi bd jq md me mf ju mg mh mi jy kp mj mk ka kt ml mm kc kx mn mo ke mp bi translated">第八步:间谍ETF对比</h2><p id="8aac" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">这一步是可选的，但强烈推荐，因为我们可以了解我们的交易策略相对于基准(间谍ETF)的表现如何。在这一步中，我们将使用我们创建的“get_historical_data”函数提取SPY ETF的数据，并将我们从SPY ETF获得的回报与我们在英特尔上的Keltner渠道突破交易策略回报进行比较。</p><p id="0d72" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">你可能已经注意到，在我所有的算法交易文章中，我没有将策略结果与标准普尔500市场指数本身进行比较，而是与SPY ETF进行比较，这是因为大多数股票数据提供商(如12 Data)不提供标准普尔500指数数据。所以，我别无选择，只能选择间谍ETF。如果你有幸得到标准普尔500市场指数数据，建议用它来做比较，而不是任何ETF。</p><p id="67fd" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="cee8" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj"># SPY ETF COMPARISON<br/></strong><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('KC Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre><p id="0367" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="0ae5" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj">Benchmark profit by investing $100k : 22631.16</strong><br/><strong class="lr hj">Benchmark Profit percentage : 22%</strong><br/><strong class="lr hj">KC Strategy profit is 25% higher than the Benchmark Profit</strong></span></pre><p id="9333" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>此步骤中使用的代码与前一个回溯测试步骤中使用的代码几乎相似，但我们不是投资英特尔，而是通过不实施任何交易策略来投资SPY ETF。从输出中，我们可以看到，我们的凯尔特纳通道突破交易策略跑赢了间谍ETF 25%。太好了！</p><h1 id="69f9" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">最后的想法！</h1><p id="5ddf" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">经过一个长期的理论和编码的过程，我们已经成功地学习了凯尔特纳通道指标是什么，指标背后的数学，最后，如何从零开始构建指标和用Python构建突破交易策略。我们也确实取得了一些不错的结果，事实上，除了超过间谍ETF的回报，我们还通过突破策略超过了英特尔股票的实际回报。</p><p id="620f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我经常在我的文章中谈论策略调整或优化，今天，我们真的通过调整和对传统突破策略进行一些改变来实现它。因此，我们能够超越实际市场本身的回报。这只是一个小例子，说明了如何调整策略以及结果将如何受到相应的影响，但是，还有更多内容需要探索。策略优化不仅仅是对长期存在的传统策略进行调整或做出一些改变，而是创造一个最佳的交易环境，这包括您用于交易目的的经纪人、风险管理系统等等。所以强烈建议你看看这些空间，把你的策略提升到一个全新的水平。</p><p id="d056" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">话虽如此，你已经到了文章的结尾。如果您忘记了遵循任何编码部分，不要担心。我在最后提供了完整的源代码。希望你能从这篇文章中学到一些新的有用的东西。</p><h2 id="522d" class="lv jp hi bd jq md me mf ju mg mh mi jy kp mj mk ka kt ml mm kc kx mn mo ke mp bi translated">完整代码:</h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="e9cc" class="lv jp hi lr b fi lw lx l ly lz"><strong class="lr hj"># IMPORTING PACKAGES<br/></strong><br/>import requests<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import pandas as pd<br/>from termcolor import colored as cl<br/>from math import floor<br/><br/>plt.rcParams['figure.figsize'] = (20,10)<br/>plt.style.use('fivethirtyeight')<br/><br/><br/><strong class="lr hj"># EXTRACTING STOCK DATA<br/></strong><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>intc = get_historical_data('INTC', '2020-01-01')<br/>print(intc.tail())<br/><br/><br/><strong class="lr hj"># KELTNER CHANNEL CALCULATION<br/></strong><br/>def get_kc(high, low, close, kc_lookback, multiplier, atr_lookback):<br/>    tr1 = pd.DataFrame(high - low)<br/>    tr2 = pd.DataFrame(abs(high - close.shift()))<br/>    tr3 = pd.DataFrame(abs(low - close.shift()))<br/>    frames = [tr1, tr2, tr3]<br/>    tr = pd.concat(frames, axis = 1, join = 'inner').max(axis = 1)<br/>    atr = tr.ewm(alpha = 1/atr_lookback).mean()<br/>    <br/>    kc_middle = close.ewm(kc_lookback).mean()<br/>    kc_upper = close.ewm(kc_lookback).mean() + multiplier * atr<br/>    kc_lower = close.ewm(kc_lookback).mean() - multiplier * atr<br/>    <br/>    return kc_middle, kc_upper, kc_lower<br/>    <br/>intc = intc.iloc[:,:4]<br/>intc['kc_middle'], intc['kc_upper'], intc['kc_lower'] = get_kc(intc['high'], intc['low'], intc['close'], 20, 2, 10)<br/>print(intc.tail())<br/><br/><br/><strong class="lr hj"># KELTNER CHANNEL PLOT<br/></strong><br/>plt.plot(intc['close'], linewidth = 2, label = 'INTC')<br/>plt.plot(intc['kc_upper'], linewidth = 2, color = 'orange', linestyle = '--', label = 'KC UPPER 20')<br/>plt.plot(intc['kc_middle'], linewidth = 1.5, color = 'grey', label = 'KC MIDDLE 20')<br/>plt.plot(intc['kc_lower'], linewidth = 2, color = 'orange', linestyle = '--', label = 'KC LOWER 20')<br/>plt.legend(loc = 'lower right', fontsize = 15)<br/>plt.title('INTC KELTNER CHANNEL 20')<br/>plt.show()<br/><br/><br/><strong class="lr hj"># KELTNER CHANNEL STRATEGY<br/></strong><br/>def implement_kc_strategy(prices, kc_upper, kc_lower):<br/>    buy_price = []<br/>    sell_price = []<br/>    kc_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(prices)):<br/>        if prices[i] &lt; kc_lower[i] and prices[i+1] &gt; prices[i]:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                kc_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                kc_signal.append(0)<br/>        elif prices[i] &gt; kc_upper[i] and prices[i+1] &lt; prices[i]:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                kc_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                kc_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            kc_signal.append(0)<br/>            <br/>    return buy_price, sell_price, kc_signal<br/><br/>buy_price, sell_price, kc_signal = implement_kc_strategy(intc['close'], intc['kc_upper'], intc['kc_lower'])<br/><br/><br/><strong class="lr hj"># TRADING SIGNALS PLOT<br/></strong><br/>plt.plot(intc['close'], linewidth = 2, label = 'INTC')<br/>plt.plot(intc['kc_upper'], linewidth = 2, color = 'orange', linestyle = '--', label = 'KC UPPER 20')<br/>plt.plot(intc['kc_middle'], linewidth = 1.5, color = 'grey', label = 'KC MIDDLE 20')<br/>plt.plot(intc['kc_lower'], linewidth = 2, color = 'orange', linestyle = '--', label = 'KC LOWER 20')<br/>plt.plot(intc.index, buy_price, marker = '^', color = 'green', markersize = 15, linewidth = 0, label = 'BUY SIGNAL')<br/>plt.plot(intc.index, sell_price, marker = 'v', color= 'r', markersize = 15, linewidth = 0, label = 'SELL SIGNAL')<br/>plt.legend(loc = 'lower right')<br/>plt.title('INTC KELTNER CHANNEL 20 TRADING SIGNALS')<br/>plt.show()<br/><br/><br/><strong class="lr hj"># STOCK POSITION<br/></strong><br/>position = []<br/>for i in range(len(kc_signal)):<br/>    if kc_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(intc['close'])):<br/>    if kc_signal[i] == 1:<br/>        position[i] = 1<br/>    elif kc_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = intc['close']<br/>kc_upper = intc['kc_upper']<br/>kc_lower = intc['kc_lower']<br/>kc_signal = pd.DataFrame(kc_signal).rename(columns = {0:'kc_signal'}).set_index(intc.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'kc_position'}).set_index(intc.index)<br/><br/>frames = [close_price, kc_upper, kc_lower, kc_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>print(strategy)<br/>print(strategy[14:19])<br/><br/><br/><strong class="lr hj"># BACKTESTING<br/></strong><br/>intc_ret = pd.DataFrame(np.diff(intc['close'])).rename(columns = {0:'returns'})<br/>kc_strategy_ret = []<br/><br/>for i in range(len(intc_ret)):<br/>    returns = intc_ret['returns'][i]*strategy['kc_position'][i]<br/>    kc_strategy_ret.append(returns)<br/>    <br/>kc_strategy_ret_df = pd.DataFrame(kc_strategy_ret).rename(columns = {0:'kc_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/intc['close'][0])<br/>kc_investment_ret = []<br/><br/>for i in range(len(kc_strategy_ret_df['kc_returns'])):<br/>    returns = number_of_stocks*kc_strategy_ret_df['kc_returns'][i]<br/>    kc_investment_ret.append(returns)<br/><br/>kc_investment_ret_df = pd.DataFrame(kc_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(kc_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the KC strategy by investing $100k in INTC : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the KC strategy : {}%'.format(profit_percentage), attrs = ['bold']))<br/><br/><br/><strong class="lr hj"># SPY ETF COMPARISON<br/></strong><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('KC Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre></div></div>    
</body>
</html>