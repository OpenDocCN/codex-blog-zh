<html>
<head>
<title>Fixing Intel compiler’s unfair CPU dispatcher (Part 1/2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修复英特尔编译器的不公平CPU调度程序(第1/2部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/fixing-intel-compilers-unfair-cpu-dispatcher-part-1-2-4a4a367c8919?source=collection_archive---------0-----------------------#2022-06-05">https://medium.com/codex/fixing-intel-compilers-unfair-cpu-dispatcher-part-1-2-4a4a367c8919?source=collection_archive---------0-----------------------#2022-06-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9ae2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一个提高AMD处理器性能的简单补丁</h2></div><p id="36ee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您是用C、C++或Fortran编写代码的人，那么您可能听说过英特尔C/C++编译器和英特尔Fortran编译器。事实上，在科学计算中，英特尔编译器通常比GNU或LLVM编译器更受青睐，因为它们在处理数字时提供了显著的提升。例如，<a class="ae jt" href="https://colfaxresearch.com/compiler-comparison/#sec-3-1" rel="noopener ugc nofollow" target="_blank">该</a>基准测试显示，英特尔C++编译器优于各种编译器供应商，在数值计算方面比g++快50%。这主要是因为英特尔编译器通常在从源代码生成优化的机器代码方面表现出色。</p><p id="21dd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用英特尔编译器的另一个原因是，它有许多编译器扩展(即编程语言标准中未声明的功能)，可以更好地控制编码。然而，许多程序员认为使用非标准的编译器扩展是一种不好的做法，因为这样的代码是不可移植的。英特尔编译器在所有平台(Linux、macOS和Windows)上都同样出色，但在GNU、LLVM或MSVC编译器上就不一样了。其实很多PC视频游戏都是用Intel C++编译器编译的。我是一名计算化学研究员，所以我所在领域的大多数软件都需要进行大量的数值计算，因此它们中的大多数都是由英特尔编译发布的。</p><p id="7251" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大多数做数值计算的软件经常使用线性代数(如矩阵乘法、对角化等)。)这些操作经常被使用，因此有一些优化的库支持快速线性代数。这些被称为BLAS(基本线性代数子程序)和LAPACK(线性代数软件包)。此类库的常见示例包括OpenBLAS、BLIS、英特尔MKL。同样，英特尔的MKL(数学内核库)通常表现最佳，大多数软件包(如Matlab)使用英特尔MKL进行线性代数运算。这种库可以运行快速计算，因为它们使用SIMD向量指令、多线程、缓存优化等。</p><p id="fc2a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">英特尔编译器和MKL库的一个主要问题是编译后的软件仅针对英特尔CPU进行了优化。在编译过程中，英特尔编译器会添加一些额外的代码来检查CPUID中的供应商字符串。如果供应商字符串是“GenuineIntel”(即英特尔处理器)，则软件使用优化的代码路径，并带有SIMD指令。如果供应商字符串是“AuthenticAMD”(即AMD处理器)或其他任何字符串，则软件将运行未优化的路径。(英特尔似乎已经在最近的更新中为英特尔MKL解决了这个问题。)</p><p id="0de1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我将写为什么和如何发生这种CPU调度，以及如何修补一个编译好的软件来“修复”这个问题。</p><p id="11d2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想避免无聊的细节和解释，请跳到<strong class="iz hj">如何修复</strong>部分。也请阅读博客的<a class="ae jt" href="https://shoubhikrmaiti.medium.com/fixing-intel-compilers-unfair-cpu-dispatcher-part-2-2-1920bf17315c" rel="noopener">下一篇</a>部分，我将在那里进行基准测试，看看这种修补可能带来多大的性能提升。</p><h1 id="c289" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">简史</h1><p id="51c0" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">这种不公平的CPU厂商检查早就知道了。例如，AMD早在2005年就已经就这个问题写过文章。丹麦计算机科学家Agner Fog也在2009年的博客中详细描述了这一点:</p><blockquote class="kr ks kt"><p id="e218" class="ix iy ku iz b ja jb ij jc jd je im jf kv jh ji jj kw jl jm jn kx jp jq jr js hb bi translated">不幸的是，使用英特尔编译器或英特尔函数库编译的软件在AMD和VIA处理器上的性能较差。原因是编译器或库可以生成一段代码的多个版本，每个版本都针对特定的处理器和指令集进行了优化，例如SSE2、SSE3等。该系统包含一个功能，可以检测它运行在哪种类型的CPU上，并为该CPU选择最佳的代码路径。这被称为CPU调度程序。然而，英特尔CPU调度程序不仅检查CPU支持哪个指令集，还检查供应商ID字符串。如果供应商字符串为“GenuineIntel ”,那么它将使用最佳代码路径。如果CPU不是来自英特尔，那么在大多数情况下，它将运行最慢的代码版本，即使CPU与更好的版本完全兼容。</p></blockquote><p id="6e91" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">CPU分派是不公平的，因为代码不检查CPU的能力(这是完全合理的)，而是检查CPU是否是Intel的，并且不执行在任何非Intel处理器上都能完美运行的代码。大多数现代AMD处理器实现了与英特尔相同的SIMD指令，因此没有理由这样做。英特尔也没有选择向公众披露其编译器和库的这一缺点。</p><p id="e53b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">英特尔编译器的这种行为是AMD在2005年对英特尔提起的诉讼中的投诉之一。他们在2009年达成了法律和解。AMD还在2010年与联邦贸易委员会达成和解，其中<a class="ae jt" href="https://www.ftc.gov/news-events/news/press-releases/2010/08/ftc-settles-charges-anticompetitive-conduct-against-intel" rel="noopener ugc nofollow" target="_blank">规定</a>英特尔必须公开披露他们的软件歧视英特尔和非英特尔CPU的事实。这个免责声明现在可以在英特尔关于性能的<a class="ae jt" href="https://edc.intel.com/content/www/us/en/products/performance/benchmarks/overview/" rel="noopener ugc nofollow" target="_blank">页面</a>的最后找到:</p><blockquote class="kr ks kt"><p id="12af" class="ix iy ku iz b ja jb ij jc jd je im jf kv jh ji jj kw jl jm jn kx jp jq jr js hb bi translated">针对英特尔编译器或其它产品的英特尔优化可能不会针对非英特尔产品进行相同程度的优化。</p></blockquote><p id="ae4c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在任何情况下，英特尔编译器和英特尔MKL函数库在非英特尔处理器上仍然表现不佳，甚至到目前为止(2022年5月)。由于AMD是消费者笔记本电脑和台式机处理器的另一个主要供应商，它对AMD的影响最大。从法律上来说，英特尔是被允许这么做的，因为他们的软件并没有特别歧视AMD，只是在检查自己品牌的处理器。我个人认为，英特尔的行为可能有点不道德，因为虽然它没有特别歧视AMD处理器，但在法律的约束下，它在功能上等同于歧视。很明显，基准测试的结果偏向于英特尔，并且许多消费者在做出购买决定时会使用基准测试的结果。</p><p id="9060" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，这篇文章不是在讨论大公司的道德规范！！因此，让我们来详细了解一下使用了什么样的优化以及英特尔的CPU调度是如何工作的。</p><h1 id="d541" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">什么是SIMD？</h1><p id="f363" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">在使用英特尔编译器或MKL编译的软件中，优化的和未优化的机器码之间的主要区别是使用矢量指令或SIMD(单指令多数据)。当你在电脑上运行一个软件时，它向你的CPU发送指令，在CPU的每个周期，它获取并执行一条指令。</p><p id="dc24" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在旧的处理器中，每条指令只能执行一次算术运算，例如一次加法或减法。然而，现代处理器有能力在一个指令周期内对多个数据执行相同的操作。这就是所谓的SIMD，当需要进行数字处理时，它可以提供很大的性能优势。</p><p id="4896" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看一个C/C++中的具体例子就更容易理解了，在这个例子中，将两个数组的元素相加得到一个最终的数组:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="7cda" class="lh jv hi ld b fi li lj l lk ll">int a[100]; // contains some numbers<br/>int b[100]; // contains some numbers<br/>int c[100]; // empty array</span><span id="1c20" class="lh jv hi ld b fi lm lj l lk ll">// Now add a and b together<br/>for (int i=0; i&lt;100; i++) {<br/>    c[i] = a[i] + b[i]; // each turn of loop does one addition<br/>}</span></pre><p id="4c9f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果这种类型的代码是在没有SIMD的情况下编译的，那么当循环执行时，每个指令周期将执行一次加法，即它将添加两个整数。</p><p id="8ade" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你用SIMD呢？大多数现代英特尔和AMD处理器都实现了一种叫做AVX2的SIMD，它有256位寄存器。在C/C++中，<code class="du ln lo lp ld b">int</code>整数通常是32位的，所以每个寄存器可以存放8个整数。然后，AVX2加法指令(<code class="du ln lo lp ld b">vpaddd</code>)将在一个指令周期内将所有这8个整数相加。本质上，for循环的8次通过将在一个循环中发生。现在，无论您是否使用SIMD，CPU的每个周期都花费完全相同的时间(由时钟速度规格决定)。因此，在处理数字时，使用SIMD可以大大提高速度。</p><p id="40ba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">SIMD有不同的种类，现代矢量指令集支持更大的寄存器(即更多的数据)和更广泛的可用操作。SIMD指令集包括SSE、SSE2、SSE3、SSE4.1、SSE4.2、FMA、AVX、AVX2、AVX-512，按照发布的大致时间表和效率的递增顺序排列。支持较新指令集的处理器通常也支持较旧的指令集。大多数消费类CPU实现高达AVX2，AVX-512仅在一些高端英特尔处理器中可用。</p><h1 id="09a2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">汇编码</h1><p id="39df" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">当编译C/C++或Fortran中的源代码时，它被转换成人类不可读的机器代码(二进制)。理解它们的唯一方法是用汇编语言反汇编二进制文件。在汇编语言中，CPU指令用名字来表示，如前面提到的<code class="du ln lo lp ld b">mov</code>或<code class="du ln lo lp ld b">cmp</code>或<code class="du ln lo lp ld b">vpaddd</code>。即使这样，阅读汇编仍然是相当困难的，因为人类不像机器算法那样思考！</p><p id="b110" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您使用的是Windows，则二进制文件(如*。obj或*。exe)可以通过从Visual Studio命令行运行<code class="du ln lo lp ld b">dumpbin /disasm file.obj &gt; output.txt</code>来反汇编。在Linux和macOS(以及Windows上的mingw)上，二进制文件可以通过<code class="du ln lo lp ld b">objdump -D -Mintel file.o &gt; output.txt</code>反汇编。请注意，<code class="du ln lo lp ld b">-Mintel</code>标志选择英特尔语法进行反汇编，而在Windows上是默认的。语法只是个人喜好。</p><figure class="ky kz la lb fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lq"><img src="../Images/cb39591df0329594be1d2657f9420606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zOTlR6ujPrJeTq1hNNUKw.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">英特尔语法中二进制反汇编的一小段，展示了AVX-512指令</figcaption></figure><p id="72ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下一节中，我将使用汇编代码来展示CPU调度是如何工作的。我还会解释每条指令出现时的含义。</p><h1 id="3efd" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">英特尔编译器的CPU调度</h1><p id="138f" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">英特尔编译器使用的CPU调度类型取决于用于编译的编译器标志。我在Windows上工作，所以我使用的标志将与Linux或macOS略有不同，但是，我也会提到这些平台的标志。</p><p id="1da1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们用下面的C++程序来添加两个填充了随机数的数组:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="8ffc" class="lh jv hi ld b fi li lj l lk ll">#include &lt;array&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;iostream&gt;</span><span id="790c" class="lh jv hi ld b fi lm lj l lk ll">void calc() {<br/>    constexpr long long LEN_OF_ARR = 20000;// the size of array<br/>    std::array&lt;int,LEN_OF_ARR&gt; a;<br/>    std::array&lt;int,LEN_OF_ARR&gt; b;<br/>    std::array&lt;int,LEN_OF_ARR&gt; c;<br/>    std::srand( (unsigned int)std::time(nullptr) );<br/>    // fill a with random numbers    <br/>    std::generate(a.begin(),a.end(),std::rand);<br/>    // fill b with random numbers <br/>    std::generate(b.begin(),b.end(),std::rand);<br/>    for (size_t i=0; i &lt; LEN_OF_ARR; i++) {<br/>        c[i] = a[i] + b[i]; // sum numbers<br/>    }<br/>    std::cout&lt;&lt;"First number of vector sum of arrays: "&lt;&lt;c[0]; <br/>}<br/>// the calculation must be in a separate function not in main()</span><span id="48e4" class="lh jv hi ld b fi lm lj l lk ll">int main() {<br/>    calc();<br/>}</span></pre><p id="880e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将其保存为test.cpp，然后在Windows上打开英特尔编译器命令行(在Linux源代码上为英特尔setvars脚本),并运行:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="cced" class="lh jv hi ld b fi li lj l lk ll">icl -arch:CORE-AVX2 -O3 test.cpp</span></pre><p id="c90d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果不使用编译器标志，早期版本的英特尔C++编译器将不使用SIMD(即仅x86)指令。Windows上当前版本的英特尔编译器默认使用SSE2指令(可能是因为Windows x64内核使用SSE，所以没有SSE就无法运行64位Windows)，适用于包括AMD在内的所有处理器。在Linux上，默认的指令集实际上是x86(即没有向量化)。<code class="du ln lo lp ld b">-arch:CORE-AVX2</code> <a class="ae jt" href="https://www.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/compiler-options/code-generation-options/x-qx.html#x-qx" rel="noopener ugc nofollow" target="_blank">标志</a>(Linux的<code class="du ln lo lp ld b">-march=core-avx2</code>)告诉编译器默认使用AVX2指令集。然而，这意味着该软件不能在任何没有AVX2的处理器上运行。这显然不是软件开发者想要的。在我的笔记本电脑上运行AVX2软件。但是如果我用<code class="du ln lo lp ld b">-arch:COMMON-AVX512</code>(Linux用<code class="du ln lo lp ld b">-march=common-avx512</code>)编译，软件不会运行，因为我的处理器不支持AVX-512。(还有另一个标志<code class="du ln lo lp ld b">-Qx</code>或<code class="du ln lo lp ld b">-x</code>，它只为英特尔CPU执行额外的优化，结果可执行文件甚至不能在AMD CPUs上运行，它停止显示错误消息。)</p><p id="8ed0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，很多软件开发人员倾向于做的就是利用编译器的多重分派，用编译器<a class="ae jt" href="https://www.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/compiler-options/code-generation-options/ax-qax.html" rel="noopener ugc nofollow" target="_blank">标志</a> <code class="du ln lo lp ld b">-Qax</code>:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="ebaf" class="lh jv hi ld b fi li lj l lk ll">icl -QaxCORE-AVX2,COMMON-AVX512 -arch:SSE2 -Ob1 -O3 test.cpp</span></pre><p id="d9b0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ln lo lp ld b">-arch</code>标志决定了默认的代码路径。然而，额外的<code class="du ln lo lp ld b">-QaxCORE-AVX2,COMMON-AVX512</code>标志(Linux上的<code class="du ln lo lp ld b">-axCORE-AVX2,COMMON-AVX512</code>)告诉编译器生成多个分派路径，一个使用AVX2指令，另一个使用AVX-512指令。这意味着编译器编写相同代码的不同版本，并添加一个调度程序，该调度程序根据处理器的能力(在英特尔CPU上)在运行时选择运行哪个版本。需要<code class="du ln lo lp ld b">-Ob1</code> <a class="ae jt" href="https://www.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/compiler-options/inlining-options/inline-level-ob.html" rel="noopener ugc nofollow" target="_blank">标志</a> ( <code class="du ln lo lp ld b">-inline-level=1</code>)来防止编译器内联函数<code class="du ln lo lp ld b">calc()</code>，稍后我将解释为什么需要这样做。</p><p id="d301" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个多调度器代码首先检查CPU是否是Intel(“genuine Intel”CPUID)，如果检查成功，则代码检查处理器的能力(即，它是否能运行AVX2指令)，然后运行最好的一个。另一方面，如果CPU不是Intel的，那么它根本不检查功能，而是运行默认的代码路径。</p><h1 id="c4fb" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">调度员是如何工作的？</h1><p id="87cd" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">首先，反汇编目标文件(在Windows上是*。obj)来自多分派编译(即带有<code class="du ln lo lp ld b">-QaxCORE-AVX2,COMMON-AVX512</code>和<code class="du ln lo lp ld b">-Ob1 </code>标志)。在Linux上，可能需要在编译中添加<code class="du ln lo lp ld b">-c</code>标志来获得目标文件(*。o)。</p><p id="39d2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我认为读取目标文件的反汇编更容易，因为在链接之后，函数和节的名字被删除，所以它们不再出现在可执行文件中。</p><p id="c839" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">拆卸应该从头开始(即在<code class="du ln lo lp ld b">main</code>功能处)。如果没有，那么寻找以“main:”开始的部分。让我们看看第一部分-</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="0ed0" class="lh jv hi ld b fi li lj l lk ll">main:<br/>  0000000000000000: 48 83 EC 28        sub         rsp,28h<br/>  0000000000000004: B9 03 00 00 00     mov         ecx,3<br/>  0000000000000009: 33 D2              xor         edx,edx<br/>  000000000000000B: E8 00 00 00 00     call        __intel_new_feature_proc_init<br/>  0000000000000010: 0F AE 5C 24 20     stmxcsr     dword ptr [rsp+20h]<br/>  0000000000000015: 81 4C 24 20 40 80  or          dword ptr [rsp+20h],8040h<br/>                    00 00<br/>  000000000000001D: 0F AE 54 24 20     ldmxcsr     dword ptr [rsp+20h]<br/>  0000000000000022: E8 00 00 00 00     call        ?calc@@YAXXZ<br/>  0000000000000027: 33 C0              xor         eax,eax<br/>  0000000000000029: 48 83 C4 28        add         rsp,28h<br/>  000000000000002D: C3                 ret<br/>  000000000000002E: 66 90              nop</span></pre><p id="dd33" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当主程序启动时，它立即调用函数<code class="du ln lo lp ld b">__intel_new_feature_proc_init()</code>，该函数调用另一个函数<code class="du ln lo lp ld b">__intel_cpu_features_init()</code>。这是检测CPUID的函数，我相信它也是不公平调度背后的罪魁祸首。后面我会详细描述。在这个函数被调用后，它通过一些指令，并调用函数<code class="du ln lo lp ld b">calc()</code>(由于C++，这里的名字被破坏了)。现在让我们看看函数的组装。</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="7d0a" class="lh jv hi ld b fi li lj l lk ll">?calc@@YAXXZ (void __cdecl calc(void)):<br/>  0000000000000000: 48 83 EC 08        sub         rsp,8<br/>  0000000000000004: 48 BA FF 97 9D 18  mov         rdx,4189D97FFh<br/>                    04 00 00 00<br/>  000000000000000E: 48 8B 05 00 00 00  mov         rax,qword ptr [__intel_cpu_feature_indicator]<br/>                    00<br/>  0000000000000015: 48 23 C2           and         rax,rdx<br/>  0000000000000018: 48 3B C2           cmp         rax,rdx<br/>  000000000000001B: 75 09              jne         0000000000000026<br/>  000000000000001D: 48 83 C4 08        add         rsp,8<br/>  0000000000000021: E9 00 00 00 00     jmp         ?calc@@YAXXZ.h     ; Jump to AVX-512 version of calc<br/>  0000000000000026: 8B 05 00 00 00 00  mov         eax,dword ptr [__intel_cpu_feature_indicator]<br/>  000000000000002C: 25 FF 97 9D 00     and         eax,9D97FFh<br/>  0000000000000031: 3D FF 97 9D 00     cmp         eax,9D97FFh<br/>  0000000000000036: 75 09              jne         0000000000000041<br/>  0000000000000038: 48 83 C4 08        add         rsp,8<br/>  000000000000003C: E9 00 00 00 00     jmp         ?calc@@YAXXZ.V     ; Jump to AVX2 version of calc<br/>  0000000000000041: F6 05 00 00 00 00  test        byte ptr [__intel_cpu_feature_indicator],1<br/>                    01<br/>  0000000000000048: 74 09              je          0000000000000053<br/>  000000000000004A: 48 83 C4 08        add         rsp,8<br/>  000000000000004E: E9 00 00 00 00     jmp         ?calc@@YAXXZ.A    ; Jump to SSE2 version of calc<br/>  0000000000000053: E8 00 00 00 00     call        __intel_cpu_features_init<br/>  0000000000000058: EB B4              jmp         000000000000000E<br/>  000000000000005A: 66 0F 1F 44 00 00  nop         word ptr [rax+rax]</span></pre><p id="a39e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">功能开始执行后，<code class="du ln lo lp ld b">rdx</code>被设定为常数(4189D97FFh)。然后它得到了<code class="du ln lo lp ld b">__intel_cpu_feature_indicator</code>的值，我想这个值是由函数<code class="du ln lo lp ld b">__intel_cpu_features_init()</code>设置的。然后是一个<code class="du ln lo lp ld b">and</code>指令，它只将<code class="du ln lo lp ld b">rax</code>和<code class="du ln lo lp ld b">rdx</code>之间的公共位设置为1，然后将其放入<code class="du ln lo lp ld b">rax</code>。然后比较<code class="du ln lo lp ld b">rax</code>和<code class="du ln lo lp ld b">rdx</code>的值，只有当<code class="du ln lo lp ld b">rax</code>与<code class="du ln lo lp ld b">rdx</code>相比包含相同或额外的位时，才会返回true。我怀疑CPU特性指示器返回一个设置了特定位的整数(二进制),其中每一位都表示某些特性的存在。因此，这部分代码检查CPU是否能够运行可执行文件中可用的最高指令集(这里是AVX-512)。如果是，那么它继续并从<code class="du ln lo lp ld b">jmp</code>跳到<code class="du ln lo lp ld b">?calc@@YAXXZ.h</code>。如果没有，它跳转(<code class="du ln lo lp ld b">jne</code>)到第26行，再次进行相同的检查，但是使用不同的常数。这一次它检查较低的指令集(这里是AVX2)。如果是，则继续到<code class="du ln lo lp ld b">?calc@@YAXXZ.V</code>。如果不是，那么它跳到第41行，然后测试值是否为1。如果是，则进行到<code class="du ln lo lp ld b">?calc@@YAXXZ.A</code>。(如果不是，则它调用CPU特征检查器并再次开始循环)。</p><p id="844d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">英特尔的特性指示器仅返回英特尔CPU的处理器能力。对于其他CPU，<code class="du ln lo lp ld b">__intel_cpu_feature_indicator</code>始终返回1，因此它总是进入<code class="du ln lo lp ld b">?calc@@YAXXZ.A</code>路径。</p><p id="db8d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看<code class="du ln lo lp ld b">?calc@@YAXXZ.h</code>部分:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="f588" class="lh jv hi ld b fi li lj l lk ll">?calc@@YAXXZ.h (?calc@@YAXXZ.h):<br/>  0000000000000000: B8 78 9F 24 00     mov         eax,249F78h<br/>.... (some lines)<br/>  000000000000007B: 62 C1 7C 48 10 64  vmovups     zmm20,zmmword ptr [r13+rax*4+80h]<br/>                    85 02<br/>  0000000000000083: 62 C1 7C 48 10 74  vmovups     zmm22,zmmword ptr [r13+rax*4+0C0h]<br/>                    85 03<br/>  000000000000008B: 62 C1 7D 40 FE 8C  vpaddd      zmm17,zmm16,zmmword ptr [r13+rax*4+0C3500h]<br/>                    85 00 35 0C 00<br/>  0000000000000096: 62 C1 6D 40 FE 9C  vpaddd      zmm19,zmm18,zmmword ptr [r13+rax*4+0C3540h]<br/>....</span></pre><p id="c5ed" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">512位<code class="du ln lo lp ld b">zmm</code>寄存器指示这是AVX-512代码。<code class="du ln lo lp ld b">vmovups</code>指令从指针指示的位置将整数载入寄存器。然后<code class="du ln lo lp ld b">vpaddd</code>指令在一个周期内将加载的整数(即16个整数)相加。这应该会转化为大量的性能增益。然而，整数加法本质上是如此之快，以至于在你的程序中需要大量的整数加法，你才能看到明显的不同。</p><p id="5144" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那<code class="du ln lo lp ld b">?calc@@YAXXZ.V</code>呢？这里可以看到AVX2代码的256位<code class="du ln lo lp ld b">ymm</code>寄存器:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="a743" class="lh jv hi ld b fi li lj l lk ll">?calc@@YAXXZ.V<br/>.... (some lines)<br/>  000000000000007E: C4 C1 7E 6F 64 85  vmovdqu     ymm4,ymmword ptr [r13+rax*4+40h]<br/>                    40<br/>  0000000000000085: C4 C1 7D FE 8C 85  vpaddd      ymm1,ymm0,ymmword ptr [r13+rax*4+0C3500h]<br/>                    00 35 0C 00<br/>  000000000000008F: C4 C1 6D FE 9C 85  vpaddd      ymm3,ymm2,ymmword ptr [r13+rax*4+0C3520h]<br/>....</span></pre><p id="8994" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ln lo lp ld b">?calc@@YAXXZ.A</code>部分应该包含最慢的代码，SSE2，这就是我们发现的:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="ee1d" class="lh jv hi ld b fi li lj l lk ll">?calc@@YAXXZ.A<br/>.... (some lines)<br/>  000000000000006C: 66 0F 6F 54 84 40  movdqa      xmm2,xmmword ptr [rsp+rax*4+40h]<br/>  0000000000000072: 66 0F 6F 5C 84 50  movdqa      xmm3,xmmword ptr [rsp+rax*4+50h]<br/>  0000000000000078: 66 0F FE 84 84 20  paddd       xmm0,xmmword ptr [rsp+rax*4+0C3520h]<br/>                    35 0C 00<br/>....</span></pre><p id="8fe6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">128位的<code class="du ln lo lp ld b">xmm</code>寄存器指示SSE代码，<code class="du ln lo lp ld b">movdqa</code>和<code class="du ln lo lp ld b">paddd</code>指令分别加载整数并执行加法。</p><p id="f5b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，很明显，如果不是因为<code class="du ln lo lp ld b">__intel_cpu_feature_indicator</code>为AMD处理器返回1，调度程序应该可以完美地工作。该变量的值由函数<code class="du ln lo lp ld b">void __intel_cpu_features_init()</code>设置(函数的名称根据编译器和MKL的版本而变化)，该函数在链接期间被插入到程序中。</p><p id="b93d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像我上面描述的CPU调度程序也存在于英特尔MKL库中。因此，当您链接到英特尔MKL函数库时，调度程序会自动进入软件。</p><p id="6f5b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过使用链接器标志(<code class="du ln lo lp ld b">/debug:full</code>)进行编译，然后反汇编可执行文件，可以在汇编形式中检查函数<code class="du ln lo lp ld b">__intel_cpu_features_init()</code>。这是因为在Windows上，默认模式下的链接器破坏了函数的名称，因此无法从二进制文件中恢复它们。我不确定在Linux中会发生什么，但是我相信不需要额外的标志。</p><p id="51d2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">函数<code class="du ln lo lp ld b">__intel_cpu_features_init()</code>是这样工作的:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="ac94" class="lh jv hi ld b fi li lj l lk ll">__intel_cpu_features_init:<br/>  000000014001C7E0: B8 01 00 00 00     mov         eax,1<br/>  000000014001C7E5: E9 16 00 00 00     jmp         000000014001C800<br/>....</span><span id="96ac" class="lh jv hi ld b fi lm lj l lk ll">000000014001C867: 0F A2              cpuid<br/>  000000014001C869: 89 84 24 A0 00 00  mov         dword ptr [rsp+0A0h],eax<br/>                    00<br/>  000000014001C870: 89 9C 24 A4 00 00  mov         dword ptr [rsp+0A4h],ebx<br/>                    00<br/>  000000014001C877: 89 8C 24 A8 00 00  mov         dword ptr [rsp+0A8h],ecx<br/>                    00<br/>  000000014001C87E: 89 94 24 AC 00 00  mov         dword ptr [rsp+0ACh],edx<br/>                    00<br/>.... </span><span id="7e6d" class="lh jv hi ld b fi lm lj l lk ll">  000000014001D364: 81 BC 24 A4 00 00  cmp         dword ptr [rsp+0A4h],756E6547h # "Genu"<br/>                    00 47 65 6E 75<br/>  000000014001D36F: 75 90              jne         000000014001D301<br/>  000000014001D371: 81 BC 24 AC 00 00  cmp         dword ptr [rsp+0ACh],49656E69h # "ineI"<br/>                    00 69 6E 65 49<br/>  000000014001D37C: 75 83              jne         000000014001D301<br/>  000000014001D37E: 81 BC 24 A8 00 00  cmp         dword ptr [rsp+0A8h],6C65746Eh # "ntel"<br/>                    00 6E 74 65 6C<br/>  000000014001D389: 0F 85 72 FF FF FF  jne         000000014001D301</span></pre><p id="6cd6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">调用该函数后，使用<code class="du ln lo lp ld b">cpuid</code>指令获取CPU供应商名称，然后将其存储在内存位置。关键部分包含三对<code class="du ln lo lp ld b">cmp</code>和<code class="du ln lo lp ld b">jne</code>指令。第一条指令将厂商字符串(<code class="du ln lo lp ld b">rsp+0A4h</code>)的前4个字节与常量<code class="du ln lo lp ld b">756E6547h</code>进行比较。现在，大多数消费类计算机都是小端的，所以这个常量被翻译成十六进制数<code class="du ln lo lp ld b">47 65 6E 75</code>，它代表字符串<code class="du ln lo lp ld b">Genu</code>。如果数字不相等，那么它跳转(<code class="du ln lo lp ld b">jne</code>)到另一行，最终将<code class="du ln lo lp ld b">__intel_cpu_feature_indicator</code>的值设置为1。接下来的两行检查厂商字符串的第二个4字节是否等于字符串<code class="du ln lo lp ld b">ineI</code>，否则进行相同的跳转。最后两行将厂商字符串的第三个4字节与<code class="du ln lo lp ld b">ntel</code>进行比较，如果不匹配，则执行相同的跳转。</p><p id="3557" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上，该函数正在检查CPU供应商字符串是否与<code class="du ln lo lp ld b">GenuineIntel</code>匹配。如果所有检查都成功，那么代码继续正常运行，并通过<code class="du ln lo lp ld b">__intel_cpu_feature_indicator</code>返回CPU支持的向量指令。</p><p id="cabf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可能已经注意到，我已经把做实际计算的那部分代码放在一个单独的函数中，然后从<code class="du ln lo lp ld b">main()</code>调用它，并且停止了内联，也就是说，用函数本身内部的代码替换函数调用。这迫使英特尔C++编译器制作函数<code class="du ln lo lp ld b">calc()</code>的多个分派副本。如果你把你的计算放在main中，那么编译器会制作不同的<code class="du ln lo lp ld b">main()</code>副本，CPUID检查会在软件的其他部分调用<code class="du ln lo lp ld b">main()</code>之前进行。这使得修补二进制文件变得困难(我将在下一节解释)。事实上，当主函数被分成多个分派副本时，我一直无法弄清楚检查究竟发生在哪里。我的贴片在这种情况下不起作用。所以，把你的计算放在一个单独的函数/子程序中。而不是在代码的主要部分。</p><h1 id="6fde" class="ju jv hi bd jw jx jy jz ka kb kc kd ke io kf ip kg ir kh is ki iu kj iv kk kl bi translated">如何修复不公平的调度员？</h1><p id="6ac8" class="pw-post-body-paragraph ix iy hi iz b ja km ij jc jd kn im jf jg ko ji jj jk kp jm jn jo kq jq jr js hb bi translated">如果您可以访问源代码，修复调度程序的一种方法是在编译之前在源代码中添加您自己的<code class="du ln lo lp ld b">__intel_cpu_features_init()</code>函数，以便它取代英特尔的CPU检查器函数。Agner Fog在他的<a class="ae jt" href="http://__intel_cpu_features_init" rel="noopener ugc nofollow" target="_blank">博客</a>和他的C++ <a class="ae jt" href="https://www.agner.org/optimize/#manual_cpp" rel="noopener ugc nofollow" target="_blank">优化手册</a>中详细描述了这种方法。然而，源代码并不总是可用的，所以这不是很有用。许多像MATLAB这样的商业软件使用英特尔MKL库，因此它们在AMD上的性能受到影响。虽然英特尔似乎已经在最近的一次更新中修复了MKL在AMD上的性能问题。</p><p id="a655" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在2020年之前，英特尔有一个未记录的环境变量(<code class="du ln lo lp ld b">MKL_DEBUG_CPU_TYPE</code>)，可以设置它以避免不公平的调度。但是，一旦关于该功能的消息传播开来，英特尔在他们的下一次更新中删除了它。</p><p id="3bd8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一种无需源代码的简单修补方法是以检查CPU供应商ID的<code class="du ln lo lp ld b">cmp</code>指令为目标。即使当程序被编译(即二进制形式)时，字符串常量，即<code class="du ln lo lp ld b">Genu</code>、<code class="du ln lo lp ld b">ineI</code>、<code class="du ln lo lp ld b">ntel</code>也存在于程序中。如果我们用<code class="du ln lo lp ld b">Auth</code>、<code class="du ln lo lp ld b">enti</code>、<code class="du ln lo lp ld b">cAMD</code>替换这些常量，那么CPU检查将会寻找AMD处理器！因此，调度程序将为AMD处理器正确工作。</p><p id="af08" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种类型的修补可以通过十六进制编辑器在文件中查找字节来完成。我制作了一个简单的python脚本来自动完成这项工作。该脚本寻找三条相互接近的<code class="du ln lo lp ld b">cmp</code>指令，其中三个字符串对应英特尔CPUID。如果找到这样的模式，那么它会将字符串常量替换为<code class="du ln lo lp ld b">Auth</code>、<code class="du ln lo lp ld b">enti</code>、<code class="du ln lo lp ld b">cAMD</code>(即<code class="du ln lo lp ld b">AuthenticAMD</code>)。修补后的代码应该可以在AMD上成功运行。这里有一个可用的修补程序<a class="ae jt" href="https://github.com/jimenezrick/patch-AuthenticAMD" rel="noopener ugc nofollow" target="_blank"/>以类似的原理工作，但它只在Linux上工作，并且它不检查与字符串常量比较的不同顺序(较新版本的英特尔编译器和MKL使用)。我的python脚本应该可以在Windows和Linux上运行，不会有任何问题，它会检查字符串常量顺序的所有变化。但是，它稍微不太安全，因为它在打补丁之前不会做太多检查。</p><p id="dffd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">python脚本可以在我的github repo中的这里找到<a class="ae jt" href="https://github.com/shoubhikraj/intel-cpu-patch" rel="noopener ugc nofollow" target="_blank">。请记住，编辑二进制文件和可执行文件总是很危险的。因此，请务必备份您正在修改的文件。该脚本用<code class="du ln lo lp ld b">AuthenticAMD</code>替换它能找到的所有检查英特尔CPUID ( <code class="du ln lo lp ld b">GenuineIntel</code>)的实例。我已经在我的电脑上测试过了，效果相当好。但是，无法保证这种改装是否安全。有些软件有防补丁机制，如果你修改了可执行文件，它就会停止工作。一些软件也可能有合法的理由检查CPU是否是英特尔的(例如，用于识别线程策略)。因此，用我提供的python脚本修补可执行文件时，应该非常小心。尽管如此，修补CPU调度程序将显示一些性能增益，特别是对于数值计算。</a></p><p id="92f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要修补二进制文件，首先运行python脚本:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="4d84" class="lh jv hi ld b fi li lj l lk ll">python find_intel_replace.py myfile.exe</span></pre><p id="c933" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以在*上运行脚本。exe和*。仅dll文件。我添加了这项检查，以确保脚本不会意外修改非二进制文件。python脚本将遍历二进制文件，并检查它可以找到可能的Intel CPUID检查的位置，但它不会修改二进制文件。</p><p id="ac82" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在检查它是否有Intel CPUID检查之后，您可以使用参数<code class="du ln lo lp ld b">--force</code>来修改该文件:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="5e25" class="lh jv hi ld b fi li lj l lk ll">python find_intel_replace.py myfile.exe --force</span></pre><p id="36c6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">再次重申，不要在操作系统使用的系统DLL或EXE文件上使用脚本，因为这可能会损坏您的计算机。即使你在用户安装的软件上使用它，也要备份！！</p><p id="c357" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本博客的下一部分中，我将讨论AMD上安装这个补丁的预期性能增益，以及其他可能的用途。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="912c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！请随时在回复中留下评论或问题。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="8a09" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python脚本可以在这里找到:<a class="ae jt" href="https://github.com/shoubhikraj/intel-cpu-patch/blob/main/find_intel_replace.py" rel="noopener ugc nofollow" target="_blank">https://github . com/shoub hikraj/Intel-CPU-patch/blob/main/find _ Intel _ replace . py</a>。</p></div></div>    
</body>
</html>