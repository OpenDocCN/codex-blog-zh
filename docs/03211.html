<html>
<head>
<title>Pythonic data (pipeline) testing on Azure Databricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure数据块上的Pythonic数据(管道)测试</h1>
<blockquote>原文：<a href="https://medium.com/codex/pythonic-data-pipeline-testing-on-azure-databricks-2d27d3b5d587?source=collection_archive---------3-----------------------#2021-08-23">https://medium.com/codex/pythonic-data-pipeline-testing-on-azure-databricks-2d27d3b5d587?source=collection_archive---------3-----------------------#2021-08-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="fb13" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">有没有想过如何在不建立全面的企业级数据质量解决方案的情况下，以有效的方式测试数据和数据管道？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e78204aee7687bb6302d55bc4d54080f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ajTNgjq06ekijHMF"/></div></div></figure><p id="5367" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Python为单元测试代码提供了很多很棒的包。这样，您就可以检查您的管道代码是否正在运行。您当然可以使用fixtures来隔离单元测试，并且不要让单元测试依赖于变化的数据。但是，您如何检查您更改的数据转换是否会影响您的机器学习模型预期的数据管道结果？</p><p id="86ce" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">前段时间，我在Medium上写了<a class="ae kf" href="https://towardsdatascience.com/great-expectations-ef9059f04995" rel="noopener" target="_blank">这篇</a>关于开源Python包<a class="ae kf" href="https://greatexpectations.io/" rel="noopener ugc nofollow" target="_blank">的价值的博客文章</a>。</p><p id="01e9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当时，我是一名顾问，在一个机器学习项目上为我的客户提供支持。我们使用了大量的内部数据源。当我们开始这个项目时，目标是快速原型化产品，并将智能部分开发为界面。我们将原始源中的所有数据复制到一个数据湖中。当然，在早期勘探阶段，我们既没有合适的管道，也没有接口合同。</p><p id="8ff4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于实时ML模型，我们使用Kafka流中的数据，这些数据来自客户使用的移动应用程序。有一天，我们的模型发疯了，我们花了一些时间才弄明白发生了什么。appdev团队更改了应用的源代码，导致数据混乱。因为我们是唯一真正消耗这些数据的团队，所以我们是唯一受到影响的人。</p><p id="730a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们需要一个快速解决方案来防止这个问题再次发生。因为我们是Python的人，所以我们想给远大前程一个机会。最小环境的设置在几天内就完成了。我们没有失望。</p><p id="e16f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我经历了类似的设置，但是我和客户一起在Azure上设置他们的ML架构。从我早期的项目中，我知道Great Expectations需要通过一个yaml文件来建立和配置，并且产生的工件(expectation suites，validation runs，DataDocs)也存储在一个文件系统中。所以对我来说，在像Azure Databricks和Azure Machine Learning这样的云服务上设置这似乎有点笨拙，我花了一些时间研究如何在托管环境中实现这一点。</p><p id="636c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">《远大前程》的一个精彩特性是数据文档，以及这个特性为团队带来的机会。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kg"><img src="../Images/d04246cadc38dfdbc5b969c739bb1798.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*TBl0F0bBkLRteQ5-cmz_lQ.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">图片取自远大前程YouTube频道。</figcaption></figure><p id="34d5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">DataDocs不仅是所用数据的文档，或者显示数据验证的结果，还可以作为数据契约使用。主题专家、数据科学家和数据工程师可以在同一页面上工作，以确保数据得到充分理解，并确保数据质量。</p><p id="3446" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在我看来，这在MLOps管道中特别有趣，除了测试代码本身之外，您还需要测试管道代码、数据漂移，并验证您从其他数据源或供应商处获取的数据。</p><p id="e4f0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">好吧，但是在我们进入实质之前，我想告诉你我是如何使用这个包的！我把远大前程看做一个框架，挑出我觉得有用的东西。所以当我使用Spark工作时，我只配置数据源来提供我以后可以使用的元数据信息。我主要是手动加载一批数据，然后将Spark数据帧放入batch_kwargs(或者……在新的API中)。</p><p id="4c9b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kl">💻在博客文章的末尾找到附加的代码。</em></p><p id="abbf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一个远大前程项目的建立有两种方式。如果您运行的系统已经准备好了文件系统，请选择第一种方式。从great-expectations init开始创建配置框架，并相应地配置您的DataContext。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es km"><img src="../Images/8e67a7b69123a7d010c0645064d80553.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*90AbH6896wRW1psjnCwj-g.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">使用文件系统时，使用高期望值时产生的文件夹结构。</figcaption></figure><p id="8f4f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当您在托管系统上运行时，比如云中的PaaS，您可能并不总是有可用的CLI或文件系统来方便地持久存储文件夹。使用Azure Databricks或Azure Machine learning，理论上你可以访问CLI或文件系统(就像ADB上的DBFS或AML计算实例上的Linux)。但这似乎不是最佳选择，因为在云中，您最好使用其他选项，比如有一个更集中的位置来存储您的配置和工件。</p><p id="e5c9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我从观看YouTube上的<a class="ae kf" href="https://youtu.be/pq5CBea12v4" rel="noopener ugc nofollow" target="_blank">网上研讨会</a>开始，并在文档中找到了许多有用的材料(<a class="ae kf" href="https://docs.greatexpectations.io/en/latest/guides/how_to_guides/configuring_data_contexts/how_to_instantiate_a_data_context_without_a_yml_file.html" rel="noopener ugc nofollow" target="_blank">如何在没有YML文件的情况下开始</a>，<a class="ae kf" href="https://docs.greatexpectations.io/en/latest/guides/how_to_guides/configuring_data_contexts/how_to_instantiate_a_data_context_on_a_databricks_spark_cluster.html" rel="noopener ugc nofollow" target="_blank">如何在数据块上运行</a>)。</p><p id="4fc4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如前所述，我喜欢指定数据的位置以使其作为元数据可用，但不想使用ExecutionEngine为我生成一批数据。稍后我将手动执行该操作。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kn"><img src="../Images/514ab9cd75e856df4c510d485d2b5edd.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*ctaaFVTBIEz2Ln53Q_SkBg.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">数据源的最小配置。</figcaption></figure><p id="5213" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我使用Azure Key Vault backed scope 来管理我的秘密。结合Azure Databricks或AzureML，做到这一点非常容易。这是我在使用配置作为代码时的一个优势。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ko"><img src="../Images/6cd0760027c7c269be3e5adbe9f1737b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VhTZ5XJq6YTtgKGQxbtD0g.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">使用密钥库支持的作用域来管理机密。</figcaption></figure><p id="2c1d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在使用yaml文件来配置DataContext的情况下，您可以使用一个没有签入git存储库的<a class="ae kf" href="https://docs.greatexpectations.io/en/latest/guides/how_to_guides/configuring_data_contexts/how_to_use_a_yaml_file_or_environment_variables_to_populate_credentials.html#how-to-guides-configuring-data-contexts-how-to-use-a-yaml-file-or-environment-variables-to-populate-credentials" rel="noopener ugc nofollow" target="_blank"> secrets配置文件</a>，或者使用与Azure Key Vault 相同的<a class="ae kf" href="https://docs.greatexpectations.io/en/latest/guides/how_to_guides/configuring_data_contexts/how_to_populate_credentials_from_a_secrets_store.html#how-to-guides-configuring-data-contexts-how-to-populate-credentials-from-a-secrets-store" rel="noopener ugc nofollow" target="_blank">方法。</a></p><p id="6415" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们从数据源的配置开始。我希望稍后在DataDocs中使用该配置作为元数据，但不一定希望使用ExecutionEngine加载一批配置，我稍后将手动执行。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kp"><img src="../Images/fa17770ebf01042b13a2443182277125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*XglcwWcRB-nIQVT1Q5FkGA.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">数据上下文的配置。</figcaption></figure><p id="7a68" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我想在Azure Blob存储上存储我所有的工件(期望、验证)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kq"><img src="../Images/2b616baba50832d4c0a77bb7459a03e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*gcFyynwDul3qXeXfFMTq6g.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">将配置设置为在Azure Blob存储上存储预期。</figcaption></figure><p id="a0b6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">数据文档也将被推送到Azure Blob存储器，但是我们将使用\$web容器来托管静态网站。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kr"><img src="../Images/c395743829fb9455cda8827d30439aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*6I8MDMY9Eb2sjouHqLZ-mQ.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">数据文档的配置</figcaption></figure><p id="e177" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">手动创建一批数据(火花数据帧)…</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ks"><img src="../Images/d2063667f33d3edb5f44e782f3e1b3a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*SxHymi1HyF7_ZRTGbSN1hQ.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">加载一批数据。</figcaption></figure><p id="5097" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">…我们开始吧。让我们创造一些期望。您可能需要查看文档或尝试一下。这是不言自明的。所以我们只是跳到下一个阶段。保存期望套件之后，我们可以运行一个验证或者创建一个检查点。我们将使用run_validation_operator根据一批数据来验证一批数据。它将进行验证运行，将生成的工件推送到存储区，并更新DataDocs。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kt"><img src="../Images/d6c2c16cab451bb6eceda35fe23650c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/format:webp/1*R653aRNWK4uwDDLYVrNLwQ.png"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">不要忘记代码版本。</figcaption></figure><p id="f56b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，浏览数据文档并查看验证结果。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ku"><img src="../Images/1e6446cae215c8af9a26d933372e4815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vyr0y66RxWLSmYBqLiIrow.png"/></div></div></figure><p id="a05f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后一个注意事项:<a class="ae kf" href="https://cookiecutter.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> Cookiecutter </a>在您有大量数据源和需要检查每个转换步骤的复杂数据管道时非常有用。</p><p id="abd0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在下一篇博客文章中，我们将看看<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/databricks/data-engineering/delta-live-tables/" rel="noopener ugc nofollow" target="_blank"> Delta Live Tables </a>，看看这个新的(预览)数据块特性如何对管道测试有用。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kv kw l"/></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">在Azure数据块上运行Great Expectations管道测试的完整代码。</figcaption></figure></div></div>    
</body>
</html>