<html>
<head>
<title>7 Basic Algorithms Every Newbie Coder Should Know: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个编程新手都应该知道的7个基本算法:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/7-basic-algorithms-every-newbie-coder-should-know-part-2-425985e0ae69?source=collection_archive---------6-----------------------#2021-08-01">https://medium.com/codex/7-basic-algorithms-every-newbie-coder-should-know-part-2-425985e0ae69?source=collection_archive---------6-----------------------#2021-08-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b45e8f27e17ad47bf085f51a89756015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bF93fdrIywFZAiTmnSP7nw.jpeg"/></div></div></figure><p id="94d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文是一个系列的第2部分，涵盖了每个编程新手都应该知道的7个基本算法。以下是该系列的计划:</p><ul class=""><li id="2cdc" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae jx" rel="noopener" href="/@manvendraaaa/7-basic-algorithms-every-newbie-coder-should-know-part-1-6119ca14e6df">算法介绍:第一部分</a></li><li id="3611" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" rel="noopener" href="/@manvendraaaa/7-basic-algorithms-every-newbie-coder-should-know-part-2-425985e0ae69">搜索&amp;排序算法:第二部分</a></li><li id="b587" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" rel="noopener" href="/@manvendraaaa/7-basic-algorithms-every-newbie-coder-should-know-part-3-dc25feb68f66">两个指针&amp;滑动窗口:第三部分</a></li></ul><p id="a09b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将介绍最基本的搜索和排序算法。所以在整篇文章中，我将使用一个例子，7个不同身高的人站成一条直线来解释算法。</p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h2 id="8eb3" class="kk kl hi bd km kn ko kp kq kr ks kt ku jb kv kw kx jf ky kz la jj lb lc ld le bi translated">线性搜索</h2><p id="0000" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">这是最基本的搜索算法之一，最坏情况的时间复杂度为O(n ),最好情况的时间复杂度为O(1)。</p><blockquote class="lk ll lm"><p id="f4ac" class="iq ir ln is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated">定义:在计算机科学中，线性搜索或顺序搜索是一种在列表中查找元素的方法。它按顺序检查列表中的每个元素，直到找到匹配项或搜索完整个列表。</p></blockquote><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/2bda0b6b5c804e4ac3839139abb4a8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/1*mSRDuXonYS3-hjPQe0RAVQ.gif"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">图片提供:<a class="ae jx" href="https://www.tutorialspoint.com/" rel="noopener ugc nofollow" target="_blank">教程点</a></figcaption></figure><p id="e801" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么让我们用一个真实的例子来理解这个算法。正如我们所知，我们有7个不同身高的人随机站成一排&amp;假设这些人的身高是180、140、170、160、190、130、150厘米&amp;假设这些人的名字是P1、P2……..P7。如果我们想找到一个身高160厘米的人，我们可以在这里使用线性搜索。我们开始传递一行人，并询问每个人的身高，如果身高等于160厘米，我们可以返回此人的位置或姓名，如果没有人，我们可以返回零值。在这个场景中，我们将询问每个人的身高，当我们到达P4时，我们将知道这个人的身高是160厘米。下面是线性搜索的伪代码，我希望你能尝试用你喜欢的编程语言来实现它。</p><pre class="ls lt lu lv fd ma mb mc md aw me bi"><span id="35a8" class="kk kl hi mb b fi mf mg l mh mi"><strong class="mb hj">Step 1.</strong> Take Input of the array and x.</span><span id="9db0" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 2. </strong>Start from the leftmost element of list/array and one by one compare x with each element of array/list.</span><span id="df1f" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 3.</strong> If x matches with an element, return the index.</span><span id="be48" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 4.</strong> If x doesn’t match with any of elements, return -1.</span></pre></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h2 id="3345" class="kk kl hi bd km kn ko kp kq kr ks kt ku jb kv kw kx jf ky kz la jj lb lc ld le bi translated">二进位检索</h2><p id="1ec8" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">二分搜索法是一种搜索算法，用于查找排序数组中元素的位置。简而言之，这种搜索算法通过在一次比较后忽略一半的元素来利用已经排序的元素集合。</p><blockquote class="lk ll lm"><p id="eb66" class="iq ir ln is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated">定义:在计算机科学中，二分搜索法，也称为半区间搜索、对数搜索或二进制斩波，是一种在排序数组中查找目标值位置的搜索算法。二分搜索法将目标值与数组的中间元素进行比较。如果它们不相等，则消除目标不能位于其中的一半，并且在剩余的一半上继续搜索，再次取中间的元素来与目标值进行比较，并且重复这一过程，直到找到目标值。如果搜索结束时剩下的一半为空，则目标不在数组中。</p></blockquote><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">视频提供:<a class="ae jx" href="https://gfycat.com/" rel="noopener ugc nofollow" target="_blank"> Gyfcat </a></figcaption></figure><p id="c51b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们用理解线性搜索的同一个例子来理解二分搜索法，但在此之前，让我们看看二分搜索法的先决条件；与元素可以是任意顺序的线性搜索不同，二分搜索法中的数组必须排序。这是二分搜索法的唯一先决条件。</p><p id="40e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1.让我们考虑人们以这种方式站成一排。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/9dee5e3e6f83fb22be5fe4cda876f67c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*QaP1TQGobdtyN6TO5ZUabw.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">按照升序排列的人。</figcaption></figure><p id="bda5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.设x = 4 (P4)是被搜索的人。</p><p id="e652" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.在第一个和最后一个元素分别设置两个低和高指针。</p><p id="1cba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.找到数组中间的元素。arr[(低+高)/2] = 160。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/e301e59f41769282535000d3c3e1fa2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*Bhh5LccwUn7PQQ_nnR4uXA.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">(0+6)/2 = 3 == P4 == 160</figcaption></figure><p id="c0d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.如果x == mid，则返回mid。否则，将待搜索的元素与m进行比较。</p><p id="62c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">6.如果x &gt; mid，则将x与mid右侧元素中的中间元素进行比较。这可以通过将low设置为low = mid + 1来实现。</p><p id="1c82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">7.否则，将x与mid左侧元素中的中间元素进行比较。这是通过将high设为high = mid-1来实现的。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/80d2be95384ad532be94b47d6ca843e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*ijJXJbJA04DpaDwNa5jfjQ.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">新低和新高</figcaption></figure><p id="4ba3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">8.重复这些步骤，直到低遇到高。我们找到了P4。</p><p id="e586" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种搜索技术更快，更容易实现，不需要额外的空间&amp;在很大程度上降低了程序的时间复杂度。最坏情况下的时间复杂度为O(nlogn)。下面给出了这个算法的伪代码，我希望你能用你喜欢的语言实现这个算法。</p><pre class="ls lt lu lv fd ma mb mc md aw me bi"><span id="5c66" class="kk kl hi mb b fi mf mg l mh mi"><strong class="mb hj">Step 1</strong>. Let the element we are searching for, in the given array/list is X.</span><span id="dcb4" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 2</strong>. Compare X with the middle element in the array.</span><span id="3be9" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 3</strong>. If X matches with the middle element, we return the middle index.</span><span id="8b0b" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 4</strong>. If X is greater than the middle element, then X can only lie in the right (greater)half subarray after the middle element, then we apply the algorithm again for the right half.</span><span id="d37e" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 5</strong>. If X is smaller than the middle element, then X must lie in the left (lower) half , this is because the array is sorted. So we apply the algorithm for the left half.</span></pre></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><h2 id="d00a" class="kk kl hi bd km kn ko kp kq kr ks kt ku jb kv kw kx jf ky kz la jj lb lc ld le bi translated">整理</h2><p id="094c" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">排序是对元素列表的排列，使得元素按升序或降序排列。有许多不同的排序技术。主要区别在于它们在程序中执行时所消耗的空间和时间。现在，我们将讨论以下排序技术:</p><ul class=""><li id="5468" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">选择排序</li><li id="70ce" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">冒泡排序</li><li id="9253" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">插入排序</li></ul><p id="b200" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们详细讨论一下这些排序技术。</p><h2 id="5bf0" class="kk kl hi bd km kn ko kp kq kr ks kt ku jb kv kw kx jf ky kz la jj lb lc ld le bi translated">选择排序法</h2><blockquote class="lk ll lm"><p id="0557" class="iq ir ln is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated">定义:选择排序是一种算法，它在每次迭代中从未排序列表中选择最小的元素，并将该元素放在未排序列表的开头。详细算法如下。</p></blockquote><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/700366c3acb405a5c1978dd2091d05c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*sBC4znJwu6ZzhJ7h5OYSTg.gif"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">图片提供:<a class="ae jx" href="https://gfycat.com/" rel="noopener ugc nofollow" target="_blank"> Gyfcat </a></figcaption></figure><p id="857f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在你掌握了上面的图形之后，我将描述<em class="ln">选择排序</em>算法是如何工作的。我希望你从图像中得到一些东西；现在我将把它分解给你，让它变得非常简单易懂。我们首先假设图中的第一个条形(3)具有最小的高度，然后遍历数组，将其与每个条形进行比较，如果条形的高度更小，我们将它作为新的最小值，在图的末尾，我们将具有最小高度的条形(2)，我们将与第一个条形交换，从而在图中的第一个位置产生最小的条形。</p><p id="59e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将从第二个条(44)开始，作为下一次迭代的最小值，因为第一个条已经排序并位于正确的位置，我们将重复这个过程。我们需要进行n-1次迭代来对图进行完全排序，其中n是元素/条的数量。下面提供了相同的伪代码，我希望你能尝试用你喜欢的编程语言实现相同的功能。</p><pre class="ls lt lu lv fd ma mb mc md aw me bi"><span id="d6bc" class="kk kl hi mb b fi mf mg l mh mi"><strong class="mb hj">Step 1</strong> − Set MIN to location 0</span><span id="531d" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 2</strong> − Search the minimum element in the list</span><span id="aa5b" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 3</strong> − Swap with value at location MIN</span><span id="10b4" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 4</strong> − Increment MIN to point to next element</span><span id="4d7a" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 5</strong> − Repeat until list is sorted.</span></pre><h2 id="63c7" class="kk kl hi bd km kn ko kp kq kr ks kt ku jb kv kw kx jf ky kz la jj lb lc ld le bi translated">冒泡排序</h2><blockquote class="lk ll lm"><p id="ac92" class="iq ir ln is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated">定义:冒泡排序(Bubble sort)，也称为下沉排序(sinking sort)，是一种基本的排序算法，它遍历一个列表，比较相邻的元素，如果它们无序，就交换它们。列表被一次又一次地发送，直到它被排序。比较排序法是根据较小或较大的组件“冒泡”到列表顶部的方式命名的。这种简单的方法在现实世界中表现不佳，主要用作教学辅助。</p></blockquote><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/4ae86f1d7d00ab8fc5886e32a59c38b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wCf-rOesNILwXC0FLAr3ag.gif"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">图片提供:<a class="ae jx" href="https://gfycat.com/" rel="noopener ugc nofollow" target="_blank"> Gyfcat </a></figcaption></figure><p id="299e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在你掌握了上面的图形之后，我将描述一下<em class="ln">冒泡排序</em>算法是如何工作的。我希望你从图像中得到一些东西；现在我将把它分解给你，让它变得非常简单易懂。我们首先遍历图/列表，比较每一个相邻的成员，如果它们是无序的，就交换它们，到第一次迭代结束时，我们将在最后得到最大的元素。</p><p id="42fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在接下来的迭代中，我们将从第一个元素开始，重复比较和交换过程，但是这次我们将只进行倒数第二个元素，因为最后一个元素已经被排序并位于正确的位置。要对列表进行排序，我们必须执行n-1次，类似于选择排序，其中n代表列表中元素的数量。下面你可以找到同样的伪代码，我希望你能用你喜欢的编程语言实现它。</p><pre class="ls lt lu lv fd ma mb mc md aw me bi"><span id="ab3e" class="kk kl hi mb b fi mf mg l mh mi"><strong class="mb hj">Step 1.</strong> In first cycle, Start by comparing 1st and 2nd element and swap if 1st element is greater. After that do the same for 2nd and 3rd element. At the end of cycle you will get max element at the end of list.</span><span id="343e" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 2.</strong> Now do the same in all subsequent cycles.</span><span id="adbf" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 3.</strong> Perform this for (number of elements – 1) times.</span><span id="5923" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 4.</strong> You will get sorted list.</span></pre><h2 id="94e8" class="kk kl hi bd km kn ko kp kq kr ks kt ku jb kv kw kx jf ky kz la jj lb lc ld le bi translated">插入分类</h2><blockquote class="lk ll lm"><p id="b538" class="iq ir ln is b it iu iv iw ix iy iz ja lo jc jd je lp jg jh ji lq jk jl jm jn hb bi translated">定义:插入排序是一种简单的排序算法，它一次构建一个最终排序的数组(或列表)。在大型列表上，它的效率比快速排序、堆排序或合并排序等更高级的算法要低得多。但是，插入排序有几个优点。插入排序是一种排序算法，它一次一个元素地构建最终排序的数组(有时称为列表)。插入排序的平均和最坏情况运行时间为O(n)，O(n)，因此在大多数情况下，更快的算法是更可取的。</p></blockquote><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/3c8bd9da2e52f81857081ff8fadbfaef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*UpB6EEJZB8HihhERZWxC-A.gif"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">图片提供:<a class="ae jx" href="http://www.xybernetics.com/" rel="noopener ugc nofollow" target="_blank"> Zybernetics </a></figcaption></figure><p id="cf08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在您掌握了上面的图形之后，我将描述一下<em class="ln">插入排序</em>算法是如何工作的。我希望你从图像中得到一些东西；现在我将把它分解给你，让它变得非常简单易懂。</p><p id="2838" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ln">插入排序</em>的工作方式类似于我们在纸牌游戏中排序手中的牌。假设上图中的数字在你的右手边，你想对它们进行排序；所以你从右边选择最左边的卡片，放在你的左手。我们可以说左手边的列表已经排序，因为只有一张卡片存在&amp;现在我们将再次从右手中挑选最左边的卡片，并将其与左手中唯一的卡片进行比较，比较后，我们将按顺序排列。然后，我们将从右手中取出最左边的卡片，将其与左手中的所有其他卡片进行比较，并相应地放置，直到我们的左手中有三张排序的卡片，我们将重复这些过程，直到我们的右手中没有任何卡片。下面你会发现<em class="ln">插入排序</em> &amp;的伪代码，我希望你会用你喜欢的编程语言实现它。</p><pre class="ls lt lu lv fd ma mb mc md aw me bi"><span id="6a44" class="kk kl hi mb b fi mf mg l mh mi"><strong class="mb hj">Step 1:</strong> Iterate through the array from arr[1] to arr[n].</span><span id="1b0b" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 2:</strong> Compare the current element (key) to the one that came before it.</span><span id="7ddc" class="kk kl hi mb b fi mj mg l mh mi"><strong class="mb hj">Step 3:</strong> Compare the essential element to the elements that came before it if it is smaller , To make room for the switched element, move the larger elements up one position.</span></pre></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><p id="9604" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi mq translated">在“每个新手程序员都应该知道的7个基本算法”系列的这一部分中，我们学习了两个基本的搜索算法和三个非常有用的排序算法，这将帮助你解决主题数组/列表、链表、字符串等问题。在本系列的下一节也是最后一节，我们将学习两个真正有趣的算法，叫做滑动窗口和双指针。我希望你们都和我一样兴奋。</p></div><div class="ab cl kd ke gp kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="hb hc hd he hf"><blockquote class="mz"><p id="47c0" class="na nb hi bd nc nd ne nf ng nh ni jn dx translated">编者按:首先感谢你一直阅读这篇文章，我希望你们都学到了新的东西。</p></blockquote></div></div>    
</body>
</html>