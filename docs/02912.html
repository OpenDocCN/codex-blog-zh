<html>
<head>
<title>How to share data between components in Angular: A shopping cart example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular组件之间共享数据:购物车示例</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-share-data-between-components-in-angular-a-shopping-cart-example-b86ce8254965?source=collection_archive---------1-----------------------#2021-08-11">https://medium.com/codex/how-to-share-data-between-components-in-angular-a-shopping-cart-example-b86ce8254965?source=collection_archive---------1-----------------------#2021-08-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/365f739173480ff60ba561bf25aa4dd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTOKOedx7vTY1hb9b23P_A.jpeg"/></div></div></figure><p id="0411" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你已经用<a class="ae jo" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>开发了现代web应用程序，你不可避免地会遇到这样的情况，你需要在组件之间共享数据(从父到子，子到父，子到祖父，或者兄弟姐妹到兄弟姐妹)。</p><p id="4ab6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Angular提供了许多不同的方式让<a class="ae jo" href="https://angular.io/guide/component-interaction" rel="noopener ugc nofollow" target="_blank">在组件</a>之间共享数据，比如<code class="du jp jq jr js b">@Input()</code>和<code class="du jp jq jr js b">@Output()</code>模式，或者通过使用<code class="du jp jq jr js b">@ViewChild()</code>访问另一个组件的实例。然而，这些方法往往在范围上受到限制，并且可能很快变得难以维护，尤其是当数据需要在嵌套很深或者根本没有直接连接的组件之间共享时。</p><p id="114f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">幸运的是，Angular中的<a class="ae jo" href="https://angular.io/guide/architecture-services" rel="noopener ugc nofollow" target="_blank">服务</a>是一个强大的特性，可以为在组件之间共享数据和业务逻辑创建公共参考点。此外，<a class="ae jo" href="https://coryrylan.com/blog/angular-observable-data-services" rel="noopener ugc nofollow" target="_blank">当与Observables </a>结合时，更具体地说，与<a class="ae jo" href="https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject" rel="noopener ugc nofollow" target="_blank"> BehaviorSubjects </a>结合时，我们可以进一步增强它们，以创建有状态的、反应式的服务，这可以帮助我们在整个应用程序中更有效地同步状态。</p><h1 id="85fa" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">购物车示例</h1><p id="b805" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">为了说明利用可观察对象和行为主体的服务的威力，我们将建立一个基本的购物车应用程序。该购物车将具有一个项目列表，一个小计部分，以及一个显示购物车中项目数量的摘要。该应用程序还允许用户编辑物品的数量，以及删除物品的能力。</p><p id="ca57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总的来说，购物车将是这样的:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/7467b82514980deb1093d129d0af1bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85Zeb0wgXdpsfqGYEMqUWA.png"/></div></div></figure><p id="3d1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该应用程序将分为以下组件/服务:</p><ul class=""><li id="33af" class="lb lc hi is b it iu ix iy jb ld jf le jj lf jn lg lh li lj bi translated"><code class="du jp jq jr js b">AppComponent</code>，它会托住app的脚手架。</li><li id="3df5" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">一个<code class="du jp jq jr js b">SummaryComponent</code>，它将在标题中显示购物车的商品数量摘要。</li><li id="fe4b" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">一个<code class="du jp jq jr js b">ItemsComponent</code>，它将显示购物车中的商品列表。</li><li id="d00e" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">一个<code class="du jp jq jr js b">SubTotalComponent</code>，将显示小计。</li><li id="a55c" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">最后，也是最重要的，一个<code class="du jp jq jr js b">ShoppingCartService</code>，它将保存所有组件共享的状态和业务逻辑。</li></ul><h1 id="18a2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">设置</h1><p id="de87" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated"><em class="lp">在我们开始之前，请注意，您可以在</em><a class="ae jo" href="https://stackblitz.com/edit/angular-ivy-zyhakh" rel="noopener ugc nofollow" target="_blank"><em class="lp">stack blitz</em></a><em class="lp">上运行完成的应用程序，或者在</em><a class="ae jo" href="https://github.com/VidalQuevedo/angular-shopping-cart" rel="noopener ugc nofollow" target="_blank"><em class="lp">Github</em></a><em class="lp">上克隆它的repo。</em></p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="lq lr l"/></div></figure><h2 id="3736" class="ls ju hi bd jv lt lu lv jz lw lx ly kd jb lz ma kh jf mb mc kl jj md me kp mf bi translated">创建应用程序</h2><p id="bfbf" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">首先，安装<a class="ae jo" href="https://angular.io/cli" rel="noopener ugc nofollow" target="_blank"> Angular CLI </a>(如果您还没有安装的话)，打开您的终端并运行:</p><pre class="kx ky kz la fd mg js mh mi aw mj bi"><span id="4789" class="ls ju hi js b fi mk ml l mm mn">$ npm install -g @angular/cli</span></pre><p id="df8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，使用Angular CLI创建一个新的<code class="du jp jq jr js b">shopping-cart</code>应用程序(选择“N”作为路由，选择“SCSS”作为样式表格式)。接下来，<code class="du jp jq jr js b">cd</code>到新的<code class="du jp jq jr js b">shopping-cart/</code>并启动应用程序。一旦应用程序被加载，进入<a class="ae jo" href="http://localhost:4200/" rel="noopener ugc nofollow" target="_blank"> localhost:4200 </a>打开它。</p><pre class="kx ky kz la fd mg js mh mi aw mj bi"><span id="6284" class="ls ju hi js b fi mk ml l mm mn">$ ng new shopping-cart<br/>$ cd shopping-cart<br/>$ npm start</span></pre><h2 id="c038" class="ls ju hi bd jv lt lu lv jz lw lx ly kd jb lz ma kh jf mb mc kl jj md me kp mf bi translated">添加引导CSS和FontAwesome</h2><p id="40c7" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">为了节省时间，我们将使用Bootstrap的CSS库和FontAwesome web字体来设计我们的项目，所以添加一个直接指向它们的cdn的链接，以便在<code class="du jp jq jr js b">index.html</code>中加载它们:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><h2 id="daac" class="ls ju hi bd jv lt lu lv jz lw lx ly kd jb lz ma kh jf mb mc kl jj md me kp mf bi translated">向AppComponent添加基本HTML搭建</h2><p id="26cd" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated"><code class="du jp jq jr js b">AppComponent</code>视图将保存我们应用程序的基本框架，所以用下面的代码替换<code class="du jp jq jr js b">app.component.html</code>中的默认HTML(我们将从放置组件的占位符开始，并随着我们的进展替换它们):</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="c087" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，在保存您的更改并重新加载后，您的应用程序应该如下所示:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/c3351b71c3c9e31183f3ecee17e900b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IQvCcjePW0zJNIXcCniEeA.png"/></div></div></figure><h2 id="aa39" class="ls ju hi bd jv lt lu lv jz lw lx ly kd jb lz ma kh jf mb mc kl jj md me kp mf bi translated">创建数据接口</h2><p id="8e88" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">我们的应用程序将有一个购物车，其中将包含项目，每个项目将包含一个SKU ( <a class="ae jo" href="https://en.wikipedia.org/wiki/Stock_keeping_unit" rel="noopener ugc nofollow" target="_blank">库存单位</a>)，或产品项目。构建该数据的接口将在我们的<code class="du jp jq jr js b">models.ts</code>文件中声明如下:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><h2 id="ad83" class="ls ju hi bd jv lt lu lv jz lw lx ly kd jb lz ma kh jf mb mc kl jj md me kp mf bi translated">创建购物车数据文件</h2><p id="29d8" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">对于这个应用程序，我们的样本数据将来自<code class="du jp jq jr js b">/assets/data.json</code>，这是一个JSON文件，其中包含一个购物车，里面有两件商品。继续将该文件添加到应用程序的<code class="du jp jq jr js b">assets/</code>目录中，数据如下:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><h1 id="7e4b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">功能</h1><h2 id="3aec" class="ls ju hi bd jv lt lu lv jz lw lx ly kd jb lz ma kh jf mb mc kl jj md me kp mf bi translated">创建购物车服务</h2><p id="d7fa" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated"><code class="du jp jq jr js b">ShoppingCartService</code>将是我们应用程序的大脑，有两个主要用途:</p><ol class=""><li id="821d" class="lb lc hi is b it iu ix iy jb ld jf le jj lf jn mq lh li lj bi translated">它将在它的<code class="du jp jq jr js b">shoppingCart$</code>属性中保存购物车的基本状态。这个属性将是一个<code class="du jp jq jr js b"><a class="ae jo" href="https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject" rel="noopener ugc nofollow" target="_blank">BehaviorSubject</a></code>，它将发出一个<code class="du jp jq jr js b">ShoppingCart</code>数据对象。</li><li id="7e50" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn mq lh li lj bi translated">它将包含计算和处理数据所需的业务逻辑，以及处理编辑购物车中商品的事件。</li></ol><p id="531a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，为什么要使用一个<code class="du jp jq jr js b">BehaviorSubject</code>来保存状态并作为应用程序的唯一来源呢？一个<code class="du jp jq jr js b">BehaviorSubject</code>是一种具有本地属性的<code class="du jp jq jr js b">Observable</code>，这使得它非常适合以一种反应的方式设置应用程序的状态:</p><ul class=""><li id="0e9c" class="lb lc hi is b it iu ix iy jb ld jf le jj lf jn lg lh li lj bi translated">它在实例化时需要一个初始值，这允许我们为状态设置一个默认值。</li><li id="e79d" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">它在subscription上发出它的最新值(默认值或其他值)，这允许我们立即开始处理它发出的数据。</li><li id="e66f" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">它允许我们通过它的<code class="du jp jq jr js b">.getValue()</code>方法或<code class="du jp jq jr js b">.value</code>属性获得它的最新值的“快照”,而不需要订阅。当我们需要将<code class="du jp jq jr js b">BehaviorSubject</code>作为只读的同步变量时，这很有用。</li><li id="b09e" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">最后(也是最重要的)，由于<code class="du jp jq jr js b">BehaviorSubject</code>是<code class="du jp jq jr js b">Observable</code>的一种类型，它允许我们使用RxJS操作符创建新的<em class="lp">投影</em>来导出更有意义的<em class="lp">数据，而无需修改原始状态</em>。由于这些投影也是可观察的，它们可以成为为我们的服务创建反应式API的构建块，然后将更改传播到整个UI，并帮助我们保持所有组件无缝同步。</li></ul><p id="b83c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，什么是投影呢？</p><p id="e83d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简而言之，创建一个投影意味着从原始数据源(或者它的一部分)中创建一个新的、更加专门化的数据<em class="lp">，而不需要修改原始数据源本身</em>。例如:</p><ul class=""><li id="41bb" class="lb lc hi is b it iu ix iy jb ld jf le jj lf jn lg lh li lj bi translated">从购物车数据中，我们可以创建一个投影来计算购物车中的<strong class="is hj">商品列表。</strong></li><li id="c0ed" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">从购物车数据中，我们可以创建一个投影来获得购物车中的商品列表，然后将每件商品的数量相加来计算购物车中的商品总数。</li><li id="ee48" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">从购物车数据中，我们可以创建一个投影来提取商品列表，将每个商品的数量乘以其价格，然后将它们相加，得到购物车的<strong class="is hj">小计。</strong></li></ul><p id="cef5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，关于这些投影的重要一点是<strong class="is hj">它们会在每次原始数据源更新时自动运行</strong>。</p><p id="bb5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，这转化为使用RxJS操作符从源发出的原始数据创建投影，a <code class="du jp jq jr js b">BehaviorSubject</code>，然后订阅结果<code class="du jp jq jr js b">Observables</code>以在每次源发出新值时实时更新视图。</p><p id="96c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住这些基本概念，让我们继续创建我们的反应式的、基于投影的服务(我保证，随着我们的进展，你会开始看到这些模式；)):</p><pre class="kx ky kz la fd mg js mh mi aw mj bi"><span id="150a" class="ls ju hi js b fi mk ml l mm mn">$ ng generate service services/shopping-cart</span></pre><p id="0da1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，新的<code class="du jp jq jr js b">shopping-cart.service.ts</code>将增加两件重要的东西:</p><ul class=""><li id="9883" class="lb lc hi is b it iu ix iy jb ld jf le jj lf jn lg lh li lj bi translated">我们将把<code class="du jp jq jr js b">shoppingCart$</code>私有属性声明为一个<code class="du jp jq jr js b">BehaviorSubject&lt;ShoppingCart&gt;</code>对象，然后在构造函数中用一个代表空购物车的默认值初始化它。</li><li id="596e" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">我们将添加一个<code class="du jp jq jr js b">getShoppingCart()</code>私有方法，该方法将放置一个HTTP请求来获取构造函数中的数据。成功后，我们将调用<code class="du jp jq jr js b">setShoppingCart()</code>私有方法，其中<code class="du jp jq jr js b">shoppingCart$</code>属性将发出新的购物车数据。如果失败，我们将简单地在浏览器的控制台中显示一个错误。</li></ul><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="0d1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，由于服务使用<code class="du jp jq jr js b">HttpClient</code>来发出HTTP请求，我们需要将<code class="du jp jq jr js b">HttpClientModule</code>添加到<code class="du jp jq jr js b">app.module.ts</code>中的导入列表中，以使它在我们的应用程序中可用:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><h2 id="a544" class="ls ju hi bd jv lt lu lv jz lw lx ly kd jb lz ma kh jf mb mc kl jj md me kp mf bi translated">创建购物车商品组件</h2><p id="b987" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated"><code class="du jp jq jr js b">ItemsComponent</code>将显示购物车中的商品列表(专业提示:<code class="du jp jq jr js b">--export</code>标志将自动将新组件添加到最近模块的<code class="du jp jq jr js b">exports</code>列表中，在本例中是<code class="du jp jq jr js b">AppModule</code>，节省了我们手动添加组件的工作)。</p><pre class="kx ky kz la fd mg js mh mi aw mj bi"><span id="7789" class="ls ju hi js b fi mk ml l mm mn">$ ng generate component items --export</span></pre><p id="a529" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在新的<code class="du jp jq jr js b">items.component.ts</code>文件中，我们将把<code class="du jp jq jr js b">items$</code>属性设置为一个可观察对象，它将发出一个项目列表，<code class="du jp jq jr js b">Observable&lt;Items[]&gt;</code>:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="af4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du jp jq jr js b">items.component.html</code>中，我们将使用<code class="du jp jq jr js b"><a class="ae jo" href="https://angular.io/api/common/AsyncPipe" rel="noopener ugc nofollow" target="_blank">async</a></code>管道来订阅<code class="du jp jq jr js b">items$</code>以显示项目列表。每个商品都有图片、标题、价格(使用<code class="du jp jq jr js b"><a class="ae jo" href="https://angular.io/api/common/CurrencyPipe" rel="noopener ugc nofollow" target="_blank">currency</a></code>管道进行格式化)和数量，以及一个“删除”按钮，用于将其从购物车中删除。如果购物车是空的，组件将显示一个"<em class="lp">你的购物车是空的。</em>谓消息相反。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="15f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们将占位符“(购物车商品)”替换为<code class="du jp jq jr js b">&lt;app-items&gt;&lt;/app-items&gt;.</code>，将商品组件添加到<code class="du jp jq jr js b">app.component.html</code></p><h2 id="ca3b" class="ls ju hi bd jv lt lu lv jz lw lx ly kd jb lz ma kh jf mb mc kl jj md me kp mf bi translated">用购物车中的数据填充购物车商品列表</h2><p id="3fe6" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">在这里，我们将开始使用<code class="du jp jq jr js b">ShoppingCartService</code>来管理我们的应用程序的状态。</p><p id="9fa1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要<code class="du jp jq jr js b">ShoppingCartService</code>来允许我们访问购物车中的当前商品列表。为此，我们将把<code class="du jp jq jr js b">getItems()</code>方法添加到<code class="du jp jq jr js b">shopping-cart.service.ts</code>中。该方法将是从<code class="du jp jq jr js b">shoppingCart$</code> <code class="du jp jq jr js b">BehaviorSubject</code>派生的<em class="lp">投影</em>，并且将在每次<code class="du jp jq jr js b">shoppingCart$</code>更新时返回一个发出项目列表<code class="du jp jq jr js b">Observable&lt;Item[]&gt;</code>的可观察对象:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="815d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b"><a class="ae jo" href="https://www.learnrxjs.io/learn-rxjs/operators/transformation/pluck" rel="noopener ugc nofollow" target="_blank">pluck</a></code>操作符是一个RxJS操作符，它简单地允许你返回一个特定的属性，由可观察对象发出。当您知道需要从传入的数据中获得什么属性，并且不需要在每次发射时传递整个数据对象时，这当然很方便。</p><p id="304c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，让我们使用来自<code class="du jp jq jr js b">ShoppingCartService</code>的<code class="du jp jq jr js b">getItems()</code>方法将<code class="du jp jq jr js b">items.component.ts</code>中的项目列表加载到<code class="du jp jq jr js b">ngOnInit()</code>上，确保首先将<code class="du jp jq jr js b">shoppingCartService</code>作为依赖项注入到组件中以访问其功能:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="44b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">保存并重新加载后，我们的应用程序现在应该显示如下所示的项目列表:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/84ce3e028d2e4e5a6d354e22e3b93f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o3lpQj7pQKskrHYUNIRsDQ.png"/></div></div></figure><h2 id="fed2" class="ls ju hi bd jv lt lu lv jz lw lx ly kd jb lz ma kh jf mb mc kl jj md me kp mf bi translated">创建购物车小计组件</h2><p id="e918" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated"><code class="du jp jq jr js b">SubtotalComponent</code>将显示购物车中商品的小计、商品数量和“继续结账”按钮。当然，在产品实现中，我们最有可能为这个按钮提供一个专用组件来保存任何复杂的显示/业务逻辑，但是为了简洁起见，我们只在这里显示它。</p><pre class="kx ky kz la fd mg js mh mi aw mj bi"><span id="2d08" class="ls ju hi js b fi mk ml l mm mn">$ ng generate component subtotal --export</span></pre><p id="ce28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">两个属性，<code class="du jp jq jr js b">subTotal$</code>和<code class="du jp jq jr js b">count$</code>，将保存可观察到的数字，<code class="du jp jq jr js b">Observable&lt;number&gt;</code>:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="db17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du jp jq jr js b">subtotal.component.html</code>中，<code class="du jp jq jr js b">count$</code>属性不仅用于显示商品数量，还用于为“继续结账”按钮添加基本的“禁用”逻辑(即当<code class="du jp jq jr js b">$count</code>等于<code class="du jp jq jr js b">0</code>时，购物车为空，因此用户不能继续结账)。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="861e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du jp jq jr js b">ShoppingCartService</code>中，添加两个方法<code class="du jp jq jr js b">getSubstotal()</code>和<code class="du jp jq jr js b">getCount()</code>进行检索。</p><p id="2d8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与<code class="du jp jq jr js b">getItems()</code>方法类似，<code class="du jp jq jr js b">getSubtotal()</code>方法将是从<code class="du jp jq jr js b">shoppingCart$</code> <code class="du jp jq jr js b">BehaviorSubject</code>派生的一个投影，这意味着它将是一个每次<code class="du jp jq jr js b">shoppingCart$</code>更新时发出一个数字<code class="du jp jq jr js b">Observable&lt;number&gt;</code>的可观察对象。</p><p id="7f84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了计算小计，我们将每个购物车商品的数量乘以其SKU价格，然后将结果相加，如下所示:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="5683" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，<code class="du jp jq jr js b">getCount()</code>方法也将是从<code class="du jp jq jr js b">shoppingCart$</code> <code class="du jp jq jr js b">BehaviorSubject</code>派生的一个投影(您在这里开始看到一个模式，对吗？)将返回并发出购物车中所有商品的计数的Observable，<code class="du jp jq jr js b">Observable&lt;number&gt;</code>。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="0d50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们可以将这些新方法与<code class="du jp jq jr js b">SubTotalComponent</code>挂钩，开始向视图发出这些值。首先，我们需要在构造函数中注入<code class="du jp jq jr js b">ShoppingCartService</code>作为依赖项，然后在<code class="du jp jq jr js b">subtotal.component.ts</code>中分配对<code class="du jp jq jr js b">ngOnInit()</code>上这些方法的调用:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="cab2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们将用<code class="du jp jq jr js b">&lt;app-subtotal&gt;&lt;/app-subtotal&gt;</code>标签替换“(购物车小计)”占位符来显示小计。</p><p id="98a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">保存并重新加载后，我们购物车的小计区域现在应该有两(2)件商品，小计金额为119.98美元:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/30bc67152056c9869074cbd272c75c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJ-UCNU9ybk1IIcxpFPzEQ.png"/></div></div></figure><h2 id="81f2" class="ls ju hi bd jv lt lu lv jz lw lx ly kd jb lz ma kh jf mb mc kl jj md me kp mf bi translated">创建购物车汇总组件</h2><p id="3297" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated"><code class="du jp jq jr js b">SummaryComponent</code>将被放置在标题中，并将显示一个购物车图标和购物车中的商品数量。</p><pre class="kx ky kz la fd mg js mh mi aw mj bi"><span id="9549" class="ls ju hi js b fi mk ml l mm mn">$ ng generate component summary --export</span></pre><p id="0143" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">SummaryComponent</code>将有一个<code class="du jp jq jr js b">count$</code>属性。为了填充它，我们将在<code class="du jp jq jr js b">ngOnInit()</code>中初始化它，引用我们已经在<code class="du jp jq jr js b">ShoppingCartService</code>中创建的<code class="du jp jq jr js b">getCount()</code>方法。通过这样做，我们将重用我们在<code class="du jp jq jr js b">SubtotalComponent</code>中使用的相同业务逻辑和状态，有效地利用服务在组件之间共享数据和功能:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="a95a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在视图中，我们将显示计数和购物车图标:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="ce4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们将用<code class="du jp jq jr js b">&lt;app-summary&gt;&lt;/app-summary&gt;</code>替换“(购物车摘要)”占位符来创建组件。</p><p id="3214" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在保存和重新加载之后，我们的应用程序现在应该在标题上显示一个购物车图标，以及数字2，因为我们在加载的购物车中有两个商品:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/cd3e51120586d117aebff3c0e4f968d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0w9czVwFsYKgThj_glkQA.png"/></div></div></figure><p id="76e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在已经创建了所有需要的组件，并使用<code class="du jp jq jr js b">ShoppingCartService</code>为它们供电！！！接下来，我们将创建几个方法来编辑状态，并让视图对所有组件的这种变化立即做出反应，而不必手动更新它们的状态。</p><h2 id="e735" class="ls ju hi bd jv lt lu lv jz lw lx ly kd jb lz ma kh jf mb mc kl jj md me kp mf bi translated">更新项目的数量</h2><p id="57a9" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">每个项目都有一个反映其数量的<code class="du jp jq jr js b">&lt;select&gt;</code>输入字段，取值范围从1到3(请注意，这个限制是为了说明)。我们的下一步是处理数量的任何变化，并相应地更新购物车。</p><p id="7b0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du jp jq jr js b">ShoppingCartService</code>中，让我们为此创建一个<code class="du jp jq jr js b">updateQuantity()</code>方法。这个方法将简单地通过id找到传递的项目，然后相应地更新它的数量。</p><p id="024d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有两个重要的步骤:首先，我们将通过访问<code class="du jp jq jr js b">shoppingCart$</code> BehaviorSubject的<code class="du jp jq jr js b">value</code>属性来创建当前状态的副本。然后，在找到物品并计算其数量后，我们将让<code class="du jp jq jr js b">shoppingCart$</code>通过它的<code class="du jp jq jr js b">next()</code>方法发出这个新值。通过这样做，我们从<code class="du jp jq jr js b">shoppingCart$</code>创建的所有<code class="du jp jq jr js b">Observables</code>，比如在<code class="du jp jq jr js b">getItems()</code>、<code class="du jp jq jr js b">getTotals()</code>和<code class="du jp jq jr js b">getCount()</code>方法中的那些，也将发出那些值给它们所有的订阅者，有效地用新状态更新所有组件的视图。</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="c0a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，在生产应用程序中，任何编辑购物车商品的事件都很可能由后端处理，然后后端将提供购物车数据的更新副本，我们可以用它来刷新前端。然而，在我们的例子中，出于说明的目的，我们只在前端编辑状态，因为支持后端架构的设置超出了本文的范围。</p><p id="3925" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们通过<code class="du jp jq jr js b">ItemsComponent</code>中一个类似名称的方法调用<code class="du jp jq jr js b">updateQuantity()</code>，该方法将使用<code class="du jp jq jr js b">$event</code>对象提取视图中<code class="du jp jq jr js b">select</code>数量输入元素的每个<code class="du jp jq jr js b">change</code>事件上的选定值:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="2b7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，让我们调用<code class="du jp jq jr js b">change</code>上的方法:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="65b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">保存并重新加载后，继续更改任何项目的数量。虽然变更是在<code class="du jp jq jr js b">ItemsComponent</code>中生成的，但是数量和小计在<code class="du jp jq jr js b">SubTotalsComponent</code>和<code class="du jp jq jr js b">SummaryComponent</code>中无缝更新，这是多个组件通过公共服务进行通信的一个很好的例子。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/99740c8d0fd3ecc723349955e33562ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nrQIZoqPGf6po24gjgmwjA.gif"/></div></div></figure><h2 id="aa6e" class="ls ju hi bd jv lt lu lv jz lw lx ly kd jb lz ma kh jf mb mc kl jj md me kp mf bi translated">删除项目</h2><p id="f0d2" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">作为我们的应用程序的最后一个功能，我们将为用户添加一个选项，通过按下项目上的“删除”链接来删除项目。</p><p id="1974" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，我们将在<code class="du jp jq jr js b">ShoppingCartService</code>中添加一个新的<code class="du jp jq jr js b">deleteItem()</code>方法。它将获取要删除的项目的id:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="effa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，在<code class="du jp jq jr js b">updateQuantity()</code>方法中，我们首先从<code class="du jp jq jr js b">shoppingCart$</code>属性创建状态的副本，对副本执行删除操作，并将副本传递给<code class="du jp jq jr js b">shoppingCart$</code>作为其新值发出，再次更新基于该行为主体的所有观察对象及其跨所有组件的订阅。</p><p id="a961" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将在<code class="du jp jq jr js b">ItemsComponent</code>中创建一个类似命名的方法来调用<code class="du jp jq jr js b">ShoppingCartService</code>的<code class="du jp jq jr js b">deleteItem()</code>方法:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="c227" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，让我们在用户点击任何项目上的“删除”按钮时调用上面的方法:</p><figure class="kx ky kz la fd ij"><div class="bz dy l di"><div class="mo lr l"/></div></figure><p id="d605" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">保存并重新加载后，现在继续删除一个项目。该项应该会从视图中消失，计数和小计也会相应地更新。删除所有商品也应该显示一个"<em class="lp">你的购物车是空的。</em>"消息。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/da9d9f18a0fa475e09f81e936945be57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Ke9XQu3wJP0AHn2RC8D3gA.gif"/></div></div></figure><h2 id="dd7d" class="ls ju hi bd jv lt lu lv jz lw lx ly kd jb lz ma kh jf mb mc kl jj md me kp mf bi translated">结论</h2><p id="6626" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">通过这个基本的购物车应用程序，我们探索了使用服务和可观察对象(更具体地说，是行为主体)在组件之间共享应用程序的数据和业务逻辑的能力。鉴于这种方法的可复制性，它可以很快用于标准化您的Angular应用程序的状态管理方法，使其在未来更容易扩展和维护。</p><p id="4a41" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，一些要点:</p><ul class=""><li id="6775" class="lb lc hi is b it iu ix iy jb ld jf le jj lf jn lg lh li lj bi translated">Angular中的服务是一个强大的特性，可以为在组件之间共享数据和业务逻辑创建公共的参考点，并作为驱动应用程序的单一事实来源。</li><li id="3ed4" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">BehaviorSubjects可以用作创建反应式服务的起点，因为它们的固有能力允许我们在订阅或不订阅的情况下获取其最新发出的数据(通过其<code class="du jp jq jr js b">.value</code>属性或<code class="du jp jq jr js b">.getValue()</code>方法)。</li><li id="fb68" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">通过使用RxJS操作符，我们可以从保持原始状态的<code class="du jp jq jr js b">BehaviorSubject</code>创建<em class="lp">投影</em>，从而在不修改原始状态的情况下获得更有意义的数据。</li><li id="892f" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">这些投影可以用来为我们的服务创建一个反应式API，然后组件可以使用它在整个应用程序中共享数据和业务逻辑。</li></ul><p id="769a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢，请随时分享您的意见或问题！</p></div></div>    
</body>
</html>