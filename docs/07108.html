<html>
<head>
<title>Using the Kotlin Serialization Library for Tough JSON Serialization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin序列化库进行严格的JSON序列化</h1>
<blockquote>原文：<a href="https://medium.com/codex/using-the-kotlin-serialization-library-for-tough-json-serialization-82f8b7ae70dc?source=collection_archive---------0-----------------------#2022-05-31">https://medium.com/codex/using-the-kotlin-serialization-library-for-tough-json-serialization-82f8b7ae70dc?source=collection_archive---------0-----------------------#2022-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c8db" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">由<a class="ae ix" href="https://www.linkedin.com/in/yarden-gavish-6b2559227" rel="noopener ugc nofollow" target="_blank">亚登·加维什</a></h2></div><p id="8fc6" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">序列化——我们不能假装这是一个让许多人心跳加速的话题。</p><p id="9898" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">然而，如果你正在开发一个传递文件(比如通过服务器)或者保存信息到数据库的应用程序，序列化是不可避免的。</p><p id="ed02" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在这里，我们开发了照片和视频编辑应用程序。在我们这个时代，我们已经有了Kotlin序列化所能提供的最好(和最差)的第一手经验。</p><p id="7cd8" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我们使用<a class="ae ix" href="https://github.com/Kotlin/kotlinx.serialization" rel="noopener ugc nofollow" target="_blank"> Kotlin序列化</a>库，因为它与Kotlin兼容，具有比Gson或Moshi更快的运行时，并且可以在支持多平台的其他平台上运行。通常，默认的序列化程序会为我们做所有的工作。但是，当JSON文件与我们想要在Kotlin中表示它们的方式不同时，会有一些边缘情况迫使我们增加默认序列化的复杂性。</p><p id="5bef" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">作为我们最新功能的一部分，我们需要创建跨平台的视频项目。这需要创建代表这些项目的平台无关的JSON文件。每个平台然后接收JSON文件，没有(或有限的)能力改变它们——使得转换到内存视频项目变得棘手。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/300611f7f676adbf2555d3c0df4bab7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIHvMDzl0DhQeT1cw_aReg.jpeg"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">JSON文件跨iOS和Android两个平台使用。</figcaption></figure><p id="bda4" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在这篇文章中，我们将解释在处理不能直接映射到Kotlin对象的JSON文件时，如何处理棘手的序列化。具体来说，我们将探索在反序列化过程中使用<code class="du kk kl km kn b">JsonTransformingSerializer</code>处理多态性和改变数据类型。</p><p id="3b2a" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj">多态性是怎么回事？</strong></p><p id="ca96" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">让我们看一个视频项目对象的例子。这是一个简单的视频项目，由一系列层组成，特别是文本、音频和视频。JSON文件如下所示:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="67b9" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">从JSON的格式中，我们可以看到多态性是必需的。必须有一些通用的抽象层类型可以保存在一个列表中。每一层可以是音频、视频或文本。因此，我们可以尝试将<code class="du kk kl km kn b">VideoProject</code>定义如下:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="9218" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">它由一系列层组成，其中<code class="du kk kl km kn b">Layer</code>是一个抽象类。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="b752" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">每个特定的层都继承自这个抽象类。它们有一些相同的字段(如<code class="du kk kl km kn b">startTime</code>和<code class="du kk kl km kn b">duration</code>)，但它们也有一些特定于图层的字段。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="dbe3" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这已经很好了，但是还不可序列化。</p><p id="801b" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">为了使其可序列化，我们首先需要了解一点Kotlin序列化程序如何处理多态性。Kotlin序列化程序通过关键字<code class="du kk kl km kn b">type</code>来区分不同的类型。这向序列化程序指示要序列化哪个子类。在上面的例子中，如果<code class="du kk kl km kn b">type</code>是<code class="du kk kl km kn b">AudioLayer</code>，那么串行化器知道寻找<code class="du kk kl km kn b">volume</code>字段。</p><p id="83cf" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">查看上面的JSON，我们看到<code class="du kk kl km kn b">type</code>字段存在，这意味着Kotlin序列化程序将使用这个字段来区分不同的子类。具体来说，序列化程序希望<code class="du kk kl km kn b">type</code>字段与特定的类完全匹配。</p><p id="ab5e" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在这种情况下，我们希望给Kotlin中的子类起一个合适的(camel-case)和有意义的名字，比如<code class="du kk kl km kn b">AudioLayer</code>(而不是JSON中的<code class="du kk kl km kn b">audio</code>)。为此，我们可以添加<code class="du kk kl km kn b">@SerialName</code>注释，使层子类型与JSON中的<code class="du kk kl km kn b">type</code>相匹配。对于音频层，如下所示:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="f174" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这个注释可以在类级别或字段级别使用，当我们希望序列化的名称不同于Kotlin名称时，或者为了防止任何意外的重构，这个注释非常有用。例如，如果将来某一天这个类被重构为<code class="du kk kl km kn b">MusicLayer</code>，那么<code class="du kk kl km kn b">@SerialName</code>注释会保持反序列化工作。如果没有它，任何对类或字段的名称重构都会导致JSON和Kotlin对象之间的差异，从而导致反序列化失败。</p><p id="9dab" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">现在回到我们的多态序列化。</p><p id="9e88" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果预先知道所有的层，那么让<code class="du kk kl km kn b">Layer</code>成为一个可序列化的密封类就足够了。像这样:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="f30e" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">但是，如果类不能被密封，我们需要手动注册子类。这意味着创建一个包含所有子类的对象，比如<code class="du kk kl km kn b">ProjectSerializer</code>。像这样:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="19b7" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">然后，当编码或解码时，我们需要使用<code class="du kk kl km kn b">ProjectSerializer</code>中的<code class="du kk kl km kn b">projectJson</code>，如下所示:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="da63" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这样做是因为我们可以使用编码字段<code class="du kk kl km kn b">type</code>来区分不同的子类。然而，我们不能假设情况总是如此，尤其是如果JSON不是由Kotlin序列化程序创建的。</p><p id="8f7a" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果在上面的例子中没有<code class="du kk kl km kn b">type</code>字段，而是描述每个层的字段被命名为<code class="du kk kl km kn b">layer_type</code>，会发生什么？如果我们使用与上面相同的序列化程序，我们会得到以下错误:</p><p id="1795" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><code class="du kk kl km kn b">Polymorphic serializer was not found for missing class discriminator (‘null’)</code></p><p id="c469" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">换句话说，Kotlin序列化程序在说:“我不知道使用哪个序列化程序，因为我没有办法区分这些类。”</p><p id="eb05" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这里的解决方案是直接告诉序列化程序使用哪个字段来区分不同的类。这可以通过使用注释<code class="du kk kl km kn b">@JsonClassDiscriminator</code>来实现。在我们的例子中，它看起来像这样:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="b689" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">序列化又开始工作了。</p><p id="e835" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">值得注意的是，这是我们特别面临的问题，因为序列化是平台不可知的。如果序列化最初是由Kotlin完成的，Kotlin序列化程序会用子类名称对默认的<code class="du kk kl km kn b">type</code>字段进行编码，然后用它来区分多态中的不同子类型。</p><p id="7821" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj">转型是关键</strong></p><p id="054a" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">让我们看看另一种情况，在这种情况下，JSON中编写的复杂类型需要在对象中以不同的方式表示。为此，我们希望在完成反序列化之前以某种方式转换JsonElements。我们可以将JsonElements视为JSON文件的抽象构建块。这种转变就像是把这些积木按照我们希望的方式重新组合。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/ca98d80207197adbedc484a364575031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4uQUUIpnX803x5LUrI0Vng.jpeg"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">Kotlin序列化程序将JSON文件反序列化为JSON元素。这是我们应用转换的地方。</figcaption></figure><p id="b807" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">让我们看一个例子来深入研究一下。再次以我们的<code class="du kk kl km kn b">VideoProject</code>为例，让我们给代表层中心的<code class="du kk kl km kn b">TextLayer</code>添加一个字段。带有这个新字段的JSON将如下所示:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="a09d" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我们可以看到中心被定义为一个JSON数组。从文档中，我们被告知第一个值是x坐标，第二个是y坐标。</p><p id="d595" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在Kotlin中，我们希望将中心字段表示为一个名为<code class="du kk kl km kn b">Point</code>的数据类，因为从代码的角度来看，这是更正确的抽象。这看起来像是:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="81d8" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">然而，上面定义的<code class="du kk kl km kn b">Point</code>类将被序列化如下:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="b6e6" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">而不是它在JSON中是如何定义的(作为数组)。</p><p id="f5d0" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如何在这两个JSON元素之间进行转换？解决方案是使用一个名为<code class="du kk kl km kn b">JsonTransformingSerializer</code>的类。这个类允许您在序列化或反序列化之前，在不同的<code class="du kk kl km kn b">JsonElements</code>之间进行任何必要的转换。例如，它允许您将一个<code class="du kk kl km kn b">JsonArray</code>转换为<code class="du kk kl km kn b">JsonObject</code>，反之亦然——这就是我们在这里的<code class="du kk kl km kn b">Point</code>对象转换所需要的。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="7409" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">具体来说，我们可以覆盖函数<code class="du kk kl km kn b">transformDeserialize(element: JsonElement)</code>和<code class="du kk kl km kn b">transformSerialize(element: JsonElement),</code>，它们正是我们所需要的。在这些函数中，我们需要添加转换的逻辑。在我们的例子中，这意味着获取数组的元素并将它们映射到<code class="du kk kl km kn b">Point</code>中的正确属性以创建一个<code class="du kk kl km kn b">JsonObject</code>。</p><p id="6eac" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在反序列化中，这将类似于:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="8778" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在序列化中，我们需要做相反的转换，将<code class="du kk kl km kn b">JsonObject</code>中的值(同时省略键，它们是<code class="du kk kl km kn b">x</code>和<code class="du kk kl km kn b">y</code>)转换回<code class="du kk kl km kn b">JsonArray</code>。这看起来像这样:</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="f02a" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">最后，我们需要在<code class="du kk kl km kn b">TextLayer</code>的中间区域使用这个串行化器。</p><figure class="jv jw jx jy fd jz"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="8917" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">太好了！我们又一次实现了序列化！</p><p id="45d4" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这个接口在许多其他场景中也很有用，比如省略或操作某些值，或者数组包装/展开。</p><p id="cc63" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj">结论</strong></p><p id="cc3a" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我真诚地希望您能够始终使用默认的序列化程序来满足您所有的序列化需求。但是我知道有时候，就像跨平台JSON文件一样，默认的序列化不够好。在这些棘手的情况下，我希望这些JSON序列化示例对您有所帮助。</p><p id="cdaf" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">要了解更多信息，我还建议查看完整的Kotlin序列化指南(<a class="ae ix" href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/serialization-guide.md" rel="noopener ugc nofollow" target="_blank">这里是</a>),其中有很多例子和解释。</p><p id="75fb" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">连载快乐！</p><p id="39fb" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi">—</p><p id="403b" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj"> <em class="kq">与我们一起创造魔法</em> </strong></p><p id="ae45" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">我们总是在寻找有前途的新人才。如果你对为创作者开发突破性的新工具感到兴奋，我们希望听到你的意见。从编写代码到研究新功能，你将被一个支持你的团队所包围，他们生活在技术之中。</p><p id="e772" class="pw-post-body-paragraph iy iz hi ja b jb jc ij jd je jf im jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">听起来像你？ <a class="ae ix" href="https://grnh.se/6654aee02us" rel="noopener ugc nofollow" target="_blank"> <em class="kq">此处适用</em> </a> <em class="kq">。</em></p></div></div>    
</body>
</html>