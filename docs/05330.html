<html>
<head>
<title>HTTP and its evolution: Diving deep into network and communication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP及其演变:深入网络和通信</h1>
<blockquote>原文：<a href="https://medium.com/codex/diving-deep-into-communication-layer-7-protocols-3e05d969eff7?source=collection_archive---------6-----------------------#2022-02-18">https://medium.com/codex/diving-deep-into-communication-layer-7-protocols-3e05d969eff7?source=collection_archive---------6-----------------------#2022-02-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5b59" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是致力于探索两台机器如何通过互联网相互通信的系列文章的第一篇。作为一名软件工程出身的人，我一直觉得对我们日常编写的业务代码之外发生的事情缺乏了解。这是我试图理解通信的底层细节，以及每条消息是如何通过不同的路线到达目的地的。</p><h1 id="0763" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">简介</strong></h1><p id="98e1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">开放系统互连(OSI)模型定义了计算机系统用来通过网络进行通信的七个层。OSI模型的最顶层是应用层。</p><p id="f6af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用层由最终用户软件使用，如web浏览器和电子邮件客户端。它提供协议，允许软件发送和接收<a class="ae kg" href="https://www.imperva.com/learn/data-security/information-security-infosec/" rel="noopener ugc nofollow" target="_blank">信息，并向用户呈现有意义的数据</a>。应用层协议的几个例子是<a class="ae kg" href="https://www.imperva.com/learn/performance/http2/" rel="noopener ugc nofollow" target="_blank">超文本传输协议</a> (HTTP)、文件传输协议(FTP)、邮局协议(POP)、简单邮件传输协议(SMTP)等。</p><p id="d040" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个过于简单的解释是，任何第7层协议都只是一组规则，这些规则定义了从客户端发送到服务器的数据在转换为字节流之前的整体结构。在客户端，各种类型的元数据在被转换成TCP/UDP流之前被添加到有效载荷中，并且在服务器端，这些流根据定义的规则被解析以获得所需的有效载荷。我会在后续文章中讨论TCP/UDP以及第7层和第4层之间的交互。</p><p id="6acb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将讨论在第7层的web应用程序中广泛使用的协议，即HTTP和web套接字。</p><h1 id="fda6" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">超文本传送协议</h1><p id="df0e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">超文本传输协议(HTTP)是万维网的基础，用于通过超文本链接加载网页。该协议被设计为在TCP上运行。<br/>当您向web服务器发出请求时，您和服务器之间会建立TCP连接(客户端IP +客户端端口—服务器IP +服务器端口)。<br/>所有这些连接的创建和持久化通常由一个HTTP客户端从我们这里抽象出来，例如Axios。浏览器也是HTTP客户端，因为它向HTTP服务器(Web服务器)发送请求，然后服务器向客户端发回响应。然而，这些HTTP客户端和服务器在发出请求或响应请求时遵循HTTP定义的所有规则。<a class="ae kg" href="https://github.com/ZeroGazer/http-client-socket-java/blob/master/src/main/java/hk/ust/comp4621/project/HTTPClient.java" rel="noopener ugc nofollow" target="_blank">这个</a>是JAVA中HTTP客户端的一个非常简单的例子。</p><p id="f7a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> HTTP/0.9 —单行协议</strong></p><p id="a262" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HTTP的初始版本没有版本号；后来被称为0.9，以区别于后来的版本。HTTP/0.9非常简单:请求由一行组成，以唯一可能的方法<code class="du kh ki kj kk b"><a class="ae kg" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET" rel="noopener ugc nofollow" target="_blank">GET</a></code>开始，后跟资源的路径。将为每个HTTP请求打开一个TCP连接，然后在收到响应时关闭。<br/>由于每个TCP连接上只有一个请求，客户端和服务器很容易理解请求或响应何时结束。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="9568" class="kt je hi kk b fi ku kv l kw kx">GET /mypage.html</span><span id="16e3" class="kt je hi kk b fi ky kv l kw kx">&lt;html&gt;<br/>A very simple HTML page<br/>&lt;/html&gt;</span></pre><p id="3c16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解析请求和响应</strong></p><p id="95ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于请求，一旦TCP流结束，服务器就知道请求字符串是完整的，它现在可以解析它以理解请求是什么..<br/>响应也非常简单:它只包含文件本身。当HTTP客户端获得结束HTML标记时，它将知道响应已送达，并将关闭TCP连接。</p><p id="2aa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">问题</strong></p><p id="5eec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不像后来的发展，没有HTTP头。正因为如此，HTTP/0.9出现了许多问题。其中一些是:</p><ul class=""><li id="b25d" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">无法发送除HTML文件之外的任何内容。</li><li id="689e" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">错误响应和成功响应之间没有区别。</li></ul><p id="1ffb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> HTTP/1.0 </strong></p><p id="9a68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HTTP/1.0被称为网络浏览器友好协议。随着万维网的普及，HTTP/0.9的各种问题开始浮出水面。为了消除它的一些问题，1.0中引入了标题和状态码(200，404)的概念。我们还开始在请求和响应中添加HTTP/1.0，以区分请求和0.9请求。现在有了头的概念，服务器可以在响应中提到什么是内容类型，这样客户端就可以相应地解析它。作为响应的一部分，状态代码确保了客户端知道收到的是哪种响应。</p><p id="2b3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，典型的请求和响应如下所示:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="38f9" class="kt je hi kk b fi ku kv l kw kx">GET /mypage.html HTTP/1.0<br/>User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)</span><span id="f840" class="kt je hi kk b fi ky kv l kw kx">HTTP/1.0 200 OK<br/>Date: Tue, 15 Nov 1994 08:12:31 GMT<br/>Server: CERN/3.0 libwww/2.17<br/>Content-Type: text/html<br/>&lt;HTML&gt;<br/>A page with an image<br/>  &lt;IMG SRC="/myimage.gif"&gt;<br/>&lt;/HTML&gt;</span></pre><p id="2bad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解析请求和响应</strong></p><p id="566c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然请求和响应都有头和负载，HTTP就定义了如何解析流以从中获取有意义的数据。基本规则是头中的content-length告诉您读取有效负载所需的字节数。为了识别标头结束和负载开始的时间，只需获取第一次出现的“\r\n\r\n”。在这之后，消息的主体将开始。标头中的每个键值对由“\r\n”分隔。上面标记的例子<a class="ae kg" href="https://github.com/ZeroGazer/http-client-socket-java/blob/master/src/main/java/hk/ust/comp4621/project/HTTPClient.java" rel="noopener ugc nofollow" target="_blank"/>基于同样的原理工作。</p><p id="a9d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">问题</strong></p><p id="2ec6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HTTP/1.0仍然存在的一个问题是为每个HTTP请求打开一个TCP连接。当服务器准备响应时，TCP流保持未使用状态。此外，每次建立新连接时，还应该进行TCP三次握手。为了获得更好的性能，减少往返次数并优化客户端和服务器之间的TCP隧道的使用是至关重要的。HTTP/1.1用持久连接和管道解决了这个问题。</p><h2 id="0920" class="kt je hi bd jf ln lo lp jj lq lr ls jn iq lt lu jr iu lv lw jv iy lx ly jz lz bi translated"><strong class="ak"> HTTP/1.1 —标准化协议</strong></h2><p id="8efa" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这是目前大多数用例使用的版本。HTTP/1.0和1.1有各种不同，比如支持<code class="du kh ki kj kk b">GET</code>、<code class="du kh ki kj kk b">HEAD</code>、<code class="du kh ki kj kk b">POST</code>、<code class="du kh ki kj kk b">PUT</code>、<code class="du kh ki kj kk b">DELETE</code>、<code class="du kh ki kj kk b">TRACE</code>、<code class="du kh ki kj kk b">OPTIONS</code>，而1.0只支持<code class="du kh ki kj kk b">GET</code>、<code class="du kh ki kj kk b">HEAD</code>、<code class="du kh ki kj kk b">POST</code>。HTTP/1.1还支持<code class="du kh ki kj kk b">Upgrade</code>头，通过它可以使用常用的协议(如HTTP/1.1)启动连接，然后请求连接切换到增强的协议类型(如HTTP/2.0或WebSockets)。<br/>但最显著的区别是HTTP/1.1如何引入各种性能优化，如下所述:</p><ul class=""><li id="6045" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated"><strong class="ih hj">持久连接</strong> <br/>从下图中可以清楚地看到，我们不需要为每个HTTP请求创建一个新的TCP连接，这样可以节省多次往返，例如加载一个附加了多个图像的网站，或者使用客户端的相同端口重复调用网络服务器。此外，主机可以添加<code class="du kh ki kj kk b">timeout</code>和<code class="du kh ki kj kk b">max</code>参数，以便设置超时或限制每个连接的最大请求数，从而不会耗尽主机的资源。</li><li id="0c37" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">HTTP并行请求HTTP 1.1中的另一个优化是并行请求。客户机可以通过一个TCP连接发出多个并行请求，而不是发出请求然后等待响应。并行化的一个问题是接收者现在需要理解<a class="ae kg" href="https://stackoverflow.com/a/65597570/5799085" rel="noopener ugc nofollow" target="_blank">哪个响应属于哪个请求</a>。这就是为什么服务器仅在第一次响应后才发送第二次响应，如下图HTTP管道图所示。但是由于TCP提供的序列排序，请求和响应不会相互混淆。即，请求1将具有序列1-m，请求2将具有序列m+1-n等等。一旦请求到达服务器，根据定义的规则，每个请求都将被解析(响应也是如此)。<br/>对于浏览器，每个浏览器都有不同的<a class="ae kg" href="http://Max Number of default simultaneous persistent connections per server" rel="noopener ugc nofollow" target="_blank">每个服务器的默认同时持久连接数上限</a>。</li></ul><figure class="kl km kn ko fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es ma"><img src="../Images/741ebd338caa0bcc016edf4a83bdc026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmUdpxC7Rp8rmrqGkXE9wA.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx translated">HTTP连接持久化和管道化(图片来自<a class="ae kg" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Connection_management_in_HTTP_1.x" rel="noopener ugc nofollow" target="_blank">developer.mozilla.org</a></figcaption></figure><p id="aafe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该图清楚地展示了持久连接和管道对性能的影响。</p><p id="261e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个典型的请求流，<strong class="ih hj">都通过一个TCP连接</strong>，看起来像这样:</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="fd43" class="kt je hi kk b fi ku kv l kw kx">GET /en-US/docs/Glossary/Simple_header HTTP/1.1<br/>Host: developer.mozilla.org<br/>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0<br/>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br/>Accept-Language: en-US,en;q=0.5<br/>Accept-Encoding: gzip, deflate, br<br/>Referer: <a class="ae kg" href="https://developer.mozilla.org/en-US/docs/Glossary/Simple_header" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Glossary/Simple_header</a></span><span id="b285" class="kt je hi kk b fi ky kv l kw kx">200 OK<br/>Connection: Keep-Alive<br/>Content-Encoding: gzip<br/>Content-Type: text/html; charset=utf-8<br/>Date: Wed, 20 Jul 2016 10:55:30 GMT<br/>Etag: "547fa7e369ef56031dd3bff2ace9fc0832eb251a"<br/>Keep-Alive: timeout=5, max=1000<br/>Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT<br/>Server: Apache<br/>Transfer-Encoding: chunked<br/>Vary: Cookie, Accept-Encoding</span><span id="1ea3" class="kt je hi kk b fi ky kv l kw kx">(content)</span><span id="9ba1" class="kt je hi kk b fi ky kv l kw kx">GET /static/img/header-background.png HTTP/1.1<br/>Host: developer.mozilla.org<br/>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0<br/>Accept: */*<br/>Accept-Language: en-US,en;q=0.5<br/>Accept-Encoding: gzip, deflate, br<br/>Referer: <a class="ae kg" href="https://developer.mozilla.org/en-US/docs/Glossary/Simple_header" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Glossary/Simple_header</a></span><span id="3a7b" class="kt je hi kk b fi ky kv l kw kx">200 OK<br/>Age: 9578461<br/>Cache-Control: public, max-age=315360000<br/>Connection: keep-alive<br/>Content-Length: 3077<br/>Content-Type: image/png<br/>Date: Thu, 31 Mar 2016 13:34:46 GMT<br/>Last-Modified: Wed, 21 Oct 2015 18:27:50 GMT<br/>Server: Apache</span><span id="9714" class="kt je hi kk b fi ky kv l kw kx">(image content of 3077 bytes)</span></pre><p id="6374" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解析请求和响应</strong></p><p id="2dac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HTTP 1.0和1.1在语法上没有太大的区别。尽管它有更多的方法和其他添加到头中的内容，但基本思想是一样的。我们用“\r\n”分隔每个标题行，标题和正文用“\r\n\r\n”分隔。</p><p id="eec9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，在1.1中，我们还需要处理流水线和持久性。<br/>在流水线中，如上所述，服务器提供的响应必须按照请求到达的顺序。即，如果客户端发送了3个请求，服务器将返回请求1的响应，然后是请求2，接着是请求3。响应2和3是否在响应1之前计算无关紧要。(这也叫<a class="ae kg" href="https://en.wikipedia.org/wiki/Head-of-line_blocking#:~:text=Head%2Dof%2Dline%20blocking%20(,multiple%20requests%20in%20HTTP%20pipelining." rel="noopener ugc nofollow" target="_blank">线头堵塞</a>)。这是必需的，因为HTTP无法理解每个请求对应的响应是什么，所以它依赖于它们的顺序。由于需要服务器支持这一要求，目前大多数浏览器都不支持。</p><p id="f13b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">问题</strong></p><p id="386a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管HTTP 1.1提供了相当大的性能升级和各种其他功能，但它仍然有一些限制，如下所述:</p><ul class=""><li id="d8ce" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">这里的<a class="ae kg" href="https://www.ietf.org/archive/id/draft-nottingham-http-pipeline-01.html" rel="noopener ugc nofollow" target="_blank">所指的流水线故障</a>。</li><li id="7a84" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">每个请求的标题复制。</li><li id="ed48" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">线路阻塞负责人。</li></ul><p id="ca0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一点上我们只完成了一半，这看起来已经像是一篇大文章了。我会写一篇续篇，讨论更多版本的HTTP (2.0，3.0)并详细描述web套接字。敬请期待:)</p></div></div>    
</body>
</html>