<html>
<head>
<title>How to use a dynamic library generated by Zig-lang in C++ codebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在C++代码库中使用Zig-lang生成的动态库</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-use-a-dynamic-library-generated-by-zig-lang-in-c-codebase-f83790520e03?source=collection_archive---------3-----------------------#2022-01-22">https://medium.com/codex/how-to-use-a-dynamic-library-generated-by-zig-lang-in-c-codebase-f83790520e03?source=collection_archive---------3-----------------------#2022-01-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="32f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">过去，我写过一个类似的故事,讲的是用C++和Python来使用动态库，但是是用土耳其语写的。如果你想让我翻译它，请写下评论或者不要犹豫，在任何社交媒体账户上联系我。今天，我们将尝试使用Zig编程语言生成一个动态库，然后在C++代码中使用它。我们开始吧！</p><p id="c162" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在解释这个代码库的实现细节之前，也许我应该介绍一下我新喜欢的编程语言<a class="ae jd" href="https://ziglang.org/" rel="noopener ugc nofollow" target="_blank"> Zig </a>。Zig是一种刚起步的编程语言，它鼓励你编写基于编译时代码的元编程风格。至少对我来说，它的语法类似于Go语言，但它有许多独特而重要的特性集，我可以在另一篇文章中解释，比如comptime、独立于Glibc、零依赖性、嵌入式C/C++编译器支持等等。目前，它支持跨平台编译，可以从许多不同的包管理器安装，你可以在这里找到它们<a class="ae jd" href="https://github.com/ziglang/zig/wiki/Install-Zig-from-a-Package-Manager" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="e403" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Zig中，有许多不同的选项，你可以在终端中简单地写下“Zig”来列出它们。如果你想从头开始创建一个可执行项目，你可以使用“<strong class="ih hj"> zig init-exe </strong>”。另一方面，如果你想创建一个库项目，你可以直接使用“<strong class="ih hj"> zig init-lib </strong>”命令，如下图所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/bbfec0756cb83e18dfd4e7534a40a99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*PtlmoLejKwIVqAgMe8S2iw.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">Zig列出终端上的所有选项/命令</figcaption></figure><p id="e822" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您选择&amp; run上面的"<strong class="ih hj"> zig init-lib </strong>"命令，zig将在当前目录下生成<em class="jq"> build.zig </em>文件，并在其中新建一个包含<em class="jq"> main.zig </em>文件的"<strong class="ih hj"> src </strong>"文件夹。在这个简单的例子中，我们与<em class="jq"> build.zig </em>文件没有任何交互，该文件主要与编译、链接和测试配置相关。我们应该进入<em class="jq"> main.zig </em>文件，尝试理解默认情况下写的是什么。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jr"><img src="../Images/1ea098e0c1039846598497bb826fb3ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*IPU-HS9z_C_pm-YhlbVeKw.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">zig自己创建的默认main.zig文件</figcaption></figure><p id="9dab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，您将在<em class="jq"> main.zig </em>文件中看到这些内容，我将尝试逐行解释。第一行，让你想起了什么？哦，我也一样。就像C#的<a class="ae jd" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive" rel="noopener ugc nofollow" target="_blank">使用</a>指令或者是C++的<a class="ae jd" href="https://en.cppreference.com/w/cpp/language/namespace" rel="noopener ugc nofollow" target="_blank">使用</a>指令和<a class="ae jd" href="https://en.cppreference.com/w/cpp/preprocessor/include" rel="noopener ugc nofollow" target="_blank">包含</a>预处理器的组合。第二行是别名用法的一个很好的例子。它简化了语言标准所支持的测试功能的使用。</p><p id="a0bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事后你可以猜到，它是一个函数调用，带两个<em class="jq"> i32 </em>类型参数，在同一个类型中返回它们的和。“<em class="jq"> fn </em>是表示一个函数的关键字(也可以是缩写)，后面“<em class="jq">加</em>就是它的名字。然后给出类似于“<em class="jq">参数名-冒号-类型</em>”和<em class="jq"> i32 </em>等价于<em class="jq"> int32_t </em> C类型的参数语法。与Go语言一样，返回类型位于这些参数之后。如果你熟悉Golang，你可能会说<a class="ae jd" href="https://go.dev/tour/basics/4" rel="noopener ugc nofollow" target="_blank">除了参数的冒号和函数的关键字名选择之外，它们几乎和</a>一样。</p><p id="71ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">测试是Zig语言的另一个关键特性，你可以在源代码中直接使用它。“<em class="jq"> test </em>”关键字代表测试用例，之后你可以给这个用例命名。如果你熟悉类似C++的<a class="ae jd" href="https://github.com/google/googletest" rel="noopener ugc nofollow" target="_blank"> GTest </a>或<a class="ae jd" href="https://github.com/catchorg/Catch2" rel="noopener ugc nofollow" target="_blank"> Catch2 </a>这样的单元测试框架，那么下一行就简单易懂了吧？</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es js"><img src="../Images/20d5dee878125ebe1a63930f09d28c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/0*ccdK-6iCJfwzs8n-.jpg"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">测试中的期望与现实</figcaption></figure><p id="b387" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">深入解释，你可能会意识到一件事，我还没有提到有意。哦对了，<em class="jq">导出</em>关键字。有了下面的新例子，我会更详细地解释它。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jt"><img src="../Images/f94d57554f26518a8c17a9498335e33b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*3skHjDcJtoz_YHQbKbsw8w.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">Zig中的导出关键字用法</figcaption></figure><p id="380b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设有两个几乎相似的函数调用，分别命名为“<em class="jq"> add_internal </em>”和“<em class="jq"> add_external </em>”。第二个函数有另一个关键字“<a class="ae jd" href="https://ziglang.org/documentation/0.9.0/#Exporting-a-C-Library" rel="noopener ugc nofollow" target="_blank"> <em class="jq"> export </em> </a>”，这使得它可以公开使用。让我们编译这个代码块并生成一个动态库。</p><p id="a1a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要从一个文件生成一个动态库，你必须显式地给出"<em class="jq">-动态</em>"选项，因为Zig默认生成一个<strong class="ih hj">静态</strong>库<strong class="ih hj"/>。因此，在运行“<em class="jq">zig build-lib-dynamic { filename }</em>”命令后，我们将拥有一个动态库。让我们检查我们的函数调用是否位于动态库的符号表中。如下面的截图所示，符号表中有<em class="jq"> add_external </em>，但不像我们预期的那样有<em class="jq"> add_internal </em>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jy"><img src="../Images/a140a9e1f05c47408cf95289b79ab65e.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*Zq8HLOAVDgLDWdixYmjeFg.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">符号表中的“add_external”</figcaption></figure><p id="f1a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们准备在C++代码中使用它。让我们写一个简单的C++代码来立即使用Zig编写的函数。下面是要编译和运行的简单的几行C++代码。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jz"><img src="../Images/51520c76ff9a7f458a91bee3bd60b7dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*bgqlVtw2Qc2hC6xPpodPvw.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">使用Zig函数的简单C++代码</figcaption></figure><p id="0449" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，一切都好了，对吗？哎呀，编译阶段似乎没问题，但链接我们有一个问题。为什么？</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ka"><img src="../Images/f0205f8cb9a4ccf118d86643e511e03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*u5ww3TxWw2BaligI8tM57Q.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">add_internal函数的链接错误。</figcaption></figure><p id="8ccf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几分钟后…哦，对了<a class="ae jd" href="https://en.wikipedia.org/wiki/Name_mangling" rel="noopener ugc nofollow" target="_blank">莽撞</a>！编译阶段没问题，因为函数名根本没有冲突。但是，“<em class="jq"> ld </em>”找不到这个函数的实现细节，因为函数名被篡改了。那么，下一个问题是，我们如何禁用这个功能的mangling？你好，"<em class="jq"> extern C </em> " <a class="ae jd" href="https://www.youtube.com/watch?v=NAEppFUWLfc" rel="noopener ugc nofollow" target="_blank">我的老朋友</a>。让我们通过在函数前面添加这个关键字来修改我们的函数签名，如下所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es kb"><img src="../Images/578e751d3fe586548174c414e4b6391c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*LYeaDfFJL1mvd7lwQgM25A.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">将extern关键字添加到函数签名后</figcaption></figure><p id="dc9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们知道我们的函数签名不会再被破坏，我们可以照原样使用它。让我们再次编译并运行它，不要有任何错误。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kc"><img src="../Images/e7e0ff94b6d4838618cf32f43653abc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*IWoRq-ljycCXE5OhIPAAKA.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">成功编译后的打印输出</figcaption></figure><p id="b816" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完美！现在，我们准备在C++代码库中使用我们的实现。我希望你也喜欢这次旅行。在下一个故事中，我将尝试解释Zig语言更吸引人的功能。请在这里或任何你能找到我的地方分享你对这个故事的想法！</p></div></div>    
</body>
</html>