<html>
<head>
<title>Let’s make Tappy Plane with Unity!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们团结一致制造塔皮飞机！</h1>
<blockquote>原文：<a href="https://medium.com/codex/lets-make-tappy-plane-with-unity-bdcde93f2705?source=collection_archive---------3-----------------------#2021-10-02">https://medium.com/codex/lets-make-tappy-plane-with-unity-bdcde93f2705?source=collection_archive---------3-----------------------#2021-10-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3cd9471f639d9edc9760a56c9ec32aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UhhstsGA4JatF6XKAlpkXQ.jpeg"/></div></div></figure><p id="f99d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将向你展示如何使用Unity创建Tappy平面游戏(类似于Flappy Bird )!</p><p id="df4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们将要建造的:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/c569368099f81f941a80c7e3a50cb0e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/1*4ntN6lABAnQUzq4Kg0xrHQ.gif"/></div></figure><p id="f5ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在GitHub的这里获得游戏<a class="ae jt" href="https://github.com/tariibaba/Tappy-Plane" rel="noopener ugc nofollow" target="_blank">的源代码。</a></p><h1 id="34ea" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">我们将使用的是:</h1><ul class=""><li id="c30d" class="ks kt hi is b it ku ix kv jb kw jf kx jj ky jn kz la lb lc bi translated"><a class="ae jt" href="https://github.com/neuecc/UniRx" rel="noopener ugc nofollow" target="_blank">UniRx</a>——用于反应式编程，以及漂亮干净的数据和视图分离。</li><li id="00c5" class="ks kt hi is b it ld ix le jb lf jf lg jj lh jn kz la lb lc bi translated"><a class="ae jt" href="https://www.kenney.nl/assets/tappy-plane" rel="noopener ugc nofollow" target="_blank">来自肯尼的Tappy飞机资产</a>。</li></ul><h1 id="a921" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">添加重复的背景和背景</h1><p id="17b1" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">我们首先创建我们将在游戏中使用的背景。用于背景的精灵是<code class="du ll lm ln lo b">Assets/Sprites/background.png</code>。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/7e89450f273a68e7ffcdbb553c32cd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFUL8ivmpQqEm65U380gqA.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">我们的背景图像</figcaption></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/15bc3c84bb5e5dc2f42aaa037650b56c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPKFDfxxM6eKBmGUl9EN_Q.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">同一图像的三个副本并排</figcaption></figure><h2 id="072f" class="lv jv hi bd jw lw lx ly ka lz ma mb ke jb mc md ki jf me mf km jj mg mh kq mi bi translated">制作重复的图像</h2><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="2adc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">组件<code class="du ll lm ln lo b">RepeatingBackground</code>被附加到组件<code class="du ll lm ln lo b">Background</code>上，该组件包含背景的所有片段作为子游戏对象。我们首先将重复背景的所有片段按照它们在场景中出现的顺序初始化成一个队列。这些片段是连接在一起的同一个图像，并以一定的速度向屏幕的左边移动。当第一个段完全离开屏幕时，我们将其发送到队列的末尾(成为新的最后一个段),并将其位置移动到屏幕的最右侧——但仍与其他段相连。我们一直这样做，直到游戏停止。通过这样做，我们创造了一个永无止境的背景的幻觉。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/e20dc54bd45d56463495b220f99062c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*_84oAthoEOcOvZDIPTMaiQ.gif"/></div></figure><p id="f0aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是场景中实际发生的情况:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/1abcf19e34f63bed30feffabe0930363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QgLVbiiSXQBtQBSAtgqXag.gif"/></div></div></figure><p id="cdf3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是因为精灵的设计方式。</p><p id="db93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们对地面做了同样的处理，但是速度更快，因为它在前景中(精灵是<code class="du ll lm ln lo b">Assets/Sprites/groundGrass.png</code>)</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/320572acb56214db7047810677e721cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*3w_84yghkeRKvg_JkMdX5g.gif"/></div></figure><h1 id="9903" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">创建平面</h1><p id="0432" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">我们将在飞机上使用这些精灵:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/91b6931dd4debc0a0e68503944f5c15b.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*VWbZfhieUly6z2wfbY3TvA.png"/></div></figure><p id="bcef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们一次选择三个并把它们拖到场景中。这将打开一个对话框，允许我们自动创建一个新的精灵动画。现在我们在游戏中有了带旋转叶片的飞机:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/1f1807b6e92b827d3279fa2344c42f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*Tuh_wUTkKYaqqNHXLhX6eQ.gif"/></div></figure><h1 id="795e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">检测玩家输入</h1><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="702e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du ll lm ln lo b">Plane</code>脚本组件中，我们从玩家那里获得输入来让飞机跳跃。当用户点击鼠标左键或按空格键时，我们设置Y方向的速度。这是飞机在由于重力而失去速度之前的初始速度(我们在飞机上附加了一个<code class="du ll lm ln lo b">Rigidbody 2D</code>组件来实现物理)。当玩家撞上障碍物时，游戏将会结束，所以当这种情况发生并且飞机落到地面时，我们停止检测输入。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/e9c5a85cce44d468375c837f59c91a8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*lUUHqM7_Q-Vi8NdZ1dS9zQ.gif"/></div></figure><h1 id="986d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">制造障碍</h1><p id="d29b" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">我们用这两个精灵来制造障碍:</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/a2abf757a2f58d95e42187e90a604eef.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/1*Ryyl5CwuCpYTTKSBqzQ7Kw.png"/></div></figure><p id="fd4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们通过在<code class="du ll lm ln lo b">Hierarchy</code>窗口中使它们成为同一个父<code class="du ll lm ln lo b">Rock Grass</code>的两个孩子来使它们一起移动。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/e98cf3bffffd6a9b02d0da683677f195.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*0rG4B147OgTCwyKHWiH9Gg.png"/></div></div></figure><p id="eefa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在场景中有一个<code class="du ll lm ln lo b">GameController</code>游戏对象(来实现单机游戏管理模式)。它有一个附加的<code class="du ll lm ln lo b">GameController</code>脚本，该脚本有<code class="du ll lm ln lo b">firstRockPair</code>序列化字段。我们在Unity编辑器中将该字段设置为<code class="du ll lm ln lo b">Rock Grass</code>。是玩家在游戏中遇到的第一个障碍，也是我们将要克隆以制造更多障碍的对象。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="7682" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当游戏开始时，我们创建了一个<code class="du ll lm ln lo b">firstRockPair</code>的克隆体，并把它放在离<code class="du ll lm ln lo b">firstRockPair</code>随机距离的地方。在随机的几秒钟后，第一个克隆体向左移动了很多，我们创建了另一个<code class="du ll lm ln lo b">firstRockPair</code>的克隆体。</p><h1 id="1058" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">检测碰撞</h1><p id="6bab" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">我们将一个<code class="du ll lm ln lo b">Polygon Collider 2D</code>组件附加到平面和显示顶部和底部岩石精灵的两个子组件<code class="du ll lm ln lo b">Rock Grass</code>(<code class="du ll lm ln lo b">rockGrass</code>和<code class="du ll lm ln lo b">rockGrassDown</code>)上，以启用我们在<code class="du ll lm ln lo b">Plane</code>脚本中处理的碰撞检测:</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="e7cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这一点上，我们已经有了一个功能齐全的Tappy飞机游戏！</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/bdc8861c61e9d3ef54010a5501712c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/1*VO7_cNVW5C2PTx5TreqlJg.gif"/></div></figure><h1 id="f23f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">添加评分</h1><p id="3b77" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">我们在场景中创建一个不可见的游戏对象，并使它成为岩草的孩子。我们将这个对象标记为<code class="du ll lm ln lo b">ScoreIncreaseTrigger</code>。我们把它放在场景中岩石对的后面，这样当<code class="du ll lm ln lo b">OnTriggerExit2D</code>函数被调用来触发飞机和这个物体之间的碰撞时，就意味着飞机已经成功地通过了岩石对，所以我们增加了玩家的分数。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><h2 id="ae35" class="lv jv hi bd jw lw lx ly ka lz ma mb ke jb mc md ki jf me mf km jj mg mh kq mi bi translated">分数指示器</h2><p id="bcb2" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">代替显示玩家当前分数的字体，我们将使用这些精灵(一个精灵代表分数的一个数字):</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/67385d2df5903f26ffe03369ca771e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*bf6P7Q6YxsupMAsflxKLEg.jpeg"/></div></figure><p id="ea71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以我们需要一个自定义方法来根据来自<code class="du ll lm ln lo b">Score</code>组件的分数更新显示的精灵。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="774b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在一个列表中存储每个数字的。这些图像在场景中并排放置。假设现在的分数是9。9只有一个数字，这意味着我们在列表中只有一个图像。当我们将分数更新为10时会发生什么？嗯，10有两个数字(1和0)，所以我们将列表中第一个图像的精灵更新为显示数字1的精灵。然后我们在列表中创建一个新的图像，并将它的sprite设置为显示数字0的sprite。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/fd5fc3c752b1517548f55c8655655615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/1*vaNmjnz3FdsPJIVO_KYt2g.gif"/></div></figure><h1 id="f6f1" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">添加星星</h1><p id="4672" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb li jd je jf lj jh ji jj lk jl jm jn hb bi translated">自从上一次产生一个恒星群以来，在飞机通过随机数量的岩石后，我们产生了一个新的恒星群。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="b5db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ll lm ln lo b">SpawnStars()</code>使每个星群中的星星走半圆的路径。一组中的每颗恒星都围绕同一点旋转一个角度，这个角度基于它们在组中的位置。</p><p id="bb12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当飞机撞上一颗星星时，我们破坏该星星的游戏对象，并增加星星数:</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="667c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要做的最后一件事是添加一个星计数指示器。<code class="du ll lm ln lo b">StarCount</code>组件只是检测星星数量的变化，并相应地更新场景中指示器的文本。我们这次使用了一种字体(KenVector Future ),所以我们不会像分数指示器那样使用自定义更新方法。我们只需要设置<code class="du ll lm ln lo b">text</code>属性。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/bfb391852822c19580252733cdb97d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/1*9ygxCSPtOM-jT7QZEhMf2w.gif"/></div></figure><p id="83a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就是这样！我们有Tappy飞机启动并运行(飞行，跳跃？)!</p><p id="4256" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以给游戏增加更多的功能。来自<a class="ae jt" href="https://www.kenney.nl/" rel="noopener ugc nofollow" target="_blank">肯尼</a>的资源包含精灵，当飞机跳跃时，我们可以用它们来创建像排气动画这样的东西。我们甚至可以利用地面和岩石精灵的各种变化来改变天气。</p><p id="d5ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在GitHub上的这里找到项目<a class="ae jt" href="https://github.com/tariibaba/Tappy-Plane" rel="noopener ugc nofollow" target="_blank">。也许你可以克隆它，并尝试自己扩展它？或者喜欢就从头开始？</a></p><p id="6357" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">无论如何，我希望你在阅读这篇文章的时候过得愉快，现在你知道如何用类似的机制制作一个游戏了。</p></div></div>    
</body>
</html>