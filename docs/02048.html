<html>
<head>
<title>Designing Pastebin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计剪贴板</h1>
<blockquote>原文：<a href="https://medium.com/codex/designing-pastebin-77e6e86172eb?source=collection_archive---------1-----------------------#2021-06-26">https://medium.com/codex/designing-pastebin-77e6e86172eb?source=collection_archive---------1-----------------------#2021-06-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a001" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">让我们设计一个web服务来存储纯文本，并获得一个随机生成的URL来访问它。</h2></div><p id="a7b5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似服务:pasted.co、hastebin.com、chopapp.com</p><h1 id="f6ed" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">Pastebin是什么？</h1><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kl"><img src="../Images/2a5102c5914aeca83f2f8a02b214ba5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R6qCdbTp09dLwYnp"/></div></div></figure><p id="3fa9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Pastebin.com类似的服务使用户能够通过网络(通常是互联网)存储纯文本或图像，并生成唯一的URL来访问上传的数据。这种服务也用于在网络上快速共享数据，因为用户需要传递URL才能让其他用户看到。</p><p id="8601" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你以前没有使用过pastebin.com，请尝试在那里创建一个新的“粘贴”,并花一些时间浏览他们的服务提供的不同选项。这将有助于你更好地理解这一章。</p><h1 id="f883" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">系统的要求和目标</h1><p id="bf0e" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们的Pastebin服务应满足以下要求:</p><h2 id="2d2b" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">功能需求</h2><ol class=""><li id="0dde" class="lr ls hi iz b ja ky jd kz jg lt jk lu jo lv js lw lx ly lz bi translated">用户应该上传或“粘贴”他们的数据，并获得一个唯一的网址来访问它。</li><li id="bbea" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">用户将只能上传文本。</li><li id="f2bf" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">数据和链接将在特定时间间隔后自动过期；用户还应该指定到期时间。</li><li id="0f15" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">用户应该可以选择为他们的粘贴选择一个自定义别名。</li></ol><h2 id="857c" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">非功能性需求</h2><ol class=""><li id="9ece" class="lr ls hi iz b ja ky jd kz jg lt jk lu jo lv js lw lx ly lz bi translated">该系统应该是高度可靠的，任何数据上传不应丢失。</li><li id="06cb" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">系统应该是高度可用的。这是必要的，因为如果我们的服务关闭，用户将无法访问他们的粘贴。</li><li id="ad60" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">用户应该能够以最小的延迟实时访问他们的粘贴。</li><li id="062e" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">粘贴链接不应该是可猜测的(不可预测)。</li></ol><h2 id="0217" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">扩展要求</h2><ol class=""><li id="5770" class="lr ls hi iz b ja ky jd kz jg lt jk lu jo lv js lw lx ly lz bi translated">分析，例如，重定向发生了多少次？</li><li id="fc05" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">其他服务也应该可以通过REST APIs访问我们的服务。</li></ol><h1 id="ac77" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">一些设计考虑</h1><p id="060a" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">Pastebin与URL缩短服务有一些相同的要求，但是我们应该记住一些额外的设计考虑。</p><h2 id="11b4" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">用户一次可以粘贴的文本数量限制应该是多少？</h2><p id="42bc" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以限制用户不要有大于10MB的贴子，以防止滥用这项服务。</p><h2 id="6ee3" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">我们应该限制自定义网址的大小吗？</h2><p id="bb18" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">由于我们的服务支持自定义URL，用户可以选择他们喜欢的任何URL，但提供自定义URL不是强制性的。然而，对自定义URL施加大小限制以获得一致的URL数据库是合理的(并且通常是可取的)。</p><h1 id="70d7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">容量估计和限制</h1><p id="0b9e" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们的服务需要大量的阅读；与新的粘贴创建相比，将会有更多的读取请求。因此，我们可以假设读写比为100:1。</p><h2 id="e5b2" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">交通量估计</h2><p id="0e2e" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">Pastebin服务预计不会有类似Twitter或脸书的流量。让我们假设每天有100万个新的粘贴添加到我们的系统中。假设读写比为100:1，那么我们每天有1亿次读取。</p><p id="ef9a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每秒新贴:1M / (24小时* 3600秒)～= 10贴/秒</p><p id="8dcb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每秒粘贴读取次数:100M / (24小时* 3600秒)～= 1200次读取/秒</p><h2 id="2bfa" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">存储估计</h2><p id="4578" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">用户最多可以上传10MB的数据；通常，类似Pastebin的服务用于共享源代码、配置或日志。这样的文本并不大，所以让我们假设每个粘贴平均包含100 KB。</p><p id="44c3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">按照这个速度，我们每天将存储100 GB的数据。</p><p id="5fa3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh mi b">1M * 10KB = 100 GB/day</code></p><p id="22a6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们希望将这些数据存储5年，我们将需要180 TB的总存储容量。</p><p id="852d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh mi b">100 GB * 365 days * 5 years ~= 180 TB</code></p><p id="4634" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每天有100万个牙膏，我们将在5年内拥有大约20亿个牙膏。</p><p id="3452" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh mi b">1M * 365 * 5 ~= 2 Billion</code></p><p id="7847" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要生成并存储密钥来唯一地标识这些粘贴。如果我们使用base64编码([A-Z，A-Z，0–9，.，-])我们需要六个字母的字符串:</p><p id="6eca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh mi b">64⁶ ~= 68.7 billion unique strings</code></p><p id="ce9f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果存储一个字符需要一个字节，则存储3.6B密钥所需的总大小为:</p><p id="499a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh mi b">2 B * 6 = 12 GB</code></p><p id="a16f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">12 GB与180 TB相比微不足道。为了保持一定的余量，我们将假设70%的容量模式(意味着我们不希望在任何时候使用超过总存储容量的70%)，这将我们的存储需求提高到260 TB。</p><h2 id="d45c" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">带宽估计</h2><p id="35eb" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">对于每秒的写请求，我们期望每秒10个新的粘贴，导致每秒1 MB的入口。</p><p id="7c07" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh mi b">10 * 100 KB = 1 MB/s</code></p><p id="d646" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">至于读请求，我们预计每秒1000个请求。因此，总的数据输出(发送给用户)将是100 MB/s。</p><p id="adee" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh mi b">1000 * 100 KB =&gt; 100 MB/s</code></p><p id="210e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然总的入口和出口并不大，但在设计我们的服务时，我们应该记住这些数字。</p><h2 id="9111" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">内存估计</h2><p id="c541" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以缓存一些经常访问的热粘贴。遵循80–20法则，也就是说20%的热粘贴产生80%的流量，我们希望缓存这20%的粘贴。</p><p id="5e7c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于我们每天有1亿个读取请求，要缓存其中的20%,我们需要:</p><p id="3c39" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh mi b">0.2 * 100 M * 100 KB ~= 2 TB</code></p><p id="d1db" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以随意使用这个<a class="ae kx" href="https://docs.google.com/spreadsheets/d/1MQ780cyE5UdK3w78tDa44064AkY3vS8cP-VbqrZkl7I/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank"> Excel文件</a>来获得特定于您系统的估计值。</p><h1 id="217a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">数据库设计</h1><p id="7f8e" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">关于我们将要存储的数据的性质的一些观察:</p><ol class=""><li id="59b0" class="lr ls hi iz b ja jb jd je jg mj jk mk jo ml js lw lx ly lz bi translated">我们需要存储大约20亿条记录。</li></ol><p id="5d8b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh mi b">1 Million per day * 365 days * 5 years ~= 2 Billion</code></p><ol class=""><li id="07d5" class="lr ls hi iz b ja jb jd je jg mj jk mk jo ml js lw lx ly lz bi translated">我们要存储的每个元数据对象都很小(小于100字节)。</li><li id="c007" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">我们存储的每个粘贴对象可以是中等大小(平均100KB，最大10 MB)。</li><li id="0a8b" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">记录之间没有关系，除非我们想存储哪个用户创建了什么粘贴。</li><li id="95a0" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js lw lx ly lz bi translated">我们的服务阅读量很大。100:1的读写比率。</li></ol><h2 id="d00a" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">数据库模式</h2><p id="9728" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们需要两个表，一个用于存储关于粘贴的信息，另一个用于存储用户的数据。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es mm"><img src="../Images/6282243bba234d36701da31aa741b213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/0*kY_SLBJVya9Ff51T"/></div></figure><h1 id="8558" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">高层设计</h1><p id="9f81" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们需要一个应用层，它将在一个高层次上服务于所有的读写请求。</p><p id="c258" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">应用层将与存储层通信，以存储和检索数据。</p><p id="0e75" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以用一个数据库来隔离我们的存储层，该数据库存储与每个粘贴、用户等相关的元数据。而另一个将粘贴内容存储在某个块存储器或数据库中。这种数据划分将允许我们对它们进行单独扩展。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es mn"><img src="../Images/fcab8a1749a6f65405a2228ab97f4775.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/0*S1Wom25l_WKZeXLX"/></div></figure><h1 id="e336" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">组件设计</h1><h1 id="c1d1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">应用层</h1><p id="354a" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们的应用层将处理所有传入和传出的请求。应用服务器将与后端数据存储组件进行对话，以满足请求。</p><h2 id="07f8" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">如何处理写请求？</h2><p id="ba66" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在收到写请求时，我们的应用服务器将生成一个六个字母的随机字符串，它将作为粘贴的密钥(如果用户没有提供自定义密钥)。然后，应用服务器将把粘贴的内容和生成的密钥存储在数据库中。成功插入后，服务器可以将密钥返回给用户。</p><p id="c4fb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里可能存在的一个问题是，由于重复的键，插入会失败。因为我们正在生成一个随机密钥，所以新生成的密钥有可能与现有的密钥相匹配。在这种情况下，我们应该重新生成一个新的密钥并重试。我们应该不断重试，直到我们看不到由于重复的密钥而导致的失败。如果用户提供的自定义密钥已经存在于我们的数据库中，我们应该向用户返回一个错误。</p><p id="bc46" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述问题的另一个解决方案是运行一个独立的密钥生成服务(KGS ),它预先生成随机的六个字母的字符串，并将它们存储在一个数据库中(我们称之为key-DB)。</p><p id="3871" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">KGS将确保key-DB中插入的所有密钥都是唯一的。每当我们想要存储一个新的粘贴，我们将采取一个已经生成的密钥，并使用它。这种方法将使事情变得非常简单和快速，因为我们不用担心重复或冲突。</p><p id="d8bc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">kg可以使用两个表来存储密钥，一个表存储尚未使用的密钥，另一个表存储所有已使用的密钥。只要KGS给任何应用服务器一些密钥，它就可以将这些密钥移动到used keys表中。KGS总是可以在内存中保存一些密钥，这样每当服务器需要它们时，它就可以快速地提供它们。一旦KGS在内存中加载了一些密钥，它就可以将它们移动到used keys表中。这样，我们可以确保每台服务器都获得唯一的密钥。如果KGS在使用所有加载到内存中的密钥之前死亡，我们将会浪费这些密钥。我们可以忽略这些键，因为我们有大量的键。</p><h2 id="2cd8" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">KGS不是单点故障吗？</h2><p id="5c2e" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">是的，它是。为了解决这个问题，我们可以有一个KGS的备用副本，只要主服务器死亡，它就可以接管生成和提供密钥。</p><h2 id="41fe" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">每个应用服务器可以缓存key-DB中的一些密钥吗？</h2><p id="aa95" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">是的，这肯定能加快速度。虽然在这种情况下，如果应用服务器在使用完所有密钥之前就死掉了，我们最终会丢失这些密钥。这是可以接受的，因为我们有68B个独特的六字母键，比我们需要的多得多。(我们只需要20亿)</p><h2 id="1630" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">如何处理粘贴读取请求？</h2><p id="375c" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">收到读取请求后，应用服务层会联系数据存储。数据存储搜索该键，如果找到，则返回粘贴的内容。否则，将返回一个错误代码。</p><h1 id="6953" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">数据存储层</h1><p id="7a74" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以将数据存储层分为两层:</p><h2 id="2df2" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">元数据数据库</h2><p id="5cbc" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以使用像MySQL这样的关系数据库，或者像Redis或Memcached这样的分布式键值存储。前者更适合老牌企业，后者更适合快速成长的初创企业。有关选择数据库类型的更多详细信息，请参考本文。</p><h2 id="86f9" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">块存储器</h2><p id="303b" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以将我们的内容存储在分布式键值块存储中，以享受NoSQL(如HDFS或S3)提供的好处。每当我们想充分利用内容存储的容量时，我们可以通过添加更多的服务器来快速增加容量。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es mo"><img src="../Images/a859f4beb51bcdf381e6d52ebd7616dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75CQltkeKHlpVm8nwTwpoA.png"/></div></div></figure><h1 id="9838" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">隐藏物</h1><p id="89a1" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以缓存频繁访问的粘贴。我们可以使用一些现成的解决方案，如Memcached，它可以存储全文内容及其各自的哈希。在访问后端存储之前，应用服务器可以快速检查缓存中是否有所需的粘贴。</p><h2 id="4432" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">我们应该有多少缓存？​</h2><p id="2ef8" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以从20%的日流量开始，并且我们可以根据客户的使用模式来调整我们需要多少缓存服务器。根据上面的估计，我们需要600GB的内存来缓存20%的日常流量。由于一台<strong class="iz hj">现代服务器可以有256GB的内存</strong>，我们可以轻松地将所有的缓存放入三台机器中，或者使用一些较小的服务器来存储所有这些热门URL。</p><h2 id="5eb4" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">哪种缓存回收策略最符合我们的需求？​</h2><p id="aa35" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">当缓存满了，我们想用一个更新/更热的URL替换一个链接，我们该如何选择？<strong class="iz hj">最近最少使用(LRU) </strong>可以是我们系统的合理策略。根据此策略，我们首先丢弃最近最少使用的URL。然后，我们可以使用一个<a class="ae kx" href="https://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html" rel="noopener ugc nofollow" target="_blank">链接的散列图</a>或类似的数据结构来存储我们的URL和散列，跟踪最近访问了哪些URL。</p><p id="9d3a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了进一步提高效率，我们可以复制我们的缓存服务器，以便在它们之间分配负载。</p><p id="3105" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要了解更多细节，请参考<a class="ae kx" rel="noopener" href="/geekculture/caching-b863bbce4bf">这篇缓存文章</a>。</p><h2 id="a4ac" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kf jk lm ln kh jo lo lp kj lq bi translated">如何更新每个缓存副本？​</h2><p id="e02d" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">无论何时出现缓存缺失，我们的服务器都会命中后端数据库。相反，每当发生这种情况时，我们可以更新缓存并将新条目传递给所有缓存副本。这也称为直写策略。参考<a class="ae kx" rel="noopener" href="/geekculture/caching-b863bbce4bf">这篇缓存文章</a>了解更多细节。每个副本可以通过添加新条目来更新其缓存。如果副本已经有了那个条目，它可以简单地忽略它。</p><h1 id="d63b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">负载平衡器(磅)</h1><p id="2ead" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以在系统的三个位置添加负载平衡层:</p><p id="42b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.客户端和应用服务器之间</p><p id="130e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.在应用服务器和数据库服务器之间</p><p id="484c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.在应用服务器和缓存服务器之间</p><p id="d1b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最初，可以采用简单的循环法；它将传入的请求平均分配给后端服务器。这种LB实现起来很简单，不会引入任何开销。这种方法的另一个好处是，如果一个服务器死了，LB将把它从轮换中去掉，并停止发送任何流量。然而，循环LB的一个问题是，它不考虑服务器负载。因此，如果一个服务器过载或运行缓慢，LB不会停止向该服务器发送新的请求。为了处理这个问题，可以放置一个更智能的LB解决方案，定期查询后端服务器的负载，并根据负载调整流量。参考<a class="ae kx" rel="noopener" href="/geekculture/load-balancing-da0bde7882f1">这篇负载平衡器文章</a>了解更多详情。</p><h1 id="e25b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">清除或数据库清理</h1><p id="1bb6" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">条目应该永远保留，还是应该被清除？如果到了用户指定的到期时间，粘贴会发生什么情况？</p><p id="b6b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们选择搜索过期的贴子来持续删除它们，这将给我们的数据库带来很大压力。</p><p id="c247" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相反，我们可以慢慢地删除过期的粘贴，做一个懒惰的清理。我们的服务将确保只有过期的粘贴将被删除，虽然一些过期的粘贴可以生存更长时间，但永远不会返回给用户。</p><ul class=""><li id="6fe2" class="lr ls hi iz b ja jb jd je jg mj jk mk jo ml js mp lx ly lz bi translated">每当用户试图访问过期的粘贴，我们可以删除链接，并返回一个错误给用户。</li><li id="f614" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js mp lx ly lz bi translated">一个单独的清理服务可以定期运行，从我们的存储和缓存中删除过期的粘贴。该服务应该是非常轻量级的，并且被安排为仅在预期用户流量较少时运行。</li><li id="27ba" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js mp lx ly lz bi translated">我们可以为每次粘贴设置一个默认的到期时间(例如，两年)。</li><li id="ee71" class="lr ls hi iz b ja ma jd mb jg mc jk md jo me js mp lx ly lz bi translated">删除过期的粘贴后，我们可以将密钥放回key-DB中以供重用。</li></ul><h1 id="f8da" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">安全性和权限</h1><p id="7bc0" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">用户可以创建私人粘贴或允许一组特定的用户访问粘贴吗？</p><p id="78a1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以将每次粘贴的权限级别(公共/私有)存储在数据库中。</p><p id="ab72" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还可以创建一个单独的表来存储有权查看特定粘贴的用户id。如果我们将数据存储在NoSQL键值或宽列数据库中，存储权限的表的键将是“Hash”(或KGS生成的“key”)，列将存储那些有权查看粘贴内容的用户的UserIDs。</p><p id="b68a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果用户没有权限并试图访问粘贴，我们可以发送一个错误(HTTP 401)回来。</p></div></div>    
</body>
</html>