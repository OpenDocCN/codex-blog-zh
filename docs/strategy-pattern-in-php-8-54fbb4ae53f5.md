# PHP 8+中的策略模式

> 原文：<https://medium.com/codex/strategy-pattern-in-php-8-54fbb4ae53f5?source=collection_archive---------9----------------------->

![](img/63c085eb93da64ac01246bcb20387633.png)

[JESHOOTS.COM](https://unsplash.com/@jeshoots?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

## 如何使用模式解决现实世界的问题，同时保持代码整洁

在本文中，我们将讨论**策略**模式，如何在 PHP 中应用它，以及我如何使用它来解决我工作的公司中的一个现实问题，从代码中删除几个具有类似行为的类。

# ♟战略设计模式

策略是一种行为设计模式，让你定义一系列算法，将它们放入一个单独的类中，并使它们的对象可以互换。这种模式具有**低复杂度**并且**非常流行**。

这个模式由两种类型的类组成:上下文**和策略**。

第一个是主类，必须有一个属性来保存一个**策略**。然后，**上下文**将部分工作委托给**策略**对象，而不是单独完成。

**策略**可以被认为是具有相似行为的算法，即做同样的事情，但方式不同。

**上下文**没有责任为每个案例选择合适的策略，这个责任在于**客户**本身。事实上，**语境**对策略了解不多。它只知道所有**策略**实现的通用接口。

**策略**模式可以应用于您希望在一个对象中使用不同的算法变体，并且能够在运行时从一种算法切换到另一种算法的情况。

使用该模式的另一个用例是当一个类有许多行为并使用许多条件命令时，这会使应用程序的性能不令人满意。使用该模式，您可以删除条件，并为每个条件创建名为**策略**的新类，从而提高性能。

**策略**也可以用于重构几个类似的类，这些类的不同之处仅在于它们通过将每个表单提取到单独的**策略**中来执行行为。

# 👷‍♂️实施

最后，我将解释我如何在我工作的公司中解决一个现实世界的问题，使用**策略**模式来消除几个具有相似行为的类，并使代码更干净。

首先，简单介绍一下:

在我工作的应用程序中，我们有课程和可以注册这些课程的用户。问题是，这些注册可能来自不同的来源，我们必须在创建新注册时存储该来源，以控制发生的情况，并使调试更容易。

此外，每个起点都有自己的逻辑来计算登记到期时间。

以下是一些可能的注册来源:

*   **自动** -自动创建免费课程或已确认付款的付费课程的注册
*   **手动** -由管理员手动创建的注册
*   **组** -因为用户是已注册课程的组的成员而创建的注册
*   **批次** -通过批次导入创建的注册
*   **组合** -注册已创建，因为用户已注册课程组合

在我重构之前运行的代码对每个原点都有一个类。这些类有太多的代码重复，在某些情况下，客户端负责实现到期逻辑。

现在，让我们来看看我使用的解决方案:

为了解决这个问题，我可以使用继承，为每个起源创建一个子类，并创建一个抽象超类来实现起源之间的公共逻辑。

但是最好的解决方案可能是遵循 OOP 的良好实践，并且更喜欢**组合而不是继承**。因此，**策略**模式非常适合。

首先，我们需要创建一个所有策略都将实现的接口:

策略界面

重构代码的第二步是创建一个主类，名为**名为**。在这个例子中，我们将它命名为 *Enroll* ，以更好地表达该类的功能:

上下文类

**OBS:面向在构造函数中定义的映射器对象，像一个通用类一样处理数据，创建模型，并将它们保存在某个地方**

> Enroll 类拥有策略之间的所有公共逻辑，并拥有一个保存已定义的**策略**的属性。在这个例子中，策略是在构造函数中定义的，但是如果需要更多的灵活性，您可以实现一个策略设置器

然后，我们可以根据需要创建任意多的策略。在这种情况下，我们需要为每个注册来源创建一个**策略**，下面是一个示例:

战略实施示例

# 📉优势

使用**策略**模式的主要优势是使代码更加灵活和可扩展，使得维护和新特性的创建更加容易。此外，这种模式可以帮助我们消除重复代码。

**策略**设计模式让我们在运行时交换对象内部使用的算法，并将算法的实现细节与使用它的代码隔离开来。

这种模式也遵循编程的良好实践，因为它让我们在类中用组合代替继承。再者，它符合 [**开合原理**](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle) 中所述**[](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#:~:text=SOLID%20is%20an%20acronym%20for,OOD)%20principles%20by%20Robert%20C.&text=O%20%2D%20Open%2Dclosed%20Principle,I%20%2D%20Interface%20Segregation%20Principle)**原理。****

# ****📈不足之处****

****我在这个主题中的意图是展示实现这个模式的权衡，不要像面对“问题”一样面对它，而是在决定是否实现它时要考虑的要点。****

****要注意的第一个问题是，如果你只有几个算法，而且它们很少改变。在这种情况下，没有真正的理由随着模式增加新的类和接口来增加代码的复杂性。****

******策略**模式也迫使客户意识到可用策略之间的差异，以选择合适的策略。****

# ****✅结论****

****PHP 代码中经常使用**策略**模式，尤其是在运行时需要切换算法的时候。它为我们提供了一种定义算法族的方法，将每个算法封装成一个对象，并使它们可以互换。这种模式具有**低复杂度**并且**非常流行**。****

****使用**策略**模式的主要优势是使代码更加灵活和可扩展，使得维护和新特性的创建更加容易。另一方面，它会给代码带来不必要的复杂性。****

****在本文中，我展示了如何使用这种模式来解决现实世界中的问题，从应用程序中删除大量重复的代码。****

****我希望你们喜欢这篇文章，如果你们喜欢，请留下掌声和评论。如果你不喜欢它，让我知道为什么，建设性的批评总是受欢迎的！****

****如果你想更深入的了解这个主题，我推荐你去访问我在文章末尾留下的所有参考资料！****

****如果你喜欢这篇文章，我想邀请你访问我的另一篇关于 Medium 的文章，它讨论了[观察者设计模式](/codex/observer-pattern-in-php-8-569c71dd7837?sk=7e926d06b0f5c9035e0127caeec82dab)，在那里我解释了这个模式到底是什么，并且给了你一些教导性的例子，展示了实现这个模式的优点和缺点。如果你想看，就去下面的链接:)****

****[](/codex/observer-pattern-in-php-8-569c71dd7837) [## PHP 8+中的观察者模式

### 在 PHP 8+中实现观察者模式的最简单指南

medium.com](/codex/observer-pattern-in-php-8-569c71dd7837) 

# 📚参考

[攻略-维基百科](https://pt.wikipedia.org/wiki/Strategy)

[战略模式重构大师](https://refactoring.guru/design-patterns/strategy/)

[带 Java 示例的策略模式教程- DZone](https://dzone.com/articles/design-patterns-strategy)****