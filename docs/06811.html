<html>
<head>
<title>Generics In Kotlin (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的泛型(第3部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/generics-in-kotlin-part-3-1efde0bf0167?source=collection_archive---------5-----------------------#2022-05-14">https://medium.com/codex/generics-in-kotlin-part-3-1efde0bf0167?source=collection_archive---------5-----------------------#2022-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3771144cfa82b166657ee26efa804433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Da2LzK4ATS1XfXH8EzrZ-A.jpeg"/></div></div></figure><p id="a955" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">欢迎阅读泛型系列的第3部分。</p><p id="cdfa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你是第一次学习泛型，请检查</p><p id="0367" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包含Java示例的第1部分:</p><div class="jo jp ez fb jq jr"><a rel="noopener follow" target="_blank" href="/@nehalCodes/generics-in-java-part-1-e6a2d74745cd"><div class="js ab dw"><div class="jt ab ju cl cj jv"><h2 class="bd hj fi z dy jw ea eb jx ed ef hh bi translated">Java中的泛型(第1部分)</h2><div class="jy l"><h3 class="bd b fi z dy jw ea eb jx ed ef dx translated">泛型在Java和Kotlin中都是一个强大的特性，可以帮助您编写类型安全的可伸缩代码。然而，我发现…</h3></div><div class="jz l"><p class="bd b fp z dy jw ea eb jx ed ef dx translated">medium.com</p></div></div><div class="ka l"><div class="kb l kc kd ke ka kf io jr"/></div></div></a></div><p id="6f58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kotlin基础知识第2部分:</p><div class="jo jp ez fb jq jr"><a rel="noopener follow" target="_blank" href="/@nehalCodes/generics-in-kotlin-part-2-6e87f9b2e8ac"><div class="js ab dw"><div class="jt ab ju cl cj jv"><h2 class="bd hj fi z dy jw ea eb jx ed ef hh bi translated">Kotlin中的泛型(第2部分)</h2><div class="jy l"><h3 class="bd b fi z dy jw ea eb jx ed ef dx translated">欢迎阅读泛型系列的第2部分。</h3></div><div class="jz l"><p class="bd b fp z dy jw ea eb jx ed ef dx translated">medium.com</p></div></div><div class="ka l"><div class="kg l kc kd ke ka kf io jr"/></div></div></a></div><p id="221a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我想在Kotlin中复习更多关于泛型的概念，同时根据需要与Java进行比较。如前所述，学习这些的最好方法是在您的首选IDE中尝试这些示例:)</p><h1 id="b9c1" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">星形投影</h1><p id="6d67" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">有一个单独的bog帖子专门用于恒星投影可能会感觉怪怪的，但让我们确保理解它背后的所有概念。</p><p id="5d85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kotlin的星形投影类似于Java中的无界通配符，当我们对类型一无所知，但仍然希望以安全的方式使用时，我们会使用它。</p><p id="690f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然这是一个简单的定义，但让我们来理解为什么会有星图投影，以及我们如何利用这个概念。使用星形投影有多种原因/场景:</p><ol class=""><li id="8594" class="lk ll hi is b it iu ix iy jb lm jf ln jj lo jn lp lq lr ls bi translated">我们不知道要指定的类型(这很简单！)</li><li id="aa71" class="lk ll hi is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated">对于用参数T声明的泛型类，我们对使用签名中有T的函数不感兴趣</li><li id="dd4e" class="lk ll hi is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls bi translated">我们不想意外地使用特定的函数！</li></ol><p id="fa2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们通过一些代码示例来了解一下。我鼓励在您的IDE中尝试这个示例代码，并立即看到不同之处:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="5931" class="mh ki hi md b fi mi mj l mk ml"><strong class="md hj">class </strong>Foo&lt;<strong class="md hj">in </strong>T&gt; {<br/><br/>    <strong class="md hj">fun </strong>accept(value: T){<br/>        <em class="mm">println</em>(value)<br/>    }<br/>}</span><span id="1488" class="mh ki hi md b fi mn mj l mk ml"><strong class="md hj">fun </strong>&lt;T&gt; usingFoo(con: Foo&lt;T&gt;, t: T){<br/>    con.accept(t) //Allowed<br/>}</span><span id="354a" class="mh ki hi md b fi mn mj l mk ml"><strong class="md hj">fun </strong>usingFooStar(con: <strong class="md hj">Foo&lt;*&gt;</strong>, t: Any){<br/>    <strong class="md hj">con.accept(t)   // Not Allowed</strong><br/>}</span></pre><p id="7cb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在上面的示例代码中所看到的，<strong class="is hj">我们只能在拥有特定类型</strong>时使用签名中带有T的方法。我们先来理解一下这为什么有意义。</p><p id="3e97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们使用星形投影时，编译器不知道它的类型。因此，任何依赖于验证类型的东西都不再安全。如果某些东西在编译时工作，而在运行时失败，这又是一个麻烦。</p><p id="99af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来看看当你使用这些方法时，什么是特定类型和星形投影所允许的，并阐明为什么某些事情是不允许的。</p><p id="e7a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用类型声明了Foo，并使用Foo 方法使用了<strong class="is hj">:</strong></p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="8269" class="mh ki hi md b fi mi mj l mk ml">//Case 1(Valid): Foo is declared with Number type &amp; 7 is Int which is Subtype of Number.</span><span id="f57b" class="mh ki hi md b fi mn mj l mk ml"><strong class="md hj">val </strong>fooNum : Foo&lt;Number&gt; = Foo()<br/>usingFoo(fooNum, 7) </span><span id="c620" class="mh ki hi md b fi mn mj l mk ml">//Case 2(Invalid &amp; Compile time failure): Foo is declared with type Int and we are trying to store a Double which is NOT Subtype of Int</span><span id="facd" class="mh ki hi md b fi mn mj l mk ml"><strong class="md hj">val </strong>fooNum : Foo&lt;Int&gt; = Foo()<br/>usingFoo<strong class="md hj">(fooNum, 7.0)</strong></span></pre><p id="554d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们使用FooStar 方法来使用<strong class="is hj"/></p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="4169" class="mh ki hi md b fi mi mj l mk ml">//Case 3(No compile time failure here but you are <strong class="md hj">not allowed to use accept method from Foo class as mentioned above</strong>!)</span><span id="f8cc" class="mh ki hi md b fi mn mj l mk ml"><strong class="md hj">val </strong>fooString : Foo&lt;String&gt; = Foo()<br/>usingFooStar(fooString, 7)</span><span id="b902" class="mh ki hi md b fi mn mj l mk ml">//Case 4(No compile time failure here but you are <strong class="md hj">not allowed to use accept method from Foo class as mentioned above</strong>!)</span><span id="6469" class="mh ki hi md b fi mn mj l mk ml"><strong class="md hj">val </strong>fooAny : Foo&lt;*&gt; = Foo&lt;Any&gt;()<br/>usingFooStar(fooAny, 7)</span></pre><p id="734b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我现在让你明白为什么编译器阻止你使用签名中有T的方法！如果我们允许调用类型相关的方法，那么它们将在运行时失败，因为我们无法验证类型。</p><h2 id="fd60" class="mh ki hi bd kj mo mp mq kn mr ms mt kr jb mu mv kv jf mw mx kz jj my mz ld na bi translated">与通配符的比较</h2><p id="b599" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">Kotlin博客没有Java参考是不完整的，你看:)</p><p id="321a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">科特林的星形投影类似于我们以类似方式使用的无界通配符:</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/813fa15bc86a2eafe3b658ccb2884f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vtdoDe925bQXKq16cOmRWw.png"/></div></div></figure><p id="6256" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可能需要注意的一点是，在Java代码中，我们允许为Foo <t>或Foo &gt;传递null，但在Kotlin中不允许，除非我们显式地将它们标记为可选的。我想这也是Kotlin官方博客用这句话传达的意思:</t></p><p id="1c67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">星形投影非常像Java的原始类型，但是很安全。</strong></p><p id="e7bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这篇短文能澄清恒星投影的细节。添加一些有用的资源，帮助我更好地理解这些主题。</p><h2 id="976e" class="mh ki hi bd kj mo mp mq kn mr ms mt kr jb mu mv kv jf mw mx kz jj my mz ld na bi translated">资源</h2><div class="jo jp ez fb jq jr"><a href="https://stackoverflow.com/questions/48172314/kotlin-star-projection-on-contravariant-types" rel="noopener  ugc nofollow" target="_blank"><div class="js ab dw"><div class="jt ab ju cl cj jv"><h2 class="bd hj fi z dy jw ea eb jx ed ef hh bi translated">逆变型柯特林星投影</h2><div class="jy l"><h3 class="bd b fi z dy jw ea eb jx ed ef dx translated">让我们来理解一下为什么逆变消费的星空投影等同于。但在那之前，我们…</h3></div><div class="jz l"><p class="bd b fp z dy jw ea eb jx ed ef dx translated">stackoverflow.com</p></div></div><div class="ka l"><div class="nc l kc kd ke ka kf io jr"/></div></div></a></div><div class="jo jp ez fb jq jr"><a href="https://kotlinlang.org/docs/generics.html#star-projections" rel="noopener  ugc nofollow" target="_blank"><div class="js ab dw"><div class="jt ab ju cl cj jv"><h2 class="bd hj fi z dy jw ea eb jx ed ef hh bi translated">泛型:in，out，where | Kotlin</h2><div class="jy l"><h3 class="bd b fi z dy jw ea eb jx ed ef dx translated">Kotlin中的类可以有类型参数，就像Java中一样:class Box (t: T) { var value = t }创建一个实例…</h3></div><div class="jz l"><p class="bd b fp z dy jw ea eb jx ed ef dx translated">kotlinlang.org</p></div></div><div class="ka l"><div class="nd l kc kd ke ka kf io jr"/></div></div></a></div><p id="6e82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本系列的第1和第2部分:</p><div class="jo jp ez fb jq jr"><a rel="noopener follow" target="_blank" href="/codex/generics-in-java-part-1-e6a2d74745cd"><div class="js ab dw"><div class="jt ab ju cl cj jv"><h2 class="bd hj fi z dy jw ea eb jx ed ef hh bi translated">Java中的泛型(第1部分)</h2><div class="jy l"><h3 class="bd b fi z dy jw ea eb jx ed ef dx translated">泛型在Java和Kotlin中都是一个强大的特性，可以帮助您编写类型安全的可伸缩代码。然而，我发现…</h3></div><div class="jz l"><p class="bd b fp z dy jw ea eb jx ed ef dx translated">medium.com</p></div></div><div class="ka l"><div class="kb l kc kd ke ka kf io jr"/></div></div></a></div><div class="jo jp ez fb jq jr"><a rel="noopener follow" target="_blank" href="/codex/generics-in-kotlin-part-2-6e87f9b2e8ac"><div class="js ab dw"><div class="jt ab ju cl cj jv"><h2 class="bd hj fi z dy jw ea eb jx ed ef hh bi translated">Kotlin中的泛型(第2部分)</h2><div class="jy l"><h3 class="bd b fi z dy jw ea eb jx ed ef dx translated">欢迎阅读泛型系列的第2部分。</h3></div><div class="jz l"><p class="bd b fp z dy jw ea eb jx ed ef dx translated">medium.com</p></div></div><div class="ka l"><div class="kg l kc kd ke ka kf io jr"/></div></div></a></div></div></div>    
</body>
</html>