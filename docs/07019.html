<html>
<head>
<title>Python 3.11: Unpacking Five New Features.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.11:解包五个新特性。</h1>
<blockquote>原文：<a href="https://medium.com/codex/python-3-11-unpacking-five-new-features-ca05925f5495?source=collection_archive---------0-----------------------#2022-05-25">https://medium.com/codex/python-3-11-unpacking-five-new-features-ca05925f5495?source=collection_archive---------0-----------------------#2022-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/df774b33a1f4db0d070e95cf6ff4a57e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e_j-ScJizgzRAiSOlx-Ulw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片由SHVETS制作:<a class="ae iu" href="https://www.pexels.com/photo/young-relocating-lady-packing-carton-boxes-sitting-on-floor-7203812/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/young-搬迁-女士-打包-纸箱-盒子-坐在地板上-7203812/ </a></figcaption></figure><p id="943e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python 3.11就要发布了，每个新版本都有新的特性。在本文中，我们将看看Python 3.11的五(5)个很酷的新特性，你应该期待一下。</p><h1 id="5782" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">1.比前一版本快60%</h1><p id="477f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Python 3.11预计比Python 3.10快60%，具体取决于您的工作负载。平均而言，在启动和运行时间方面，预计它将比以前的版本快25%。为了证实这一点，我用Python 3.11和Python 3.10运行了相同的代码，并比较了执行时间。运行时结果证实Python 3.11比以前的版本快得多。请参见下面的代码:</p><p id="dd5a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用Python 3.10</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/d22335e1d5eb57271f5a334b28627245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w80wXHRGWYi7DMWq"/></div></div></figure><p id="dd31" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">执行时间为5.50秒。</p><p id="1ad2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用Python 3.11</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/0d12e04d27d9910b77aaadd2abc2d678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mf4pekDlIPZBHt9D"/></div></div></figure><p id="55cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">执行时间为2.14秒。</p><h1 id="3761" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">2.改进了回溯中的错误位置</h1><p id="84dd" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了演示这一新特性，我们将使用两个示例。我们将使用Python 3.10运行第一个示例，使用Python 3.11运行第二个示例。这两个代码都会产生错误。请注意错误消息中的差异。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/57b3a072c4c0ae7635dddb720f984394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HXKPter8RPtTw9t3"/></div></div></figure><p id="dbb5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">例二</strong></p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/8e88191f4735a101df0bcf81b007acfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ikKdrwOQLSiNZTG-"/></div></div></figure><p id="264d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以上两个代码都输出零除法误差。第一个例子只返回有错误的行(c = a/b ),但是它没有具体说明错误的确切原因。在第二个示例(使用Python 3.11)中，它不仅返回有错误的行，而且还指向代码中导致错误的实际元素，即除法(/)符号。</p><h1 id="0ade" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">3.用自身类型注释代码</h1><p id="f526" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在以前的Python版本中，如果想要注释返回类实例的方法，可以使用类型模块的TypeVar类。Python 3.11增加了一种新的直观方式来注释方法，而不使用基于类型变量的方法。下面的第一段代码演示了如何实现基于TypeVar的方法。第二段代码演示了使用self类型的新Python 3.11方法。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/051e2a5fa4a6612fd3f7673917a8df93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WckTpA0T_MBVt4sY"/></div></div></figure><p id="1efd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Python 3.11中，您将使用Self类型注释类的方法。你可以在下面看到Python 3.11的方法使得代码更加简洁易懂。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/3d40c31eca425dcf7a65f7b477c41c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tBHz_nVMLvyU5Rnk"/></div></div></figure><h1 id="68d7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">4.用异常组处理多个异常</h1><p id="6a7b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Python 3.11将包含一个新的内置异常类型，称为ExceptionGroup。这种异常类型令人兴奋的地方在于，它可以同时引发多个不同的异常或错误。ExceptionGroup接受两个参数，一个字符串，然后是我们希望引发和处理的一系列错误。参见下面的代码:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/7ec1f6f917a3dd24d373c7f151e9acf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0oiB1uZkrHF-00W_"/></div></div></figure><p id="a96e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们抛出错误，我们可以使用新的except*块来处理错误。见下文:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/31f9a83babcb6502a7dcbac28a6afb54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ga2tXWjv8XvhlpTJ"/></div></div></figure><p id="e948" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">except*还可以对多个异常进行分组。有关这一全新内置标准的更多信息，请查看以下链接:</p><h1 id="e1ee" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">5.TypeDict必需和非必需键。</h1><p id="5163" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Python 3.8在类型模块中引入并添加了TypedDict。TypedDict类型使得用特定的键和值创建字典成为可能。然而，如果我们希望某些信息在字典中是可选的，那么用TypedDict实现就不容易了。让我们用一个例子来说明这一点。我们将创建一个包含三(3)个关键字的字典—姓名、年龄和汽车。见下文:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/927adf399763f0d3b7f4c6550752bdf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/0*vQZY2Vzd5r8-jQFw"/></div></figure><p id="2b25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的字典需要这个人的姓名、年龄和驾驶的汽车。但是，我们想让汽车信息可选，因为不是每个人都有车。为了在Python 3.10或更早的版本中实现这一点，我们必须创建另一个类(子类)来实现可选键。在以前的Python版本中，这是唯一的方法。下面是代码的样子:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/0c8f2c1cfd351e8696e700650f8f3a97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SSVtBZyGP-pzCsNk"/></div></div></figure><p id="1a8b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，total是false，因为这个车钥匙现在是可选的。如果有人没有汽车，他们可以省略汽车部分。</p><p id="f845" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python 3.11引入了<em class="lh">必需的</em>和<em class="lh">非必需的</em>类型来解决这类问题。使用这些类型(<em class="lh"> Required </em>和<em class="lh"> NotRequired </em>，我们不必创建一个子类来实现一个可选键，相反，我们可以将可选键注释为<em class="lh"> NotRequired </em>。见下文:</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/1aa81aa5e7d562320f61f7379df532b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ShYyS2aPpQo7-2Sp"/></div></div></figure><h1 id="1fa5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论。</h1><p id="14c8" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这些是Python 3.11中的一些新特性。Python 3.11的beta预览版于2022年5月8日发布。Python的最终版本预计将于2022年10月发布。请分享文章，关注我，订阅在我发表文章时获得通知。</p></div></div>    
</body>
</html>