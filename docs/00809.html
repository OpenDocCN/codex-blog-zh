<html>
<head>
<title>Realistic TDD: How I Adapt Test-Driven Development for My Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现实的TDD:我如何为我的项目适应测试驱动的开发</h1>
<blockquote>原文：<a href="https://medium.com/codex/realistic-tdd-how-i-adapt-test-driven-development-for-my-projects-964fed9014e4?source=collection_archive---------6-----------------------#2021-03-20">https://medium.com/codex/realistic-tdd-how-i-adapt-test-driven-development-for-my-projects-964fed9014e4?source=collection_archive---------6-----------------------#2021-03-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="dcc7" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><p id="cf42" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">测试驱动开发(TDD)一直是我的大学课程中涉及软件开发的首选软件开发过程(例如，用Django进行web编程，用Java Springboot进行微服务)，所以术语红绿重构现在可能已经在我的每个朋友中根深蒂固了。我班上的任何人都可以轻松地解释TDD的哲学和方法论。</p><p id="67a1" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">但是你实际上如何使用TDD编码呢？</strong></p><p id="5679" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">什么…你是什么意思？</p><p id="4c56" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">在这篇文章中，我将讨论我作为一个年轻的软件开发人员尝试刚性TDD时遇到的问题，以及我如何做出一些调整，使TDD实际上比普通编码更快、更安全。</p><h1 id="608e" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">TDD快速回顾</h1><p id="9a89" class="pw-post-body-paragraph io ip hi iq b ir kk it iu iv kl ix iy iz km jb jc jd kn jf jg jh ko jj jk jl hb bi translated">测试驱动开发是一个进化的软件开发过程，由Kent Beck在90年代后期开发。本质上，你是一点一点地构建你的软件，每一部分都有三个阶段:</p><ul class=""><li id="4b57" class="kp kq hi iq b ir is iv iw iz kr jd ks jh kt jl ku kv kw kx bi translated"><strong class="iq hs">红色</strong>:为你的下一个作品创建测试。当然，现在运行测试会报告一个错误(又名红色)，因为您没有这个测试的实现。</li><li id="018f" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated"><strong class="iq hs">绿色</strong>:对之前测试的实现进行编码，直到通过为止。现在，运行测试将不会报告错误(绿色)。</li><li id="4883" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated"><strong class="iq hs">重构</strong>:重构刚刚实现的代码，使其结构良好。</li></ul><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es ld"><img src="../Images/25ce57180b4dd418332e2f9779ac21e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*-CAyRyPSSg-29v3kqvKoEQ.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">TDD周期</figcaption></figure><p id="d6ed" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">根据我的理解，TDD的目标是:</p><ul class=""><li id="be3a" class="kp kq hi iq b ir is iv iw iz kr jd ks jh kt jl ku kv kw kx bi translated">测试对于你编写的每一个代码都是可用的，减少了错误的可能性。</li><li id="93e9" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">软件代码最终是结构良好的，程序流易于阅读和理解。</li><li id="1e28" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">减少创建测试的时间。在运行中创建许多简单的测试是很累的，无论是身体上还是精神上，然后查看一个大的代码库并找出下一步要测试什么。</li></ul><p id="7709" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">TDD在理论上听起来真的很好，而且确实如此！它提供了一个框架，可以缓慢但稳定地开发大型结构化软件，否则会导致十亿个bug。</p><h1 id="59f9" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">TDD示例</h1><p id="e13e" class="pw-post-body-paragraph io ip hi iq b ir kk it iu iv kl ix iy iz km jb jc jd kn jf jg jh ko jj jk jl hb bi translated">目前，我正在使用Golang为我的软件项目开发登录功能。其中一个重要的功能是散列密码，因为在某些国家存储纯文本密码是非法的。</p><p id="d05a" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">假设我已经得到了散列函数。酷！现在让我们编写验证散列的代码。由于它的TDD，让我们先做测试:</p><pre class="le lf lg lh fd lp lq lr ls aw lt bi"><span id="e33a" class="lu jn hi lq b fi lv lw l lx ly">// Positive test<br/>func <strong class="lq hs">TestHashVerifyIsCorrect</strong>(t *testing.T) {</span><span id="6ac9" class="lu jn hi lq b fi lz lw l lx ly">  hashedString, _ := Hash("fragrance in thaw")</span><span id="dc4f" class="lu jn hi lq b fi lz lw l lx ly">  assert.Equal(t, true, Verify(hashedString, "fragrance in thaw"))<br/>}<br/></span><span id="7e2d" class="lu jn hi lq b fi lz lw l lx ly">// Negative test<br/>func <strong class="lq hs">TestHashVerifyIsWrong</strong>(t *testing.T) {<br/>  hashedString, _ := Hash("fragrance in thaw")</span><span id="4e57" class="lu jn hi lq b fi lz lw l lx ly">  assert.Equal(t, false, Verify(hashedString, "Fragrance in thaw"))<br/>}</span></pre><p id="ab29" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">非常简单。第一个测试检查它是否可以验证相同的字符串，第二个测试检查它是否可以捕获不同的字符串(否则，我可以对代码“返回true”)。</p><p id="12da" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">测试完成了！现在我们创建实现</p><pre class="le lf lg lh fd lp lq lr ls aw lt bi"><span id="3fec" class="lu jn hi lq b fi lv lw l lx ly">func <strong class="lq hs">Verify</strong>(hashed string, actual string) bool <strong class="lq hs">{</strong></span><span id="5aa1" class="lu jn hi lq b fi lz lw l lx ly">  err := bcrypt.CompareHashAndPassword([]byte(hashed), []byte(actual))</span><span id="17e4" class="lu jn hi lq b fi lz lw l lx ly">  return err == nil</span><span id="1e13" class="lu jn hi lq b fi lz lw l lx ly">}</span></pre><p id="43e3" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">实现变得非常简单。当哈希与密码不匹配时，我使用的库函数(bcrypt)会返回一个错误。所以我们检查误差是否为零。</p><p id="0bf2" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">就是这样！这就是你如何使用TDD开发代码。那么，为什么这篇文章的滚动条仍然在顶部附近呢？</p><h1 id="4039" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">棘手的</h1><p id="6601" class="pw-post-body-paragraph io ip hi iq b ir kk it iu iv kl ix iy iz km jb jc jd kn jf jg jh ko jj jk jl hb bi translated">当你意识到这一原则是由专业编码人员创建的，而我最大的“项目”是一个简单的照片存储网站。当测试已经很简单的功能时，TDD可以无缝地工作。当您按照TDD原则进行开发时，迷惑就开始出现了:</p><h2 id="1b40" class="lu jn hi bd jo ma mb mc js md me mf jw iz mg mh ka jd mi mj ke jh mk ml ki ho bi translated">1.测试是错误的</h2><p id="68a7" class="pw-post-body-paragraph io ip hi iq b ir kk it iu iv kl ix iy iz km jb jc jd kn jf jg jh ko jj jk jl hb bi translated">在软件开发课程中，你需要对你制定的每个TDD原则做出承诺。即:创建测试-&gt;提交<strong class="iq hs">【红色】</strong> - &gt;创建代码- &gt;提交<strong class="iq hs">【绿色】</strong> - &gt;重构- &gt;提交<strong class="iq hs">【重构】</strong>。那么，当您提交red，编写实现代码，然后仍然是RED时会发生什么呢？</p><p id="f7c8" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">这是我在项目中实际遇到的一个案例。还记得之前的测试吗？这是<strong class="iq hs"> TestHashVerifyIsCorrect </strong>的原始实现</p><pre class="le lf lg lh fd lp lq lr ls aw lt bi"><span id="57c3" class="lu jn hi lq b fi lv lw l lx ly">func <strong class="lq hs">TestHashVerifyIsCorrect</strong>(t *testing.T) {</span><span id="5d8d" class="lu jn hi lq b fi lz lw l lx ly">  hashedString, _ := Hash("fragrance in thaw")</span><span id="b077" class="lu jn hi lq b fi lz lw l lx ly">  assert.Equal(t, true, Verify(hashedString, "fragrances in thaw"))<br/>}</span></pre><p id="bb28" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我创建了这个，提交，编码实现，运行测试，然后…测试失败了。在我的实现中经过大量的调试打印语句后，我意识到大约15分钟后测试中出现了错误。</p><p id="929f" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">所以这意味着我要修改测试，对吗？</p><p id="aaeb" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">"<strong class="iq hs">不</strong>，红色之后必须提交绿色&gt; :(" — TDD古鲁，大概</p><p id="42ae" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">有些人可能会说，我需要像开发源代码一样关注创建测试。很公平，上面的错误是我的。那另一个案子呢。</p><p id="c751" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">下面是我在为登录系统开发JWT令牌生成时所做的测试。</p><pre class="le lf lg lh fd lp lq lr ls aw lt bi"><span id="eb11" class="lu jn hi lq b fi lv lw l lx ly">func <strong class="lq hs">TestCreateTokenShouldGiveCorrectPayload</strong>(t *testing.T) {</span><span id="5045" class="lu jn hi lq b fi lz lw l lx ly">  token := GetToken(12, 6, 5)</span><span id="203e" class="lu jn hi lq b fi lz lw l lx ly">  payloadBase64 := strings.Split(token, ".")[1]</span><span id="1e9e" class="lu jn hi lq b fi lz lw l lx ly">  payloadBytes, _ := base64.StdEncoding.DecodeString(payloadBase64)<br/>  var payload map[string]interface{}</span><span id="9fcf" class="lu jn hi lq b fi lz lw l lx ly">  err := json.Unmarshal(payloadBytes, &amp;payload)<br/>  assert.Nil(t, err, "unmarshall must not be error")</span><span id="398c" class="lu jn hi lq b fi lz lw l lx ly">  payloadUID := payload["uid"].(int64)<br/>  payloadRole := payload["role"].(int64)<br/>  assert.Equal(t, 12, payloadUID, "payload UID must be equal")<br/>  assert.Equal(t, 6, payloadRole, "payload role must be equal")<br/>}</span></pre><p id="5341" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">基本上，我的测试创建了一个令牌，并验证令牌的有效负载部分是否与预期的有效负载相匹配。Go程序员应该很快就会在这个测试中看到几个错误，但这个问题真的很棒。</p><p id="4068" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我的代码成功地生成了令牌。但是，<code class="du mm mn mo lq b">payload</code>的字符串值缺少右花括号语句。例如:</p><pre class="le lf lg lh fd lp lq lr ls aw lt bi"><span id="578c" class="lu jn hi lq b fi lv lw l lx ly">{uid: 12, role:6, iss: 123456</span></pre><p id="ce9e" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我尝试打印整个令牌，并通过在<a class="ae mp" href="http://jwt.io" rel="noopener ugc nofollow" target="_blank"> jwt.io </a>和<a class="ae mp" href="https://www.base64decode.org/" rel="noopener ugc nofollow" target="_blank">www.base64decode.org</a>解码来验证有效载荷。两者都用结束括号正确解码。然而，不知何故，我的测试总是漏掉它。我断定Go的base64解码器可能是罪魁祸首，翻了翻文件，什么也没找到。</p><p id="3531" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">随机地，我意识到base64不应该以' = '结尾吗？我试图在<code class="du mm mn mo lq b">payloadBase64</code>的末尾添加一个等号，它成功地解码成我想要的方式。这种行为真的很奇特，我想很多人在创建类似的测试时都会被难倒。</p><p id="8057" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">哦，是的，这个JWT的演讲把我们带到了下一个棘手的问题。</p><h2 id="9a42" class="lu jn hi bd jo ma mb mc js md me mf jw iz mg mh ka jd mi mj ke jh mk ml ki ho bi translated">2.使用不熟悉的实体</h2><p id="8340" class="pw-post-body-paragraph io ip hi iq b ir kk it iu iv kl ix iy iz km jb jc jd kn jf jg jh ko jj jk jl hb bi translated">我对JWT的了解仍然不多，因为我没有和JWT一起工作过。事实上，在开发登录系统的前几天，我才知道JWT没有用秘密密钥签署有效载荷(谢谢，队友阿克巴)。</p><p id="a071" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">这个问题变得更加严重，因为在我看来，Go上可用的JWT库是反直觉的。我发现的最发达的库是jwt-go，天哪，它太复杂了。</p><p id="5831" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我<strong class="iq hs">可以</strong>马上<strong class="iq hs">T5】做一个测试，假设我的GetToken()会返回一个完整的JWT令牌，但是在看到生成JWT令牌的代码片段后，我发现了很多组件，比如:</strong></p><ul class=""><li id="d9a7" class="kp kq hi iq b ir is iv iw iz kr jd ks jh kt jl ku kv kw kx bi translated">JWT标准索赔公司</li><li id="8e45" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">JWT海关索赔</li><li id="8882" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">JWT令牌回拨</li><li id="9980" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">JWT签名</li></ul><p id="9802" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">既然TDD必须是一部分一部分的，我应该首先为这些组件中的每一个创建测试吗？但我不确定他们的行为:(。如果这些只是内部组件，我不需要对它们进行测试怎么办？AAAA很不确定:“(</p><h1 id="83b2" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">有些人是如何适应的</h1><p id="fe05" class="pw-post-body-paragraph io ip hi iq b ir kk it iu iv kl ix iy iz km jb jc jd kn jf jg jh ko jj jk jl hb bi translated">这些是我大约两年前第一次开始使用TDD时遇到的问题。我询问了我的同事如何处理这些问题，他们中的大多数人似乎都有相同的黄金解决方案:</p><blockquote class="mq mr ms"><p id="90df" class="io ip mt iq b ir is it iu iv iw ix iy mu ja jb jc mv je jf jg mw ji jj jk jl hb bi translated">首先编码实现，但是首先提交和推送测试</p></blockquote><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="er es mx"><img src="../Images/624c192817e9612fc74e47e77772e342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbv14BYyt3wpuTFVd1Fd4Q.jpeg"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">当一个大型软件是用TDD或者这种阴暗面方法构建的时候，很容易判断出来。</figcaption></figure><p id="5043" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">希望你现在知道我在说什么了。我们不断地提倡要<strong class="iq hs">做</strong> TDD。然而，要真正遵循这个原则是相当困难的。当TDD应该是一个简化软件开发的过程时，它却成了一个障碍。</p><h1 id="2590" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">我如何适应这一点</h1><p id="4c55" class="pw-post-body-paragraph io ip hi iq b ir kk it iu iv kl ix iy iz km jb jc jd kn jf jg jh ko jj jk jl hb bi translated">大约一年前，当我使用springboot开发一个LINE chatbot时，我第一次认真对待TDD。这个项目非常大，有大量相互关联的组件。起初，我计划走正常路线，在最后编写测试。然而，我可以看到我的应用程序的走向，并说:“嘿，为什么不是TDD？”</p><p id="5de4" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">因为这个项目更加自由，并没有规定你必须进行严格的TDD，所以我在尊重TDD意图的同时，对这个原则做了<strong class="iq hs">小小的修改</strong>。结果棒极了。尽管我每周做50多个小单元测试，我的开发实际上加速了<strong class="iq hs"> </strong>因为<strong class="iq hs">我吸取了两个世界的精华</strong>:</p><ul class=""><li id="d6b0" class="kp kq hi iq b ir is iv iw iz kr jd ks jh kt jl ku kv kw kx bi translated">TDD的行为指导:创建小的行为测试来指导我开发大型软件。当编码时，我仍然不确定整体逻辑将会如何，但是使用TDD，我只是不断地创建小组件，这些组件粘在一起，直到有一天:“嗯？app做好了？”</li><li id="0926" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">DDT的确定性和速度(与TDD相反):TDD的主要弱点是与不熟悉的实体一起工作时的不确定性。我的修改去掉了这个。有时候，你只需要一点点速度就够了。</li></ul><p id="e872" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">免责声明:我绝不声明我的改编是革命性的。我也没有说它是原创的，因为这些天似乎一切都被发现了。事实上，这是一个<strong class="iq hs">简单的</strong>改编。但是，它将TDD变成了一个实际上更快更容易的软件开发原则。</p><p id="26ed" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我将通过回答我在文章开头提出的问题来展示我的改编。</p><h2 id="d54a" class="lu jn hi bd jo ma mb mc js md me mf jw iz mg mh ka jd mi mj ke jh mk ml ki ho bi translated">1.测试是错误的</h2><p id="1925" class="pw-post-body-paragraph io ip hi iq b ir kk it iu iv kl ix iy iz km jb jc jd kn jf jg jh ko jj jk jl hb bi translated">这个很简单:</p><ul class=""><li id="a7ad" class="kp kq hi iq b ir is iv iw iz kr jd ks jh kt jl ku kv kw kx bi translated">修复测试</li><li id="1234" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">运行测试。现在所有的测试都应该成功了，因为我们对实现进行了编码。</li><li id="4896" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">在<strong class="iq hs">测试中再次提交红色。</strong></li><li id="b749" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">承诺绿色实施。</li><li id="2435" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">忽略我头脑中所有的声音，因为还有软件要编码，那些声音不会帮助你编码:(</li></ul><p id="98c5" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我有点倾向于黑暗的一面。我觉得这是必要的恶。当我创建了一个错误的测试时，我真的无能为力。</p><h2 id="05b1" class="lu jn hi bd jo ma mb mc js md me mf jw iz mg mh ka jd mi mj ke jh mk ml ki ho bi translated">2.使用不熟悉的实体</h2><p id="018c" class="pw-post-body-paragraph io ip hi iq b ir kk it iu iv kl ix iy iz km jb jc jd kn jf jg jh ko jj jk jl hb bi translated">这是一个大的。在进行测试之前，我通过在我想要开发的方法<strong class="iq hs">上写一些测试驱动代码来处理这个问题。</strong></p><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es nc"><img src="../Images/25075dff108506ca4aa719da91d0acaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*02n5nIMSwLwiYfqHrobXGw.jpeg"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">写这篇文章的时候，我已经可以听到警笛声了。</figcaption></figure><p id="8dca" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">测试驱动程序通常是“部分”实现，并且通常充满了日志打印语句。它的工作是让我感受那个实体。</p><p id="7d4d" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">好吧，我就跳到一个例子。</p><p id="4e4a" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">让我们回到以前讨论过的JWT问题。</p><p id="83ce" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">所以我尝试用一个不熟悉的库(jwt-go)创建一个方法GetToken。所以，在写测试之前，我在GetToken()上写了这样的东西</p><pre class="le lf lg lh fd lp lq lr ls aw lt bi"><span id="97de" class="lu jn hi lq b fi lv lw l lx ly">func <strong class="lq hs">GetToken</strong>(uid int, role int, expiresInHour int) string {<br/>  privateKey := "privatekey"</span><span id="7d03" class="lu jn hi lq b fi lz lw l lx ly">  claims := JwtClaim{<br/>    uid,<br/>    role,<br/>    jwt.StandardClaims{<br/>     ExpiresAt: time.Now().Local().Add(time.Hour *      time.Duration(expiresInHour)).Unix(),<br/>     Issuer:    "xxx",<br/>  },<br/> }<br/> <br/> fmt.Println(claims)</span><span id="7b73" class="lu jn hi lq b fi lz lw l lx ly"> token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)<br/> fmt.Println(token)</span><span id="2319" class="lu jn hi lq b fi lz lw l lx ly"> jwtToken, _ := token.SignedString(privateKey)<br/> fmt.Println(jwtToken)</span><span id="7c54" class="lu jn hi lq b fi lz lw l lx ly"> return jwtToken</span><span id="c735" class="lu jn hi lq b fi lz lw l lx ly">}</span></pre><p id="a734" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">这只是我从文档中获取的<a class="ae mp" href="https://pkg.go.dev/github.com/dgrijalva/jwt-go" rel="noopener ugc nofollow" target="_blank">令牌生成的<strong class="iq hs">最小修改</strong>。我添加了许多打印语句来感受每个组件。</a></p><p id="45fc" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">然后，我创建一个测试代码来运行这个方法:</p><pre class="le lf lg lh fd lp lq lr ls aw lt bi"><span id="e699" class="lu jn hi lq b fi lv lw l lx ly">func <strong class="lq hs">TestCreateTokenShouldGiveCorrectPayload</strong>(t *testing.T) {</span><span id="d1cb" class="lu jn hi lq b fi lz lw l lx ly"> token := GetToken(12, 6, 5)</span><span id="710d" class="lu jn hi lq b fi lz lw l lx ly"> fmt.Println(token)<br/>}</span></pre><p id="e222" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">运行这个应该会给出很多打印语句。从这里，我知道:</p><ul class=""><li id="2dca" class="kp kq hi iq b ir is iv iw iz kr jd ks jh kt jl ku kv kw kx bi translated">JWT库上的组件非常轻，不需要进行单独的测试。</li><li id="0e65" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">token.signString()返回整个令牌，而不仅仅是签名的部分。</li><li id="d482" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">我不需要复杂的回调，只需要签署一个令牌。所以还是那句话，没必要先开发回调。</li></ul><p id="2c82" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">就这样，不确定性消失了。现在，我知道我不需要创建单独的组件。现在，我可以为这个方法编写实际的测试了。最终产品是这样的:</p><pre class="le lf lg lh fd lp lq lr ls aw lt bi"><span id="71ff" class="lu jn hi lq b fi lv lw l lx ly">func TestCreateTokenShouldGiveCorrectPayload(t *testing.T) {</span><span id="2cb2" class="lu jn hi lq b fi lz lw l lx ly">  token := GetToken(12, 6, 5)</span><span id="dbbe" class="lu jn hi lq b fi lz lw l lx ly">  payloadBase64 := strings.Split(token, ".")[1]<br/>  payloadBase64 += "=" //Go's base64 decoder needs = at the end</span><span id="e00f" class="lu jn hi lq b fi lz lw l lx ly">  payloadBytes, _ := base64.StdEncoding.DecodeString(payloadBase64)<br/>  var payload map[string]interface{}</span><span id="409a" class="lu jn hi lq b fi lz lw l lx ly">  err := json.Unmarshal(payloadBytes, &amp;payload)<br/>  assert.Nil(t, err, "unmarshall must not be error")<br/>  <br/>  payloadUID := payload["uid"].(float64)<br/>  payloadRole := payload["role"].(float64)</span><span id="0237" class="lu jn hi lq b fi lz lw l lx ly">  assert.Equal(t, 12, int(payloadUID), "payload UID must be equal")<br/>  assert.Equal(t, 6, int(payloadRole), "payload role must be equal")<br/>}</span></pre><p id="2f0d" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">很简单，对吧？生成令牌，获取有效负载部分，解码它，最后检查它是否与预期的有效负载匹配。总的来说，我花了大约20分钟来实现所有这些(从编写测试驱动，到编写实际测试，再到编写实际实现)。</p><p id="1cf9" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">也就这样了！那是我对TDD的简单适应。每当我与不熟悉的实体一起工作时，我只是写一些测试代码来获得感觉，然后回到TDD。</p><h1 id="358a" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">我的TDD在行动</h1><p id="303b" class="pw-post-body-paragraph io ip hi iq b ir kk it iu iv kl ix iy iz km jb jc jd kn jf jg jh ko jj jk jl hb bi translated">澄清一下，我<strong class="iq hs">很少</strong>做我之前说过的事情，只有在我处理不熟悉的东西的时候。但是，有这样做的选择真的很好。</p><p id="a424" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">当我不这样做的时候，就是教科书红绿重构。创建测试-&gt;实现代码-&gt;重构。下面是我当前项目中的一个示例管道，我在这个项目中使用TDD来开发整个登录服务:</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="er es nd"><img src="../Images/4f6200054bb9143ea978d8ff3d0c29b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kTA4H2Fadg-vmXLF2ipJKQ.png"/></div></div></figure><p id="f863" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">首先要注意几件事:</p><ul class=""><li id="f2cb" class="kp kq hi iq b ir is iv iw iz kr jd ks jh kt jl ku kv kw kx bi translated">注意底部有两个红色标签。那就像我说的，测试有bug就犯双红。</li><li id="5102" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">顶部的杂务标签是用于更改配置文件的特殊标签(在go中是go.mod)</li></ul><p id="af36" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">消息被截断，因此开发顺序如下:</p><ol class=""><li id="1ef2" class="kp kq hi iq b ir is iv iw iz kr jd ks jh kt jl ne kv kw kx bi translated">当在数据库中找不到用户的电子邮件时，创建测试</li><li id="b76a" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ne kv kw kx bi translated">实施它</li><li id="8992" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ne kv kw kx bi translated">为用户输入无效密码时创建测试</li><li id="ffbc" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ne kv kw kx bi translated">实施它</li><li id="4420" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ne kv kw kx bi translated">为用户成功登录时创建测试</li><li id="5969" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ne kv kw kx bi translated">实施它</li></ol><p id="e488" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">像一二三一样简单。</p><h1 id="6bd1" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">结论</h1><p id="54b7" class="pw-post-body-paragraph io ip hi iq b ir kk it iu iv kl ix iy iz km jb jc jd kn jf jg jh ko jj jk jl hb bi translated">我无法想象在没有TDD的情况下构建我的大型项目。TDD是一个令人惊叹的框架，但是它的僵化让一些人感到害怕。每当我感到不确定时，通过编写一个简单的测试驱动程序，我可以无缝地开发应用程序，同时仍然实现TDD的原则:</p><ul class=""><li id="8c8e" class="kp kq hi iq b ir is iv iw iz kr jd ks jh kt jl ku kv kw kx bi translated">每个开发的代码都有一个测试。</li><li id="c197" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">软件是由小的增量部分组成的，每一部分都经过了很好的测试。</li></ul><p id="69f5" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">仅此而已。希望通过阅读这篇文章，你会看到过去的僵化，并尝试TDD。</p><blockquote class="mq mr ms"><p id="a9f3" class="io ip mt iq b ir is it iu iv iw ix iy mu ja jb jc mv je jf jg mw ji jj jk jl hb bi translated">对我来说，TDD不是一个规则，而是一个指南。</p></blockquote><h1 id="9660" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">参考</h1><ul class=""><li id="0372" class="kp kq hi iq b ir kk iv kl iz nf jd ng jh nh jl ku kv kw kx bi translated"><a class="ae mp" href="https://www.oreilly.com/library/view/modern-c-programming/9781941222423/f_0055.html" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/library/view/modern-c-programming/9781941222423/f _ 0055 . html</a></li><li id="2f2c" class="kp kq hi iq b ir ky iv kz iz la jd lb jh lc jl ku kv kw kx bi translated">【https://github.com/janke-learning/tdd T4】(TDD图像)</li></ul></div></div>    
</body>
</html>