<html>
<head>
<title>Getting Started with Competitive Coding in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python竞争性编码入门</h1>
<blockquote>原文：<a href="https://medium.com/codex/getting-started-with-competitive-coding-in-python-8365d9cc64?source=collection_archive---------13-----------------------#2022-06-20">https://medium.com/codex/getting-started-with-competitive-coding-in-python-8365d9cc64?source=collection_archive---------13-----------------------#2022-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d988" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">本文将展示Python中基本的内置数据结构，这有助于我们在解决编程问题时节省时间。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/4adccb4284742a3bdbcb6929127cb523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c6kk4FHCSFw-Qg77oKW8BQ.png"/></div></div></figure><h1 id="8699" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">介绍</h1><p id="95a4" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">数据结构和算法(DSA)知识是计算机科学中成功职业道路的必要条件。无论我们以软件工程师、数据科学家还是机器学习工程师为例，他们都要求最低水平的DSA理解。几乎所有的公司都有一个最初的在线编码环节，在这个环节中他们会问DSA一些问题。除此之外，还有代码共享、白板讨论等。，这很考验编码技巧。</p><p id="d413" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">DSA面试一开始就让人望而生畏。受访者希望找到解决问题的最佳方法。因此，在我们的在线测试或面试中，我们可以更多地关注我们的算法，而不是专注于数据结构的实现。我的意思是，我们可以使用Python中内置的数据结构和它们的函数，这样可以省去从头编写它们的麻烦。为什么要重新发明轮子？</p><p id="9936" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">熟悉核心数据结构并了解关于它们的特定于Python的注意事项将使实现无缝。因此，本文将展示对我们的代码有帮助的最广泛使用的数据结构。</p><h1 id="d739" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated"><strong class="ak"> 1。堆栈</strong></h1><p id="21f5" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">堆栈遵循<em class="lc">后进先出</em>程序，其中先去的元素将首先被移除。堆栈具有以下基本功能。</p><ol class=""><li id="9cff" class="ld le hi kd b ke kx kh ky kk lf ko lg ks lh kw li lj lk ll bi translated"><strong class="kd hj">推送:</strong>将一个元素添加到栈顶。</li><li id="3cd4" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw li lj lk ll bi translated"><strong class="kd hj"> pop: </strong>取下顶部元件，放回原处。</li><li id="e396" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw li lj lk ll bi translated"><strong class="kd hj"> top: </strong>返回堆栈中的顶部元素。</li><li id="6cdb" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw li lj lk ll bi translated"><strong class="kd hj"> isEmpty: </strong>如果堆栈为空，则返回True。</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/2f9de349552dfbbe9bfd068b6b02e34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qD306tFbQGqT7nsdu0466A.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">图一。基本堆栈操作。</figcaption></figure><p id="ad75" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">上面提到的所有函数应该具有恒定的时间复杂度。在Python中，我们可以使用“列表”来实现堆栈。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="a6b6" class="mb jk hi lx b fi mc md l me mf"><strong class="lx hj"># stack initialization<br/></strong>stack = []</span><span id="b117" class="mb jk hi lx b fi mg md l me mf"><strong class="lx hj"># Push operation with O(1) time complexity <br/></strong>stack.append(4) </span><span id="2851" class="mb jk hi lx b fi mg md l me mf"><strong class="lx hj"># Pop operation with O(1) time complexity</strong><br/>top_element = stack.pop()</span><span id="3504" class="mb jk hi lx b fi mg md l me mf"><strong class="lx hj"># Top element with O(1) time complexity</strong><br/>top = stack[-1] </span><span id="8976" class="mb jk hi lx b fi mg md l me mf"><strong class="lx hj"># isEmpty O(1) time complexity<br/></strong>if len(stack) == 0:<br/>    print("stack is empty")</span></pre><h1 id="4589" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">2.行列</h1><p id="13e2" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">队列遵循先入先出策略，即先添加的元素将先被移除。队列具有以下基本功能。</p><ol class=""><li id="0971" class="ld le hi kd b ke kx kh ky kk lf ko lg ks lh kw li lj lk ll bi translated"><strong class="kd hj">推送:</strong>添加后方元素。(恒定时间复杂度)</li><li id="25df" class="ld le hi kd b ke lm kh ln kk lo ko lp ks lq kw li lj lk ll bi translated"><strong class="kd hj">弹出:</strong>从前面移除元素。(恒定时间复杂度)</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/07177742596fbd523d3138e08608c6b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kom37KljSiByvzuYOYxaA.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">图二。基本队列操作。</figcaption></figure><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="019f" class="mb jk hi lx b fi mc md l me mf"><strong class="lx hj"># import the deque module<br/></strong>from collections import deque </span><span id="b925" class="mb jk hi lx b fi mg md l me mf"><strong class="lx hj"># queue initialization<br/></strong>queue = deque([])</span><span id="366e" class="mb jk hi lx b fi mg md l me mf"><strong class="lx hj"># PUSH at end<br/></strong>queue.append(5)</span><span id="aea9" class="mb jk hi lx b fi mg md l me mf"><strong class="lx hj"># POP at starting<br/></strong>element = queue.popleft()</span></pre><p id="6853" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">Deque模块提供了另外两个对我们有用的函数。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="0cb3" class="mb jk hi lx b fi mc md l me mf"><strong class="lx hj"># PUSH at start<br/></strong>queue.appendleft(5)</span><span id="4f93" class="mb jk hi lx b fi mg md l me mf"><strong class="lx hj"># POP at end<br/></strong>element = queue.pop()</span></pre><h1 id="8c28" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">3.哈希映射</h1><p id="807f" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">Python有“字典”,它的工作方式类似于散列图。字典存储键值对。在Python中，字典的键只能是可哈希的值，比如int、str、tuple等。此外，一个字典可以有多种类型的键和值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/559e616b7bda2590615a71bf320c9cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Tn1krBE7hHHAPludjRyNw.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">图3。哈希映射。</figcaption></figure><p id="1409" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">一般来说，用“默认字典”代替普通字典是一个好习惯。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="d1d6" class="mb jk hi lx b fi mc md l me mf"><strong class="lx hj"># import the module<br/></strong>from collections import defaultdict </span><span id="ff3f" class="mb jk hi lx b fi mg md l me mf"><strong class="lx hj"># initialize the dict with default datatype of values.<br/></strong>hash_map = defaultdict(list) </span><span id="bfad" class="mb jk hi lx b fi mg md l me mf"><strong class="lx hj"># add elements in the dict<br/></strong>hash_map[x].append(y)</span><span id="3ab4" class="mb jk hi lx b fi mg md l me mf"><strong class="lx hj"># delete key = x<br/></strong>del hash_map[x]</span></pre><h1 id="c8a4" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">4.很</h1><p id="b4c6" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">堆是一个完整的二叉树，其中除了最后一层(即叶节点)之外的所有层都应该被填充，并且所有节点都应该左对齐。有两种类型的堆:(a) <strong class="kd hj">最小堆</strong> —父节点的值小于或等于其子节点的值，以及(b) <strong class="kd hj">最大堆</strong> —父节点的值大于或等于其子节点的值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/2d42c93e8773b421b088d6786f51a422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AoJpkpNOIahnQmXYzf9mqw.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">图4。最小和最大堆。</figcaption></figure><p id="ce0d" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">像堆栈一样，在Python中，没有单独的类来创建优先级队列或堆数据结构。相反，我们有一个"<a class="ae mk" href="https://docs.python.org/3/library/heapq.html" rel="noopener ugc nofollow" target="_blank"> heapq </a>"模块，它允许我们使用列表作为堆。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="85e7" class="mb jk hi lx b fi mc md l me mf"><strong class="lx hj"># import the module<br/></strong>import heapq</span><span id="1029" class="mb jk hi lx b fi mg md l me mf"><strong class="lx hj"># initializing a heap<br/></strong>heap = []</span><span id="ba93" class="mb jk hi lx b fi mg md l me mf"><strong class="lx hj"># push an element into the heap<br/></strong>heapq.heappush(heap, 10)</span><span id="7e70" class="mb jk hi lx b fi mg md l me mf"><strong class="lx hj"># pop an element value on top of the heap<br/></strong>element = heapq.heappop(heap)</span></pre><p id="93a8" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du ml mm mn lx b">heapq.heappush</code>和<code class="du ml mm mn lx b">heapq.heappop</code>将在我们用作堆的列表中维护<a class="ae mk" href="https://docs.python.org/3/library/heapq.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kd hj">最小堆不变量</strong> </a>。</p><h2 id="65e7" class="mb jk hi bd jl mo mp mq jp mr ms mt jt kk mu mv jv ko mw mx jx ks my mz jz na bi translated">将列表转换成堆(最小堆)。</h2><p id="5349" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我们可以创建一个空的列表，并用<strong class="kd hj"><em class="lc">“heapq . heap push”</em></strong>将元素推送到那个列表中。这种方法的时间复杂度是<strong class="kd hj"> <em class="lc"> O(NlogN) </em> </strong>，其中N是列表中元素的数量。一个更有效的方法是使用<a class="ae mk" href="https://docs.python.org/3/library/heapq.html" rel="noopener ugc nofollow" target="_blank"><strong class="kd hj">heapq . heapify</strong></a><strong class="kd hj">，</strong>来交换它的元素，使一个列表成为一个最小堆。而且heapq.heapify只需要<strong class="kd hj"> O(N) </strong>时间。</p><pre class="iy iz ja jb fd lw lx ly lz aw ma bi"><span id="884c" class="mb jk hi lx b fi mc md l me mf">arr = [42,15,4,22,100]<br/>heapq.heapify(arr)</span></pre><p id="c24b" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">如何使用最大堆？</p><p id="c410" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们可以将初始元素乘以-1，然后使用最小堆。这样，我们得到了根节点上的最大元素，或者说是最大元素的负数。当我们从堆中取出反转的数字时，我们再次将它乘以-1来得到我们的初始数字。</p><p id="9c83" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">如果需要比较多个字段来确定哪个元素更小或更大，可以考虑将堆的元素保存为元组。</p><h1 id="6b95" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">结论</h1><p id="621d" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">本文展示了Python中解决编程问题的四种最广泛使用的数据结构。除了数据结构，本文还提到了它们各自的功能。这篇文章可能是编程新手或想开始用Python编程的人的第一步。</p></div></div>    
</body>
</html>