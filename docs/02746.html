<html>
<head>
<title>7 Basic Algorithms Every Newbie Coder Should Know: Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个编程新手都应该知道的7个基本算法:第3部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/7-basic-algorithms-every-newbie-coder-should-know-part-3-dc25feb68f66?source=collection_archive---------5-----------------------#2021-08-03">https://medium.com/codex/7-basic-algorithms-every-newbie-coder-should-know-part-3-dc25feb68f66?source=collection_archive---------5-----------------------#2021-08-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8e37b7d2fbf09bf84feb76741cfcf580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KFqZsSSRbl98BCD7G--Yrw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片提供:<a class="ae iu" href="http://www.unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="e5e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">问候学习者！所以这篇文章将是我的小编《每个新手程序员都应该知道的7个基本算法》的结论。今天我们将讨论两个非常有趣并且在解决问题中广泛使用的算法，但是在此之前，我希望你们都去检查一下本系列的前两部分，如果你们还没有检查过的话。以下是该系列的计划:</p><ul class=""><li id="d0a6" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><a class="ae iu" rel="noopener" href="/@manvendraaaa/7-basic-algorithms-every-newbie-coder-should-know-part-1-6119ca14e6df">算法介绍:第一部分</a></li><li id="e75b" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><a class="ae iu" rel="noopener" href="/@manvendraaaa/7-basic-algorithms-every-newbie-coder-should-know-part-2-425985e0ae69">搜索&amp;排序算法:第二部分</a></li><li id="6cf1" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><a class="ae iu" rel="noopener" href="/@manvendraaaa/7-basic-algorithms-every-newbie-coder-should-know-part-3-dc25feb68f66">双指针&amp;滑动窗口:第三部分</a></li></ul><p id="8ab6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">开门见山今天我们将学习两种最广泛使用的算法/技术:<em class="kh">双指针&amp;滑动窗口，</em>所以让我们以一种简单而有趣的方式来学习它们。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h2 id="d2dd" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">双指针算法</h2><p id="a187" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">可以毫不夸张地说，两点技术是任何软件开发人员工具包中最重要的工具之一，甚至对于初学者来说，它也是一项必须学习的技术，因为它将在任何人的整个旅程中为他们提供帮助，甚至在他们的技术面试中。我们将通过问自己三个问题来理解这个技巧，这三个问题是:什么，为什么，如何？。</p><p id="542f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">什么是</em> </strong>双指针技术？<br/>名字(<em class="kh">两个指针</em>)表明我们在这种技术中使用两个指针或标记来遍历类似列表/数组的可迭代对象，以在数据结构(例如列表/数组、字符串、链表)的单个循环中使用两个指针/标记来执行搜索操作。现在让我们来谈谈双指针技术的<em class="kh">变体</em>:</p><ul class=""><li id="525b" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><em class="kh">反方向</em>:在这种情况下，每个指针/标记被放置在数组的相对两端，它们在遍历时彼此相向移动，直到它们相遇或满足其他条件。基于此变体的问题<em class="kh">两个指针</em>:</li></ul><div class="lp lq ez fb lr ls"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hj fi z dy lx ea eb ly ed ef hh bi translated">两个和II -输入数组排序- LeetCode</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">给定一个已经按非降序排序的整数数组，找出两个数字，使它们相加…</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">leetcode.co</p></div></div><div class="mb l"><div class="mc l md me mf mb mg io ls"/></div></div></a></div><ul class=""><li id="8aae" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><em class="kh">同向</em>:在这种情况下，每个指针/标记从头开始，一个慢速移动，另一个快速移动，直到满足某个条件。基于<em class="kh">两个指针</em>的变体的问题:</li></ul><div class="lp lq ez fb lr ls"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hj fi z dy lx ea eb ly ed ef hh bi translated">从排序的数组中删除重复项- LeetCode</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">给定一个按非降序排序的整数数组num，就地删除重复项，使每个唯一的…</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">leetcode.com</p></div></div><div class="mb l"><div class="mh l md me mf mb mg io ls"/></div></div></a></div><p id="6327" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">为什么</em> </strong>要用两个指针的手法？<br/>使用这种技术背后最突出的原因是根据数组是否排序，将问题的时间复杂度从O(n3)或O(n2)降低到O(n)或O(nlogn)。</p><p id="b3b0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">如何使用</em> </strong>两种指针技术？<br/>我们通过上面提到的同一个问题来理解这一点，<em class="kh">两个Sum(排序数组)</em>。所以问题如下:</p><pre class="mi mj mk ml fd mm mn mo mp aw mq bi"><span id="be8f" class="kp kq hi mn b fi mr ms l mt mu">Given an array of integers <!-- -->numbers<!-- --> that is already <strong class="mn hj"><em class="kh">sorted in non-decreasing order</em></strong>, find two numbers such that they add up to a specific <!-- -->target<!-- --> number.Return<em class="kh"> the indices of the two numbers (</em><strong class="mn hj"><em class="kh">1-indexed</em></strong><em class="kh">) as an integer array </em>answer<em class="kh"> of size </em>2<em class="kh">, where </em>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length<!-- -->.</span><span id="05cc" class="kp kq hi mn b fi mv ms l mt mu"><strong class="mn hj">Example:<br/>Input:</strong> numbers = [2,7,11,15], target = 9<br/><strong class="mn hj">Output:</strong> [1,2]<br/><strong class="mn hj">Explanation:</strong> The sum of 2 and 7 is 9. Therefore index1 = 1,index2 = 2.</span></pre><p id="83a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以从前面的问题中推断出，我们已经得到了一个排序数组和一个数字；我们必须遍历数组，找到两个这样的数字，它们加起来就是提供的数字，然后返回这些数字的索引。现在让我们来谈谈可以用来解决这个问题的方法:</p><p id="2ee6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.蛮力|时间复杂度:O(n2) <br/> 2。双指针技术|时间复杂度:O(n)</p><p id="d21b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一种方法本质上非常简单，但仍然需要很多时间，我将解释这两种方法，只是为了指出明显的问题(时间复杂性)。</p><p id="ad50" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kh">暴力破解方法</em>:在暴力破解中，我们使用两个循环，外层循环一个接一个地迭代每个元素&amp;内层循环做同样的事情，但是对于外层循环元素的每一次跳转，内层循环完成数组的整个迭代。在这种方法中，我们检查数组中每个元素与其他元素的总和，然后将其与给定的总和进行比较，检查是否相等。下面提供了相同的代码。</p><figure class="mi mj mk ml fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/da51dfa75f201bcf5604a5d8d75abdf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkyaDzMhaseRgOPKZ561jA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">解决方案代码:暴力方法</figcaption></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="cb95" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kh">双指针技术:</em>在这个方法中，我们使用了两个指针/标记来发现排序后的数组中的元素，这些元素加起来就是想要的值。我们首先初始化两个指针，一个指向最左边的索引:start = 0，另一个指向数组的末尾:end = length(array)-1。现在，我们将遍历数组，直到开始小于结束，然后添加指针引用的元素，以查看它们是否匹配所需的数字。如果总和等于数字，我们可以返回开始和结束变量；如果总和大于所需的数字，我们将end变量减1；否则，我们将start递增1。因为数组是排序的，我们可以利用这样一个事实，如果我们减少变量end，它所指向的数字将小于它之前的数字，降低总和&amp;开始增加也是一样，它将增加总和。相同的代码已附在下面。</p><figure class="mi mj mk ml fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/6d289c8214667f7db1ae8bbbbf7f2977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZ2ADiGxfQWU8BBvYm5w_Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">解决方案代码:双指针方法</figcaption></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h2 id="2c2c" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jg la lb lc jk ld le lf jo lg lh li lj bi translated">滑动窗口算法</h2><p id="c5b4" class="pw-post-body-paragraph iv iw hi ix b iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo lo jq jr js hb bi translated">因此，在<em class="kh">双指针</em>算法之后，我们将讨论<em class="kh">滑动窗口</em>算法，因为在双指针技术之后，它也是任何软件开发人员工具包中最重要的工具之一，甚至对于初学者来说，它也是一项必须学习的技术，因为它将在任何人的整个旅程中&amp;帮助每个人&amp;，甚至在他们的技术面试中。我们将通过问自己三个问题来理解这个技巧，这三个问题是:什么，为什么，如何？。</p><p id="d534" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">什么</em> </strong>是滑动窗口算法？<br/>涉及线性序列的问题，如数组，可以使用滑动窗口方法解决。作为数组一部分的连续序列称为窗口。顾名思义，窗口在阵列上滑动。当对窗口中的元素执行某些操作时，窗口会进一步滑动。这种算法有各种各样的变体，但我们不会在本文中涵盖所有的变体，因为本文中我们将讨论最通用的一种。下面是一个可以使用这个算法的问题。</p><div class="lp lq ez fb lr ls"><a href="https://leetcode.com/problems/maximum-average-subarray-i/" rel="noopener  ugc nofollow" target="_blank"><div class="lt ab dw"><div class="lu ab lv cl cj lw"><h2 class="bd hj fi z dy lx ea eb ly ed ef hh bi translated">最大平均子阵列I - LeetCode</h2><div class="lz l"><h3 class="bd b fi z dy lx ea eb ly ed ef dx translated">给你一个由n个元素组成的整数数组nums和一个整数k。求一个连续的子数组，它的长度…</h3></div><div class="ma l"><p class="bd b fp z dy lx ea eb ly ed ef dx translated">leetcode.com</p></div></div><div class="mb l"><div class="mx l md me mf mb mg io ls"/></div></div></a></div><p id="373f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">为什么</em> </strong>使用滑动窗口算法？<br/>该算法通过降低时间复杂度来帮助我们，就像双指针算法一样&amp;该算法的各种各样的问题和变体被开发人员社区的很大一部分使用。</p><p id="d67a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kh">如何使用</em> </strong>滑动窗口算法？<br/>让我们通过上面提到的同一个问题来理解这一点，<em class="kh">具有不同字符的大小为三的子串</em>。所以问题如下:</p><pre class="mi mj mk ml fd mm mn mo mp aw mq bi"><span id="d8f5" class="kp kq hi mn b fi mr ms l mt mu">You are given an integer array <!-- -->nums<!-- --> consisting of <!-- -->n<!-- --> elements, and an integer <!-- -->k<!-- -->.Find a contiguous subarray whose <strong class="mn hj">length is equal to</strong> <!-- -->k<!-- --> that has the maximum average value and return <em class="kh">this value</em>. Any answer with a calculation error less than <!-- -->10-5<!-- --> will be accepted.</span><span id="087a" class="kp kq hi mn b fi mv ms l mt mu"><strong class="mn hj">Example:<br/>Input:</strong> nums = [1,12,-5,-6,50,3], k = 4<br/><strong class="mn hj">Output:</strong> 12.75000<br/><strong class="mn hj">Explanation:</strong> Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75</span></pre><p id="9271" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以从上面的挑战中得出，给我们一个数字数组和一个数(k)，我们必须找到一个长度为(k)的连续子数组，它具有最大的平均值并返回最大的平均值。现在让我们来谈谈可以用来解决这个问题的方法:</p><p id="d1f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.蛮力|时间复杂度:O(n2) <br/> 2。滑动窗口技术|时间复杂度:O(n)</p><p id="831b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一种方法本质上非常简单，但需要很多时间&amp;对于这个问题，我希望你们都自己尝试一下，因为它非常简单。我们将讨论这个问题的<em class="kh">滑动窗口</em>方法。</p><p id="ef48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kh">滑动窗口方法</em>:主要思想是建立一个大小为k的窗口，然后遍历该窗口穿过阵列，添加后面的元素并丢弃前面的元素，然后除以k，找到并比较平均值，以获得最大的平均子阵列。所以我们创建两个变量:current sum和Max Sum，在将Max Sum设置为等于Current Sum之前，我们将前k个元素的和存储在Current Sum中。现在，我们开始遍历数组，从索引k开始，一直到最后，通过添加后面的元素并删除前面的元素来更新当前的总和，直到我们达到与窗口大小k相对应的最大总和，我们只需将它除以k即可获得平均值。这方面的代码可以在下面找到。</p><figure class="mi mj mk ml fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/8984c4a122d18748e9616f6f8bb871db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uto9Ttvb2zLdzdze57UNXw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">解决方案代码:滑动窗口方法</figcaption></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="7d09" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi my translated"><span class="l mz na nb bm nc nd ne nf ng di"> O </span> verview:我们学习了两个非常有用的算法，在“每个新手程序员都应该知道的7个基本算法”系列的这一部分中，这两个基本但非常有用的算法将帮助你在技术面试中解决主题数组/列表、链表、字符串&amp;中的问题。还有，这标志着这个系列的结束。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><blockquote class="nh"><p id="0c88" class="ni nj hi bd nk nl nm nn no np nq js dx translated">编者按:首先，感谢你坚持写完这篇文章；如果你学到了新的东西，请鼓掌并跟随。</p></blockquote></div></div>    
</body>
</html>