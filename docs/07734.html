<html>
<head>
<title>LeetCode 153. Find Minimum in Rotated Sorted Array — Python Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 153。在旋转排序数组中查找最小值Python解决方案</h1>
<blockquote>原文：<a href="https://medium.com/codex/leetcode-153-find-minimum-in-rotated-sorted-array-python-solution-8e3c6818b0e7?source=collection_archive---------9-----------------------#2022-06-24">https://medium.com/codex/leetcode-153-find-minimum-in-rotated-sorted-array-python-solution-8e3c6818b0e7?source=collection_archive---------9-----------------------#2022-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f9eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">盲75 —编程和技术面试问题—解释系列</p><h2 id="76c2" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">问题是:</h2><p id="d199" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">假设按升序排序的长度为n的数组被旋转1到n次。例如，数组<strong class="ih hj"> <em class="kd"> nums </em> </strong> = [0，1，2，4，5，6，7]可能变成:</p><p id="0840" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[4，5，6，7，0，1，2]如果旋转4次。<br/>【0，1，2，4，5，6，7】如果旋转7次。<br/>注意，将数组[a[0]，a[1]，a[2]，…，a[n-1]]旋转1次，得到数组[a[n-1]，a[0]，a[1]，a[2]，…，a[n-2]]。</p><p id="27a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给定唯一元素的排序旋转数组<strong class="ih hj"> <em class="kd"> nums </em> </strong>，返回该数组的最小元素。</p><h2 id="f5af" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">示例:</h2><p id="be40" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated"><strong class="ih hj">例1: </strong></p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="fc81" class="jd je hi kj b fi kn ko l kp kq"><strong class="kj hj">Input:</strong> nums = [3,4,5,1,2]<br/><strong class="kj hj">Output:</strong> 1<br/><strong class="kj hj">Explanation:</strong> The original array was [1,2,3,4,5] rotated 3 times.</span></pre><p id="adc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例2: </strong></p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="3e5f" class="jd je hi kj b fi kn ko l kp kq"><strong class="kj hj">Input:</strong> nums = [4,5,6,7,0,1,2]<br/><strong class="kj hj">Output:</strong> 0<br/><strong class="kj hj">Explanation:</strong> The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.</span></pre><p id="3940" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例3: </strong></p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="b606" class="jd je hi kj b fi kn ko l kp kq"><strong class="kj hj">Input:</strong> nums = [11,13,15,17]<br/><strong class="kj hj">Output:</strong> 11<br/><strong class="kj hj">Explanation:</strong> The original array was [11,13,15,17] and it was rotated 4 times.</span></pre><p id="d394" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输入:nums = [4，5，6，7，0，1，2] <br/>输出:0 <br/>说明:原数组为[0，1，2，4，5，6，7]，旋转了4次。<br/>例3:</p><p id="6d16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输入:nums = [11，13，15，17] <br/>输出:11 <br/>说明:原数组为[11，13，15，17]，旋转了4次。</p><h2 id="e921" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">制约因素:</h2><ul class=""><li id="7f48" class="kr ks hi ih b ii jy im jz iq kt iu ku iy kv jc kw kx ky kz bi translated">你必须写一个在O(log n)中运行的算法</li><li id="19e5" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated"><strong class="ih hj"><em class="kd">time . n</em></strong>= =<strong class="ih hj"><em class="kd">nums . length</em></strong></li><li id="014f" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">1&lt;= n &lt;= 5000</li><li id="1fc4" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated">-5000 &lt;= <strong class="ih hj"><em class="kd">nums【I】</em></strong>&lt;= 5000</li></ul><figure class="ke kf kg kh fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lf"><img src="../Images/0e32ea7aa851f1a3185ed54aa3034c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CuvEK1IfuDHzs0st.png"/></div></div></figure><h2 id="aa7a" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">解释是:</h2><p id="c2a3" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">要在O(登录)时间内做到这一点，必须使用二分搜索法。否则你可以遍历数组寻找最小值。对于二分搜索法，你需要有一个左右指针。因为数组在通过二分搜索法时是排序的，如果中间的元素小于前一个元素或者中间的元素大于下一个元素，那么你就找到了最小值。如果没有找到最小值，则更新左指针或右指针。如果右边的元素大于中间的元素，那么右边的可以被设置为中间减1，否则将左边的指针设置为中间加1。更新左右指针只是基本的二分搜索法。</p><h2 id="c664" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">解决方案— O(logn):</h2><p id="ca61" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">首先将变量初始化为数组的长度。如果长度只有一个，那么你返回一个元素，因为它必须是最小值。现在将数组左边的长度初始化为零，右边的长度减一。当左边小于或等于右边时，进行解释中提到的计算。计算mid，然后检查mid、mid + 1或mid-1是否是最小值，如果是，则返回该数字。如果没有找到最小值，使用基本二分搜索法相应地更新左或右指针。这样就可以保证找到最小值，所以在while循环之后不需要return语句。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="4cd6" class="jd je hi kj b fi kn ko l kp kq">class Solution:<br/> def findMin(self, nums: List[int]) -&gt; int:<br/>  len_n = len(nums)<br/> <br/>   if len_n == 1:<br/>    return nums[0]<br/> <br/>   l, r = 0, len_n — 1<br/> <br/>   while l &lt;= r:<br/>    mid = (l + r) // 2<br/> <br/>    if nums[mid + 1] &lt; nums[mid]:<br/>     return nums[mid + 1]<br/>    if nums[mid — 1] &gt; nums[mid]:<br/>     return nums[mid]<br/> <br/>    if nums[r] &gt; nums[mid]:<br/>     r = mid — 1<br/>    else:<br/>     l = mid + 1</span></pre><figure class="ke kf kg kh fd lg er es paragraph-image"><div class="er es ln"><img src="../Images/20a54bc965e7254dfa6bd80e9d4154dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/0*mV9Hbcy_nqmFmk4G.png"/></div></figure><h1 id="77fc" class="lo je hi bd jf lp lq lr jj ls lt lu jn lv lw lx jq ly lz ma jt mb mc md jw me bi translated">信息:</h1><p id="ef51" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">网址:<a class="ae mf" href="http://www.nkwade.dev/" rel="noopener ugc nofollow" target="_blank">nkwade . dev</a><br/>LinkedIn:<a class="ae mf" href="http://www.linkedin.com/in/nkwade/" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/nkwade</a><br/>GitHub:<a class="ae mf" href="http://www.github.com/nkwade" rel="noopener ugc nofollow" target="_blank">github.com/nkwade</a><br/>邮箱:<a class="ae mf" href="mailto:nicholas@nkwade.dev" rel="noopener ugc nofollow" target="_blank"> nicholas@nkwade.dev </a></p><ul class=""><li id="3d0e" class="kr ks hi ih b ii ij im in iq mg iu mh iy mi jc kw kx ky kz bi translated"><strong class="ih hj"> <em class="kd"> nums </em> </strong>的所有整数都是唯一的。</li><li id="3b0b" class="kr ks hi ih b ii la im lb iq lc iu ld iy le jc kw kx ky kz bi translated"><strong class="ih hj"> <em class="kd"> nums </em> </strong>排序并旋转1到n次。</li></ul></div></div>    
</body>
</html>