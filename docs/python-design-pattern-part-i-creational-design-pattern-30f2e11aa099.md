# Python 设计模式——第一部分:创造性设计模式

> 原文：<https://medium.com/codex/python-design-pattern-part-i-creational-design-pattern-30f2e11aa099?source=collection_archive---------6----------------------->

创造性设计模式提供了多样化的对象创建机制，这提高了现有代码的灵活性和重用性。

如果我们试图在软件工程的背景下定义设计模式，没有什么比[维基百科](https://en.wikipedia.org/wiki/Software_design_pattern)更能给出直截了当的定义了:

> 在软件工程中，**软件设计模式**是一种通用的、可重用的解决方案，用于解决软件设计中给定环境下经常出现的问题。

![](img/1bf095aa6d105bc18b30f32752dc40a4.png)

设计模式上下文中有三个主要类别:创建、结构和行为模式。创造性设计模式主要处理各种对象创建机制，这增加了现有代码的灵活性和重用性。结构模式解释了如何将对象和类组装成更大的结构，同时保持这些结构的灵活性和高效性。行为设计模式与算法和对象之间的责任分配有关。在这篇短文中，我们将通过 Python 中的一些例子向您展示创造性的设计模式。

如前所述，创造性设计模式提供了各种对象创建机制，这提高了代码的灵活性，便于将来重用。这也促进了开发人员之间的交流，以便在高度动态的环境中更有效地协作。

创建设计模式主要由处理对象创建的五个有用组件组成:

*   工厂方法
*   抽象工厂
*   建设者
*   原型
*   一个

在接下来的文章中，我们将逐一介绍，并向您展示一些 Python 示例。

# 工厂方法

工厂方法是一种创造性的设计模式，它为超类提供了调用和创建对象的接口，所创建的对象的类型可以由子类控制和确定。

## 问题

假设您有一个宠物管理应用程序。最初，你只有一个宠物类，叫做*狗。你的大部分代码都存在于`Dog`类中。后来想出了一个需要多加类比如*猫*的情况。将`Cat`添加到应用程序中需要对整个代码库进行修改。此外，如果增加更多的类别，这个问题将会恶化。*

## 解决办法

工厂方法允许您从另一个对象创建一个对象。它是构造调用(使用 new 操作符),调用一个特殊的*工厂*方法。请注意，为了使用工厂方法，最好是所有要调用的类共享相同的方法和属性。

## Python 示例代码

这是工厂方法的 Python 示例。如你所见，我们有两个不同的类，`dog`和`cat` 。两个类可以从`get_pet`工厂类中调用。

# 抽象工厂

抽象工厂允许您创建一系列相关对象，而无需指定具体的类。换句话说，你可以通过一个接口调用类的家族。当你想创建一堆相关的操作时，也可以使用它。

## 问题

假设您想创建一个宠物店，里面有宠物的名字、食物和声音。您需要一种方法来创建单独的家具对象，以便它们与同一族的其他对象相匹配。

## 解决办法

你可以通过一个超类抽象工厂来创建和调用所有这些类。您实际上是单独创建相关的类，并通过一个公共接口调用它们。

## Python 示例代码

下面是使用抽象工厂创建两个类的 Python 片段。通过`petfactory`类我们创建了创建宠物对象的接口。接下来，我们使用`petStore`来访问物体的名称、食物和声音。

# 建设者

生成器作为一种创造性的设计模式，让您一步一步地构建一个复杂的系统。该模式允许您构造不同的对象，每个对象都来自已经构建的组件的子集。

## 问题

想象一个复杂的对象，它需要费力地逐步初始化许多字段和嵌套对象。为了用任何一组可用组件构造任何单个对象，您需要编写许多类，每个类对应于一个特定的集合。

## 解决办法

解决方案是，您可以将组装任务卸载到一个名为 builder 的单独类中。建造者的责任是组装通常由*主管规定的所需步骤。*然而，director 的存在并不是必须的，但会提高可读性和模块化。

## Python 示例

这里，我们想创建两辆具有不同选项的汽车:一辆带喇叭，另一辆不带喇叭。我们通过从超类`builder`继承的`engine_builder` 类添加选项。`engine_builder`包括由`builder`指定的所有选项结构。该控制器包括两种方法，分别对应于两个不同的选项。指导者指定步骤，构建者构建对象。

# 原型

Prototype 是一种创造性的设计模式，它允许您复制现有的对象，而无需让您的代码依赖于它们的类。

## 问题

假设你有一个对象，你想创建它的精确副本。你会怎么做？首先，您必须创建一个相同类的新对象。然后，您必须遍历原始对象的所有字段，并将它们的值复制到新对象[【1】](https://refactoring.guru/design-patterns/prototype)。这种方法有一个缺点。并非所有的属性和方法都可以在对象外部看到，并且可能是私有的。

## 解决办法

原型模式将克隆过程委托给被克隆的实际对象。该模式为所有支持克隆的对象声明了一个公共接口。通常用`clone`法识别。

## Python 示例

在这里，我们想要从另一个创建的汽车中克隆一个汽车对象。为此，我们将首先注册该类，然后使用`clone`方法将其克隆到另一个不同名称的对象中。

# 一个

Singleton 允许确保一个类只有一个实例化，并且是全局可访问的。

## 问题

单例设计模式旨在解决两个常见问题。一是我们要确保一个给定的类只有一个实例。我们为什么关心？在一些应用程序中，我们有一个共享文件，比如在不同类之间共享的数据库。我们希望确保每个类都有相同的数据库副本。singleton 试图解决的第二个问题是全局访问，这使得一个类可以被程序中任何地方的任何类访问。

## Python 示例

在这里，我们有一本词典，我们希望在某个时候能对它进行编辑。我们首先看到，文件包含了`John="Paid`，然后又添加了另一个元素。现在，内容改为{ '约翰':'付费'，'露西':'未付费' }。

文章到此结束:)

参考

[1][https://refactoring.guru/design-patterns/prototype](https://refactoring.guru/design-patterns/prototype)