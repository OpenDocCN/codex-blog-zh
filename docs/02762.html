<html>
<head>
<title>Sequelize, Postgres, JSON &amp; JSONB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Sequelize、Postgres、JSON和JSONB</h1>
<blockquote>原文：<a href="https://medium.com/codex/sequelize-postgres-json-jsonb-c1d4a80a0a51?source=collection_archive---------4-----------------------#2021-08-04">https://medium.com/codex/sequelize-postgres-json-jsonb-c1d4a80a0a51?source=collection_archive---------4-----------------------#2021-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4d3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里是我在使用sequelize时遇到的一些问题。把它们写下来，希望能为别人节省几分钟。</p><p id="7faf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Sequelize对于node来说是一个非常棒的ORM，它给了我强烈的活跃记录的感觉，我喜欢它！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a51a99d775573998b99b9299f5d97c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWLEHbhCCRqg-XY2ocYcwg.png"/></div></div></figure><p id="e602" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它的特点是</p><ul class=""><li id="df4a" class="jp jq hi ih b ii ij im in iq jr iu js iy jt jc ju jv jw jx bi translated">种子和迁移。</li><li id="f08f" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">关联模型的急切加载和迟缓加载。</li><li id="91ec" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">挂钩(生命周期方法/回调)</li><li id="5a6d" class="jp jq hi ih b ii jy im jz iq ka iu kb iy kc jc ju jv jw jx bi translated">发电机(npx序列-cli)</li></ul><h2 id="73c0" class="kd ke hi bd kf kg kh ki kj kk kl km kn iq ko kp kq iu kr ks kt iy ku kv kw kx bi translated">同步您的模型</h2><p id="2046" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">sequelize相对于active record的一个特性是将你的模型“同步”到数据库的能力。实际上，它生成了一个模式并将其应用到数据库中(尽管如果也生成一个模式文件会很酷，可能我还没有发现)。</p><p id="8c52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么有意思？在rails世界中，您可以生成模型和迁移，并在进行过程中迁移数据库。在生产中，这是正确的做法。但是对于一个在基础上快速迭代的新项目，这就有点矫枉过正了。一旦您使用了v1或更早的版本，您将希望开始使用迁移。但是，虽然您的项目只存在于localhost上，但是最好有一个地方来进行更改(模型)并传播这些更改。</p><p id="3813" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是同步所做的。</p><p id="d7ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">docs:<a class="ae ld" href="https://sequelize.org/master/manual/model-basics.html#model-synchronization" rel="noopener ugc nofollow" target="_blank">https://sequel ize . org/master/manual/model-basics . html # model-synchron ization</a></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="b240" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有强制、改变或仅创建缺失表的选项。到目前为止，我已经使用了force，但是在env变量后面设置了这个特性，这样它就不会在每次代码更改时清除数据库(使用nodemon进行重载)。</p><p id="8ff1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不会把它放在我的产品代码附近，但在早期开发阶段，我喜欢它。它让对模型的想象过程更加即时。</p><h2 id="f1d6" class="kd ke hi bd kf kg kh ki kj kk kl km kn iq ko kp kq iu kr ks kt iy ku kv kw kx bi translated">可能的改进:</h2><p id="a639" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">虽然sync在开发中很棒，但是如果有更清晰的从sync切换到migrations的路径就更好了。如前所述，如果sync可以在某个时间点(当您过渡到生产、版本控制或引入更多开发人员时)生成一个模式(或直接迁移)，这将是一个很好的工作流。</p><p id="5fb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前，当谈到迁移和同步时，感觉就像是另一个命题，在它们之间不可避免地会有一个转换点。当您更改模型并同步它时，使用生成器生成模型(它生成相应的迁移)会立即脱离“同步”。我希望生成我的模型，对它们进行处理，然后在稍后阶段从这些模型生成迁移。</p><p id="85e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">种子也有类似的感觉，因为生成的种子语法利用SQL查询来创建和删除种子数据，而我更喜欢在初始开发期间使用我的模型来这样做，然后在稍后的阶段生成种子/设备。肯定取决于数据量和个人喜好，所以里程会有所不同。</p><p id="2e00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有人可能已经解决了这些问题，只是我还没有找到，如果你有更好的方法在twitter上联系我。</p><h1 id="3a30" class="lg ke hi bd kf lh li lj kj lk ll lm kn ln lo lp kq lq lr ls kt lt lu lv kw lw bi translated">Postgres JSON vs JSONB</h1><p id="c188" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">但是尽管sync很酷，JSON vs JSONB却非常烦人，直到我发现我做错了什么。</p><p id="fdea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>使用sequelize，postgres &amp; <code class="du lx ly lz ma b">DataTypes.JSON</code>时你的数据实际上是<em class="mb"/>存储为明文，而不是json。</p><p id="6db5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这导致了各种烦人的解析&amp;将json字符串化到数据库内外。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="3f88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我意识到实际发生了什么之前，我在想‘他们到底为什么认为这是个好主意？’，我将设置get() &amp; set()方法来解析json。</p><p id="13e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我没有选择JSONB，因为我认为我不需要直接查询这些字段，所以这看起来有些多余。我想我可以很快地在任何阶段切换它。</p><p id="d9af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再次查阅文档后，我看到:</p><h1 id="fd15" class="lg ke hi bd kf lh li lj kj lk ll lm kn ln lo lp kq lq lr ls kt lt lu lv kw lw bi translated">PostgreSQL注意事项</h1><p id="c88b" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">PostgreSQL中的JSON数据类型将值存储为纯文本，而不是二进制表示。如果您只是想存储和检索JSON表示，使用JSON将占用更少的磁盘空间，并且从它的输入表示进行构建所需的时间也更少。但是，如果您想对JSON值进行任何操作，您应该首选下面描述的JSONB数据类型。</p><p id="f0f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">文件:<a class="ae ld" href="https://sequelize.org/master/manual/other-data-types.html" rel="noopener ugc nofollow" target="_blank">https://sequelize.org/master/manual/other-data-types.html</a></p><p id="fca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">另请注意:JSONB仅适用于Postgres </strong></p><p id="608e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果您不需要直接查询JSON中的数据，那么使用JSON似乎有一些性能上的好处。但是如果您选择使用JSON，您将需要管理数据库中的序列化数据(只有几行代码)。</p></div></div>    
</body>
</html>