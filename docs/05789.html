<html>
<head>
<title>An Introduction to Automating Data Processes with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker自动化数据处理简介</h1>
<blockquote>原文：<a href="https://medium.com/codex/automating-data-processes-with-docker-1d58576ce0c9?source=collection_archive---------4-----------------------#2022-03-29">https://medium.com/codex/automating-data-processes-with-docker-1d58576ce0c9?source=collection_archive---------4-----------------------#2022-03-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="53a4" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">-以python、venv和Azure blobs为特色</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/b7980092a719656129b7a85229ee4584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5TrzWxY7PY-H7_uN7lQDKQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Docker logo来自<a class="ae jn" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank">https://www.docker.com/</a>，Azure logo来自<a class="ae jn" href="https://azure.microsoft.com/" rel="noopener ugc nofollow" target="_blank">https://azure.microsoft.com/</a>T9】python logo来自<a class="ae jn" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank">https://www.python.org/</a></figcaption></figure><h1 id="515b" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">Docker是什么？</h1><p id="1dfe" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">Docker是一个工具，可以用来为你的代码创建一个虚拟环境或者容器。如果您在本地机器上运行一段代码，例如python中的<code class="du lc ld le lf b">print('Hello')</code>,该代码将在您计算机的操作系统(OS)中运行，带有您已安装的python和python包的版本，在您当前的文件结构中，并且可能使用您本地定义的环境设置。</p><p id="1038" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">使用Docker，你可以定义你的代码应该在一个完全不同的环境中运行。这种环境的定义叫做形象。在<a class="ae jn" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker hub </a>上，您可以找到仅设置了操作系统的通用基础映像，但也可以找到更具体的映像。后者的一个例子是python基础映像。这里使用Linux Debian作为OS，定义基本设置，并安装python。基础映像用作您自己的映像(即环境定义)的起点。</p><p id="aec4" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">任何人都可以将图像上传到Docker Hub，并根据自己的需要使用它们，有点像GitHub或GitLab。这意味着你也可以在Docker Hub上找到完整的项目。例如，运行整个应用程序的映像。</p><h1 id="8705" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">为什么要用Docker？</h1><p id="413a" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">使用Docker是解决代码在一个人的本地机器上运行却不能在另一个人的机器上运行的问题的一种方法。这些问题的出现是因为本地机器的环境不同。</p><blockquote class="ll lm ln"><p id="70d5" class="kg kh lo ki b kj lg ij kl km lh im ko lp li kr ks lq lj kv kw lr lk kz la lb hb bi translated">开发人员A可能拥有python包的2.2版本，而开发人员B拥有1.9版本。a使用了版本2.2中添加的新功能，因此，这对于B来说是不工作的，因为他有这个包的早期版本。如果后来更新了代码中使用的包，也会出现这种情况。新版本可能不再与使用的其他包兼容，因此代码无法编译。</p></blockquote><p id="4302" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">使用Docker(和Docker compose，这是一种同时编排多个Docker映像运行的方法)的另一个原因是它极大地简化了开发，尤其是对于大型应用程序。如果您正在开发一个web应用程序，您有一个前端、一个后端和几个数据库，使用Docker，您可以用一个命令一次性部署它们！</p><p id="3984" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">尽管Docker的好处可能在多人一起开发web应用程序时最为明显，但它在较小的项目中也会带来好处。Docker可能不会使开发和运行您的代码变得更容易，但它肯定会为您省去调试环境不匹配的麻烦(这是一个不容忽视的问题！).</p><h1 id="23c8" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">教程先决条件</h1><p id="484f" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">要学习docker教程，您需要</p><p id="fcff" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated"><strong class="ki hj">需要</strong>:</p><ol class=""><li id="08c0" class="ls lt hi ki b kj lg km lh kp lu kt lv kx lw lb lx ly lz ma bi translated">对您的计算机拥有管理员权限。如果您的物理计算机上没有，您可以通过Azure/AWS/GoogleCloud创建一个虚拟机，并使用该虚拟机</li><li id="10ef" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">安装docker。你会在这里找到说明<a class="ae jn" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"/>。如果您使用Linux，您还应该创建一个docker用户组，这样您就不必在所有docker命令之前键入sudo。你可以在这里找到<a class="ae jn" href="https://docs.docker.com/engine/install/linux-postinstall/" rel="noopener ugc nofollow" target="_blank">的说明</a>。</li></ol><p id="79ea" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated"><strong class="ki hj">好到有</strong>:</p><p id="3386" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">3.对python的基本理解</p><p id="1c55" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">4.<a class="ae jn" href="https://pip.pypa.io/en/stable/installation" rel="noopener ugc nofollow" target="_blank"> pip </a>已安装</p><p id="61b5" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">5.<a class="ae jn" href="https://docs.python.org/3/library/venv.html" rel="noopener ugc nofollow" target="_blank"> venv </a>已安装</p><p id="e8dc" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">6.一个绑定了存储帐户的Azure帐户(针对演示的第2部分)</p><h1 id="7bb8" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">我们的演示简而言之</h1><p id="55c7" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在本次演示中，我们将:</p><ol class=""><li id="2ed8" class="ls lt hi ki b kj lg km lh kp lu kt lv kx lw lb lx ly lz ma bi translated">将包含课程反馈数据的CSV文件读入python</li><li id="3811" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">向数据框添加列</li><li id="38e1" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">将数据框保存到新的CSV文件中</li><li id="84f0" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">让上述事情发生在Docker容器中，该容器从我们将要定义的图像中运行</li><li id="abe6" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">用crontab调度docker容器的运行</li></ol><p id="f17c" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">我们从本地读写文件开始(演示部分1)，然后切换到从Azure容器读写(演示部分2)。</p><h1 id="97ef" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">我们项目的主要组成部分</h1><p id="98d9" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">为了将我们的新项目归档，我们需要项目目录具有以下结构:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mg"><img src="../Images/dda113a2bd7536af56d065ee3dd7b8ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*SNQX22cP2nqteMICc36lDg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">项目目录结构</figcaption></figure><ol class=""><li id="b8ca" class="ls lt hi ki b kj lg km lh kp lu kt lv kx lw lb lx ly lz ma bi translated">我们想要运行的代码，在本例中，是一个名为<em class="lo"> handle_data.py </em>的文件</li><li id="6a23" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">docker文件将引用的要安装的软件包列表。在本例中，命名为<em class="lo"> requirements.txt </em>。我们在venv包的帮助下创建包列表</li><li id="965d" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">一份文件。这是我们想要运行代码的环境的定义/方法(操作系统、python版本、python包……)</li><li id="366c" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">一个<em class="lo">数据</em>文件夹，用于我们的输入和输出数据</li><li id="b7fd" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">答<em class="lo">。dockerignore </em>文件，包含构建docker映像时不需要的文件名和文件夹名。在我们的例子中，一行带有/venv，一行带有. env。</li><li id="b04a" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">(一个<em class="lo">。env </em>文件包含<em class="lo"> handle_data.py </em>中引用的环境变量。)</li><li id="252f" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">(如果使用版本控制，一个<em class="lo">。gitignore </em>文件有一行带有/venv，一行带有。环境)</li></ol><h1 id="6d51" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">演示部分1:本地文件</h1><p id="8deb" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在演示的第一部分，我们将从本地计算机读取和写入文件。这是一种简单的开始方式，并且不需要外部源的连接器。</p><h2 id="9866" class="mh jp hi bd jq mi mj mk ju ml mm mn jy kp mo mp ka kt mq mr kc kx ms mt ke mu bi translated">1.密码</h2><p id="3b33" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们在文件<em class="lo"> handle_data.py </em>中的代码非常简单。我们从导入熊猫开始，然后读取、转换和写入数据。文件路径将在docker映像中创建和使用，并且在<em class="lo"> /data </em>之前的部分不一定必须对应于您的本地文件结构。</p><pre class="iy iz ja jb fd mv lf mw mx aw my bi"><span id="71fa" class="mh jp hi lf b fi mz na l nb nc">import pandas as pd</span><span id="4fe5" class="mh jp hi lf b fi nd na l nb nc"># Read base data from local csv file<br/>INPUT_FILEPATH= ‘./data/courses.csv’<br/>course_feedback = pd.read_csv(INPUT_FILEPATH)</span><span id="fb12" class="mh jp hi lf b fi nd na l nb nc"># Create overall grade column<br/>course_feedback[‘Overall’] = course_feedback.iloc[:, 4:7].mean(axis=1).round(2)</span><span id="0c21" class="mh jp hi lf b fi nd na l nb nc"># Write new data frame to CSV locally<br/>OUTPUT_FILEPATH = ‘./data/course_feedback_finished.csv’<br/>course_feedback.to_csv(OUTPUT_FILEPATH, encoding=’utf-8', index=False)</span></pre><h2 id="982e" class="mh jp hi bd jq mi mj mk ju ml mm mn jy kp mo mp ka kt mq mr kc kx ms mt ke mu bi translated">2.虚拟环境</h2><p id="673f" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">接下来，我们需要上面代码使用的所有包的列表，这样我们可以确保它们在我们的Docker映像中都是可用的，并且代码可以顺利运行。尽管我们在代码中只导入熊猫，但这并不意味着这是唯一需要的包。熊猫有我们也需要包括在名单上的依赖。你可以谷歌一下它们是什么，最新的版本是什么。然而，更简单的方法是使用python虚拟环境。</p><p id="45f3" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">虚拟环境背后的想法类似于docker的想法。当docker创建一个从操作系统开始到项目代码执行结束的独立环境时，python虚拟环境创建一个从python版本开始到python包及其版本结束的独立环境。当我们为一个特定的项目创建一个python虚拟环境时，我们可以只安装该特定项目所需的python包(以及它们的版本)。因此，我们得到了一个苗条和干净的环境。当我们列出虚拟环境中已安装的软件包时，它比我们列出在基础环境中下载的所有软件包要短得多。如果我们安装了很多额外的包，我们的Docker镜像可能不会被破坏，但是它增加了镜像的大小(无论如何，镜像会很大)。</p><p id="ae64" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">在python包venv的帮助下，我们得到了如下的精简包列表:</p><ol class=""><li id="9b8d" class="ls lt hi ki b kj lg km lh kp lu kt lv kx lw lb lx ly lz ma bi translated">当您在项目目录中时，运行<code class="du lc ld le lf b">python -m venv ./venv</code>在该目录中创建一个名为venv的虚拟环境。</li><li id="9fc0" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">运行<code class="du lc ld le lf b">source venv/bin/activate</code>激活环境</li><li id="671c" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">现在<a class="ae jn" href="https://pypi.org/project/pandas/" rel="noopener ugc nofollow" target="_blank">装熊猫</a>。Pip将自动安装所需的依赖项。</li><li id="68a4" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">将包列表保存到Docker图像可以引用的文本文件:<code class="du lc ld le lf b">pip freeze &gt; requirements.txt</code>。现在，文件已经创建在项目目录的根目录下</li><li id="51ef" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">停用虚拟环境:<code class="du lc ld le lf b">deactivate</code></li><li id="741b" class="ls lt hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">(如果使用版本控制，请忽略虚拟环境目录)</li></ol><h2 id="b183" class="mh jp hi bd jq mi mj mk ju ml mm mn jy kp mo mp ka kt mq mr kc kx ms mt ke mu bi translated">3.Dockerfile文件</h2><p id="6604" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">Dockerfile是一个文本文件，其名称(通常)没有任何扩展名。它所包含的“配方”是自上而下阅读的。食谱中每一步的类型(FROM，COPY…)都是用大写字母写的。你可以在这里找到关于文件结构<a class="ae jn" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">的详细信息</a>。</p><p id="d2fb" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">每个Dockerfile文件都以FROM子句开头。在这里，我们定义我们想要使用哪个图像作为我们的起点。因为我们将运行python脚本，所以我们可以使用安装了python 的<a class="ae jn" href="https://hub.docker.com/layers/python/library/python/3.9.10-bullseye/images/sha256-c59372055ab5f8f22b21964a58d5d7a2df1b7a09f10c18a687cb93f548ffe76c?context=explore https://www.debian.org/releases/bullseye/" rel="noopener ugc nofollow" target="_blank">图像。我选择的是基于Linux Debian的牛眼版本构建的python 3 . 9 . 10版本。</a></p><p id="c7c2" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">在用<code class="du lc ld le lf b">RUN pip install —upgrade pip </code>更新pip之后(安装是用RUN命令完成的)，我们创建一个工作目录在这个Docker映像中使用。这使得管理映像中的文件以及将它们映射到本地计算机上的文件变得更加容易(稍后将详细介绍)。我选择了路径<em class="lo"> /handle_data </em>，并将其写在WORKDIR子句之后。</p><p id="936c" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">下一步是安装我们需要的所有软件包。这是通过首先将(COPY clause)<em class="lo">requirements . txt</em>从我们的本地计算机复制到docker映像，然后——在运行pip升级后——使用pip install安装所有软件包来完成的。</p><p id="7cf4" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">之后，我们将本地机器上项目目录中的所有文件复制到docker映像中。</p><p id="72a6" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">最后，在CMD，即命令步骤中，我们定义当我们使用这个图像时，文件<em class="lo"> handle_data.py </em>应该在python中运行。之前的所有步骤都将在我们构建映像时执行(混合各种成分)，但这一步只会在我们从映像运行容器时执行(开始使用完成的映像)。</p><pre class="iy iz ja jb fd mv lf mw mx aw my bi"><span id="208b" class="mh jp hi lf b fi mz na l nb nc">FROM python:3.9.10-bullseye</span><span id="d5f1" class="mh jp hi lf b fi nd na l nb nc">RUN pip install --upgrade pip</span><span id="f26b" class="mh jp hi lf b fi nd na l nb nc">WORKDIR /handle_data</span><span id="a231" class="mh jp hi lf b fi nd na l nb nc">COPY requirements.txt ./</span><span id="2a1b" class="mh jp hi lf b fi nd na l nb nc">RUN pip install --no-cache-dir -r requirements.txt</span><span id="7245" class="mh jp hi lf b fi nd na l nb nc">COPY . .</span><span id="a97f" class="mh jp hi lf b fi nd na l nb nc">CMD [ "python", "handle_data.py" ]</span></pre><h2 id="59c1" class="mh jp hi bd jq mi mj mk ju ml mm mn jy kp mo mp ka kt mq mr kc kx ms mt ke mu bi translated">4.存储输入和输出数据的地方</h2><p id="8bf5" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在演示的第一部分，我们将从本地文件中读取输入数据。因此，我们创建一个包含这个文件的数据文件夹<a class="ae jn" href="https://github.com/chpatola/docker-python-tutorial/blob/main/data/courses.csv" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="ddd8" class="mh jp hi bd jq mi mj mk ju ml mm mn jy kp mo mp ka kt mq mr kc kx ms mt ke mu bi translated">5.行动的时间到了！</h2><p id="a229" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们现在准备构建我们的Docker映像，然后从中运行一个容器！</p><p id="e57f" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">我们的目标是从数据文件夹中读取输入CSV文件，让handle_data.py向数据框添加一个新列，并将结果作为新的CSV文件写入数据文件夹。我们从构建Dockerfile文件开始。在根目录中，运行这个代码<code class="du lc ld le lf b">docker image build . -t &lt;the name you want to give your image&gt;</code>。我将图像命名为<em class="lo"> handle_data </em>。</p><p id="072a" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">构建需要几分钟时间，您可以在终端中遵循这个过程。如果在这个过程中有任何问题，您将得到一个错误消息，并可以从那里进行调查。</p><p id="3ec9" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">我们的图像现在可以使用了。从映像运行容器的基本方式是使用命令<code class="du lc ld le lf b">docker run &lt;image name&gt;</code>。然而，当运行一个容器时，我们必须意识到它是在自己的环境中运行的，独立于我们的本地机器。这些文件将在容器中被读写，我们将无法从本地机器中访问它们。这不是我们现在想要的。</p><p id="2ceb" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">幸运的是，有一种方法可以解决这个问题。我们可以将本地机器上的一个目录映射到我们在docker映像中设置的工作目录。这样，我们可以让输出CSV文件出现在本地机器上项目目录的data文件夹中。这是通过本地机器中的路径(如果我们直接从项目目录运行容器，我们可以使用<code class="du lc ld le lf b">$(pwd)/data, </code>)、冒号和docker映像中的路径来完成的。</p><p id="6dad" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">当从新的docker映像运行容器时，将Docker终端输出映射到我们本地机器的终端也是一个聪明的想法。这样我们可以看到信息或错误消息(如果有的话)(否则这些也只能在容器内部看到)。这是通过标志<code class="du lc ld le lf b">-it</code>完成的。</p><p id="82b1" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">从项目目录中运行容器的完整命令现在是:<code class="du lc ld le lf b">docker run -it -v “$(pwd)/data:/handle_data/data" handle_data</code>。</p><p id="4732" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">当代码成功运行时，您应该在项目目录的<em class="lo"> data </em>文件夹中看到输出文件<em class="lo">course _ feedback _ finished . CSV</em>。</p><p id="d4fd" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">很高兴我们现在已经成功地建立了一个基本的docker结构。然而，我们多久需要在本地计算机上自动读写一次文件？可能不经常。通常，我们从一个外部源读取，并向另一个外部源写入。这是我们将在本演示的第2部分中做的事情。</p><h1 id="6bb8" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">演示第2部分:Azure容器中的文件</h1><p id="7be0" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在演示的这一部分，我们将从一个Azure容器读取数据，并将其写入另一个容器。两个容器都是私有的，我们使用<a class="ae jn" href="https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview" rel="noopener ugc nofollow" target="_blank">共享访问签名(SAS)</a>URL进行认证。</p><h2 id="dcc7" class="mh jp hi bd jq mi mj mk ju ml mm mn jy kp mo mp ka kt mq mr kc kx ms mt ke mu bi translated">1.密码</h2><p id="01e7" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们的代码需要一些更新来读写Azure容器。为了写入我们的Azure容器，我们需要导入<em class="lo"> ContainerClient </em>。我们将把我们的SAS凭证存储为环境变量，因此需要导入environ来访问它们。</p><p id="b2cc" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">接下来，我们将路径更改为<em class="lo"> read_csv </em>，以使用新环境变量<em class="lo"> URL_TO_INPUT_BLOB </em>的值。最后，我们添加几行代码将输出文件写入Azure中的容器(<em class="lo"> URL_TO_OUTPUT_CONTAINER </em>)。您可以在下面的<strong class="ki hj">粗体</strong>中找到所有更新。</p><pre class="iy iz ja jb fd mv lf mw mx aw my bi"><span id="1ee7" class="mh jp hi lf b fi mz na l nb nc"><strong class="lf hj">from os import environ</strong></span><span id="3e02" class="mh jp hi lf b fi nd na l nb nc">import pandas as pd</span><span id="0bfb" class="mh jp hi lf b fi nd na l nb nc"><strong class="lf hj">from azure.storage.blob import ContainerClient</strong></span><span id="a5d4" class="mh jp hi lf b fi nd na l nb nc"># Read base data via blob sas url<br/>course_feedback = pd.read_csv(<strong class="lf hj">environ.get('URL_TO_INPUT_BLOB')</strong>)</span><span id="c8e4" class="mh jp hi lf b fi nd na l nb nc"># Create overall grade column<br/>course_feedback['Overall'] = course_feedback.iloc[:, 4:7].mean(axis=1).round(2)</span><span id="d7ae" class="mh jp hi lf b fi nd na l nb nc"># Write new dataframe to csv locally<br/>LOCAL_FILEPATH = './data/course_feedback_finished.csv'</span><span id="f93c" class="mh jp hi lf b fi nd na l nb nc">course_feedback.to_csv(LOCAL_FILEPATH, encoding='utf-8', index=False)</span><span id="1b90" class="mh jp hi lf b fi nd na l nb nc"><strong class="lf hj">#Write local csv to Azure blob<br/>cont_cli = ContainerClient.from_container_url(environ.get('URL_TO_OUTPUT_CONTAINER'))</strong></span><span id="9223" class="mh jp hi lf b fi nd na l nb nc"><strong class="lf hj">with open(LOCAL_FILEPATH, 'rb') as data:<br/>cont_cli.upload_blob('course_feedback_finished.csv', data, overwrite=True)</strong></span></pre><h2 id="3da7" class="mh jp hi bd jq mi mj mk ju ml mm mn jy kp mo mp ka kt mq mr kc kx ms mt ke mu bi translated">2.虚拟环境</h2><p id="6f91" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">由于我们刚刚在代码中导入了更多的模块，我们需要更新我们的包列表<em class="lo"> requirements.txt </em>。通过演示第1部分的虚拟环境部分中的步骤2-5来完成，但是将<code class="du lc ld le lf b">pip install pandas</code>换成<code class="du lc ld le lf b">pip install azure-storage-blob</code>我们不需要安装<em class="lo">操作系统</em>，因为它已经包含在我们docker文件中使用的python基本映像中。</p><h2 id="ad9c" class="mh jp hi bd jq mi mj mk ju ml mm mn jy kp mo mp ka kt mq mr kc kx ms mt ke mu bi translated">3.环境变量</h2><p id="9982" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">正如你在我们的<em class="lo"> handle_data.py </em>文件中看到的变化，我们将使用两个不同的Azure容器，一个作为输入，一个作为输出。让我们创造这些吧！</p><p id="eb26" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">当您登录到azureaccount并转到您的存储帐户时，首先创建一个容器，您将在其中以blob的形式存储<a class="ae jn" href="https://github.com/chpatola/docker-python-tutorial/blob/main/data/courses.csv" rel="noopener ugc nofollow" target="_blank">输入数据</a>。上传文件后，左键单击该文件并选择“生成SAS”。在弹出的菜单中，选择sas生效的时间范围，然后单击“生成SAS令牌和URL”。不要关闭浏览器选项卡。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ne"><img src="../Images/51e7d7839d9e5fd58443adb7adfdfcd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*xVbPQ5WIsVEcPrpf7adlxA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">为blob生成服务协议</figcaption></figure><p id="8335" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">接下来，打开一个新的浏览器选项卡，为您的输出数据创建一个新的容器，左键单击该容器，然后再次选择“生成SAS”。现在，请确保选择足够广泛的权限。除了“不可变存储”，我都检查了。然后，选择有效期，并再次单击“生成SAS令牌和URL”。不要关闭浏览器选项卡。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nf"><img src="../Images/165a5ef2579cc08178860ee679b92cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*-Jow4MVd_06Pv-N_wl0Xbw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">SAS选项</figcaption></figure><p id="4046" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">我们将通过名为<em class="lo">的文件传递环境变量。婀</em>。在项目目录中创建该文件，并编写一行带有<strong class="ki hj">URL _ TO _ INPUT _ BLOB</strong>=您的输入BLOB的URL的代码和一行带有<strong class="ki hj">URL _ TO _ OUTPUT _ CONTAINER</strong>=您的输出容器的URL的代码。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/3ea0ead343c242aaca586784b10fa056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_Mit56lY-IPNBrQe9_EXA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">。环境文件模型</figcaption></figure><h2 id="d15d" class="mh jp hi bd jq mi mj mk ju ml mm mn jy kp mo mp ka kt mq mr kc kx ms mt ke mu bi translated">4.行动的时间到了！</h2><p id="3951" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们的修改完成了！让我们再次构建更新后的Docker映像:<code class="du lc ld le lf b">docker image build . -t handle_data</code>。</p><p id="bb52" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">这一次，当我们从映像运行容器时，我们不需要将任何本地文件夹映射到docker文件夹。然而，我们需要做的是告诉docker它将在哪里找到我们在代码中引用的环境变量。这是通过标志<code class="du lc ld le lf b">--env-file</code>完成的，后面是文件的路径。</p><p id="1bbc" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated"><code class="du lc ld le lf b">-it</code>标志仍然值得保留，因为这是我们第一次使用图像的更新版本，我们希望看到可能的错误消息。如果从项目目录的根目录运行它，完整的运行命令是<code class="du lc ld le lf b">docker run --env-file .env -it handle_data</code>。</p><p id="691e" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">如果一切正常，您将在Azure输出容器中看到输出CSV。</p><h2 id="3e77" class="mh jp hi bd jq mi mj mk ju ml mm mn jy kp mo mp ka kt mq mr kc kx ms mt ke mu bi translated">5.安排容器的自动运行</h2><p id="a999" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">现在，当我们测试了映像并知道它可以工作时，我们可以安排容器定期运行，例如，每天晚上。为此，我们使用调度工具crontab，它可以在Linux和Mac机器上使用。</p><p id="571c" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">通过写<code class="du lc ld le lf b">crontab -e</code>在终端中打开crontab。要在每天下午7点运行一次容器，请这样写:</p><pre class="iy iz ja jb fd mv lf mw mx aw my bi"><span id="ac4c" class="mh jp hi lf b fi mz na l nb nc">0 19 * * * cd &lt;full path to your project directory on your local computer&gt; &amp;&amp; docker run --env-file .env handle_data</span></pre><p id="7d9f" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">如果你想了解更多关于cron是如何工作的，你可以看看<a class="ae jn" href="https://ostechnix.com/a-beginners-guide-to-cron-jobs/" rel="noopener ugc nofollow" target="_blank">这个指南</a>。</p><h1 id="0ee0" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">清除</h1><p id="4909" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">如果您的系统上有一些docker映像，它们会很快占用您机器上的大量空间。养成经常清理你不再需要的图片的习惯是很好的。您可以使用命令<code class="du lc ld le lf b">docker image ls</code>检查您的所有图像。用<code class="du lc ld le lf b">docker image rm &lt;image name&gt;</code>命令删除不需要的图像。</p><p id="fce4" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">移除多余的容器也是一种好的做法。你可以一个接一个地这样做，就像对图像一样，但是更快的方法是使用<code class="du lc ld le lf b">docker system prune</code>。这将删除当前未运行的所有容器。如果您建立了缓存或未使用的网络，它们也会被删除。你可以在这里找到关于命令<a class="ae jn" href="https://docs.docker.com/engine/reference/commandline/system_prune/" rel="noopener ugc nofollow" target="_blank">的更多信息</a>。</p><h1 id="fa76" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">结论</h1><p id="ca67" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们现在有办法从任何机器上按计划运行我们的代码。不管本地机器有什么操作系统、python包或文件结构，我们的代码将总是运行在相同的操作系统上，有相同的包和相同的文件结构。</p><p id="d267" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated"><strong class="ki hj">有了这个，我们可以享受代码的可移植性和稳定性。</strong></p><p id="0eed" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">如果你有兴趣了解更多关于docker的知识，我推荐<a class="ae jn" href="https://devopswithdocker.com/" rel="noopener ugc nofollow" target="_blank">赫尔辛基大学的Docker MOOC </a>。</p></div></div>    
</body>
</html>