<html>
<head>
<title>Design Patterns for Javascript — Builder Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript的设计模式—构建器模式</h1>
<blockquote>原文：<a href="https://medium.com/codex/design-patterns-for-javascript-builder-pattern-c287c54b9b6b?source=collection_archive---------6-----------------------#2022-03-24">https://medium.com/codex/design-patterns-for-javascript-builder-pattern-c287c54b9b6b?source=collection_archive---------6-----------------------#2022-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a8392e6bc22503c4dc50fb4e1eeebea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V6LiYQPd_fJkCZcrE_wSSw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">设计模式——公认的做事标准是什么？</figcaption></figure><p id="08bd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">builder模式是一种<strong class="iw hj">创造</strong>设计模式，适用于我们必须设计或构建具有多个复杂创造步骤的对象的情况。</p><p id="046a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">builder模式允许我们拥有一个基类，我们可以随时引用它，并从基类中挑选出总是可用的方法，编排它们的调用，并且通常会提出一种更直接、更简单的方法来构造目标类。</p><p id="0d30" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">builder类将允许你定义创建实体、对象实例的步骤，或者也可以允许你动态地编排创建过程。</strong></p><h1 id="cbc9" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">一个简单的例子</h1><p id="e47a" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">假设我们有一个为团队制作茶的程序。考虑下面的代码片段</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="59a9" class="le jt hi la b fi lf lg l lh li">class Tea {</span><span id="7ac7" class="le jt hi la b fi lj lg l lh li">    constructor(chocolate, milk, sugar, honey, temperature) {</span><span id="6825" class="le jt hi la b fi lj lg l lh li">        return chocolate + milk + sugar + honey + temperature;</span><span id="95c5" class="le jt hi la b fi lj lg l lh li">    }</span><span id="0dd1" class="le jt hi la b fi lj lg l lh li">}</span></pre><p id="9e69" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这段代码为消费者泡了一杯茶。为了简单起见，让我们假设一个非常简单的过程。将所有的材料混合在一起，然后上路。</p><p id="7d3f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从表面上看，这似乎很简单。接下来的几个月，这个程序可能会被第三方甚至我们自己使用，我们开始遇到一些细节问题，比如温度是四舍五入到2或3位小数吗？或者哪个先来…蜂蜜还是糖？虽然我们现在可能很容易回过头来查看类构造函数的定义，但我们可能不会一直拥有这种奢侈。这是一个我们可以使用生成器的例子。</p><p id="073b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在某种程度上，以这种方式想象一个建造者；</p><p id="2c60" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">构建器可用于抽象精细的对象构造实现细节，并向用户呈现通用接口</p><p id="bf06" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们把这个类写成一个Builder类，我们将能够抽象出一些实现细节，比如小数位数、数据类型、构造函数参数顺序等等，并把它们放到一个更友好的界面中。</p><p id="c7ef" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">目前，要构建Tea类的实例，我们需要执行以下代码:</p><p id="9435" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">设MyTea =新茶(23，null，5，3，23.45)；</p><p id="1b50" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，使用构建器模式，我们可以按以下方式重构Tea类；</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="98cb" class="le jt hi la b fi lf lg l lh li">class Tea {</span><span id="fe9a" class="le jt hi la b fi lj lg l lh li">    constructor(chocolate) { // constructor now takes an argument. We could implement a zero-parameter constructor if we desire.</span><span id="1ae8" class="le jt hi la b fi lj lg l lh li">        this._chocolate = chocolate;</span><span id="96df" class="le jt hi la b fi lj lg l lh li">        this._milk = null;</span><span id="94e4" class="le jt hi la b fi lj lg l lh li">        this._sugar = null;</span><span id="f878" class="le jt hi la b fi lj lg l lh li">        this._honey = null;</span><span id="cba7" class="le jt hi la b fi lj lg l lh li">        this._temperature = null;</span><span id="9291" class="le jt hi la b fi lj lg l lh li">}</span><span id="e54c" class="le jt hi la b fi lj lg l lh li">    addMilk (quantity) {</span><span id="ade2" class="le jt hi la b fi lj lg l lh li">// we can apply transformations to the value here, much like using a setter</span><span id="6cb2" class="le jt hi la b fi lj lg l lh li">        this._milk = quantity;</span><span id="a627" class="le jt hi la b fi lj lg l lh li">        return this; // this is the line that does all the magic. I will explain further in a bit</span><span id="7eda" class="le jt hi la b fi lj lg l lh li">    }</span><span id="0ad1" class="le jt hi la b fi lj lg l lh li">    addSugar (quantity) {</span><span id="80e2" class="le jt hi la b fi lj lg l lh li">        this._sugar = quantity;</span><span id="455e" class="le jt hi la b fi lj lg l lh li">        return this;</span><span id="2da2" class="le jt hi la b fi lj lg l lh li">    }</span><span id="b220" class="le jt hi la b fi lj lg l lh li">    addHoney (quantity) {</span><span id="ac1f" class="le jt hi la b fi lj lg l lh li">        this._honey = quantity;</span><span id="da24" class="le jt hi la b fi lj lg l lh li">        return this;</span><span id="1e48" class="le jt hi la b fi lj lg l lh li">    }</span><span id="69b4" class="le jt hi la b fi lj lg l lh li">    setTemperature (value) {</span><span id="bfc0" class="le jt hi la b fi lj lg l lh li">        let temperature = Number.parseFloat(value); // like I said, we can control how the passed values are injected into the application using this</span><span id="cf65" class="le jt hi la b fi lj lg l lh li">        this._temperature = temperature;</span><span id="9a22" class="le jt hi la b fi lj lg l lh li">        return this;</span><span id="7093" class="le jt hi la b fi lj lg l lh li">}</span><span id="15c1" class="le jt hi la b fi lj lg l lh li">    brewCup () {</span><span id="028b" class="le jt hi la b fi lj lg l lh li">        return this._chocolate + this._milk + this._honey + this._sugar + this._temperature;</span><span id="0e6e" class="le jt hi la b fi lj lg l lh li">    }</span><span id="7cc3" class="le jt hi la b fi lj lg l lh li">}</span></pre><p id="535a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，为了泡杯茶，我们可以这样做。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="279a" class="le jt hi la b fi lf lg l lh li">let MyTea = new Tea(‘Choco’);</span><span id="4f0a" class="le jt hi la b fi lj lg l lh li">myTea.addMilk(‘milk’).addHoney(‘honey’).addSugar(‘sugar’).setTemperature(23.918).brewCup();</span></pre><p id="79d0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">注意方法的调用顺序对最终产品并不重要。这是因为构建器模式不断地返回构建器的类实例，并且这个类实例将总是公开它的所有方法，以供消费者在任何时候调用。你真的可以做一个<code class="du lk ll lm la b">.addMilk().addMilk().addMilk()</code>，它就会飞起来，因为由方法返回的<code class="du lk ll lm la b">this</code>将总是携带方法。</p><p id="97c7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">执行构建器模式的另一种方式是使用抽象类和具体类。然而，JavaScript没有抽象或具体实体的概念，所以如果我们不模仿抽象功能，我们可以使用的构造就很有限。然而，这个想法是你有一个创建者，一个模板/模板类叫做抽象类，你生成一个目标类或对象的实例。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/1083eb7738362ec056c37e9a1aeb0da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*gEoOmjGJ7wdFLwwI5L3IHQ.jpeg"/></div></figure><p id="bf58" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为什么这可能是更好的方法？在某种程度上，目标类也可能变得足够大，以至于可以被抽象成它们自己的单独的类。为了说明构建器模式的这种方法，我们可以使用一个汽车制造公司的生产线作为例子。</p><p id="1af5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">假设我开一家公司，迎合中国多种交通方式。我们正在寻求大量生产自行车、汽车和轮船。我们需要建立生产线。这是生产产品的生产线。</p><p id="0c20" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每条线路都应适合特定的运输方式。所以，我们总共设置了3条生产线。</p><p id="1296" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">假设我们有一个工厂；</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="6b3f" class="le jt hi la b fi lf lg l lh li">class VehicleFactory {</span><span id="0049" class="le jt hi la b fi lj lg l lh li">    constructor(builder) {</span><span id="4e51" class="le jt hi la b fi lj lg l lh li">        this._builder = builder</span><span id="dbca" class="le jt hi la b fi lj lg l lh li">    }</span><span id="07a0" class="le jt hi la b fi lj lg l lh li">    build () {</span><span id="458f" class="le jt hi la b fi lj lg l lh li">        this._builder.step1();</span><span id="c493" class="le jt hi la b fi lj lg l lh li">        this._builder.step2();</span><span id="f6c1" class="le jt hi la b fi lj lg l lh li">        this._builder.step3();</span><span id="e34f" class="le jt hi la b fi lj lg l lh li">        return this._builder.getBuild();</span><span id="1bca" class="le jt hi la b fi lj lg l lh li">    }</span><span id="b755" class="le jt hi la b fi lj lg l lh li">}</span></pre><p id="a2da" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是一个简单的工厂。这里没有太多的细节，虽然工厂可以变得更复杂。然而，为了本教程的目的，让我们说我们的工厂就是这么简单。</p><p id="cde6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以看到，这个工厂公开了一个build方法，然后该方法与用来初始化我们的类的builder进行交互，并输出一个产品。我们还可以在这里看到一个警告，我们所有的抽象类必须公开名为step1、step2、step3和getBuild的方法。然而，当我们可以创建单独的抽象类时，我们可以享受我们得到的抽象，我们享受对类的更好的控制，因为它们更小，更容易理解和思考。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="4d87" class="le jt hi la b fi lf lg l lh li">class BicycleFactory {</span><span id="c0c5" class="le jt hi la b fi lj lg l lh li">    constructor(product) {</span><span id="c902" class="le jt hi la b fi lj lg l lh li">        this._product = product;</span><span id="b3bc" class="le jt hi la b fi lj lg l lh li">    }</span><span id="f2c7" class="le jt hi la b fi lj lg l lh li">    step1 () {</span><span id="021d" class="le jt hi la b fi lj lg l lh li">        return 'Add 2 tyres'</span><span id="ecd4" class="le jt hi la b fi lj lg l lh li">    }</span><span id="02be" class="le jt hi la b fi lj lg l lh li">    step2 () {</span><span id="4566" class="le jt hi la b fi lj lg l lh li">        return 'Add handlebar controls'</span><span id="bb3d" class="le jt hi la b fi lj lg l lh li">    }</span><span id="1ef1" class="le jt hi la b fi lj lg l lh li">    step3 () {</span><span id="e392" class="le jt hi la b fi lj lg l lh li">        return 'Add manual power'</span><span id="85db" class="le jt hi la b fi lj lg l lh li">    }</span><span id="5fd6" class="le jt hi la b fi lj lg l lh li">    getBuild () {</span><span id="60dd" class="le jt hi la b fi lj lg l lh li">        return 'Build'</span><span id="0168" class="le jt hi la b fi lj lg l lh li">    }</span><span id="7e8e" class="le jt hi la b fi lj lg l lh li">}</span><span id="4cef" class="le jt hi la b fi lj lg l lh li">class CarFactory {</span><span id="9e51" class="le jt hi la b fi lj lg l lh li">    constructor(product) {</span><span id="e1ae" class="le jt hi la b fi lj lg l lh li">        this._product = product;</span><span id="9163" class="le jt hi la b fi lj lg l lh li">    }</span><span id="bee6" class="le jt hi la b fi lj lg l lh li">    step1 () {</span><span id="d07a" class="le jt hi la b fi lj lg l lh li">        return 'Add 4 tyres'</span><span id="4082" class="le jt hi la b fi lj lg l lh li">    }</span><span id="0033" class="le jt hi la b fi lj lg l lh li">    step2 () {</span><span id="eb20" class="le jt hi la b fi lj lg l lh li">        return 'Add steering controls'</span><span id="1c10" class="le jt hi la b fi lj lg l lh li">    }</span><span id="0417" class="le jt hi la b fi lj lg l lh li">    step3 () {</span><span id="ab14" class="le jt hi la b fi lj lg l lh li">        return 'Add petrol power'</span><span id="2fa3" class="le jt hi la b fi lj lg l lh li">    }</span><span id="d049" class="le jt hi la b fi lj lg l lh li">    getBuild () {</span><span id="277a" class="le jt hi la b fi lj lg l lh li">        return 'Build'</span><span id="7bb0" class="le jt hi la b fi lj lg l lh li">    }</span><span id="318a" class="le jt hi la b fi lj lg l lh li">}</span><span id="03f8" class="le jt hi la b fi lj lg l lh li">class ShipFactory {</span><span id="3f34" class="le jt hi la b fi lj lg l lh li">    constructor(product) {</span><span id="1de4" class="le jt hi la b fi lj lg l lh li">        this._product = product;</span><span id="3c28" class="le jt hi la b fi lj lg l lh li">    }</span><span id="8a30" class="le jt hi la b fi lj lg l lh li">    step1 () {</span><span id="fb89" class="le jt hi la b fi lj lg l lh li">        return 'Add floatation technology'</span><span id="4ace" class="le jt hi la b fi lj lg l lh li">    }</span><span id="31b4" class="le jt hi la b fi lj lg l lh li">    step2 () {</span><span id="0230" class="le jt hi la b fi lj lg l lh li">        return 'Add rudder controls'</span><span id="f065" class="le jt hi la b fi lj lg l lh li">    }</span><span id="2fcf" class="le jt hi la b fi lj lg l lh li">    step3 () {</span><span id="966d" class="le jt hi la b fi lj lg l lh li">        return 'Add diesel power'</span><span id="0913" class="le jt hi la b fi lj lg l lh li">    }</span><span id="8635" class="le jt hi la b fi lj lg l lh li">    getBuild () {</span><span id="3dde" class="le jt hi la b fi lj lg l lh li">        return 'Build'</span><span id="6df5" class="le jt hi la b fi lj lg l lh li">    }</span><span id="0068" class="le jt hi la b fi lj lg l lh li">}</span></pre><p id="e60e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以看到所有三个工厂都公开了相同的接口。这就使得我们抽象的工厂有可能适应我们的工厂，创造出具体的产品。我们现在可以说</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="5c2d" class="le jt hi la b fi lf lg l lh li">let AbstractCar = new CarFactory(‘car’);</span><span id="c8e6" class="le jt hi la b fi lj lg l lh li">let AbstractBicycle = new BicycleFactory(‘bicycle’);</span><span id="573c" class="le jt hi la b fi lj lg l lh li">let AbstractShip = new ShipFactory(‘ship’);</span><span id="de37" class="le jt hi la b fi lj lg l lh li">let CarShop = new VehicleFactory(AbstractCar);</span><span id="871a" class="le jt hi la b fi lj lg l lh li">let BicycleShop = new VehicleFactory(AbstractBicycle);</span><span id="c2a1" class="le jt hi la b fi lj lg l lh li">let ShipShop = new VehicleFactory(AbstractShip);</span></pre><p id="24eb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，我们可以通过调用以下命令来获取具体的类:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="73c6" class="le jt hi la b fi lf lg l lh li">CarShop.build();</span><span id="9851" class="le jt hi la b fi lj lg l lh li">BicycleShop.build();</span><span id="1049" class="le jt hi la b fi lj lg l lh li">ShipShop.build();</span></pre><p id="8724" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们再次从工厂中抽象出具体类的创建。我们已经成功地将创造的过程(实际的工厂)与产品是如何被创造出来的(抽象的工厂)分离开来；</p><p id="d78e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这就是构建器模式的内容，以及如何用Javascript成功实现它。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><h1 id="7c9f" class="js jt hi bd ju jv lv jx jy jz lw kb kc kd lx kf kg kh ly kj kk kl lz kn ko kp bi translated">进一步阅读</h1><ol class=""><li id="5b8a" class="ma mb hi iw b ix kq jb kr jf mc jj md jn me jr mf mg mh mi bi translated"><a class="ae mj" href="https://iq.opengenus.org/inheritance/" rel="noopener ugc nofollow" target="_blank">深入了解继承— OpenGenus </a></li><li id="193f" class="ma mb hi iw b ix mk jb ml jf mm jj mn jn mo jr mf mg mh mi bi translated"><a class="ae mj" href="https://www.geeksforgeeks.org/difference-between-abstract-class-and-concrete-class-in-java/" rel="noopener ugc nofollow" target="_blank">抽象类和具体类的区别——Geeksforgeeks</a></li></ol></div></div>    
</body>
</html>