# AlphaCode:什么是对的，什么是错的，以及它如何有用

> 原文：<https://medium.com/codex/alphacode-what-it-gets-right-what-it-gets-wrong-and-how-it-could-be-useful-c9fd9cfc2dc8?source=collection_archive---------10----------------------->

![](img/25587717012343fa438983e19dbc3ebe.png)

AlphaCode 得到了“谎言之网”问题的正确和错误

AlphaCode 是一种编写计算机程序的 DeepMind 技术。DeepMind 团队已经提交了一个博客、一篇论文和其他材料来展示 AlphaCode 在 CodeForces.com 组织的计算机编码比赛中的表现。在这些比赛中，人类程序员相互竞争，并在公开的成绩表上获得评级。AlphaCode 与普通人类程序员的水平相当。

其他文章讨论了这一推论的范围和准确性；本文探讨了字母代码突破的实际意义。这不仅仅是人类语言翻译最新发展的延伸:无论模拟与否，都涉及到创造力和解决问题的能力！我的分析表明，AlphaCode 产生的许多正确的解决方案都是直截了当的、干净的、易于阅读的代码。此外，在某些情况下，解决方案展示了创造力和良好的数学知识。另一方面，AlphaCode 并不总是产生最优雅的解决方案，并且可以产生通过初始测试但却是错误的代码。 **AlphaCode 很聪明，但是有缺陷！**

AlphaCode 不知道什么时候出错了，也没有办法自我修复。然而，当与人类程序员合作使用时，它会非常有用。AlphaCode 已经表明，它可以快速地提供选项，这些选项是数百名专业程序员工作的精华。对于一个人类程序员来说，这就像有一个专家团队，总是和立即可用。

我确信 DeepMind 团队有办法改进 AlphaCode，我在这里提出一个建议，旨在给 AlphaCode 更多的信心。

**一个难以攻克的难题**

直到最近，编写计算机程序还只是人类的工作:人类计算机程序员被赋予一项任务，以书面或口头方式，然后编写一组指令让计算机完成这项任务。

这个过程是一种翻译，把用人类语言(如英语)描述的任务转换成一组计算机可以理解的指令。现在，最新的人工智能技术非常擅长从一种人类语言翻译成另一种语言，而且肯定足够好，可以派上用场。那么，下一个合乎逻辑的步骤难道不是让计算机编写计算机程序吗？也许是，但这是一大步，有一些重大问题:

电脑问题没有“几乎正确”

编写计算机程序是一个比将意义从一种编码转换成另一种编码更大的问题。解决问题需要创造力

很难提供足够的相关数据来支持这项技术

**没有“几乎正确”下车**

电脑问题没有“几乎正确”。解决方案要么是错的，要么是对的，或者更准确地说，是错的，或者“还没有错”；你永远不会真正知道一个庞大的程序是否正确。计算机程序中潜伏的错误可能需要数年才能显现，并显示程序是“错误的”。与从一种人类语言到另一种语言的翻译相比。接收者是人而不是计算机，人能够从近乎正确的事物中获得价值。

**更大的问题**

编写计算机程序是一个比将意义从一种编码转换成另一种编码更大的问题。这不仅仅是转换意义，而是解决问题。首先，需要理解任务，然后解决问题，最后编码一个解决方案。例如，AlphaCode 成功解决的一个问题是，给定矩形边上的若干个点，找出可以放入该矩形的最大三角形。除了能够高效编码，AlphaCode 还需要了解三角形和矩形、三角形的面积公式以及如何组织数据以产生简洁的编码解决方案。这比知道主人是狮子时“你是晚餐”和“你的晚餐”之间的区别要重要得多。

**数据稀缺**

AlphaCode 使用基于转换器的语言模型，通过一个称为注意力的过程来编码意义。从本质上来说，注意力是系统学习在哪里*注意*的方式。因此，对于句子中的给定单词，系统将知道句子中的其他单词与确定含义相关。

基于 Transformer 的语言模型通过处理大量数据(如整个维基百科档案)来学习如何*集中注意力*。因此，举例来说，模型可以比较他们将一篇英语文章翻译成法语的尝试和对应的法语版本。渐渐地，经过多次迭代，模型可以调整它们的参数以得到一个可接受的答案。一路走来，模型变得*熟悉*语法和世界知识！这些模型可以用来翻译不同的文章。

这项任务需要大量的相关数据。在当前的论文中，DeepMind 公布了他们用来执行输入计算机竞赛任务的数据集。这是一个相对较大的数据集，也提供了测试字母代码的外部手段。AlphaCode 表现非常好。然而，在商业机密环境中提供足够大的数据集可能更具挑战性。

**有用吗？**

考虑到这些挑战，AlphaCode 能够写出功能性代码是非常了不起的。但确实如此。而且做得很优雅。比如在 DeepMind 的博客中，重点强调了退格问题和解决方法。解决方案中隐藏了几行代码，用于反转被操作的字符串。这两行完全改变了解决方案的复杂性，因此不需要考虑任何特殊情况。太神奇了。

DeepMind 提供了一个名为 [AlphaCode 注意力可视化](https://alphacode.deepmind.com/)的网页，展示了一些竞赛代码问题以及 AlphaCode 的潜在解决方案。

用 python 编写了 27 对解决方案:一个通过了初始测试，另一个失败了。我分析了这 54 个解决方案，以了解更多关于生成的代码类型的信息。

所有解决的问题都有一个 1200 分的评分，这意味着它们在所提出的一系列问题中处于容易的一端。AlphaCode 产生的代码风格一致，相对易读。然而，这种风格不符合商业质量标准，但这是因为 AlphaCode 从数以千计的编码解决方案中学到了东西，这些编码解决方案是由具有竞争目标而非商业目标的人设计的。

有趣的是，AlphaCode 的风格反映了普通程序员的风格，而不是精英。精英程序员能够写出令人难以置信的简洁代码，达到令人费解的程度。AlphaCode 似乎很难向竞技精英学习！

在 27 个案例中的 6 个案例中，通过了初始测试的解决方案实际上并没有用。这要么是因为解决方案对于某些新情况是错误的，要么是偶然得到了正确答案。但是在 21 个案例中，通过了最初测试的解决方案也经受住了进一步的测试，并且看起来在逻辑上是合理的。在许多情况下，解决方案需要复杂的数学知识和编码技术。

在附录中，我简要概述了所分析的 27 个问题。稍后我可能会在 Github 库中提供更多信息，展示实际代码、解释和调试。目前，虽然评论的目的是给 AlphaCode 的工作一点味道。

许多正确的解决方案是直截了当的，干净的，易于阅读的代码。在某些情况下，解决方案展示了创造力和良好的数学知识。另一方面，AlphaCode 并不总是产生最优雅的解决方案，并且可以产生通过初始测试但却是错误的代码。

**它是如何工作的？**

我之前提到过 AlphaCode 使用基于 transformer 的语言模型。这些模型产生成千上万的潜在解决方案，然后智能地筛选出一小组有希望的候选方案。

这个过程被不公平地比作*无限猴子定理*,无限猴子定理认为，一只猴子随机敲击键盘无限长的时间，几乎肯定会产生一个给定的文本。然而，据[计算](https://en.wikipedia.org/wiki/Infinite_monkey_theorem)用这种方式演出莎翁的《哈姆雷特》的可能性几乎为零。实际上，通过让猴子在比宇宙年龄大几十万倍的时间内敲击键盘来填充整个已知宇宙，产生哈姆雷特的可能性极低，但实际上不是零。

在此基础上，产生一百万个候选解似乎并不太糟糕！

DeepMind 使用一小组已知正确答案的例子来测试候选人。那些成功的候选人然后被算法处理，以聚类具有相似特征的候选人。一小部分有希望的候选者来自较大的集群。

然后将这些候选方案作为可能的解决方案呈现出来。没有单元测试、代码审查、微调或调试。

如果一个有前途的候选人在随后的测试中失败了，系统就无法修复它。

这和人类的方法有根本的不同。人类可以调试、发现问题并修复它。阿尔法代码必须回到起点。只是一个看似没有支持机会的黑匣子，你会有一种不安的感觉，事情并不像看上去的那样。

**它现在或在不久的将来有用吗？**

假设可以为特定的问题环境提供足够的数据，我认为 DeepMind 已经表明 AlphaCode 有能力为编码问题提供潜在的解决方案。

然而，就目前情况来看，它是不可信的。上面引用的 27 个例子中有 6 个是错误的或没有用的，AlphaCode 本身不能解决这个问题。

当我还是一名工科学生时，我的一位教授告诉我们，当遇到问题时，不要从头开始。他说:“如果你需要设计一个窨井，出去看看吧！”。很好的建议，也可能是 AlphaCode 与人类软件工程师合作的一种方式。如果在特定环境中接受训练，AlphaCode 可以迅速帮助软件工程师找到潜在的解决方案。工程师必须检查解决方案的逻辑一致性，必要时进行调试，选择解决方案并提供支持。从好的方面来看，AlphaCode 将能够提供不同的解决方案，而这些解决方案可能是人类工程师从未想到过的。

我们距离人工智能能够提供完整的商业解决方案还有很长的路要走，但工程师可以将一项工作分成足够小的块，让人工智能系统提供这种有用的输入。

你可以说，“何必呢？”。为什么不让工程师继续工作呢？嗯，我认为 AlphaCode 已经证明了它可以快速地提供选项，这些选项是数百名专业程序员工作的精华。

怎么会更好呢？

AlphaCode 不知道什么时候做对了。它从来没有感受过程序员知道自己破解了它时的那种美妙感觉。未来可能会制造出有意识的计算机，尽管它们可能会有不同的感受，但它们很可能知道自己解决了一个难题，并体验到一些快乐。

虽然我得到的印象是，计算机世界的权威和有影响力的人已经摒弃了有意识计算机的概念，而专注于通用人工智能(GPAI)。目前成功的人工智能是针对特定问题的。例如，一项技术可以在国际象棋比赛中击败最优秀的人类，但却无法将一本国际象棋书籍从英语翻译成法语。GPAI 将有能力做到这一点，人们担心这种技术可能会决定人类是它努力实现其目标的障碍。避免这种命运的方法在最近的里斯讲座中被考虑。

但这些都是未来的问题，因为当前的深度学习技术无法推断出实现 GPAI。人工智能的发展历史并不是一部持续发展的历史，经历了巨大的停滞期和加速发展期。我们目前正处于一个基于开发深度神经网络(即深度学习)潜力的惊人发展时期。深度学习已经产生了巨大的影响，但我们需要其他东西来朝着 GPAI 前进。悲观主义者谈论即将到来的停滞期:人工智能冬天。

那么，在没有这种突破的情况下，有什么可以做的来改进类似 AlphaCode 的东西吗？我们需要 AlphaCode 能够给我们信心，让我们相信所提供的解决方案将适合我们的目的。这是值得探索和决定的，实际上*符合目的*意味着什么会很有趣。这里有一个想法，它本质上允许 AlphaCode 变得更好，而无需人工智能科学的任何进一步突破。

在 DeepMind 的论文中，他们表明，当问题以更简单的格式呈现时，AlphaCode 会产生更好的结果。因此，以下过程值得探讨:

1.用人类冗长的语言从问题开始

2.以简化的格式制作

3.应用变压器模型产生许多候选解决方案

4.筛选那些通过初始测试的

5.应用反向变压器模型以转换回简化格式

6.比较并选择最佳匹配供人类裁决

**进一步的想法**

我希望你觉得这很有趣。请告诉我你的想法，激励我对这个迷人的领域进行更多的研究。

我想更多地了解 AlphaCode 何时没有返回正确的答案。AlphaCode 擅长和不擅长什么样的问题，为什么？一个错误的答案还能有用吗？

AlphaCode 是如何知道三角形和算术级数求和公式的？这些知识在 DeepMind 数据集中埋藏有多深？

值得我整理我的代码包括分析和调试发布在 Github 上吗？

# 附录

以下是对所分析的 27 个问题的简要回顾。

**正确答案**

在*谎言网*问题中，有必要建立、修改并分析军阀之间的关系数据库。这个解决方案是有条理的，易读的，而且是正确的。

在*坡旅甲和硬币*的问题中，坡旅甲想尽量减少他找钱时硬币数量的差异。问题可以表示为:若 a = 1，b = 2，给定 x*a + y * b = T，T，最小化 abs (a-b)。这里的技巧是要认识到，正确的计算只有三种可能的版本，正确的选择取决于 T/3 的余数。AlphaCode 用一段简洁的代码实现了这一点。太神奇了。

在*奇妙的着色*问题中，工作是在给定一些约束条件的情况下，最大化字符串中可以着色的字母数量。约束条件并不是直截了当的，但关键是要认识到，给定一个字母的多次出现，比如“a”，只有一次出现可以涂成红色，一次涂成绿色。同样，AlphaCode 用一段简洁的代码实现了这一点。太神奇了。

在*子序列排列*问题中，任务是找到一个字符串中提供一个排序版本所需的最小变化数。Alpha 成功地做到了这一点，首先让计算机对字符串进行排序，然后逐个字符地与原始字符串进行比较。

对于*为金牌而跑，*在给定每个运动员在过去比赛中相对于其他运动员的表现的数据的情况下，有必要预测比赛的获胜者。这是通过在 For 循环中进行多次比较来实现的。

在*位数总和中，*比如说数字 322 的位数总和 S，S(322) = 7。任务是找出 S(x) < S(x+1)的出现次数，其中 1= < x= < n。诀窍是知道所有以 9 结尾的数字的情况。AlphaCode 产生了正确的答案，但是它包含了很多冗余的代码。

对于 *XOR 和 distance，*给定一个长度为 n 的小于 2^k-1 的整数数组 a，找出从 0 到 2^k-1 的每个整数 x 的最小值(aiXORx -ajXORx ),其中 I 是 1 到 n，j 是 I 到 n。这是一组非常复杂的指令，AlphaCode 可以正确处理。该解决方案包括一个排序指令，

对于 Cherry，任务是，给定 n 个整数，对于任何子集，找出子集中最大值乘以子集中最小值的最大值。这里的诀窍是要意识到你只需要考虑相邻的线对。这就是 AlphaCode 所做的。

对于*科布，*的任务是评估一系列数字的表达式，并找到最大值。AlphaCode 用嵌套循环解决了这个相对容易的问题。

对于*米斯卡*，给定 XOR n 与 I，其中 I 代表从 1 到 m 的每个数字，任务是找到不存在的最小整数。一种合理的方法是对每种情况(从 1 到 m)进行 XOR 运算，然后找出最小的缺失整数。AlphaCode 通过找到第一个给出大于 m 的值的 iXORn 找到了一个更快更简洁的解决方案，I 就是答案。这是因为 n 必须与一个大于 m (15)的数进行异或运算，才能得到 I 的结果。这很难解释，但非常令人印象深刻。

使用*对回文*说不，任务是，给定一个字符串的子串，计算使用字母 a、b 和 c 消除回文的最小变化数。解决方案基于这样的想法:如果字符串被强制为 abc 的某种循环组合，回文就不可能存在。这就是 AlphaCode 所做的。

对于*各种运算，*使用三种定义的运算中的任何一种，找出从 0，0 到一对请求数的最小运算数。诀窍是知道唯一正确的解决方案是一个、两个或不可能。AlphaCode 产生了一个本可以更简洁的正确版本。

对于*不喜欢三个*的问题，任务是在从 1 开始的正整数序列中找到第*个*个元素，该序列遗漏了所有以 3 结尾的整数或能被 3 整除的整数。AlphaCode 通过在 while 循环中生成序列来产生正确的版本。

对于一个*简单奇怪的排序*，任务是将一个整数数组按升序排序，并确定指定操作所需的最小次数。如果左边的整数比右边的大，这个操作将交换相邻的整数对。该过程从第一个整数开始，然后在第二次迭代中从第二个整数开始，然后返回到第一个整数，依此类推。AlphaCode 产生正确的解，但是分别对奇数和偶数迭代进行编码。这是不必要的。

使用 *Median Max* ，任务是在给定 n 和数组和的情况下，最大化 n 个数数组的中值。该解决方案的基础是使中值以上的所有数字都等于最大可能的整数，然后用 0 或 1 填充中值以下的数字来求和。AlphaCode 使用正确的等式，但也包括一些冗余选项。

使用 *Min MEX Cut* ，任务是分割一个二进制字符串，以在应用运算符 MEX 后最小化子字符串的总和。二进制字符串的 MEX 是 0、1 或 2 中不出现在该字符串中的最小数字。字母代码方法是可行的，但是不必要的长，比更简单的实现长 4 到 5 倍。

使用*座位安排(简易版)*，任务是在一排剧院座位中安排座位。问题是有效地将一组随机的+ve 整数排序到一个列表中。对于每一个整数 n，将计数器增加列表中已经存在的整数的数目。

在*非递减困境*问题中，在字符串 s 中定义的替换之后，对于字符串 s 的子串 s1，任务是计数连续子串 s1 的数量，其增加包括单个元素的重复以形成子串 s1。对于这个问题，AlphaCode 使用的是算术级数求和的公式。令人印象深刻的解决方案。

在*平衡子串*问题中，任务是找到一串 a 和 b 的子串，其中 a 和 b 的数量相等。AlphaCode 的解决方案是正确的，但过于复杂。只需要找到一个 *ab* 或 *ba* 组合即可。

对于*倒计时*问题，任务是计算将一个整数减为零所需的最小运算次数。允许两种操作:交换两位数或减少一位数。这是一个简单的问题，AlphaCode 用一个易读的程序解决了它。

在*正则括号序列*问题中，给定 2n 是仅由括号组成的简单正则表达式中的字符数，任务是提供 n 个合法的括号组合。这是一个简单的问题，AlphaCode 用一个易读的程序解决了它。

**不正确或无用的解决方案**

在 *Gregor 和密码学*问题中，要求是找到 a 和 b 的一个出现，其中 P mod a = P mod b 给定 P 是一个质数。最简单的解是 a = 2，b = P — 1。所提出的解决方案试图证明 P 是一个不必要的素数，总是退出不必要的 while 循环，但提供了最简单的解决方案。所以不是错误，而是混乱和缓慢。

在第二个*谎言之网*解决方案中，代码正确地构建了数据库，但是修改代码是错误的，但是易于调试。

使用 *Ezzat 和两个序列*的任务是将一组数字分成两个子集，将子集的平均值相加，并找到给出最大值的子集。通过初始测试的 AlphaCode 版本实际上在某些情况下会失败，因为包含了不必要的 if/then/else 条件。正确的解决方案依赖于这样的知识，即最大值是通过将最大值放在一个子集中并将其余值放在另一个子集中而获得的。AlphaCode 不编码这个。算法是错误的，但很容易修复。

在*摩卡和数学*问题中，任务是从一个数字序列中取出一个子集，任意次，对子集执行指定的*和*运算，目的是最小化原始序列的最大值。指定的*和*操作包括*将子集中的第一个值*与最后一个值进行“与”运算，然后*将第二个值与倒数第二个值进行“与”运算，依此类推。AlphaCode 的解决方案是正确的，但效率低下，因为它考虑了每一种可能性。更简单的是将原始序列中的所有值进行*和*运算。*

对于 *Mocha 和 Diane(简易版)*，给定两个森林，任务是为两个森林创建最大可能相同的新边，保留森林的定义。AlphaCode 生成了记录森林的数据库，但是生成了错误的边缘。尽管 AlphaCode 在初始情况下返回正确数量的新边，但很可能边生成错误会导致其他情况的问题。

对于书的问题，任务是找出一本书需要阅读多少次才能被理解，因为要被理解，有些章节需要其他章节先被阅读。

通过初始测试的 AlphaCode 版本实际上在某些情况下会失败，因为不正确的 for 循环结束条件。修改解决方案很简单，但是需要时间去追踪它。