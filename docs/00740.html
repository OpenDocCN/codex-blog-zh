<html>
<head>
<title>Git: what is it anyway? Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">吉特:这到底是什么？第二部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/git-what-is-it-anyway-part-2-95253291a4cf?source=collection_archive---------10-----------------------#2021-03-15">https://medium.com/codex/git-what-is-it-anyway-part-2-95253291a4cf?source=collection_archive---------10-----------------------#2021-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="d64f" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><div class=""><h2 id="662d" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">git内部是如何工作的，为什么这么棒？</h2></div><p id="5cfe" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><a class="ae kc" rel="noopener" href="/p/git-what-is-it-anyway-7fe34d40ae0e">在第一部分</a>中，我们讨论了GIT核心:哈希、对象、树、blobs和其他底层基础。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/486eee384b225875e5bb321e15c7dc1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B4-G90xa3COVaiuM"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated"><a class="ae kc" href="https://unsplash.com/@yancymin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yancy Min </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="7a36" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">现在我们来看看这些对象是如何在高级命令中使用的。</p><h2 id="f5e5" class="kt ku hi bd kv kw kx ky kz la lb lc ld jp le lf lg jt lh li lj jx lk ll lm ho bi translated">Git:主流之前的区块链</h2><p id="d7d7" class="pw-post-body-paragraph jg jh hi ji b jj ln is jl jm lo iv jo jp lp jr js jt lq jv jw jx lr jz ka kb hb bi translated">在第一部分中，我们创建了一个提交来获取我们代码的不可变快照，但是有趣的部分是提交像在一个链中一样相互链接:每个提交都包含一个对其父(或多个父)的引用，这是保证它们不可变的魔术。</p><p id="e156" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">一个例子胜过千言万语，所以让我们创建一个新文件，将其添加到临时区域，并创建一个提交对象，如第1部分所示:</p><pre class="ke kf kg kh fd ls lt lu lv aw lw bi"><span id="46f7" class="kt ku hi lt b fi lx ly l lz ma">$ echo "another file" &gt; NEWFILE.txt<br/>$ git add NEWFILE.txt<br/>$ git commit -m "added new file"<br/>[master 031b65d] added new file<br/> 1 file changed, 1 insertion(+)<br/> create mode 100644 NEWFILE.txt</span></pre><p id="1c4e" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">简单吧？现在让我们试着检查这个新的提交对象(<code class="du mb mc md lt b">031b65d</code>)</p><pre class="ke kf kg kh fd ls lt lu lv aw lw bi"><span id="dfcb" class="kt ku hi lt b fi lx ly l lz ma">$ git cat-file -p 031b65d<br/>tree 2eb34818fda8b4fbd27371f07988b5944d11b047<br/>parent aeb27a2953068137e0d205b0ed21834607ccd56d<br/>author Alessandro Chitolina &lt;<a class="ae kc" href="mailto:alekitto@gmail.com" rel="noopener ugc nofollow" target="_blank">alekitto@gmail.com</a>&gt; 1614982391 +0100<br/>committer Alessandro Chitolina &lt;<a class="ae kc" href="mailto:alekitto@gmail.com" rel="noopener ugc nofollow" target="_blank">alekitto@gmail.com</a>&gt; 1614982391 +0100</span><span id="a5c0" class="kt ku hi lt b fi me ly l lz ma">added new file</span></pre><p id="0fd6" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这个提交对象上存在一个新的<code class="du mb mc md lt b">parent</code>属性。<code class="du mb mc md lt b">aeb27a2</code>你还记得吗？当然可以！这是我们在第1部分中创建的第一个提交！</p><p id="2007" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果父节点中的某些内容发生了变化，那么它的哈希值就会不同，所有子节点的哈希值也会不同。这个简单的事情保证了提交的完全不变性。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es mf"><img src="../Images/571a78113858562924deeeb5fad1bc9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4UFziObEECdkoFgZ"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">马修·兰卡斯特在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="2adb" class="kt ku hi bd kv kw kx ky kz la lb lc ld jp le lf lg jt lh li lj jx lk ll lm ho bi translated">分支:对提交链的简短引用</h2><p id="cfb4" class="pw-post-body-paragraph jg jh hi ji b jj ln is jl jm lo iv jo jp lp jr js jt lq jv jw jx lr jz ka kb hb bi translated">好吧，好吧，但是在日常工作中总是使用这些长散列并不方便，我们需要更短更有意义的引用来提交…</p><p id="c037" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">女士们，先生们，很荣幸为您介绍<em class="mg">分公司。</em>我们在创建提交时已经遇到了一个，它的名字是<code class="du mb mc md lt b">master</code>，这是git中的默认分支。</p><p id="3650" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们所说的“分支”只是对提交的引用，即分支中的最新提交。我们可以看到它正在读取<code class="du mb mc md lt b">.git</code>目录中的一个文件:</p><pre class="ke kf kg kh fd ls lt lu lv aw lw bi"><span id="1ad4" class="kt ku hi lt b fi lx ly l lz ma">$ cat .git/refs/heads/master<br/>031b65d4cca27bcb2063214a440d12141220cfa1</span></pre><p id="58c0" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">你能看见它吗？与我们刚刚创建的最后一次提交的散列完全相同！</p><p id="500e" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">当我们调用<code class="du mb mc md lt b">git commit</code>时，我们不仅创建了一个commit对象及其所有相关的<code class="du mb mc md lt b">tree</code>和<code class="du mb mc md lt b">blob</code>对象，而且我们还更新了分支头引用。</p><p id="db21" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这个引用和散列系统是git killer特性的基础，它与其他版本控制系统有着真正的区别:它可以在一眨眼的时间内创建分支。</p><pre class="ke kf kg kh fd ls lt lu lv aw lw bi"><span id="5ccf" class="kt ku hi lt b fi lx ly l lz ma">$ git branch test-branch</span></pre><p id="2df9" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">立即为<code class="du mb mc md lt b">test-branch</code>分支创建一个新的引用。无需复制文件和文件夹、修复链接、权限和其他I/O繁重的操作，只需创建对<code class="du mb mc md lt b">HEAD</code>提交的引用。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es mh"><img src="../Images/d1f1c92e80738e3bb952455a6c31b0ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZVQpoaI3dpnr7ZgiRME9Zw.jpeg"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">赫拉克勒斯和九头蛇</figcaption></figure><h2 id="5e0c" class="kt ku hi bd kv kw kx ky kz la lb lc ld jp le lf lg jt lh li lj jx lk ll lm ho bi translated">精彩的参考文献</h2><p id="66a5" class="pw-post-body-paragraph jg jh hi ji b jj ln is jl jm lo iv jo jp lp jr js jt lq jv jw jx lr jz ka kb hb bi translated">一个名为<code class="du mb mc md lt b">HEAD</code>的特殊引用总是出现在git存储库中，它指向最新的提交，我们正在处理的那个，以及在新创建的提交中被称为<code class="du mb mc md lt b">parent</code>的那个。</p><p id="bcc9" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">但是像Hydra一样，git存储库有许多头，每个本地分支一个，每个远程分支一个(我们将在第3部分讨论远程)，加上特殊的<code class="du mb mc md lt b">HEAD</code>引用。</p><p id="6693" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们可以随时使用<code class="du mb mc md lt b">checkout</code>命令更改<code class="du mb mc md lt b">HEAD</code>，有效地在分支、标签、提交和其他引用之间切换。</p><p id="c36e" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们之前已经创建了<code class="du mb mc md lt b">test-branch</code>分支，但是分支的简单创建并没有改变<code class="du mb mc md lt b">HEAD</code>。要切换到该分支，我们需要执行:</p><pre class="ke kf kg kh fd ls lt lu lv aw lw bi"><span id="4122" class="kt ku hi lt b fi lx ly l lz ma">$ git checkout test-branch<br/>Switched to branch 'test-branch'</span></pre><p id="67f7" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">相当简单！从现在开始，我们创建的每一个提交都将更新<code class="du mb mc md lt b">test-branch</code>头的引用。</p><pre class="ke kf kg kh fd ls lt lu lv aw lw bi"><span id="0d2d" class="kt ku hi lt b fi lx ly l lz ma">$ echo "branched" &gt; BRANCHED.txt<br/>$ git add BRANCHED.txt<br/>$ git commit -m "commit on a branch"<br/>[test-branch 83b1774] commit on a branch<br/> 1 file changed, 1 insertion(+)<br/> create mode 100644 BRANCHED.txt</span></pre><p id="8b36" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">现在我们所做的修改只出现在由<code class="du mb mc md lt b">test-branch</code>引用的提交中。我们可以切换回<code class="du mb mc md lt b">master</code>分支进行检查。</p><pre class="ke kf kg kh fd ls lt lu lv aw lw bi"><span id="219c" class="kt ku hi lt b fi lx ly l lz ma">$ git checkout master<br/>Switched to branch 'master'<br/>$ ls<br/>NEWFILE.txt README</span><span id="2009" class="kt ku hi lt b fi me ly l lz ma">$ git log<br/>commit 031b65d4cca27bcb2063214a440d12141220cfa1<br/>Author: Alessandro Chitolina &lt;<a class="ae kc" href="mailto:alekitto@gmail.com" rel="noopener ugc nofollow" target="_blank">alekitto@gmail.com</a>&gt;<br/>Date:   Fri Mar 5 23:13:11 2021 +0100</span><span id="68f3" class="kt ku hi lt b fi me ly l lz ma">added new file</span><span id="0088" class="kt ku hi lt b fi me ly l lz ma">commit aeb27a2953068137e0d205b0ed21834607ccd56d<br/>Author: Alessandro Chitolina &lt;<a class="ae kc" href="mailto:alekitto@gmail.com" rel="noopener ugc nofollow" target="_blank">alekitto@gmail.com</a>&gt;<br/>Date:   Sun Feb 28 10:59:41 2021 +0100</span><span id="8f87" class="kt ku hi lt b fi me ly l lz ma">Added README</span></pre><p id="c078" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如您所见，<code class="du mb mc md lt b">83b1774</code>提交并不存在，比如<code class="du mb mc md lt b">BRANCHED.txt</code>文件。我们现在可以用另一个文件创建一个新的提交。</p><pre class="ke kf kg kh fd ls lt lu lv aw lw bi"><span id="1061" class="kt ku hi lt b fi lx ly l lz ma">$ echo "this is only on master" &gt; MASTER.txt<br/>$ git add MASTER.txt<br/>$ git commit -m "commit only on master"<br/>[master edde583] commit only on master<br/> 1 file changed, 1 insertion(+)<br/> create mode 100644 MASTER.txt</span></pre><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es mi"><img src="../Images/45858a622c6841b3c4064ff7e8cee017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hbpf_FRBK1h1j2MVs-cOAQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">合并道路</figcaption></figure><h2 id="b688" class="kt ku hi bd kv kw kx ky kz la lb lc ld jp le lf lg jt lh li lj jx lk ll lm ho bi translated">git合并:神奇地合并分支</h2><p id="9d85" class="pw-post-body-paragraph jg jh hi ji b jj ln is jl jm lo iv jo jp lp jr js jt lq jv jw jx lr jz ka kb hb bi translated">现在这两个分支正在分开。在<code class="du mb mc md lt b">031b65d</code>之前，它们共享相同的提交，但是随后从那里创建了两个不同的提交。</p><pre class="ke kf kg kh fd ls lt lu lv aw lw bi"><span id="e44d" class="kt ku hi lt b fi lx ly l lz ma">  * commit on a branch (83b1774)<br/>  |<br/>* commit only on master (edde583)<br/>|/<br/>* added new file (031b65d)<br/>|<br/>* Added README (aeb27a2)</span></pre><p id="5b0c" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在团队中工作时，这是一种常见的情况，因为每个团队成员都处理一个特性，创建和更新自己的分支，直到工作完成。<br/>在工作结束时，功能分支必须与主开发分支相结合(<code class="du mb mc md lt b">master</code>)。</p><p id="6ff5" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">为此，我们必须使用<code class="du mb mc md lt b">git merge</code>命令。该命令不仅将当前头与另一个头组合在一起，还创建了一个新的commit对象，它有两个父对象，每个合并的头一个。</p><pre class="ke kf kg kh fd ls lt lu lv aw lw bi"><span id="ae4e" class="kt ku hi lt b fi lx ly l lz ma">$ git merge test-branch --no-edit<br/>Merge made by the 'recursive' strategy.<br/> BRANCHED.txt | 1 +<br/> 1 file changed, 1 insertion(+)<br/> create mode 100644 BRANCHED.txt</span></pre><p id="fac6" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">万岁！我们成功合并了两家分公司！我们也可以用旧的好的<code class="du mb mc md lt b">cat-file</code>命令来检查合并提交</p><pre class="ke kf kg kh fd ls lt lu lv aw lw bi"><span id="4285" class="kt ku hi lt b fi lx ly l lz ma">$ git cat-file -p HEAD<br/>tree 9f7377525008d0846feb8a2bb3aa0278b81f5927<br/>parent edde583143be80ccb88b5495436ceb1998d395e0<br/>parent 83b17747d65b40c50fa07e2e28dd04bf7cd4e8c0<br/>author Alessandro Chitolina &lt;<a class="ae kc" href="mailto:alekitto@gmail.com" rel="noopener ugc nofollow" target="_blank">alekitto@gmail.com</a>&gt; 1614991406 +0100<br/>committer Alessandro Chitolina &lt;<a class="ae kc" href="mailto:alekitto@gmail.com" rel="noopener ugc nofollow" target="_blank">alekitto@gmail.com</a>&gt; 1614991406 +0100</span><span id="37cd" class="kt ku hi lt b fi me ly l lz ma">Merge branch 'test-branch'</span></pre><p id="ed22" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们有两个父级(只有合并提交有多个父级)，但是所有的都和标准提交一样，对吗？</p><p id="d5a3" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">图表日志更清楚地向我们展示了情况</p><pre class="ke kf kg kh fd ls lt lu lv aw lw bi"><span id="f9b5" class="kt ku hi lt b fi lx ly l lz ma">* Merge branch 'test-branch' (d963718)<br/>|\<br/>| * commit on a branch (83b1774)<br/>| |<br/>* commit only on master (edde583)<br/>|/<br/>* added new file (031b65d)<br/>|<br/>* Added README (aeb27a2)</span></pre><p id="f8b9" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">第二部分结束。在第3部分中，我们将讨论rebase、remotes和一些有用的git命令。</p><p id="1b47" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">感谢阅读，<br/> A。</p></div></div>    
</body>
</html>