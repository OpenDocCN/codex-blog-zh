<html>
<head>
<title>Synchronize Different Consumers of the Same Kafka Topic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同步同一Kafka主题的不同消费者</h1>
<blockquote>原文：<a href="https://medium.com/codex/synchronize-different-consumers-of-the-same-kafka-topic-23b30851158e?source=collection_archive---------4-----------------------#2022-07-28">https://medium.com/codex/synchronize-different-consumers-of-the-same-kafka-topic-23b30851158e?source=collection_archive---------4-----------------------#2022-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1650" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分布式系统中的同步是困难的。你的目标可能是尽可能地阻止它。但是有时业务需求引入了协调不同服务的需求，这些服务对数据新鲜度有很强的依赖性。</p><p id="d4ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了一般化，假设架构由<em class="jd"> Service-A、Service-B </em>和<em class="jd"> Service-C. </em>组成，它们都使用来自同一个Kafka主题的消息，但显然根据各自的业务逻辑、API和SLA对它们进行不同的处理。当<em class="jd"> Service-A </em>处理一条消息时，<em class="jd"> </em>调用<em class="jd"> Service-B </em>和<em class="jd"> Service-C </em>的API，并期望这条消息包含在其中。这就是为什么只有在<em class="jd"> Service-B </em>和<em class="jd"> Service-C </em>成功处理了<em class="jd"> </em>之后<em class="jd"> Service-A </em>才能处理一条消息。如果其中一个<em class="jd">T21出现故障或者那里的数据没有更新，那么<em class="jd">服务-A </em>唯一能做的就是停止并等待。换句话说，<strong class="ih hj">从<em class="jd">可用性</em>和<em class="jd">数据新鲜度</em>方面</strong>来看，都存在对Service-B和Service-C的硬依赖。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/82d75d0493309c56236758765992ab97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*Namzulrgkmoc_GzfuAYuig.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">服务A应该在消息被B和c处理之后才处理消息。</figcaption></figure><p id="0f54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">架构挑战是如何通过最可扩展、最具成本效益和最简单的方法在<em class="jd">服务-A </em>及其依赖关系<em class="jd"> </em>之间进行同步。是的，我相信huber系统的设计原则是降低复杂性。(如果你还不够确信，可以看看这本伟大的书<a class="ae jq" href="https://www.amazon.com/Philosophy-Software-Design-2nd/dp/173210221X" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jd"/></strong></a><em class="jd"/>】软件设计的哲学，它以对软件和系统设计中复杂性的危险的高尚解释开始)。</p><p id="0754" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，为什么我们最初会给自己制造这个问题呢？</p><p id="8930" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你可能会问自己，如果<em class="jd"> Service-A </em>对消息顺序如此敏感，那么最简单的(也许是唯一的！)保证顺序的方法是执行由<em class="jd">服务-B </em>和<em class="jd">服务-C </em>完成的加工，作为<em class="jd">服务-A </em>内的连续步骤。你为什么把它们分发到各处？</p><p id="ecfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，毫无疑问，微(或迷你)服务架构有其成本，但这种架构风格提高了团队速度，因为每项服务都更容易开发、测试、部署，更重要的是，更容易扩展、维护和运营。这肯定不是我们组织独有的，但就个人而言，通过观察Dev org的实际情况，我已经确信并欣赏了这些好处。想象一下<em class="jd"> Service-A </em>是一个反洗钱检测流程，它消耗付款并评估其风险。<em class="jd"> Service-B </em>处理从同一个支付主题中提取的实体关系，而<em class="jd"> Service-C </em>负责聚合这些支付，并提供有效的时间感知聚合查询。与AML检测(<em class="jd"> Service-A </em>)一样，也存在欺诈(姑且称之为<em class="jd"> Service-A1 </em>)，它们具有完全不同的业务逻辑，但仍然需要查询实体关系图和聚合简档。我们不希望每个团队都投资于时序数据库和图形数据库技术选择，获得如何扩展(或不扩展)和操作的经验，而不是专注于各自的业务，即反洗钱或欺诈检测。</p><p id="7e87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">回到我们最初的问题… </strong></p><p id="b1f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们继续使用AML检测作为<em class="jd"> Service-A </em>的具体示例，它如何确保一旦调用关系API(由<em class="jd"> Service-B </em>公开)或聚合API(由<em class="jd"> Service-C </em>公开)，它将获得最新的结果？如果他们因为某种原因暂时停机或变慢了怎么办？在所有需要的信息都可用之前，检测过程不能处理消息。使用陈旧的信息可能会错过数百万美元的洗钱活动！</p><h1 id="12e9" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">架构模式</h1><p id="9a17" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">这里的核心思想是利用Kafka偏移管理作为跟踪各种服务进度的单一真实来源。偏移量是一个简单的整数，Kafka使用它来保持消费者的当前位置。当前偏移量是指向Kafka在最近一次轮询中已经发送给消费者的最后一条记录的指针。以便消费者不会因为当前偏移而两次获得相同的记录。由于Kafka管理每个主题、消费群和分区的偏移量，这实际上意味着每个单独的记录只能由<topic partition="" offset="">来标识。对于消费者如何向Kafka提交offset有不同的策略，这里我们依赖于只有在消费者成功处理消息之后才完成的提交。</topic></p><p id="cb32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<em class="jd"> Service-A </em>从主题中轮询一条消息时，应该先提取这条消息的分区和偏移量。然后，它调用Kafka admin API来验证这个偏移量已经被与<em class="jd"> Service-B </em>和<em class="jd"> Service-C </em>相关联的消费者组处理了。Kafka admin API是为每个消费者组调用的，用于检索主题分区到偏移量的映射(查看Kafka admin Java客户端的<a class="ae jq" href="https://kafka.apache.org/20/javadoc/org/apache/kafka/clients/admin/AdminClient.html#listConsumerGroupOffsets-java.lang.String-" rel="noopener ugc nofollow" target="_blank"> listConsumerGroupOffsets </a>函数)。每个分区的最小偏移量表示最慢服务的偏移量。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/1775a14e3fcd3ccd63b2f675b237eedf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRz28w-os0OC7hj7eSvG-w.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">Kafka的admin用于确定服务B和服务C的进度</figcaption></figure><p id="8542" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，服务可能会消费各种主题，如消费不同事件类型的<em class="jd"> Service-C </em>来聚合，因此<em class="jd"> Service-A </em>应该清楚地将其依赖关系定义为一个组合&lt; service、topic &gt;的组合，从技术上来说，该组合被转换为一个消费者组。</p><p id="ea9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只要<em class="jd">服务-B </em>和<em class="jd">服务-C </em>之间的最小偏移量低于<em class="jd">服务-A </em>消耗的消息偏移量，它就等待。</p><h2 id="0d46" class="kz js hi bd jt la lb lc jx ld le lf kb iq lg lh kf iu li lj kj iy lk ll kn lm bi translated">更详细的算法…</h2><p id="82b2" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">让我们假设一种情况，其中主题T1的提交偏移量如下:</p><ul class=""><li id="e429" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc ls lt lu lv bi translated">消费者组CG-A(服务-A): <br/>分区p1 (C1): 0 <br/>分区p2 (C1): 0 <br/>分区p3 (C2): 0</li><li id="c2de" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">消费群CG-B (Service-B): <br/>分区p1 (C1): 30 <br/>分区p2 (C2): 30 <br/>分区p3 (C3): 10</li><li id="1875" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated">消费群CG-C (Service-C): <br/>分区p1 (C1): 23 <br/>分区p2 (C2): 52 <br/>分区p3 (C3): 15</li></ul><p id="7ba3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，t1主题被划分为3个分区。CG-A和CG-B组各由3个消费者组成，因此每个消费者只处理一个分区。但是在CG-A中，p1和p2都由消费者C1处理。</p><p id="500f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">CG-A中的每个消费者都应该保持一个更新的分区图。该地图可以定期更新:</p><pre class="jf jg jh ji fd mb mc md me aw mf bi"><span id="c731" class="kz js hi mc b fi mg mh l mi mj"><strong class="mc hj">for</strong> <!-- -->each dependency consumer group // CG-B, CG-C</span><span id="975e" class="kz js hi mc b fi mk mh l mi mj">{  <br/>admin.listConsumerGroupOffsets <br/>/// (CG-B -&gt; ( p1 -&gt; 30, p2 -&gt; 30, p3 -&gt; 10)), (CG-C -&gt; ( p1 -&gt; 23, p2 -&gt; 52, p3 -&gt; 15))<br/>update partitionMinOffset map <strong class="mc hj">with</strong> <!-- -->minimal offset <br/>/// (P1 -&gt; 23), (p2 -&gt; 30), (p3 -&gt; 10)<br/>}</span></pre><p id="215c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在正在进行的消息轮询期间:</p><pre class="jf jg jh ji fd mb mc md me aw mf bi"><span id="07f6" class="kz js hi mc b fi mg mh l mi mj"><strong class="mc hj">for</strong> <!-- -->every consumed message /// (sorted from early to latest) <br/>{</span><span id="06d8" class="kz js hi mc b fi mk mh l mi mj">set message.offset  = extract the offset of the current message<br/>set message.partition  = extract the partition of the current message</span><span id="b35e" class="kz js hi mc b fi mk mh l mi mj"><strong class="mc hj">while</strong> <!-- -->(message.offset &gt; partitionMinOffset[message.partition])</span><span id="253b" class="kz js hi mc b fi mk mh l mi mj">     wait</span><span id="5cc2" class="kz js hi mc b fi mk mh l mi mj">process /// only now service-A can process the message</span><span id="e935" class="kz js hi mc b fi mk mh l mi mj">manual commit offset /// commit offset after processing successfully</span><span id="6022" class="kz js hi mc b fi mk mh l mi mj">}</span></pre><p id="a918" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于最佳实践是防止将分区静态分配给使用者，因此使用者不能假定已处理分区的列表，而是需要保留所有主题分区偏移量，因为它可能在任何给定的时间点处理这些分区中的任何一个。</p><h2 id="53a5" class="kz js hi bd jt la lb lc jx ld le lf kb iq lg lh kf iu li lj kj iy lk ll kn lm bi translated">假设</h2><p id="4168" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">这种方法在很大程度上基于卡夫卡的抵消，以反映服务的实际进展。实际上，对于如何向卡夫卡提交《偏移》有不同的策略。我们在内部使用<a class="ae jq" href="https://javadoc.io/doc/org.apache.flink/flink-connector-kafka_2.12/1.12.2/index.html" rel="noopener ugc nofollow" target="_blank"> flink-connector-kafka </a>，它仅在检查点完成后提交偏移量(当<a class="ae jq" href="https://nightlies.apache.org/flink/flink-docs-master/api/java/org/apache/flink/streaming/connectors/kafka/config/OffsetCommitMode.html" rel="noopener ugc nofollow" target="_blank"> OffsetCommitMode </a>设置为<a class="ae jq" href="https://nightlies.apache.org/flink/flink-docs-master/api/java/org/apache/flink/streaming/connectors/kafka/config/OffsetCommitMode.html#ON_CHECKPOINTS" rel="noopener ugc nofollow" target="_blank"> ON_CHECKPOINTS </a>)。无论如何，不考虑具体的技术，假设消费者正在禁用默认的自动提交，但是只有在消息被成功处理之后才手动提交偏移量，即使在异步操作的情况下也是如此。</p><h1 id="3363" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">建议的替代方案</h1><p id="c6b6" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">已经考虑的另一种方法是<em class="jd"> Service-B </em>和<em class="jd"> Service-C </em>将省略已处理消息的消息ID到专用输出主题中，并且<em class="jd"> Service-A </em>将加入输出主题和原始主题以获得完整的有效负载。只有当所有三个主题的消息ID都被使用后，<em class="jd"> Service-A </em>才会处理该消息。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ml"><img src="../Images/ad76f1607d525ac3877d981688ef078e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sODZdSVlB_MCZ2E_tiqNgw.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">输出主题方法</figcaption></figure><p id="369b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于以下缺点，这种方法已被拒绝:</p><ul class=""><li id="45fb" class="ln lo hi ih b ii ij im in iq lp iu lq iy lr jc ls lt lu lv bi translated"><strong class="ih hj">来自生产者端的复杂性</strong>:事实上<em class="jd"> Service-B </em>(和<em class="jd"> Service-C) </em>需要写入它自己的内部DB以及输出主题(当然，还要提交Kafka偏移量)，这增加了在某些情况下DB和输出主题这两个接收器不同步的可能性。</li><li id="2ff7" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated"><strong class="ih hj">复杂性</strong>来自消费者端:<em class="jd">服务-A </em>需要在原始T1主题和两个输出主题之间加入，并小心处理其中一个(或多个)非常落后的情况。它可以不崩溃(由于OOM)，但只是停止消费和等待。诚然，像Flink这样的流处理引擎可以通过管理每个源的阻塞队列来处理<a class="ae jq" href="https://www.ververica.com/blog/how-flink-handles-backpressure" rel="noopener ugc nofollow" target="_blank">背压</a>，但是这大大增加了复杂性。</li><li id="8842" class="ln lo hi ih b ii lw im lx iq ly iu lz iy ma jc ls lt lu lv bi translated"><strong class="ih hj">大规模消息量</strong>:这种方法只是大大增加了消息的数量，因为每条消息实际上都是重复的(或三倍的),会影响事件总线的性能和成本。</li></ul><h1 id="7c30" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">总结一下</strong></h1><p id="bf02" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">如果你是一个卡夫卡专家，这可能对你来说是显而易见的，但令人惊讶的是，这不是那么微不足道，以说服人们摆脱额外的输出主题，因为那些基本上已经被卡夫卡抵消本身捕获。</p><p id="3bb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种模式非常适合同一主题的多个消费者。实际上，它甚至可以扩展到他们消费不同主题的情况，只要他们都从一个共同的主题开始。但是这绝对是更复杂的模式，需要后续的文章来证明…</p></div></div>    
</body>
</html>