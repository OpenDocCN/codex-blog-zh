<html>
<head>
<title>Load Balancing with Nginx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nginx实现负载平衡</h1>
<blockquote>原文：<a href="https://medium.com/codex/load-balancing-with-nginx-7d1bb4c24d5d?source=collection_archive---------1-----------------------#2021-04-13">https://medium.com/codex/load-balancing-with-nginx-7d1bb4c24d5d?source=collection_archive---------1-----------------------#2021-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="74e9" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">不要只是试图去理解它。感受一下。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/88198c3d0521d8a00a16d2b4f423cc40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*BbpIqYjceKTgXRaXtMd7Ng.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">使用Nginx实现负载平衡</figcaption></figure><p id="a144" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在本文中，我们将讨论如何在一台拥有多台服务器的本地机器上使用Nginx实现第7层(应用层)负载平衡，提供相同的内容。在我深入细节之前，对于那些不知道Nginx是什么的人</p><blockquote class="kf kg kh"><p id="5e4e" class="jj jk ki jl b jm jn ij jo jp jq im jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated"><strong class="jl hj"> NGINX </strong>是一款免费、开源、高性能、功能丰富、配置简单、资源消耗低的web服务器，还可以充当反向代理、负载均衡器、邮件代理、HTTP缓存等等。</p></blockquote><h1 id="3ac1" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">步骤1:安装并运行Nginx</h1><p id="a09b" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">我用brew在我的机器上安装Nginx。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="e7a2" class="lo kn hi lk b fi lp lq l lr ls">brew install nginx</span></pre><p id="6ba3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">检查它是否安装成功。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="6914" class="lo kn hi lk b fi lp lq l lr ls">nginx -v</span></pre><p id="4deb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你应该看到Nginx的版本。</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="767f" class="lo kn hi lk b fi lp lq l lr ls">nginx version: nginx/1.19.9</span></pre><p id="b323" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在启动Nginx服务器</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="3474" class="lo kn hi lk b fi lp lq l lr ls">brew services start nginx</span></pre><p id="9ca7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Nginx服务器已启动。导航到<a class="ae lt" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>。您应该会在浏览器中看到下面的响应。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lu"><img src="../Images/83d4575e0edb7ec937cb0a311fd3948f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nNEzJwosLccHRZaCAha2VA.png"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">Nginx默认消息</figcaption></figure><h1 id="b7f7" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">步骤2:创建NodeJs服务器</h1><p id="621b" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">为了分配负载，让我们创建几个简单的nodejs服务器。下面的要点是一个模板，旋转几台服务器。如果你知道docker，那么你可以使用一个图像旋转多个容器。我正在创建6个节点应用程序。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es mb"><img src="../Images/29db661ee69da835049420abbbeae853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B6iCkap9JK-0Z-oMLH_WHw.png"/></div></div></figure><p id="f3d1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">只要把端口和消息改成你想要的就行了。我正在运行我的六个服务器，如上图所示。</p><h1 id="4bda" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">步骤3:请求分发</h1><p id="d33e" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">导航到<code class="du mc md me lk b">/usr/local/etc/nginx</code>用下面的要点替换Nginx默认配置文件<code class="du mc md me lk b">nginx.conf</code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="4f47" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在导航到<a class="ae lt" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>并不断刷新浏览器。请注意，每次您发出请求时，请求都会以循环方式被重定向到这6台服务器。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es mf"><img src="../Images/47624ef94c5ffa3d63e0f658152de99a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*b1qT2PYWR9gIkb8BEM063Q.gif"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">以循环方式路由的请求</figcaption></figure><p id="0d4f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在让我们试着理解配置文件。在http指令中，我们创建了一个包含6台服务器的上游指令。在服务器指令中，我们定义每当有人试图访问<a class="ae lt" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>时，我们将这些请求代理到我的后端服务器组。由于在上游指令中没有指定如何平衡请求的算法，Nginx默认使用<strong class="jl hj">循环</strong>算法。这样，向<a class="ae lt" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>发出的每个请求都由这六个服务器以循环方式提供服务。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="7270" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">根据上面的配置，我们可以理解，如果有人试图访问<code class="du mc md me lk b">http://localhost:8080/profile</code><a class="ae lt" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/profile</a>，服务器会返回404错误。所有的<code class="du mc md me lk b"><a class="ae lt" href="http://localhost:8080/profile" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/stories</a> </code>请求将被重定向到storyService组，这些请求在端口3333和4444上运行的服务器之间循环。所有的<code class="du mc md me lk b"><a class="ae lt" href="http://localhost:8080/profile" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/newsfeed</a></code>请求都将被重定向到newsfeedService组，这些请求在运行于端口1111和2222的服务器之间循环。除了stories和newsfeed之外的任何其他请求都被重定向到wholeBackend组，这些请求在运行于端口5555、6666、7777和8888上的服务器之间循环。</p><h2 id="3793" class="lo kn hi bd ko mg mh mi ks mj mk ml kw js mm mn ky jw mo mp la ka mq mr lc ms bi translated">服务器重量</h2><p id="c7a5" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">默认情况下，每个服务器的权重为1。例如，如果您将第二台服务器的权重设置为5，那么在发出的10个请求中，有5个(但不是按顺序)被重定向到第二台服务器，其余5个被重定向到其余的服务器。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es mf"><img src="../Images/5dafd0c0f1acc669af4f64df58ccd154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*y_K5JnW_pOLjHJbkVM6ajg.gif"/></div></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">通过分配给服务器的权重实现负载平衡</figcaption></figure><h2 id="1151" class="lo kn hi bd ko mg mh mi ks mj mk ml kw js mm mn ky jw mo mp la ka mq mr lc ms bi translated">服务器慢速启动</h2><p id="f2fb" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">服务器慢速启动功能可防止最近恢复的服务器因连接过多而不堪重负，这可能会超时并导致服务器再次被标记为失败。</p><p id="a60b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在NGINX Plus中，slow-start允许上游服务器在恢复或变得可用后，逐渐将其权重从<code class="du mc md me lk b">0</code>恢复到其标称值。这可以通过<code class="du mc md me lk b">server</code>指令的<code class="du mc md me lk b">slow_start</code>参数来实现:</p><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="06f0" class="lo kn hi lk b fi lp lq l lr ls"><strong class="lk hj">upstream</strong> mybackend {<br/>    <strong class="lk hj">least_conn</strong>;<br/>    <strong class="lk hj">server</strong> 127.0.0.1:1111 slow_start=30s;<br/>    <strong class="lk hj">server</strong> 127.0.0.1:2222 weight=5;<br/>}</span></pre><p id="5daf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">时间值(这里是<code class="du mc md me lk b">30</code>秒)设置NGINX Plus将服务器连接数量提升到最大值的时间。</p><p id="0dcb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">请注意，如果一个组中只有一台服务器，则<code class="du mc md me lk b">server</code>指令的<code class="du mc md me lk b">max_fails</code>、<code class="du mc md me lk b">fail_timeout</code>和<code class="du mc md me lk b">slow_start</code>参数将被忽略，并且该服务器永远不会被视为不可用。</p></div><div class="ab cl mt mu gp mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hb hc hd he hf"><h1 id="feb5" class="km kn hi bd ko kp na kr ks kt nb kv kw io nc ip ky ir nd is la iu ne iv lc ld bi translated">负载平衡方法</h1><p id="d3ae" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">NGINX开源支持四种负载平衡方法，NGINX Plus又增加了两种方法。我们已经看到了默认的循环法。其他负载平衡方法</p><ul class=""><li id="9170" class="nf ng hi jl b jm jn jp jq js nh jw ni ka nj ke nk nl nm nn bi translated">least_conn:请求被发送到活动连接数最少的服务器，同样考虑服务器权重。</li></ul><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="eec5" class="lo kn hi lk b fi lp lq l lr ls"><strong class="lk hj">upstream</strong> mybackend {<br/>    <strong class="lk hj">least_conn</strong>;<br/>    <strong class="lk hj">server</strong> 127.0.0.1:1111;<br/>    <strong class="lk hj">server</strong> 127.0.0.1:2222 weight=5;<br/>}</span></pre><ul class=""><li id="ad87" class="nf ng hi jl b jm jn jp jq js nh jw ni ka nj ke nk nl nm nn bi translated">ip_hash:请求发送到的服务器由客户端ip地址决定。在这种情况下，要么使用IPv4地址的前三个八位字节，要么使用整个IPv6地址来计算哈希值。该方法保证来自同一地址的请求到达同一服务器，除非该服务器不可用。</li></ul><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="071b" class="lo kn hi lk b fi lp lq l lr ls"><strong class="lk hj">upstream</strong> mybackend {<br/>    <strong class="lk hj">ip_hash</strong> $request_uri consistent;<br/>    <strong class="lk hj">server</strong> 127.0.0.1:1111;<br/>    <strong class="lk hj">server</strong> 127.0.0.1:2222 weight=5;<br/>}</span></pre><p id="6623" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果需要从负载平衡循环中临时删除其中一台服务器，可以使用<code class="du mc md me lk b">down</code>参数对其进行标记，以保留客户端IP地址的当前哈希。将由该服务器处理的请求自动发送到组中的下一个服务器。</p><ul class=""><li id="fa73" class="nf ng hi jl b jm jn jp jq js nh jw ni ka nj ke nk nl nm nn bi translated">哈希:也称为通用哈希。请求发送到的服务器由用户定义的密钥确定，该密钥可以是文本字符串、变量或它们的组合。例如，密钥可以是成对的源IP地址和端口，或者是URI，如下例所示:</li></ul><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="abf7" class="lo kn hi lk b fi lp lq l lr ls"><strong class="lk hj">upstream</strong> backend {<br/>    <strong class="lk hj">hash</strong> $request_uri consistent;<br/>    <strong class="lk hj">server</strong> backend1.example.com;<br/>    <strong class="lk hj">server</strong> backend2.example.com;<br/>}</span></pre><p id="2d68" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du mc md me lk b">hash</code>指令的可选参数<code class="du mc md me lk b">consistent</code>支持<a class="ae lt" href="https://www.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients" rel="noopener ugc nofollow" target="_blank"> ketama </a>一致散列负载平衡。请求根据用户定义的散列键值均匀分布在所有上游服务器上。如果上游服务器被添加到上游组或从上游组中删除，则只有几个键被重新映射，这在负载平衡缓存服务器或其他累积状态的应用程序的情况下最大限度地减少了缓存未命中。</p><ul class=""><li id="2cc4" class="nf ng hi jl b jm jn jp jq js nh jw ni ka nj ke nk nl nm nn bi translated">least_time:对于每个请求，NGINX Plus选择具有最低平均延迟和最低活动连接数的服务器，其中最低平均延迟是基于包含以下<code class="du mc md me lk b">least_time</code>指令的哪个参数来计算的:</li></ul><pre class="iy iz ja jb fd lj lk ll lm aw ln bi"><span id="cd6c" class="lo kn hi lk b fi lp lq l lr ls"><strong class="lk hj">upstream</strong> backend {<br/>    <strong class="lk hj">least_time</strong> header;<br/>    <strong class="lk hj">server</strong> backend1.example.com;<br/>    <strong class="lk hj">server</strong> backend2.example.com;<br/>}</span></pre><ul class=""><li id="c6cf" class="nf ng hi jl b jm jn jp jq js nh jw ni ka nj ke nk nl nm nn bi translated"><code class="du mc md me lk b">header</code>–从服务器接收第一个字节的时间</li><li id="7769" class="nf ng hi jl b jm no jp np js nq jw nr ka ns ke nk nl nm nn bi translated"><code class="du mc md me lk b">last_byte</code>–从服务器接收完整响应的时间</li><li id="f21c" class="nf ng hi jl b jm no jp np js nq jw nr ka ns ke nk nl nm nn bi translated"><code class="du mc md me lk b">last_byte inflight</code>–从服务器接收完整响应的时间，包括未完成的请求</li></ul><h1 id="63f9" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">结论</h1><p id="2ab1" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">这个话题还有很多我们没有涉及到的内容，这确实是一个令人着迷的讨论。</p><p id="0a9a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果我遗漏了什么，或者你觉得有什么不对，请在下面写下回复，让我知道。非常感谢任何建议或意见。</p><p id="1c03" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你有兴趣，可以在<a class="ae lt" href="https://www.linkedin.com/in/prathapchandra" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae lt" href="https://twitter.com/prathapmoola/" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae lt" href="https://www.instagram.com/prathap_chandra/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上与我联系。</p><p id="ff89" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="ki">感谢阅读！！</em></p></div></div>    
</body>
</html>