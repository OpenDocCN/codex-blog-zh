<html>
<head>
<title>DolphinScheduler can schedule workflows with Python scripts!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DolphinScheduler可以用Python脚本调度工作流！</h1>
<blockquote>原文：<a href="https://medium.com/codex/dolphinscheduler-can-schedule-workflows-with-python-scripts-a882fdd2d862?source=collection_archive---------3-----------------------#2022-12-09">https://medium.com/codex/dolphinscheduler-can-schedule-workflows-with-python-scripts-a882fdd2d862?source=collection_archive---------3-----------------------#2022-12-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9cf8e703648b8098bb222e17572b453b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JPTuZpYIBP9kOTBZbZ1eQQ.png"/></div></div></figure><blockquote class="iq"><p id="7ba0" class="ir is hi bd it iu iv iw ix iy iz ja dx translated">随着2.0.5版本的发布，Apache DolphinScheduler增加了Python API函数，使用户能够通过Python脚本安排工作流，以创建、更新和调度工作流。那对Python用户来说就方便多了！</p></blockquote><p id="cd08" class="pw-post-body-paragraph jb jc hi jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ja hb bi translated">Apache DolphinScheduler是一个分布式、高可扩展、可视化的开源工作流任务调度框架，适用于企业级应用案例，为可视化的任务操作、工作流调度以及整个数据处理过程提供可视化的解决方案。</p><p id="adcc" class="pw-post-body-paragraph jb jc hi jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx ja hb bi translated">Apache DolphinScheduler提供了丰富的组件，允许用户调用MR、SageMaker、DMS、DataSync等AWS服务，以及Spark、Flink、Hive等私有部署的服务；它还为核心调度场景提供了工具，如失败重试、失败警报、任务SLA、复杂依赖处理等。；它还提供了丰富的调度功能，如外部资源文件管理、集群物理机资源监控；以及用于外部监控的各种度量。</p><h1 id="de9c" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Dolphin调度器Python API</h1><p id="42ba" class="pw-post-body-paragraph jb jc hi jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx ja hb bi translated">使用Python API，用户可以通过Python脚本来安排工作流，以创建、更新和调度工作流等。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/c4096e06c373c30617085055d6ac61ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QfQeiPe731H3CtyD"/></div></div></figure><h2 id="407f" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jm ls lt kr jq lu lv kv ju lw lx kz ly bi translated">安装</h2><p id="da8f" class="pw-post-body-paragraph jb jc hi jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx ja hb bi translated">您可以通过pip轻松方便地安装PyDolphinScheduler:</p><pre class="lh li lj lk fd lz ma mb bn mc md bi"><span id="e1f6" class="me ke hi ma b be mf mg l mh mi">python -m pip install apache-dolphinscheduler</span></pre><h2 id="d3c3" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jm ls lt kr jq lu lv kv ju lw lx kz ly bi translated">奔跑</h2><p id="04a4" class="pw-post-body-paragraph jb jc hi jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx ja hb bi translated">我们提供了现成的示例，用户可以使用以下命令运行Python API:</p><pre class="lh li lj lk fd lz ma mb bn mc md bi"><span id="8b20" class="me ke hi ma b be mf mg l mh mi">wget https://raw.githubusercontent.com/apache/dolphinscheduler/dev/dolphinscheduler-python/pydolphinscheduler/src/pydolphinscheduler/examples/tutorial.py<br/>python tutorial.py</span></pre><h1 id="20ae" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Python API函数</h1><p id="285d" class="pw-post-body-paragraph jb jc hi jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx ja hb bi translated">Python API提供了我们可以在DolphinScheduler Web UI中直接操作的所有功能，比如工作流创建、任务创建、工作流调度、资源文件实用程序、参数传递等。目前支持DolphinScheduler中大部分任务类型，用户可以通过Python API体验DolphinScheduler的大部分核心功能。</p><p id="d73f" class="pw-post-body-paragraph jb jc hi jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx ja hb bi translated">如果我们想要通过DolphinScheduler Python API创建并运行DolphinScheduler工作流，我们需要首先启动DolphinScheduler服务，该服务可以在<a class="ae mj" href="https://dolphinscheduler.apache.org/python/dev/start.html#start-python-gateway-service" rel="noopener ugc nofollow" target="_blank">https://dolphin scheduler . Apache . org/Python/dev/start . html # start-Python-gateway-service</a>找到，以检查它是如何安装和运行的。本文主要带你领略Python API的魅力，所以我们将重点讲解Python API任务。</p><h1 id="7625" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">例子</h1><p id="dd95" class="pw-post-body-paragraph jb jc hi jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx ja hb bi translated">这是一个如何使用Python API运行DolphinScheduler工作流的例子。我们需要从官网下载资源，做一些计算。</p><p id="4ac7" class="pw-post-body-paragraph jb jc hi jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx ja hb bi translated"><strong class="jd hj">概述</strong></p><p id="2b52" class="pw-post-body-paragraph jb jc hi jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx ja hb bi translated">以下是我们代码的概述。在这个脚本中，用户需要下载DolphinScheduler源代码，然后找到最大的文件和最常见的文件扩展名。要做到这一点需要三个步骤。所有的步骤在DolphinScheduler中都叫做“任务”，我们要完成的整个工作叫做“ProcessDefinition”。</p><p id="db5a" class="pw-post-body-paragraph jb jc hi jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx ja hb bi translated">除了这3个主要步骤，我们还有一些额外的步骤来准备我们的环境，并确保主要步骤正常工作。比如我们需要创建一个新的目录来保存从官网获取的资源，并保证传入的压缩包不与现有环境冲突。下载资产后，我们需要压缩它，并从tarball中提取内容。</p><pre class="lh li lj lk fd lz ma mb bn mc md bi"><span id="690b" class="me ke hi ma b be mf mg l mh mi">from pydolphinscheduler.core.process_definition import ProcessDefinition<br/>from pydolphinscheduler.tasks.python import Python<br/>from pydolphinscheduler.tasks.shell import Shell<br/>download_dir = "/tmp/demo"<br/>store_dir = "dolphinscheduler"<br/>download_link = "https://github.com/apache/dolphinscheduler/archive/refs/heads/dev.zip"<br/>file_name = download_link. split("/")[-1]<br/>def largest_size():<br/>     from pathlib import Path<br/>     download_dir = "/tmp/demo"<br/>     store_dir = "dolphinscheduler"<br/>     result = (None, 0)<br/>     paths = Path(download_dir).joinpath(store_dir).glob("**/*")<br/>     for path in paths:<br/>         # skip is path is directory<br/>         if path.is_dir():<br/>             continue<br/>         file_size = path.stat().st_size<br/>         if result[0] is None or file_size &gt; result[1]:<br/>             result = (path.name, file_size)<br/>     print(result)<br/>def most_frequently():<br/>     from pathlib import Path<br/>     download_dir = "/tmp/demo"<br/>     store_dir = "dolphinscheduler"<br/>     ext_cnt = {}<br/>     paths = Path(download_dir).joinpath(store_dir).glob("**/*")<br/>     for path in paths:<br/>         # skip is path is directory<br/>         if path.is_dir():<br/>             continue<br/>         ext = path.suffix<br/>         ext_cnt[ext] = ext_cnt[ext] + 1 if ext in ext_cnt else 1<br/>     print(max(ext_cnt.items(), key=lambda p: p[1]))<br/>with ProcessDefinition(<br/>         name="top_ten_size_files",<br/>         tenant="zhongjiajie",<br/>) as pd:<br/>     prepare = Shell(<br/>         name="prepare_dir",<br/>         command=f"mkdir -p {download_dir}; rm -rf {download_dir}/*"<br/>     )<br/>     download = Shell(<br/>         name="download_resources",<br/>         command=f"wget -P {download_dir} {download_link}"<br/>     )<br/>     compress = Shell(<br/>         name="compress_tar",<br/>         command=f "cd {download_dir}; unzip {file_name} -d {store_dir}"<br/>     )<br/>     largest_file = Python(<br/>         name="largest_file",<br/>         definition=largest_size,<br/>     )<br/>     most_type = Python(<br/>         name="most_type",<br/>         definition=most_frequently,<br/>     )<br/>     prepare &gt;&gt; download &gt;&gt; compress &gt;&gt; [<br/>         largest_file,<br/>         most_type,<br/>     ]<br/>     pd. run()</span></pre><h1 id="d16e" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">下载资源</h1><p id="9558" class="pw-post-body-paragraph jb jc hi jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx ja hb bi translated">在这个任务中，我们使用shell命令wget从GitHub下载资源，我们可以简单地使用PyDolphinScheduler的内置shell将wget命令传递给parameter命令。</p><p id="6b5a" class="pw-post-body-paragraph jb jc hi jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx ja hb bi translated">您可以看到，我们在这里使用了名为download_dir和download_link的Python变量，以使我们的代码可维护。实际运行的命令是wget-P/tmp/demo<a class="ae mj" href="https://github.com/apache/dolphinscheduler/archive/refs" rel="noopener ugc nofollow" target="_blank">https://github.com/apache/dolphinscheduler/archive/refs</a>/heads/dev . zip。完成后，DolphinScheduler源代码将被下载到目录/tmp/demo。</p><pre class="lh li lj lk fd lz ma mb bn mc md bi"><span id="bb61" class="me ke hi ma b be mf mg l mh mi">download = Shell(<br/>     name="download_resources",<br/>     command=f"wget -P {download_dir} {download_link}"<br/>)</span></pre><h2 id="c33a" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jm ls lt kr jq lu lv kv ju lw lx kz ly bi translated">下载资源前后我们需要做什么？</h2><p id="9b33" class="pw-post-body-paragraph jb jc hi jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx ja hb bi translated">正如我们在概述中提到的，我们需要在从官方网站下载资产之前或之后经历一些额外的步骤。对于环境准备，我们使用单个shell任务来确保下载目录存在，并且目录中没有其他资源文件。传递命令mkdir-p/tmp/demo；参数命令的rm -rf /tmp/demo/*(注意我们在这里也使用Python变量)。我们必须压缩。然后将它们解压缩到一个特定的目录，这样我们就可以在这个路径上运行一些Python代码。</p><pre class="lh li lj lk fd lz ma mb bn mc md bi"><span id="4e03" class="me ke hi ma b be mf mg l mh mi">prepare = Shell(<br/>     name="prepare_dir",<br/>     command=f"mkdir -p {download_dir}; rm -rf {download_dir}/*"<br/>)<br/>compress = Shell(<br/>     name="compress_tar",<br/>     command=f "cd {download_dir}; unzip {file_name} -d {store_dir}"<br/>)</span></pre><h2 id="c4cf" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jm ls lt kr jq lu lv kv ju lw lx kz ly bi translated">计算最大的文件</h2><p id="f57b" class="pw-post-body-paragraph jb jc hi jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx ja hb bi translated">我们使用Python任务来统计DolphinScheduler源代码中最大的文件和最常用的文件类型。如你所见，我们还需要命名Python任务，这里我将其命名为maximum _ file，然后将函数传递给Python任务的参数定义。<strong class="jd hj">这一步的核心逻辑来自于最大尺寸函数</strong>。在这个函数中，我们通过pathlib库遍历源代码目录并找到最大的文件。使用一个名为result的元组来存储命名文件及其大小，最后打印结果，结果将显示在控制台上。</p><pre class="lh li lj lk fd lz ma mb bn mc md bi"><span id="f0b0" class="me ke hi ma b be mf mg l mh mi">def largest_size():<br/>     from pathlib import Path<br/>     download_dir = "/tmp/demo"<br/>     store_dir = "dolphinscheduler"<br/>     result = (None, 0)<br/>     paths = Path(download_dir).joinpath(store_dir).glob("**/*")<br/>     for path in paths:<br/>         # skip is path is directory<br/>         if path.is_dir():<br/>             continue<br/>         file_size = path.stat().st_size<br/>         if result[0] is None or file_size &gt; result[1]:<br/>             result = (path.name, file_size)<br/>     print(result)<br/>largest_file = Python(<br/>     name="largest_file",<br/>     definition=largest_size,<br/>)</span></pre><h2 id="072a" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jm ls lt kr jq lu lv kv ju lw lx kz ly bi translated">计算最常出现的文件类型</h2><p id="1c6b" class="pw-post-body-paragraph jb jc hi jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx ja hb bi translated">这里的方法对于最大的文件是相同的，我们使用Python任务，用most_type作为名称，most _ frequently作为定义。为了找到最常用的文件类型，我们创建了一个字典来保存所有文件扩展名。然后使用pathlib库遍历源代码。在这个过程中，注意跳过没有扩展名的目录和文件，从字典中找到最常用的值。</p><pre class="lh li lj lk fd lz ma mb bn mc md bi"><span id="36ed" class="me ke hi ma b be mf mg l mh mi">def most_frequently():<br/>     from pathlib import Path<br/>     download_dir = "/tmp/demo"<br/>     store_dir = "dolphinscheduler"<br/>     ext_cnt = {}<br/>     paths = Path(download_dir).joinpath(store_dir).glob("**/*")<br/>     for path in paths:<br/>         # skip is path is directory<br/>         if path.is_dir():<br/>             continue<br/>         ext = path.suffix<br/>         # skip file without suffix<br/>         if ext == "":<br/>             continue<br/>         ext_cnt[ext] = ext_cnt[ext] + 1 if ext in ext_cnt else 1<br/>     print(max(ext_cnt.items(), key=lambda p: p[1]))<br/>most_type = Python(<br/>     name="most_type",<br/>     definition=most_frequently,<br/>)</span></pre><h2 id="67e3" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jm ls lt kr jq lu lv kv ju lw lx kz ly bi translated">设置任务相关性</h2><p id="ac3c" class="pw-post-body-paragraph jb jc hi jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx ja hb bi translated">设置完成后，我们需要声明任务的依赖关系。不用说，我们应该先运行准备任务，因为没有压缩包就无法进行压缩，所以我们需要将任务下载设置为压缩的上游。另一个计算可以并行运行，所以我们将它们都设置在压缩任务的下游，我们使用语法sugar compress &gt;&gt; [largest_file，most_type]在这里，可以在一个语句中设置两个或多个依赖项。</p><h2 id="70b0" class="ll ke hi bd kf lm ln lo kj lp lq lr kn jm ls lt kr jq lu lv kv ju lw lx kz ly bi translated">快跑！</h2><p id="080b" class="pw-post-body-paragraph jb jc hi jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx ja hb bi translated">将以下代码添加到脚本的末尾，以将工作流和任务提交给DolphinScheduler，并在默认情况下触发它们。</p><pre class="lh li lj lk fd lz ma mb bn mc md bi"><span id="4098" class="me ke hi ma b be mf mg l mh mi">pd. run()</span></pre><p id="b3f8" class="pw-post-body-paragraph jb jc hi jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx ja hb bi translated">完成所有工作后，您可以在Python控制台中运行代码并观察结果。之后，您可以在DolphinScheduler UI中看到正在运行的工作流和任务，默认为</p><pre class="lh li lj lk fd lz ma mb bn mc md bi"><span id="90a2" class="me ke hi ma b be mf mg l mh mi">http://127.0.0.1:12345/dolphinscheduler.<br/>python3 demo.py</span></pre><h1 id="423f" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">摘要</h1><p id="c282" class="pw-post-body-paragraph jb jc hi jd b je lb jg jh ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx ja hb bi translated">在这里，我们介绍了什么是DolphinScheduler及其最近添加的Python API特性，并展示了如何使用Python API来构建包含多个任务的工作流，如何设置任务，以及如何将任务提交给DolphinScheduler。</p><p id="afb1" class="pw-post-body-paragraph jb jc hi jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx ja hb bi translated">您可以在任务中找到Python API支持的所有任务。有关DolphinScheduler Python API的更多信息，请参考<a class="ae mj" href="https://dolphinscheduler.apache.org/python/dev/index.html" rel="noopener ugc nofollow" target="_blank">本文档</a>。</p><p id="22a9" class="pw-post-body-paragraph jb jc hi jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx ja hb bi translated">📌📌欢迎填写<a class="ae mj" href="https://www.surveymonkey.com/r/7CHHWGW" rel="noopener ugc nofollow" target="_blank">这份调查</a>来反馈您的用户体验或您对Apache DolphinScheduler的想法:)</p><p id="d171" class="pw-post-body-paragraph jb jc hi jd b je jy jg jh ji jz jk jl jm ka jo jp jq kb js jt ju kc jw jx ja hb bi translated">【https://www.surveymonkey.com/r/7CHHWGW T4】</p></div></div>    
</body>
</html>