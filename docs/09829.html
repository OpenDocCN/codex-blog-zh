<html>
<head>
<title>Synchronous Communication — Queries and Cache (Part 3/3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同步通信—查询和缓存(第3/3部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/synchronous-communication-queries-and-cache-part-3-3-755d2a19dc33?source=collection_archive---------3-----------------------#2022-11-12">https://medium.com/codex/synchronous-communication-queries-and-cache-part-3-3-755d2a19dc33?source=collection_archive---------3-----------------------#2022-11-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="aa96" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">缓存在哪里？服务器端还是客户端？共享还是私有？代理还是反向代理还是CDN？这篇文章谈到了对每一个问题的考虑。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/5d078be121578b550dcad1e2b5477a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_hqQBZOZYKsiEuOjPvtNqg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">缓存大图</figcaption></figure><p id="3f5d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在<a class="ae kj" rel="noopener" href="/codex/synchronous-communication-queries-cache-c91124a0aad0">的上一篇文章中，</a>我介绍了保持缓存与数据源一致的策略。在这篇文章中，以上面的图片为参考，我将涵盖所有我们可以缓存它们的含义的地方。</p><h1 id="988c" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">1.服务器端缓存</h1><p id="c5dc" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">origin管理数据的快照，以便更快地为查询服务。</p><p id="6f46" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">有几个好处—</p><ol class=""><li id="af79" class="lh li hi jp b jq jr jt ju jw lj ka lk ke ll ki lm ln lo lp bi translated">所有的客户都得到好处。</li><li id="1c02" class="lh li hi jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">缓存的数据仍然归原始数据所有。在某些情况下，由于法律限制，可能不希望在拥有数据的服务之外复制数据。</li><li id="276e" class="lh li hi jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">可伸缩性—服务可以处理更多的读取请求，因为它不需要一次又一次地执行昂贵的操作。</li><li id="30e8" class="lh li hi jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">可用性—如果下游服务之一不可用，缓存可以为查询提供服务。</li><li id="1953" class="lh li hi jp b jq lq jt lr jw ls ka lt ke lu ki lm ln lo lp bi translated">保持缓存更新更容易(前一篇文章中提到的策略)。</li></ol><p id="ee23" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">不利的一面是</strong>，请求仍然必须通过<strong class="jp hj">的网络</strong>才能到达源/服务。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/18b9b8f39d5eedb5b78b0549839e3981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UWS6v1pX-0jJrEoVdpzaUQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">服务器端缓存</figcaption></figure><h2 id="b4ef" class="lw kl hi bd km lx ly lz kq ma mb mc ku jw md me kw ka mf mg ky ke mh mi la mj bi translated"><strong class="ak"> 1.1私有/应用缓存</strong></h2><p id="e389" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">这是实现缓存的最简单和最基本的方式之一，这意味着应用程序的每个实例都有自己的数据副本供查看。</p><p id="ac74" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这是检索缓存数据的最快方式，实现为内存哈希表或文件存储，无论哪种情况，都避免了网络延迟。</p><p id="e7ac" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">它可以在服务器端或客户端实现。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mk"><img src="../Images/99dbe55d3ae5bdd810480fde6f4d740d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7TmEWE_5_3UTCTOSFxrGYQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">服务器和客户端的应用缓存</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ml"><img src="../Images/57b7c83c1577fa0e9db1c38d4ab9779c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pEU5HjQ0q7KsqLgaqhDIPQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">应用程序缓存—图像信用<a class="ae kj" href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/caching" rel="noopener ugc nofollow" target="_blank">https://learn . Microsoft . com/en-us/azure/architecture/best-practices/caching</a></figcaption></figure><p id="94fa" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">从上图可以明显看出，每个应用程序都有自己的数据副本，如果有几个应用程序实例，就会有几个数据副本，这不仅<strong class="jp hj">会增加存储</strong>，而且还会根据哪个应用程序实例回答查询或处理数据而给出<strong class="jp hj">不一致的结果</strong>。此外，当这样的应用程序向外扩展时，它们可能会淹没原始的T21，因为它们的缓存在启动时是空的。</p><h2 id="71ae" class="lw kl hi bd km lx ly lz kq ma mb mc ku jw md me kw ka mf mg ky ke mh mi la mj bi translated">1.2分布式/共享缓存</h2><p id="caa4" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">与应用程序缓存不同，在应用程序缓存中，每个应用程序实例都有自己的专用缓存，而在分布式缓存<strong class="jp hj">中，有一个外部缓存供所有应用程序实例</strong>在进一步操作之前查找。</p><p id="bfd3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">它可以在服务器级别实现，也可以在客户端实现。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mm"><img src="../Images/c2caa67a0aaf3c74f3790c6d98f4ac3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUSjPPAh446tQ629mtACHA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">应用程序的所有实例共享一个公共缓存。image credit<a class="ae kj" href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/caching" rel="noopener ugc nofollow" target="_blank">https://learn . Microsoft . com/en-us/azure/architecture/best-practices/caching</a></figcaption></figure><p id="047e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">它带来的好处是提供了缓存数据的<strong class="jp hj">一致视图</strong>，缓存可以有多个节点来提供伸缩性和弹性。Redis等产品可用于支持复杂的数据类型和高级用例(如发布者-订阅者模型、批处理操作、事务和地理空间数据)。</p><p id="9d1a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">不利的一面是<strong class="jp hj">，因为它是一个外部服务，它会受到网络延迟</strong>(网络延迟的影响可以通过使用批处理操作来减少)，它<strong class="jp hj">增加了复杂性</strong>，因为它是一个要管理的独立车队<strong class="jp hj">安全考虑变得更加重要</strong>。</p><h2 id="3758" class="lw kl hi bd km lx ly lz kq ma mb mc ku jw md me kw ka mf mg ky ke mh mi la mj bi translated">1.3 API网关处的缓存(和反向代理)</h2><p id="97ec" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">缓存仍然在服务器上，但是已经从应用程序/服务中移除。缓存HTTP响应<strong class="jp hj">很有帮助。</strong></p><p id="2608" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">根据API Gateway产品的不同，它可以是现成的解决方案，可以添加一些配置。或者它可以是像Varnish cache这样的产品，可以用反向代理来实现。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mn"><img src="../Images/16751db8d2dfee9bca6ce45c038e907d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pLvyEI5ZWBkfStKfqOKfYQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在调用后端服务之前，API gateway首先根据查询查找其缓存。</figcaption></figure><p id="c9de" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">API网关中的缓存将有一段生存时间，这意味着它可以在这段时间内给出陈旧的值。如果客户端需要来自后端的实际数据，一些API网关产品支持Cache-Control: max-age=0头，这将使缓存无效。</p><p id="19a5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然而，<strong class="jp hj">如果客户端为了得到最终结果而必须对不同的端点进行多次查询，那么API的缓存就不是很有效。因为它会使界面变得喋喋不休，并放大网络延迟的影响。</strong></p><p id="d91d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">作为一个解决方案，一个聚合器服务(<a class="ae kj" href="https://www.enterpriseintegrationpatterns.com/Aggregator.html" rel="noopener ugc nofollow" target="_blank">这里提到聚合器模式</a>)可以位于一个API网关之后，该网关可以连接到各种服务以产生最终结果。拥有聚合器的另一个好处是，它可以与可能具有API网关产品不支持的不同协议的服务进行对话。<strong class="jp hj">聚合器可以有一个缓存，并对其失效有更多的控制。</strong>API网关可以执行其他与业务无关的工作，如认证、日志记录和节流。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/d517159e529f8d2a42690b73d17d1700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mDh6N2MRlmQvbU8Ft1ehpA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">添加了一个聚合器来聚合来自服务的请求，从而减少了网络延迟，并使客户端不必了解各个服务。</figcaption></figure><p id="ae84" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Apigateways &amp; aggregators可能成为单点故障，因此考虑它们的资源分配至关重要。</p><h1 id="37e7" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">2.客户端缓存</h1><p id="c7d9" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">这意味着数据快照是在客户端管理的，原始服务对此没有控制权或不了解。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/d545f50c901cf537abd377b0fa0fc780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mc0iviDU8vwByLoYU8do2g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">客户端服务A实例使用客户端(共享/分布式)缓存。</figcaption></figure><p id="0d7b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最显著的<strong class="jp hj">好处是避免了网络调用，增强了性能和健壮性</strong>。而<strong class="jp hj">的挑战是保持客户端缓存与服务器保持最新</strong>。</p><p id="bef5" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在<strong class="jp hj">中，除了应用缓存和分布式缓存</strong>、<strong class="jp hj">之外，Web代理缓存</strong>可以在客户端使用。它是位于客户机和服务器/服务之间的服务器，可以缓存HTTP内容。代理服务器上的Squid缓存就是一个产品示例。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/c8ba4cdb41cf6d8df8edb673962699cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*maDKRAiO_hvn7ergCK5orw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">带缓存的代理服务器</figcaption></figure><h1 id="f7f0" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">3.内容交付网络</h1><p id="8554" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">这就像<strong class="jp hj">网络内的缓存</strong>。当数据源远离网络和<strong class="jp hj">消费者分散在世界各地</strong>时，这是很有帮助的<strong class="jp hj">。</strong></p><p id="05f0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这是由AWS、Akamai、Cloudflare和Google等公司提供的一项服务，通过创建一个边缘位置网络来拉近数据与用户的距离。</p><p id="0efd" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">客户端请求一到达边缘位置就获得收益</strong>。</p><p id="c578" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">主要用于传送媒体文件、软件包和流媒体视频。但是根据产品的不同，它可以用于传送静态、动态、交互式或流式内容。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/58d2774227e58a9b932a57e3ddde1e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zQgDVG2Y99PG1-mL28m8QA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">本文发布时的AWS边缘和区域位置。<a class="ae kj" href="https://aws.amazon.com/cloudfront/features/?nc=sn&amp;loc=2&amp;whats-new-cloudfront.sort-by=item.additionalFields.postDateTime&amp;whats-new-cloudfront.sort-order=desc" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="298a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如上图所示，AWS CDN有两种类型的缓存位置—区域缓存和边缘位置。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/8a73e2048310d207499470173b9166b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hvzb9gaPU9ALla5h7-_loQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">AWS CDN中区域和边缘缓存的逻辑视图</figcaption></figure><p id="ad18" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">区域边缘缓存具有更大的缓存，因此对象可以在那里停留更长时间。<em class="ms"> " </em> Get <em class="ms"> " </em>请求被缓存，可以配置生存时间和立即失效。</p><h2 id="2aa3" class="lw kl hi bd km lx ly lz kq ma mb mc ku jw md me kw ka mf mg ky ke mh mi la mj bi translated">结束语</h2><p id="faaf" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">如果不需要，就不要添加缓存。数据副本增加了复杂性。如果不需要额外的数据拷贝就能满足性能、可用性和可扩展性方面的限制，这是一个不错的选择。</p><p id="6bb8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">从源到目的地的缓存层数越多，陈旧数据被提供的机会就越多，狡猾的漏洞就越多。</p><h2 id="abd6" class="lw kl hi bd km lx ly lz kq ma mb mc ku jw md me kw ka mf mg ky ke mh mi la mj bi translated"><strong class="ak">总结</strong></h2><p id="0377" class="pw-post-body-paragraph jn jo hi jp b jq lc ij js jt ld im jv jw le jy jz ka lf kc kd ke lg kg kh ki hb bi translated">在第<a class="ae kj" rel="noopener" href="/codex/synchronous-communication-queries-cache-c91124a0aad0">第一部分</a>测试中，我通过参考Gregory Young 2010年&amp;至2012年关于CQRS的论文，以最简单的形式提出了关于CQRS模式的问题&amp;。然后继续展示如何将该模式应用于不同的上下文。</p><p id="5e7c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><a class="ae kj" rel="noopener" href="/codex/synchronous-communication-queries-cache-c91124a0aad0">第二部分</a>讲述了缓存如何帮助NFRs，同时为查询&amp;策略提供服务，以保持缓存与数据源一致。</p><p id="1e1a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这个结论部分，我试图涵盖所有我们可以缓存的地方。以及各自有什么好处和考虑。</p><p id="069a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我把它分成3部分，希望它能读得更好。请让我知道你的想法。</p><p id="0cb6" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">进一步阅读和学分<a class="ae kj" href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/caching" rel="noopener ugc nofollow" target="_blank">https://learn . Microsoft . com/en-us/azure/architecture/best-practices/caching</a></p></div></div>    
</body>
</html>