<html>
<head>
<title>RESTful API for Git on Node.js with Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Express的Node.js上Git的RESTful API</h1>
<blockquote>原文：<a href="https://medium.com/codex/restful-api-for-git-on-node-js-with-express-d6902a75dc9b?source=collection_archive---------10-----------------------#2021-07-25">https://medium.com/codex/restful-api-for-git-on-node-js-with-express-d6902a75dc9b?source=collection_archive---------10-----------------------#2021-07-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/861dbd01062cf24175c4ae8f7c1ae335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68zsiuI-a9FE_Vy5STqR8g.png"/></div></div></figure><p id="7cd8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用Node.js在git存储库上实现RESTful API可以快速解决与获取git存储库信息相关的任务。下面是使用Express框架创建API的描述。</p><p id="554e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，您需要将Express添加到项目中，以及提供git CLI包装的<em class="jo"> nodegit </em>库，创建Postgre数据库连接池的<em class="jo"> pg </em>库(如果其中存储了链接或存储库名称)，用于BASE64编码的<em class="jo"> btoa </em>，用于在服务器上执行bash命令的child_process:</p><p id="bfd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">npm install express nodegit pg btoa child_process — save</code></p><p id="1a5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">安装后，我们将模块导入server.js文件，并描述服务器在端口3031上的启动(如果在环境变量中没有指定不同的端口):</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="fae1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个例子将着眼于使用多个存储库的能力。将为其提供API的存储库列表可以通过各种可用的方式获得。下面是一个如何直接从数据库中获取存储库列表的示例:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="997f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">YAMLconvert is函数在这里执行YAML到JSON的转换。作为执行的结果，repos数组将包含一个对象列表，该列表包含关于可用存储库和用于身份验证的数据的信息。通常，要使用远程存储库，必须将其克隆到节点。为此，让我们创建一个克隆函数:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="ca76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">克隆函数使用计数器对象遍历存储库列表并克隆到服务器。如果克隆应该在服务器启动时执行一次，或者在用户路径开始时根据请求执行一次，则允许在克隆请求处理程序中声明这样一个对象，如下例所示:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="93b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个处理程序将在一个GET请求上沿着/git/api/clone路径执行，counter将包含已经从resolved字段中的列表克隆的存储库的数量，并将调用clone函数，直到遍历整个列表。然而，在这种情况下，在克隆回调内部，我们得到一个在外部变异的对象。这种行为会对执行产生负面影响，因此您可以将计数器对象实现为iterable:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="dfa7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后在克隆功能中你可以行:</p><pre class="jt ju jv jw fd jz js ka kb aw kc bi"><span id="05c4" class="kd ke hi js b fi kf kg l kh ki">counter.resolved += 1;<br/>counter.onResolve();</span></pre><p id="23b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">替换为:</p><pre class="jt ju jv jw fd jz js ka kb aw kc bi"><span id="3744" class="kd ke hi js b fi kf kg l kh ki">counter.next();</span></pre><p id="b44c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在将存储库克隆到服务器上之后，您可以对它们执行操作，以获得关于提交、分支等的信息。例如，要通过get请求按存储库名称获取分支，您可以实现以下内容:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="3237" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">获取存储库提交:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="acab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">获取分页存储库目录树中特定路径下分支的文件列表:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="73a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">需要walkTree函数来为所请求的目录过滤文件列表，因为当在eventEmmiter中形成列表时，文件名是用来自存储库根目录的完整路径写入的:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure></div></div>    
</body>
</html>