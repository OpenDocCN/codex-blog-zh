<html>
<head>
<title>What Are Java 8 Lambda Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Java 8 Lambda表达式</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-are-java-8-lambda-expressions-8a112a7f895d?source=collection_archive---------14-----------------------#2021-07-24">https://medium.com/codex/what-are-java-8-lambda-expressions-8a112a7f895d?source=collection_archive---------14-----------------------#2021-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c856" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">lambda表达式是一个未命名的代码块，带有可选参数<br/>，可以存储、传递，稍后执行&amp;<strong class="ih hj"/>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/cdb4e75d4ad63d12b60e62e564bcf590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Inz46jhcU6qaZl5B"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@amenabarladrondeguevara?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊格纳西奥·阿门纳巴尔</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="c5e7" class="jz ka hi jv b fi kb kc l kd ke">new Thread( <br/>    <strong class="jv hj">() -&gt; System.<em class="kf">out</em>.println("hello world") <br/></strong>).start();</span></pre><p id="3cae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本例中，线程构造函数需要Runnable的一个实例。没有λ的等价物将是，</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="e26d" class="jz ka hi jv b fi kb kc l kd ke">new Thread(new Runnable() {<br/>    @Override<br/>    public void run() {<br/>        System.<em class="kf">out</em>.println("hello world 2");<br/>    }<br/>}).start();</span></pre><blockquote class="kg kh ki"><p id="499d" class="if ig kf ih b ii ij ik il im in io ip kj ir is it kk iv iw ix kl iz ja jb jc hb bi translated"><strong class="ih hj"> () </strong>输入参数<br/> <strong class="ih hj"> - &gt; </strong>箭头将参数列表与lambda体分开。<br/><strong class="ih hj">system . out . println(" hello world ")</strong>lambda体定义了计算。</p></blockquote><p id="1259" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Lambda表达式可以以比匿名内部类更紧凑的方式处理多个参数。他们只关注要执行的计算。</p><h2 id="560f" class="jz ka hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">行为参数化</h2><p id="7e45" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">Java的lambda表达式支持简洁的“行为参数化”，本质上是获取一段代码，并使其在不执行的情况下可用。例如，它可以传递给一个方法。<strong class="ih hj">自从Java 8引入了lambdas </strong>(最后)，现在可以用匿名函数参数化方法的行为了。</p><h2 id="e5a1" class="jz ka hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">λ作为参数</h2><p id="6654" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">您还可以将lambda表达式存储到一个变量中，并将该变量传递给一个方法。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="d0f7" class="jz ka hi jv b fi kb kc l kd ke">Runnable r = () -&gt; System.<em class="kf">out</em>.println("hello world 3");<br/>new Thread(r).start();</span></pre><h2 id="4261" class="jz ka hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">有效最终</h2><p id="c1fc" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">Java 8还引入了一个新概念，叫做“有效最终”变量。非final局部变量或方法参数的值在初始化后从未改变，称为有效final。在Java 8之前，我们不能在匿名类中使用非final局部变量。变量仍然必须是final，但不要求使用final关键字，如果违反规则，将抛出错误。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="2079" class="jz ka hi jv b fi kb kc l kd ke">String answer="Nuwan";<br/>new Thread(() -&gt;<br/>        System.<em class="kf">out</em>.println("The answer is " + answer))<br/>        .start();</span></pre><p id="373a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个lambda表达式可以访问“answer”的值，这是一个有效的最终变量，它的值在初始化后不会改变。</p><p id="f37e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你试图改变答案将会出错。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="7292" class="jz ka hi jv b fi kb kc l kd ke">//will not compile<br/>String answer="Nuwan";<br/>new Thread(() -&gt;<br/>        System.<em class="kf">out</em>.println("The answer is " + answer))<br/>        .start();<br/>answer="change";</span></pre><h2 id="c059" class="jz ka hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">无国籍的</h2><p id="f5f7" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">Lambda表达式在“无状态”时最有效&amp;没有<br/>共享可变数据。无状态lambda表达式在应用于Java并行流时特别有用。</p><p id="40d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当在集合中实现并行时，自动同步被添加以使其线程安全。然而，同步会引入线程争用，从而阻止线程并行运行。因此，当集合不被修改时，可以实现并行的好处。</p><p id="d26e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="http://henrikeichenhardt.blogspot.com/2013/06/why-shared-mutable-state-is-root-of-all.html" rel="noopener ugc nofollow" target="_blank">http://henrikeichenhardt . blogspot . com/2013/06/why-shared-mutable-state-is-root-of-all . html</a></p><h2 id="12e1" class="jz ka hi bd km kn ko kp kq kr ks kt ku iq kv kw kx iu ky kz la iy lb lc ld le bi translated">类型推理</h2><p id="e18e" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated"><em class="kf">类型推断</em>是Java编译器查看每个方法调用和相应声明以确定使调用适用的类型参数(或多个参数)的能力。</p><p id="e7fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">lambda表达式省略了方法名&amp;无关语法。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="fa2d" class="jz ka hi jv b fi kb kc l kd ke">List&lt;String&gt; list = new ArrayList&lt;&gt;();<br/>list.forEach(s -&gt; System.<em class="kf">out</em>.println(s));</span></pre><p id="9d6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以看到lambda中的类型信息<strong class="ih hj"> s </strong>丢失了，在这个例子中由于list是strings s也将是一个string。</p><h1 id="cef5" class="lk ka hi bd km ll lm ln kq lo lp lq ku lr ls lt kx lu lv lw la lx ly lz ld ma bi translated">关闭</h1><p id="c09b" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">Lambda表达式可以实现“闭包”的(简化)变体。闭包是一个对象，它将一个方法和一个至少有一个绑定变量的环境存储在一起。绑定变量是具有值的名称，例如数字或字符串。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="cc53" class="jz ka hi jv b fi kb kc l kd ke">private static void closures() {<br/>    Name name = new Name();<br/>    name.value="Nuwan";<br/>    new Thread(() -&gt;<br/>            System.<em class="kf">out</em>.println("The answer is " + name.value))<br/>            .start();<br/>    name.value="Chamara";<br/>}<br/><br/>private static class Name{<br/>    public String value;<br/>}</span></pre><p id="32ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你把这个和最终给出的样品进行比较，这就是我们之前没有做到的。这是因为传递给lambda的值是一个引用类型，只要引用是固定的，Lambda就不会抱怨。</p><p id="f7b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jt" href="https://dzone.com/articles/java-8-lambas-limitations-closures" rel="noopener ugc nofollow" target="_blank">https://dzone . com/articles/Java-8-lambas-limits-closures</a></p><h1 id="099c" class="lk ka hi bd km ll lm ln kq lo lp lq ku lr ls lt kx lu lv lw la lx ly lz ld ma bi translated">方法引用</h1><p id="f0ed" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">方法引用不是Lambda表达式，但是它们具有类似Lambda的行为。在Lambda中，方法引用将使用“<strong class="ih hj">:::</strong>而不是“<strong class="ih hj"> - &gt; </strong>”。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mb"><img src="../Images/f2f176a5a2d98836305ab31b99cd8168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*XC_Kq7jleygz2w7-XESXew.png"/></div></figure><p id="1e34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">方法引用通过创建一个单独的有名称的方法将Lambda转换成更可读的格式。使用方法引用可以使我们的代码更干净，可读性更强，并促进代码的重用。因此，尽可能使用方法引用是一个好习惯！</p><h1 id="c9c6" class="lk ka hi bd km ll lm ln kq lo lp lq ku lr ls lt kx lu lv lw la lx ly lz ld ma bi translated">功能界面</h1><p id="fac7" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">函数接口是只包含一个抽象方法的接口。当lambda表达式或方法引用作为参数传递给方法时，用于参数的类型。</p></div></div>    
</body>
</html>