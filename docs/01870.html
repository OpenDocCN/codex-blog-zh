<html>
<head>
<title>The Coppock Curve — Coding and Backtesting a Trading Strategy in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科博克曲线——用Python对交易策略进行编码和回溯测试</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-coppock-curve-coding-and-backtesting-a-trading-strategy-in-python-8dac8bbe3c3f?source=collection_archive---------0-----------------------#2021-06-10">https://medium.com/codex/the-coppock-curve-coding-and-backtesting-a-trading-strategy-in-python-8dac8bbe3c3f?source=collection_archive---------0-----------------------#2021-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ad88" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用科博克曲线指标进行更好的算法交易的完整指南</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/4d04b590a08aad63db05db3e85b2ee5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3LaP5sed86hpvoQk"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">穆罕默德·拉赫马尼在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2fa5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在今天的文章中，我们将讨论一个专门用于长期交易目的的特殊指标，即科博克曲线。我们将首先讨论科博克曲线的前提概念。然后，我们将继续探索本文的主要概念，即科博克曲线，以及指标背后的数学原理。之后，我们将进入编码部分，在这里我们将使用Python从头构建指标，基于它构建交易策略，对策略进行回溯测试，并将结果与SPY ETF(一种专门设计用于跟踪标准普尔500市场指数运动的ETF)的结果进行比较。话虽如此，让我们深入到文章中。</p><p id="52fd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在继续之前，如果你想在没有任何代码的情况下回溯测试你的交易策略，有一个解决方案。这是<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">的后验区</a>。这是一个平台，可以免费对不同类型的可交易资产的任意数量的交易策略进行回溯测试，无需编码。点击这里的链接，你可以马上使用这个工具:<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">https://www.backtestzone.com/</a></p><h1 id="e075" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">中华民国和WMA</h1><p id="da15" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">正如我之前所说，我们将首先讨论科博克曲线的前提概念，这些概念只不过是变化率(ROC)和加权移动平均线(WMA)。如果没有这些概念的知识，学习科博克曲线是很困难的。</p><p id="a4cb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先是ROC指标。变化率指标是一个动量指标，交易者使用它作为一种工具来确定价格相对于当前收盘价和指定时间段之前的价格的百分比变化。与RSI和CCI等其他动量指标不同，变化率指标是一个无界的振荡器，其值不会在一定的范围内波动。</p><p id="c46a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了计算ROC的读数，我们必须首先确定“n”值，这个值就是当前收盘价与多少个周期之前的值进行比较。“n”的确定因交易者而异，但传统的设置是9(广泛用于短期交易)。将9作为“n”值，ROC指示器的读数计算如下:</p><p id="a263" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，从当前收盘价中减去9期前的收盘价。这个差额然后除以9期前的收盘价，再乘以100。该计算可以用数学方法表示如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="12ee" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">ROC 9</strong> = [ ( <strong class="li hj">C.CLOSE </strong>- <strong class="li hj">PREV9.CLOSE</strong> ) / <strong class="li hj">PREV9.CLOSE</strong> ] * <strong class="li hj">100</strong></span><span id="7864" class="lm kl hi li b fi lr lo l lp lq">where,<br/>C.CLOSE = Current Closing Price<br/>PREV9.CLOSE = Closing Price of 9 Periods ago</span></pre><p id="545a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是WMA。在使用简单移动平均线时，困扰交易者的一件事是，该指标对一个系列中的所有数据点赋予相同的权重。这就是加权移动平均线发挥作用的地方。为了解决这个问题，WMA给最近或最近的数据点分配较大的权重(或较大的重要性),给过去的数据点分配较小的权重。为了确定给定系列的WMA，将每个值乘以预先确定的某些权重，并将结果相加。</p><p id="8946" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，让我们假设一个序列有过去三天的收盘价数据，它们的值分别是12，13，15。现在，为了计算这三个收盘价的WMA，我们需要首先确定权重，权重为1，2，3，权重之和为6。使用这些预先确定的权重及其总和，WMA计算如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="b542" class="lm kl hi li b fi ln lo l lp lq">[ <strong class="li hj">( 15 * 3 )</strong> + <strong class="li hj">( 13 * 2 )</strong> + <strong class="li hj">( 12 * 1 )</strong> ] / <strong class="li hj">6  </strong>= <strong class="li hj">21.333333</strong></span></pre><p id="33b1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从上面的计算中，您可以看到我们给最新的数据点(15)分配了较大的权重，给过去的数据点(12)分配了较小的权重。请注意，这是一个关于如何分配权重以计算WMA的非常基本的示例，但在现实世界中，情况要复杂得多。有时，权重也可以是十进制数。这就是关于中华民国和WMA的一切。现在，让我们深入了解这篇文章的主要概念，即科博克曲线。</p><h1 id="0c18" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">科博克曲线</h1><p id="9a42" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">由Edwin Coppock创立的Coppock曲线是一个长期动量指标，交易者或投资者经常使用它来确定市场的上涨趋势和下跌趋势。这一指标主要应用于标准普尔500等市场指数，以确定买入和卖出信号，但在本文中，我们将把它应用于股票，这样做也没有限制。此外，该指标的设计方式是按月实施，但今天我们将尝试按日实施。</p><p id="0a55" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过取两个roc的WMA来计算科博克曲线的读数，一个roc的n值较小，另一个roc的n值较大。确定科博克曲线的典型设置是10作为WMA的回望期，14和11分别作为长和短ROC的“n”值。使用典型设置计算Coppock曲线的公式可表示如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="aa92" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">COPPOCK CURVE</strong> =<strong class="li hj"> WMA 10 </strong>[ <strong class="li hj">LONG ROC </strong>+<strong class="li hj"> SHORT ROC</strong> ]</span><span id="7e0b" class="lm kl hi li b fi lr lo l lp lq">where,<br/>WMA 10 = 10-day Weighted Moving Average<br/>LONG ROC = 14-period Rate Of Change<br/>SHORT ROC = 11-period Rate Of Change</span></pre><p id="8f3f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是计算科博克曲线读数的全过程。现在，让我们来分析一个图表，其中苹果的收盘价数据与其科博克曲线一起绘制。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ls"><img src="../Images/f28f036ebc5a524e9f63ade1e0b783f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yP-ioY3DuswySd2I4o1qCg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="d23d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的图表分为两个面板:上面的面板是苹果的收盘价数据，下面的面板是科博克曲线的读数。从上面的图表中，可以观察到，每当Coppock曲线的读数高于零时，直方图以绿色绘制，同样，每当读数低于零或为负时，直方图变为红色。现在，使用直方图，我们可以很容易地发现市场的当前趋势。如果柱状图用绿色绘制，代表市场处于上升趋势，如果柱状图用红色绘制，则观察到市场处于下降趋势。科博克曲线也可以用来检测市场的波动和趋势，但这不是它的主要优势。</p><p id="178a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们来讨论一下利用科博克曲线可以建立的交易策略。根据这个指标实施的最重要的策略是零线交叉，当科博克曲线从零线以下上升到零线以上时，它显示买入信号，同样，当科博克曲线从零线以上下降到零线以下时，它显示卖出信号。如果零线听起来像一个流行语，它只不过是零(0)。该策略可以表示如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="3398" class="lm kl hi li b fi ln lo l lp lq">IF <strong class="li hj">P.COPPC</strong> &lt; <strong class="li hj">ZERO-LINE</strong> AND <strong class="li hj">C.COPPC</strong> &gt; <strong class="li hj">ZERO-LINE</strong> ==&gt; <strong class="li hj">BUY SIGNAL</strong><br/>IF <strong class="li hj">P.COPPC</strong> &gt; <strong class="li hj">ZERO-LINE </strong>AND <strong class="li hj">C.COPPC</strong> &lt; <strong class="li hj">ZERO-LINE</strong> ==&gt; <strong class="li hj">SELL SIGNAL</strong></span></pre><p id="99b6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">直接应用这种策略可能会导致灾难性的结果，因为科博克曲线有两个缺点。科博克曲线的第一个缺点是它在本质上非常滞后。因此，人们在使用该指标进行交易时，必须比以往任何时候都更加谨慎。另一个缺点是，科博克曲线容易暴露很多错误信号，导致我们做不好的交易。为了取得好的效果，需要对典型的零线交叉策略进行调优。只有当过去四个读数低于零线，当前读数高于零线时，我们调整的策略才会显示买入信号。同样，只有在过去四个读数高于零线，当前读数低于零线时，才会产生卖出。调整后的策略可以表示如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="ee13" class="lm kl hi li b fi ln lo l lp lq">IF <strong class="li hj">P.4 COPPCs</strong> &lt; <strong class="li hj">ZERO-LINE </strong>AND <strong class="li hj">C.COPPC </strong>&gt; <strong class="li hj">ZERO-LINE</strong> ==&gt; <strong class="li hj">BUY SIGNAL</strong><br/>IF <strong class="li hj">P.4 COPPCs</strong> &gt; <strong class="li hj">ZERO-LINE</strong> AND <strong class="li hj">C.COPPC </strong>&lt; <strong class="li hj">ZERO-LINE</strong> ==&gt; <strong class="li hj">SELL SIGNAL</strong></span></pre><p id="b0e1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就结束了我们关于科博克曲线的理论部分。现在，让我们转到编程部分，首先从头开始构建指标，构建我们刚刚讨论过的调整过的零线交叉策略，然后将我们的策略与Python中SPY ETF的性能进行比较。来做点编码吧！在继续之前，关于免责声明的一个注意事项:本文的唯一目的是教育人们，必须被视为一个信息，而不是投资建议等。</p><h1 id="9815" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">用Python实现</h1><p id="8f19" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">编码部分分为以下几个步骤:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="b6bd" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">1. Importing Packages<br/>2. Extracting Stock Data from Twelve Data<br/>3. Coppock Curve Calculation<br/>4. Creating the Tuned Zero-line Crossover Trading Strategy<br/>5. Plotting the Trading Lists<br/>6. Creating our Position<br/>7. Backtesting<br/>8. SPY ETF Comparison</strong></span></pre><p id="10ce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h2 id="9c60" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">步骤1:导入包</h2><p id="4817" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="f420" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="402f" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># IMPORTING PACKAGES<br/></strong><br/>import requests<br/>import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)</span></pre><p id="f139" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经将所有需要的包导入到python中。我们用十二数据的API端点来拉一下苹果的历史数据。</p><h2 id="f66d" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">步骤2:从12个数据中提取数据</h2><p id="89a5" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将使用twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">提供的API端点提取苹果的历史股票数据。在此之前，请注意twelvedata.com</a><a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank"/>:十二数据公司是领先的市场数据提供商之一，拥有大量适用于所有类型市场数据的API端点。它非常容易与十二数据提供的API进行交互，并且拥有有史以来最好的文档。此外，确保您在<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>上有一个帐户，只有这样，您才能访问您的API密钥(使用API提取数据的重要元素)。</p><p id="1f3d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="87a4" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># EXTRACTING STOCK DATA<br/></strong><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>aapl = get_historical_data('AAPL', '2020-01-01')<br/>aapl.tail()</span></pre><p id="2b5a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/ccc451aad18775ed8cd3122d91e7a742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0SIJuAIj-b8hQ2kJrIWUoQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="f157" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们做的第一件事是定义一个名为‘get _ historical _ data’的函数，该函数将股票的符号(‘symbol’)和历史数据的起始日期(‘start _ date’)作为参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们调用创建的函数来提取苹果公司从2020年开始的历史数据，并将其存储到‘AAPL’变量中。</p><h2 id="2ffe" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">第三步:科博克曲线计算</h2><p id="016a" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将按照之前讨论的公式来计算Coppock曲线的读数。</p><p id="5cb0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="6c8e" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># COPPOCK CURVE CALCULATION<br/></strong><br/>def wma(data, lookback):<br/>    weights = np.arange(1, lookback + 1)<br/>    val = data.rolling(lookback)<br/>    wma = val.apply(lambda prices: np.dot(prices, weights) / weights.sum(), raw = True)<br/>    return wma<br/><br/>def get_roc(close, n):<br/>    difference = close.diff(n)<br/>    nprev_values = close.shift(n)<br/>    roc = (difference / nprev_values) * 100<br/>    return roc<br/><br/>def get_cc(data, roc1_n, roc2_n, wma_lookback):<br/>    longROC = get_roc(data, roc1_n)<br/>    shortROC = get_roc(data, roc2_n)<br/>    ROC = longROC + shortROC<br/>    cc = wma(ROC, wma_lookback)<br/>    return cc<br/><br/>aapl['cc'] = get_cc(aapl['close'], 14, 11, 10)<br/>aapl = aapl.dropna()<br/>aapl.tail()</span></pre><p id="2dca" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/53919a7b8658e93eb1721fe673de8002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AL-JX0J3kSyPgIWXKPqL9g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="8a93" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>以上代码可分为三类:加权移动平均计算、变化率计算、科博克曲线计算。</p><p id="9eae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">wma计算:在这一部分中，我们首先定义一个名为“WMA”的函数，它将收盘价(“数据”)和回望期(“回望”)作为参数。在函数内部，我们首先确定分配给每个数据点的权重，并将它们存储到“weights”变量中。接下来，我们将创建一个名为‘val’的变量，在Pandas包提供的‘rolling’函数的帮助下，存储指定周期数的滚动数据系列。现在，使用预先确定的权重和滚动值，我们正在计算wma值并将其存储到“WMA”变量中。</p><p id="1901" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">ROC计算:首先，我们定义一个名为“get_roc”的函数，它将股票的收盘价(“close”)和“n”值(“n”)作为参数。在该函数中，我们首先使用Pandas包提供的“diff”函数来获取当前收盘价和指定时间段之前的收盘价之间的差值。在“shift”函数的帮助下，我们考虑了指定时间段之前的收盘价，并将其存储到“nprev_values”变量中。然后，我们将确定的值代入我们之前讨论的ROC指标公式，以计算值并最终返回数据。</p><p id="c35c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Coppock曲线计算:与我们在其他两个函数中所做的一样，这里我们也首先定义一个名为“get_cc”的函数，它将股票的收盘价数据(“data”)、较长ROC(“ROC _ 1”)和较短ROC(“ROC _ 2”)的“n”值以及加权移动平均回看周期(“wma_lookback”)作为参数。在函数内部，我们首先使用前面创建的“get_roc”函数确定两个roc，一个具有较大的“n”值，另一个具有较短的“n”值。然后我们将两个ROC相加，并将结果存储到“ROC”变量中。在我们之前创建的“wma”函数的帮助下，我们对两个roc之和进行加权移动平均，以获得Coppock曲线的读数。</p><p id="4abc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们调用创建的“get_cc”函数来存储苹果公司的Coppock曲线的读数。现在，让我们开始创建讨论过的调整零线交叉交易策略。</p><h2 id="8cea" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">步骤4:创建交易策略</h2><p id="6c36" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将在python中实现讨论过的Coppock曲线调整的零线交叉交易策略。</p><p id="5469" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="c2e1" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># COPPOCK CURVE STRATEGY<br/></strong><br/>def implement_cc_strategy(prices, cc):<br/>    buy_price = []<br/>    sell_price = []<br/>    cc_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(prices)):<br/>        if cc[i-4] &lt; 0 and cc[i-3] &lt; 0 and cc[i-2] &lt; 0 and cc[i-1] &lt; 0 and cc[i] &gt; 0:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                cc_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                cc_signal.append(0)<br/>        elif cc[i-4] &gt; 0 and cc[i-3] &gt; 0 and cc[i-2] &gt; 0 and cc[i-1] &gt; 0 and cc[i] &lt; 0:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                cc_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                cc_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            cc_signal.append(0)<br/>            <br/>    return buy_price, sell_price, cc_signal<br/><br/>buy_price, sell_price, cc_signal = implement_cc_strategy(aapl['close'], aapl['cc'])</span></pre><p id="8ef0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为‘implement _ cc _ strategy’的函数，它将股票价格(‘prices’)和科博克曲线的读数(‘cc’)作为参数。</p><p id="f10d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在该函数中，我们创建了三个空列表(buy_price、sell_price和cc_signal ),在创建交易策略时，将在这些列表中追加值。</p><p id="35e8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之后，我们通过for循环实施交易策略。在for循环内部，我们传递某些条件，如果条件得到满足，相应的值将被追加到空列表中。如果购买股票的条件得到满足，买入价将被追加到“buy_price”列表中，信号值将被追加为1，表示购买股票。类似地，如果卖出股票的条件得到满足，卖价将被追加到“sell_price”列表中，信号值将被追加为-1，表示卖出股票。</p><p id="553e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们返回附加了值的列表。然后，我们调用创建的函数并将值存储到各自的变量中。除非我们画出这些值，否则这个列表没有任何意义。所以，让我们画出创建的交易列表的值。</p><h2 id="fc70" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">第五步:绘制交易信号</h2><p id="011a" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将绘制已创建的交易列表，以使它们有意义。</p><p id="2be6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="5b75" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># COPPOCK CURVE TRADING SIGNAL PLOT<br/></strong><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 6, colspan = 1)<br/>ax1.plot(aapl['close'], linewidth = 2, label = 'aapl')<br/>ax1.plot(aapl.index, buy_price, marker = '^', color = 'green', markersize = 12, linewidth = 0, label = 'BUY SIGNAL')<br/>ax1.plot(aapl.index, sell_price, marker = 'v', color = 'r', markersize = 12, linewidth = 0, label = 'SELL SIGNAL')<br/>ax1.legend()<br/>ax1.set_title('AAPL CC TRADING SIGNALS')<br/>for i in range(len(aapl)):<br/>    if aapl.iloc[i, 5] &gt;= 0:<br/>        ax2.bar(aapl.iloc[i].name, aapl.iloc[i, 5], color = '#009688')<br/>    else:    <br/>        ax2.bar(aapl.iloc[i].name, aapl.iloc[i, 5], color = '#f44336')<br/>ax2.set_title('AAPL COPPOCK CURVE')<br/>plt.show()</span></pre><p id="1205" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/a1a46e2681a894d7e983c3f8b94a7ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XHeRIUiZAE-eEp-MXylolA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="b31b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们正在绘制科博克曲线的读数，以及由调整后的零线交叉交易策略产生的买入和卖出信号。我们可以观察到，每当Coppock曲线的前四个读数低于零线，当前读数高于零线时，图表中就会绘制绿色的买入信号。类似地，每当Coppock曲线的前四个读数在零线以上，当前读数在零线以下时，图表中就会显示红色的卖出信号。</p><h2 id="2f18" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">步骤6:创建我们的职位</h2><p id="ed07" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将创建一个列表，如果我们持有股票，该列表将指示1；如果我们不拥有或持有股票，该列表将指示0。</p><p id="2a78" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="30c0" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># STOCK POSITION<br/></strong><br/>position = []<br/>for i in range(len(cc_signal)):<br/>    if cc_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(aapl['close'])):<br/>    if cc_signal[i] == 1:<br/>        position[i] = 1<br/>    elif cc_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = aapl['close']<br/>cc = aapl['cc']<br/>cc_signal = pd.DataFrame(cc_signal).rename(columns = {0:'cc_signal'}).set_index(aapl.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'cc_position'}).set_index(aapl.index)<br/><br/>frames = [close_price, cc, cc_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy</span></pre><p id="6161" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/16de43f7bb402f9905c7290a0ec653e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ml-gdhx5vh-10lfPKh1h9w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="24ed" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们创建一个名为‘position’的空列表。我们传递两个for循环，一个是为“位置”列表生成值，以匹配“信号”列表的长度。另一个for循环是我们用来生成实际位置值的循环。在第二个for循环中，我们对“signal”列表的值进行迭代，而“position”列表的值被附加到满足哪个条件上。如果我们持有股票，头寸的价值仍为1；如果我们卖出或不持有股票，头寸的价值仍为0。最后，我们正在进行一些数据操作，将所有创建的列表合并到一个数据帧中。</p><p id="5bbd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从显示的输出中，我们可以看到，在前两行中，我们在股票中的位置保持为1(因为在Coppock曲线信号中没有任何变化)，但是当Coppock曲线交易信号代表卖出信号(-1)时，当我们卖出股票时，我们的位置突然变成-1。我们的头寸将保持为0，直到交易信号发生一些变化。现在是时候实现一些回溯测试过程了！</p><h2 id="12be" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">步骤7:回溯测试</h2><p id="4244" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在继续之前，有必要知道什么是回溯测试。回溯测试是查看我们的交易策略在给定股票数据上表现如何的过程。在我们的例子中，我们将对苹果股票数据的Coppock曲线交易策略实施回溯测试过程。</p><p id="ad7d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="cf74" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># BACKTESTING<br/></strong><br/>aapl_ret = pd.DataFrame(np.diff(aapl['close'])).rename(columns = {0:'returns'})<br/>cc_strategy_ret = []<br/><br/>for i in range(len(aapl_ret)):<br/>    returns = aapl_ret['returns'][i]*strategy['cc_position'][i]<br/>    cc_strategy_ret.append(returns)<br/>    <br/>cc_strategy_ret_df = pd.DataFrame(cc_strategy_ret).rename(columns = {0:'cc_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/aapl['close'][0])<br/>cc_investment_ret = []<br/><br/>for i in range(len(cc_strategy_ret_df['cc_returns'])):<br/>    returns = number_of_stocks*cc_strategy_ret_df['cc_returns'][i]<br/>    cc_investment_ret.append(returns)<br/><br/>cc_investment_ret_df = pd.DataFrame(cc_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(cc_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the CC strategy by investing $100k in AAPL : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the CC strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre><p id="4f90" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="773e" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">Profit gained from the CC strategy by investing $100k in AAPL : 60850.26</strong><br/><strong class="li hj">Profit percentage of the CC strategy : 60%</strong></span></pre><p id="cf8a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们使用NumPy包提供的‘diff’函数计算苹果股票的回报，并将其作为数据帧存储到‘AAPL _ ret’变量中。接下来，我们将传递一个for循环来迭代' aapl_ret '变量的值，以计算我们从Coppock曲线交易策略中获得的回报，这些回报值将被追加到' cc_strategy_ret '列表中。接下来，我们将“cc_strategy_ret”列表转换为数据帧，并将其存储到“cc_strategy_ret_df”变量中。</p><p id="0c87" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是回溯测试过程。我们将通过投资10万美元到我们的交易策略中来回测我们的策略。首先，我们将投资金额存储到“投资值”变量中。之后，我们正在计算使用投资金额可以购买的苹果股票数量。你可以注意到，我使用了Math软件包提供的“floor”函数，因为当投资金额除以苹果股票的收盘价时，它会输出一个十进制数。股票数量应该是整数，而不是小数。使用“底数”函数，我们可以去掉小数。请记住,“floor”函数比“round”函数要复杂得多。然后，我们传递一个for循环来查找投资回报，后面是一些数据操作任务。</p><p id="422b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们打印了我们通过投资10万美元到我们的交易策略中得到的总回报，并且显示我们在一年中获得了大约6万美元的利润。那还不错！现在，让我们将我们的回报与SPY ETF(一种旨在跟踪标准普尔500股票市场指数的ETF)的回报进行比较。</p><h2 id="da55" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">第八步:间谍ETF对比</h2><p id="a053" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">这一步是可选的，但强烈推荐，因为我们可以了解我们的交易策略相对于基准(间谍ETF)的表现如何。在这一步中，我们将使用我们创建的“get_historical_data”函数提取SPY ETF数据，并将我们从SPY ETF获得的回报与我们在Apple上的Coppock曲线调整的零线交叉交易策略回报进行比较。</p><p id="9974" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可能已经注意到，在我所有的算法交易文章中，我没有将策略结果与标准普尔500市场指数本身进行比较，而是与SPY ETF进行比较，这是因为大多数股票数据提供商(如12 Data)不提供标准普尔500指数数据。所以，我别无选择，只能选择间谍ETF。如果你有幸得到标准普尔500市场指数数据，建议用它来做比较，而不是任何ETF。</p><p id="8ea0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="aaae" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># SPY ETF COMPARISON<br/></strong><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('CC Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre><p id="8c9c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="5af5" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">Benchmark profit by investing $100k : 22929.75</strong><br/><strong class="li hj">Benchmark Profit percentage : 22%</strong><br/><strong class="li hj">CC Strategy profit is 38% higher than the Benchmark Profit</strong></span></pre><p id="95af" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>这一步中使用的代码几乎与前一个回溯测试步骤中使用的代码相似，但我们不是投资苹果，而是通过不实施任何交易策略来投资SPY ETF。从输出中，我们可以看到我们的Coppock曲线调整的零线交叉交易策略已经跑赢SPY ETF 22%。太好了！</p><h1 id="11a3" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后的想法！</h1><p id="c28b" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在粉碎理论和编码部分的巨大过程后，我们成功地了解了科博克曲线是什么，以及如何在Python的帮助下实现基于它的交易策略。</p><p id="e8a7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，谈到我在所有文章中经常提到的即兴创作，可以改进的一个重要方面是选择最佳股票的方法。在本文中，我们随机选择了苹果股票来实施该指标，但在现实市场中应用时，它可能会导致糟糕的交易。因此，选择正确的股票至关重要，但如何选择呢？用定量策略处理这种情况会更好，如果这听起来太专业，请在这里阅读我的文章。</p><p id="2cf3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就是这样！如果您忘记了遵循任何编码部分，不要担心。我在文章末尾提供了完整的源代码。希望你能从这篇文章中学到一些新的有用的东西。</p><h2 id="d1b5" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">完整代码:</h2><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="0034" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># IMPORTING PACKAGES<br/></strong><br/>import requests<br/>import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)<br/><br/><br/><strong class="li hj"># EXTRACTING STOCK DATA<br/></strong><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>aapl = get_historical_data('AAPL', '2020-01-01')<br/>aapl.tail()<br/><br/><br/><strong class="li hj"># COPPOCK CURVE CALCULATION<br/></strong><br/>def wma(data, lookback):<br/>    weights = np.arange(1, lookback + 1)<br/>    val = data.rolling(lookback)<br/>    wma = val.apply(lambda prices: np.dot(prices, weights) / weights.sum(), raw = True)<br/>    return wma<br/><br/>def get_roc(close, n):<br/>    difference = close.diff(n)<br/>    nprev_values = close.shift(n)<br/>    roc = (difference / nprev_values) * 100<br/>    return roc<br/><br/>def get_cc(data, roc1_n, roc2_n, wma_lookback):<br/>    longROC = get_roc(data, roc1_n)<br/>    shortROC = get_roc(data, roc2_n)<br/>    ROC = longROC + shortROC<br/>    cc = wma(ROC, wma_lookback)<br/>    return cc<br/><br/>aapl['cc'] = get_cc(aapl['close'], 14, 11, 10)<br/>aapl = aapl.dropna()<br/>aapl.tail()<br/><br/><br/><strong class="li hj"># COPPOCK CURVE PLOT<br/></strong><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 6, colspan = 1)<br/>ax1.plot(aapl['close'], linewidth = 2.5)<br/>ax1.set_title('AAPL CLOSING PRICES')<br/>for i in range(len(aapl)):<br/>    if aapl.iloc[i, 5] &gt;= 0:<br/>        ax2.bar(aapl.iloc[i].name, aapl.iloc[i, 5], color = '#009688')<br/>    else:    <br/>        ax2.bar(aapl.iloc[i].name, aapl.iloc[i, 5], color = '#f44336')<br/>ax2.set_title('AAPL COPPOCK CURVE')<br/>plt.show()<br/><br/><br/><strong class="li hj"># COPPOCK CURVE STRATEGY<br/></strong><br/>def implement_cc_strategy(prices, cc):<br/>    buy_price = []<br/>    sell_price = []<br/>    cc_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(prices)):<br/>        if cc[i-4] &lt; 0 and cc[i-3] &lt; 0 and cc[i-2] &lt; 0 and cc[i-1] &lt; 0 and cc[i] &gt; 0:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                cc_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                cc_signal.append(0)<br/>        elif cc[i-4] &gt; 0 and cc[i-3] &gt; 0 and cc[i-2] &gt; 0 and cc[i-1] &gt; 0 and cc[i] &lt; 0:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                cc_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                cc_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            cc_signal.append(0)<br/>            <br/>    return buy_price, sell_price, cc_signal<br/><br/>buy_price, sell_price, cc_signal = implement_cc_strategy(aapl['close'], aapl['cc'])<br/><br/><br/><strong class="li hj"># COPPOCK CURVE TRADING SIGNAL PLOT<br/></strong><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 6, colspan = 1)<br/>ax1.plot(aapl['close'], linewidth = 2, label = 'AAPL')<br/>ax1.plot(aapl.index, buy_price, marker = '^', color = 'green', markersize = 12, linewidth = 0, label = 'BUY SIGNAL')<br/>ax1.plot(aapl.index, sell_price, marker = 'v', color = 'r', markersize = 12, linewidth = 0, label = 'SELL SIGNAL')<br/>ax1.legend()<br/>ax1.set_title('AAPL CC TRADING SIGNALS')<br/>for i in range(len(aapl)):<br/>    if aapl.iloc[i, 5] &gt;= 0:<br/>        ax2.bar(aapl.iloc[i].name, aapl.iloc[i, 5], color = '#009688')<br/>    else:    <br/>        ax2.bar(aapl.iloc[i].name, aapl.iloc[i, 5], color = '#f44336')<br/>ax2.set_title('AAPL COPPOCK CURVE')<br/>plt.show()<br/><br/><br/><strong class="li hj"># STOCK POSITION<br/></strong><br/>position = []<br/>for i in range(len(cc_signal)):<br/>    if cc_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(aapl['close'])):<br/>    if cc_signal[i] == 1:<br/>        position[i] = 1<br/>    elif cc_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = aapl['close']<br/>cc = aapl['cc']<br/>cc_signal = pd.DataFrame(cc_signal).rename(columns = {0:'cc_signal'}).set_index(aapl.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'cc_position'}).set_index(aapl.index)<br/><br/>frames = [close_price, cc, cc_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy<br/>strategy[10:15]<br/><br/><br/><strong class="li hj"># BACKTESTING<br/></strong><br/>aapl_ret = pd.DataFrame(np.diff(aapl['close'])).rename(columns = {0:'returns'})<br/>cc_strategy_ret = []<br/><br/>for i in range(len(aapl_ret)):<br/>    returns = aapl_ret['returns'][i]*strategy['cc_position'][i]<br/>    cc_strategy_ret.append(returns)<br/>    <br/>cc_strategy_ret_df = pd.DataFrame(cc_strategy_ret).rename(columns = {0:'cc_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/aapl['close'][0])<br/>cc_investment_ret = []<br/><br/>for i in range(len(cc_strategy_ret_df['cc_returns'])):<br/>    returns = number_of_stocks*cc_strategy_ret_df['cc_returns'][i]<br/>    cc_investment_ret.append(returns)<br/><br/>cc_investment_ret_df = pd.DataFrame(cc_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(cc_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the CC strategy by investing $100k in AAPL : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the CC strategy : {}%'.format(profit_percentage), attrs = ['bold']))<br/><br/><br/><strong class="li hj"># SPY ETF COMPARISON<br/></strong><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('CC Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre></div></div>    
</body>
</html>