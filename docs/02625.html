<html>
<head>
<title>Increasing Stock Returns by Combining Williams %R and MACD in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过在Python中结合威廉姆斯%R和MACD提高股票回报率</h1>
<blockquote>原文：<a href="https://medium.com/codex/increasing-stock-returns-by-combining-williams-r-and-macd-in-python-5af999c90259?source=collection_archive---------5-----------------------#2021-07-29">https://medium.com/codex/increasing-stock-returns-by-combining-williams-r-and-macd-in-python-5af999c90259?source=collection_archive---------5-----------------------#2021-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f6f5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">关于使用python结合两个技术指标并创建杀手交易策略的详细案例研究</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/05fca0013eec4c6f510ba6b54fac9e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rM4xfEsJQH4RxbX7T29sSQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@jpvalery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jp Valery </a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄(作者编辑)</figcaption></figure><p id="1966" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">技术指标是交易领域的新宠，值得花时间去研究。虽然它在分析市场方面有更大的潜力，但是我们也应该明确地考虑它的缺点。虽然不多，但有一个明显的问题是，它会泄露错误信号，一旦被发现，可能会导致灾难性的后果。很难避免这种信号，但不是不可避免的，最好的方法之一是结合两个技术指标，其中一个指标作为过滤器，将真实信号与虚假信号进行分类。这正是我们今天要做的。</p><p id="d091" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这篇文章中，我们将结合两个强大的技术指标，威廉姆斯%R和移动平均线收敛/发散(MACD ),创造一个杀手交易策略，尽可能消除虚假交易信号，大大提高投资回报。事不宜迟，让我们进入文章。</p><p id="4588" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在继续之前，如果你想在没有任何代码的情况下回溯测试你的交易策略，有一个解决方案。这是<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">的后验区</a>。这是一个平台，可以免费对不同类型的可交易资产的任意数量的交易策略进行回溯测试，无需编码。点击这里的链接，你可以马上使用这个工具:<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">https://www.backtestzone.com/</a></p><h1 id="ebe8" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">威廉姆斯%R</h1><p id="f726" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">由拉里·威廉姆斯创立的威廉姆斯%R是一个动量指标，其值在0到-100之间波动。这个指标和随机振荡指标非常相似，但是计算方法不同。交易者使用这个指标，通过构建超买和超卖两个级别来发现交易的潜在进场点和出场点。在讨论超买和超卖水平之前，先说一句:当市场趋势看起来非常看涨并注定要盘整时，股票被认为是超买。类似地，当市场趋势似乎极度看跌并有反弹趋势时，股票到达超卖区域。超买和超卖水平的传统阈值分别是20和80，但也没有任何禁止采取其他价值。</p><p id="42fc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了用14作为回望周期的传统设置来计算Williams %R的值，首先，确定14天时间范围内每个周期的最高价和最低价。然后，取两个差值:从最高价到收盘价，从最高价到最低价。最后，将第一个差值除以第二个差值，再乘以-100，以获得Williams %R的值。该计算可数学表示如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="c9bf" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">W%R 14</strong> = [ <strong class="li hj">H.HIGH</strong> - <strong class="li hj">C.PRICE</strong> ] / [ <strong class="li hj">L.LOW</strong> - <strong class="li hj">C.PRICE</strong> ] * (<strong class="li hj"> - 100</strong> )</span><span id="7969" class="lm kl hi li b fi lr lo l lp lq">where,<br/>W%R 14 = 14-day Williams %R of the stock<br/>H.HIGH = 14-day Highest High of the stock<br/>L.LOW = 14-day Lowest Low of the stock<br/>C.PRICE = Closing price of the stock</span></pre><p id="3966" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个指标的基本思想是，当它是一个强劲的上升趋势时，股票将不断达到新高，同样，当它跟随一个强劲的下降趋势时，股票将达到新低。现在，让我们分析威廉姆斯%R的图表，以便更好地理解该指标。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ls"><img src="../Images/08c0f1a8ae46e09797310f1866eb4089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mDhpJn9BAya9N6v1oG7Y7A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="9e4d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的图表分为两个面板:上面的面板显示苹果股票数据的收盘价，下面的面板显示苹果14天Williams %R的读数。现在，该图表可以通过两种方式使用。第一种方法是使用图表作为工具来识别市场的超买和超卖状态。你可以观察到在市场的上方和下方有两条水平的灰色线，这是超买和超卖水平，分别位于-20和-80。如果威廉姆斯%R的读数高于上线或超买线，您可以认为市场处于超买状态。同样，如果威廉姆斯%R的读数低于较低的线或超卖线，你可以假设市场处于超卖状态。</p><p id="202b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用威廉姆斯%R的第二种方法是识别市场中的虚假动量。在强劲的上升趋势中，威廉姆斯%R的读数往往达到-20以上。如果该指标下跌，并在下一次下跌之前努力达到-20以上，表明市场的动力不是真实的，可能会跟随一个巨大的下跌趋势。同样，在健康的下跌趋势中，威廉姆斯%R的读数必然会经常低于-80。如果该指标上涨，但在下一次上涨前未能达到-80，表明市场将遵循积极的趋势。</p><p id="c688" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于威廉姆斯%R是一个方向指标(其运动与实际市场的运动成正比)，交易者也用这个指标来寻找和确认市场中的强劲上涨趋势或下跌趋势，并沿着它进行交易。一些指标在用于识别或确认市场趋势时没有多大用处，因为它们可能在本质上是滞后的(考虑历史数据点以确定当前读数的指标)，但Williams %R是一个有效的指标，因为它是领先指标(考虑先前数据点以预测未来走势的指标)。</p><h1 id="46c2" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">MACD</h1><p id="e549" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在学习MACD之前，有必要知道指数移动平均线(EMA)是什么意思。EMA是一种移动平均线(MA ),它自动为最近的数据点分配较大的权重(除了重要性之外),而为遥远过去的数据点分配较小的权重。例如，一份试卷将由10%的一分问题、40%的三分问题和50%的长答案问题组成。从这个例子中，您可以观察到，我们根据重要性级别为试卷的每个部分分配了唯一的权重(长答案问题可能比一分问题更重要)。</p><p id="d1d5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，MACD是一个趋势跟踪领先指标，通过减去两个指数移动平均线(一个周期较长，另一个周期较短)来计算。MACD指标有三个显著的组成部分。</p><ul class=""><li id="a6c3" class="lt lu hi jq b jr js ju jv jx lv kb lw kf lx kj ly lz ma mb bi translated"><strong class="jq hj"> MACD线:</strong>这条线是两个给定的指数均线之差。为了计算MACD线，需要计算一个周期较长的均线(慢速线)和一个周期较短的均线(快速线)。最快和最慢的长度分别是12，26。从快速均线中减去慢速均线可以得到最终的MACD线值。计算MACD线的公式可以表示如下:</li></ul><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="2ceb" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">MACD LINE = FAST LENGTH EMA - SLOW LENGTH EMA</strong></span></pre><ul class=""><li id="ae16" class="lt lu hi jq b jr js ju jv jx lv kb lw kf lx kj ly lz ma mb bi translated"><strong class="jq hj">信号线:</strong>这条线是MACD线本身在给定时间段内的指数移动平均线。计算信号线最流行的时期是9。由于我们平均了MACD线本身，信号线将比MACD线更平滑。</li><li id="215a" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated"><strong class="jq hj">直方图:</strong>顾名思义，是特意绘制出来揭示MACD线和信号线区别的直方图。这是用来识别趋势的一个很好的组件。计算直方图的公式可表示如下:</li></ul><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="cada" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">HISTOGRAM = MACD LINE - SIGNAL LINE</strong></span></pre><p id="c003" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">既然我们已经了解了MACD到底是什么。让我们分析一张MACD的图表来建立对指标的直觉。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/c4b82050f5a433a9ba19de51ef422200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ncG_Wx3uAKRWxYKq4OhNg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="8a70" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此图中有两个面板:顶部面板是苹果收盘价的图，底部面板是计算的MACD成分的一系列图。让我们拆开来看看每一个部件。</p><p id="7462" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">底部面板中第一个也是最明显的部分显然是计算直方图值的图。你可以注意到，每当市场显示负趋势时，该图就会变红，每当市场显示正趋势时，该图就会变绿。直方图的这个特性在识别市场趋势时变得非常方便。每当MACD线和信号线之间的差异很大时，直方图就扩展得更大，并且值得注意的是，直方图有时收缩，表示两个其他分量之间的差异相对较小。</p><p id="6712" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来的两个组件是MACD线和信号线。MACD线是灰色的线图，显示了苹果股价的慢速均线和快速均线之间的差异。同样，蓝色的线图是代表MACD线本身的均线的信号线。正如我们之前讨论的，信号线看起来更像是MACD线的平滑版本，因为它是通过平均MACD线本身的值计算出来的。</p><h1 id="66a8" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">交易策略</h1><p id="8901" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">现在我们已经对威廉姆斯%R和MACD指标建立了一些基本的直觉。让我们讨论一下这篇文章中我们将要实施的交易策略。这个策略非常简单。如果之前的威廉姆斯%R读数高于-50，当前的威廉姆斯%R读数低于-50，并且MACD线大于信号线，我们就做多(买入股票)。同样，如果之前的威廉姆斯%R读数低于-50，当前的威廉姆斯%R读数高于-50，并且MACD线小于信号线，我们做空(卖出股票)。我们的交易策略可以表述如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="d5bd" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">PREV.WR</strong> <strong class="li hj">&gt; -50</strong> AND <strong class="li hj">CUR.WR &lt; -50 </strong>AND <strong class="li hj">MACD.L &gt; SIGNAL.L </strong>==&gt; <strong class="li hj">BUY SIGNAL</strong><br/><strong class="li hj">PREV.WR &lt; -50</strong> AND <strong class="li hj">CUR.WR &gt;</strong> -<strong class="li hj">50 </strong>AND <strong class="li hj">MACD.L &lt; SIGNAL.L</strong> ==&gt;<strong class="li hj"> SELL SIGNAL</strong></span></pre><p id="abaf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就是这样！我们的理论部分到此结束，让我们进入编程部分，我们将首先使用Python从头构建指标，构建讨论的交易策略，对苹果股票数据进行回溯测试，最后将结果与SPY ETF的结果进行比较。来做点编码吧！在继续之前，关于免责声明的一个注意事项:本文的唯一目的是教育人们，必须被视为一个信息，而不是投资建议等。</p><h1 id="2dcd" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">用Python实现</h1><p id="adb5" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">编码部分分为以下几个步骤:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="f892" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">1. Importing Packages<br/>2. Extracting Stock Data from Twelve Data<br/>3. Williams %R Calculation<br/>4. MACD Calculation<br/>5. Creating the Trading Strategy<br/>6. Creating our Position<br/>7. Backtesting<br/>8. SPY ETF Comparison</strong></span></pre><p id="18e9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h2 id="1027" class="lm kl hi bd km mi mj mk kq ml mm mn ku jx mo mp kw kb mq mr ky kf ms mt la mu bi translated">步骤1:导入包</h2><p id="f57d" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="721a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="2a2b" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># IMPORTING PACKAGES<br/></strong><br/>import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import requests<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)</span></pre><p id="39a4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经将所有需要的包导入到python中。我们用十二数据的API端点来拉一下苹果的历史数据。</p><h2 id="6dad" class="lm kl hi bd km mi mj mk kq ml mm mn ku jx mo mp kw kb mq mr ky kf ms mt la mu bi translated">步骤2:从12个数据中提取股票数据</h2><p id="3b08" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将使用由<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>提供的API端点提取苹果的历史股票数据。在此之前，请注意twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank"/>:十二数据公司是领先的市场数据提供商之一，拥有大量适用于所有类型市场数据的API端点。它非常容易与十二数据提供的API进行交互，并且拥有有史以来最好的文档。此外，确保你有一个twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">的账户，只有这样，你才能访问你的API密匙(用API提取数据的重要元素)。</a></p><p id="e4d0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="b6ea" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># EXTRACTING STOCK DATA<br/></strong><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>aapl = get_historical_data('AAPL', '2010-01-01')<br/>aapl.tail()</span></pre><p id="9526" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/b7653a0260446ab3c1c669b61ad4074f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*69IvVmKmjyK4NZFUYw6Q1A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="27b7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们做的第一件事是定义一个名为‘get _ historical _ data’的函数，该函数将股票的符号(‘symbol’)和历史数据的起始日期(‘start _ date’)作为参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们调用创建的函数从2010年开始提取苹果的历史数据，并将其存储到‘AAPL’变量中。</p><h2 id="8806" class="lm kl hi bd km mi mj mk kq ml mm mn ku jx mo mp kw kb mq mr ky kf ms mt la mu bi translated">步骤3:威廉姆斯%R计算</h2><p id="4dcf" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将按照之前讨论的公式计算Williams %R的值。</p><p id="efa0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="b5df" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># WILLIAMS %R CALCULATION<br/></strong><br/>def get_wr(high, low, close, lookback):<br/>    highh = high.rolling(lookback).max() <br/>    lowl = low.rolling(lookback).min()<br/>    wr = -100 * ((highh - close) / (highh - lowl))<br/>    return wr<br/><br/>aapl['wr_14'] = get_wr(aapl['high'], aapl['low'], aapl['close'], 14)<br/>aapl.tail()</span></pre><p id="1ede" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/eda22c3d70858c76d120265974996231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pR7uFk4bzqRzDbUfzV3hoA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="704a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们首先定义一个名为“get_wr”的函数，它将股票的高价格数据(“高”)、低价格数据(“低”)、收盘价数据(“收盘”)和回望期(“周期”)作为参数。</p><p id="ed91" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在该函数中，我们首先借助Pandas软件包提供的“滚动”和“最大”函数来确定特定回看时段内的最高高点，并将其存储到“high”变量中。“滚动”函数的作用是考虑我们指定的n周期时间框架，而“最大值”函数过滤给定数据框架中的最大值。</p><p id="668c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我们将定义一个名为“lowl”的变量来存储指定回看周期时间范围内的最低低点，我们使用Pandas包提供的“滚动”和“最小”函数(顾名思义，过滤给定数据帧中的最小值)来确定该时间范围。</p><p id="5172" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，我们将确定的最高最高值和最低低值代入之前讨论的公式，计算Williams %R的值，并将其存储到“wr”变量中。最后，我们返回并调用创建的函数来存储Apple的Williams %R读数，14为回望期。</p><h2 id="e1e9" class="lm kl hi bd km mi mj mk kq ml mm mn ku jx mo mp kw kb mq mr ky kf ms mt la mu bi translated">第四步:MACD计算</h2><p id="81fb" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将从提取的苹果历史数据中计算MACD指标的所有组成部分。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="3960" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># MACD CALCULATION<br/></strong><br/>def get_macd(price, slow, fast, smooth):<br/>    exp1 = price.ewm(span = fast, adjust = False).mean()<br/>    exp2 = price.ewm(span = slow, adjust = False).mean()<br/>    macd = pd.DataFrame(exp1 - exp2).rename(columns = {'close':'macd'})<br/>    signal = pd.DataFrame(macd.ewm(span = smooth, adjust = False).mean()).rename(columns = {'macd':'signal'})<br/>    hist = pd.DataFrame(macd['macd'] - signal['signal']).rename(columns = {0:'hist'})<br/>    return macd, signal, hist<br/><br/>aapl['macd'] = get_macd(aapl['close'], 26, 12, 9)[0]<br/>aapl['macd_signal'] = get_macd(aapl['close'], 26, 12, 9)[1]<br/>aapl['macd_hist'] = get_macd(aapl['close'], 26, 12, 9)[2]<br/>aapl = aapl.dropna()<br/>aapl.tail()</span></pre><p id="583e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mx"><img src="../Images/7f1edb8fd2fd4c035bfb42231ef75c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mSYu07Mk1uaZRtsxI8E7kw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="4635" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为“get_macd”的函数，它获取股票的价格(“prices”)、慢速均线的长度(“slow”)、快速均线的长度(“fast”)以及信号线的周期(“smooth”)。</p><p id="fbb0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在函数内部，我们首先使用Pandas提供的“ewm”函数计算快速和慢速长度ema，并将它们分别存储到“ema1”和“ema2”变量中。</p><p id="1cf1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我们通过从快速均线中减去慢速均线来计算macd线的值，并以熊猫数据帧的形式存储到“MACD”变量中。接下来，我们定义了一个名为“signal”的变量来存储信号线的值，该值是通过在指定的时间段内获取macd线值(“MACD”)的均线来计算的。</p><p id="e50b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，我们通过从信号线的值(“信号”)中减去macd线的值(“MACD”)来计算直方图值，并将它们存储到“hist”变量中。最后，我们返回所有计算出的值，并调用创建的函数来存储苹果的MACD组件。</p><h2 id="c923" class="lm kl hi bd km mi mj mk kq ml mm mn ku jx mo mp kw kb mq mr ky kf ms mt la mu bi translated">步骤5:创建交易策略:</h2><p id="2b21" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将在python中实现讨论过的威廉姆斯%R和移动平均线收敛/发散(MACD)组合交易策略。</p><p id="3205" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="0304" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># TRADING STRATEGY<br/></strong><br/>def implement_wr_macd_strategy(prices, wr, macd, macd_signal):    <br/>    buy_price = []<br/>    sell_price = []<br/>    wr_macd_signal = []<br/>    signal = 0<br/><br/>    for i in range(len(wr)):<br/>        if wr[i-1] &gt; -50 and wr[i] &lt; -50 and macd[i] &gt; macd_signal[i]:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                wr_macd_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                wr_macd_signal.append(0)<br/>                <br/>        elif wr[i-1] &lt; -50 and wr[i] &gt; -50 and macd[i] &lt; macd_signal[i]:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                wr_macd_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                wr_macd_signal.append(0)<br/>        <br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            wr_macd_signal.append(0)<br/>            <br/>    return buy_price, sell_price, wr_macd_signal<br/>            <br/>buy_price, sell_price, wr_macd_signal = implement_wr_macd_strategy(aapl['close'], aapl['wr_14'], aapl['macd'], aapl['macd_signal'])</span></pre><p id="aac6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为‘wr _ macd _ strategy’的函数，它将股票价格(‘prices’)、Williams %R读数(‘wr’)、MACD线读数(‘MACD’)和信号线读数(‘MACD _ Signal’)作为参数。</p><p id="799a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在该函数中，我们创建了三个空列表(buy_price、sell_price和wr_macd_signal ),在创建交易策略时，将在这些列表中追加值。</p><p id="9682" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之后，我们通过for循环实施交易策略。在for循环内部，我们传递某些条件，如果条件得到满足，相应的值将被追加到空列表中。如果购买股票的条件得到满足，买入价将被追加到“buy_price”列表中，信号值将被追加为1，表示购买股票。类似地，如果卖出股票的条件得到满足，卖价将被追加到“sell_price”列表中，信号值将被追加为-1，表示卖出股票。最后，我们返回附加了值的列表。然后，我们调用创建的函数并将值存储到各自的变量中。</p><h2 id="0775" class="lm kl hi bd km mi mj mk kq ml mm mn ku jx mo mp kw kb mq mr ky kf ms mt la mu bi translated">步骤6:创建我们的职位</h2><p id="8b41" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将创建一个列表，如果我们持有股票，该列表将指示1；如果我们不拥有或持有股票，该列表将指示0。</p><p id="fc8d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="7ede" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># POSITION<br/></strong><br/>position = []<br/>for i in range(len(wr_macd_signal)):<br/>    if wr_macd_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(aapl['close'])):<br/>    if wr_macd_signal[i] == 1:<br/>        position[i] = 1<br/>    elif wr_macd_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = aapl['close']<br/>wr = aapl['wr_14']<br/>macd_line = aapl['macd']<br/>signal_line = aapl['macd_signal']<br/>wr_macd_signal = pd.DataFrame(wr_macd_signal).rename(columns = {0:'wr_macd_signal'}).set_index(aapl.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'wr_macd_position'}).set_index(aapl.index)<br/><br/>frames = [close_price, wr, macd_line, signal_line, wr_macd_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy.head()</span></pre><p id="039b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/7246ada57e16c84b36dfa1a35bcdbaf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WmpuyRmTMytfpfw5excmeA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="e31d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们创建一个名为‘position’的空列表。我们传递两个for循环，一个是为“位置”列表生成值，以匹配“信号”列表的长度。另一个for循环是我们用来生成实际位置值的循环。</p><p id="324c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在第二个for循环中，我们对“signal”列表的值进行迭代，而“position”列表的值被附加到满足哪个条件上。如果我们持有股票，头寸的价值仍为1；如果我们卖出或不持有股票，头寸的价值仍为0。最后，我们正在进行一些数据操作，将所有创建的列表合并到一个数据帧中。</p><p id="184d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从显示的输出中，我们可以看到，在前三行中，我们在股票中的位置保持为1(因为交易信号没有任何变化)，但是当交易信号代表买入信号(-1)时，我们的位置突然变为0。我们的头寸将保持-1，直到交易信号发生一些变化。现在是时候实现一些回溯测试过程了！</p><h2 id="4936" class="lm kl hi bd km mi mj mk kq ml mm mn ku jx mo mp kw kb mq mr ky kf ms mt la mu bi translated">步骤7:回溯测试</h2><p id="1b4d" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在继续之前，有必要知道什么是回溯测试。回溯测试是查看我们的交易策略在给定股票数据上表现如何的过程。在我们的例子中，我们将对我们的威廉姆斯%R和MACD组合交易策略的苹果股票数据实施回溯测试过程。</p><p id="5986" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="8d71" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># BACKTESTING<br/></strong><br/>aapl_ret = pd.DataFrame(np.diff(aapl['close'])).rename(columns = {0:'returns'})<br/>wr_macd_strategy_ret = []<br/><br/>for i in range(len(aapl_ret)):<br/>    try:<br/>        returns = aapl_ret['returns'][i] * strategy['wr_macd_position'][i]<br/>        wr_macd_strategy_ret.append(returns)<br/>    except:<br/>        pass<br/>    <br/>wr_macd_strategy_ret_df = pd.DataFrame(wr_macd_strategy_ret).rename(columns = {0:'wr_macd_returns'})<br/><br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value / aapl['close'][0])<br/>wr_macd_investment_ret = []<br/><br/>for i in range(len(wr_macd_strategy_ret_df['wr_macd_returns'])):<br/>    returns = number_of_stocks * wr_macd_strategy_ret_df['wr_macd_returns'][i]<br/>    wr_macd_investment_ret.append(returns)<br/><br/>wr_macd_investment_ret_df = pd.DataFrame(wr_macd_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(wr_macd_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret / investment_value) * 100)<br/>print(cl('Profit gained from the W%R MACD strategy by investing $100k in AAPL : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the W%R MACD strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre><p id="f288" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="1a3b" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">Profit gained from the W%R MACD strategy by investing $100k in AAPL : 1207459.27</strong><br/><strong class="li hj">Profit percentage of the W%R MACD strategy : 1207%</strong></span></pre><p id="e7ea" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们使用NumPy包提供的“diff”函数计算苹果股票的回报，并将其作为数据帧存储到“aapl_ret”变量中。接下来，我们传递一个for循环来迭代' aapl_ret '变量的值，以计算我们从交易策略中获得的回报，这些回报值被追加到' wr_macd_strategy_ret '列表中。接下来，我们将“wr_macd_strategy_ret”列表转换为数据帧，并将其存储到“wr_macd_strategy_ret_df”变量中。</p><p id="a16b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是回溯测试过程。我们将通过投资10万美元到我们的交易策略中来回测我们的策略。首先，我们将投资金额存储到“投资值”变量中。之后，我们正在计算使用投资金额可以购买的苹果股票数量。你可以注意到，我使用了Math软件包提供的“floor”函数，因为当投资金额除以苹果股票的收盘价时，它会输出一个十进制数。股票数量应该是整数，而不是小数。使用“底数”函数，我们可以去掉小数。请记住,“floor”函数比“round”函数要复杂得多。然后，我们传递一个for循环来查找投资回报，后面是一些数据操作任务。</p><p id="f24d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们打印了我们在交易策略中投资10万美元的总回报，显示我们在大约10年半的时间里获得了大约120万美元的利润，利润率为1207%。太好了！现在，让我们将我们的回报与SPY ETF(一种旨在跟踪标准普尔500股票市场指数的ETF)的回报进行比较。</p><h2 id="3096" class="lm kl hi bd km mi mj mk kq ml mm mn ku jx mo mp kw kb mq mr ky kf ms mt la mu bi translated">第八步:间谍ETF对比</h2><p id="56f3" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">这一步是可选的，但强烈推荐，因为我们可以了解我们的交易策略相对于基准(间谍ETF)的表现如何。在这一步中，我们将使用我们创建的“get_historical_data”函数提取SPY ETF数据，并将我们从SPY ETF获得的回报与我们在Apple上的交易策略回报进行比较。</p><p id="c643" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可能已经注意到，在我所有的算法交易文章中，我没有将策略结果与标准普尔500市场指数本身进行比较，而是与SPY ETF进行比较，这是因为大多数股票数据提供商(如12 Data)不提供标准普尔500指数数据。所以，我别无选择，只能选择间谍ETF。如果你有幸得到标准普尔500市场指数数据，建议用它来做比较，而不是任何ETF。</p><p id="8deb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="7a2e" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># SPY ETF COMPARISON<br/></strong><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[0])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2010-01-01', 100000)<br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('W%R MACD Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre><p id="61d6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="932e" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">Benchmark profit by investing $100k : 288493.39</strong><br/><strong class="li hj">Benchmark Profit percentage : 288%</strong><br/><strong class="li hj">W%R MACD Strategy profit is 919% higher than the Benchmark Profit</strong></span></pre><p id="ac3f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>此步骤中使用的代码与前一个回溯测试步骤中使用的代码几乎相似，但我们不是投资苹果，而是通过不实施任何交易策略来投资SPY ETF。从输出可以看出，我们的交易策略跑赢了SPY ETF 919%。太棒了。</p><h1 id="4c80" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后的想法！</h1><p id="2700" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在粉碎理论和编程部分的巨大过程后，我们成功地学习了威廉姆斯%R和移动平均线收敛/发散是什么，并通过使用python结合这两个指标建立了一个交易策略，实际上赚了钱。</p><p id="15eb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在是时候谈谈需要改进的地方了。第一个方面是建立一个更加复杂的交易策略。使用两个技术指标并不意味着我们的策略足够复杂，可以战胜疯狂的市场。因此，强烈建议想出新的、创新的、非传统的策略，并在不同的时间框架和情景下对各种股票进行回溯测试。</p><p id="45d7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下一个方面是战略评估。对于那些不知道评估在交易领域意味着什么的人来说，它是从交易策略中获取实际见解的过程。在这篇文章中，我们直接得出结论，我们的战略是有利可图的，只需仔细研究已经取得的回报或利润，但有许多因素需要考虑。因此，评估我们的交易策略有助于我们用更实际和现实的事实更好地理解它。</p><p id="21bd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后一个方面显然是风险管理。它是股票市场中最常见、最敏感的术语，也是交易系统中必须执行的概念。仅仅因为我们在本文中没有实现它，并不意味着它不那么重要，在将该策略投入实际市场之前，必须确保它已经被正确部署。</p><p id="f847" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">本文没有讨论这些方面的原因是因为每个概念都是交易空间中的一个全新的章节，不可能在一篇文章的一小部分中讲述。话虽如此，你已经到了文章的结尾。如果您忘记了遵循任何编码部分，不要担心。我在文章末尾提供了完整的源代码。希望你能从这篇文章中学到一些新的有用的东西。</p><p id="6547" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">赞助:</strong> <a class="ae jn" href="https://eodhistoricaldata.com/r/?ref=DHY3H8NT" rel="noopener ugc nofollow" target="_blank"> EOD历史数据</a>是金融应用编程接口市场的领导者之一，提供各种各样的应用编程接口，从基本的每日市场数据到高度可定制的应用编程接口，如金融新闻应用编程接口和股票筛选应用编程接口。他们所有的API都是以一种本质上易于使用的方式设计的，因此初学者可以毫无障碍地使用它们。我个人使用过<a class="ae jn" href="https://eodhistoricaldata.com/r/?ref=DHY3H8NT" rel="noopener ugc nofollow" target="_blank"> EOD历史数据公司的</a>API，从我的经验来看，他们的API既适合专业人士，也适合业余爱好者，用于辅助项目和构建企业级应用。</p><h2 id="6061" class="lm kl hi bd km mi mj mk kq ml mm mn ku jx mo mp kw kb mq mr ky kf ms mt la mu bi translated">完整代码:</h2><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="6126" class="lm kl hi li b fi ln lo l lp lq"># IMPORTING PACKAGES<br/><br/>import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import requests<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)<br/><br/># EXTRACTING STOCK DATA<br/><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>aapl = get_historical_data('AAPL', '2010-01-01')<br/>aapl.tail()<br/><br/># WILLIAMS %R CALCULATION<br/><br/>def get_wr(high, low, close, lookback):<br/>    highh = high.rolling(lookback).max() <br/>    lowl = low.rolling(lookback).min()<br/>    wr = -100 * ((highh - close) / (highh - lowl))<br/>    return wr<br/><br/>aapl['wr_14'] = get_wr(aapl['high'], aapl['low'], aapl['close'], 14)<br/>aapl.tail()<br/><br/># WILLIAMS %R PLOT<br/><br/>plot_data = aapl[aapl.index &gt;= '2020-01-01']<br/><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(plot_data['close'], linewidth = 2)<br/>ax1.set_title('AAPL CLOSING PRICE')<br/>ax2.plot(plot_data['wr_14'], color = 'orange', linewidth = 2)<br/>ax2.axhline(-20, linewidth = 1.5, linestyle = '--', color = 'grey')<br/>ax2.axhline(-80, linewidth = 1.5, linestyle = '--', color = 'grey')<br/>ax2.set_title('AAPL WILLIAMS %R 14')<br/>plt.show()<br/><br/># MACD CALCULATION<br/><br/>def get_macd(price, slow, fast, smooth):<br/>    exp1 = price.ewm(span = fast, adjust = False).mean()<br/>    exp2 = price.ewm(span = slow, adjust = False).mean()<br/>    macd = pd.DataFrame(exp1 - exp2).rename(columns = {'close':'macd'})<br/>    signal = pd.DataFrame(macd.ewm(span = smooth, adjust = False).mean()).rename(columns = {'macd':'signal'})<br/>    hist = pd.DataFrame(macd['macd'] - signal['signal']).rename(columns = {0:'hist'})<br/>    return macd, signal, hist<br/><br/>aapl['macd'] = get_macd(aapl['close'], 26, 12, 9)[0]<br/>aapl['macd_signal'] = get_macd(aapl['close'], 26, 12, 9)[1]<br/>aapl['macd_hist'] = get_macd(aapl['close'], 26, 12, 9)[2]<br/>aapl = aapl.dropna()<br/>aapl.tail()<br/><br/># MACD PLOT<br/><br/>plot_data = aapl[aapl.index &gt;= '2020-01-01']<br/><br/>def plot_macd(prices, macd, signal, hist):<br/>    ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>    ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/><br/>    ax1.plot(prices)<br/>    ax1.set_title('AAPL STOCK PRICES')<br/>    ax2.plot(macd, color = 'grey', linewidth = 1.5, label = 'MACD')<br/>    ax2.plot(signal, color = 'skyblue', linewidth = 1.5, label = 'SIGNAL')<br/>    ax2.set_title('AAPL MACD 26,12,9')<br/><br/>    for i in range(len(prices)):<br/>        if str(hist[i])[0] == '-':<br/>            ax2.bar(prices.index[i], hist[i], color = '#ef5350')<br/>        else:<br/>            ax2.bar(prices.index[i], hist[i], color = '#26a69a')<br/><br/>    plt.legend(loc = 'lower right')<br/><br/>plot_macd(plot_data['close'], plot_data['macd'], plot_data['macd_signal'], plot_data['macd_hist'])<br/><br/># TRADING STRATEGY<br/><br/>def implement_wr_macd_strategy(prices, wr, macd, macd_signal):    <br/>    buy_price = []<br/>    sell_price = []<br/>    wr_macd_signal = []<br/>    signal = 0<br/><br/>    for i in range(len(wr)):<br/>        if wr[i-1] &gt; -50 and wr[i] &lt; -50 and macd[i] &gt; macd_signal[i]:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                wr_macd_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                wr_macd_signal.append(0)<br/>                <br/>        elif wr[i-1] &lt; -50 and wr[i] &gt; -50 and macd[i] &lt; macd_signal[i]:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                wr_macd_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                wr_macd_signal.append(0)<br/>        <br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            wr_macd_signal.append(0)<br/>            <br/>    return buy_price, sell_price, wr_macd_signal<br/>            <br/>buy_price, sell_price, wr_macd_signal = implement_wr_macd_strategy(aapl['close'], aapl['wr_14'], aapl['macd'], aapl['macd_signal'])<br/><br/># TRADING SIGNALS PLOT<br/><br/>plt.plot(aapl['close'])<br/>plt.plot(aapl.index, buy_price, marker = '^', markersize = 10, color = 'green')<br/>plt.plot(aapl.index, sell_price, marker = 'v', markersize = 10, color = 'r')<br/><br/># POSITION<br/><br/>position = []<br/>for i in range(len(wr_macd_signal)):<br/>    if wr_macd_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(aapl['close'])):<br/>    if wr_macd_signal[i] == 1:<br/>        position[i] = 1<br/>    elif wr_macd_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = aapl['close']<br/>wr = aapl['wr_14']<br/>macd_line = aapl['macd']<br/>signal_line = aapl['macd_signal']<br/>wr_macd_signal = pd.DataFrame(wr_macd_signal).rename(columns = {0:'wr_macd_signal'}).set_index(aapl.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'wr_macd_position'}).set_index(aapl.index)<br/><br/>frames = [close_price, wr, macd_line, signal_line, wr_macd_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy.head()<br/><br/># BACKTESTING<br/><br/>aapl_ret = pd.DataFrame(np.diff(aapl['close'])).rename(columns = {0:'returns'})<br/>wr_macd_strategy_ret = []<br/><br/>for i in range(len(aapl_ret)):<br/>    try:<br/>        returns = aapl_ret['returns'][i] * strategy['wr_macd_position'][i]<br/>        wr_macd_strategy_ret.append(returns)<br/>    except:<br/>        pass<br/>    <br/>wr_macd_strategy_ret_df = pd.DataFrame(wr_macd_strategy_ret).rename(columns = {0:'wr_macd_returns'})<br/><br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value / aapl['close'][0])<br/>wr_macd_investment_ret = []<br/><br/>for i in range(len(wr_macd_strategy_ret_df['wr_macd_returns'])):<br/>    returns = number_of_stocks * wr_macd_strategy_ret_df['wr_macd_returns'][i]<br/>    wr_macd_investment_ret.append(returns)<br/><br/>wr_macd_investment_ret_df = pd.DataFrame(wr_macd_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(wr_macd_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret / investment_value) * 100)<br/>print(cl('Profit gained from the W%R MACD strategy by investing $100k in AAPL : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the W%R MACD strategy : {}%'.format(profit_percentage), attrs = ['bold']))<br/><br/># SPY ETF COMPARISON<br/><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[0])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2010-01-01', 100000)<br/><br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('W%R MACD Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre></div></div>    
</body>
</html>