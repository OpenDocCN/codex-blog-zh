<html>
<head>
<title>React like a pro: Some fancy React concepts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像专业人士一样反应:一些奇特的反应概念</h1>
<blockquote>原文：<a href="https://medium.com/codex/some-fancy-react-concepts-caa99a07ed8e?source=collection_archive---------5-----------------------#2021-07-23">https://medium.com/codex/some-fancy-react-concepts-caa99a07ed8e?source=collection_archive---------5-----------------------#2021-07-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b728c5e9e573ec993943e19258d0720a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l6rAcIsjIXoENSd9"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@codestorm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨法尔·萨法罗夫</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7cb8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你是React新手，我建议你先浏览React 的<a class="ae iu" href="https://reactjs.org/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank">基础知识，然后随着你的进步，你可能想在你的工具箱中添加这些小工具，并在必要时拿出来。👩‍🚒</a></p><h1 id="52be" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">1.对救援做出反应:</h1><p id="65f8" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">作为一名软件开发人员，你可能已经使用过一些常见的钩子，比如<code class="du kw kx ky kz b">useState</code>、<code class="du kw kx ky kz b">useEffect</code>、<code class="du kw kx ky kz b">useRef</code>。别担心，我不会让你厌烦的😛</p><p id="5456" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来谈谈那些不经常使用，但如果有效使用，会有很大价值的方法:</p><p id="dfbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">使用命令句柄:</strong></p><p id="5e41" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果父组件需要直接控制子组件，命令子组件做什么，并希望在其他选项(如回调、上下文等)出现时调用它的方法，那么这个钩子可能是你的防火梯。是不可行的。</p><p id="70c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React文档称:</p><blockquote class="lb lc ld"><p id="070d" class="iv iw la ix b iy iz ja jb jc jd je jf le jh ji jj lf jl jm jn lg jp jq jr js hb bi translated"><code class="du kw kx ky kz b"><em class="hi">useImperativeHandle</em></code> <em class="hi">定制使用</em> <code class="du kw kx ky kz b"><em class="hi">ref</em></code> <em class="hi">时暴露给父组件的实例值。</em> <code class="du kw kx ky kz b"><em class="hi">useImperativeHandle</em></code> <em class="hi">应与</em> <code class="du kw kx ky kz b"><em class="hi">forwardRef</em></code>配合使用</p></blockquote><p id="6e7f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一般来说，当你使用<code class="du kw kx ky kz b">useRef</code>时，你会得到<code class="du kw kx ky kz b">ref</code>所附加的组件的实例值，这允许你直接与DOM元素交互。<code class="du kw kx ky kz b">useImperativeHandle</code>非常相似，但是，它也让你做两件事:</p><ol class=""><li id="4d9c" class="lh li hi ix b iy iz jc jd jg lj jk lk jo ll js lm ln lo lp bi translated"><strong class="ix hj">它允许你决定实例的哪些属性将在引用中公开。不是返回实例元素，而是显式地声明返回值是什么。</strong></li></ol><pre class="lq lr ls lt fd lu kz lv lw aw lx bi"><span id="826b" class="ly ju hi kz b fi lz ma l mb mc">const MyComponent = React.forwardRef((props, ref) =&gt; {</span><span id="9550" class="ly ju hi kz b fi md ma l mb mc">   React.useImperativeHandle(ref, () =&gt; ({<br/>     functionToExpose: () =&gt; {<br/>       console.log("Oh no, I am exposed :/ ");<br/>     }<br/>   }));<br/>  <br/>   return (<br/>     &lt;div&gt; <strong class="kz hj">Hello there! I am groot</strong>!! &lt;/div&gt;<br/>   );<br/>});<br/></span><span id="cf1b" class="ly ju hi kz b fi md ma l mb mc">const App = () =&gt; {<br/>  const ref = React.useRef(null);<br/>  const handleClick = () =&gt; {<br/>    console.log(ref.current); //this will contain only one property!<br/>    ref.current.functionToExpose();<br/>  };</span><span id="66c3" class="ly ju hi kz b fi md ma l mb mc"> return &lt;MyComponent ref={ref} onClick={handleClick} /&gt;<br/>}</span></pre><p id="6ee0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.<strong class="ix hj">它允许您用自己的函数替换本机函数(如</strong> <code class="du kw kx ky kz b"><strong class="ix hj">blur</strong></code> <strong class="ix hj">，</strong> <code class="du kw kx ky kz b"><strong class="ix hj">focus</strong></code> <strong class="ix hj">等)，</strong>因此使您能够给正常行为添加副作用，或者可能有完全不同的行为。</p><pre class="lq lr ls lt fd lu kz lv lw aw lx bi"><span id="3940" class="ly ju hi kz b fi lz ma l mb mc">const MyInput = React.forwardRef((props, ref) =&gt; {<br/>  const inputRef = React.useRef();</span><span id="de6f" class="ly ju hi kz b fi md ma l mb mc">  React.useImperativeHandle(ref, () =&gt; ({<br/>    blur: () =&gt; {<br/>      console.log("I am replacing a native function");<br/>      inputRef.current.blur();<br/>    }<br/>  }));</span><span id="8770" class="ly ju hi kz b fi md ma l mb mc">  return (<br/>    &lt;input<br/>      ref={inputRef}<br/>      {...props}<br/>    /&gt;<br/>  );<br/>});</span><span id="e47f" class="ly ju hi kz b fi md ma l mb mc">const App = () =&gt; {<br/>  const ref = React.useRef(null);<br/>  const onBlur = () =&gt; {<br/>    ref.current.blur();<br/>  };</span><span id="0b1b" class="ly ju hi kz b fi md ma l mb mc">  return &lt;MyInput ref={ref} onBlur={onBlur} /&gt;;<br/>};</span></pre></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="6c71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> useReducer : </strong></p><p id="4e97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="la">在一个中等规模的应用程序中需要处理一堆复杂的状态？useReducer应该是您的首选。</em></p><p id="1fc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">它只接受一个reducer函数和一个初始状态，并返回当前应用程序状态和一个调度函数。调度功能通过将动作映射到状态转换来改变状态</strong>:</p><p id="88e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我曾经不愿意首先使用它，认为<code class="du kw kx ky kz b">useState</code>可以很好地工作，直到我意识到它在处理复杂状态时是多么有用，在这种情况下使用Redux可能是多余的，但是<code class="du kw kx ky kz b">useState</code>可能不是那么有效，因为一旦你的应用程序变大，你很可能会处理更复杂的状态和状态转换。这也有助于提高性能<em class="la">，因为我们用一个useReducer调用替换了多个</em> <code class="du kw kx ky kz b"><em class="la">useState</em></code> <em class="la">调用(这会导致多次重新渲染)。</em></p><p id="1336" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">什么时候用？</strong></p><p id="1736" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您有以下情况，useReducer是一个不错的选择:</p><ul class=""><li id="ed65" class="lh li hi ix b iy iz jc jd jg lj jk lk jo ll js ml ln lo lp bi translated">JavaScript对象或数组作为组件的状态</li><li id="8dae" class="lh li hi ix b iy mm jc mn jg mo jk mp jo mq js ml ln lo lp bi translated">复杂的状态转换</li><li id="39d9" class="lh li hi ix b iy mm jc mn jg mo jk mp jo mq js ml ln lo lp bi translated">复杂的业务逻辑，更适合减速器功能</li><li id="6ef2" class="lh li hi ix b iy mm jc mn jg mo jk mp jo mq js ml ln lo lp bi translated">应该在一个状态对象中管理的不同属性绑定在一起</li><li id="3d23" class="lh li hi ix b iy mm jc mn jg mo jk mp jo mq js ml ln lo lp bi translated">需要更新组件树深处的状态</li><li id="09a5" class="lh li hi ix b iy mm jc mn jg mo jk mp jo mq js ml ln lo lp bi translated">需要更加可预测和可维护的状态架构</li></ul><p id="cfda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一个简单的例子，展示了<code class="du kw kx ky kz b">useReducer</code>的实现</p><pre class="lq lr ls lt fd lu kz lv lw aw lx bi"><span id="5b17" class="ly ju hi kz b fi lz ma l mb mc">function itemsReducer(state, action) {<br/>  <em class="la">switch </em>(action.type) {<br/>    <em class="la">case </em>"LOADING": {<br/>      <em class="la">return </em>{ isLoading: <em class="la">true</em>, items: <em class="la">null</em>, error: <em class="la">null </em>};<br/>    }<br/>    <em class="la">case </em>"LOADED": {<br/>      <em class="la">return </em>{ isLoading: <em class="la">false</em>, items: action.items, error: <em class="la">null </em>};<br/>    }<br/>    <em class="la">case </em>"ERROR": {<br/>      <em class="la">return </em>{ isLoading: <em class="la">false</em>, items: <em class="la">null</em>, error: action.error };<br/>    }<br/>    <em class="la">default</em>: {<br/>      <em class="la">throw new </em>Error(`Unhandled action type: ${action.type}`);<br/>    }<br/>  }<br/>}</span><span id="dbaa" class="ly ju hi kz b fi md ma l mb mc">function itemsList() {<br/>  <em class="la">const </em>[state, dispatch] = React.useReducer(itemsReducer, {<br/>    items: <em class="la">null</em>,<br/>    isLoading: <em class="la">false</em>,<br/>    error: <em class="la">null<br/>  </em>});</span><span id="d455" class="ly ju hi kz b fi md ma l mb mc"><em class="la">const </em>getItems = () =&gt; {<br/>    dispatch({ type: "LOADING" });<br/>    fetchItems().then(<br/>      items =&gt; {<br/>        dispatch({ type: "LOADED", items});<br/>      },<br/>      error =&gt; {<br/>        dispatch({ type: "ERROR", error});<br/>      }<br/>    );<br/>  }<br/>}</span></pre></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="c2dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> useLayoutEffect : </strong></p><p id="6640" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="la">如果您的组件在状态更新时闪烁，即它首先呈现在部分就绪状态，然后立即重新呈现在最终状态——这是一个很好的线索，是时候换入</em> <code class="du kw kx ky kz b"><em class="la">useLayoutEffect</em></code>了。</p><p id="4615" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然在某种程度上类似于<code class="du kw kx ky kz b">useEffect()</code>，但不同之处在于它将在React向DOM提交更新后运行。</p><pre class="lq lr ls lt fd lu kz lv lw aw lx bi"><span id="0011" class="ly ju hi kz b fi lz ma l mb mc">useEffect(() =&gt; {<br/>   // do side effects<br/>   return () =&gt; {} /* cleanup */ <br/>}, [dependency, array]);</span><span id="85b9" class="ly ju hi kz b fi md ma l mb mc">useLayoutEffect(() =&gt; { <br/>  // do side effects<br/>  return () =&gt; {} /* cleanup */ <br/>},[dependency, array]);</span></pre><p id="38d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据React文档:</p><blockquote class="lb lc ld"><p id="d5dc" class="iv iw la ix b iy iz ja jb jc jd je jf le jh ji jj lf jl jm jn lg jp jq jr js hb bi translated">签名与<code class="du kw kx ky kz b"><em class="hi">useEffect</em></code>相同，但它在所有DOM突变后同步触发。使用它从DOM中读取布局并同步重新渲染。在浏览器有机会绘制之前，<code class="du kw kx ky kz b"><em class="hi">useLayoutEffect</em></code>中安排的更新将被同步刷新。</p></blockquote><p id="e031" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">什么时候用</strong> <strong class="ix hj"> it: </strong></p><p id="40ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，如果<code class="du kw kx ky kz b">useLayoutEffect</code>会延迟组件的喷漆，我们为什么要使用它。当正在运行的代码以用户可观察到的方式直接修改DOM时，应该使用<code class="du kw kx ky kz b">useLayoutEffect</code>。</p><p id="3a8b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果我们需要改变DOM元素的背景颜色作为副作用，最好使用<code class="du kw kx ky kz b">useLayoutEffect</code>,因为我们直接修改DOM，用户可以观察到这些变化。如果我们使用<code class="du kw kx ky kz b">useEffect</code>,我们可能会遇到一个问题，即在运行<code class="du kw kx ky kz b">useEffect</code>代码之前绘制DOM。这将导致DOM元素起初是错误的颜色，然后由于<code class="du kw kx ky kz b">useEffect</code>代码而变成正确的颜色。</p><p id="6ddf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，是的，大多数时候你可能甚至不需要它，可以简单地带着<code class="du kw kx ky kz b">useEffect</code>离开，直到或者除非你面临它的问题😉</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="122e" class="jt ju hi bd jv jw mr jy jz ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq bi translated"><strong class="ak"> 2。万能的HOCs及其用途</strong></h1><p id="4f7f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">首先要做的事！什么是HOC？？🙄<br/> <strong class="ix hj"> HOC(高阶分量)是取(包装)一个分量并返回一个新分量的函数。</strong><strong class="ix hj">HOC的思想是用函数或数据来增强组件。<em class="la"> </em> </strong>它们的主要目的是在组件之间共享通用功能，而无需重复代码。抓住你了。</p><p id="1e37" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据你的需要，你可以使用这两个中的任何一个:<br/>a . Props Proxy HOC<br/>b . Inheritance Inversion HOC</p><p id="aa3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> Props Proxy (ppHOC) </strong>当我们需要操作Props，抽象状态，或者我们需要用额外的元素包装组件时，这是很有用的。</p><pre class="lq lr ls lt fd lu kz lv lw aw lx bi"><span id="5013" class="ly ju hi kz b fi lz ma l mb mc">function ppHOC(WrappedComponent) {<br/>  return class myHOC extends Component {<br/>    render() {<br/>      const newProps = {<br/>        title: 'My new title goes here',<br/>        showFeatureX: false,<br/>        showFeatureY: true<br/>      };<br/><br/>      return &lt;WrappedComponent {...this.props} {...newProps} /&gt;<br/>    }<br/>  }<br/>}</span></pre><p id="bada" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">继承反转(iiHOC) </strong>另一方面，当我们需要劫持渲染的组件，或者需要操纵状态时使用。</p><p id="9ffe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">渲染劫持是指我们可以读取、修改<em class="la">渲染</em>  <em class="la">、</em>输出的React元素树<strong class="ix hj">，或者有条件地显示元素树，或者读取、添加、编辑、删除<em class="la">渲染</em> </strong>输出的React元素<strong class="ix hj">中的任何道具</strong></p><p id="baca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">|请注意，这里的render指的是WrappedComponent.render</p><p id="e72c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继承反转允许HOC通过<em class="la"> this </em>访问<em class="la"> WrappedComponent </em>实例，这意味着<strong class="ix hj">它可以访问状态、道具、组件生命周期挂钩和渲染方法</strong></p><p id="6914" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在非常基本的层面上，<code class="du kw kx ky kz b">iiHOC</code>可以如下实现:</p><pre class="lq lr ls lt fd lu kz lv lw aw lx bi"><span id="be50" class="ly ju hi kz b fi lz ma l mb mc">function iiHOC(WrappedComponent) {  <br/>  return class myiiHOC extends WrappedComponent {<br/>    render() {<br/>     return super.render()<br/>    }<br/>  }<br/>}</span></pre></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="984e" class="jt ju hi bd jv jw mr jy jz ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq bi translated"><strong class="ak"> 3。全新的startTransition API </strong></h1><p id="5e8e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">让我们欢迎React 18版本中引入的这个新API。<code class="du kw kx ky kz b">startTransition</code> <strong class="ix hj">有助于保持当前网页的响应性，同时允许进行大量的非阻塞UI更新。</strong></p><p id="95ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">包装在<code class="du kw kx ky kz b">startTransition</code>中的更新被视为非紧急更新，如果出现更紧急的更新，如点击或按键，更新将被中断。假设过渡被用户打断(例如，在一行中输入多个字符)，那么React将明智地丢弃没有完成的陈旧渲染工作，只渲染最新的更新。整洁！！</p><p id="8bba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">延迟更新(即从一个UI视图到另一个的转换)被称为转换更新。过渡有助于保持大多数交互的整洁，即使它们会导致显著的UI变化。另一个优点是:由于您不再呈现陈旧的内容，这也节省了时间。</strong></p><p id="c18a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kw kx ky kz b">startTransition</code>的一个很好的例子是当用户开始在搜索框中输入时。虽然输入值必须立即更新，但是搜索结果仍然可以等待几毫秒。</p><pre class="lq lr ls lt fd lu kz lv lw aw lx bi"><span id="c562" class="ly ju hi kz b fi lz ma l mb mc">// Urgent: Show what was typed<br/>setInputValue(input);<br/><br/>// Wrap your non-urgent updates inside startTransition<br/>React.startTransition(() =&gt; {<br/>  // Transition: Show the results<br/>  setSearchQuery(input);<br/>});</span></pre></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="0aa2" class="jt ju hi bd jv jw mr jy jz ka ms kc kd ke mt kg kh ki mu kk kl km mv ko kp kq bi translated">4.严格模式:不会让你犯愚蠢的错误</h1><p id="ab2b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">严格模式就像你的严厉的学校老师，他会因为你愚蠢的错误而不停地戳你😆</p><p id="b78b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个突出应用程序中潜在问题的工具，一种确保你的代码遵循最佳实践的新方法。它是<code class="du kw kx ky kz b">React.StrictMode</code>下的一个组件，可以添加到你的应用程序树或子树中。</p><p id="eef7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就像<code class="du kw kx ky kz b">Fragment</code>，<code class="du kw kx ky kz b">StrictMode</code>不呈现任何UI，只在运行时激活检查和添加警告。</p><p id="2973" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它有助于:</p><ul class=""><li id="93af" class="lh li hi ix b iy iz jc jd jg lj jk lk jo ll js ml ln lo lp bi translated">检测具有不安全生命周期的意外副作用和组件</li><li id="3a19" class="lh li hi ix b iy mm jc mn jg mo jk mp jo mq js ml ln lo lp bi translated">验证内部组件是否遵循<em class="la">一些</em>建议的做法，如果不遵循，则在控制台中向您发出警告。</li><li id="ee9b" class="lh li hi ix b iy mm jc mn jg mo jk mp jo mq js ml ln lo lp bi translated">验证没有使用任何不推荐使用的方法</li></ul><p id="3227" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">React docs说:</p><blockquote class="lb lc ld"><p id="7511" class="iv iw la ix b iy iz ja jb jc jd je jf le jh ji jj lf jl jm jn lg jp jq jr js hb bi translated">严格模式是面向开发的，所以您不需要担心它会影响您的产品构建</p></blockquote><pre class="lq lr ls lt fd lu kz lv lw aw lx bi"><span id="cea4" class="ly ju hi kz b fi lz ma l mb mc">function myComponent() {<br/>  return (<br/>      &lt;React.StrictMode&gt;<br/>        &lt;div&gt;     <br/>          &lt;ComponentOne /&gt;<br/>          &lt;ComponentTwo /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/React.StrictMode&gt;      <br/>  );<br/>}</span></pre></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="e647" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谢谢你的来访！</p><p id="5692" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的名字叫Supreet，我只是一个碰巧喜欢编码的技术爱好者😺</p><p id="0b17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://www.linkedin.com/in/supreet-kaur-sandhu/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/supreet-kaur-sandhu/</a></p></div></div>    
</body>
</html>