<html>
<head>
<title>Understanding the Observer Pattern — Event Systems in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解观察者模式Unity中的事件系统</h1>
<blockquote>原文：<a href="https://medium.com/codex/understanding-the-observer-pattern-event-systems-in-unity-a92cdec26d7f?source=collection_archive---------1-----------------------#2022-04-23">https://medium.com/codex/understanding-the-observer-pattern-event-systems-in-unity-a92cdec26d7f?source=collection_archive---------1-----------------------#2022-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c345" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我就是喜欢用事件系统！</h2></div><p id="bc72" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">自从我进入游戏开发以来，有大量的主题需要学习，无论是2D艺术、动画、3D建模、C#编程，还是熟悉Unity引擎等等——这简直让人应接不暇。但尽管看起来势不可挡，学习部分绝对是我最喜欢的部分，因为我来自编程背景，我一头扎进挑选必要的主题，为我在小丑村建立我的游戏之夜。今天，我想分享一个在Unity中常用的编程设计模式，因为它的简单性，我似乎总是会回去使用它。进入观察者模式。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/773c54b1b8953d59a759ca23b5f6d67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FWLCDMnXL8GoWvQXdZi_zg.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">谢尔盖·塞明在<a class="ae kj" href="https://unsplash.com/s/photos/observer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="kk kl km"><p id="5870" class="ix iy kn iz b ja jb ij jc jd je im jf ko jh ji jj kp jl jm jn kq jp jq jr js hb bi translated">基本上，观察者模式是一种设计模式，允许您为主题配置订阅机制，以通知多个对象它们正在观察的对象发生的任何事件。</p></blockquote><h1 id="9251" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">它是如何工作的</h1><p id="10d0" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">为了解释观察者模式，请考虑这个场景:假设您正在等待当地商店重新进货一些ps5(我假设您仍然在等待您的ps5)，并且您每天都要开车去商店查看产品。虽然你可能是任何一天中第一个拿到PS5的人，但是如果你不知道商店当天是否有这款产品，那么大多数旅行都是没有意义的。商店也可以给你发大量的电子邮件，通知你他们店内的其他索尼产品，但它们本质上不是你想要的产品。现在，这对商店和作为顾客的你都不利。</p><p id="348a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">商店现在可以做的就是提供订阅服务，顾客可以订阅特定产品的供货通知，或者通常称为<strong class="iz hj"> <em class="kn">事件</em> </strong>。在这里，商店将充当<strong class="iz hj"> <em class="kn">发布者</em> </strong>，而顾客将充当<strong class="iz hj"> <em class="kn">订阅者</em> </strong> <em class="kn">。</em>显然，对PS5s不感兴趣的客户不会订阅此活动。因此，顾客不需要浪费宝贵的资源去商店，商店可以通过简化他们的生活来留住顾客。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lo"><img src="../Images/fb724a366829ee18a1be4041c4326ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*fB1Oe6Re_aTTlx1VnWGotA.png"/></div></figure><p id="bfbb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，如果你生活在互联网上，你应该已经知道这整件事了。有史以来最大的视频平台YouTube会让你订阅创作者，当他们发布新视频时，你会收到通知。现在我们知道了这个东西是如何工作的，让我们看看如何在Unity中使用代码来实现它。</p><h1 id="c3e6" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">问题</h1><p id="aa77" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">是的，如果你想知道，你绝对猜对了——可能有多个发布者和无数的订阅者，如果订阅者-发布者网络维护不当，这将导致一场灾难。然后，您可能还拥有继续广播事件状态的发布者，但是没有订阅者收听它们。更糟糕的是，每个发布者也可能有不同类型的消息或信息要传达给他们的订户，因此以这种方式处理通信会很复杂。既然你理解了这个问题，让我们来看看解决方案是什么。</p><h1 id="89c5" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">解决办法</h1><p id="92d6" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">我们想在Unity中编码的是一个游戏事件组件，它处理来自发行商的信息或消息的传递。还记得我们提到的每个发布者想要广播不同类型信息的问题吗？一种处理方法是创建一个特定的节点或消息类型，让订阅者知道这个节点广播这种特定类型的消息，如果他们愿意，可以订阅它。简而言之，想象一下YouTube有这样的订阅结构，你可以单独订阅创作者的视频、帖子或文章。理想情况下，你不会这样做，但只是想象一下，因为这在制作游戏中是有用的。</p><p id="7748" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了创建这个系统，我们需要2个组件:一个游戏事件和一个游戏事件监听器。游戏事件组件可以被任何游戏对象调用，并负责引发游戏事件。另一方面，游戏事件监听器可以连接到任何游戏对象，并负责监听由它订阅的游戏对象广播的任何游戏事件。为了使事情模块化，我们为游戏事件组件创建了一个抽象类，它可以接受一种通用类型的消息，如下所示:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lp"><img src="../Images/6fb1a92c65f5e1e0c4c75d6cc4560ba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NotkZRn1UfLEhuAxRR4Zxg.png"/></div></div></figure><p id="f85a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如上所示，<em class="kn"> Raise() </em>方法将事件广播给订阅者。对事件的任何响应都将由游戏事件监听器组件——单一责任原则(SRP)来处理。当订户决定收听游戏事件时，<em class="kn"> RegisterListener() </em>和<em class="kn"> UnregisterListener() </em>方法都会这样做。</p><p id="3f0c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于游戏事件监听器，我们也想用一个抽象类使它模块化。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lq"><img src="../Images/0af21416339f02085ade10ee077e9d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vIOHBFaRwlNS8eZgzbWocA.png"/></div></div></figure><p id="36aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当带有这个游戏事件监听器组件的任何游戏对象注意到事件被引发时，它可以使用方法<em class="kn">oneventreased()调用一组特定的操作。Unity为游戏开发者简化了这一点，因为我们只需要在Unity编辑器中传递一个函数作为事件发生时的响应。</em></p><p id="4f41" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经创建了一个基础模板，我们可以继续制作我们自己的特定类型的游戏事件消息！常见的游戏事件消息类型有<em class="kn">整数</em>、<em class="kn">浮点</em>甚至Unity的<em class="kn">碰撞器</em>类型。</p><h1 id="b20f" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">例子</h1><p id="54fa" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">让我们看一个简单的例子，看看我是如何在我的游戏中使用这个事件系统的。假设我编写了一个<em class="kn"> PlayerCoinSystem </em>来处理与游戏中硬币的交互。正如你在下面看到的，这个组件有3个事件，并且可以引发这3个事件中的任何一个<em class="kn">。</em>当收集到一枚硬币时，将引发一个特定的事件，您将获得其他事件的灵感！</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lr"><img src="../Images/eb0c9276c42e30555257be43938a5bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*4yj9F-aeoQ43piALAmc9Aw.png"/></div></figure><p id="8bc6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一方面，我将这个<em class="kn">整数</em>类型的事件监听器附加到UI组件上。它监听<em class="kn"> OnCoinChange </em>的事件并相应地更新UI！</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ls"><img src="../Images/5bb5b9ff9b70c3289d35d59323fafb47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*tlylKH8yM8KRWk8T6j4gYg.png"/></div></figure><p id="1eff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我相信我不需要运行我的游戏来让你理解事件系统！亲自试试看，我相信你会爱上这种图案的！</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="33a7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经分享了我们如何使用C#在Unity中编写我们自己的游戏事件和游戏事件监听器组件，以及如何在游戏中的任何地方使用它们。虽然《小丑之夜》的代码库目前是私有的，但我很想与任何有兴趣帮助我们改进当前代码库的人分享。有兴趣的给我发邮件！在那之前，编码快乐！</p><h1 id="261a" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">参考</h1><div class="ma mb ez fb mc md"><a href="https://refactoring.guru/design-patterns/observer" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">观察者</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">也称为:事件订阅者、侦听器观察者是一种行为设计模式，它允许您定义订阅…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">重构大师</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr kd md"/></div></div></a></div><div class="ma mb ez fb mc md"><a href="https://www.tutorialspoint.com/design_pattern/observer_pattern.htm" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">设计模式——观察者模式</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">观察者模式用于对象之间存在一对多关系的情况，比如一个对象被修改，它的…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">www.tutorialspoint.com</p></div></div><div class="mm l"><div class="ms l mo mp mq mm mr kd md"/></div></div></a></div><div class="ma mb ez fb mc md"><a href="https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/EventSystem.html" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">事件系统</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">事件系统是一种基于输入向应用程序中的对象发送事件的方式，输入可以是键盘、鼠标、触摸…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">docs.unity3d.com</p></div></div></div></a></div></div></div>    
</body>
</html>