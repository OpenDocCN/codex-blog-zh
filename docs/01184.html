<html>
<head>
<title>What is this Hash Map Thing I Keep Hearing About?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我一直听到的散列图是什么？</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-is-this-hash-map-thing-i-keep-hearing-about-794f4e27b980?source=collection_archive---------13-----------------------#2021-04-09">https://medium.com/codex/what-is-this-hash-map-thing-i-keep-hearing-about-794f4e27b980?source=collection_archive---------13-----------------------#2021-04-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="849e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">哈希映射、哈希函数、碰撞和其他你可能听说过但还没有深入研究过的东西的介绍。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/ab4255aaa0acdfb6bf996ad283955760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*7NjvKMiGay88zKGg4ZZ2Sw.png"/></div></figure><h1 id="7719" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">哈希映射简介</h1><p id="9d6c" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">哈希映射(有时称为哈希表)是一种数据结构，通常用于以使用更多内存为代价提供更快的数据检索方式。</p><p id="c183" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">假设我有大量数据，我想从中找出一个值。如果我知道那段数据的确切索引，那么我可以直接查找它，但是如果我只知道我要查找的值，我可能必须查看数组的每个索引，直到我找到该值。</p><p id="0aa6" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">当我们只有一个值时，通过使用我们称之为散列函数，散列映射提供了索引样式的查找。hash函数将您正在搜索的值转换成一个数值，然后使用该值在我们的Hash图中进行直接查找。</p><p id="bbe4" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">听起来很混乱，所以让我们来分析一下。</p><h1 id="50cd" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">哈希函数</h1><p id="e5d1" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们的散列函数将负责把我们正在寻找的值转换成散列值。例如，假设我们有一个很大的单词字典，我们正在查看某个单词是否在其中。如果是，我们将返回它的定义。</p><p id="9415" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">这听起来就像Ruby中的Hash或JavaScript中的Object，我们将单词存储为键，将其定义存储为值，形成对。</p><p id="9018" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">但是，假设我们正在使用一种语言，在这种语言中，我们必须提前预定义对象的大小，或者我们可能想要比内置的对象/散列查找更快的查找时间。我们可以构建自己的哈希映射，并使用哈希函数将每个单词正确地放入映射中。</p><p id="db2f" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">我们的哈希函数逻辑可能看起来像这样:</p><ol class=""><li id="3834" class="ky kz hi jz b ka kt kd ku kg la kk lb ko lc ks ld le lf lg bi translated">用值0声明hashCode变量</li><li id="77db" class="ky kz hi jz b ka lh kd li kg lj kk lk ko ll ks ld le lf lg bi translated">对于键中的每个字符，将当前字符代码值和hashCode之和加到hashCode上</li><li id="1576" class="ky kz hi jz b ka lh kd li kg lj kk lk ko ll ks ld le lf lg bi translated">返回哈希码</li></ol><p id="a006" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">让我们把它编码出来:</p><pre class="iy iz ja jb fd lm ln lo lp aw lq bi"><span id="2e2d" class="lr jg hi ln b fi ls lt l lu lv">hash(key) {</span><span id="3664" class="lr jg hi ln b fi lw lt l lu lv">    let hashCode = 0;</span><span id="d0cf" class="lr jg hi ln b fi lw lt l lu lv">     for (let i = 0; i &lt; key.length; i++) {</span><span id="dc59" class="lr jg hi ln b fi lw lt l lu lv">        hashCode += hashCode + key.charCodeAt(i);</span><span id="156a" class="lr jg hi ln b fi lw lt l lu lv">     }</span><span id="262a" class="lr jg hi ln b fi lw lt l lu lv">     return hashCode % this.hashmap.length;</span><span id="6f8e" class="lr jg hi ln b fi lw lt l lu lv">}</span></pre><p id="3997" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">现在，如果我们有一个字符串“word”的关键字，我们的哈希函数将遍历该字符串，将每个字母的字符值添加到hashCode变量中，得到以下内容。</p><p id="b955" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">w = 119o = 111r = 114d=100</p><p id="bc4b" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">hashCode = 0 + 119 + 111 + 114 + 100 = 444</p><p id="fc70" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">然后，它将返回该代码除以hashmap长度的余数，以确保它匹配hashmap中从0到length的一个索引。例如，如果上面例子中的hashMap有8个槽，我们的散列函数将返回4，我们将把“word”的定义放在Hash Map的第4个索引中。</p><p id="6efb" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">现在，当我们稍后查找定义时，我们的哈希函数将再次在字符串“word”上运行，并将返回查找值4，因此我们的主HashMap函数将知道在索引4中查找定义。</p><p id="c6b0" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">我们的散列函数在存储和查找过程中都运行。</p><h1 id="90f3" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">碰撞</h1><p id="f7a2" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">现在，我敢肯定，我们的许多精明的读者刚刚说了类似“如果两个不同的单词返回相同的哈希代码会怎么样？我们的HashMap将如何知道返回哪个定义？”</p><p id="1692" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">这肯定是个问题，我们称之为碰撞。事实上，我们放入哈希表的键越多，有限的哈希表就越有可能发生冲突。有两种主要的方法来处理这个问题。</p><h2 id="0bad" class="lr jg hi bd jh lx ly lz jl ma mb mc jp kg md me jr kk mf mg jt ko mh mi jv mj bi translated">单独链接</h2><p id="a8e5" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">第一种方法不是让我们的Hash Map的键引用一个值，我们可以让键引用一个链表，这个链表本身包含许多其他的值。这被称为分离链接(链表就像一个定义的长链，然后可以搜索到合适的定义)。</p><p id="8e0d" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">如果你不熟悉链表<a class="ae mk" rel="noopener" href="/swlh/real-life-example-of-a-linked-list-8f787b660b3f">，我在这里写了一篇关于它们的博客</a>。</p><p id="94a0" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">基本上，您要做的是将哈希表中的每个键指向一个单独的链表，然后使用您创建的链表类的查找功能来查找您需要的特定节点。这里有一个关于<a class="ae mk" href="https://www.geeksforgeeks.org/hashing-set-2-separate-chaining/" rel="noopener ugc nofollow" target="_blank">的指南，一种用JavaScript </a>实现的方法。</p><h2 id="eb41" class="lr jg hi bd jh lx ly lz jl ma mb mc jp kg md me jr kk mf mg jt ko mh mi jv mj bi translated">散列地址</h2><p id="6780" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">处理冲突的另一种方法叫做开放式寻址。在这种方法中，如果我们到达一个已经被占用的索引，我们使用某种设置的步长间隔在另一个索引中寻找空位。例如，让我们回到“word”的例子，其中散列码是4。如果我们将“word”添加到我们的哈希表中，而索引4已经满了，那么我们将跳过预定数量的空间来寻找另一个。</p><p id="51c6" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">现在你的直觉可能会说，好吧，让我们看看下一个相邻的空间，但这并不总是最佳策略，因为它可能会导致集群。假设数字4-6是我们的哈希代码非常流行的返回。现在每次我们添加一个值为4的键时，都会遇到这样的问题。</p><p id="661c" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">“4号已经满了，好吧，我们去5号看看。5号也满了，好吧，我们去6号看看。6也满了…7…8…9…”</p><p id="aa97" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">现在突然一个散列码为4的键被存储在10中，现在一个索引为10的键也不在原来的位置了，因为其他键都在原来的位置，现在我们整个事情都乱套了。通过使步长增量为一个更大的数字，或者更好，使其基于键值(例如，步长= 3*key.length + 7)可变，我们实际上分散了位置，并减少了我们必须运行到一个完整空间然后移动我们的键的次数。<a class="ae mk" href="https://www.geeksforgeeks.org/hashing-set-3-open-addressing/" rel="noopener ugc nofollow" target="_blank">这里有一篇文章更详细地介绍了</a>开放式寻址方法中每种方法的优缺点。</p><h1 id="92c5" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">用JavaScript构建散列图</h1><pre class="iy iz ja jb fd lm ln lo lp aw lq bi"><span id="e1b9" class="lr jg hi ln b fi ls lt l lu lv">class HashMap {</span><span id="36ea" class="lr jg hi ln b fi lw lt l lu lv">     constructor(size = 0) {</span><span id="09e5" class="lr jg hi ln b fi lw lt l lu lv">       this.hashmap = new Array(size)</span><span id="1350" class="lr jg hi ln b fi lw lt l lu lv">         .fill(null);</span><span id="1996" class="lr jg hi ln b fi lw lt l lu lv">     }</span><span id="02c1" class="lr jg hi ln b fi lw lt l lu lv">     hash(key) {</span><span id="8b3a" class="lr jg hi ln b fi lw lt l lu lv">       let hashCode = 0;</span><span id="d3ab" class="lr jg hi ln b fi lw lt l lu lv">       for (let i = 0; i &lt; key.length; i++) {</span><span id="2cf7" class="lr jg hi ln b fi lw lt l lu lv">         hashCode += hashCode + key.charCodeAt(i);</span><span id="bad5" class="lr jg hi ln b fi lw lt l lu lv">       }</span><span id="2288" class="lr jg hi ln b fi lw lt l lu lv">       return hashCode % this.hashmap.length;</span><span id="8828" class="lr jg hi ln b fi lw lt l lu lv">     }</span><span id="51d8" class="lr jg hi ln b fi lw lt l lu lv">     assign(key, value){</span><span id="2206" class="lr jg hi ln b fi lw lt l lu lv">        const arrayIndex = this.hash(key)</span><span id="2192" class="lr jg hi ln b fi lw lt l lu lv">        this.hashmap[arrayIndex] = value</span><span id="f29e" class="lr jg hi ln b fi lw lt l lu lv">     }</span><span id="3200" class="lr jg hi ln b fi lw lt l lu lv">   }</span></pre><p id="ec64" class="pw-post-body-paragraph jx jy hi jz b ka kt ij kc kd ku im kf kg kv ki kj kk kw km kn ko kx kq kr ks hb bi translated">这里有一个标准的散列表，它没有解决上面的冲突问题。您可以随意使用这段代码，添加单独的链接和开放式寻址助手函数来处理冲突。使用上面的资源来实现它们，看看你更喜欢哪一个，以及在实现每一个时你会遇到什么样的挑战！</p></div></div>    
</body>
</html>