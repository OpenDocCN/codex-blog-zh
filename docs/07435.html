<html>
<head>
<title>LeetCode 1. Two Sum Python Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 1。两总和Python解决方案</h1>
<blockquote>原文：<a href="https://medium.com/codex/leetcode-1-two-sum-python-solution-programming-technical-interview-question-8f19ea881194?source=collection_archive---------24-----------------------#2022-06-14">https://medium.com/codex/leetcode-1-two-sum-python-solution-programming-technical-interview-question-8f19ea881194?source=collection_archive---------24-----------------------#2022-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f131" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">盲75 —编程和技术面试问题—解释系列</h2></div><h2 id="9b6c" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">问题是:</h2><p id="4a62" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">给定一个整数数组<strong class="jx hj"> <em class="ko"> nums </em> </strong>和一个整数<strong class="jx hj"> <em class="ko"> target </em> </strong>，返回这两个数字的索引【在<strong class="jx hj"> <em class="ko"> nums </em> </strong>数组中】，使它们加起来等于target。</p><h2 id="c73a" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">制约因素:</h2><ol class=""><li id="3745" class="kp kq hi jx b jy jz kb kc ji kr jm ks jq kt kn ku kv kw kx bi translated">你可以<strong class="jx hj">而不是</strong>使用同一个<em class="ko">元素两次。</em></li><li id="65cb" class="kp kq hi jx b jy ky kb kz ji la jm lb jq lc kn ku kv kw kx bi translated">只存在一个有效答案。</li><li id="521a" class="kp kq hi jx b jy ky kb kz ji la jm lb jq lc kn ku kv kw kx bi translated">2 &lt;= nums.length &lt;= 104</li><li id="3de4" class="kp kq hi jx b jy ky kb kz ji la jm lb jq lc kn ku kv kw kx bi translated">-109 &lt;= nums[i] &lt;= 109</li><li id="c73c" class="kp kq hi jx b jy ky kb kz ji la jm lb jq lc kn ku kv kw kx bi translated">-109 &lt;= target &lt;= 109</li></ol><h2 id="0b84" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">The explanation:</h2><p id="ccf5" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">This problem in ones head is actually pretty simple; you pass through the array and for each number in that array you check if there is another number in that array that, in combination with your first number, add up to the target.</p><h2 id="68f5" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">Solution #1 — Nested For-Loops — O(n²)</h2><p id="0139" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">Using the explanation in your head makes coming up with the brute force solution pretty easy. You pass through the array using a for-loop, then <em class="ko">嵌套</em>在那个for循环中你再次遍历数组，检查第一个for循环中的<strong class="jx hj"> <em class="ko"> nums </em> </strong>的值和第二个for循环中的<strong class="jx hj"> <em class="ko"> nums </em> </strong>的值加起来是否等于目标值，如果是，返回这两个索引。</p><p id="a91f" class="pw-post-body-paragraph jv jw hi jx b jy ld ij ka kb le im kd ji lf kf kg jm lg ki kj jq lh kl km kn hb bi translated">这里我建立了<strong class="jx hj"> <em class="ko"> len_nums </em> </strong>变量，因为<strong class="jx hj"> <em class="ko"> nums </em> </strong>数组的长度被多次使用。第一个for循环从0遍历到数组末尾减1。这是因为您不能使用相同的索引两次，如约束中所述，并且第二个for-loop一直循环到最后一个值。第二个for循环从<strong class="jx hj"> <em class="ko"> i + 1 </em> </strong>开始遍历，因为不需要检查从0到<strong class="jx hj"> <em class="ko"> len_n </em> </strong>的值，那样会多次检查值，影响我们的效率。然后我们检查<strong class="jx hj"> <em class="ko"> nums </em> </strong>的两个值加起来是否等于<strong class="jx hj"> <em class="ko"> target </em> </strong>以及它们是否返回那些索引。不需要在for循环后放一个return语句，因为正如约束中所述,<strong class="jx hj">总是</strong>有解。</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="e48d" class="ix iy hi ln b fi lr ls l lt lu">class Solution:<br/>  def twoSum(self, nums: List[int], target: int) -&gt; List[int]:<br/>    len_nums = len(nums)<br/>   <br/>    for i in range(0, len_n — 1):<br/>      for j in range(i + 1, len_n):<br/>        if nums[i] + nums[j] == target:<br/>          return [i, j]</span></pre><h2 id="0831" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">解决方案#2 —哈希表— O(n)</h2><p id="d867" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">这无疑是更困难的解决方案，并且需要哈希表的知识。虽然，如果你能想出这个解决方案的时间效率要比以前的解决方案好得多。类似前面的解决方案，我们保存了<strong class="jx hj"> <em class="ko"> nums </em> </strong>数组的长度。我们引入一个新的变量作为我们的哈希表:<strong class="jx hj"> <em class="ko">哈希表。</em> </strong>这被初始化为<strong class="jx hj"> <em class="ko"> dict() </em> </strong>，在Python中，它保存键和值。第一个for循环遍历<strong class="jx hj"> <em class="ko"> nums </em> </strong>数组，将其值用作键，并将索引<strong class="jx hj"> <em class="ko"> i </em> </strong>存储为该键的值。这在查看第二个for循环时更有意义，在这里我们可以检查<strong class="jx hj"> <em class="ko">哈希表</em> </strong>是否包含某个值。我们将检查的这个特定值是<strong class="jx hj"> <em class="ko">目标</em> </strong>的补充值和<strong class="jx hj"><em class="ko">nums【I】</em></strong>的当前值，它存储在<strong class="jx hj"> <em class="ko">补充值</em> </strong>变量中，因为它的值将被多次使用。接下来是这个解决方案的最后一部分，检查compliment是否是<strong class="jx hj"> <em class="ko">哈希表</em> </strong>中的一个值，但是<strong class="jx hj">不是<strong class="jx hj"> <em class="ko"> nums[i] </em> </strong>的当前值</strong>，因为在约束中我们不能两次返回相同的索引。因为我们保证有一个解，所以在for循环之后不需要return语句，你已经解决了LeetCode 1。两个总和！</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="1328" class="ix iy hi ln b fi lr ls l lt lu">class Solution:<br/>  def twoSum(self, nums: List[int], target: int) -&gt; List[int]:<br/>    hashtable = dict()<br/>    len_n = len(nums)<br/> <br/>    for i in range(len_n):<br/>      hashtable[nums[i]] = i<br/> <br/>    for i in range(len_n):<br/>      compliment = target — nums[i]<br/> <br/>      if compliment in hashtable and i != hashtable[compliment]:<br/>        return [i, hashtable[compliment]]</span></pre><figure class="li lj lk ll fd lw er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es lv"><img src="../Images/3785e0f8ee88a9f855b41e4fcc98794f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TFQO9Ys2gy5JxVbm.png"/></div></div></figure><h2 id="564c" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">信息:</h2><p id="1754" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">网址:<a class="ae md" href="http://www.nkwade.dev" rel="noopener ugc nofollow" target="_blank">nkwade . dev</a><br/>LinkedIn:<a class="ae md" href="http://www.linkedin.com/in/nkwade/" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/nkwade</a><br/>GitHub:<a class="ae md" href="http://www.github.com/nkwade" rel="noopener ugc nofollow" target="_blank">github.com/nkwade</a><br/>邮箱:<a class="ae md" href="mailto:nicholas@nkwade.dev" rel="noopener ugc nofollow" target="_blank"> nicholas@nkwade.dev </a></p></div></div>    
</body>
</html>