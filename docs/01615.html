<html>
<head>
<title>Migrating a Legacy App to Cloud Native — Part 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将传统应用迁移到云原生环境—第5部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/migrating-a-legacy-app-to-cloud-native-part-5-34696c6f0f43?source=collection_archive---------17-----------------------#2021-05-16">https://medium.com/codex/migrating-a-legacy-app-to-cloud-native-part-5-34696c6f0f43?source=collection_archive---------17-----------------------#2021-05-16</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><figure class="ew ey ih ii ij ik es et paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="es et ig"><img src="../Images/76d66e1c247603ac8b4c7e07c58e5ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7kQY1Cw1mdmpcXvI2EGwg.jpeg"/></div></div><figcaption class="ir is eu es et it iu bd b be z dy translated">酝酿中的风暴——亚当·法内罗摄影</figcaption></figure><p id="2918" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">这是系列文章的第5部分。如果你之前没有关注过，以下是之前的帖子:</p><ul class=""><li id="0c8a" class="jt ju hj ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><a class="ae kc" rel="noopener" href="/@kernwig/migrating-a-legacy-app-to-cloud-native-part-1-68a1adbb95d5">第一部分:背景</a></li><li id="4de5" class="jt ju hj ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated"><a class="ae kc" rel="noopener" href="/@kernwig/migrating-a-legacy-app-to-cloud-native-part-2-533dfebd38fb">第二部分:需求&amp;架构</a></li><li id="48cd" class="jt ju hj ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated"><a class="ae kc" rel="noopener" href="/@kernwig/migrating-a-legacy-app-to-cloud-native-part-3-4bb187fea485">第三部分:认证</a></li><li id="80fa" class="jt ju hj ix b iy kd jc ke jg kf jk kg jo kh js jy jz ka kb bi translated"><a class="ae kc" href="https://adamfanello.medium.com/migrating-a-legacy-app-to-cloud-native-part-4-2741585e4953" rel="noopener">第4部分:添加云存储</a></li></ul><p id="a5be" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">现在，我已经通过Amplify CLI添加了云存储，并对其进行了配置，是时候在我的应用程序中使用新的存储了。</p><h1 id="9229" class="ki kj hj bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">前言</h1><p id="4d8c" class="pw-post-body-paragraph iv iw hj ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hc bi translated">一般来说，这个系列是在我使用这个工具时编写的，并按照我创建内容的顺序呈现。从草稿到出版有一些编辑工作，但是这个系列是关于旅程的，所以我这样呈现它。</p><p id="0281" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">不过这一次，我会在你进入帖子内容之前回来添加这个注释。到目前为止，这绝对是迁移中最具挑战性的部分，我怀疑它在整个系列中会一直如此。由于糟糕的文档和我的挫败感，我大约一半的时间花在了对Amplify和Javascript SDK的逆向工程上。我想在这里声明，我真的很喜欢AWS，我真的很期待Amplify的成功。AWS的工程师创造了令人惊叹的工具和服务，在过去十年中改变了软件开发人员的身份，使得以前所未有的规模和速度构建产品成为可能。因此，虽然我对不完美感到沮丧，但我也承认，如果没有Amazon和AWS的出色工作，我可能还会回到构建认证系统的第1部分。😬</p><p id="499f" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">在被吓退之前，也一定要阅读结论。开始了…</p><h1 id="b800" class="ki kj hj bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">为Amplify App添加存储支持</h1><p id="989f" class="pw-post-body-paragraph iv iw hj ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hc bi translated">第一步是将Amplify存储模块添加到我的Angular应用程序中，如下图<a class="ae kc" href="https://aws-amplify.github.io/docs/js/angular#option-2-configuring-the-amplify-provider-with-specified-amplify-js-modules" rel="noopener ugc nofollow" target="_blank">所示</a>。不过，出于对这种需求的预期，我已经在添加身份验证时完成了这一步。继续前进…</p><h1 id="8320" class="ki kj hj bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">基本使用—不太容易</h1><p id="30e6" class="pw-post-body-paragraph iv iw hj ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hc bi translated">web应用程序一直在使用<a class="ae kc" href="https://feathersjs.com/" rel="noopener ugc nofollow" target="_blank"> Feathers </a>的客户端库与Feathers后端进行通信。现在必须用放大存储来代替。幸运的是，我通过将所有的实际通信隔离到一个<code class="dv lm ln lo lp b">PersistenceService</code>类中，很好地设计了这个应用程序。🎉</p><p id="3002" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">首先要做的是写一些东西到存储，这就导致了<code class="dv lm ln lo lp b">Storage.put(key, content, config)</code>。有哪些<code class="dv lm ln lo lp b">config</code>选项？没有一个地方能告诉你所有的信息。Typescript声明没有给出任何东西，只有<a class="ae kc" href="https://aws-amplify.github.io/docs/js/storage#put" rel="noopener ugc nofollow" target="_blank">文档的这一部分</a>通过一系列例子告诉你什么可能是，什么可能不是一个完整的列表。这里有一个API引用<a class="ae kc" href="https://aws-amplify.github.io/amplify-js/api/classes/storageclass.html" rel="noopener ugc nofollow" target="_blank"/>，显然是从一些类型脚本中生成的，只是将配置选项列为类型<code class="dv lm ln lo lp b">any</code>。😕<code class="dv lm ln lo lp b">get</code>函数的API在某种程度上更糟糕，因为它表明它返回“预先指定的url或对象”。哪一个是神秘的，也许是由同样神秘的<code class="dv lm ln lo lp b">config?: any</code>第二个参数控制的。不管怎样，Amplify Storage <a class="ae kc" href="https://aws-amplify.github.io/docs/js/storage#get" rel="noopener ugc nofollow" target="_blank">文档</a>声明get“检索可公开访问的URL ”,所以这看起来是最有可能的结果，尽管不是很有用。也许是这样，但是当我追踪到<a class="ae kc" href="https://github.com/aws-amplify/amplify-js/blob/master/packages/storage/src/Storage.ts" rel="noopener ugc nofollow" target="_blank">源代码</a>并发现API文档是从整个代码中<em class="ll">而不是</em>生成的时候，我之前的怀疑似乎得到了证实。JsDoc被证明更有用:</p><pre class="lq lr ls lt fe lu lp lv lw aw lx bi"><span id="6d5c" class="ly kj hj lp b fj lz ma l mb mc">/**<br/> * Get a presigned URL of the file or the object data when download:true<br/> *<br/> * @param {String} key - key of the object<br/> * @param {Object} [config] - { level : private|protected|public, download: true|false }<br/> * @return - A promise resolves to either a presigned url or the object<br/> */<br/>public async get(key: string, config?): Promise&lt;String | Object&gt; {</span></pre><p id="1699" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">感谢开源！实际的逻辑在<a class="ae kc" href="https://github.com/aws-amplify/amplify-js/blob/master/packages/storage/src/Providers/AWSS3Provider.ts" rel="noopener ugc nofollow" target="_blank"> AWSS3Provider.ts </a>中，其内容回答了我下一个关于错误处理的问题。我看到<code class="dv lm ln lo lp b">Promise</code>从AWS-SDK的<code class="dv lm ln lo lp b">s3.getObject</code>返回原始响应。所以跟踪API 的<a class="ae kc" href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#getObject-property" rel="noopener ugc nofollow" target="_blank">只会发现被拒绝的数据类型是<code class="dv lm ln lo lp b">Error</code>，就像它变得那样通用。😕此外，只有在这里我才知道，在选择下载时，结果对象将有一个名为“类型化数组”的属性<code class="dv lm ln lo lp b">Body</code>…不管那是什么。&lt;叹&gt;通过实验(也就是<code class="dv lm ln lo lp b">console.log</code>，我发现身体是<code class="dv lm ln lo lp b">Uint8Array</code>，那上面的一个<code class="dv lm ln lo lp b">toString(‘UTF-8’)</code>把我存的弦还回去了。(一般来说，我认为任何包含getter和setter的API都不会以与设置时相同的形式返回值。)</a></p><p id="1f71" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">情况更糟<em class="ll">又</em>为<code class="dv lm ln lo lp b">Storage.list()</code>。示例<a class="ae kc" href="https://aws-amplify.github.io/docs/js/storage#list-keys" rel="noopener ugc nofollow" target="_blank">这里的</a>只是表示它返回一个结果。就是这样。它返回<em class="ll">某个东西</em>。我又一次追踪到了SDK s3.listObjects文档，但是这一次实际结果甚至与那里的不匹配，因此表明AWS的文档问题不仅仅局限于Amplify。(仅供参考:实际返回的结果只是<code class="dv lm ln lo lp b">Contents</code>数组，它的字段以小写字母开始，而不是记录的大写字母。)</p><p id="6358" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">我大概可以进一步挖掘其来源，但这种做法已经达到了荒谬的程度。这是一个API的失败，是不可维护代码的标志，当任何超出文档和函数签名的内容需要被试图使用它的人读取时。Amplify的目的是使AWS的使用更容易。它的存储模块被证明是另一层神秘的东西，让我难以捉摸。这是一个特别的失误，因为放大源本身<em class="ll">有</em>更多的文档准备提供帮助，但它被隐藏起来了。</p><p id="0fea" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">以下是Amplify Storage API实际工作的重点片段<em class="ll">。完整代码可在<a class="ae kc" href="https://github.com/kernwig/sqac-amplify/pull/4/files?w=1" rel="noopener ugc nofollow" target="_blank"> PR #4 </a>中找到。</em></p><pre class="lq lr ls lt fe lu lp lv lw aw lx bi"><span id="6d4f" class="ly kj hj lp b fj lz ma l mb mc">import {AmplifyService} from 'aws-amplify-angular';<br/>import {StorageClass} from 'aws-amplify';</span><span id="673f" class="ly kj hj lp b fj md ma l mb mc">@Injectable()<br/>export class PersistenceService {<br/>  /** API to the cloud storage */<br/>  <strong class="lp hk">private readonly cloud: StorageClass;</strong></span><span id="35a6" class="ly kj hj lp b fj md ma l mb mc"><strong class="lp hk">  constructor(private readonly amplifySvc: AmplifyService) {<br/>    this.cloud = this.amplifySvc.storage();<br/>  }</strong></span><span id="d9ab" class="ly kj hj lp b fj md ma l mb mc">  async loadUser(): Promise&lt;UserSettings&gt; {<br/><strong class="lp hk">    const downloadedObj = await this.cloud.get(<br/>      settingsKey, <br/>      {level: 'private', download: true}<br/>    );<br/>    const downloadedStr = (downloadedObj as any).Body.toString('utf-8');<br/></strong>    const downloadedJson = JSON.parse(downloadedStr) as UserSettingsJSON;<br/>    // etc<br/>  }</span><span id="e91e" class="ly kj hj lp b fj md ma l mb mc">  private async saveModelToCloud&lt;T extends AbstractStorableModel&gt;(model: T, id: string, level: 'private'|'protected'): Promise&lt;T&gt; {<br/>    let json = model.toJSON() as AbstractStorableModelJSON;<br/><strong class="lp hk">    await this.cloud.put(<br/>      id, JSON.stringify(json),<br/>      {level, contentType: "application/json"}<br/>    );<br/></strong>  }<br/>}</span></pre><p id="87a7" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">好消息是，我现在有一个文件在我的存储S3桶！🎉</p><h1 id="80e6" class="ki kj hj bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">当sub不是sub时</h1><p id="6bdf" class="pw-post-body-paragraph iv iw hj ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hc bi translated">在本系列的第4部分<a class="ae kc" href="https://adamfanello.medium.com/migrating-a-legacy-app-to-cloud-native-part-4-2741585e4953" rel="noopener">中，我研究了存储策略，并发现该策略保护了云结构中的S3存储路径<code class="dv lm ln lo lp b">"private/${cognito-identity.amazonaws.com:sub}/"</code>。</a></p><p id="61b6" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">一旦我存储了一个文件，我看到它实际上创建了S3前缀<code class="dv lm ln lo lp b">“private/us-west-2:ecee2298-97c5-4331-867c-908eef1660c8/”</code>，而by <code class="dv lm ln lo lp b">CognitoUser</code>有sub <code class="dv lm ln lo lp b">"508903f1-9203-4cf6-b0d8-353fc54c2916"</code>。🤔为什么这些不匹配？</p><p id="102c" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">经过一番挖掘，我终于注意到云结构的第一部分写着“cognito- <em class="ll"> identity </em>”。这是认知身份池。同时，<code class="dv lm ln lo lp b">CognitoUser</code> sub来自Cognito <strong class="ix hk">用户</strong>池。两码事。哎呦。这是一个陷阱，在Amplify CLI <a class="ae kc" href="https://github.com/aws-amplify/amplify-cli/issues/1847" rel="noopener ugc nofollow" target="_blank">第1847期</a>和<a class="ae kc" href="https://github.com/aws-amplify/amplify-js/issues/54" rel="noopener ugc nofollow" target="_blank"> Amplify JS第54期</a>中详细讨论过，其中一些评论者对复杂的解决方法感到有点困惑。这是一个惊喜，但只需几行代码就可以解决。简单地说，我调用<code class="dv lm ln lo lp b">AuthService#currentUserInfo()</code>并使用这个ID(身份池ID)而不是来自<code class="dv lm ln lo lp b">AuthService#authStateChange$</code>的值。在<a class="ae kc" href="https://github.com/kernwig/sqac-amplify/commit/2ffb97af1c4821b4d2d8c8d093b48ffc91a5e97c?w=1" rel="noopener ugc nofollow" target="_blank">提交</a>中可以看到代码的变化。</p><h1 id="d18e" class="ki kj hj bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">存储NoSQL选项？</h1><p id="c1a2" class="pw-post-body-paragraph iv iw hj ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hc bi translated">在深入研究Amplify以发现如何使用存储模块的过程中，我了解到它是AWS SDK的一个薄薄的包装器，其行为与S3紧密耦合。如果我在执行<code class="dv lm ln lo lp b">amplify add storage</code>命令时选择了NoSQL (DynamoDB)选项，会发生什么？相同的API会提供完全不同的结果吗？我回头在<a class="ae kc" href="https://github.com/aws-amplify/amplify-js/tree/master/packages/storage" rel="noopener ugc nofollow" target="_blank"> amplify-js存储源代码</a>中，只找到了S3提供者。😲</p><p id="b2ba" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">然后我看了一眼iOS和Android文档。像Javascript文档一样，他们说要选择“内容”选项。(我在之前的阅读中漏掉了这句话。)我认为编写Angular CLI的团队只是领先于客户端库团队。我很高兴在项目的架构阶段考虑这个问题时，我选择了S3选项！</p><h1 id="0628" class="ki kj hj bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="0c3b" class="pw-post-body-paragraph iv iw hj ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hc bi translated">虽然Amplify CLI使建立AWS基础设施变得更加容易，Amplify身份验证模块使管理用户<em class="ll">变得真正</em>容易，但存储模块已经失败了。考虑到我必须深入研究底层SDK来弄清楚如何使用它，使用底层SDK会更容易。不过，这远不是一个注定要失败的事业。能力是存在的；赎回只需要适当的API文件！正确使用Typescript也会大有帮助。(避免类型<code class="dv lm ln lo lp b">any</code>。)</p><p id="715f" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">不幸的是，这是开发人员驱动的产品的一个常见问题。我们开发人员喜欢制作功能，而不是文档。我们让这个功能达到“适合我”的程度，称之为完整，然后继续下一个闪亮的东西。我们很少有人喜欢为人类写作。即使有文档(Amplify也确实写了很多文档)，结果也是更多的废话。“看看这个闪亮的新功能！用它来做大事！”当你真正尝试使用它时，我们会得到这样的结果:</p><figure class="lq lr ls lt fe ik es et paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="es et me"><img src="../Images/516e3256ba0c5804f7288860c0b36e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VTLtO5JXyE0PYZb0.png"/></div></div></figure><p id="c39e" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated">list函数接受something的两个参数，并返回一个something。🤷‍♂️:这不是AWS的问题，这是我整个职业生涯中遇到的行业问题。也许开源变得如此占主导地位的部分原因不是经济上的，而是因为在一个没有文档的专有库和一个没有文档的开源库之间做出选择，我们使用唯一一个<em class="ll">可以</em>使用的库。</p><h1 id="cc9b" class="ki kj hj bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">下次再来…</h1><p id="4cc5" class="pw-post-body-paragraph iv iw hj ix b iy lg ja jb jc lh je jf jg li ji jj jk lj jm jn jo lk jq jr js hc bi translated">我需要花更多的时间来测试我的应用程序，并确保这个存储工作正常，所以在我继续之前可能会有一点延迟。下一部分将涉及使用Amplify CLI来设置非常小的GraphQL API，以便它将生成DynamoDB表。为了将数据<em class="ll">放入</em>表中，我将监控S3数据桶的变化，并将元数据存储到DynamoDB中。如我的架构图所示(第二部分的结尾)，我可能需要跳出Amplify的范围。更多即将推出！</p><p id="1447" class="pw-post-body-paragraph iv iw hj ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hc bi translated"><em class="ll">(故事原载</em> <a class="ae kc" href="http://fanello.net/home/2019/09/18/migrating-a-legacy-app-to-cloud-native-part-4/" rel="noopener ugc nofollow" target="_blank"> <em class="ll">此处</em></a><em class="ll">2019年10月。)</em></p></div></div>    
</body>
</html>