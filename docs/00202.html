<html>
<head>
<title>Creating an MVC application using NODEjs and MariaDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NODEjs和MariaDB创建MVC应用程序</h1>
<blockquote>原文：<a href="https://medium.com/codex/creating-an-mvc-application-using-nodejs-and-mariadb-9510c7b91716?source=collection_archive---------2-----------------------#2021-01-05">https://medium.com/codex/creating-an-mvc-application-using-nodejs-and-mariadb-9510c7b91716?source=collection_archive---------2-----------------------#2021-01-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/c10f596eeb3e73f114b96cb3bced4423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BN_1TlT9X6ihkfod"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae hv" href="https://unsplash.com/@altumcode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> AltumCode </a>拍摄的照片</figcaption></figure><div class=""/><h1 id="052d" class="iv iw hy bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">堆栈</h1><p id="6132" class="pw-post-body-paragraph jt ju hy jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">MVC或模型-视图-控制器是一种设计模式，它将应用程序分成三个主要组件:模型、视图和控制器。简单来说，模型管理数据，视图呈现数据，控制器是其他组件的接口。</p><p id="14b1" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这个MVC应用程序将用Nodejs运行环境构建。Nodejs使用google V8引擎，该引擎允许在web浏览器之外执行JavaScript代码。具有非阻塞I/O操作的单线程事件循环模型体系结构提供了一种处理并发请求的方法，而无需创建多线程。这些特性使Nodejs成为构建高效应用程序的好选择。此外，我们还将使用Express框架，该框架提供了几个特性，使得用Nodejs开发web应用程序变得更加容易和快速。</p><p id="64c5" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在数据库引擎方面，我们将使用MariaDB。MariaDB是由MySQL的原始开发者构建的，并保证保持开源，目前正在被像Google或Wikipedia这样的著名用户使用。查询将通过Nodejs MariaDB connector手动编写，而不是像流行的Sequelize那样使用对象关系映射器(ORM)。</p><p id="6264" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">为了实现视图，将使用模板引擎EJS(嵌入式JavaScript)。EJS的学习曲线很快，因为你需要编写的代码基本上是HTML标记结合基本的JavaScript代码。</p><p id="5aca" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在开始之前，我认为设定目标和限制是合适的。本教程的主要目的是提出一个使用Nodejs创建MVC应用程序时可以使用的策略。为此，我们将构建一个简单的登录页面，您可以在其中进行身份验证并查看用户资料页面。我们将实现基本的基于角色的访问控制，以区分管理员和普通角色。它不会涵盖您在开发要在生产环境中部署的应用程序时需要考虑的许多方面。例如，错误处理、日志记录或基本的安全措施(如加密密码)不包括在内。</p><h1 id="c975" class="iv iw hy bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">开始</h1><p id="ad4a" class="pw-post-body-paragraph jt ju hy jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">为了能够继续学习本教程，您应该已经安装了:</p><ul class=""><li id="4616" class="kw kx hy jv b jw kr ka ks ke ky ki kz km la kq lb lc ld le bi translated">NPM或者百胜这样的包装经理；</li><li id="5282" class="kw kx hy jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">Nodejs</li><li id="3f01" class="kw kx hy jv b jw lf ka lg ke lh ki li km lj kq lb lc ld le bi translated">MariaDB服务器。</li></ul><p id="927e" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">好吧，让我们从创建以下文件夹结构开始:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="9505" class="lt iw hy lp b fi lu lv l lw lx">mkdir controllers models views</span></pre><p id="4f20" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">打开您的终端并输入<em class="ly"> npm init -y </em>来创建我们的package.json文件，不要问任何问题。在本教程中，我没有讨论在配置包文件时需要考虑的问题。让我们通过输入以下命令来安装节点模块:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="6c68" class="lt iw hy lp b fi lu lv l lw lx"> npm install mariadb express express-session body-parser passport dotenv ejs</span></pre><p id="0bb6" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">dotenv模块支持将环境变量从. env文件加载到process.env中。在本例中，我们使用dotenv来存储数据库配置和服务器端口。在应用程序的根文件夹中创建一个. env文件，并复制这些配置，稍后将通过调用<em class="ly"> dotenv.config() </em>来加载这些配置。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="94ae" class="lt iw hy lp b fi lu lv l lw lx">DB_HOST=localhost</span><span id="3ea5" class="lt iw hy lp b fi lz lv l lw lx">DB_DATABASE=myapp</span><span id="3951" class="lt iw hy lp b fi lz lv l lw lx">DB_USER=admin</span><span id="233d" class="lt iw hy lp b fi lz lv l lw lx">DB_PASSWORD=mypass</span><span id="d710" class="lt iw hy lp b fi lz lv l lw lx">SERVER_PORT=3000</span></pre><p id="f2a6" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">更改内容以适应您的数据库服务器配置。现在在同一个文件夹中创建一个server.js文件，并通过import express和dotenv启动。添加express listen函数来创建HTTP服务器。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="2f17" class="lt iw hy lp b fi lu lv l lw lx">const express = require(“express”); </span><span id="2144" class="lt iw hy lp b fi lz lv l lw lx">const dotenv = require(“dotenv”);</span><span id="4b40" class="lt iw hy lp b fi lz lv l lw lx">const app = express();</span><span id="6013" class="lt iw hy lp b fi lz lv l lw lx">dotenv.config();</span><span id="5a53" class="lt iw hy lp b fi lz lv l lw lx">app.listen(process.env.SERVER_PORT, function () {</span><span id="9990" class="lt iw hy lp b fi lz lv l lw lx">console.log(“Server listening at: “ + process.env.SERVER_PORT)});</span></pre><p id="447a" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">尝试用命令<em class="ly"> node server.js </em>启动你的服务器，你应该得到一个终端消息“服务器监听3000”。现在，应用程序的根目录应该如下所示:</p><figure class="lk ll lm ln fd hk er es paragraph-image"><div class="er es ma"><img src="../Images/cc35719a297f42fe11d9bd0f49309925.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/1*LON-scRZ6MH0p3UQXNJmuQ.png"/></div></figure><p id="1334" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在“views”文件夹中创建一个名为<em class="ly"> partials </em>的文件夹，并在里面创建一个<em class="ly"> headers.ejs </em>文件。在这个文件中，我们将放置一些可以被其他ejs文件导入的HTML代码。当不同的页面(如导航栏、页脚或页眉)中有相同的代码时，这个ejs特性特别有用。在这种情况下，我们更多地是用这个来展示概念，而不是出于实际原因。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="9239" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在views文件夹中，我们需要创建一个<em class="ly"> login.ejs </em>文件，其中包含我们的HTML标记和来自ejs的javascript。该文件将从partials文件夹导入header.ejs文件。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="87d2" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">看一下<em class="ly">&lt;% if(errors . length){ %&gt;</em>块。使用这个代码片段，我们可以发送一个错误变量，并向最终用户显示一条错误消息。如果错误变量不包含任何消息，生成的HTML将不包含任何内容。</p><p id="0d4b" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在控制器中，folder用我们的第一个路由创建了一个login.route.js文件。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="285b" class="lt iw hy lp b fi lu lv l lw lx">const express = require("express");</span><span id="6b9a" class="lt iw hy lp b fi lz lv l lw lx">const router = express.Router();</span><span id="06f7" class="lt iw hy lp b fi lz lv l lw lx">router.get("/", function (request, response) {</span><span id="b62d" class="lt iw hy lp b fi lz lv l lw lx">   response.render("login", { errors: [] });</span><span id="a3a7" class="lt iw hy lp b fi lz lv l lw lx">});</span><span id="6cb9" class="lt iw hy lp b fi lz lv l lw lx">module.exports = router;</span></pre><p id="1355" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">返回server.js文件，将EJS设置为视图引擎，并将登录路由文件与登录端点绑定在一起。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="3144" class="lt iw hy lp b fi lu lv l lw lx">app.set("view engine", "ejs");</span><span id="deab" class="lt iw hy lp b fi lz lv l lw lx">app.set("views", "views");</span><span id="4e31" class="lt iw hy lp b fi lz lv l lw lx">app.use("/login", require("./controllers/login.route"));</span></pre><p id="7477" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">再次启动我们的应用程序，在<a class="ae hv" href="http://localhost:3000/login" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/log in</a>打开您的浏览器。您应该能够看到登录页面。</p><p id="78a6" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">下一步是创建数据库连接池。在应用程序的根目录下创建utils文件夹，并在其中创建一个包含以下内容的db.js文件。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="4da8" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">基本上，我们创建了一个新的MariaDB服务器连接池，并在getConnection函数中封装了获取新连接的能力。访问数据库的详细信息从dot env文件中获取。</p><p id="feef" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在打开您的SQL IDE并创建包含两个用户的USERS表:一个用户具有管理员角色，另一个是普通用户。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="f23e" class="lt iw hy lp b fi lu lv l lw lx">CREATE DATABASE myapp</span><span id="2c1d" class="lt iw hy lp b fi lz lv l lw lx">CREATE TABLE USERS</span><span id="2c0b" class="lt iw hy lp b fi lz lv l lw lx">( ID int NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><span id="25d5" class="lt iw hy lp b fi lz lv l lw lx">USERNAME varchar(100),</span><span id="1050" class="lt iw hy lp b fi lz lv l lw lx">EMAIL varchar(100),</span><span id="151d" class="lt iw hy lp b fi lz lv l lw lx">ROLE varchar(100),</span><span id="a506" class="lt iw hy lp b fi lz lv l lw lx">PASS varchar(100)</span><span id="89d3" class="lt iw hy lp b fi lz lv l lw lx">);</span><span id="95c1" class="lt iw hy lp b fi lz lv l lw lx">INSERT INTO USERS</span><span id="f5be" class="lt iw hy lp b fi lz lv l lw lx">(USERNAME,EMAIL,ROLE,PASS)</span><span id="e334" class="lt iw hy lp b fi lz lv l lw lx">VALUES(‘John’,’a@myemail.com’,’USER’,’mypassword’);</span><span id="16a3" class="lt iw hy lp b fi lz lv l lw lx">INSERT INTO USERS</span><span id="2acb" class="lt iw hy lp b fi lz lv l lw lx">(USERNAME,EMAIL,ROLE,PASS)</span><span id="5261" class="lt iw hy lp b fi lz lv l lw lx">VALUES(‘Mary’,’b@myemail.com’,’ADMIN’,’mypassword’);</span></pre><p id="1bd3" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在模型中，文件夹创建一个user.model.js文件，并声明<em class="ly"> read </em>、<em class="ly"> list、</em>和<em class="ly">是ValidCredentials </em>函数。<em class="ly"> Read </em>用于获取用户信息，<em class="ly"> list </em>用于获取所有用户的列表，<em class="ly"> areValidCredentials </em>用于检查登录凭证是否正确。在每个函数中，我们从连接池中请求一个新的连接，在获取数据后，我们关闭连接。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="633e" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在utils内部，该文件夹创建了一个名为auth.js的新文件。首先导入express-session模块，该模块允许服务器端会话存储，客户端接收带有会话id的cookie。我们将使用默认配置在服务器端(内存)存储会话信息。在passport <em class="ly"> serializeuser </em>函数中，我们选择希望在会话中存储什么用户信息，在本例中，我们只存储用户名。随后在<em class="ly">deseriizeduser</em>函数中从数据库中检索整个用户对象，并保存到request.user。<em class="ly">check authentic ation</em>函数可用作简单的基于角色的授权中间件，其中角色可在路由级别传递，并与存储在request . user中的用户角色进行比较</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="5136" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在服务器中，该文件添加bodyParser中间件并初始化身份验证。在app.use(route，routefile)之前添加这个中间件很重要。否则，passport将不会被初始化，您将会得到一个错误。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="6db6" class="lt iw hy lp b fi lu lv l lw lx">const bodyParser = require(“body-parser”)</span><span id="d1f6" class="lt iw hy lp b fi lz lv l lw lx">app.use(bodyParser.json(), bodyParser.urlencoded({ extended: true }));</span><span id="a250" class="lt iw hy lp b fi lz lv l lw lx">const auth = require(“./utils/auth”);</span><span id="6358" class="lt iw hy lp b fi lz lv l lw lx">auth.initialization(app);</span></pre><p id="b76c" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在控制器的文件夹中创建profile.route.js文件。基本上，我们将有一个profile/user和profile/admin路由，其中我们使用<em class="ly"> checkAuthentication </em>中间件来限制对我们传递的角色的访问。用户可以使用他们的个人资料访问页面，而管理员可以访问他们的个人资料和用户列表。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="00f0" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在server.js中添加配置文件路由</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="1990" class="lt iw hy lp b fi lu lv l lw lx">app.use(“/profile”, require(“./controllers/profile.route”));</span></pre><p id="9e79" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">更改登录路由器文件以考虑登录过程。get方法呈现登录页面，或者如果用户已经过身份验证，则重定向到配置文件页面。post方法检查凭证是否有效，以及它们是否是通过request.login(user)登录的用户。除了这种定制方法，我们可以使用passport local策略来完成基本相同的任务。我们在这里还包括允许注销的路由。为此，我们只需调用request.logOut()。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="3adc" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在views文件夹中创建一个profile.ejs。该文件呈现用户数据，如果用户是管理员，它还呈现数据库中的用户列表。</p><figure class="lk ll lm ln fd hk"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="30e9" class="pw-post-body-paragraph jt ju hy jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">再次启动我们的服务器，检查您是否能够同时登录两个用户。感谢阅读本教程，你可以在这里查看项目代码<a class="ae hv" href="https://github.com/lrpt/myrep" rel="noopener ugc nofollow" target="_blank"/>。请随时提出改进文章质量的建议。</p></div></div>    
</body>
</html>