<html>
<head>
<title>Generating Clients/Models for RESTful services from OpenAPI Specification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">根据OpenAPI规范为RESTful服务生成客户端/模型</h1>
<blockquote>原文：<a href="https://medium.com/codex/generating-clients-models-for-restful-services-from-openapi-specification-edf211e5d761?source=collection_archive---------0-----------------------#2022-01-05">https://medium.com/codex/generating-clients-models-for-restful-services-from-openapi-specification-edf211e5d761?source=collection_archive---------0-----------------------#2022-01-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="06c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在几秒钟内生成随时可用的客户端和模型</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/6194134f548a0fdc6b6fdefbbff674ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*18dCkkRm7Xv0EZgpASkGyA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">网飞的服务图——注意有多少连接！(<a class="ae jt" href="https://www.youtube.com/watch?v=CZ3wIuvmHeM" rel="noopener ugc nofollow" target="_blank"> src </a>)</figcaption></figure><h1 id="2120" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">沟通是不可或缺的！</h1><p id="a107" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">随着<a class="ae jt" href="https://microservices.io/" rel="noopener ugc nofollow" target="_blank">微服务</a>越来越受欢迎，服务间的沟通成为一个组织架构的重要组成部分。企业的技术堆栈不再由三个很少通信的单一应用程序组成，而是由数百个频繁交互的微小组件组成。这些服务最常见的通信方式是与<a class="ae jt" href="https://www.redhat.com/en/topics/api/what-is-a-rest-api" rel="noopener ugc nofollow" target="_blank"> REST </a>进行通信。</p><blockquote class="kx ky kz"><p id="7437" class="if ig la ih b ii ij ik il im in io ip lb ir is it lc iv iw ix ld iz ja jb jc hb bi translated">B <em class="hi">在我们继续讨论之前，我必须指出的是</em> <a class="ae jt" href="https://aws.plainenglish.io/stop-making-synchronous-calls-f101af15cd46" rel="noopener ugc nofollow" target="_blank"> <em class="hi">我尽可能避免进行同步调用</em></a><em class="hi">(REST是同步调用的一种形式)，但是如果您必须进行同步调用，那么您应该</em> <a class="ae jt" rel="noopener" href="/codex/successful-microservice-architecture-eda2adee67f8"> <em class="hi">遵循这些提示</em> </a> <em class="hi">来使您的服务更有弹性</em></p></blockquote><h1 id="cf6a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">当前(有缺陷的)流程</h1><p id="33b6" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">尽管它很重要，但我看到许多组织进行进程间调用的方式还有很多不足之处。事情往往是这样的:</p><ul class=""><li id="d9d7" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">服务器端团队手工输入模型(假设他们使用java)</li><li id="9ea8" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">服务器端团队试图以反映上一步中创建的手写模型的方式编写开放api规范</li><li id="ce0b" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">服务器端团队创建他们自己的客户端进行测试</li><li id="5e98" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">消费团队手工输入模型</li><li id="5974" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">消费团队创建他们自己的客户来消费服务</li></ul><h1 id="5a93" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">有待改进的领域</h1><p id="02d8" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">这一过程在许多方面存在缺陷；下面是一些主要的例子</p><ul class=""><li id="e7ab" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">容易出错— <strong class="ih hj">不能保证契约是正确的</strong>(考虑模型有transactionId，契约有transactionID)</li><li id="8b04" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">低效——服务器端团队已经定义了合同，为什么他们还需要编写模型呢？<strong class="ih hj">浪费开发者时间</strong></li><li id="7f7d" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">低效——服务器端团队编写测试客户端，然后消费者各自编写自己的客户端；再次，<strong class="ih hj">又一次浪费开发者的时间</strong></li><li id="2405" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">低效——消耗团队必须花时间为他们编写的客户编写单元测试</li><li id="5794" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">额外的开销——因为每个消费团队都编写自己的客户端，</li><li id="1e09" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">缺乏标准化——无法保证最佳实践在团队中得到遵循</li><li id="6fc8" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">缺乏可扩展性——添加新功能需要修改由不同团队维护的大量代码</li></ul><h1 id="da3a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如何改进:代码生成</h1><p id="0dcb" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">有一种方法可以改善上面列出的许多缺点:<strong class="ih hj">通过从规范</strong>中生成代码(包括客户端和服务器端)。因为这篇文章是关于REST的，我们将使用<a class="ae jt" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank">开放api规范</a>，但是你也可以用其他格式做类似的事情(比如用protobuffers 的<a class="ae jt" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank"> GRPC，或者用WSDL </a>文件的<a class="ae jt" href="https://www.soapui.org/docs/soap-and-wsdl/working-with-wsdls/" rel="noopener ugc nofollow" target="_blank"> SOAP)。我们的流程概述如下:</a></p><ul class=""><li id="6f0e" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">为我们的服务写合同</li><li id="0627" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">在它自己的sdk/jar中生成客户端(在这种情况下，我们将使用一个<a class="ae jt" href="https://openapi-generator.tech/docs/plugins/" rel="noopener ugc nofollow" target="_blank"> gradle插件</a>，<strong class="ih hj">，这样我们就可以在我们的测试中使用它，消费者也可以将它包含在他们的项目中</strong></li><li id="2719" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">生成服务器端模型和接口(同样，使用相同的<a class="ae jt" href="https://openapi-generator.tech/docs/plugins/" rel="noopener ugc nofollow" target="_blank"> gradle插件</a>，只是不同的<a class="ae jt" href="https://subscription.packtpub.com/book/application_development/9781784392789/1/ch01lvl1sec08/declaring-dependency-configurations" rel="noopener ugc nofollow" target="_blank">配置</a> ) —可以与上述步骤并行完成</li><li id="32e2" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">为我们的功能编写<a class="ae jt" href="https://cucumber.io/" rel="noopener ugc nofollow" target="_blank">黄瓜测试</a>(使用我们生成的客户端)</li></ul><p id="aa92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="la">注意这是如何改进上述解决方案的缺点的:</em></p><ul class=""><li id="68bf" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">保证正确性——因为模型是从开放api规范中生成的；他们将会是100%正确的</li><li id="0ba3" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">更高效——服务器端团队不再需要写模型；哪个<strong class="ih hj">节省了几个小时的时间</strong></li><li id="07e2" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">更高效——消费者使用与服务器端团队在功能测试中使用的相同的客户端(而不是编写他们自己的客户端),这<strong class="ih hj">为每个消费者节省了数小时的时间</strong></li><li id="0bc4" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">更高效——消费者不再需要为客户编写单元测试，<strong class="ih hj">为每个消费者节省了几个小时的时间</strong></li><li id="1a47" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">标准化——每个客户端都将遵循相似的结构，这使得调试和使用更加容易，<strong class="ih hj">节省了数小时的时间</strong></li><li id="f2f1" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated">更容易扩展——团队可以传递拦截器来修改请求和响应；或者他们可以定制小胡子模板来修改生成的代码，<strong class="ih hj">，这对所有团队都有好处</strong></li></ul><p id="1449" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="la">注:这个过程类似于</em> <a class="ae jt" href="https://www.programmableweb.com/news/how-to-auto-generate-grpc-code-using-protoc/how-to/2020/10/14" rel="noopener ugc nofollow" target="_blank"> <em class="la"> google多年来用grpc </em> </a> <em class="la">所拥抱的，对于</em> <a class="ae jt" href="https://www.baeldung.com/java-soap-web-service" rel="noopener ugc nofollow" target="_blank"> <em class="la"> SOAP webservices(用WSDL) </em> </a> <em class="la">它是存在的(至少代码生成)，还有如果你看</em> <a class="ae jt" href="https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/services/sqs/AmazonSQSClient.html" rel="noopener ugc nofollow" target="_blank"> <em class="la"> aws的客户端SDK</em></a><em class="la">，它们都是生成的。最后，许多其他成功的技术公司，如</em><a class="ae jt" href="https://www.salesforce.com" rel="noopener ugc nofollow" target="_blank"><em class="la">sales force</em></a><em class="la">和</em><a class="ae jt" href="https://www.paypal.com" rel="noopener ugc nofollow" target="_blank"><em class="la">paypal</em></a><em class="la">都长期使用客户端生成流程。故事的寓意；这是经过实践检验的真理，如果你不使用它，你的公司就会被甩在后面。</em></p></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="39da" class="ju jv hi bd jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr bi translated">最后结果</h1><p id="9c1e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在本文结束时，您将已经建立了一个自动生成java模型对象的过程，这些对象表示open api规范中声明的任何模型(用于请求/响应主体)以及功能完整的java客户机，这些客户机为规范中声明的每个操作提供了一个方法。它在你的build.gradle中包含10行代码(<strong class="ih hj">你不用写一行java代码</strong>——它都是自动生成的),你可以用它来调用你的服务。</p><ul class=""><li id="d39b" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">开放api规范中指定的任何模型都有一个为其创建的Java POJO用相同的名称构造并适当嵌套</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es me"><img src="../Images/6c2ba81fe2e52c21d3595479c7e671e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AhhuhEBtCpzxy5qdmBdhMw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">开放api文档中评估对象的规范(通过<a class="ae jt" href="https://editor.swagger.io/" rel="noopener ugc nofollow" target="_blank"> swagger编辑器</a>可视化)</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mf"><img src="../Images/2ee563518a5b13b5610ca92c1b1c0a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uepFlnuGcZ1iC4_yBv00Gg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">生成的代表评估的java类</figcaption></figure><ul class=""><li id="f72c" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">任何操作(url和方法的组合)都有一个生成了方法的客户端。这个方法是调用api的全功能方法，使用生成的请求和响应模型。如果您愿意，您可以使用标签来生成不同的APIs如果您用不同的标签标记相同的操作，您可以在不同的类中公开相同的功能。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mg"><img src="../Images/8fb6fd006668fdfcbb40845c58430bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rL3fywJkPmcrk2Kdii9llw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">这些是开放api规范中规定的操作(通过<a class="ae jt" href="https://editor.swagger.io/" rel="noopener ugc nofollow" target="_blank"> swagger编辑器</a>可视化)</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mh"><img src="../Images/34509a48edde76e66ce3f9b19d949890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O47bB5vg1lI8VK64NWoUgg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">您还可以获得一个为生成的java客户端，其中包含规范中声明的每个操作的方法</figcaption></figure></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="b51a" class="ju jv hi bd jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr bi translated">实施细节</h1><p id="8fc1" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们现在将看到如何用Java为客户端库实现上述过程(<em class="la">注意，对于其他语言</em>，可以遵循非常相似的过程)。这个过程与服务器端存根类似，只是它们为您提供了一个接口来实现使用您的业务逻辑，而不是一个全功能的客户端:</p><ul class=""><li id="c393" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">应用开放api生成器插件</li></ul><pre class="je jf jg jh fd mi mj mk ml aw mm bi"><span id="a501" class="mn jv hi mj b fi mo mp l mq mr">plugins {<br/>    id "java-library"<br/><strong class="mj hj">    id "org.openapi.generator" version "4.3.1" </strong><br/>}</span></pre><ul class=""><li id="a0a4" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">添加配置块—唯一必需的重要字段是inputSpec、generatorName和library</li></ul><pre class="je jf jg jh fd mi mj mk ml aw mm bi"><span id="4464" class="mn jv hi mj b fi mo mp l mq mr">openApiGenerate {<br/><strong class="mj hj">    generatorName = "java"</strong><br/><strong class="mj hj">    inputSpec = "$rootDir/infrastructure/openapi-spec.yml"</strong><br/>    outputDir = "$projectDir"<br/>    apiPackage = "com.connor.reading.client"<br/>    modelPackage = "com.connor.reading.client.dto"<br/>    configOptions = [<br/>            dateLibrary: "java8",<br/>            generateBuilders: "true",<br/><strong class="mj hj">            library: "native",</strong><br/>            useRuntimeException: "true",<br/>            generatePom: "false",<br/>            sourceFolder: "build/generated/sources/" <br/>    ]<br/>}</span></pre><ul class=""><li id="4baa" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">添加生成的*代码中使用的依赖项</li></ul><pre class="je jf jg jh fd mi mj mk ml aw mm bi"><span id="7a9c" class="mn jv hi mj b fi mo mp l mq mr">dependencies {<br/>    implementation "com.fasterxml.jackson.core:jackson-core:$jacksonVersion"<br/>    implementation "com.fasterxml.jackson.core:jackson-annotations:$jacksonVersion"<br/>    implementation "com.fasterxml.jackson.core:jackson-databind:$jacksonVersion"<br/>    implementation "com.fasterxml.jackson.datatype:jackson-datatype-jsr310:$jacksonVersion"<br/>    implementation "org.openapitools:jackson-databind-nullable:$jacksonDatabindVersion"<br/>    implementation "com.google.code.findbugs:jsr305:$findBugsVersion"<br/>    implementation "io.swagger:swagger-annotations:$swaggerAnnotationsVersion"<br/>}</span></pre><ul class=""><li id="37c2" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">将生成的代码添加到类路径中—检查编译并允许使用它</li></ul><pre class="je jf jg jh fd mi mj mk ml aw mm bi"><span id="111c" class="mn jv hi mj b fi mo mp l mq mr">sourceSets.main.java.srcDirs += "$outputDir"</span></pre><ul class=""><li id="fba7" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">使生成在代码编译之前运行，这样如果生成的代码中有任何错误，项目将不会编译</li></ul><pre class="je jf jg jh fd mi mj mk ml aw mm bi"><span id="dd93" class="mn jv hi mj b fi mo mp l mq mr">tasks.compileJava.dependsOn tasks.openApiGenerate</span></pre><ul class=""><li id="87e0" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">(可选)更新<a class="ae jt" href="https://gitlab.com/connorbutch/reading-comprehension/-/blob/master/reading-comprehension-client/.openapi-generator-ignore" rel="noopener ugc nofollow" target="_blank">。openapi-generator-ignore </a>防止生成额外的文件</li></ul><h1 id="8d30" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">最后结果</h1><p id="bdc8" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">完整的build.gradle如下所示(在gitlab <a class="ae jt" href="https://gitlab.com/connorbutch/reading-comprehension/-/blob/master/reading-comprehension-client/build.gradle" rel="noopener ugc nofollow" target="_blank">这里</a>)至此，您已经完成了设置代码生成所需的所有工作(下一节将展示如何运行它)</p><pre class="je jf jg jh fd mi mj mk ml aw mm bi"><span id="1bac" class="mn jv hi mj b fi mo mp l mq mr">plugins {<br/>    id "java-library"<br/>    id "org.openapi.generator" version "4.3.1"<br/>}<br/><br/>ext{<br/>    findBugsVersion = "3.0.2"<br/>    jacksonDatabindVersion = "0.2.1"<br/>    jacksonVersion = "2.9.9"<br/>    openApiGeneratorVersion = "4.3.1"<br/>    swaggerAnnotationsVersion = "1.5.22"<br/><br/>    outputDir = "build/generated/sources/"<br/>}<br/><br/>sourceCompatibility = 11<br/>targetCompatibility = 11<br/><br/>sourceSets.main.java.srcDirs += "$outputDir"<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencies {<br/>    implementation "com.fasterxml.jackson.core:jackson-core:$jacksonVersion"<br/>    implementation "com.fasterxml.jackson.core:jackson-annotations:$jacksonVersion"<br/>    implementation "com.fasterxml.jackson.core:jackson-databind:$jacksonVersion"<br/>    implementation "com.fasterxml.jackson.datatype:jackson-datatype-jsr310:$jacksonVersion"<br/>    implementation "org.openapitools:jackson-databind-nullable:$jacksonDatabindVersion"<br/>    implementation "com.google.code.findbugs:jsr305:$findBugsVersion"<br/>    implementation "io.swagger:swagger-annotations:$swaggerAnnotationsVersion"<br/>}<br/><br/>task deleteExtraGeneratedDirectories(type: Delete) {<br/>    delete ".openapi-generator"<br/>    delete "api"<br/>    delete "src"<br/>}<br/><br/>tasks.deleteExtraGeneratedDirectories.dependsOn tasks.openApiGenerate<br/>compileJava.dependsOn tasks.deleteExtraGeneratedDirectories<br/><br/>openApiGenerate {<br/>    generatorName = "java"<br/>    inputSpec = "$rootDir/infrastructure/openapi-spec.yml"<br/>    outputDir = "$projectDir"<br/>    apiPackage = "com.connor.reading.client"<br/>    modelPackage = "com.connor.reading.client.dto"<br/>    configOptions = [<br/>            dateLibrary: "java8",<br/>            generateBuilders: "true",<br/>            library: "native",<br/>            useRuntimeException: "true",<br/>            generatePom: "false",<br/>            sourceFolder: "build/generated/sources/" <br/>    ]<br/>}</span></pre><h2 id="d48b" class="mn jv hi bd jw ms mt mu ka mv mw mx ke iq my mz ki iu na nb km iy nc nd kq ne bi translated">其他强调点</h2><p id="a9ce" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在生成代码时，我有一些建议，如下所示:</p><ul class=""><li id="f1b5" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated">生成客户端，因为它是<strong class="ih hj">自己的jar — </strong>这允许消费者轻松地将客户端包含在他们的项目中</li><li id="173b" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated"><strong class="ih hj">生成到构建目录</strong>，它通过。<a class="ae jt" href="https://git-scm.com/docs/gitignore" rel="noopener ugc nofollow" target="_blank">git ignore</a>——这将避免它被登记到git中(并且不会出现在pull请求中)，并且它可以从静态代码分析和单元测试覆盖中排除</li><li id="768a" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated"><strong class="ih hj">在您的功能测试中使用生成的客户端</strong>——这确保了您提供给客户端的sdk是有效的(并且您必须测试您部署的服务)</li><li id="38d6" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated"><strong class="ih hj">发布jar</strong>——然后让你的客户使用它(就像aws、salesforce、okta和其他行业领导者一样)</li><li id="143f" class="le lf hi ih b ii ln im lo iq lp iu lq iy lr jc lj lk ll lm bi translated"><strong class="ih hj">修改生成的(java)代码没有任何作用</strong>——它将被构建过程重写。如果您想对此进行修改，请修改小胡子模板(参见本系列的下一篇文章)</li></ul></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h2 id="6f8e" class="mn jv hi bd jw ms mt mu ka mv mw mx ke iq my mz ki iu na nb km iy nc nd kq ne bi translated">让我们看看它的实际效果吧！</h2><p id="0ae9" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">当您运行gradle build时，将为open api规范中描述的端点生成模型和客户端的java文件(通过插件中的<em class="la"> openApiGenerate </em>任务)。这显示在下面的视频。请注意，构建目录并不存在，在我运行构建之后，目录存在了，它包含模型(对于成功和错误响应)以及我们可以用来调用端点的客户端。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nf"><img src="../Images/40e52b79c10380f007caf572d9c8dc56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*HKvo6aHFNi7qEtrn2b3c6w.gif"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">此视频显示了代码生成过程(第一个文件是生成的成功响应，第二个是生成的错误响应，第三个是生成的客户端)</figcaption></figure><h2 id="c290" class="mn jv hi bd jw ms mt mu ka mv mw mx ke iq my mz ki iu na nb km iy nc nd kq ne bi translated">使用</h2><p id="3000" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在我们已经有了生成的客户端和模型，剩下唯一要做的事情就是使用它:</p><ul class=""><li id="fffe" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated"><a class="ae jt" href="https://gitlab.com/connorbutch/reading-comprehension/-/blob/master/reading-comprehension-server-quarkus-impl/src/acceptance-test/java/com/connor/reading/util/ClientBuilder.java#L34" rel="noopener ugc nofollow" target="_blank">通过指定主机(和其他可选字段)获得生成的客户端</a>的实例</li></ul><pre class="je jf jg jh fd mi mj mk ml aw mm bi"><span id="375e" class="mn jv hi mj b fi mo mp l mq mr"><strong class="mj hj">String host = getHost(); //get the host from service discovery</strong><br/>ApiClient apiClient = new ApiClient()<br/>        .setScheme(<em class="la">SCHEME</em>) //http or https<br/>        .setHost(host) //i.e. dev.mycompany.com<br/>        .setPort(<em class="la">PORT</em>); //http or https port (8080 or 443) <br/>return new AssessmentsApi(apiClient);</span></pre><ul class=""><li id="af50" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated"><a class="ae jt" href="https://gitlab.com/connorbutch/reading-comprehension/-/blob/master/reading-comprehension-server-quarkus-impl/src/acceptance-test/java/com/connor/reading/add/RunAddAssessmentIT.java#L117" rel="noopener ugc nofollow" target="_blank">在客户端调用适当的方法并使用响应</a>(包含响应体、响应头等)</li></ul><pre class="je jf jg jh fd mi mj mk ml aw mm bi"><span id="afe9" class="mn jv hi mj b fi mo mp l mq mr">responseBody = assessmentsApi.getAssessmentByIsbn(isbnUsedInRequest);</span></pre><ul class=""><li id="1da5" class="le lf hi ih b ii ij im in iq lg iu lh iy li jc lj lk ll lm bi translated"><a class="ae jt" href="https://gitlab.com/connorbutch/reading-comprehension/-/blob/master/reading-comprehension-server-quarkus-impl/src/acceptance-test/java/com/connor/reading/add/RunAddAssessmentIT.java#L120" rel="noopener ugc nofollow" target="_blank">捕捉ApiException </a>并使用它来检查状态代码、响应正文、失败时的标题</li></ul><pre class="je jf jg jh fd mi mj mk ml aw mm bi"><span id="5d68" class="mn jv hi mj b fi mo mp l mq mr">try{<br/>    responseBody = assessmentsApi.getAssessmentByIsbn(isbnUsedInRequest);<br/>    scenario.log("Successfully made request (and got response with 2xx status code)");<br/>}catch (ApiException e){<br/>    exceptionThrownOnNonSuccess = e;<br/>    scenario.log("Exception thrown when making request (NOTE: doesn't mean bad, if running negative tests this is actually expected behavior).  The response body was " + <strong class="mj hj">e.getResponseBody()</strong>);<br/>}</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mh"><img src="../Images/b0ff207cb27bd7cf67e2c3c4dcef4a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQfRJ769wl6Hjqe_ds0YpA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">您可以从抛出的api异常中获得http状态代码、响应正文和响应头</figcaption></figure></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><h1 id="a661" class="ju jv hi bd jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr bi translated">结论</h1><p id="e876" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们已经认识到，不根据规范生成代码的过程是低效的、不准确的，并且难以扩展。我们已经改进了这些缺点，使我们的服务100%符合我们的合同，节省了大量时间，并允许我们通过为通过OpenAPI规范定义的RESTful服务生成全功能客户端(和模型),轻松扩展现有功能并在团队间共享最佳实践。这在我们的build.gradle中只需要10-20行代码，生成模型和客户端只需要几秒钟。</p><p id="39ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们在功能测试中使用这个客户端库，然后将它分发给任意数量的消费者使用。这减轻了压力，并允许工程师专注于编写业务逻辑。</p><p id="1bcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请继续关注<a class="ae jt" rel="noopener" href="/@connorbutch/enhancing-openapi-code-generation-with-custom-features-58d38e38222">系列的下一部分</a>，在那里我将向您展示<em class="la">如何修改代码生成模板(存储在mustache文件中)来定制生成的代码，以自动重试失败的呼叫(4xx响应除外)</em>。</p><h1 id="1cc2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">相关链接</h1><p id="f449" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><a class="ae jt" rel="noopener" href="/@connorbutch/enhancing-openapi-code-generation-with-custom-features-58d38e38222">https://medium . com/@ Connor butch/enhancing-open API-code-generation-with-custom-features-58d 38 e 38222</a></p><div class="ng nh ez fb ni nj"><a href="https://gitlab.com/connorbutch/reading-comprehension/-/tree/master" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hj fi z dy no ea eb np ed ef hh bi translated">档案大师康纳·布奇/阅读理解</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">GitLab.com</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">gitlab.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jn nj"/></div></div></a></div><div class="ng nh ez fb ni nj"><a href="https://openapi-generator.tech/docs/plugins/" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hj fi z dy no ea eb np ed ef hh bi translated">OpenAPI生成器从OpenAPI 2.0/3.x文档生成客户端、服务器和文档</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">将一个支持OpenAPI生成器项目的Maven插件添加到您的build-&gt;plugins部分(默认阶段是…</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">openapi-generator.tech</p></div></div></div></a></div><div class="ng nh ez fb ni nj"><a rel="noopener follow" target="_blank" href="/codex/successful-microservice-architecture-eda2adee67f8"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hj fi z dy no ea eb np ed ef hh bi translated">成功的微服务架构</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">如何在设计涉及同步调用的实时系统时取得成功？</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">medium.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx jn nj"/></div></div></a></div><div class="ng nh ez fb ni nj"><a href="https://aws.plainenglish.io/stop-making-synchronous-calls-f101af15cd46" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hj fi z dy no ea eb np ed ef hh bi translated">停止同步呼叫！</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">为什么同步调用会破坏你的架构</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">aws .平原英语. io</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx jn nj"/></div></div></a></div></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><p id="5b8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">*如果您想知道要包含哪些版本，请暂时从open api generator ignore文件中删除pom.xml，运行一个构建，从那里复制依赖项，然后删除pom文件</p></div></div>    
</body>
</html>