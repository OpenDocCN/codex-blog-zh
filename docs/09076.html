<html>
<head>
<title>How does ShardingSphere’s Show processlist &amp; Kill Work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ShardingSphere的Show processlist &amp; Kill是如何工作的？</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-does-shardingspheres-show-processlist-kill-work-6bfad30b6687?source=collection_archive---------18-----------------------#2022-09-22">https://medium.com/codex/how-does-shardingspheres-show-processlist-kill-work-6bfad30b6687?source=collection_archive---------18-----------------------#2022-09-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="989d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于经常使用数据库的人来说，您可能想知道:</p><p id="1c5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.如何检查数据库当前正在执行什么SQL，以及处于什么状态？</p><p id="5e2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.如何终止异常SQL？例如，如果一个用于查询包含大量数据的表的<code class="du jd je jf jg b">SELECT</code>语句不包含查询条件，它将会降低整个数据库的性能。这可能会促使想要终止这个异常的SQL。</p><p id="a73a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">针对以上问题，<a class="ae jh" href="https://shardingsphere.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache ShardingSphere </a>引入了<code class="du jd je jf jg b">Show processlist</code>、<code class="du jd je jf jg b">Kill &lt;processID&gt;</code>等功能。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/0f1658df9892dcd2e0cdb470d8d0ee9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xs4XXyTqJgCfZy9Y2aSV7Q@2x.png"/></div></div></figure><h2 id="708b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">1.介绍</h2><p id="002e" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated"><code class="du jd je jf jg b">Show processlist</code>:该命令可以显示ShardingSphere当前正在执行的SQL列表以及每条SQL的执行进度。如果ShardingSphere是以集群模式部署的，<code class="du jd je jf jg b">Show processlist</code>函数会聚合集群中所有代理实例运行的SQL，然后显示结果，这样您就可以随时看到当时所有正在运行的SQL。</p><pre class="jj jk jl jm fd ku jg kv kw aw kx bi"><span id="0688" class="ju jv hi jg b fi ky kz l la lb">mysql&gt; show processlist \G;<br/>*************************** 1. row ***************************<br/>     Id: 82a67f254959e0a0807a00f3cd695d87<br/>   User: root<br/>   Host: 10.200.79.156<br/>     db: root<br/>Command: Execute<br/>   Time: 19<br/>  State: Executing 0/1<br/>   Info: update t_order set version = 456<br/>1 row in set (0.24 sec)</span></pre><p id="4f6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">Kill &lt;processID&gt;</code>:该命令基于<code class="du jd je jf jg b">Show processlist</code>执行，可以终止<code class="du jd je jf jg b">Show processlist</code>中列出的正在运行的SQL。</p><pre class="jj jk jl jm fd ku jg kv kw aw kx bi"><span id="2b89" class="ju jv hi jg b fi ky kz l la lb">mysql&gt; kill 82a67f254959e0a0807a00f3cd695d87;<br/>Query OK, 0 rows affected (0.17 sec)</span></pre><h2 id="754f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">2.它们是如何工作的？</h2><p id="4e35" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">现在您已经了解了<code class="du jd je jf jg b">Show processlist</code>和<code class="du jd je jf jg b">Kill &lt;processID&gt;</code>的功能，让我们来看看这两个命令是如何工作的。由于<code class="du jd je jf jg b">Kill &lt;processID&gt;</code>背后的工作原理与<code class="du jd je jf jg b">Show processlist</code>相似，我们将重点解释<code class="du jd je jf jg b">Show processlist</code>。</p><h2 id="1e49" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">2.1 SQL是如何保存和销毁的？</h2><p id="5732" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在ShardingSphere中执行的每个SQL都将生成一个<code class="du jd je jf jg b">ExecutionGroupContext</code>对象。该对象包含关于该SQL的所有信息，其中有一个<code class="du jd je jf jg b">executionID</code>字段确保其唯一性。</p><p id="d390" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当ShardingSphere接收到SQL命令时，调用<code class="du jd je jf jg b">GovernanceExecuteProcessReporter# report</code>将<code class="du jd je jf jg b">ExecutionGroupContext</code>信息存储到<code class="du jd je jf jg b">ConcurrentHashMap </code>的缓存中(目前只支持MySQL的DML和DDL语句；以后的版本将支持其他类型的数据库。查询语句也归入DML)。</p><pre class="jj jk jl jm fd ku jg kv kw aw kx bi"><span id="3277" class="ju jv hi jg b fi ky kz l la lb">public final class GovernanceExecuteProcessReporter implements ExecuteProcessReporter {<br/>    <br/>    @Override<br/>    public void report(final QueryContext queryContext, final ExecutionGroupContext&lt;? extends SQLExecutionUnit&gt; executionGroupContext,<br/>                       final ExecuteProcessConstants constants, final EventBusContext eventBusContext) {<br/>        ExecuteProcessContext executeProcessContext = new ExecuteProcessContext(queryContext.getSql(), executionGroupContext, constants);<br/>        ShowProcessListManager.getInstance().putProcessContext(executeProcessContext.getExecutionID(), executeProcessContext);<br/>        ShowProcessListManager.getInstance().putProcessStatement(executeProcessContext.getExecutionID(), executeProcessContext.getProcessStatements());<br/>    }<br/>}</span><span id="4f6d" class="ju jv hi jg b fi lc kz l la lb">@NoArgsConstructor(access = AccessLevel.PRIVATE)<br/>public final class ShowProcessListManager {<br/>    <br/>    private static final ShowProcessListManager INSTANCE = new ShowProcessListManager();<br/>    <br/>    @Getter<br/>    private final Map&lt;String, ExecuteProcessContext&gt; processContexts = new ConcurrentHashMap&lt;&gt;();<br/>    <br/>    @Getter<br/>    private final Map&lt;String, Collection&lt;Statement&gt;&gt; processStatements = new ConcurrentHashMap&lt;&gt;();<br/> <br/>    public static ShowProcessListManager getInstance() {<br/>        return INSTANCE;<br/>    }<br/>    <br/>    public void putProcessContext(final String executionId, final ExecuteProcessContext processContext) {<br/>        processContexts.put(executionId, processContext);<br/>    }<br/>    <br/>    public void putProcessStatement(final String executionId, final Collection&lt;Statement&gt; statements) {<br/>        if (statements.isEmpty()) {<br/>            return;<br/>        }<br/>        processStatements.put(executionId, statements);<br/>    }<br/>}</span></pre><p id="c043" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上图所示，<code class="du jd je jf jg b">ShowProcessListManager</code>类有两个缓存映射，分别是<code class="du jd je jf jg b">processContexts</code>和<code class="du jd je jf jg b">processStatements</code>。前者存储了<code class="du jd je jf jg b">executionID</code>和<code class="du jd je jf jg b">ExecuteProcessContext</code>之间的映射。</p><p id="33ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">后者包含<code class="du jd je jf jg b">executionID</code>和<code class="du jd je jf jg b">Statement objects</code>之间的映射，这可能会在SQL被覆盖后生成多个语句。</p><p id="89fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次ShardingSphere接收到一个SQL语句，SQL信息就会被缓存到这两个映射中。SQL执行后，地图的缓存将被删除。</p><pre class="jj jk jl jm fd ku jg kv kw aw kx bi"><span id="2e3e" class="ju jv hi jg b fi ky kz l la lb">@RequiredArgsConstructor<br/>public final class ProxyJDBCExecutor {<br/>    <br/>    private final String type;<br/>    <br/>    private final ConnectionSession connectionSession;<br/>    <br/>    private final JDBCDatabaseCommunicationEngine databaseCommunicationEngine;<br/>    <br/>    private final JDBCExecutor jdbcExecutor;<br/>    <br/>    public List&lt;ExecuteResult&gt; execute(final QueryContext queryContext, final ExecutionGroupContext&lt;JDBCExecutionUnit&gt; executionGroupContext,<br/>                                       final boolean isReturnGeneratedKeys, final boolean isExceptionThrown) throws SQLException {<br/>        try {<br/>            MetaDataContexts metaDataContexts = ProxyContext.getInstance().getContextManager().getMetaDataContexts();<br/>            EventBusContext eventBusContext = ProxyContext.getInstance().getContextManager().getInstanceContext().getEventBusContext();<br/>            ShardingSphereDatabase database = metaDataContexts.getMetaData().getDatabase(connectionSession.getDatabaseName());<br/>            DatabaseType protocolType = database.getProtocolType();<br/>            DatabaseType databaseType = database.getResource().getDatabaseType();<br/>            ExecuteProcessEngine.initialize(queryContext, executionGroupContext, eventBusContext);<br/>            SQLStatementContext&lt;?&gt; context = queryContext.getSqlStatementContext();<br/>            List&lt;ExecuteResult&gt; result = jdbcExecutor.execute(executionGroupContext,<br/>                    ProxyJDBCExecutorCallbackFactory.newInstance(type, protocolType, databaseType, context.getSqlStatement(), databaseCommunicationEngine, isReturnGeneratedKeys, isExceptionThrown,<br/>                            true),<br/>                    ProxyJDBCExecutorCallbackFactory.newInstance(type, protocolType, databaseType, context.getSqlStatement(), databaseCommunicationEngine, isReturnGeneratedKeys, isExceptionThrown,<br/>                            false));<br/>            ExecuteProcessEngine.finish(executionGroupContext.getExecutionID(), eventBusContext);<br/>            return result;<br/>        } finally {<br/>            ExecuteProcessEngine.clean();<br/>        }<br/>    }</span></pre><p id="7b5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上所示，<code class="du jd je jf jg b">ExecuteProcessEngine.initialize(queryContext, executionGroupContext, eventBusContext);</code>将把SQL信息存储在两个缓存映射中。最后，代码块中的<code class="du jd je jf jg b">ExecuteProcessEngine.clean();</code>将清除缓存中的地图。</p><p id="68cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">Show processlist</code>中显示的SQL是从<code class="du jd je jf jg b">processContexts</code>中获得的。但是这个地图只是一个本地缓存。如果ShardingSphere部署在集群模式下，<code class="du jd je jf jg b">Show processlist</code>如何获取集群中其他机器上运行的SQL？让我们看看ShardingSphere是如何处理的。</p><h2 id="8c0a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">2.2<code class="du jd je jf jg b">Show processlist</code>是如何工作的？</h2><p id="1351" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">当ShardingSphere接收到<code class="du jd je jf jg b">Show process</code>命令时，它被发送到执行器<code class="du jd je jf jg b">ShowProcessListExecutor#execute</code>进行处理。<code class="du jd je jf jg b">getQueryResult()</code>的实施是重点。</p><pre class="jj jk jl jm fd ku jg kv kw aw kx bi"><span id="24a3" class="ju jv hi jg b fi ky kz l la lb">public final class ShowProcessListExecutor implements DatabaseAdminQueryExecutor {<br/>    <br/>    private Collection&lt;String&gt; batchProcessContexts;<br/>    <br/>    @Getter<br/>    private QueryResultMetaData queryResultMetaData;<br/>    <br/>    @Getter<br/>    private MergedResult mergedResult;<br/>    <br/>    public ShowProcessListExecutor() {<br/>        ProxyContext.getInstance().getContextManager().getInstanceContext().getEventBusContext().register(this);<br/>    }<br/>    <br/>    @Subscribe<br/>    public void receiveProcessListData(final ShowProcessListResponseEvent event) {<br/>        batchProcessContexts = event.getBatchProcessContexts();<br/>    }<br/>    <br/>    @Override<br/>    public void execute(final ConnectionSession connectionSession) {<br/>        queryResultMetaData = createQueryResultMetaData();<br/>        mergedResult = new TransparentMergedResult(getQueryResult());<br/>    }<br/>    <br/>    private QueryResult getQueryResult() {<br/>        ProxyContext.getInstance().getContextManager().getInstanceContext().getEventBusContext().post(new ShowProcessListRequestEvent());<br/>        if (null == batchProcessContexts || batchProcessContexts.isEmpty()) {<br/>            return new RawMemoryQueryResult(queryResultMetaData, Collections.emptyList());<br/>        }<br/>        Collection&lt;YamlExecuteProcessContext&gt; processContexts = new LinkedList&lt;&gt;();<br/>        for (String each : batchProcessContexts) {<br/>            processContexts.addAll(YamlEngine.unmarshal(each, BatchYamlExecuteProcessContext.class).getContexts());<br/>        }<br/>        List&lt;MemoryQueryResultDataRow&gt; rows = processContexts.stream().map(processContext -&gt; {<br/>            List&lt;Object&gt; rowValues = new ArrayList&lt;&gt;(8);<br/>            rowValues.add(processContext.getExecutionID());<br/>            rowValues.add(processContext.getUsername());<br/>            rowValues.add(processContext.getHostname());<br/>            rowValues.add(processContext.getDatabaseName());<br/>            rowValues.add("Execute");<br/>            rowValues.add(TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - processContext.getStartTimeMillis()));<br/>            int processDoneCount = processContext.getUnitStatuses().stream().map(each -&gt; ExecuteProcessConstants.EXECUTE_STATUS_DONE == each.getStatus() ? 1 : 0).reduce(0, Integer::sum);<br/>            String statePrefix = "Executing ";<br/>            rowValues.add(statePrefix + processDoneCount + "/" + processContext.getUnitStatuses().size());<br/>            String sql = processContext.getSql();<br/>            if (null != sql &amp;&amp; sql.length() &gt; 100) {<br/>                sql = sql.substring(0, 100);<br/>            }<br/>            rowValues.add(null != sql ? sql : "");<br/>            return new MemoryQueryResultDataRow(rowValues);<br/>        }).collect(Collectors.toList());<br/>        return new RawMemoryQueryResult(queryResultMetaData, rows);<br/>    }<br/>    <br/>    private QueryResultMetaData createQueryResultMetaData() {<br/>        List&lt;RawQueryResultColumnMetaData&gt; columns = new ArrayList&lt;&gt;();<br/>        columns.add(new RawQueryResultColumnMetaData("", "Id", "Id", Types.VARCHAR, "VARCHAR", 20, 0));<br/>        columns.add(new RawQueryResultColumnMetaData("", "User", "User", Types.VARCHAR, "VARCHAR", 20, 0));<br/>        columns.add(new RawQueryResultColumnMetaData("", "Host", "Host", Types.VARCHAR, "VARCHAR", 64, 0));<br/>        columns.add(new RawQueryResultColumnMetaData("", "db", "db", Types.VARCHAR, "VARCHAR", 64, 0));<br/>        columns.add(new RawQueryResultColumnMetaData("", "Command", "Command", Types.VARCHAR, "VARCHAR", 64, 0));<br/>        columns.add(new RawQueryResultColumnMetaData("", "Time", "Time", Types.VARCHAR, "VARCHAR", 10, 0));<br/>        columns.add(new RawQueryResultColumnMetaData("", "State", "State", Types.VARCHAR, "VARCHAR", 64, 0));<br/>        columns.add(new RawQueryResultColumnMetaData("", "Info", "Info", Types.VARCHAR, "VARCHAR", 120, 0));<br/>        return new RawQueryResultMetaData(columns);<br/>    }<br/>}</span></pre><p id="7824" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将使用<code class="du jd je jf jg b">guava</code>包的<code class="du jd je jf jg b">EventBus</code>函数，它是一个信息发布/订阅数据库，是<a class="ae jh" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者模式</a>的一个优雅实现。<code class="du jd je jf jg b">EventBus</code>将类相互解耦，你将在下面找到更多关于它的内容。</p><p id="aa60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">getQueryResult()</code>法必贴<code class="du jd je jf jg b">ShowProcessListRequestEvent</code>。<code class="du jd je jf jg b">ProcessRegistrySubscriber#loadShowProcessListData</code>使用<code class="du jd je jf jg b">@Subscribe</code>注释来订阅事件。</p><p id="81f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个方法是实现<code class="du jd je jf jg b">Show processlist</code>的核心。接下来，我们将介绍这种方法的具体步骤。</p><pre class="jj jk jl jm fd ku jg kv kw aw kx bi"><span id="b7d1" class="ju jv hi jg b fi ky kz l la lb">public final class ProcessRegistrySubscriber {    <br/>    @Subscribe<br/>    public void loadShowProcessListData(final ShowProcessListRequestEvent event) {<br/>        String processListId = new UUID(ThreadLocalRandom.current().nextLong(), ThreadLocalRandom.current().nextLong()).toString().replace("-", "");<br/>        boolean triggerIsComplete = false;<br/>        <em class="ld">// 1. Obtain the Process List path of all existing proxy nodes in cluster mode</em><br/>        Collection&lt;String&gt; triggerPaths = getTriggerPaths(processListId);<br/>        try {<br/>            <em class="ld">// 2. Iterate through the path and write an empty string to the node, to trigger the node monitoring.</em><br/>            triggerPaths.forEach(each -&gt; repository.persist(each, ""));<br/>            <em class="ld">// 3. Lock and wait 5 seconds for each node to write the information of currently running SQL to the persistence layer. </em><br/>            triggerIsComplete = waitAllNodeDataReady(processListId, triggerPaths);<br/>            <em class="ld">// 4. Fetch and aggregate the data written by each proxy node from the persistence layer. Then EventBus will post a ShowProcessListResponseEvent command, which means the operation is completed.</em><br/>            sendShowProcessList(processListId);<br/>        } finally {<br/>            <em class="ld">// 5. Delete resources</em><br/>            repository.delete(ProcessNode.getProcessListIdPath(processListId));<br/>            if (!triggerIsComplete) {<br/>                triggerPaths.forEach(repository::delete);<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="8166" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它包括五个步骤，第二和第三步是重点。</p><h2 id="0003" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">2.2.1步骤2:集群获取数据实现</h2><p id="4df0" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在这一步中，一个空字符串将被写入节点<code class="du jd je jf jg b">/nodes/compute_nodes/process_trigger/&lt;instanceId&gt;:&lt;processlistId&gt;</code>，这将触发ShardingSphere的监控逻辑。</p><p id="062e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当ShardingSphere启动后，持久层会<code class="du jd je jf jg b">watch</code>去监控一系列的路径变化，比如路径<code class="du jd je jf jg b">/nodes/compute_nodes</code>的添加、删除、修改操作。</p><p id="946d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，监控是一个异步过程，主线程不会阻塞，因此需要步骤3来锁定并等待每个ShardingSphere节点将其当前运行的SQL信息写入持久层。</p><p id="40c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看ShardingSphere是如何处理监控逻辑的。</p><pre class="jj jk jl jm fd ku jg kv kw aw kx bi"><span id="0cfe" class="ju jv hi jg b fi ky kz l la lb">public final class ComputeNodeStateChangedWatcher implements GovernanceWatcher&lt;GovernanceEvent&gt; {<br/>    <br/>    @Override<br/>    public Collection&lt;String&gt; getWatchingKeys(final String databaseName) {<br/>        return Collections.singleton(ComputeNode.getComputeNodePath());<br/>    }<br/>    <br/>    @Override<br/>    public Collection&lt;Type&gt; getWatchingTypes() {<br/>        return Arrays.asList(Type.ADDED, Type.UPDATED, Type.DELETED);<br/>    }<br/>    <br/>    @SuppressWarnings("unchecked")<br/>    @Override<br/>    public Optional&lt;GovernanceEvent&gt; createGovernanceEvent(final DataChangedEvent event) {<br/>        String instanceId = ComputeNode.getInstanceIdByComputeNode(event.getKey());<br/>        if (!Strings.isNullOrEmpty(instanceId)) {<br/>            ...<br/>        } else if (event.getKey().startsWith(ComputeNode.getOnlineInstanceNodePath())) {<br/>            return createInstanceEvent(event);<br/>            <em class="ld">// show processlist</em><br/>        } else if (event.getKey().startsWith(ComputeNode.getProcessTriggerNodePatch())) {<br/>            return createShowProcessListTriggerEvent(event);<br/>            <em class="ld">// kill processlistId</em><br/>        } else if (event.getKey().startsWith(ComputeNode.getProcessKillNodePatch())) {<br/>            return createKillProcessListIdEvent(event);<br/>        }<br/>        return Optional.empty();<br/>    }<br/>    <br/>        <br/>    private Optional&lt;GovernanceEvent&gt; createShowProcessListTriggerEvent(final DataChangedEvent event) {<br/>        Matcher matcher = getShowProcessTriggerMatcher(event);<br/>        if (!matcher.find()) {<br/>            return Optional.empty();<br/>        }<br/>        if (Type.ADDED == event.getType()) {<br/>            return Optional.of(new ShowProcessListTriggerEvent(matcher.group(1), matcher.group(2)));<br/>        }<br/>        if (Type.DELETED == event.getType()) {<br/>            return Optional.of(new ShowProcessListUnitCompleteEvent(matcher.group(2)));<br/>        }<br/>        return Optional.empty();<br/>    }<br/>}</span></pre><p id="a8d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">ComputeNodeStateChangedWatcher#createGovernanceEvent</code>监测到信息后，会根据路径区分创建哪个事件。</p><p id="992d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如上面的代码所示，这是一个新的节点，所以<code class="du jd je jf jg b">ShowProcessListTriggerEvent</code>将被发布。由于每个ShardingSphere实例将监控<code class="du jd je jf jg b">/nodes/compute_nodes</code>，每个实例将处理<code class="du jd je jf jg b">ShowProcessListTriggerEvent</code>。</p><p id="9428" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，单机加工转化为集群加工。让我们看看ShardingSphere是如何处理它的。</p><pre class="jj jk jl jm fd ku jg kv kw aw kx bi"><span id="3971" class="ju jv hi jg b fi ky kz l la lb">public final class ClusterContextManagerCoordinator {</span><span id="9839" class="ju jv hi jg b fi lc kz l la lb">    @Subscribe<br/>    public synchronized void triggerShowProcessList(final ShowProcessListTriggerEvent event) {<br/>        if (!event.getInstanceId().equals(contextManager.getInstanceContext().getInstance().getMetaData().getId())) {<br/>            return;<br/>        }<br/>        Collection&lt;ExecuteProcessContext&gt; processContexts = ShowProcessListManager.getInstance().getAllProcessContext();<br/>        if (!processContexts.isEmpty()) {<br/>            registryCenter.getRepository().persist(ProcessNode.getProcessListInstancePath(event.getProcessListId(), event.getInstanceId()),<br/>                    YamlEngine.marshal(new BatchYamlExecuteProcessContext(processContexts)));<br/>        }<br/>        registryCenter.getRepository().delete(ComputeNode.getProcessTriggerInstanceIdNodePath(event.getInstanceId(), event.getProcessListId()));<br/>    }<br/>}</span></pre><p id="416b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">ClusterContextManagerCoordinator#triggerShowProcessList</code>将订阅<code class="du jd je jf jg b">ShowProcessListTriggerEvent</code>，其中<code class="du jd je jf jg b">processContext</code>数据自行处理。<code class="du jd je jf jg b">ShowProcessListManager.getInstance().getAllProcessContext()</code>检索当前正在运行的<code class="du jd je jf jg b">processContext</code>(这里的数据指的是ShardingSphere在每次SQL执行前存储在Map中的SQL信息，在文章开头有描述)并将其传输到持久层。如果<code class="du jd je jf jg b">/nodes/compute_nodes/process_trigger/&lt;instanceId&gt;:&lt;processlistId&gt;</code>节点被删除，则处理完成。</p><p id="ed1f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您删除该节点时，也会触发监控并发布<code class="du jd je jf jg b">ShowProcessListUnitCompleteEvent</code>。这个事件将最终唤醒挂起的锁。</p><pre class="jj jk jl jm fd ku jg kv kw aw kx bi"><span id="9485" class="ju jv hi jg b fi ky kz l la lb">public final class ClusterContextManagerCoordinator {<br/>    <br/>    @Subscribe<br/>    public synchronized void completeUnitShowProcessList(final ShowProcessListUnitCompleteEvent event) {<br/>        ShowProcessListSimpleLock simpleLock = ShowProcessListManager.getInstance().getLocks().get(event.getProcessListId());<br/>        if (null != simpleLock) {<br/>            simpleLock.doNotify();<br/>        }<br/>    }<br/>}</span></pre><h2 id="669e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">2.2.2步骤3:锁定并等待数据实现</h2><p id="6bd3" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">ShardingSphere使用<code class="du jd je jf jg b">isReady(Paths)</code>方法来确定是否已经处理了所有实例。只有当所有实例都被处理后，它才返回<code class="du jd je jf jg b">true</code>。</p><p id="c7f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据处理的最长等待时间为5秒。如果处理在5秒内没有完成，则返回<code class="du jd je jf jg b">false</code>。</p><pre class="jj jk jl jm fd ku jg kv kw aw kx bi"><span id="08ee" class="ju jv hi jg b fi ky kz l la lb">public final class ClusterContextManagerCoordinator {<br/>    <br/>    @Subscribe<br/>    public synchronized void completeUnitShowProcessList(final ShowProcessListUnitCompleteEvent event) {<br/>        ShowProcessListSimpleLock simpleLock = ShowProcessListManager.getInstance().getLocks().get(event.getProcessListId());<br/>        if (null != simpleLock) {<br/>            simpleLock.doNotify();<br/>        }<br/>    }<br/>}</span></pre><h2 id="bcd6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">2.2.3汇总<code class="du jd je jf jg b">processList</code>数据并返回</h2><p id="b26d" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在每个实例处理完数据后，接收到<code class="du jd je jf jg b">Show processlist</code>命令的实例需要聚合数据，然后显示结果。</p><pre class="jj jk jl jm fd ku jg kv kw aw kx bi"><span id="9a75" class="ju jv hi jg b fi ky kz l la lb">public final class ProcessRegistrySubscriber {  <br/>    <br/>    private void sendShowProcessList(final String processListId) {<br/>        List&lt;String&gt; childrenKeys = repository.getChildrenKeys(ProcessNode.getProcessListIdPath(processListId));<br/>        Collection&lt;String&gt; batchProcessContexts = new LinkedList&lt;&gt;();<br/>        for (String each : childrenKeys) {<br/>            batchProcessContexts.add(repository.get(ProcessNode.getProcessListInstancePath(processListId, each)));<br/>        }<br/>        eventBusContext.post(new ShowProcessListResponseEvent(batchProcessContexts));<br/>    }<br/>}</span></pre><p id="1dbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">ProcessRegistrySubscriber#sendShowProcessList</code>会将运行的SQL数据聚合到<code class="du jd je jf jg b">batchProcessContexts</code>，然后发布<code class="du jd je jf jg b">ShowProcessListResponseEvent</code>。</p><p id="29b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该事件将被<code class="du jd je jf jg b">ShowProcessListExecutor#receiveProcessListData</code>消耗，并且<code class="du jd je jf jg b">getQueryResult()</code>方法将继续显示<code class="du jd je jf jg b">queryResult</code>。</p><p id="9bf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至此，我们已经完成了<code class="du jd je jf jg b">Show processlist</code>命令的执行过程。</p><h1 id="8565" class="le jv hi bd jw lf lg lh ka li lj lk ke ll lm ln kh lo lp lq kk lr ls lt kn lu bi translated">2.3<code class="du jd je jf jg b">Kill &lt;processId&gt;</code>如何工作？</h1><p id="57ec" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated"><code class="du jd je jf jg b">Kill &lt;processId&gt;</code>与<code class="du jd je jf jg b">Show processlist</code>有相似的逻辑，那就是将<code class="du jd je jf jg b">EventBus</code>与<code class="du jd je jf jg b">watch</code>机构相结合。</p><p id="031a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们不知道<code class="du jd je jf jg b">processId</code>属于哪个SQL，所以也有必要为每个实例添加空节点。</p><p id="4764" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过<code class="du jd je jf jg b">watch</code>机制，每个ShardingSphere实例监视新节点，并检查<code class="du jd je jf jg b">processId</code>键是否在缓存映射中。如果是，获取与该键对应的值。</p><p id="374a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该值是一个<code class="du jd je jf jg b">Collection&lt;Statement&gt;</code>集合。然后你只需要迭代<code class="du jd je jf jg b">Statement</code>集合，依次调用<code class="du jd je jf jg b">statement.cancel()</code>。底层是被调用来取消SQL执行的<code class="du jd je jf jg b">java.sql.Statement#cancel()</code>方法。</p><h2 id="5079" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">3.结论</h2><p id="6f25" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">目前，Apache ShardingSphere只能为<a class="ae jh" href="https://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>方言实现<code class="du jd je jf jg b">Show processlist</code>和<code class="du jd je jf jg b">Kill &lt;processId&gt;</code>功能。</p><p id="9c3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你了解了它们是如何工作的，如果你感兴趣，欢迎你参与相关功能的开发。我们的社区非常开放，欢迎任何对开源代码感兴趣的人。</p><h2 id="e2de" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">相关链接:</h2><p id="c530" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated"><a class="ae jh" href="https://shardingsphere.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache ShardingSphere官网</a></p><p id="1782" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jh" href="https://github.com/apache/shardingsphere" rel="noopener ugc nofollow" target="_blank">Apache sharding sphere GitHub</a></p><p id="c324" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jh" href="https://apacheshardingsphere.slack.com/" rel="noopener ugc nofollow" target="_blank"> Apache ShardingSphere松弛通道</a></p><h2 id="e31d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">作者</h2><p id="5db9" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">徐阳，<a class="ae jh" href="https://www.crunchbase.com/organization/servyou-group" rel="noopener ugc nofollow" target="_blank"> Servyou Group </a>的中间件R&amp;D工程师。负责海量数据的表和数据库分片。开源爱好者和ShardingSphere贡献者。目前，他对开发ShardingSphere项目的内核模块感兴趣。</p></div></div>    
</body>
</html>