<html>
<head>
<title>Hey, leave those alone! -Application State and Function Purity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">嘿，别碰那些！-应用状态和功能纯度</h1>
<blockquote>原文：<a href="https://medium.com/codex/hey-leave-those-alone-application-state-and-function-purity-d64c285a4703?source=collection_archive---------25-----------------------#2021-08-18">https://medium.com/codex/hey-leave-those-alone-application-state-and-function-purity-d64c285a4703?source=collection_archive---------25-----------------------#2021-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b863349666981dd4ea1b73fb789dcc29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qrPRx4gu7n-hD5PhRzIG-A.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由来自<a class="ae iu" href="https://www.pexels.com/photo/clear-glass-bottle-on-table-544112/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae iu" href="https://www.pexels.com/@tirachard-kumtanom-112571?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Tirachard Kumtanom </a>拍摄</figcaption></figure><p id="32b0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你有没有遇到过这样的错误，你没有得到一个错误记录到控制台，或者你没有一个大的错误出现在你的应用程序的屏幕上</p><blockquote class="jt"><p id="0fea" class="ju jv hi bd jw jx jy jz ka kb kc js dx translated">“你好，你在index.js文件的第71行搞砸了…”</p></blockquote><p id="ffbc" class="pw-post-body-paragraph iv iw hi ix b iy kd ja jb jc ke je jf jg kf ji jj jk kg jm jn jo kh jq jr js hb bi translated">相反，你看到没有错误屏幕，没有错误日志，应用程序运行正常，但你刚刚意识到你所有的交付被发送到错误的地址，或者有一个奇怪的NGN 100被添加到所有客户的订单总数？</p><p id="4a69" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">应用状态和副作用</strong></p><p id="5ea4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">应用程序状态是指应用程序中已分配的变量的当前条件和值。所有被赋值的变量都被分配到内存中的一个小槽中(顺便说一下，在一个叫做<strong class="ix hj">堆</strong>的小地方)，它们一直在那里，直到垃圾收集发生(这在JavaScript中是自动处理的)。</p><p id="59cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">副作用是当我们的函数修改超出其自身范围的状态时，我们在应用程序中引起的变化。这实际上是告诉我们，当我们编写影响应用程序运行状态的代码时，我们会产生副作用。考虑下面的代码块</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="5287" class="kr ks hi kn b fi kt ku l kv kw">var dayOfMonth = 21 // A CONSTANT THAT HOLDS A VALUE, IN THIS INSTANCE LET US CALL IT THE DAYOFMONTH</span><span id="4e6c" class="kr ks hi kn b fi kx ku l kv kw">var logOutAndIncrementDay // A FUNCTION THAT LOGS A USER OUT AND INCREMENTS THE DATE TO BE READY TO LOG IN TOMORROW (let us assume our program allows us log in once in a day)</span><span id="4de4" class="kr ks hi kn b fi kx ku l kv kw">var payStaffDailyWage // A FUNCTION THAT PAYS EACH STAFF'S STIPEND DAILY</span><span id="0c51" class="kr ks hi kn b fi kx ku l kv kw">var incrementDate = () =&gt; dayOfMonth++;</span><span id="9497" class="kr ks hi kn b fi kx ku l kv kw">//assuming logOutAndIncrementDay and payStaffDailyWage are implemented as follows</span><span id="8a8d" class="kr ks hi kn b fi kx ku l kv kw">logOutAndIncrementDay = function (user_id) {</span><span id="0acd" class="kr ks hi kn b fi kx ku l kv kw">    return getUser(user_id).<br/>        then(logUserOut).<br/>        then(incrementDate).<br/>        catch(handleError);  //PSEUDOCODE</span><span id="9186" class="kr ks hi kn b fi kx ku l kv kw">};</span><span id="158a" class="kr ks hi kn b fi kx ku l kv kw">payStaffDailyWage = function (date) {</span><span id="2762" class="kr ks hi kn b fi kx ku l kv kw">    console.log(date);        // THIS IS THE DAY OF MONTH</span><span id="c8bd" class="kr ks hi kn b fi kx ku l kv kw">}</span><span id="148d" class="kr ks hi kn b fi kx ku l kv kw">And then we go on to call our procedures as so;</span><span id="1997" class="kr ks hi kn b fi kx ku l kv kw">logOutAndIncrementDate(user_id);</span><span id="bae5" class="kr ks hi kn b fi kx ku l kv kw">payStaffDailyWage(dayOfMonth)         // 22<br/></span></pre><p id="a740" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以清楚地看到，与我们使用相同代码库和相同变量的其他人现在面临着代码中不可预测行为的风险，因为输入现在与预期不同，这都要归功于我们在logOutAndIncrementDate过程中增加了date变量。</p><p id="dfa0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">副作用有各种形式，我们通常把函数式程序员看作是把副作用减少到几乎为零。副作用是无法避免的，因为我们的程序运行带来的副作用是CPU ram被吃掉，CPU甚至产生热量。副作用肯定会发生，因为应用程序依赖于状态变化才是有用的，否则应用程序将什么也不做，这可能不是很好。</p><p id="c1c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">副作用包括但不限于:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="de5d" class="kr ks hi kn b fi kt ku l kv kw">1. Changes in State like our logOutAndIncrementDate procedure</span><span id="9261" class="kr ks hi kn b fi kx ku l kv kw">2. Network Calls</span><span id="bc52" class="kr ks hi kn b fi kx ku l kv kw">3. I/O Operations (Disk Writes, File Writes, etc)</span><span id="2437" class="kr ks hi kn b fi kx ku l kv kw">4. Database Operations</span><span id="3cdb" class="kr ks hi kn b fi kx ku l kv kw">5. DOM Mutations among others</span></pre><p id="8652" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">必须保留应用程序状态，并且只有我们知道的更改对我们的应用程序有帮助。未跟踪的变更只是一个巨大的干草堆，让bug可以隐藏并在其中茁壮成长。</p><p id="bae4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好吧…那我为什么要在乎呢？</p><p id="c555" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我喜欢你问这个问题。我们非常关心结果，这里有一些结果，当你开始使用纯函数时，你马上就能看到。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9ca3" class="kr ks hi kn b fi kt ku l kv kw">1. Pure functions are easy to understand, maintain and debug</span><span id="c312" class="kr ks hi kn b fi kx ku l kv kw">2. Pure functions can be relied upon, and we can go to sleep without worrying about edge cases that may cause our programs to behave unpredictably, because all changes are structured.</span><span id="014d" class="kr ks hi kn b fi kx ku l kv kw">3. Pure functions are easy to test because they compute their output based on given inputs, so we can easily make assertions on them.</span><span id="3f35" class="kr ks hi kn b fi kx ku l kv kw">4. Pure functions can be <strong class="kn hj">memoized</strong>. A pure function can be replaced by its return value, due to something cool called <strong class="kn hj">REFERENTIAL TRANSPARENCY</strong>. This means the functions execution has no external footprints or effects on state, hence we can skip executing it altogether and just plug in its return value, and our app should still work fine!</span></pre><p id="f579" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">那么，什么时候一个函数被描述为纯的呢？</strong></p><p id="f139" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">功能纯度是一个相对的课题。在这个系列中，我们将检查代码块，这些代码块将指导我们理解在编写纯函数时要注意什么，并帮助介绍我们编写代码的函数方法。</p><p id="5d78" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个函数要被描述为纯函数，它的定义和执行必须满足一些标准。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="713a" class="kr ks hi kn b fi kt ku l kv kw">1. INPUT AND OUTPUT: A pure function must receive arguments, and compute the result BASED ON the arguments received, and return an output.</span><span id="fea4" class="kr ks hi kn b fi kx ku l kv kw">a. What this means is that a pure function will calculate its return value using only values that are passed in as arguments. A pure function will <strong class="kn hj">NOT REACH OUT OF ITS SCOPE</strong>, to access or reassign some <strong class="kn hj">FREE VARIABLE</strong> (variables that are floating outside the functions scope)</span><span id="8fa2" class="kr ks hi kn b fi kx ku l kv kw">Consider the following block of code</span><span id="a6a4" class="kr ks hi kn b fi kx ku l kv kw">var c = 4;</span><span id="3cb8" class="kr ks hi kn b fi kx ku l kv kw">var add = function (a,b) {</span><span id="e399" class="kr ks hi kn b fi kx ku l kv kw">     return a + b + c; // ACCESSES A FREE VARIABLE “c”, BAD</span><span id="804b" class="kr ks hi kn b fi kx ku l kv kw">}</span><span id="a0a6" class="kr ks hi kn b fi kx ku l kv kw">2. CONSISTENT RESULTS: A pure function must return the same output every time it is fed the same inputs.</span><span id="a097" class="kr ks hi kn b fi kx ku l kv kw">a. This tells us that so long as inputs don’t change, the return value of a pure function must be the same. Remember how we touched on referential transparency? A pure function returns the same input, which is why we can comfortably replace it with its return value and not have our applications explode (like Michael Bay does it).</span><span id="c211" class="kr ks hi kn b fi kx ku l kv kw">Consider the following block of code</span><span id="4a55" class="kr ks hi kn b fi kx ku l kv kw">var generateID = () =&gt; {</span><span id="88aa" class="kr ks hi kn b fi kx ku l kv kw">    return Math.random(); // OUTPUT DOES NOT CORRELATE TO INPUT, NEITHER WILL OUTPUT REMAIN THE SAME ACROSS ALL EXECUTIONS OF THIS FUNCTION, ALSO TAKES NO INPUT</span><span id="d42a" class="kr ks hi kn b fi kx ku l kv kw">}</span><span id="94b3" class="kr ks hi kn b fi kx ku l kv kw">3. SIDE EFFECTS: A pure function must not cause any observable side effect, as has been explained earlier. If a side effect is present, then the code is by definition, impure.<br/></span><span id="5ab8" class="kr ks hi kn b fi kx ku l kv kw">TRIVIA: Consider the function below, would you describe this function as pure?</span><span id="f325" class="kr ks hi kn b fi kx ku l kv kw">var giveMeNull = () =&gt; { <br/>    return null; <br/>}</span></pre><p id="2bf1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">功能纯度、强制性杂质和表面积</strong></p><p id="eefc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">副作用不可避免。这一点已经说得很清楚了，我们作为程序员也明白这一点。我们的代码将总是导致状态的变化是有用的，这显然总是一个副作用。数据库写入发生，DOM变异以呈现新数据，CPU在我们工作时消耗RAM，等等。这是我们作为程序员必须适应的事情，因为我们在代码库中找到了绕过强制性杂质的方法。</p><p id="d580" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，作为函数式程序员，我们如何与代码中的副作用共生共存呢？</p><p id="7d03" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请记住，我们可以使用一些技术来减少杂质在代码库中游荡的情况。我们今天要考虑的其中一个概念是，如果我们不能完全去除杂质，那么就去除杂质，减少杂质在我们函数中出现的表面积。抽象是面向对象编程的支柱，如果你不知道OOP的支柱，一个好的读物是<a class="ae iu" href="https://www.freecodecamp.org/news/object-oriented-programming-concepts-21bb035f7260/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">如何向一个六岁的孩子解释面向对象编程的概念</strong> </a></p><p id="2eae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">抽象不一定隐藏代码。然而，它确实允许我们在代码中执行关注点分离。这意味着，当我们编写一个函数时，我们需要理解我们可以将杂质抽象到代码库中的一个临时“容器”中，这样我们就可以从一个点管理它们。</p><p id="1eba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> YADDI，YADDI，YADDA……让我看看你在练习中所说的内容</strong></p><p id="b67b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好吧，好吧！既然你不肯放手，我们来检查一些代码，看看如何重构我们的代码，抽象出杂质，给我们可怜的函数(双关语)一些喘息的空间！</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="31cc" class="kr ks hi kn b fi kt ku l kv kw">var getUserAndRenderFullname = async (user_id) =&gt; {</span><span id="7756" class="kr ks hi kn b fi kx ku l kv kw">    let user = await getNetwork.call(user_id); // PSEUDOCODE</span><span id="7f1b" class="kr ks hi kn b fi kx ku l kv kw">    if(!user) return null; </span><span id="6471" class="kr ks hi kn b fi kx ku l kv kw">    let username = user[username];</span><span id="c3e3" class="kr ks hi kn b fi kx ku l kv kw">    let myH1 = document.createElement(‘h1’);</span><span id="b713" class="kr ks hi kn b fi kx ku l kv kw">    myH1.innerText = username;</span><span id="7407" class="kr ks hi kn b fi kx ku l kv kw">    let namespace = document.querySelector(‘#name_h1’); //ACCESSES  THE DOM</span><span id="d082" class="kr ks hi kn b fi kx ku l kv kw">    namespace.append(myH1);</span><span id="74e9" class="kr ks hi kn b fi kx ku l kv kw">    return null;</span><span id="8ffe" class="kr ks hi kn b fi kx ku l kv kw">}</span></pre><p id="5a67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码块有问题。一些已经在代码注释中指出，还有一些。</p><p id="9cfc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关注点不分离。函数式编程教导我们从“函数作为组件”的角度来处理程序，其中逻辑的每一小步都由一个单独的函数来处理，赋予每个函数一个单独的职责。</p><p id="fd99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的getUserAndRenderFullname函数至少可以分成两个独立的函数。我们可以有一个获取用户的函数getUser，还有另一个将用户名附加到DOM的函数，我们可以更进一步，将函数去专门化，只将任何文本附加到DOM！</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="3904" class="kr ks hi kn b fi kt ku l kv kw">var getUser = async (user_id) =&gt; {</span><span id="395d" class="kr ks hi kn b fi kx ku l kv kw">    let user = await makeNetworkCall(user_id);</span><span id="f214" class="kr ks hi kn b fi kx ku l kv kw">    if(!user) return null;</span><span id="2a36" class="kr ks hi kn b fi kx ku l kv kw">    return user;</span><span id="5adf" class="kr ks hi kn b fi kx ku l kv kw">}</span><span id="ab97" class="kr ks hi kn b fi kx ku l kv kw">var renderTextToDOM = (elem, position, text) =&gt; {</span><span id="0ebb" class="kr ks hi kn b fi kx ku l kv kw">    let docElement = document.createElement(`${elem}`);</span><span id="bd0c" class="kr ks hi kn b fi kx ku l kv kw">    docElement.innerText = `${text}`;</span><span id="daa4" class="kr ks hi kn b fi kx ku l kv kw">    position.append(docElement);</span><span id="148f" class="kr ks hi kn b fi kx ku l kv kw">    return null;</span><span id="6717" class="kr ks hi kn b fi kx ku l kv kw">}</span></pre><p id="543f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们可以重构代码</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="0198" class="kr ks hi kn b fi kt ku l kv kw">var user = getUser(`12345`);</span><span id="cdbe" class="kr ks hi kn b fi kx ku l kv kw">var nameH1 = document.querySelector(`#name_h1`)</span><span id="e324" class="kr ks hi kn b fi kx ku l kv kw">renderTextToDOM(`h1`, nameH1, user.name);</span></pre><p id="16bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以将我们的函数视为单个组件，我们可以理解、优化和重构这些组件，而不用担心它会破坏我们代码的另一部分……这是纯函数和函数式编程为我们开发人员提供的好处之一。</p><p id="c1b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">延伸阅读</strong></p><ol class=""><li id="4d8d" class="ky kz hi ix b iy iz jc jd jg la jk lb jo lc js ld le lf lg bi translated"><a class="ae iu" href="https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch5.md/#chapter-5-reducing-side-effects" rel="noopener ugc nofollow" target="_blank">减少副作用——凯尔·辛普森</a></li><li id="1015" class="ky kz hi ix b iy lh jc li jg lj jk lk jo ll js ld le lf lg bi translated"><a class="ae iu" href="https://www.freecodecamp.org/news/what-is-a-pure-function-in-javascript-acb887375dfe/" rel="noopener ugc nofollow" target="_blank">JavaScript中的纯函数是什么</a></li></ol></div></div>    
</body>
</html>