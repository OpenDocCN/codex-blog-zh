<html>
<head>
<title>Using gRPC and ProtoBuf in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Java中使用gRPC和ProtoBuf</h1>
<blockquote>原文：<a href="https://medium.com/codex/using-grpc-and-protobuf-in-java-f8730bb65aa7?source=collection_archive---------3-----------------------#2021-09-11">https://medium.com/codex/using-grpc-and-protobuf-in-java-f8730bb65aa7?source=collection_archive---------3-----------------------#2021-09-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/01e2532cb18c0348391d664a22726f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHyDS2r5qZnp3DYDxwD2Jw.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="b572" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh dx translated">本文是构建Web服务器系列文章<a class="ae ji" href="https://sumit-agarwal.medium.com/golang-building-a-web-server-2d34d4f90fa1" rel="noopener">的一部分</a></h2></div><p id="02f5" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">欢迎回到构建Web服务器系列。到目前为止，我们主要关注用GoLang编写web服务器。然而，有人要求我写一篇文章，介绍如何使用Java实现gRPC，以及有哪些可用的库和选项来实现相同的功能。</p><blockquote class="kf kg kh"><p id="4b22" class="jj jk ki jl b jm jn iu jo jp jq ix jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated">先决条件:基本了解<a class="ae ji" href="https://docs.spring.io/spring-framework/docs/current/reference/html/" rel="noopener ugc nofollow" target="_blank"> Spring </a>、<a class="ae ji" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>、<a class="ae ji" rel="noopener" href="/swlh/dependency-injection-in-go-using-fx-6a623c5c5e01">依赖注入</a>、<a class="ae ji" rel="noopener" href="/swlh/using-grpc-and-protobuf-in-golang-9c218d662db3"> RPC和ProtoBuf </a>。</p><p id="5a55" class="jj jk ki jl b jm jn iu jo jp jq ix jr kj jt ju jv kk jx jy jz kl kb kc kd ke hb bi translated">我们将使用spring boot来初始化一个基本服务，然后在其上添加一个RPC服务器和客户端。</p></blockquote><h1 id="fb0a" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld bi translated">编写Java gRPC服务器的步骤</h1><p id="4577" class="pw-post-body-paragraph jj jk ht jl b jm le iu jo jp lf ix jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">假设我们已经从spring <a class="ae ji" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> initlizr </a>网站生成了一个代码，项目名为<em class="ki"> grpc-server </em></p><ol class=""><li id="a516" class="lj lk ht jl b jm jn jp jq js ll jw lm ka ln ke lo lp lq lr bi translated">我们定义服务protobuf文件，并在<code class="du ls lt lu lv b">pom.xml</code>中添加所需的依赖项，以编译proto文件并生成RPC Java接口，作为构建过程的一部分。</li><li id="9c64" class="lj lk ht jl b jm lw jp lx js ly jw lz ka ma ke lo lp lq lr bi translated">接下来，我们继续编写一个基本的<code class="du ls lt lu lv b">HelloWorld</code>服务器。</li><li id="e960" class="lj lk ht jl b jm lw jp lx js ly jw lz ka ma ke lo lp lq lr bi translated">编译代码并调用RPC服务器进行测试。</li></ol><h1 id="a418" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld bi translated">1.编写原型定义</h1><p id="7306" class="pw-post-body-paragraph jj jk ht jl b jm le iu jo jp lf ix jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">Protobuf定义是语言不可知的，因此不会在我们所有可用的选项中改变。对于这个服务器示例，我们将编写一个非常基本的HelloWorld服务，如下所示:</p><pre class="mb mc md me fd mf lv mg mh aw mi bi"><span id="900b" class="mj kn ht lv b fi mk ml l mm mn">syntax = "proto3";<br/>option java_multiple_files = true;<br/>package com.test.grpc;<br/><br/>message HelloRequest {<br/>    string firstName = 1;<br/>    string lastName = 2;<br/>}<br/><br/>message HelloResponse {<br/>    string greeting = 1;<br/>}<br/><br/>service HelloService {<br/>    rpc hello(HelloRequest) returns (HelloResponse);<br/>}</span></pre><p id="e954" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">确保在<code class="du ls lt lu lv b">main</code>目录下创建这个文件，否则原型文件将不会包含在构建过程中。<code class="du ls lt lu lv b">File Path: &lt;project-root&gt;/src/main/proto/HelloService.proto</code></p><p id="13f6" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，将下面的依赖项、扩展和插件添加到<code class="du ls lt lu lv b">pom.xml</code></p><pre class="mb mc md me fd mf lv mg mh aw mi bi"><span id="5011" class="mj kn ht lv b fi mk ml l mm mn">// add the following dependency to dependencies section. This dependency helps you to run a basic GRPC server out of the box by using the io.grpc module.<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;net.devh&lt;/groupId&gt;<br/>  &lt;artifactId&gt;grpc-server-spring-boot-autoconfigure&lt;/artifactId&gt;<br/>  &lt;version&gt;2.12.0.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;</span><span id="44e5" class="mj kn ht lv b fi mo ml l mm mn">//add the following extension to build section. This extension adds OS specific logic during the protobuf compilation step.<br/>&lt;extensions&gt;<br/>  &lt;extension&gt;<br/>    &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt;<br/>    &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt;<br/>    &lt;version&gt;${os-maven-plugin.version}&lt;/version&gt;<br/>  &lt;/extension&gt;<br/>&lt;/extensions&gt;</span><span id="0eec" class="mj kn ht lv b fi mo ml l mm mn">// add the following plugin to the build section. This plugin compiles the protobuf files and adds it to the target folder.<br/>&lt;plugin&gt;<br/>  &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;<br/>  &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;<br/>  &lt;version&gt;${protobuf-maven-plugin.version}&lt;/version&gt;<br/>  &lt;configuration&gt;<br/>    &lt;protocArtifact&gt;<br/>      com.google.protobuf:protoc:3.3.0:exe:${os.detected.classifier}<br/>    &lt;/protocArtifact&gt;<br/>    &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;<br/>    &lt;pluginArtifact&gt;<br/>      io.grpc:protoc-gen-grpc-java:1.4.0:exe:${os.detected.classifier}<br/>    &lt;/pluginArtifact&gt;<br/>  &lt;/configuration&gt;<br/>  &lt;executions&gt;<br/>    &lt;execution&gt;<br/>      &lt;goals&gt;<br/>        &lt;goal&gt;compile&lt;/goal&gt;<br/>        &lt;goal&gt;compile-custom&lt;/goal&gt;<br/>      &lt;/goals&gt;<br/>    &lt;/execution&gt;<br/>  &lt;/executions&gt;<br/>&lt;/plugin&gt;</span><span id="47c0" class="mj kn ht lv b fi mo ml l mm mn">// add the following to properties section<br/>&lt;protobuf-maven-plugin.version&gt;0.6.1&lt;/protobuf-maven-plugin.version&gt;<br/>&lt;os-maven-plugin.version&gt;1.6.1&lt;/os-maven-plugin.version&gt;</span></pre><p id="2240" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对<code class="du ls lt lu lv b">pom.xml</code>文件进行修改后，运行<code class="du ls lt lu lv b">mvn clean install</code>来编译代码，并从protobuf定义中生成所需的样板java代码。</p><h1 id="2bc1" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld bi translated">2.Hello World服务器</h1><p id="051e" class="pw-post-body-paragraph jj jk ht jl b jm le iu jo jp lf ix jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">一旦我们了解了protobuf的构建和编译步骤，设置服务器就相对容易了。</p><p id="09f1" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们通过实现基类“<em class="ki">com . test . gRPC . helloservicegrpc . helloserviceimplbase</em>”来创建一个基本的java gRPC服务器，该基类是在我们的原型编译步骤中生成的。</p><pre class="mb mc md me fd mf lv mg mh aw mi bi"><span id="6b8f" class="mj kn ht lv b fi mk ml l mm mn">@GrpcService<br/>public class HelloServiceImpl extends HelloServiceImplBase {<br/>  @Override<br/>  public void hello(HelloRequest request, StreamObserver&lt;HelloResponse&gt; responseObserver) {<br/>    System.<em class="ki">out</em>.println("Received:" + request);<br/><br/>    String greeting = new StringBuilder().append("Hello, ")<br/>      .append(request.getFirstName())<br/>      .append(" ")<br/>      .append(request.getLastName())<br/>      .toString();<br/><br/>    HelloResponse response = HelloResponse.<em class="ki">newBuilder</em>()<br/>      .setGreeting(greeting)<br/>      .build();<br/>    responseObserver.onNext(response);<br/>    responseObserver.onCompleted();<br/>  }<br/>}</span></pre><p id="094a" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，我们需要初始化服务器并注册gRPC服务实现。修改您的<code class="du ls lt lu lv b">GrpcServerApplication.java</code>文件，如下所示:</p><pre class="mb mc md me fd mf lv mg mh aw mi bi"><span id="0f3e" class="mj kn ht lv b fi mk ml l mm mn">@SpringBootApplication<br/>public class GrpcServerApplication {<br/><br/>   public static void main(String[] args)  throws IOException, InterruptedException {<br/>    Server server = ServerBuilder.<em class="ki">forPort</em>(8080)<br/>      .addService(new HelloServiceImpl()).build();<br/><br/>    System.<em class="ki">out</em>.println("Starting server...");<br/>    server.start();<br/>    System.<em class="ki">out</em>.println("Server started!");<br/>    server.awaitTermination();<br/>   }<br/><br/>}</span></pre><p id="80e9" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在上面的文件中，我们在端口<code class="du ls lt lu lv b">8080</code>上创建了一个新的gRPC服务器，并用它注册了我们的<code class="du ls lt lu lv b">HelloServiceImpl</code>。</p><h1 id="d00d" class="km kn ht bd ko kp kq kr ks kt ku kv kw iz kx ja ky jc kz jd la jf lb jg lc ld bi translated">3.编译和测试</h1><p id="271b" class="pw-post-body-paragraph jj jk ht jl b jm le iu jo jp lf ix jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">到目前为止，我们使用proto定义在Java中创建了一个基本的RPC服务器实现，并将其注册到我们的服务器中。RPC服务器创建的魔力由我们在第一步中添加的<code class="du ls lt lu lv b">net.devh</code>依赖项来处理。</p><p id="f5fc" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，继续运行服务器并测试它是否满足请求。</p><p id="8c36" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">编译运行:<code class="du ls lt lu lv b">mvn spring-boot:run</code></p><p id="182b" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上面的命令启动了一个gRPC服务器，可以使用多种工具对其进行测试，如<a class="ae ji" href="https://github.com/yarpc/yab" rel="noopener ugc nofollow" target="_blank"> yab </a>和<a class="ae ji" href="https://github.com/fullstorydev/grpcurl" rel="noopener ugc nofollow" target="_blank"> grpcurl </a>。</p><p id="59f7" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这样，在Spring boot中使用Java完成了服务器设置。在下一篇文章的<a class="ae ji" href="https://sumit-agarwal.medium.com/writing-fx-modules-517193b9c4f0" rel="noopener">中，我们将通过启动一个客户机来使用这个服务器提供的数据。我们还将为此添加一个GoLang客户端，看看基于RPC的通信如何更容易、更高效地跨越多个服务，而没有任何语言障碍。</a></p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="959a" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi mw translated"><span class="l mx my mz bm na nb nc nd ne di">C</span><strong class="jl hu"><em class="ki">o丁趣事:</em> </strong> <em class="ki">根据很多网上的研究，最不喜欢的编程语言是Perl、Delphi、VBA。</em></p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="3003" class="pw-post-body-paragraph jj jk ht jl b jm jn iu jo jp jq ix jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hu"> <em class="ki">请求:</em> </strong> <em class="ki">请在评论中添加您的宝贵反馈。这将真正帮助我提高内容的质量，并使其符合您的期望。</em></p></div></div>    
</body>
</html>