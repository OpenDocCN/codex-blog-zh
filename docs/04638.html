<html>
<head>
<title>Useful Github actions for effective CI/CD process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效CI/CD流程的有用Github操作</h1>
<blockquote>原文：<a href="https://medium.com/codex/useful-github-actions-for-effective-ci-cd-process-3d7ff1c7954c?source=collection_archive---------7-----------------------#2021-12-21">https://medium.com/codex/useful-github-actions-for-effective-ci-cd-process-3d7ff1c7954c?source=collection_archive---------7-----------------------#2021-12-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="7721" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><em class="hi"/><a class="ae jh" href="https://github.com/donvadicastro/github-actions" rel="noopener ugc nofollow" target="_blank"><em class="hi">在回购</em> </a> <em class="hi">中收集，但计划定期审核更新。</em></p></blockquote><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/ff98c8ac942eb8884dcb113ca526a9c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_34bIRwwV3OY9uV_M1gaA.png"/></div></div></figure><p id="fc32" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">自动化日常工作是高效代码交付过程的关键因素。通过引入“<a class="ae jh" href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions" rel="noopener ugc nofollow" target="_blank"> actions </a>”，Github允许免费为我们的项目配置CI/CD过程，因此没有理由不在日常代码交付例程中使用它。</p><p id="4810" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">在这篇文章中，我只是收集了有用的Github操作来组织高效的CI/CD作为我的个人备忘单。</p><h2 id="101c" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ju ki kj kk jv kl km kn jw ko kp kq kr bi translated">运行工作流的最常见事件类型</h2><p id="b52b" class="pw-post-body-paragraph ii ij hi il b im ks io ip iq kt is it ju ku iw ix jv kv ja jb jw kw je jf jg hb bi translated">动作定义要求首先定义将要触发工作流的事件。有大量的事件可以使用，这里可以考察<a class="ae jh" href="https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank">和</a>，但是在日常活动中使用最广泛的有:</p><ul class=""><li id="1473" class="kx ky hi il b im in iq ir ju kz jv la jw lb jg lc ld le lf bi translated"><strong class="il hj">预定事件</strong></li></ul><p id="8524" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">通常用于监控现有的打开拉取请求、陈旧分支等，定期清理工作区。</p><pre class="jj jk jl jm fd lg lh li lj aw lk bi"><span id="27fa" class="jx jy hi lh b fi ll lm l ln lo">on:<br/>  schedule:<br/>    - cron:  '<!-- -->0 0 * * *<!-- -->' #every midnight</span></pre><ul class=""><li id="624b" class="kx ky hi il b im in iq ir ju kz jv la jw lb jg lc ld le lf bi translated"><strong class="il hj">创建或删除分支或标签</strong></li></ul><p id="d081" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">根据CD配置，可用于引导测试环境或清理不再需要的资源。</p><pre class="jj jk jl jm fd lg lh li lj aw lk bi"><span id="945e" class="jx jy hi lh b fi ll lm l ln lo">on:<br/>  create:<br/>  delete:</span></pre><ul class=""><li id="a2e9" class="kx ky hi il b im in iq ir ju kz jv la jw lb jg lc ld le lf bi translated"><strong class="il hj">创建部署</strong></li></ul><p id="ad35" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">当有一个特定环境的部署活动时(Github允许<a class="ae jh" href="https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment" rel="noopener ugc nofollow" target="_blank">将环境</a>配置为安全隔离的上下文)，管道也可以对此事件做出反应</p><pre class="jj jk jl jm fd lg lh li lj aw lk bi"><span id="a691" class="jx jy hi lh b fi ll lm l ln lo">on:<br/>  deployment:</span></pre><ul class=""><li id="4933" class="kx ky hi il b im in iq ir ju kz jv la jw lb jg lc ld le lf bi translated"><strong class="il hj">创建/更新拉式请求内容</strong></li></ul><p id="f9a9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">当特征分支将被合并到master中，并且创建了一个pull请求时，我们可以对此事件做出反应，并执行更复杂的特征验证</p><pre class="jj jk jl jm fd lg lh li lj aw lk bi"><span id="6895" class="jx jy hi lh b fi ll lm l ln lo">on:<br/>  pull_request:<br/>    types: [opened, synchronize, reopened, <!-- -->labeled, unlabeled<!-- -->]</span></pre><ul class=""><li id="72eb" class="kx ky hi il b im in iq ir ju kz jv la jw lb jg lc ld le lf bi translated"><strong class="il hj">推送到特定或任何分支</strong></li></ul><p id="d50a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">可能是最广泛使用的事件——对交付的代码增量进行必要的验证(例如，单元测试、静态代码分析、lint等)</p><pre class="jj jk jl jm fd lg lh li lj aw lk bi"><span id="f0e9" class="jx jy hi lh b fi ll lm l ln lo">on:<br/>  push:<br/>    branches:<br/>      - main<br/>      - 'releases/*'</span></pre><ul class=""><li id="7784" class="kx ky hi il b im in iq ir ju kz jv la jw lb jg lc ld le lf bi translated"><strong class="il hj">关于发布活动</strong></li></ul><p id="4158" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">在这种情况下，发布意味着产生一个新的发布标签，因此当有一个手动标签创建过程(例如，基于QA批准)时，该事件是有用的，然后自动化过程使用创建的发布标签构建和发布一个包</p><pre class="jj jk jl jm fd lg lh li lj aw lk bi"><span id="b2f3" class="jx jy hi lh b fi ll lm l ln lo">on:<br/>  release:<br/>    types: [create]</span></pre><h1 id="519d" class="lp jy hi bd jz lq lr ls kd lt lu lv kh lw lx ly kk lz ma mb kn mc md me kq mf bi translated">有用的动作</h1><p id="322a" class="pw-post-body-paragraph ii ij hi il b im ks io ip iq kt is it ju ku iw ix jv kv ja jb jw kw je jf jg hb bi translated">可以根据目的跨项目重用的非常常见和广泛使用的操作列表:</p><h2 id="b35c" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ju ki kj kk jv kl km kn jw ko kp kq kr bi translated">构建和测试</h2><ul class=""><li id="66ec" class="kx ky hi il b im ks iq kt ju mg jv mh jw mi jg lc ld le lf bi translated"><strong class="il hj"> B </strong> <a class="ae jh" href="https://github.com/donvadicastro/github-actions/blob/main/.github/workflows/build.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj">构建项目并在每次提交时运行内部单元测试</strong> </a> <strong class="il hj">(包括PR合并)</strong></li></ul><p id="c03d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">可能是最常见的指令集和使用事件:每次提交都需要通过一个最简单的验证过程(代码被编译，测试通过)。</p><pre class="jj jk jl jm fd lg lh li lj aw lk bi"><span id="c7ec" class="jx jy hi lh b fi ll lm l ln lo">jobs:<br/>  build:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - uses: actions/checkout@v2<br/>      - uses: actions/setup-node@v2<br/>        with:<br/>          node-version: 14<br/>      - run: npm ci<br/>      - <strong class="lh hj">run: npm run build</strong></span><span id="6b9f" class="jx jy hi lh b fi mj lm l ln lo">  test:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - uses: actions/checkout@v2<br/>      - run: npm ci<br/>      - <strong class="lh hj">run: npm test</strong></span></pre><ul class=""><li id="0d27" class="kx ky hi il b im in iq ir ju kz jv la jw lb jg lc ld le lf bi translated"><strong class="il hj"> R </strong></li></ul><p id="73e0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">当特性准备就绪时，必须通过一个更复杂的验证过程:应该创建一个隔离的虚拟测试环境，向其部署特性，并通过端到端的自动化测试。</p><pre class="jj jk jl jm fd lg lh li lj aw lk bi"><span id="71dd" class="jx jy hi lh b fi ll lm l ln lo">jobs:<br/>  cypress-run:<br/>    runs-on: ubuntu-latest<br/>    environment: test<br/>    steps:<br/>      - name: Checkout<br/>        uses: actions/checkout@v2<br/>      - name: Cypress run<br/>        <strong class="lh hj">uses: cypress-io/github-action@v2</strong><br/>        with:<br/>          build: npm run build<br/>          start: npm start<br/>          <strong class="lh hj">wait-on: </strong><a class="ae jh" href="http://localhost:4200" rel="noopener ugc nofollow" target="_blank"><strong class="lh hj">http://localhost:4200</strong></a><br/>    env:<br/>      CYPRESS_authLogin: ${{ secrets.AUTHLOGIN }}<br/>      CYPRESS_authPass: ${{ secrets.AUTHPASS }}</span></pre><ul class=""><li id="5aa4" class="kx ky hi il b im in iq ir ju kz jv la jw lb jg lc ld le lf bi translated"><strong class="il hj"> R </strong> <a class="ae jh" href="https://github.com/donvadicastro/github-actions/blob/main/.github/workflows/e2e-docker.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj">在Docker提供的基础设施上取消集成测试</strong> </a></li></ul><p id="bca8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">对于更复杂的端到端测试场景，可能需要提供复杂的基础设施(例如用于异步通信的Kafka、用于存储数据的Postgres等)。我们可以预先将所有依赖项配置为Docker容器，然后在集成场景中使用它们。</p><pre class="jj jk jl jm fd lg lh li lj aw lk bi"><span id="1cf0" class="jx jy hi lh b fi ll lm l ln lo">jobs:<br/>  test:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - uses: actions/checkout@v2</span><span id="7f6c" class="jx jy hi lh b fi mj lm l ln lo">      - name: Use Node.js<br/>        uses: actions/setup-node@v1<br/>        with:<br/>          node-version: ${{ matrix.node-version }}</span><span id="a852" class="jx jy hi lh b fi mj lm l ln lo">      - name: Start Redis<br/>        run: <strong class="lh hj">docker-compose up -d redis &amp;&amp; sleep 10</strong></span><span id="6087" class="jx jy hi lh b fi mj lm l ln lo">      - name: Start Kafka<br/>        run: <strong class="lh hj">docker-compose up -d zookeeper kafka &amp;&amp; sleep 60</strong></span><span id="cf1a" class="jx jy hi lh b fi mj lm l ln lo">. . .</span></pre><ul class=""><li id="57e4" class="kx ky hi il b im in iq ir ju kz jv la jw lb jg lc ld le lf bi translated"><strong class="il hj"> R </strong> <a class="ae jh" href="https://github.com/donvadicastro/github-actions/blob/main/.github/workflows/e2e-conditional.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj"> un扩展验证套件时标签分配</strong> </a></li></ul><p id="6b4d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">通常，扩展的验证管道(包括长期运行的端到端测试、性能/安全性测试等)并不需要用于每个提交的变更，但是开发人员愿意决定何时运行。当这个决定仅仅通过分配一个特定的标签给拉式请求(例如“运行-扩展-e2e”)来控制时，非常方便</p><pre class="jj jk jl jm fd lg lh li lj aw lk bi"><span id="9719" class="jx jy hi lh b fi ll lm l ln lo">name: e2e-conditional<br/>on:<br/>  pull_request:<br/>    types: [labeled]</span><span id="3fb2" class="jx jy hi lh b fi mj lm l ln lo">jobs:<br/>  cypress-run:<br/>    runs-on: ubuntu-latest<br/>    environment: test<br/>    if: <strong class="lh hj">github.event.label.name == 'run e2e extended test suite'</strong><br/>    steps:<br/>      . . .</span></pre><ul class=""><li id="a338" class="kx ky hi il b im in iq ir ju kz jv la jw lb jg lc ld le lf bi translated"><strong class="il hj"> C </strong> <a class="ae jh" href="https://github.com/moleculerjs/moleculer/blob/master/.github/workflows/ci.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj">在每次提交</strong>时收集并上传测试覆盖率统计数据到覆盖率 </a> <strong class="il hj"/></li></ul><h1 id="6b69" class="lp jy hi bd jz lq lr ls kd lt lu lv kh lw lx ly kk lz ma mb kn mc md me kq mf bi translated">发布和版本处理</h1><ul class=""><li id="bcf0" class="kx ky hi il b im ks iq kt ju mg jv mh jw mi jg lc ld le lf bi translated"><strong class="il hj"> P </strong> <a class="ae jh" href="https://github.com/donvadicastro/github-actions/blob/main/.github/workflows/npm-publish.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj">发布工件到NPM注册表</strong> </a> <strong class="il hj">上创建新的发布标签</strong></li></ul><p id="528d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">显然，不是每个主提交都应该被认为是终端用户可用的新NPM模块。我们希望通过只选择发布候选项作为工作依赖项来控制模块发布过程，这样一旦管理员在项目中创建了“release tag ”,就可以配置工作流来构建工件并将其发布到NPM注册表。</p><pre class="jj jk jl jm fd lg lh li lj aw lk bi"><span id="6486" class="jx jy hi lh b fi ll lm l ln lo">name: publish-npm<br/>on:<br/>  <strong class="lh hj">release:<br/>    types: [created]</strong></span><span id="57e0" class="jx jy hi lh b fi mj lm l ln lo">jobs:<br/>  publish-npm:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - uses: actions/checkout@v2<br/>      - uses: actions/setup-node@v2<br/>        with:<br/>          node-version: 14<br/>          registry-url: <a class="ae jh" href="https://registry.npmjs.org/" rel="noopener ugc nofollow" target="_blank">https://registry.npmjs.org/</a><br/>      - run: npm ci<br/>      - run: npm run build<br/>      - run: |<br/>          git config --global user.name github-actions<br/>          git config --global user.email github-actions@github.com<br/>      - run: <strong class="lh hj">npm publish --tag ${{github.event.release.target_commitish}}</strong><br/>        env:<br/>          NODE_AUTH_TOKEN: ${{secrets.npm_token}}</span></pre><ul class=""><li id="fb46" class="kx ky hi il b im in iq ir ju kz jv la jw lb jg lc ld le lf bi translated"><strong class="il hj"> B </strong> <a class="ae jh" href="https://github.com/donvadicastro/github-actions/blob/main/.github/workflows/bump.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj"> ump项目补丁版本</strong> </a> <strong class="il hj">每次合并后代码为主控</strong></li></ul><p id="6fe1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">手动管理依赖版本确实具有挑战性。最好是自动增加每个主合并的补丁版本，这样每个主合并的pr-merge都有一个唯一的补丁版本</p><pre class="jj jk jl jm fd lg lh li lj aw lk bi"><span id="1eaa" class="jx jy hi lh b fi ll lm l ln lo">jobs:<br/>  bump-version:<br/>    name: 'Bump Version on master'<br/>    runs-on: ubuntu-latest</span><span id="1c64" class="jx jy hi lh b fi mj lm l ln lo">    steps:<br/>      - name: 'Checkout source code'<br/>        uses: 'actions/checkout@v2'<br/>        with:<br/>          ref: ${{ github.ref }}<br/>      - name: 'Automated Version Bump for project'<br/>        uses: 'phips28/gh-action-bump-version@master'<br/>        with:<br/>          tag-prefix: 'v'<br/>          commit-message: 'CI: bumps ROOT version to {{version}}'<br/>        env:<br/>          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</span></pre><ul class=""><li id="52ab" class="kx ky hi il b im in iq ir ju kz jv la jw lb jg lc ld le lf bi translated"><strong class="il hj"> A </strong> <a class="ae jh" href="https://github.com/donvadicastro/github-actions/blob/main/.github/workflows/gh-pages-publish.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj">主合并时自动将编译好的应用部署到github.io </strong> </a> <strong class="il hj"/></li></ul><p id="f29f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">Github提供静态web资源的免费托管，因此发布过程可能包括将项目的轻量级测试版本部署到“github.io”中供内部使用(用于内部演示、更快的反馈等)。我们可以自动化这一过程，并在功能就绪时自动发布最小化的应用程序版本</p><pre class="jj jk jl jm fd lg lh li lj aw lk bi"><span id="d54c" class="jx jy hi lh b fi ll lm l ln lo">jobs:<br/>  build:<br/>    name: Publish<br/>    runs-on: ubuntu-latest<br/><br/>    steps:<br/>      - uses: actions/checkout@v2<br/>      - uses: actions/setup-node@v2<br/>        with:<br/>          node-version: "14"<br/>          cache: "npm"<br/><br/>      - name: Install dependencies<br/>        run: npm install<br/><br/>      - name: Build application<br/>        run: npm run build<br/><br/>      - name: Stage build artifacts<br/>        run: |<br/>          git add -f client/dist/<br/>          git status<br/>      - name: Make commit message<br/>        run: |<br/>          <strong class="lh hj">git config --global user.name "GitHub Actions"<br/>          git commit -m "Deployed build artifacts (`date '+%F %T %Z'`)" || true<br/>          git restore .</strong><br/>      - name: Push build artifacts to gh-pages branch<br/>        <strong class="lh hj">run: git push origin HEAD:gh-pages --force</strong></span></pre><ul class=""><li id="38a3" class="kx ky hi il b im in iq ir ju kz jv la jw lb jg lc ld le lf bi translated"><strong class="il hj"> C </strong></li></ul><p id="7792" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">例如，如果交付阶段之一需要创建和发布docker图像，我们也可以将其自动化，并通过手动创建发布标签来控制此流程。</p><h1 id="a9bd" class="lp jy hi bd jz lq lr ls kd lt lu lv kh lw lx ly kk lz ma mb kn mc md me kq mf bi translated">项目质量</h1><ul class=""><li id="591c" class="kx ky hi il b im ks iq kt ju mg jv mh jw mi jg lc ld le lf bi translated"><strong class="il hj"> E </strong></li></ul><p id="d97b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">在不同版本之间保持changelog最新是非常重要的。它有助于清楚地了解特定版本升级带来的变化。但是手动控制它是一个很大的挑战，因为增加了人为错误的可能性——忘记更新所需的文件。因此，这种保护可以是自动的—如果在pull请求中没有检测到对CHANGELOG.md的更新，CI可能会失败。</p><pre class="jj jk jl jm fd lg lh li lj aw lk bi"><span id="bd57" class="jx jy hi lh b fi ll lm l ln lo">jobs:<br/>  changelog:<br/>    runs-on: ubuntu-latest<br/>    <br/>    steps:<br/>      - uses: actions/checkout@v2<br/>      - name: Check for CHANGELOG changes<br/>        run: |<br/>          if [[$(git diff --name-only FETCH_HEAD | grep CHANGELOG)]]<br/>          then<br/>            <strong class="lh hj">echo "A CHANGELOG was modified. Looks good!"</strong><br/>          else<br/>            <strong class="lh hj">echo "No CHANGELOG was modified."<br/>            </strong>echo "Please add a CHANGELOG entry"<strong class="lh hj"><br/>            false</strong><br/>          fi</span></pre><ul class=""><li id="b365" class="kx ky hi il b im in iq ir ju kz jv la jw lb jg lc ld le lf bi translated"><a class="ae jh" href="https://github.com/donvadicastro/github-actions/blob/main/.github/workflows/todo.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj">为每个现有待办事宜创建单独的问题</strong> </a></li><li id="de47" class="kx ky hi il b im mk iq ml ju mm jv mn jw mo jg lc ld le lf bi translated"><a class="ae jh" href="https://github.com/donvadicastro/github-actions/blob/main/.github/workflows/cron.yml" rel="noopener ugc nofollow" target="_blank"><strong class="il hj"/></a><strong class="il hj">【午夜】定期监控过时和陈旧的拉式请求</strong></li><li id="3009" class="kx ky hi il b im mk iq ml ju mm jv mn jw mo jg lc ld le lf bi translated"><a class="ae jh" href="https://github.com/donvadicastro/github-actions/blob/main/.github/workflows/codesee.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj">在代码中创建架构图参见</strong> </a> <strong class="il hj">关于主合并</strong></li></ul><p id="d8e9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi translated">对于复杂的项目，创建架构图降低了项目启动的复杂性，并增加了对总体高层次项目视图的理解。需要额外注册codesee API密钥作为存储库密码，以允许远程导入数据。</p><h1 id="740a" class="lp jy hi bd jz lq lr ls kd lt lu lv kh lw lx ly kk lz ma mb kn mc md me kq mf bi translated">通知配置项助手</h1><ul class=""><li id="ddd4" class="kx ky hi il b im ks iq kt ju mg jv mh jw mi jg lc ld le lf bi translated"><strong class="il hj">得到</strong> <a class="ae jh" href="https://github.com/nrwl/nx/blob/master/.github/workflows/npm-audit.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj">懈怠通知</strong> </a> <strong class="il hj">发布神器发布</strong></li><li id="af94" class="kx ky hi il b im mk iq ml ju mm jv mn jw mo jg lc ld le lf bi translated"><strong class="il hj">得到</strong> <a class="ae jh" href="https://github.com/moleculerjs/moleculer/blob/master/.github/workflows/notification.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj">不和谐通知</strong> </a> <strong class="il hj">发布神器</strong></li></ul><h1 id="b4ba" class="lp jy hi bd jz lq lr ls kd lt lu lv kh lw lx ly kk lz ma mb kn mc md me kq mf bi translated">贡献CI助手</h1><ul class=""><li id="c84d" class="kx ky hi il b im ks iq kt ju mg jv mh jw mi jg lc ld le lf bi translated"><strong class="il hj">在</strong> <a class="ae jh" href="https://github.com/vegasbrianc/prometheus/blob/master/.github/workflows/greetings.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj">拉式请求</strong> </a> <strong class="il hj">或</strong> <a class="ae jh" href="https://github.com/debezium/debezium/blob/main/.github/workflows/contributor-check.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj">问题</strong> </a>上生成第一条评论——当需要描述投稿流程时，我们可以在创建拉式请求或问题后自动发布评论</li><li id="51cf" class="kx ky hi il b im mk iq ml ju mm jv mn jw mo jg lc ld le lf bi translated"><strong class="il hj">确保提交注释包含</strong> <a class="ae jh" href="https://github.com/debezium/debezium/blob/main/.github/workflows/sanity-check.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj"> JIRA票证</strong> </a> —如果链接到JIRA是公司的严格要求，那么我们可以通过检查每个提交注释来遵守此要求，如果命名不符合要求，则CI失败。</li><li id="508b" class="kx ky hi il b im mk iq ml ju mm jv mn jw mo jg lc ld le lf bi translated"><a class="ae jh" href="https://github.com/remix-run/remix/blob/main/.github/workflows/format.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="il hj">合并到master </strong>后重新格式化代码</a><strong class="il hj">——为了保持所有开发人员和项目的代码风格一致，我们可以在提交时重新格式化代码，而不是同步开发人员环境。</strong></li></ul></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="42d7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it ju iv iw ix jv iz ja jb jw jd je jf jg hb bi mw translated"><span class="l mx my mz bm na nb nc nd ne di"> B </span>责任:习惯于定期使用Github动作，并轻松地在本地重新检查配置——有一个优秀的开源实用程序<a class="ae jh" href="https://github.com/nektos/act" rel="noopener ugc nofollow" target="_blank"> ACT </a>允许在发布到云之前，在本地运行每个定义好的动作在它自己的docker容器中。</p></div></div>    
</body>
</html>