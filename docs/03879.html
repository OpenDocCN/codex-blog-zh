<html>
<head>
<title>Blazor Webassembly SVG Drag And Drop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Blazor Webassembly SVG拖放</h1>
<blockquote>原文：<a href="https://medium.com/codex/blazor-webassembly-svg-drag-and-drop-e680769ac682?source=collection_archive---------1-----------------------#2021-10-04">https://medium.com/codex/blazor-webassembly-svg-drag-and-drop-e680769ac682?source=collection_archive---------1-----------------------#2021-10-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0519" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://alexeyboiko.github.io/BlazorDraggableDemo/" rel="noopener ugc nofollow" target="_blank">试玩</a> | <a class="ae jd" href="https://github.com/AlexeyBoiko/BlazorDraggableDemo" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/b27662e32ad238e342d307d3dbcc18ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gEfzNg8rnZdgEzNHsVrtcQ.gif"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">Blazor Webassembly SVG拖放演示。可拖动组件支持嵌套可拖动、双向绑定、无参数绑定的初始化</figcaption></figure><p id="dd9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文描述了一种实现SVG对象拖放的方法。在此过程中，考虑了Blazor的以下开发要点:</p><ul class=""><li id="a6de" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">模板化组件。模板化组件的内容可以在父组件中设置；</li><li id="e6b5" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">将事件从父组件传递到子组件(父-&gt;子)；</li><li id="98c0" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">组件内部重新布线组件输入参数问题(<a class="ae jd" href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#overwritten-parameters-1" rel="noopener ugc nofollow" target="_blank">参数被覆盖问题</a>)；</li><li id="2429" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">父组件和子组件之间的双向绑定。那些。子组件的输入参数可以修改父组件和子组件；</li><li id="6331" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">如何与Blazor一起使用stopPropagation？</li></ul><h1 id="afd3" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">我们最终会得到什么</h1><p id="98cd" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">结果是一个Blazor组件——可拖动的。使用示例:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="4e06" class="lq kj hi lm b fi lr ls l lt lu"><a class="ae jd" href="http://twitter.com/inject" rel="noopener ugc nofollow" target="_blank">@inject</a> MouseService mouseSrv;</span><span id="2284" class="lq kj hi lm b fi lv ls l lt lu">&lt;svg ae jd" href="http://www.w3.org/2000/svg" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/2000/svg"<br/>  <a class="ae jd" href="http://twitter.com/onmousemove" rel="noopener ugc nofollow" target="_blank">@onmousemove</a>=@(e =&gt; mouseSrv.FireMove(this, e))<br/>  <a class="ae jd" href="http://twitter.com/onmouseup" rel="noopener ugc nofollow" target="_blank">@onmouseup</a>=@(e =&gt; mouseSrv.FireUp(this, e))&gt;&gt;</span><span id="d485" class="lq kj hi lm b fi lv ls l lt lu">  &lt;Draggable X=250 Y=150&gt;<br/>    &lt;circle r="60" fill="#ff6600" /&gt;<br/>    &lt;text text-anchor="middle"<br/>      alignment-baseline="central" style="fill:#fff;"&gt;Sun&lt;/text&gt;<br/>  &lt;/Draggable&gt;<br/>&lt;/svg&gt;</span></pre><p id="5f65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单1。使用可拖动组件</em></p><p id="ee8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可拖动的连同它的内容将被拖动。</p><p id="b9d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">x和Y参数支持双向绑定:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="ac35" class="lq kj hi lm b fi lr ls l lt lu"><a class="ae jd" href="http://twitter.com/inject" rel="noopener ugc nofollow" target="_blank">@inject</a> MouseService mouseSrv;</span><span id="8ab0" class="lq kj hi lm b fi lv ls l lt lu">&lt;svg ae jd" href="http://www.w3.org/2000/svg" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/2000/svg"<br/>  <a class="ae jd" href="http://twitter.com/onmousemove" rel="noopener ugc nofollow" target="_blank">@onmousemove</a>=@(e =&gt; mouseSrv.FireMove(this, e)) <br/>  <a class="ae jd" href="http://twitter.com/onmouseup" rel="noopener ugc nofollow" target="_blank">@onmouseup</a>=@(e =&gt; mouseSrv.FireUp(this, e))&gt;&gt;</span><span id="7f40" class="lq kj hi lm b fi lv ls l lt lu">  &lt;Draggable <a class="ae jd" href="http://twitter.com/bind" rel="noopener ugc nofollow" target="_blank">@bind</a>-X=X <a class="ae jd" href="http://twitter.com/bind" rel="noopener ugc nofollow" target="_blank">@bind</a>-Y=Y&gt;<br/>    &lt;circle r="60" fill="#ff6600" /&gt;<br/>      &lt;text text-anchor="middle"<br/>        alignment-baseline="central" style="fill:#fff;"&gt;Sun&lt;/text&gt;<br/>  &lt;/Draggable&gt;<br/>&lt;/svg&gt;</span><span id="fe7a" class="lq kj hi lm b fi lv ls l lt lu"><a class="ae jd" href="http://twitter.com/code" rel="noopener ugc nofollow" target="_blank">@code</a> {<br/>    double X = 250;<br/>    double Y = 150;<br/>}</span></pre><p id="ee64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单2。使用双向绑定X、Y的可拖动工具</em></p><p id="a20a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你只是需要一个现成的解决方案，你不需要阅读这篇文章——直接阅读文章最后的“如何在你的项目中使用可拖动组件”。</p><h1 id="a469" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">主要思想</h1><p id="4635" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">使用g分组元素并“转换”到SVG对象的位置很方便:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="ebea" class="lq kj hi lm b fi lr ls l lt lu">&lt;svg style="width:500px; height:300px"<br/>  ae jd" href="http://www.w3.org/2000/svg" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/2000/svg"&gt;</span><span id="d700" class="lq kj hi lm b fi lv ls l lt lu">  &lt;g transform="translate(250, 150)"&gt;<br/>    &lt;circle r="60" fill="#ff6600" /&gt;<br/>      &lt;text text-anchor="middle"<br/>        alignment-baseline="central" style="fill:#fff;"&gt;Sun&lt;/text&gt;<br/>  &lt;/g&gt;</span><span id="9a7a" class="lq kj hi lm b fi lv ls l lt lu">&lt;/svg&gt;</span></pre><p id="5fbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单3。使用translate定位一组SVG对象</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lx"><img src="../Images/9559e504bbf5807f0de7a2e86ecc2de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nNmvEU08ItjAxd0Yb1jGtQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图一。使用translate定位一组SVG对象</figcaption></figure><p id="496e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要“拖动”，需要订阅鼠标移动事件并更改“翻译”值。</p><h1 id="7a04" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">模板化组件可拖动</h1><p id="9bed" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">清单1展示了Draggable组件的使用。Draggable是一个模板化的组件，它包装了<g>中的内容:</g></p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="017b" class="lq kj hi lm b fi lr ls l lt lu">&lt;g transform="translate(<a class="ae jd" href="http://twitter.com/x" rel="noopener ugc nofollow" target="_blank">@x</a>, <a class="ae jd" href="http://twitter.com/y" rel="noopener ugc nofollow" target="_blank">@y</a>)"&gt;<br/>  <a class="ae jd" href="http://twitter.com/ChildContent" rel="noopener ugc nofollow" target="_blank">@ChildContent</a><br/>&lt;/g&gt;</span><span id="2204" class="lq kj hi lm b fi lv ls l lt lu"><a class="ae jd" href="http://twitter.com/code" rel="noopener ugc nofollow" target="_blank">@code</a> {<br/>  [Parameter] public RenderFragment? ChildContent { get; set; }</span><span id="864c" class="lq kj hi lm b fi lv ls l lt lu">double x = 250;<br/>  double y = 150;<br/>}</span></pre><p id="fa17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单4。模板化组件可拖动包装&lt;g&gt;T14】中的内容</em></p><p id="6486" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当x，y改变时，<g>的位置会随着内容而改变。</g></p><p id="b27f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要拖动(正确更改x，y)，需要以下事件:</p><ol class=""><li id="03bc" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ly ka kb kc bi translated">用户开始拖动时的事件。<br/>它是&lt; g &gt;元素上的“onmousedown”。注意&lt; g &gt;不是一个矩形，&lt; g &gt;的边框遵循嵌套对象的轮廓。那些。对于清单3，onmousedown将只在圆圈内触发，这正是我们所需要的。</li><li id="7cd1" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ly ka kb kc bi translated">按下鼠标时光标移动的事件。<br/>思考&lt; g &gt;元素上的“onmousemove”？不会。在快速移动的情况下，鼠标超出了&lt; g &gt;的界限,“onmousemove”停止工作。因此，“onmousemove”需要订阅整个&lt; svg &gt;并且事件必须转发给Draggable。</li><li id="84aa" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ly ka kb kc bi translated">用户完成拖动(抬起)鼠标时的事件。<br/>&lt;g&gt;上的“onmouseup”也不合适，原因相同:快速移动时，鼠标超出&lt; g &gt;的界限，“onmouseup”不起作用。原来“onmouseup”需要订阅整个&lt; svg &gt;。</li></ol><h1 id="7ca4" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">将事件从父组件传递到子组件(父-&gt;子)</h1><p id="cddf" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">事实证明，我们需要一种方法来订阅父<svg>的“onmousemove”和“onmouseup”事件。这可以通过使用单例服务来实现:</svg></p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="3ca4" class="lq kj hi lm b fi lr ls l lt lu">// inject IMouseService into subscribers<br/>public interface IMouseService {<br/>  event EventHandler&lt;MouseEventArgs&gt;? OnMove;<br/>  event EventHandler&lt;MouseEventArgs&gt;? OnUp;<br/>}</span><span id="5072" class="lq kj hi lm b fi lv ls l lt lu">// use MouseService to fire events<br/>public class MouseService : IMouseService {<br/>  public event EventHandler&lt;MouseEventArgs&gt;? OnMove;<br/>  public event EventHandler&lt;MouseEventArgs&gt;? OnUp;</span><span id="71ab" class="lq kj hi lm b fi lv ls l lt lu">  public void FireMove(object obj, MouseEventArgs evt) <br/>    =&gt; OnMove?.Invoke(obj, evt);<br/>  public void FireUp(object obj, MouseEventArgs evt)<br/>    =&gt; OnUp?.Invoke(obj, evt);<br/>}</span></pre><p id="6a9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单5。在需要订阅事件的组件中使用IMouseService。使用触发事件的鼠标服务</em></p><p id="3334" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MouseService需要注册为singleotn，以便所有组件接收一个服务实例:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="23b0" class="lq kj hi lm b fi lr ls l lt lu">builder.Services<br/>  .AddSingleton&lt;MouseService&gt;()<br/>  .AddSingleton&lt;IMouseService&gt;(ff <br/>    =&gt; ff.GetRequiredService&lt;MouseService&gt;());</span></pre><p id="da20" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单6。MouseService注册为singleton </em></p><p id="fc65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在可以使用MouseService了。</p><p id="1bd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">订阅<svg>事件并激活鼠标服务事件:</svg></p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="8fa3" class="lq kj hi lm b fi lr ls l lt lu"><a class="ae jd" href="http://twitter.com/inject" rel="noopener ugc nofollow" target="_blank">@inject</a> MouseService mouseSrv;</span><span id="6177" class="lq kj hi lm b fi lv ls l lt lu">&lt;svg style="width:500px; height:300px" <br/>  ae jd" href="http://www.w3.org/2000/svg" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/2000/svg"<br/>  <a class="ae jd" href="http://twitter.com/onmousemove" rel="noopener ugc nofollow" target="_blank">@onmousemove</a>=@(e =&gt; mouseSrv.FireMove(this, e)) <br/>  <a class="ae jd" href="http://twitter.com/onmouseup" rel="noopener ugc nofollow" target="_blank">@onmouseup</a>=@(e =&gt; mouseSrv.FireUp(this, e))&gt;&gt;</span><span id="b7eb" class="lq kj hi lm b fi lv ls l lt lu">  &lt;Draggable&gt;<br/>    &lt;circle r="60" fill="#ff6600" /&gt;<br/>      &lt;text text-anchor="middle"<br/>        alignment-baseline="central" style="fill:#fff;"&gt;Sun&lt;/text&gt;<br/>  &lt;/Draggable&gt;</span><span id="fea1" class="lq kj hi lm b fi lv ls l lt lu">&lt;/svg&gt;</span></pre><p id="c780" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单7。向全局单体服务</em>触发&lt;SVG&gt;“onmousemove”和“onmouseup”事件</p><p id="36a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">订阅Draggable内部的<svg>事件:</svg></p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="7721" class="lq kj hi lm b fi lr ls l lt lu"><a class="ae jd" href="http://twitter.com/inject" rel="noopener ugc nofollow" target="_blank">@inject</a> IMouseService mouseSrv;<br/> <br/>&lt;g transform="translate(<a class="ae jd" href="http://twitter.com/x" rel="noopener ugc nofollow" target="_blank">@x</a>, <a class="ae jd" href="http://twitter.com/y" rel="noopener ugc nofollow" target="_blank">@y</a>)" <a class="ae jd" href="http://twitter.com/onmousedown" rel="noopener ugc nofollow" target="_blank">@onmousedown</a>=OnDown&gt;<br/>  <a class="ae jd" href="http://twitter.com/ChildContent" rel="noopener ugc nofollow" target="_blank">@ChildContent</a><br/>&lt;/g&gt;</span><span id="aecf" class="lq kj hi lm b fi lv ls l lt lu"><a class="ae jd" href="http://twitter.com/code" rel="noopener ugc nofollow" target="_blank">@code</a> {<br/>  [Parameter] public RenderFragment? ChildContent { get; set; }</span><span id="1e0a" class="lq kj hi lm b fi lv ls l lt lu">  double x = 250;<br/>  double y = 150;</span><span id="4149" class="lq kj hi lm b fi lv ls l lt lu">  protected override void OnInitialized() {</span><span id="9815" class="lq kj hi lm b fi lv ls l lt lu">    mouseSrv.OnMove += OnMove;<br/>    mouseSrv.OnUp += OnUp;</span><span id="2385" class="lq kj hi lm b fi lv ls l lt lu">    base.OnInitialized();<br/>  }</span><span id="7150" class="lq kj hi lm b fi lv ls l lt lu">  void OnDown(MouseEventArgs e) {...}<br/>  void OnMove(object? _, MouseEventArgs e) {... x=... y=...}<br/>  void OnUp(object? _, MouseEventArgs e) {...}</span><span id="025a" class="lq kj hi lm b fi lv ls l lt lu">  public void Dispose() {<br/>    mouseSrv.OnMove -= OnMove;<br/>    mouseSrv.OnUp -= OnUp;<br/>  }<br/>}</span></pre><p id="6b0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单8。可拖动组件。订阅鼠标服务事件和&lt; g &gt;元素</em>的“onmousedown”</p><p id="964d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意Dispose方法:您需要取消订阅。</p><p id="2258" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在Draggable内部有了所有必要的事件:</p><ul class=""><li id="e9b0" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">OnDown —拖动开始事件，</li><li id="e2aa" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">OnMove —改变鼠标位置，</li><li id="cce6" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">OnUp —拖动结束事件。</li></ul><p id="42c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以实现拖放算法:</p><ol class=""><li id="962f" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc ly ka kb kc bi translated">在“OnDown”上，设置“鼠标按下”标志并记住光标位置；</li><li id="d1b0" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ly ka kb kc bi translated">在“OnMove”上，如果“鼠标被按下”:<br/> -计算新旧光标位置之间的差值；<br/> -记住当前光标位置；<br/> -改变x，y-添加到当前增量值。<br/>光标的具体坐标不重要，增量才重要。</li></ol><p id="6d13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简洁起见，这里不包括算法的代码——看看GitHub。</p><h1 id="c662" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">输入参数重写问题</h1><p id="82f8" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">现在Draggable已经在工作了，但是没有办法设置起始位置——即设置参数x，y。</p><p id="14ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们将内部的x，y字段作为输入参数(清单9)，那么我们可以设置开始位置(清单10)，但是拖放将停止工作。</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="23a3" class="lq kj hi lm b fi lr ls l lt lu">...<br/><a class="ae jd" href="http://twitter.com/code" rel="noopener ugc nofollow" target="_blank">@code</a> {<br/>  …<br/>  [Parameter]  double x { get; set; };<br/>  [Parameter]  double y { get; set; };<br/>  …<br/>  void OnMove(object? _, MouseEventArgs e) {... x=... y=...}</span></pre><p id="8252" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单9。可拖动组件。私有x，y作为公共输入参数。在组件内部，x，y被更新(在OnMove方法中)。不是一个可行的选择。</em></p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="77bf" class="lq kj hi lm b fi lr ls l lt lu">&lt;Draggable x=250 y=150&gt;<br/>  ...<br/>&lt;/Draggable&gt;</span></pre><p id="b323" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单10。在父组件</em>中设置可拖动的输入参数</p><p id="a307" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于参数被覆盖的问题，拖放停止工作。那些。覆盖组件内部的输入参数。会发生以下情况:</p><ul class=""><li id="44de" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">可拖动更新x，y</li><li id="afce" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">这将导致组件被重新呈现</li><li id="ccc7" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">重新渲染导致输入参数重置，即x，y再次变为250，150。</li></ul><p id="2b2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由此得出一般规则:最好避免更新组件内部的输入参数——这会导致意外的行为。</p><p id="422e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以如下解决问题:</p><ul class=""><li id="559d" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">让内部字段x，y保持原样—不要将它们作为输入参数，</li><li id="b9a0" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">为参数创建单独的属性，</li><li id="b9fa" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">在初始化时设置内部字段x，y的初始值</li></ul><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="814f" class="lq kj hi lm b fi lr ls l lt lu">...<br/><a class="ae jd" href="http://twitter.com/code" rel="noopener ugc nofollow" target="_blank">@code</a> {<br/>  ...<br/>  double x;<br/>  double y;</span><span id="3da2" class="lq kj hi lm b fi lv ls l lt lu">  [Parameter]  double X { get; set; }<br/>  [Parameter]  double Y { get; set; }</span><span id="1ee7" class="lq kj hi lm b fi lv ls l lt lu">  protected override void OnInitialized() {<br/>    x = X;<br/>    y = Y;<br/>    ...<br/>  }<br/>  …<br/>  void OnMove(object? _, MouseEventArgs e) {... x=... y=...}</span></pre><p id="752a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单11。可拖动组件。x、y字段在初始化</em>时初始化</p><p id="438b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种解决方案的缺点是在初始化后更新输入参数不会有任何影响:我们不能从父组件改变对象的位置。此外，这个缺点将被修复。</p><h1 id="5e3c" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">父组件和子组件之间的双向绑定</h1><h2 id="c560" class="lq kj hi bd kk lz ma mb ko mc md me ks iq mf mg kw iu mh mi la iy mj mk le ml bi translated">Child -&gt; Parent binding:参数在组件内部被更新，父组件被通知这个变化</h2><p id="a830" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">子-&gt;父绑定是通过添加EventCallback类型的“XChanged”、“YChanged”输入参数来完成的。命名规则:“{参数名称}已更改”。</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="700e" class="lq kj hi lm b fi lr ls l lt lu">...<br/><a class="ae jd" href="http://twitter.com/code" rel="noopener ugc nofollow" target="_blank">@code</a> {<br/>  ..<br/>  double x;<br/>  double y;</span><span id="b40b" class="lq kj hi lm b fi lv ls l lt lu">  [Parameter] double X { get; set; }<br/>  [Parameter] public EventCallback&lt;double&gt; XChanged { get; set; }</span><span id="93bf" class="lq kj hi lm b fi lv ls l lt lu">  [Parameter] double Y { get; set; }<br/>  [Parameter] public EventCallback&lt;double&gt; YChanged { get; set; }<br/>  ...<br/>  void OnMove(object? _, MouseEventArgs e)  {<br/>    ...<br/>    x=... y=...<br/>    XChanged.InvokeAsync(x);<br/>    XChanged.InvokeAsync(xy;<br/>  }</span></pre><p id="1872" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单12。可拖动组件。x，Y参数与子&gt;父绑定</em></p><p id="2650" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以跟踪父组件中的X，Y变化:</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="f0dc" class="lq kj hi lm b fi lr ls l lt lu">Solar system position: <a class="ae jd" href="http://twitter.com/X" rel="noopener ugc nofollow" target="_blank">@X</a> , <a class="ae jd" href="http://twitter.com/Y" rel="noopener ugc nofollow" target="_blank">@Y</a><br/>&lt;svg&gt;<br/>  &lt;Draggable <a class="ae jd" href="http://twitter.com/bind" rel="noopener ugc nofollow" target="_blank">@bind</a>-X=X <a class="ae jd" href="http://twitter.com/bind" rel="noopener ugc nofollow" target="_blank">@bind</a>-Y=Y&gt;<br/>  ...<br/>  &lt;/Draggable&gt;<br/>&lt;/svg&gt;</span><span id="1f69" class="lq kj hi lm b fi lv ls l lt lu"><a class="ae jd" href="http://twitter.com/code" rel="noopener ugc nofollow" target="_blank">@code</a> {<br/>  double X = 250;<br/>  double Y = 150;<br/>}</span></pre><p id="fa1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单13。使用具有X，Y绑定的可拖动</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lx"><img src="../Images/d68b3481289bff700545ef50a60d682d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kBIW8-mBqRbbQ1FZd_LaFg.gif"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图2。子组件更改输入参数，父组件订阅这些更改</figcaption></figure><h2 id="239c" class="lq kj hi bd kk lz ma mb ko mc md me ks iq mf mg kw iu mh mi la iy mj mk le ml bi translated">父-&gt;子绑定:父组件更新子组件的参数</h2><p id="ec63" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">现在，父对象可以跟踪可拖动位置的变化，可以设置初始位置，但不能在初始化后更改位置。</p><p id="f81e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">子组件“开箱即用”接收对输入参数的更改:每当父组件发生更改时，就会调用setters X，Y。整个问题是如何处理这些事件，并避免覆盖输入参数的问题(见上文)。</p><p id="10a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可拖动以支持两种选项:</p><ul class=""><li id="e16f" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">设置初始位置而不跟踪变化，</li><li id="d24a" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">跟踪更改，以及从父组件更改位置的能力。</li></ul><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="2a50" class="lq kj hi lm b fi lr ls l lt lu">setting the starting position without tracking changes<br/>&lt;Draggable X=250 Y=150&gt;<br/>...<br/>&lt;/Draggable&gt;</span><span id="b600" class="lq kj hi lm b fi lv ls l lt lu"><br/>tracking changes<br/>&lt;Draggable <a class="ae jd" href="http://twitter.com/bind" rel="noopener ugc nofollow" target="_blank">@bind</a>-X=X <a class="ae jd" href="http://twitter.com/bind" rel="noopener ugc nofollow" target="_blank">@bind</a>-Y=Y&gt;<br/>...<br/>&lt;/Draggable&gt;</span></pre><p id="f232" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单14。可拖动的两个用例:有和没有变更跟踪</em></p><p id="5d7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码变得难看。</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="36e4" class="lq kj hi lm b fi lr ls l lt lu">...<br/>double? x;<br/>[Parameter]<br/>public double X { <br/>  get { return x ?? 0; }<br/>  set { if (!x.HasValue || (!isDown &amp; XChanged.HasDelegate)) {<br/>    x = value; } } <br/>}<br/>[Parameter] public EventCallback&lt;double&gt; XChanged { get; set; }<br/>...<br/>protected override void OnInitialized() {<br/>  mouseSrv.OnMove += OnMove;<br/>  mouseSrv.OnUp += OnUp;<br/>  base.OnInitialized();<br/>}</span><span id="17c5" class="lq kj hi lm b fi lv ls l lt lu">bool isDown;</span><span id="f426" class="lq kj hi lm b fi lv ls l lt lu">void OnDown(MouseEventArgs e) {... isDown = true; }<br/>void OnMove(object? _, MouseEventArgs e) {... }<br/>void OnUp(object? _, MouseEventArgs e) {isDown = false; }</span></pre><p id="eb1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单15。可拖动组件。x、Y输入参数可从父组件</em>中更改</p><p id="bb5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">算法:</p><ul class=""><li id="704e" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">如果初始化(！x.HasValue) —设置x的初始值，</li><li id="1f35" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">如果用户当前正在移动组件(isDown)，我们忽略输入参数X的设置</li><li id="cf6a" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">如果组件当前没有被用户移动，并且输入参数被绑定到父属性(XChanged。HasDelegate) —更新x。</li></ul><p id="234a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">y也一样。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lx"><img src="../Images/94b7bef75b9b8b74b6ffa912725a60d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qwwbp-uAua-Yc3EC4Fga4g.gif"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图3。双向装订</figcaption></figure><h1 id="1b9f" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">可拖动的内部可拖动的内部可拖动的。停止向布拉索传播</h1><p id="34c4" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">当然我们应该试着把Draggable变成Draggable。</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="2a42" class="lq kj hi lm b fi lr ls l lt lu">&lt;Draggable <a class="ae jd" href="http://twitter.com/bind" rel="noopener ugc nofollow" target="_blank">@bind</a>-X=X <a class="ae jd" href="http://twitter.com/bind" rel="noopener ugc nofollow" target="_blank">@bind</a>-Y=Y&gt;<br/>  &lt;circle r="60" fill="#ff6600" /&gt;<br/>  &lt;text text-anchor="middle"<br/>    alignment-baseline="central" style="fill:#fff;"&gt;Sun&lt;/text&gt;</span><span id="7d2a" class="lq kj hi lm b fi lv ls l lt lu">  &lt;Draggable X=173 Y=-15&gt;<br/>    &lt;circle r="35" fill="#1aaee5" stroke="#fff" /&gt;<br/>    &lt;Draggable X=-57 Y=-38&gt;<br/>      &lt;text&gt;Earth&lt;/text&gt;<br/>    &lt;/Draggable&gt;</span><span id="e895" class="lq kj hi lm b fi lv ls l lt lu">    &lt;Draggable X=51 Y=-25&gt;<br/>      &lt;circle r="15" fill="#04dcd2" stroke="#fff" /&gt;<br/>      &lt;Draggable X=-5 Y=-20&gt;<br/>        &lt;text&gt;Moon&lt;/text&gt;<br/>      &lt;/Draggable&gt;<br/>    &lt;/Draggable&gt;<br/>  &lt;/Draggable&gt;</span><span id="4269" class="lq kj hi lm b fi lv ls l lt lu">&lt;/Draggable&gt;</span></pre><p id="d1c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单16。可拖动内部可拖动</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lx"><img src="../Images/47ccc9e4e89aa9583cc6e43e27f237f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_-e5HGrp_1ttYd6M77EHeA.gif"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图4。可拖动内部不停止传播</figcaption></figure><p id="2648" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不错，但无法使用。如果我们拖动嵌套的可拖动对象，外部的也开始拖动。</p><p id="3b65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HTML鼠标事件如“onmousedown”是自下而上浮动的。那些。首先为内部元素触发“onmousedown ”,然后为父元素触发。</p><p id="d181" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Draggable中，拖动开始事件是“onmousedown”。如果我们不允许事件冒泡到父组件，那么只有嵌套的组件会被拖动。</p><pre class="jf jg jh ji fd ll lm ln lo aw lp bi"><span id="e2d4" class="lq kj hi lm b fi lr ls l lt lu">&lt;g transform="translate(<a class="ae jd" href="http://twitter.com/x" rel="noopener ugc nofollow" target="_blank">@x</a>, <a class="ae jd" href="http://twitter.com/y" rel="noopener ugc nofollow" target="_blank">@y</a>)" cursor=<a class="ae jd" href="http://twitter.com/cursor" rel="noopener ugc nofollow" target="_blank">@cursor</a> <a class="ae jd" href="http://twitter.com/onmousedown" rel="noopener ugc nofollow" target="_blank">@onmousedown</a>=OnDown <br/>  <a class="ae jd" href="http://twitter.com/onmousedown" rel="noopener ugc nofollow" target="_blank">@onmousedown</a>:stopPropagation="true"&gt;<br/>  <a class="ae jd" href="http://twitter.com/ChildContent" rel="noopener ugc nofollow" target="_blank">@ChildContent</a><br/>&lt;/g&gt;</span></pre><p id="aa52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lw">清单17。可拖动组件。防止“onmousedown”事件冒泡</em></p><p id="1a3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以画出太阳系:</p><ul class=""><li id="3a5e" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">月球绕着地球转，所以它和地球同时拖动。</li><li id="b80a" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc jz ka kb kc bi translated">地球绕着太阳转，所以地球和月亮和太阳同时拖动。</li></ul><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/b27662e32ad238e342d307d3dbcc18ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gEfzNg8rnZdgEzNHsVrtcQ.gif"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图4。可拖动支持嵌套可拖动、双向绑定、无参数绑定的初始化</figcaption></figure><h1 id="6b1a" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">如何在项目中使用可拖动组件</h1><ol class=""><li id="02f8" class="ju jv hi ih b ii lg im lh iq mm iu mn iy mo jc ly ka kb kc bi translated">创建MouseService —清单5</li><li id="06fb" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ly ka kb kc bi translated">在Program.cs中注册MouseService清单6</li><li id="8370" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ly ka kb kc bi translated">从GitHub创建可拖动组件</li><li id="8481" class="ju jv hi ih b ii kd im ke iq kf iu kg iy kh jc ly ka kb kc bi translated">订阅SVG事件onmousemove和onmouseup，并触发MouseService事件——清单1</li></ol><h1 id="b102" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">链接</h1><p id="2daa" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated"><a class="ae jd" href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#overwritten-parameters-1" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/aspnet/core/blazor/components/？view = aspnetcore-5.0 # overwritten-parameters-1</a></p><p id="a073" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://docs.microsoft.com/en-us/aspnet/core/blazor/components/data-binding?view=aspnetcore-3.1#parent-to-child-binding-with-component-parameters" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/aspnet/core/blazor/components/data-binding？view = aspnetcore-3.1 #父子绑定组件参数</a></p><p id="f02c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://chrissainty.com/3-ways-to-communicate-between-components-in-blazor/" rel="noopener ugc nofollow" target="_blank">https://chrissainty . com/3-ways-to-communication-between-components-in-blazor/</a></p><p id="50c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://visualstudiomagazine.com/articles/2020/01/27/suppressing-events-blazor.aspx" rel="noopener ugc nofollow" target="_blank">https://visual studio magazine . com/articles/2020/01/27/suppressing-events-blazor . aspx</a></p></div></div>    
</body>
</html>