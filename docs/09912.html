<html>
<head>
<title>5 Rules for .Net Services Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">的5条规则。网络服务优化</h1>
<blockquote>原文：<a href="https://medium.com/codex/5-rules-for-net-service-optimizations-cf45e5517e08?source=collection_archive---------2-----------------------#2022-11-19">https://medium.com/codex/5-rules-for-net-service-optimizations-cf45e5517e08?source=collection_archive---------2-----------------------#2022-11-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/94771d68b49995d1f0ab01732851fcb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tNY5VqbDeRjEkxDy"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">约书亚·厄尔在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="63de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不管你在哪个框架上工作，也不管你服务的目的是什么，我们作为工程师总是在寻找优化的机会。它可以是重构一个方法以使其更短，改变架构以节省内存，使用利用CPU消耗的新功能或其他方式。</p><p id="af45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我将提出五条规则，帮助我们将应用程序或服务提升到一个新的水平。例如。NET，但它们也与其他框架相关。</p><h2 id="ee4e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">始终监控。</h2><p id="fd46" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">当我们在产品中监控我们的服务时，我们也应该监控开发周期中的性能。现在，ide有高效的内置工具，可以显示应用程序运行期间的内存和CPU消耗。我们应该时刻关注这些——寻找异常和尖峰。这将有助于我们找到可以优化的领域，并量化我们的任何回归或改进。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/ac593da8e31877500d14310ec43eca7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*CtLCEjWl7kbb8vBj-xdArQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Visual Studio 2022诊断工具</figcaption></figure><p id="39e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我发现一个对这项任务非常有用的工具是JetBrains <a class="ae iu" href="https://www.jetbrains.com/dotmemory/" rel="noopener ugc nofollow" target="_blank"> DotMemory </a>，它运行EXE文件并在它们的生命周期中监控它们的内存使用情况。DotMemory还可以在特定时间拍摄快照，并在选定的时间点给出更好的内存利用率建议(字符串复制功能非常棒)。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/eff353d9ac39b3fcf09935e591b28816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZGcfGctSyMnxTbqXD_dJw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">JetBrains点记忆工具</figcaption></figure><h2 id="1f97" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">使用最新版本。</h2><p id="a552" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我们生活在一个时代，开发者工具是行业中最热门的领域之一，成千上万有才华的工程师努力工作，让我们的生活更轻松，让我们的应用更快。为什么不从中受益呢？</p><p id="b776" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将框架更新到最新版本，几乎免费享受性能改进(对于某些版本，可能会有小的突破性变化)。从安全角度来说，也建议使用最新的框架版本，因为它通常包含漏洞缓解措施。</p><p id="fab4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，在下面的博客中，你可以看到。Net 6相比之前的版本有显著的改进:<a class="ae iu" href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-aspnet-core-6/" rel="noopener ugc nofollow" target="_blank">ASP.NET Core 6的性能提升</a>。文章中真正吸引我眼球的是不同框架上的安全WebSocket连接(WSS)的内存使用情况。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es kz"><img src="../Images/6df3d6673a98e97656a784c94be1b407.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*JsvJTqkTaKGRUCvf31qH6A.png"/></div></figure><p id="456d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从net5.0到net6.0几乎减少了4倍的内存！</p><h2 id="bd35" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">懂GC。</h2><p id="19d7" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">垃圾收集器(GC)可以是我们最好的朋友，也可以是最坏的敌人，这取决于我们的观点。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/8a9e7162ec87f3a97a4cba2c2f2bc2e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UpCpX6pkTIzwVeKx"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">齐比克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2e8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在公共语言运行时(CLR)中，GC充当自动内存管理器。GC管理应用程序的内存分配和释放。对于使用托管代码的开发人员来说，这意味着不需要编写执行内存管理任务的代码。自动内存管理可以消除常见的问题，例如内存泄漏或对已经释放的对象的内存访问。</p><p id="de50" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">英寸Net中，应用程序内存被分成几个独立的块:</p><ul class=""><li id="e662" class="lb lc hi ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">3种类型的层代(Gen0、Gen1、Gen2)，用于保存小对象。</li><li id="1ede" class="lb lc hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">大对象堆(LOH)，它保存大于85K字节的对象。</li></ul><p id="8c3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">的。Net GC算法基于几个考虑因素:</p><ul class=""><li id="02b7" class="lb lc hi ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">压缩部分托管堆的内存比压缩整个托管堆的内存更快。</li><li id="eb78" class="lb lc hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">较新的对象生存期较短，较旧的对象生存期较长。</li><li id="8725" class="lb lc hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">较新的对象倾向于彼此相关，并由应用程序在大约相同的时间访问。</li></ul><p id="cce7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，GC听起来很棒！但是权力越大，责任越大。GC操作会消耗CPU资源，所以当GC运行时，它会阻塞或减慢您的服务。</p><p id="e94d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了改进服务中的GC过程，建议阅读并了解潜在的改进和特性(比如服务器的GC模式)。我推荐微软的这个很棒的文档:<a class="ae iu" href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/standard/garbage-collection/</a>。确保理解它是如何工作的——这将对你帮助最大。</p><h2 id="f732" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">避免反射。</h2><p id="6276" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">反射提供了获取信息和访问类型和对象成员的能力。比如调用构造函数、设置属性值、添加事件处理程序等。</p><pre class="ku kv kw kx fd lp lq lr bn ls lt bi"><span id="7148" class="lu ju hi lq b be lv lw l lx ly">// Reflection example<br/>using System.Reflection;<br/><br/>int i = 42;<br/>Type type = i.GetType();<br/>FieldInfo[] fields = type.GetFields();<br/>foreach (var field in fields)<br/>{<br/>    Console.WriteLine(field.Name);<br/>}</span></pre><p id="79ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用反射来获取有关类型和成员的信息是不受限制的。我们总是可以使用反射来执行以下任务:</p><ul class=""><li id="ec79" class="lb lc hi ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">枚举类型和成员并检查它们的元数据。</li><li id="e8ad" class="lb lc hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">枚举和检查程序集和模块。</li></ul><p id="64dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然反射是一个强大的工具，可以帮助编写复杂的代码，但它也有许多缺点:</p><ul class=""><li id="14de" class="lb lc hi ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">人们常说，平均而言，反射比通过访问器获取数据慢大约1000倍。</li><li id="a3a4" class="lb lc hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">反射可能存在安全风险。一些问题在更新的。Net版本。还记得“使用最新版本”一节吗？😊</li><li id="0cf2" class="lb lc hi ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">对于糟糕的设计来说，反射可能是一种“代码味道”。。Net是面向对象(OO)语言是有原因的。当开发人员使用反射时，他们破坏了面向对象方法。它可以表明做错了什么。</li></ul><h2 id="52bc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">神圣的琴弦。</h2><p id="8c41" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">琴弦很棒，很有用，也很漂亮。它们在任何代码库中都非常常见，但也很棘手。在大多数编程语言中，包括C#，字符串是一个对象char对象的集合。这就是为什么一个字符串将被保存在堆上，而它的指针将位于。</p><p id="ca28" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">值得一提的是，字符串是不可变的。它回答说，任何字符串连接都会导致新的字符串分配。这将导致更长的运行时间、更多的内存分配和额外的GC工作。</p><p id="ff25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果可能，请尽量避免使用以下语法:</p><pre class="ku kv kw kx fd lp lq lr bn ls lt bi"><span id="728e" class="lu ju hi lq b be lv lw l lx ly">var str1 = "Hello";<br/>var str2 = "World";<br/>var newStr = str1 + ' ' + str2;</span></pre><p id="115f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并遵循以下内容:</p><pre class="ku kv kw kx fd lp lq lr bn ls lt bi"><span id="6e94" class="lu ju hi lq b be lv lw l lx ly">var str1 = "Hello";<br/>var str2 = "World";<br/>var strBuilder = new StringBuilder(str1);<br/>strBuilder.Append(' ');<br/>strBuilder.Append(str2);<br/>var newStr = strBuilder.ToString();</span></pre><p id="f92c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">至于字符串内插，总是倾向于选择<code class="du lz ma mb lq b">$</code>——一个特殊字符将字符串文字标识为内插的字符串，而不是连接。字符串插值在较新版本中进行了优化。Net版本，而且，在我看来，它也更具可读性。</p><p id="587c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的字符串也可以用于节省内存。在常用的字符串上使用<code class="du lz ma mb lq b">const</code>将使编译器只保留对象的一个副本，并在每次使用时引用它。在内存密集型系统中，创建原子化字符串会很有用。它将缓存字符串，同时检查具有重复数据的大数据结构。如上所述，DotMemory有一个字符串复制特性，可以帮助处理服务中的字符串。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="d4be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的服务表现总有需要改进的地方。请记住这一点，并寻找下一个将推动针的增强。像我们一样，我们的服务应该永远比昨天更好。</p><p id="4a57" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>