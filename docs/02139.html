<html>
<head>
<title>On Command Injection over Java’s ProcessBuilder</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Java process builder的命令注入研究</h1>
<blockquote>原文：<a href="https://medium.com/codex/on-command-injection-over-javas-processbuilder-8d9f833c808c?source=collection_archive---------1-----------------------#2021-07-03">https://medium.com/codex/on-command-injection-over-javas-processbuilder-8d9f833c808c?source=collection_archive---------1-----------------------#2021-07-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c94c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">一个示例代码的安全性分析</h2></div><p id="426d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ProcessBuilder是一个用于创建操作系统进程的Java类。因此，不用说，如果编码不安全，就会导致严重的安全风险。在本帖中，我们将回顾一个利用ProcessBuilder的示例代码块，并通过分析揭示一些安全代码的最佳和不良实践。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/9ee6fe6dec82e88d654b9549f0e4dc03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NOvyWYG04I-nFccVf2TBSQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">API为开发人员提供了巨大的力量。但是，很容易毁了一切。*</figcaption></figure><p id="2f59" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，事不宜迟，下面是代码块；</p><pre class="ju jv jw jx fd kj kk kl km aw kn bi"><span id="586f" class="ko kp hi kk b fi kq kr l ks kt">String path = "C:\\Windows\\system32\\cmd.exe";</span><span id="6d24" class="ko kp hi kk b fi ku kr l ks kt">ProcessBuilder pb = new ProcessBuilder(path);<br/>pb.command().add("/c");<br/>pb.command().add("ping.exe");<br/>pb.command().add(<strong class="kk hj">userInput</strong>);</span><span id="772c" class="ko kp hi kk b fi ku kr l ks kt">Process pingProcess = pb.start();</span></pre><p id="5459" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们阅读并评论这段简单的代码。它将用户输入(user input)作为参数，并使用它执行ping命令。</p><p id="e492" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看Windows帮助文档是如何讲述给予cmd.exe的<strong class="iz hj"> /c </strong>选项的；</p><blockquote class="kv kw kx"><p id="4e0d" class="ix iy ky iz b ja jb ij jc jd je im jf kz jh ji jj la jl jm jn lb jp jq jr js hb bi translated">执行字符串指定的命令，然后终止。</p></blockquote><p id="b37d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">太酷了。在JDK 5.0之前，同样的东西，流行的编码方式是这样的；</p><pre class="ju jv jw jx fd kj kk kl km aw kn bi"><span id="aab6" class="ko kp hi kk b fi kq kr l ks kt">process = Runtime.<em class="ky">getRuntime</em>().exec(path + " /c ping.exe " + userInput);</span></pre><p id="0e4b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只看这两段代码，我们可以很容易地将第二段代码与内联SQL查询执行API相类似，而第一段代码更像是用PreparedStatement的方式来做同样的事情。</p><p id="8cc3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们知道，与动态SQL构造和执行相比，预处理语句或绑定变量是执行SQL查询的安全方式。这是生死攸关的情况，尤其是涉及到用户输入时。</p><h1 id="06df" class="lc kp hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">代码的安全性分析</h1><p id="d186" class="pw-post-body-paragraph ix iy hi iz b ja lt ij jc jd lu im jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated">那么，第一个代码安全吗？或者让我换个说法。如果一个恶意用户可以操纵<em class="ky"> userInput </em>变量的内容，他有可能执行一个随机的操作系统命令吗？在可能的情况下，这被称为命令注入，这是一个流行且严重的安全弱点。</p><p id="6eae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯，我喜欢动态测试的一点是，你总是可以向运行的目标代码块提供危险和智能的字符串，并检查响应。让我们列出一些测试人员可以使用的字符串，以便了解原始代码是否会导致运行Windows calculator可执行文件。</p><pre class="ju jv jw jx fd kj kk kl km aw kn bi"><span id="0691" class="ko kp hi kk b fi kq kr l ks kt">127.0.0.1 &amp;&amp; calc.exe<br/>127.0.0.1 &amp; calc.exe<br/>127.0.0.1 | calc.exe<br/>127.0.0.1 || calc.exe<br/>127.0.0.1 &gt; calc.exe</span></pre><p id="b56b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但我不喜欢动态测试的是，当所有这些模糊不清的东西都毫无结果时，这真的意味着我们是安全的吗？</p><p id="9d98" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在大多数情况下，同样的问题对于静态测试也是有效的，但是这次不行，因为在构建要执行的命令时没有动态字符串连接。然而，这真的意味着我们是安全的吗？</p><p id="22b5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我几乎不这么认为…</p><h1 id="af4f" class="lc kp hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">为什么我们的代码不受命令注入的影响？</h1><p id="1224" class="pw-post-body-paragraph ix iy hi iz b ja lt ij jc jd lu im jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated">我们先来看看为什么不能通过这段代码运行Windows calculator。</p><p id="8af9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了理解为什么，我们不得不钻研Java的ProcessBuilder的源代码。这是一项有些乏味的工作，然而，它可以归结为以下几点:</p><pre class="ju jv jw jx fd kj kk kl km aw kn bi"><span id="5acc" class="ko kp hi kk b fi kq kr l ks kt">for (int i = 1; i &lt; cmd.length; ++i) {<br/>    cmdbuf.append(' ');<br/>    String s = cmd[i];<br/>    if (<em class="ky">needsEscaping</em>(verificationType, s)) {<br/>       <strong class="kk hj">cmdbuf.append('"');<br/>    ...</strong></span></pre><p id="0de0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，Java代码将<strong class="iz hj">双引号</strong>附加到一个数组元素，如果它包含一个空格。我这里说的数组的元素是；</p><pre class="ju jv jw jx fd kj kk kl km aw kn bi"><span id="43fc" class="ko kp hi kk b fi kq kr l ks kt">[0] -&gt; C:\\Windows\\system32\\cmd.exe<br/>[1] -&gt; /c<br/>[2] -&gt; ping.exe<br/>[3] -&gt; userInput</span></pre><p id="9d21" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当<em class="ky"> userInput </em>包含空格时，代码将其用双引号括起来，有效地对其进行了转义，这样它就不会对ping.exe进行转义:)因此，最后一个数组项“127.0.0.1 &amp; &amp; calc.exe”将作为一个整体参数传递给ping.exe。</p><p id="4bb7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是我们调试带有恶意输入的代码并查看数组的toString版本的值时的屏幕截图。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es ly"><img src="../Images/08e3cb8fdc7baeb01dec38683f68b94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_fAD20Ue5llooWs2e0kxA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">双引号用户输入，这意味着它将始终作为ping.exe的参数执行。</figcaption></figure><p id="ecc2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，ProcessBuilder中应用的控件不止一个，但这一个就足够我们理解了。</p><p id="040a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然在这里不可能通过cmd.exe注入命令，但是仍然有可能通过ping.exe导致该代码恶意运行。例如，黑客可以提供像“-n 1000”这样的输入，以便命令运行相当长的时间，这可能会导致拒绝服务的情况。</p><p id="bff7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">顺便说一下，ping的-n参数是“要发送的回送请求的数量”。这里有一个模拟，当提供更高的n数时，显然需要相当长的时间才能完成。</p><pre class="ju jv jw jx fd kj kk kl km aw kn bi"><span id="99bf" class="ko kp hi kk b fi kq kr l ks kt">C:\Users\CodeThreat&gt;ping.exe -n 1000 127.0.0.1</span><span id="2a6e" class="ko kp hi kk b fi ku kr l ks kt">Pinging 127.0.0.1 with 32 bytes of data:<br/>Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128<br/>Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128<br/>Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128<br/>Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128<br/>Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128<br/>Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128<br/>Reply from 127.0.0.1: bytes=32 time&lt;1ms TTL=128<br/>...</span></pre><blockquote class="kv kw kx"><p id="e5b8" class="ix iy ky iz b ja jb ij jc jd je im jf kz jh ji jj la jl jm jn lb jp jq jr js hb bi translated">顺便提一下，即使我们在代码中将一些默认的硬编码参数传递给ping.exe，恶意的用户输入也可能会覆盖这些参数并带来风险。这很像HTTP参数污染弱点。</p></blockquote><h1 id="79a5" class="lc kp hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">那么ProcessBuilder是一个安全的API吗？</h1><p id="05f3" class="pw-post-body-paragraph ix iy hi iz b ja lt ij jc jd lu im jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated">这是值得思考的问题。我们有没有可能用ProcessBuilder写一个不安全的代码？我总是惊讶于我们开发人员如何找到使用相当不错的API编写不安全代码的方法。</p><p id="44ec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，我们当然可以！在这里。</p><pre class="ju jv jw jx fd kj kk kl km aw kn bi"><span id="5e03" class="ko kp hi kk b fi kq kr l ks kt">String path = "C:\\Windows\\system32\\cmd.exe";</span><span id="1508" class="ko kp hi kk b fi ku kr l ks kt">pb = new ProcessBuilder(path, "/c", "ping.exe " + userInput);</span><span id="226f" class="ko kp hi kk b fi ku kr l ks kt">Process pingProcess = pb.start();</span></pre><p id="ae12" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这一次，Windows计算器开始工作，因为最后一个数组项变成了整个命令“ping.exe 127.0.0.1 &amp;&amp; calc.exe”。上面显示的Java源代码会用双引号引起来，shell会很好地解释它。</p><p id="79ef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这不是唯一的方法。这里还有一个，但这次不那么明显；</p><pre class="ju jv jw jx fd kj kk kl km aw kn bi"><span id="a9fa" class="ko kp hi kk b fi kq kr l ks kt">String path = "C:\\Windows\\system32\\cmd.exe";</span><span id="6441" class="ko kp hi kk b fi ku kr l ks kt">ProcessBuilder pb = new ProcessBuilder(path);<br/>pb.command().add("/c");<br/>pb.command().add("ping.exe");<br/>pb.command().addAll(Arrays.<em class="ky">asList</em>(userInput.split("\\s")));</span><span id="380f" class="ko kp hi kk b fi ku kr l ks kt">Process pingProcess = pb.start();</span></pre><p id="b93a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一个是杀手。我来让你分析一下为什么没有安全感。</p><h1 id="a4b4" class="lc kp hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">那么，如何使用ProcessBuilder呢？</h1><p id="8d77" class="pw-post-body-paragraph ix iy hi iz b ja lt ij jc jd lu im jf jg lv ji jj jk lw jm jn jo lx jq jr js hb bi translated">在提供ProcessBuilder或Runtime.exec时，最好不要使用任何shell支持，cmd或sh或任何其他解释器。然而，随着应该运行的命令变得越来越复杂，我们倾向于选择复杂的shell，而不是编写自己的解释器…</p><p id="8720" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，ProcessBuilder提供了一种更细粒度的方法来完成这项任务，然而，正如我们从上面给出的两个例子中可以看到的，编写易受攻击的代码是很容易的。最终，这意味着编写安全代码的责任仍然落在我们的肩上。看看这个<a class="ae lz" href="https://stackoverflow.com/a/31776547" rel="noopener ugc nofollow" target="_blank">很棒所以回答</a>来理解这个困境。</p><p id="dbdb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了最小化这里的安全风险，我的建议是，一旦我们从信任边界之外获得用户输入，就使用白名单。我特别没有在这里使用“用户”这个词，因为发送这个输入的参与者可能是一个配置文件、一个数据库行或者甚至是一个B2B web服务调用的响应字段…</p><p id="da18" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过应用白名单，我们可以很容易地验证一个IP地址，并回避所有模糊的东西，我已经经历了以上！</p><ul class=""><li id="00cd" class="ma mb hi iz b ja jb jd je jg mc jk md jo me js mf mg mh mi bi translated">图片由<a class="ae lz" href="https://pixabay.com/users/stevepb-282134/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=583163" rel="noopener ugc nofollow" target="_blank">史蒂夫·比辛尼</a>拍摄。</li></ul></div></div>    
</body>
</html>