<html>
<head>
<title>This Python library will help you get Stock technical indicators in one line of code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这个Python库将帮助你在一行代码中获得股票技术指标</h1>
<blockquote>原文：<a href="https://medium.com/codex/this-python-library-will-help-you-get-stock-technical-indicators-in-one-line-of-code-c11ed2c8e45f?source=collection_archive---------0-----------------------#2021-08-12">https://medium.com/codex/this-python-library-will-help-you-get-stock-technical-indicators-in-one-line-of-code-c11ed2c8e45f?source=collection_archive---------0-----------------------#2021-08-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3bc6" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">无缝提取基本股票信息到高级技术指标</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/20ac7c0fea3862d8ce9fac5d649f8a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EDUZYqXZZMB4N7ls3sTkog.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@killerfvith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alex wong </a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="738c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">技术指标非常吸引人，总能抓住我的注意力。我对它们进行了大量的研究，并了解到研究技术指标的重要部分是将它们应用到现实世界的市场中，但在此之前，我们需要做一些称为回溯测试的事情，这只是通过对过去的历史数据进行测试来确定策略性能的过程。</p><p id="e598" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在要进行回溯测试过程，有几个平台，但我找不到我需要的灵活性。所以我开始使用Python(我现在仍然是)来编写整个程序，顺便说一下，这非常灵活和有趣。</p><p id="a43d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对我来说，使用Python编写整个程序的唯一缺点是从头开始创建技术指标。为了做到这一点，我们必须首先理解指标的基本思想，其次是它的数学公式(有些有两个或更多)。因此，我决定使用Python包来完成这项工作，但由于两个原因，我仍然无法找到值得注意的库。第一是安装和文件很差，第二是读数不规则。</p><p id="bc29" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我开始遵循我的传统方法，即从头开始构建指标，直到我遇到这个Python库。看，股票统计。它是熊猫数据框架的包装器，提供从基本股票信息到高级技术指标的数据。在本文中，我们将深入研究这个库并探索它的功能。事不宜迟，我们走吧！</p><h1 id="e74e" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">导入包</h1><p id="d834" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">将所需的包导入到我们的python环境中是一个不可避免的步骤。在本文中，我们总共需要五个包，它们是用于处理数据帧的Pandas、用于进行API调用和提取股票数据的请求、用于高级功能的NumPy和用于可视化的Matplotlib，最后是用于访问技术指标和其他基本股票信息的StockStats包。对于那些尚未安装这些软件包的用户，请将以下代码复制到您的终端中:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="f61f" class="lm kl hi li b fi ln lo l lp lq">pip install pandas<br/>pip install requests<br/>pip install numpy<br/>pip install matplotlib<br/>pip install stockstats</span></pre><p id="59bd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">安装完这些包之后，就该将它们导入到我们的python环境中了。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="1eb2" class="lm kl hi li b fi ln lo l lp lq">import requests<br/>import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>from stockstats import StockDataFrame<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20, 10)</span></pre><h1 id="def2" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">提取股票数据</h1><p id="53c0" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">现在，我们已经导入了所有必要的包。让我们使用由<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>提供的API端点提取苹果的历史股票数据。在此之前，关于<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>的一个说明:十二数据是领先的市场数据提供商之一，拥有针对所有类型市场数据的大量API端点。它非常容易与十二数据提供的API进行交互，并且拥有有史以来最好的文档。此外，确保您在<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>拥有账户，只有这样，您才能访问您的API密钥(使用API提取数据的重要元素)。</p><p id="5197" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="a146" class="lm kl hi li b fi ln lo l lp lq">def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>aapl = get_historical_data('AAPL', '2020-01-01')<br/>aapl.tail()</span></pre><p id="6eba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/54f036baa2ee722fce348c4aab3f3d58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l_zjmQdUtZNKJfDgEa12Mw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="fa63" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在上面的代码中，我们做的第一件事是定义一个名为<code class="du ls lt lu li b">get_historical_data</code>的函数，它将股票的符号(<code class="du ls lt lu li b">symbol</code>)和历史数据的起始日期(<code class="du ls lt lu li b">start_date</code>)作为参数。</p><p id="7321" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用<code class="du ls lt lu li b">get</code>函数提取JSON格式的历史数据，并将其存储到<code class="du ls lt lu li b">raw_df</code>变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们调用创建的函数从2020年开始提取苹果的历史数据，并将其存储到<code class="du ls lt lu li b">aapl</code>变量中。</p><h1 id="0915" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">熊猫数据帧到Stockstats数据帧</h1><p id="1d43" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在进行任何操作之前，最重要的事情之一是将Pandas数据帧转换为Stockstats数据帧。在前面的步骤中，我们使用API端点提取了苹果的历史数据，我们转换了JSON响应，并以Pandas dataframe的形式存储它。因此，我们首先必须将其更改为Stockstats数据帧，这可以通过调用包的主类<code class="du ls lt lu li b">StockDataFrame</code>并将数据帧传递给它来轻松完成。按照代码片段来做:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="4504" class="lm kl hi li b fi ln lo l lp lq">aapl = StockDataFrame(aapl)</span></pre><p id="8d10" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在实现了上面的代码之后，您会注意到您的数据帧几乎没有变化，除非您的列是用大写字母命名的，它们会被转换成小写字母。但这并不意味着这一步是可选的，事实上，将数据帧转换成Stockstats格式对于执行任何类型的任务都是强制性的。</p><h1 id="e03d" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">获取技术指标</h1><p id="32a1" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">现在，我们都开始关注本文的主要部分。正如我在标题中提到的，Stockstats以这样一种方式提供技术指标，我们只需编写一行代码，就可以得到想要的结果，顺便说一下，这不是一个虚假的希望，而是一件真实的事情。我们所要做的就是选择列名，就像我们在Pandas数据帧中访问列一样，Stockstats会处理剩下的事情。为了说明它有多简单，让我们看一个例子，在这个例子中，我们将访问具有不同回顾期的SMA的读数:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="d247" class="lm kl hi li b fi ln lo l lp lq">aapl[['close_10_sma', 'close_20_sma', 'close_50_sma']]</span></pre><p id="bdca" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的代码将为我们提供回顾期10、20和50的SMA值。与此同时，这些值将被附加到原始的Apple dataframe上，这是另一个技术分析库所没有的。代码的输出将是一个Stockstats数据帧，如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/54f036baa2ee722fce348c4aab3f3d58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l_zjmQdUtZNKJfDgEa12Mw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">按作者分类的图像(显示数据帧的前五行)</figcaption></figure><p id="8633" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Stockstats希望我们遵循特定的结构来访问技术指标，即<code class="du ls lt lu li b">{columnName_window_statistics}</code>，其中<code class="du ls lt lu li b">columnName</code>是我们在计算指标时要考虑的数据框架中的列，<code class="du ls lt lu li b">window</code>是回望期，<code class="du ls lt lu li b">statistics</code>是我们要访问的指标。在上面的例子中，我们提到<code class="du ls lt lu li b">close</code>作为<code class="du ls lt lu li b">columnName</code>，意味着我们要考虑苹果的收盘价，<code class="du ls lt lu li b">10,20,50</code>作为回望期，<code class="du ls lt lu li b">sma</code>作为我们要访问的统计数据或技术指标。</p><p id="04a3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Stockstats不仅允许我们访问简单移动平均线等基本技术指标，还为许多其他高级指标打开了大门，如布林线、相对强度指数、威廉姆斯%R、移动平均线收敛/发散、商品通道指数等。以下代码片段将访问上述所有高级技术指标，遵循与SMA代码相同的结构。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="c04c" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># 1. BOLLINGER BANDS<br/></strong>aapl[['boll', 'boll_ub', 'boll_lb']]<br/><br/><strong class="li hj"># 2. RSI<br/></strong>aapl[['rsi_11', 'rsi_14', 'rsi_21']]<br/><br/><strong class="li hj"># 3. WILLIAMS %R<br/></strong>aapl[['wr_11', 'wr_14', 'wr_21']]<br/><br/><strong class="li hj"># 4. MACD<br/></strong>aapl[['macd', 'macdh', 'macds']]<br/><br/><strong class="li hj"># 5. COMMODITY CHANNEL INDEX<br/></strong>aapl[['cci_11', 'cci_14', 'cci_21']]</span></pre><p id="8a2d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上述代码中的每一行都将访问不同回顾期的指标，并将这些值附加到原始数据帧中。可以注意到，我在访问技术指标时使用了双括号，这是因为Stockstats构建在Pandas dataframe类之上，并且仍然保留其功能，因此，当使用单括号时，输出将是Pandas系列的形式。因为我希望输出在Pandas数据帧中，所以我使用了双括号。</p><h1 id="710b" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">产生贸易信号</h1><p id="0fef" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">Stockstats的独特之处之一是它能够从提到的交易策略中产生信号。这太棒了，因为算法交易就是产生交易信号，没有它，创造的交易策略就会过时。就像我们如何访问技术指标一样，这也只需要一行代码，但结构不同。当SMA 20在SMA 50上方交叉时，下面的代码片段产生进场交易信号:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="bdc8" class="lm kl hi li b fi ln lo l lp lq">aapl['close_50_sma_xd_close_20_sma']</span></pre><p id="2efc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的代码给出了一系列布尔值作为输出，如果条件得到满足，这些值就变成<code class="du ls lt lu li b">True</code>，否则，这些值就是<code class="du ls lt lu li b">False</code>。下面的代码将通过生成进场和出场交易信号使这一策略更上一层楼，从而使策略在本质上更加现实:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="8636" class="lm kl hi li b fi ln lo l lp lq">buy_signals = aapl['close_50_sma_xd_close_20_sma']<br/>sell_signals = aapl['close_20_sma_xd_close_50_sma']</span><span id="11bc" class="lm kl hi li b fi lv lo l lp lq">for i in range(len(buy_signals)):<br/>    if buy_signals.iloc[i] == True:<br/>        buy_signals.iloc[i] = aapl.close[i]<br/>    else:<br/>        buy_signals.iloc[i] = np.nan</span><span id="79a8" class="lm kl hi li b fi lv lo l lp lq">for i in range(len(sell_signals)):<br/>    if sell_signals.iloc[i] == True:<br/>        sell_signals.iloc[i] = aapl.close[i]<br/>    else:<br/>        sell_signals.iloc[i] = np.nan<br/>        <br/>plt.plot(aapl['close'], linewidth = 2.5, label = 'AAPL')<br/>plt.plot(aapl['close_20_sma'], linewidth = 2.5, alpha = 0.6, label = 'SMA 20')<br/>plt.plot(aapl['close_50_sma'], linewidth = 2.5, alpha = 0.6, label = 'SMA 50')<br/>plt.plot(aapl.index, buy_signals, marker = '^', markersize = 15, color = 'green', linewidth = 0, label = 'BUY SIGNAL')<br/>plt.plot(aapl.index, sell_signals, marker = 'v', markersize = 15, color = 'r', linewidth = 0, label = 'SELL SIGNAL')<br/>plt.legend(loc = 'upper left')<br/>plt.title('AAPL SMA 20,50 CROSSOVER STRATEGY SIGNALS')<br/>plt.show()</span></pre><p id="1693" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们逐行分解代码。在前两行代码中，我们使用Stockstats生成进场和出场交易信号，并将值保存到各自的变量中。之后，我们将创建两个for循环，如果值为<code class="du ls lt lu li b">True</code>，将使用股票的收盘价替换交易信号，否则，<code class="du ls lt lu li b">False</code>值将被NaN替换。下面几行绘制了创建的交易信号，以及苹果的收盘价和计算出的SMA 20，50，这将产生如下所示的输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/1a271876740ddeaf3e15a09d5d70e86f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_SLbbjKih8ts3YITkda6Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="61f9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从上面的图表可以看出，每当红线(SMA 20)越过金线(SMA 50)时，买入信号用绿色绘制，同样，每当金线越过红线时，卖出信号用红色绘制。</p><h1 id="f0fd" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后的想法！</h1><p id="7b94" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在本文中，我们简要地看了一下Stockstats库，更不用说，它确实是一个非常棒的库。值得一提的是，Stockstats不仅支持技术指标并生成交易信号，还允许我们访问基本的股票信息，如价格、回报等的变化。</p><p id="1d4f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个软件包目前唯一的缺点是它的文档很差，需要一千年才能完全理解。尽管这个包不像Pandas和NumPy那样庞大，但保持完美的文档是必不可少的，因为它是一个包装器库，所提供的函数很复杂并且与其他函数不同。非常感谢<a class="lx ly ge" href="https://medium.com/u/44bc27317e6b?source=post_page-----c11ed2c8e45f--------------------------------" rel="noopener" target="_blank">艾里克·林森</a>通过他的<a class="ae jn" href="https://towardsdatascience.com/stockstats-a-handy-stocks-oriented-pandas-dataframe-wrapper-a879a06d9c3f" rel="noopener" target="_blank">精彩文章</a>向我介绍了这个包(强烈推荐查看)。</p><p id="ec11" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">总之，Stockstats是独一无二的，对于任何刚进入技术分析领域的人来说都是一个很好的库，它提供了强大的功能，只需一行代码就可以访问，最终减少了程序员的工作量并节省了时间。话虽如此，你已经到了文章的结尾。希望你能从这篇文章中学到一些有用的新东西。</p><p id="f577" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">赞助:</strong> <a class="ae jn" href="https://eodhistoricaldata.com/r/?ref=DHY3H8NT" rel="noopener ugc nofollow" target="_blank"> EOD历史数据</a>是金融应用编程接口市场的领导者之一，提供各种各样的应用编程接口，从基本的每日市场数据到高度可定制的应用编程接口，如金融新闻应用编程接口和股票筛选应用编程接口。他们所有的API都是以一种本质上易于使用的方式设计的，因此初学者可以毫无障碍地使用它们。我个人使用过<a class="ae jn" href="https://eodhistoricaldata.com/r/?ref=DHY3H8NT" rel="noopener ugc nofollow" target="_blank"> EOD历史数据公司的</a>API，从我的经验来看，他们的API既适合专业人士，也适合业余爱好者，用于辅助项目和构建企业级应用。</p></div></div>    
</body>
</html>