<html>
<head>
<title>Master Keras’ ImageDataGenerator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">主Keras的图像数据生成器</h1>
<blockquote>原文：<a href="https://medium.com/codex/master-keras-imagedatagenerator-class-989ea21fc489?source=collection_archive---------4-----------------------#2021-01-06">https://medium.com/codex/master-keras-imagedatagenerator-class-989ea21fc489?source=collection_archive---------4-----------------------#2021-01-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/e0b8baa5160a663fd8a8e8b69b29d8d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*40oaXBc5ETTfJuuX"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由<a class="ae hv" href="https://unsplash.com/@margotd1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">玛格丽特·韦尔</a>在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><div class=""><h2 id="c4cc" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated">训练深度学习模型而不用担心记忆</h2></div><p id="dd40" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">对于所有希望使用图像数据为分类任务开发深度学习模型的新手、热切的数据科学家来说，你们来对地方了！</p><p id="168e" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这篇文章中，我将解释使用Keras API正确训练深度学习模型的最简单方法，更具体地说是<strong class="jp hz">imagedata generator类</strong>，以及适当利用自己的数据和数据结构所需的所有位和块。这在处理大量图像时变得非常有价值，而依靠RAM来使你的数据随时可用是不可行的。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="fd54" class="kq kr hy bd ks kt ku kv kw kx ky kz la je lb jf lc jh ld ji le jk lf jl lg lh bi translated">1.您的数据是如何组织的？</h1><p id="cce2" class="pw-post-body-paragraph jn jo hy jp b jq li iz js jt lj jc jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">在训练深度学习模型时，数据结构是非常重要的。拥有一个定制的、有组织的结构肯定会让你的生活更轻松，尤其是在使用图像数据的时候。</p><p id="b65d" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">根据您的图像数据集，您可能在特定的文件夹中有松散的图像，或者在不同的子文件夹中有每类数据，甚至在每个图像的子文件夹中有一个图像，这在处理医疗数据时很常见，因为每个文件夹可能代表不同的患者。然而，Keras提供了两种主要方法来处理大图像数据。</p><h2 id="1196" class="ln kr hy bd ks lo lp lq kw lr ls lt la jw lu lv lc ka lw lx le ke ly lz lg ma bi translated"><strong class="ak">训练和验证子文件夹</strong></h2><p id="b688" class="pw-post-body-paragraph jn jo hy jp b jq li iz js jt lj jc jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">将数据放在两个不同的文件夹中分别用于模型训练和模型验证是最直接、最自然的组织方式。在<em class="mb"> Train </em>和<em class="mb"> Validation </em>文件夹中，有更多的子文件夹，与数据的类别数量一样多，最后，在每个类别子文件夹中，您可以找到图像。为了更清楚，下面有一个<strong class="jp hz">子文件夹方法</strong>的例子:</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="1c37" class="ln kr hy mh b fi ml mm l mn mo">image_data/<br/>           /train/<br/>                  /class_1/<br/>                           image1.png<br/>                           image2.png<br/>                           .<br/>                           . </span><span id="5d0f" class="ln kr hy mh b fi mp mm l mn mo">                  /class_2/<br/>                           .<br/>                           .<br/>                           .</span><span id="d4ac" class="ln kr hy mh b fi mp mm l mn mo">          /validation/<br/>                      /class_1/<br/>                               .<br/>                               .<br/>                               .</span><span id="4f6a" class="ln kr hy mh b fi mp mm l mn mo">                     /class_2/<br/>                               .<br/>                               .<br/>                               .</span></pre><p id="39ea" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">从上面可以清楚地看到，主文件夹中有两个子文件夹，它们又有对应于数据集每个类的子文件夹。一些数据集已经按照这种结构进行了组织，但是，如果您从一开始就没有这种数据结构，那么通过定义一个训练分割(通常为0.8)，然后相应地组织您的图像(80%的图像将用于训练，20%用于验证)，就可以相对容易地完成。</p><p id="e3c7" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">按照类别以及训练和验证文件夹来组织图像是机器学习中最常见的组织方案，也是大型数据集的首选。</p><p id="2197" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">注意:</strong>如果您的数据是用每个图像的子文件夹(即医疗数据)组织的，您可能要考虑第二种方法，因为将每个图像从其文件夹移动到另一个文件夹可能会很麻烦。</p><h2 id="527a" class="ln kr hy bd ks lo lp lq kw lr ls lt la jw lu lv lc ka lw lx le ke ly lz lg ma bi translated"><strong class="ak">带有图像路径和相应类别的数据帧</strong></h2><p id="c39a" class="pw-post-body-paragraph jn jo hy jp b jq li iz js jt lj jc jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">如果您正在使用以特定方式组织的影像数据集，并且您想知道将训练和验证文件夹放在一起会有多麻烦，请不要担心！有一个功能一样的替代品。</p><p id="65f3" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Keras的ImageDataGenerator允许另一种方法，它不需要包含所有不同类的培训文件夹和验证文件夹。然而，它需要<strong class="jp hz">一个有两列</strong>的数据帧:第一列应该包含<strong class="jp hz">图像的完整路径</strong>和<strong class="jp hz">第二列对应的类</strong>。这对于提供包含文本/数字要素以及图像路径的. csv文件的数据集尤其有用。</p><figure class="mc md me mf fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mq"><img src="../Images/410b81b0169faf85f9308fc5f19ab251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_eYaLImB26Xt9uawCRS1Sw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">包含图像路径和相应标签的示例数据帧。作者图片</figcaption></figure><p id="00fe" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">请注意，您将需要一个用于训练集的数据帧，以及另一个用于验证图像的数据帧！</p><p id="4818" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在您的数据已经组织好了，一切都准备好了！让我们开始制造那些发电机。</p><h1 id="00b8" class="kq kr hy bd ks kt mr kv kw kx ms kz la je mt jf lc jh mu ji le jk mv jl lg lh bi translated">2.建筑图像生成器</h1><p id="1432" class="pw-post-body-paragraph jn jo hy jp b jq li iz js jt lj jc jv jw lk jy jz ka ll kc kd ke lm kg kh ki hb bi translated">现在您的数据已经组织好了，我们终于可以开始导入图像并构建批量数据了。</p><p id="b7e4" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">建造发电机的第一步是…你猜对了！检查依赖性。这种情况下唯一需要的依赖项主要是<em class="mb"> Tensorflow </em>和<em class="mb"> Pandas </em>，如果你使用dataframe方法的话。如果您尚未安装Tensorflow，您可以使用命令提示符通过<em class="mb"> pip </em>进行安装。熊猫应该是预装的，所以不用担心。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="814a" class="ln kr hy mh b fi ml mm l mn mo">pip install tensorflow</span></pre><p id="a570" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">之后，用必要的导入开始你的脚本/笔记本。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="6918" class="ln kr hy mh b fi ml mm l mn mo">import pandas as pd<br/>from tensorflow import keras<br/>from keras.preprocessing.image import ImageDataGenerator</span></pre><p id="acfa" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">很好！现在，不管您的数据结构如何，下一步是构建ImageDataGenerator对象。根据<a class="ae hv" href="https://keras.io/api/preprocessing/image/#imagedatagenerator-class" rel="noopener ugc nofollow" target="_blank"> Keras文档</a>，可以实现多种数据增强技术，如旋转、裁剪、放大/缩小等。，使用ImageDataGenerator对象，并声明要应用于每个图像的预处理函数。现在，我们将构建一个简单的ImageDataGenerator对象。例如，如果您打算将数据扩充技术应用于验证集或测试集，而不是定型集，也可以创建多个ImageDataGenerator对象。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="1de0" class="ln kr hy mh b fi ml mm l mn mo">data_generator = ImageDataGenerator()</span></pre><p id="d44c" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">有许多不同的参数来定制表示方法，如Keras文档中的<a class="ae hv" href="https://keras.io/api/preprocessing/image/#flowfromdataframe-method" rel="noopener ugc nofollow" target="_blank"><em class="mb"/></a>所示。在<em class="mb"> flow_from_dataframe() </em>方法中使用的最重要的是:</p><ul class=""><li id="169f" class="mw mx hy jp b jq jr jt ju jw my ka mz ke na ki nb nc nd ne bi translated">包含图像路径和类的熊猫数据帧</li><li id="1d9f" class="mw mx hy jp b jq nf jt ng jw nh ka ni ke nj ki nb nc nd ne bi translated"><strong class="jp hz">目录</strong> =如果数据帧中声明的路径不是绝对路径，则应在此声明存储图像的目录。</li><li id="d7c6" class="mw mx hy jp b jq nf jt ng jw nh ka ni ke nj ki nb nc nd ne bi translated"><strong class="jp hz"> x_col </strong> =包含图像路径的数据帧中的列</li><li id="8b6a" class="mw mx hy jp b jq nf jt ng jw nh ka ni ke nj ki nb nc nd ne bi translated"><strong class="jp hz"> y_col </strong> =包含图像类的数据帧中的列</li></ul><p id="3831" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在<em class="mb"> flow_from_directory() </em>方法中，只有一个特定的参数:</p><ul class=""><li id="d258" class="mw mx hy jp b jq jr jt ju jw my ka mz ke na ki nb nc nd ne bi translated"><strong class="jp hz">目录</strong> =包含训练和验证文件夹的主文件夹的路径</li></ul><p id="1277" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然而，定义两种方法共享的一些额外参数是很重要的:</p><ul class=""><li id="a2b6" class="mw mx hy jp b jq jr jt ju jw my ka mz ke na ki nb nc nd ne bi translated"><strong class="jp hz"> target_size </strong> =一个元组，包含您希望图像采用的尺寸/调整到的尺寸。默认的尺寸是(256，256)，不考虑图片的大小，所以我总是声明目标尺寸。</li><li id="37ba" class="mw mx hy jp b jq nf jt ng jw nh ka ni ke nj ki nb nc nd ne bi translated"><strong class="jp hz"> color_mode </strong> =声明颜色通道数量的字符串。默认为<em class="mb">‘RGB’</em>，所以如果想要灰度或者RGBA图像，就声明为<em class="mb">‘灰度’</em>或者<em class="mb">‘rgba’</em>。</li><li id="4838" class="mw mx hy jp b jq nf jt ng jw nh ka ni ke nj ki nb nc nd ne bi translated"><strong class="jp hz"> class_mode </strong> =定义模型分类类型的字符串。如果模型的输出层只有一个节点和sigmoid激活，使用<em class="mb">‘二进制’</em>，如果它的节点数与类数相同，并且有一个softmax激活，使用<em class="mb">‘分类’</em>。</li><li id="069c" class="mw mx hy jp b jq nf jt ng jw nh ka ni ke nj ki nb nc nd ne bi translated"><strong class="jp hz"> batch_size </strong> =定义每批图像数量的整数。默认值为32。</li></ul><p id="dfa8" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果您已经在<strong class="jp hz">训练和验证文件夹</strong>中组织了图像数据，使用<em class="mb"> flow_from_directory() </em>方法，如下所示。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="2fa4" class="ln kr hy mh b fi ml mm l mn mo">training_generator = data_generator.flow_from_directory(<br/>    directory= 'image_data/training',<br/>    batch_size= 64,<br/>    target_size= (500,500),<br/>    color_mode= 'grayscale',<br/>    class_mode= 'binary'<br/>)</span><span id="3af5" class="ln kr hy mh b fi mp mm l mn mo">validation_generator = data_generator.flow_from_directory(<br/>    directory= 'image_data/validation',<br/>    batch_size= 64,<br/>    target_size= (500,500),<br/>    color_mode= 'grayscale',<br/>    class_mode= 'binary'<br/>)</span></pre><p id="e96b" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然而，如果您的数据是根据包含图像路径和类的<strong class="jp hz">数据帧</strong>来组织的，您应该使用<em class="mb"> flow_from_dataframe() </em>方法。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="5110" class="ln kr hy mh b fi ml mm l mn mo">training_generator = data_generator.flow_from_dataframe(<br/>    dataframe= training_dataframe,<br/>    x_col= 'paths',<br/>    y_col= 'labels',<br/>    batch_size= 128,<br/>    target_size= (350,350),<br/>    color_mode= 'rgba',<br/>    class_mode= 'categorical'<br/>)</span><span id="97c1" class="ln kr hy mh b fi mp mm l mn mo">validation_generator = data_generator.flow_from_directory(<br/>    directory= validation_dataframe,<br/>    batch_size= 128,<br/>    target_size= (350,350),<br/>    color_mode= 'rgba',<br/>    class_mode= 'categorical'<br/>)</span></pre><p id="789c" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">太棒了。由于我们刚刚创建的生成器的特殊设计，想到您可以利用大型图像数据集而不需要大量计算能力，这真是令人惊讶:</p><p id="eb01" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">尽管它们批处理了我们想要的那么多图像，但创建它们只需要很少甚至不需要内存，因为批处理只在您尝试访问生成器时生成:在训练阶段，或者当您调用特定的批处理时。</strong></p><p id="e28f" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我第一次使用图像生成器时，我很难理解它们的结构，所以我深入研究了它们。此外，我的结论是，这样做很重要，只是为了确认生成的图像具有所需的特征。可以通过订阅访问生成的批处理:</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="ce5d" class="ln kr hy mh b fi ml mm l mn mo">first_batch= training generator[0]</span></pre><p id="caf9" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">每个批次由一个大小为2的元组表示，其中第一项是一个包含图像的数组，第二项是另一个包含标签的数组。因此，如果您想检查ImageDataGenerator是否正确地拾取了您的图像，我建议绘制生成的图像。下图是第一批中的第一幅图像。</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="e6bf" class="ln kr hy mh b fi ml mm l mn mo">generated_image = training_generator[0][0][0]<br/>matplotlib.pyplot.imshow(generated_image)</span></pre><h1 id="c7a7" class="kq kr hy bd ks kt mr kv kw kx ms kz la je mt jf lc jh mu ji le jk mv jl lg lh bi translated">3.该训练了！</h1><figure class="mc md me mf fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nk"><img src="../Images/2a4175be054a14f34aa412a2680e3121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ycN9nF7l4sUfLVJu"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">维克多·弗雷塔斯在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ae84" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">数据准备好了，该训练模型了！使用Keras和图像生成器来训练深度学习模型是非常容易的。假设你已经建立了一个深度学习模型，你只需要编译它并训练它。在<strong class="jp hz"> model.fit() </strong>方法中，您不需要声明<em class="mb"> y </em>和<em class="mb"> batch_size </em>参数，因为这些参数已经包含在生成器对象中。因此，在编译完您的架构之后，一个<em class="mb"> fit() </em>方法将看起来像这样:</p><pre class="mc md me mf fd mg mh mi mj aw mk bi"><span id="270a" class="ln kr hy mh b fi ml mm l mn mo">model.fit(<br/>    training_generator,<br/>    epochs = 100,<br/>    validation_data = validation_generator<br/>)</span></pre><p id="5170" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">就是这样！您现在可以使用您想要的多少图像来训练模型，而不用担心内存或输入形状，所有这些都在一天的工作中完成！</p><p id="c770" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我希望你理解了处理大量图像的基本原理和Keras图像生成器的潜力！</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="5c8e" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="mb">如有任何问题，欢迎留言评论！</em></p><p id="66c6" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="mb">玩得开心！</em>😄</p></div></div>    
</body>
</html>