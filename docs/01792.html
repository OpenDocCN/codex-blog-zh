<html>
<head>
<title>JavaScript Data Structures and Algorithms (Recursion, Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript数据结构和算法(递归，第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/javascript-data-structures-and-algorithms-recursion-part-1-fb2c33ccbc17?source=collection_archive---------8-----------------------#2021-05-31">https://medium.com/codex/javascript-data-structures-and-algorithms-recursion-part-1-fb2c33ccbc17?source=collection_archive---------8-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7621f3965a0fe564cd7913af46176665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eQftGgfyrTG9NDnY"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@smnzhu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西蒙朱</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="0164" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你好，欢迎光临！如果您不是第一次阅读，那么我希望您已经阅读了本系列的前一篇文章，其中介绍了树数据结构中的搜索算法的基础知识(如果没有，那么您可以阅读前一篇文章的第2部分<a class="ae iu" rel="noopener" href="/@oaluna/javascript-data-structures-and-algorithms-search-algorithms-part-2-6f7c577b32e9">这里</a>，或者<a class="ae iu" rel="noopener" href="/@oaluna/javascript-algorithms-and-data-structures-search-algorithms-part-1-8270911d5f84">这里</a>第1部分)。</p><p id="d416" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天我将谈论一个编程概念，我发现这个概念至今仍难以理解。没错，今天我们来谈谈<em class="jt">递归</em>。递归是一种解决问题的技术，在这种技术中，一个给定的解决方案(或者在我们的例子中，是一个函数)调用它自己来解决问题。一位不知名的编程圣人曾经说过:</p><blockquote class="ju jv jw"><p id="b828" class="iv iw jt ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">"为了理解递归，必须理解递归."</p></blockquote><p id="c5ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅仅是这句话就为我揭开了众所周知的困惑的面纱，也让我明白了这句话的真正含义。说到这里，让我们开始吧！</p><h1 id="c420" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">递归方法</h1><p id="5217" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">正如我前面提到的，编程中的递归是一种解决问题的方法，其中函数调用自身来解决给定的问题。这是一个简单的定义，但是自从我第一次了解到这个编程概念(直到我发现这个匿名引用，见上)以来，它就让我晕头转向。这是一种我们至少用过一次的解决问题的技巧，尽管你可能不记得了。如果你曾经求解过阶乘，比如必须求出5的值！在学校，那么你在生活中至少用过一次递归。递归作为一种解决问题的模式，在同一个函数体内调用一个函数。递归要求重复进行，将数据分解到其最低值，也称为递归函数的<em class="jt">基例</em>。</p><p id="0f4d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看一个阶乘表达式(别担心，这不是复杂的数学)。提醒一下，阶乘是从1到<em class="jt"> n的所有非零整数的乘积。可以评估为<strong class="ix hj"> 5 * 4 * 3 * 2 * 1 </strong>，等于<strong class="ix hj"> 120 </strong>。让我们构建一个接收数字<em class="jt"> n </em>并返回其阶乘值的函数。这比听起来简单；你能做到的！</em></p><p id="4a23" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然我说过使用递归解决问题只是简单地调用函数本身<em class="jt">，</em>如果没有停止递归过程的方法，这样做实际上会导致调用堆栈(大小有限)在运行这个函数时溢出。不用说，这是有问题的。我们需要建立一个所谓的基础案例，也就是所谓的中断条件。只要我们的递归回调不超过调用堆栈的大小限制，堆栈中的任何返回值都可以用作基本情况。</p><p id="096e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这对我们的阶乘函数意味着什么？这意味着我们不能乘以一个小于1的数，所以这一定是我们定义基本情况的值。由于阶乘涉及1和<em class="jt"> n </em>之间的每个非零整数，我们可以反向工作，从我们的数中减去1，直到<em class="jt"> n </em>等于1，并且不继续超过1(因为如果n = 1，那么n-1 = 0，并且5*4*3*2*1*0 = 0)。这意味着当n-1等于1时，我们必须停止递归，并在到达那个数(2)时返回那个值(而不是再次递归调用它自己)。恭喜你，你刚刚找到了我们的基本情况，这已经是我们递归函数的一半逻辑了。让我们开始写出来:</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们的阶乘递归函数，以及我们的基本情况条件语句。(创建于https://carbon.now.sh)</figcaption></figure><p id="27e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简单，不是吗？现在我们知道了递归必须在哪里结束，剩下的就是定义递归逻辑本身了。让我们反向操作，从<em class="jt"> n </em>乘到1，而不是从1到<em class="jt"> n </em>、<em class="jt"> </em>递增。所有需要做的就是从<em class="jt"> n </em>中一次又一次地减去1，或者递归地。哒哒！就是这样。现在，您可以在控制台中运行递归函数并检查结果:</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们成功了，孩子们！(创建于https://carbon.now.sh)</figcaption></figure><p id="b0ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(附带说明:你可能需要使用浏览器的DevTools手动运行递归回调，因为我们的数量需要在范围内冒泡。在这种情况下，只需在调试器的范围工具中单击“单步执行”即可在“局部”选项卡中查看存储的局部变量。)</p><p id="a255" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">乍一看，这似乎并不复杂，但是递归是一种强大的解决问题的方法。虽然它在空间复杂度方面可以运行得很高，但它比必须迭代一系列值要好，因为每个嵌套循环都会增加O(n)的时间复杂度。</p><h1 id="6b2c" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">永恒的科技面试经典:斐波那契数列算法</h1><p id="38ec" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">让我们来看一个可以用递归来解决的技术面试问题(事实上，如果你用递归来解决这个问题，看起来非常好)。这是一个老掉牙的斐波那契数列问题，我第一次读到这个问题是在这里<a class="ae iu" rel="noopener" href="/@leog7one/to-understand-recursion-you-must-first-understand-recursion-recursion-explained-c574245cf788"/>，这个问题被无数的面试官恶心地使用过，它说:</p><blockquote class="ju jv jw"><p id="0cdd" class="iv iw jt ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="ix hj">"给定一个由<em class="hi"> n </em>个数字组成的数组，写一个函数返回斐波那契数列中的第<em class="hi"> n </em>个元素。(</strong>约束:假设0&lt;n≤30)<strong class="ix hj"/></p></blockquote><p id="c914" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">斐波纳契数列是一个数字序列，其中任意两个连续的数字加起来是数列中的第三个数字。比如斐波那契数列的前十个数字是[1，1，2，3，5，8，13，21，34，55](因为1 + 1 = 2，1 + 2 = 3，2 + 3 = 5等。).就上面的问题而言，我们的任务是找到斐波纳契数列中10个数字的数组中的第10个元素。听起来很可怕，但是所有的逆境都是可以克服的。让我们一步一步地递归解决这个问题。</p><p id="ce96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一种解释斐波纳契数列定义的方式是，每三个数字是它自己减1和它自己减2的和。现在，停在那里。如果你重读这个问题，我们得到一个约束，0 &lt; n. This means that neither <em class="jt"> n-1 </em>和<em class="jt"> n-2 </em>都不能等于0。就这样，我们找到了找到基本案例的方法。如果n-2不小于1，n-1也是，那么(n-2)+(n-1)至少是2。我们唯一能接受的低于2的值是1。因此:</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">斐波那契数列函数的基本情况。(创建于https://carbon.now.sh)</figcaption></figure><p id="ad0d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其余的几乎是自己写的。我不确定为什么我要在快照之间写这篇中间评论:</p><figure class="ld le lf lg fd ij"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">我们的递归斐波那契数列函数(创建于https://carbon.now.sh)</figcaption></figure><p id="ed1a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好东西，读者！我知道递归可能很棘手，但是理解它可以帮你避免很多麻烦。我想我今天就说到这里，下一次，我们将更深入地研究递归用例，主要是广度优先搜索和深度优先搜索。记得练习，练习，练习。下次见！</p></div></div>    
</body>
</html>