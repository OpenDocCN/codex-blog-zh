<html>
<head>
<title>Go Deeper — Database Connection Pool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更深入—数据库连接池</h1>
<blockquote>原文：<a href="https://medium.com/codex/go-deeper-database-connection-pool-9a0a394a2bf1?source=collection_archive---------0-----------------------#2018-12-12">https://medium.com/codex/go-deeper-database-connection-pool-9a0a394a2bf1?source=collection_archive---------0-----------------------#2018-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8630d3102118dfba266890166b18dfcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oz7Ztx6isbQCCwDn.jpg"/></div></div></figure><p id="ad64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Golang使用连接池来为我们管理打开的连接。因此，当没有空闲连接时使用新的连接，当golang找到空闲连接时重用它们。最重要的是，当一个接一个地调用两个查询时，并不意味着这两个查询将使用相同的连接。这可能是真的，如果不是在每种情况下。</p><p id="57d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的例子中，您可以找到似乎在一个连接中执行的两个查询。问题是第一个查询可能使用与第二个不同的连接。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0df5" class="jx jy hi jt b fi jz ka l kb kc">db.Exec('LOCK TABLE table1 WRITE;');<br/>db.Exec("INSERT INTO table1 VALUES ($1, $2)", val1, val2);</span></pre><p id="5064" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这可能会导致一个很难发现和重现的错误。如果INSERT语句使用的连接与第一个不同，将会产生错误。这可能是因为table1表被阻止写入。在这种情况下，第二个查询将无法成功执行。如果错误得不到正确处理，可能会导致锁定表，直到连接关闭。</p><p id="89c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了避免这种情况，我们必须确保查询使用连接池中的同一个连接。为此，应该使用一个事务。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="163f" class="jx jy hi jt b fi jz ka l kb kc">tx, err := db.BeginTx(ctx, nil)<br/>tx.Exec("LOCK TABLE table1 WRITE;")<br/>tx.Exec("INSERT INTO table1 VALUES ($1, $2)", val1, val2)<br/>err = tx.Commit()</span></pre><p id="4cb4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建事务时，连接池中的一个连接与其相关，并且只有这个连接用于执行查询。由于这一点，我们可以确保在真正需要时使用相同的连接。</p><h2 id="ad01" class="jx jy hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">管理连接</h2><p id="2b8d" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">有一种方法可以配置打开的连接或空闲连接的数量。要设置打开连接的最大数量，应使用<code class="du lb lc ld jt b">db.SetMaxOpenConns(N)</code>。默认情况下，该值设置为<code class="du lb lc ld jt b">0</code>,这意味着对客户端站点没有限制。但是，当使用默认值时，并不意味着数据库服务器站点不能达到该限制。这是一件值得记住的重要事情。</p><p id="8c9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当达到最大打开连接数时，想要执行SQL语句的goroutinge将等待一个连接返回连接池。这可能需要很长时间，或者永远不会发生。</p><p id="f747" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用TCP协议发送对数据库的查询。然而，打开一个新的TCP连接是昂贵的。为了最小化成本，golang保持一些空闲连接打开，以备重用。另一方面，最大空闲连接数不应该太大，因为正如我们前面谈到的，服务器端的可用打开连接数是有限的。此外，其他服务可以共享这个限制，因此达到这个限制的速度甚至比我们想象的还要快。<br/>可以使用<code class="du lb lc ld jt b">db.SetMaxIdleConns(N)</code>功能配置最大空闲连接数。该值有助于优化打开的连接数。当空闲连接的数量达到限制时，其他连接将被关闭，资源将被重新使用。当服务器端的可用连接数非常少时，这一点很重要。</p><h2 id="4246" class="jx jy hi bd kd ke kf kg kh ki kj kk kl jb km kn ko jf kp kq kr jj ks kt ku kv bi translated">摘要</h2><p id="244a" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated"><code class="du lb lc ld jt b">database/sql</code>库通过管理连接池来帮助开发人员。另一方面，开发人员必须记住管理连接是如何工作的，以防止发现重要的错误。在单个事务中保留相互依赖的查询可以解决许多问题。</p></div></div>    
</body>
</html>