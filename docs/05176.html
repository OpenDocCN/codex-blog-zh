<html>
<head>
<title>Binary Tree And How to Search and Insert With Recursive Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉树以及如何用递归函数进行查找和插入</h1>
<blockquote>原文：<a href="https://medium.com/codex/binary-tree-and-how-to-search-and-insert-with-recursive-functions-91dd69473a5b?source=collection_archive---------4-----------------------#2022-02-06">https://medium.com/codex/binary-tree-and-how-to-search-and-insert-with-recursive-functions-91dd69473a5b?source=collection_archive---------4-----------------------#2022-02-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ee1806416fcb4de490978068e5cbac67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4XM_0FgbniVqKz2edHjyCA.jpeg"/></div></div></figure><p id="f3e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当谈到在计算科学中研究数据结构时，有简单的字节，通常所知的数组，实现对象的乐趣，甚至是我过去谈到的那些<a class="ae jo" rel="noopener" href="/codex/linked-list-fa0eba0f4c0f">链表</a>。在我提到的这些数据结构中，还有一种数据结构会在leetcode问题中遇到，二叉树。</p><p id="7419" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://www.programiz.com/dsa/binary-tree" rel="noopener ugc nofollow" target="_blank">二叉树</a>是一种数据结构，其中每个父节点最多可以有两个子节点。每一项都是:</p><ul class=""><li id="0758" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">数据项目</li><li id="5db1" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">左侧孩子的地址</li><li id="9ac7" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">右子女的地址</li></ul><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/07c6c23491fc6e0259d6f2bd941ba28c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V-D4tK50pIsNDwtu.png"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx translated">图片来自Programiz。请参阅超链接参考。</figcaption></figure><p id="08b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据节点和子节点的连接方式，二叉树被分类或描述为完全、完美、完整和几种退化/病态类型。</p><p id="e8a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>这篇博客文章是关于我解决leetcode数据结构和算法问题的经验。如果你想从头开始创建和实现你的树节点，<a class="ae jo" href="https://www.30secondsofcode.org/articles/s/js-data-structures-tree" rel="noopener ugc nofollow" target="_blank"> 30秒代码</a>有一篇内容丰富的文章可以练习。</p><p id="c4c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们来看看leetcode参考。</p><p id="cf36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个JavaScript二进制TreeNode应该是这样的。</p><pre class="ke kf kg kh fd km kn ko kp aw kq bi"><span id="713d" class="kr ks hi kn b fi kt ku l kv kw">function TreeNode(val, left, right) {</span><span id="e63f" class="kr ks hi kn b fi kx ku l kv kw">   this.val = (val === undefined ? 0 : val)</span><span id="a7b8" class="kr ks hi kn b fi kx ku l kv kw">   this.left = (left === undefined ? null : left)</span><span id="b2d9" class="kr ks hi kn b fi kx ku l kv kw">   this.right = (right === undefined ? null : right)</span><span id="f038" class="kr ks hi kn b fi kx ku l kv kw">}</span></pre><p id="2978" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这相当于像这样创建您的类:</p><pre class="ke kf kg kh fd km kn ko kp aw kq bi"><span id="39cc" class="kr ks hi kn b fi kt ku l kv kw">class treeNode {</span><span id="0588" class="kr ks hi kn b fi kx ku l kv kw">   constructor(val) {</span><span id="6b13" class="kr ks hi kn b fi kx ku l kv kw">      this.val = val</span><span id="72da" class="kr ks hi kn b fi kx ku l kv kw">      this.left = null</span><span id="91a0" class="kr ks hi kn b fi kx ku l kv kw">      this.right = null</span><span id="c78a" class="kr ks hi kn b fi kx ku l kv kw">   }</span><span id="4423" class="kr ks hi kn b fi kx ku l kv kw">}</span><span id="859d" class="kr ks hi kn b fi kx ku l kv kw">class BinarySearchTree {</span><span id="6c65" class="kr ks hi kn b fi kx ku l kv kw">   constructor() {</span><span id="5910" class="kr ks hi kn b fi kx ku l kv kw">      this.root = null</span><span id="4db8" class="kr ks hi kn b fi kx ku l kv kw">   }</span><span id="f7b5" class="kr ks hi kn b fi kx ku l kv kw">}</span></pre><p id="a9bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以在递归中使用声明的值和根参数实现find或insert。一个<a class="ae jo" href="https://www.javascripttutorial.net/javascript-recursive-function/" rel="noopener ugc nofollow" target="_blank">递归函数</a>将在它自己的体内调用它自己。使用递归函数解决这些算法帮助我理解了它们是如何在二叉树场景中被调用和实现的。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/6cb53102a41c1548dc2c62f656c04a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/0*SUAvJD1_FcNfNN4S.jpg"/></div><figcaption class="ki kj et er es kk kl bd b be z dx translated">M·C·埃舍尔的Relativity很好地展示了以下JavaScript函数的模式和递归。</figcaption></figure><h1 id="1973" class="kz ks hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">搜索</h1><pre class="ke kf kg kh fd km kn ko kp aw kq bi"><span id="d090" class="kr ks hi kn b fi kt ku l kv kw">const searchBST = (root, val) =&gt; {<br/>    if (!root) return null;</span><span id="0eda" class="kr ks hi kn b fi kx ku l kv kw">    if(root.val === val) {<br/>        return root;<br/>    } else {<br/>    if(root.val &gt; val) {<br/>        return searchBST(root.left, val);<br/>    } else {<br/>        return searchBST(root.right, val);<br/>      }<br/>    }<br/>};</span></pre><p id="da2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这段代码中:</p><ol class=""><li id="602e" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn lw jv jw jx bi translated">我们正在检查是否有根，如果根本没有根，我们将返回<code class="du lx ly lz kn b">null</code>。</li><li id="60f3" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lw jv jw jx bi translated">如果这是搜索结果，我们将返回确切的值。</li><li id="a3c8" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lw jv jw jx bi translated">否则，如果它们在树中，我们也会返回它们的值。</li></ol><figure class="ke kf kg kh fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/53636e292f75e855cd00dc3459e20e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*Z5hwxTMQEldGfz0N.jpg"/></div></figure><p id="420b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不过，这可能是展示在二叉树中搜索值的能力的最佳语法。有一种更干净的方法。首先，让我们检查根节点是否为空或者与值i <code class="du lx ly lz kn b">f (!root || root.val === val) return root;</code>相同。其次，我们返回子节点的全部值，不管他们是左返回还是右返回<code class="du lx ly lz kn b">searchBST(root.left, val) || searchBST(root.right, val);</code>。</p><p id="8510" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">整个函数如下所示:</p><pre class="ke kf kg kh fd km kn ko kp aw kq bi"><span id="4bce" class="kr ks hi kn b fi kt ku l kv kw">const searchBST = (root, val) =&gt; {</span><span id="d9af" class="kr ks hi kn b fi kx ku l kv kw">   if (!root || root.val === val) return root;</span><span id="6ae8" class="kr ks hi kn b fi kx ku l kv kw">   return searchBST(root.left, val) || searchBST(root.right, val)</span><span id="6320" class="kr ks hi kn b fi kx ku l kv kw">};</span></pre><h1 id="04dd" class="kz ks hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">插入</h1><pre class="ke kf kg kh fd km kn ko kp aw kq bi"><span id="49ac" class="kr ks hi kn b fi kt ku l kv kw">const insertIntoBST = (root, val) =&gt; {</span><span id="d224" class="kr ks hi kn b fi kx ku l kv kw">   if(!root) return new TreeNode(val);</span><span id="def1" class="kr ks hi kn b fi kx ku l kv kw">   if (val &gt; root.val) {</span><span id="747c" class="kr ks hi kn b fi kx ku l kv kw">      root.right = insertIntoBST(root.right, val);</span><span id="c69f" class="kr ks hi kn b fi kx ku l kv kw">   } else {</span><span id="6cbd" class="kr ks hi kn b fi kx ku l kv kw">        root.left = insertIntoBST(root.left, val);</span><span id="ce80" class="kr ks hi kn b fi kx ku l kv kw">   }</span><span id="6a6b" class="kr ks hi kn b fi kx ku l kv kw">   return root;</span><span id="f072" class="kr ks hi kn b fi kx ku l kv kw">};</span></pre><p id="6768" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在树中插入新值的代码与搜索给定值的方法类似。这一次，我们将有根，我们拥有的值将是我们必须插入的值。从上面的代码中可以看出，该函数与我们为搜索而编写的<code class="du lx ly lz kn b">searchBST</code>非常相似。</p><p id="12ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">功能细分如下:</p><ol class=""><li id="a2b3" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn lw jv jw jx bi translated">如果没有根，我们将创建它。在这种情况下，我们在leetcode中的代码是<code class="du lx ly lz kn b">new TreeNode(val);</code>。</li><li id="e42e" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lw jv jw jx bi translated">如果根的值高于我们插入的值，我们将插入一个新的子元素。</li><li id="c69e" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lw jv jw jx bi translated">否则，我们将继续插入给定的值作为新树的根。</li></ol><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/8683301a61289494b8598f7a714bd2e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7PkKXhkHbfX4FQuU.jpg"/></div></div></figure><figure class="ke kf kg kh fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/30cc038b7da25813692cd88d96fe928a.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/0*C55gs-TswRxjLwp1.jpg"/></div></figure><p id="7847" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能会想，有一种更简单的方法。首先，我们将检查是否没有根，或者给定的值是否等于现有的根值，<code class="du lx ly lz kn b">if (!root || root.val === val) return new TreeNode(val);</code>。其次，我们可以用三行代码编写其余部分，不用花括号，也可以使用三元运算。然而，我更喜欢单独的线。下面是完整的功能:</p><pre class="ke kf kg kh fd km kn ko kp aw kq bi"><span id="2da9" class="kr ks hi kn b fi kt ku l kv kw">const insertIntoBST = (root, val) =&gt; {</span><span id="59ae" class="kr ks hi kn b fi kx ku l kv kw">   if (!root || root.val === val) return new TreeNode(val);</span><span id="ff1d" class="kr ks hi kn b fi kx ku l kv kw">   if(val &lt; root.val) root.left = insertIntoBST(root.left, val);</span><span id="b7ec" class="kr ks hi kn b fi kx ku l kv kw">   else root.right = insertIntoBST(root.right, val);</span><span id="e07a" class="kr ks hi kn b fi kx ku l kv kw">   return root;</span><span id="4e8f" class="kr ks hi kn b fi kx ku l kv kw">};</span></pre><h1 id="0ae2" class="kz ks hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">横越</h1><p id="6fd8" class="pw-post-body-paragraph iq ir hi is b it md iv iw ix me iz ja jb mf jd je jf mg jh ji jj mh jl jm jn hb bi translated">如果我们可以搜索并向二叉树中插入值，那么访问每个节点呢？我们如何获得整个树的信息和流量？我们能以不同的方式做那件事吗？答案是遍历。</p><p id="3bed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html" rel="noopener ugc nofollow" target="_blank">遍历</a>是以某种顺序访问数据集合中所有对象(如<a class="ae jo" href="https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/Glossary.html#term-tree" rel="noopener ugc nofollow" target="_blank">树</a>或<a class="ae jo" href="https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/Glossary.html#term-graph" rel="noopener ugc nofollow" target="_blank">图</a>)的任何过程。</p><p id="feb4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">顺序是:</p><p id="ebcf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">前序遍历</strong></p><pre class="ke kf kg kh fd km kn ko kp aw kq bi"><span id="6668" class="kr ks hi kn b fi kt ku l kv kw">const preorderTraversal = (root) =&gt; {<br/>    if (!root) return [];<br/>    <br/>    let queue = [root], result = [];<br/>    <br/>    while (queue.length) {<br/>        const node = queue.pop();<br/>        result.push(node.val);<br/>        if (node.right) queue.push(node.right);<br/>        if (node.left) queue.push(node.left); <br/>    }<br/>    return result; <br/>};</span></pre><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ca"><img src="../Images/aac74a5328f731e52d06849d6d34b8a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-MQ0E-oxZwOv6zAs5Hhtaw.jpeg"/></div></div></figure><p id="69be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">后序遍历</strong></p><pre class="ke kf kg kh fd km kn ko kp aw kq bi"><span id="be56" class="kr ks hi kn b fi kt ku l kv kw">const postorderTraversal = (root) =&gt; {<br/>    let result = [];<br/>    <br/>    let traverse = (root) =&gt; {<br/>        if(root === null) return;<br/>        traverse(root.left);<br/>        traverse(root.right);<br/>        result.push(root.val);<br/>   }<br/>   traverse(root);<br/>   return result;<br/>};</span></pre><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/c12ba91bcc8abc57cfb3718b89490db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ya-glL6St28nTAIWN4BtQ.jpeg"/></div></div></figure><p id="a5de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">顺序遍历</strong></p><pre class="ke kf kg kh fd km kn ko kp aw kq bi"><span id="fb8f" class="kr ks hi kn b fi kt ku l kv kw">const inorderTraversal = (root) =&gt; {<br/>    let result = [];<br/>    <br/>    let traverse = (root) =&gt; {<br/>        if(root === null) return;<br/>        traverse(root.left);<br/>        result.push(root.val);<br/>        traverse(root.right);<br/>   }<br/>   traverse(root);<br/>   return result;<br/>};</span></pre><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/9110373b1afe1834d4c722b4abfff183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rMSb98940CVfhWqsPDZ5sQ.jpeg"/></div></div></figure><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/a7d64710dad597792aae6253c616297a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D8qaGTwasS1qcqDZ.jpg"/></div></div></figure><p id="7a6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编码中的树让我想起从我祖父母家的树上摘芒果。抽象比我们想象的更能反映现实，这是我编码的乐趣之一。</p><p id="8a5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也许你电脑屏幕上的字节树也给你带来了快乐的童年回忆，但我也希望你能从中学到一些东西。编码快乐！</p><h1 id="992b" class="kz ks hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">总结:</h1><ol class=""><li id="3c41" class="jp jq hi is b it md ix me jb ml jf mm jj mn jn lw jv jw jx bi translated">二叉树概述。</li><li id="69b8" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lw jv jw jx bi translated">递归函数概述。</li><li id="9592" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lw jv jw jx bi translated">搜索功能。</li><li id="3f1f" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lw jv jw jx bi translated">插入函数。</li><li id="6e67" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lw jv jw jx bi translated">横越</li></ol><h1 id="8afb" class="kz ks hi bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">参考资料:</h1><ol class=""><li id="c613" class="jp jq hi is b it md ix me jb ml jf mm jj mn jn lw jv jw jx bi translated"><a class="ae jo" href="https://www.programiz.com/dsa/binary-tree" rel="noopener ugc nofollow" target="_blank">程序名</a>，二叉树</li><li id="1f25" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lw jv jw jx bi translated"><a class="ae jo" href="https://www.30secondsofcode.org/articles/s/js-data-structures-tree" rel="noopener ugc nofollow" target="_blank"> 30秒代码</a>，数据结构——JavaScript二叉树</li><li id="6a2d" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lw jv jw jx bi translated"><a class="ae jo" href="https://www.javascripttutorial.net/javascript-recursive-function/" rel="noopener ugc nofollow" target="_blank"> JavaScript教程</a>，递归函数</li><li id="3ee7" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lw jv jw jx bi translated"><a class="ae jo" href="https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html" rel="noopener ugc nofollow" target="_blank"> OpenDSA </a>，二叉树遍历</li></ol></div></div>    
</body>
</html>