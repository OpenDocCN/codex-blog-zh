<html>
<head>
<title>Overview of Java Virtual Machine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java虚拟机概述</h1>
<blockquote>原文：<a href="https://medium.com/codex/overview-of-java-virtual-machine-491358c9ba12?source=collection_archive---------9-----------------------#2022-06-10">https://medium.com/codex/overview-of-java-virtual-machine-491358c9ba12?source=collection_archive---------9-----------------------#2022-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="13b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你知道JVM (Java虚拟机)吗？让我们简单了解一下JVM。</p><p id="e5a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虚拟机分为两部分。它们是基于系统的虚拟机和基于应用程序的虚拟机。基于应用的虚拟机意味着您不需要任何硬件设备。但是你可能有软件来帮助运行另一个程序的平台。基于应用的虚拟机称为基于进程的虚拟机。</p><p id="3d46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM是一个基于应用程序的虚拟机。JVM是不存在的现实。JVM是一个完整的规范，它说明应该如何做。当我们下载JRE时，JVM附带了JRE。它部署了所有可以创建JVM的代码。JVM也负责字节码到机器码的转换。</p><p id="da60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次运行Java应用程序时，都会创建一个JVM实例。它负责字节码到机器码的转换过程。如果您执行多个Java程序，它将为每个Java程序创建一个JVM实例。</p><p id="d31c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，JVM实例是什么时候创建的呢？当JVM实例启动时，会创建一个非守护线程。JVM实例也可能以两种方式死亡。</p><ol class=""><li id="3d0a" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">如果没有运行非守护进程线程</li><li id="366f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">2.应用程序本身调用了系统exit()方法。</li></ol><p id="c15e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们学习JVM的架构。它在JVM中有3个组件。他们是</p><ol class=""><li id="7ede" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">类装入器</li><li id="3c0f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">运行时内存/数据区</li><li id="1469" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">执行引擎。</li></ol><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/38dc881b21f08948b8703e582b3cec3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oDJnJ4wAb0n-skPZnjzQ-w.jpeg"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated"><strong class="bd kh"> JVM架构</strong></figcaption></figure><p id="e723" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以逐一了解这三个组件。</p><h2 id="dc01" class="ki kj hi bd kh kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">1.类别载入器-</h2><ul class=""><li id="7b81" class="jd je hi ih b ii lc im ld iq le iu lf iy lg jc lh jj jk jl bi translated">类加载器执行3个主要任务。它们是加载、链接和初始化。现在我们可以逐一识别它们。</li></ul><h2 id="1103" class="ki kj hi bd kh kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">装货</h2><p id="4e99" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">在加载过程之前，类加载器读取一个应该被加载的类的以下内容。完全限定名、变量信息、直接父级，检查它是类、接口还是枚举。在读取上述项目后，将类加载到内存区域。有3个类装入器，如下所示。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ll"><img src="../Images/bec3d958d5db973c21eecc6be0bad9c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*wbutUh7ZEjTwbZKDSYzgXQ.jpeg"/></div></figure><h2 id="7998" class="ki kj hi bd kh kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">连接</h2><p id="39d7" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">这个过程可以分为三个主要部分。</p><ol class=""><li id="2a4d" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">验证-</li></ol><p id="8ba7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">VM可以确定执行是否安全。为此，JVM提供了一个字节码验证器。它研究编译器、格式和结构。如果其中任何一个被破坏，字节码验证器将抛出一个验证器异常。否则，如果是通过，下一阶段就是准备。</p><p id="8dd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.准备-</p><p id="94f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一阶段，对于所有静态变量，将根据数据类型分配内存并赋予默认值。</p><p id="c429" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.分辨率-</p><p id="9bef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM用直接链接代替了符号链接</p><h2 id="881c" class="ki kj hi bd kh kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">初始化</h2><p id="9773" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">该过程将把实际值赋给先前在链接过程的准备步骤中被赋予默认值的变量。此外，如果存在任何静态块，它们将被执行。<br/>JVM要求实现在使用每个类之前执行初始化。</p><p id="581a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">积极使用一个类，</p><p id="8be4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.使用新的关键字。</p><p id="daf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.调用静态方法。</p><p id="e301" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.为静态字段赋值。</p><p id="5a13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.如果一个类是初始类(使用main()方法的类)。</p><p id="c01c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.使用反射API</p><p id="68e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.从当前类初始化子类。</p><p id="c770" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有四种方法可以初始化一个类:使用new关键字——这将引导类完成初始化过程；<br/>利用clone()函数——从父对象(源对象)收集信息。<br/>这将使用反射API (getInstance())完成初始化过程；).<br/>利用木卫一。ObjectInputStream()；—这会将所有非瞬态变量的初始值设置为InputStream的值。</p><h2 id="7f62" class="ki kj hi bd kh kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">2.运行时内存/数据区-</h2><p id="d86f" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">该存储区分为5类。它们是方法区、堆、Java堆栈、Pc寄存器和负方法堆栈。当我们加载类时，</p><ul class=""><li id="8bb6" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc lh jj jk jl bi translated">方法区存储了所有的类信息(像类型信息)。</li><li id="5818" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc lh jj jk jl bi translated">所有的对象都来到堆区。</li><li id="1a77" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc lh jj jk jl bi translated">堆栈区域存储所有局部变量、方法调用和程序的部分结果(非本机方法)。将为每个线程创建一个运行时堆栈。“堆栈框架”是一个堆栈区域块，用于保存方法调用的局部变量。因此，在方法调用完成后，框架被移除(POP)。因为这是一个堆栈，所以结构是后进先出的。</li><li id="8184" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc lh jj jk jl bi translated">pc寄存器保存下一次执行的信息。</li><li id="68c0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc lh jj jk jl bi translated">当本地方法访问这个区域时，它保存本地信息/方法。</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es lm"><img src="../Images/311cf7c5db0f70bfbe853f25d6f535aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Y8WwHa0cTVejyfE8J-PXw.jpeg"/></div></div></figure><p id="4034" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个虚拟机都执行方法区域和堆。但是另外3个执行每个线程。</p><h2 id="9dc0" class="ki kj hi bd kh kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">3.执行引擎</h2><p id="b7ff" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">JVM的执行引擎是其最重要的组件。这将Java字节码转换成机器码，然后可以在内存中加载和执行。</p><p id="471a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行引擎由三部分组成。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es ln"><img src="../Images/8b2982d7a4b81da59ea306246db9b549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djPkGaUf0rYs6JH8fZcfkA.jpeg"/></div></div></figure><p id="c5df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1-口译员-</p><p id="31d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解释器读取字节码指令并顺序执行它们。<br/> 2- JIT编译器-</p><p id="1d82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行引擎使用解释器来逐行执行字节码，JIT编译器在发现重复代码时使用。然后，JIT编译器将所有字节码编译成本机代码。</p><p id="dce9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3-垃圾收集器-</p><p id="f0a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将检查堆区域中任何未被引用的对象，并销毁它们以释放内存。因此，它为更多的项目腾出了空间。</p><h2 id="4d8a" class="ki kj hi bd kh kk kl km kn ko kp kq kr iq ks kt ku iu kv kw kx iy ky kz la lb bi translated">参考</h2><p id="0ac0" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">[1]K .迪内什，<em class="lo">Youtube.com</em>，2022年。【在线】。可用:<a class="ae lp" href="https://www.youtube.com/watch?v=GzFdNzLB7iI." rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=GzFdNzLB7iI.</a>【访问时间:2022年6月10日】。</p></div></div>    
</body>
</html>