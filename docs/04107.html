<html>
<head>
<title>How Web Scraping is Used to Scrape Google Play Store Data?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何网页抓取是用来抓取谷歌Play商店数据？</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-web-scraping-is-used-to-scrape-google-play-store-data-36bafa8c2b61?source=collection_archive---------10-----------------------#2021-10-26">https://medium.com/codex/how-web-scraping-is-used-to-scrape-google-play-store-data-36bafa8c2b61?source=collection_archive---------10-----------------------#2021-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c29220b7cba70fe1a6e52260353c6b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ETQbUoO-QlciVIo8c5driA.jpeg"/></div></div></figure><p id="1db4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用程序增加了与世界的互动。购物、音乐、新闻和约会只是你在社交媒体上可以做的几件事。如果你能想到它，可能有一个应用程序。有些应用程序优于其他应用程序。你可以通过分析用户评论的语言来了解人们喜欢和不喜欢一个应用程序的什么。情感分析和主题建模是自然语言处理(NLP)的两个领域，可以帮助你做到这一点，但是如果你没有任何评论要检查的话就不行了！</p><p id="08d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们超越自己之前，你需要收集和保存一些评论。这篇博客将向您展示如何使用Python代码、google-play-scraper和PyMongo包来做到这一点。你有几个选项来存储或保存你的刮掉的评论。</p><p id="8278" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用于抓取谷歌Play商店的实时API由google-play-scraper提供。它可用于获得:</p><p id="f405" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用程序信息包括应用程序的标题和描述，以及价格、类型和当前版本。</p><p id="0bf3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> App评测</strong></p><p id="c78a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以使用app函数检索app信息，使用reviews或reviews_ all函数获取评论。我们将简要介绍如何使用该应用程序，然后重点讨论如何充分利用评论。虽然评论在某些情况下很方便，但我们更喜欢使用评论。一旦我们到达那里，我们将用大量的代码解释为什么和如何。</p><h1 id="f22f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">从Google-Play-Scraper开始</h1><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ae5eec1047e96636a2145ae058f64c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*myYiMMmowOMe4CuB.jpg"/></div></div></figure><p id="986a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第一步:获取应用id</strong></p><p id="7c3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要抓取每个应用程序，你需要一条信息:应用程序的ID代码。这可以在谷歌Play商店的应用程序页面的URL上找到。您需要的组件就在“id=”后面，如下图所示。</p><p id="2532" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在其他情况下，URL以应用ID结束。在这种情况下，您只需要“id=" and "&amp; "之间的部分。</p><p id="e113" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你最近的工作将是收集心理健康、正念和自我保健的应用。在开发应用程序时，我们会在电子表格上记录大量不同的信息。这似乎是保存每个应用程序ID的合理位置。</p><p id="bc56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第二步:安装并导入</strong></p><p id="4738" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们将进口和什么是使用较早，包括PyMongo。此外，最初您需要安装MongoDB。安装社区版的指南将在<a class="ae jo" href="https://docs.mongodb.com/manual/administration/install-community/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="95a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">为了能够导入以下各项，应根据需要安装pip:</strong></p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="feec" class="kw jq hi ks b fi kx ky l kz la">import pandas as pd # for scraping app info and reviews from Google Play from google_play_scraper import app, Sort, reviews # for pretty printing data structures from pprint import pprint # for storing in MongoDB import pymongo from pymongo import MongoClient # for keeping track of timing import datetime as dt from tzlocal import get_localzone # for building in wait times import random import time</span></pre><p id="9ad9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还将安装Mongo，为项目建立一个新的数据库，并添加新的集合(本质上是MongoDB，相当于关系数据库的表)。您还将有一个应用程序信息集合和另一个应用程序评论集合。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="bf12" class="kw jq hi ks b fi kx ky l kz la">## Set up Mongo client client = MongoClient(host='localhost', port=27017) ## Database for project app_proj_db = client['app_proj_db'] ## Set up new collection within project db for app info info_collection = app_proj_db['info_collection'] ## Set up new collection within project db for app reviews review_collection = app_proj_db['review_collection']</span></pre><p id="f2ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">MongoDB是一个懒惰的数据库和集合创建者。这意味着除非我们开始向集合中输入文档(MongoDB相当于关系数据库表中的行)，否则这些特性都不会存在。</p><h1 id="9af6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">抓取应用程序数据</h1><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c7f144f9c3016dad4bdeeee47e662e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-5b__VbHasJmGV-M.jpg"/></div></div></figure><p id="5459" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">平台现在可以刮削了。我们需要的是应用程序id列表。你可以下载一份csv格式的电子表格，用Pandas DataFrame阅读。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="207f" class="kw jq hi ks b fi kx ky l kz la">## Read in file containing app names and IDs app_df = pd.read_csv('Data/app_ids.csv') app_df.head() ## Read in file containing app names and IDs app_df = pd.read_csv('Data/app_ids.csv') app_df.head()</span></pre><p id="1758" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以简单地获取应用程序名称和id的列表，以便在抓取过程中进行循环:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="178b" class="kw jq hi ks b fi kx ky l kz la">## Get list of app names and app IDs app_names = list(app_df['app_name']) app_ids = list(app_df['android_appID'])</span></pre><p id="2ea0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们收集评论时，我们将使用应用程序名称。我们所需要的是应用程序id，以通过应用程序功能收集一般的应用程序信息。下面的代码遍历每个程序，从谷歌Play商店中抓取信息并保存在一个列表中。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="9923" class="kw jq hi ks b fi kx ky l kz la">## Loop through app IDs to get app info app_info = [] for i in app_ids: info = app(i) del info['comments'] app_info.append(info) ## Pretty print the data for the first app pprint(app_info[0])</span></pre><p id="e327" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一行提供了一个字典，里面有关于我们最初计划的各种细节。以下是该输出的简短版本:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="e116" class="kw jq hi ks b fi kx ky l kz la">{'adSupported': None, 'androidVersion': '4.1', 'androidVersionText': '4.1 and up', 'appId': 'com.aurahealth', 'containsAds': False, 'contentRating': 'Everyone', 'contentRatingDescription': None, 'currency': 'USD', 'description': '&lt;b&gt;Find peace everyday with Aura&lt;/b&gt; - discover thousands of ' ... (truncated), 'descriptionHTML': '&lt;b&gt;Find peace everyday with Aura&lt;/b&gt; - discover ' ... (truncated), 'developer': 'Aura Health - Mindfulness, Sleep, Meditations', 'developerAddress': '2 Embarcadero Center, Fl 8\nSan Francisco, CA 94111', 'developerEmail': 'hello@aurahealth.io', 'developerId': 'Aura+Health+-+Mindfulness,+Sleep,+Meditations', 'developerInternalID': '8194778368040078712', 'developerWebsite': 'http://www.aurahealth.io', 'editorsChoice': False, 'free': True, 'genre': 'Health &amp; Fitness', ... }</span></pre><p id="2a3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们使用PyMongo的insert many方法将应用程序的详细信息安全地保存在我们的信息集合中。insert many需要一个字典列表，这是我们刚刚创建的。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="3447" class="kw jq hi ks b fi kx ky l kz la">## Insert app details into info_collection info_collection.insert_many(app_info)</span></pre><p id="e168" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只要您想开始使用数据集，就可以用一行代码直接查询到数据帧！</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="1501" class="kw jq hi ks b fi kx ky l kz la">## Query the collection and create DataFrame from the list of dicts info_df = pd.DataFrame(list(info_collection.find({}))) info_df.head()</span></pre><h1 id="6569" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">抓取应用评论</h1><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/167d7a4fabbc981fcd2fa79ea39a2631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yn0k8dLWr8yudELP.jpg"/></div></div></figure><p id="6dda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用review函数总比使用reviews_all要好。原因如下</p><ul class=""><li id="9308" class="lb lc hi is b it iu ix iy jb ld jf le jj lf jn lg lh li lj bi translated">如果你真的想要所有的评论，你仍然可以获得它们。</li><li id="8317" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">你可以把每个应用程序的过程分成几个部分，而不是一次做一个应用程序的所有事情。这是有益的，因为它为您提供了选择。您可以执行以下操作:</li><li id="b353" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">定期更新你获得了多少评论。</li><li id="cf51" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">不要等到结束，在进行过程中保存收集到的数据。</li></ul><h1 id="7266" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">剖析“评论”功能</h1><p id="661f" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">reviews函数返回两个变量。我们在第一个变量中寻找评论数据。第二个变量是一个信息令牌，如果我们希望获得的评论数超过计数，我们将需要它。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="6957" class="kw jq hi ks b fi kx ky l kz la">rvws, token = reviews( 'co.thefabulous.app', # app's ID, found in app's url lang='en', # defaults to 'en' country='us', # defaults to 'us' sort=Sort.NEWEST, # defaults to Sort.MOST_RELEVANT filter_score_with=5, # defaults to None (get all scores) count=100 # defaults to 100 # , continuation_token=token )</span></pre><p id="4cc7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用ID是你需要提供给评论的第一个参数。对评论进行分类有两种方式:最近的或者Google Play认为最相关的。您也可以根据分数过滤评论。</p><p id="88f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">count参数的主要目的是告诉函数在结束之前应该检索多少评论。以下摘自google-play-scraper文档:</p><p id="ff2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“过高的计数会引起并发症。因为Google Play支持每页200条评论的限制，所以它被设计为按200条进行分页和重新搜索，直到结果数达到count为止。</p><p id="5ac2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">* *作为题外话，将count设置为无穷大相当于将reviews all设置为无穷大，这在我看来有些过分。</p><p id="5d12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我看来，计数是思考和使用批量的更好方式。只需将评论的数量设置为200，将评论和您的令牌一起返回，并在reviews函数的下一次迭代中使用您的令牌。</p><h1 id="2613" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">查看刮痧</h1><p id="b455" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">让我们破解密码</p><ul class=""><li id="7ae1" class="lb lc hi is b it iu ix iy jb ld jf le jj lf jn lg lh li lj bi translated">通过遍历应用id列表来抓取Google Play评论。</li><li id="b682" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">定期将评论存储在MongoDB集合中。</li><li id="5f02" class="lb lc hi is b it lk ix ll jb lm jf ln jj lo jn lg lh li lj bi translated">打印有关刮擦操作的进度更新。</li></ul><p id="4c29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤1:设置回路</strong></p><p id="8855" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你之前已经保存了我们的应用程序名称和id列表。抓取不一定需要应用程序名称列表。这背后是有原因的。在这段代码中，您将开始使用loop遍历我们所有的应用程序。请再次检查您的姓名和身份证列表是否相同。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="5ef0" class="kw jq hi ks b fi kx ky l kz la">## Loop through apps to get reviews for app_name, app_id in zip(app_names, app_ids): # Get start time start = dt.datetime.now(tz=get_localzone()) fmt= "%m/%d/%y - %T %p" # Print starting output for app print('---'*20) print('---'*20) print(f'***** {app_name} started at {start.strftime(fmt)}') print() # Empty list for storing reviews app_reviews = [] # Number of reviews to scrape per batch count = 200 # To keep track of how many batches have been completed batch_num = 0</span></pre><p id="99e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第二步:刮出第一批评论</strong></p><p id="dbb4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你需要给每本新得到的复习词典增加两个关键词。因为为每个评论收集的数据不会明确标识该评论是针对哪个应用程序的，所以附加这些标识符是有益的。一场潜在的危机已经避免了！</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="463e" class="kw jq hi ks b fi kx ky l kz la"># Retrieve reviews (and continuation_token) with reviews function rvws, token = reviews( app_id, # found in app's url lang='en', # defaults to 'en' country='us', # defaults to 'us' sort=Sort.NEWEST, # start with most recent count=count # batch size ) # For each review obtained for r in rvws: r['app_name'] = app_name # add key for app's name r['app_id'] = app_id # add key for app's id # Add the list of review dicts to overall list app_reviews.extend(rvws) # Increase batch count by one batch_num +=1 print(f'Batch {batch_num} completed.') # Wait 1 to 5 seconds to start next batch time.sleep(random.randint(1,5))</span></pre><p id="2399" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第三步:存储第一批的审核id</strong></p><p id="2b14" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每篇评论都有独特的标识。我们需要在收集下一批评论之前保存这些评论，以便以后进行比较。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="8f79" class="kw jq hi ks b fi kx ky l kz la"># Append review IDs to list prior to starting next batch pre_review_ids = [] for rvw in app_reviews: pre_review_ids.append(rvw['reviewId'])</span></pre><p id="df97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤4:设置并循环最大批次数量</strong></p><p id="4ba8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我们已经收到了第一批评论的令牌，因此我们可以循环通过每批200个评论。我们将在下面的代码中使用range(4999)将最大批次数设置为5，000(我们已经获得了第一批)。这意味着我们将获得前一百万条评论，假设有的话。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="2988" class="kw jq hi ks b fi kx ky l kz la"># Loop through at most max number of batches for batch in range(4999): rvws, token = reviews( # store continuation_token app_id, lang='en', country='us', sort=Sort.NEWEST, count=count, # using token obtained from previous batch continuation_token=token ) # Append unique review IDs from current batch to new list new_review_ids = [] for r in rvws: new_review_ids.append(r['reviewId']) # And add keys for name and id to ea review dict r['app_name'] = app_name # add key for app's name r['app_id'] = app_id # add key for app's id # Add the list of review dicts to main app_reviews list app_reviews.extend(rvws) # Increase batch count by one batch_num +=1</span></pre><p id="ef6a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤5:如果没有添加任何内容，则中断循环</strong></p><p id="a6f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在抓取当前批次之前，您需要将审查id的集合与当前批次之后的审查id集合进行比较。如果两组长度相同，这意味着我们已经停止向数据库添加新的评论。结果就是你会中断循环，继续下一个app。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="589d" class="kw jq hi ks b fi kx ky l kz la"># Break loop and stop scraping for current app if most recent batch # did not add any unique reviews all_review_ids = pre_review_ids + new_review_ids if len(set(pre_review_ids)) == len(set(all_review_ids)): print(f'No reviews left to scrape. Completed {batch_num} batches.\n') break # all_review_ids becomes pre_review_ids to check against # for next batch pre_review_ids = all_review_ids</span></pre><p id="1c8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果长度不同，再刮一次。在开始下一批之前，您将把我们当前的所有审核id列表重新分配给pre review ids变量。</p><p id="a091" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤6:保存数据并在每第I批后打印一次更新</strong></p><p id="f393" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你获得数万甚至数百万条评论时，获得事情进展的最新信息是一件美妙的事情。或许更重要的是，当你知道你的信息在旅行中被安全地保存时，你会感到很欣慰。每100批，下面的代码完成这两项。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="15a4" class="kw jq hi ks b fi kx ky l kz la"># At every 100th batch if batch_num%100==0: # print update on number of batches print(f'Batch {batch_num} completed.') # insert reviews into collection review_collection.insert_many(app_reviews) # print update about num of reviews inserted store_time = dt.datetime.now(tz=get_localzone()) print(f""" Successfully inserted {len(app_reviews)} {app_name} reviews into collection at {store_time.strftime(fmt)}.\n """) # empty our list for next round of 100 batches app_reviews = [] # Wait 1 to 5 seconds to start next batch time.sleep(random.randint(1,5))</span></pre><p id="ef10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你正在寻找刮谷歌Play商店数据，联系网页屏幕刮今天！！！</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><p id="44bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mb">最初发表于</em><a class="ae jo" href="https://www.webscreenscraping.com/how-web-scraping-is-used-to-scrape-google-play-store-data.php" rel="noopener ugc nofollow" target="_blank"><em class="mb">【https://www.webscreenscraping.com】</em></a><em class="mb">。</em></p></div></div>    
</body>
</html>