<html>
<head>
<title>The backbone of a serverless app: Lambda functions and DynamoDb tables (Detecting Paris’ locked bicycle stations 2/5)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器应用的主干:Lambda函数和DynamoDb表(检测巴黎2/5上锁的自行车站)</h1>
<blockquote>原文：<a href="https://medium.com/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-2-b1967d639699?source=collection_archive---------9-----------------------#2021-08-02">https://medium.com/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-2-b1967d639699?source=collection_archive---------9-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a4de9e67b7d58248468a03e9cad5d8ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uW5nj8uss2tBnUcC"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">切佩·尼科利在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="iv iw ix"><p id="9ca3" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这一系列文章是关于我在学习如何使用AWS无服务器堆栈的同时，花了太多时间试图解决一个小问题(检测巴黎上锁的自行车站，见<a class="ae iu" rel="noopener" href="/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-1-95dcdb477649">第一部分</a>)。要查找其他文章，请跳到页面底部。</p></blockquote></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="7b4e" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">获取Velib的数据</h1><p id="22f0" class="pw-post-body-paragraph iy iz hi jb b jc lc je jf jg ld ji jj le lf jm jn lg lh jq jr li lj ju jv jw hb bi translated">在<a class="ae iu" rel="noopener" href="/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-1-95dcdb477649">第1部分</a>中，为了能够检测锁定的Velib站，第一步是摄取Velib API数据。正如我们之前看到的，这个<a class="ae iu" href="https://www.velib-metropole.fr/donnees-open-data-gbfs-du-service-velib-metropole" rel="noopener ugc nofollow" target="_blank"> API </a>公开了两个主要端点:</p><ul class=""><li id="e905" class="lk ll hi jb b jc jd jg jh le lm lg ln li lo jw lp lq lr ls bi translated"><a class="ae iu" href="https://velib-metropole-opendata.smoove.pro/opendata/Velib_Metropole/station_status.json" rel="noopener ugc nofollow" target="_blank"><strong class="jb hj">/station _ status . JSON</strong></a>实时(每分钟刷新一次)返回每个站点的内容和状态。</li><li id="83cd" class="lk ll hi jb b jc lt jg lu le lv lg lw li lx jw lp lq lr ls bi translated"><a class="ae iu" href="https://velib-metropole-opendata.smoove.pro/opendata/Velib_Metropole/station_information.json" rel="noopener ugc nofollow" target="_blank"><strong class="jb hj">/station _ information . JSON</strong></a>返回每个站点的特征(地理坐标和名称)。</li></ul><p id="bfe7" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">为了准确得到每个站内容的演变，我需要每分钟调用第一个端点。另一个可以不经常调用，因为特征很少改变。为此，我将创建两个Lambda函数:<em class="ja"> FetchStationsContent </em>和<em class="ja">fetchstations characteristics</em>。相应的数据将存储在DynamoDb表中。为了每分钟(或每小时)都“触发”我的函数，我将使用EventBridge规则。</p><p id="713a" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">下面是它的样子:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/fcec1c3413f83cc9dd57248195211ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dXXgyTOAoVRvycjmcr8erQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">数据接收管道</figcaption></figure><h1 id="60fc" class="ke kf hi bd kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx mh kz la lb bi translated">第一功能</h1><p id="5837" class="pw-post-body-paragraph iy iz hi jb b jc lc je jf jg ld ji jj le lf jm jn lg lh jq jr li lj ju jv jw hb bi translated">Lambda函数几乎可以用任何语言编写。对于某些应用程序(如JavaScript或Python)，您甚至可以将您的函数直接编码到AWS web控制台中。这对于快速原型来说很好，但是对于更大的项目来说并不推荐。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/704798a3e7ed802f1ef160c5e6bfd298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EmDf_mSgC2pQx91oTxlbag.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Javascript函数的web编辑器</figcaption></figure><p id="e896" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">第一个Kafka原型的大部分代码是用Java编写的。但是，我将使用Angular作为前端，如果可能的话，我想使用单一语言，所以我将用Typescript编写我的函数。AWS Lambda没有正式支持TypeScript，但是JavaScript支持(您可以为您的函数选择NodeJS后端)，所以我只需要将我的TypeScript代码转换成JavaScript，并上传到我的Lambda。</p><p id="a12d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">让我们开始第一个功能(获取电台的内容)。我将首先定义一些表示域对象的类型。</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="4214" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">然后我将使用<a class="ae iu" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>创建一个基本的REST客户端。</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">简化的Axios客户端</figcaption></figure><p id="add1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">Lambda函数本身只是使用客户端并记录内容。稍后我会将它保存在数据库中。</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="c909" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">函数<em class="ja"> lambdaHandler </em>就是被Lambda基础设施调用的<em class="ja">T5。之后，很简单的事情就是将它转换成JavaScript，压缩生成的文件夹，创建函数，并使用AWS web控制台将代码上传到其中。</em></p><p id="be0c" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">从那里，我可以手动运行该功能，以确保一切正常。每次运行的日志将在cloud watch(AWS日志和警报服务)中可见。我可以看到我成功获取了1410个电台的内容。完美！</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/492d58adfb10033e73889f07638a470d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mXJiqtzI9UcFHr-ewxM4Nw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">CloudWatch中的功能日志</figcaption></figure><p id="4b8f" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">为了每分钟都运行这个函数，我需要返回到我的函数页面，按照步骤添加一个触发器。然后，我将选择创建一个EventBridge规则，并指定一个计划表达式。可以使用CRON表达式，以及更简单的“rate”表达式。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/0c56f5fcd8c1a32b8e45cc1e9903baf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*EfzVgWDdIwPu43OH8urA9A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">“每分钟一次”的简单EventBridge表达式。</figcaption></figure><p id="3664" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">如果我返回到我的函数的页面，我可以看到EventBridge触发器已经附加到它。该功能现在将每分钟运行一次。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/992dbc4a6ed6c5b232ea2eeaea13eba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jtOGGpHmGu2_7-xgu9Ru6Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">AWS web控制台上的我的Lambda详细信息页面</figcaption></figure><p id="bf83" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">完美。现在我有了一个非常简单的类型脚本lambda，它将每分钟自动运行一次，并获取每个Velib站的当前数据。接下来，我需要将数据存储在某个地方。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/b488272d2b7c53a711e8ef54c8e859ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/0*jbKKYahrP556PsYV.png"/></div></figure><h1 id="d6ca" class="ke kf hi bd kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx mh kz la lb bi translated">无服务器文档数据库DynamoDb</h1><p id="ce65" class="pw-post-body-paragraph iy iz hi jb b jc lc je jf jg ld ji jj le lf jm jn lg lh jq jr li lj ju jv jw hb bi translated">DynamoDb是一个键/值和文档的无服务器数据库。数据存储在<em class="ja">表</em>中。每个表包含<em class="ja">项</em>，它们是简单的JSON有效载荷。对于每个表，您必须定义项目的哪些字段将用作关键字，以唯一地标识每个项目。您可以在两个选项之间进行选择:</p><ul class=""><li id="08f6" class="lk ll hi jb b jc jd jg jh le lm lg ln li lo jw lp lq lr ls bi translated"><strong class="jb hj">单个<em class="ja">分区键</em> </strong>:例如一个国家代码，如果你存储国家的特征。这就像SQL中一个简单的主键。</li><li id="f8d8" class="lk ll hi jb b jc lt jg lu le lv lg lw li lx jw lp lq lr ls bi translated"><strong class="jb hj">一个<em class="ja">分区键</em>和一个<em class="ja">排序键</em> </strong>:例如一个股票标识符和一个时间戳，如果你存储不同股票的历史价格。这就像SQL中的复合主键。</li></ul><p id="d0b3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">默认情况下，DynamoDb允许您根据为表选择的键来执行CRUD操作。您还可以扫描所有项目，或者使用更复杂的过滤器运行查询，如果可能的话，这些过滤器还会扫描项目或利用所选的键。当您为扫描或查询的每个项目付费时(稍后将详细介绍)，避免对您的表进行完全扫描是很重要的。因此，如果您希望能够按照给定的顺序获取项目，那么拥有排序键是非常有用的。例如，如果您想要加载“最后”项，您可以使用插入时间戳作为排序关键字，并按照时间戳进行简单的查询，限制为1。如果没有合适的排序键，您将不得不扫描所有的条目，并在代码中手动排序。</p><p id="846f" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">由于键的选择将影响项目的物理存储方式<a class="ae iu" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.Partitions.html" rel="noopener ugc nofollow" target="_blank"/>，一旦创建了一个表，就无法更改哪些字段用作键。您需要重新创建一个新表，并将数据迁移到该表中。</p><p id="15c1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">但是，如果您经常需要使用关键字以外的其他字段来查询项目，您可以定义附加索引:</p><ul class=""><li id="6aff" class="lk ll hi jb b jc jd jg jh le lm lg ln li lo jw lp lq lr ls bi translated"><a class="ae iu" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LSI.html" rel="noopener ugc nofollow" target="_blank"><strong class="jb hj"><em class="ja">【LSI】</em></strong></a><strong class="jb hj"><em class="ja"/></strong>允许你定义一个额外的排序键，(但你必须保持相同的分区键)。</li><li id="75d1" class="lk ll hi jb b jc lt jg lu le lv lg lw li lx jw lp lq lr ls bi translated"><a class="ae iu" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jb hj"> <em class="ja">全局二级索引(GSI) </em> </strong> </a>:允许你定义一对全新的分区和排序键。事实上，GSI几乎是您的表的副本，只是存储方式不同。这意味着GSI可能会稍微落后于您的主牌桌，并且只被视为最终与主牌桌一致。</li></ul><p id="70dc" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">DynamoDb还提供额外的生活质量功能，如自动删除旧项目。为此，您需要向项目添加一个字段，该字段将包含删除项目的时间戳。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/05ddf634c44df40b05d73939ab5aebf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sVwgcesmW4jGrX6IHkdMsw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">一个“库存”表，带有分区和分类键，以及一个生存时间字段，用于一年后自动删除。</figcaption></figure><h1 id="48dd" class="ke kf hi bd kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx mh kz la lb bi translated">动力定价还是持续流动的方式</h1><p id="b313" class="pw-post-body-paragraph iy iz hi jb b jc lc je jf jg ld ji jj le lf jm jn lg lh jq jr li lj ju jv jw hb bi translated">作为一种无服务器服务，DynamoDb定价模型不是基于底层服务器实例，而是基于您如何使用服务。您需要为存储的数据量以及执行的读写操作数量付费。更准确地说，你有两个选择:</p><ul class=""><li id="97ad" class="lk ll hi jb b jc jd jg jh le lm lg ln li lo jw lp lq lr ls bi translated"><a class="ae iu" href="https://aws.amazon.com/dynamodb/pricing/on-demand/" rel="noopener ugc nofollow" target="_blank"> <strong class="jb hj"> <em class="ja">按需</em> </strong> </a>:按本月实际完成的读/写次数付费</li><li id="e352" class="lk ll hi jb b jc lt jg lu le lv lg lw li lx jw lp lq lr ls bi translated"><a class="ae iu" href="https://aws.amazon.com/dynamodb/pricing/provisioned/" rel="noopener ugc nofollow" target="_blank"><strong class="jb hj"><em class="ja">provisioned</em></strong></a>:预先定义表每秒需要多少读/写。如果您超过了，DynamoDb将抛出一个错误，阻止您过度消费。</li></ul><p id="89f5" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">按需服务似乎更简单，但成本也更高。对于相同数量的读取/写入，调配的表的成本将降低约6倍。此外，Dynamo的空闲层只涉及已配置的表，所以我将使用它。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/173a92f49a41095a2a3366c3c2e83da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*0LVaHcKrBcQ-K_8UUkSbqg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">DynamoDb和Lambda的自由层。请注意，仅涵盖“已供应”的表。</figcaption></figure><p id="d428" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">那么，具体来说，这种供应是如何工作的呢？</p><p id="8be7" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">对于每个表，您需要定义RCU(读容量单位)和WCU(写容量单位)的数量。如果您希望这两个属性自动调整到给定的限制，您还可以设置自动缩放。</p><p id="2ade" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">RCU和WCU都表示表每秒可以支持的读写次数。更准确地说:</p><ul class=""><li id="3565" class="lk ll hi jb b jc jd jg jh le lm lg ln li lo jw lp lq lr ls bi translated"><strong class="jb hj"> 1 RCU =每秒1次4kb项目的一致读取。或者每秒2次不一致地读取4kb项目</strong> (DynamoDb使用非锁定复制过程，这意味着写操作可能需要几秒钟才能传播到集群中的所有节点。因此，根据您的用例，您可能绝对需要一致的数据，或者您可能不介意获取陈旧的数据)。如果读取大小超过4Kb的项目，则每增加一个4Kb的块需要1个RCU。</li><li id="d87c" class="lk ll hi jb b jc lt jg lu le lv lg lw li lx jw lp lq lr ls bi translated"><strong class="jb hj"> 1 WCU =每秒1次1kb项目的写入。</strong>如果您编写的项目大小超过1Kb，那么每增加1Kb的块就需要1个WCU。</li></ul><blockquote class="iv iw ix"><p id="dd8f" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hj">举例:</strong> <br/>如果你每秒(持续)读两个大小各为8Kb的条目，需要4个RCU。阅读(不一致的)相同的项目只需要2 RCU。写这些需要16个WCU。<br/>遗憾的是，如果每秒读取/写入一个大小为0.01Kb的项目，您仍然需要至少1个RCU和1个WCU，因为4Kb和1Kb分别是读取和写入操作的最小大小。</p></blockquote><p id="5c5a" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">但是，计划每秒的读写似乎几乎是不可能的。这就是为什么DynamoDb允许“突发”读写。不使用的操作最多可累积300秒(5分钟)。</p><blockquote class="iv iw ix"><p id="ebc1" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hj">例子</strong> : <br/>用1个RCU，如果你2分钟(120秒)什么都不读，就意味着你可以在很短的时间内从你的表中(持续)读取120s * 1 RCU * 4Kb = 960Kb的数据。</p></blockquote><p id="ea96" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">因此，如果您预先知道大约每5分钟从您的表中读取和写入的数据量，您应该能够选择rcu和wcu的最佳数量。在我的例子中，数据代表(几乎)固定数量的站点，并且每分钟都被获取，所以这应该是可行的。</p><h1 id="a431" class="ke kf hi bd kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx mh kz la lb bi translated">成本设计</h1><p id="cb47" class="pw-post-body-paragraph iy iz hi jb b jc lc je jf jg ld ji jj le lf jm jn lg lh jq jr li lj ju jv jw hb bi translated">整个应用程序只有25个rcu和25个wcu，我真的需要优化每个表。</p><p id="d2bd" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">让我们看看第一个表，它将存储每个站点每分钟的内容(可用自行车的数量和状态)。我如何组织数据(以及我选择哪些键)将影响我需要的RCU/WCU的数量。</p><p id="25b1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">那么，我可以用什么钥匙呢？</p><p id="0735" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated"><strong class="jb hj"> #1使用车站代码作为分区关键字，日期时间作为分类关键字:</strong></p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/71f0a949ebc80a30c3a9f01848dda19d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1T6ka9UV-WuXCT1a-bl9Rg.png"/></div></div></figure><p id="0038" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">似乎很明显。访问特定电台的内容变得非常简单。问题是我有~1.500个站，每个站的内容代表一个很小的有效载荷(大概160b)。每次我想更新所有站点的内容时，我需要执行大约1.500次写入。即使有突发(我每60秒才获取一次内容)，也将达到1.500/60 = 25 wcu！</p><p id="7a7a" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated"><strong class="jb hj"> #2使用日期时间作为分区键:</strong></p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/771306936b628b4a66dd292eab3c9a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8YzBnK5SXiXMDLcoMvFjcg.png"/></div></div></figure><p id="7129" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">为了减少所需的写操作数量，我可以将每个工作站的内容存储为一个对象(使用JavaScript字典)。这样我将得到一个230Kb的大对象(低于DynamoDb的400Kb大小限制),并且我将更好地使用我的rcu和wcu。但是分区键不能用于排序数据，这意味着我不能有效地获得最后更新的内容。</p><p id="7039" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated"><strong class="jb hj"> #3仅使用日期时间作为排序关键字</strong>:</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/8b0521c2c8b122b879ec96b5f0ca2d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KsKvUfMkvLPHl1E7tYgnZQ.png"/></div></div></figure><p id="d382" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">这在技术上是禁止的，因为分区键是强制的。但是没有什么可以阻止我使用一个简单的常量作为分区键。这样，我可以得到与解决方案#2相同的大小优化，并且我可以很容易地基于日期时间进行排序。</p><p id="bc87" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">平心而论，就性能而言，这并不是一个好的解决方案。拥有一个分区意味着DynamoDb将不能最优地分配我的数据。但是成本是我最大的限制。</p><p id="dda9" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">让我们回顾一下每个解决方案的不同特征。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/4e96bd60f4235823010d4bca2042a26f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zQZ-OABkvLn31wC0yWffPQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">存储每个电台内容的不同解决方案，以及它们各自的成本和特点</figcaption></figure><p id="7566" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">解决方案#3显然是赢家。</p><p id="15bc" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">使用AWS web控制台创建表格只需几秒钟。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/cfe1e0ca1bad21f38d1546a27d7deb91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IBjut6m9QLeR6sgwkcz2mw.png"/></div></div></figure><p id="81e4" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">我不会详述如何用TypeScript编写DynamoDb存储库，因为官方SDK文档已经很完整了。从TypeScript对象到JSON的封送/解封时要小心。<a class="ae iu" href="https://www.npmjs.com/package/type-transformer" rel="noopener ugc nofollow" target="_blank">型变压器</a>对此很有用。不要忘记为您的函数附加正确的角色，以便它可以访问您的表。</p><p id="e4a5" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">而且很管用！使用的写容量刚好低于我为此表定义的4 WCU。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/c87917cf0a1912b76f6968d0ddf47b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fa5G_xaMjCfdXsflE-dcOQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">供应的与消耗的wcu</figcaption></figure><p id="256a" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">这些成本问题在我的第一个Kafka原型中实现“事件”的方式和在无服务器解决方案中实现“事件”的方式之间引入了一个重大转变:以前，有了Kafka，我可以负担得起每个工作站一个事件，结果每分钟约1.500个事件。现在，一个事件代表了整个电视台网络。</p><h1 id="f3df" class="ke kf hi bd kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx mh kz la lb bi translated">计算增量</h1><p id="d63c" class="pw-post-body-paragraph iy iz hi jb b jc lc je jf jg ld ji jj le lf jm jn lg lh jq jr li lj ju jv jw hb bi translated">我将在<em class="ja"> FetchStationsContent </em>函数<em class="ja">中做最后一件事。</em></p><p id="aa18" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">我将为每个站点计算站点中现在的自行车数量与一分钟前的自行车数量之间的差异，并将其包含在内容数据中。如果给定的站没有发生任何事情，我还将计算它最后一次看到一些活动的时间。只要一个站没有活动，这个<em class="ja">无效自</em>属性就会复合。</p><p id="a39e" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">这样，内容将不再代表车站在给定时间的状态，而且还代表这些车站发生了什么(自行车是租出去的还是还回来的？从什么时候开始它不动了？).</p><p id="1f19" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">为此，我需要获取当前电台的内容(使用Axios客户端)和我的Dynamo表中最后插入的内容(使用Dynamo存储库)。在这里，我的Dynamo排序键将非常方便，可以避免扫描整个表。这两个操作可以使用<em class="ja"> Promise.all </em>并行完成，一旦都完成了，我就可以计算delta。</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="ee32" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">基础设施作为代码</h1><p id="7e87" class="pw-post-body-paragraph iy iz hi jb b jc lc je jf jg ld ji jj le lf jm jn lg lh jq jr li lj ju jv jw hb bi translated">另一个函数<em class="ja">fetchstations characteristics</em>的工作非常相似。我需要创建一个函数，上传一些代码，创建一个EventBridge规则，创建一个表，并将正确的角色附加到该函数。</p><p id="969b" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">我们已经看到了无服务器方法的局限性:我们需要创建许多小功能，并为每个功能定义正确的基础设施，而不是拥有几个“大”应用程序。</p><p id="cf9a" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">第一次使用AWS web控制台是可以的，但是这是不可伸缩的。我应该手动创建数十个函数和表吗？如果我想改变所有函数的一些共同特征，该怎么办？如何轻松回滚基础架构更改？这很快就会变得很难看。幸运的是，这里有几个工具可以帮助我。</p><p id="3cc6" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">CloudFormation是一种AWS服务，允许在YAML或JSON中定义应用程序所需的不同资源，甚至更好的是，在必要时创建和更新这些资源。需要一个新函数和一个新的DynamoDb表吗？只需将它们添加到您的CloudFormation文件(或<em class="ja">模板</em>)中，部署它，一切都会相应地创建或更新。</p><p id="c6ae" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">下面是一个模板示例，它定义了一个Lambda函数、一个DynamoDb表以及该函数更新和查询该表所需的角色:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="d742" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">定义函数和表非常简单，但是定义角色需要一些工作。</p><p id="58f1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">幸运的是，我们可以使用SAM简化这一过程。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/f6162d47a5a5707a76c90f5d6aba8bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9XhYvURbfqG6uw_MRAdslQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">SAM，无服务器应用程序模型</figcaption></figure><p id="4872" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated"><a class="ae iu" href="https://aws.amazon.com/serverless/sam/" rel="noopener ugc nofollow" target="_blank"> SAM </a>，或无服务器应用模型，是一个开源框架，用于在AWS上构建无服务器应用(由AWS开发)。它由两件事组成:</p><ul class=""><li id="d02b" class="lk ll hi jb b jc jd jg jh le lm lg ln li lo jw lp lq lr ls bi translated">CloudFormation的扩展，为最常见的无服务器服务提供简化的资源</li><li id="b497" class="lk ll hi jb b jc lt jg lu le lv lg lw li lx jw lp lq lr ls bi translated">CLI，允许您在本地构建、测试和部署您的应用程序</li></ul><p id="ca71" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">由于SAM的资源更简单，相同的Lambda函数和DynamoDb表可以这样描述:</p><figure class="lz ma mb mc fd ij"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="3bb7" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">没有更多的角色需要精心定义。SAM将把简化的模板转换成充实的CloudFormation模板，并创建所需的角色。而且，如果需要的话，您仍然可以在同一个模板中使用“成熟的”云信息资源。</p><p id="b564" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">为了构建和部署我的两个函数及其对应的表，我只需要编写SAM模板并运行以下命令。</p><pre class="lz ma mb mc fd mw mx my mz aw na bi"><span id="6172" class="nb kf hi mx b fi nc nd l ne nf">sam build<br/>sam deploy</span></pre><p id="fff1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">这是行不通的…因为SAM并不真正知道如何处理TypeScript编译过程。有几种解决方案可以解决这个问题。我可以创建一个<a class="ae iu" href="https://evilmartians.com/chronicles/serverless-typescript-a-complete-setup-for-aws-sam-lambda" rel="noopener ugc nofollow" target="_blank">专用层</a>(一种给你的Lambda增加额外能力的方法)。但是我发现使用sam-webpack-plugin 更容易。<br/>所以，现在我的流程将是:</p><pre class="lz ma mb mc fd mw mx my mz aw na bi"><span id="c2e5" class="nb kf hi mx b fi nc nd l ne nf">npm run build<br/>sam deploy</span></pre><p id="90ed" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">这将把我的TypeScript函数转换成JavaScript，把源代码上传到S3桶，把简化的SAM模板转换成完整的CloudFormation模板，然后部署一切。</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/b2196b247d37c29fceab3e4b9060c624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vDBsy7xPv2mNnElZ7XNVqg.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">构建和部署过程</figcaption></figure><p id="58be" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">在创建新的函数和表时，我可以啜饮咖啡。</p><blockquote class="iv iw ix"><p id="84c9" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">还有其他工具可以简化无服务器应用程序的开发。例如，<a class="ae iu" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器</a>提供了与SAM类似的功能，同时允许您与其他云提供商合作。它还提供了更强大的测试和警报功能。</p></blockquote></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="56c7" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">这是一个好的开始。现在我能够存储每个站点随时间变化的内容，我应该能够计算给定站点的通常活动，并使用它来检测站点何时似乎被锁定。</p><p id="5a31" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj le jl jm jn lg jp jq jr li jt ju jv jw hb bi translated">第3部分再见！</p><figure class="lz ma mb mc fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/3f4bbe14e6a83932c05b67c4912a0279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*tJfd4EEKVAwUKpMa"/></div></figure></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><ul class=""><li id="5594" class="lk ll hi jb b jc jd jg jh le lm lg ln li lo jw lp lq lr ls bi translated"><a class="ae iu" rel="noopener" href="/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-1-95dcdb477649">第1部分</a>:为原型选择AWS无服务器堆栈</li><li id="19fa" class="lk ll hi jb b jc lt jg lu le lv lg lw li lx jw lp lq lr ls bi translated"><a class="ae iu" href="https://ouvreboite.medium.com/detecting-locked-bicycle-stations-an-aws-serverless-story-part-2-b1967d639699" rel="noopener">第2部分</a>:无服务器应用的主干:Lambda函数和DynamoDb表</li><li id="2e16" class="lk ll hi jb b jc lt jg lu le lv lg lw li lx jw lp lq lr ls bi translated">第3部分:用Lambda函数和DynamoDb流实现实时检测算法</li><li id="b36a" class="lk ll hi jb b jc lt jg lu le lv lg lw li lx jw lp lq lr ls bi translated">第4部分:创建一个无服务器的API，用S3托管一个前端</li><li id="9fd0" class="lk ll hi jb b jc lt jg lu le lv lg lw li lx jw lp lq lr ls bi translated"><a class="ae iu" rel="noopener" href="/codex/performance-tuning-for-an-aws-lambda-based-api-b8b49b2d07db">第5部分</a>:基于Lambda的API的性能调优</li></ul></div></div>    
</body>
</html>