# 作为软件工程师要避免的 10 个错误

> 原文：<https://medium.com/codex/10-mistakes-to-avoid-as-a-software-engineer-b50a2bb1956f?source=collection_archive---------9----------------------->

![](img/b62f8870bc077589531d87c9041d9e66.png)

图片鸣谢:[searchenginejournal.com](https://www.searchenginejournal.com/10-common-seo-mistakes/178734/)

我们都必须从某个地方开始。对我来说，那是 2019 年 6 月，我在[数据营](https://www.datacamp.com/)开设了 python 速成班。在获得应用统计学学士学位后，我变得聪明、充满活力，充满了多年来在教室里积累的能量。我对“最佳实践”一无所知我只想停止学习，开始做*。*

![](img/1444d9af672d02536e1564fd9d4c9b66.png)

我在工作面试中

但我很快发现，在现实生活中，你永远不会停止学习。每天都有一课要记笔记，每一个错误都比任何教授教给我们的更多。一开始，我对泊松分布的了解比软件工程多。

从那以后，我成长了许多，但我也不得不艰难地学习了许多课程。虽然对于那些已经编程一段时间的人来说，这些经验似乎是显而易见的，但正如他们所说的，“事后诸葛亮”。这篇文章献给那些一年前和我在同一个地方的年轻雄鹿。我希望我犯的这 10 个错误能帮助你走向成功。

# 错误 1:想法太小

很容易做出这样的假设:如果某些东西在您的本地机器上工作正常，那么它在生产中也会工作得很好。当我构建我的第一批微服务时，我没有考虑它们的扩展和性能会有多好。

如果您要搜索一个文档，使用 python 字典和 regex 表达式来支持原始搜索引擎效果很好。试图使用相同的工具搜索成千上万的文件是徒劳的定义。我希望在我的项目早期做的一件事是停下来问自己“这个会扩展吗？”大多数情况下，答案是绝对不。

寻找大规模工作良好的解决方案和架构是软件开发的基础部分。当评估一个问题的潜在答案时，我做的第一件事是考虑它在更大的范围内会有多有效。随着时间的推移和实践，我能够预测由于规模和复杂性而出现的问题。这里有几个例子:

*   数据库的选择可以决定一个产品的成败。如果你选择了一个弱选项，你将深陷科技债务，直到你还清学生贷款(如果这种情况发生的话)。
*   当处理大量任务时，线程和并发任务可能会导致意外的行为。我已经着手进行了许多 Scooby-Doo 调试会话，这些会话最终导致了对罪魁祸首的揭露。通常的嫌疑人？竞争条件、内存不足错误和节流。
*   过于脆弱的设计或命名约定会使以后的更改变得痛苦。重构发生的频率比你想象的要高，尤其是当你在创业公司工作的时候。从每个服务都是一个可替换的乐高积木的角度来构建微服务，会使更改它们变得容易一千倍。我的第一个服务工作起来更像被子里缠绕的线，而不是任何类似于模块化设计的东西。
*   拥有一个需要手动更改和更新才能工作的系统是不可持续的。自动化这些类型的任务可以节省您的时间，并有助于避免以后的用户错误。我们曾经有一个产品，每次添加新客户时，它都要求我在列表中添加一些正则表达式。**不可扩展！**

# 错误 2:想得太多

思维太小的另一面是思维太大。试图想象一个问题集中的每一个边缘情况会很快变得令人不知所措，并且经常会使人瘫痪。

在学会不孤立地考虑事情后，我试图一次考虑所有的相互联系，以此来过度补偿。一旦我达到了我的理解门槛，我的大脑就僵住了，变得不知所措，因为我不知道从哪里开始。

![](img/c47a93f3b09d8ac5b12ddf6e0e8e0887.png)

我试图思考我们的微服务架构

在同事们的帮助下，我懂得了把复杂的大问题分解成小问题的价值。每当我被卡住的时候，他们都帮我问“这个问题怎么分解？”一旦我能够把这个庞大的任务分解成几个容易理解的任务，我就变得无拘无束，更有效率。

在这里帮助我的最有价值的工具之一是流程图。我是一个视觉思考者，所以有一张图片伴随着一个抽象的概念会大大增加我对问题的理解。

我将分享一个我为帮助构建的数据管道建模而制作的示例图。每当我与团队中的其他开发人员讨论这个管道时，我总是拿出这个来，因为它有助于我解释它。一张照片真的抵得上 1000 个字:

![](img/99263e0d9e27afae1d8501a203aabe59.png)

对不起那些不用黑暗模式的人…

我不打算详细解释整个管道，但你可以想象这是多么有用。我可以回到这个图，快速回顾一下管道是如何工作的，每个服务做什么的基本思想，以及它如何适应更大的画面。想象一下试图在你的头脑中记录这一切！另外，如果我被一辆公共汽车碾过，有人可以弄清楚 autodocs 管道是如何工作的…

![](img/80a215c9aaee7f16875905cc16dc3590.png)

实际上，放一张截图比刻一个二维码更便宜…

# 错误 3:重演巴别塔

对于那些不熟悉的人来说，巴别塔是误解和不同语言造成的障碍的同义词。适用于人类语言的斗争也适用于编码语言。使用不同的编码语言在短期内可能看起来更有效率，但是从长期来看，可能会对生产力造成很大的损失。

![](img/811190b5e0a6cf5f955f9821e7387a1d.png)

图片来源:[蒂姆·安德森](/the-infinite-universe/the-tower-of-babel-project-how-human-beings-must-prepare-for-the-approaching-singularity-36355b908aed)

每个人都有自己喜欢的编码语言。对于一些人(像我一样)，它是 Python。对其他人来说是红宝石。当被要求完成一项任务时，用一种你感到舒适和胜任的语言来铺平道路是很有诱惑力的。但是如果这种语言不同于你的拼图中的其他部分，这实际上会成为开发过程中的一个难点。

我们的大多数微服务和 API 都是用 Python 构建的，但也有一些是用 Ruby 构建的。在 Ruby 中制作的服务很快成为其他开发人员的黑匣子(他们和我一样资历较浅，只懂 Python)，如果服务出现故障，唯一能修复服务的人就是构建它的开发人员。

在这个问题不断发生后，我们对基础设施中使用的语言进行了标准化:

*   自动化服务使用 Java
*   微服务、API、云函数使用 Python
*   前端应用程序使用 NodeJs

这带来了额外的效果，统一了我们各自的代码库，改善了潜在开发人员的招聘流程。简历上有 Python 和 NodeJs 的人更有可能成功。

是的，这迫使一些人适应并在每次不得不键入`self.my_python_variable`时内心畏缩，但那些不适应的人不会在这个行业持续很久。

我承认这条规则也有例外，因为有时某项任务只能用某种语言来完成。例如，如果您试图减少处理大型 csv 文件所需的处理时间，C++将比 Python 更具性能。但是总的来说，你的代码库越一致，你的情况就越好。

# 错误 4:没有记录我的代码

看我六个月前写的代码通常会变成一种解读古埃及象形文字的练习。在那一刻看起来如此清晰的事物，在时间的迷雾和不完美的记忆中会很快变得模糊不清。

![](img/ef26ece89e4157c64d94ac1af372960d.png)

#他们真的应该留下一些评论…图片来源:[阿历克斯·唐沃尔](/@alex.dovr00/hieroglyphics-language-the-history-of-ancient-egypt-5a6385185952)

留下代码注释和花时间记录我工作过的代码是我工作流程的重要部分，但过去不是。早期，当人们对我工作的服务有疑问时，我会回答他们的问题，我对这项服务的大部分知识都停留在部落知识的水平。

随着时间的推移，我构建了越来越多的服务，我开始不得不回答越来越多的问题。我意识到记录我所做的事情可以回答我收到的很多问题，也可以帮助我记住服务实际上做了什么。

花时间记录你的代码可能会感到乏味和浪费，尤其是当你被迫快速前进的时候。但是我发现从长远来看，文档实际上节省了时间。它节省了我通常花在回答简单问题上的时间，而且如果我记录了它，我可以以快 10 倍的速度回到老项目。

我总是欣赏那些记录他们代码的团队成员(留下好的评论是其中的一部分)。相信我，你的团队也会感激你的。

拥有一个好的平台来存放你的文档也很关键。寻找一个允许您对文档执行全文搜索的平台。相信我，当你记不住确切的变量时，它会派上用场的。我的团队使用的是亚特兰大的 T1，我会推荐它。它有时有点笨拙，但看起来很棒，而且比 README.md 文件更容易操作。

# 错误 5:不使用发布/订阅

在其核心，pub/sub 是一个消息系统，它可以**向**用户**发布**消息。发布者将消息推送到一个队列(称为主题)，订阅者依次接收消息，订阅者连接到队列。

![](img/bf1bf40135f51ce62fad2c88c553beae.png)

这种设计非常灵活、可伸缩且功能强大，尤其是在数据管道中。然而，我甚至不知道它的存在，直到一个同事让我知道了它，从此我就爱上了它。如果你想构建可伸缩的解决方案，发布/订阅应该是其中的一部分。

pub/sub 有不同的实现方式，就像在冰淇淋店挑选口味一样:你真的不会出错。谷歌有[云发布/订阅](https://cloud.google.com/pubsub)，亚马逊有[发布/订阅消息](https://aws.amazon.com/pub-sub-messaging/)。还有一个真的很厉害的叫[阿帕奇卡夫卡](https://kafka.apache.org/)(不过我还没怎么体验过)。

我发现的学习 pub/sub 的最佳资源是由侯赛因·纳赛尔制作的视频。他举了一些很好的例子来说明为什么发布/订阅很棒，以及它如何优于传统的请求/响应架构。

# 错误 6:没有使用自动格式化程序

即使你和别人说同一种语言，方言和口音也会有差异。我总是喜欢纯正的澳大利亚或英国口音。当然，听起来很有趣，但有时很难理解:

*   松饼和茶点？克罗齐。我想我会的。

当人们使用不同的格式和缩进时，在编码语言中就形成了方言。考虑由两个不同的 dev 产生的以下 Python 代码。他们都做同样的事情，但看起来非常不同。

```
# Dev A (multiline method chaining, 4 space indentation)
my_documents = db.collection("users").document("tim_estes").\
    collection("documents").where("createdAt", "<", yesterday).get()for doc in my_documents:
    doc.reference.update({
        "first_name": "tim",
        "last_name": "estes",
        "edited_at": now,
        "edited_by": "admin"
    })
```

_____________________________________

```
# Dev B (no dict indenting, 2 space indentation, but better method chaining)
my_documents = (
  db.collection("users")
  .document("tim_estes")
  .collection("documents")
  .where("createdAt", "<", yesterday)
  .get()
)for doc in my_documents:
  doc.reference.update({"first_name": "tim", "last_name": "estes", "edited_at": now, "edited_by": "admin"})
```

通常，这些小差异不是问题。但是一旦你开始在一个有不同格式偏好的团队中工作，合并冲突就会出现，你的代码库开始看起来像我奶奶的旧家庭剪贴簿。没有一致性，只是看起来很丑(对不起奶奶！)

我曾经花很多时间尝试格式化我的代码，直到一个队友建议我们开始使用[黑色](https://black.readthedocs.io/en/latest/)。Black 是一个朴实无华、固执己见的代码格式化程序，它让我专注于重要的编码部分，而不是不重要的部分。

这是一个黑色的例子。完成 Black 的 pip 安装后，只需运行`black my_python_file.py`，它就会为你完成所有的格式化工作！这是之前的同一个 python 脚本，但是被格式化为 Black 的 PEP-8 样式:

```
# ah, much better!
my_documents = (
    db.collection("users")
    .document("tim_estes")
    .collection("documents")
    .where("createdAt", "<", yesterday)
    .get()
)for doc in my_documents:
    doc.reference.update(
        {
            "first_name": "tim",
            "last_name": "estes",
            "edited_at": now,
            "edited_by": "admin",
        }
    )
```

对于那些现在想给布莱克一个旋转的人来说，去看看[互动游乐场](https://black.now.sh/)。如果你还没有被说服，你应该看一个由制造黑色的人做的展示。

作为合并请求过程的一部分，强烈鼓励开发人员通过 Black 运行他们的代码。结果是一个专业和一致的代码库，没有方言和愚蠢的合并冲突。

虽然我不建议使用一台可以去除人类语音中所有口音的机器，但我*会*推荐对代码语言做同样事情的 Black 或等效的包(Javascript 用[beautiful](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)，C++用 [Astyle](http://astyle.sourceforge.net/) )。

# 错误 7:没有重用代码

想象一下，每当工人需要挖洞时，他们就出去买一把新铲子，这是多么愚蠢的事情啊！我们会说他们疯了，因为他们没有重复使用他们已经拥有的工具。

![](img/b4dcfc566cf8a6cb5f2d207474b3f28e.png)

好吧，我以前就是那样的人。我有一个在我工作的项目中非常有用的函数目录，当开始一个新的目录时，我做的第一件事就是将该目录复制到新的代码库中。

我不仅有一堆重复的代码，如果其中一个功能需要补丁，我还需要更新每一个回购协议。最终，一位同事意识到了我的错误，建议我将这些函数放入一个 Python 包中，这个包可以在内部使用，也可以导出到需要它们的项目中。

这些功能变得更容易管理，并且对于那些想在他们自己的项目中使用这些功能的人来说也更容易访问。这标志着我开始成为我们开发团队中一股不可忽视的力量，这个包很小，但也是我真正引以为豪的东西。

如果你担心你的代码是开源的，有一些方法可以托管私有包。Gitlab 有一个选项，你可以上传包到一个代码库，并使用私有令牌来访问所述包。关于如何使用它的步骤可以在[这里](/maisonsdumonde/gitlab-ci-cd-and-gitlab-pypi-repository-4916a51d22eb)找到。

# 错误 8:没有抽象数据库请求

当应用程序与数据库通信时，您有两种选择:

1.  直接与数据库通信
2.  通过抽象层与数据库通信

![](img/5b0d0712893dd397ac004276ef8e9c76.png)

抽象层起初可能看起来没有必要，但我已经认识到不使用它们可能是一个大错误。我将简单列出雇佣一个的好处和不雇佣的后果。

好处:

*   抽象层更安全，因为您可以更好地控制哪些请求可以访问数据库。
*   抽象层允许您在流量大的时候限制请求。
*   您可以通过在抽象层隐藏更难看的查询语义来简化应用程序所做的查询。
*   从数据库中创建、更新和删除数据的代码是集中的，而不是分散在应用程序中。
*   您可以在抽象层中放置一个缓存，提高频繁访问的数据的读取速度，同时减少数据库读取操作的开销。

后果:

*   如果您需要迁移到不同的数据库，应用重构将比抽象层重构昂贵得多。如果您使用抽象层，您可以在保留应用程序代码的同时切换出层服务。我的团队已经亲身经历了这一点，现在我们的应用程序本质上是与数据库结合在一起的，离婚不是一个可行的选择。不要让这种事发生在你身上！

# 错误 9:忽略幂等性

![](img/d2cf8f33c3def609aa17dce4617ea692.png)

书生鸽无所不知。图片来源: [Thesaurus.plus](https://thesaurus.plus/)

幂等是一个有趣的词。根据堆栈溢出的定义:

> 在计算中，幂等运算是一种如果用相同的输入参数多次调用就不会产生额外效果的运算。例如，从集合中移除一个项目可以被认为是对集合的幂等运算。”

对于更倾向于数学的人，这里有一个幂等函数的例子(你们中的一些人可能认为它是[恒等函数](http://Identity Function)):

*让 f* ( *x* ) = *x*

如果*f*(*f*(*x*)=*f*(*x*)，则称一个函数是幂等的。将输入输入到我们的函数中总是产生相同的输出*，*，因此*f*(*x*)=*x*是一个幂等函数。

回到现实世界，幂等性在处理网络协议时很重要。许多服务都有“至少一次”的交付策略，这意味着请求保证至少发生一次，但也可能发生多次。这是为了防止超时或失败导致消息丢失。请求被重新传输，以确保它们至少被传递一次。

如果您正在使用“至少一次”的交付策略，那么所涉及的操作是幂等的是很重要的。考虑以下场景:

*   用户在网站上下订单。订单请求带有至少一次交付策略。

如果后台设置不正确，人们可能会因为他们的订单被收取两次费用！这是因为订单请求可能会被传递多次，如果您将每个请求都视为一个新订单，那么每次至少一次策略生效时，您都会复制该订单。

这里有一个技巧可以帮助你使你的服务幂等:

*   从传入的请求中创建一个散列，并将其用作事务 id。它不会创建新的事务，而是无害地覆盖已经存在的事务。

对于那些渴望了解更多的人，可以看看这个关于[为什么幂等性很重要的视频](https://www.youtube.com/watch?v=4OuaONkZw1I)。

# 错误 10:不完全粗制滥造

C.R.U.D .是代表创建、读取、更新和删除的首字母缩写词。当处理一个数据库时，最重要的是你有能力执行这四个操作。

在我早期的项目中，我非常专注于从我正在工作的数据库中创建和读取数据，并且有很大的压力要将项目投入生产。一切都很顺利…直到一个用户想从数据库中更新和删除文档！啊哦！我应该想到的！

![](img/7c4731145a5168cea511a6e364a37895.png)

我承认，在有些情况下，更新和销毁记录并不重要，在 CRUD 中添加“UD”也没有意义(想想审计跟踪数据和其他类型的只读数据)。但是在其他场景中，很容易忽略更新和删除操作。

如果没有很好的删除操作，数据库可能会被不应该存在的数据弄得乱七八糟。当处理巨大的数据湖时，这些数据会变得很难找到，并增加您的开销。

一个很好的策略是利用对象生命周期来帮助你管理你的文件。在谷歌云存储和 AWS 中，如果文件达到一定年龄或满足特定条件，可以让文件过期。或者，如果处理索引，您可以设置一个索引生命周期策略，清除索引中的旧文档。我在 Elasticsearch 中有过这样的经历，这是另一篇媒体文章的主题…

不要忽视你的 CRUD 操作孩子们！

# 结论

不要害怕犯错误，也不要先入为主。这是成为一个美丽的人和成长的一部分。我已经从我一生中所犯的所有错误中学到了很多(不仅仅是与软件相关的)，但是我也不想最小化它们的后果。

当我搞砸的时候，我不会对自己发火，而是试着后退一步，倾听在每一个错误的脚步中回响的智慧。因为我认为我们可能犯的最大错误是*犯两次同样的错误*。