<html>
<head>
<title>Introduction to Dynamic Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态编程简介</h1>
<blockquote>原文：<a href="https://medium.com/codex/introduction-to-dynamic-programming-24666933ae6?source=collection_archive---------6-----------------------#2021-10-03">https://medium.com/codex/introduction-to-dynamic-programming-24666933ae6?source=collection_archive---------6-----------------------#2021-10-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a188" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">为国家优化！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/2d8d09bded3e8d76e4314f865595e537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EP7X9rQrz1OeLXno"/></div></div></figure><h1 id="ff16" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">观众</h1><p id="3fe5" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">本文的目标读者是对算法有初步经验的工程师，他们希望迈出动态编程的第一步。需要扎实的递归知识，并对位操作符有所了解。</p><p id="c1e8" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们将在Java中实现这些技术，所以对这种语言有一个基本的了解是有帮助的，尽管不是必需的。</p><h1 id="3ff5" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">争吵</h1><p id="4401" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">动态编程可以被认为是递归的优化。如果我们有一个递归问题，需要我们解决同一个问题两次，那么存储和重用那个问题的结果就更容易了。</p><p id="d7db" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">从形式上来说，它用下面的公式表示:</p><ol class=""><li id="2920" class="lc ld hi kd b ke kx kh ky kk le ko lf ks lg kw lh li lj lk bi translated"><strong class="kd hj">最优子结构:</strong>一个问题可以分解成子问题，子问题的最优解可以用来寻找主问题的最优解。</li><li id="5ff6" class="lc ld hi kd b ke ll kh lm kk ln ko lo ks lp kw lh li lj lk bi translated"><strong class="kd hj">重叠子问题:</strong>有些子问题的解会被多次使用，我们可以缓存以提高性能。</li></ol><p id="7132" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">虽然这听起来有点抽象，但还是用一个例子具体说一下吧。斐波纳契数列的计算公式如下:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="5e4b" class="lv jk hi lr b fi lw lx l ly lz">f(n) = f(n - 1) + f(n - 2)</span></pre><p id="c8c0" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">这里我们有起始条件<code class="du ma mb mc lr b">f(1) = 1</code>和<code class="du ma mb mc lr b">f(0) = 0</code>。让我们走一遍。</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="db76" class="lv jk hi lr b fi lw lx l ly lz">f(0) = 0<br/>f(1) = 1<br/>f(2) = f(1) + f(0) = 1<br/>f(3) = f(2) + f(1) = 1 + 1 = 2<br/>f(4) = f(3) + f(2) = 2 + 1 = 3<br/>...</span></pre><p id="b627" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们可以很快看到一种模式的出现。那么我们该如何编码呢？一种解决方案是使用:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="2f01" class="lv jk hi lr b fi lw lx l ly lz"><strong class="lr hj">public int </strong>fibonacci(<strong class="lr hj">int </strong>n) {<br/>    <strong class="lr hj">if</strong>(n &lt;= 1) {<br/>        <strong class="lr hj">return </strong>n;<br/>    }<br/>    <strong class="lr hj">return </strong>fibonacci(n - 1) + fibonacci(n - 2);<br/>}</span></pre><p id="4f96" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">然而，如果我们考虑一下这对<code class="du ma mb mc lr b">f(4)</code>来说是如何执行的，它将计算<code class="du ma mb mc lr b">f(3) + f(2)</code>，而<code class="du ma mb mc lr b">f(3)</code>也需要计算<code class="du ma mb mc lr b">f(2)</code>(由于<code class="du ma mb mc lr b">f(3) = f(2) + f(1)</code>)。因此，这种计算发生了两次，浪费资源！</p><p id="6fdb" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">更好的方法可能是使用数组结构来存储前面的两个斐波纳契数。一旦计算出来，这将允许我们重复使用它们！</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="6f28" class="lv jk hi lr b fi lw lx l ly lz"><strong class="lr hj">private static int </strong>fibonacci(<strong class="lr hj">int </strong>n) {<br/>    <strong class="lr hj">int</strong>[] fibonacciNumbers = <strong class="lr hj">new int</strong>[n + 1];<br/><br/>    fibonacciNumbers[0] = 0;<br/>    fibonacciNumbers[1] = 1;<br/><br/>    <strong class="lr hj">for</strong>(<strong class="lr hj">int </strong>i = 2; i &lt;= n; i++) {<br/>        fibonacciNumbers[i] = fibonacciNumbers[i - 1] +  <br/>                              fibonacciNumbers[i - 2];<br/>    }<br/><br/>    <strong class="lr hj">return </strong>fibonacciNumbers[n];<br/>}</span></pre><p id="4856" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">需要注意的一件重要事情是<strong class="kd hj">我们经常用空间换取时间。</strong>这里我们有一系列的解决方案，占用了空间。在一些动态编程问题中，我们会发现自己为了寻找更快的解决方案而耗尽了更多的内存。</p><h2 id="4da2" class="lv jk hi bd jl md me mf jp mg mh mi jt kk mj mk jv ko ml mm jx ks mn mo jz mp bi translated">自上而下与自下而上</h2><p id="a564" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">动态编程有两种主要方法:自顶向下(记忆化)和自底向上(制表)。</p><p id="458d" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">自底向上(听起来是这样)，是一种我们想要达到一种状态<code class="du ma mb mc lr b">n</code>的技术，我们需要从一些初始条件开始，并计算我们向上的方式。我们对斐波那契的动态编程回答就是一个很好的例子。注意我们如何计算<code class="du ma mb mc lr b">f(0)</code>，然后<code class="du ma mb mc lr b">f(1)</code>，然后<code class="du ma mb mc lr b">f(2)</code>。我们从底层做起，一路向上。</p><p id="7b17" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">自上而下则相反。我们的非DP Fibonacci解决方案就是一个很好的例子。我们从我们希望找到的解决方案开始<code class="du ma mb mc lr b">f(n)</code>，然后从该解决方案返回进行我们需要的计算。</p><p id="831d" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">一些人发现用下面的术语来表达这些想法是很清楚的:</p><ul class=""><li id="5caf" class="lc ld hi kd b ke kx kh ky kk le ko lf ks lg kw mq li lj lk bi translated"><strong class="kd hj">自下而上(memoization): </strong>我要学习Java，我要学习在线课程，我要阅读James的所有文章，我要成为一名编程大师。</li><li id="5bef" class="lc ld hi kd b ke ll kh lm kk ln ko lo ks lp kw mq li lj lk bi translated"><strong class="kd hj">自上而下(制表):</strong>我要成为一名编程大师，所以我会读完James的所有文章，但是先学习一门在线课程，但是先学习Java。</li></ul><p id="ef58" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们可以看到一个从一开始就朝着我们的目标前进，而另一个则相反。</p><h2 id="d04b" class="lv jk hi bd jl md me mf jp mg mh mi jt kk mj mk jv ko ml mm jx ks mn mo jz mp bi translated">最优化与组合问题</h2><p id="3d65" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">通常有两种类型的问题我们可以应用动态编程来解决。</p><ol class=""><li id="a429" class="lc ld hi kd b ke kx kh ky kk le ko lf ks lg kw lh li lj lk bi translated"><strong class="kd hj">优化问题:</strong>到目前为止，这些都是本文的重点。在这些类型的应用中，我们希望找到给定问题的最佳解决方案。</li><li id="1ccd" class="lc ld hi kd b ke ll kh lm kk ln ko lo ks lp kw lh li lj lk bi translated"><strong class="kd hj">组合问题:</strong>在这类问题中，我们要寻找一个因素可能的不同组合的数量。这可以用来计算某件事情发生的概率。</li></ol><p id="7c68" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">让我们使用来自<a class="ae mr" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>的一些例子来探索这些想法。</p><p id="6edd" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">看看优化，我们有下面的问题<a class="ae mr" href="https://leetcode.com/explore/featured/card/top-interview-questions-easy/97/dynamic-programming/576/" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="ms mt mu"><p id="b389" class="kb kc mv kd b ke kx ij kg kh ky im kj mw kz km kn mx la kq kr my lb ku kv kw hb bi translated">你是一个专业的强盗，计划沿街抢劫房屋。每栋房子都藏了一定数量的钱，阻止你抢劫每栋房子的唯一限制是相邻的房子都连接了安全系统，如果两栋相邻的房子在同一个晚上被闯入，它会自动联系警察。</p><p id="7239" class="kb kc mv kd b ke kx ij kg kh ky im kj mw kz km kn mx la kq kr my lb ku kv kw hb bi translated">给定一个表示每栋房子的钱数的整数数组<code class="du ma mb mc lr b">nums</code>，返回你今晚可以抢劫的最大金额<strong class="kd hj">而不惊动警察</strong>。</p></blockquote><p id="cb62" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">那么这是一个怎样的动态规划问题呢？我们想<strong class="kd hj">最大化</strong>我们能偷的数量，这是我们的第一个线索。此外，我们在房子A能偷的最大值与我们在房子A后面第二栋房子能偷的最大值相同(因为不想惊动警察，我们不能抢劫后面第一栋房子)，加上当前房子的价值。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="c2e9" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们可以对一个组合问题做类似的事情。让我们再举一个来自<a class="ae mr" href="https://leetcode.com/explore/featured/card/top-interview-questions-easy/97/dynamic-programming/569/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>的例子。</p><blockquote class="ms mt mu"><p id="5dc5" class="kb kc mv kd b ke kx ij kg kh ky im kj mw kz km kn mx la kq kr my lb ku kv kw hb bi translated">你正在爬楼梯。到达顶端需要<code class="du ma mb mc lr b">n</code>步。</p><p id="8b67" class="kb kc mv kd b ke kx ij kg kh ky im kj mw kz km kn mx la kq kr my lb ku kv kw hb bi translated">每次你可以爬<code class="du ma mb mc lr b">1</code>或<code class="du ma mb mc lr b">2</code>台阶。有多少种不同的方式可以让你爬上顶峰？</p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mz na l"/></div></figure><h2 id="c4f7" class="lv jk hi bd jl md me mf jp mg mh mi jt kk mj mk jv ko ml mm jx ks mn mo jz mp bi translated">比特屏蔽</h2><p id="6710" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">有时在动态编程中，我们需要表示一个集合。我们将探讨DP之外的位屏蔽的概念，因为孤立地研究更容易。再来看<a class="ae mr" href="https://leetcode.com/problems/maximum-product-of-word-lengths/" rel="noopener ugc nofollow" target="_blank">另一个LeetCode问题</a>。</p><blockquote class="ms mt mu"><p id="d8a1" class="kb kc mv kd b ke kx ij kg kh ky im kj mw kz km kn mx la kq kr my lb ku kv kw hb bi translated">给定一个字符串数组<code class="du ma mb mc lr b">words</code>，返回 <code class="du ma mb mc lr b">length(word[i]) * length(word[j])</code> <em class="hi">的最大值<em class="hi">，其中两个单词不共享公共字母</em>。如果没有这两个字，返回<code class="du ma mb mc lr b">0</code>。</em></p></blockquote><p id="8305" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">当我们寻找有共同字母的单词时，将这两个单词表示为它们的字母集合就足够了，然后检查是否有交集。</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="33bc" class="lv jk hi lr b fi lw lx l ly lz">hello = {h, e, l, l, o}<br/>jealous = {j, e, a, l, o, u, s}<br/>hello ∩ jealous = {e, l, o}</span></pre><p id="d55f" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">如果交集非空，我们知道存在冲突。我们可以用比特来表示这些集合，只要一个字母出现在单词中，我们就把它设为1。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="5dfb" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">请注意，我们并不关心一个字母出现了多少次，或者出现在哪里，只关心它们出现了多少次。</p><p id="df18" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">从这里我们可以看到这个问题的一个相当清晰的解决方案。创建每个单词的位掩码，同时跟踪带有该掩码的单词的最大长度。然后，我们遍历所有掩码，找到没有共同位的掩码，并计算它们的字长乘积。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mz na l"/></div></figure><h2 id="37d7" class="lv jk hi bd jl md me mf jp mg mh mi jt kk mj mk jv ko ml mm jx ks mn mo jz mp bi translated">数字动态编程</h2><p id="2558" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">好的，戴上你们的帽子，因为这里有点危险。我花了很长时间才明白过来，但也许你比我聪明一点！</p><p id="b1c2" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">有时，将一个数字视为其数字数组会很有用。例如<code class="du ma mb mc lr b">1234</code>变成了数组<code class="du ma mb mc lr b">[4, 3, 2, 1]</code>。注意它是如何被颠倒的，所以最左边的数字变成了最重要的数字。从4开始，我们可以生成它下面的所有数字，同时动态地检查它们的属性。我们稍后将引入一个示例，所以如果这暂时看起来很奇怪，请不要担心。</p><p id="2460" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">但是，您应该看到，生成4之后的数字并不像看起来那么简单。一个基本的生成算法可能会得出:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="534e" class="lv jk hi lr b fi lw lx l ly lz">40**<br/>41**<br/>42**<br/>43**<br/>44**</span></pre><p id="3443" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">其中<code class="du ma mb mc lr b">*</code>代表一些还需要在递归中计算的数字。<code class="du ma mb mc lr b">40** </code>可能变成<code class="du ma mb mc lr b">4000</code>、<code class="du ma mb mc lr b">4001</code>、……但是，如果我们看一下，最后一个条目太高了！我们需要一种方法来限制这种行为。输入<code class="du ma mb mc lr b">tight</code>。</p><p id="aa28" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated"><code class="du ma mb mc lr b">tight</code>变量用于告诉我们是否需要查看初始数字中的数字。例如，如果我们在寻找<code class="du ma mb mc lr b">40**</code>之后的数字，那么<code class="du ma mb mc lr b">tight</code>将被设置为<code class="du ma mb mc lr b">0</code>(或off)。这意味着下一个数字可以取从<code class="du ma mb mc lr b">400*</code>到<code class="du ma mb mc lr b">409*</code>的任何值(明白我为什么开始困惑了吧？).</p><p id="2934" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">开始时<code class="du ma mb mc lr b">tight</code>将被设置为<code class="du ma mb mc lr b">1</code>。这意味着我们需要在生成下一个数字之前检查我们的原始数字。我们需要记住我们最初的数字:<code class="du ma mb mc lr b">4321</code>。</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="ff0d" class="lv jk hi lr b fi lw lx l ly lz">40** - Is 0 less than 3? Yes, keep going<br/>41** - Is 0 less than 3? Yes, keep going<br/>42** - Is 0 less than 3? Yes, keep going<br/>43** - Is 0 less than 3? No, stop!</span></pre><p id="a803" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">一旦我们知道我们只生成无法达到上限的数字，我们就可以将<code class="du ma mb mc lr b">tight</code>设置为off。</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="63c9" class="lv jk hi lr b fi lw lx l ly lz">400* - Generate any numbers after this, they'll all be fine<br/>401* - Generate any numbers after this, they'll all be fine<br/>...</span></pre><p id="d41f" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">这是一个棘手的问题，但希望在通读几遍后，你会明白。从本质上说，这是一个聪明的方法，可以生成所有小于一个数的不同数。</p><p id="e639" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">当我们以这种方式生成数字时，我们也可以检查它们的任何我们需要的属性。一个有用的事实是，如果我们在两个边界<code class="du ma mb mc lr b">a</code>和<code class="du ma mb mc lr b">b</code>之间寻找一个属性<code class="du ma mb mc lr b">f(x)</code>，那么我们可以使用<code class="du ma mb mc lr b">f(b) — f(a)</code>计算这个属性的结果。同样，有点抽象，所以让我们来看我们的例子！我们从<a class="ae mr" href="https://www.geeksforgeeks.org/digit-dp-introduction/" rel="noopener ugc nofollow" target="_blank">极客那里借了一个给极客</a>。</p><blockquote class="ms mt mu"><p id="c3fd" class="kb kc mv kd b ke kx ij kg kh ky im kj mw kz km kn mx la kq kr my lb ku kv kw hb bi translated">给定两个整数<strong class="kd hj"> a </strong>和<strong class="kd hj"> b </strong>。找出a和b之间的整数中出现的所有数字的总和。例如，如果a = 5，b = 11，则答案是38 (5 + 6 + 7 + 8 + 9 + (1 + 0) + (1 + 1))</p></blockquote><p id="c1ca" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">希望有了上面的内容和下面的解决方案，情况会变得明朗一些。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="f8a6" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">数字DP是一个相当容易混淆的领域，所以可能需要补充阅读。然而，我希望这个粗略的介绍能提供一个直观的基础。</p><h1 id="5acc" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">结论</h1><p id="0128" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">总之，我们已经讨论了动态编程，它的定义，动机和一些用例。</p></div></div>    
</body>
</html>