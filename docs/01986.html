<html>
<head>
<title>Predicting the Risk of Cervical Cancer Using Gradient Boosted Decision Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用梯度增强决策树预测宫颈癌风险</h1>
<blockquote>原文：<a href="https://medium.com/codex/predicting-the-risk-of-cervical-cancer-using-gradient-boosted-decision-trees-777077941ff7?source=collection_archive---------5-----------------------#2021-06-20">https://medium.com/codex/predicting-the-risk-of-cervical-cancer-using-gradient-boosted-decision-trees-777077941ff7?source=collection_archive---------5-----------------------#2021-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8ab40e438c57a5d7e9fe291a27cf6f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRdoM-q5Sc0l58EBw9qQcA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://www.sciencellonline.com/human-cervical-epithelial-cells.html" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="93ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">每年，在美国本土有超过13万名女性</strong>被诊断患有宫颈癌，其中超过4000名女性将死于该疾病。</p><p id="1011" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">宫颈癌是全球女性第四大常见癌症，但由于它会随着时间的推移而发展，它也是最<em class="jt">可预防的癌症类型之一。</em></p><p id="e8cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管多种因素都可能导致个人患宫颈癌，但我们没有标准的方法来诊断有患宫颈癌风险的女性。</p><p id="7028" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果我们知道一名服用口服避孕药并经常吸烟的妇女有患宫颈癌的风险，她将能够消除这些风险因素并改变她的生活方式以限制她患宫颈癌的机会。</p><p id="269b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过利用<strong class="ix hj">机器学习</strong>，我们可以通过建立风险预测模型来大幅减少被诊断患有宫颈癌和死于宫颈癌的女性人数。</p><p id="d0cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了建立宫颈癌的风险预测模型，我们可以利用极端梯度增强算法，也称为<strong class="ix hj"> XGBoost算法。</strong></p><h2 id="b867" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">了解XGBoost算法</h2><p id="f999" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">XGBoost算法是一个有用的算法，因为它可以用于回归和分类任务。它使用监督学习和梯度推进，这意味着它以多决策树的形式产生预测模型。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/953c785aa84097e1e62decd8cc25cbc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZ1uce7m6DgwF6AXCAl4OQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://analyticsindiamag.com/xgboost-internal-working-to-make-decision-trees-and-deduce-predictions/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="598b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该算法通过从以前模型预测中的错误中学习来实现更好的未来预测。它以连续的方式训练弱模型。它根据训练数据建立初步模型，并根据<strong class="ix hj">残差</strong>或第一个模型的错误建立第二个模型。重复此过程，直到创建了最大数量的模型，或者直到模型提供了准确的预测。</p><p id="240b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个项目中，模型将被输入输入特征，包括个人的年龄、怀孕次数、吸烟频率、宫内节育器(IUD)的存在，以及他们是否患有性病，并将被告知该妇女是否应该接受活检以检查宫颈癌的存在。如果她被告知接受活检，但没有宫颈癌，她会知道自己可能有风险，并可以相应地采取行动，以将风险降至最低。</p><p id="c48c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了这个项目，我使用了2017年的数据集,该数据集收集了委内瑞拉加拉加斯的加拉加斯大学医院(Hospital Universitario de Caracas)的女性信息。该数据集包含858名患者的人口统计信息、习惯和医疗记录。</p><h1 id="e260" class="kz jv hi bd jw la lb lc ka ld le lf ke lg lh li kh lj lk ll kk lm ln lo kn lp bi translated">1.导入库和数据集</h1><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/6da1f830acff6ce01b98eeb7d2a81d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4SjqbV62i0CzwJqshDU6vg.png"/></div></div></figure><p id="6114" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">构建模型的第一步是将我们的库和数据集导入到我们的Jupyter笔记本中。</p><blockquote class="lr ls lt"><p id="3f12" class="iv iw jt ix b iy iz ja jb jc jd je jf lu jh ji jj lv jl jm jn lw jp jq jr js hb bi translated"><strong class="ix hj"> pandas </strong>:最流行的python库，用于数据操作和分析。在这个项目中，它主要用于数据帧操作。</p><p id="0148" class="iv iw jt ix b iy iz ja jb jc jd je jf lu jh ji jj lv jl jm jn lw jp jq jr js hb bi translated"><strong class="ix hj"> NumPy </strong>:一个python库，提供对大型多维数组和矩阵的支持，并具有高级数学函数来帮助操作和操纵这些数组。</p><p id="14f5" class="iv iw jt ix b iy iz ja jb jc jd je jf lu jh ji jj lv jl jm jn lw jp jq jr js hb bi translated"><strong class="ix hj"> seaborn </strong>和<strong class="ix hj"> matplotlib.pyplot </strong>:用于数据可视化。</p><p id="35da" class="iv iw jt ix b iy iz ja jb jc jd je jf lu jh ji jj lv jl jm jn lw jp jq jr js hb bi translated"><strong class="ix hj"> plotly </strong>:用于交互式数据可视化。</p></blockquote><p id="afbd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们安装了库，我们就可以使用pandas导入数据集。数据集应保存为CSV文件。下载我的数据集时，我将其命名为“子宫颈_癌症. csv”，并能够导入它，如下所示。</p><pre class="kv kw kx ky fd lx ly lz ma aw mb bi"><span id="4df4" class="ju jv hi ly b fi mc md l me mf">cancer_df = pd.read_csv('cervical_cancer.csv')</span></pre><h1 id="efbf" class="kz jv hi bd jw la lb lc ka ld le lf ke lg lh li kh lj lk ll kk lm ln lo kn lp bi translated">2.探索性数据分析</h1><p id="8963" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">进行探索性数据分析对于消除数据集中的不一致性至关重要；它需要删除重复，纠正错误，并处理丢失的值。</p><p id="68cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在项目的这一部分，我们将可视化我们的数据并删除空值。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/dbe2343ee90e0a3e7800322457262b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hRh9MNvvl1JLW4ZpVdYaIg.png"/></div></div></figure><p id="ab37" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们想从数据帧中获取信息。当我们运行<em class="jt"> cancer_df.info( ) </em>时，我们应该得到一个表，它显示了我们有多少条目(我们有数据的患者)和36列，它们显示了我们的不同特征，从个体的年龄到他们的性病诊断数量。</p><p id="9ad4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还可以看到所有的功能都有非空计数，我们还可以看到不同功能的数据类型。大多数是对象，稍后我们需要将它们转换成数值。</p><p id="5b6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们还可以通过运行<em class="jt"> cancer_df.describe( ) </em>获得一些关于我们的数据帧的统计信息。例如，我们可以看到患者的平均年龄约为26.8岁。</p><p id="e5c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，如果我们只看dataframe而不描述它，通过只运行<em class="jt"> cancer_df，</em>我们可以看到两列下面有问号；“STDs:自首次诊断以来的时间”和“STDs:自上次诊断以来的时间”</p><p id="916f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些问号是缺失数据或空数据的占位符。因此，我们需要将问号替换为<em class="jt"> NaN </em>，意思是“不是一个数字”，以表示它是一个空值。</p><pre class="kv kw kx ky fd lx ly lz ma aw mb bi"><span id="103a" class="ju jv hi ly b fi mc md l me mf">cancer_df = cancer_df.replace('?', np.nan)<br/>cancer_df</span></pre><p id="a9c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还可以通过真值或假值来可视化我们的数据框架，这将允许我们绘制热图，并查看整个数据中的空值。我们可以通过运行<em class="jt"> cancer_df.isnull()来做到这一点。</em></p><p id="60c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据中唯一的空值表示为“真”，而非空值表示为“假”</p><p id="0b15" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了可视化我们数据中的空值，我们可以用给定的特性绘制一个数据帧的<strong class="ix hj">热图</strong>。我们可以将热图设置为20x 20的网格。白色部分显示数据中的空值。</p><div class="kv kw kx ky fd ab cb"><figure class="mh ij mi mj mk ml mm paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/80ecc2e93cac816680bfb8aa97e5074c.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*VGE3-ZYIf2_MjshxM9ON-g.png"/></div></figure><figure class="mh ij mn mj mk ml mm paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/b92b5ec697695c983e6646e6f98fcab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*qXfFr2_729y-ZW_SdHxYVw.png"/></div></figure></div><p id="450a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如热图所示,“STDs: Time since first diagnosis”和“STDs: Time since last diagnosis”功能有许多空值，因此我们需要从数据中删除这些功能。这样，我们的数据中将有34列，而不是36列。</p><pre class="kv kw kx ky fd lx ly lz ma aw mb bi"><span id="bb16" class="ju jv hi ly b fi mc md l me mf">cancer_df = cancer_df.drop(columns = ['STDs: Time since first diagnosis, 'STDs: Time since last diagnosis'])</span><span id="2ff0" class="ju jv hi ly b fi mo md l me mf">cancer_df</span></pre><p id="192d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还需要将我们的数据从对象数据类型转换为数值，因为大多数要素都存储为对象数据类型。</p><pre class="kv kw kx ky fd lx ly lz ma aw mb bi"><span id="720f" class="ju jv hi ly b fi mc md l me mf">cancer_df = cancer_df.apply(pd.to_numeric)<br/>cancer_df.info()</span></pre><p id="29cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们的数据完全由数值组成，我们可以通过运行<em class="jt"> cancer_df.mean()来查看所有特征的平均值。</em></p><p id="39d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以用平均值替换任何其他空值。</p><pre class="kv kw kx ky fd lx ly lz ma aw mb bi"><span id="5751" class="ju jv hi ly b fi mc md l me mf">cancer_df = cancer_df.fillna(cancer_df.mean())<br/>cancer_df</span></pre><h1 id="d56c" class="kz jv hi bd jw la lb lc ka ld le lf ke lg lh li kh lj lk ll kk lm ln lo kn lp bi translated">3.数据可视化</h1><p id="2424" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">在这一步中，我们可以进一步可视化数据，以找到特征之间的相关性。</p><p id="0ce1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一步是获得相关矩阵:</p><pre class="kv kw kx ky fd lx ly lz ma aw mb bi"><span id="4d9b" class="ju jv hi ly b fi mc md l me mf">corr_matrix = cancer_df.corr()<br/>corr_matrix</span></pre><p id="efd7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们这样做了，我们可以绘制它:</p><pre class="kv kw kx ky fd lx ly lz ma aw mb bi"><span id="a2d4" class="ju jv hi ly b fi mc md l me mf">plt.figure(figsize = (30, 30))<br/>sns.heatmap(corr_matrix, annot = True)<br/>plt.show()</span></pre><p id="13e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">(30，30)创建了一个更大的热图，以确保所有数据都是可见的，并且适合热图，而<em class="jt"> annot = True </em>，向我们显示热图中的数值。绘制时，它将如下所示:</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/09ae904d3bd2e52dea63aacd2433588d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8myo7CAcrOu8d3xhRwLgWw.png"/></div></div></figure><p id="e725" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该矩阵显示了数据集中所有要素之间的相关性或影响。最接近1(白色)的值表示接近完美的相关性，最接近0(紫色)的值表示几乎没有相关性，负值(最暗)表示相反的相关性。</p><p id="8055" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，有一条白色的值的对角线，看起来具有完美的相关性，因为相同的要素在x轴和y轴上对齐，并且相同的要素与自身具有完美的相关性。</p><h1 id="79d1" class="kz jv hi bd jw la lb lc ka ld le lf ke lg lh li kh lj lk ll kk lm ln lo kn lp bi translated">4.在模型训练之前准备数据</h1><p id="cd68" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">下一步是在训练模型之前准备我们的数据。</p><p id="ca1b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们在前面描述数据时所看到的，数据中的最后四个特征是“Hinselman”、“Schiller”、“Citology”和“Biopsy”。所有这四个特性都是不同的诊断指标。但是，由于我们只是尝试训练算法来预测目标变量活检，因此我们只需要选择该列作为我们的目标输出。</p><pre class="kv kw kx ky fd lx ly lz ma aw mb bi"><span id="82d4" class="ju jv hi ly b fi mc md l me mf">target_df = cancer_df['Biopsy']<br/>input_df = cancer_df.drop(columns = ['Biopsy'])</span></pre><p id="2b93" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以检查我们的目标形状，它是858，或者(858)，正如我们所预期的，因为我们有来自858个患者的数据。然后，我们想要检查输入形状，我们得到(858，33)，因为我们有858行和33列。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/89dbc7428ea6899e1f5adf5ba6d793c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yeWq1O4fq7vZ57rtxJUUvg.png"/></div></div></figure><p id="fdd8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们需要使用NumPy将输入和输出转换成“float32”格式。然后，我们可以通过运行<em class="jt"> y.shape </em>来重塑输出的数组，以确保它是合适的。</p><pre class="kv kw kx ky fd lx ly lz ma aw mb bi"><span id="5160" class="ju jv hi ly b fi mc md l me mf">x = np.array(input_df).astype('float32')<br/>y = np.array(target_df).astype('float32')</span></pre><p id="6aef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在将数据输入模型之前，准备数据的下一步是缩放数据，为此我们需要导入<strong class="ix hj"> scikit-learn </strong>，这是一个包含各种分类、回归和聚类算法的Python库。</p><p id="305c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用sci-kit learn来规范化我们的输入数据或我们的特征，因此我们希望导入StandardScaler和MinMaxScaler。</p><p id="795c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还想从我们的类“StandardScaler”中实例化一个对象“scaler”然后，我们希望对我们的对象应用“fit_transform”方法，这个对象是“scaler”，并将其传递给X，以生成一个输出，这是X的缩放版本。</p><pre class="kv kw kx ky fd lx ly lz ma aw mb bi"><span id="2f8e" class="ju jv hi ly b fi mc md l me mf"><strong class="ly hj">from</strong> sklearn.processing <strong class="ly hj">import </strong>StandardScaler, MinMaxScaler<br/>scaler = StandardScaler()<br/>X = scaler.fit_transform(X)</span></pre><p id="b797" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">训练模型之前的最后一步是将其分成三个类别，训练数据、验证数据和测试数据。</p><p id="dff9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">训练数据</strong>仅用于训练模型。我们只需将数据输入模型，这样它就可以了解输入和输出之间的关系。</p><p id="6fa5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在对模型进行定型时，我们希望确保模型不会过度拟合定型数据。因此，我们可以使用<strong class="ix hj">验证数据</strong>并将其输入到模型中，因为它以前从未见过验证数据。</p><p id="6337" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们希望训练和验证数据的误差都下降。我们希望模型能够概括，而不是记忆。</p><p id="d5ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，如果我们看到训练数据上的误差下降，而验证数据上的误差上升，这意味着模型对训练数据过度拟合，无法进行归纳。</p><p id="5747" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">测试数据</strong>在模型训练后使用。在我们完成训练和迭代之后，我们将测试数据提供给模型。模型在训练期间将永远不会看到测试数据。</p><pre class="kv kw kx ky fd lx ly lz ma aw mb bi"><span id="fc01" class="ju jv hi ly b fi mc md l me mf"><strong class="ly hj">from</strong> sklearn.model_selection <strong class="ly hj">import</strong> train_test_split</span><span id="eedf" class="ju jv hi ly b fi mo md l me mf">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2)<br/>X_test, X_val, y_test, y_val = train_test_split(X, y, test_size = 0.5)</span></pre><p id="fc39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的训练和测试数据中的0.2意味着我们的数据有20%是用于测试的，80%会用于训练。</p><p id="051e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">测试数据集进一步分为验证和测试类别。正如我们所看到的，50%的数据进入测试集，其余的进入验证集。</p><h1 id="eda2" class="kz jv hi bd jw la lb lc ka ld le lf ke lg lh li kh lj lk ll kk lm ln lo kn lp bi translated">5.训练和评估模型</h1><p id="ac0b" class="pw-post-body-paragraph iv iw hi ix b iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo kt jq jr js hb bi translated">为了训练和评估模型，我们首先需要通过运行以下代码来安装xgboost:</p><pre class="kv kw kx ky fd lx ly lz ma aw mb bi"><span id="0121" class="ju jv hi ly b fi mc md l me mf">!pip install xgboost</span></pre><p id="195e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们要<em class="jt">将xgboost导入为xgb </em>。一旦我们这样做了，我们就可以训练xgboost分类模型。</p><p id="a2fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以将学习率设定为0.1，因为这可能是我们系统的一个很好的起点。我们还可以将分类树的期望深度指定为5，这是从决策树的底部到根的最长路径。在这里，我们还可以指定估计器的数量或我们将要使用的模型的数量。我们可以将估计数设置为10。</p><p id="c534" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">值得注意的是，我们可以显著增加树的深度和估计器的数量。然而，这意味着我们的模型变得更加复杂。可能出现的一个问题是训练数据的过度拟合。该模型可能在训练数据上表现很好，而在测试数据上表现很差。</p><p id="d7d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在建立了我们的学习率和估计数之后，我们可以拟合模型，并传递我们的训练数据，<em class="jt"> X_train，y_train。</em>在运行代码块之后，我们可以看到我们的模型已经被训练好了。</p><pre class="kv kw kx ky fd lx ly lz ma aw mb bi"><span id="0ae6" class="ju jv hi ly b fi mc md l me mf"><strong class="ly hj">import</strong> xgboost <strong class="ly hj">as</strong> xgb<br/>model = xgb.XGBClassifier(learning_rate = 0.1, max_depth = 5, n_estimators = 10)</span></pre><p id="294f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们可以使用测试数据集预测训练模型的得分。。我们还想在我们的测试数据上绘制模型的准确性，这是模型从未见过的。</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/bdba77f07aea0aaf010de9652bc6a3e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-mzwW9kfxXr9YqTRF7LPQ.png"/></div></div></figure><p id="0cec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行代码后，我们可以看到，在我们的训练数据上，我们已经达到了<strong class="ix hj"> 97%的准确率</strong>。我们可以对测试数据重复同样的过程:</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/1c866ca55390b075cb63482caa54dbb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qiwLMxtAnN1hPxGjkJqC2Q.png"/></div></div></figure><p id="5344" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行代码后，我们可以看到我们的模型在测试数据上达到了<strong class="ix hj"> 94%的准确率</strong>。鉴于该模型以前从未见过这些数据，我们可以说该模型表现得相当好。</p><p id="e77c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">达到这个准确率后，我们可以继续绘制一个分类报告和混淆矩阵，它显示了模型哪里做得好，哪里做得差。</p><div class="kv kw kx ky fd ab cb"><figure class="mh ij mt mj mk ml mm paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/628d10ed5540c52d3d678f51a411918f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1574/format:webp/1*OL2a-yq60kEuREPIFMZ4-w.png"/></div></figure><figure class="mh ij mu mj mk ml mm paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/912639460ef9ceea84f06f07d81f0738.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*wLd1L7Mvv5-HHv0qu4zRnQ.png"/></div></figure></div><p id="db39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是你要的。一种宫颈癌风险预测模型，可以接受患者的信息并显示他们患宫颈癌的风险。如果你想更深入地了解这个项目是如何进行的，请查看我用过的<a class="ae iu" href="https://www.coursera.org/projects/cervical-cancer-risk-prediction-using-machine-learning" rel="noopener ugc nofollow" target="_blank">课程</a>，以及<a class="ae iu" href="https://www.youtube.com/watch?v=Tdmx0aTHOIc" rel="noopener ugc nofollow" target="_blank">我关于这个项目的视频</a>！</p></div><div class="ab cl mv mw gp mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="hb hc hd he hf"><blockquote class="lr ls lt"><p id="6dd0" class="iv iw jt ix b iy iz ja jb jc jd je jf lu jh ji jj lv jl jm jn lw jp jq jr js hb bi translated">非常感谢您阅读这篇文章！如果你从这篇文章中学到了什么，请分享！一定要把<a class="ae iu" href="https://linktr.ee/manasigajjalapurna" rel="noopener ugc nofollow" target="_blank">跟我</a>联系起来，留下这篇文章一个掌声👏如果你喜欢的话！</p></blockquote><h2 id="73f6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">来源:</h2><div class="nc nd ez fb ne nf"><a href="https://machinelearningmastery.com/extreme-gradient-boosting-ensemble-in-python/" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hj fi z dy nk ea eb nl ed ef hh bi translated">Python -机器学习掌握中的极端梯度推进(XGBoost)集成</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">extreme Gradient Boosting(XGBoost)是一个开源库，它提供了一个高效的实现…</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">machinelearningmastery.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt io nf"/></div></div></a></div><div class="nc nd ez fb ne nf"><a href="https://xgboost.readthedocs.io/en/latest/tutorials/model.html" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hj fi z dy nk ea eb nl ed ef hh bi translated">增强树简介- xgboost 1.5.0-dev文档</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">XGBoost代表“极端梯度增强”，其中术语“梯度增强”源于论文Greedy…</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">xgboost.readthedocs.io</p></div></div><div class="no l"><div class="nu l nq nr ns no nt io nf"/></div></div></a></div><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="nv nw l"/></div></figure></div></div>    
</body>
</html>