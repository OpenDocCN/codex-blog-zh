<html>
<head>
<title>Create A Simple But Effective JSON File Converter With Jinja2 In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python中的Jinja2创建一个简单而有效的JSON文件转换器</h1>
<blockquote>原文：<a href="https://medium.com/codex/create-a-simple-but-effective-json-file-converter-with-jinja2-in-python-28732d4f210e?source=collection_archive---------2-----------------------#2022-11-13">https://medium.com/codex/create-a-simple-but-effective-json-file-converter-with-jinja2-in-python-28732d4f210e?source=collection_archive---------2-----------------------#2022-11-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fbf213ddbad408479f7e7d40c9ba6e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NP0HUgN6Z7SBW8rpGFmxPA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@shiroscope?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Shiro hatori </a>在<a class="ae iu" href="https://unsplash.com/s/photos/long-exposure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="eebd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">需要将一个JSON文件转换成另一种格式？这可以通过几行Python和Jinja2模板快速实现并重用。我们将用不到30个LOC实现这一点，并使用一个示例模板将GeoJSON转换为KML，并且可以在更多转换中重用。</p><p id="7236" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将文件从一种格式转换成另一种格式是软件开发人员日常生活中经常出现的任务。问八个不同的软件开发者他们最喜欢的方法，你会得到128个答案。有现成的转换工具、脚本、框架、库，但有时一个简单的解决方案就足以完成手头的任务。</p><p id="2d85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/JSON" rel="noopener ugc nofollow" target="_blank"> JSON </a>是半结构化数据的一种流行格式。将JSON转换成其他文件格式的用例很多:JSON转换成XML，JSON转换成另一种JSON方言，等等。然而，没有人想从头开始为每个转换编写新的解析器和转换器。今天的解决方案将可重复用于不同的用例，从长远来看可能会节省时间。</p><p id="4cd7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经把最终的Python脚本放在一个<a class="ae iu" href="https://gist.github.com/mostsignificant/acddc048851d0e751846d24e62afc6d1" rel="noopener ugc nofollow" target="_blank"> GitHub gist </a>中以供参考。</p><h1 id="42cd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">今天的例子:GeoJSON到KML</h1><p id="c12e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了演示快速简单的转换，我们使用开放数据世界中的一个例子。奥地利国家铁路(ÖBB)在其开放数据门户上提供<a class="ae iu" href="https://data.oebb.at/oebb?dataset=uddi:77ce2fcf-1712-11e8-b619-a385d0a26832" rel="noopener ugc nofollow" target="_blank">文件</a>及其车站和路线。其中一个文件<a class="ae iu" href="https://data.oebb.at/oebb?dataset=uddi:77ce2fcf-1712-11e8-b619-a385d0a26832&amp;file=uddi:d3e25791-7889-11e8-8fc8-edb0b0e1f0ef/GIP_OEBB_STRECKEN.json" rel="noopener ugc nofollow" target="_blank"> GIP_OEBB_STRECKEN.json </a>是所谓的<a class="ae iu" href="https://geojson.org/" rel="noopener ugc nofollow" target="_blank"> Geojson </a>格式:一种基于JSON的地理数据结构编码的可访问格式。</p><p id="5038" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下示例显示了GeoJSON文件。该文件包含类型为<code class="du kw kx ky kz b">Feature</code>的对象。其中几个可以捆绑在一个<code class="du kw kx ky kz b">FeatureCollection</code>中。每个<code class="du kw kx ky kz b">Feature</code>都有一个<code class="du kw kx ky kz b">geometry</code>，T3本身就拥有<code class="du kw kx ky kz b">coordinates</code>。这些<code class="du kw kx ky kz b">coordinates</code>是两个或三个数字的数组。这些数字是经度和纬度(或东距和北距)，以及可选的高度(或海拔)。您可以在相应的<a class="ae iu" href="https://www.rfc-editor.org/rfc/rfc7946" rel="noopener ugc nofollow" target="_blank"> RFC 7946 </a>中阅读完整的规范。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="9ace" class="li ju hi kz b be lj lk l ll lm">{<br/>    "type" : "FeatureCollection",<br/>    "name" : "GIP_OEBB_STRECKEN",<br/>    "features" : [<br/>        {<br/>            "type" : "Feature",<br/>            "geometry" : {<br/>                "type" : "MultiLineString",<br/>                "coordinates" : [<br/>                    [<br/>                        [ 13.8282417878, 46.5874404328 ],<br/>                        [ 13.8281239459, 46.5871572442 ],<br/>                        // ...<br/>                    ]<br/>                ]<br/>            },<br/>            "properties" : {<br/>                // ...<br/>            }<br/>        }<br/>}</span></pre><p id="6910" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们希望实现一个脚本，将GeoJSON文件转换成Keyhole标记语言(<a class="ae iu" href="https://developers.google.com/kml" rel="noopener ugc nofollow" target="_blank"> KML </a>)格式的新文件。KML是地理数据和注释的XML符号。KML文件可以被导入到像谷歌地球这样的浏览器中，这是它最初被开发出来的目的。这种格式的名字源于它的历史:谷歌地球以前被称为Keyhole Earth Viewer，由一家名为Keyhole Inc .的公司创建，后来被大型搜索引擎巨头收购。</p><p id="7212" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下示例显示了一个简单的KML文件及其基本概念:</p><ul class=""><li id="0888" class="ln lo hi ix b iy iz jc jd jg lp jk lq jo lr js ls lt lu lv bi translated">标准的XML声明</li><li id="2e76" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated">带有名称空间引用的<code class="du kw kx ky kz b">kml</code>标签</li><li id="2d6d" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated">一个<code class="du kw kx ky kz b">Document</code>标签，用于保存任意数量的</li><li id="cc08" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated"><code class="du kw kx ky kz b">Placemark</code>标签，包含以下信息</li><li id="cef6" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated">带<code class="du kw kx ky kz b">name</code>和<code class="du kw kx ky kz b">description</code>的注释和</li><li id="d2a8" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated">带有<code class="du kw kx ky kz b">Point</code>标签和嵌入式<code class="du kw kx ky kz b">coordinates</code>的地理位置</li></ul><p id="19ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在官方的<a class="ae iu" href="https://developers.google.com/kml" rel="noopener ugc nofollow" target="_blank">谷歌开发者网站</a>上了解更多信息。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="e924" class="li ju hi kz b be lj lk l ll lm">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;kml &gt;<br/>&lt;Document&gt;<br/>&lt;Placemark&gt;<br/>  &lt;name&gt;Vienna&lt;/name&gt;<br/>  &lt;description&gt;Beautiful city in the east of Austria&lt;/description&gt;<br/>  &lt;Point&gt;<br/>    &lt;coordinates&gt;16.363449,48.210033,190.0&lt;/coordinates&gt;<br/>  &lt;/Point&gt;<br/>&lt;/Placemark&gt;<br/>&lt;/Document&gt;<br/>&lt;/kml&gt;</span></pre><p id="17e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于坐标，我们已经可以看到GeoJSON格式的平行。请注意，坐标的顺序是经度，然后是纬度，因为它对应于x轴和y轴，然后是高程，映射到z轴。从GeoJSON转换到KML基本上是一个简单的过程，我们稍后会看到一些例外。这个过程的基本概念如下图所示。该转换器将使我们能够在谷歌地球上显示ÖBB开放数据GeoJSON文件及其站点和路线。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/50ccee93fb79b076dd4b1cbd92e8ed27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FY50mN44wm0295NnfgKheg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">转换器概念</figcaption></figure><h1 id="b922" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">工具集</h1><p id="05fa" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在今天的练习中，我们将结合使用我们库存中的两个强大工具:<a class="ae iu" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae iu" href="https://palletsprojects.com/p/jinja/" rel="noopener ugc nofollow" target="_blank"> Jinja2 </a>模板引擎及其丰富的模板语法。Python脚本将接收源JSON文件，并将其转换为相应模板中定义的任何格式。</p><p id="c217" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过使用模板，我们可以将转换器从实际的转换用例中分离出来:</p><ul class=""><li id="f36b" class="ln lo hi ix b iy iz jc jd jg lp jk lq jo lr js ls lt lu lv bi translated">如果我们需要另一种类型的目标数据格式，我们只需编写另一个模板</li><li id="4ad4" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated">如果我们在目标文件中需要一个额外的特性，我们只需要改变模板</li></ul><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/183204bcd1178cfd52f167e91883825c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3SJo7uUMhViRItSH0sInCA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">带有Jinja2模板的Python转换器</figcaption></figure><p id="caac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Jinja2就是我们需要的模板引擎。它带来了具有条件、循环等等的表达性和强大的语法。官方文档中的以下示例展示了它的一些功能。对于我们的转换器，我们不会使用所有这些功能，读者可以发挥自己的创造力，用额外的功能来扩展转换器。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="02a4" class="li ju hi kz b be lj lk l ll lm">{% extends "layout.html" %}<br/>{% block body %}<br/>  &lt;ul&gt;<br/>  {% for user in users %}<br/>    &lt;li&gt;&lt;a href="{{ user.url }}"&gt;{{ user.username }}&lt;/a&gt;&lt;/li&gt;<br/>  {% endfor %}<br/>  &lt;/ul&gt;<br/>{% endblock %}</span></pre><p id="a95b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于版本3之前的Python安装，有一个没有版本号的原始版本，名为<code class="du kw kx ky kz b">Jinja</code>。然而，我们需要<code class="du kw kx ky kz b">Jinja2</code>,因为我们使用的是Python 3(如果你被之前的东西卡住了，我会很同情你)。你可以通过Python的包管理器<code class="du kw kx ky kz b">pip</code>简单地安装模板引擎:</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="49d9" class="li ju hi kz b be lj lk l ll lm">pip install jinja2</span></pre><h1 id="b526" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">完成这项工作的脚本</h1><p id="06b0" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">每个剧本都需要一个超级有趣和超级有创意的短名字——但是我们两者都缺乏，所以我们正在创建一个名为<code class="du kw kx ky kz b">convo.py</code>的文件。在脚本的顶部，我们添加了一个描述性的一行程序，并导入了重要的包:</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="eda7" class="li ju hi kz b be lj lk l ll lm">import argparse # reading the command line parameters<br/>import json # reading the input file<br/>import os # file path magic<br/><br/>from jinja2 import Environment, FileSystemLoader # template magic</span></pre><p id="597b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们按照流行的Python <a class="ae iu" href="https://realpython.com/python-main-function/#create-a-function-called-main-to-contain-the-code-you-want-to-run" rel="noopener ugc nofollow" target="_blank">模式</a>编写了一个<code class="du kw kx ky kz b">main()</code>函数，尽管整个脚本会很短——但是为了将来的增强，我们会保持它的简洁。在<code class="du kw kx ky kz b">main()</code>函数中，我们将解析三个命令行参数:</p><ul class=""><li id="43fc" class="ln lo hi ix b iy iz jc jd jg lp jk lq jo lr js ls lt lu lv bi translated"><code class="du kw kx ky kz b">input</code>是要摄取和转换的JSON文件</li><li id="9974" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated"><code class="du kw kx ky kz b">template</code>是应用的Jinja2模板</li><li id="fe18" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated"><code class="du kw kx ky kz b">output</code>是最终转换文件的名称</li></ul><p id="bd84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于GeoJSON和最终KML文件的示例，从命令行调用脚本的语法应该如下所示:</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="bd11" class="li ju hi kz b be lj lk l ll lm">python convo.py \<br/>  GIP_OEBB_STRECKEN.json \<br/>  templates/geojson.kml \<br/>  oebb_strecken.kml</span></pre><p id="65cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个调用将导致脚本读取文件<code class="du kw kx ky kz b">GIP_OEBB_STRECKEN.json</code>，使用模板<code class="du kw kx ky kz b">templates/geojson.kml</code>将JSON数据转换为最终文件<code class="du kw kx ky kz b">oebb_strecken.kml</code>。下面的代码行将设置<a class="ae iu" href="https://docs.python.org/3/library/argparse.html" rel="noopener ugc nofollow" target="_blank"> Python参数解析器</a>来接收三个命令行参数。为了简洁起见，省略了对参数的描述，但是强烈建议您使用命令行参数来使任何脚本更有用。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="fff7" class="li ju hi kz b be lj lk l ll lm">parser = argparse.ArgumentParser(<br/>        description='Converts json files to other formats via templates')<br/>parser.add_argument('input')<br/>parser.add_argument('template')<br/>parser.add_argument('output')<br/><br/>args = parser.parse_args()</span></pre><p id="3148" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来的两行获取输入文件，并将JSON数据读入Python dictionary对象。字典的美妙之处在于，这种数据结构以后可以直接传递给模板引擎，而不需要任何额外的转换代码。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="e336" class="li ju hi kz b be lj lk l ll lm">file = open(args.input)<br/>data = json.load(file)</span></pre><p id="0597" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解析JSON文件后，我们加载模板文件。第二个名为<code class="du kw kx ky kz b">template</code>的命令行参数是实际模板文件的路径。我们从它构造一个绝对路径来获得目录名。Jinja2环境需要包含模板文件的目录，我们将通过使用绝对路径来省去一些麻烦。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="2048" class="li ju hi kz b be lj lk l ll lm">template_dir = os.path.dirname(os.path.abspath(args.template))<br/>environment = Environment(loader=FileSystemLoader(template_dir))</span></pre><p id="9e20" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似地，我们从同一个命令行参数中提取模板文件名。我们将使用文件名通过Jinja2环境加载模板。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="fdf1" class="li ju hi kz b be lj lk l ll lm">template_file = os.path.basename(args.template)<br/>template = environment.get_template(template_file)</span></pre><p id="bddb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，调用Jinja2 <code class="du kw kx ky kz b">template</code>来渲染数据。这个render方法接受一个dictionary对象，这就是这个转换代码如此简单的原因。<code class="du kw kx ky kz b">render()</code>方法返回一个字符串类型的对象。该字符串可以写入输出文档。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="2b40" class="li ju hi kz b be lj lk l ll lm">content = template.render(data)<br/>with open(args.output, mode='w', encoding='utf-8') as document:<br/>    document.write(content)</span></pre><h1 id="0552" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">完成工作的模板</h1><p id="e10b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">此外，我们需要写相应的模板。以下部分显示了将GeoJSON文件转换为KML文件的完整模板。我们只在条件和循环中使用基本的Jinja2特性。这些必须用带百分号的大括号括起来。开始标记处的减号告诉模板引擎在呈现输出文件时不要用空行替换这一行。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="f5a8" class="li ju hi kz b be lj lk l ll lm">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;kml &gt;<br/>    &lt;Document&gt;<br/>        {%- if name %}<br/>        &lt;name&gt;{{ name }}&lt;/name&gt;<br/>        {%- endif %}<br/>        &lt;description&gt;Converted KML file from GeoJSON&lt;/description&gt;<br/>        {%- for feature in features %}<br/>        &lt;Placemark&gt;<br/>            {%- if feature.properties.GIP_OBID %}<br/>            &lt;name&gt;{{ feature.properties.GIP_OBID }}&lt;/name&gt;<br/>            {%- endif %}<br/>            {%- if feature.properties.MAINNAME %}<br/>            &lt;description&gt;{{ feature.properties.MAINNAME }}&lt;/description&gt;<br/>            {%- endif %}<br/>            {%- if feature.geometry.type == 'MultiLineString' %}<br/>            &lt;LineString&gt;<br/>                &lt;coordinates&gt;<br/>                {%- for coordinategroup in feature.geometry.coordinates %}<br/>                    {%- for coordinate in coordinategroup %}<br/>                    {{ coordinate.0 }},{{ coordinate.1 }}<br/>                    {%- endfor %}<br/>                {%- endfor %}<br/>                &lt;/coordinates&gt;<br/>            &lt;/LineString&gt;<br/>            {%- endif %}<br/>        &lt;/Placemark&gt;<br/>        {%- endfor %}<br/>    &lt;/Document&gt;<br/>&lt;/kml&gt;</span></pre><p id="a4f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一些变通方法可以使模板适合我们特定的输入GeoJSON格式:</p><ul class=""><li id="06bc" class="ln lo hi ix b iy iz jc jd jg lp jk lq jo lr js ls lt lu lv bi translated">对于<code class="du kw kx ky kz b">&lt;Document&gt;</code>标签内的<code class="du kw kx ky kz b">&lt;name&gt;</code>标签的文本，我们使用整个GeoJSON文件的名称，这在GeoJSON标准中是不需要的。这意味着如果输入文件在JSON结构中没有名称，KML文档也没有名称。</li><li id="3d6b" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated">对于<code class="du kw kx ky kz b">&lt;Placemark&gt;</code>的<code class="du kw kx ky kz b">&lt;name&gt;</code>标签，我们使用了一个未标准化的属性。出现了与前面的解决方法相同的问题。</li><li id="20e3" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated">类似地，对于<code class="du kw kx ky kz b">&lt;Placemark&gt;</code>的<code class="du kw kx ky kz b">&lt;description&gt;</code>标记，我们使用了另一个属性，如果我们有不同的输入GeoJSON文件，会再次导致相同的问题。</li></ul><p id="7a39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了减轻这种情况，我们可以为其他GeoJSON输入文件使用不同的模板，或者使模板更加通用。对于更通用的版本，我们可以使用输入或输出文件的名称作为KML文档的名称。为此，在将输入文件的数据传递给模板引擎渲染器时，我们必须包含额外的字典条目。这个练习留给读者。</p><h1 id="8b72" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">最后的结果</h1><p id="1f31" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">最后，我们可以使用ÖBB开放数据GeoJSON文件和模板调用完成的脚本，将其转换为KML:</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="7735" class="li ju hi kz b be lj lk l ll lm">python convo.py GIP_OEBB_STRECKEN.json templates/geojson.kml oebb_strecken.kml</span></pre><p id="607b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">转换后的KML文件可以通过<em class="mc">文件</em> &gt; <em class="mc">导入… </em>并选择您的KML文件导入到Google Earth Pro中。下面的截图显示了地图上的结果。实际路线在画布上绘制为白线。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/3d374e7a3befda8eae541c3a781e0d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rIzIgKZy5L9uZk81aQpq5Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">谷歌地球Pro截图</figcaption></figure><h1 id="5bf4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">奖励步骤</h1><p id="e0db" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对于奖励积分，可以添加许多功能，使我们的转换脚本更加有用:</p><ul class=""><li id="72fd" class="ln lo hi ix b iy iz jc jd jg lp jk lq jo lr js ls lt lu lv bi translated">更多的输入文件格式:支持CSV、XML或Parquet等格式</li><li id="8178" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated">约定胜于配置:让我们将模板和输出文件名命令行参数设置为可选的，并从输入文件的名称中推断出它们的名称</li><li id="2168" class="ln lo hi ix b iy lw jc lx jg ly jk lz jo ma js ls lt lu lv bi translated">模板的元信息:输入/模板/输出文件名、转换时间戳或Python版本等信息</li></ul><h1 id="9fa9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="52ee" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这个快速练习展示了Python的Jinja2模板结合其板载JSON解析器的有效性。它允许您控制模板中的转换逻辑，并使用新模板添加额外的输出格式。我已经把最终的Python脚本放在一个<a class="ae iu" href="https://gist.github.com/mostsignificant/acddc048851d0e751846d24e62afc6d1" rel="noopener ugc nofollow" target="_blank"> GitHub gist </a>中以供参考。</p><p id="c455" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以在下一个文件转换任务中使用这种方法，但更重要的是:继续编码，继续创作！</p></div></div>    
</body>
</html>