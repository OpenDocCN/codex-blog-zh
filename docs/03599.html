<html>
<head>
<title>Python and Physics: Matrix Math Cheatsheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python和物理学:矩阵数学小抄</h1>
<blockquote>原文：<a href="https://medium.com/codex/python-and-physics-matrix-math-cheat-sheet-1209f4e71e93?source=collection_archive---------10-----------------------#2021-09-10">https://medium.com/codex/python-and-physics-matrix-math-cheat-sheet-1209f4e71e93?source=collection_archive---------10-----------------------#2021-09-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/82d1dc738d1e1bd8a404193a35ea7e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QzX5RsStpdJZ4jjO"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">约书亚·雷德科普在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9843" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随着STEM课程的深入，一个常见的数学主题不断出现，那就是矩阵。在本文中，我们将通过一些例子来说明如何使用Python来解决一些常见的矩阵数学问题。</p><h1 id="f6c0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">直入代码</strong></h1><p id="ad13" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">首先，我们应该导入一些包来帮助我们处理一些更复杂的主题，比如特征值和行列式。虽然它们可以通过冗长的计算来解决，但这些软件包将帮助我们更快地处理事情。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f025" class="lf ju hi lb b fi lg lh l li lj">import numpy as np<br/>from numpy.linalg import det<br/>from numpy.linalg import eig<br/>from numpy.linalg import inv</span></pre><p id="363d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">标量乘法</strong></p><p id="ddf4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们从一些简单的乘法开始，比如从正数变成负数。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ccd5" class="lf ju hi lb b fi lg lh l li lj">a = np.reshape(([2, 3, 4, 5]), (2,2)) #Making a 2x2 matrix<br/>print(a)</span><span id="02c5" class="lf ju hi lb b fi lk lh l li lj">##Output<br/>[[2 3]<br/> [4 5]]</span></pre><p id="9c15" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要相乘，我们只用星号。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="33db" class="lf ju hi lb b fi lg lh l li lj">symbol_change = -1 * a<br/>print(symbol_change)</span><span id="698a" class="lf ju hi lb b fi lk lh l li lj">##Output<br/>[[-2 -3]<br/> [-4 -5]]</span></pre><p id="cd12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">乘以一个常数，我们做同样的事情。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="36e8" class="lf ju hi lb b fi lg lh l li lj">constant_multiplication = 2 * a<br/>print(constant_multiplication)</span><span id="d8ac" class="lf ju hi lb b fi lk lh l li lj">##Output<br/>[[ 4  6]<br/> [ 8 10]]</span></pre><p id="c3cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">矩阵乘法/点积</strong></p><p id="df6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们从矩阵乘法/点积开始。这次我们将尝试不同维数的矩阵。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ae32" class="lf ju hi lb b fi lg lh l li lj">b = np.reshape([1,2,3,4,5,6],(2,3))#Matrix with 2 rows and 3 columns<br/>print(b)<br/>print('----')<br/>c = np.reshape([7,8,9,10,11,12],(3,2))#3 rows and 2 columns matrix<br/>print(c)</span><span id="7f66" class="lf ju hi lb b fi lk lh l li lj">##Output<br/>[[1 2 3]<br/> [4 5 6]]<br/>----<br/>[[ 7  8]<br/> [ 9 10]<br/> [11 12]]</span></pre><p id="c4d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然Numpy确实有一个<em class="ll"> matmul </em>函数，但是Python使用@符号来表示矩阵乘法。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f1b4" class="lf ju hi lb b fi lg lh l li lj">matrix_dot_product = b@c #@ symbol does our matrix multiplication<br/>print(matrix_dot_product)</span><span id="b2c8" class="lf ju hi lb b fi lk lh l li lj">##Output<br/>[[ 58  64]<br/> [139 154]]</span></pre><p id="7bf4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">矩阵求逆</strong></p><p id="9666" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用我们之前导入的包<em class="ll"> inv </em>，我们可以很容易地对矩阵求逆。为了验证它是否有效，我们将把我们的逆矩阵与原始矩阵相乘，看它是否形成单位矩阵。需要注意的是，由于Python处理的精度，单位矩阵的值有时可能是非零的，所以如果您正在进行某些需要精度的计算，请注意一点。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="103c" class="lf ju hi lb b fi lg lh l li lj">print(a)<br/>inverse = inv(a)<br/>print('---')<br/>print(inverse)<br/>print('---')<br/>identity = a@inverse<br/>print(identity)</span><span id="342d" class="lf ju hi lb b fi lk lh l li lj">##Output<br/>[[2 3]        #Original<br/> [4 5]]<br/>---<br/>[[-2.5  1.5]  #Inverse<br/> [ 2.  -1. ]]<br/>---<br/>[[1. 0.]       #Verified that it does output our identity matrix<br/> [0. 1.]] </span></pre><p id="f008" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">决定因素</strong></p><p id="73d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用我们导入的另一个包，det将帮助求解决定因素。对于这个例子，我们将通过一个2x2矩阵和一个3x3矩阵。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="15b0" class="lf ju hi lb b fi lg lh l li lj">b = np.reshape([4,6,3,8],(2,2))<br/>print(b)<br/>determinant = det(b)<br/>det_format = float("%.2f" % det(b))<br/>print('---')<br/>print(determinant,'/',det_format),<br/>c= np.reshape([6,1,1,4,-2,5,2,8,7],(3,3))<br/>print('---')<br/>print(c)<br/>print('---')<br/>det_c = det(c)<br/>print(det_c)</span><span id="58c9" class="lf ju hi lb b fi lk lh l li lj">##Output<br/>[[4 6]<br/> [3 8]]                       #Original 2x2 matrix<br/>---<br/>14.000000000000004 / 14.0     #Determinants, second value formatted<br/>---<br/>[[ 6  1  1]<br/> [ 4 -2  5]<br/> [ 2  8  7]]                  #Original 3x3 matrix<br/>---<br/>-306.0                        #Determinant</span></pre><p id="a971" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如前所述，Python的精度有时会给我们带来意想不到的值，比如这个行列式。代码行<em class="ll"> det_format </em>，我只是使用Python的字符串格式来保持小数点后两位，同时使用<em class="ll"> float </em>来确保它不是字符串值。</p><p id="ad68" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">求解Ax = B </strong></p><p id="c6d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们一直在使用的函数的一个更实际的用途是求解一个方程组。通过将它们转换成<strong class="ix hj"> Ax=B </strong>的形式，我们可以通过将两边乘以<em class="ll"> A </em>的倒数来求解<em class="ll"> x </em>。由于<em class="ll"> A </em>的逆矩阵就是单位矩阵，为了求解<em class="ll"> x </em>，我们只需将<em class="ll"> A </em>的逆矩阵乘以<em class="ll"> B </em>。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="708e" class="lf ju hi lb b fi lg lh l li lj">a = np.reshape([1,1,1,0,2,5,2,5,-1],(3,3))<br/>print(a)<br/>print('---')<br/>b = np.reshape([6,-4,27],(3,1))<br/>print(b)<br/>print('---')<br/>solving_x = inv(a) @ b<br/>print(solving_x)</span><span id="ce93" class="lf ju hi lb b fi lk lh l li lj">##Output<br/>[[ 1  1  1]<br/> [ 0  2  5]<br/> [ 2  5 -1]]    #Our A<br/>---<br/>[[ 6]<br/> [-4]<br/> [27]]          #Our B<br/>---<br/>[[ 5.]<br/> [ 3.]<br/> [-2.]]         #Our X</span></pre><p id="be2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了验证，我们将<em class="ll"> A </em>乘以<em class="ll"> x </em>，看看我们是否得到了<em class="ll"> B </em>。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b148" class="lf ju hi lb b fi lg lh l li lj">print(a@solving_x)</span><span id="67b9" class="lf ju hi lb b fi lk lh l li lj">##Output<br/>[[ 6.]<br/> [-4.]<br/> [27.]]   #Works!</span></pre><p id="5f3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">转置和共轭</strong></p><p id="13b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于转置，我们利用Numpy的内置命令<em class="ll"> T </em>。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="1f70" class="lf ju hi lb b fi lg lh l li lj">print(a)<br/>print('---')<br/>transpose = a.T #All we need to get the transpose of a Numpy array<br/>print(transpose)</span><span id="856c" class="lf ju hi lb b fi lk lh l li lj">##Output<br/>[[2 3]<br/> [4 5]]<br/>---<br/>[[2 4]<br/> [3 5]]    #Switched out values over the diagonal</span></pre><p id="8272" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于共轭，我们使用Numpy的共轭命令，我们可以完全键入<em class="ll">共轭</em>或者只使用<em class="ll"> conj </em>。为了表示我们的虚数，我们用<em class="ll"> j </em>代替最常见的<em class="ll"> i </em>。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f0b9" class="lf ju hi lb b fi lg lh l li lj">#j for our imaginary number, 1j is equal to i.<br/>a = np.reshape([1+1j,-2+1j,3+-1j,4+-1j],(2,2)) <br/>print(a)<br/>print('---')<br/>conjugate = np.conj(a)<br/>print(conjugate)</span><span id="5737" class="lf ju hi lb b fi lk lh l li lj">##Output<br/>[[ 1.+1.j -2.+1.j]<br/> [ 3.-1.j  4.-1.j]]<br/>---<br/>[[ 1.-1.j -2.-1.j]<br/> [ 3.+1.j  4.+1.j]]   #Changed the sign of our imaginary numbers </span></pre><p id="6561" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">特征值和特征向量</strong></p><p id="fff1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，我们将使用我们导入的最后一个包，<em class="ll"> eig </em>。特征值给出的很简单，但是对于特征向量，我们将不得不做一些改动。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2239" class="lf ju hi lb b fi lg lh l li lj">a = np.reshape([-6,3,4,5],(2,2)) #2x2 matrix<br/>print(a)<br/>print('---')<br/>values, vectors = eig(a) #Values and vectors given by eig function<br/>print(values)<br/>print('---')<br/>print(vectors)</span><span id="35ed" class="lf ju hi lb b fi lk lh l li lj">##Output<br/>[[-6  3]                      #Original Matrix<br/> [ 4  5]]<br/>---<br/>[-7.  6.]                     #2 eigenvalues<br/>---<br/>[[-0.9486833  -0.24253563]    #2 Vectors, each vector is a column<br/> [ 0.31622777 -0.9701425 ]]</span></pre><p id="3d44" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们使用<em class="ll"> vectors[0] </em>来获得我们的第一个向量，我们将获得第一行，这将不是第一个向量。为了得到第一个向量，这就是我做的。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="89c1" class="lf ju hi lb b fi lg lh l li lj">#Assigning the first values of the rows as the vector<br/>vector_one = np.reshape([vectors[0][0],vectors[1][0]],(2,1))<br/>print(vector_one)</span><span id="5d49" class="lf ju hi lb b fi lk lh l li lj">##Output<br/>array([[-0.9486833 ],<br/>       [ 0.31622777]])</span></pre><p id="2302" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">检查它们是否是特征值和特征向量，我们首先将原始矩阵乘以向量，看看它是否与特征值乘以向量得到的向量匹配。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f999" class="lf ju hi lb b fi lg lh l li lj">print(a@vector_one) #Matrix multiplied by vector<br/>print(values[0]*vector_one) #First eigenvalue by the vector</span><span id="f843" class="lf ju hi lb b fi lk lh l li lj">##Output<br/>[[ 6.64078309]<br/> [-2.21359436]]<br/>[[ 6.64078309]<br/> [-2.21359436]]             #They match!</span></pre><p id="a28d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在你知道了！一个很好的Python示例集，可以帮助那些需要创建处理矩阵的程序的人。还有很多其他的概念需要研究，比如trace和正交性等等，但是对于大多数需求来说，这应该是朝着正确方向迈出的一步！希望你喜欢这个！</p></div></div>    
</body>
</html>