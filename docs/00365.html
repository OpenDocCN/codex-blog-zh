<html>
<head>
<title>Exploring Windows Memory Management —Swapping &amp; Virtual Memory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Windows内存管理—交换和虚拟内存</h1>
<blockquote>原文：<a href="https://medium.com/codex/exploring-windows-memory-management-virtual-memory-712fee0def31?source=collection_archive---------2-----------------------#2021-01-23">https://medium.com/codex/exploring-windows-memory-management-virtual-memory-712fee0def31?source=collection_archive---------2-----------------------#2021-01-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/7d5e949a9517da1e58aadf9077dfe4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p2fGRDGp9e0iWN67"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">亚历山大·安德鲁斯在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="6ce1" class="hw hx hy bd b fp hz ia ib ic id ie dx if translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">抄本</a></h2><div class=""/><p id="e05d" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我曾经很好奇我的窗户里发生了什么。我想和你分享我在这个话题上的探索。有两种内存管理方法:交换和虚拟内存。它们之间的区别在于进程加载到主存的方式。</p><h1 id="c1c7" class="kc kd hy bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">交换</h1><p id="8d99" class="pw-post-body-paragraph je jf hy jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">下图说明了交换系统的操作。最初，只有进程A在内存中。然后，进程B和C被创建或从磁盘换入。在(d)中，A被换出到磁盘。然后D进来，B出去。终于，A又进来了。因为A现在位于不同的位置，所以其中包含的地址必须重新定位，或者在换入时由软件重新定位，或者(更有可能)在程序执行期间由硬件重新定位。</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es lf"><img src="../Images/fc071caaaf0287e6f56a8a6b1b581752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*gcPKzE30vb1YFYvtMuS8wA.jpeg"/></div></figure><p id="0568" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">当交换在内存中产生多个洞时，可以通过尽可能向下移动所有进程，将它们合并成一个大洞。这种技术被称为内存压缩。通常不这样做，因为它需要大量的CPU时间。例如，在能够以2gb/秒(0.5纳秒/字节)的速度复制的1gb机器上，压缩所有内存大约需要0.5秒。这看起来时间不多，但对于观看视频流的用户来说，这显然会造成干扰。</p><p id="f6fc" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">值得关注的一点是，当一个进程被创建或换入时，应该为它分配多少内存。如果创建的进程大小固定不变，那么分配就很简单:操作系统准确分配所需的大小，不多也不少。</p><p id="239f" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">但是，如果进程的数据段可以增长，例如，通过从堆中动态分配内存，就像在许多编程语言中一样，那么每当进程试图增长时就会出现问题。如果某个孔与该进程相邻，则可以分配该孔，并允许该进程生长到该孔中。另一方面，如果该进程与另一个进程相邻，则要么必须将正在增长的进程移到内存中一个足够大的空间中，要么必须换出一个或多个进程来创建一个足够大的空间。如果一个进程不能在内存中增长，并且磁盘上的交换区已满，该进程将不得不等待或被终止。</p><p id="dbc7" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果预计大多数进程将随着运行而增长，那么每当换入或移动一个进程时，分配一点额外的内存可能是一个好主意，这样可以减少与移动或交换不再适合其分配的内存的进程相关的开销。然而，当将进程交换到磁盘时，应该只交换实际使用的内存；交换额外的内存也是一种浪费。在下图中，我们看到一个内存配置，其中增长空间已分配给两个进程。</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es lk"><img src="../Images/ef094261fd286b60733b16c198a797b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*QnOhzkY2mIXFKM-SoXh_8w.jpeg"/></div></figure><p id="5188" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果进程可以有两个不断增长的段，例如，数据段用作动态分配和释放的变量的堆，而堆栈段用于正常的局部变量和返回地址，则另一种安排是显而易见的，即图(b)中的安排。在这个图中，我们看到每个进程在其分配的内存顶部有一个向下增长的堆栈，而在程序文本之外有一个向上增长的数据段。它们之间的内存可用于任一段。如果它用完了，要么将该进程移到一个有足够空间的洞，换出内存直到可以创建一个足够大的洞，要么终止该进程。</p><h1 id="3cf9" class="kc kd hy bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">虚拟内存</h1><p id="7a9c" class="pw-post-body-paragraph je jf hy jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">虚拟内存背后的基本思想是，程序、数据和堆栈的总大小可能会超过可供它使用的物理内存量。操作系统将当前正在使用的程序部分保存在主存中，其余部分保存在磁盘上。例如，一个512 MB的程序可以在一台256 MB的机器上运行，方法是仔细选择每一时刻在内存中保留哪256 MB，并根据需要在磁盘和内存之间交换程序片段。</p><p id="14e2" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">虚拟内存也可以在多道程序系统中工作，一次在内存中存储许多程序的片断。当一个程序在等待它自己的一部分被引入时，它在等待I/O而不能运行，所以CPU可以给另一个进程，就像在任何其他多道程序系统中一样。</p><h2 id="8157" class="ll kd hy bd ke lm ln lo ki lp lq lr km jp ls lt kq jt lu lv ku jx lw lx ky ie bi translated">分页</h2><p id="7941" class="pw-post-body-paragraph je jf hy jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">大多数虚拟内存系统使用一种叫做分页的技术，我们现在将描述这种技术。在任何计算机上，都存在一组程序可以产生的内存地址。当一个程序使用像</p><blockquote class="ly lz ma"><p id="73ba" class="je jf mb jg b jh ji jj jk jl jm jn jo mc jq jr js md ju jv jw me jy jz ka kb hb bi translated"><em class="hy"> MOV注册，1000 </em></p></blockquote><p id="b09c" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">它这样做是为了将内存地址1000的内容复制到REG(反之亦然，具体取决于计算机)。可以使用索引、基址寄存器、段寄存器和其他方式生成地址。</p><p id="df58" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这些程序生成的地址被称为虚拟地址，形成虚拟地址空间。在没有虚拟内存的计算机上，虚拟地址被直接放到内存总线上，并导致具有相同地址的物理内存字被读取或写入。当使用虚拟内存时，虚拟地址不会直接到达内存总线。相反，它们会进入一个MMU(内存管理单元),将虚拟地址映射到物理内存地址上。</p><p id="4530" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">下图显示了一个非常简单的映射工作原理的例子。在这个例子中，我们有一台计算机可以生成16位地址，从0到64K。这些是虚拟地址。然而，这台计算机只有32 KB的物理内存，所以尽管可以编写64kb的程序，但它们不能全部装入内存并运行。但是，一个程序的内存映像的完整副本(最大64 KB)必须存在于磁盘上，以便可以根据需要引入片段。</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es mf"><img src="../Images/e5da6af196cde6e19a664bbedd7f556b.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/0*Y-EAYtQS1Iu33dAM.JPG"/></div></figure><p id="c805" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">虚拟地址空间被分成称为页面的单元。物理内存中相应的单元称为页帧。页面和页面框架的大小总是相同的。在本例中，它们是4 KB，但是实际系统中使用了从512字节到1 MB的页面大小。使用64 KB的虚拟地址空间和32 KB的物理内存，我们得到了16个虚拟页面和8页的框架。RAM和磁盘之间的传输总是以页为单位。当程序试图访问地址0时，例如，使用指令</p><blockquote class="ly lz ma"><p id="56d8" class="je jf mb jg b jh ji jj jk jl jm jn jo mc jq jr js md ju jv jw me jy jz ka kb hb bi translated">MOV区，0</p></blockquote><p id="6b7a" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">虚拟地址0被发送到MMU。MMU发现该虚拟地址位于页面0 (0至4095)，根据其映射，该页面是页面帧2 (8192至12287)。因此，它将地址转换为8192，并将地址8192输出到总线上。存储器对MMU一无所知，只看到一个读或写地址8192的请求，它接受这个请求。因此，MMU已经有效地将0到4095之间的所有虚拟地址映射到物理地址8192到12287上。类似地，一个指令</p><blockquote class="ly lz ma"><p id="4cc1" class="je jf mb jg b jh ji jj jk jl jm jn jo mc jq jr js md ju jv jw me jy jz ka kb hb bi translated">MOV区，8192</p></blockquote><p id="cc71" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">被有效地转化为</p><blockquote class="ly lz ma"><p id="2b21" class="je jf mb jg b jh ji jj jk jl jm jn jo mc jq jr js md ju jv jw me jy jz ka kb hb bi translated">MOV区，24576</p></blockquote><p id="af4f" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">因为虚拟地址8192在虚拟页面2上，并且该页面被映射到物理页面帧6上(物理地址24576到28671)。作为第三个例子，虚拟地址20500距离虚拟页面5(虚拟地址20480到24575)的开始有20个字节，并且映射到物理地址12288 + 20 = 12308。</p><p id="9eb4" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这种通过适当设置MMU的映射将16个虚拟页面映射到任何8页帧的能力本身并不能解决虚拟地址空间大于物理内存的问题。因为我们只有八个物理页框，所以只有八个虚拟页被映射到物理内存上。其他的，在图中显示为十字，没有被映射。在实际的硬件中，存在/不存在位跟踪哪些页面实际存在于内存中。</p><p id="41fb" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果程序试图使用一个未映射的页面，例如，通过使用指令，会发生什么</p><blockquote class="ly lz ma"><p id="9fde" class="je jf mb jg b jh ji jj jk jl jm jn jo mc jq jr js md ju jv jw me jy jz ka kb hb bi translated">MOV区，32780</p></blockquote><p id="0e0f" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">哪一个是虚拟页面8(从32768开始)中的字节12？MMU注意到该页面未被映射(在图中用叉号表示),并使CPU捕获操作系统。这个陷阱被称为页面错误。操作系统挑选一个很少使用的页框，并将其内容写回磁盘。然后，它将刚刚引用的页面提取到刚刚释放的页面框架中，更改映射，并重新启动被捕获的指令。</p><p id="5087" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">例如，如果操作系统决定驱逐页帧1，它将在物理地址4K加载虚拟页8，并对MMU映射做出两个改变。首先，它会将虚拟页面1的条目标记为未映射，以捕获将来对4K和8K之间的虚拟地址的任何访问。那么它将用1替换虚拟页面8的条目中的叉号，以便当被捕获的指令被重新执行时，它将把虚拟地址32780映射到物理地址4108上。</p><p id="a11b" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">现在让我们看看MMU的内部，看看它是如何工作的，以及为什么我们选择使用2的幂的页面大小。在下图中，我们看到了一个虚拟地址8196(二进制为0010000000000100)的示例，它是使用上一个示例的MMU映射进行映射的。传入的16位虚拟地址被分成4位页号和12位偏移量。用4位作为页码，我们可以有16页，用12位作为偏移量，我们可以寻址一页内的所有4096个字节。</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es mg"><img src="../Images/7562700016a8eb533f83adff3ffad608.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/0*Zt2o2ofyVWrkYAET.JPG"/></div></figure><p id="1106" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">页号被用作页表的索引，产生对应于该虚拟页的页框号。如果存在/不存在位为0，则导致操作系统陷入陷阱。如果该位为1，则页表中的页帧号与12位偏移一起复制到输出寄存器的高3位，该偏移是从传入虚拟地址不加修改地复制而来的。它们一起构成了一个15位的物理地址。然后，输出寄存器作为物理存储器地址放在存储器总线上。</p><h2 id="f5cf" class="ll kd hy bd ke lm ln lo ki lp lq lr km jp ls lt kq jt lu lv ku jx lw lx ky ie bi translated">分割</h2><p id="f6f8" class="pw-post-body-paragraph je jf hy jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">这是另一种基于虚拟内存概念的内存管理方案。这样，虚拟地址空间就是段的集合。每段都有名称和长度。因此，地址指定了段名和该段内的偏移量。因此，用户用两个量来指定每个地址:段名和偏移量。将这种方案与分页方案进行比较，在分页方案中，用户只指定一个地址，这个地址被硬件分成一个页号和一个偏移量，所有这些对程序员都是不可见的。</p><p id="9709" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">为了简化实现，对段进行编号，并通过段号而不是段名来引用。这就是分段方法中逻辑地址由两个元组组成的原因:</p><blockquote class="ly lz ma"><p id="a3ef" class="je jf mb jg b jh ji jj jk jl jm jn jo mc jq jr js md ju jv jw me jy jz ka kb hb bi translated"><segment-number offset=""/></p></blockquote><p id="2beb" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">虽然用户可以通过二维地址引用程序中的对象，但是实际的物理地址当然仍然是一维的字节序列。因此，段表被定义为从二维用户定义地址到一维物理地址的映射。段表中的每个条目都有一个段基和一个段限。段基址包含段在内存中驻留的起始物理地址，而段限制指定了段的长度。</p><h2 id="1d27" class="ll kd hy bd ke lm ln lo ki lp lq lr km jp ls lt kq jt lu lv ku jx lw lx ky ie bi translated"><strong class="ak">英特尔架构的战略</strong></h2><p id="49e6" class="pw-post-body-paragraph je jf hy jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">分页和分段各有利弊。事实上，有些架构两者都提供，英特尔就是其中之一。它支持纯分段和带有分页的分段。</p><p id="5129" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在Pentium系统中，CPU产生一个逻辑地址给分段单元。分段单元为每个逻辑地址产生一个线性地址。然后线性地址被提供给分页单元，分页单元又在主存储器中产生物理地址。因此，分段单元和分页单元相当于内存管理单元，如下所示:</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es mh"><img src="../Images/1ed3d4d938e8526734b694e54b2bad2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/0*GlyxScns0SkFKsjn.JPG"/></div></figure><p id="15d2" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">奔腾架构允许一个段为4GB，每个进程的最大段数为16KB。逻辑地址空间被分成两个分区。第一个由该进程专用的多达8KB的数据段组成。第二个由所有进程共享的高达8KB的数据段组成。关于分页，页面大小可以是4 KB或4 MB。</p><p id="d4fd" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><em class="mb">最初发表于</em><a class="ae hv" href="https://emerging-it-technologies.blogspot.com/2021/01/exploring-windows-memory-management.html" rel="noopener ugc nofollow" target="_blank"><em class="mb">【https://emerging-it-technologies.blogspot.com】</em></a><em class="mb">。</em></p></div></div>    
</body>
</html>