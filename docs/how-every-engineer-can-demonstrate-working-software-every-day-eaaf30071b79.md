# 每个工程师如何每天演示工作软件

> 原文：<https://medium.com/codex/how-every-engineer-can-demonstrate-working-software-every-day-eaaf30071b79?source=collection_archive---------9----------------------->

## 我脑海中有一个疯狂的想法，每个开发人员都可以将所有的软件开发工作分解成他们可以炫耀的日常迭代。

![](img/c52e88d50742b266517d08cc783b0a42.png)

照片由 Kampus 制作:[https://www . pexels . com/photo/a-woman-pointing-on-computer-monitor-8636611/](https://www.pexels.com/photo/a-woman-pointing-on-the-computer-monitor-8636611/)

**炫耀？对谁？**用户、客户、利益相关者、队友。

# 每日演示

你如何每天演示一些东西？有什么值得炫耀的？它需要是用户能够理解的东西。用户可以看到的操作或结果。我已经把它作为整个架构中的一个薄片进行了讨论。哇，好大一口。

一张**薄片**？它需要对用户可用，以炫耀你的工作。用户通过 UI(用户界面)来查看。该软件将有一个按钮，一个菜单项，一个表单，一个链接，一个表格——在用户界面上可用。thin slice 的部分工作将涉及 UI。

您将需要从某处的存储中取出它来显示结果。从文件，从 blob，从数据库。你炫耀的东西需要来自某个地方。部分薄片工作将涉及一些数据或持久性。

你还需要一些东西把你的用户界面和你的数据放在一起。您可以将处理数据的代码放在 UI 中。您可以将它分解成几层，包括一个控制器、一些用例逻辑或业务逻辑。您可以使用数据的公共域表示来进一步抽象。然后，您可能需要将持久化数据转换成域数据，并将域数据转换成它的 UI 形式。

你可以用很多方式分解你的代码。关键是你的薄片需要关注所有这些区域。

听起来我们要深入这里了。UI、控制器、业务逻辑、转换逻辑、持久性逻辑。这是很多逻辑。

要想走得这么深，我们可能必须先走得相对窄一些。哦，对了，这是一个**薄片**。

我们可能不得不缩小范围，以至于几乎没有特定的层。例如，控制器可以将它从 UI 获得的内容传递给下一个逻辑层。

我们可能不得不缩小范围，以至于一个层看起来甚至像一个退化层。单看它，你可能会问它为什么会存在，它今天带来了什么价值。例如，控制器可能—哦，不！— **硬编码**初始值，甚至不用从 UI 中获取。相当堕落！

你可以*进一步* **用一个区域触发另一个区域响应的事件来解耦**你的代码。所有这些都取决于你如何看待这个系统的发展。系统的规模，团队，以及你打算一次做多少。

# **你的第一个用户故事**

让我们把一个“事物”想象成你在一个领域中工作的一个实体。例如，它可以是日程安排应用程序中的约会。它可以是目录应用程序中的产品。它可以是邮件应用程序中的地址。

它是怎么到那里的？在你展示你的“东西”之前，它必须到达那里。这取决于你如何排列这些薄片的顺序。我认为这是双向的。

在一种方法中，你可以创建一个薄片，把“东西”放在适当的位置，然后再创建一个薄片来读取和显示你的东西。

另一种方法是手动将你的东西放回原处。作为开发人员，这种方法让您“播种”您需要的东西。然后，您将在您的切片上工作以显示结果。最后，你可以通过把“东西”放在适当的位置来跟进。

当我们处理事物时，我们通常会做三件事情中的一件。

1.  我们创造新事物并把它们放在某个地方。
2.  我们找回并审视我们所拥有的东西。
3.  我们操纵和改变我们所拥有的东西。

我们还可以做其他的活动。有时候我们想收拾自己的东西。那可能是操纵我们东西的特例。有时我们也想级联一些动作。创造或操纵我们的事物可能会引发其他事物被操纵、检索或创造。

在我们学习编程的早期，我们学习输入-处理-输出作为工作的主体。更复杂的程序来自于将更简单的程序链接在一起。例如，一个程序的输出成为下一个程序的输入。

# 默认为效率优化

当我与团队分享我对薄片的想法时，我遇到了很多阻力。

*   这种方法在我们的环境中行不通。
*   此样式不适用于此域。
*   对这个习题集是不行的。
*   用这种技术是不行的。
*   它不能跨 API 层工作。
*   它不能在 3D 中工作。
*   它不能用于后端流程。
*   它不能。

我们通常会去白板前讨论用户故事。我们绘制出粗略的架构，并继续完善故事。在每一层，我们都会问是否有更直接的方法，通常都有。它通常是硬代码，或者其他一些退化的实现。

在这一点上，讨论转向了价值和效率。交付硬编码的解决方案有什么意义？为什么我会写一些堕落的东西，知道我以后必须回到它？

让我们单独解决这些问题。交付硬编码的解决方案可以让您快速推出端到端的解决方案。它能让你向他人展示你的应用。它能让你迅速得到反馈。最后，它允许您在需要时改变路线，最大限度地减少返工。

写一些小而简单的东西可以减少出错的机会。当绑定到 TDD 和验收测试时，您总是对您所拥有的工作充满信心。从功能的角度来看，它可能不完整，但应该是稳定的。应该能行。

# 优化工作软件

随着下一个功能的发展，硬编码将会消失。这些变化也很小。他们将接受考验。他们会很稳定。下一组改变会起作用。

当您重复这个过程时，您将拥有足够的代码来保持当前的规范——单元和验收测试——通过。应用程序将**总是**工作。

当使用特性标志并频繁集成和部署时，您的软件将**始终**处于交付状态。因此，应用程序将**始终**工作。

当你发现一个 bug 时，你的代码将会很简单，被分解，并由测试支持。您可以快速挤压 bug，然后继续添加切片。代码将**总是**工作。

# 再次考虑单元测试

通过深入细致地工作，您可以重新思考如何定义单元测试。当我们学习 TDD 时，我们倾向于将单元测试与类或对象联系起来。我们模仿依赖性。这种风格导致测试与实现相结合。每当我们想要重构的时候，我们最终都会改变我们的测试。

如果一个单元是一个功能单元呢？如果一个单元是一个特征的一部分，或者是一个完整的特征呢？如果测试指定了我们在代码中追求的行为，而不是嘲笑我们的依赖，会怎么样？突然间，我们可以在不改变测试的情况下重构代码的重要部分。我们突然有了快速行动的信心！

这与在层中工作形成对比。无论您是从 UI 开始并致力于持久性，还是从持久性开始并致力于 UI，或者定义您的契约并在最后并行集成，故事的结局总是一样的。

当您开发层时，您通常希望构建完整的 API，不管是否需要。因此，编写您永远不会使用的代码是可能的。

当你整合时，你会发现事情并不完全一致。一个层的 API 与另一个层不匹配是一回事。更棘手的是当一层中的假设与另一层不匹配时。例如，UI 假设 X，用例假设 Y，持久层假设 z。

# 有效结果

解决不匹配的假设将导致调试、修改层，以及一段时间的稳定和修复。此外，通过在完整的层上工作，看起来你已经为自己做好了改变你写的许多代码的准备。

你将一直重写你的部分代码。你更愿意通过调试器来完成吗？或者你会用小步骤来做，用测试的安全网来逐步重构，以支持添加下一点必要的功能吗？

难道你不希望**总是**有稳定的代码吗？

*👏🏻给我鼓掌* ***跟着*** *如果你喜欢这篇文章。*

# 📋关于米洛

我是一名科技高管、作家、演说家、企业家和发明家。我从 1995 年开始开发软件，十多年来一直在开发团队。🚀

我写关于软件、工程、管理和领导力的文章。

*你也可以* [*在 Twitter 上关注我*](https://twitter.com/milotodorovich) *。🐦*