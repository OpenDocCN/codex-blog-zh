<html>
<head>
<title>DevOps in AWS: Utilize infrastructure as code to deploy a Golang application to ECS with Terraform and CodeBuild</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS中的DevOps:利用基础设施作为代码，通过Terraform和CodeBuild将Golang应用程序部署到ECS</h1>
<blockquote>原文：<a href="https://medium.com/codex/devops-in-aws-utilize-infrastructure-as-code-to-deploy-a-golang-application-to-ecs-with-terraform-85a312bc1a50?source=collection_archive---------12-----------------------#2021-08-08">https://medium.com/codex/devops-in-aws-utilize-infrastructure-as-code-to-deploy-a-golang-application-to-ecs-with-terraform-85a312bc1a50?source=collection_archive---------12-----------------------#2021-08-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7fa0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">特色AWS服务:VPC、代码构建、ECR、ECS、IAM、CloudWatch</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/65c3585c9d0e2112c33d9b33294751fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RnjBWIlPy96j0vjJkH_j_g.png"/></div></div></figure><h1 id="a5e8" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">概观</h1><p id="d6f1" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">现代软件工程是复杂的。云服务提供易于使用的仪表板和界面来减轻一些痛苦。这种易用性的一个缺点是无法快速复制您创建的资源。例如，如果您想要创建一个完整的环境用于试运行和生产，您实际上需要在浏览器中点击两次相同的屏幕，并对某些参数进行小的更改。</p><p id="4669" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">有了Terraform，我们可以根据需要，用几个命令创建整个应用堆栈。在本文中，我将展示在AWS中使用CI/CD管道部署ECS应用程序是多么容易。在本文的最后，您将拥有一个可以通过web访问的Golang应用程序，以及作为基础设施的42个AWS资源。</p><h1 id="1989" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">我们将建造什么</h1><p id="2740" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">首先，这篇文章的源代码可以在<a class="ae lc" href="https://github.com/brianfromlife/new-proto" rel="noopener ugc nofollow" target="_blank">这里</a>找到。这个库有一个简单的Golang REST API，支持Docker和所有部署我们的基础设施的文件。上图显示了将从该存储库中创建的托管资源。</p><p id="cc27" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">一个应用程序负载平衡器将在端口80上监听HTTP请求，然后将该请求转发到一个目标组，该组包含我们每个服务任务的IP地址。当我们向服务部署新任务时，它们会自动向目标组注册，以开始接受请求。</p><p id="6d10" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们还将创建一个简单的CodeBuild项目，该项目将监听对我们的存储库的主要分支的推送。我们构建步骤的细节可以在<strong class="kd hj"><em class="ld">pipeline/deploy . yml</em></strong>文件中找到。当我们对我们的主分支进行变更时，这个构建项目将会触发:</p><ul class=""><li id="f2a3" class="le lf hi kd b ke kx kh ky kk lg ko lh ks li kw lj lk ll lm bi translated">安装Golang模块依赖项。</li><li id="bbd0" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated">登录AWS ECR，我们稍后可以推送新图像</li><li id="24e4" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated">运行所有的单元测试，如果它们失败了，构建项目会提前退出，这样就不会部署不完整的代码</li><li id="0568" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated">根据构建/生产中的docker文件构建docker映像</li><li id="3421" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated">标记并把我们图像的最新版本推送到AWS ECR</li><li id="2098" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated">更新ECS服务以获取最新的ECR映像</li></ul><h1 id="17ee" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">先决条件</h1><p id="885c" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在部署基础设施和应用程序之前，需要注意一些事情，以便一切正常运行。</p><h2 id="2883" class="ls jk hi bd jl lt lu lv jp lw lx ly jt kk lz ma jv ko mb mc jx ks md me jz mf bi translated">克隆存储库</h2><p id="eb61" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">首先将存储库克隆到您的Github帐户，这样当您推送更改时，您的AWS资源可以做出相应的响应。一旦完成，在<strong class="kd hj"><em class="ld">infra structure/terraform . TF vars</em></strong>文件中，相应地更新<strong class="kd hj"> <em class="ld"> github_owner </em> </strong>和<strong class="kd hj"> <em class="ld"> github_repo </em> </strong>变量。比如min分别是<strong class="kd hj"><em class="ld">brianfromlife</em></strong>和<strong class="kd hj"> <em class="ld"> new-proto </em> </strong>。</p><h2 id="50a2" class="ls jk hi bd jl lt lu lv jp lw lx ly jt kk lz ma jv ko mb mc jx ks md me jz mf bi translated">Github访问令牌</h2><p id="b8d7" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">当我们将更改推送到我们的主GitHub分支时，它将自动触发CodeBuild项目来安装我们的依赖项，运行测试，并部署新代码。为了正常工作，您首先需要生成一个具有正确权限的个人访问令牌。在Github中导航到设置，然后开发者设置并生成一个具有<strong class="kd hj"> <em class="ld"> repo </em> </strong>和<strong class="kd hj"> <em class="ld"> admin:repo </em> </strong>权限的新令牌。</p><p id="0f0e" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在<strong class="kd hj"><em class="ld">infra structure/terra form . TF vars</em></strong>文件中，用刚刚生成的变量更新<strong class="kd hj"> <em class="ld"> github_token </em> </strong>变量。</p><h2 id="c697" class="ls jk hi bd jl lt lu lv jp lw lx ly jt kk lz ma jv ko mb mc jx ks md me jz mf bi translated">AWS CLI和凭据</h2><p id="2085" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">首先，确保您安装了AWS CLI。terraform项目依赖于在您的机器上本地配置的AWS CLI配置文件。如果您不熟悉，请在您的终端中运行以下命令:</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="cba8" class="ls jk hi mh b fi ml mm l mn mo">aws configure --profile XXXXXX</span></pre><p id="abcb" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">例如，如果我想创建一个名为testing的概要文件，它将如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/e2948c77240c2251463a18e003dd88ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLMvR1HVcit9SAIZJWEUEQ.png"/></div></div></figure><p id="4407" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在AWS控制台中，创建一个具有管理访问权限的新IAM用户，并在配置新配置文件时输入访问密钥ID和秘密访问密钥。</p><p id="482f" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">然后在<strong class="kd hj"><em class="ld">infra structure/terraform . TF vars</em></strong>文件中，用你选择的名字更新<strong class="kd hj"> <em class="ld"> aws-profile </em> </strong>变量。</p><h2 id="b4fe" class="ls jk hi bd jl lt lu lv jp lw lx ly jt kk lz ma jv ko mb mc jx ks md me jz mf bi translated">将（行星）地球化（以适合人类居住）</h2><p id="c202" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">最后，确保您的机器上本地安装了Terraform。</p><h1 id="9c3c" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">配置如何工作</h1><p id="ac38" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">您可以轻松定制一些变量来控制服务及其AWS基础设施的功能。在基础设施文件夹中，有一个<strong class="kd hj"><em class="ld">terra form . TF vars</em></strong>文件，包含以下内容:</p><ul class=""><li id="09c8" class="le lf hi kd b ke kx kh ky kk lg ko lh ks li kw lj lk ll lm bi translated"><strong class="kd hj"> <em class="ld"> name </em> </strong> —您所称的服务或应用程序，该值用于整个terraform文件的命名约定。</li><li id="6a4b" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kd hj"> <em class="ld"> aws-region </em> </strong> —您要部署基础架构的aws区域。</li><li id="3973" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kd hj"><em class="ld">AWS-profile</em></strong>—包含创建所有基础架构的凭据的AWS CLI配置文件名称。</li><li id="e366" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kd hj"> <em class="ld">环境</em> </strong> —您的环境的名称，例如“生产”、“暂存”、“测试”等。该值用于整个terraform文件的命名约定。</li><li id="98fb" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kd hj"> <em class="ld">可用性区域</em> </strong> —在所选AWS区域中使用的可用性区域列表。</li><li id="0935" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kd hj"><em class="ld">private _ subnets</em></strong>—面向互联网的子网的CIDR块列表。</li><li id="15f7" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kd hj"><em class="ld">public _ subnets</em></strong>—私有子网的CIDR块列表。</li><li id="e02b" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kd hj"><em class="ld">container _ memory</em></strong>—您希望应用程序的每个实例拥有多少内存。</li><li id="3e53" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kd hj"><em class="ld">container _ port</em></strong>—应用程序监听的端口。这个API监听端口8888，你可以在docker文件和<em class="ld"> api/api.go </em>中看到。</li><li id="58e2" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kd hj"><em class="ld">container _ cpu</em></strong>—您希望应用程序的每个实例拥有多少CPU。</li><li id="a793" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kd hj"><em class="ld">health _ check _ path</em></strong>—您的应用程序上的路由，将用于查看您的服务是否工作，并决定启动新的实例。</li><li id="4005" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kd hj"><em class="ld">github _ branch</em></strong>—github仓库的分支。</li><li id="0256" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kd hj"><em class="ld">github _ owner</em></strong>—github仓库的所有者。</li><li id="041b" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kd hj"><em class="ld">github _ repo</em></strong>—仓库名称。</li><li id="68eb" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><strong class="kd hj"><em class="ld">github _ Token</em></strong>—用于Github和AWS CodeBuild之间通信的个人访问令牌。</li></ul><h1 id="ecdf" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">部署应用程序</h1><p id="a6c3" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">您的环境现在已经为部署做好了准备。在您的终端中，导航到基础设施文件夹并初始化terraform项目。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="4b4b" class="ls jk hi mh b fi ml mm l mn mo">terraform init</span></pre><p id="80e0" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">您应该在终端中看到类似的内容。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/69f7540118e5980d7654d55518e7a2de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IhE_tjadxnplH4okppCkzg.png"/></div></div></figure><p id="d2e0" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">您应该会看到一个. terraform文件夹出现。接下来运行plan命令，看看会创建什么。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="54aa" class="ls jk hi mh b fi ml mm l mn mo">terraform plan -out=tfplan</span></pre><p id="cb1a" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">您应该会看到一长串类似JSON的对象，描述了所有新的基础设施。</p><p id="9f01" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">最后，应用地形图创建基础设施。这可能需要5分钟。</p><pre class="iy iz ja jb fd mg mh mi mj aw mk bi"><span id="218b" class="ls jk hi mh b fi ml mm l mn mo">terraform apply tfplan</span></pre><p id="ed03" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">之后，终端应该显示部署确认。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/381f212fdd66311e3b3cb78e276ba6ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AAuJOyaZ_kbY7y-k_9_H0w.png"/></div></div></figure><p id="c549" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">如果您导航到ECS控制面板的负载平衡器部分，您应该会看到新的DNS，我们可以使用它来访问我们的应用程序。负载平衡器命名约定使用名称和环境terraform变量。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/8742f71fd1f4dcb3bd40c671b77b099e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8_bnEifGrkp3my75ZdHIg.png"/></div></div></figure><p id="838b" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">但是，应用程序还不能工作。如果我们访问那个URL，我们得到一个503错误。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mt"><img src="../Images/effe227803acc788650db9b4dfceeb76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TpFRemLsgREx3prvAezVew.png"/></div></div></figure><p id="65a5" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">我们需要首先对我们的代码库进行更改，以便我们的CodeBuild项目触发并部署新代码到ECS服务。</p><p id="9d3c" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">在<strong class="kd hj"> <em class="ld"> api/api.go </em> </strong>文件中，将/ route改为返回再见而不是你好。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/f48390bd48b5e502dfbc1d7cb17b9950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWKU_kS_kSK9NS61ouptIg.png"/></div></div></figure><p id="a087" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">一旦您将变更推进到您的主分支，您应该会看到CodeBuild项目正在进行中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/c97cb77dff9346f814e10a69773c4662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZDkdKxGCq5HsVx4NLSewA.png"/></div></div></figure><p id="4d39" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">几分钟后，您应该能够从负载平衡器DNS访问您的应用程序了！</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/b3803adb6fe0f905f1610cc7030e7450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LaG08z4KORfZdZQvo1scaA.png"/></div></div></figure><h1 id="399b" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">AWS资源</h1><p id="39e3" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">我将简要描述从这个Terraform堆栈中创建的关键组件，这些组件在查看代码时并不明显。</p><h2 id="79e4" class="ls jk hi bd jl lt lu lv jp lw lx ly jt kk lz ma jv ko mb mc jx ks md me jz mf bi translated">Nat网关和弹性IP</h2><p id="ec5b" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">由于我们的后端“服务器”或任务驻留在私有子网中，这意味着它们不能通过互联网公开访问，我们需要从这些子网进行出站互联网访问，以便我们可以访问AWS资源并在需要时获得软件更新。</p><h2 id="7f98" class="ls jk hi bd jl lt lu lv jp lw lx ly jt kk lz ma jv ko mb mc jx ks md me jz mf bi translated">IAM角色和策略</h2><p id="96a2" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">IAM是在AWS中操作的基础，它向资源授予执行某些任务的权限。这个项目需要注意以下几点:</p><ul class=""><li id="0d6a" class="le lf hi kd b ke kx kh ky kk lg ko lh ks li kw lj lk ll lm bi translated"><em class="ld"> CodeBuild </em> —有两个关键策略附加到CodeBuild资源上，<strong class="kd hj"><em class="ld">assume _ by _ CodeBuild</em></strong>with gives<strong class="kd hj"><em class="ld">STS:AssumeRole</em></strong>动作，让code build与其他AWS服务对话。然后是<strong class="kd hj"><em class="ld">AWS _ iam _ policy _ document . codebuild</em></strong>策略，允许code build上传到我们的ECR存储库并更新ECS服务。</li><li id="fdb3" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><em class="ld"> ECS — </em>与CodeBuild策略类似，我们的ECS资源需要<strong class="kd hj"><em class="ld">STS:AssumeRole</em></strong>用于我们的任务定义，以允许ECS进行某些内部AWS调用，如获取新的ECR图像或访问CloudWatch日志。</li></ul><h2 id="b70e" class="ls jk hi bd jl lt lu lv jp lw lx ly jt kk lz ma jv ko mb mc jx ks md me jz mf bi translated">代码构建</h2><p id="d97b" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">对于这个特定的代码库，我想指出的一点是，用于运行buildspec文件的构建映像被设置为<strong class="kd hj"><em class="ld">aws/code build/standard:5.0</em></strong>，这是AWS对Ubuntu的说法。测试时，我注意到一些构建映像不支持Go模块，而这个支持。</p><p id="b29d" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">另一件事是环境变量。在<strong class="kd hj"><em class="ld">AWS _ code build _ project . main</em></strong>中，我们设置了<strong class="kd hj"><em class="ld">pipeline/deploy . yml</em></strong>文件中用到的各种环境变量。<br/>还有最后一件事，用于CodeBuild的Github连接。在CodeBuild Terraform文件的末尾，我们将源设置为Github存储库，设置凭证以使用我们的个人访问令牌，然后使用CodeBuild web钩子来监听主分支上的推送事件。</p><h2 id="6225" class="ls jk hi bd jl lt lu lv jp lw lx ly jt kk lz ma jv ko mb mc jx ks md me jz mf bi translated">安全组</h2><p id="e9a0" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">这个项目有两个主要的安全组:一个用于负载平衡器，另一个用于ECS服务。负载平衡器安全组仅允许端口80上的流量(HTTP请求)，而我们的ECS服务安全组仅允许来自负载平衡器安全组的流量(所有流量)，实际上就是说您只能通过负载平衡器DNS访问这些服务。</p><h1 id="a1e0" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">结论</h1><p id="37d8" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">这个项目是一个反复试验的项目:阅读Terraform文档，寻找其他具有类似目标的公共存储库，无数次地建立和破坏基础设施。我故意没有涉及Terraform的细节，因为我觉得有大量的教程可以解决这个问题，我还想提供开箱即用的源代码(我发现大多数存储库在当前版本的Terraform中都没有),并提供一个机会来搜索terraform文件，看看它们是如何连接的。</p><h1 id="17d4" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">附录:代码库详细信息</h1><p id="e7b1" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">本文的目的是用Terraform和AWS演示DevOps，但是如果您对某些实践不熟悉，我想简要介绍一些关于代码库的主题。</p><h2 id="89eb" class="ls jk hi bd jl lt lu lv jp lw lx ly jt kk lz ma jv ko mb mc jx ks md me jz mf bi translated">代码组织</h2><p id="3e4b" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">像大多数用于api开发的后端语言一样，我实现了一个简单的分层过程，以1)保持处理程序精简，2)使测试更容易。为了满足这两点，我倾向于如下组织逻辑的分离:</p><ul class=""><li id="2adf" class="le lf hi kd b ke kx kh ky kk lg ko lh ks li kw lj lk ll lm bi translated"><em class="ld">处理程序</em> —处理传入的请求并验证HTTP输入，如请求体和查询参数。</li><li id="ea19" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><em class="ld">服务</em> —执行大部分业务逻辑。</li><li id="421d" class="le lf hi kd b ke ln kh lo kk lp ko lq ks lr kw lj lk ll lm bi translated"><em class="ld">存储库</em> —与您选择的数据存储交互的基本逻辑。在这种情况下，它是一个内存数组，但是如果您切换到MongoDB或Postgres，您只需要对存储库文件进行更改，其他功能都是一样的。</li></ul><h2 id="3d68" class="ls jk hi bd jl lt lu lv jp lw lx ly jt kk lz ma jv ko mb mc jx ks md me jz mf bi translated">测试和嘲笑</h2><p id="ec09" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">应用程序中的每一层都需要某种形式的依赖关系。处理程序需要服务，服务需要存储库。每一层依赖关系都耦合到一个接口，因此我们可以模拟依赖关系的底层执行，而不是在单元测试期间实际连接到数据库。</p><p id="cdb0" class="pw-post-body-paragraph kb kc hi kd b ke kx ij kg kh ky im kj kk kz km kn ko la kq kr ks lb ku kv kw hb bi translated">为了模仿，我使用了本地安装在我机器上的<a class="ae lc" href="https://github.com/vektra/mockery" rel="noopener ugc nofollow" target="_blank">模仿</a>包。在<em class="ld"> makefile </em>中，您可以看到<em class="ld"> mockgen </em>命令，它为每个依赖项创建模拟包，特别是任务服务和存储库。运行时，<em class="ld">模拟</em>文件夹将出现在<em class="ld">服务</em>和<em class="ld">存储库</em>文件夹中。</p><h1 id="0ac6" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">配置</h1><p id="f009" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">大多数现代web应用程序使用某种形式的外部配置来存储敏感信息，如外部API凭证，或者可能是控制某些逻辑功能的标志。在api/config包中，我使用了一个基本的系统，它首先检查JSON文件的值，如果它们不存在，检查表单，然后作为环境变量。</p><h2 id="828c" class="ls jk hi bd jl lt lu lv jp lw lx ly jt kk lz ma jv ko mb mc jx ks md me jz mf bi translated">发出命令</h2><p id="a112" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">项目的根目录是一个名为<em class="ld"> makefile，</em>的文件，它包含了一个命令列表，这些命令总是让人厌烦。如果您的机器上安装了Make，您可以运行<em class="ld"> make coverage </em>来生成HTML golang覆盖率报告，或者如果您对接口进行了更改，可以运行<em class="ld"> make mockgen </em>来重新生成您的模拟文件。</p></div></div>    
</body>
</html>