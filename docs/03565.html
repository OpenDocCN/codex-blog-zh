<html>
<head>
<title>A React Single-Page Application Built on the Twitter API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Twitter API构建的React单页面应用程序</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-react-single-page-application-built-on-the-twitter-api-ea9518beab09?source=collection_archive---------4-----------------------#2021-09-09">https://medium.com/codex/a-react-single-page-application-built-on-the-twitter-api-ea9518beab09?source=collection_archive---------4-----------------------#2021-09-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4606" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本帖涵盖的技能、语言和软件包:</p><ul class=""><li id="1584" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">反应</li><li id="58f6" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">Redux</li><li id="60c4" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">反应路由器</li><li id="dd88" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">Redux Thunk</li><li id="a360" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">Twitter API</li><li id="e671" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">Ruby on Rails API</li><li id="e5d7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">网络云</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/87adfd93995225c41078582a18f72973.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OToCfYEaV1EN85k4WB_gpg.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">FlockWords:一个带有Ruby on Rails后端的React单页应用程序。</figcaption></figure><p id="499a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文中的代码示例:</p><ul class=""><li id="3745" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">React容器组件设计模式</li><li id="38c5" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">有状态与无状态React组件</li><li id="dff0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">Rails API作为Twitter API数据检索和处理的代理服务器</li><li id="e35c" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">构建React单页面应用程序</li></ul></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="c30d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个项目的目标是使用React创建一个用户界面，用于可视化分析多达四个Twitter feeds，作为一个动态创建的wordcloud。为了实现这一目标，必须完成三个主要步骤:</p><ol class=""><li id="aa36" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ko jj jk jl bi translated">访问Twitter API</li><li id="bf7a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ko jj jk jl bi translated">在Rails服务器中操作和存储数据</li><li id="ec5b" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ko jj jk jl bi translated">在React前端显示处理后的数据</li></ol><h1 id="acb1" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">访问Twitter API</h1><p id="1220" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">Twitter要求用户拥有一个开发者账户来访问它的API。现有的Twitter账户可以用来注册一个开发者账户。Twitter要求用户回答几个关于他们是什么类型的开发人员的问题(学生、专业人员等)。)以及他们需要什么类型的发展账户。我选择了专业开发人员和标准(非商业)帐户。一旦开发人员帐户就位并且凭证得到验证，就必须指定一个应用程序，以便Twitter可以发布API密钥、秘密和不记名令牌。</p><p id="4993" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Twitter最近发布了他们的v2 API，以及一个名为Projects的新开发工具。为了使用v2端点，开发人员必须创建项目，其中可以包含单个应用程序。推文上限和其他端点限制适用于项目级别。要了解更多关于Twitter开发者空间的项目和应用，请查看<a class="ae ls" href="https://developer.twitter.com/en/docs/apps/overview" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="d2d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为简单起见，该应用程序所在的项目也被称为FlockWords(这个想法是由一小群Twitter用户创建的wordcloud)。从开发者仪表板，用户可以访问他们的项目/应用程序，还可以检查所有端点的推文限制的接近度。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es lt"><img src="../Images/9d0484122a03fb33d714750190ac31c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-cCwzhC-Oqo9jvlbG7Duw.png"/></div></div></figure><p id="9b8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Twitter API文档使得访问变得相当容易，只要开发人员已经熟悉API的用法。对于这个项目，我使用gem rest-client从Ruby on Rails服务器进行API调用。我更喜欢从React前端进行调用，因为它速度快得多，并且将处理能力的责任放在了客户端，但是React没有隐藏API键或其他敏感信息的真正方法。</p><blockquote class="lu lv lw"><p id="f0df" class="if ig lx ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated">React没有真正的方法来隐藏API键或其他敏感信息。</p></blockquote><p id="d614" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管秘密和密钥可以隐藏在一个. env文件中，并远离GitHub，但是当React应用程序运行时，环境文件仍然嵌入到客户端中。这首先会使使用. env的安全性失效。因此，在这种情况下，Rails服务器实质上是调用Twitter API的代理。Rails服务器并不是保护敏感信息安全的完美解决方案，但它比客户端方法更安全。</p><h1 id="1586" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">构建Rails服务器</h1><p id="fee5" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">Rails服务器是使用API标志生成的。我以前在这里写过这个过程<a class="ae ls" href="https://hanreitz.medium.com/building-a-javascript-single-page-application-with-rails-api-a8e5945128a9#61fe" rel="noopener">。对于这个项目，在生成API构建之后，使用以下通用模式搭建了Feed和Tweet(以在API构建下生成路由、迁移、模型和控制器):</a></p><pre class="js jt ju jv fd mb mc md me aw mf bi"><span id="1395" class="mg kq hi mc b fi mh mi l mj mk">terminal $ rails g scaffold Tweet content:string twitter_id:string</span></pre><p id="e520" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无需添加表列字段即可使用Scaffold仍然会生成所有相关的文件，但是迁移应该在运行之前用列名进行更新。</p><p id="db75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了由scaffolding Feed和Tweet创建的样板代码之外，这个应用程序示例需要连接到Twitter API，并使用存储在. env文件中的秘密信息获取数据。为了在轨道上做到这一点:</p><ul class=""><li id="8380" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">将“gem dotenv”添加到gem文件中</li><li id="5681" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">运行捆绑包安装</li><li id="f553" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">补充。env到。Git在运行任何新的Git推送之前忽略文件</li><li id="31d6" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">创造。Rails服务器根目录中的env</li></ul><p id="e3b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">约定是将秘密信息添加到。Ruby常量样式的env文件(全部大写):</p><pre class="js jt ju jv fd mb mc md me aw mf bi"><span id="32e3" class="mg kq hi mc b fi mh mi l mj mk">API_KEY = uHoHnOwThEyKnOw1234<br/>API_KEY_SECRET = I'vegotasecretasecretsecret<br/>BEARER_TOKEN = AAAAAAAAAAAAwhydoTwitterbearertokensscream?</span></pre><p id="fd10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过使用ENV["API_KEY"]等任何需要值的地方，可以在应用程序的其余部分访问这些信息。</p><p id="426c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个项目中的Rails服务器在接收到前端用户输入的Twitter句柄时，发起对Twitter API的调用。尽管v2 API有一个端点，可以根据用户名检索用户的推文，但在撰写本文时，该端点还没有运行。因此，使用自定义函数，首先通过用户名端点对用户的调用来验证句柄:</p><pre class="js jt ju jv fd mb mc md me aw mf bi"><span id="31de" class="mg kq hi mc b fi mh mi l mj mk">https://api.twitter.com/2/users/by/username/:username</span></pre><p id="7059" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果句柄返回有效，那么同一个定制函数将使用第一次调用返回的user_id进行第二次调用，以检索现在已验证的Twitter用户的Tweets:</p><pre class="js jt ju jv fd mb mc md me aw mf bi"><span id="de78" class="mg kq hi mc b fi mh mi l mj mk">https://api.twitter.com/2/users/:user_id/tweets</span></pre><p id="2d75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用了Twitter API提供的一些<a class="ae ls" href="https://developer.twitter.com/en/docs/twitter-api/tweets/timelines/api-reference/get-users-by-username-username-tweets" rel="noopener ugc nofollow" target="_blank">扩展</a>来将author_id和created_at字段添加到数据中，同时将Tweets的数量从10条增加到20条。从那里，FeedsController#create调用定制函数，创建Feed对象及其相关Tweets。当用户删除一个feed时，后端也会删除它和相关的Tweets。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es ml"><img src="../Images/5d6ec5b44ff0840fd7e207631e5a178f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FyTqF5RfTZcDyaqDw0yMHA.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">RestClient调用Twitter API的自定义句柄验证函数。</figcaption></figure><p id="8b87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Rails服务器完成的另一项关键工作是将Tweet字符串处理成数据，以备ReactWordcloud在前端使用。为此，我使用了一个自定义方法TweetsController#get_data，以及它自己的路由。前端使用自定义的“/data”路由调用服务器，提供的响应是一个包含Tweets中所有单词(除了常见的单词，如“The”)及其各自计数的对象。ReactWordcloud能够直接使用这个对象进行渲染。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es mm"><img src="../Images/43f70feb5b6cb33e658916bba2988373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53Att-piCATc2UoPHm4UHg.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">TweetsController#get_data方法，排除列表和过滤的单词因大小而被截断。</figcaption></figure><blockquote class="lu lv lw"><p id="819a" class="if ig lx ih b ii ij ik il im in io ip ly ir is it lz iv iw ix ma iz ja jb jc hb bi translated">注意:最初，我在React中编写了Tweet数据处理，但是spec要求在前端进行最少的数据处理，所以我将它移回了Rails服务器。如果完全由我决定，我会将这种数据处理移回React，因为它的速度比Rails快。</p></blockquote><h1 id="e5a1" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">在React中显示数据</h1><p id="74e3" class="pw-post-body-paragraph if ig hi ih b ii ln ik il im lo io ip iq lp is it iu lq iw ix iy lr ja jb jc hb bi translated">前端实现了两个关键目标:它允许用户输入Twitter句柄，然后显示这些Twitter句柄的feed和wordcloud贡献。为了创建我的前端应用程序，我使用了<a class="ae ls" href="https://reactjs.org/docs/create-a-new-react-app.html#create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>。</p><pre class="js jt ju jv fd mb mc md me aw mf bi"><span id="29da" class="mg kq hi mc b fi mh mi l mj mk">terminal $ npx create-react-app flock-words-client</span></pre><p id="1a57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用create-react-app意味着不必手动配置Webpack和Babel，以及其他东西(如ESLint)，这意味着从没有代码快速转移到一个工作的react应用程序。关于create-react-app的一些优点，请查看<a class="ae ls" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> Create React App开发页面</a>。当然，将所有东西都设置为某个默认标准也会给一些开发人员带来问题。关于为什么不使用create-react-app的对比，请看这篇<a class="ae ls" href="https://dev.to/nikhilkumaran/don-t-use-create-react-app-how-you-can-set-up-your-own-reactjs-boilerplate-43l0" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="5732" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在创建了React前端之后，我构建了容器组件结构。应用主页有三个容器组件:FeedsContainer、TweetsContainer和WordcloudContainer。只有这三个组件是有状态的，连接到Redux并将必要的数据作为props向下传递给它们各自的组件。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es mn"><img src="../Images/6c0c76be1428c4d5098b28f70fcced2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pckOZ-0EonBlXmFud5-k_A.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">TweetsContainer，React中容器组件的一个例子。</figcaption></figure><p id="b4d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面显示的tweetsContainer示例中，Tweet组件是用key和Tweet的属性呈现的。在tweet组件中，这些道具用于呈现每条Tweet的文本。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es mo"><img src="../Images/8ede72dfa0753748a201273d007b1c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*aWwyyJ5wZS18jdF9qUeraA.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">Tweet，React中功能组件的一个例子。</figcaption></figure><p id="55f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无状态的功能组件本质上比连接的容器组件更短、更清晰。应用程序的大部分由这些简短、清晰、模块化的组件组成。甚至出现在每个提要上方的删除按钮也是功能组件，从它们的父级FeedsContainer传递deleteFeed属性。结果是一个清晰的“命令链”,其中容器组件管理数据并将数据传递给下属的功能组件。Redux将任何组件连接到状态的能力允许容器组件出现在站点结构中的任何地方，甚至在其他功能组件的“下面”。恰当的例子是:TweetsContainer组件实际上是由functional Feed组件呈现的。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es mp"><img src="../Images/09f65531f9ae03b9704483b878529608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wXyMQd132U0sQcscQc_M-A.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">由无状态组件呈现的有状态组件。</figcaption></figure><p id="9153" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个单页应用程序中“隐藏”的另一个关键技术过程是react-router-dom中的React浏览器。这允许用户像浏览多页站点一样浏览单页应用程序。为了使用BrowserRouter，我使用yarn添加react-router-dom，然后在App.js中导入BrowserRouter和Route。</p><pre class="js jt ju jv fd mb mc md me aw mf bi"><span id="302b" class="mg kq hi mc b fi mh mi l mj mk">import Header from './components/Header'<br/>import Navbar from './components/Navbar'<br/>import { BrowserRouter as Router, Route } from 'react-router-dom'<br/>import Homepage from './components/Homepage'<br/>import DataContainer from './containers/DataContainer'<br/>import AboutPage from './components/AboutPage'</span><span id="7661" class="mg kq hi mc b fi mq mi l mj mk">function App() {<br/>  const info = console.log(process.env)<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      {info}<br/>      &lt;Header /&gt;<br/>      &lt;Router&gt;<br/>        &lt;div&gt;<br/>          &lt;Navbar /&gt;<br/>          &lt;Route exact path='/' component={Homepage} /&gt; <br/>          &lt;Route exact path='/data' component={DataContainer} /&gt;<br/>          &lt;Route exact path='/about' component={AboutPage} /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/Router&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="440a" class="mg kq hi mc b fi mq mi l mj mk">export default App;</span></pre><p id="1a2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将路由定义为精确的路径，以确保当用户导航到这些路由时，只显示指定组件的内容。我希望导航条显示在每一页上，所以我把它放在所有没有指定路径的单独路线的上面。为了创建有效的导航栏链接，我在我的Navbar组件中定义了一个带有名称和路径的对象数组，然后在组件中将该数组的映射呈现为NavLinks:</p><pre class="js jt ju jv fd mb mc md me aw mf bi"><span id="a3e0" class="mg kq hi mc b fi mh mi l mj mk">import React from 'react'<br/>import { NavLink } from 'react-router-dom'</span><span id="3b41" class="mg kq hi mc b fi mq mi l mj mk">const navbarItems = [<br/>  {<br/>    name: 'Home',<br/>    route: '/'<br/>  },<br/>  {<br/>   name: 'Data',<br/>   route: '/data'<br/>  },<br/>  {<br/>    name: 'About',<br/>    route: '/about'<br/>  }<br/>]</span><span id="e65a" class="mg kq hi mc b fi mq mi l mj mk">const Navbar = () =&gt; {<br/>  return (<br/>    &lt;div className='navbar-container'&gt;<br/>      {navbarItems.map(item =&gt; &lt;NavLink to={item.route} className='navbar-item'&gt;{item.name}&lt;/NavLink&gt;)}<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="d9f2" class="mg kq hi mc b fi mq mi l mj mk">export default Navbar</span></pre><p id="dea1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，考虑这里显示的'/data '路由。在上面的App.js代码中，数据路由指向正在呈现的DataContainer组件。DataContainer使用getData动作创建器在组件挂载后访问Rails服务器，并获取页面显示所需的数据。</p><pre class="js jt ju jv fd mb mc md me aw mf bi"><span id="a139" class="mg kq hi mc b fi mh mi l mj mk">export const getData = () =&gt; {<br/>  return (dispatch) =&gt; {<br/>    dispatch({ type: 'LOADING_DATA' })<br/>    fetch('<a class="ae ls" href="http://localhost:3000/data'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/data'</a>)<br/>    .then(resp =&gt; resp.json())<br/>    .then(data =&gt; dispatch({<br/>      type: 'ADD_DATA',<br/>      data: data<br/>    }))<br/>  }<br/>}</span></pre><p id="bcf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦承诺完成，reducer就会根据链接到fetch请求的最终“then”中调度的动作将数据添加到状态中。然后，DataContainer组件可以呈现在所有提要中使用了五次或更多次的单词表。所有这些操作只需要在调用ReactDOM.render的文件(在本例中是index.js)中导入一次Redux和React-Redux库。</p><pre class="js jt ju jv fd mb mc md me aw mf bi"><span id="d221" class="mg kq hi mc b fi mh mi l mj mk">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import './index.css';<br/>import App from './App';<br/>import { Provider } from 'react-redux'<br/>import { createStore, applyMiddleware } from 'redux';<br/>import thunk from 'redux-thunk'<br/>import rootReducer from './reducers/rootReducer'</span><span id="96af" class="mg kq hi mc b fi mq mi l mj mk">const store = createStore(rootReducer, applyMiddleware(thunk))</span><span id="64f5" class="mg kq hi mc b fi mq mi l mj mk">ReactDOM.render(<br/>  &lt;Provider store={store}&gt;<br/>    &lt;App /&gt;<br/>  &lt;/Provider&gt;,<br/>  document.getElementById('root')<br/>);</span></pre></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="1cb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个概述中，演示了从Twitter API到Rails代理服务器，再到React前端的Twitter数据可视化分析应用程序的完整开发。应该清楚的是，虽然这个项目需要努力和创造力，但即使是那些刚刚开始使用Rails或React的人，如果他们使用这里描述的工具，也可以编写类似的东西。允许的预配置，尤其是Rails scaffolding和create-react-app允许的预配置，让开发人员可以快速启动并运行，并继续处理代码中比配置更有趣的问题。</p><p id="73a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想了解更多或者运行这个应用，点击这里查看Rails服务器<a class="ae ls" href="https://github.com/hanreitz/flock-words-api" rel="noopener ugc nofollow" target="_blank">，点击这里</a>查看React前端<a class="ae ls" href="https://github.com/hanreitz/flock-words-api" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>