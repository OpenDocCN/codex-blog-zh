<html>
<head>
<title>A couple of use cases for nested static classes in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中嵌套静态类的几个用例</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-couple-of-use-cases-for-nested-static-classes-in-java-8a115dbcaacf?source=collection_archive---------16-----------------------#2022-05-05">https://medium.com/codex/a-couple-of-use-cases-for-nested-static-classes-in-java-8a115dbcaacf?source=collection_archive---------16-----------------------#2022-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8f2934d90802a48015a3e6a4c435c66e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KF52lggz426c86ui"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@pixtagrammer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Vignesh Jayaprakash </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="db04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只要可以使用匿名类，就可以使用命名的嵌套静态类。但是，只有当您需要从两个或更多地方实例化该类时，这才有意义。</p><p id="d594" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">迭代器可能不会出现这种情况，但单链表或双向链表中的节点可能会出现这种情况。</p><h1 id="9b57" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">链表中的节点</h1><p id="7516" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">不像<code class="du kw kx ky kz b">ArrayList</code>那样用一个后备数组来保存列表的元素，链表用链接的节点来保存元素。</p><p id="5873" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们可以使用私有嵌套静态类来表示链表中的每个节点。</p><p id="6688" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在单链表的情况下，每个节点只需要保存两件事:元素和指向下一个节点或前一个节点的指针，或者如果它是列表中的最后一个或第一个元素，则为空指针(取决于链接是向前指向还是向后指向)。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/6e4d5b533f8699fd507ef29d3ad8205c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uKI1q0MudL1mn4c3Jk8bVw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">显示具有四个元素的链表的图表。</figcaption></figure><p id="251a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">链表的一个优点是在链表的中间插入和删除非常容易。没有必要在后备数组中移动元素。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/cbffe64d7a256c2175a766f96f207e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ttAFrNBPoOKczmuQ4thDMg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">显示向链表中插入元素的图。</figcaption></figure><p id="c2e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">无论哪个方向。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/4797574ae0e5d76aa66bad3891bc5ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9HDq0pgyY6c7-xW3Nx8AA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">显示从链表中移除元素的图。</figcaption></figure><p id="92fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">链表也有其缺点，但这超出了本文的范围。重要的是，链表的节点可以由嵌套在链表类中的专用类来表示。</p><p id="c71f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是<code class="du kw kx ky kz b">SinglyLinkedList&lt;E&gt;</code>的草稿:</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="a122" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为<code class="du kw kx ky kz b">Node&lt;E&gt;</code>不需要访问封闭类<code class="du kw kx ky kz b">this</code>，所以它可以被声明为嵌套的静态类而不是内部类。</p><h1 id="6853" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">实现嵌套在测试类中的类</h1><p id="0ab6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">另一个用例是我感谢Apache NetBeans的:使用嵌套在测试类中的静态嵌套类来测试抽象类。</p><p id="770c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我试图更彻底地了解测试驱动开发(TDD)时，我意识到在大多数情况下抽象类需要被测试。第一次想到这个问题时，我决定在NetBeans中尝试一下。</p><p id="743b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果让NetBeans为一个抽象类生成一个测试类，它可能会包含一个嵌套在测试类中的“Impl”类。例如，如果<code class="du kw kx ky kz b">SomeClass</code>是抽象的，并且有一个需要一个或多个参数的构造函数，NetBeans将包含嵌套在<code class="du kw kx ky kz b">SomeClassTest</code>中的<code class="du kw kx ky kz b">SomeClassImpl</code>。</p><p id="369d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，NetBeans不会将这样的Impl类标记为静态，也不会提醒您它可以是静态的。但也许您可以将这归因于NetBeans不像Eclipse或IntelliJ IDEA那样“固执己见”——最后一个肯定会让您知道嵌套类何时可以是静态的。</p><p id="f80b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，给定这个抽象类，</p><figure class="lb lc ld le fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="d42a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">NetBeans将为您生成如下内容:</p><pre class="lb lc ld le fd lj kz lk ll aw lm bi"><span id="f6b0" class="ln ju hi kz b fi lo lp l lq lr">package postal;</span><span id="509e" class="ln ju hi kz b fi ls lp l lq lr">// JUnit imports go here</span><span id="34df" class="ln ju hi kz b fi ls lp l lq lr">public class PostalCodeTest {</span><span id="b6d5" class="ln ju hi kz b fi ls lp l lq lr">    // Test stub for getCountry()</span><span id="1716" class="ln ju hi kz b fi ls lp l lq lr">    private class PostalCodeImpl extends PostalCode {<br/>        <br/>        @Override<br/>        public String toString() {<br/>            return "ImplPostal " + this.postalCodeNumber;<br/>        }</span><span id="3fb9" class="ln ju hi kz b fi ls lp l lq lr">        PostalCodeImpl(int code) {<br/>            super(code, Locale.US);<br/>        }<br/>        <br/>    }</span><span id="b19d" class="ln ju hi kz b fi ls lp l lq lr">}</span></pre><p id="4676" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一种良好的形式，您可以在<code class="du kw kx ky kz b">PostalCodeImpl</code>声明中添加“<code class="du kw kx ky kz b">static</code>”。我非常喜欢这个想法，我也在我的IntelliJ项目中使用它，这就是我如何发现我缺少这个特定用例的静态声明。</p></div></div>    
</body>
</html>