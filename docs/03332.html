<html>
<head>
<title>eBPF and WebAssembly: whose VM reigns supreme?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">eBPF和WebAssembly:谁的VM至高无上？</h1>
<blockquote>原文：<a href="https://medium.com/codex/ebpf-and-webassembly-whose-vm-reigns-supreme-c2861ce08f89?source=collection_archive---------7-----------------------#2021-08-28">https://medium.com/codex/ebpf-and-webassembly-whose-vm-reigns-supreme-c2861ce08f89?source=collection_archive---------7-----------------------#2021-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ebe3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">看情况。但是对于开发者来说，Rust是一种方式。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3c164a8c3751ad900e1ac1c2e535c692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p1YF3tsQ46F22a0l-QUnUw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://unsplash.com/@john_cameron?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约翰·卡梅隆</a>在<a class="ae jn" href="https://unsplash.com/s/photos/competition?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="82d5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">今天在云原生世界中最热门的两个轻量级代码执行沙箱/虚拟机是<a class="ae jn" href="https://ebpf.io" rel="noopener ugc nofollow" target="_blank"> eBPF </a>和<a class="ae jn" href="https://webassembly.org" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>。它们都运行由C、C++和Rust编译的高性能字节码程序。</p><p id="4f60" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，最大的区别是eBPF运行在Linux内核中，而WebAssembly运行在用户空间中。eBPF有一些编程限制，使得它对于内核用例是安全的(例如没有无限循环)。但这也意味着eBPF是图灵不完全的。另一方面，WebAssembly是一种图灵完整语言，具有打破沙箱和访问本机OS库的扩展。</p><p id="c28a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一般来说，eBPF适合于网络或安全相关的任务，而WebAssembly非常适合于业务应用程序。但肯定有重叠。</p><p id="1124" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，已经有人努力在<a class="ae jn" href="https://hub.packtpub.com/introducing-wasmjit-a-kernel-mode-webassembly-runtime-for-linux/" rel="noopener ugc nofollow" target="_blank"> Linux内核</a>中<a class="ae jn" href="https://link.medium.com/HAUbDlHM4ib" rel="noopener">运行WebAssembly </a>。然而，他们大多不成功。对于这个用例，eBPF是更好的选择。</p><p id="e2cd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，WebAssembly程序可以处理许多类似内核的任务。WebAssembly可以被AOT编译成本机应用程序。基于LLVM的云本地WebAssembly编译器的一个很好的例子是来自CNCF的WasmEdge运行时。本机应用程序将所有沙箱检查合并到本机库中。这使得WebAssembly程序的行为像一个自包含的单内核“库操作系统”。</p><p id="1945" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，这种AOT编译的沙盒WebAssembly应用程序可以运行在微内核操作系统上，如<a class="ae jn" href="https://lists.sel4.systems/hyperkitty/list/announce@sel4.systems/thread/PTIILUXXLO5X6MDAG7GJMUBYDOB7ASCJ/" rel="noopener ugc nofollow" target="_blank"> seL4 </a>，并可以接管许多“内核级”任务。</p><p id="f9c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">虽然WebAssembly可以下降到内核级别，但是eBPF也可以上升到应用程序级别。例如，服务网格代理通常支持<a class="ae jn" href="https://github.com/proxy-wasm/spec" rel="noopener ugc nofollow" target="_blank"> WebAssembly作为扩展机制</a>。因为这些代理基本上是网络应用程序，所以可以用eBPF编写一些扩展，以获得更高的性能和可观察性，而不会损害安全性和可扩展性。</p><p id="49b0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在服务网格用例中，WebAssembly非常适合于<a class="ae jn" href="https://github.com/second-state/dapr-wasm" rel="noopener ugc nofollow" target="_blank"> sidecar微服务应用</a>，eBPF适合于通过代理路由API流量并监控整个应用。</p><p id="d26b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">eBPF和WebAssembly的兴起对开发者来说是个好消息。我们有更多的工具来管理和规划日益复杂的基础设施。Rust已经成为这两种虚拟机的主要编程语言，因为它是高性能的，并且可以由LLVM编译成机器代码，而无需额外的运行时支持。</p><p id="b500" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以最终，开发者只需要关心Rust API，把Rust程序编译成eBPF和WebAssembly as。部署时需要。生锈是一种方式。</p></div></div>    
</body>
</html>