<html>
<head>
<title>A simple lesson in coding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一堂简单的编程课</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-simple-lesson-in-coding-38334e9d8608?source=collection_archive---------18-----------------------#2021-08-16">https://medium.com/codex/a-simple-lesson-in-coding-38334e9d8608?source=collection_archive---------18-----------------------#2021-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cb9bf9c5d34b2508a67172cf0ebff0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PoBNribF3TBnMIhxB1R2ig.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">威斯康辛州华盛顿岛，藏在树叶后面的旧卡车。(作者照片，2021)。</figcaption></figure><p id="6b10" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些天我在修改我在第一周的数据结构课程中用到的例子。这些例子帮助学生更新他们的基本编程技能。其中一个例子对我来说是宝贵的一课。</p><p id="9584" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它从一个简单的问题开始:写一个方法来判断一个字符串是否是回文。几乎是本能地，我输入了下面的代码:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">第4、5和6行的详细程度是为了说明的目的，将在下一次尝试中合并。</figcaption></figure><p id="532f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">看起来简单明了，但它却有着不切实际的缺点。这是降临到二年级学生身上的一种常见疾病——有时也降临到他们的导师身上:我们不假思索就匆忙编写代码。我们可能已经弄清楚了基本的逻辑:假设任何字符串都是一个回文，直到我们在其中找到一对驳斥我们假设的字母。我们从字符串的前端和末端开始比较成对的字母，向其中心移动。</p><p id="cc9e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码里有两件事我不喜欢。首先，如果字符串是一个单字母单词，那么运行循环就像是一种浪费。为了避免这种情况，我添加了下面第3行的<code class="du jz ka kb kc b">if</code>语句。该方法现在将所有单字母单词视为回文。如果我们愿意，我们可以改变这一点；目前，我还能接受。</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">请注意，前面的冗长已经合并成一行(第5行)。</figcaption></figure><p id="dbf4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我不喜欢这种方法的第二点是它很浪费。考虑这样的情况:<code class="du jz ka kb kc b">isPalindrome(<strong class="iw hj">"supercalifragilisticexpialidocious");</strong></code> <strong class="iw hj"> </strong>它的第一个字母匹配它的最后一个字母(<code class="du jz ka kb kc b">'s'=='s’</code>)，它的第二个和倒数第二个字母(<code class="du jz ka kb kc b">'u'=='u'</code>)也是如此。但这不再是第三个和倒数第三个字母的情况，分别是<code class="du jz ka kb kc b">p</code>和<code class="du jz ka kb kc b">o</code>。至此，这个词作为回文被取消了资格。为什么继续剩下的14个配对比较。即使它们都显示匹配的字母，这个单词也不是回文。难道不能节省一些处理时间，一发现不匹配就调用吗？当然可以，只需在下面添加第6行和第7行。</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="2094" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">不过，这很糟糕。几乎和写作一样糟糕:</p><pre class="jt ju jv jw fd kd kc ke kf aw kg bi"><span id="5ac3" class="kh ki hi kc b fi kj kk l kl km">if (!palindrome)<br/>  break; // the for-loop</span></pre><p id="c7fb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们预料到不运行整个循环的情况，最好不要使用for循环。试图过早地跳出for循环是不明智的。它可以工作，但不是好代码。</p><p id="d248" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下一步是用一个更智能的<em class="js">循环重写这个方法。下面第5行中的while循环检查每一对字母。如果发现不匹配，它可能会更快停止。</em></p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="39e8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个例子帮助学生更新他们关于返回类型和参数、字符串方法以及迭代设置中的条件的知识。它将他们从冗长的、设计不良的代码转变为更健壮的方法。它强调了<code class="du jz ka kb kc b">for</code>和<code class="du jz ka kb kc b">while</code>循环之间的主要区别。这也引发了关于设计考虑的有趣对话。</p><p id="b6e1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个值得讨论的话题是传递给方法的参数。如果我们调用<code class="du jz ka kb kc b">isPalindrome("<strong class="iw hj">Noon</strong>");</code>，第一个和最后一个字母不相等，因此<em class="js"> Noon </em>不是一个回文。但它是，我们需要说服我们的代码。因此，我们需要在我们的方法中添加以下语句。</p><pre class="jt ju jv jw fd kd kc ke kf aw kg bi"><span id="4c81" class="kh ki hi kc b fi kj kk l kl km">s = s.<strong class="kc hj">toLowerCase()</strong>; // or .toUpperCase()</span></pre><p id="9b9e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果may将<code class="du jz ka kb kc b">"Noon"</code>传递给该方法，它会在比较每对字母之前将其转换为<code class="du jz ka kb kc b">"noon"</code>(或<code class="du jz ka kb kc b">"NOON"</code>)。</p><p id="07f9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">另一个考虑是关于论点中的空格。假设我们在语法上调用<code class="du jz ka kb kc b">isPalindrome("<strong class="iw hj">Race car"</strong>);</code>，它是一个回文。我们的方法将返回<code class="du jz ka kb kc b">false</code>，因为<code class="du jz ka kb kc b">s.charAt(3)==s.charAt(4)</code>为假。因此，我们开始用以下方式消除空格:</p><pre class="jt ju jv jw fd kd kc ke kf aw kg bi"><span id="1669" class="kh ki hi kc b fi kj kk l kl km">s = s.<strong class="kc hj">replace(" ", "")</strong>.toLowerCase();</span></pre><p id="3280" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">而<code class="du jz ka kb kc b">"Race car"</code>变成了<code class="du jz ka kb kc b">"racecar"</code>。现在，所有成对条件都为真:</p><pre class="jt ju jv jw fd kd kc ke kf aw kg bi"><span id="8d6e" class="kh ki hi kc b fi kj kk l kl km">s.charAt(0) == s.charAt(6); // true because <strong class="kc hj">r </strong>acecar  ==  raceca <strong class="kc hj">r</strong><br/>s.charAt(1) == s.charAt(5); // true because r <strong class="kc hj">a </strong>cecar == racec <strong class="kc hj">a </strong>r<br/>s.charAt(2) == s.charAt(4); // true because ra <strong class="kc hj">c </strong>ecar == race <strong class="kc hj">c </strong>ar<br/>s.charAt(3) == s.charAt(3); // true because rac <strong class="kc hj">e </strong>car == rac <strong class="kc hj">e </strong>car</span></pre><p id="1de3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是还有更多。那么<code class="du jz ka kb kc b">isPalindrome("<strong class="iw hj">a man, a plan, a canal: Panama</strong>");</code>是回文吗？如果我们通过<code class="du jz ka kb kc b">replace()</code>和<code class="du jz ka kb kc b">toLowerCase()</code>清洗字符串，我们得到<code class="du jz ka kb kc b">"aman,aplan,acanal:panama"</code>:不完全是一个回文。我们需要再次清洗字符串<code class="du jz ka kb kc b">s</code>，去掉标点符号。</p><pre class="jt ju jv jw fd kd kc ke kf aw kg bi"><span id="89fb" class="kh ki hi kc b fi kj kk l kl km">s = s.<strong class="kc hj">replaceAll("[^a-zA-Z ]", "")</strong>.replace(" ", "").toLowerCase();</span></pre><p id="9952" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的方法<code class="du jz ka kb kc b">replace()</code>现在是多余的——它的角色可以委托给<code class="du jz ka kb kc b">replaceAll()</code>,只需在正则表达式中稍加修改。然而，我没有这样做，因为我想说明我应用于字符串参数的三个独立的转换:删除标点符号，删除空格，转换为小写(或大写)。最后，前两个删除可以合并到一个正则表达式中，删除所有非字母字符(包括空格、标点、数字等)。现在，最终产品如下所示，第4行中的字符串<code class="du jz ka kb kc b">a</code>经过了转换。</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="6757" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，对话可以转到上面的第4行是否可以委托给一个助手方法，即，</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="5398" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">讨论这种委托的必要性也是很好的，因为我们可以将分解和可重用性作为良好的编码实践来讨论。</p><p id="1627" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，还有一个问题需要讨论:调用<code class="du jz ka kb kc b">wash()</code>的位置。我们把它放在了<code class="du jz ka kb kc b">if</code>的范围内，也就是说，我们只对包含两个或更多字符的参数调用它。这可能会有问题。询问<code class="du jz ka kb kc b">isPalindrome("4");</code>将返回<code class="du jz ka kb kc b">true</code>，尽管我们的目的是检查由字母组成的单词。询问<code class="du jz ka kb kc b">isPalindrome("5A");</code>也将返回true，因为<code class="du jz ka kb kc b">wash()</code>将把参数减少到只有<code class="du jz ka kb kc b">"A"</code>。这是一个谈论预期和意外代码行为以及测试在我们设计过程中的作用的机会。</p><p id="946b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">返回课堂的学生可能对他们的基本编程技能有些生疏。一个构建布尔方法的简单入门示例可以帮助他们探索技术和设计考虑事项，并刷新他们的编码能力。从这里，我们可以将对话引向简单的测试，讨论性能分析，甚至扫描一些文本文件来搜索回文。那么重复数据的问题就出现了。这将我们带到集合论行为数据结构，真正的乐趣开始了！</p><p id="2293" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">接下来:</em> <a class="ae kn" rel="noopener" href="/@leoirakliotis/a-simple-lesson-in-coding-revisited-fbc9add1e599"> <em class="js">一堂简单的编码课，重温一下。</em>T12】</a></p></div></div>    
</body>
</html>