<html>
<head>
<title>Introduction To Pragmatic Functional Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用函数式Java简介</h1>
<blockquote>原文：<a href="https://medium.com/codex/introduction-to-pragmatic-functional-java-md-fba6bdaae6a8?source=collection_archive---------0-----------------------#2021-10-06">https://medium.com/codex/introduction-to-pragmatic-functional-java-md-fba6bdaae6a8?source=collection_archive---------0-----------------------#2021-10-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3876" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实用函数式Java (PFJ)试图定义一种新的惯用Java编码风格。编码风格，它将完全利用当前和未来Java版本的所有特性。编码风格，这将涉及编译器，以帮助编写简洁而可靠和可读的代码。</p><p id="7bdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这种风格甚至可以在Java 8中使用，但在Java 11中，它看起来更加简洁明了。在Java 17中，它变得更有表现力，并受益于每一个新的Java语言特性。</p><p id="1631" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是PFJ不是免费的午餐，它需要开发者在习惯和方法上的重大改变。改变习惯并不容易，传统的命令式习惯尤其难以处理。</p><p id="10a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得吗？肯定！PFJ代码简洁、表达能力强、可靠、易于阅读和维护。在大多数情况下，如果代码能够编译——它就能工作！</p><p id="5794" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(本文是<a class="ae jd" href="https://github.com/siy/pragmatica" rel="noopener ugc nofollow" target="_blank">语用学</a>库的组成部分)。</p><h2 id="6e51" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">实用函数式Java的要素</h2><p id="59f8" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">PFJ源自精彩的<a class="ae jd" href="https://www.amazon.com/dp/0134685997/" rel="noopener ugc nofollow" target="_blank"> Effective Java </a>书，带有一些额外的概念和约定，特别是源自函数式编程。</p><p id="da55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，尽管使用了FP概念，PFJ并没有试图强制使用特定于FP的术语。(尽管为那些有兴趣进一步探索这些概念的人提供了参考)。</p><p id="f68f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PFJ专注于:</p><ul class=""><li id="5ea4" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">减少精神开销</li><li id="bea3" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">提高代码可靠性</li><li id="a6d0" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">提高长期可维护性</li><li id="a116" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">让编译器帮助编写正确的代码</li><li id="0612" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">使编写正确的代码变得容易和自然；编写不正确的代码，虽然仍然有可能，但应该需要努力</li></ul><p id="8ae1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管目标远大，但只有两条关键的PFJ规则:</p><ul class=""><li id="0dcf" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">尽可能避免<code class="du ks kt ku kv b">null</code></li><li id="c702" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">没有业务例外</li></ul><p id="b426" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面，我们将更详细地探讨每个关键规则:</p><h2 id="ba0a" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">尽可能避免<code class="du ks kt ku kv b">null</code>(地图规则)</h2><p id="c7a9" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">变量的可空性是<a class="ae jd" href="https://dev.to/siy/leveraging-java-type-system-to-represent-special-states-688" rel="noopener ugc nofollow" target="_blank">特殊状态</a>之一。它们是运行时错误和样板代码的众所周知的来源。为了消除这些问题并表示可能丢失的值，PFJ使用了<a class="ae jd" href="https://github.com/siy/pragmatica/blob/main/core/src/main/java/org/pfj/lang/Option.java" rel="noopener ugc nofollow" target="_blank">选项</a>容器。这涵盖了可能出现这种值的所有情况—返回值、输入参数或字段。</p><p id="b06a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在某些情况下，例如出于性能或与现有框架兼容的原因，类可能会在内部使用<code class="du ks kt ku kv b">null</code>。这些情况必须清楚地记录下来，并且对类用户不可见，即所有的类API都应该使用<code class="du ks kt ku kv b">Option&lt;T&gt;</code>。</p><p id="324d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法有几个优点:</p><ul class=""><li id="fa76" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">可空变量在代码中立即可见。无需阅读文档/检查源代码/依赖注释。</li><li id="d3ba" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">编译器区分可空变量和不可空变量，并防止它们之间的不正确赋值。</li><li id="20c7" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">取消了<code class="du ks kt ku kv b">null</code>检查所需的所有样板文件。</li></ul><h2 id="376f" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">没有业务例外(NBE规则)</h2><p id="2503" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">PFJ只使用异常来代表致命的、不可恢复的(技术)故障。这种异常可能仅出于记录和/或应用程序正常关闭的目的而被拦截。不鼓励并尽可能避免所有其他异常及其拦截。</p><p id="3a09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">业务异常是<a class="ae jd" href="https://dev.to/siy/leveraging-java-type-system-to-represent-special-states-688" rel="noopener ugc nofollow" target="_blank">特殊状态</a>的另一种情况。对于业务级错误的传播和处理，PFJ使用<a class="ae jd" href="https://github.com/siy/pragmatica/blob/main/core/src/main/java/org/pfj/lang/Result.java" rel="noopener ugc nofollow" target="_blank">结果</a>容器。</p><p id="1c60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，这涵盖了可能出现错误的所有情况—返回值、输入参数或字段。实践表明，字段很少(如果有的话)需要使用这个容器。</p><p id="0eed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当可以使用业务级异常时，没有合理的情况。通过专用的包装方法实现与现有Java库和遗留代码的接口。<a class="ae jd" href="https://github.com/siy/pragmatica/blob/main/core/src/main/java/org/pfj/lang/Result.java" rel="noopener ugc nofollow" target="_blank">结果</a>容器包含这些包装方法的实现。</p><p id="3eb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ks kt ku kv b">No Business Exceptions</code>规则提供了以下优势:</p><ul class=""><li id="ec4c" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">可以返回错误的方法在代码中立即可见。无需阅读文档/检查源代码/分析调用树来检查哪些异常可以抛出以及在哪些条件下抛出。</li><li id="17f4" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">编译器强制执行正确的错误处理和传播。</li><li id="fcec" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">几乎没有错误处理和传播的样板文件。</li><li id="0d88" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">可以为<em class="kw">快乐日场景</em>编写代码，并在最方便的时候处理错误——这是异常的最初意图，但实际上从未实现。</li><li id="ea9a" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">代码仍然是可组合的，易于阅读和推理，在执行流程中没有隐藏的中断或意外的转换— <em class="kw">您所阅读的就是将要执行的</em>。</li></ul><h2 id="3b0e" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">将遗留代码转换为PFJ风格的代码</h2><p id="06ec" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">好吧，关键规则看起来很好很有用，但是真正的代码会是什么样子呢？</p><p id="8979" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从非常典型的后端代码开始:</p><blockquote class="kx ky kz"><p id="2952" class="if ig kw ih b ii ij ik il im in io ip la ir is it lb iv iw ix lc iz ja jb jc hb bi translated"><code class="du ks kt ku kv b">public interface UserRepository {<br/> User findById(User.Id userId);<br/>}<br/><br/>public interface UserProfileRepository {<br/> UserProfile findById(User.Id userId);<br/>}<br/><br/>public class UserService {<br/> private final UserRepository userRepository;<br/> private final UserProfileRepository userProfileRepository;<br/> <br/> public UserWithProfile getUserWithProfile(User.Id userId) {<br/> User user = userRepository.findById(userId);<br/> <br/> if (user == null) {<br/> throw UserNotFoundException("User with ID " + userId + " not found");<br/> }<br/> <br/> UserProfile details = userProfileRepository.findById(userId);<br/> <br/> return UserWithProfile.of(user, details == null <br/> ? UserProfile.defaultDetails()<br/> : details);<br/> }<br/>}</code></p></blockquote><p id="3726" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例开头的接口是为了上下文清晰而提供的。</p><p id="47ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">主要的兴趣点是<code class="du ks kt ku kv b">getUserWithProfile</code>方法。我们一步步来分析吧。</p><ul class=""><li id="8fde" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">第一条语句从用户存储库中检索<code class="du ks kt ku kv b">user</code>变量。</li><li id="5e73" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">由于用户可能不在存储库中，<code class="du ks kt ku kv b">user</code>变量可能是<code class="du ks kt ku kv b">null</code>。接下来的<code class="du ks kt ku kv b">null</code>检查验证是否是这种情况，如果是，则抛出业务异常。</li><li id="4c94" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">下一步是检索用户配置文件的详细信息。缺少细节不被认为是错误。相反，当缺少详细信息时，将为配置文件使用默认值。</li></ul><p id="cc7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码有几个问题。首先，从界面上看，如果值不在存储库中，则返回<code class="du ks kt ku kv b">null</code>。我们需要检查文档，研究实现或者猜测这些存储库是如何工作的。有时注释被用来提供提示，但是这仍然不能保证API的行为。</p><p id="cd12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，让我们对存储库应用<a class="ae jd" href="#avoid-null-as-much-as-possible-anamap-rule" rel="noopener ugc nofollow"> <em class="kw"> ANAMAP </em> </a>规则:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="90d6" class="je jf hi kv b fi ll lm l ln lo">public interface UserRepository {<br/>    Option&lt;User&gt; findById(User.Id userId);<br/>}<br/><br/>public interface UserProfileRepository {<br/>    Option&lt;UserProfile&gt; findById(User.Id userId);<br/>}</span></pre><p id="daa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在不需要做任何猜测——API明确地告诉我们返回值可能不存在。</p><p id="9664" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们再来看看<code class="du ks kt ku kv b">getUserWithProfile</code>方法。要注意的第二件事是，该方法可能返回值，也可能抛出异常。这是一个业务异常，所以我们可以应用<a class="ae jd" href="#no-business-exceptions-nbe-rule" rel="noopener ugc nofollow"> <em class="kw"> NBE </em> </a>规则。变更的主要目标——明确方法可能返回值<em class="kw">或</em>错误的事实:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="367d" class="je jf hi kv b fi ll lm l ln lo">public Result&lt;UserWithProfile&gt; getUserWithProfile(User.Id userId) {</span></pre><p id="cf91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，现在我们已经清理了API，可以开始修改代码了。第一个变化是由以下事实引起的，即<code class="du ks kt ku kv b">userRepository</code>现在返回<code class="du ks kt ku kv b">Option&lt;User&gt;</code>:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="b26e" class="je jf hi kv b fi ll lm l ln lo">public Result&lt;UserWithProfile&gt; getUserWithProfile(User.Id userId) {<br/>        Option&lt;User&gt; user = userRepository.findById(userId);<br/>    }</span></pre><p id="e8be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要检查用户是否存在，如果不存在，返回一个错误。对于传统的命令式方法，代码应该是这样的:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="963e" class="je jf hi kv b fi ll lm l ln lo">public Result&lt;UserWithProfile&gt; getUserWithProfile(User.Id userId) {<br/>        Option&lt;User&gt; user = userRepository.findById(userId);<br/>        <br/>        if (user.isEmpty()) {<br/>            return Result.failure(Causes.cause("User with ID " + userId + " not found"));<br/>        }<br/>    }</span></pre><p id="498e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码看起来不太吸引人，但也不比原始代码差，所以现在让我们保持原样。</p><p id="8288" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是尝试转换代码的剩余部分:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="a265" class="je jf hi kv b fi ll lm l ln lo">public Result&lt;UserWithProfile&gt; getUserWithProfile(User.Id userId) {<br/>        Option&lt;User&gt; user = userRepository.findById(userId);<br/>        <br/>        if (user.isEmpty()) {<br/>            return Result.failure(Causes.cause("User with ID " + userId + " not found"));<br/>        }<br/><br/>        Option&lt;UserProfile&gt; details = userProfileRepository.findById(userId);<br/>        <br/>    }</span></pre><p id="53b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">问题来了:细节和用户存储在<code class="du ks kt ku kv b">Option&lt;T&gt;</code>容器中，所以为了组装<code class="du ks kt ku kv b">UserWithProfile</code>,我们需要以某种方式提取值。这里可能有不同的方法，例如，使用<code class="du ks kt ku kv b">Option.fold()</code>法。生成的代码肯定不好看，而且很可能会违反<a class="ae jd" href="#avoid-null-as-much-as-possible-anamap-rule" rel="noopener ugc nofollow"> <em class="kw">反图</em> </a>规则。</p><p id="0a8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有另一种方法——利用<code class="du ks kt ku kv b">Option&lt;T&gt;</code>是一个具有特殊属性的<a class="ae jd" href="#brief-technical-overview-of-optiont-and-resultt" rel="noopener ugc nofollow">容器这一事实。特别是，可以使用<code class="du ks kt ku kv b">Option.map()</code>和<code class="du ks kt ku kv b">Option.flatMap()</code>方法转换<code class="du ks kt ku kv b">Option&lt;T&gt;</code>内部的值。此外，我们知道<code class="du ks kt ku kv b">details</code>值要么由存储库提供，要么替换为默认值。为此，我们可以使用<code class="du ks kt ku kv b">Option.or()</code>方法从容器中提取细节。让我们试试这些方法:</a></p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="e0da" class="je jf hi kv b fi ll lm l ln lo">public Result&lt;UserWithProfile&gt; getUserWithProfile(User.Id userId) {<br/>        Option&lt;User&gt; user = userRepository.findById(userId);<br/>        <br/>        if (user.isEmpty()) {<br/>            return Result.failure(Causes.cause("User with ID " + userId + " not found"));<br/>        }<br/><br/>        UserProfile details = userProfileRepository.findById(userId).or(UserProfile.defaultDetails());<br/>        <br/>        Option&lt;UserWithProfile&gt; userWithProfile =  user.map(userValue -&gt; UserWithProfile.of(userValue, details));<br/>        <br/>    }</span></pre><p id="de79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要编写最后一步——将<code class="du ks kt ku kv b">userWithProfile</code>容器从<code class="du ks kt ku kv b">Option&lt;T&gt;</code>转换为<code class="du ks kt ku kv b">Result&lt;T&gt;</code>:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="f551" class="je jf hi kv b fi ll lm l ln lo">public Result&lt;UserWithProfile&gt; getUserWithProfile(User.Id userId) {<br/>        Option&lt;User&gt; user = userRepository.findById(userId);<br/>        <br/>        if (user.isEmpty()) {<br/>            return Result.failure(Causes.cause("User with ID " + userId + " not found"));<br/>        }<br/><br/>        UserProfile details = userProfileRepository.findById(userId).or(UserProfile.defaultDetails());<br/><br/>        Option&lt;UserWithProfile&gt; userWithProfile =  user.map(userValue -&gt; UserWithProfile.of(userValue, details));<br/><br/>        return userWithProfile.toResult(Cause.cause(""));<br/>    }</span></pre><p id="28b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们暂时将<code class="du ks kt ku kv b">return</code>语句中的错误原因保留为空，并再次查看代码。我们很容易发现一个问题:我们肯定知道<code class="du ks kt ku kv b">userWithProfile</code>总是存在——当<code class="du ks kt ku kv b">user</code>不存在时，上面已经处理过了。我们如何解决这个问题？</p><p id="d90a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我们可以调用<code class="du ks kt ku kv b">user.map()</code>而不检查用户是否存在。仅当<code class="du ks kt ku kv b">user</code>存在时，转换才会被应用，否则会被忽略。这样，我们可以消除<code class="du ks kt ku kv b">if(user.isEmpty())</code>检查。让我们将<code class="du ks kt ku kv b">details</code>的检索和<code class="du ks kt ku kv b">User</code>到<code class="du ks kt ku kv b">UserWithProfile</code>的转换移到传递给<code class="du ks kt ku kv b">user.map()</code>的lambda中:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="ca8c" class="je jf hi kv b fi ll lm l ln lo">public Result&lt;UserWithProfile&gt; getUserWithProfile(User.Id userId) {<br/>        Option&lt;UserWithProfile&gt; userWithProfile = userRepository.findById(userId).map(userValue -&gt; {<br/>            UserProfile details = userProfileRepository.findById(userId).or(UserProfile.defaultDetails());<br/>            return UserWithProfile.of(userValue, details);<br/>        });<br/>        <br/>        return userWithProfile.toResult(Cause.cause(""));<br/>    }</span></pre><p id="0281" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在需要更改最后一行，因为<code class="du ks kt ku kv b">userWithProfile</code>可能会丢失。错误将与前一版本相同，因为只有当<code class="du ks kt ku kv b">userRepository.findById(userId)</code>返回的值丢失时<code class="du ks kt ku kv b">userWithProfile</code>才可能丢失:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="97b7" class="je jf hi kv b fi ll lm l ln lo">public Result&lt;UserWithProfile&gt; getUserWithProfile(User.Id userId) {<br/>        Option&lt;UserWithProfile&gt; userWithProfile = userRepository.findById(userId).map(userValue -&gt; {<br/>            UserProfile details = userProfileRepository.findById(userId).or(UserProfile.defaultDetails());<br/>            return UserWithProfile.of(userValue, details);<br/>        });<br/>        <br/>        return userWithProfile.toResult(Causes.cause("User with ID " + userId + " not found"));<br/>    }</span></pre><p id="dff6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们可以内联<code class="du ks kt ku kv b">details</code>和<code class="du ks kt ku kv b">userWithProfile</code>，因为它们只在创建后立即使用一次:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="7519" class="je jf hi kv b fi ll lm l ln lo">public Result&lt;UserWithProfile&gt; getUserWithProfile(User.Id userId) {<br/>        return userRepository.findById(userId)<br/>            .map(userValue -&gt; UserWithProfile.of(userValue, userProfileRepository.findById(userId)<br/>                                                                                 .or(UserProfile.defaultDetails())))<br/>            .toResult(Causes.cause("User with ID " + userId + " not found"));<br/>    }</span></pre><p id="fe4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意缩进是如何帮助将代码分组为逻辑链接的部分的。</p><p id="db58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们分析结果代码。</p><ul class=""><li id="9b3f" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">代码更加简洁，是为<code class="du ks kt ku kv b">happy day scenario</code>编写的，没有明显的错误或<code class="du ks kt ku kv b">null</code>检查，没有对业务逻辑的干扰</li><li id="8dfc" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">没有简单的方法可以跳过或避免错误或<code class="du ks kt ku kv b">null</code>检查，编写正确可靠的代码是简单而自然的。</li></ul><p id="2793" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不太明显的观察结果:</p><ul class=""><li id="4216" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">所有类型都是自动派生的。这简化了重构并消除了不必要的混乱。如果需要，仍然可以添加类型。</li><li id="5634" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">如果在某个时候存储库将开始返回<code class="du ks kt ku kv b">Result&lt;T&gt;</code>而不是<code class="du ks kt ku kv b">Option&lt;T&gt;</code>，代码将保持不变，除了最后的转换(<code class="du ks kt ku kv b">toResult</code>)将被移除。</li><li id="059b" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">除了用<code class="du ks kt ku kv b">Option.or()</code>方法替换三元运算符之外，产生的代码看起来很像我们将代码从lambda内部的原始<code class="du ks kt ku kv b">return</code>语句转移到<code class="du ks kt ku kv b">map()</code>方法。</li></ul><p id="0b25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一个观察对于开始方便地编写(阅读通常不是问题)PFJ风格的代码非常有用。可以改写成以下经验法则:<em class="kw">在右边找值</em>。只需比较:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="7284" class="je jf hi kv b fi ll lm l ln lo">User user = userRepository.findById(userId);    // &lt;-- value is on the left side of the expression</span></pre><p id="63b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="269f" class="je jf hi kv b fi ll lm l ln lo">return userRepository.findById(userId)<br/>                      .map(user -&gt; ...); // &lt;-- value is on the right side of the expression</span></pre><p id="e64b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个有用的观察有助于从遗留命令式代码风格到PFJ的转换。</p><h2 id="6664" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">与遗留代码接口</h2><p id="878f" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">不用说，现有的法规没有遵循PFJ的方法。它抛出异常，返回<code class="du ks kt ku kv b">null</code>等等。有时可以修改这些代码，使其与PFJ兼容，但通常情况并非如此。对于外部库和框架来说尤其如此。</p><h2 id="9de5" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">调用遗留代码</h2><p id="fa31" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">遗留代码调用有两个主要问题。它们中的每一个都与违反相应的PFJ规则有关:</p><h2 id="6681" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">处理业务异常</h2><p id="a70f" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated"><code class="du ks kt ku kv b">Result&lt;T&gt;</code>包含一个名为<code class="du ks kt ku kv b">lift()</code>的助手方法，它涵盖了大多数用例。方法签名看起来是这样的:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="6a58" class="je jf hi kv b fi ll lm l ln lo">static &lt;R&gt; Result&lt;R&gt; lift(FN1&lt;? extends Cause, ? super Throwable&gt; exceptionMapper, ThrowingSupplier&lt;R&gt; supplier)</span></pre><p id="5a73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个参数是将一个异常转换成<code class="du ks kt ku kv b">Cause</code>实例的函数(它反过来用于在失败的情况下创建<code class="du ks kt ku kv b">Result&lt;T&gt;</code>实例)。</p><p id="5374" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个参数是lambda，它包装了对需要与PFJ兼容的实际代码的调用。</p><p id="870b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du ks kt ku kv b">Causes</code>实用程序类:<code class="du ks kt ku kv b">fromThrowable()</code>中提供了最简单的函数，它将异常转换为<code class="du ks kt ku kv b">Cause</code>的实例。与<code class="du ks kt ku kv b">Result.lift()</code>一起，它们可以如下使用:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="5c4e" class="je jf hi kv b fi ll lm l ln lo">public static Result&lt;URI&gt; createURI(String uri) {<br/>    return Result.lift(Causes::fromThrowable, () -&gt; URI.create(uri));<br/>}</span></pre><h2 id="163b" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">处理<code class="du ks kt ku kv b">null</code>值返回</h2><p id="0fb1" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">这种情况相当简单——如果API可以返回<code class="du ks kt ku kv b">null</code>,只需使用<code class="du ks kt ku kv b">Option.option()</code>方法将其包装到<code class="du ks kt ku kv b">Option&lt;T&gt;</code>中。</p><h2 id="c7ae" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">提供传统API</h2><p id="0a51" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">有时有必要允许遗留代码调用以PFJ风格编写的代码。特别是，当一些较小的子系统被转换为PFJ风格，但是系统的其余部分仍然以旧风格编写并且API需要保留时，这种情况经常发生。</p><p id="3bda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最方便的方法是将实现分成两部分——PFJ风格的API和适配器，它只使新API适应旧API。下面是非常有用的简单帮助器方法，如下所示:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="1ddd" class="je jf hi kv b fi ll lm l ln lo">public static &lt;T&gt; T unwrap(Result&lt;T&gt; value) {<br/>    return value.fold(<br/>        cause -&gt; { throw new IllegalStateException(cause.message()); },<br/>        content -&gt; content<br/>    );<br/>}</span></pre><p id="9200" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于以下原因，<code class="du ks kt ku kv b">Result&lt;T&gt;</code>中没有提供随时可用的帮助器方法:</p><ul class=""><li id="68fc" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">可能有不同的用例，并且可能抛出不同类型的异常(检查的和未检查的)。</li><li id="b23f" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">将<code class="du ks kt ku kv b">Cause</code>转换成不同的特定异常严重依赖于特定的用例。</li></ul><h2 id="1cb2" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">管理变量范围</h2><p id="1054" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">这一部分将致力于编写PFJ风格代码时出现的各种实际案例。</p><p id="21d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下示例假设使用<code class="du ks kt ku kv b">Result&lt;T&gt;</code>，但这在很大程度上是不相关的，因为所有考虑因素也适用于<code class="du ks kt ku kv b">Option&lt;T&gt;</code>。此外，示例假设示例中调用的函数被转换为返回<code class="du ks kt ku kv b">Result&lt;T&gt;</code>而不是抛出异常。</p><h2 id="47a9" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">嵌套范围</h2><p id="1ad1" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">函数式代码大量使用lambdas来执行<code class="du ks kt ku kv b">Option&lt;T&gt;</code>和<code class="du ks kt ku kv b">Result&lt;T&gt;</code>容器中的值的计算和转换。每个lambda都隐式地为它们的参数创建了作用域——它们在lambda主体内部是可访问的，但在主体外部是不可访问的。一般来说，这是一个有用的属性，但是对于传统的命令式代码来说，这是很不寻常的，可能一开始会觉得不方便。幸运的是，有一个简单的技术可以克服感觉到的不便。</p><p id="6bd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看下面的命令式代码:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="c691" class="je jf hi kv b fi ll lm l ln lo">var value1 = function1(...);                    // function1() may throw exception<br/>var value2 = function2(value1, ...);            // function2() may throw exception<br/>var value3 = function3(value1, value2, ...);    // function3() may throw exception</span></pre><p id="d422" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">变量<code class="du ks kt ku kv b">value1</code>应该可以被<code class="du ks kt ku kv b">function2()</code>和<code class="du ks kt ku kv b">function3()</code>调用。这确实意味着简单地转换成PFJ风格是行不通的:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="abf9" class="je jf hi kv b fi ll lm l ln lo">function1(...)<br/>       .flatMap(value1 -&gt; function2(value1, ...))<br/>       .flatMap(value2 -&gt; function3(value1, value2, ...)); // &lt;-- ERROR, value1 is not accessible!</span></pre><p id="2508" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了保持值的可访问性，我们需要使用<em class="kw">嵌套作用域</em>，即如下嵌套调用:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="0854" class="je jf hi kv b fi ll lm l ln lo">function1(...)<br/>       .flatMap(value1 -&gt; function2(value1, ...)<br/>           .flatMap(value2 -&gt; function3(value1, value2, ...)));</span></pre><p id="7201" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对<code class="du ks kt ku kv b">flatMap()</code>的第二次调用是针对<code class="du ks kt ku kv b">function2</code>返回的值，而不是针对第一次<code class="du ks kt ku kv b">flatMap()</code>返回的值。通过这种方式，我们将<code class="du ks kt ku kv b">value1</code>保留在范围内，并使其可被<code class="du ks kt ku kv b">function3</code>访问。</p><p id="5153" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管可以任意深度嵌套作用域，但通常超过两个嵌套作用域会更难阅读和理解。在这种情况下，强烈建议将更深的作用域提取到专用函数中。</p><h2 id="89f5" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">平行范围</h2><p id="9da6" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">另一个常见的情况是需要计算/检索几个独立的值，然后进行调用或构建一个对象。让我们看看下面的例子:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="5887" class="je jf hi kv b fi ll lm l ln lo">var value1 = function1(...);    // function1() may throw exception<br/>var value2 = function2(...);    // function2() may throw exception<br/>var value3 = function3(...);    // function3() may throw exception<br/><br/>return new MyObject(value1, value2, value3);</span></pre><p id="9cad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">乍一看，向PFJ风格的转换可以完全按照<a class="ae jd" href="#nested-scopes" rel="noopener ugc nofollow">嵌套作用域</a>来完成。每个值的可见性将与命令式代码相同。不幸的是，这将使作用域嵌套得很深，尤其是在需要获取很多值的情况下。</p><p id="058e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于这种情况，<code class="du ks kt ku kv b">Option&lt;T&gt;</code>和<code class="du ks kt ku kv b">Result&lt;T&gt;</code>提供了一套<code class="du ks kt ku kv b">all()</code>方法。这些方法执行所有值的“并行”计算，并返回专用版本的<code class="du ks kt ku kv b">MapperX&lt;...&gt;</code>接口。这个接口只有三个方法- <code class="du ks kt ku kv b">id()</code>、<code class="du ks kt ku kv b">map()</code>和<code class="du ks kt ku kv b">flatMap()</code>。<code class="du ks kt ku kv b">map()</code>和<code class="du ks kt ku kv b">flatMap()</code>方法的工作方式与<code class="du ks kt ku kv b">Option&lt;T&gt;</code>和<code class="du ks kt ku kv b">Result&lt;T&gt;</code>中的相应方法完全相同，只是它们接受的lambdas参数数量不同。让我们看看它在实践中是如何工作的，并将上面的命令式代码转换成PFJ风格:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="f317" class="je jf hi kv b fi ll lm l ln lo">return Result.all(<br/>          function1(...), <br/>          function2(...), <br/>          function3(...)<br/>        ).map(MyObject::new);</span></pre><p id="798a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了紧凑和扁平之外，这种方法没有更多的优点。首先，它明确表达了意图——在使用之前计算所有值。命令式代码按顺序执行，隐藏了原始意图。第二个优势—每个值的计算都是独立的，不会将不必要的值带入范围。这减少了理解和推理每个函数调用所需的上下文。</p><h2 id="0a90" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">替代范围</h2><p id="905a" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">一种不太常见但仍然重要的情况是，当我们需要检索值时，但是如果它不可用，那么我们使用值的替代来源。有多种选择的情况就更少了，但是当涉及到错误处理时就更痛苦了。</p><p id="a34c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看下面的命令式代码:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="de54" class="je jf hi kv b fi ll lm l ln lo">MyType value;<br/><br/>try {<br/>    value = function1(...);<br/>} catch (MyException e1) {<br/>    try {<br/>        value = function2(...);    <br/>    } catch(MyException e2) {<br/>        try {<br/>            value = function3(...);<br/>        } catch(MyException e3) {<br/>            ... // repeat as many times as there are alternatives <br/>        }<br/>    }<br/>}</span></pre><p id="af28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码有些做作，因为嵌套的案例通常隐藏在其他方法中。然而，整体逻辑远非简单，主要是因为除了选择值之外，我们还需要处理错误。错误处理使代码变得混乱，并使最初的意图—选择第一个可用的替代方案—隐藏在错误处理中。</p><p id="0665" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">向PFJ风格的转变让意图昭然若揭:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="f308" class="je jf hi kv b fi ll lm l ln lo">var value = Result.any(<br/>        function1(...),<br/>        function2(...),<br/>        function3(...)<br/>    );</span></pre><p id="69ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不幸的是，这里有一个重要的区别:最初的命令式代码只在必要时才计算第二个和随后的选项。在某些情况下，这不是一个问题，但在许多情况下，这是非常不可取的。还好有<code class="du ks kt ku kv b">Result.any()</code>的懒人版。使用它，我们可以重写代码如下:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="86fb" class="je jf hi kv b fi ll lm l ln lo">var value = Result.any(<br/>        function1(...),<br/>        () -&gt; function2(...),<br/>        () -&gt; function3(...)<br/>    );</span></pre><p id="06e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，转换后的代码的行为与命令式代码完全一样。</p><h2 id="5564" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><code class="du ks kt ku kv b">Option&lt;T&gt;</code>和<code class="du ks kt ku kv b">Result&lt;T&gt;</code>的简要技术概述</h2><p id="d241" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">在函数式编程术语中，这两个容器是<a class="ae jd" href="https://dev.to/siy/beautiful-world-of-mondas-2cd6" rel="noopener ugc nofollow" target="_blank">单子</a>。</p><p id="ca49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ks kt ku kv b">Option&lt;T&gt;</code>是<code class="du ks kt ku kv b">Option/Optional/Maybe</code>单子的简单实现。</p><p id="aacf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ks kt ku kv b">Result&lt;T&gt;</code>是<code class="du ks kt ku kv b">Either&lt;L,R&gt;</code>的有意简化和专门化版本:左类型是固定的，应该实现<code class="du ks kt ku kv b">Cause</code>接口。专门化使得API与<code class="du ks kt ku kv b">Option&lt;T&gt;</code>非常相似，以丧失通用性和通用性为代价，消除了大量不必要的键入。</p><p id="a899" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种特殊的实现集中在两件事上:</p><ul class=""><li id="f502" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">彼此之间以及与现有JDK类(如<code class="du ks kt ku kv b">Optional&lt;T&gt;</code>和<code class="du ks kt ku kv b">Stream&lt;T&gt;</code>)之间的互操作性</li><li id="e4dc" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">API旨在明确表达意图</li></ul><p id="7be8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一句话值得更深入的解释。</p><p id="93dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个容器都有几个<em class="kw">核心</em>方法:</p><ul class=""><li id="902b" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">工厂方法</li><li id="deb0" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><code class="du ks kt ku kv b">map()</code>转换方法，转换值但不改变<em class="kw">特殊状态</em> : present <code class="du ks kt ku kv b">Option&lt;T&gt;</code>保持存在，success <code class="du ks kt ku kv b">Result&lt;T&gt;</code>保持成功。</li><li id="2cf1" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><code class="du ks kt ku kv b">flatMap()</code>转换方法，除了转换之外，还可以改变<em class="kw">特殊状态</em>:将当前<code class="du ks kt ku kv b">Option&lt;T&gt;</code>转换为空或者将成功<code class="du ks kt ku kv b">Result&lt;T&gt;</code>转换为失败。</li><li id="a63d" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated"><code class="du ks kt ku kv b">fold()</code>方法，一次处理两种情况(<code class="du ks kt ku kv b">Option&lt;T&gt;</code>存在/空，<code class="du ks kt ku kv b">Result&lt;T&gt;</code>成功/失败)。</li></ul><p id="338a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了<em class="kw">核心</em>方法，还有一堆<em class="kw">助手</em>方法，它们在经常观察到的用例中很有用。在这些方法中，有一组方法被明确设计为产生<em class="kw">副作用</em>。</p><p id="bf41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ks kt ku kv b">Option&lt;T&gt;</code>对<em class="kw">副作用</em>有以下方法:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="49af" class="je jf hi kv b fi ll lm l ln lo">Option&lt;T&gt; whenPresent(Consumer&lt;? super T&gt; consumer);<br/>Option&lt;T&gt; whenEmpty(Runnable action);<br/>Option&lt;T&gt; apply(Runnable emptyValConsumer, Consumer&lt;? super T&gt; nonEmptyValConsumer);</span></pre><p id="ca29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ks kt ku kv b">Result&lt;T&gt;</code>对<em class="kw">副作用</em>有以下方法:</p><pre class="ld le lf lg fd lh kv li lj aw lk bi"><span id="19e5" class="je jf hi kv b fi ll lm l ln lo">Result&lt;T&gt; onSuccess(Consumer&lt;T&gt; consumer);<br/>Result&lt;T&gt; onSuccessDo(Runnable action);<br/>Result&lt;T&gt; onFailure(Consumer&lt;? super Cause&gt; consumer);<br/>Result&lt;T&gt; onFailureDo(Runnable action);<br/>Result&lt;T&gt; apply(Consumer&lt;? super Cause&gt; failureConsumer, Consumer&lt;? super T&gt; successConsumer);</span></pre><p id="87c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些方法向读者暗示代码处理的是副作用而不是转换。</p><h2 id="4599" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">其他有用的工具</h2><p id="7bcf" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">除了<code class="du ks kt ku kv b">Option&lt;T&gt;</code>和<code class="du ks kt ku kv b">Result&lt;T&gt;</code>，PFJ还使用了其他一些通用类。下面，将详细介绍每一种方法。</p><h2 id="7245" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">功能</h2><p id="1808" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">JDK提供了许多有用的功能接口。不幸的是，通用函数的函数接口仅限于两个版本:单参数<code class="du ks kt ku kv b">Function&lt;T, R&gt;</code>和双参数<code class="du ks kt ku kv b">BiFunction&lt;T, U, R&gt;</code>。</p><p id="0cdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然，这在很多实际情况下是不够的。此外，由于某种原因，这些函数的类型参数与Java中函数的声明方式相反:结果类型列在最后，而在函数声明中，它是首先定义的。</p><p id="16d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PFJ为具有1到9个参数的函数使用一组一致的函数接口。为简便起见，它们被称为<code class="du ks kt ku kv b">FN1</code>...<code class="du ks kt ku kv b">FN9</code>。到目前为止，还没有带有更多参数的函数的用例(通常这是一种代码味道)。但是，如果有必要的话，这个清单可以进一步扩大。</p><h2 id="6222" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">元组</h2><p id="5ac2" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">元组是一种特殊的容器，可以用来在一个变量中存储不同类型的几个值。与类或记录不同，存储在内部的值没有名称。这使得它们成为在保留类型的同时捕获任意一组值的不可或缺的工具。这个用例的一个很好的例子是<code class="du ks kt ku kv b">Result.all()</code>和<code class="du ks kt ku kv b">Option.all()</code>组方法的实现。</p><p id="1703" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在某种意义上，元组可以被认为是为函数调用准备的一组<em class="kw">冻结的参数</em>。从这个角度来看，让元组内部值只能通过<code class="du ks kt ku kv b">map()</code>方法访问的决定听起来很合理。然而，有两个参数的元组有额外的访问器，这使得使用<code class="du ks kt ku kv b">Tuple2&lt;T1,T2&gt;</code>作为各种<code class="du ks kt ku kv b">Pair&lt;T1,T2&gt;</code>实现的替代成为可能。</p><p id="b406" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PFJ使用具有0到9个值的一组一致的元组实现。提供具有0和1值的元组是为了一致性。</p><h2 id="d44c" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">结论</h2><p id="6fce" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">实用函数式Java是一种基于函数式编程概念的现代、非常简洁但可读的Java编码风格。与传统的惯用Java编码风格相比，它提供了许多好处:</p><ul class=""><li id="8279" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">PFJ使用Java编译器来帮助编写可靠的代码:</li><li id="bdad" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">编译的代码通常是有效的</li><li id="9c7c" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">许多错误从运行时转移到了编译时</li><li id="e39a" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">一些种类的错误，像<code class="du ks kt ku kv b">NullPointerException</code>或未处理的异常，实际上被消除了</li><li id="563f" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">PFJ显著减少了与错误传播和处理相关的样板代码的数量，以及<code class="du ks kt ku kv b">null</code>检查</li><li id="bb8a" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">PFJ专注于清晰地表达意图和减少精神开销</li></ul></div></div>    
</body>
</html>