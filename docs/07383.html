<html>
<head>
<title>Understanding Ethereum From the Ground Up (Data Storage)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始理解以太坊(数据存储)</h1>
<blockquote>原文：<a href="https://medium.com/codex/understanding-ethereum-from-the-ground-up-data-storage-2b55022aa663?source=collection_archive---------19-----------------------#2022-06-13">https://medium.com/codex/understanding-ethereum-from-the-ground-up-data-storage-2b55022aa663?source=collection_archive---------19-----------------------#2022-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d001a6e504416eaf74a7f39e61189be3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6rx2Nr_vM5Q21S5YAnrTg.png"/></div></div></figure><p id="d918" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">前言:</strong>下面这篇文章旨在巩固知识，就像我了解以太坊一样。如果任何信息是不正确的，部分不正确的，或不完整的，我竭诚欢迎您的投入。</p><p id="b155" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目的:</strong>我有一种感觉，正确理解以太坊数据存储所必需的信息是高度碎片化的，并且缺乏说明性的例子。本文旨在通过巩固和澄清以太坊如何存储数据的知识来解决这个问题。</p><p id="04de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">文章结构:</strong>在本文中，我们将介绍以下概念:</p><ul class=""><li id="83ea" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">存储了哪些以太坊数据</li><li id="d2bd" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">以太坊数据的存储位置(分布式数据库)</li><li id="20ed" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">以太坊数据是如何存储的(数据结构)</li><li id="dbf0" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">编码如何为哈希奠定基础</li><li id="6f63" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">Merkle Patricia Trie示例</li></ul><h1 id="ff52" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">存储了哪些数据？</h1><p id="d157" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">区块链是链接(严格格式化)的数据组(“块”)的“链”。在以太坊区块链中，添加到“数据块链”中的每个新数据块都包含:</p><ul class=""><li id="eb28" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">一个块标题</strong></li><li id="ae12" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">以太坊交易列表</strong></li><li id="30ea" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">“ommer”(大叔)块头列表</strong>，与上述块头格式相同</li></ul><p id="14e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们把重点放在块头上，因为它与我们讨论的数据存储最相关。下图A摘自Preethi Kasireddy的文章，“<a class="ae lf" href="https://www.preethikasireddy.com/post/how-does-ethereum-work-anyway" rel="noopener ugc nofollow" target="_blank">以太坊到底是如何工作的？</a>“清楚的说明了块头中包含的信息(我稍微修改了一下):</p><p id="65e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">图一:</strong></p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/88d48ab768c94b9e4efdb7bbd3a44265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1imd_5tNTfs678Evi5yIig.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">来源:<a class="ae lf" href="https://www.preethikasireddy.com/post/how-does-ethereum-work-anyway" rel="noopener ugc nofollow" target="_blank">https://www . preethikasireddy . com/post/how-does-ether eum-work-anyway</a></figcaption></figure><p id="b412" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于数据存储，<strong class="is hj"> stateRoot </strong>、<strong class="is hj"> transactionsRoot </strong>和<strong class="is hj"> receiptsRoot </strong>很重要，因为它们代表三个独立的“Merkle Patricia Tries”(一种以太坊特有的数据结构)的根节点的<strong class="is hj"> Keccak 256位</strong>散列。我们将在下面详细介绍这种数据结构。这三个try都存储键值对，因此出于我们的目的，我们将使用符号来表示它们，<code class="du lp lq lr ls b">key</code> <strong class="is hj"> → </strong> <code class="du lp lq lr ls b">value</code>。</p><ul class=""><li id="f3c4" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><code class="du lp lq lr ls b"><strong class="is hj">stateRoot</strong></code><strong class="is hj">:</strong><strong class="is hj">世界状态Trie，</strong> <strong class="is hj"> <em class="lt"> σ的Keccak 256位散列。</em> </strong>这个trie包含了地址、<strong class="is hj"> <em class="lt"> a </em> </strong>和账户状态、<strong class="is hj"> <em class="lt"> σ </em> [ <em class="lt"> a </em>之间的映射。</strong>更具体地说，键值映射是以太坊公共地址的<strong class="is hj"> Keccak 256位</strong>hash<code class="du lp lq lr ls b">keccak(<em class="lt">a</em>)</code>到“RLP”编码的账户对象<code class="du lp lq lr ls b">RLP(accountState)</code>之间的映射，可以表示为<code class="du lp lq lr ls b">keccak(ethereumAddress)</code> <strong class="is hj"> → </strong> <code class="du lp lq lr ls b"><strong class="is hj"> </strong>RLP(accountState)</code>。如果不清楚什么是以太坊账户或账户状态，请参阅我之前关于以太坊账户的文章。此外，我们将在下面讨论RLP编码。如黄皮书所示，图B描述了世界状态的正式表示:</li></ul><p id="5df7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">图B: </strong></p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/55fed0b8c76dbecfd0a04f15a590c549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YbkygyoYknyFs4VLgd0eXA.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">以太坊黄皮书的世界状态解释。</figcaption></figure><ul class=""><li id="344f" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><code class="du lp lq lr ls b"><strong class="is hj">transactionsRoot</strong></code> <strong class="is hj"> : </strong>用块的事务列表部分中的每个事务填充的trie结构的根节点的Keccak 256位哈希。每个新块都有自己的事务trie，其中键-值对采用的形式是，<code class="du lp lq lr ls b">RLP(transactionIndex)<strong class="is hj"> </strong></code> <strong class="is hj"> → </strong> <code class="du lp lq lr ls b">RLP(ethereumTransaction)</code>，其中<code class="du lp lq lr ls b">transactionIndex</code>是指其块中某个事务的索引，<code class="du lp lq lr ls b">ethereumTransaction</code>是以太坊事务对象。一旦挖掘出来，这个trie就不可改变。</li><li id="f45f" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><code class="du lp lq lr ls b"><strong class="is hj">receiptsRoot</strong></code><strong class="is hj">:</strong>trie结构的根节点的Keccak 256位哈希，该结构由块的事务列表部分中每个事务的收据填充。与事务尝试类似，每个块都有自己的收据trie，其中键-值对采用的形式是，<code class="du lp lq lr ls b">RLP(transactionIndex)</code> <strong class="is hj"> → </strong> <code class="du lp lq lr ls b">RLP(transactionReceipt)</code>，其中<code class="du lp lq lr ls b">transactionIndex</code>指的是其块内事务的索引，<code class="du lp lq lr ls b">transactionReceipt</code>是以太坊事务收据对象。一旦被挖掘，这个trie也是不可变的。</li></ul><p id="dcec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图C中的下图清楚地说明了上述概念。即组成一个块的组件以及<code class="du lp lq lr ls b">stateRoots</code>、<code class="du lp lq lr ls b">transactionsRoots</code>和<code class="du lp lq lr ls b">receiptsRoots</code>所代表的数据。值得花些时间来消化这张图片，因为它是信息密集型的。</p><p id="74f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">图C: </strong></p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/2c887d5664ede0ef0812cbe631ded7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-p-Z4u8rDgRhJ8hsIHJrg.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">来源:<a class="ae lf" href="https://i.stack.imgur.com/afWDt.jpg" rel="noopener ugc nofollow" target="_blank">https://i.stack.imgur.com/afWDt.jpg</a></figcaption></figure><h1 id="69ee" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">数据存储在哪里？</h1><p id="6b69" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">正如我在之前关于以太坊账户的文章中提到的，以太坊是一个计算机网络，每个计算机都运行软件，称为以太坊客户端。客户端软件安装还会安装一个键值存储库(一种数据库)，如<a class="ae lf" href="https://github.com/google/leveldb" rel="noopener ugc nofollow" target="_blank"> LevelDB </a>或<a class="ae lf" href="http://rocksdb.org/" rel="noopener ugc nofollow" target="_blank"> RocksDB </a>。每个节点将其数据存储在其安装的键值存储库中，这导致相同的数据分布在相同类型的所有节点中——请记住，有不同类型的节点:<a class="ae lf" href="https://www.quicknode.com/guides/infrastructure/ethereum-full-node-vs-archive-node" rel="noopener ugc nofollow" target="_blank">归档节点、完整节点和轻型节点</a>。为了说明这一想法，见下图D:</p><p id="2e78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">图D: </strong></p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/c5ea4e625002c388d968b192f60c52cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOjdsox2v4w6ZXgHDEq9gw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">节点网络，其中每个节点都有自己的数据库。</figcaption></figure><h1 id="b538" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">数据是如何存储的？</h1><p id="f8b4" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">现在我们知道了存储的是什么数据以及它驻留在哪里，让我们讨论一下它是如何存储的。从上面，我们知道以太坊使用了一种键值存储机制。明确地说，键值存储库存储键值对。作为一个高级的例子，考虑类似于<a class="ae lf" href="https://www.w3schools.com/python/python_dictionaries.asp" rel="noopener ugc nofollow" target="_blank"> Python字典</a>或<a class="ae lf" href="https://www.w3schools.com/js/js_objects.asp" rel="noopener ugc nofollow" target="_blank"> JavaScript对象</a>的东西。这意味着无论使用什么数据结构，最终都必须很好地适应键值存储结构。此外，由于每个完整节点都复制存储的数据，因此尽可能压缩数据以节省存储空间非常重要。为了实现上述两个目标，以太坊采用了一种叫做“改进的Merkle Patricia Trie”的数据结构。</p><h1 id="f225" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">默克尔帕特里夏试图解释说</h1><h2 id="0dac" class="lx kd hi bd ke ly lz ma ki mb mc md km jb me mf kq jf mg mh ku jj mi mj ky mk bi translated"><strong class="ak">键值结构</strong></h2><p id="e739" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">Merkle Patricia Trie是一种独特的数据结构，它结合了Patricia Trie的数据压缩元素和Merkle树的确定性散列属性。Merkle Patricia Trie中的一个“节点”可以被认为是一个更大的Trie结构中的一个小数据结构，所有节点都必须适合一个键值数据库。为了实现这一点，每个键-值对采用的形式是，<code class="du lp lq lr ls b"><strong class="is hj">keccak(RLP(node))</strong></code> <strong class="is hj"> → </strong> <code class="du lp lq lr ls b"><strong class="is hj">RLP(node)</strong></code>。为了清楚起见，每个键都是其对应值的散列。也就是说，从上面，我们知道<code class="du lp lq lr ls b">stateRoots</code>、<code class="du lp lq lr ls b">transactionsRoots</code>和<code class="du lp lq lr ls b">receiptsRoots</code>是存储<em class="lt">它们自己的</em>键-值对的尝试的散列——这意味着这三个尝试的键<em class="lt">和</em>值必须存储在<code class="du lp lq lr ls b"><strong class="is hj">nodes</strong></code>中。更具体地说，它们存储在父节点和子节点的序列中，这些节点构成了整个Merkle Patricia Trie数据结构。在上面的键值对中，<strong class="is hj"> RLP </strong>代表“递归长度前缀”编码。编码用于以可用于某些用例的方式表示数据。这里的用例是将<strong class="is hj">节点</strong>(一个子数据结构)转换成可以被散列的格式，因为<strong class="is hj">散列函数需要以</strong> <a class="ae lf" href="https://stackoverflow.com/questions/4019837/what-do-we-mean-by-byte-array#:~:text=A%20byte%20array%20is%20simply,%2C%20the%20second%20byte%20etc.." rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">字节数组</strong> </a>的形式输入数据。RLP编码算法正是实现了这一点:它将一个结构化的节点转换成一个字节数组，这样它就可以被散列。</p><h2 id="dcf2" class="lx kd hi bd ke ly lz ma ki mb mc md km jb me mf kq jf mg mh ku jj mi mj ky mk bi translated"><strong class="ak">让我们提高储物效率(Patricia Trie影响力)</strong></h2><p id="e801" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">给定大量的十六进制键(RLP编码的节点的散列)，很可能许多键将共享公共“路径”，这些路径是许多键之间共享的、非发散的字符子集。例如，“car”和“cars”这两个词共用一个路径，“car”。从这个意义上来说，共同的道路类似于(有机的)树的主干，而分歧的道路类似于它的分支。如果多个键共享相同的路径，那么单独存储所有的键就是多余的。公共路径只需要存储一次，而分歧分支路径可以在分歧字符的点上专门处理。这样的存储结构被称为<strong class="is hj">前缀Trie </strong>。也就是说，存储效率仍然可以提高:如果一个节点只有一个子节点，或者如果对于给定的数据集出现了一系列的单个子节点，那么这个单个子节点的序列可以压缩成一个节点。这样的结构被称为<strong class="is hj">帕特丽夏·特里</strong>。一个Patricia Trie规定所有<em class="lt">内部</em> <em class="lt">节点</em>必须至少有两个子节点。图E摘自卡米尔·耶泽克的论文“<a class="ae lf" href="https://arxiv.org/pdf/2108.05513.pdf" rel="noopener ugc nofollow" target="_blank">以太坊数据结构</a>”，描述了Prefix和Patricia试图存储一组给定的二进制密钥。然而，在以太坊中，密钥是十六进制字符，而不是二进制数字。正是这种数据压缩技术解释了Merkle Patricia Trie的“Patricia”部分。</p><p id="4113" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">图E: </strong></p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/f0a0fd88161444ddcaf96f7a6438fff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wi0SLLZK6Yndic9J99013g.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">资料来源:https://arxiv.org/pdf/2108.05513.pdf</figcaption></figure><h2 id="d1e9" class="lx kd hi bd ke ly lz ma ki mb mc md km jb me mf kq jf mg mh ku jj mi mj ky mk bi translated"><strong class="ak"> Merkle Patricia Trie节点类型</strong></h2><p id="bb2e" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">为了实现上述数据压缩，Merkle Patrica Trie使用了三种类型的节点。请记住，Merkle Patrica Trie中的键值对采用的形式是，<code class="du lp lq lr ls b"><strong class="is hj">keccak(RLP(node))</strong></code> <strong class="is hj"> → </strong> <code class="du lp lq lr ls b"><strong class="is hj">RLP(node)</strong></code>。</p><ul class=""><li id="ef22" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">扩展节点(2项):</strong> <code class="du lp lq lr ls b"><strong class="is hj">node ≡ [encodedPath, key]</strong></code>，其中<code class="du lp lq lr ls b">key</code>代表，<code class="du lp lq lr ls b">keccak(RLP(node))</code><strong class="is hj"/><code class="du lp lq lr ls b">encodedPath</code>代表<code class="du lp lq lr ls b">HP(prefix + path)</code>，其中<code class="du lp lq lr ls b">HP</code>为“十六进制前缀编码”功能(详见下文)。替换后，一个扩展节点可以表示为<code class="du lp lq lr ls b">node ≡ [HP(prefix + path), keccak(RLP(node))]</code>。扩展节点在数据压缩中起着重要的作用，因为它们负责对键之间的公共路径进行分组(分支节点之前和之后)。</li><li id="a3a1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">分支节点(17项):</strong> <code class="du lp lq lr ls b"><strong class="is hj">node ≡ [branchCharacters, value]</strong></code>，其中<code class="du lp lq lr ls b">branchCharacters</code>为数组的前16个元素，<code class="du lp lq lr ls b">value</code>为第17个元素。<code class="du lp lq lr ls b">branchCharacters</code>表示路径可以采用的16个可能的十六进制字符，从一个键中的一个字符到下一个字符(<code class="du lp lq lr ls b">0-F</code>)；每个索引(0–15)要么是<code class="du lp lq lr ls b">NULL</code>，要么保存子节点的散列值<code class="du lp lq lr ls b">keccak(RLP(childNode))</code>(一个新的键)。<code class="du lp lq lr ls b">value</code>表示一个<em class="lt">可选的</em>终止父扩展节点的值，如<code class="du lp lq lr ls b">RLP(accountState)</code>、<code class="du lp lq lr ls b">RLP(ethereumTransaction)</code>或<code class="du lp lq lr ls b">RLP(transactionReceipt)</code>，具体取决于您所在的trie如果其父节点不是终止扩展节点，则为<code class="du lp lq lr ls b">NULL</code>。</li><li id="6840" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">叶节点(2项):</strong> <code class="du lp lq lr ls b"><strong class="is hj">node ≡ [encodedPath, value]</strong></code>，其中<code class="du lp lq lr ls b">value</code>代表一个键的终止RLP编码值，<code class="du lp lq lr ls b">encodedPath</code>代表<code class="du lp lq lr ls b">HP(prefix + path)</code>。叶节点终止trie中的路径，它们也有助于数据压缩，因为它们将单个子节点序列(键后缀)组合成一个节点。这种数据压缩也受到Patricia-Trie的影响。</li></ul><p id="a5f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图F中的下图也摘自卡米尔·耶泽克的论文“以太坊数据结构”<a class="ae lf" href="https://arxiv.org/pdf/2108.05513.pdf" rel="noopener ugc nofollow" target="_blank">清楚地描述了Merkle Patricia Trie节点类型及其在简单键值存储示例中的功能:</a></p><p id="3177" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">图F: </strong></p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/83d5a2a0dd4d58396671a7429f2dc2e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SaTH8NbDANC-rsgBAg2U-g.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">来源:https://arxiv.org/pdf/2108.05513.pdf<a class="ae lf" href="https://arxiv.org/pdf/2108.05513.pdf" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><h2 id="9ffc" class="lx kd hi bd ke ly lz ma ki mb mc md km jb me mf kq jf mg mh ku jj mi mj ky mk bi translated"><strong class="ak">节点被加密链接(Merkle树影响)</strong></h2><p id="35c3" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">注意上面的每个键:<code class="du lp lq lr ls b">N1</code>、<code class="du lp lq lr ls b">N2</code>、<code class="du lp lq lr ls b">N3</code>、<code class="du lp lq lr ls b">N4</code>和<code class="du lp lq lr ls b">N5</code>，都是一个编码节点的Keccak 265位散列。另外，注意父节点，<code class="du lp lq lr ls b">N1</code>和<code class="du lp lq lr ls b">N2</code>包含散列的子节点(分别是<code class="du lp lq lr ls b">N2</code>和<code class="du lp lq lr ls b">N3</code>)。这就是Merkle Tree影响的来源。假定父节点是节点的散列，包含它们的子节点的散列，每个父节点确定性地链接到它的子节点持有的数据。因为根节点实际上是整个trie的父节点，所以它确定性地链接到trie包含的所有数据。trie中任何节点的变化都会导致不同的根节点散列。这一特性使得比较大型数据集变得简单，人们可以简单地比较两个数据集的根哈希，而不是将每个数据块与另一个数据集中的数据块进行比较。给定哈希的确定性属性，如果根哈希不同，数据集就不相同。作为参考，下面的图G描述了一个二叉树，其中每个非叶节点都有两个子节点。需要说明的是，二进制Merkle树与Merkle Patricia Trie没有直接关系，但是我将它包括进来是为了更好地理解它对加密的影响。底层:<code class="du lp lq lr ls b">L1</code>、<code class="du lp lq lr ls b">L2</code>、<code class="du lp lq lr ls b">L3</code>和<code class="du lp lq lr ls b">L4</code>，代表组成树的数据。</p><p id="076d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">图G: </strong></p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/94cc3f51930892a397f7ec44661454a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZ-rsDH3NbipUByBObxvVA.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">来源:<a class="ae lf" href="https://en.wikipedia.org/wiki/Merkle_tree" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Merkle_tree</a></figcaption></figure><p id="b622" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">主要观察:</strong></p><ul class=""><li id="cefe" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">叶节点是数据块的加密散列</li><li id="c99a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">分支节点是其两个子节点的散列，这两个子节点本身也是散列</li><li id="4a07" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">所有叶节点深度相同</li><li id="3448" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">该树在顶部收敛到一个根节点</li></ul><p id="664e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似于Merkle Patricia Trie中的上述内容，包括根节点在内的父节点被确定性地链接到驻留在其子节点中的数据，这允许数据集的有效比较。</p><h1 id="7c47" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">编码如何为哈希奠定基础</h1><h2 id="8052" class="lx kd hi bd ke ly lz ma ki mb mc md km jb me mf kq jf mg mh ku jj mi mj ky mk bi translated"><strong class="ak">递归长度前缀(RLP)编码</strong></h2><p id="f726" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">给定<code class="du lp lq lr ls b"><strong class="is hj">keccak(RLP(node))</strong></code> <strong class="is hj"> → </strong> <code class="du lp lq lr ls b"><strong class="is hj">RLP(node)</strong></code> <strong class="is hj"> </strong>为键值对格式，我们知道Merkle Patricia Trie中的每个键都是其对应值的keccak 256位hash。这意味着该值本身必须采用合适的格式<em class="lt">作为散列函数的</em> <em class="lt">输入</em>。如上所述，散列函数要求其输入是一个<a class="ae lf" href="https://stackoverflow.com/questions/4019837/what-do-we-mean-by-byte-array#:~:text=A%20byte%20array%20is%20simply,%2C%20the%20second%20byte%20etc.." rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">字节数组</strong> </a>。这一需求导致了使用<a class="ae lf" href="https://eth.wiki/fundamentals/rlp" rel="noopener ugc nofollow" target="_blank"> RLP编码</a>，因为它确实完成了:它将一个结构化的节点编码成一个单字节数组。这种编码方法可以接受一组结构化的或任意嵌套的输入数组，并将它们序列化为一个输出字节数组，适合于散列。由于值也是RLP编码的(不是加密的)，它们很容易被解码。编码的目的是将数据组织成用例的特定格式，而加密隐藏数据，只有通过某种密钥才能访问。</p><h2 id="aebd" class="lx kd hi bd ke ly lz ma ki mb mc md km jb me mf kq jf mg mh ku jj mi mj ky mk bi translated"><strong class="ak">十六进制前缀(HP)编码</strong></h2><p id="bb4c" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">注意上面的<strong class="is hj">叶节点</strong>和<strong class="is hj">扩展节点</strong>都是<strong class="is hj"> 2-item </strong>节点——它们具有相同的结构。此外，第一个元素在每两者中都采取了形式，<code class="du lp lq lr ls b">HP(prefix + path)</code>。考虑到这一点，必须有一种方法来区分这两者。我们知道扩展节点和叶节点都将一个子节点序列合并到一个节点中，或者表示一个公共路径(在扩展节点的情况下)，或者表示一个键的后缀(在叶节点的情况下)。这些合并序列中的每个十六进制字符称为一个“半字节”。为了区分扩展节点和叶节点，可以添加一个额外的半字节(十六进制字符)作为节点当前半字节的前缀。然后，根据这个新添加的字符的值，我们可以获得关于节点的信息，包括节点类型。记住，<a class="ae lf" href="https://www.youtube.com/watch?v=8T4F7WboWPQ" rel="noopener ugc nofollow" target="_blank">十六进制字符可以转换成二进制数字系统</a>，这样每个字符代表4位。</p><p id="c3ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">前缀规则:</strong>由于可以用4位来表示一个十六进制字符，所以我们可以把这样一个“节点类型解密”的前缀半字节看作一个4位前缀。有了这个前缀，我们可以为扩展和叶节点灌输以下规则:</p><ul class=""><li id="e036" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">偶数还是奇数:</strong>最低位(最右边)告诉我们“单节点字符合并序列”(一个节点的半字节)的<em class="lt">长度</em>是偶数还是奇数，其中<code class="du lp lq lr ls b">0 = even</code>和<code class="du lp lq lr ls b">1 = odd</code></li><li id="1735" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><strong class="is hj">节点类型:</strong>第二低阶(第二右)位告诉我们该节点是扩展节点还是叶节点，其中<code class="du lp lq lr ls b">0 = extension</code>和<code class="du lp lq lr ls b">1 = leaf</code></li></ul><p id="ecb7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据上述规则，我们现在可以通过添加和解释前缀十六进制字符(半字节)来解密扩展节点和叶节点之间的内容。下图H说明了这个前缀及其编码含义:</p><p id="47f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">图H: </strong></p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/c04ab165df00d27701eb64d21394ab00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Usd_V5GQuqmXtnlTDOY0FQ.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">来源:https://arxiv.org/pdf/2108.05513.pdf<a class="ae lf" href="https://arxiv.org/pdf/2108.05513.pdf" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="5edb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">字节数组需要偶数个半字节:</strong>好奇的读者可能会质疑知道路径长度是奇数还是偶数的重要性。这样做的原因是，我们需要再次将<code class="du lp lq lr ls b">HP(prefix + path)</code>中的<code class="du lp lq lr ls b">prefix + path</code>放入一个字节数组，因为大多数计算机存储的是字节，而不是半字节(<a class="ae lf" href="https://en.wikipedia.org/wiki/Nibble" rel="noopener ugc nofollow" target="_blank">半字节</a>)。将一个前缀半字节添加到一组偶数长度的半字节<em class="lt">会导致半字节的<em class="lt">奇数长度</em>(偶数加1是奇数)，这不能恰当地放入一个字节数组。请记住，1个字节(8位)需要2个半字节(每个4位)，这意味着一个字节数组需要偶数个半字节。对于诸如此类的情况(在添加前缀半字节</em>之后的半字节总数<em class="lt">为奇数)，在第一个前缀半字节之后插入一个额外的半字节<code class="du lp lq lr ls b">0</code>，以使半字节总数为偶数，从而可以获得适当的字节数组。这里，这两个新引入的半字节组成了“前缀字节”。另一方面，如果添加前缀半字节导致偶数长度路径(其中添加前缀半字节</em>之后的半字节总数<em class="lt">是偶数)，则节点的第一个<em class="lt">非前缀</em>半字节直接包括在前缀半字节之后的前缀字节中。参见下图一中的示例:</em></p><p id="e328" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">图一:</strong></p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/630f219ad9883fb632c9f873deebf9da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QbeSpD064HJa7dV3KwPfQQ.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">来源:https://arxiv.org/pdf/2108.05513.pdf</figcaption></figure><p id="3684" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦扩展节点和叶节点的键被HP编码，它们连同它们的值可以被RLP编码，使它们准备好被散列。结果呢？我们可以哈希节点来生成Merkle Patricia Trie键，我们还可以区分叶节点和扩展节点(分支节点显然是可区分的，因为它们是17项节点)。</p><h1 id="c4e0" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Merkle Patricia Trie示例</h1><p id="539e" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">现在我们对Merkle Patricia Trie数据结构有了一个不错的概念性理解，让我们通过一个具体的例子来巩固我们的知识，这个例子可以在<a class="ae lf" href="https://eth.wiki/fundamentals/patricia-tree" rel="noopener ugc nofollow" target="_blank">以太坊Wiki </a>上找到。假设我们要存储以下键值对:<code class="du lp lq lr ls b">('do', 'verb')</code>、<code class="du lp lq lr ls b">('dog', 'puppy')</code>、<code class="du lp lq lr ls b">('doge', 'coin')</code>、<code class="du lp lq lr ls b">('horse', 'stallion')</code>。</p><ul class=""><li id="ef29" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">首先，<strong class="is hj">键</strong>和<strong class="is hj">值</strong>都被转换成字节(为了更容易理解，本例中仅以字节显示键):</li></ul><pre class="lh li lj lk fd mq ls mr ms aw mt bi"><span id="f403" class="lx kd hi ls b fi mu mv l mw mx">&lt;64 6f&gt; : 'verb'<br/>&lt;64 6f 67&gt; : 'puppy'<br/>&lt;64 6f 67 65&gt; : 'coin'<br/>&lt;68 6f 72 73 65&gt; : 'stallion'</span></pre><ul class=""><li id="13a3" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">然后可以将键值对构造成Merkle Patricia Trie，如下图J所示:</li></ul><p id="e6a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">图J: </strong></p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/3e7c0f5d8e7188dcd8d16251d87be553.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oBaG0sT7a1KJXBfe6x3u6w.png"/></div></div></figure><p id="ea07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">主要观察结果:</strong></p><ul class=""><li id="5668" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">所有键都以一个共享路径<code class="du lp lq lr ls b">6</code>开始，这就是为什么6会进入与<code class="du lp lq lr ls b">rootHash</code>关联的扩展节点的<code class="du lp lq lr ls b">HP(prefix + path)</code>部分。换句话说，所有键共享一个公共半字节，<code class="du lp lq lr ls b">6</code>。假定公共半字节组的长度为1(奇数)，添加前缀半字节<code class="du lp lq lr ls b">1</code>足以构建字节数组，因此按照HP编码规则，半字节<code class="du lp lq lr ls b">6</code>直接添加到前缀半字节之后的前缀字节。</li><li id="c35b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">路径的分歧发生在第二个半字节:三个键有第二个半字节，<code class="du lp lq lr ls b">4</code>，一个键有<code class="du lp lq lr ls b">8</code>。因此，属于<code class="du lp lq lr ls b">hashB</code>的分支节点的第4和第8个索引是非空的。</li><li id="4b89" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">所有扩展节点的值都是新的子节点的散列(键)。</li><li id="288d" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">也有一些节点包含其他节点的情况，比如带键的节点，<code class="du lp lq lr ls b">hashA</code>和<code class="du lp lq lr ls b">hashE</code>。当子节点的RLP编码小于32字节时，子节点不会被散列，而是直接包含在父节点中，这是另一种数据压缩技术。</li><li id="b8d1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">值<code class="du lp lq lr ls b">‘verb’</code>和<code class="du lp lq lr ls b">‘puppy’</code>是分支节点中的值，但是它们实际上表示它们的父<em class="lt">扩展</em>节点的终止值，因为扩展节点不包含“值”字段，而是包含子节点键。</li></ul><h2 id="ab12" class="lx kd hi bd ke ly lz ma ki mb mc md km jb me mf kq jf mg mh ku jj mi mj ky mk bi translated">结论</h2><p id="8c85" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我希望在读完这篇文章后，以太坊数据存储能更有意义一些。如果你想了解最新的以太坊和Web3知识，请随时订阅<a class="ae lf" href="https://adamcuc.substack.com/" rel="noopener ugc nofollow" target="_blank">我的简讯</a>！谢谢你。</p></div></div>    
</body>
</html>