<html>
<head>
<title>Notes on recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于递归的注记</h1>
<blockquote>原文：<a href="https://medium.com/codex/notes-on-recursion-53f90d4ed7be?source=collection_archive---------11-----------------------#2022-06-12">https://medium.com/codex/notes-on-recursion-53f90d4ed7be?source=collection_archive---------11-----------------------#2022-06-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7660" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这个博客旨在简化和可视化递归概念及其工作</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/9ecc88a2d9fef82534d24454d10bbd98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-R8zhuvQGi8dz9H-"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">米卡·鲍梅斯特在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b91e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">递归</strong>是一种编程概念，通过将复杂的问题分解成更小的子问题来解决它。</p><p id="ec2a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">运行时调用自身的函数是<strong class="jq hj">递归函数</strong>。例如，在Linux系统中，我们使用命令“ls -R ”,它告诉系统递归地显示目录的所有内容，或者进入每个文件夹，依次进入子文件夹并打印内容。</p><h2 id="461a" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">堆栈溢出问题</h2><p id="a4f6" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">递归函数的主要缺点是<strong class="jq hj">堆栈溢出</strong>问题。</p><p id="f1d7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当Python程序运行时，变量(变量指向的堆栈中的地址或引用)与函数调用的返回地址一起被加载到堆栈内存中。然而堆栈内存是静态的，这意味着我们可以进行有限次数的函数调用。此外，堆栈是临时的，因为一旦Python解释器执行了函数调用并返回到下一行，地址就会弹出堆栈。<a class="ae jn" href="https://towardsdatascience.com/python-memory-and-objects-e7bec4a2845#:~:text=Code%20%28also%20called%20Text%20or%20Instructions%29%20section%20of,in%20the%20Stack%20Memory%20%28also%20called%20the%20Stack%29." rel="noopener" target="_blank">这篇</a>博客更详细地解释了Python中的内存管理。</p><p id="b13e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为递归函数调用自己，所以下一行代码的返回地址在函数第一次调用自己时就存储在堆栈中。随后，随着函数不断调用自身，返回地址被存储在堆栈中，当由于堆栈内存耗尽而没有更多空间来存储另一个地址时，这可能导致堆栈溢出。</p><h2 id="cdb7" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">迭代、递归、动态规划</h2><p id="acae" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">编写递归解决方案包括以下内容:</p><ol class=""><li id="b5e5" class="lk ll hi jq b jr js ju jv jx lm kb ln kf lo kj lp lq lr ls bi translated"><strong class="jq hj">识别基本情况</strong>:基本情况是指代码的停止条件，一旦满足基本情况，Python解释器弹出返回地址</li></ol><p id="06bc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">2.<strong class="jq hj">识别递归情况</strong>:函数需要调用自身或递归关系的情况，递归关系将调用函数来解决比原始复杂问题更小的相似子问题(<a class="ae jn" href="https://www.tutorialspoint.com/data_structures_algorithms/divide_and_conquer.htm" rel="noopener ugc nofollow" target="_blank">分治</a>方法)</p><p id="3c3f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">3.<strong class="jq hj">越来越接近基础案例</strong>:当我们经历递归案例时，在某一点上我们应该到达基础案例</p><pre class="iy iz ja jb fd lt lu lv lw aw lx bi"><span id="e304" class="kk kl hi lu b fi ly lz l ma mb">def fibonacci(n):<br/> <br/> if n &lt;= 1: return n # base case<br/><br/> return fibonacci(n-1) + fibonacci(n-2) # recursive case </span></pre><p id="e8e6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">函数fibonacci是一个递归函数，其中第一行是基本情况；一旦我们计算了Fibonacci(1 ), Python解释器返回n或1。对于任何大于1的n，满足递归情况，调用fibonacci。</p><p id="243d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">递归与迭代:</strong></p><p id="dd7c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">虽然递归遵循<a class="ae jn" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> DRY </a>(不要重复自己)原则保持代码简单，但它也有很大的内存占用(一个大的调用栈)；因此，当我们<strong class="jq hj">知道我们想要通过</strong>多少次迭代时，迭代可能是有用的。</p><p id="5508" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我们不知道迭代次数以及处理像树和链表这样的数据结构时，递归是有用的。使用深度优先搜索遍历二叉树的所有节点的过程非常简单。</p><p id="830b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们分析编码斐波纳契数列的堆栈和递归所用的时间。</p><pre class="iy iz ja jb fd lt lu lv lw aw lx bi"><span id="53c4" class="kk kl hi lu b fi ly lz l ma mb">import inspect<br/>import time</span><span id="5dce" class="kk kl hi lu b fi mc lz l ma mb">num_calls_list = []</span><span id="f344" class="kk kl hi lu b fi mc lz l ma mb">def fibonacci(n):<br/> num_calls = 0<br/> <br/> if n &lt;= 1: return n<br/> <br/> num_calls_list.append(len(inspect.stack())) # Return a list of the frames pushed onto stack for executing the current line of code<br/> <br/> <br/> return fibonacci(n-1) + fibonacci(n-2)</span></pre><p id="bd7f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们使用<code class="du md me mf lu b">inspect.stack()</code>来查看Python调用栈。我们这样得到一个命名的元组</p><p id="7437" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du md me mf lu b">FrameInfo(frame, filename, lineno, function, code_context, index)</code></p><p id="97af" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">num_calls_list存储每次递归调用时的<code class="du md me mf lu b">len(inspect.stack())</code>。对于n = 2，我们得到<code class="du md me mf lu b">len(num_calls_list), num_calls_list</code>:</p><pre class="iy iz ja jb fd lt lu lv lw aw lx bi"><span id="f346" class="kk kl hi lu b fi ly lz l ma mb">1 [29]</span></pre><ul class=""><li id="7cd2" class="lk ll hi jq b jr js ju jv jx lm kb ln kf lo kj mg lq lr ls bi translated">1次对函数递归的调用，29代表从函数递归到最后一次对所用库的堆栈调用的堆栈调用次数(因为这是在Anaconda上运行的，所以我们也将Anaconda帧添加到堆栈中)。</li></ul><p id="3e66" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">打印<code class="du md me mf lu b">inspect.stack()</code>返回的列表的第一个元素</p><pre class="iy iz ja jb fd lt lu lv lw aw lx bi"><span id="4c45" class="kk kl hi lu b fi ly lz l ma mb">FrameInfo(frame=&lt;frame at 0x0000027E131DECF0, file '&lt;ipython-input-12-89cd151ff95a&gt;', line 6, code fibonacci&gt;, filename='&lt;ipython-input-12-89cd151ff95a&gt;', lineno=5, function='fibonacci', code_context=['    for ind, i in enumerate(inspect.stack()):\n'], index=0)</span></pre><p id="5c9f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第一个字段<code class="du md me mf lu b">frame</code>具有帧信息，例如地址、包含它的文件名、调用函数<code class="du md me mf lu b">&lt;frame at 0x0000027E131DECF0, file ‘&lt;ipython-input-12–89cd151ff95a&gt;’, line 6, code fibonacci&gt;</code>；<code class="du md me mf lu b">filename</code>具有调用<code class="du md me mf lu b"> ‘&lt;ipython-input-12–89cd151ff95a&gt;'</code>函数的文件名；从<code class="du md me mf lu b">lineno</code>中调用的行；在<code class="du md me mf lu b">function</code>中调用<code class="du md me mf lu b">‘fibonacci’</code>的功能；并且<code class="du md me mf lu b">code context </code>给出了检查该帧的代码行列表；而<code class="du md me mf lu b">index</code>表示列表中代码上下文的索引。</p><p id="0103" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于n = 3:</p><pre class="iy iz ja jb fd lt lu lv lw aw lx bi"><span id="ea4a" class="kk kl hi lu b fi ly lz l ma mb">2 [29, 30]</span></pre><ul class=""><li id="9df3" class="lk ll hi jq b jr js ju jv jx lm kb ln kf lo kj mg lq lr ls bi translated">对于n = 3，我们有:</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mh"><img src="../Images/1c116230402b151d4905f645de643265.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*9PBttJkhs-GYir3KWiKY9w.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">计算N = 3的斐波那契数列的递归树</figcaption></figure><p id="7367" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">1#纤维(3) =纤维(2) +纤维(1) = &gt;纤维(2) + 1</p><p id="ec1c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">2# fib(2) = fib(1) + fib(0) =&gt; 1 + 0</p><ul class=""><li id="aea8" class="lk ll hi jq b jr js ju jv jx lm kb ln kf lo kj mg lq lr ls bi translated">2个函数调用，其中第二个函数调用在堆栈空间中堆叠了30个地址(比第一个多1个，因为递归函数调用用于计算fibonacci值2)</li></ul><p id="d3eb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">类似地，对于n = 5:</p><pre class="iy iz ja jb fd lt lu lv lw aw lx bi"><span id="1237" class="kk kl hi lu b fi ly lz l ma mb">7 [29, 30, 31, 32, 31, 30, 31]</span></pre><p id="1589" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于n = 8:</p><pre class="iy iz ja jb fd lt lu lv lw aw lx bi"><span id="eca0" class="kk kl hi lu b fi ly lz l ma mb">33 [29, 30, 31, 32, 33, 34, 35, 34, 33, 34, 32, 33, 34, 33, 31, 32, 33, 34, 33, 32, 33, 30, 31, 32, 33, 34, 33, 32, 33, 31, 32, 33, 32]</span></pre><p id="c03b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于n = 15:</p><pre class="iy iz ja jb fd lt lu lv lw aw lx bi"><span id="7192" class="kk kl hi lu b fi ly lz l ma mb">986 [29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 41, 40, 41, 39, 40, 41, 40, 38, 39, 40, 41, 40, 39, 40, 37, 38, 39, 40, 41, 40, 39, 40, 38, 39, 40, 39, 36, 37, 38, 39, 40, 41, 40, 39, 40, 38, 39, 40, 39, 37, 38, 39, 40, 39, 38, 39, 35, 36, 37, 38, 39, 40, 41, 40, 39, 40, 38, 39, 40, 39, 37, 38, 39, 40, 39, 38, 39, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 34, 35, 36, 37, 38, 39, 40, 41, 40, 39, 40, 38, 39, 40, 39, 37, 38, 39, 40, 39, 38, 39, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 33, 34, 35, 36, 37, 38, 39, 40, 41, 40, 39, 40, 38, 39, 40, 39, 37, 38, 39, 40, 39, 38, 39, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 34, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 40, 39, 40, 38, 39, 40, 39, 37, 38, 39, 40, 39, 38, 39, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 34, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 33, 34, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 34, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 35, 36, 37, 38, 37, 36, 37, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 40, 39, 40, 38, 39, 40, 39, 37, 38, 39, 40, 39, 38, 39, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 34, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 33, 34, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 34, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 35, 36, 37, 38, 37, 36, 37, 32, 33, 34, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 34, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 35, 36, 37, 38, 37, 36, 37, 33, 34, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 35, 36, 37, 38, 37, 36, 37, 34, 35, 36, 37, 38, 37, 36, 37, 35, 36, 37, 36, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 40, 39, 40, 38, 39, 40, 39, 37, 38, 39, 40, 39, 38, 39, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 34, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 33, 34, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 34, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 35, 36, 37, 38, 37, 36, 37, 32, 33, 34, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 34, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 35, 36, 37, 38, 37, 36, 37, 33, 34, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 35, 36, 37, 38, 37, 36, 37, 34, 35, 36, 37, 38, 37, 36, 37, 35, 36, 37, 36, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 39, 38, 39, 37, 38, 39, 38, 36, 37, 38, 39, 38, 37, 38, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 34, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 35, 36, 37, 38, 37, 36, 37, 33, 34, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 35, 36, 37, 38, 37, 36, 37, 34, 35, 36, 37, 38, 37, 36, 37, 35, 36, 37, 36, 32, 33, 34, 35, 36, 37, 38, 39, 38, 37, 38, 36, 37, 38, 37, 35, 36, 37, 38, 37, 36, 37, 34, 35, 36, 37, 38, 37, 36, 37, 35, 36, 37, 36, 33, 34, 35, 36, 37, 38, 37, 36, 37, 35, 36, 37, 36, 34, 35, 36, 37, 36, 35, 36]</span></pre><p id="afad" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">总结..</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/937c16986668587611cb74844dcf9f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOsTm8VrF__T3i5dO8fGjg.png"/></div></div></figure><p id="fc2b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">随着N的增加，我们看到所用的时间、总的函数调用和总的堆栈空间呈指数增长。因此，如果我们知道输入N可以变化到一个非常大的数，递归被认为不是一个非常有效的解决方案。</p><p id="7dde" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一方面，<strong class="jq hj">迭代解</strong>不使用额外的堆栈空间，并且在线性时间内找到解。</p><p id="f637" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">动态编程</strong>将通过存储已经计算出的斐波那契数列来帮助节省时间，这样我们就不必在每次迭代中执行多余的计算。</p><p id="3ee6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于这个问题，下面的方法比递归更有效。</p><pre class="iy iz ja jb fd lt lu lv lw aw lx bi"><span id="e1fb" class="kk kl hi lu b fi ly lz l ma mb">def fibonacci(n):<br/>    fib, fib_list = 0 , [] # array to store the fibonacci values<br/>    for i in range(0,n):<br/>        if i &lt;= 1 : <br/>            fib_list.append(i)<br/>        else:<br/>            fib_list.append(sum(fib_list))<br/>            fib_list = fib_list[1:]  # Use a window to only store the nessecary fibonacci series values to calculate the next<br/>                                        <br/>    return fib_list[-1]+fib_list[-2]</span></pre><p id="8a7b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">随着N的增加，所用的时间几乎是一个常数。我们还可以看到，对于N= 150，我们得到的时间与N= 0几乎相同。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mj"><img src="../Images/8787b3f9eef20b84a7f1b0b7bab7549d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*dGueWCvAYZ8SD31FcCqJkg.png"/></div></figure><h2 id="7ba8" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">二叉树上的深度优先搜索</h2><p id="913b" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">编写一个递归程序来打印二叉树的前序遍历(根-&gt;左-&gt;右) :</p><pre class="iy iz ja jb fd lt lu lv lw aw lx bi"><span id="a3cf" class="kk kl hi lu b fi ly lz l ma mb">def get_node(node):<br/>    <br/>    if node == None: # base case<br/>        return<br/>    <br/>    num_calls_list.append(len(inspect.stack()))</span><span id="4cfc" class="kk kl hi lu b fi mc lz l ma mb">    node_list.append(node.data) # Append to node_list<br/>    <br/>    #print('left', node.data)<br/>    a = get_node(node.left) # Traverse left node  ## Recursive case<br/>    <br/>    # print('right', node.data)<br/>    b = get_node(node.right) # Traverse right node ## Recursive case<br/>    <br/>    return</span></pre><p id="eb23" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个解决方案非常容易理解:</p><ol class=""><li id="2a98" class="lk ll hi jq b jr js ju jv jx lm kb ln kf lo kj lp lq lr ls bi translated">基本情况:如果当前节点为None，则返回到调用函数</li><li id="9caa" class="lk ll hi jq b jr mk ju ml jx mm kb mn kf mo kj lp lq lr ls bi translated">递归情况:如果节点不为None，则查找左侧节点，直到基本情况返回None；之后，寻找正确的节点，直到没有返回。</li></ol><p id="4eac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们得到以下输出:</p><pre class="iy iz ja jb fd lt lu lv lw aw lx bi"><span id="7ee7" class="kk kl hi lu b fi ly lz l ma mb">'1-&gt; 2-&gt; 5-&gt; 4-&gt; 6'</span></pre><p id="4ed8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">原始树:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mp"><img src="../Images/c718713167027b592d95fb1d3042ccdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*o_E6mvMv5nOjtPUGzUO-_g.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">树1</figcaption></figure><p id="5b39" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们考虑另外两棵树，深度为4和8的树2和树3:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mq"><img src="../Images/8e17d734921d09e3eec4e87398bab57d.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*oMApJZ93vbiH9Q9TX2KG6A.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">tree2</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mr"><img src="../Images/08805ca52b4469d238d84a4348b3b184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*9is1dbEVG8pMm1Vewi0Omw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">tree3</figcaption></figure><p id="da6e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">打印花费的时间和我们得到的堆栈空间:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/57dc3f603a72bd5cbf1848b6da7c5cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9dMni45Z4TLtgpSsSRRGw.png"/></div></div></figure><p id="640e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">虽然代码非常<strong class="jq hj">简单易懂</strong>，但是我们看到随着树深度的增加，花费的时间和使用的堆栈空间都有所增加。</p><p id="92cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一方面，如果我们使用迭代解决方案:</p><pre class="iy iz ja jb fd lt lu lv lw aw lx bi"><span id="2831" class="kk kl hi lu b fi ly lz l ma mb">def print_node(linked_list):<br/>    node = linked_list.head<br/>    stack, preorder_traversal = [], [] # stack to store the previous node to pop ; preorder_traversal stores the order of nodes</span><span id="5e21" class="kk kl hi lu b fi mc lz l ma mb">    while True:<br/>        <br/>        if node != None: # keep finding the left node and store the root node in stack<br/> <br/>            preorder_traversal.append(node.data)<br/> <br/>            stack.append(node)<br/>            # print('Appending ', node.data, 'to stack ..', stack)<br/> <br/>            node = node.left<br/>        <br/>        elif stack: # Once left node returns null, we pop the stack and find the right nodes<br/>            <br/>            node = stack.pop()<br/>            node = node.right<br/>        <br/>        else:<br/>            break<br/>            <br/>    return preorder_traversal #print("-&gt; ".join(preorder_traversal))</span></pre><p id="65e0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们得到了一个常数时间解，尽管代码不像递归解那样容易理解。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mj"><img src="../Images/093e9a7fd4b6d607cd430fdfe2f0607c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*jzTSW7beosWlQyyBvg03Uw.png"/></div></figure></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><p id="0800" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="mz">感谢阅读！</em></p><p id="b734" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另外，如果有任何改进这篇文章的建议，请告诉我！</p><p id="5b6c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="https://github.com/aishani691/Recursion/blob/main/recursion_1.ipynb" rel="noopener ugc nofollow" target="_blank">这里的</a>是参考代码的链接。</p></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><h2 id="fc21" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">参考资料:</h2><p id="038e" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated"><a class="ae jn" href="https://towardsdatascience.com/python-memory-and-objects-e7bec4a2845#:~:text=Code%20(also%20called%20Text%20or%20Instructions)%20section%20of,in%20the%20Stack%20Memory%20(also%20called%20the%20Stack)." rel="noopener" target="_blank">https://towardsdatascience . com/python-memory-and-objects-E7 bec 4a 2845 #:~:text = Code % 20(也称为% 20Text % 20or或% 20 instructions)% 20 section % 20 of，在%20Stack%20Memory%20(也称为%20the%20Stack)中。</a></p><div class="na nb ez fb nc nd"><a href="https://nikhilism.com/post/2018/python-call-stack/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">深入Python调用堆栈(PyGotham 2018)</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">我在PyGotham 2018上做了一个关于Python如何实现堆栈框架以及Dropbox如何利用它来改善崩溃的演讲…</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">nikhilism.com</p></div></div></div></a></div><p id="7cf1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" rel="noopener" href="/towards-data-science/python-stack-frames-and-tail-call-optimization-4d0ea55b0542">https://medium . com/forward-data-science/python-stack-frames-and-tail-call-optimization-4d 0 ea 55 b 0542</a></p><p id="2123" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="https://www.udemy.com/course/master-the-coding-interview-data-structures-algorithms/?ranMID=39197&amp;ranEAID=fRpllyICu8o&amp;ranSiteID=fRpllyICu8o-KUTgZT.ExtsAdUVC9vMHew&amp;LSNPUBID=fRpllyICu8o&amp;utm_source=aff-campaign&amp;utm_medium=udemyads" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/course/master-the-coding-interview-data-structures-algorithms/？ran mid = 39197&amp;rane aid = frpllyicu 8 o&amp;ranSiteID = frpllyicu 8 o-KUTgZT。extsaduvc 9 VM hew&amp;lsn pubid = frpllyicu 8 o&amp;UTM _ source = aff-campaign&amp;UTM _ medium = udemyads</a></p><p id="0a09" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">【https://www.coursera.org/learn/algorithmic-toolbox T4】</p></div></div>    
</body>
</html>