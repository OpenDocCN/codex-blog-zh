<html>
<head>
<title>System Design goal: efficient property reads from multiple sources</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">系统设计目标:从多个来源高效地读取属性</h1>
<blockquote>原文：<a href="https://medium.com/codex/system-design-goal-efficient-property-reads-from-multiple-sources-da015ff0407a?source=collection_archive---------21-----------------------#2021-09-08">https://medium.com/codex/system-design-goal-efficient-property-reads-from-multiple-sources-da015ff0407a?source=collection_archive---------21-----------------------#2021-09-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="db62" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">选择正确的组件设计和数据结构来读取和选择线程安全的属性值。</h2></div><p id="c208" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">🔔这篇文章最初发表在我的网站上，<a class="ae jt" href="https://MihaiBojin.com/application-settings/system-design/read-key-from-multiple-sources?utm_source=Medium&amp;utm_medium=organic&amp;utm_campaign=top-promo" rel="noopener ugc nofollow" target="_blank">MihaiBojin.com</a>。由于表格和美人鱼图不在介质上渲染，<strong class="iz hj">我强烈推荐阅读</strong> <a class="ae jt" href="https://mihaibojin.com/application-settings/system-design/read-key-from-multiple-sources?utm_source=Medium&amp;utm_medium=organic&amp;utm_campaign=top-promo" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj">那里</strong> </a> <strong class="iz hj">！</strong>🔔</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/cc8083ae445c1dc34480c157ad433a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*osrKodRkcMJRTMrEiPJVrA.jpeg"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">照片由Hasan Almasi在Unsplash上拍摄</figcaption></figure></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="85bb" class="kr ks hi bd kt ku kv kw kx ky kz la lb jg lc ld le jk lf lg lh jo li lj lk ll bi translated">所有权的问题</h2><p id="b45c" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">我开始构建<a class="ae jt" href="https://github.com/props-sh/props" rel="noopener ugc nofollow" target="_blank"> props </a>库来标准化从多个<em class="lv">源</em>中检索<code class="du lr ls lt lu b">(key,value)</code>对，同时也允许一个简单的机制在多个源知道同一个键时建立<em class="lv">键</em>优先级。</p><p id="01ca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来源可以是属性文件、系统属性，也可以来自键值存储或数据库。</p><p id="b609" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于每个<em class="lv"> (key，value) </em>对可以在每个源上独立地改变，我们需要建立一个键的优先级，基本上回答<strong class="iz hj">“谁为这个键提供值？”</strong>问题。</p><p id="3b3b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们通过引入<strong class="iz hj">层的概念来做到这一点。</strong></p><p id="bf24" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个添加的图层都可以从源中检索数据。当我们添加更多层时，对于它定义的任何键，每个层都优先于前一层。</p><p id="91bb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们称这个概念为<strong class="iz hj">所有权。</strong></p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="c4c9" class="kr ks hi bd kt ku kv kw kx ky kz la lb jg lc ld le jk lf lg lh jo li lj lk ll bi translated">源与层</h2><p id="afd3" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">让我们考虑一下来源和层次。</p><p id="1259" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一种简单的方法是在源和层之间建立1:1的关系模型，基本上创建一个实体来表示两者，然后将这些实体的列表传递给一个<em class="lv">注册表</em>。</p><p id="b97e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果两个源都指向磁盘上的<em class="lv">相同文件，并且</em>我们有两个独立读取相同数据的对象，这就产生了潜在的争用和一致性问题(例如，第1层读取数据，文件在磁盘上更新，第2层读取不同的数据)。</p><p id="7f87" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一致性并不总是可能的，也不总是系统的属性，但是在这种情况下，我们可以确保一个<em class="lv">源</em>在一个正在运行的JVM进程中拥有相同的数据视图。</p><p id="957b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与其让<em class="lv">源</em>和<em class="lv">层</em>相同(1:1 ),不如让单个<em class="lv">源</em>代表一个数据集和多个<em class="lv">层</em> (1:N ),它们在数据集改变时接收更新。这种设计的一个额外好处是，我们的系统只需要对每个数据集进行<strong class="iz hj">一次读取操作，而不是对每个层进行<em class="lv">一次读取操作。由于I/O通常比内存操作更“昂贵”，因此<strong class="iz hj">这是一个胜利！</strong></em></strong></p><p id="169f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是我们系统的组成部分:</p><ul class=""><li id="adb3" class="lw lx hi iz b ja jb jd je jg ly jk lz jo ma js mb mc md me bi translated"><code class="du lr ls lt lu b">Source</code>:从原始位置(如文件系统)加载数据，使用用户定义的逻辑(如时间间隔)重新加载数据，并将任何重新加载事件通知注册层</li><li id="69d3" class="lw lx hi iz b ja mf jd mg jg mh jk mi jo mj js mb mc md me bi translated"><code class="du lr ls lt lu b">Layer</code>:保存每个注册表的数据副本</li><li id="5eee" class="lw lx hi iz b ja mf jd mg jg mh jk mi jo mj js mb mc md me bi translated"><code class="du lr ls lt lu b">Registry</code>:查询各层数据</li></ul><h2 id="55a5" class="kr ks hi bd kt ku kv kw kx ky kz la lb jg lc ld le jk lf lg lh jo li lj lk ll bi translated">检索有效值</h2><p id="4949" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">但是如果一个层添加了一个新的键或者删除了一个现有的键呢！？</p><p id="bced" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在两次读取<em class="lv"> X </em>之间，所有者从第3层变为第2层。</p><p id="e0ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解决这个问题的一个简单算法总是查询所有层，例如:</p><ul class=""><li id="3388" class="lw lx hi iz b ja jb jd je jg ly jk lz jo ma js mb mc md me bi translated">问第1-3层:你定义了<em class="lv"> X </em>吗？</li><li id="b89b" class="lw lx hi iz b ja mf jd mg jg mh jk mi jo mj js mb mc md me bi translated">第2层和第3层响应<em class="lv">是</em></li><li id="9451" class="lw lx hi iz b ja mf jd mg jg mh jk mi jo mj js mb mc md me bi translated">第3层具有优先权，<em class="lv">拥有</em>密钥</li><li id="4519" class="lw lx hi iz b ja mf jd mg jg mh jk mi jo mj js mb mc md me bi translated">x从第3层复位</li><li id="0425" class="lw lx hi iz b ja mf jd mg jg mh jk mi jo mj js mb mc md me bi translated">我们重复前三个步骤，并将第2层建立为X 的<em class="lv">所有者</em></li></ul><p id="e57d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个选择并不理想。首先，我们必须在每次读取时重复这个<strong class="iz hj">，这将导致每个读取属性的<code class="du lr ls lt lu b">O(K)</code>时间复杂度(其中K是注册表中的层数)。这听起来不像表演！</strong></p><p id="2a62" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里的一个附带目标是处理高频率的所有权变更；例如，源数据集可能会在短时间间隔内重复设置和取消设置一个或多个键。</p><h2 id="ed11" class="kr ks hi bd kt ku kv kw kx ky kz la lb jg lc ld le jk lf lg lh jo li lj lk ll bi translated">铸造值类型</h2><p id="f689" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">在讨论所有权之前，让我们快速进入数据类型。当我们从属性文件、系统属性和环境中读取这些值时，它们总是被序列化为字符串。(该库将支持从其他数据存储(如数据库)加载值，但从属性文件转换字符串的问题仍然存在)</p><p id="56c5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一个标准Java属性文件的示例:</p><pre class="jv jw jx jy fd mk lu ml mm aw mn bi"><span id="237f" class="kr ks hi lu b fi mo mp l mq mr">string.prop=some value<br/>int.prop=42<br/>float.prop=1.23</span></pre><p id="9d84" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">即使我们有整型和浮点型值，相关的Java APIs仍然会返回一个<code class="du lr ls lt lu b">Map&lt;String,String&gt;</code>，把将这些值转换成适当类型的工作留给开发人员。</p><p id="c25a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上，当开发人员在项目中“来来去去”时，这导致了许多方式，不是那么优化地，加载字符串并重复地将它们转换成期望的类型。</p><p id="f0e1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我开始构建<code class="du lr ls lt lu b">props</code>库时，我想给开发人员“一种”加载对应于每个键的值的方式，而不用担心类型、简单的验证或缓存。我的目标是实现一个简单、高效的库来处理应用程序属性！</p><h2 id="1f92" class="kr ks hi bd kt ku kv kw kx ky kz la lb jg lc ld le jk lf lg lh jo li lj lk ll bi translated">我们如何建立密钥所有权？</h2><p id="beaf" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">好了，回到所有权！</p><p id="8978" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注册表需要跟踪足够多的键(假设在10，000个范围内)并从适当的层检索值。</p><p id="c925" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">开发人员将能够依靠一个<strong class="iz hj">注册表</strong>来检索转换成他们想要的类型的值。</p><p id="5b5a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们想象下面的例子:一个客户端查询注册中心(1)，注册中心依次检查它的所有层(2)，等待响应(3)，然后确定<em class="lv">的所有者</em>并将<em class="lv">的有效值</em>返回给客户端(4)。</p><p id="f946" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在实际应用中，我们可以假设一个<em class="lv">注册表</em>会有几层(<code class="du lr ls lt lu b">K</code>)。</p><p id="2c11" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们的应用程序处理<code class="du lr ls lt lu b">N</code>属性(键)，那么读取所有属性至少一次将是一个<code class="du lr ls lt lu b">O(N*K)</code>操作。假设最终一个密钥是由一个层拥有的，我们所能期望的最好结果是N个密钥的T4，或者每个密钥的固定时间。</p><p id="32bb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种时间复杂度不仅更有效，而且完全可以实现！</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="e0f5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在内部，<em class="lv">注册表</em>需要跟踪哪一层拥有每个键。</p><blockquote class="ms mt mu"><p id="623d" class="ix iy lv iz b ja jb ij jc jd je im jf mv jh ji jj mw jl jm jn mx jp jq jr js hb bi translated">2021年9月21日更新:我发现了这个设计的致命缺陷！查看<a class="ae jt" href="https://mihaibojin.com/application-settings/system-design/algorithms-for-effective-key-ownership?utm_source=Medium&amp;utm_medium=organic&amp;utm_campaign=rss" rel="noopener ugc nofollow" target="_blank">下一篇文章</a>获得深入解释！</p></blockquote><p id="f230" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于层可以同时更新，我们需要一个线程安全的数据结构。</p><p id="673e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们需要<em class="lv"/><em class="lv">(双关语)键到层，我们需要使用一个<code class="du lr ls lt lu b">Map</code>(咄！)</em></p><p id="a33d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java SDK提供了一个非常高效、线程安全的映射:<a class="ae jt" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html" rel="noopener ugc nofollow" target="_blank"> ConcurrentHashMap </a>。</p><p id="457e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看这在代码中会是什么样子:</p><pre class="jv jw jx jy fd mk lu ml mm aw mn bi"><span id="e9e6" class="kr ks hi lu b fi mo mp l mq mr">public class Registry {<br/>    ConcurrentHashMap&lt;String, Layer&gt; owners;<br/><br/>    // retrieves the value for the specified key<br/>    public &lt;T&gt; T get(String key, Class&lt;T&gt; clz) {<br/>        // finds the owner<br/>        Layer owner = owners.get(key);<br/>        // retrieves the value<br/>        String effectiveValue = owner.get(key);<br/>        // casts it<br/>        return clz.cast(effectiveValue);<br/>    }<br/>}<br/><br/>public interface Layer{<br/>    // retrieves the value for the specified key, from this layer alone<br/>    String get(String key);<br/>}</span></pre><p id="e124" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">难题的最后一块是更新所有权。下面，我们来考察一下<em class="lv">新钥匙</em>的案例。</p><pre class="jv jw jx jy fd mk lu ml mm aw mn bi"><span id="c29d" class="kr ks hi lu b fi mo mp l mq mr">public class Source{<br/>    List&lt;Layer&gt; layers;<br/><br/>    // reloads data periodically, at the specified interval<br/>    void reload(Duration interval) {<br/>        // the trigger will be periodically scheduled at an interval<br/>        var trigger = () -&gt; {<br/>            // data is reloaded from source<br/>            Map&lt;String, String&gt; data = ...;<br/><br/>            // and then sent to all registered layers for this source<br/>            for (Layer layer : layers) {<br/>                layer.onReload(data);<br/>            }<br/><br/>            // we may also want a sync stage here<br/>            // to make the new dataset available to all sources at the same time<br/>            // but it's beyond the scope, for the moment<br/>        }<br/>    }<br/>}<br/><br/>public class Layer{<br/>    // processes the reloaded data<br/>    public void onReload(Map&lt;String, String&gt; data) {<br/>        // for each key in the dataset<br/>        for (var entry : data.entrySet()) {<br/>            // updates the value<br/>            updateValue(entry.getKey(), entry.getValue());<br/>            // and notifies the registry that a new owner might be available<br/>            registry().bindKey(entry.getKey(), this);<br/>        }<br/>    }<br/><br/>    // decides the priority of this layer, in the current registry<br/>    int priority();<br/><br/>    // reference to the registry that owns this layer<br/>    abstract Registry registry();<br/>    <br/>    // stores the (key,value) pair<br/>    abstract void updateValue(String key, String value);<br/>}<br/><br/>public class Registry {<br/>    ConcurrentHashMap&lt;String, Layer&gt; owners;<br/><br/>    // registers ownership of a layer over a key<br/>    void bindKey(String key, Layer layer) {<br/>        // finds the current owner<br/>        Layer owner = owners.get(key);<br/>        <br/>        // determines if ownership change is required<br/>        if (owner.priority() &lt; layer.priority()) {<br/>            // change the current owner<br/>            owners.put(key, layer);<br/><br/>            // from this point, all "get"s of "key" will be routed to "layer"<br/>        }<br/>    }<br/>}</span></pre><p id="ed73" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的场景详细描述了系统将如何处理出现在层中的新键。</p><p id="aab8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完整的实现还需要考虑<em class="lv">删除的密钥</em>和<em class="lv">更新的密钥</em>。对于这些情况，我们希望避免调用<code class="du lr ls lt lu b">registry().bindKey(...)</code>，因为这无论如何都会导致无效操作。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="515b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总的来说，我愿意打赌，在现实世界的场景中，所有权的变化不会像价值的变化那样频繁。因此，<em class="lv">添加</em>和<em class="lv">删除</em>密钥的前期成本(由从一个层注册和注销密钥表示)对于实现每个密钥的恒定时间(<code class="du lr ls lt lu b">O(1)</code>)读取是值得的。</p><h2 id="a041" class="kr ks hi bd kt ku kv kw kx ky kz la lb jg lc ld le jk lf lg lh jo li lj lk ll bi translated">结论</h2><p id="052e" class="pw-post-body-paragraph ix iy hi iz b ja lm ij jc jd ln im jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">在这一点上，<strong class="iz hj">我对实现这段代码感到由衷的兴奋！</strong></p><p id="0c43" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我相信随着我的发展，我会学到更多，并可能改变我对这些选择的想法，但这是目前的计划！</p><p id="9a16" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">直到下一次…</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="8a69" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你喜欢这篇文章，并想阅读更多类似的文章，请订阅我的时事通讯。我每隔几周就发一封！</p></div></div>    
</body>
</html>