<html>
<head>
<title>Advanced React + Webpack 4 + Babel 7 Web Application Setup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级React + Webpack 4 + Babel 7 Web应用程序设置</h1>
<blockquote>原文：<a href="https://medium.com/codex/advanced-react-webpack-4-babel-7-web-application-setup-698651f9f50f?source=collection_archive---------13-----------------------#2021-06-22">https://medium.com/codex/advanced-react-webpack-4-babel-7-web-application-setup-698651f9f50f?source=collection_archive---------13-----------------------#2021-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/9f6c5536ec1270910b428bf23c23db13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYVqTEfiGuqN7UrXsdkQ9A.jpeg"/></div></div></figure><div class=""/><p id="ecf1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">构建用户界面的世界可能是一个复杂的导航场景。可供开发人员使用的工具数量之多令人应接不暇。在我的上一篇<a class="ae jo" href="https://nasidul-islam.medium.com/beginners-guide-to-minimal-react-webpack-4-babel-7-project-setup-9d2c9921e7b6" rel="noopener">教程</a>中，我们讨论了其中的一些工具(React、Webpack和Babel ),并回顾了它们是什么以及如何工作的基础知识。此外，我们还学习了如何将它们缝合在一起，从头开始构建适合开发的应用程序代码库。</p><p id="8db5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">拼凑起来的应用程序只有最少的功能。它不允许我们测试我们正在编写的代码，当然也不适合部署到产品中。<strong class="is hu">在本指南</strong>中，我们将在现有设置的基础上更进一步</p><ul class=""><li id="1ed3" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">学习开发+生产环境配置</li><li id="b05e" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">添加测试框架</li><li id="b044" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">厚颜无耻</li><li id="0d49" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">埃斯林特</li><li id="bf4f" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">静态资产(图像、SVG图标、字体图标、字体系列)</li></ul><p id="9b57" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kd">简介部分可以跳过。点击</em> <a class="ae jo" href="https://nasidulislam.hashnode.dev/advanced-react-webpack-4-babel-7-web-application-setup?guid=none&amp;deviceId=35dfb059-423f-4ff4-b206-b24d0ee035f1#step-1" rel="noopener ugc nofollow" target="_blank"> <em class="kd">此处</em> </a> <em class="kd">直接跳转到分步指南。</em></p><h1 id="748b" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">环境配置</h1><p id="6003" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">一个应用程序由特性组成，每个特性都有一个生命周期— —从它成为<code class="du lh li lj lk b">developed</code>，然后经过<code class="du lh li lj lk b">testing</code>，最后被部署到<code class="du lh li lj lk b">production</code>，它存在于不同的环境中(<em class="kd"> envs </em>)。环境服务于不同的目的，因此它们的需求也相应地不同。</p><p id="dfba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，我们不关心<em class="kd"> dev </em> env中的性能或优化，也不关心代码的缩减。通常，我们会启用dev env中的工具来帮助我们编写代码和调试代码，比如源代码映射、linters等。另一方面，在<em class="kd"> prod </em> env上，我们绝对关心应用程序性能和安全性、缓存等。在浏览本指南时，我们将使用的工具不会涉及我们在此讨论的所有项目，但是，我们将浏览环境配置如何工作以及它为什么有用的基础知识(以及更多内容)。</p><h1 id="9262" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">测试框架</h1><p id="7e32" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">测试框架为我们提供了一个平台和一套规则，允许我们测试我们正在编写的代码。任何打算为用户部署的应用程序都必须经过测试。原因如下:</p><ul class=""><li id="c175" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hu">这有助于减少bug</strong>的数量— —如果我们为<em class="kd">出现的bug</em>编写新的测试，我们就能极大地降低那个特定bug再次出现的可能性。</li><li id="496c" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">当我们试图重构代码时，它给了我们信心。失败的测试意味着重构的代码不能满足特定的场景。</li><li id="ca9b" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hu">提高了代码质量</strong>，因为开发人员必须编写可测试的代码，尽管编写好的测试本身是一种完全不同的(并且<em class="kd">非常</em>有价值的)技能</li><li id="39e5" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">以上所有的原因<strong class="is hu">从长远来看降低了开发的整体成本</strong>(更少的bug，更好的代码质量，等等。)</li><li id="8865" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">写得好的测试本身就成为了为其编写测试的代码的一种文档形式。</li></ul><p id="5257" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">框架有各种各样的风格--它们都有各自的优缺点。出于我们的目的，我们将使用两个更流行的框架，<a class="ae jo" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>来测试功能性JS，以及<a class="ae jo" href="https://enzymejs.github.io/enzyme/" rel="noopener ugc nofollow" target="_blank"> Enzyme </a>来测试我们的<strong class="is hu"> React </strong>组件。</p><h1 id="c7a5" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">厚颜无耻</h1><p id="ee2b" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">随着应用程序规模的增长，开发人员开始关注可维护性和可伸缩性。CSS就是这样一个领域，代码会很快变得非常混乱。<a class="ae jo" href="https://sass-lang.com/" rel="noopener ugc nofollow" target="_blank"> Sass </a>是在这方面帮助我们的工具:</p><ul class=""><li id="6445" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hu">编译成CSS </strong>，所以结果是熟悉的代码。</li><li id="3c16" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hu">允许嵌套选择器</strong>。这使得开发人员能够编写更简洁、更少的代码行，并且为更易维护的样式表打开了大门。</li><li id="b19c" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">它允许创建变量，混合，进一步提高可维护性。</li><li id="3e36" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hu">有条件的CSS </strong>，刺激的玩意儿！</li><li id="ca39" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">这是一个行业认可的社区支持。</li></ul><p id="8546" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没有理由不使用肯定会改进我们的开发工作流程的工具，对吗？</p><h1 id="53e4" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">埃斯林特</h1><p id="a22b" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">随着代码库开始增长，另一个关注点是确保高标准的代码质量。当多个团队或开发人员在同一个代码库上工作时，这尤其重要。ESLint 在这里拯救了这一天— —它强制执行通用的编码标准，或<em class="kd">风格指南</em>，供所有开发人员遵循。有许多行业认可的风格指南，例如，<a class="ae jo" href="https://google.github.io/styleguide/htmlcssguide.html" rel="noopener ugc nofollow" target="_blank">谷歌</a>和<a class="ae jo" href="https://github.com/airbnb/javascript" rel="noopener ugc nofollow" target="_blank"> Airbnb </a>。出于我们的目的，我们将使用AirBnB风格指南。</p><h1 id="fed7" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">静态资产</h1><p id="d2b0" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">这包括了应用程序中使用的所有漂亮的东西--自定义字体、字体图标、SVG和图像。它们被放在一个<code class="du lh li lj lk b">public</code>文件夹中，尽管可以为不同的设置进行争论。</p><p id="9d52" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">请注意:</strong>本指南的其余部分建立在我写的最后一篇文章<a class="ae jo" href="https://nasidulislam.hashnode.dev/beginners-guide-to-minimal-react-webpack-4-babel-7-project-setup-ck7m7erad00ec8ss1xzmfntqm" rel="noopener ugc nofollow" target="_blank">的基础上。您可以在继续此处的操作之前遵循第一条<em class="kd">或</em>执行以下操作:</a></p><ol class=""><li id="547e" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ll jv jw jx bi translated">确保您的节点版本为10.15.3或更高版本。打开你的终端，输入<code class="du lh li lj lk b">node -v</code>进行检查。如果版本不符合要求，请从<a class="ae jo" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">这里</a>获取最新版本。</li><li id="9192" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ll jv jw jx bi translated">一旦你熟悉了上述内容，拿起<a class="ae jo" href="https://github.com/all-things-javascript/minimal-react-webpack-babel" rel="noopener ugc nofollow" target="_blank">回购</a>并按照<code class="du lh li lj lk b">README</code>中的安装说明进行操作。</li><li id="1245" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ll jv jw jx bi translated">使用<code class="du lh li lj lk b">npm install</code>安装完依赖项后，运行<code class="du lh li lj lk b">npm start</code>来编译代码并启动开发服务器。此时，您应该看到一个新的浏览器选项卡打开，呈现一个<code class="du lh li lj lk b">hello world</code>组件。在尝试该命令之前，请确保您位于刚刚“git克隆”的存储库目录中。</li></ol><p id="2849" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kd">在学习了我们将要使用的工具的基础知识并建立了我们的基础回购后，我们终于可以继续学习指南了。</em></p><h1 id="b245" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">第一步</h1><p id="c403" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">假设<a class="ae jo" href="https://github.com/all-things-javascript/minimal-react-webpack-babel" rel="noopener ugc nofollow" target="_blank">回购</a>已经成功下载，在你选择的文本编辑器中打开它。您应该会看到一个名为<code class="du lh li lj lk b">webpack.config.js</code>的文件。这是webpack配置目前完整存在的地方。</p><p id="91aa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了将<em class="kd">生产</em>和<em class="kd">开发</em>构建分开，我们将创建单独的文件来托管它们的配置，另一个文件将包含它们之间的通用设置，以保持我们的代码干燥。</p><p id="f26e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为至少涉及到3个配置文件，所以它们需要在编译时互相<code class="du lh li lj lk b">merge</code>来呈现应用程序。为此，我们需要安装一个名为<code class="du lh li lj lk b">webpack-merge</code>的实用程序包到我们的开发依赖项中。</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="0b87" class="lu kf ht lk b fi lv lw l lx ly">npm install webpack-merge --save-dev</span></pre><p id="1554" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后把<code class="du lh li lj lk b">webpack.config.js</code>改名为<code class="du lh li lj lk b">webpack.common.js</code>。顾名思义，这将包含公共配置。我们将创建另外两个文件</p><ul class=""><li id="4cca" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><code class="du lh li lj lk b">webpack.production.js</code> -包含生产环境设置</li><li id="6253" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><code class="du lh li lj lk b">webpack.development.js</code> -包含开发环境设置</li></ul><p id="0211" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们讨论配置webpack构建时，我们将借此机会安装几个npm包，它们将有助于我们的工具和优化我们的构建。</p><p id="321a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们将安装一个名为<a class="ae jo" href="https://github.com/johnagan/clean-webpack-plugin" rel="noopener ugc nofollow" target="_blank"> CleanWebpackPlugin </a>的包。</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="7249" class="lu kf ht lk b fi lv lw l lx ly">npm install clean-webpack-plugin --save-dev</span></pre><p id="4df1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Webpack将输出包和文件放在<code class="du lh li lj lk b">/dist</code>文件夹中，因为这是我们为它配置的功能。随着时间的推移，这个文件夹往往会变得杂乱，因为我们每次(通过热重装)进行代码更改并保存时都会进行构建。Webpack很难跟踪所有这些文件，所以在每次构建之前清理<code class="du lh li lj lk b">/dist</code>文件夹<em class="kd">以确保使用正确的输出文件是一个好习惯。会处理好的。</em></p><p id="b7a5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将安装另一个名为<a class="ae jo" href="https://www.npmjs.com/package/path" rel="noopener ugc nofollow" target="_blank">路径</a>的包。它将允许我们在webpack中以编程方式设置入口和输出路径。</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="c787" class="lu kf ht lk b fi lv lw l lx ly">npm install path --save</span></pre><p id="9756" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经有了配置一个干净的、优化的webpack构建所需的包，让我们修改<code class="du lh li lj lk b">webpack.common.js</code>来包含下面的代码，</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="2329" class="lu kf ht lk b fi lv lw l lx ly">const path = require('path');<br/>const { CleanWebpackPlugin } = require('clean-webpack-plugin');<br/>const HtmlWebPackPlugin = require("html-webpack-plugin");</span><span id="89ab" class="lu kf ht lk b fi lz lw l lx ly">module.exports = {<br/>    output: {<br/>        filename: '[name].bundle.js',<br/>        path: path.resolve(__dirname, 'dist')<br/>    },<br/>    module: {<br/>        rules: [<br/>            {<br/>                test: /\.(js|jsx)$/,<br/>                exclude: /node_modules/,<br/>                use: {<br/>                    loader: "babel-loader"<br/>                }<br/>            },<br/>            {<br/>                test: /\.html$/,<br/>                use: [<br/>                    {<br/>                        loader: "html-loader"<br/>                    }<br/>                ]<br/>            }<br/>        ]<br/>    },<br/>    plugins: [<br/>        new CleanWebpackPlugin(),<br/>        new HtmlWebPackPlugin({<br/>            template: "./src/index.html",<br/>            filename: "./index.html",<br/>        })<br/>    ]<br/>};</span></pre><p id="8729" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将以下几行添加到<code class="du lh li lj lk b">webpack.development.js</code></p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="95b0" class="lu kf ht lk b fi lv lw l lx ly">const merge = require('webpack-merge');<br/>const common = require('./webpack.common');</span><span id="bdba" class="lu kf ht lk b fi lz lw l lx ly">module.exports = merge(common, {<br/>    mode: 'development',<br/>    devtool: 'inline-source-map',<br/>    devServer: {<br/>        contentBase: './dist',<br/>        hot: true<br/>    }<br/>});</span></pre><p id="6f92" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">…这几行到<code class="du lh li lj lk b">webpack.production.js</code></p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="54ea" class="lu kf ht lk b fi lv lw l lx ly">const merge = require('webpack-merge');<br/>const common = require('./webpack.common');</span><span id="2c59" class="lu kf ht lk b fi lz lw l lx ly">module.exports = merge(common, {<br/>    mode: 'production'<br/>});</span></pre><p id="6b98" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与之前的版本相比，这里有一些需要解释的变化:</p><h2 id="6881" class="lu kf ht bd kg ma mb mc kk md me mf ko jb mg mh ks jf mi mj kw jj mk ml la mm bi translated"><strong class="ak"> webpack.common.js </strong></h2><ul class=""><li id="867c" class="jp jq ht is b it lc ix ld jb mn jf mo jj mp jn ju jv jw jx bi translated">注意，我们已经添加了一个<code class="du lh li lj lk b">output</code>属性。它重命名包文件，并定义可以找到它的路径。</li><li id="5e5c" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">我们在这里不再有dev服务器定义。</li><li id="5452" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">我们正在利用<code class="du lh li lj lk b">CleanWebpackPlugin</code>清理<em class="kd"> dist </em>文件夹</li></ul><h2 id="fd17" class="lu kf ht bd kg ma mb mc kk md me mf ko jb mg mh ks jf mi mj kw jj mk ml la mm bi translated"><strong class="ak"> webpack.development.js </strong></h2><ul class=""><li id="dee8" class="jp jq ht is b it lc ix ld jb mn jf mo jj mp jn ju jv jw jx bi translated">很自然，dev服务器定义已经被移到了这个文件中</li><li id="86aa" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">我们启用了<code class="du lh li lj lk b">source maps</code></li></ul><h2 id="ef43" class="lu kf ht bd kg ma mb mc kk md me mf ko jb mg mh ks jf mi mj kw jj mk ml la mm bi translated"><strong class="ak"> webpack.production.js </strong></h2><ul class=""><li id="64a2" class="jp jq ht is b it lc ix ld jb mn jf mo jj mp jn ju jv jw jx bi translated">目前它只包含<code class="du lh li lj lk b">mode</code>定义，但是为以后添加额外的修改打开了大门。</li></ul><p id="b1e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那是许多信息！我们朝着建立这个项目迈出了重要的一步。尽管我已经尽力解释了这些概念和代码的变化，但我还是建议对每一个主题进行额外的阅读以获得完整的理解。Webpack是一个庞然大物--即使是最聪明的开发人员也很难在第一次通读中完全理解所有内容。让我们进入下一步。</p><h1 id="2bca" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">第二步</h1><p id="6a6f" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">在这一步中，我们将向我们的代码库添加测试框架！我们需要添加两个框架，一个测试功能性JS，另一个测试React组件。它们分别叫做Jest和Enzyme。一旦我们完成配置，我们将编写一个简单的小型JS模块和React组件来测试它们。我们将设置它们，并在不同的步骤中使用它们。我们开始吧！</p><p id="e1b7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将首先安装<code class="du lh li lj lk b">Jest</code>,作为一个开发依赖项，因为它是一个测试框架，在产品包中没有用处。要安装，</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="b4fb" class="lu kf ht lk b fi lv lw l lx ly">npm install jest --save-dev</span></pre><p id="31a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将添加一个名为<code class="du lh li lj lk b">jest.config.js</code>的文件到我们代码库的根目录中，它将指示我们想要如何配置我们的测试。这是Jest的<a class="ae jo" href="https://jestjs.io/docs/en/23.x/configuration" rel="noopener ugc nofollow" target="_blank">官方文档</a>页面，包含了每一项配置的细节——值得一读。</p><p id="ca29" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们不需要所有的部分，因此我浓缩了必要的部分来编写我们自己的自定义配置文件。它包含了对每一部分所做工作的详细评论。这是我们正在配置的项目的<code class="du lh li lj lk b">jest.config.js</code>文件的样子</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="0500" class="lu kf ht lk b fi lv lw l lx ly">// For a detailed explanation regarding each configuration property, visit:<br/>// <a class="ae jo" href="https://jestjs.io/docs/en/configuration.html" rel="noopener ugc nofollow" target="_blank">https://jestjs.io/docs/en/configuration.html</a></span><span id="5169" class="lu kf ht lk b fi lz lw l lx ly">module.exports = {<br/>    // All imported modules in your tests should be mocked automatically<br/>    // automock: false,</span><span id="d35d" class="lu kf ht lk b fi lz lw l lx ly">// Stop running tests after the first failure<br/>    // bail: false,</span><span id="8cb1" class="lu kf ht lk b fi lz lw l lx ly">// Respect "browser" field in package.json when resolving modules<br/>    // browser: false,</span><span id="80f0" class="lu kf ht lk b fi lz lw l lx ly">// The directory where Jest should store its cached dependency information<br/>    // cacheDirectory: "C:\\Users\\VenD\\AppData\\Local\\Temp\\jest",</span><span id="fdcf" class="lu kf ht lk b fi lz lw l lx ly">// Automatically clear mock calls and instances between every test<br/>    clearMocks: true,</span><span id="7aa8" class="lu kf ht lk b fi lz lw l lx ly">// Indicates whether the coverage information should be collected while executing the test<br/>    // collectCoverage: false,</span><span id="1bbd" class="lu kf ht lk b fi lz lw l lx ly">// An array of glob patterns indicating a set of files for which coverage information should be collected<br/>    collectCoverageFrom: ['src/tests/*.test.js'],</span><span id="f862" class="lu kf ht lk b fi lz lw l lx ly">// The directory where Jest should output its coverage files<br/>    coverageDirectory: 'src/tests/coverage',</span><span id="ca30" class="lu kf ht lk b fi lz lw l lx ly">// An array of regexp pattern strings used to skip coverage collection<br/>    coveragePathIgnorePatterns: [<br/>      "\\\\node_modules\\\\"<br/>    ],</span><span id="9d98" class="lu kf ht lk b fi lz lw l lx ly">// A list of reporter names that Jest uses when writing coverage reports<br/>    coverageReporters: [<br/>      "json",<br/>      "text",<br/>      "lcov",<br/>      "clover"<br/>    ],</span><span id="d5fe" class="lu kf ht lk b fi lz lw l lx ly">// An object that configures minimum threshold enforcement for coverage results<br/>    coverageThreshold: {<br/>        "global": {<br/>            "branches": 80,<br/>            "functions": 80,<br/>            "lines": 80<br/>        }<br/>    },</span><span id="4dce" class="lu kf ht lk b fi lz lw l lx ly">// Make calling deprecated APIs throw helpful error messages<br/>    errorOnDeprecated: false,</span><span id="009e" class="lu kf ht lk b fi lz lw l lx ly">// Force coverage collection from ignored files using an array of glob patterns<br/>    // forceCoverageMatch: [],</span><span id="2933" class="lu kf ht lk b fi lz lw l lx ly">// A path to a module which exports an async function that is triggered once before all test suites<br/>    // globalSetup: null,</span><span id="54b4" class="lu kf ht lk b fi lz lw l lx ly">// A path to a module which exports an async function that is triggered once after all test suites<br/>    // globalTeardown: null,</span><span id="340e" class="lu kf ht lk b fi lz lw l lx ly">// A set of global variables that need to be available in all test environments<br/>    // globals: {},</span><span id="390f" class="lu kf ht lk b fi lz lw l lx ly">// An array of directory names to be searched recursively up from the requiring module's location<br/>    // moduleDirectories: [<br/>    //   "node_modules"<br/>    // ],</span><span id="2799" class="lu kf ht lk b fi lz lw l lx ly">// An array of file extensions your modules use<br/>    moduleFileExtensions: ['js', 'json', 'jsx'],</span><span id="44c9" class="lu kf ht lk b fi lz lw l lx ly">// A map from regular expressions to module names that allow to stub out resources with a single module<br/>    // moduleNameMapper: {},</span><span id="0711" class="lu kf ht lk b fi lz lw l lx ly">// An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader<br/>    // modulePathIgnorePatterns: [],</span><span id="c0a5" class="lu kf ht lk b fi lz lw l lx ly">// Activates notifications for test results<br/>    // notify: false,</span><span id="9919" class="lu kf ht lk b fi lz lw l lx ly">// An enum that specifies notification mode. Requires { notify: true }<br/>    // notifyMode: "always",</span><span id="682c" class="lu kf ht lk b fi lz lw l lx ly">// A preset that is used as a base for Jest's configuration<br/>    // preset: null,</span><span id="5041" class="lu kf ht lk b fi lz lw l lx ly">// Run tests from one or more projects<br/>    // projects: null,</span><span id="a3b0" class="lu kf ht lk b fi lz lw l lx ly">// Use this configuration option to add custom reporters to Jest<br/>    // reporters: undefined,</span><span id="bfed" class="lu kf ht lk b fi lz lw l lx ly">// Automatically reset mock state between every test<br/>    resetMocks: false,</span><span id="af3b" class="lu kf ht lk b fi lz lw l lx ly">// Reset the module registry before running each individual test<br/>    // resetModules: false,</span><span id="ffd9" class="lu kf ht lk b fi lz lw l lx ly">// A path to a custom resolver<br/>    // resolver: null,</span><span id="9a2e" class="lu kf ht lk b fi lz lw l lx ly">// Automatically restore mock state between every test<br/>    restoreMocks: true,</span><span id="41b9" class="lu kf ht lk b fi lz lw l lx ly">// The root directory that Jest should scan for tests and modules within<br/>    // rootDir: null,</span><span id="a14a" class="lu kf ht lk b fi lz lw l lx ly">// A list of paths to directories that Jest should use to search for files in<br/>    // roots: [<br/>    //   "&lt;rootDir&gt;"<br/>    // ],</span><span id="51d5" class="lu kf ht lk b fi lz lw l lx ly">// Allows you to use a custom runner instead of Jest's default test runner<br/>    // runner: "jest-runner",</span><span id="f324" class="lu kf ht lk b fi lz lw l lx ly">// The paths to modules that run some code to configure or set up the testing environment before each test<br/>    // setupFiles: ['&lt;rootDir&gt;/enzyme.config.js'],</span><span id="2ee4" class="lu kf ht lk b fi lz lw l lx ly">// The path to a module that runs some code to configure or set up the testing framework before each test<br/>    // setupTestFrameworkScriptFile: '',</span><span id="6f46" class="lu kf ht lk b fi lz lw l lx ly">// A list of paths to snapshot serializer modules Jest should use for snapshot testing<br/>    // snapshotSerializers: [],</span><span id="0727" class="lu kf ht lk b fi lz lw l lx ly">// The test environment that will be used for testing<br/>    testEnvironment: 'jsdom',</span><span id="9b74" class="lu kf ht lk b fi lz lw l lx ly">// Options that will be passed to the testEnvironment<br/>    // testEnvironmentOptions: {},</span><span id="fba6" class="lu kf ht lk b fi lz lw l lx ly">// Adds a location field to test results<br/>    // testLocationInResults: false,</span><span id="57ae" class="lu kf ht lk b fi lz lw l lx ly">// The glob patterns Jest uses to detect test files<br/>    testMatch: ['**/__tests__/**/*.js?(x)', '**/?(*.)+(spec|test).js?(x)'],</span><span id="f8b5" class="lu kf ht lk b fi lz lw l lx ly">// An array of regexp pattern strings that are matched against all test paths, matched tests are skipped<br/>    testPathIgnorePatterns: ['\\\\node_modules\\\\'],</span><span id="739f" class="lu kf ht lk b fi lz lw l lx ly">// The regexp pattern Jest uses to detect test files<br/>    // testRegex: "",</span><span id="8ea2" class="lu kf ht lk b fi lz lw l lx ly">// This option allows the use of a custom results processor<br/>    // testResultsProcessor: null,</span><span id="79fc" class="lu kf ht lk b fi lz lw l lx ly">// This option allows use of a custom test runner<br/>    // testRunner: "jasmine2",</span><span id="82fe" class="lu kf ht lk b fi lz lw l lx ly">// This option sets the URL for the jsdom environment. It is reflected in properties such as location.href<br/>    testURL: '<a class="ae jo" href="http://localhost:3030'" rel="noopener ugc nofollow" target="_blank">http://localhost:3030'</a>,</span><span id="c3e2" class="lu kf ht lk b fi lz lw l lx ly">// Setting this value to "fake" allows the use of fake timers for functions such as "setTimeout"<br/>    // timers: "real",</span><span id="65b2" class="lu kf ht lk b fi lz lw l lx ly">// A map from regular expressions to paths to transformers<br/>    // transform: {},</span><span id="0961" class="lu kf ht lk b fi lz lw l lx ly">// An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation<br/>    transformIgnorePatterns: ['&lt;rootDir&gt;/node_modules/'],</span><span id="f24f" class="lu kf ht lk b fi lz lw l lx ly">// An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them<br/>    // unmockedModulePathPatterns: undefined,</span><span id="2558" class="lu kf ht lk b fi lz lw l lx ly">// Indicates whether each individual test should be reported during the run<br/>    verbose: false,</span><span id="80f8" class="lu kf ht lk b fi lz lw l lx ly">// An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode<br/>    // watchPathIgnorePatterns: [],</span><span id="bd0c" class="lu kf ht lk b fi lz lw l lx ly">// Whether to use watchman for file crawling<br/>    watchman: true,<br/>};</span></pre><p id="cbb7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据我们的配置，我们的测试应该位于<code class="du lh li lj lk b">/src</code>中一个名为<code class="du lh li lj lk b">tests</code>的目录中。让我们继续创建它——在我们讨论创建目录的主题时，让我们总共创建三个<em class="kd">目录，以便我们为指南的后续步骤做好准备</em></p><ul class=""><li id="ded5" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><code class="du lh li lj lk b">tests</code> -包含我们测试的目录</li><li id="ad03" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">我们将把我们的功能性JS文件放在这里，比如helper、utils、services等。</li><li id="0a30" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><code class="du lh li lj lk b">core/scss</code> -这将包含浏览器重置、全局变量声明。我们将在以后的文章中添加这些内容。</li></ul><p id="323c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，我们正在进步！现在我们有了一个好的测试设置，让我们在<code class="du lh li lj lk b">core/js</code>中创建一个简单的JS模块<code class="du lh li lj lk b">multiply.js</code></p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="54b6" class="lu kf ht lk b fi lv lw l lx ly">const multiply = (a, b) =&gt; {<br/>    return a* b;<br/>};</span><span id="2eb3" class="lu kf ht lk b fi lz lw l lx ly">export default multiply;</span></pre><p id="b094" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">…并通过在<code class="du lh li lj lk b">tests</code>目录中创建一个名为<code class="du lh li lj lk b">multiply.spec.js</code>的文件来为它编写测试。</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="3702" class="lu kf ht lk b fi lv lw l lx ly">import multiply from '../core/js/multiply';</span><span id="1b2f" class="lu kf ht lk b fi lz lw l lx ly">describe('The Multiply module test suite', () =&gt; {<br/>    it('is a public function', () =&gt; {<br/>        expect(multiply).toBeDefined();<br/>    });</span><span id="e2c3" class="lu kf ht lk b fi lz lw l lx ly">it('should correctly multiply two numbers', () =&gt; {<br/>        const expected = 6;<br/>        const actual1 = multiply(2, 3);<br/>        const actual2 = multiply(1, 6);</span><span id="09cc" class="lu kf ht lk b fi lz lw l lx ly">expect(actual1).toEqual(expected);<br/>        expect(actual2).toEqual(expected);<br/>    });</span><span id="0135" class="lu kf ht lk b fi lz lw l lx ly">it('should not multiply incorrectly', () =&gt; {<br/>        const notExpected = 10;<br/>        const actual = multiply(3, 5);</span><span id="8e8c" class="lu kf ht lk b fi lz lw l lx ly">expect(notExpected).not.toEqual(actual);<br/>    });<br/>});</span></pre><p id="ffb9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一项配置是在我们的<code class="du lh li lj lk b">package.json</code>中添加一个脚本，它将运行我们所有的测试。它将存在于<code class="du lh li lj lk b">scripts</code>属性中</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="2b11" class="lu kf ht lk b fi lv lw l lx ly">"scripts": {<br/>    "test": "jest",<br/>    "build": "webpack --config webpack.production.js",<br/>    "start": "webpack-dev-server --open --config webpack.development.js"<br/>  },</span></pre><p id="67ec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果我们在终端中运行<code class="du lh li lj lk b">npm run test</code>(在项目的根目录中)，它将运行我们所有的测试并产生如下输出。</p><figure class="lm ln lo lp fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mq"><img src="../Images/dc4be4aea1a5b4458630177d80b5acd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YoZH3cnoC_1lPQ0B"/></div></div></figure><p id="d3f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以继续以类似的方式添加更多的模块和测试套件。让我们进入下一步！</p><h1 id="804e" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">第三步</h1><p id="cec2" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">是时候安装酶并测试我们的React组件了！我们需要安装一个与我们正在使用的React版本相对应的酶版本，即<strong class="is hu"> 16 </strong>。要做到这一点，我们需要做以下事情，记住这个工具也将作为一个开发依赖项来安装，因为像Jest一样，测试框架不需要被编译成产品捆绑包</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="15e0" class="lu kf ht lk b fi lv lw l lx ly">npm install enzyme enzyme-adapter-react-16 --save dev</span></pre><p id="1c90" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将在项目的根目录下创建<code class="du lh li lj lk b">enzyme.config.js</code>，类似于我们为Jest所做的。该文件应该是这样的</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="0fa7" class="lu kf ht lk b fi lv lw l lx ly">import { configure } from 'enzyme';<br/>import Adapter from 'enzyme-adapter-react-16';</span><span id="5a4f" class="lu kf ht lk b fi lz lw l lx ly">configure({ adapter: new Adapter() });</span></pre><p id="9206" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果你去看一看第119行<code class="du lh li lj lk b">jest.config.js</code>，你会发现我们已经为这一刻做好了准备，我们设置了酶来与Jest一起工作。所有需要做的就是取消第119行的注释，我们的设置就完成了！</p><p id="d20e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们为<code class="du lh li lj lk b">&lt;App /&gt;</code>组件写一个测试，看看我们设置的是否有效。在<code class="du lh li lj lk b">tests</code>中创建一个名为<code class="du lh li lj lk b">components</code>的目录——它将保存您将在未来编写的组件的所有测试。创建了一个单独的目录来将功能测试和组件测试分开。这种分离可以以任何方式进行，只要所有的测试都在<code class="du lh li lj lk b">src/tests</code>目录中。当应用程序开始增长时，这将有助于未来的发展。</p><p id="81b2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du lh li lj lk b">src/tests/components</code>目录中，创建一个名为<code class="du lh li lj lk b">App.spec.js</code>的文件，并添加以下几行</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="4d62" class="lu kf ht lk b fi lv lw l lx ly">import React from 'react';<br/>import { shallow} from 'enzyme';</span><span id="a6a3" class="lu kf ht lk b fi lz lw l lx ly">import App from '../../components/App';</span><span id="b61a" class="lu kf ht lk b fi lz lw l lx ly">describe('The App component test suite', () =&gt; {<br/>    it('should render component', () =&gt; {<br/>        expect(shallow(&lt;App /&gt;).contains(&lt;div&gt;Hello World&lt;/div&gt;)).toBe(true);<br/>    });<br/>});</span></pre><p id="d3f1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果我们在终端中运行我们的测试脚本，您将看到这个测试正在运行并通过！</p><figure class="lm ln lo lp fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mq"><img src="../Images/6b6e63a70a6901e578266f229cd7d0c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BWgHgHnUJQFq02B7"/></div></div></figure><p id="55ed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">请注意:</strong> <em class="kd">在步骤2和3中，我们已经简单地在我们的代码库中设置了Jest和Enzyme一起工作。为了证明设置正在工作，我们编写了两个过于简单的测试。写好测试的艺术是完全不同的，这些测试不应该被当作任何形式的指导。</em></p><h1 id="d03a" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">第四步</h1><p id="0520" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">在指南的这一部分，我们将配置我们的代码库以提供<code class="du lh li lj lk b">.scss</code>支持。然而，在我们学会跑之前，我们需要学会走——这意味着我们必须先加载CSS。</p><p id="74f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们去拿必要的npm包吧</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="ca6a" class="lu kf ht lk b fi lv lw l lx ly">npm install css-loader style-loader --save-dev<br/>npm install node-sass sass-loader --save</span></pre><p id="f4d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kd">在下面的解释块中，您可以点击出现的工具名称来访问它们的官方文档。</em></p><ul class=""><li id="bdc1" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><code class="du lh li lj lk b">css-loader</code>是一个webpack插件，它解释和解析类似于<code class="du lh li lj lk b">@import</code>或<code class="du lh li lj lk b">url()</code>的语法，这些语法用于在组件中包含<code class="du lh li lj lk b">.scss</code>文件。</li><li id="85f7" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><code class="du lh li lj lk b"><a class="ae jo" href="https://webpack.js.org/loaders/style-loader/" rel="noopener ugc nofollow" target="_blank">style-loader</a></code>是一个webpack插件，将编译好的CSS文件注入DOM。</li><li id="201d" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><code class="du lh li lj lk b">node-sass</code>是一个Node.js库，它绑定到一个流行的样式表预处理程序。它让我们可以在节点环境中将<code class="du lh li lj lk b">.scss</code>文件编译成CSS。</li><li id="b0d2" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">是一个webpack插件，允许我们在项目中使用Sass。</li></ul><p id="c355" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我们已经安装了必要的npm包，我们需要告诉webpack使用它们。在<code class="du lh li lj lk b">webpack.common.js</code>中，在<code class="du lh li lj lk b">rules</code>数组中我们使用<code class="du lh li lj lk b">babel-loader</code>和<code class="du lh li lj lk b">html-loader</code>的地方添加以下行</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="1442" class="lu kf ht lk b fi lv lw l lx ly">{<br/>    test: /\.s[ac]ss$/i,<br/>    use: [<br/>        // Creates `style` nodes from JS strings<br/>        'style-loader',<br/>        // Translates CSS into CommonJS<br/>        'css-loader',<br/>        // Compiles Sass to CSS<br/>        'sass-loader',<br/>    ]<br/>}</span></pre><p id="1df2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设置完成了！让我们写一些sass！在<code class="du lh li lj lk b">src/components</code>目录中，创建一个名为<code class="du lh li lj lk b">App.scss</code>的文件，并添加以下几行</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="960c" class="lu kf ht lk b fi lv lw l lx ly">#app-container {<br/>    letter-spacing: 1px;<br/>    padding-top: 40px;</span><span id="807f" class="lu kf ht lk b fi lz lw l lx ly">&amp; &gt; div {<br/>        display: flex;<br/>        font-size: 25px;<br/>        font-weight: bold;<br/>        justify-content: center;<br/>        margin: 0 auto;<br/>    }<br/>}</span></pre><p id="9466" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kd">sass语法的解释超出了本文的范围。这是一本优秀的</em> <a class="ae jo" href="https://blog.teamtreehouse.com/the-absolute-beginners-guide-to-sass" rel="noopener ugc nofollow" target="_blank"> <em class="kd">资源</em> </a> <em class="kd">供初学者更深入的学习。</em>现在，保存文件并通过运行<code class="du lh li lj lk b">npm run start</code>启动项目。应用程序应该加载我们刚刚编写的样式规则。</p><h1 id="6650" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">第五步</h1><p id="ca4e" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">是时候安装ESLint了。与我们目前所做的类似，我们需要安装几个npm包，然后向我们的代码库添加一个配置文件。这是一个纯粹用于开发目的的工具，所以我们将把它作为一个开发依赖项来安装。我们开始吧！</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="b097" class="lu kf ht lk b fi lv lw l lx ly">npm install eslint eslint-config-airbnb-base eslint-plugin-jest --save-dev</span></pre><ul class=""><li id="883e" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><code class="du lh li lj lk b">eslint-config-airbnb-base</code>是我们要求<code class="du lh li lj lk b">eslint</code>应用于我们项目的Airbnb风格指南。</li><li id="4f83" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><code class="du lh li lj lk b">eslint-plugin-jest</code>是用于<code class="du lh li lj lk b">jest</code>测试框架的eslint插件。</li></ul><p id="7580" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Airbnb风格指南也需要安装对等依赖项。你可以输入</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="c984" class="lu kf ht lk b fi lv lw l lx ly">npm info "eslint-config-airbnb@latest" peerDependencies</span></pre><p id="6267" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，要安装，请执行以下操作</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="a557" class="lu kf ht lk b fi lv lw l lx ly">npx install-peerdeps --dev eslint-config-airbnb</span></pre><p id="98b9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们需要在项目的根目录下创建一个名为<code class="du lh li lj lk b">.eslintrc.json</code>的文件(注意开头的<code class="du lh li lj lk b">.</code>，表示它是一个隐藏文件)，类似于其他配置文件(webpack、jest、enzyme、babel)的添加方式，</p><p id="9c30" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">…并添加这些行</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="c821" class="lu kf ht lk b fi lv lw l lx ly">{<br/>    "extends": "airbnb",<br/>    "plugins": ["jest"],<br/>    "env": {<br/>      "browser": true,<br/>      "jest": true<br/>    },<br/>    "rules": {<br/>      "arrow-body-style": [2, "always"],<br/>      "react/jsx-filename-extension": [1, { "extensions": [".js", ".jsx"] }],<br/>      "no-unused-expressions": "off",<br/>      "max-len": "off",<br/>      "import/no-extraneous-dependencies": "off",<br/>      "react/destructuring-assignment": "off",<br/>      "react/prop-types": "off"<br/>    }<br/>}</span></pre><p id="e1b5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想详细了解配置ESLint是如何工作的，那么官方文档是很好的读物。该文件中最相关的代码行是<code class="du lh li lj lk b">rules</code>对象——这里我们基本上覆盖了<em class="kd">样式指南中的一些</em>规则，以适应我们项目的特定需求。这些都不是一成不变的，所以请随意使用它们来最大限度地满足您的需求，但是忽略太多的规则可能不是一个好主意——这首先就违背了使用风格指南的目的。</p><p id="51b5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们给<code class="du lh li lj lk b">package.json</code>添加一个脚本，将Airbnb风格指南应用到我们的代码库中。我们需要告诉Eslint我们希望它扫描哪些文件和/或目录——所以我们会告诉它扫描所有的JS文件</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="7227" class="lu kf ht lk b fi lv lw l lx ly">"lint": "eslint '**/*.js' --ignore-pattern node_modules"</span></pre><p id="044d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果你在终端上运行<code class="du lh li lj lk b">npm run lint</code>，eslint将扫描脚本中指定的文件类型和模式，并显示一个问题列表。公平的警告，这个项目将会有相当多的错误，但是如果你使用流行的代码编辑器，比如IDEA products，Visual Studio Code，Sublime等，它们提供了开箱即用的支持来快速修复这些问题。</p><p id="9781" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kd">如果大量错误阻碍了您的学习，请运行</em> <code class="du lh li lj lk b"><em class="kd">npm uninstall eslint eslint-config-airbnb-base eslint-plugin-jest --save-dev</em></code>卸载ESLint</p><h1 id="728c" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">第六步</h1><p id="61dd" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">我们几乎完成了我们的项目设置--终点线就在我们眼前！在最后一步中，我们将配置我们的项目，以利用各种静态资产，如图像、SVG、图标和定制字体。</p><h2 id="d0c3" class="lu kf ht bd kg ma mb mc kk md me mf ko jb mg mh ks jf mi mj kw jj mk ml la mm bi translated"><strong class="ak">自定义字体</strong></h2><p id="9e87" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">任何可信的前端设置都应该使用不同的字体在页面上显示信息。字体的粗细和大小是所显示文本的上下文的指示器— —例如，页面或章节的标题往往是<em class="kd">大</em>和<em class="kd">粗</em>，而帮助文本通常是<em class="kd">小</em>、<em class="kd">亮</em>，甚至可能是<em class="kd">斜体</em>。</p><p id="2be8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有多种方法可以将自定义字体引入应用程序。大型企业代码库通常购买字体许可证，并将它们的静态资产作为托管应用程序的服务器的一部分。这样做的过程有点复杂--我们需要一个专门的部分来完成它。</p><p id="a225" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用自定义字体最方便的方式是使用公共领域库，该库拥有大量收藏并托管在CDN(内容交付网络)上，如<a class="ae jo" href="https://fonts.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Fonts </a>。这很方便，因为我们需要做的就是，选择一些我们喜欢的字体，然后简单地将它们嵌入到我们的静态标记中</p><p id="eadc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">…我们准备好了！所以让我们开始吧。出于我们的目的，我们将使用<code class="du lh li lj lk b">Roboto Mono</code>字体系列。</p><p id="992f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">打开<code class="du lh li lj lk b">index.html</code>，将下面的样式表<code class="du lh li lj lk b">link</code>粘贴到<code class="du lh li lj lk b">head</code>中</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="2355" class="lu kf ht lk b fi lv lw l lx ly">&lt;link rel="stylesheet" href="<a class="ae jo" href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="noopener ugc nofollow" target="_blank">https://fonts.googleapis.com/css?family=Roboto+Mono</a>"&gt;</span></pre><p id="d119" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们完了。现在我们可以在任何一个<code class="du lh li lj lk b">.scss</code>文件中使用<code class="du lh li lj lk b">font-family: 'Roboto Mono'</code>。我们可以用这种方式使用任意数量的字体。</p><h2 id="e816" class="lu kf ht bd kg ma mb mc kk md me mf ko jb mg mh ks jf mi mj kw jj mk ml la mm bi translated"><strong class="ak">图像</strong></h2><p id="d8cf" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">像字体一样，图像是前端设置的重要组成部分。为了使我们的项目能够利用应用程序中的图像，我们需要为webpack安装一个加载器。这一步与我们在本指南中多次做的是一样的— —安装加载程序，并在webpack配置中添加几行代码来使用它</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="0393" class="lu kf ht lk b fi lv lw l lx ly">npm install url-loader --save-dev</span></pre><p id="0943" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">…然后将以下几行添加到<code class="du lh li lj lk b">webpack.common.js</code>中的<code class="du lh li lj lk b">rules</code>数组</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="6786" class="lu kf ht lk b fi lv lw l lx ly">...<br/>{<br/>  test: /\.(jpg|png)$/,<br/>  use: {<br/>    loader: 'url-loader',<br/>  },<br/>},<br/>...</span></pre><p id="4726" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">项目现在可以使用类型为<code class="du lh li lj lk b">.jpg</code>和<code class="du lh li lj lk b">.png</code>的图像了。为了进行演示，在项目的根目录下创建一个<code class="du lh li lj lk b">public/images</code>文件夹。然后在子目录<code class="du lh li lj lk b">images</code>中添加<em class="kd">一张</em>图片。出于我们的目的，我从Unsplash下载了一个免费图像，并将其命名为<code class="du lh li lj lk b">coffee.png</code></p><p id="ac88" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将在<code class="du lh li lj lk b">src/components</code>中创建一个名为Image的目录——然后创建<code class="du lh li lj lk b">Image</code>组件。</p><p id="50b0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lh li lj lk b">Image.js</code></p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="c45d" class="lu kf ht lk b fi lv lw l lx ly">import React from 'react';</span><span id="aa64" class="lu kf ht lk b fi lz lw l lx ly">const Image = (props) =&gt; {<br/>  return (<br/>    &lt;img<br/>      src={props.src}<br/>      alt={props.alt}<br/>      height={props.height}<br/>      wdth={props.wdth}<br/>    /&gt;<br/>  );<br/>};</span><span id="32e3" class="lu kf ht lk b fi lz lw l lx ly">export default Image;</span></pre><p id="a8fc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，在<code class="du lh li lj lk b">App.js</code>中导入<code class="du lh li lj lk b">Image</code>组件和实际图像<code class="du lh li lj lk b">coffee.png</code>。在这一点上，我们将不得不对<code class="du lh li lj lk b">App.js</code>做一些小的编辑来使用这张图片</p><pre class="lm ln lo lp fd lq lk lr ls aw lt bi"><span id="725d" class="lu kf ht lk b fi lv lw l lx ly">import React from 'react';<br/>import './App.scss';</span><span id="6247" class="lu kf ht lk b fi lz lw l lx ly">// component imports<br/>import Image from './Image/Image';</span><span id="e9a0" class="lu kf ht lk b fi lz lw l lx ly">// other imports<br/>import coffee from '../../public/images/coffee.png';</span><span id="8296" class="lu kf ht lk b fi lz lw l lx ly">const App = () =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;span&gt;Hello World&lt;/span&gt;<br/>      &lt;Image<br/>        src={coffee}<br/>        alt="hero"<br/>        height="400"<br/>        width="400"<br/>      /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="5425" class="lu kf ht lk b fi lz lw l lx ly">export default App;</span></pre><p id="660d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果您启动应用程序，您将看到图像正在页面上加载。</p><h1 id="8aa5" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">结论</h1><p id="089c" class="pw-post-body-paragraph iq ir ht is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">这就结束了我们从头开始建立一个现代React项目的逐步指南。这里有很多信息需要消化，但是仔细想想，我们已经从之前的最小设置走了很长一段路。我希望该指南帮助我了解了现代前端安装工具领域的一些关键概念。我为这个系列计划的未来作品是</p><ul class=""><li id="0a14" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">学习容器化的基础知识，以及如何在容器中部署这个项目。</li><li id="834b" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">为我们的项目增加额外的功能，比如JS文档，全面的测试运行输出(有颜色和覆盖率！)，更多的<code class="du lh li lj lk b">package.json</code>脚本，以及像重置和变量这样的全局scss样式表。</li></ul><p id="d8da" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请随时留下评论，分享给你的朋友。下一部再见！<em class="kd">回购高级设置可以在</em>  <em class="kd">这里找到</em> <a class="ae jo" href="https://github.com/all-things-javascript/advanced-react-webpack-babel" rel="noopener ugc nofollow" target="_blank"> <em class="kd">。</em></a></p><h2 id="9fcd" class="lu kf ht bd kg ma mb mc kk md me mf ko jb mg mh ks jf mi mj kw jj mk ml la mm bi translated">参考</h2><ol class=""><li id="f44b" class="jp jq ht is b it lc ix ld jb mn jf mo jj mp jn ll jv jw jx bi translated"><a class="ae jo" href="https://webpack.js.org/guides/production/" rel="noopener ugc nofollow" target="_blank"> Webpack环境变量和配置</a></li><li id="1296" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ll jv jw jx bi translated"><a class="ae jo" href="https://webpack.js.org/guides/output-management/" rel="noopener ugc nofollow" target="_blank"> Webpack输出管理</a></li><li id="bde4" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ll jv jw jx bi translated"><a class="ae jo" href="https://webpack.js.org/loaders/sass-loader/" rel="noopener ugc nofollow" target="_blank"> Sass-loader </a></li><li id="fe7d" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ll jv jw jx bi translated"><a class="ae jo" href="https://blog.teamtreehouse.com/the-absolute-beginners-guide-to-sass" rel="noopener ugc nofollow" target="_blank">Sass绝对初学者指南</a></li><li id="90b2" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ll jv jw jx bi translated"><a class="ae jo" href="https://eslint.org/docs/user-guide/configuring#top" rel="noopener ugc nofollow" target="_blank"> ESLint配置</a></li><li id="c4a8" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ll jv jw jx bi translated"><a class="ae jo" href="https://developers.google.com/fonts/docs/getting_started" rel="noopener ugc nofollow" target="_blank">谷歌网络字体—开始使用</a></li></ol><p id="bc5d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章最初发表在我的<a class="ae jo" href="https://nasidulislam.hashnode.dev/" rel="noopener ugc nofollow" target="_blank">博客</a>上。它有语法高亮！</p></div><div class="ab cl mr ms gp mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hb hc hd he hf"><p id="8cc1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kd">原载于</em><a class="ae jo" href="https://nasidulislam.hashnode.dev/advanced-react-webpack-4-babel-7-web-application-setup" rel="noopener ugc nofollow" target="_blank"><em class="kd">https://nasidulislam . hashnode . dev</em></a><em class="kd">。</em></p></div></div>    
</body>
</html>