<html>
<head>
<title>Nature of Rust — Particles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">铁锈的性质——颗粒</h1>
<blockquote>原文：<a href="https://medium.com/codex/nature-of-rust-particles-40cec0a8c25e?source=collection_archive---------9-----------------------#2021-08-17">https://medium.com/codex/nature-of-rust-particles-40cec0a8c25e?source=collection_archive---------9-----------------------#2021-08-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5cce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以大约五年前，我正在完成我的博士学位，想要自学如何为了一点乐趣而编码。我不知道从哪里开始，发现很难做什么。直到我发现了编码列车YouTube频道。这个频道上展示的挑战很容易理解，也是学习新概念的有趣方式。</p><p id="c149" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，也是几年前，该频道发布了一个名为《代码处理的本质》(Java)和p5 JavaScript的系列文章。看到这些视频让我有了尝试这些例子的想法，但是是在Rust中。</p><p id="009c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以现在开始…</p><h1 id="9c61" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">什么是粒子？</strong></h1><p id="6992" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">对于此示例，粒子将被定义为具有以下属性的对象:</p><ul class=""><li id="e24d" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated"><strong class="ih hj">初始位置</strong> (x，y)</li><li id="7411" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">初始速度</strong> (Vx，Vy)</li><li id="1a76" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">初始尺寸</strong>:例如圆的半径</li><li id="6d7a" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">初始颜色</strong>:如果粒子在其生命周期中发生变化，则需要该颜色</li><li id="59ed" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">初始形状</strong></li><li id="53a9" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">寿命</strong>:粒子将在窗口中存在固定的寿命</li></ul><p id="3a2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了这些属性，粒子还会受到力的影响，例如重力，粒子对象需要能够处理这种情况。牛顿第二定律可以用下面的等式来概括:</p><p id="78a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ku">力=质量x加速度</em> </strong></p><p id="878f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简化示例，我假设所有粒子的质量都是1，因此等式变为:</p><p id="ad13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="ku">力=加速度</em> </strong></p><p id="a564" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这个我可以改变粒子的速度并更新粒子在屏幕中的位置。</p><h1 id="8289" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">你如何用Rust创作一幅油画？</h1><p id="e76f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这是要克服的第一个挑战，对于这个问题，我们想画一个粒子，但是在哪里以及如何在铁锈中画任何东西。这个比较容易解决。Rust中有两个名为<strong class="ih hj"> piston </strong>和<strong class="ih hj"> piston_window </strong>的库，使您能够创建画布并在画布上绘制形状。要使用它们，在<strong class="ih hj"> <em class="ku"> Cargo.toml </em> </strong>文件中，添加以下依赖项:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="1c9f" class="le je hi la b fi lf lg l lh li">.....<br/>[dependencies]<br/>piston = "0.53.0"<br/>piston_window = "0.120.0"</span></pre><p id="0093" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并在<strong class="ih hj"> <em class="ku"> main.rs </em> </strong>文件中添加以下内容:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="47eb" class="le je hi la b fi lf lg l lh li">extern crate piston_window;<br/>use piston_window::*;</span><span id="38b9" class="le je hi la b fi lj lg l lh li">fn main() {<br/>    let mut window: PistonWindow = WindowSettings::new("Name",<br/>                                    [400, 400])<br/>                                   .exit_on_esc(true)<br/>                                   .build()<br/>                                   .unwrap();<br/>    while let Some(e) = window.next() {<br/>        window.draw_2d(&amp;e, |c, g, _device| {<br/>            clear([0.0, 0.0, 0.0, 1.0], g);<br/>        });<br/>    }</span><span id="6a4b" class="le je hi la b fi lj lg l lh li">}</span></pre><p id="7c07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行时，这将创建一个名为“Name”的窗口，大小为400像素乘400像素。行<strong class="ih hj"> <em class="ku"> clear([0.0，0.0，0.0，1.0]，g) </em> </strong>正在设置窗口的颜色为黑色。四个数字的阵列以红、绿、蓝、阿尔法格式工作，通过在0.0和1.0之间改变数值，可以改变窗口的颜色。使用piston库时，这种数组格式用于设置放入窗口的所有对象的颜色。</p><h1 id="6cdf" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">创建粒子结构</strong></h1><p id="fb2e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在我们有了一个窗口，是时候考虑粒子结构和它需要什么属性了。上面的粒子定义已经定义了其中的一些属性，但是为了以后的完整性和方便性，还有一些额外的属性。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="3509" class="le je hi la b fi lf lg l lh li">pub struct Particle {<br/>    pub pos: Vec&lt;f64&gt;,<br/>    pub vel: Vec&lt;f64&gt;,<br/>    pub acc: Vec&lt;f64&gt;,<br/>    lifetime: f64,<br/>    size: f64,<br/>    colour: [f64; 4],<br/>    max_vel: f64,<br/>    max_acc: f64,<br/>    height: f64,<br/>    width: f64,<br/>}</span></pre><h1 id="032a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">实现粒子</h1><p id="77e9" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">既然已经定义了粒子，就需要实现它并创建相关的函数。第一个是<strong class="ih hj"> <em class="ku">新的</em> </strong>功能，它将用于创建一个粒子并初始化它的属性。这个函数将设置粒子的初始位置，它的速度，加速度以及粒子在画布上的高度和宽度。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="ea60" class="le je hi la b fi lf lg l lh li">impl Particle {<br/>    pub fn new(pos: Vec&lt;f64&gt;, vel: Vec&lt;f64&gt;, acc: Vec&lt;f64&gt;, <br/>           height: u32, width: u32) -&gt; Particle {<br/>        return Particle {<br/>            pos: pos, vel: vel, acc: acc,<br/>            lifetime: 1.0, size: 10.,<br/>            colour: [1.0, 0.0, 0.0, 1.0],<br/>            max_speed: 10.0, max_acc: 0.5,<br/>            height: height as f64,<br/>            width: width as f64,<br/>        };<br/>    }<br/>}</span></pre><h1 id="9e05" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">显示粒子</h1><p id="dc5a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在粒子已经被初始化了，它需要被绘制到屏幕上。为此，粒子的位置和大小需要在一个数组中给定到活塞窗口函数<strong class="ih hj"> <em class="ku">椭圆</em> </strong>。椭圆函数需要一个颜色数组、位置和大小数组以及绘制椭圆的窗口的细节。为了生成位置和大小数组，粒子实现可以有一个名为<strong class="ih hj"> <em class="ku"> show </em> </strong>的函数。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="1ff3" class="le je hi la b fi lf lg l lh li">impl Particle {</span><span id="6dbe" class="le je hi la b fi lj lg l lh li">    ....</span><span id="cc39" class="le je hi la b fi lj lg l lh li">    pub fn show(&amp;self) -&gt; [f64; 4] {<br/>        return [self.pos[0], self.pos[1], self.size, self.size];<br/>   }</span><span id="0761" class="le je hi la b fi lj lg l lh li">} </span></pre><p id="caca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj"> main.rs文件</strong>中，让我们在画布中间创建一个粒子(x = 200，y = 200)。它将以一个随机的速度初始化，并且会有一个小的向下的加速度作用在它上面。要设置粒子的颜色，将在活塞窗口中传递结构的寿命属性<strong class="ih hj"> <em class="ku"> color::alpha </em> </strong>函数来设置粒子在屏幕上的透明度。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="7b99" class="le je hi la b fi lf lg l lh li">extern crate piston_window;<br/>use piston_window::*;<br/>use rand::Rng;</span><span id="795a" class="le je hi la b fi lj lg l lh li">pub const WIDTH: u32 = 400;<br/>pub const HEIGHT: u32 = 400;</span><span id="dc45" class="le je hi la b fi lj lg l lh li">fn main() {<br/>    let mut rng = rand::thread_rng();</span><span id="8d27" class="le je hi la b fi lj lg l lh li">    let mut particle = Particle::new(Particle::new(<br/>        vec![200., 200.],<br/>        vec![rng.gen_range(-1.0..1.0), rng.gen_range(-1.0..1.0)],<br/>        vec![0.0, 0.1],<br/>        HEIGHT,<br/>        WIDTH,<br/>     );</span><span id="3b3e" class="le je hi la b fi lj lg l lh li">    let mut window: PistonWindow = WindowSettings::new("Name",<br/>                                    [400, 400])<br/>                                   .exit_on_esc(true)<br/>                                   .build()<br/>                                   .unwrap();<br/>    while let Some(e) = window.next() {<br/>        window.draw_2d(&amp;e, |c, g, _device| {<br/>            clear([0.0, 0.0, 0.0, 1.0], g);</span><span id="2f3b" class="le je hi la b fi lj lg l lh li">            ellipse(color::alpha(particle.lifetime),<br/>                    particle.show(), c.transform, g);<br/>        });<br/>    }</span><span id="df70" class="le je hi la b fi lj lg l lh li">}</span></pre><h1 id="7775" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">更新粒子</h1><p id="023d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">运行上面的代码会在屏幕上生成一个静态粒子。要让它移动，粒子必须在帧之间更新，为此，另一个函数被添加到名为<strong class="ih hj"> update </strong>的粒子实现中。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="32a5" class="le je hi la b fi lf lg l lh li">impl Particle {</span><span id="25d9" class="le je hi la b fi lj lg l lh li">....</span><span id="c9d5" class="le je hi la b fi lj lg l lh li">    pub fn update(&amp;mut self) {<br/>        <em class="ku">self</em>.pos[0] = <em class="ku">self</em>.pos[0] + <em class="ku">self</em>.vel[0];<br/>        s<em class="ku">elf</em>.pos[1] = <em class="ku">self</em>.pos[1] + <em class="ku">self</em>.vel[1];<br/>        <em class="ku">self</em>.vel[0] = <em class="ku">self</em>.vel[0] + <em class="ku">self</em>.acc[0];<br/>        <em class="ku">self</em>.vel[1] = <em class="ku">self</em>.vel[1] + <em class="ku">self</em>.acc[1];<br/>        <br/>        <em class="ku">self</em>.check_limits();<br/>        <em class="ku">self</em>.edges();</span><span id="e34a" class="le je hi la b fi lj lg l lh li"><em class="ku">        self</em>.lifetime = <em class="ku">self</em>.lifetime - 0.002;<br/>    }</span><span id="d47f" class="le je hi la b fi lj lg l lh li">}</span></pre><p id="c191" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个函数中，有两个其他函数与粒子相关联。这些是<strong class="ih hj"> <em class="ku">边，</em> </strong>检查粒子是否在边上，如果在边上，将反转运动平面上的速度。这确保了粒子不会从屏幕上消失。第二个功能<strong class="ih hj"> <em class="ku"> check_limits </em> </strong>查看是否超过了最大速度或加速度。如果有，粒子的速度或加速度都被重置为最大允许值。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="1417" class="le je hi la b fi lf lg l lh li">impl Particle {</span><span id="58b5" class="le je hi la b fi lj lg l lh li">....</span><span id="d1c8" class="le je hi la b fi lj lg l lh li">fn check_limits(&amp;mut <em class="ku">self</em>) {<br/>        if <em class="ku">self</em>.vel[0] &gt; <em class="ku">self</em>.max_vel {<br/>            <em class="ku">self</em>.vel[0] = <em class="ku">self</em>.max_vel;<br/>        }<br/>        if <em class="ku">self</em>.vel[1] &gt; <em class="ku">self</em>.max_vel {<br/>            <em class="ku">self</em>.vel[1] = <em class="ku">self</em>.max_vel;<br/>        }<br/>        if <em class="ku">self</em>.acc[0] &gt; <em class="ku">self</em>.max_acc {<br/>            <em class="ku">self</em>.acc[0] = <em class="ku">self</em>.max_acc;<br/>        }<br/>        if <em class="ku">self</em>.acc[1] &gt; <em class="ku">self</em>.max_acc {<br/>            <em class="ku">self</em>.acc[1] = <em class="ku">self</em>.max_acc;<br/>        }<br/>    }</span><span id="0bfa" class="le je hi la b fi lj lg l lh li">    fn edges(&amp;mut <em class="ku">self</em>) {<br/>       if <em class="ku">self</em>.pos[1] &gt;= <em class="ku">self</em>.height || <em class="ku">self</em>.pos[1] &lt;= 0.0 {<br/>            <em class="ku">self</em>.vel[1] = <em class="ku">self</em>.vel[1] * -1.0;<br/>        }<br/>        if <em class="ku">self</em>.pos[0] &gt;= <em class="ku">self</em>.width || <em class="ku">self</em>.pos[0] &lt;= 0.0 {<br/>            <em class="ku">self</em>.vel[0] = <em class="ku">self</em>.vel[0] * -1.0;<br/>        }<br/>    }</span><span id="8aa8" class="le je hi la b fi lj lg l lh li">}</span></pre><p id="3b18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于update函数，最后要提到的是每次调用函数时lifetime属性减少的方式。如前所述，粒子需要有一个生命周期，通过减少每一帧的生命周期，粒子将变得更加透明，直到最后看不见为止。当在屏幕上看不到它时，这个粒子就到达了它的寿命终点。</p><p id="b783" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在在正在绘制画布的while循环内的<strong class="ih hj"> main.rs文件</strong>中，可以添加行<strong class="ih hj"><em class="ku">particle . update()</em></strong>。这将确保每次循环完成时，粒子属性都会更新，并在屏幕上移动。</p><h1 id="98bc" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">粒子发射器</strong></h1><p id="2000" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在我们有了一个粒子，可能会有一些乐趣。一种类型的粒子系统是<strong class="ih hj">粒子发射器。</strong> <em class="ku"> </em>这里粒子以随机的速度从一个固定点发射出来，在轻微的重力作用下产生级联效应。</p><p id="b6d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了创建发射器，粒子被存储在一个矢量中，并且画布的每个循环都被绘制和更新。由于piston_window的帧速率，每10帧创建一个新粒子，因此程序的性能不受影响。</p><p id="4175" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后要做的事情是从所有粒子的向量中移除已经到达其寿命终点的粒子。通过反向循环粒子向量并移除寿命属性等于或小于零的粒子。</p><figure class="kv kw kx ky fd ll er es paragraph-image"><div class="er es lk"><img src="../Images/b7279d7fdd95a1c93823dbce29534d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*blmwZhxpN6oMmp40bOvHcw.png"/></div></figure><p id="0400" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要查看粒子发射器的代码，请参考我的项目<a class="ae lo" href="https://github.com/Jack-Sim/rust_particle_emitter/tree/main/rust_particles/src" rel="noopener ugc nofollow" target="_blank"> github repo </a></p><h1 id="64b9" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">总结</strong></h1><p id="6795" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我希望这是对粒子的一个有用的介绍，以及如何使用活塞和活塞窗箱在Rust中创建一个粒子模拟。这是一个简单的概述，除了我在这里创建的，粒子还有很多其他的用途。请随意对代码进行实验，并尝试提出其他示例，如果您真的这样做了，请在本文的评论中告诉我。</p><p id="5fee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">非常感谢您的阅读:)</p></div></div>    
</body>
</html>