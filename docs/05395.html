<html>
<head>
<title>Doing away with passwords in ASP.NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在ASP中取消密码。网</h1>
<blockquote>原文：<a href="https://medium.com/codex/doing-away-with-passwords-in-asp-net-fa65bd5fb601?source=collection_archive---------7-----------------------#2022-02-24">https://medium.com/codex/doing-away-with-passwords-in-asp-net-fa65bd5fb601?source=collection_archive---------7-----------------------#2022-02-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ed6d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">也许替代品应该有更大的吸引力，让用户少一些烦恼。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/825f85ce7901fc717ecef32a15eeb8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wuJW9PC9r7v1KK154LLnzw@2x.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">由<a class="ae jn" href="https://unsplash.com/@moneyphotos" rel="noopener ugc nofollow" target="_blank"> olieman.eth </a>上<a class="ae jn" href="https://unsplash.com/photos/r8VbpgMS6Uc" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="2090" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我第一次听说Medium时，远在我真正加入之前，我记得我被它的登录系统惊呆了。我看着我的老板通过查看他的电子邮件登录他的账户，并使用那个链接，我问“它不需要任何密码吗？”</p><p id="c9cd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">几年后，在阅读了大量关于如何保护网站、应用程序和设备的资料后，我开始意识到这种方法在安全性方面的诸多优势。</p><h1 id="a826" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">基本原理</h1><p id="2f57" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">对于开发应用程序、网站或其他任何处理用户身份验证的软件的任何人来说，最困难的安全任务之一是可靠地，尤其是安全地验证该用户。</p><p id="c019" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">处理用户的密码是一种将所述密码暴露给许多可能的攻击媒介的操作:</p><ul class=""><li id="32ba" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated">用户必须键入密码，这使得它容易受到键盘记录器的攻击</li><li id="fd9c" class="lh li hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">客户端应用程序(可能是浏览器，也可能是移动应用程序)需要将密码发送到服务器，因此任何数量的中间人或类似邪恶双胞胎的技术都可以工作，特别是如果用户不是特别懂安全的话</li><li id="b9d1" class="lh li hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">服务器接收并需要验证密码，因此，至少在一个实例中，某种形式的密码存储在服务器内存中的某个地方，使其容易受到更高级的漏洞的攻击</li><li id="076a" class="lh li hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated">需要存储密码，或者存储一个散列值，以便以后可以对其进行验证，这样，如果操作不正确，就容易受到攻击者的攻击</li></ul><p id="fffa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在应该很明显，针对密码的攻击面是巨大的，而且，尽管最近使用上述任何一种手段成功攻击变得越来越困难，但我们仍然面临着一个巨大的难题:</p><p id="06f3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用户。</p><p id="313a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果用户选择“password”作为他的密码，那么您的密码处理机制有多安全并不重要。如果你的客户的倒霉员工在众目睽睽之下把他们的密码写在便利贴上，那么你有一个强制使用非常强的密码的密码策略也没有什么区别。如果您有多因素身份验证，如果您不喜欢的用户不能区分实际的登录页面和钓鱼页面，这都无关紧要。</p><p id="2e4e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当然，这并不是什么新鲜事。该领域的主要参与者在保证用户安全方面遇到了真正的麻烦。大多数这样的玩家投入了大量的时间和精力来尽可能地保护东西。以一个<a class="ae jn" href="https://en.wikipedia.org/wiki/Active_Directory" rel="noopener ugc nofollow" target="_blank"> Active Directory </a>域的功能和灵活性为例，通过查看其内部概念和协议，想象一下这些年来它遇到了多少挑战。或者就拿<a class="ae jn" href="https://www.facebook.com/" rel="noopener ugc nofollow" target="_blank">脸书</a>来说，重大数据泄露事件多到有<a class="ae jn" href="https://selfkey.org/facebooks-data-breaches-a-timeline/" rel="noopener ugc nofollow" target="_blank">页面</a> <a class="ae jn" href="https://firewalltimes.com/facebook-data-breach-timeline/" rel="noopener ugc nofollow" target="_blank">专用</a>到<a class="ae jn" href="https://www.forbes.com/sites/kateoflahertyuk/2021/04/06/facebook-data-breach-heres-what-to-do-now/" rel="noopener ugc nofollow" target="_blank">分析</a> <a class="ae jn" href="https://haveibeenpwned.com/PwnedWebsites#Facebook" rel="noopener ugc nofollow" target="_blank">它们</a>。就连强调安全是其首要任务之一的苹果公司也未能幸免。</p><p id="1e4a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以任何一个新应用程序的开发者都应该问自己:我有足够的知识和经验来解决这个问题吗？我的解决方案真的能与历史悠久的身份认证解决方案相提并论吗？答案是，在大多数情况下，可能不会。</p><p id="e6f5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不要误解我的意思，软件开发和架构技能很可能不缺乏足够勇敢的人来接受这样的挑战。但是一个开发人员或一个小团队根本没有时间或资源来实现(尤其是维护！)以与该领域主要参与者相同的方式保护解决方案。并且有这样的态度“好吧，脸书是巨大的，谁会来lil' ol' Jackson O'Coder的网站？”一点帮助也没有:请记住，脸书有足够的资源从巨大的数据泄露中幸存下来(就像它在过去多次发生的那样)，但仅仅一个小的泄露就可能足以让你的企业从地球上消失。你可能最终没有人认为你值得他们花时间，但是，通常，这也意味着你的软件也不会带来很多客户。</p><h1 id="2aa7" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">毕竟，为什么要废除密码呢？</h1><p id="7a91" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">因此，在阅读了基本原理后，您仍然不相信，如果存在比使用密码更好的选择，您一定应该采用它，让我们来看看取消密码的一系列优点:</p><ol class=""><li id="2e55" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lv ln lo lp bi translated">不使用密码不会暴露他们的安全。这对用户来说是一个很大的优势，因为大多数人在多个应用程序中重复使用他们的密码，所以攻击者很有可能获得一个密码的访问权，从而获得这个人正在使用的大多数应用程序的访问权</li><li id="5602" class="lh li hi jq b jr lq ju lr jx ls kb lt kf lu kj lv ln lo lp bi translated">不使用密码大大降低了消耗的资源量，因为不需要额外的加密和/或散列，也不需要为此编写代码或分配存储空间</li><li id="50bc" class="lh li hi jq b jr lq ju lr jx ls kb lt kf lu kj lv ln lo lp bi translated">不使用密码丝毫不会妨碍任何框架正确认证用户的能力，也不会阻止用户维护会话</li><li id="60bf" class="lh li hi jq b jr lq ju lr jx ls kb lt kf lu kj lv ln lo lp bi translated">不使用密码严重降低了数据泄露时的责任，也严重限制了攻击者收集的数据的有用性。这种观点很可能会让任何企业的法律和财务部门欢呼雀跃，尤其是那些不会从用户那里收集太多数据的应用程序</li></ol><p id="7a9a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，进一步的优势来自于你可以选择废除密码的特定方式。作为一名ASP.NET开发者，和我一样，对于外部登录提供者有现成的解决方案和文档，像<a class="ae jn" href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/social/facebook-logins" rel="noopener ugc nofollow" target="_blank">脸书</a>、<a class="ae jn" href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/social/google-logins" rel="noopener ugc nofollow" target="_blank">谷歌</a>、<a class="ae jn" href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/social/twitter-logins" rel="noopener ugc nofollow" target="_blank">推特</a>、<a class="ae jn" href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/social/microsoft-logins" rel="noopener ugc nofollow" target="_blank">微软</a>、<a class="ae jn" href="https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-v2-aspnet-core-webapp" rel="noopener ugc nofollow" target="_blank"> Azure AD </a>、<a class="ae jn" href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/windowsauth" rel="noopener ugc nofollow" target="_blank"> Windows认证</a>或<a class="ae jn" href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/social/other-logins" rel="noopener ugc nofollow" target="_blank">其他通用提供者</a>，甚至多因素认证和TOTP方案。我不会在这里详细介绍，但是可以说，将身份验证委托给比您的开发团队更强大的第三方在开发效率、安全性以及用户参与度方面有其优势。</p><p id="f3ef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，本文不是关于委托给第三方。已经有大量相关文档了。但是，尽管它们有优势，但它们有一个严重的缺点:它们是第三方，因此，会使您的应用程序进入数据保护、跟踪和隐私的监管领域。这对于你的应用程序来说完全没问题，所以，无论如何，如果这种方法适合你的目的，就去用它吧。但如果没有，可能需要一个单独的方法。</p><h1 id="65c4" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">输入个人物品</h1><p id="d89d" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">可以有把握地假设，如果有人使用你的软件，他们至少可以访问一个电子邮件地址，可能还有一个电话号码。几乎可以肯定的是，他们会使用某种智能手机。</p><p id="a7f9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">近年来最大的安全改进之一是将智能手机融入日常生活。它在许多方面使事情变得更加安全，但最重要的安全改进实际上根本不是安全改进:让每个人都能随手拿到电子邮件的能力。</p><p id="031c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，人们连接笔记本电脑，将其连接到无密码的公共Wi-Fi热点，并导航到或多或少(通常不太安全)的网页，像hotshot69@smartypants-email.com一样查看他们喜欢的域名电子邮件的日子已经一去不复返了。此后，大多数用户都转向了少数几家标准化的提供商，然后这些提供商就可以开始正确地对待用户设备和服务器之间的网络，就像它实际上是一个不安全、最有可能是敌对的环境一样。通过将安全性集中在几个提供商身上，这些提供商和智能手机制造商已经设法使电子邮件足够安全。</p><p id="3a85" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">除此之外，还有电话网络的问题，每个设备都保证有一个严格监管的通信通道，如果不投入大量的金钱和时间，很难以实际的方式攻击。</p><p id="15ef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最重要的是，让设备尽可能安全的竞争还在继续。沙箱、锁定机制、内部安全、加密、查找我的设备技术、远程加锁选项等。所有这些协同工作，使每个人都拥有一个理想的多因素一体化身份验证设备。</p><h1 id="4de6" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">所以，让我们开始吧</h1><p id="8e9b" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">既然我已经解释了我们是如何接近的，我将做一个非常简短的代码介绍如何在ASP.NET正确地做这件事。出于这个目的，我将假设我们使用。NET 6，并且您已经掌握了一些如何正确处理基本ASP.NET应用程序的知识。</p><p id="e595" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">虽然我将使用电子邮件来尝试对用户进行身份验证，但您可能希望使用的任何其他方式(如短信、TOTP或推送通知)也应该使用相同的原则。</p><h2 id="f933" class="lw kl hi bd km lx ly lz kq ma mb mc ku jx md me kw kb mf mg ky kf mh mi la mj bi translated">第一步</h2><p id="763c" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我们首先需要在DI容器中设置身份和授权服务:</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="ac71" class="lw kl hi ml b fi mp mq l mr ms">// Authentication and authorization<br/>services.AddIdentity&lt;IdentityUser&lt;int&gt;, IdentityRole&lt;int&gt;&gt;()<br/>    .AddEntityFrameworkStores&lt;MyDbContext&gt;()<br/>    .AddDefaultTokenProviders();<br/> <br/>services.AddAuthorization(<br/>    options =&gt;<br/>    {<br/>        options.AddPolicy("AdministratorsOnly",<br/>            policyBuilder =&gt;<br/>            {<br/>                policyBuilder.RequireRole("Administrators");<br/>            });<br/>    });</span></pre><p id="dc5d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请注意，我在具有默认令牌提供者的实体框架数据存储中使用了具有整数主键的标准IdentityUser和IdentityRole实体。请根据自己的情况随意调整。在我的例子中，MyDbContext类被简单地定义为:</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="910a" class="lw kl hi ml b fi mp mq l mr ms">public class MyDbContext : IdentityDbContext&lt;IdentityUser&lt;int&gt;, IdentityRole&lt;int&gt;, int&gt;</span></pre><p id="6e2e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我还添加了一个“AdministratorsOnly”策略作为示例策略(检查用户是否属于“Administrators”组)，当然，您可以根据自己的需要进行调整。</p><p id="f41a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是添加所需的中间件:</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="1fd2" class="lw kl hi ml b fi mp mq l mr ms">app.UseAuthentication();<br/>app.UseAuthorization();</span></pre><p id="df5f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">根据中间件指示，在使用路由和端点的情况下，需要在<a class="ae jn" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.userouting" rel="noopener ugc nofollow" target="_blank">用户路由</a>和<a class="ae jn" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.useendpoints" rel="noopener ugc nofollow" target="_blank">用户端点</a>或Map…方法(<a class="ae jn" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.razorpagesendpointroutebuilderextensions.maprazorpages" rel="noopener ugc nofollow" target="_blank"> MapRazorPages </a>、<a class="ae jn" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollers" rel="noopener ugc nofollow" target="_blank"> MapControllers </a>等)之间添加这些。).</p><p id="d11d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是所有的管道，我们准备实施。</p><h2 id="ff44" class="lw kl hi bd km lx ly lz kq ma mb mc ku jx md me kw kb mf mg ky kf mh mi la mj bi translated">简单登录页面</h2><p id="4cfa" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我们只需要一个简单的表单，只有一个字段，有一个登录页面:</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="5756" class="lw kl hi ml b fi mp mq l mr ms">&lt;h1&gt;Log in&lt;/h1&gt;<br/> <br/>&lt;form method="post" class="container-fluid"&gt;<br/>    &lt;div class="row"&gt;<br/>        &lt;div class="col-sm-12 col-md-4 col-lg-3 col-xl-2"&gt;<br/>            &lt;label for="email" class="form-label"&gt;Your e-mail address:&lt;/label&gt;<br/>        &lt;/div&gt;<br/>        &lt;div class="col-sm-12 col-md-8 col-lg-9 col-xl-10"&gt;<br/>            &lt;input type="text" name="email" id="email" placeholder="my.name@email.com" class="form-control" /&gt;<br/>        &lt;/div&gt;<br/>        &lt;div class="row"&gt;<br/>            &lt;div class="col-12 align-content-end"&gt;<br/>                &lt;input type="submit" class="btn btn-primary" value="Log in"/&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/form&gt;</span></pre><p id="016f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请注意，我使用的是带有响应式布局的引导类，这是一个模板ASP.NET应用程序所使用的。显然，您可以根据自己的需要随意修改。</p><p id="d837" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该表单只发布一个字段，即用于登录的电子邮件地址。我使用一个Razor页面来托管它，并使用一个幕后模型来捕捉电子邮件的价值:</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="f3f8" class="lw kl hi ml b fi mp mq l mr ms">public class LoginModel : PageModel<br/>{<br/>    private readonly LoginValidationService loginService;<br/> <br/>    public LoginModel(LoginValidationService loginService)<br/>    {<br/>        Requires.NotNull(out this.loginService, loginService);<br/>    }<br/> <br/>    public void OnGet()<br/>    {<br/>    }<br/> <br/>    public async Task&lt;IActionResult&gt; OnPost(<br/>        PostModel postModel,<br/>        CancellationToken cancellationToken = default)<br/>    {<br/>        if (!this.ModelState.IsValid)<br/>        {<br/>            return this.Page();<br/>        }<br/> <br/>        await this.loginService.CommitLogin(postModel.Email, cancellationToken);<br/> <br/>        return this.RedirectToPage("LoginMessageSent");<br/>    }<br/> <br/>    public class PostModel<br/>    {<br/>        [BindProperty(Name = "email")]<br/>        [MaxLength(255)]<br/>        [Required]<br/>        public string Email { get; set; }<br/>    }<br/>}</span></pre><p id="2962" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们仔细分析一下。</p><p id="5643" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，我们有一个LoginValidationService实例(我们稍后将创建这个实例，所以现在就让它保持原样)，它是通过构造函数注入和验证的。</p><p id="c502" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="mt">注:需要。NotNull是</em> <a class="ae jn" href="https://www.nuget.org/packages/IX.StandardExtensions/" rel="noopener ugc nofollow" target="_blank"> <em class="mt"> IX的一个类似契约的验证和初始化方法部分。标准扩展</em> </a> <em class="mt">获取包。</em></p><p id="f8f1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们没有理由为GET方法做任何特殊的事情，因为神奇的事情发生在页面上的表单通过POST方法回发的时候。</p><p id="873e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当处理POST方法时，我们得到一个只包含email字段的模型(如PostModel类中所定义的),如果模型有效，就调用带有电子邮件地址的CommitLogin方法，然后将用户重定向到某个页面，让他查看自己的电子邮件。</p><p id="44fe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这个阶段，我们只对获取用户的电子邮件感兴趣，这样我们就可以生成一些秘密代码和一个链接发送给用户。这只是第一步，用户对所述链接的访问将触发登录过程的第二步。</p><h2 id="897e" class="lw kl hi bd km lx ly lz kq ma mb mc ku jx md me kw kb mf mg ky kf mh mi la mj bi translated">登录和验证控制器</h2><p id="b93d" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在我的例子中，仅仅为了多样性，我选择将登录验证链接处理程序实现为一个无视图的MVC控制器。一个Razor页面也能很好地工作，所以你可以随意修改你认为合适的页面，但是我只是觉得这需要更多的工作。</p><p id="0635" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我的代码如下所示:</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="1588" class="lw kl hi ml b fi mp mq l mr ms">[Route("Login")]<br/>public class LoginController : Controller<br/>{<br/>    private readonly LoginValidationService lvs;<br/> <br/>    public LoginController(LoginValidationService lvs)<br/>    {<br/>        Requires.NotNull(out this.lvs, lvs);<br/>    }<br/> <br/> <br/>    [HttpGet("Validate")]<br/>    public async Task&lt;IActionResult&gt; ValidateLogin([FromQuery] string email, [FromQuery] string code)<br/>    {<br/>        var result = await this.lvs.ValidateLogin(<br/>            email,<br/>            code);<br/> <br/>        if (result)<br/>        {<br/>            return this.Redirect("~/");<br/>        }<br/> <br/>        return this.RedirectToPage("/Forms/Authentication/LoginFailed");<br/>    }<br/>}</span></pre><p id="90d2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们注入了相同的LoginValidationService，并且我们有ValidateLogin操作方法，该方法将使用用户接收到的查询字符串参数调用其ValodateLogin方法:代码以及电子邮件地址。我们也处理GET方法，因为没有一个有自尊的电子邮件客户端会在没有首先提醒用户的情况下为你做一个适当和安全的帖子，我们不希望不必要的复杂化。</p><p id="e7be" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">收到验证结果(在本例中是一个布尔值)后，控制器将用户重定向到一个页面，告诉他登录失败，或者重定向到主页。随意适应自己的需求。</p><p id="8c51" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">仅此而已。现在，让我们转到LoginValidationService类。</p><h2 id="2652" class="lw kl hi bd km lx ly lz kq ma mb mc ku jx md me kw kb mf mg ky kf mh mi la mj bi translated">登录验证服务</h2><p id="f9f4" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">现在真正的奇迹发生了。但是，在此之前，我们需要定义一个具有大量字段的类:</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="1607" class="lw kl hi ml b fi mp mq l mr ms">public class LoginValidationService<br/>{<br/>    private const string LoginValidationKey = "LOGINVALIDATION:{0}";<br/> <br/>    private readonly IConfiguration config;<br/>    private readonly IWebHostEnvironment host;<br/>    private readonly IHttpContextAccessor httpContextAccessor;<br/>    private readonly IAppCache cache;<br/>    private readonly UserManager&lt;IdentityUser&lt;int&gt;&gt; userManager;<br/>    private readonly SignInManager&lt;IdentityUser&lt;int&gt;&gt; signInManager;<br/>    private readonly ILogger&lt;LoginValidationService&gt; logger;<br/> <br/>    public LoginValidationService(<br/>        IConfiguration config,<br/>        IWebHostEnvironment host,<br/>        IHttpContextAccessor httpContextAccessor,<br/>        IAppCache cache,<br/>        UserManager&lt;IdentityUser&lt;int&gt;&gt; userManager,<br/>        SignInManager&lt;IdentityUser&lt;int&gt;&gt; signInManager,<br/>        ILogger&lt;LoginValidationService&gt; logger)<br/>    {<br/>        Requires.NotNull(out this.config, config);<br/>        Requires.NotNull(out this.host, host);<br/>        Requires.NotNull(out this.httpContextAccessor, httpContextAccessor);<br/>        Requires.NotNull(out this.cache, cache);<br/>        Requires.NotNull(out this.userManager, userManager);<br/>        Requires.NotNull(out this.signInManager, signInManager);<br/>        Requires.NotNull(out this.logger, logger);<br/>    }</span><span id="c238" class="lw kl hi ml b fi mu mq l mr ms">[... rest of class ...]<br/>}</span></pre><p id="d493" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们依次把他们都带走。</p><p id="aa63" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可能需要某种配置访问，所以我们注入IConfiguration接口作为访问它的最简单的方法。更多关于ASP.NET配置的<a class="ae jn" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/" rel="noopener ugc nofollow" target="_blank">文档在微软文档。</a></p><p id="5c76" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们希望获得一些关于当前主机的信息，因为您可能不希望从开发人员的机器上发送电子邮件(或发送太多电子邮件)。稍后您将看到这是如何发生的。</p><p id="5b68" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们需要访问HTTP上下文，我们通过注入IHttpContextAccessor来访问它。更多关于注入和使用ASP.NET HttpContext的<a class="ae jn" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-context" rel="noopener ugc nofollow" target="_blank">文档在微软文档。</a></p><p id="e404" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后我们变了一个相当有趣的戏法。具体如何执行取决于您的实际需求，因此您可能需要调整这一部分以适应您的业务需求。但是对于一个非常简单的应用程序来说，这是可行的:</p><p id="4f9f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们需要生成一个代码，用户可以使用10分钟左右，之后就消失了。我们不一定需要存储它，只要在它还没有过期的时候，为应用程序提供一个简单的方法来访问它。我们不期望过多的这种代码需要同时有效。这听起来完全像缓存对象的行为，因此，自然地，缓存(在我们的特定缓存中是内存缓存)将完成这一任务。我用的是<a class="ae jn" href="https://www.nuget.org/packages/LazyCache/" rel="noopener ugc nofollow" target="_blank">懒人缓存</a>，注射IAppCache。</p><p id="8e77" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在需要注意的一件重要事情是常量LoginValidationKey。它将被用来与我们的IAppCache实例一起工作。</p><p id="03a0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后我们注入UserManager，请注意它有上面提到的user类作为类型参数。我们将用它来检查用户以前是否登录过，如果没有，就为它创建一个数据库条目。</p><p id="f331" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之后，我们将使用SignInManager来指示ASP.NET实际进行登录，最后，如果需要，ILogger将为我们提供记录日志的机会。</p><p id="45f7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们看看这是如何工作的。</p><h2 id="681f" class="lw kl hi bd km lx ly lz kq ma mb mc ku jx md me kw kb mf mg ky kf mh mi la mj bi translated">第一阶段登录</h2><p id="bcf4" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">让我们分析登录第一阶段的代码:</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="d729" class="lw kl hi ml b fi mp mq l mr ms">public async ValueTask CommitLogin(string emailAddress, CancellationToken cancellationToken = default)<br/>        {<br/>            // Create login key<br/>            string key = string.Format(<br/>                LoginValidationKey,<br/>                Requires.NotNullOrWhiteSpace(emailAddress));<br/> <br/>            // Validate that there hasn't already been a login<br/>            if (this.cache.TryGetValue&lt;string&gt;(<br/>                    key,<br/>                    out _))<br/>            {<br/>                return;<br/>            }<br/> <br/>            // Generate code<br/>            string loginCode = DataGenerator.RandomAlphanumericString(50);<br/> <br/>            // Save code to cache<br/>            this.cache.Add(key, loginCode, new DateTimeOffset(DateTime.Now.AddMinutes(10)));<br/> <br/>            // Send e-mail message<br/>            if (this.host.IsDevelopment())<br/>            {<br/>                this.logger.LogDebug("Message sending on login was triggered, but will not run on a development environment.");<br/> <br/>                return;<br/>            }<br/> <br/>            try<br/>            {<br/>[... initialize email sending service here ...]</span><span id="69c2" class="lw kl hi ml b fi mu mq l mr ms">                var httpContext = this.httpContextAccessor.HttpContext ?? throw new InvalidOperationException("No HTTP context, cannot proceed.");<br/>                var linkGenerator = httpContext.RequestServices.GetService&lt;LinkGenerator&gt;() ?? throw new InvalidOperationException("No link generator, cannot proceed.");<br/>                var website = linkGenerator.GetUriByName(httpContext, "default", new RouteValueDictionary());<br/>                var loginValidateAddress = linkGenerator.GetUriByAction(<br/>                    httpContext,<br/>                    "ValidateLogin",<br/>                    "Login");<br/>                var loginPageAddress = linkGenerator.GetUriByPage(httpContext, "/Forms/Authentication/Login");<br/> <br/>                var subject = $"Login request for {emailAddress}";<br/>                var plainTextContent = string.Format(<br/>                    @"Thank you for your interest in the {2} site.<br/> <br/>Please login using the following link (valid for 10 minutes):<br/> <br/>{3}?code={0}&amp;email={1}<br/> <br/>This link should validate your session, and should redirect you towards the home page.<br/> <br/>If you cannot use this link, this means it might have expired, so please try to log in again.",<br/>                    loginCode,<br/>                    emailAddress,<br/>                    website,<br/>                    loginValidateAddress);<br/>                var htmlContent = string.Format(<br/>                    @"&lt;h1&gt;Login&lt;/h1&gt;<br/>&lt;p&gt;Thank you for your interest in the &lt;a href=""{2}""&gt;{2}&lt;/a&gt; site.&lt;p&gt;<br/>&lt;p&gt;Please login using the following link (valid for &lt;strong&gt;10 minutes&lt;/strong&gt;):&lt;/p&gt;<br/>&lt;p&gt;&lt;a href=""{3}?code={0}&amp;email={1}""&gt;{3}?code={0}&amp;email={1}&lt;/a&gt;&lt;p&gt;<br/>&lt;p&gt;...or copy and paste it into a browser's navigation bar.&lt;/p&gt;<br/>&lt;p&gt;This link should validate your session, and should redirect you towards the home page.&lt;/p&gt;<br/>&lt;p&gt;If you cannot use this link, this means it might have expired, so please try to &lt;a href=""{4}""&gt;log in again&lt;/a&gt;.&lt;/p&gt;",<br/>                    loginCode,<br/>                    emailAddress,<br/>                    website,<br/>                    loginValidateAddress,<br/>                    loginPageAddress);<br/> <br/>[... send the email with the content ...]<br/>            }<br/>            catch (Exception e)<br/>            {<br/>                this.logger.LogError(e, "Could not send the login email due to an exception.");<br/> <br/>                return;<br/>            }<br/>        }</span></pre><p id="61b4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">很长，但是很简单，不是吗？</p><p id="80c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，从电子邮件地址创建一个适当的缓存键，检查是否已经有效，如果无效，则创建代码(<em class="mt">注意:DataGenerator。RandomAlphanumericString是</em> <a class="ae jn" href="https://www.nuget.org/packages/IX.StandardExtensions/" rel="noopener ugc nofollow" target="_blank"> <em class="mt"> IX的一部分。StandardExtensions </em> </a> <em class="mt">包</em>。我们将使用已经存在的键将代码保存在缓存中。我们检查我们是否在一个开发环境中(比如一台开发机器，为了不处理电子邮件，为了避免发送垃圾邮件给SMTP服务器)，如果不是，我们可以继续创建一些链接。</p><p id="4628" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请注意我们是如何使用HTTP上下文的。我们从它那里得到一个LinkGenerator实例，并使用它来生成链接。为什么我们需要将它与HttpContext联系起来？</p><p id="c724" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">答案在于ASP.NET(以及一般的web应用程序框架)如何生成链接。例如，如果我使用www.myawesomeapp.com访问应用程序，那么这就是我们需要创建相关链接的地方。然而，如果我们使用的是一个临时服务器，比如staging.myawesomeapp.com，那么我们需要创建相对于它的链接，否则它们就不能工作。我们还需要思考:我们使用的是HTTP还是HTTPS(尽管这很快就会变成一个无关紧要的问题)？诸如此类。我们可以在配置文件中硬编码一些地址，但是这意味着要维护那些链接，这只是一个无用的努力，因为我们有这个工作解决方案。</p><p id="1ced" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是实际的电子邮件发送，代码示例中展示了内容(包括链接)。</p><p id="2b87" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第二阶段登录</p><p id="98df" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第二阶段的代码稍微复杂一些:</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="fdc4" class="lw kl hi ml b fi mp mq l mr ms">public async ValueTask&lt;bool&gt; ValidateLogin(<br/>            string emailAddress,<br/>            string code,<br/>            CancellationToken cancellationToken = default)<br/>        {<br/>            // Create login key and code<br/>            string key = string.Format(<br/>                LoginValidationKey,<br/>                Requires.NotNullOrWhiteSpace(emailAddress));<br/> <br/>            var innerCode = Requires.NotNullOrWhiteSpace(code);<br/> <br/>            // Validate that there was a login that hasn't expired<br/>            if (!this.cache.TryGetValue&lt;string&gt;(<br/>                    key,<br/>                    out var existingCode))<br/>            {<br/>                return false;<br/>            }<br/> <br/>            // Compare code<br/>            if (!existingCode.OrdinalEquals(innerCode))<br/>            {<br/>                return false;<br/>            }<br/> <br/>            // Do login<br/>            try<br/>            {<br/>                var existingUser = await this.userManager.FindByNameAsync(emailAddress);<br/> <br/>                if (existingUser == null)<br/>                {<br/>                    // If there is no current user, let's create one<br/>                    existingUser = new IdentityUser&lt;int&gt;(emailAddress);<br/> <br/>                    var result = await this.userManager.CreateAsync(existingUser);<br/> <br/>                    if (!result.Succeeded)<br/>                    {<br/>                        return false;<br/>                    }<br/> <br/>                    // Send an e-mail to the new user, if we're not in development mode<br/>                    if (!this.host.IsDevelopment())<br/>                    {<br/>[... send user an email with user creation ...]<br/>                    }<br/>                }<br/> <br/>                await this.signInManager.SignInAsync(<br/>                    existingUser,<br/>                    false);<br/> <br/>                // Done<br/>                return true;<br/>            }<br/>            catch (Exception e)<br/>            {<br/>                this.logger.LogError(e, "Could not perform login due to an exception.");<br/> <br/>                return false;<br/>            }<br/>        }</span></pre><p id="e3c9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">主要的区别是，我们实际上希望我们的缓存现在包含一个条目，我们尽职尽责地验证它。</p><p id="0572" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这一点上，只有一件事需要提及:默认的身份实现确实期望用户被持久化以便正常工作，所以这就是userManager所做的——试图找到一个现有的条目，如果没有找到，则试图创建一个。它唯一需要设置的是用户名，也就是电子邮件地址。</p><p id="12a5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，同样重要的是，signInManager调用SignInAsync并指示ASP.NET登录用户。从那时起，就创建了一个用户会话，您可以使用该身份做所有基于会话的事情:</p><pre class="iy iz ja jb fd mk ml mm mn aw mo bi"><span id="3c96" class="lw kl hi ml b fi mp mq l mr ms">@if (User.Identity?.IsAuthenticated ?? false)<br/>{<br/>    &lt;a class="nav-link text-dark"&gt;Welcome, @User.Identity.Name! @Html.GravatarImage(User.Identity.Name, size: 25)&lt;/a&gt;<br/>}<br/>else<br/>{<br/>    &lt;a class="nav-link text-dark" asp-page="/Forms/Authentication/Login"&gt;Log in&lt;/a&gt;<br/>}</span></pre><p id="a7b4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">(<em class="mt">注:Html。GravatarImage可以从Andrew Freemantle的GitHub存储库</em>  <em class="mt">中使用，它可以做你所期望的事情</em></p><p id="1513" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我不会详细介绍注销页面，因为它唯一需要做的就是调用<a class="ae jn" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.signinmanager-1.signoutasync" rel="noopener ugc nofollow" target="_blank"> SignInManager。signot async</a>方法。</p><h1 id="184c" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">结论</h1><p id="a544" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">正如<a class="ae jn" href="https://blog.medium.com/signing-in-to-medium-by-email-aacc21134fcd" rel="noopener"> Medium清楚地展示了自己</a>，取消密码和不麻烦第三方社交媒体是可能的。</p><p id="dc7f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我希望我这个相当短的实现示例是一个确凿的证据，证明它也可以被开发人员使用。</p><p id="7df0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请记住:每个人都对安全负责，作为安全应用程序的开发人员，您的首要职责是给攻击者尽可能少的攻击面，尽可能少的成功机会。有些事情总是不在您的掌控之中，但是，在不在您掌控之中的时候，您有责任确保安全性几乎不可能受到损害。</p></div></div>    
</body>
</html>