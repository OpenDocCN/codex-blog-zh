<html>
<head>
<title>Top 3 Best-Performing Technical Indicators Implemented in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中实现的前3个最佳技术指标</h1>
<blockquote>原文：<a href="https://medium.com/codex/top-3-best-performing-technical-indicators-implemented-in-python-de7fec949c6b?source=collection_archive---------2-----------------------#2021-08-19">https://medium.com/codex/top-3-best-performing-technical-indicators-implemented-in-python-de7fec949c6b?source=collection_archive---------2-----------------------#2021-08-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8641" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">通过Python实现成功交易市场所必需的有效指标</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/eaca06c8dd7718822ac7ee776e2cc682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PdvIAzFhitbAtzKkiVPabw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由来自<a class="ae jn" href="https://www.pexels.com/photo/purple-and-pink-diamond-on-blue-background-5011647/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的<a class="ae jn" href="https://www.pexels.com/@rostislav-uzunov-3145660?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">罗斯季斯拉夫·乌祖诺夫</a>拍摄</figcaption></figure><p id="cd7b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">市场被成吨成吨的技术指标勒死了，对于新手来说，选择正确的指标将是一场噩梦。因为我花了相当多的时间在这些指标上漫游，并在市场上实现它们，所以我决定创建一个列表，列出3个表现最好的指标，以及它们在Python中的实现，以帮助初学者进入技术分析领域。事不宜迟，让我们进入文章吧！</p><p id="4474" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">注</strong>:即将到来的指标不是随机选择的，而是根据苹果公司的历史数据进行回测得出的结果挑选出来的。</p><h1 id="d65b" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">1.差异指数</h1><p id="9c43" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">差异指数是一个动量指标，用于测量股票的当前收盘价与其在指定时间段内的移动平均值之间的距离，并以百分比的形式解释读数。与其他动量振荡器不同，差异指数不限制在某些水平之间，因此是一个无界振荡器。</p><p id="c13e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">交易者经常使用差异指数来确定市场的当前势头。如果差异指数的读数高于零，则可以观察到市场的上升势头，类似地，如果该指标的读数低于零，则认为市场处于下降势头。</p><h2 id="0370" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">数学</h2><p id="2187" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">视差指数的计算非常简单。首先，我们必须找出一只股票的收盘价格与指定时间段内的移动平均线之间的差值，并将该差值除以移动平均线，然后乘以100。以14作为回看周期的典型设置的视差指数的计算可以表示如下:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="3029" class="lh kl hi lw b fi ma mb l mc md"><strong class="lw hj">DI 14</strong> = [ <strong class="lw hj">C.PRICE</strong> - <strong class="lw hj">MOVING  AVG 14</strong> ] / [ <strong class="lw hj">MOVING AVG 14</strong> ] * <strong class="lw hj">100</strong></span><span id="c239" class="lh kl hi lw b fi me mb l mc md">where,<br/>DI 14 = 14-day Disparity Index<br/>MOVING AVG 14 = 14-day Moving Average<br/>C.PRICE = Closing price of the stock</span></pre><h2 id="4fb8" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">Python实现</h2><p id="a3c5" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">现在，让我们实际使用Python来实现上面讨论的数学计算指标。</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="3c90" class="lh kl hi lw b fi ma mb l mc md">def get_di(data, lookback):<br/>    ma = data.rolling(lookback).mean()<br/>    di = ((data - ma) / ma) * 100<br/>    return di</span></pre><h2 id="9592" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">代码解释</h2><p id="f4bc" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">首先，我们定义一个名为“get_di”的函数，它将股票的收盘价(“数据”)和回望期(“回望”)作为参数。在函数内部，我们首先计算指定数量的回望期的收盘价数据的移动平均值。然后，我们将确定的值代入视差指数公式来计算读数。最后，我们将计算出的读数作为输出返回。</p><h1 id="8811" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">2.知道肯定的事</h1><p id="59ba" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">确知事物指标(简称KST)是一个无界动量振荡器，被交易者广泛用于理解ROC指标的读数。KST指标基于平滑ROC的四个不同时间框架，并将收集的数据合并到一个振荡器中。</p><h2 id="2eee" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">组件和数学</h2><p id="7eef" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">已知事物指示器由两部分组成:</p><p id="9da7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> KST线:</strong>第一个组成部分是KST线本身。为了计算KST线的读数，我们必须首先确定四个roc，分别以10、15、20、30作为“n”值。然后分别以10、10、10、15作为回顾期，使用简单的移动平均来平滑每个ROC。这种平滑的ROC称为ROCSMA。在获得四个不同时间段的ROCSMA后，我们必须将第一个ROCSMA乘以1，第二个ROCSMA乘以2，第三个ROCSMA乘以3，第四个乘以4。最后，将这四个乘积相加。KST线的计算可以用数学方法表示如下:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="0644" class="lh kl hi lw b fi ma mb l mc md"><strong class="lw hj">KL </strong>= (<strong class="lw hj">ROCSMA1 </strong>* <strong class="lw hj">1</strong>) + (<strong class="lw hj">ROCSMA2 </strong>* <strong class="lw hj">2</strong>) + (<strong class="lw hj">ROCSMA3 </strong>* <strong class="lw hj">3</strong>) + (<strong class="lw hj">ROCSMA4 </strong>* <strong class="lw hj">4</strong>)</span><span id="6574" class="lh kl hi lw b fi me mb l mc md">where,<br/>KL = KST Line<br/>ROCSMA1 = ROC 10 smoothed with SMA 10<br/>ROCSMA2 = ROC 15 smoothed with SMA 10<br/>ROCSMA3 = ROC 20 smoothed with SMA 10<br/>ROCSMA4 = ROC 30 smoothed with SMA 15</span></pre><p id="5df9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">信号线:</strong>现在，确知事物指示器的第二个组件是信号线组件。这个分量只不过是KST线的平滑版本。为了平滑KST线的值，以9作为回望周期的简单移动平均线被广泛使用。信号线的计算如下所示:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="3347" class="lh kl hi lw b fi ma mb l mc md"><strong class="lw hj">SIGNAL LINE</strong> = <strong class="lw hj">SMA9 </strong>( <strong class="lw hj">KST LINE</strong> )</span></pre><h2 id="ee53" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">Python实现</h2><p id="706c" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">现在是时候用Python实现指示器来获取其组件的读数了。</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="42a4" class="lh kl hi lw b fi ma mb l mc md">def get_roc(close, n):<br/>    difference = close.diff(n)<br/>    nprev_values = close.shift(n)<br/>    roc = (difference / nprev_values) * 100<br/>    return roc</span><span id="3713" class="lh kl hi lw b fi me mb l mc md">def get_kst(close, sma1, sma2, sma3, sma4, roc1, roc2, roc3, roc4, signal):<br/>    rcma1 = get_roc(close, roc1).rolling(sma1).mean()<br/>    rcma2 = get_roc(close, roc2).rolling(sma2).mean()<br/>    rcma3 = get_roc(close, roc3).rolling(sma3).mean()<br/>    rcma4 = get_roc(close, roc4).rolling(sma4).mean()<br/>    kst = (rcma1 * 1) + (rcma2 * 2) + (rcma3 * 3) + (rcma4 * 4)<br/>    signal = kst.rolling(signal).mean()<br/>    return kst, signal</span></pre><h2 id="f473" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">代码解释</h2><p id="5031" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">上述代码可以分为两个不同的部分:ROC计算和KST计算。</p><p id="2e3e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> ROC计算:</strong>我们首先定义一个名为“get_roc”的函数，它将股票的收盘价(“close”)和“n”值(“n”)作为参数。在该函数中，我们首先使用Pandas包提供的“diff”函数来获取当前收盘价和指定时间段之前的收盘价之间的差值。在“shift”函数的帮助下，我们考虑了指定时间段之前的收盘价，并将其存储到“nprev_values”变量中。然后，我们将确定的值代入我们之前讨论的ROC指标公式，以计算值并最终返回数据。</p><p id="4db8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> KST计算:</strong>首先，我们定义一个名为“get_kst”的函数，该函数将股票的收盘价(“close”)、平滑ROC值的四个回顾期(“sma1”、“sma2”、“sma3”、“sma4”)、ROC的四个“n”值(“roc1”、“roc2”、“roc3”、“roc4”)以及信号线的回顾期(“signal”)作为参数。在函数内部，我们首先使用Pandas包提供的‘rolling’函数和我们之前创建的‘get _ roc’函数来计算四个ROCSMA值。然后，我们将计算出的ROCSMAs代入我们之前讨论过的公式，以确定KST线的读数。然后，我们用“滚动”函数平滑KST线的值，以获得信号线的值，并将它们存储到“信号”变量中。最后，我们将返回KST指标的两个计算组件。</p><h1 id="45ab" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">3.真实强度指数</h1><p id="459e" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">真实力量指数(TSI)是一个动量振荡器，主要由交易者用来确定市场是向上还是向下的动量，并随之交易。它还用于识别市场的当前状态，超买或超卖，但这不是该指标的主要优势。</p><h2 id="577c" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">组件和数学</h2><p id="6e32" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">与“确信无疑”指标一样，真实实力指数也由两部分组成:</p><p id="2e00" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> TSI线:</strong>第一部分是TSI线本身，它是通过首先确定实际价格变化(当前收盘价减去前一收盘价)和绝对价格变化(实际价格变化的绝对值)来计算的。然后，实际价格变化和绝对价格变化都采用周期数为25的均线(多头)。然后这两个EMA被13天的指数移动平均线平滑。用两个EMA平滑数据序列的过程称为双重平滑，这样做的目的是消除数据中的噪声。现在，双重平滑的实际价格变化除以双重平滑的绝对价格变化，然后乘以100，以获得TSI线的读数。请注意，我们考虑的参数(25，13)是典型设置，但可以相应调整。计算可能很模糊，但如果我们以公式或图示的形式来解释，就很容易理解:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="7b6c" class="lh kl hi lw b fi ma mb l mc md"><strong class="lw hj">TSI LINE</strong> = [ <strong class="lw hj">DS. ACTUAL PC</strong> / <strong class="lw hj">DS. ABSOLUTE PC</strong> ] * <strong class="lw hj">100</strong></span><span id="b0c1" class="lh kl hi lw b fi me mb l mc md">where,</span><span id="3915" class="lh kl hi lw b fi me mb l mc md"><strong class="lw hj">DS. ACTUAL PC</strong> = Double smoothed actual price change with the length of 25 and 13</span><span id="f0fd" class="lh kl hi lw b fi me mb l mc md"><strong class="lw hj">DS. ABSOLUTE PC</strong> = Double smoothed absolute price change with the length of 25 and 13</span></pre><p id="c33d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">信号线:</strong>下一个组件是信号线组件，它只是TSI在指定周期数(在7到12个周期内)的指数移动平均值。大多数交易者喜欢日交易周期接近7，长期投资周期接近12。在本文中，我们将周期数定为12，因为我们将处理每日时间段的股票数据，而不是分钟时间段的数据。该计算可以表示如下:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="2f09" class="lh kl hi lw b fi ma mb l mc md"><strong class="lw hj">SIGNAL LINE</strong> = <strong class="lw hj">EXP.MA 13</strong> [ <strong class="lw hj">TSI LINE </strong>]</span></pre><h2 id="0ba1" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">Python实现</h2><p id="d98d" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">与其他两个指标不同，真正的实力指数有一个相当长的代码，因为它有复杂的数学公式来计算其组成部分。现在，让我们用Python编写指示器的代码。</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="3792" class="lh kl hi lw b fi ma mb l mc md">def get_tsi(close, long, short, signal):<br/>    diff = close - close.shift(1)<br/>    abs_diff = abs(diff)<br/>    <br/>    diff_smoothed = diff.ewm(span = long, adjust = False).mean()<br/>    diff_double_smoothed = diff_smoothed.ewm(span = short, adjust = False).mean()<br/>    abs_diff_smoothed = abs_diff.ewm(span = long, adjust = False).mean()<br/>    abs_diff_double_smoothed = abs_diff_smoothed.ewm(span = short, adjust = False).mean()<br/>    <br/>    tsi = (diff_double_smoothed / abs_diff_double_smoothed) * 100<br/>    signal = tsi.ewm(span = signal, adjust = False).mean()<br/>    tsi = tsi[tsi.index &gt;= '2020-01-01'].dropna()<br/>    signal = signal[signal.index &gt;= '2020-01-01'].dropna()<br/>    <br/>    return tsi, signal</span></pre><h2 id="9841" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">代码解释</h2><p id="c049" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">首先，我们定义一个名为“get_tsi”的函数，它将股票的收盘价数据(“收盘”)、长均线的回望期(“长”)和短均线的回望期(“短”)以及信号线的回望期(“信号”)作为参数。在函数内部，我们首先计算实际价格变化(' diff ')和绝对价格变化(' abs_diff ')并将其存储到各自的变量中。</p><p id="e902" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，使用Pandas软件包提供的“ewm”函数来确定指数移动平均值，我们对之前计算的价格变化进行双重平滑，以获得双重平滑的实际价格变化(“diff_double_smoothed”)和双重平滑的绝对价格变化(“abs_diff_double_smoothed”)。</p><p id="ae1b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，我们将双平滑值代入TSI线的公式，以确定其读数。为了计算信号线的值，我们采用特定周期数的已确定TSI线读数的EMA。最后，我们返回计算的组件。</p><blockquote class="mf"><p id="26fa" class="mg mh hi bd mi mj mk ml mm mn mo kj dx translated"><strong class="ak">荣誉奖:科博克曲线，MACD，阿隆，和令人敬畏的振荡器</strong></p></blockquote><h1 id="3836" class="kk kl hi bd km kn ko kp kq kr ks kt ku io mp ip kw ir mq is ky iu mr iv la lb bi translated">最后的想法！</h1><p id="8e3e" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">要记住的一个重要方面是，如果构建的策略没有效率，伟大的指标就会过时。所以要确保你的武器库中不仅有好的指标，还有适合市场的交易策略。此外，不要忘记回测和评估策略，以得出实际的见解。如果没有这两个过程，得出结论并将其部署到现实世界市场是致命的。</p><p id="ce49" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">话虽如此，你已经到了文章的结尾。如果您忘记了遵循任何编码部分，不要担心。我在文章底部提供了完整的源代码。希望你能从这篇文章中学到一些新的有用的东西。</p><p id="72db" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">主办:</strong> <a class="ae jn" href="https://eodhistoricaldata.com/r/?ref=DHY3H8NT" rel="noopener ugc nofollow" target="_blank"> EOD历史数据</a>是金融应用编程接口市场的领导者之一，提供各种各样的应用编程接口，从基本的每日市场数据到高度可定制的应用编程接口，如金融新闻应用编程接口和股票筛选应用编程接口。他们所有的API都是以一种本质上易于使用的方式设计的，因此初学者可以毫无障碍地使用它们。我个人使用过<a class="ae jn" href="https://eodhistoricaldata.com/r/?ref=DHY3H8NT" rel="noopener ugc nofollow" target="_blank"> EOD历史数据公司的</a>API，从我的经验来看，他们的API既适合专业人士也适合业余爱好者，用于辅助项目和构建企业级应用程序。</p><h2 id="5fc7" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">完整代码:</h2><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="6c5d" class="lh kl hi lw b fi ma mb l mc md"><strong class="lw hj"># DISPARITY INDEX</strong></span><span id="341a" class="lh kl hi lw b fi me mb l mc md">def get_di(data, lookback):<br/>    ma = data.rolling(lookback).mean()<br/>    di = ((data - ma) / ma) * 100<br/>    return di</span><span id="a82e" class="lh kl hi lw b fi me mb l mc md"><strong class="lw hj"># KNOW SURE THING</strong></span><span id="0bc1" class="lh kl hi lw b fi me mb l mc md">def get_roc(close, n):<br/>    difference = close.diff(n)<br/>    nprev_values = close.shift(n)<br/>    roc = (difference / nprev_values) * 100<br/>    return roc</span><span id="5b04" class="lh kl hi lw b fi me mb l mc md">def get_kst(close, sma1, sma2, sma3, sma4, roc1, roc2, roc3, roc4, signal):<br/>    rcma1 = get_roc(close, roc1).rolling(sma1).mean()<br/>    rcma2 = get_roc(close, roc2).rolling(sma2).mean()<br/>    rcma3 = get_roc(close, roc3).rolling(sma3).mean()<br/>    rcma4 = get_roc(close, roc4).rolling(sma4).mean()<br/>    kst = (rcma1 * 1) + (rcma2 * 2) + (rcma3 * 3) + (rcma4 * 4)<br/>    signal = kst.rolling(signal).mean()<br/>    return kst, signal</span><span id="d8b1" class="lh kl hi lw b fi me mb l mc md"><strong class="lw hj"># TRUE STRENGTH INDEX</strong></span><span id="de72" class="lh kl hi lw b fi me mb l mc md">def get_tsi(close, long, short, signal):<br/>    diff = close - close.shift(1)<br/>    abs_diff = abs(diff)<br/>    <br/>    diff_smoothed = diff.ewm(span = long, adjust = False).mean()<br/>    diff_double_smoothed = diff_smoothed.ewm(span = short, adjust = False).mean()<br/>    abs_diff_smoothed = abs_diff.ewm(span = long, adjust = False).mean()<br/>    abs_diff_double_smoothed = abs_diff_smoothed.ewm(span = short, adjust = False).mean()<br/>    <br/>    tsi = (diff_double_smoothed / abs_diff_double_smoothed) * 100<br/>    signal = tsi.ewm(span = signal, adjust = False).mean()<br/>    tsi = tsi[tsi.index &gt;= '2020-01-01'].dropna()<br/>    signal = signal[signal.index &gt;= '2020-01-01'].dropna()<br/>    <br/>    return tsi, signal</span></pre></div></div>    
</body>
</html>