<html>
<head>
<title>Should Functions Be Small?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数应该很小吗？</h1>
<blockquote>原文：<a href="https://medium.com/codex/should-functions-be-small-e76b45aa93f?source=collection_archive---------0-----------------------#2022-05-11">https://medium.com/codex/should-functions-be-small-e76b45aa93f?source=collection_archive---------0-----------------------#2022-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/5027e9e72ab08fe289ff7f7e27508e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xce6bQ2MDUPbCq49"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae hv" href="https://unsplash.com/@danielkcheung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张志勇</a>拍摄的照片</figcaption></figure><div class=""/><p id="46ff" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">干净的代码告诉我们:</p><blockquote class="jt ju jv"><p id="420a" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">"函数的第一条规则是它们应该很小."</p></blockquote><figure class="kb kc kd ke fd hk er es paragraph-image"><div class="er es ka"><img src="../Images/375788a62082027a2d0f56c23774bf26.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*d-xiG51N4NIo2uVxQdi3iQ.jpeg"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">卷毛其实是在说代码。</figcaption></figure><p id="6a2f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">几乎每个开发人员都熟悉做一件事(DOT)准则，也就是众所周知的<a class="ae hv" href="https://youtu.be/xtrQUoRJ_W4" rel="noopener ugc nofollow" target="_blank">卷曲</a>法则。这条准则告诉我们函数应该只做一件事。Clean Code对此做了更多的解释:</p><blockquote class="jt ju jv"><p id="2d9f" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">"函数应该做些什么，或者回答些什么，但不能两者都做."</p></blockquote><p id="c708" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个很好的区别，因为如果我们都在采取行动和回答某事，我们就定义为在做不止一件事。</p><p id="b7c0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最终，我们必须将这些功能拼凑在一起，并做一些事情。一个较高级别的函数调用多个较低级别的函数，根据定义，最终会做不止一件事。鲍勃大叔在《干净的代码》中用相同层次的抽象原则(SLAP)再次阐明了这一点:</p><blockquote class="jt ju jv"><p id="15b7" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">“这个原则背后的思想是，一个方法中的所有代码都应该处于同一抽象级别。这样更容易阅读和理解代码。如果在同一方法中用不同层次的抽象来表达代码，这将会导致混乱，难以理解。”</p></blockquote><p id="eacd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">DOT指南实际上意味着我们正在做的“一件事”是同一水平的事情。考虑一个简单的函数，它将更新用户记录中的电话号码。首先，该函数必须找到记录。然后更新记录，最后保存记录。它返回更新的用户记录是合理的。它可能是为这些活动中的每一个调用函数，而这些函数可能是调用其他函数，这些函数到达写入数据的实际硬件。</p><p id="19bc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">查找-更新-保存这三个步骤都在同一层，可以包含在一个函数中，该函数做的“一件事”是UpdateUser()。考虑一下阅读UpdateUser()从低级磁盘读取开始的代码的恐怖之处。或者UpdateUser()是否同时执行了UpdateCompany()和UpdateAccount()。</p><p id="260e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些都没有告诉我们一个函数可以有多大，只要它只做一件事。“小”是一个主观术语。</p><p id="e9d2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">PowerPoint规则</strong></p><p id="c916" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我刚进入中层管理时，我给一群副总裁做了一个演示。会后，其中一位副总裁把我拉到一边，说:“很棒的演讲，但让我提供一些建议。”他们是:</p><ul class=""><li id="c672" class="kf kg hy ix b iy iz jc jd jg kh jk ki jo kj js kk kl km kn bi translated">使用大字体。你爬得越高，你的视力就越差。</li><li id="7a69" class="kf kg hy ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated">少说。说话的部分是为了解释，屏幕上的应该是最少的。</li><li id="f530" class="kf kg hy ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated">三个。一张幻灯片上的项目符号不能超过三个。这是一名高管脑子里最多能记住的信息。</li></ul><p id="97d9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想进行有效的演讲，就要遵循这些规则。我认为同样的事情也适用于函数:</p><ul class=""><li id="f4ed" class="kf kg hy ix b iy iz jc jd jg kh jk ki jo kj js kk kl km kn bi translated">一个功能应该适合一个屏幕，有一个合理大小的字体。鲍勃大叔建议不要超过20行。</li><li id="86b2" class="kf kg hy ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated">它应该读起来很简单。任何解释性的东西都是命名良好的低级函数。结果应该是代码读起来像一个故事。</li><li id="2151" class="kf kg hy ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated">三个。将函数保持在三个代码块左右。不是台词，而是大概三个“段落”。这些段落也应该只有大约三步长。请注意，我从未说过任何关于代码行的内容。</li></ul><p id="0e76" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些规则是关于可读性和认知负荷的。但是还有其他原因让我们的函数保持小规模:</p><ul class=""><li id="7e23" class="kf kg hy ix b iy iz jc jd jg kh jk ki jo kj js kk kl km kn bi translated">不要重复自己(干)。较长的函数倾向于使用略有不同的重复代码。当我们的功能越短，就越容易消除动作中的重复。</li><li id="24ee" class="kf kg hy ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated">通过单元测试进行调试。是的，是的，我知道，我们不单元测试功能，我们单元测试行为。但是，当我们在调试为什么事情没有按照我们预期的方式工作时，编写单元测试来断言构建块是如何工作的会非常有用。我们的块越小，我们可以调试的粒度就越细。当然，我们也可以在抽象的阶梯上向上移动，并断言当我们向上移动时会发生什么。</li><li id="0e4b" class="kf kg hy ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated">重构以降低复杂性。较小的函数更容易删除代码。</li><li id="4e8d" class="kf kg hy ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated">重组。更小的函数使得在模块/类之间移动更容易。如果一个函数正在做一堆事情，我们可能必须在移动它的一部分之前把它分解。</li></ul><p id="4d7d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一边呢？</p><p id="7773" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一种思路采取了相反的方法。据称，<a class="ae hv" href="https://softwarebyscience.com/very-short-functions-are-a-code-smell-an-overview-of-the-science-on-function-length/" rel="noopener ugc nofollow" target="_blank">更短的功能导致更高的缺陷密度，并使调试</a>更加困难。我不相信:</p><ul class=""><li id="5516" class="kf kg hy ix b iy iz jc jd jg kh jk ki jo kj js kk kl km kn bi translated">这篇文章所依赖的更高缺陷密度的研究是2000年以前的。知道2000年以前也没有什么吗？干净的代码，TDD，以及我们今天拥有的更强大的语言和库。</li><li id="6735" class="kf kg hy ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated">这可能是因为在过去的日子里(我经历过，离开我的草坪)，更长的例程得到了更多的关注，因为它们是系统的核心。不是例程的长度，而是开发人员的注意力驱动了缺陷的数量。</li><li id="4afd" class="kf kg hy ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated">如果您遵循代码调试周期，那么较短的函数可能确实是个问题。但是我们一直在重构，我们在使用TDD，我们在写可读的代码。可读代码本来就更容易维护。任何不同意这一点的人都不会继承一个烂摊子。</li><li id="b858" class="kf kg hy ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated">可读性在早期并不被重视。在Fortran中，变量类型由变量名的首字母决定。当我写Fortran时，最大变量长度是8个字符。较短的功能可能会增加认知负荷，现在它们有相反的效果。COBOL被宣称是自文档化的，这很容易被任何使用过它的人反驳。</li><li id="70b5" class="kf kg hy ix b iy ko jc kp jg kq jk kr jo ks js kk kl km kn bi translated">任何时候一种方法声称比另一种方法有更少的缺陷，你必须回答“与什么相比？”如果你没有发现缺陷，它还存在吗？你有没有两次构建同一个东西并比较缺陷率？你是如何把你从第一次实现中获得的知识从你的头脑中移除的？你如何确保从事这项工作的开发人员处于相同的天赋水平？这些研究检查了已经开发的代码库，并测量了功能长度和报告的缺陷。很容易出现的情况是，较短的函数还不够成熟，不足以覆盖作为缺陷出现的极端情况。</li></ul><p id="66fc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">这不是单一责任原则</strong></p><p id="63d3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我最讨厌的一点是，许多作者混淆了SRP(一个函数或方法应该只有一个改变的理由)和点。SRP是关于人的——将与我们的系统一起做事的参与者。如果使用我们代码的参与者之一需要更改，它不应该要求我们更改其他参与者使用的代码。装运职员不应受到安全摄像机监控系统的改变的影响，即使该职员可能是该监控系统的对象。</p><p id="bc43" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">幸运的是，跟随圆点有助于我们理解SRP。因为我们有许多原子构建块，所以能够容易地移动方法有助于我们将行为分离到正确的模块中。</p><p id="3242" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">写短函数打断了我的思路</strong></p><p id="a987" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后继续写一个长函数并重构。让它工作，然后让它变得更好。现在大多数ide都有很好的重构工具来分解方法，并在类之间移动它们。继续重构，直到你完全明白你的代码的意图。</p><p id="843b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如Bob叔叔在他的一个视频中所说，当他可以从IF语句中去掉花括号时，他喜欢奖励自己拥有更短的代码。我自己，我喜欢牙套，但每个人都有自己的。</p><p id="fba7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">多短才算短？</strong></p><p id="bc28" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当你提取的代码比替换它的函数名更易读时，你就做得太过分了。这就是为什么对于一个函数中应该有多少行代码没有硬性规定，只有一些指导原则。</p><p id="7418" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">人们经常问我煮东西要多长时间。答案永远是“直到完成为止。”一些有代码的东西。不断清理代码，直到干净为止。</p></div></div>    
</body>
</html>