<html>
<head>
<title>Regex: The Simple Edition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式:简单版</h1>
<blockquote>原文：<a href="https://medium.com/codex/regex-the-simple-edition-6987fa1dd3f5?source=collection_archive---------4-----------------------#2022-01-11">https://medium.com/codex/regex-the-simple-edition-6987fa1dd3f5?source=collection_archive---------4-----------------------#2022-01-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class="if ig ez fb ih ii"><a href="https://www.linkedin.com/in/jason-padilla-8294bb1a7/" rel="noopener  ugc nofollow" target="_blank"><div class="ij ab dw"><div class="ik ab il cl cj im"><h2 class="bd hj fi z dy in ea eb io ed ef hh bi translated">Jason Padilla -美国纽约布鲁克林区马西实验室学校| LinkedIn</h2><div class="ip l"><h3 class="bd b fi z dy in ea eb io ed ef dx translated">查看Jason Padilla在全球最大的职业社区LinkedIn上的个人资料。杰森的学历列在…</h3></div><div class="iq l"><p class="bd b fp z dy in ea eb io ed ef dx translated">www.linkedin.com</p></div></div><div class="ir l"><div class="is l it iu iv ir iw ix ii"/></div></div></a></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/d7aff7b0de2e41d3540f4d797cfaf807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X8Q_25_R5FAsbpR9"/></div></div></figure><p id="e7bd" class="pw-post-body-paragraph jj jk hi jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hb bi translated">Regex也称为正则表达式，是各种编程语言中使用的模式，它匹配称为字符串的原始数据类型的一部分。如果你认为模式已经很难在代码之外找到了，那么你现在会猛然醒悟。但是不要担心，这就是你在这里的原因；学习复杂主题的基础知识。但是让我提醒你，这是正则表达式的简化版本。这意味着您必须继续阅读这个主题，但是不要担心，因为继续学习正则表达式的一个好地方是freeCodeCamp.org。无论如何，让我们开始你的旅程。</p><h1 id="54cc" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">介绍</h1><p id="105e" class="pw-post-body-paragraph jj jk hi jl b jm lf jo jp jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg hb bi translated">一位名叫肯·汤普森的数学家在1986年创造了正则表达式。他从斯蒂芬·克莱尼、沃伦·s·麦卡洛和沃尔特·皮茨那里汲取灵感。尽管regex看起来似乎是一个简单的概念，但它有几个关键部分必须掌握才能发挥其威力。在本文中，我们将只讨论五个部分:字符类、锚、量词和交替。对于本文，使用的编程语言是JavaScript。</p><h1 id="63ed" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">停下来。</h1><p id="f1e3" class="pw-post-body-paragraph jj jk hi jl b jm lf jo jp jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg hb bi translated">我忘记提到最关键的部分，regex的结构以及如何使用这个模式。要开始一个模式，您必须首先创建该模式。你用两个像/ /这样的正斜杠来做这件事。我们称之为<code class="du lk ll lm ln b">search pattern</code>。为了找到一个精确的匹配，您只需在搜索模式之间放入一个字符串，就像这样<code class="du lk ll lm ln b">/Jason/</code>。默认情况下，它只会找到第一个匹配的<code class="du lk ll lm ln b">Jason</code>。但是，您可以通过标志来改变搜索模式的行为。我们将使用两种类型的旗帜，<code class="du lk ll lm ln b">-g</code>和<code class="du lk ll lm ln b">-i</code>。通过执行<code class="du lk ll lm ln b">/Jason/g</code>，搜索模式现在将在一个字符串中查看<code class="du lk ll lm ln b">Jason</code>的多个条目。</p><pre class="iz ja jb jc fd lo ln lp lq aw lr bi"><span id="f526" class="ls ki hi ln b fi lt lu l lv lw">let string = 'Jason Padilla';<br/>let literalMatch = /Jason/g;<br/><br/>const test = literalMatch.test(string);<br/>const match = string.match(literalMatch);<br/><br/>console.log(test) // true<br/>console.log(match) // [‘Jason’]</span></pre><p id="9da6" class="pw-post-body-paragraph jj jk hi jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hb bi translated">现在将<code class="du lk ll lm ln b">-i </code>添加到搜索模式:<code class="du lk ll lm ln b">/Jason/gi</code>。这种搜索模式不再区分大小写，这意味着无论字符串是否有类似于<code class="du lk ll lm ln b">JASON</code>或<code class="du lk ll lm ln b">jAson</code>的<code class="du lk ll lm ln b">Jason</code>，该模式仍然会匹配它。</p><pre class="iz ja jb jc fd lo ln lp lq aw lr bi"><span id="2329" class="ls ki hi ln b fi lt lu l lv lw">let string = 'Jason jAson JASON';<br/>let regex = /Jason/g;<br/><br/>const match = string.match(regex);<br/><br/>console.log(match) // [‘Jason’]<br/><br/><br/><br/>let string = 'Jason jAson JASON';<br/>let regex = /Jason/gi;<br/><br/>const match = string.match(regex);<br/><br/>console.log(match)  // [‘Jason’, ‘jAson’, ‘JASON’]</span></pre><p id="26e0" class="pw-post-body-paragraph jj jk hi jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hb bi translated">还有更多的特殊人物要讲，但节目必须继续。为了继续这个节目，你必须看看正则表达式是否有效。我们可以用<code class="du lk ll lm ln b">.test()</code>方法做到这一点。该方法获取正则表达式，将其应用于一个字符串，并根据是否找到匹配返回<code class="du lk ll lm ln b">true</code>或<code class="du lk ll lm ln b">false</code>。还有另一种称为<code class="du lk ll lm ln b">.match()</code>的方法，它创建一个新数组，提取匹配项，并将它们放入新数组中。现在我们开始吧。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/6bf52a0be4e32590968c3b5882074485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HtlQ-FjyoJvK7sgW"/></div></div></figure><h1 id="efb7" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">字符类别</h1><p id="1e67" class="pw-post-body-paragraph jj jk hi jl b jm lf jo jp jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg hb bi translated">首先，字符类很简单，它允许计算机区分字符。这方面的一个例子是可以辨别字母和数字或只有数字。为了只匹配数字，您将输入搜索模式<code class="du lk ll lm ln b">/\d/g</code>，并添加<code class="du lk ll lm ln b">-g</code>标志来启用迭代。</p><pre class="iz ja jb jc fd lo ln lp lq aw lr bi"><span id="7aff" class="ls ki hi ln b fi lt lu l lv lw">let numbers = "1234567890";<br/>let regex = /\d/g;<br/><br/>const match = numbers.match(regex);<br/><br/>console.log(match) // [‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’, ‘0’]</span></pre><p id="8763" class="pw-post-body-paragraph jj jk hi jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hb bi translated">要匹配字母和数字，您可以在搜索模式中输入<code class="du lk ll lm ln b">\w</code>来匹配任何字符(字母数字和下划线)。</p><pre class="iz ja jb jc fd lo ln lp lq aw lr bi"><span id="86a9" class="ls ki hi ln b fi lt lu l lv lw">let numbers = "A B C, It's easy as 123";<br/>let regex = /\w/g;<br/><br/>const match = numbers.match(regex);<br/><br/>console.log(match)  // ['A', 'B', 'C', 'I', 't', 's', 'e', 'a', 's', 'y', 'a', 's', '1', '2', '3']</span></pre><p id="5d40" class="pw-post-body-paragraph jj jk hi jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hb bi translated">你也可以用大写的变体做相反的事情；<code class="du lk ll lm ln b">\D</code>匹配非数字的所有内容，而<code class="du lk ll lm ln b">\S</code>匹配除空白、换行符和制表符之外的所有内容。</p><pre class="iz ja jb jc fd lo ln lp lq aw lr bi"><span id="f590" class="ls ki hi ln b fi lt lu l lv lw">let numbers = "A B C, It's easy as 123";<br/>let regex = /\D/g;<br/><br/>const match = numbers.match(regex);<br/><br/>console.log(match) // ['A', ' ', 'B', ' ', 'C', ',', ' ', 'I', 't', "'", 's', ' ', 'e', 'a', 's', 'y', ' ', 'a', 's', ' ']<br/><br/><br/><br/>let numbers = "A B C, It's easy as 123";<br/>let regex = /\S/g;<br/><br/>const match = numbers.match(regex);<br/><br/>console.log(match) // ['A', 'B', 'C', ',', 'I', 't', "'", 's', 'e', 'a', 's', 'y', 'a', 's', '1', '2', '3']</span></pre><p id="0861" class="pw-post-body-paragraph jj jk hi jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hb bi translated">关于角色类的另一个很酷的事情是方括号<code class="du lk ll lm ln b">[]</code>。这允许您搜索想要匹配的特定字符组。为了进一步增强这一点，您可以通过使用连字符<code class="du lk ll lm ln b">-</code>来定义想要匹配的字符范围。我们可以在下面看到一个例子。在这个例子中，我想匹配所有以<code class="du lk ll lm ln b">at</code>结尾的字符。这是通过定义所有字母字符到<code class="du lk ll lm ln b">[a-z]</code>的范围并在末尾添加‘at’作为我们想要的结束字符的精确匹配来实现的。</p><pre class="iz ja jb jc fd lo ln lp lq aw lr bi"><span id="9e02" class="ls ki hi ln b fi lt lu l lv lw">let numbers = "That rat ran with my food. So I tried to hit it with a bat. Afterwards I laid on the mat while he ate the food on my doormat";<br/><br/>let regex = /[a-z]at/g;<br/><br/>const match = numbers.match(regex);<br/><br/>console.log(match) // ['hat', 'rat', 'bat', 'mat', 'mat']</span></pre><h1 id="f34b" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">锚</h1><p id="c292" class="pw-post-body-paragraph jj jk hi jl b jm lf jo jp jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg hb bi translated">锚点在正则表达式中很特殊，因为它们不匹配特定的字符；它们匹配字符的位置。<code class="du lk ll lm ln b">^</code>锚点匹配文本开头字符的位置。<code class="du lk ll lm ln b">$</code>锚点匹配文本末尾字符的位置。</p><pre class="iz ja jb jc fd lo ln lp lq aw lr bi"><span id="14bd" class="ls ki hi ln b fi lt lu l lv lw">let numbers = "The story never ends, it just has new beginning";<br/>let regex = /^The/g;<br/><br/>const match = numbers.match(regex);<br/><br/>console.log(match) // ['The']<br/><br/><br/><br/>let numbers = "The story never ends, it just has new beginning";<br/>let regex = /beginning$/g;<br/><br/>const match = numbers.match(regex);<br/><br/>console.log(match) // ['beginning']</span></pre><h1 id="02ff" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">量词和交替</h1><p id="4930" class="pw-post-body-paragraph jj jk hi jl b jm lf jo jp jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg hb bi translated">量词指定字符串中需要匹配的字符数。对于本节，我们将只通过使用花括号<code class="du lk ll lm ln b">{}</code>来讨论数量说明符。花括号有两部分，下面的数字和上面的数字。在匹配一个字符串或另一个字符串的逻辑OR运算符<code class="du lk ll lm ln b">|</code>之后进行替换。</p><pre class="iz ja jb jc fd lo ln lp lq aw lr bi"><span id="0af0" class="ls ki hi ln b fi lt lu l lv lw">let numbers = "abcdefghijklmnopqrstuvwxyz";<br/>let regex = /[a-z]{10}/g;<br/><br/>const match = numbers.match(regex);<br/><br/>console.log(match) // ['abcdefghij', 'klmnopqrst']<br/><br/><br/><br/>let numbers = "Here at Marcy Lab, we do both frontend and backend development";<br/>let literalMatch = /frontend|backend/g;<br/><br/>const match = numbers.match(literalMatch);<br/><br/>console.log(match) // ['frontend', 'backend']</span></pre><h1 id="5d19" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">抛售</h1><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/a0f3385f4121abbf872d5c3f13c5e20d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qkChEAaaqI6aAz_A"/></div></div></figure><p id="7d29" class="pw-post-body-paragraph jj jk hi jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg hb bi translated">正则表达式根本不是一个容易学的题目。我特别遗漏了regex的许多组件，因为它们深入到了正则表达式的功能中；其中一些是正面/负面环视、捕捉组等。请记住，本文是对regex的简单概述，因此继续学习其他平台对您最有利。我推荐的一些资源有freeCodeCamp(我从中汲取灵感的地方)、Odin Project、MDN等等。记住，编码是一种通过无数小时的学习和工作而学到的技能；所以，当时间或手头的话题变得艰难时，不要感到气馁。继续前进，感谢您花时间阅读我的文章。</p></div></div>    
</body>
</html>