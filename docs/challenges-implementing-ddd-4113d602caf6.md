# 实施 DDD 面临的挑战

> 原文：<https://medium.com/codex/challenges-implementing-ddd-4113d602caf6?source=collection_archive---------2----------------------->

![](img/e07f5d833d8e47620b2e2f708945a32f.png)

我已经读完了 Eric Evans(蓝皮书)和 Vaughn Vernon(红皮书)的 DDD 书籍，并想写下我个人关于实施 DDD 的挑战的笔记。

![](img/f7c90b55676160b6b60dd5511f8c1b23.png)

虽然所有的原创想法都来自蓝皮书，但我承认红皮书让你对如何应用 DDD 方法有了更多的理解。这并不奇怪，因为蓝皮书是在 2003 年出版的，所以在提供例子的情况下，自然感觉有点过时，但尽管如此，DDD 的思想在两本书中都是相同的。

我想说，DDD 是一个非常复杂的话题，有很多方法和模式，所以我甚至不想在这里一一介绍。我只想总结一下，DDD 就是要理解业务领域，并在代码中恰当地反映出来。省略了许多细节，该方法要求在代码中有一个专用的领域层，使用领域专家的语言描述业务逻辑。重要的是，有一个复杂的领域逻辑和理想的领域专家来从 DDD 中获益，因为它有自己的价格。

正如我提到的，DDD 方法需要一个尽可能用业务语言(通用语言)描述的领域层。它很自然地将我们推向所谓的"[干净的架构](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)"，因为业务专家不说技术术语，所以领域层应该尽可能与框架无关。

*小备注:DDD 通常用六角架构实现，但这不是强制要求，因为它也可以用分层架构实现。*

现在让我们强调第一个挑战:

![](img/a807c9bcf451b28a6e933193fecec269.png)

从领域层移除框架需要很多额外的抽象。看看 DDD 图。

![](img/fd58c282bc4851b2515d1d799f81e3c7.png)

**请注意，实体和存储库不是 JPA 抽象。它们是领域抽象。**这意味着您需要在创建域对象时(使用工厂或存储库)将数据放入域对象，并在保存域对象时(使用存储库)检索数据。

您可能希望使用 Java mapper 库将信息复制到域层或从域层复制信息。我建议看看[重映射](https://github.com/remondis-it/remap)库。它使用漂亮的 DSL +提供类型安全映射，保证在映射 ***(但仅在运行时)*** *期间不会遗漏任何字段。*

作为一个经验法则:如果你没有复杂的领域逻辑，你可能不需要实现 DDD，因为它带来更多的开销而不是好处。

![](img/3ca52b580a6391146019f126f06d33ea.png)

第二个挑战是事务管理。在解释之前，我强烈建议阅读“红皮书”中关于存储库的第 12 章。我个人认为这是最有用的章节之一，因为它给出了一种看待持久层的不同方式。

基本上，有两种类型的存储库:

*   **面向集合的存储库**——实现 JPA 存储库的更传统的方式，因为它经常需要“工作单元——即事务”,并跟踪实体的变化
*   **面向持久性的存储库—** 存储库的每个操作都应该单独执行(没有“工作单元”)

现在让我们回到挑战上来。**域存储库应该只返回域实体和集合，而不是 JPA 实体**。这意味着面向集合的方法更难实现，因为域实体只持有数据的副本(在与框架无关的域层的情况下)。跟踪更改是可能的，但需要额外的努力。

实现面向持久性的方法要容易得多，因为 DDD 集合代表了可以原子提交的抽象。此外，面向持久性的方法使我们更接近“干净的架构”,因为我们不依赖于“工作单元”,只有在这种情况下，我们才能轻松地用 NoSQL 实现替换 RDBM 实现。使用面向持久性的方法，我们甚至可以将事务管理从应用层转移到持久层。

作为结论，我要指出的是，如果您处理以数据为中心的系统而不是以域为中心的系统，那么 DDD 可能不是最佳选择，因为您经常会违反“每个聚合一个事务”这样的规则，并且必须将一些逻辑移到 DB 查询中(由于性能要求)。emark:这里我只谈论“战术设计”,因为在我看来“战略设计”在任何情况下都是有用的。

![](img/e27c13ffa4e583950144c7d4e04bd4fe.png)

最后一个挑战是实现可靠的事件。DDD 背后有一个简单的想法——对于实体持久性，有一个专用层，对于与其他系统的通信，有一些事件将外部系统的依赖性从域层解耦。理想情况下，我们希望以原子的方式提交数据库更改和发送事件，但不幸的是，没有简单的方法来做到这一点。“两阶段提交”有一个糟糕的名声(由于性能问题和协调器故障问题)，并且大多数现代系统不支持该协议。

它让我们选择先做什么:提交事务还是发送事件？在提交事务之前发送事件可能会导致不一致的状态，因为无法保证随后会提交事务(应用程序可能会在任何时候被终止，尤其是在云原生应用程序时代)。最有可能的是，我们希望在提交数据库更改后发送事件。在这种情况下，我们需要做出选择:

*   发送保证“最多一次”的事件
*   发送保证“至少一次”的事件

发送保证“最多一次”的事件非常简单。不需要做任何特殊的事情，我们只是接受这样一个事实，即在应用程序失败的情况下，在尝试发送之前，事件可能会丢失。不幸的是，并不是所有的需求都接受这种保证。

实现“至少一次”保证更加复杂，因为它需要在同一事务中的同一存储中保存事件和数据库更改。交付事件可以使用专门的工作或特殊工具来完成，如“ [Debezium](https://debezium.io/) ”和“ [Kafka Connect](https://docs.confluent.io/platform/current/connect/index.html) ”。这种模式被称为[“变更数据捕获”](https://en.wikipedia.org/wiki/Change_data_capture)模式，许多云提供商为流变更提供现成的解决方案。但是我们仍然需要使用相同的事务来保存主要的更改和事件。这将我们推回到之前的主题:要么我们需要在应用层进行事务管理(在面向集合的存储库的情况下)，要么我们需要一个“一致的”保存方法来接受聚合和事件(在面向持久化的存储库的情况下)。对于面向持久性的存储库，当我们处理不支持事务的非 SQL 数据库时，事情变得复杂(因为没有办法实现“一致的”保存方法)。我们可能只监视数据库数据本身的变化，并在域层之外生成事件(更多细节见本文)。

因此，没有解决这个问题的“灵丹妙药”,因此应用程序不能完全与持久性无关，数据库也不能轻易交换。您仍然需要至少了解数据库的“家族”,以及它为可靠事件的持久层的正确实现提供了什么保证。

综上所述，我认为 DDD 有很多好的想法，但是任何软件都包含需要考虑的技术挑战，并且不是所有的都可以容易地在领域层呈现或隐藏。