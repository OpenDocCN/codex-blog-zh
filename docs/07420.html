<html>
<head>
<title>Biggest Angular Pitfalls and how to avoid them — Part One — Circular Dependency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最大的角度陷阱和如何避免——第一部分——循环依赖</h1>
<blockquote>原文：<a href="https://medium.com/codex/biggest-angular-pitfalls-and-how-to-avoid-them-part-one-circular-dependency-4272417428e4?source=collection_archive---------9-----------------------#2022-06-14">https://medium.com/codex/biggest-angular-pitfalls-and-how-to-avoid-them-part-one-circular-dependency-4272417428e4?source=collection_archive---------9-----------------------#2022-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0d47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以另一个有角度的陷阱。我知道互联网上已经有数百万张这样的照片了。我还是决定再写一本。你可能会想，这是为什么？嗯，原因很简单，因为即使在过去五年里在Angular框架中大量编码之后，我仍然有时成为这些陷阱的受害者。所以这篇文章也是为了给我自己以及那些可能在谷歌上搜索到一个问题并意外登陆到这里的人记录这些陷阱:)</p><p id="2ff0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我会把这个话题分成几部分，因为我不想再写一个列表。相反，我想更深入地探究每一个陷阱。所以，在第一部分中，我们将看看每个Angular开发者最喜欢的错误——<strong class="ih hj">循环依赖。</strong></p><p id="6c48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">循环依赖</strong>是新手Angular开发者可能犯的最常见的错误。老实说，它甚至不是Angular Framework特有的东西。这更像是一个依赖注入的问题。</p><p id="a704" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，什么是循环依赖呢？假设你有两个服务，让我们称它们为pizza.service.ts和delivery.service.ts。我们在pizza.service中注入delivery.service，因为我们需要pizza.service中的交付状态。这很好<strong class="ih hj">只要我们在delivery.service中不需要pizza.service本身。</strong></p><p id="789e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能会问，如何解决这个问题？在这种情况下，最好将依赖代码(例如delivery.service中的状态变量)放在第三个服务中，该服务不依赖于上述两个服务中的任何一个。然后，在这两个中注入第三个服务。</p><p id="d1c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，有时问题比这更复杂。例如，如果您在Angular应用程序中启用了延迟加载。现在，在这个惰性加载的应用程序中，您有两个不同的模块。<strong class="ih hj">模块A </strong>有组件——pizza . component、pasta.component和tiramisu.component。另一方面，<strong class="ih hj">模块B </strong>有delivery.component、payment.component和extras.component，以及一些服务..现在，在表面上，我们已经在模块之间清晰地划分了组件。但是在实践中，我们需要来自模块A的组件在模块B的组件中，模块B的服务在模块A的组件中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/8904459ef95ab81f828ce02b99035a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-j8NnMuQrHl5cYZH5HEzvw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">问题是</figcaption></figure><p id="3422" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，最干净的方法总是实现一个<strong class="ih hj"> shared.module </strong>来保存公共组件，然后在两个模块中导入shared.module。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jt"><img src="../Images/5850c1a554531023cf8d6ce6fa26ced2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tc-bEYHpvg-DVfe-4mv5Dw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">解决方案</figcaption></figure><p id="abab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">但是要小心— </strong>这与其说是角度问题，不如说是架构问题。总是问自己，把某个组件放在某个模块中有意义吗？业务用例是什么？clearner的工作流程是什么？不要盲目地把所有东西都放在shared.module中。如果你有不必要的东西存储在shared.module中，它可能会完全违背懒惰加载的目的。你也可以有更小更干净的多个共享模块，以防你有多个东西需要在懒惰模块之间共享。在这种情况下，只需引用您需要的共享模块。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ju"><img src="../Images/670271374bb228231c0ea37ad7b74ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8ThKkqPELfzntD6ftYyug.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">较小的共享模块</figcaption></figure><p id="433a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">循环依赖可以是兔子洞。尤其是当你有一块巨大的巨石。虽然我理解在当今时代编写monolith Frontend的缺点，但考虑到项目的生命周期，这有时是不可避免的。在这种情况下，最好从一开始就设计应用程序，以避免将来出现这样的陷阱。绕过一个可能的未来问题，在短期内看起来很昂贵，但从长期来看，它总是比重构更划算。</p><p id="fe3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一部分，我们将讨论订阅的常见错误以及如何避免它们。</p><p id="c953" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在那之前:)</p></div></div>    
</body>
</html>