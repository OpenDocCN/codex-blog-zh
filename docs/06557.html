<html>
<head>
<title>Generics in Java (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的泛型(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/generics-in-java-part-1-e6a2d74745cd?source=collection_archive---------4-----------------------#2022-05-01">https://medium.com/codex/generics-in-java-part-1-e6a2d74745cd?source=collection_archive---------4-----------------------#2022-05-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="952c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本系列第2部分:<a class="ae jd" rel="noopener" href="/codex/generics-in-kotlin-part-2-6e87f9b2e8ac">https://medium . com/codex/generics-in-kotlin-part-2-6 e 87 f 9 b 2 E8 AC</a></p><p id="a816" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本系列第三部分:<a class="ae jd" rel="noopener" href="/codex/generics-in-kotlin-part-3-1efde0bf0167">https://medium . com/codex/generics-in-kotlin-part-3-1 efde 0 BF 0167</a></p><p id="3262" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">泛型在Java和Kotlin中都是一个强大的特性，可以帮助您编写类型安全的可伸缩代码。然而，我发现了多个概念，如界限、通配符、递归界限等。非常令人困惑，现在是Kotlin中泛型的区别。这篇文章试图揭开泛型各种基本概念的神秘面纱。</p><p id="88a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:这是一篇长文，会有更多更新。请继续关注并通过在您的IDE中尝试代码示例来理解这些概念:)</p><p id="1d87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从最基本的开始。</p><h1 id="68a6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">为什么是仿制药？</h1><p id="d353" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我相信大多数人已经看到了列表中的例子，并且阅读了像编译时类型检查和代码重用这样的术语，它们是使用泛型的最大好处。让我们来看一个泛型能让我们做什么的例子。</p><h2 id="df26" class="kh jf hi bd jg ki kj kk jk kl km kn jo iq ko kp js iu kq kr jw iy ks kt ka ku bi translated">参数化的类/接口/方法/变量</h2><p id="f294" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">让我们按照预期从列表示例开始。如果没有泛型，我们将编写如下代码:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="e137" class="kh jf hi la b fi le lf l lg lh">List ints = Arrays.<em class="li">asList</em>(1, 2, 3, <strong class="la hj">"hello"</strong>);<br/><strong class="la hj">int </strong>s = 0;<br/><strong class="la hj">for </strong>(Iterator it = ints.iterator(); it.hasNext(); ) {<br/>    <strong class="la hj">int </strong>n = (<strong class="la hj">int</strong>) it.next();<br/>    s += n; }<br/><strong class="la hj">assert </strong>s == 6;</span></pre><p id="005c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，编码器必须记住添加的值的类型，并引入手动转换(第4行)。<strong class="ih hj">我们无法在声明期间指定类型。</strong>另外，如果你注意到了，我狡猾地添加了一个字符串，因为为什么不？！这个程序在编译时不显示任何错误，只在运行时(即我们执行代码时)失败。您应该已经猜到了失败的原因:编译器无法将字符串转换为int类型。</p><p id="258f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些超级聪明的人意识到了这种混乱，并添加了一种方法，让你很早就定义什么样的元素是预期的，并让编译器很早就向你显示错误(当编译器只是编译代码，而不是等待你运行代码)。</p><p id="1dfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦使用泛型编写代码，您会立即在IDE中看到错误，并且代码不再编译。</p><figure class="kv kw kx ky fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lj"><img src="../Images/b21a45c45d87224e994bc604869acc71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oeRa10Kuy3h9XQXi2hUiqQ.png"/></div></div></figure><p id="624e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，没有泛型，就没有办法指定我们打算在列表中存储什么样的条目，这需要更多的手动检查。它引入了冗长和运行时故障，而不是编译时故障。请不要建议我们应该为所有不同的类型创建单独的列表类，然后永远不必处理上面提到的问题，甚至重载构造函数！</p><p id="226e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顾名思义，泛型通过在尖括号&lt;&gt;中指定类型，让我们将泛型结构用作具有类型安全和更强编译时检查的列表</p><h1 id="14e4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">数组与列表</h1><p id="86e9" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">Java中数组和列表的定义方式与经常出现的多个关键字/概念(如协方差、不变性、具体化和擦除)之间存在显著差异。让我们通过这些，了解这些看起来很吓人的文字背后的细节。</p><blockquote class="lr ls lt"><p id="1644" class="if ig li ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">Effective Java在首选列表胜于数组的主题下很好地涵盖了这些内容</p></blockquote><h2 id="529a" class="kh jf hi bd jg ki kj kk jk kl km kn jo iq ko kp js iu kq kr jw iy ks kt ka ku bi translated">数组是协变的，列表是不变的</h2><p id="f485" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这种令人困惑的说法只是解释了列表是使用泛型定义的，而数组不是。这进一步证实了列表<type1>既不是父类型也不是列表<type2>的子类型，其中类型1和类型2可以具有子类型或父类型关系。对于数组来说，情况并非如此。如果Type1是Type2的子类型，Type1[]也是Type2[]的子类型，反之亦然。让我们通过一个简单的例子来阐明:</type2></type1></p><figure class="kv kw kx ky fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lx"><img src="../Images/a0c8e724bf6c76f04d0eb41612b29d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3DsWLyUmRbKS0o-bamT9zQ.png"/></div></div></figure><p id="b44e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，在上面的例子中，如果我试图将一个列表<double>赋给一个列表<number>，在编译时会失败。然而，我可以将一个Double类型的数组赋给一个Number类型的数组，因为Double <strong class="ih hj">扩展了</strong> Number。这就是为什么数组是协变的，列表是不变的。</number></double></p><h2 id="b161" class="kh jf hi bd jg ki kj kk jk kl km kn jo iq ko kp js iu kq kr jw iy ks kt ka ku bi translated"><strong class="ak">具体化&amp;擦除</strong></h2><p id="3538" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">数组是具体化的&amp;泛型是通过擦除实现的。正如我们已经看到的，如果使用数组，失败只会在运行时发生，而使用泛型List，可以在编译时捕获错误。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="34d3" class="kh jf hi la b fi le lf l lg lh">Arrays = Store all type information and verify at Runtime</span><span id="6ca1" class="kh jf hi la b fi ly lf l lg lh">List = Ensure all type checks at Compile time &amp; delete all type information at Runtime</span></pre><p id="f1fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，因为在泛型的情况下，检查已经在编译时完成了，所以它们也不需要在运行时携带类型描述。</p><p id="4cd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，<strong class="ih hj">当我们使用泛型时，类型描述在编译时存在，但是<em class="li">在运行时被删除</em> </strong> <em class="li">。</em>这样做是为了提高效率，因为不再需要这些细节了&amp;也保持了与5之前没有泛型的Java版本的向后兼容性。你可以看到为什么数组不是这种情况，即使在实际运行时，我们也一直带着类型描述。当我们在Kotlin中讨论泛型时，我们将在后面的博客中更详细地讨论内联函数和具体化的概念。</p><h1 id="7c4e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">扩展和超级</h1><p id="ac79" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我相信任何一个Java程序员都见过这些术语，并且困惑过一段时间。让我试着澄清一下每一个问题，以及为什么首先引入它们。</p><p id="583a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经看到参数化类型是不变的，这意味着我们不能仅仅因为Integer扩展了Number就用List <integer>代替List <number>。</number></integer></p><p id="0196" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们举一个简单的例子来理解为什么我们需要更多的灵活性。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="5304" class="kh jf hi la b fi le lf l lg lh"><strong class="la hj">public class </strong>CustomStack&lt;E&gt; {<br/>    <br/>    Stack&lt;E&gt; <strong class="la hj">stack </strong>= <strong class="la hj">new </strong>Stack&lt;&gt;();<br/>    <br/>    <strong class="la hj">void </strong>pushAll(Iterable&lt;E&gt; source){<br/>        <strong class="la hj">while </strong>(source.iterator().hasNext()){<br/>            <strong class="la hj">stack</strong>.push(source.iterator().next());<br/>        }<br/>    }<br/>    <br/>    <strong class="la hj">void </strong>pop(Collection&lt;E&gt; destination){<br/>        destination.add(<strong class="la hj">stack</strong>.pop());<br/>    }<br/>}</span></pre><p id="b5bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们创建了一个用类型参数化的自定义类。这一点很重要，因为我们看到了为什么要使用泛型。如果我们没有将它声明为CustomStack <e>，我们就不能指定一个类型，然后你基本上可以将任何类型放入这个堆栈，它只会在运行时出现问题时失败。我可以在自定义堆栈中放置随机类型，比如字符串和整数，但是当我们声明它为自定义堆栈时就不行了</e></p><p id="b328" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们尝试使用这个自定义堆栈。</p><figure class="kv kw kx ky fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lz"><img src="../Images/b306dc2ca5aa9803388e0caa1f93a333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5oFLeCSc33IvIRdiRNOjw.png"/></div></div></figure><p id="f3e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，我将其声明为CustomStack <number>，这意味着根据泛型原则，除了Number之外，不允许其他类型。那么，我如何更灵活地创建自定义堆栈呢？我想做以下事情，一旦你经历了这些事情，这些事情听起来会很有效:</number></p><ol class=""><li id="9fa9" class="ma mb hi ih b ii ij im in iq mc iu md iy me jc mf mg mh mi bi translated">我有一堆自定义的数字。我现在想把整数或其他子类型也放到这个堆栈中。请注意，我们正在从源可迭代获取值，并将它们存储到堆栈中(push all(Iterable&lt;E&gt;source))。</li><li id="833d" class="ma mb hi ih b ii mj im mk iq ml iu mm iy mn jc mf mg mh mi bi translated">现在，假设我们有一堆在声明中定义的数字。我现在想创建一个<strong class="ih hj">对象的集合(例如List &lt; Objects &gt;)并将其传递给pop方法来存储/放置弹出的值。</strong>由于对象类型是先前存储的值(Number)的超类型，我们应该被允许在其中存储数字。</li></ol><p id="07fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在CustomStack <e>和方法只接受E类型的情况下，上述选项不可用。让我们修改我们的自定义堆栈并引入<strong class="ih hj">扩展&amp;超级</strong>。</e></p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="42bb" class="kh jf hi la b fi le lf l lg lh"><strong class="la hj">public class </strong>CustomStack&lt;E&gt; {<br/><br/>    Stack&lt;E&gt; <strong class="la hj">stack </strong>= <strong class="la hj">new </strong>Stack&lt;&gt;();<br/><br/>    <strong class="la hj">void </strong>pushAll(Iterable&lt;? <strong class="la hj">extends </strong>E&gt; source){<br/>        <strong class="la hj">while </strong>(source.iterator().hasNext()){<br/>            <strong class="la hj">stack</strong>.push(source.iterator().next());<br/>        }<br/>    }<br/><br/>    <strong class="la hj">void </strong>pop(Collection&lt;? <strong class="la hj">super </strong>E&gt; destination){<br/>        destination.add(<strong class="la hj">stack</strong>.pop());<br/>    }<br/>}</span></pre><p id="0fad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请务必记住，对于要传递给方法的变量(源和目标)，应该考虑get和put的以下细节。理解所解释的获取和放置逻辑很重要。</p><p id="a381" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了支持灵活性1，我们希望允许更多的子类型存储在CustomStack <number>中。我们需要确保我们<strong class="ih hj">从pushAll方法中定义的结构中获得的值</strong>要么是<strong class="ih hj">数字，要么是数字的子类型</strong>。我们用“扩展”来做这件事，现在如果你把它作为一个整体来读，以数字为例，这很简单。扩展号码。唯一能证实这一点的类型是数字的子类型，如整数、双精度等...</number></p><p id="a7ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要清楚理解的一个细节是，使用“extends ”,我们只能从结构中获取元素，而不能将元素放入结构中。这是已经实施的，您可以通过尝试在pushAll方法中声明的<strong class="ih hj">源</strong>变量<strong class="ih hj"> </strong>中存储任何值来轻松地进行试验。编译器不会允许你。</p><p id="19a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了支持灵活性2，我们希望定义一个超类型的集合来存储堆栈中的值。为此，我们需要确保用于存储堆栈中值的集合类型(<strong class="ih hj"> destination </strong>变量)应该是我们可以从堆栈中获得的值的超类型，或者(E的超类型)。这是使用。超级e。</p><p id="8505" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与extends相反，当你只有<strong class="ih hj">把</strong>值放入结构时，使用“super”。在这里，我们<strong class="ih hj">将值放入目标变量</strong>。希望我们修改后的类的用法能够澄清这些细节:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="1be4" class="kh jf hi la b fi le lf l lg lh">CustomStack&lt;Number&gt; customStack = <strong class="la hj">new </strong>CustomStack&lt;&gt;();<br/>List&lt;Integer&gt; list = <strong class="la hj">new </strong>ArrayList&lt;&gt;();<br/>List&lt;Object&gt; listOfObject = <strong class="la hj">new </strong>ArrayList&lt;&gt;();<br/><br/>list.add(1);<br/>list.add(2);<br/>list.add(3);<br/>customStack.pushAll(list);<br/>customStack.pop(listOfObject);</span></pre><p id="2e4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经创建了一个自定义的数字堆栈，但是现在也从<strong class="ih hj">源</strong>变量中获取整数。我们还可以传入一个集合&lt; Object &gt;来存储堆栈中的值，在这种情况下，这些值可以是整数或数字，Object可以存储它们。</p><h1 id="2ab6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">通配符</h1><p id="bc76" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">让我们更详细地讨论一下<strong class="ih hj">。</strong>仿制药中常见的是什么？</p><p id="d737" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单来说就是“？”代表某种类型。让我们快速回顾一下我们在上面看到的扩展和超级示例:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="8f2b" class="kh jf hi la b fi le lf l lg lh">? extends E = Any Type that is a subtype of E<br/>? super E = Any type that is a super type of E<br/>? = ? extends Object</span></pre><p id="07f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想快速地谈论一下通配符捕获以及通配符和类型参数方面的不同选项。</p><h2 id="96c5" class="kh jf hi bd jg ki kj kk jk kl km kn jo iq ko kp js iu kq kr jw iy ks kt ka ku bi translated">更短/更简洁代码的通配符</h2><p id="f659" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这些方法声明是等效的，这里的通配符提供了一种更简洁的方式来编写代码:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="9d19" class="kh jf hi la b fi le lf l lg lh">public static void reverse(<strong class="la hj">List&lt;?&gt; </strong>list);</span><span id="a3ec" class="kh jf hi la b fi ly lf l lg lh">public static void <strong class="la hj">&lt;T&gt; </strong>reverse(<strong class="la hj">List&lt;T&gt; </strong>list);</span></pre><p id="c60f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">通配符捕获</strong></p><p id="38d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试着理解上面提到的两个选项之间的区别:</p><p id="461d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们使用使用类型参数的选项2，下面的代码可以工作:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="8e64" class="kh jf hi la b fi le lf l lg lh">public static <strong class="la hj">&lt;T&gt;</strong> void<strong class="la hj"> </strong>reverseWithT(<strong class="la hj">List&lt;T&gt;</strong> list) {<br/>    List&lt;T&gt; tmp = <strong class="la hj">new </strong>ArrayList&lt;T&gt;(list);<br/><br/>    for (int i = 0; i &lt; list.size(); i++) {<br/>        list.set(i, tmp.get(list.size() - i - 1));<br/>    }<br/>}</span></pre><p id="20ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于选项1，上述代码可以写成如下形式:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="2dc5" class="kh jf hi la b fi le lf l lg lh">public static void reverse(<strong class="la hj">List&lt;?&gt; </strong>list) { </span><span id="10ee" class="kh jf hi la b fi ly lf l lg lh">List&lt;Object&gt;<strong class="la hj"> </strong>tmp = new ArrayList&lt;Object&gt;(list); </span><span id="3253" class="kh jf hi la b fi ly lf l lg lh">for (int i = 0; i &lt; list.size(); i++) {<br/>  list.set(i, tmp.get(list.size()-i-1)); <strong class="la hj">// compile-time error <br/> </strong>}</span><span id="fc63" class="kh jf hi la b fi ly lf l lg lh">}</span></pre><p id="2ece" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这是非法的，因为我们现在正试图将一个对象列表写入一个未知类型的列表。解决这个问题的一个方法是声明一个后续的私有方法来捕获被传递的类型:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="57b9" class="kh jf hi la b fi le lf l lg lh">public static void reverse(<strong class="la hj">List&lt;?&gt; </strong>list) { rev(list); } </span><span id="2408" class="kh jf hi la b fi ly lf l lg lh">private static <strong class="la hj">&lt;T&gt; </strong>void rev(<strong class="la hj">List&lt;T&gt; </strong>list) {</span><span id="6601" class="kh jf hi la b fi ly lf l lg lh">List&lt;T&gt; tmp = new ArrayList&lt;T&gt;(list); <br/>for (int i = 0; i &lt; list.size(); i++) {</span><span id="00a2" class="kh jf hi la b fi ly lf l lg lh">list.set(i, tmp.get(list.size()-i-1)); <br/> }<br/>}</span></pre><p id="8f68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们说<strong class="ih hj">类型变量T已经捕获了通配符</strong>。</p><p id="82d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这篇文章澄清了很多关于Java中泛型基础的问题。在下一篇文章中，我将涉及更多的主题，比如Kotlin中的泛型和递归界限，以使文章更加清晰。</p></div></div>    
</body>
</html>