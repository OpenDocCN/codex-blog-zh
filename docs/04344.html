<html>
<head>
<title>Very Useful Python Recipes On Data Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">非常有用的Python数据结构食谱</h1>
<blockquote>原文：<a href="https://medium.com/codex/very-useful-python-recipes-on-data-structure-a52aa01f3ad1?source=collection_archive---------11-----------------------#2021-11-22">https://medium.com/codex/very-useful-python-recipes-on-data-structure-a52aa01f3ad1?source=collection_archive---------11-----------------------#2021-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3dde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将讨论Python中数据结构的一些常用方法。</p><p id="e8b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">Python中有多种数据结构，比如列表、元组和字典。虽然这些结构的使用很简单，但是在使用一些比较操作(如排序、排序和过滤)时会出现一些常见的问题。在这篇短文中，我们将讨论一些常见的数据结构和涉及数据的算法。没有进一步的到期，让我们跳转到代码:)</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es jm"><img src="../Images/779ad1b927663a2820fb0c51e1e4fc70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFCCqTiyBgNltNNtxm-kfw.jpeg"/></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">电机<a class="ae jy" href="https://medicine.wustl.edu/news/scientists-discover-new-way-transform-human-skin-cells-directly-motor-neurons/" rel="noopener ugc nofollow" target="_blank">变速杆</a></figcaption></figure><h1 id="2257" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">星号算子</h1><p id="3423" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">你需要从一个iterable中解包<em class="lc"> N </em>个变量，但是iterable的长度可能会大于<em class="lc">N。</em>这样我们可以使用星号(*)操作来解决这个问题。</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="b2ef" class="li ka hi le b fi lj lk l ll lm">record = ('Math', 'math@someemail.com', '098-111-2345', '946-999-756')<br/>name, email, *phone_numbers = user_record</span><span id="29eb" class="li ka hi le b fi ln lk l ll lm"><strong class="le hj">&gt;&gt;&gt; </strong>name<br/>'Math'<br/><strong class="le hj">&gt;&gt;&gt; </strong>email<br/>'math@someemail.com'<br/><strong class="le hj">&gt;&gt;&gt; </strong>phone_numbers <br/>['098-111-2345', '946-999-756']</span><span id="e506" class="li ka hi le b fi ln lk l ll lm">record = ('PTE', 60, 435.45, (03, 24, 2015))<strong class="le hj"><br/></strong>name, *_, (*_, year) = record</span><span id="fd58" class="li ka hi le b fi ln lk l ll lm"><strong class="le hj">&gt;&gt;&gt; </strong>name<br/>'PTE'<br/><strong class="le hj">&gt;&gt;&gt; </strong>year<br/>2012</span></pre><h1 id="443a" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">使用deque保留最后的<em class="lo"> N个</em>项</h1><p id="ceb4" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">目标是在迭代或其他处理数据的过程中，保留最后几个项目的有限历史。为此，我们可以利用<code class="du lp lq lr le b">collections</code>库中的<code class="du lp lq lr le b">deque</code>。<strong class="ih hj">虽然你可以用</strong><code class="du lp lq lr le b"><strong class="ih hj">list </strong></code><strong class="ih hj"/><code class="du lp lq lr le b"><strong class="ih hj">append</strong></code><strong class="ih hj">的方法，但是，</strong> <code class="du lp lq lr le b"><strong class="ih hj">deque</strong></code> <strong class="ih hj">要快得多，效率高得多。</strong>如何使用<code class="du lp lq lr le b">deque</code>的一个例子如下:</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="cf89" class="li ka hi le b fi lj lk l ll lm">q = deque(maxlen=3) <br/>q.append(1)<br/>q.append(2)<br/>q.append(3)</span><span id="7b7e" class="li ka hi le b fi ln lk l ll lm"><strong class="le hj">&gt;&gt;&gt; </strong>q<br/>deque([1, 2, 3], maxlen=3)</span><span id="8031" class="li ka hi le b fi ln lk l ll lm">q.append(4)</span><span id="a7b6" class="li ka hi le b fi ln lk l ll lm"><strong class="le hj">&gt;&gt;&gt; </strong>q<br/>deque([2, 3, 4], maxlen=3)</span></pre><p id="e064" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果不指定<code class="du lp lq lr le b">maxlen,</code>，队列将是一个无限的存储。您可以使用其他方法来控制队列。比如<code class="du lp lq lr le b">pop</code>、<code class="du lp lq lr le b">popleft, </code>和<code class="du lp lq lr le b">appendleft.</code></p><p id="70e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以开发一个基于优先级的队列，稍后将使用<code class="du lp lq lr le b">heapq </code>结构呈现。</p><h1 id="8599" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">寻找N个项目中最大的和最小的— heapq</h1><p id="ef42" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">您有一个项目列表，并且想要检索列表中的<em class="lc"> n </em>个最大或最小的元素。我们可以使用<code class="du lp lq lr le b">heapq</code>结构。堆数据结构主要用来表示一个优先级队列。Python中这种数据结构的属性是每次弹出<strong class="ih hj">最小的堆元素(min heap) </strong>。每当元素被推入或弹出时，<strong class="ih hj">堆结构被维护</strong>。heap[0]元素每次也返回最小的元素。</p><p id="882f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lp lq lr le b">heapq, nlargest, </code>和<code class="du lp lq lr le b">smallest</code>两种方法可以用来检索<code class="du lp lq lr le b">n</code>最小或最大的元素。</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="2dc6" class="li ka hi le b fi lj lk l ll lm">import heapq</span><span id="2b2b" class="li ka hi le b fi ln lk l ll lm">nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2] </span><span id="1c5c" class="li ka hi le b fi ln lk l ll lm">heapq.nlargest(3, nums) <br/><em class="lc">&gt;&gt;&gt; [42, 37, 23] </em></span><span id="8091" class="li ka hi le b fi ln lk l ll lm">heapq.nsmallest(3, nums)) <br/><em class="lc">&gt;&gt;&gt; [-4, 1, 2]</em></span><span id="2899" class="li ka hi le b fi ln lk l ll lm">heapq.heappop(heap) <br/>&gt;&gt;&gt; -4</span><span id="2cbc" class="li ka hi le b fi ln lk l ll lm">heapq.heappop(heap)<br/>&gt;&gt;&gt; 1</span><span id="da20" class="li ka hi le b fi ln lk l ll lm">heapq.heappop(heap) <br/>&gt;&gt;&gt; 2</span></pre><p id="874d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在幕后，他们首先将数据转换成一个列表，列表中的项目作为一个堆进行排序。因此，如果<code class="du lp lq lr le b">n</code>小于项目总数<code class="du lp lq lr le b">N</code>，这种方法可以提供更好的性能。</p><h1 id="3d22" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">使用<code class="du lp lq lr le b">heapq</code>实现基于优先级的队列</h1><p id="7d73" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">我们可以使用相同的结构通过<code class="du lp lq lr le b">heapq</code>来实现基于优先级的队列。</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="3d4b" class="li ka hi le b fi lj lk l ll lm">queue = []</span><span id="6695" class="li ka hi le b fi ln lk l ll lm"># the first element of tuple is priority and the second is the item<br/>heapq.heappush(queue, (-1, 3))</span><span id="bfae" class="li ka hi le b fi ln lk l ll lm">heapq.heappush(queue, (-2, 4))</span><span id="141f" class="li ka hi le b fi ln lk l ll lm">heapq.heappush(queue, (0, 5))</span><span id="575c" class="li ka hi le b fi ln lk l ll lm">heapq.heappop(queue)[-1]<br/>&gt;&gt;&gt; 4</span><span id="85e1" class="li ka hi le b fi ln lk l ll lm">heapq.heappop(queue)[-1]<br/>&gt;&gt;&gt; 3</span><span id="244d" class="li ka hi le b fi ln lk l ll lm">heapq.heappop(queue)[-1]<br/>&gt;&gt;&gt; 5</span></pre><p id="48ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数heapq.heap push()和heapq.heappop()在list _queue中插入和移除项目，使得列表中的第一个项目具有最小的优先级。这就是为什么我们将优先级索引(元组的第一个元素)作为负数插入。</p><h1 id="960f" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">保持字典整洁</h1><p id="6459" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">如果想让字典保持有序，可以使用<code class="du lp lq lr le b">OrderDict</code>结构。当您希望构建一个以后可能要序列化或编码为不同格式的映射时，OrderedDict可能特别有用。</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="a0e1" class="li ka hi le b fi lj lk l ll lm">from collections import<strong class="le hj"> </strong>OrderedDict</span><span id="8305" class="li ka hi le b fi ln lk l ll lm">d = OrderedDict() </span><span id="543b" class="li ka hi le b fi ln lk l ll lm">d['foo'] = 1 <br/>d['bar'] = 2 <br/>d['spam'] = 3 <br/>d['grok'] = 4</span><span id="c208" class="li ka hi le b fi ln lk l ll lm">for key in d: <br/>    print(key, d[key])</span><span id="6f86" class="li ka hi le b fi ln lk l ll lm"><em class="lc">&gt;&gt;&gt; "foo 1"<br/>    "bar 2"<br/>    "spam 3"<br/>    "grok 4"</em></span></pre><h1 id="c05e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">用字典计算</h1><p id="2299" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">可能会有这样的情况，您希望对字典数据结构进行计算，如最小值、最大值或排序。</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="1c6a" class="li ka hi le b fi lj lk l ll lm">prices = {'ACME': 45.23, <br/>          'AAPL': 612.78, <br/>          'IBM': 205.55, <br/>          'HPQ': 37.20, <br/>            'FB': 10.75}</span><span id="3d73" class="li ka hi le b fi ln lk l ll lm">min_price = min(zip(prices.values(), prices.keys())) <br/><em class="lc"># min_price is (10.75, 'FB')</em></span><span id="0dbc" class="li ka hi le b fi ln lk l ll lm">max_price = max(zip(prices.values(), prices.keys())) <br/><em class="lc"># max_price is (612.78, 'AAPL')</em></span><span id="00a0" class="li ka hi le b fi ln lk l ll lm">prices_sorted = sorted(zip(prices.values(), prices.keys())) <br/><em class="lc"># prices_sorted is [(10.75, 'FB'), (37.2, 'HPQ'),<br/># (45.23, 'ACME'), (205.55, 'IBM'),<br/># (612.78, 'AAPL')]</em></span></pre><p id="aa4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">涉及<code class="du lp lq lr le b">zip()</code>的解决方案通过将字典“反转”成一系列(值，键)对来解决这个问题。当对这样的元组执行比较时，首先比较值元素，然后是键。</p><h1 id="5df8" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">按公共关键字对字典列表进行排序</h1><p id="14c4" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">你有两本词典，想找出它们的共同点(相同的关键字，相同的值，等等。).</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="0891" class="li ka hi le b fi lj lk l ll lm">a={'x' : 1, 'y' : 2, 'z' : 3 }</span><span id="a0a4" class="li ka hi le b fi ln lk l ll lm">b={'w' : 10, 'x' : 11, 'y' : 2 }</span><span id="5d8c" class="li ka hi le b fi ln lk l ll lm"><em class="lc"># Find keys in common<br/></em>a.keys() &amp; b.keys() <em class="lc"># { 'x', 'y' }</em></span><span id="3993" class="li ka hi le b fi ln lk l ll lm"><em class="lc"># Find keys in a that are not in b <br/></em>a.keys() - b.keys() <em class="lc"># { 'z' }</em></span><span id="9b60" class="li ka hi le b fi ln lk l ll lm"><em class="lc"># Find (key,value) pairs in common <br/></em>a.items() &amp; b.items() <em class="lc"># { ('y', 2) }</em></span><span id="ae66" class="li ka hi le b fi ln lk l ll lm"><em class="lc"># Make a new dictionary with certain keys removed<br/></em>c = {key:a[key] <strong class="le hj">for </strong>key <strong class="le hj">in </strong>a.keys() - {'z', 'w'}} <br/><em class="lc"># c is {'x': 1, 'y': 2}</em></span></pre><p id="9566" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">键视图的一个鲜为人知的特性是，它们还支持常见的集合运算，如并集、交集和差集。</p><h1 id="f178" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">按公共关键字对字典列表进行排序</h1><p id="b1c6" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">您有一个字典列表，并且希望根据一个或多个字典值对条目进行排序。</p><pre class="jn jo jp jq fd ld le lf lg aw lh bi"><span id="9ef1" class="li ka hi le b fi lj lk l ll lm">rows = [{‘fname’: ‘Brian’, ‘lname’: ‘Jones’, ‘uid’: 1003}, <br/>        {‘fname’: ‘David’, ‘lname’: ‘Beazley’, ‘uid’: 1002}, <br/>        {‘fname’: ‘John’, ‘lname’: ‘Cleese’, ‘uid’: 1001}, <br/>        {‘fname’: ‘Big’, ‘lname’: ‘Jones’, ‘uid’: 1004}]</span><span id="cadd" class="li ka hi le b fi ln lk l ll lm">from operator import<strong class="le hj"> </strong>itemgetter<br/>rows_by_fname = sorted(rows, key=itemgetter('fname'))<br/>rows_by_uid = sorted(rows, key=itemgetter('uid')) </span><span id="72bd" class="li ka hi le b fi ln lk l ll lm"><strong class="le hj">print</strong>(rows_by_fname)<br/><strong class="le hj">print</strong>(rows_by_uid)</span><span id="410a" class="li ka hi le b fi ln lk l ll lm">#output <br/>&gt;&gt;&gt;[{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'}, {'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'}, {'fname': 'David', 'uid': 1002, 'lname': 'Beazley'}, {'fname': 'John', 'uid': 1001, 'lname': 'Cleese'}]</span><span id="8a33" class="li ka hi le b fi ln lk l ll lm">&gt;&gt;&gt;[{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'}, {'fname': 'David', 'uid': 1002, 'lname': 'Beazley'}, {'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'}, {'fname': 'Big', 'uid': 1004, 'lname': 'Jones'}]</span></pre><h1 id="8656" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="143e" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">在这篇短文中，在数据结构上下文中提供了一些有用的方法。希望有用:)</p></div></div>    
</body>
</html>