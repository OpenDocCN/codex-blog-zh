<html>
<head>
<title>A Powerful Addition to Your Postgres Toolbelt: Table Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Postgres工具箱的强大补充:表继承</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-powerful-addition-to-your-postgres-toolbelt-table-inheritance-352a26afed1?source=collection_archive---------13-----------------------#2021-04-07">https://medium.com/codex/a-powerful-addition-to-your-postgres-toolbelt-table-inheritance-352a26afed1?source=collection_archive---------13-----------------------#2021-04-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fe532ca55c45734e8107b3e62a87ddb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PcK5tmvWiB0h4JCP.jpg"/></div></div></figure><p id="02fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过使用表继承，节省数据检索和数据库管理的时间，这是一个鲜为人知但非常有用的特性。</p><p id="8b9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将介绍Postgres中继承是如何工作的，并提供一些何时使用继承的例子。</p><p id="7acf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">按照本文中的示例，<a class="ae jo" href="https://blog.arctype.com/p/7a5ac2e5-a4ce-4f1d-8839-cdf1e258e369/www.arctype.com" rel="noopener ugc nofollow" target="_blank">尝试Arctype的免费SQL编辑器</a>来快速连接到Postgres数据库:</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jp"><img src="../Images/81b1e9372a2a93052902eb8194b43b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QJ0gllUDK5W8FO9h.gif"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated"><a class="ae jo" href="https://blog.arctype.com/inheritance-in-postgres/www.arctype.com" rel="noopener ugc nofollow" target="_blank">今天试试Arctype】</a></figcaption></figure><h2 id="0ac7" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jb kj kk kl jf km kn ko jj kp kq kr ks bi translated">Postgres中的表继承是什么？</h2><p id="1e09" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">继承是面向对象编程的主要原则之一。这是一个从另一个对象派生一个对象的过程，以便它们具有共享的属性。</p><p id="7734" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">PostgreSQL中的继承允许您基于另一个表创建子表，并且子表将包括父表中的所有列。</p><p id="3dcc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们以一个用来存储不同类型房屋蓝图的数据库为例。</p><p id="a60b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们知道每个家庭都会有一些东西，比如:卧室、浴室和厨房。我们可以创建一个父表来存储这些共享属性。</p><p id="97ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，假设我们想要添加一个带天井的房子的蓝图。这个新蓝图和我们现有的一模一样，但有一个新房间。我们可以创建一个新的“子”表，让<em class="ky">继承</em>父表，而不是重新创建整个蓝图。</p><p id="8a4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在有了一个主父蓝图的副本，带有一个新的“天井”项目，而没有创建一个重复的蓝图。</p><h2 id="4204" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jb kj kk kl jf km kn ko jj kp kq kr ks bi translated">为什么要用继承？</h2><p id="b8b8" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">两个主要好处是:</p><ol class=""><li id="2f7f" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated">更高性能的查询</li><li id="d533" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">更简单的数据库管理</li></ol><p id="3128" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">更多性能查询</strong></p><p id="f0c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">继承将数据分割成较小的表，这些表继承了父表的一些字段。这实际上是对数据进行了分区，提高了检索数据的速度。</p><p id="32cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设您正在获取两个日期的数据。有一个名为<code class="du ln lo lp lq b">year_sales</code>的父表和包含每个月数据的继承表。</p><p id="931a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">检索<code class="du ln lo lp lq b">2020-10-1</code>和<code class="du ln lo lp lq b">2020-10-15</code>之间所有销售额的命令将只扫描十月份的表。</p><p id="8ca9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">继承的表也创建了更易于管理的索引。每个单独的表包含更少的数据，无论有没有索引都可以加快搜索速度。</p><p id="6e4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">更简单的数据库管理</strong></p><p id="da71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">未来的模式更改更容易，因为您只需对父表进行一次更改，然后将更改传播到每个继承的表。这节省了时间，减少了意外分歧的机会。</p><p id="8c1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在不阻塞其他数据的情况下，也可以运行维护命令，如完全清空或对继承的表进行重新索引。</p><h2 id="5247" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jb kj kk kl jf km kn ko jj kp kq kr ks bi translated">示例1:使用继承按月存储表统计信息</h2><p id="cab4" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">表继承最流行的用例之一是按月存储信息。这有利于对数据进行分区，以加快查询速度。</p><p id="209c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我已经使用该解决方案为以下情况设计了架构:</p><p id="c93c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 1。流程执行审计</strong></p><p id="6dae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">继承表可用于跟踪持续加载/卸载到系统中的数据、用户请求和计算过程，以及用于监控系统健康的其他重要信息。</p><p id="0399" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。应用程序中关键模块的用户操作审计</strong></p><p id="7366" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以创建一个审计系统来跟踪谁更改了系统中的数据，以及他们是在什么时候更改的。如果系统有很多用户，那么就有很多数据。因此，为了加速数据访问，使用表继承更有效。</p><p id="fe6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来看一个例子。</p><p id="d484" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，创建模式“示例1”:</p><pre class="jq jr js jt fd lr lq ls lt aw lu bi"><span id="b91e" class="jy jz hi lq b fi lv lw l lx ly">CREATE SCHEMA example1<br/>    AUTHORIZATION postgres;</span></pre><p id="a388" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后创建一个父日志记录表:</p><pre class="jq jr js jt fd lr lq ls lt aw lu bi"><span id="14ee" class="jy jz hi lq b fi lv lw l lx ly">CREATE TABLE example1.logging<br/>(<br/>    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),<br/>    event_name character varying NOT NULL,<br/>    start_time timestamp(6) without time zone NOT NULL,<br/>    end_time timestamp(6) without time zone NOT NULL,<br/>    CONSTRAINT february_log_pkey PRIMARY KEY (id, start_time, end_time)<br/>)<br/>TABLESPACE pg_default;</span></pre><p id="e75d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为特定的月份和年份创建子日志记录表，该表继承父表中的字段:</p><pre class="jq jr js jt fd lr lq ls lt aw lu bi"><span id="0c3c" class="jy jz hi lq b fi lv lw l lx ly">CREATE TABLE example1.january_log_2021<br/>(<br/>    CONSTRAINT start_time CHECK (start_time BETWEEN '2021-01-01' and '2021-01-31')<br/>)<br/>    INHERITS (example1.logging)<br/>TABLESPACE pg_default;</span></pre><p id="9541" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该代码包含一个使用<code class="du ln lo lp lq b">CHECK</code>命令对“start_time”列的检查约束。这将日期和时间保持在一月以内。</p><p id="eb2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">填写2021年1月的测井表:</p><pre class="jq jr js jt fd lr lq ls lt aw lu bi"><span id="cc30" class="jy jz hi lq b fi lv lw l lx ly">INSERT INTO example1.january_log_2021(id,<br/>    event_name, start_time, end_time)<br/>    VALUES <br/>           (1, 'Log in', '2021-01-11 03:26:11', '2021-01-11 03:26:13'),<br/>           (2, 'Log out', '2021-01-03 12:11:17', '2021-01-03 12:11:18'),<br/>           (3, 'Upload file xml', '2021-01-06 16:14:28', '2021-01-06 16:14:59'),<br/>           (4, 'Delete data', '2021-01-05 23:01:55', '2021-01-05 23:01:58');</span></pre><p id="96e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用<code class="du ln lo lp lq b">SELECT</code>命令检查数据是否成功插入:</p><pre class="jq jr js jt fd lr lq ls lt aw lu bi"><span id="cb37" class="jy jz hi lq b fi lv lw l lx ly">SELECT * FROM example1.january_log_2021;</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="ab fe cl lz"><img src="../Images/4786de9b55a45d09710ae7c7411c3c87.png" data-original-src="https://miro.medium.com/v2/0*2VL1HFid32eb43wr"/></div></figure><p id="7a77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个子表中的数据也会自动添加到父表中。</p><h2 id="c920" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jb kj kk kl jf km kn ko jj kp kq kr ks bi translated">示例2:使用继承来跟踪船只的移动</h2><p id="8a8d" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">我使用继承的另一个例子是基于地理位置存储关于船只及其运动的信息。</p><p id="fd88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每艘船都有共同和独特的价值。由于这个特性，我决定使用继承来设计模式，并基于父表为每艘船创建一个单独的表。</p><p id="3bd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用继承模型给我们带来了以下好处:</p><ol class=""><li id="0737" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn le lf lg lh bi translated">当应用程序构建船只运动的地图时，它只需引用单个船只的表，从而提高了报告构建和监控的速度。</li><li id="ef5f" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">为某些船舶类型添加新的特定字段不需要更改所有表格。</li><li id="3803" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">我们可以使用一个请求检索所有船只的基线数据。</li></ol><p id="d64b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们是这样做的。</p><p id="d262" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先创建一个名为“test”的新模式:</p><pre class="jq jr js jt fd lr lq ls lt aw lu bi"><span id="6a14" class="jy jz hi lq b fi lv lw l lx ly">CREATE SCHEMA test<br/>    AUTHORIZATION postgres;</span></pre><p id="cf10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建船舶数据库:</p><pre class="jq jr js jt fd lr lq ls lt aw lu bi"><span id="f90a" class="jy jz hi lq b fi lv lw l lx ly">CREATE TABLE test.ship<br/>(<br/>    AIS_name text NOT NULL,<br/>    type text NOT NULL,<br/>    flag text NOT NULL,<br/>    IMO character varying NOT NULL,<br/>    MMSI character varying NOT NULL,<br/>    callsign character varying NOT NULL,<br/>    year_built character varying NOT NULL,<br/>    length character varying NOT NULL,<br/>    width character varying NOT NULL,<br/>    draught character varying NOT NULL,<br/>    speed character varying NOT NULL,<br/>    AIS_class character varying NOT NULL,<br/>    cargo character varying,<br/>    CONSTRAINT ship_pkey PRIMARY KEY (MMSI)<br/>)<br/> <br/>TABLESPACE pg_default;</span></pre><p id="f154" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建表“sail_ship”，它是表“ship”的子表:</p><pre class="jq jr js jt fd lr lq ls lt aw lu bi"><span id="173f" class="jy jz hi lq b fi lv lw l lx ly">CREATE TABLE test.sail_ship<br/>(<br/>    -- Inherited from table test.ship: AIS_name text NOT NULL,<br/>    -- Inherited from table test.ship: type text NOT NULL,<br/>    -- Inherited from table test.ship: flag text NOT NULL,<br/>    -- Inherited from table test.ship: IMO character varying NOT NULL,<br/>    -- Inherited from table test.ship: MMSI character varying NOT NULL,<br/>    -- Inherited from table test.ship: callsign character varying NOT NULL,<br/>    -- Inherited from table test.ship: year_built character varying NOT NULL,<br/>    -- Inherited from table test.ship: length character varying NOT NULL,<br/>    -- Inherited from table test.ship: width character varying NOT NULL,<br/>    -- Inherited from table test.ship: draught character varying NOT NULL,<br/>    -- Inherited from table test.ship: speed character varying NOT NULL,<br/>    -- Inherited from table test.ship: AIS_class character varying NOT NULL,<br/>    -- Inherited from table test.ship: cargo character varying,<br/>    id_sail integer NOT NULL,<br/>    course text NOT NULL,<br/>    navigation_status text NOT NULL,<br/>    CONSTRAINT sail_ship_pkey PRIMARY KEY (id_sail)<br/>)<br/>    INHERITS (test.ship)<br/>TABLESPACE pg_default;</span></pre><p id="f36c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在填写表格“帆船”:</p><pre class="jq jr js jt fd lr lq ls lt aw lu bi"><span id="4584" class="jy jz hi lq b fi lv lw l lx ly">INSERT INTO test.sail_ship(AIS_name, type, flag, IMO, MMSI, callsign, year_built, length, width, draught, speed, AIS_class, cargo, id_sail, course, navigation_status)<br/>    VALUES ('A P T JAMES', 'Ferry', 'Trinidad and Tobado', '9877717', '362254000', '9YNM', '2020', '94 m', '26 m', '2.9 m/', '13.1 kn/20.2 kn', '-', '-', 1, '-', '-'),<br/>           ('MOZART', 'Container ship', 'Liberia', '9337274', '636018378', 'A8MA9', '2007', '222 m', '30 m', '10.4 m /', '12.9 kn / 23.6 kn', '-', 'Containers', 2, '-', '-'),<br/>           ('ALIANCA SKY', ' Bulk carrier', 'Liberia', '9128441', '636014513', 'A8UK6', '1997', '186 m', '30 m', '8.8 m /', '10.2 kn / 17.2 kn', '-', 'Agricultural Commodities', 3, '-', '-'),<br/>           ('XXX7', 'Ship', 'China', '-', '412444890', 'BVMY5', '-', '-', '-', '-/', '60.5 kn / 66.1 kn', '-', '-', 4, '-', '-');</span></pre><p id="c477" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">表“sail_ship”继承了其父表“ship”的所有列。</p><p id="815f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们也向父表添加一些数据，看看会发生什么:</p><pre class="jq jr js jt fd lr lq ls lt aw lu bi"><span id="2d42" class="jy jz hi lq b fi lv lw l lx ly">INSERT INTO test.ship(AIS_name, type, flag, IMO, MMSI, callsign, year_built, length, width, draught, speed, AIS_class, cargo)<br/>    VALUES ('A P T JAMES', 'Ferry', 'Trinidad and Tobado', '9877717', '362254000', '9YNM', '2020', '94 m', '26 m', '2.9 m/', '13.1 kn/20.2 kn', '-', '-');</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="ab fe cl lz"><img src="../Images/de19511a6c8e03a79e29b64d51de132a.png" data-original-src="https://miro.medium.com/v2/0*x7MwXw8CdDvBUwFN"/></div></figure><p id="c87c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在图中看到的，字段已经被添加，但是主键是重复的，所以它不再是唯一的</p><p id="4f77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是Postgres中关于继承的警告之一。添加到子表时没有发现错误，即使它违反了唯一主键。</p><p id="dea8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过使用<code class="du ln lo lp lq b">ONLY</code>操作符从“ship”表中检索数据，我们可以从子表中删除这些重复项。</p><p id="74a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，<code class="du ln lo lp lq b">ONLY</code>关键字表示查询应该只应用于“ship”表，而不是继承层次结构中ship下面的表。</p><pre class="jq jr js jt fd lr lq ls lt aw lu bi"><span id="1c01" class="jy jz hi lq b fi lv lw l lx ly">SELECT AIS_name, type, flag, year_built FROM ONLY test.ship;</span></pre><figure class="jq jr js jt fd ij er es paragraph-image"><div class="ab fe cl lz"><img src="../Images/6104fcdbf6cb530f4ddd2dfa04ea3419.png" data-original-src="https://miro.medium.com/v2/0*iY15OtUc9TMEChKr"/></div></figure><h2 id="ad65" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jb kj kk kl jf km kn ko jj kp kq kr ks bi translated">PostgreSQL继承需要注意的注意事项</h2><ol class=""><li id="a676" class="kz la hi is b it kt ix ku jb ma jf mb jj mc jn le lf lg lh bi translated">不能将带有<code class="du ln lo lp lq b">ALTER TABLE</code>命令的<code class="du ln lo lp lq b">RENAME</code>应用到子表；</li><li id="5c58" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">主键和外键的唯一性不会被继承。继承机制不能在继承层次结构中跨表自动分发来自插入或复制命令的数据。INSERT只在指定的表中插入，不在其他表中插入；</li><li id="4f71" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">用户必须对父表和子表都有访问权限；</li><li id="855e" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn le lf lg lh bi translated">必须手动删除列。如果使用<code class="du ln lo lp lq b">DROP COLUMN</code>命令对父表进行级联删除的情况下，它不能影响子表。</li></ol><h2 id="fe4b" class="jy jz hi bd ka kb kc kd ke kf kg kh ki jb kj kk kl jf km kn ko jj kp kq kr ks bi translated">结论</h2><p id="db74" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">在本文中，我们讨论了:</p><ul class=""><li id="6dc0" class="kz la hi is b it iu ix iy jb lb jf lc jj ld jn md lf lg lh bi translated">Postgres中的继承是如何工作的</li><li id="7b5e" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn md lf lg lh bi translated">为什么应该在应用程序中使用继承</li><li id="4a94" class="kz la hi is b it li ix lj jb lk jf ll jj lm jn md lf lg lh bi translated">两个在实际应用中如何使用继承的例子</li></ul><p id="313d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您正在寻找一个能让数据库工作更加简单的SQL编辑器，<a class="ae jo" href="https://blog.arctype.com/p/7a5ac2e5-a4ce-4f1d-8839-cdf1e258e369/www.arctype.com" rel="noopener ugc nofollow" target="_blank">现在就免费试用Arctype】:</a></p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jp"><img src="../Images/f4719365319f6e0f06a4bbb28e2bd284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BijhVCglgJzCVT5-.gif"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated"><a class="ae jo" href="https://blog.arctype.com/inheritance-in-postgres/www.arctype.com" rel="noopener ugc nofollow" target="_blank">今天试试Arctype】</a></figcaption></figure></div></div>    
</body>
</html>