# 实际了解使用状态挂钩

> 原文：<https://medium.com/codex/all-about-react-usestate-hook-54b432d61be3?source=collection_archive---------2----------------------->

## 这里是关于 useState 钩子的所有内容，以及调试你的应用程序所需要知道的一切…

![](img/ebb8c0dc17578d8a170847df4f8acffe.png)

React 的 *useState* 钩子是我们学到的第一个钩子，但在我看来它是最难学的。据我所知，所有的使用状态教程和文档只是教我们使用使用状态的基本用法，但这不是全部。比如:-

1.  如何处理**异步** **的情况？**
2.  setState 是同步函数还是异步函数？

我会试着用一些例子来澄清这些事情。

# 回归基础

如果你对 *useState* 钩子一无所知，让我快速展示一下它的基本用法。

*   在上面的代码中，我们只是声明了一个状态变量，`counter`。
*   点击“增量值”按钮，我们将`counter`的值设置为`counter + 1`，因此每次点击都会增加变量的值。
*   因此，变量的**状态改变**并且组件被**重新呈现**，这允许我们在 UI 中看到更新的值。

## 那么为什么要使用状态变量呢？我们可以使用普通的 javascript 变量？

不，我们不能。如果我们使用普通的旧的“var”或“let”JavaScript 变量，则不会触发**重新渲染**，因为 React 只看到*使用状态*变量的状态变化。

## 什么是状态变化？

Ans >对于 React，当`prevState !== currentState`时发生状态变化。所以对于原始值(数字、布尔、字符串)来说，只是改变它们的值。例如:-

```
const [name, setName] = useState("Me"); // setName("Hamster")
const [marks, setMarks] = useState(0); // setMyNumber(100)
const [working, setWorking] = useState(false); // setWorking(true)
```

以上都将触发状态变化。

对于对象和数组，你必须传递一个新的对象或数组。如果你熟悉不变性，那么这对你来说并不陌生。如果你传递一个新的对象或数组，那么只有条件`prevState !== currentState`会被触发。如果你想通过例子学习不变性，这里的是一个很好的资源。**扩展操作符**将对此非常有用。

```
const [students, setStudents] = useState(["me"]);
// setSudents([...students, "another student"]);const [obj, setObj] = useState({something: "hello"});
// setObj({...obj, someMoreThings: "bye"});
```

以上都将触发状态变化，重新呈现组件。

# 同步还是异步？

这对我来说是一个很长时间的误解。我们上面使用的*【set】*方法是同步的还是异步的？答案可能会让你吃惊…这些方法是同步的。哦，等等，这一点也不奇怪，但是，等等，你面临着一个挑战。

那么你认为在调用了`setCounter(counter +1)`之后`console.log(counter)`会打印出什么？

您将看到`counter`值在增加 1 后是相同的。那么发生了什么？`setCounter`应该是同步函数吧？所以这种变化应该立即反映在下一行中？ **NOO** 。

原来 React 是故意这么做的。因为 setState 函数非常昂贵，所以 React 批处理许多 setState-s，所以我们不能依赖任何计算的状态变化。在这里，打印该值的正确方法是只打印`console.log(counter + 1)`。

# 如何处理**异步** **的情况？**

好了，到目前为止，我们已经知道了*使用状态*的基本知识，但是还有更多，我在很多地方都没有看到这部分的正确解释。

那么一些异步的情况呢？比如一个回调函数或者一些套接字操作？对于这些情况，setState 将同样工作，对吗？

恐怕事实并非如此。让我们考虑一些例子。

异步计数器，正常方式

在这里，我们在文档上设置了一个点击监听器，这样当您点击页面时，计数器应该增加 1。但是正如你所看到的，计数器第一次增加了 1，但是之后就卡住了。

为什么它不起作用？

基本上，对于异步的事情，React 将状态变量与初始值 0 绑定，因此第一次`counter + 1`导致 1，但是当屏幕再次被点击用于**功能**时，计数器变量仍然是 0，因此计数器再次被设置为 1。因此，为了防止这种情况，我们需要最后的渲染值，并用**渲染值进行计算。**

新的部分来了，setState 变量也可以接受一个函数作为参数。举个例子就很清楚了。

上面的代码类似于 CodeSandbox 代码，但是第 8–10 行有所不同。这次我们将一个函数传递给了`setCounter`函数。该函数的参数基本上是状态变量的 ***渲染值*** ，因此当点击屏幕时，时间一切都按预期工作，计数器上升！！！

# 结论

上述方法也可以用于套接字或任何其他异步情况。向 setState 函数传递一个函数在教程中没有涉及太多，但我认为这是一个非常重要的情况，在应用程序中需要多次。除此之外，我想读者也很好地理解了*使用状态*钩子。谢谢你的阅读。希望你有美好的一天！！！干杯😄