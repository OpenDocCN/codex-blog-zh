# 无服务器 CI/CD:提升管道等级的 5 种具体方法

> 原文：<https://medium.com/codex/serverless-ci-cd-5-specific-ways-to-level-up-your-pipelines-82eadce5e99f?source=collection_archive---------2----------------------->

![](img/a02e90b4fa17fa84be71086707ad3da2.png)

# 一点背景

我最近加入了一家成长中的金融科技初创公司，我很快就认识到交付速度和可靠性是绝对重要的。在一个创业的世界里，一个不能让它足够快的特性或者任何产生的生产问题都会导致客户不使用这个产品。

我们已经有了一个非常基本的工作流程，但是当我加入时，我的直觉是投入一些时间从概念的角度将理想的工作流程放在一起并实现它。理由是这将一劳永逸地完成，所有其他回购将重复使用它。我们采用无服务器优先的方法，我们所有的服务都是使用 AWS Lambda、EventBridge、API Gateway、SQS、无服务器框架等构建的……最终的管道应该反映这一点，并且本身应该面向无服务器。

在这篇博文中，我与你分享了一些我深思熟虑的事情和一些实现细节，它们将帮助你升级你自己的无服务器 CI/CD 管道！

# I .如果你的回购是托管在 GitHub 上，使用 GitHub 操作

我为基于 AWS 的无服务器应用程序创建的第一个管道是使用 AWS CodeBuild 和 CodePipeline。他们是不错的工具，他们做了工作，但我觉得有点古怪。显然，使用 AWS 代码套件时，开发人员的体验并没有被放在最前面和最中心的位置，这意味着要启动和运行管道需要很多样板文件。当然，有许多不同的配置涉及到许多云的形成。

与 github 操作相反，另一方面，将 YAML 文件签入根目录下的. GitHub 文件夹，您就有了管道！

此外，我发现几乎所有我想做的事情都已经有人做了，而且周围有一个非常好的社区。

我个人在我所有的无服务器应用程序中使用无服务器框架，所以让[GitHub Action for server less](https://github.com/serverless/github-action)开箱即用是令人愉快的。

部署无服务器应用程序就像运行这 4 行 YAML 一样简单:

我在使用分支名称的地方使用了一个小技巧，通过使用 ***github.ref_name*** 作为这个动作的输入，这使得特性分支部署变得轻而易举。请记住，您必须确保分支名称符合无服务器框架的阶段名称正则表达式:

```
***^[a-zA-Z0-9-]+$***
```

关于 GitHub 操作的最后一件事，确保使用新的 [AWS OIDC](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services) GitHub 集成，而不是长期存在的凭证。它不仅更安全，实际上我花了大约 15 分钟就设置好了！我发现了一篇非常有用的[博文](https://www.eliasbrange.dev/posts/secure-aws-deploys-from-github-actions-with-oidc/)，如果你正在设置 GitHub AWS 集成，一定要去看看。

# 二。利用最好的无服务器功能:不使用时免费

换句话说，经常部署和尝试。如果有任何可能发生的故障，您希望尽快知道。这里的典型问题是 IAM 角色、可能在不同阶段解析不正确的阶段相关变量，以及可能在一个环境中工作但在另一个环境中不工作的基础设施。

这就是一个关键概念发挥作用的地方:**特性分支部署**。任何有效的开发人员工作流程的第一部分，尤其是在无服务器环境中，是一个关于新添加的功能是否有效的简短反馈循环。我发现最有效的方法有两个:

*   开发人员应该在一个代表他们新特性专用环境的**隔离阶段**进行部署和测试，对我们来说，它看起来像是 **feature-0000**
*   将监听**的 GitHub 动作(或等效动作)将**推向**分支**，然后验证特性分支环境本身

更深入地研究自动化操作，每次代码被推送到任何不是主分支的分支时，一系列的自动化测试和自动化特性分支部署到一个开发帐户(你当然应该为每个环境使用不同的 AWS 帐户)。这里有一个问题:开发者应该只能够与主分支**合并，当且仅当** **这个动作成功时。**

对于 TypeScript 项目来说，可能是这样的:

# 三。比起集成和单元测试，更喜欢端到端测试

我知道，我知道这有点过火。但是请容忍我一点。

现在你我都知道，如果我们交付的特性没有针对它编写的测试，**它就不应该被认为是完整的。更重要的是，它几乎肯定会在未来以某种方式倒退，而我们没有任何东西来捕捉这种倒退。**

在一个无服务器的环境中，我们做的很多事情是把 AWS 的拼图拼在一起:无论是 Lambda 前端的 API Gateway 或 AppSync 的同步 API，还是异步处理的 EventBridge，SQS，Kinesis 或 SNS。因此，如果我们想要真正地对 lambda 函数进行单元测试，并且真正地孤立地测试它(单元测试的定义),我们必须模拟其他的一切。根据我的经验，这需要很长时间。此外，投资回报非常小，因为您仍然需要编写更全面的测试，因为单元测试不会捕捉与服务相关的错误，如 IAM 权限等。所以**对你的单元测试要有战略眼光**，考虑执行复杂计算的函数或方法的单元测试，或者任何与 AWS 无关的事情。

**另一方面，集成测试**的嘲讽较少，因为我们会使用真正的 AWS 服务来运行它们。但是根据定义，集成测试就是这样做的:测试 AWS 难题的两个部分之间的集成。比方说 Lambda 将一个项目写入 DynamoDB 表，或者 AppSync 解析器从 DynamoDB 表中获取一个项目。这比单元测试有更好的投资回报，如果你有时间，你应该总是选择编写集成测试。但是请记住，这仍然需要时间。如果交付速度至关重要，它们可能并不总是实用的。

另一方面，E2E 测试会给你所需要的信心，让你知道你的服务实际上如预期的那样工作。当然，您将牺牲一些粒度。有了 E2E 测试，没有必要嘲笑任何东西，你会希望它尽可能地接近现实生活中的情况。假设您正在使用 API Gateway 构建一个同步 rest API，您在一个测试环境中发出一个真实的 API 请求。对于异步的东西，比如 EventBridge，就有点复杂了。由于它的异步特性，没有办法知道处理何时结束。所以这里我通常会在 EventBridge 上放置一个事件，并在运行断言之前使用 setTimeout 等待几秒钟。

所以一个典型的 E2E 测试可能是这样的:

# 四。拥有利用多个 AWS 帐户的强大合并工作流

回到争议较少的话题，这是 AWS 无服务器世界中最接近一致的建议！

当 on push 动作在一个专用的特性环境中成功时，它在一个 **dev AWS 帐户**中运行，并且已经通过了团队中几个 dev 的几个评审，它就准备好被合并到主分支中了。当这种情况发生时，将会引发一系列的行动。

让我们来看看它们是什么！

首先，您将希望使用新合并的代码来将特性环境部署到开发环境中，并针对该环境运行所有的测试。一旦这一关过去，你将准备好继续前进。现在，工作流应该部署到另一个**不同的** AWS 帐户，该帐户将拥有您的**暂存环境**。你会希望**保持那个环境**，这样，如果需要的话，像产品负责人和其他开发人员这样的人可以拥有一个专用的环境，随时反映生产情况。您还针对登台环境运行了测试套件，您会对在一个 AWS 帐户中通过而在另一个帐户中没有通过的次数感到惊讶！

始终确保**试运行和生产的外观和感觉完全相同**。这包括数据，请确保您的暂存环境中没有无意义的数据，您希望它看起来像真实的东西。

现在，开发和试运行中的一切都已通过，您将准备好部署到生产中。您应该有信心知道这个部署会很顺利，不会引起任何问题。当然，生产工作负载**在单独的 AWS 账户**中运行。这意味着您将有三个帐户(或者更多，有些人每个开发人员有一个开发人员帐户！):

*   一个开发账户
*   一个**暂存**账户
*   一个**产量**账户

哦，最后一件事。在这个阶段，您需要进行一个清理步骤来删除您的特性分支部署，否则您将会遇到各种 AWS 配额限制，如 IAM、S3、API Gateway 等等！

这可能是这样的:

# 动词 （verb 的缩写）加分项:持久分支越少越好！

这可能又是一个有争议的问题，但请耐心听我说。

我曾在多个环境中工作过，其中我们有多个持久分支，通常对应于它们存在的环境: **Dev** 、 **Staging** 和 **Main。**根据我的经验，这总是会引起摩擦，他们很容易相互疏远。

如果我们始终只有一个持久分支:main，会怎么样？

其工作方式是，开发人员将从 main 创建一个特性分支。从那里，有一个独立的环境，他们在那里做他们的改变，然后在合并回 main 之前经历我们上面讨论的序列。一旦他们的分支被合并并成功部署到所有三个主要环境中，它就会被删除。

这可能对一些人来说有些激进，我知道当我向我目前的团队提出这个想法时，我有一点健康的抵触情绪！但是一旦您看到它在运行，您就会开始想为什么您需要其他持久分支来开始！