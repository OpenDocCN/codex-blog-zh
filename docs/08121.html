<html>
<head>
<title>How I made an App to Read the Top Posts from Reddit: JUDGEMENT DAY</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何制作一个应用程序来阅读Reddit上的热门帖子:审判日</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-i-made-an-app-to-read-me-the-top-posts-from-reddit-judgement-day-98387a192750?source=collection_archive---------7-----------------------#2022-07-18">https://medium.com/codex/how-i-made-an-app-to-read-me-the-top-posts-from-reddit-judgement-day-98387a192750?source=collection_archive---------7-----------------------#2022-07-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f53c628eefc74ab8ee2bbbd410acfaf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*TIu46p-4qw7PKUlumF7Hew.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">甲醇终止剂</figcaption></figure><p id="b948" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在本系列的第1部分中，我使用AWS Lambda、API Gateway和Adalao创建了一个应用程序来朗读Reddit上的新帖子。</p><p id="aaa3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第一部分可以在这里阅读:</p><div class="jt ju ez fb jv jw"><a rel="noopener follow" target="_blank" href="/codex/how-i-made-an-app-to-read-to-me-the-top-posts-from-reddit-with-aws-8acd067a6201"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">我如何制作一个应用程序，用AWS为我朗读Reddit上的热门帖子</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">总结:</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">medium.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk io jw"/></div></div></a></div><p id="5f4b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在第2部分中，我将向您展示优化我们的应用程序的各种策略。</p><ol class=""><li id="5c47" class="kl km hi iw b ix iy jb jc jf kn jj ko jn kp jr kq kr ks kt bi translated">Lambda代码流的优化</li><li id="cf8c" class="kl km hi iw b ix ku jb kv jf kw jj kx jn ky jr kq kr ks kt bi translated">安全性-使用AWS SSM参数存储</li><li id="2e88" class="kl km hi iw b ix ku jb kv jf kw jj kx jn ky jr kq kr ks kt bi translated">AWS功率调谐</li><li id="9f23" class="kl km hi iw b ix ku jb kv jf kw jj kx jn ky jr kq kr ks kt bi translated">API网关优化</li><li id="2cca" class="kl km hi iw b ix ku jb kv jf kw jj kx jn ky jr kq kr ks kt bi translated">供应的并发</li></ol><p id="75ff" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">优化Lambda码流</strong></p><p id="4470" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所有优化都必须是数据驱动的。所以我们查看了API网关和Lambda函数的cloudwatch日志。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/f975b68d8b54f82d206de19684eee1f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RwO2UyUcTX93JTHhQsxkTQ.png"/></div></div></figure><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/0a105a2847a52c5a5167aeace34aeb4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2BozHzFWCeFE0XFSdyK1g.png"/></div></div></figure><p id="b334" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">马上，我们可以通过优化lambda代码获得更多的性能。</p><p id="3e1f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每次调用函数时，它都从handler()函数开始执行。如果您的代码可以被调用一次，然后在下一次调用中重用，那么最好将它放在处理程序()之外。所以我们把一些初始化的东西，比如对Reddit API的认证，移到了处理程序之外。</p><p id="64cb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以我们在处理程序()之前定位所有的导入和初始化</p><pre class="la lb lc ld fd lf lg lh li aw lj bi"><span id="6d49" class="lk ll hi lg b fi lm ln l lo lp">import json<br/>import boto3 <br/>from botocore.exceptions import BotoCoreError, ClientError<br/>from contextlib import closing<br/>import sys <br/>import base64<br/>import requests<br/>from datetime import datetime,timedelta</span><span id="41bb" class="lk ll hi lg b fi lq ln l lo lp"># Create a client using the credentials and region defined in the [adminuser]<br/>session = boto3.Session(region_name=”us-east-1")<br/>polly = session.client(“polly”)</span><span id="b130" class="lk ll hi lg b fi lq ln l lo lp">ssm_client = boto3.client(‘ssm’)</span><span id="9f8a" class="lk ll hi lg b fi lq ln l lo lp">def lambda_handler(event, context):</span></pre><p id="c6a2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">安全性—使用AWS SSM参数存储</strong></p><p id="67c3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们真的不需要在每次调用函数时都生成一个新的Reddit API密匙，因为API密匙在24小时内有效(在这个特定的用例中。在标准的oauth2工作流中，它在较短的时间内有效),因此我们可以将令牌放在某个地方，如果到期时间还没有过去，就从那里获取它。为此，我选择使用AWS SSM参数存储。(AWS Secrets Manager更适合存储这样的实际秘密值，但为了保持低成本，我选择了参数存储)</p><p id="519e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为lambda创建内联策略以访问参数存储。这将被添加到Lambda执行角色中，因此Lambda可以访问参数存储。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/fd8cba2360af62171c2914fc0d161c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zdNmxHCseURyHLHXveicNA.png"/></div></div></figure><p id="86d0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在SSM参数库中创建参数。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/467d2fa7115a18ba854ecabbe1614da2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*clKa7k6EsGsZKZXoF1UC8w.png"/></div></div></figure><p id="4ddc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在lambda中进行必要的代码更改，以便在生成新的API密钥之前检查SSM。我们还会将用于获取API密钥的凭证放在参数存储中。</p><pre class="la lb lc ld fd lf lg lh li aw lj bi"><span id="f783" class="lk ll hi lg b fi lm ln l lo lp">token_parameter = ssm_client.get_parameter(Name='/readreddit/access_token')</span><span id="8dad" class="lk ll hi lg b fi lq ln l lo lp">token_expires = ssm_client.get_parameter(Name='/readreddit/token_expires')</span><span id="fb12" class="lk ll hi lg b fi lq ln l lo lp"># setup our header info, which gives reddit a brief description of our app</span><span id="d874" class="lk ll hi lg b fi lq ln l lo lp">headers = {'User-Agent': 'catpostv1/0.0.1'}</span><span id="a1b1" class="lk ll hi lg b fi lq ln l lo lp">if datetime.now() &lt; datetime.strptime(token_expires['Parameter']['Value'],"%Y-%m-%d %H:%M:%S.%f"):</span><span id="0ec7" class="lk ll hi lg b fi lq ln l lo lp">TOKEN = token_parameter['Parameter']['Value']</span><span id="ca21" class="lk ll hi lg b fi lq ln l lo lp">headers = {**headers, **{'Authorization': f"bearer {TOKEN}"}}</span><span id="3498" class="lk ll hi lg b fi lq ln l lo lp">else:</span><span id="c7ad" class="lk ll hi lg b fi lq ln l lo lp">TOKEN = get_new_token()</span><span id="f5c0" class="lk ll hi lg b fi lq ln l lo lp">headers = {**headers, **{'Authorization': f"bearer {TOKEN}"}}</span><span id="9903" class="lk ll hi lg b fi lq ln l lo lp"># while the token is valid (~2 hours) we just add headers=headers to our requests</span><span id="374b" class="lk ll hi lg b fi lq ln l lo lp">res = requests.get("https://oauth.reddit.com/r/popular/hot",headers=headers)</span></pre><p id="159c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> AWS Lambda功率调谐</strong></p><p id="ac34" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">优化lambda的另一种方法是分析性能如何随着内存的增加而变化(lambda中的内存设置=内存+分配的CPU)。因为增加内存也会增加每秒lambda的定价，所以我们需要在增加成本和增加内存之间做一个权衡。幸运的是，有一个叫做<a class="ae js" href="https://github.com/alexcasalboni/aws-lambda-power-tuning" rel="noopener ugc nofollow" target="_blank"> aws lambda功率调整</a>的工具可以自动完成这种分析。它将使用不同的内存设置运行您的lambda，并生成一个显示最佳选项的图表。</p><p id="0d9b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因为我们的lambda不是特别占用CPU资源，所以我们的结果基本符合预期。但比猜测要好。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/e5b11d6194d077376fcb79823d2918a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RPLLLducxwJ1VgugTD4vHA.png"/></div></div></figure><p id="c82a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> API网关优化</strong></p><p id="829a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们抽象地考虑一下API Gateway。用户将请求发送到API网关URL。Gateway将请求代理给Lambda，Lambda进行处理以创建响应。现在它从Lambda发送到网关，网关发送到用户。</p><p id="d90a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以解决API Gateway中的两个延迟来源。1)请求在不可靠的公共互联网上传输得越多，到达实际API端点所需的时间就越长。lambda必须为每个请求做出响应。</p><p id="3ff9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">API网关缓存</p><p id="8d17" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果API网关不需要做任何工作，Lambda也不需要每次都运行来产生响应，那会怎么样？这就是缓存。第一次运行时，API Gateway在网关上缓存响应。下一次请求到来时，响应将直接从缓存中提供。我们可以像这样打开API网关上的缓存:</p><p id="af1a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">API网关→API→阶段→(选择阶段)→设置—启用API缓存</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/4e83b22d14c2c506fce35e33e541e80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHNLfk1SvOEUY6Q5z56b9g.png"/></div></div></figure><p id="1e7a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我启用了这个选项，响应非常快。问题？它一直给出相同的回应，即使r/popular中的Reddit帖子已经更改。</p><p id="d24e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们解决第二个问题。我们可以通过使用边缘位置来最小化公共互联网遍历。</p><p id="b61c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">API网关→API→设置-&gt;端点-&gt;边缘优化</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/b89d2c249fbaaed03042f38b357a41b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*86C2sysEVo73n1Ay_fRGzg.png"/></div></div></figure><p id="8744" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，API网关端点使用离用户最近的AWS边缘位置，这个请求在公共互联网上的传输被最小化。这使得请求更快。</p><p id="5506" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">调配并发</strong></p><p id="ce86" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面没有提到的一种方法是供应并发。因为AWS Lambda函数是按需调用的，所以可能存在一个问题，称为冷启动。这就像在寒冷的冬天早晨启动汽车引擎一样。供应并发通过预热执行环境并使其准备好立即执行来解决冷启动问题。比方说，如果你可爱的配偶在你离开前10分钟为你发动了汽车。在AWS上，自由层配置的并发不是现成可用的，但是您可以请求增加限制以获得配置的并发。这需要额外的费用。</p><p id="61cc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如何知道自己的函数有没有冷启动？检查Cloudwatch中的lambda日志，查看给出持续时间和计费持续时间的最后一行。</p><pre class="la lb lc ld fd lf lg lh li aw lj bi"><span id="6943" class="lk ll hi lg b fi lm ln l lo lp">Duration: 177.70 ms	Billed Duration: 200 ms Memory Size: 2048 MB</span></pre><p id="6279" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果这些与上面给出的不同，这意味着准备执行环境花费了3秒钟的冷启动时间。当我们设置预配并发时，在您调用lambda之前，AWS已经为您完成了这3秒钟的工作。</p><p id="0e9b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要为您的lambda设置提供的并发性，首先发布一个版本。操作→发布新版本</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/c8190866a8c2aba51d08767bfa56f7bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBgE0_7BVKxu2ETxpgKE8g.png"/></div></div></figure><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/8e61d389fa7e6e15b27291473667980b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KUpe4ITQZNlzQisq8D6RYQ.png"/></div></div></figure><p id="d462" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以观察到，在使用供应的并发后，速度进一步提高了。延迟减少了50%</p><p id="5456" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">性能提升从来都不是一劳永逸的活动，希望这些指点对你的旅途有所帮助。</p></div></div>    
</body>
</html>