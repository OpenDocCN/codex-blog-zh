<html>
<head>
<title>Buffer Overflows, Shellcode, and Memory Corruption</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓冲区溢出、外壳代码和内存损坏</h1>
<blockquote>原文：<a href="https://medium.com/codex/buffer-overflows-shellcode-and-memory-corruption-51f546ab00ab?source=collection_archive---------7-----------------------#2022-08-08">https://medium.com/codex/buffer-overflows-shellcode-and-memory-corruption-51f546ab00ab?source=collection_archive---------7-----------------------#2022-08-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f623276a5d8eff3c931fc042df906bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5B5Ji_M0xQw8iT-6c9ixdA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">撰稿人:<a class="ae iu" href="https://www.linkedin.com/in/jake-mellichamp/" rel="noopener ugc nofollow" target="_blank">杰克·梅利查普</a>，<a class="ae iu" href="https://www.linkedin.com/in/zackary-griffin/" rel="noopener ugc nofollow" target="_blank">史蒂文·格里芬</a>，<a class="ae iu" href="https://www.linkedin.com/in/wes-b-34216817/" rel="noopener ugc nofollow" target="_blank">韦斯·贝利</a></figcaption></figure><h1 id="72a3" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">一.导言</h1><p id="5fe8" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">缓冲区溢出和内存损坏利用是最早的计算机安全问题之一，从攻击和防御的角度来看，这个主题已经花费了无数的时间。</p><p id="8e68" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">缓冲区溢出攻击的第一次描述记录在142页的1972年美国空军出版物<em class="kw">“计算机安全技术规划研究</em>”中。[1]在标题为“恶意用户威胁”的第3.2节中，该文档断言:<em class="kw">“事实上</em> <strong class="jv hj"> <em class="kw">操作系统没有被设计为安全的</em> </strong> <em class="kw">为恶意用户提供了许多破坏操作系统本身的机会”。</em></p><p id="d9bb" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">报告接着讨论了一个处理指针的易受攻击的程序，指出:<em class="kw"> " </em> <strong class="jv hj"> <em class="kw">通过向用户程序提供分配给</em> </strong> <em class="kw">的空间之外的地址，</em> <strong class="jv hj"> <em class="kw">通常可以让监视器获取该用户的未授权数据</em> </strong> <em class="kw">，或者至少……</em><em class="kw">系统崩溃</em></p><p id="183e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">对于缓冲区溢出攻击，很难找到更简洁、更规范的描述。<strong class="jv hj">显然，早期的重点是让系统<em class="kw">工作</em>，而不是让系统<em class="kw">安全</em>。那会改变的。</strong></p><p id="4f97" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">虽然大多数早期攻击只能通过显式解除默认对策才能在现代操作系统上重现，但了解这些攻击的历史仍然很有意义。网络安全领域中没有任何东西是在真空中创造出来的，通常情况下，现代系统的方法看似武断，但却直接植根于过去。了解历史可以更好地揭示和理解当前平台的现状和原因以及它们的漏洞。</p><h1 id="bee6" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">二。（从）历史的视角</h1><p id="0898" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">1988年秋天，康奈尔大学一位名叫罗伯特·塔潘·莫里斯的研究生写了一段恶意代码，后来成为臭名昭著的“<strong class="jv hj">莫里斯蠕虫</strong>”。[2]它利用了Unix体系结构中的几个弱点，包括“fingerd”网络服务中的缓冲区溢出。这种蠕虫通过连接到新生互联网的机器迅速传播，造成了严重的破坏。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/33cd0d6a25b3ae894d47ea723f61da78.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/0*-FGIZTRtICxs-wnu"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">罗伯特·塔潘·莫里斯</figcaption></figure><p id="8c1c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">莫里斯坚持说，他只是“利用他发现的安全缺陷来证明当前计算机网络安全措施的不足。”他的辩解被置若罔闻，莫里斯成为第一个根据“计算机欺诈和滥用法案”被起诉的人。他后来被判有罪，判处3年缓刑和10，500美元罚款。不过，他能够很好地东山再起，后来在哈佛大学完成了博士学位，并与人合伙创办了几家科技公司，包括非常成功的孵化器<em class="kw"/><a class="ae iu" href="https://www.ycombinator.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jv hj">y combinator</strong></a>。他目前的净资产估计为49亿美元。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/c72de79fd06b601a51ba1f07204c9667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KqmcqxUig_rtvLr5tauu4w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">缓冲区溢出的历史可视化</figcaption></figure><p id="5635" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在过去的三十年里，已经做了大量的工作来解决这种类型的脆弱性。1997年，StackGuard宣布，实现了一个<strong class="jv hj"> </strong> <a class="ae iu" href="https://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries" rel="noopener ugc nofollow" target="_blank"> <strong class="jv hj">栈金丝雀</strong> </a>的概念。同年，一个名为“Solar Designer”的黑客演示了<a class="ae iu" href="https://en.wikipedia.org/wiki/Return-to-libc_attack" rel="noopener ugc nofollow" target="_blank"> <strong class="jv hj"> return-2-libc攻击</strong> </a>，有效地绕过了不可执行的堆栈对策。有了这一发现，堆溢出、指针覆盖、格式字符串攻击和许多其他极具创造性的漏洞被开发出来。[3]同时，以<a class="ae iu" href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" rel="noopener ugc nofollow" target="_blank"><strong class="jv hj"/></a><strong class="jv hj">斯塔克豪思</strong><strong class="jv hj">帕克斯</strong>等形式不断加强防御措施。无论一方做什么，另一方似乎就在前面或在后面；猫捉老鼠的游戏永远不会结束。[4]</p><h1 id="d4b0" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">三。堆栈缓冲区溢出概念</h1><p id="bd17" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">也就是说，在我们的实验中，我们将成为抓老鼠的猫(攻击者)(现代堆栈保护)。这里概述了什么是堆栈缓冲区溢出的背景:<strong class="jv hj">堆栈缓冲区溢出(SBOF)在很长一段时间里都是ELF二进制文件中的一个基本漏洞。</strong> <strong class="jv hj">成功的攻击者可以覆盖本地变量数据或执行恶意代码。这显然不理想，通常是由于程序员不知道堆栈框架是如何工作的。</strong></p><p id="bfd2" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">将源代码编译成可执行二进制文件的过程是一个复杂的过程。源代码在最终加载到内存(用加载器)之前，必须经过预处理、汇编并链接到库函数(用链接器)。<strong class="jv hj">当该过程完成时，文本、数据、堆和堆栈分段被加载到存储器中并用于程序执行。</strong></p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/74158ab0a5a4624ac8e4dc2b35e9d283.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/0*ZUSL41YQJmc63AoS"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3.1 —程序布局。</figcaption></figure><p id="9755" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">程序布局将有助于理解SBOF攻击的本质，但真正的<strong class="jv hj">漏洞存在于堆栈框架</strong>内部。</p><p id="04b4" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">堆栈帧是每次调用函数时创建的内存段。它包含<strong class="jv hj"><em class="kw"/></strong>(<code class="du le lf lg lh b">EBP</code>/<code class="du le lf lg lh b">RBP </code>—一个标记堆栈基址的常量地址)<strong class="jv hj"> <em class="kw">堆栈指针</em> </strong> ( <code class="du le lf lg lh b">ESP</code> / <code class="du le lf lg lh b">RSP </code> —在函数执行过程中，当值被压入或弹出堆栈时可能会改变)、一个<strong class="jv hj"> <em class="kw">返回地址</em> </strong> ( <code class="du le lf lg lh b">EIP</code>，以及传入的<strong class="jv hj">函数参数</strong>。堆栈缓冲区溢出漏洞描述如下。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es li"><img src="../Images/a17f9c51be5dd92702d66f4dc92b084f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/0*_6Cbgn6uCu2qNP7Z"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1.2漏洞。</figcaption></figure><p id="4d8b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">为了利用这种情况，攻击者必须结合使用<code class="du le lf lg lh b">NOP </code>命令和外壳代码来溢出缓冲区的内存。溢出应该继续，直到基帧指针<code class="du le lf lg lh b">EBP</code>被成功覆盖。<strong class="jv hj">漏洞利用的最后一步是在外壳代码开始之前，将堆栈的<em class="kw">返回地址覆盖回缓冲区。如果这些条件都能满足，那么这个二进制数就是一个负债。</em></strong></p><h1 id="f58e" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">四。Linux 32位x86系统上的漏洞利用演示</h1><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/7ac7c02ede3786d2d18fbe3ec49c81d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*JKmvkmB1w_GZY75ofFcBlA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4.1 —易受攻击的程序</figcaption></figure><p id="60ec" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在我们的SBOF漏洞利用中，用于输入的<strong class="jv hj">缓冲区的大小为500字节</strong>。首先，我们必须发现:</p><ul class=""><li id="74b9" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated">从缓冲区的<strong class="jv hj">开始到<strong class="jv hj">返回地址</strong>的距离，这样我们就可以在<code class="du le lf lg lh b">EIP </code>寄存器中放置一个恶意返回地址。</strong></li></ul><p id="90f9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">为此，我们的团队使用了GDB的<strong class="jv hj"/>。我们从随机选择一个小的缓冲区溢出开始，在这个例子中，缓冲区溢出了8个字节(图4.2)。</p><p id="edec" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">出现segfault！通过使用命令<code class="du le lf lg lh b">(gdb) info registers</code>，用户可以看到哪些寄存器受到了影响。从下图中我们可以看到，我们成功地覆盖了<code class="du le lf lg lh b">EBP </code>寄存器，但没有覆盖<code class="du le lf lg lh b">EIP</code>。<code class="du le lf lg lh b">EIP </code>是返回地址。从图4.1中，我们还知道<code class="du le lf lg lh b">EIP </code>总是比<code class="du le lf lg lh b">EBP </code>寄存器多4个字节。所以我们只需要在508的基础上加4，使之成为512。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/09b075f6fc45f577f68934e05bfa2ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iu8U6XZQS2R2LtaJOLyBSQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">4.2堆栈溢出</figcaption></figure><h2 id="f7a6" class="lu iw hi bd ix lv lw lx jb ly lz ma jf ke mb mc jj ki md me jn km mf mg jr mh bi translated">成功覆盖寄信人地址</h2><p id="8a7b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">使用512个“A”字符启动程序会导致以下结果:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/95cab7fb00bb1f3044c4f516b8e8e7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iu1Eugc_kYd_2k9mYnpLSw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">4.3成功覆盖回邮地址</figcaption></figure><h2 id="19f6" class="lu iw hi bd ix lv lw lx jb ly lz ma jf ke mb mc jj ki md me jn km mf mg jr mh bi translated">精心制作恶意负载</h2><p id="d8a0" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">使用<a class="ae iu" href="https://www.geeksforgeeks.org/gdb-step-by-step-introduction/" rel="noopener ugc nofollow" target="_blank"> GDB </a>我们发现缓冲区末端和EIP寄存器之间的距离正好是12个字节。知道了这些信息，我们就可以制造一个恶意的有效载荷。那么，从哪里开始呢？</p><ul class=""><li id="7563" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated"><strong class="jv hj">外壳代码</strong>:使用<a class="ae iu" href="https://shell-storm.org/" rel="noopener ugc nofollow" target="_blank">https://shell-storm.org/</a>我们的团队能够找到一段外壳代码来使用43个字节执行系统调用<code class="du le lf lg lh b">execve(/bin/sh)</code>。该外壳代码将使用当前进程权限启动终端。</li><li id="2060" class="lk ll hi jv b jw mj ka mk ke ml ki mm km mn kq lp lq lr ls bi translated"><strong class="jv hj">返回地址:</strong>我们需要覆盖<code class="du le lf lg lh b">EIP</code>寄存器以指向我们的外壳代码。使用<a class="ae iu" href="https://visualgdb.com/gdbreference/commands/x" rel="noopener ugc nofollow" target="_blank">命令</a> <code class="du le lf lg lh b">(gdb) x/200wx $esp-550</code>我们能够读取堆栈基址附近200字节的虚拟内存地址。我们将把外壳代码上传到溢出堆栈<em class="kw">中的某个地方(它不必是一个精确的值，只要在堆栈</em>中的某个地方)，并使用<strong class="jv hj"> <em class="kw">返回地址指向外壳代码的开始。</em>T25】</strong></li></ul><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/0320814ba1993c17e9e6e96153cc83d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*d30hRIzLM4xiBun5rMgTkw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4.4 —可能的返回地址位置</figcaption></figure><ul class=""><li id="1e03" class="lk ll hi jv b jw kr ka ks ke lm ki ln km lo kq lp lq lr ls bi translated"><strong class="jv hj"> NOP Slide: </strong>有效载荷需要512字节长(图4.3)。我们有外壳代码(43字节)和返回地址(40字节<em class="kw">，返回地址是40字节的原因是为了创建一种缓冲空间，以确保它有更大的成功机会落在我们正确的返回地址上，即使有些东西在内存中稍微移动)。</em>经过快速计算(512–40–43 = 429 ),我们知道我们需要用<code class="du le lf lg lh b">NOP </code>命令填充剩余的429字节缓冲数据。</li></ul><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/14525fbfee3e3fe4e8ceae0b52c66337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*V3ISjgbW_K_sPat24d0KkA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4.5 —恶意负载</figcaption></figure><h2 id="66f8" class="lu iw hi bd ix lv lw lx jb ly lz ma jf ke mb mc jj ki md me jn km mf mg jr mh bi translated">执行代码</h2><p id="ad82" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">一旦创建了python脚本，我们就像任何典型用户一样运行ELF二进制文件，除了我们的缓冲区输入是<code class="du le lf lg lh b">NOPs</code>、<code class="du le lf lg lh b">Shellcode</code>和<code class="du le lf lg lh b">Return addresses</code>的组合。执行之后，您应该有一个打开的外壳/终端，并准备使用！</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/17899157cd300086577476ad2b95ac1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*0QT9GSXags6nSnuPtCcu3Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4.6 —成功的PWN</figcaption></figure><h1 id="bd3a" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">动词 （verb的缩写）高级利用</h1><p id="9c96" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">虽然这是一个有启发性和指导性的练习，但事实是，如果不至少部分解除操作系统和/或编译器中的对策，这种攻击是不可能的。<strong class="jv hj">不可执行堆栈功能(DEP) </strong>是一种基于硬件的安全功能，可防止恶意代码执行。StackGuard 特性实现了一个堆栈金丝雀，如果被这个简单的溢出攻击覆盖，它也会停止执行。由于相对较小的可用地址空间，地址空间布局随机化在32位机器中可以被强力击败。64位机器实际上对蛮力vs<strong class="jv hj">ASLR</strong>是无敌的，但是技术上仍然不能免疫。</p><h1 id="d854" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">不及物动词结论</h1><p id="b1f9" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">堆栈溢出漏洞已经存在很长时间了，它们仍然是一个现存的和可行的威胁载体。尽管操作系统和编译器工程已经发展了三十多年，但这些漏洞并没有被完全消除。这就引出了一个问题，<strong class="jv hj">缓冲区溢出能够完全从软件中“设计出来”吗？</strong></p><p id="622e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">开放Web应用程序安全项目(OWASP)是一个致力于提高软件安全性的非营利组织，它提供了与该主题相关的教育内容。其关于缓冲区溢出的在线白皮书指出:</p><p id="f5f8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><em class="kw">“这个问题一部分是由于缓冲区溢出可能以各种各样的方式发生，另一部分是由于经常用来防止缓冲区溢出的容易出错的技术。”</em></p><p id="ff7c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">该论文还指出，一些语言，如C、C++、Fortran和汇编，比其他语言更容易发生溢出</strong>。解释语言要安全得多，如果不是完全不受这种技术的影响的话。所有的操作系统在某种程度上都存在漏洞。[5]</p><p id="aea6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">看起来，最好的防御是一个精心计划的、警惕的“深度防御”，<strong class="jv hj">解决软件设计</strong>并在所有阶段构建最佳实践，以及<strong class="jv hj">维护最新的操作系统补丁</strong>以解决当前发现的漏洞。</p></div><div class="ab cl mr ms gp mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hb hc hd he hf"><p id="77e8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><em class="kw">最后提示:没有我的同事史蒂文·格里芬和韦斯·贝利令人难以置信的合作，这篇文章是不可能完成的。</em></p><p id="887e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><em class="kw">敬请关注……我们将很快尝试进行一次没有安全措施的现代堆栈溢出利用。</em></p><h1 id="6191" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">七。参考</h1><p id="666a" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">[1]詹姆斯·安德森。1972.计算机安全技术规划研究。总部电子系统部(AFSC)指挥及管理系统代表。</p><p id="02fa" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://csrc.nist.gov/csrc/media/publications/conference-paper/1998/10/08/proceedings-of-the-21st-nissc-1998/documents/early-cs-papers/ande72a.pdf" rel="noopener ugc nofollow" target="_blank">https://CSRC . NIST . gov/CSRC/media/publications/conference-paper/1998/10/08/proceedings-of-the-21-nissc-1998/documents/early-cs-papers/and e72a . pdf</a></p><p id="0f2c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">[2]维基百科贡献者。罗伯特·塔潘·莫里斯。维基百科，免费的百科全书。2020年9月21日，【https://en.wikipedia.org/w/index.php? T4】title = Robert _ Tappan _ Morris&amp;oldid = 979630920。2020年10月21日接入。</p><p id="9049" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">[3] Aleph One。砸栈取乐牟利。Underground.org。v7，第49期。一九九六年十一月。<a class="ae iu" href="https://seclists.org/bugtraq/1996/Nov/17" rel="noopener ugc nofollow" target="_blank">https://seclists.org/bugtraq/1996/Nov/17</a></p><p id="3a2f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">[4]哈龙·米尔。内存损坏攻击(几乎)完整的历史。<em class="kw"> BlackHat 2010 </em></p><p id="75f2" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><a class="ae iu" href="https://thinkst.com/resources/papers/BlackHat-USA-2010-Meer-History-of-Memory-Corruption-Attacks-wp.pdf" rel="noopener ugc nofollow" target="_blank">https://thinkst . com/resources/papers/black hat-USA-2010-Meer-History-of-Memory-Corruption-Attacks-WP . pdf</a></p><p id="5cab" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">[5]缓冲区溢出。OWASP网站。2020年4月。<a class="ae iu" href="https://owasp.org/www-community/vulnerabilities/Buffer_Overflow#" rel="noopener ugc nofollow" target="_blank">https://owasp . org/www-community/vulnerabilities/Buffer _ Overflow #</a></p></div></div>    
</body>
</html>