<html>
<head>
<title>What is Covariance and Contravariance in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是C#中的协变和逆变</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-is-covariance-and-contravariance-in-c-e3e5995fc599?source=collection_archive---------2-----------------------#2021-07-12">https://medium.com/codex/what-is-covariance-and-contravariance-in-c-e3e5995fc599?source=collection_archive---------2-----------------------#2021-07-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8cbac814b20c4357f696249706f137e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*as0QHNjbsCgcp2FB3wz_xw.png"/></div></div></figure><p id="624f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当C # 4.0版发布时，在该语言已经广泛的工具中引入了两个新的功能来解决各种问题。是的，我们正在谈论流行的协变和逆变特性。</p><p id="9a94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章将定义并演示这两个方便的特性如何让开发者解决以前需要变通的挑战。</p><p id="78ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简而言之，共变和反变指的是如何处理对象。术语“方差”指的是作用于指定类型的运算符的属性，以及运算符的排序。与它的操作数相比，co前缀意味着“连同”，并表示运算符保留了类型的顺序。当与它的操作数比较时，contra前缀意味着“反对”某事，并指示运算符颠倒类型的顺序。</p><p id="6103" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于这一点，让我们详细了解一下什么是C#中的协方差和逆变。</p><p id="2ab2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录</strong></p><ol class=""><li id="c6aa" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">C#中的协方差是什么？</li><li id="9482" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">C#中的逆变是什么？</li><li id="913b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">数组协方差</li><li id="fc6b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">结论</li></ol><h1 id="834a" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">C#中的协方差是什么？</h1><p id="e161" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">让我们从协方差的简单定义开始。假设每种动物都有名字，我们可以构造一个函数，输出集合中所有动物的名字:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/20d7390dad84e739581acad788769917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/0*50J16VemVyD4O7Jr"/></div></figure><p id="44f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">值得注意的是，IEnumerable只能用于从集合中读取动物值(通过IEnumerator的当前属性)。我们无法将动物添加到收藏中，因为它是只读的。</p><p id="1134" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在试着回答一个重要的问题——有没有可能用PrintAnimals来打印一批猫的名字？</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/a8b24a17a53a13bdc5af09146caae9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yeC50c8t8JU_e9cV"/></div></div></figure><p id="e5f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您编译并运行这个示例，您会注意到C#编译器能够识别它，并且应用程序运行良好。编译器在调用PrintAnimals时通过使用协方差将IEnumerable转换为IEnumerable。这是因为out注释指定IEnumerable接口是协变的。</p><p id="b3fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行应用程序时，PrintAnimals方法不会出错，因为它只能做一件事:打印。由于PrintAnimals方法只能从集合中读取动物，因此在运行程序时不会产生任何问题。所以用猫的集合来说明一个观点是没问题的，因为所有的猫都是动物。</p><h1 id="c892" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">C#中的逆变是什么？</h1><p id="cafc" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">逆变正好是协方差的反义词。假设我们有一个创建一些猫的方法，并将它们与我们提供的IComparer对象进行比较。在一个更实际的场景中，该方法可以对猫进行如下分类:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/0eb5d77cc2f063e8c3c58494a986f661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/0*7S8Y1Z2dko3IMHOg"/></div></figure><p id="befa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">猫作为参数传递给比较器对象，但它从不返回猫作为结果。这主要是因为它使用泛型类型参数的方式——你可以说它是只写的。现在，由于contravariance，我们可以制作一个比较动物的比较器，并将其作为参数传递给CompareCats:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/e9a3eaa5867be7132f00d48099a0ea76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Iq2k9LMHcSkNwGVm"/></div></div></figure><p id="a6ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为IComparer接口是逆变接口，并且泛型类型参数是用in注释指示的，所以编译器接受此代码。我们构造了一个可以比较动物的compareAnimals对象。这意味着它绝对可以比较两只猫。</p><h1 id="e663" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">阵列协方差</h1><p id="eb7e" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">看看下面的方法:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/cc7c207915de41766a7cb1928d82ee24.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/0*VkVaHnARMoLE63h7"/></div></figure><p id="47cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它将Person对象的数组作为输入，并将所有对象的名称输出到控制台。但是如果我们传递一个老师或学生的数组而不是一个人的数组，如下所示-</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/e6e0b14f9cca15380fea056cd287aa87.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/0*JjmsPtW3yT3M3Xtm"/></div></figure><p id="1d78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这段代码可以编译、运行，并且完全符合逻辑。因为学生和老师都有名字。提供学生[]或教师[]而不是人员[]使我们的方法比提供人员[]的精确类型匹配更有用。</p><p id="dc10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住这个例子，你可能会得出这样的结论:我们应该能够把一个带有通用参数老师或学生的对象发送到任何我们认为是通用类型的人的地方。这不是真的。考虑以下场景:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/8a7bb19ffa9bf7ea9de114568144b278.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/0*81yueaMJNxPL2nmA"/></div></figure><p id="00de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们这样称呼这个方法-</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/d30a311853815366da611aa14c33c60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/0*3t2BeKrNrT54m7-J"/></div></figure><p id="5f72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这段代码可以编译；然而，在运行时会抛出一个异常。我们可以简化这个例子来不同地解释这个问题:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/86429c8967a62ac707b447464b9f38bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/0*3Z83gbvUQIVfOWQx"/></div></figure><p id="b939" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">密切注意作业。Student[]是原始数组的类型。但是，因为我们可以用Student[]替换Person[]，所以我们在第6行收到了对Person对象数组的引用。</p><p id="191d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编译器允许执行第7行，因为每个老师都是一个人。然而，这就是运行时出现问题的地方:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/21525dbd19ded4f149314f2b3b6d1b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qMfL3xqcInLQD0i7"/></div></div></figure><p id="6390" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，这是我们所期望的。如果这段代码有效，第8行的赋值语句会做什么？我们会尝试让学生和老师配对。这至少是荒谬的，因为这两个类别是不相容的。</p><p id="d439" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果在预期的是一个人的数组时，您可以传递一个学生或教师的数组，则数组是协变的。当语言不支持泛型类型时，这从一开始就是一个深思熟虑的决定。尽管可能会有一些潜在的灾难性后果，正如我们所看到的，这种行为在实现通用算法(如PrintNames方法)时提供了很大的灵活性。</p><h1 id="6da9" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="27f7" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">协变和逆变被添加到C#语言中，以便多态特性可以被添加到数组、委托类型和泛型类型中。您可以使用比最初用contravariance指定的派生程度更低的类型，也可以使用派生程度更高的协方差类型。根据您正在处理的数据类型，您可以使用协方差或逆变。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="c4fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ma">原载于</em><a class="ae mb" href="https://www.partech.nl/nl/publicaties/2021/07/what-is-covariance-and-contravariance-in-c-sharp" rel="noopener ugc nofollow" target="_blank"><em class="ma">https://www . partech . nl</em></a><em class="ma">。</em></p></div></div>    
</body>
</html>