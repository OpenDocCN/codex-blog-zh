<html>
<head>
<title>Generic Repository &amp; Unit Of Work Patterns in .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通用存储库和工作单元模式。网</h1>
<blockquote>原文：<a href="https://medium.com/codex/generic-repository-unit-of-work-patterns-in-net-b830b7fb5668?source=collection_archive---------0-----------------------#2021-05-15">https://medium.com/codex/generic-repository-unit-of-work-patterns-in-net-b830b7fb5668?source=collection_archive---------0-----------------------#2021-05-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b745" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">实现通用知识库和工作单元模式的实用指南。NET Core C#应用程序</h2></div><h2 id="91f7" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">关于存储库和工作单元模式</h2><p id="8a0c" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">正如我所猜想的，几乎每个现代数据库应用程序都在实现存储库模式——尤其是在许多web API在线课程中。这种方法的目的是抽象持久性(在我们的例子中是EF核心)层，并使用这些实现来查询数据库。我们正在讨论的另一种模式是工作单元，它为我们的存储库执行“包装”功能，并向数据库提交更改。在本文中，我想一起实现这两种模式。</p><h2 id="a8cd" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">先决条件</h2><ul class=""><li id="4846" class="ko kp hi jx b jy jz kb kc ji kq jm kr jq ks kn kt ku kv kw bi translated">已创建。NET C#项目在你最喜欢的IDEs，VS代码，Rider等)中。)</li><li id="20cd" class="ko kp hi jx b jy kx kb ky ji kz jm la jq lb kn kt ku kv kw bi translated">关于实体框架ORM的一点知识(将来要使用的DataContext类是EF DbContext的临时实现，包含所有的数据库集和实体配置)</li></ul><h2 id="7802" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">让我们以一种通用的方式实现存储库模式</h2><p id="ea10" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">Repository是一个为指定的实体对象(表)执行数据库操作的类。它们中的大多数都足够简单，可以通用地实现，并且引用DRY原则(不要重复自己)对于编写多次通过主键查找实体的方法来说是多余的。</p><p id="06f4" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">为了简化这一点，我们将以一种通用的方式对我们的存储库进行编码，并具有扩展它的能力！</p><p id="37f9" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">现在，首先我们将在C#项目中创建两个文件:</p><ul class=""><li id="2ca2" class="ko kp hi jx b jy lc kb ld ji lh jm li jq lj kn kt ku kv kw bi translated">IRepository &lt; T &gt;  —我们存储库的通用接口。正如我们所看到的，当前的抽象是异步实现的，因为我们希望我们的数据库查询以这种方式工作。这样的操作会阻塞一些线程，我们不喜欢这样。</li></ul><figure class="ll lm ln lo fd lp er es paragraph-image"><div class="er es lk"><img src="../Images/4ed3b903a39d7b52b74995e1712d5f29.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*A31f0xW52E-5t44W3-EgIQ.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">通用存储库接口</figcaption></figure><ul class=""><li id="d5ef" class="ko kp hi jx b jy lc kb ld ji lh jm li jq lj kn kt ku kv kw bi translated"><strong class="jx hj">储存库&lt;T&gt;T3】—这里我们创建一个实现我们接口的类。现在，我们需要比前一个文件中更多的代码。长话短说，这个类的构造函数注入了DataContext对象，我们在所有方法中使用它来执行CRUD数据库操作。<br/>法境。Set &lt; T &gt;()通过泛型T类型在DataContext类中查找对应的DbSet(table)——这意味着如果repository是通知实体的类型，那么将在我们的数据库中查询通知表。</strong></li></ul><figure class="ll lm ln lo fd lp er es paragraph-image"><div class="er es lw"><img src="../Images/cc1a89aa54c54438dc638921146992a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*ng_R51hKWV84GjdleFDnsw.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">通用存储库类</figcaption></figure><p id="af81" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">现在我描述我们知识库中的每一个方法:</p><ul class=""><li id="aa72" class="ko kp hi jx b jy lc kb ld ji lh jm li jq lj kn kt ku kv kw bi translated"><strong class="jx hj"> Get(字符串id) — </strong>通过主键查找实体</li><li id="546c" class="ko kp hi jx b jy kx kb ky ji kz jm la jq lb kn kt ku kv kw bi translated"><strong class="jx hj">Find(Expression&lt;Func&lt;T，bool&gt;T20】谓词)— </strong>使用谓词查找实体。这个方法的声明可能很复杂，但是用法非常简单——我们使用它的方式和FirstOrDefault LINQ方法完全一样</li><li id="6abd" class="ko kp hi jx b jy kx kb ky ji kz jm la jq lb kn kt ku kv kw bi translated"><strong class="jx hj"> GetAll() — </strong>从指定的表中获取所有实体</li><li id="5366" class="ko kp hi jx b jy kx kb ky ji kz jm la jq lb kn kt ku kv kw bi translated"><strong class="jx hj">get Where(Expression&lt;Func&lt;T，bool&gt;T18】predicate)—</strong>使用谓词从指定的表中获取实体(与Where LINQ方法完全相同)</li><li id="0eb9" class="ko kp hi jx b jy kx kb ky ji kz jm la jq lb kn kt ku kv kw bi translated">所有剩余的方法从数据库中添加、更新或删除实体。他们还能够对一系列实体执行这些操作。<br/> <strong class="jx hj">很重要的一点是，只有当我们的UnitOfWork类调用Complete()方法时，操作才会提交给数据库！</strong></li></ul><h2 id="182d" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">好吧，那么工作单元模式呢？</h2><p id="33e7" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">正如我上面所说的，这种模式是我们的存储库的一种包装器。我们的业务逻辑类将注入IUnitOfWork，它提供对应用程序中所有已注册存储库的访问。对此的抽象非常简单:</p><figure class="ll lm ln lo fd lp er es paragraph-image"><div class="er es lx"><img src="../Images/d57f29bcd3ce33f21d2962d6d62d583e.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*_E8GZRVFuwdP0uU0dxllqA.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">工作单元接口</figcaption></figure><p id="459d" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">UnitOfWork应该通过其构造函数注入DataContext对象，然后将该对象传递给在该类中注册的所有存储库。</p><p id="376a" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">所有的存储库都以相同的方式实现——私有字段和只读属性返回其合适的现有存储库，或者如果字段没有初始化(？？运算符)—实例化新的运算符。</p><p id="781c" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">在repositories区域下，我们可以看到<strong class="jx hj"> Complete() </strong>方法实现— <strong class="jx hj">它负责提交对数据库</strong>的更改。如果进行了任何更改，它将返回true。</p><p id="9b24" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">要编写的最后一个方法是Dispose()，它简单地处理我们的上下文字段。</p><figure class="ll lm ln lo fd lp er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es ly"><img src="../Images/36ff164b20b3a8a63d864a53f6a9e63b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlpgSZfoQjAUrIFDlgnIZA.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">工作类单位</figcaption></figure><h2 id="7294" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">如果我需要比通用存储库类中实现的更复杂的查询怎么办？</h2><p id="a150" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">答案很明显——我们必须提供一个定制的存储库类。我想展示一下这个类是如何实现的，以及它是一种多么灵活的方法。</p><p id="b6c8" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">我们要做的第一件事是创建新的自定义接口，该接口实现了我们的通用IRepository抽象，但我们只是使用指定的实体对象(在本例中是通知类)而不是T参数。</p><figure class="ll lm ln lo fd lp er es paragraph-image"><div class="er es md"><img src="../Images/1df76e817a8f402dee13bd022ef79c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*V8rE8fweoKxn9EQTbQMPrg.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">自定义INotificationRepository接口</figcaption></figure><p id="e882" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">NotificationRepository类应该从泛型Repository类继承并实现其自定义接口。</p><figure class="ll lm ln lo fd lp er es paragraph-image"><div class="er es me"><img src="../Images/d1b05f6cb08a929632437f5e2c62fb60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*FOMkkqItZWYI8azcPnqPwg.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">自定义通知存储库类</figcaption></figure><p id="0e16" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">现在，使用这个自定义存储库实现，您可以调用通知表的所有通用方法，以及另外两个指定的方法:GetOrderedNotifications和CountUnreadNotifications。</p><p id="a638" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">为了在我们的UnitOfWork类中注册这个存储库，我们不使用IRepository <notification>和Repository <notification>而是键入:INotificationRepository和NotificationRepository。</notification></notification></p><figure class="ll lm ln lo fd lp er es paragraph-image"><div class="er es mf"><img src="../Images/8a3cd602b1e4fc360fc413eba3b881e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*1ihPedTVdQWK2cBCDtuk0g.png"/></div></figure><figure class="ll lm ln lo fd lp er es paragraph-image"><div class="er es mg"><img src="../Images/c45bb26d6d4d6d899111b24420689b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*lKxFytg87gflqWNixp1DFA.png"/></div></figure><h2 id="9a4b" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">在应用程序中注入函数</h2><p id="a9db" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">首先，我们需要将IUnitOfWork和IRepository <t>注册到我们的依赖注入容器——我为ASP NET核心应用程序使用默认的DI Microsoft容器。</t></p><p id="0ce5" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">在Startup.cs类中:</p><figure class="ll lm ln lo fd lp er es paragraph-image"><div class="er es mh"><img src="../Images/b2bd060274c69659caf793a2d609a270.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*IBx2Xzee9T_CCgakC4Fm5Q.png"/></div></figure><p id="7835" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">现在，我们可以在任何我们想去的地方注射IUnitOfWork。😎</p><p id="13b9" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated"><strong class="jx hj">向服务注入IUnitOfWork并查询数据库的示例:</strong></p><figure class="ll lm ln lo fd lp er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mi"><img src="../Images/9b35273f419e86b0cf2ca1bf4ac0da34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xre6PupNjCzHixDH_zqDqQ.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">使用IUnitOfWork的通知程序类的示例</figcaption></figure><p id="8f79" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">第一个通知方法是GetNotifications()，它对我们在NotificationRepository类中实现的数据库执行查询。</p><p id="1edd" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">另一个是Push()方法，它创建通知实体实例，将其本地添加到通知表，然后提交到数据库。<br/>如果Complete()成功—新通知将保存在我们的数据库中。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><h1 id="7ad1" class="mq iy hi bd iz mr ms mt jd mu mv mw jh io mx ip jl ir my is jp iu mz iv jt na bi translated">完成！</h1><p id="78c2" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">好了，我们完成了我们的工作！我认为这种方法非常灵活可靠。如果需要，我们能够扩展我们的通用存储库，但是如果它提供的功能对我们来说足够了，我们也可以使用基本存储库。😀</p><p id="04a3" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">此外，我们不需要注入我们在业务逻辑服务中使用的所有存储库，因为IUnitOfWork让我们可以访问所有存储库！不方便吗？😎</p><p id="27d8" class="pw-post-body-paragraph jv jw hi jx b jy lc ij ka kb ld im kd ji le kf kg jm lf ki kj jq lg kl km kn hb bi translated">感谢您的阅读，祝您愉快，让代码与您同在！💻 ⌨️ 🖥</p></div></div>    
</body>
</html>