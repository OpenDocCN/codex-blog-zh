<html>
<head>
<title>Server-side Caching in Web Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web应用程序中的服务器端缓存</h1>
<blockquote>原文：<a href="https://medium.com/codex/server-side-caching-in-web-applications-a9145be1cfa0?source=collection_archive---------3-----------------------#2021-06-03">https://medium.com/codex/server-side-caching-in-web-applications-a9145be1cfa0?source=collection_archive---------3-----------------------#2021-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/185781086273299b707f1e6ac11db149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1dt_vi3Zcq6glZDl_hptHw.png"/></div></div></figure><p id="af3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated">性能优化是web应用程序开发中一个主要的突出主题。众所周知，组件之间传输的每一秒每一位都非常重要。增强服务器中一个非常小的步骤或过程可能会大大减少整体响应时间。大多数时候，web服务器需要与第三方API、数据库或其他外部服务进行通信。服务器和其他组件之间的每一次通信都要花费时间和金钱。当应用程序使用量增长时，这一成本将是一个相当巨大的数额。现金交易是降低网络服务器成本的主要技术之一。</p><h1 id="19ad" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">什么是缓存？</strong></h1><p id="f3fd" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">缓存的概念是将常用/频繁使用的数据保存在内存中(服务器内部或附近)，并在请求相同类型的操作或数据时代表实际数据源使用它们。</p><p id="6c29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们举一个简单的例子，假设我们有一个简单的服务器和数据库，可以根据请求检索数据。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/ea319b09df27f5fcff28455f64f65501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*W_H_FqbJ8kdFi--3X1MH3A.png"/></div></div></figure><p id="0e69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果每个用户的用户角色都存储在数据库中。对于基于角色的身份验证机制，每个请求都需要从数据库中获取用户角色(还有其他一些机制)。在这种情况下，我们可以使用缓存将数据临时存储在缓存中，而无需频繁地从数据库中查询用户角色。它有助于减少对数据库的一次又一次的相同网络调用的发生。</p><p id="b515" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们假设有一个函数在使用时需要更多的计算能力(例如:找到许多具有管理员权限的用户)，我们可以将这种函数的结果存储在缓存中以避免重新计算。</p><p id="49ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，如果有多个服务器试图同时访问数据库，我们可以通过使用缓存来减少数据库负载。</p><p id="c299" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果是，为什么我们不能将整个数据库上下文存储在缓存中😁</p><p id="a519" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于缓存，它需要使用固态硬盘(SSD)作为内存。当数据库增长时，如果我们使用缓存来存储所有数据，成本将呈指数级增长。此外，如果缓存中的数据量增加，缓存中的搜索时间也会增加。因此，可以根据应用程序上下文来增加缓存，这是一个阈值限制。</p><h1 id="d7c8" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">缓存访问模式</strong></h1><p id="363a" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">有几种模式可用于在整个应用程序操作中获取现金。</p><ul class=""><li id="7f2b" class="lf lg hi is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated"><strong class="is hj">直写- </strong>如果新的写命令到达服务器，它将通过缓存同时更新数据库和缓存。如果其中一个失败，进程将回滚。</li><li id="b8ee" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj"> Write around- </strong>如果新的写命令到达服务器，它将直接在数据库上写并返回确认，而不更新缓存。当第一次“未命中”发生时，缓存将被更新。</li><li id="5151" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">写回- </strong>如果新的写命令到达服务器，它将只更新缓存并发回确认。它有另一个将缓存更新写入数据库的服务。这种技术的主要缺点是，如果数据库写错误发生，而后台服务运行来更新数据库用户不会承认这一点。</li></ul><h1 id="5a88" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">缓存放置方法</strong></h1><ul class=""><li id="67b1" class="lf lg hi is b it kv ix kw jb lt jf lu jj lv jn lk ll lm ln bi translated"><strong class="is hj">内存缓存(本地缓存)- </strong>使用服务器中RAM的一部分作为缓存。在这种情况下，RAM需要额外的空间用于缓存。然而，这种方法只对小规模应用有用。随着应用程序的增长和服务器数量的增加，这种方法将不再有用。</li><li id="c8c6" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">全局缓存- </strong>使用连接到服务器的外部实例作为缓存。当服务器实例的数量增加时，这些类型的全局缓存仍然可以促进数据一致性。高速缓存的大小可以独立于服务器而增加。当谈到分布式兑现方法时，全球缓存广泛涉及。</li></ul><h1 id="2cd7" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">缓存替换策略</strong></h1><p id="1a7a" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">在现代缓存库中，有许多缓存替换策略可用。但问题是，这种缓存替换策略直接影响了应用程序的性能。选择正确的缓存替换策略非常重要。让我们讨论一些常见的缓存替换策略。</p><ul class=""><li id="0ea1" class="lf lg hi is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated"><strong class="is hj">最近最少使用(LRU) </strong> -当缓存引用新的或现有的条目时，它保持在列表的顶部，并跟踪缓存中最近使用的条目。向缓存注册新条目时，它会丢弃最近最少使用的条目，并将新条目附加到列表的顶部。</li><li id="e779" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">最近使用的(MRU) </strong> -这有点类似于LRU，但是它跟踪最近使用最少的条目。当一个新条目进入缓存时，它会从缓存中丢弃最近使用的条目，并向缓存中注册一个新条目。</li><li id="4a61" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated"><strong class="is hj">最不常用(LFU) </strong> -根据该策略，它考虑每个条目在缓存中的频率。当一个新条目注册到高速缓存中时，它从高速缓存中搜索最少使用的条目，并丢弃它以保存新条目。</li></ul><p id="7855" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了这些策略之外，还有一些更常用的缓存替换策略可以用于不同的场景。</p><p id="9563" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">设计带缓存的系统之前需要关注的事情</strong></p><p id="a0fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用缓存主要是因为在时间和金钱方面降低了成本。主要提示是“缓存替换策略”,我们可以从缓存中获得真正的好处。不良的缓存替换策略会导致缓存的输出优化程度降低，有时还会使成本翻倍。</p><p id="41ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在选择缓存替换策略时，提高缓存的命中率应该是主要目标。如果我们选择一个糟糕的缓存替换策略，服务器必须处理对缓存的冗余调用，并且当它需要从原始源中找到缓存时也是如此。在这些情况下，成本将高于我们之前使用缓存的实际成本。</p><p id="2c7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，我们需要考虑用作缓存的内存大小。如果我们使用非常小的缓存，它将不得不更频繁地读取和写入条目，这将导致比我们预期更多的成本。就内存容量而言，我们必须保持中等规模的缓存内存。</p><p id="455a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">选择正确的缓存访问模式对于维护收银系统中的数据一致性也非常重要。缓存访问模式取决于您的应用程序类型和域。没有完美的访问模式。所以系统设计者需要根据应用环境选择最佳模式。</p><h1 id="1014" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">结论</strong></h1><p id="d24c" class="pw-post-body-paragraph iq ir hi is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hb bi translated">缓存是可用于web应用程序性能增强的主要技术之一。当我们在应用程序中使用缓存技术时，我们必须正确设计访问模式、我们需要使用的缓存大小以及缓存替换策略，以便从缓存中获得真正的好处。</p><h1 id="ea53" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated"><strong class="ak">参考文献</strong></h1><div class="lw lx ez fb ly lz"><a href="https://aws.amazon.com/caching/web-caching/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">Web缓存</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">缓存web内容有助于通过减少后端资源的负载来提高网站的响应能力…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">aws.amazon.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn io lz"/></div></div></a></div><div class="lw lx ez fb ly lz"><a href="https://aws.amazon.com/caching/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">什么是缓存及其工作原理| AWS</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">缓存是一个高速数据存储层，它存储数据的一个子集，通常是短暂的，以便将来…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">aws.amazon.com</p></div></div><div class="mi l"><div class="mo l mk ml mm mi mn io lz"/></div></div></a></div><div class="lw lx ez fb ly lz"><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">缓存替换策略-维基百科</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">在计算中，缓存算法(也经常被称为缓存替换算法或缓存替换策略)是…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">en.wikipedia.org</p></div></div><div class="mi l"><div class="mp l mk ml mm mi mn io lz"/></div></div></a></div><div class="lw lx ez fb ly lz"><a href="https://www.starwindsoftware.com/resource-library/server-side-caching/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">服务器端缓存-资源库</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">软件定义的存储(SDS)体系结构在正在虚拟化其…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">www.starwindsoftware.co</p></div></div><div class="mi l"><div class="mq l mk ml mm mi mn io lz"/></div></div></a></div></div></div>    
</body>
</html>