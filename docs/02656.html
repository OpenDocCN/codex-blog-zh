<html>
<head>
<title>Event-Driven Microservices using Spring Cloud Stream and Web Sockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spring Cloud Stream和Web Sockets的事件驱动微服务</h1>
<blockquote>原文：<a href="https://medium.com/codex/event-driven-microservices-using-spring-cloud-stream-and-web-sockets-ee7c8921aa4f?source=collection_archive---------5-----------------------#2021-07-30">https://medium.com/codex/event-driven-microservices-using-spring-cloud-stream-and-web-sockets-ee7c8921aa4f?source=collection_archive---------5-----------------------#2021-07-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b5d9" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第1部分:基本概念</h2></div><p id="7ee7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一名编程爱好者，我们都非常热衷于新技术，这些新技术似乎每天都层出不穷，其中一个热门话题是<strong class="iz hj"> <em class="jt">事件驱动的微服务</em> </strong>，它可以确保您的系统更加去耦，微服务更加独立。这听起来很酷，但是实现它并理解它是一件非常痛苦的事情。因此，我使用这个概念创建了一个简单的全栈应用程序，为您提供实时新闻，由于Spring和React JS提供了漂亮的库，我的工作变得轻松了。</p><p id="8782" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些是我将在这篇文章中谈论的主要内容:</p><ul class=""><li id="c7d6" class="ju jv hi iz b ja jb jd je jg jw jk jx jo jy js jz ka kb kc bi translated">微服务</li><li id="1f9b" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">事件驱动架构</li><li id="893c" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">队列和主题</li><li id="931b" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">码头基础知识</li><li id="a4dd" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">春云流</li><li id="64c5" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">使用STOMP(简单面向文本的消息协议)的Web套接字</li></ul><p id="7cf3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的主要目标是为微服务之间的通信建立一个事件驱动的架构，为此我将使用Spring Boot和React JS，我假设你对Spring Boot有很好的了解，对React JS有一点了解就足够了。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="19c3" class="kp kq hi bd kr ks kt ku kv kw kx ky kz io la ip lb ir lc is ld iu le iv lf lg bi translated">微服务</h1><p id="f60f" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">据<a class="ae lm" href="https://en.wikipedia.org/wiki/Microservices" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="ln lo lp"><p id="6c1a" class="ix iy jt iz b ja jb ij jc jd je im jf lq jh ji jj lr jl jm jn ls jp jq jr js hb bi translated">微服务不是单一应用程序中的一层(例如，web控制器或后端对前端)。相反，它是一个独立的业务功能，具有清晰的接口，并且可以通过自己的内部组件实现分层架构。从战略角度来看，微服务架构本质上遵循“做一件事并把它做好”的Unix哲学。</p></blockquote><p id="ad04" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">微服务的主要优势是:</p><ul class=""><li id="747c" class="ju jv hi iz b ja jb jd je jg jw jk jx jo jy js jz ka kb kc bi translated">微服务是高度可维护的</li><li id="e067" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">很容易被测试</li><li id="8e65" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">微服务是松散耦合的，因为它们是独立的服务，致力于执行单个明确定义的任务，并且每个微服务都可以独立部署。</li></ul><p id="3b23" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用微服务不仅可以确保复杂应用程序的交付在几次迭代中非常顺利和快速，还可以确保应用程序保持技术独立，从一个技术堆栈更改到另一个不会成为一场噩梦，这有助于应用程序始终保持最新。</p><h1 id="0010" class="kp kq hi bd kr ks lt ku kv kw lu ky kz io lv ip lb ir lw is ld iu lx iv lf lg bi translated">事件驱动架构</h1><p id="74a6" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">根据<a class="ae lm" href="https://en.wikipedia.org/wiki/Event-driven_architecture" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="ln lo lp"><p id="413e" class="ix iy jt iz b ja jb ij jc jd je im jf lq jh ji jj lr jl jm jn ls jp jq jr js hb bi translated">E <strong class="iz hj">事件驱动架构</strong> ( <strong class="iz hj"> EDA </strong>)是一种<a class="ae lm" href="https://en.wikipedia.org/wiki/Software_architecture" rel="noopener ugc nofollow" target="_blank">软件架构</a>范例，促进<a class="ae lm" href="https://en.wikipedia.org/wiki/Event_(computing)" rel="noopener ugc nofollow" target="_blank">事件</a>的产生、检测、消费和反应。</p></blockquote><p id="71fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简单来说，当我们谈论EDA时，我们可以想到这样一幅画面，其中我们有多个微服务需要相互通信，它们通过使用一种叫做<strong class="iz hj"> <em class="jt">事件</em> </strong>的东西来实现这一点。</p><p id="6bfb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在什么是<strong class="iz hj"> <em class="jt">事件</em> </strong>？</p><p id="9bb2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事件可以被定义为状态变化的指示器。因此，微服务根据它从另一个微服务接收到的变化进行操作。例如，当您单击一个按钮时，会执行一个操作，因此单击可以被视为一个事件。</p><p id="513f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据<a class="ae lm" href="https://www.redhat.com/en/topics/integration/what-is-event-driven-architecture" rel="noopener ugc nofollow" target="_blank"> RedHat </a>的说法，事件驱动架构的好处是:</p><blockquote class="ln lo lp"><p id="d88e" class="ix iy jt iz b ja jb ij jc jd je im jf lq jh ji jj lr jl jm jn ls jp jq jr js hb bi translated">事件驱动的架构可以帮助组织实现灵活的系统，能够适应变化并实时做出决策。实时态势感知意味着可以使用反映系统当前状态的所有可用数据来做出业务决策，无论是手动决策还是自动决策。</p></blockquote><p id="a6f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">在我完成下一个主题后，我会提供一个可视化的图表。</em></p><h1 id="bbe2" class="kp kq hi bd kr ks lt ku kv kw lu ky kz io lv ip lb ir lw is ld iu lx iv lf lg bi translated">队列和主题</h1><p id="c7c7" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">消息队列和主题基本上是我们可以放入一些消息和从中读取消息的组件。他们在特征上有一些根本的不同。</p><p id="9b6b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们想象一下:</p><figure class="lz ma mb mc fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es ly"><img src="../Images/f445c6059ec7bba26e38ab5ca8e628f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FznH7pU72e2isQW0VT2cVw.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated">放入队列的消息只能由单个消费者读取</figcaption></figure><p id="96ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在队列的情况下，当消息生产者将一些消息放入队列时，只有一个消费者可以读取该消息，并且消息队列中只能有一个订户。</p><figure class="lz ma mb mc fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mo"><img src="../Images/a802a735b84f2634b3806a8632bc17ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odW8RRDul3_E5CI5D86v_Q.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated">放入队列的消息只能由多个使用者读取</figcaption></figure><p id="e808" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一方面，生产者放在主题上的消息可以被几个消费者读取，因为多个消费者可以订阅单个主题。</p><h1 id="d5b5" class="kp kq hi bd kr ks lt ku kv kw lu ky kz io lv ip lb ir lw is ld iu lx iv lf lg bi translated">事件驱动的微服务的全貌</h1><p id="3570" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">现在，我们有了事件的概念，以及如何在事件驱动架构范例中使用它，还有队列和主题的基本概念。</p><p id="d7f7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们回想一下，在<strong class="iz hj"> <em class="jt">事件驱动的微服务</em> </strong>中，一个微服务产生一个事件，当被期望的微服务接收时，接收微服务执行一些操作，并可能进一步产生一个事件或不产生一个事件，这是事件驱动架构范例中交互的基本法则。</p><p id="f694" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们使用队列和主题来实现微服务之间的事件交换，由于微服务订阅了队列和主题，因此每当消息服务上出现事件时，微服务都会立即得到通知，并执行所需的活动，而无需任何外部调用。</p><p id="5bce" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，根据<a class="ae lm" href="https://www.redhat.com/en/topics/integration/what-is-event-driven-architecture" rel="noopener ugc nofollow" target="_blank"> RedHat </a>，EDA可能基于发布/订阅模型或事件流模型，但是在项目中我们遵循发布/订阅模型，让我们可视化EDA的发布/订阅模型(我们将要构建的<strong class="iz hj"> <em class="jt">印度新闻</em> </strong>应用程序):</p><figure class="lz ma mb mc fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mp"><img src="../Images/9bca629ab7e63d623d0ccd1c179fd535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWt9OxKrvt1tVWt7RZBtXA.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated">基于事件驱动架构的印度新闻应用</figcaption></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="701a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，现在我们将进一步深入应用程序的工作原理，这应该是讨论docker、spring cloud stream和web sockets基础知识的好时机。</p><h1 id="504b" class="kp kq hi bd kr ks lt ku kv kw lu ky kz io lv ip lb ir lw is ld iu lx iv lf lg bi translated">码头工人</h1><p id="2310" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">Docker可以被认为是你的app的操作系统的版本控制系统。使用Docker，您可以在笔记本电脑上运行您的应用程序，运行环境与应用程序将在生产中运行的服务器配置相同。</p><p id="9df9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于我本人对这种技术相当陌生，我将以初学者的理解来谈论，并记住这一点，我们可以简单地认为，当我们想要在安装了所有依赖项的隔离环境中部署应用程序或工具时，我们可以使用docker，而不必费心在本地环境中设置依赖项。</p><p id="2fca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，阿帕奇卡夫卡既是一个主题也是一个队列，更多细节请查看Abhishek Gupta 撰写的<a class="ae lm" href="https://abhishek1987.medium.com/kafka-is-it-a-topic-or-a-queue-30c85386afd6" rel="noopener"> <strong class="iz hj"> <em class="jt">这篇精彩文章</em> </strong> </a>。</p><p id="4b47" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">在我的例子中，由于我的应用程序需要运行Kafka主题，使用Docker有助于在隔离环境中运行服务器来托管Kafka主题，而无需在我的系统中设置任何配置。</em> </strong></p><p id="d786" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，我相信你能理解我为什么要在我的项目中使用docker。</p><p id="2d75" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在开始使用Docker之前，有必要了解一下Docker对象:</p><ul class=""><li id="9e91" class="ju jv hi iz b ja jb jd je jg jw jk jx jo jy js jz ka kb kc bi translated">容器图像</li><li id="3d21" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">容器</li></ul><h2 id="20dd" class="ms kq hi bd kr mt mu mv kv mw mx my kz jg mz na lb jk nb nc ld jo nd ne lf nf bi translated">容器图像</h2><p id="adeb" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">根据码头工人的<a class="ae lm" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><blockquote class="ln lo lp"><p id="d6af" class="ix iy jt iz b ja jb ij jc jd je im jf lq jh ji jj lr jl jm jn ls jp jq jr js hb bi translated">Docker容器映像是一个轻量级的、独立的、可执行的软件包，包括运行应用程序所需的一切:代码、运行时、系统工具、系统库和设置。</p></blockquote><p id="2787" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个<strong class="iz hj"> <em class="jt">容器映像</em> </strong>基本上是一个模板，它提供了软件、配置工具等的所有细节。并且可以执行该映像来开发隔离的文件系统。</p><h2 id="3d38" class="ms kq hi bd kr mt mu mv kv mw mx my kz jg mz na lb jk nb nc ld jo nd ne lf nf bi translated">容器</h2><p id="f5e0" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">根据码头工人的<a class="ae lm" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><blockquote class="ln lo lp"><p id="f0c7" class="ix iy jt iz b ja jb ij jc jd je im jf lq jh ji jj lr jl jm jn ls jp jq jr js hb bi translated">容器是一个标准的软件单元，它将代码及其所有依赖项打包，以便应用程序能够快速可靠地从一个计算环境运行到另一个计算环境。</p></blockquote><p id="4fdc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个<strong class="iz hj"> <em class="jt">容器</em> </strong>仅仅是你机器中的另一个进程，它与你机器中的所有其他进程相隔离。</p><p id="b6f2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可用于Linux和基于Windows的应用程序，容器化的软件将总是运行相同的，不管基础设施如何。容器将软件从它的环境中隔离出来，并确保它统一地工作，尽管存在差异，例如在开发和阶段之间。</p><h2 id="3f5c" class="ms kq hi bd kr mt mu mv kv mw mx my kz jg mz na lb jk nb nc ld jo nd ne lf nf bi translated">容器与容器意象的关系</h2><p id="2576" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">这些定义虽然很可靠，但很难理解，当你了解它们之间的关系时，理解它们就变得简单多了。</p><p id="8e6f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当运行一个<strong class="iz hj"> <em class="jt">容器</em> </strong>时，它使用一个隔离的文件系统。这个定制文件系统由一个<strong class="iz hj"> <em class="jt">容器镜像</em> </strong>提供。因为映像包含容器的文件系统，所以它必须包含运行应用程序所需的一切——所有的依赖项、配置、脚本、二进制文件等。该映像还包含容器的其他配置，如环境变量、要运行的默认命令和其他元数据。</p><p id="3dbe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我用以下三点来联系<strong class="iz hj"> <em class="jt">图像</em> </strong>和<strong class="iz hj"> <em class="jt">容器</em> </strong>:</p><ul class=""><li id="925e" class="ju jv hi iz b ja jb jd je jg jw jk jx jo jy js jz ka kb kc bi translated">一个<strong class="iz hj"> <em class="jt">图像</em> </strong>是一个只读模板，带有创建Docker <strong class="iz hj"> <em class="jt">容器的指令。</em> </strong></li><li id="bda0" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated">一个<strong class="iz hj"> <em class="jt">容器</em> </strong>是一个<strong class="iz hj"> <em class="jt">映像</em> </strong>的可运行实例。</li><li id="5abf" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated"><strong class="iz hj"> <em class="jt">图片</em> </strong>在运行时变成<strong class="iz hj"> <em class="jt">容器</em> </strong>而在Docker <strong class="iz hj"> <em class="jt">容器</em> </strong> — <strong class="iz hj"> <em class="jt">图片</em> </strong>在<a class="ae lm" href="https://www.docker.com/products/container-runtime" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj"> <em class="jt"> Docker引擎</em> </strong> </a> <strong class="iz hj">上运行时变成<strong class="iz hj"> <em class="jt">容器</em> </strong>T71】</strong></li></ul><p id="9578" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt">请注意:</em> </strong>术语<em class="jt">容器图像</em>和<em class="jt">图像</em>可以互换使用，但两者代表同一事物。</p><h2 id="1e51" class="ms kq hi bd kr mt mu mv kv mw mx my kz jg mz na lb jk nb nc ld jo nd ne lf nf bi translated">Docker撰写</h2><p id="a709" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">虽然我们可以构建容器并一次运行一个命令，但最简单的方法是使用<strong class="iz hj"> <em class="jt"> docker compose </em> </strong>就像这样，我们只需要创建一个YAML文件，然后用一个命令就可以创建整个环境并关闭它。</p><p id="8f41" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">优势在于您对环境的所有需求都记录在一个文件中，其他人也可以对此做出贡献。</p><p id="c11d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们已经了解了docker的基础知识，但由于这篇文章更侧重于解释事件驱动架构，我将不深究docker的设置，解释docker的YAML文件等。，当我在这篇文章的第二部分解释代码时，如果你不能理解这些概念，请在这篇文章中自由地评论你的想法和疑问。</p><h1 id="c088" class="kp kq hi bd kr ks lt ku kv kw lu ky kz io lv ip lb ir lw is ld iu lx iv lf lg bi translated">春云流</h1><p id="0825" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">根据<a class="ae lm" href="https://spring.io/projects/spring-cloud-stream" rel="noopener ugc nofollow" target="_blank">春季文件</a>:</p><blockquote class="ln lo lp"><p id="00dd" class="ix iy jt iz b ja jb ij jc jd je im jf lq jh ji jj lr jl jm jn ls jp jq jr js hb bi translated">Spring Cloud Stream是一个框架，用于构建与共享消息传递系统相连的高度可伸缩的事件驱动的微服务。</p><p id="4ba1" class="ix iy jt iz b ja jb ij jc jd je im jf lq jh ji jj lr jl jm jn ls jp jq jr js hb bi translated">该框架提供了一个灵活的编程模型，它建立在已经建立和熟悉的Spring习惯用法和最佳实践之上，包括对持久发布/订阅语义、消费者组和有状态分区的支持。</p></blockquote><p id="8586" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了简单了解《春云流》(SCSt)，Oleg Zhurakousky在他的<a class="ae lm" href="https://spring.io/blog/2019/10/14/spring-cloud-stream-demystified-and-simplified" rel="noopener ugc nofollow" target="_blank"> <em class="jt">博客</em> </a>中做了很好的总结:</p><blockquote class="ln lo lp"><p id="ab7a" class="ix iy jt iz b ja jb ij jc jd je im jf lq jh ji jj lr jl jm jn ls jp jq jr js hb bi translated">SCSt一直是关于纯粹的微服务，并将它们绑定到数据的<em class="hi">源</em>和<em class="hi">目标</em>(即消息传递系统)。就这么简单。</p><p id="c4cb" class="ix iy jt iz b ja jb ij jc jd je im jf lq jh ji jj lr jl jm jn ls jp jq jr js hb bi translated">如果您对SCSt的内部知识了解得足够深入，您会很快意识到它实际上是一个绑定和激活框架。它将一段代码(由用户提供)绑定到由绑定器公开的数据的源/目标，并根据绑定器实现(例如，消息到达等)激活这样的代码。差不多就是这样。</p></blockquote><p id="e958" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，SCSt基本上是spring提供的一个框架，它抽象出boiler plate代码来设置消息传递服务，这样用户就可以只关注业务逻辑，并将其放在队列/主题中，或者从队列/主题中读取，而无需编写太多代码来设置消息传递系统。因此，SCSt是一个灵活的消息传递抽象，它负责复杂的消息传递平台集成，因此您可以专注于编写简单清晰的业务逻辑。</p><p id="0241" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Spring Cloud Stream的核心构件是:</p><ul class=""><li id="5304" class="ju jv hi iz b ja jb jd je jg jw jk jx jo jy js jz ka kb kc bi translated"><strong class="iz hj"> <em class="jt">目的地绑定器</em> </strong>:负责提供与外部消息传递系统集成的组件。</li><li id="77bb" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated"><strong class="iz hj"> <em class="jt">目的地绑定</em> </strong>:外部消息传递系统和最终用户提供的应用程序代码(生产者/消费者)之间的桥梁。</li><li id="8a0f" class="ju jv hi iz b ja kd jd ke jg kf jk kg jo kh js jz ka kb kc bi translated"><strong class="iz hj"> <em class="jt">消息</em> </strong>:生产者和消费者用来与<em class="jt">目的绑定器</em>(以及其他通过外部消息传递系统的应用程序)通信的规范数据结构。</li></ul><p id="24d0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将在应用程序中使用<strong class="iz hj"><em class="jt">Apache Kafka Binder</em></strong>与队列进行交互。</p><h1 id="3888" class="kp kq hi bd kr ks lt ku kv kw lu ky kz io lv ip lb ir lw is ld iu lx iv lf lg bi translated">使用STOMP的Web套接字</h1><p id="8f74" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">spring提供的Web Sockets是Web浏览器和服务器之间的一种<strong class="iz hj"> <em class="jt">全双工、双向持久通信方案</em> </strong>。由web套接字建立的通信管道保持连接，直到客户端或服务器决定关闭连接。</p><p id="398f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">WebSocket是TCP之上的一个轻薄层，它适合使用<strong class="iz hj"> <em class="jt">子协议</em> </strong>来嵌入消息。我们将用来建立双向连接的子协议之一是<a class="ae lm" href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol" rel="noopener ugc nofollow" target="_blank"> STOMP </a>。</p><p id="0fca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据<a class="ae lm" href="https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/websocket.html#websocket-stomp-overview" rel="noopener ugc nofollow" target="_blank">春季文件</a>:</p><blockquote class="ln lo lp"><p id="ba90" class="ix iy jt iz b ja jb ij jc jd je im jf lq jh ji jj lr jl jm jn ls jp jq jr js hb bi translated"><a class="ae lm" href="https://stomp.github.io/stomp-specification-1.2.html#Abstract" rel="noopener ugc nofollow" target="_blank"> STOMP </a>是一个简单的面向文本的消息传递协议，最初是为Ruby、Python和Perl等脚本语言创建的，用于连接企业消息代理。它旨在解决常用消息传递模式的一个子集。STOMP可用于任何可靠的双向流网络协议，如TCP和WebSocket。虽然STOMP是面向文本的协议，但是消息的有效负载可以是文本或二进制的。</p></blockquote><p id="8498" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以从<a class="ae lm" href="https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/websocket.html#websocket-stomp-overview" rel="noopener ugc nofollow" target="_blank"> Spring文档</a>中了解更多关于WebSockets和STOMP的信息。</p><h1 id="1e14" class="kp kq hi bd kr ks lt ku kv kw lu ky kz io lv ip lb ir lw is ld iu lx iv lf lg bi translated">第1部分结束</h1><p id="c5d4" class="pw-post-body-paragraph ix iy hi iz b ja lh ij jc jd li im jf jg lj ji jj jk lk jm jn jo ll jq jr js hb bi translated">这一部分主要关注我将用来构建应用程序的基本概念，因为即使是简单的基础知识也有很多需要解释，所以我决定专门为此写一篇文章。如果您发现任何差异或您的想法，请随时评论。</p><p id="d207" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae lm" href="https://attyuttam.medium.com/event-driven-microservices-using-spring-cloud-stream-and-web-sockets-e93fe5fbe7d4" rel="noopener"> <strong class="iz hj"> <em class="jt">转到Part2。</em> </strong> </a></p></div></div>    
</body>
</html>