<html>
<head>
<title>What do you need to know about Golang’s Defer?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Golang的Defer，你需要了解什么？</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-do-you-need-to-know-about-golangs-defer-4fac71e0f00b?source=collection_archive---------2-----------------------#2021-08-08">https://medium.com/codex/what-do-you-need-to-know-about-golangs-defer-4fac71e0f00b?source=collection_archive---------2-----------------------#2021-08-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d25c1ba6e7fbd36beed7f969683d8d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DnnkReGamr7ps_2HlGT_FQ.png"/></div></div></figure><p id="1856" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Golang是一种函数式编程语言。它是一种强大而灵活的语言编程，为开发人员提供了从零开始设计程序架构的完整范围，并且具有很高的自由度。这种语言有其独特之处。因此，Golang有一些其他语言可能没有的独特功能。其中之一就是<strong class="is hj">延期函数</strong>。</p><h1 id="131d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是围棋延时？</h1><p id="c61a" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Go的defer是一个预定的函数调用，将在函数生命周期结束时运行。简单来说就是一个清理函数调用。您可以设置一个命名函数或构造一个匿名函数，如下面的<a class="ae kr" href="https://play.golang.org/p/nw2RTVO3H4B" rel="noopener ugc nofollow" target="_blank">示例</a>所示。对于清理任务来说，这是一个非常有用的功能，清理任务可能包括关闭连接、取消订阅事件、资源清理，甚至从死机中恢复。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="257b" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> main() {<br/>  <strong class="kx hj">defer</strong> foo()<br/>  <strong class="kx hj">defer</strong> func() {<br/>    fmt.Println("hello")<br/>  }()<br/>}</span><span id="4174" class="lb jp hi kx b fi lg ld l le lf"><strong class="kx hj">func</strong> foo() {<br/>    fmt.Println("foo")<br/>}</span></pre><p id="f0d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">延迟机制本身很简单，但如果使用得当，它会非常强大。当调用defer语句时，它将函数调用推入堆栈列表，并使用LIFO原则。因此，如果一个函数声明了多重延迟，最后一个被推的延迟将被首先调用，如下面的<a class="ae kr" href="https://play.golang.org/p/5BBRZyrz-p1" rel="noopener ugc nofollow" target="_blank">示例</a>所示。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="dc6d" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">for</strong> i := 0; i &lt; 5; i++ {<br/>    <strong class="kx hj">defer</strong> fmt.Printf("%d ", i)<br/>}</span></pre><p id="ec24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7643" class="lb jp hi kx b fi lc ld l le lf">4 3 2 1 0</span></pre><p id="ccc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于Go的defer机制还有很多其他的东西，比如关于defer的三个基本规则，与<a class="ae kr" href="https://golang.org/doc/effective_go#recover" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">recover</strong></a><strong class="is hj"/>和<a class="ae kr" href="https://golang.org/doc/effective_go#panic" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> panic </strong> </a>一起工作。更详细的golang机制可以在<a class="ae kr" href="https://blog.golang.org/defer-panic-and-recover" rel="noopener ugc nofollow" target="_blank"> golang博客</a>上找到。你也可以在Golang文档中阅读更多关于延期的信息</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="dd74" class="jo jp hi bd jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl bi translated">有用的提示</h1><p id="1810" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在本文中，我们将探索和讨论defer能做和不能做的许多事情，作为开发人员需要做或避免做的事情，defer的限制和功能。记住，这些案例大多是我亲身经历的。这里写的任何建议，纯属我的看法。因此，它可能无法直接回答你的问题，但我希望分享我在这些技巧上的研究和经验可能有助于更深入地理解延迟。</p><h1 id="e7f5" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">零函数</h1><p id="08cc" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">当你试图推迟一个可变函数。始终确保变量函数不为零。否则，它将在延迟执行时死机。你可以在Golang <a class="ae kr" href="https://play.golang.org/p/pmIGnjFhOpz" rel="noopener ugc nofollow" target="_blank">游乐场</a>玩耍。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ac7d" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">var</strong> cleanUp <strong class="kx hj">func</strong>()</span><span id="afc6" class="lb jp hi kx b fi lg ld l le lf"><strong class="kx hj">func</strong> main() {<br/>   <strong class="kx hj">defer</strong> cleanUp()<br/>   fmt.Println("hello")<br/>}</span></pre><p id="5651" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，这是一种不好的做法，不建议将函数用作变量。尽可能避免使用函数变量，考虑另一种方法，如私有函数。它不仅确保了非零功能场景，而且还增强了Golang中<a class="ae kr" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a>设计原则的良好实践。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="98e1" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> main() {<br/>   <strong class="kx hj">defer</strong> cleanUp()<br/>   fmt.Println("hello")<br/>}</span><span id="005c" class="lb jp hi kx b fi lg ld l le lf"><strong class="kx hj">func</strong> cleanUp() {<br/>   fmt.Println("foo")<br/>}</span></pre></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="9d6b" class="jo jp hi bd jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl bi translated">注意秩序</h1><p id="d52c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">正如在<a class="ae kr" href="https://blog.golang.org/defer-panic-and-recover" rel="noopener ugc nofollow" target="_blank">博客Golang </a>上所述，defer的基本规则之一如下:</p><blockquote class="lt"><p id="1be8" class="lu lv hi bd lw lx ly lz ma mb mc jn dx translated">在周围的函数返回后，延迟的函数调用按后进先出的顺序执行。</p></blockquote><p id="f09e" class="pw-post-body-paragraph iq ir hi is b it md iv iw ix me iz ja jb mf jd je jf mg jh ji jj mh jl jm jn hb bi translated">这条规则简单地说明了延迟函数只对LIFO顺序的函数返回执行。使用延迟功能时，请始终牢记这条规则。有几个与这条规则相关的常见错误，你可以记下来。</p><h2 id="cbc9" class="lb jp hi bd jq mi mj mk ju ml mm mn jy jb mo mp kc jf mq mr kg jj ms mt kk mu bi translated"><strong class="ak">小心使用for循环</strong></h2><p id="50a2" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在循环中使用defer函数时要小心，除非你知道自己在做什么。请记住，for循环不是一个函数，defer可能不会像您预期的那样工作，如下面的<a class="ae kr" href="https://play.golang.org/p/QGzh8QMQR2L" rel="noopener ugc nofollow" target="_blank">示例</a>所示。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a7ff" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> main() {<br/> <strong class="kx hj">for</strong> i := 0; i &lt; 3; i++ {<br/>   <strong class="kx hj">var</strong> num <strong class="kx hj">int</strong><br/>   <strong class="kx hj">defer</strong> <strong class="kx hj">func</strong>() {<br/>      fmt.Println("Defer", num)<br/>   }()<br/>   num = Double(i)<br/> }<br/>}</span><span id="1c9e" class="lb jp hi kx b fi lg ld l le lf"><strong class="kx hj">func</strong> Double(num <strong class="kx hj">int</strong>) <strong class="kx hj">int</strong> {<br/>  result := num * 2<br/>  fmt.Println("Inner", result)<br/>  <strong class="kx hj">return</strong> result<br/>}</span></pre><p id="c760" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5f7e" class="lb jp hi kx b fi lc ld l le lf">Inner 0<br/>Inner 2<br/>Inner 4<br/>Defer 4<br/>Defer 2<br/>Defer 0</span></pre><p id="7f74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，<strong class="is hj">延迟函数</strong> <strong class="is hj">直到主函数</strong>结束才被执行。这可能意味着对关键执行的严重后果，例如在循环内延迟关闭连接。此外，<strong class="is hj">由于LIFO堆栈原理，defer函数调用的顺序是颠倒的</strong>。</p><p id="37ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以用几种方法解决这个问题。</p><p id="ecc0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1.在循环内部创建一个函数，将每个循环的执行封装为一个整体。它确保每次循环都执行defer函数。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="523a" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">for</strong> i := 0; i &lt; 3; i++ {<br/>  <strong class="kx hj">func</strong>() {<br/>    <strong class="kx hj">var</strong> num <strong class="kx hj">int</strong><br/>    <strong class="kx hj">defer</strong> <strong class="kx hj">func</strong>() {<br/>      fmt.Println("Defer", num)<br/>    }()<br/>    num = Double(i)<br/>  }()<br/>}</span></pre><p id="fa68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.直接在现场调用就可以了，根本不用defer。这是最简单的解决方法。它可能不需要对defer做任何事情，但这可能是在Golang中使用for loop的最佳实践。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f9d2" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">for</strong> i := 0; i &lt; 3; i++ {<br/>  num := Double(i)<br/>  fmt.Println("Defer", num)<br/>}</span></pre><h2 id="81f9" class="lb jp hi bd jq mi mj mk ju ml mm mn jy jb mo mp kc jf mq mr kg jj ms mt kk mu bi translated"><strong class="ak">后进先出顺序可能比较棘手</strong></h2><p id="3929" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">虽然一旦理解了LIFO堆栈原理，延迟执行就很简单了。如果你随意放置它们，仍然可能会使代码的意义变得混乱。因此，<strong class="is hj">延迟函数通常写在需要清理的原始函数之后</strong>。下面是一个利用延迟函数的糟糕代码的例子。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="d87f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能会意识到这个例子的一些问题。</p><ul class=""><li id="fe45" class="mx my hi is b it iu ix iy jb mz jf na jj nb jn nc nd ne nf bi translated">首先，如果<code class="du ng nh ni kx b">db.Begin()</code>遇到一个会导致资源泄漏的错误，<code class="du ng nh ni kx b">db.Close()</code>不会执行。</li><li id="cf8c" class="mx my hi is b it nj ix nk jb nl jf nm jj nn jn nc nd ne nf bi translated">第二，这里的<code class="du ng nh ni kx b">err</code>变量到处都在使用，并且也覆盖了其他延迟函数，这可能会混淆下一个使用<code class="du ng nh ni kx b">err</code>变量进行验证的延迟函数。</li></ul><p id="782f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个使用延迟函数的良好实践代码示例。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="a35e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为一名开发人员，您可能会立即意识到哪些代码更容易阅读并且有意义。这对你来说似乎微不足道，但它将帮助很多人，减少人为错误。</p><h2 id="5c4a" class="lb jp hi bd jq mi mj mk ju ml mm mn jy jb mo mp kc jf mq mr kg jj ms mt kk mu bi translated"><strong class="ak">在使用defer </strong>之前先知道正确的顺序</h2><p id="844b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><strong class="is hj">注意您将要使用的功能</strong>。阅读函数文档，如果需要的话直接深入到代码中。确保您对函数在每种情况下返回的内容有信心。之后，你就可以知道延迟函数需要以什么顺序执行。这是一个可能的错误顺序的例子。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="60d7" class="lb jp hi kx b fi lc ld l le lf">rows, err := tx.Query("SELECT ...")<br/><strong class="kx hj">defer</strong> rows.Close()<br/><strong class="kx hj">if</strong> err != nil {<br/>   <strong class="kx hj">return</strong> err<br/>}</span></pre><p id="3561" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">err不为零且rows为零时的输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c4cb" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">panic</strong>: runtime error: invalid memory address or nil pointer dereference</span></pre></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="d618" class="jo jp hi bd jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl bi translated">延迟参数范围很复杂</h1><h2 id="d665" class="lb jp hi bd jq mi mj mk ju ml mm mn jy jb mo mp kc jf mq mr kg jj ms mt kk mu bi translated"><strong class="ak">我的参数讨厌范围</strong></h2><p id="f0ce" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Golang变量的作用域很简单。在外部作用域上定义的变量可以被每个内部作用域访问。但是，一旦内部作用域在相同的名称下定义了新变量。它将在内部作用域上创建一个新变量，引用一个不同于外部作用域的全新变量。</p><p id="b1f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着<a class="ae kr" href="https://golang.org/doc/effective_go#named-results" rel="noopener ugc nofollow" target="_blank">命名返回值</a>的进入，这变得更加复杂。在这种情况下，变量在函数生命周期开始时立即被实例化，可以作为常规变量使用。独特的是，您可以使用<code class="du ng nh ni kx b">return</code>而不使用任何局部变量，它将使用函数的命名变量的当前值。</p><p id="6048" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">命名返回值的复杂性是Golang上一些常见错误的根本原因。其中之一是在使用延迟函数时。下面是一个例子。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5952" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> execute() (err <strong class="kx hj">error</strong>){<br/>   db, err := sql.Open()<br/>   <strong class="kx hj">if</strong> err != nil {<br/>      log.Fatal(err)<br/>   }<br/>   <strong class="kx hj">defer</strong> <strong class="kx hj">func</strong>(){<br/>      <strong class="kx hj">if</strong> err := db.Close(); err != nil {<br/>         ...<br/>      }<br/>   }<br/>   ...<br/>   <strong class="kx hj">return</strong><br/>}</span></pre><p id="43d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们期望一旦<code class="du ng nh ni kx b">db.Close()</code>出错，该函数将从关闭db返回一个错误。但是，在这段代码中情况并非如此。因为<code class="du ng nh ni kx b">db.Close()</code>在一个延迟函数中，并且它还用<code class="du ng nh ni kx b">:=</code>实例化了一个新的err变量，该变量不会覆盖来自命名返回<code class="du ng nh ni kx b">(err error)</code>的错误。解决方案就是直接在延迟函数中使用指定的返回变量，因为函数返回值带有err。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="dc91" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">defer</strong> <strong class="kx hj">func</strong>(){<br/>   if err = db.Close(); err != nil {<br/>     ...<br/>   }<br/>}</span></pre><h2 id="d6d5" class="lb jp hi bd jq mi mj mk ju ml mm mn jy jb mo mp kc jf mq mr kg jj ms mt kk mu bi translated"><strong class="ak">在运行中评估</strong></h2><p id="bd9c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">基于<a class="ae kr" href="https://blog.golang.org/defer-panic-and-recover" rel="noopener ugc nofollow" target="_blank">博客Golang </a>的围棋延期规则之二是</p><blockquote class="lt"><p id="3e8a" class="lu lv hi bd lw lx ly lz ma mb mc jn dx translated"><em class="no">对defer语句求值时，会对延迟函数的参数求值。</em></p></blockquote><p id="c865" class="pw-post-body-paragraph iq ir hi is b it md iv iw ix me iz ja jb mf jd je jf mg jh ji jj mh jl jm jn hb bi translated">也许，在这种情况下，一个例子本身会比我试图解释它更有效。<a class="ae kr" href="https://play.golang.org/p/JYnLI16knWO" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="8d60" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> a() {<br/>    i := 0<br/>    <strong class="kx hj">defer</strong> fmt.Println(i)<br/>    i++<br/>    fmt.Println(i)<br/>    <strong class="kx hj">return</strong><br/>}</span></pre><p id="01de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="617d" class="lb jp hi kx b fi lc ld l le lf">1<br/>0</span></pre><p id="6bec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总之，任何作为参数传递给延迟函数的东西都将被立即计算。那么延迟函数将使用评估后的参数，即使原始参数现在可能已经有了不同的值。<strong class="is hj">不要将这与直接使用变量</strong> <strong class="is hj">而没有任何参数</strong>的延迟匿名函数混淆。在这种情况下，它指向同一个变量。通常，开发人员会忽略这种类型的细节，并导致他们犯下defer中最常见的错误之一。</p><p id="0ea8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有一个钱包类型。<a class="ae kr" href="https://play.golang.org/p/h6G6U6HmYpn" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="ab83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="1961" class="lb jp hi kx b fi lc ld l le lf">$ 1000<br/>$ 500<br/>$ 500</span></pre><p id="a2f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们试着把<code class="du ng nh ni kx b">myWallet</code>作为参数传递怎么样。<a class="ae kr" href="https://play.golang.org/p/AS0HYEyyx_T" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="8e21" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> main() {<br/>   myWallet := Wallet{1000}<br/>   myWallet.MyMoney()</span><span id="67c6" class="lb jp hi kx b fi lg ld l le lf">   myWallet.AddMoney(100)<br/>   <strong class="kx hj">defer</strong> <strong class="kx hj">func</strong>(myWallet Wallet) {<br/>      myWallet.MyMoney()<br/>   }(myWallet)</span><span id="e7e5" class="lb jp hi kx b fi lg ld l le lf">   myWallet.DeductMoney(600)<br/>   <strong class="kx hj">defer</strong> myWallet.MyMoney()<br/>}</span></pre><p id="68bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7e5f" class="lb jp hi kx b fi lc ld l le lf">$ 1000<br/>$ 500<br/>$ 1100</span></pre><p id="8b82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后试着把我的钱包换成指针<code class="du ng nh ni kx b">myWallet := &amp;Wallet{1000}</code>。你认为会发生什么？答案可在<em class="np">延迟方法接收器</em>下的后续章节中找到。继续读！</p><h2 id="1cbe" class="lb jp hi bd jq mi mj mk ju ml mm mn jy jb mo mp kc jf mq mr kg jj ms mt kk mu bi translated"><strong class="ak">再次循环… </strong></h2><p id="9009" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">正如前面在<em class="np">谨慎使用循环中提到的，</em>在循环中使用defer会变得相当棘手。现在利用<em class="np">求值参数</em>和<em class="np">参数范围</em>，在一个循环中延迟是非常麻烦的。例如，当您想要在匿名函数中打印一个索引循环时。<a class="ae kr" href="https://play.golang.org/p/FHHPc13eSD9" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2ecc" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">for</strong> i := 0; i &lt; 2; i++ {<br/>   <strong class="kx hj">defer</strong> <strong class="kx hj">func</strong>() {<br/>      fmt.Println(i)<br/>   }()<br/>   fmt.Println(i)<br/>}</span></pre><p id="9e2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5db0" class="lb jp hi kx b fi lc ld l le lf">0<br/>1<br/>2<br/>2</span></pre><p id="ca47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所发生的是延迟函数参数在循环结束后指向相同的变量状态。如果延迟函数想要在每个循环中使用变量状态，那么延迟函数需要在每个循环中计算参数。有多种方法可以实现这一点。这可以通过使用带参数的匿名函数来完成。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c71b" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">for</strong> i := 0; i &lt; 2; i++ {<br/>   <strong class="kx hj">defer</strong> <strong class="kx hj">func</strong>(i int) {<br/>      fmt.Println(i)<br/>   }(i)<br/>   fmt.Println(i)<br/>}</span></pre><p id="d93c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者直接使用延迟功能:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c158" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">for</strong> i := 0; i &lt; 2; i++ {<br/>   <strong class="kx hj">defer</strong> fmt.Println(i)<br/>   fmt.Println(i)<br/>}</span></pre><p id="aedd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="161a" class="lb jp hi kx b fi lc ld l le lf">0<br/>1<br/>1<br/>0</span></pre></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="082a" class="jo jp hi bd jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl bi translated">被遗忘的回归</h1><p id="2a74" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">你知道Go的延迟既不返回值也不返回错误吗？即使延迟函数返回一些东西，它也不会影响任何东西。然而，作为第三条规则，延迟函数可以分配和更改返回命名值，如<a class="ae kr" href="https://blog.golang.org/defer-panic-and-recover" rel="noopener ugc nofollow" target="_blank">博客Golang </a>中所述。</p><blockquote class="lt"><p id="7845" class="lu lv hi bd lw lx ly lz ma mb mc jn dx translated"><em class="no">延迟函数可以读取并赋值给返回函数的指定返回值。</em></p></blockquote><h2 id="cc4e" class="lb jp hi bd jq mi nq mk ju ml nr mn jy jb ns mp kc jf nt mr kg jj nu mt kk mu bi translated">错误在哪里？</h2><p id="ebed" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">开发人员经常马上使用defer，因为它太方便了，他们忘记了Golang语言中最重要的东西。这是错误处理。与其他可以捕捉父函数错误的编程语言不同，Golang依赖于对返回值的错误处理。通常，一些IDE如<em class="np"> Visual Basic </em>和<em class="np"> GoLand </em>提供了一个功能来警告开发者未处理的错误。但是，作为一名优秀的Golang开发人员，我们需要养成更好地处理错误的习惯，而不是总是依赖警告信号。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="955a" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">defer</strong> db.Close()</span></pre><p id="2129" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更好的错误处理:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a2cc" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">defer</strong> <strong class="kx hj">func</strong> () {<br/>   <strong class="kx hj">if</strong> err := db.Close(); err != nil {<br/>      log.Println(err)<br/>   }<br/>}()</span></pre><h2 id="4411" class="lb jp hi bd jq mi mj mk ju ml mm mn jy jb mo mp kc jf mq mr kg jj ms mt kk mu bi translated"><strong class="ak">遗漏退货</strong></h2><p id="2cb3" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">如果Go的defer不处理延迟函数返回的值，那么这些值在代码中的最终位置是哪里？它消失了，形象地说，变成了原子。它只是不拾取或引用任何变量，最终被垃圾收集器收集。</p><p id="79b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么问题来了，如果需要的话，它的父函数的延迟返回值是怎样的？解决这个问题的一个方法是使用前面提到的命名返回值<a class="ae kr" href="https://golang.org/doc/effective_go#named-results" rel="noopener ugc nofollow" target="_blank">。defer函数只需要将值赋给命名的返回参数，父函数将使用这些参数作为最终的返回值。</a></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7b04" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> execute(tx *sql.Tx) (err <strong class="kx hj">error</strong>){<br/>   <strong class="kx hj">defer</strong> <strong class="kx hj">func</strong> () {<br/>      <strong class="kx hj">if</strong> err != nil {<br/>         <strong class="kx hj">if</strong> errRb := tx.Rollback(); errRb != nil {<br/>            err = errRb<br/>            <strong class="kx hj">return</strong><br/>         }<br/>      }<br/>   }()<br/>   …<br/>   <strong class="kx hj">return</strong><br/>}</span></pre><p id="4f6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，请记住，Go的defer的目的首先是鼓励在函数式编程中使用干净的代码。因此，<strong class="is hj">当函数仍然能够正常返回值的时候，你不需要每次都使用defer</strong>。Defer是为了帮助您完成一项清理任务，这项任务在函数每次返回后都必须运行。但是，它不是返回非必要值的工具。比如像<code class="du ng nh ni kx b">tx.Commit()</code>。</p><h1 id="01c3" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">延迟方法接收器</h1><p id="2c9d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">到目前为止，我们主要讨论了延迟属性和机制。现在，我们可以开始用指针和<a class="ae kr" href="https://tour.golang.org/methods/1" rel="noopener ugc nofollow" target="_blank">方法接收器</a>来增加趣味。Golang方法也可以与defer和compliment一起使用，但有一个转折。我们将使用在运行部分评估的<em class="np">中使用的相同示例。让我们改为改变方法的指针。<a class="ae kr" href="https://play.golang.org/p/VJNUVy8AtqH" rel="noopener ugc nofollow" target="_blank">游乐场</a></em></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b79f" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> (wallet Wallet) MyMoney() {<br/>   fmt.Println("$", wallet.money)<br/>}</span><span id="cb4c" class="lb jp hi kx b fi lg ld l le lf">...</span><span id="67dd" class="lb jp hi kx b fi lg ld l le lf"><strong class="kx hj">func</strong> main() {<br/>   myWallet := Wallet{1000}</span><span id="9d8a" class="lb jp hi kx b fi lg ld l le lf">   myWallet.AddMoney(100)<br/>   <strong class="kx hj">defer</strong> myWallet.MyMoney()</span><span id="35c6" class="lb jp hi kx b fi lg ld l le lf">   myWallet.DeductMoney(600)<br/>   <strong class="kx hj">defer</strong> myWallet.MyMoney()<br/>}</span></pre><p id="a92a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c709" class="lb jp hi kx b fi lc ld l le lf">$ 500<br/>$ 1100</span></pre><p id="2318" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当<code class="du ng nh ni kx b">MyMoney</code>使用方法接收器上的指针时进行比较:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="357e" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> (wallet *Wallet) MyMoney() {<br/>   fmt.Println("$", wallet.money)<br/>}</span></pre><p id="c0bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="399a" class="lb jp hi kx b fi lc ld l le lf">$ 500<br/>$ 500</span></pre><p id="23fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里发生了什么？当在延迟函数上注册/计算时，不带指针的方法打印带有值状态的结果值。另一方面，带有指针的方法打印反映在最后更新的值上的两个结果。</p><p id="9451" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它通过立即计算参数与延迟的工作方式有关。更多详情，请参考<em class="np">运行</em>部分的评估。当使用defer时，将立即计算接收方，并将其复制到defer以供以后执行。如果接收者<em class="np"> (Wallet) </em>没有指针，那么复制到接收者的钱包和它的钱的状态是从它在那个时间<em class="np">(在这个例子中是1100) </em>注册时开始的。</p><p id="e7a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它同样适用于指针方法接收器<em class="np"> (*Wallet) </em>。但是，在这种情况下，复制到defer中的接收器是指针的副本，该指针仍然指向与当前接收器相同的地址。因此，在defer receiver中的钱的值仍然跟随主函数中发生的所有变化，直到结束。</p><h2 id="ac74" class="lb jp hi bd jq mi mj mk ju ml mm mn jy jb mo mp kc jf mq mr kg jj ms mt kk mu bi translated">使用匿名函数</h2><p id="8830" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">把戏并没有就此结束。还有更多。从在运行中评估的<em class="np">的例子中我们知道，我们使用匿名函数<code class="du ng nh ni kx b">func(){}()</code>立即评估<code class="du ng nh ni kx b">myWallet</code>。<a class="ae kr" href="https://play.golang.org/p/AS0HYEyyx_T" rel="noopener ugc nofollow" target="_blank">游乐场</a></em></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="775f" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">defer</strong> <strong class="kx hj">func</strong>(myWallet Wallet) {<br/>   myWallet.MyMoney()<br/>}(myWallet)</span></pre><p id="d65c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">试着玩玩吧。你会遇到一个新问题。为什么即使我改变了方法接收器指针，结果总是一样？是因为<code class="du ng nh ni kx b">myWallet</code>当场就被评价为延期函数param。意味着为延迟函数创建了<code class="du ng nh ni kx b">myWallet</code>变量的第二个实例。因此，对原始<code class="du ng nh ni kx b">myWallet</code>的任何改变都不会改变<code class="du ng nh ni kx b">myWallet</code>的第二个变量，因为它有不同的内存地址。如果我们能在正常执行上表示它，它会是这样的:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f6fa" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> main() {<br/>   myWallet := Wallet{1000}</span><span id="2284" class="lb jp hi kx b fi lg ld l le lf">   myWallet.AddMoney(100)<br/>   myWallet2 := myWallet</span><span id="0f35" class="lb jp hi kx b fi lg ld l le lf">   // Do something</span><span id="7b79" class="lb jp hi kx b fi lg ld l le lf">   deferredFunc(myWallet2)<br/>}</span><span id="90b1" class="lb jp hi kx b fi lg ld l le lf"><strong class="kx hj">func</strong> deferredFunc(myWallet Wallet) {<br/>   myWallet.MyMoney()<br/>}</span></pre><p id="c6f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您仍然感到困惑，您可以使用IDE调试器来查看<code class="du ng nh ni kx b">MyMoney</code>函数中<code class="du ng nh ni kx b">Wallet</code>上的每个内存地址。<a class="ae kr" href="https://gist.github.com/kben19/f58cd7d349a79d54ae21c7878cf0b81b" rel="noopener ugc nofollow" target="_blank"> Git gist </a>。</p><h2 id="0376" class="lb jp hi bd jq mi mj mk ju ml mm mn jy jb mo mp kc jf mq mr kg jj ms mt kk mu bi translated">指针异常</h2><p id="b1eb" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">假设您有一个在指针变量上使用方法接收器指针的复杂用例。是的，刚开始其实很困惑，但是你会习惯的。我们先来看一个例子。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d600" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> (wallet *Wallet) MyMoney() {<br/>   fmt.Println("$", wallet.money)<br/>}</span><span id="6855" class="lb jp hi kx b fi lg ld l le lf"><strong class="kx hj">func</strong> main() {<br/>   myWallet := &amp;Wallet{1000}</span><span id="aa97" class="lb jp hi kx b fi lg ld l le lf">   myWallet.AddMoney(100)<br/>   <strong class="kx hj">defer</strong> myWallet.MyMoney()</span><span id="de27" class="lb jp hi kx b fi lg ld l le lf">   myWallet.DeductMoney(600)<br/>   <strong class="kx hj">defer</strong> myWallet.MyMoney()<br/>}</span></pre><p id="c863" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="abfe" class="lb jp hi kx b fi lc ld l le lf">$ 500<br/>$ 500</span></pre><p id="2ab9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用普通方法接收机来试验一下。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="359d" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> (wallet Wallet) MyMoney() {<br/>   fmt.Println("$", wallet.money)<br/>}</span><span id="d5c1" class="lb jp hi kx b fi lg ld l le lf"><strong class="kx hj">func</strong> main() {<br/>   myWallet := &amp;Wallet{1000}</span><span id="f542" class="lb jp hi kx b fi lg ld l le lf">   myWallet.AddMoney(100)<br/>   <strong class="kx hj">defer</strong> myWallet.MyMoney()</span><span id="ae5a" class="lb jp hi kx b fi lg ld l le lf">   myWallet.DeductMoney(600)<br/>   <strong class="kx hj">defer</strong> myWallet.MyMoney()<br/>}</span></pre><p id="b5ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7701" class="lb jp hi kx b fi lc ld l le lf">$ 500<br/>$ 1100</span></pre><p id="98ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果显示了答案。就像我们之前讨论过的，当一个函数的接收者不是指针时，那么接收者复制的值只是一个结构的状态。由于接收器不是指针，所以无论<code class="du ng nh ni kx b">myWallet</code>是否是指针，该值在延迟注册时已经固定。</p><p id="d189" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下表总结了使用方法receiver的这一部分。</p><div class="nv nw ez fb nx ny"><a href="https://docs.google.com/spreadsheets/d/e/2PACX-1vSfwsxy-1lBrXmcrswjeGgzBk3cWoQDnD1Vkmxg7Ir1frb85vifY-nM2o7Zv-2Vi5JQyhjhInC53Ft3/pubhtml?gid=0&amp;single=true" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab dw"><div class="oa ab ob cl cj oc"><h2 class="bd hj fi z dy od ea eb oe ed ef hh bi translated">延期方法接收方摘要- Google Drive</h2><div class="of l"><h3 class="bd b fi z dy od ea eb oe ed ef dx translated">编辑描述</h3></div><div class="og l"><p class="bd b fp z dy od ea eb oe ed ef dx translated">docs.google.com</p></div></div></div></a></div></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="61e0" class="jo jp hi bd jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl bi translated">救援中的恢复</h1><p id="8190" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Golang有自己的方法来产生意外的运行时错误，这在正常情况下通常不应该发生。叫做<a class="ae kr" href="https://gobyexample.com/panic" rel="noopener ugc nofollow" target="_blank">慌</a>。如您所见，Golang将error视为需要返回的值。不像其他语言有自己的异常处理错误并捕捉它。因此，处理死机可能会很麻烦，因为如果处理不当，它可能会停止程序。在golang上处理恐慌的一种方法是使用恢复内置函数。</p><p id="ee77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Recover函数的目的是从死机错误中重新获得控制。除了处理死机之外，它还捕获死机给出的值，并将其作为响应值返回。你可以在<a class="ae kr" href="https://blog.golang.org/defer-panic-and-recover" rel="noopener ugc nofollow" target="_blank">博客golang </a>上看到关于<code class="du ng nh ni kx b">recover</code>的更多信息。</p><p id="11b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不幸的是，根据我的观察，许多开发者并不知道<code class="du ng nh ni kx b">recover</code>功能。这可能与<code class="du ng nh ni kx b">recover</code>需要被放置的性质有关，因为它通常被写在包装器或像<em class="np"> main </em>这样的最顶层父函数中。这也是为什么我们看不到<code class="du ng nh ni kx b">recover</code>在程序中发挥很多作用的原因之一。因此，我将尽力解释如何正确使用recover。</p><h2 id="656a" class="lb jp hi bd jq mi mj mk ju ml mm mn jy jb mo mp kc jf mq mr kg jj ms mt kk mu bi translated">恢复和延迟是一对</h2><p id="c2a5" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">没错，题目就是这个意思。<strong class="is hj">没有延期，恢复是完全无用的</strong>。他们需要在一起工作。他们注定要在一起。让我们试着把它们分开，看看会发生什么。(<em class="np">我为他们感到难过</em></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4100" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> main() {<br/>   <strong class="kx hj">recover</strong>()<br/>   <strong class="kx hj">panic</strong>(“panicking”)<br/>}</span></pre><p id="69d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:恐慌仍在肆虐。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c955" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">panic</strong>: panicking</span></pre><p id="e402" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个如何正确使用recover的示例。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="8417" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> main() {<br/>   <strong class="kx hj">defer</strong> <strong class="kx hj">func</strong>() {<br/>      recoveredValue := <strong class="kx hj">recover</strong>()<br/>      fmt.Println("recovered value:", recoveredValue)<br/>   }()<br/>   <strong class="kx hj">panic</strong>("panicking")<br/>}</span></pre><p id="e06a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b36e" class="lb jp hi kx b fi lc ld l le lf">recovered value: panicking</span></pre><h2 id="510e" class="lb jp hi bd jq mi mj mk ju ml mm mn jy jb mo mp kc jf mq mr kg jj ms mt kk mu bi translated">恢复值</h2><p id="99c8" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">现在我们知道了如何正确使用<code class="du ng nh ni kx b">recover</code>函数。下一步是利用从恐慌中恢复的值。大多数情况下，开发人员用一个字符串或一个错误来初始化panic。但是，根据panic golang <a class="ae kr" href="https://pkg.go.dev/builtin#panic" rel="noopener ugc nofollow" target="_blank">文档</a>，panic参数实际上是一个接口。它也适用于基于<a class="ae kr" href="https://pkg.go.dev/builtin#recover" rel="noopener ugc nofollow" target="_blank">文档</a>的恢复函数返回值类型。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ac14" class="lb jp hi kx b fi lc ld l le lf"><strong class="kx hj">func</strong> panic(v <strong class="kx hj">interface</strong>{})</span><span id="a8fe" class="lb jp hi kx b fi lg ld l le lf"><strong class="kx hj">func</strong> recover() <strong class="kx hj">interface</strong>{}</span></pre><p id="2554" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于这些文档，<strong class="is hj">我们可以在技术上把任何有用的东西分配到恐慌中，并在稍后的</strong>恢复。开发人员可以比以前更多地分析恐慌，或者将它用于其他用例。这为我们在程序中如何处理和使用恐慌提供了充分的灵活性。例如，让我们用定制的错误来尝试一下。</p><p id="faab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有一个定制的一般错误。<a class="ae kr" href="https://play.golang.org/p/oKXNI6nSHX-" rel="noopener ugc nofollow" target="_blank">游乐场</a></p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="2dba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c26f" class="lb jp hi kx b fi lc ld l le lf">recovered: error 500</span></pre></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="dfb0" class="jo jp hi bd jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl bi translated">结论</h1><p id="8db4" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Golang defer函数对于编写干净的代码来说是非常有用和必要的。基于我们所看到和讨论的，Golang defer很容易使用和理解，但很难掌握。在学习了Golang的延迟机制及其良好的实践后，我们可以用一种新的方式来看待延迟，并准备充分利用延迟的潜力。我希望这篇文章能帮助你深入了解延迟。感谢您到目前为止阅读我的文章。</p></div></div>    
</body>
</html>