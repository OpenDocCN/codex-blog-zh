<html>
<head>
<title>Clean Dependency Management in Multi Module Android Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多模块Android项目中的干净依赖管理</h1>
<blockquote>原文：<a href="https://medium.com/codex/clean-dependency-management-in-multi-module-android-projects-49f2a0df8d2f?source=collection_archive---------2-----------------------#2022-07-20">https://medium.com/codex/clean-dependency-management-in-multi-module-android-projects-49f2a0df8d2f?source=collection_archive---------2-----------------------#2022-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/c9530cc08e1627e339ae24a5c06218aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4zsMTxl2lwUjD5iybO_0UQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图片由<a class="ae hv" href="https://pixabay.com/photos/toys-play-plastic-funny-ant-man-4982760/" rel="noopener ugc nofollow" target="_blank"> pixabay </a></figcaption></figure><div class=""/><p id="6375" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您正在开发一个多模块的Android应用程序，并且正在寻找一种干净的、可扩展的方式来组织所有的依赖项并构建项目的配置，那么这篇文章就是为您准备的。我们将介绍一种方法，这种方法将构建配置组织在一个公共位置，并利用Kotlin的DSL支持来实现清晰的语法、强大的Kotlin功能以及构建文件中的平滑导航。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="46b9" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">我们将使用的工具</h1><p id="1d60" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如今，不使用Gradle作为Android项目的构建自动化工具是愚蠢的。Gradle不仅提供了比其他构建工具更高的性能和可定制性，而且它还附带了一个非常大的<a class="ae hv" href="https://plugins.gradle.org/" rel="noopener ugc nofollow" target="_blank">插件库</a>，这使它成为一项非常强大的资产。</p><p id="7a6e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事实上，你可能已经使用了一个插件<a class="ae hv" href="https://developer.android.com/studio/releases/gradle-plugin" rel="noopener ugc nofollow" target="_blank">来集成Gradle和Android Studio。我们还将利用</a><a class="ae hv" href="https://github.com/gradle/kotlin-dsl-samples" rel="noopener ugc nofollow" target="_blank"> kotlin-dsl插件</a>来无缝地用kotlin编写我们的构建逻辑，并将其添加到Gradle文件中。</p><h1 id="aed0" class="ka kb hy bd kc kd ld kf kg kh le kj kk kl lf kn ko kp lg kr ks kt lh kv kw kx bi translated">我们将遵循的结构</h1><p id="8c9b" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">通常的做法是使用一个<code class="du li lj lk ll b">buildSrc</code>目录来封装构建逻辑。Google经常在他们的<a class="ae hv" href="https://github.com/android/compose-samples" rel="noopener ugc nofollow" target="_blank">示例架构项目</a>中使用这种方法，Gradle本身也在他们的<a class="ae hv" href="https://docs.gradle.org/current/userguide/organizing_gradle_projects.html#sec:build_sources" rel="noopener ugc nofollow" target="_blank">文档</a>中包含了一些关于这方面的技巧。</p><blockquote class="lm ln lo"><p id="dc72" class="iv iw lp ix b iy iz ja jb jc jd je jf lq jh ji jj lr jl jm jn ls jp jq jr js hb bi translated">简而言之，诸如依赖版本控制、配置数据、代码质量脚本和其他构建脚本之类的逻辑可以包含在<code class="du li lj lk ll b">buildSrc</code>目录中。使用这种目录模型的主要优点是，Gradle会自动编译和测试这段代码，并将其添加到您的构建脚本的类路径中，从而更容易维护、重构和测试代码。</p></blockquote><p id="4e14" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里需要注意的重要一点是，Gradle期望一个单独的<code class="du li lj lk ll b">buildSrc</code>目录，它必须存在于项目根目录中。如果你仍然好奇，你可以在这里阅读更多关于Gradle的构建生命周期是如何工作的。</p><h1 id="4ef5" class="ka kb hy bd kc kd ld kf kg kh le kj kk kl lf kn ko kp lg kr ks kt lh kv kw kx bi translated">创建buildSrc目录</h1><p id="ab79" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">为了使它更容易，您可以在阅读本文剩余部分的同时跟随<a class="ae hv" href="https://github.com/frezafoltran/MultiModuleDependencyManagementSample" rel="noopener ugc nofollow" target="_blank">源代码</a>。我们将从创建一个<code class="du li lj lk ll b">buildSrc</code>目录来托管我们的构建逻辑开始。为了便于说明，我们将在<code class="du li lj lk ll b">Dependencies.kt</code>中包含依赖版本控制，在<code class="du li lj lk ll b">ConfigurationData.kt</code>中包含配置数据。但是请记住，随着项目的增长，您可以在这个目录中编写更复杂的构建脚本。</p><p id="34e2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要创建<code class="du li lj lk ll b">buildSrc</code>目录，只需转到项目的根目录，点击<em class="lp">新建</em>，然后点击<em class="lp">目录</em>并将其命名为<code class="du li lj lk ll b">buildSrc</code>。</p><figure class="lu lv lw lx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lt"><img src="../Images/5c082d807d4fe1438b831329a9c5f173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*86E4wX5aV4uh0SPe8VybTA.png"/></div></div></figure><p id="a102" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上图显示了你的<code class="du li lj lk ll b">buildSrc</code>目录应该有的初始结构，橙色的文件(1到6)是我们将要修改的。</p><h1 id="8559" class="ka kb hy bd kc kd ld kf kg kh le kj kk kl lf kn ko kp lg kr ks kt lh kv kw kx bi translated">添加kotlin-dsl插件</h1><p id="e786" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">您可能已经注意到,<code class="du li lj lk ll b">.gradle</code>文件被修改成包含一个<code class="du li lj lk ll b">.kts</code>扩展名。这是因为我们希望在这些文件中使用Kotlin，但是在我们这样做之前，我们还必须添加kotlin-dsl gradle插件。为此，修改<code class="du li lj lk ll b">buildSrc</code>的<code class="du li lj lk ll b">build.gradle.kts</code>(即。文件2)包含:</p><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="790c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你不确定什么是DSL，它代表<em class="lp">领域特定语言</em>，它是Kotlin的更高抽象层次，针对特定问题进行了优化。你可以从<a class="ae hv" href="https://kotlinlang.org/docs/type-safe-builders.html#how-it-works" rel="noopener ugc nofollow" target="_blank">文档</a>中找到一个很好的例子。</p><h1 id="2852" class="ka kb hy bd kc kd ld kf kg kh le kj kk kl lf kn ko kp lg kr ks kt lh kv kw kx bi translated">添加逻辑以构建Src</h1><p id="e5ef" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">好了，现在我们的<code class="du li lj lk ll b">.gradle</code>文件理解Kotlin，但是我们还没有任何数据给他们。更改您的<code class="du li lj lk ll b">ConfigurationData.kt</code>以包含实际配置数据，例如:</p><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="0575" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">并将所需依赖项的版本数据添加到<code class="du li lj lk ll b">Dependencies.kt</code>:</p><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="3558" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用于<code class="du li lj lk ll b">Dependencies.kt</code>的格式允许您组织对象中的依赖关系和对象中的对象，这在您的项目增长时非常有用。请查看<a class="ae hv" href="https://github.com/frezafoltran/MultiModuleDependencyManagementSample" rel="noopener ugc nofollow" target="_blank">源代码</a>获取所有文件的完整版本。</p><h1 id="07a0" class="ka kb hy bd kc kd ld kf kg kh le kj kk kl lf kn ko kp lg kr ks kt lh kv kw kx bi translated">从buildSrc向gradle脚本添加逻辑</h1><p id="b396" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">很好，我们在<code class="du li lj lk ll b">buildSrc</code>目录中用Kotlin干净地写了一些构建信息。多亏了<a class="ae hv" href="https://github.com/gradle/kotlin-dsl-samples" rel="noopener ugc nofollow" target="_blank"> kotlin-dsl插件</a>，我们可以从<code class="du li lj lk ll b">.gradle</code>文件中访问它们。为此，更改您的应用程序模块的<code class="du li lj lk ll b">build.gradle.kts</code> <em class="lp">(文件1) </em>以包括:</p><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="9745" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，配置数据和库的版本可以从gradle脚本中直接访问。</p><h1 id="9c38" class="ka kb hy bd kc kd ld kf kg kh le kj kk kl lf kn ko kp lg kr ks kt lh kv kw kx bi translated">探索优势</h1><p id="ac80" class="pw-post-body-paragraph iv iw hy ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">这种处理构建配置的建议方法有一些值得注意的优点:</p><ul class=""><li id="8f0e" class="ma mb hy ix b iy iz jc jd jg mc jk md jo me js mf mg mh mi bi translated"><strong class="ix hz">对于多模块项目表现良好。</strong>也就是说，如果多个模块依赖于同一个库，他们可以很容易地从公共库<code class="du li lj lk ll b">buildSrc</code>中获得库的版本，并在他们自己的<code class="du li lj lk ll b">build.gradle.kts</code>中使用。此外，模块也可以共享其他构建脚本。</li><li id="4198" class="ma mb hy ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="ix hz">支持可测试、可维护的构建脚本</strong>。请记住，<code class="du li lj lk ll b">buildSrc</code>有Kotlin代码，这意味着您可以使用Kotlin编写您的构建逻辑，并使用Gradle自动测试它。</li><li id="01e1" class="ma mb hy ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">它允许你充分利用你的IDE。进入你的app模块的<code class="du li lj lk ll b">build.gradle.kts</code> <em class="lp">(文件1) </em>，按住<em class="lp">命令</em>(或<em class="lp"> Ctrl </em>，点击<code class="du li lj lk ll b">implementation(Libs.Kotlin.stdlib)</code>中的<code class="du li lj lk ll b">stdlib</code>。您应该直接导航到<code class="du li lj lk ll b">stdlib</code>的定义。除了自动导航之外，您现在还可以在编写代码时享受自动完成建议，就像您已经对常规Kotlin文件所做的那样。</li></ul><p id="2a98" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读！别忘了查看一下<a class="ae hv" href="https://github.com/frezafoltran/MultiModuleDependencyManagementSample" rel="noopener ugc nofollow" target="_blank">源代码</a>，如果你想把它作为一个项目的基础，你可以随时派生它。如果你喜欢的内容，不要忘记鼓掌，并关注更多！</p></div></div>    
</body>
</html>