<html>
<head>
<title>What do I understand about “Modern” Angular Development?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我对“现代”角发育的理解是什么？</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-do-i-understand-about-modern-angular-development-fa0f4f5359c3?source=collection_archive---------17-----------------------#2022-10-29">https://medium.com/codex/what-do-i-understand-about-modern-angular-development-fa0f4f5359c3?source=collection_archive---------17-----------------------#2022-10-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6db9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是关于更新的特性或者不开发更难的构建模块。这是关于改变我们过去的惯例。在这里，我们主要关心的不是高级交互图形或CSS设计，而是创建一个伟大的UX，并使用一些标准实践为开发人员开发一个伟大的体验。</p><h1 id="ada9" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">根据我的理解，这里有5件事需要考虑。</strong></h1><h1 id="da89" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak"> OnPush变化检测</strong></h1><p id="8524" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">为了反映应用程序状态的变化，每个前端框架都需要某种类型的变化检测机制，并且以一种不会杀死浏览器的高性能方式做到这一点，每个框架都需要优化，以便不会发生不必要的重新渲染。棱角分明也没什么不同。</p><p id="9c8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，它将对同步和异步发生的所有操作做出反应。对你的<code class="du kg kh ki kj b">@Input</code>(甚至是嵌套在对象深处的属性)的每一个改变，每一个事件，以及浏览器API调用(比如<code class="du kg kh ki kj b">setTimeout</code>、滚动事件等)。)，将触发变化检测。发生这种情况是因为Angular不知道您的数据可能改变的所有可能方式。它需要“只是工作”，所以它对一切都有反应。</p><h1 id="059b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">反应式编码</strong></h1><p id="ab42" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">反应式编程有两个主要概念。</p><ol class=""><li id="b542" class="kk kl hi ih b ii ij im in iq km iu kn iy ko jc kp kq kr ks bi translated"><strong class="ih hj">流</strong>——按时间顺序排列的一系列正在进行的事件。它可以发出三种不同的东西:一个值(某种类型)、一个错误或一个“完成”信号。例如，当包含该按钮的当前窗口或视图关闭时，考虑“完成”发生。例如，如果我们试图从一个家庭组件传输数据，它将被传输到服务，并从那里发出HTTP请求，最终数据从数据库传输。</li><li id="cc8f" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kp kq kr ks bi translated">订阅-接受某物的安排。基本上，两个端点之间没有一系列的连接。Observables将连接到observators，每当它们观察到新的值或数据变化时，它们将在订阅的帮助下执行代码，所有订阅的组件都将收到更新的结果。值得注意的是，一个特定的可观察对象只能被那些订阅它的组件访问。</li></ol><p id="59f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们试图实现这一点，我们总是可以选择rxjs-streams数据。</p><h1 id="4484" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">智能/非智能组件</strong></h1><p id="ad3d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">Angular中最基本的结构是一个<strong class="ih hj">组件。</strong>将你的组件分为<strong class="ih hj">非智能</strong>(表象的)和<strong class="ih hj">智能</strong>(逻辑的)组件很流行也很有用。非智能组件负责呈现数据，它们很少拥有自己的逻辑(如果有，可能与UI有关，而不是应用程序状态)，而智能组件负责执行功能和管理数据—将相关数据发送到包含的转储组件。</p><h1 id="5a13" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">独立/诈骗</strong></h1><p id="994e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在SCAM(单组件角度模块)模式中组织您的模块是一个相对较新的想法。<strong class="ih hj">简而言之，它提倡为每个组件创建一个模块。</strong>这有助于避免使用<code class="du kg kh ki kj b"><em class="ky">NgModules</em></code> <em class="ky"> </em>时出现的所有问题——例如，麻烦的重构。</p><p id="3c28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">随着<strong class="ih hj">独立组件</strong>的即将到来的实现，SCAM将变得尤其重要，这很有可能成为Angular明年最热门的话题。</p><p id="35c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用SCAM模块模式的主要好处是:</p><ul class=""><li id="02f4" class="kk kl hi ih b ii ij im in iq km iu kn iy ko jc kz kq kr ks bi translated">易于遵循的项目结构，</li><li id="284c" class="kk kl hi ih b ii kt im ku iq kv iu kw iy kx jc kz kq kr ks bi translated">准备好<strong class="ih hj"> </strong>在实现时将组件转换成独立的组件。</li></ul><p id="14e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">独立更多关注组件构建，更少关注模块构建</p><h1 id="6960" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">协同代码</strong></h1><p id="c743" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">非常基本的代码结构可以分为四个不同的术语:</p><p id="d845" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">数据访问</strong>应该与像服务这样的API调用相关。</p><p id="e5ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> UI </strong>应该有<strong class="ih hj"> </strong>组件和特性，比如定义的指令。</p><p id="2ee5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实用程序可以在用户界面中有其他需要的帮助实用程序文件夹。就像守卫一样。</p><p id="e5f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Example.component.ts </strong>与特定组件密切相关的其他帮助特性。</p><p id="00c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用共享文件夹，我们可以在组件的不同部分使用相同的功能。</p></div></div>    
</body>
</html>