<html>
<head>
<title>A simple lesson in coding: the playground</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一堂简单的编程课:操场</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-simple-lesson-in-coding-the-playground-3ef0326b6506?source=collection_archive---------27-----------------------#2021-08-23">https://medium.com/codex/a-simple-lesson-in-coding-the-playground-3ef0326b6506?source=collection_archive---------27-----------------------#2021-08-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ih ii ij ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es ig"><img src="../Images/82705d4d3bc94230ec05c92899940e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IFNPL_BNShLNsH-0opKIoA.jpeg"/></div></div><figcaption class="ir is et er es it iu bd b be z dx translated">密苏里州菲利普斯堡糖果厂的泡菜味太妃糖。(作者照片，2021)。</figcaption></figure><p id="7dd0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是四篇系列文章中的最后一篇，讲述了一个简单的想法是如何演变成学生第一堂数据结构课的课程计划的。 <a class="ae ju" rel="noopener" href="/@leoirakliotis/a-simple-lesson-in-coding-38334e9d8608">第一篇文章</a>描述了我们将在这里继续使用的简单例子:一种判断字符串是否是回文的方法。<a class="ae ju" rel="noopener" href="/@leoirakliotis/a-simple-lesson-in-coding-revisited-fbc9add1e599">第二篇</a>稍微提炼了一下方法。第三篇文章<a class="ae ju" rel="noopener" href="/@leoirakliotis/a-simple-lesson-in-coding-testing-first-91b3da7b9925">暴露了更多的缺陷，并为编码前更好的规划和设计提供了一个案例。</a></p><p id="282c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们对我们的方法的工作方式感到满意，是时候在真实环境中部署它了:让我们扫描一本书并收集它的回文。按照下面的计划，我们将使用古登堡计划作为数据来源。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="f967" class="ke kf hi ka b fi kg kh l ki kj">establish a URL connection to the book<br/>scan the text, word by word<br/>if a word has not been processed before:<br/>  if it's a valid word (letters, spaces, punctuation only):<br/>    if it's a palindrome:<br/>      add it to the list of palindromes for the book<br/>report results</span></pre><p id="92ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个计划看起来很简单，除了关于“回文列表”的部分。学完编程入门课程的学生对数组很熟悉。自然，他们可能倾向于编写如下代码。在下面的代码片段中，<code class="du kk kl km ka b">book</code>是一个连接到基于web的文本的<code class="du kk kl km ka b">Scanner</code>对象，<code class="du kk kl km ka b">palindromesFound</code>是一个<code class="du kk kl km ka b">String</code>数组。</p><figure class="jv jw jx jy fd ik"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="83af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面代码的问题当然是数组<code class="du kk kl km ka b">palindromesFound[]</code>。用太少的元素初始化它，我们会得到一个索引越界运行时错误。用太多的元素初始化它，我们可能会浪费资源。理想情况下，我们需要一个按需调整大小的数组。Java中的数组不能做到这一点。所以学生们现在必须“发明”动态数组。</p><p id="0c80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有些程序员可能会问，为什么不在这一点上向学生展示如何使用数组列表呢？我可以，但是我的目标是向学生展示数据结构是特定问题的解决方案，并且数据结构的机制完全在他们的编程能力之内。最终，我们将使用Java集合框架和Guava中的数组列表和其他类。目前，重点是理解必要性如何变成效用。简单的编程就能让我们达到目的。</p><p id="986f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住这一点，邀请学生解决调整数组大小的问题。如果我们有一个为[10]个元素初始化的数组，但是我们想再存储一个元素，该怎么办？经过课堂上的反复讨论，我们发现我们可以在Java中调整数组的大小，尽管效率不是很高:</p><figure class="jv jw jx jy fd ik"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="c34b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们关注调整数组大小的频率。如果我们为每一个额外的元素调整大小，事情会变得非常慢。我们试验不同的调整大小计划，重写第1行，如下所示，同时我们讨论不同调整大小因子的优点。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="a06b" class="ke kf hi ka b fi kg kh l ki kj">String newArray[] = new String[oldArray.length * 2]; <br/>// or<br/>String newArray[] = new String[3 * oldArray.length / 2];</span></pre><p id="bfe6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们派生了一个类来处理动态调整大小。本质上，我们正在重新发明数组列表。</p><figure class="jv jw jx jy fd ik"><div class="bz dy l di"><div class="kn ko l"/></div><figcaption class="ir is et er es it iu bd b be z dx translated">注意方法<em class="if"> resize </em>是私有的。这是因为调整数组大小是类的内部事务，不应该由用户发起。每当我们达到数组的容量时，方法add就会调用方法resize。</figcaption></figure><p id="404f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过使用FlexArray对象，我们认识到一本书，例如，<a class="ae ju" href="https://www.gutenberg.org/ebooks/4300" rel="noopener ugc nofollow" target="_blank">詹姆斯·乔伊斯的<em class="jt">尤利西斯</em> </a> <em class="jt">，</em>有数千个回文。经过仔细检查，我们发现大多数都是重复的。每当我们的代码遇到不定冠词<em class="jt">“a”</em>时，它会将它添加到数组<code class="du kk kl km ka b">palindromesFound</code>中。结果，我们最终在那个数组中有数千个元素，包含相同的值(例如，<code class="du kk kl km ka b">"a"</code>，不定冠词；<code class="du kk kl km ka b">"i"</code>，第一人称代词；<code class="du kk kl km ka b">"did"</code>，助动词<em class="jt"> do- </em>的屈折形式；等等)。</p><p id="2aea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，下一个目标是避免处理重复的单词，确保数组<code class="du kk kl km ka b">palindromesFound</code>不包含重复的单词。为此，我们需要一个单独的<code class="du kk kl km ka b">FlexArray</code>对象来包含已经处理过的单词。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="7d1f" class="ke kf hi ka b fi kg kh l ki kj">FlexArray wordsProcessed = new FlexArray();<br/>FlexArray palindromesFound = new FlexArray();</span><span id="55cb" class="ke kf hi ka b fi kp kh l ki kj">while (book.hasNext()) {<br/>  String word = book.next();<br/>  if (!wordsProcessed.contains(word) { // first time word<br/>    wordsProcessed.add(word); // remember this word<br/>    if (isValid(word) &amp;&amp; isPalindrome(word)) { // if palindrome<br/>      palindromesFound.add(word); // add it to our collection<br/>    }<br/>  }<br/>}</span></pre><p id="156d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用这种方法，我们发现像<em class="jt">尤利西斯</em>这样的巨著，回文单词很少；就几百块。这是因为FlexArray <code class="du kk kl km ka b">wordsProcessed</code>“记住”我们之前学过的单词，并帮助我们跳过它们。当我们在FlexArray <code class="du kk kl km ka b">palindromesFound</code>中添加一个单词时，我们确定我们没有复制一个现有的条目。事实上，<em class="jt">尤利西斯</em>有25万多字，但只有4.9万左右是独一无二的。书中大约有400个回文。</p><p id="563a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用类<code class="du kk kl km ka b">FlexArray</code>搜索回文会很慢。这是因为方法<code class="du kk kl km ka b">contains</code>从头开始扫描数组，直到找到它要寻找的单词。这不是一个非常有效的搜索单词的方法。在这一点上，我开始向学生描述我们过去如何在印刷字典中搜索单词。这个描述引出了在<em class="jt">二叉查找树中添加和搜索数据的方法。</em></p><p id="a03e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然并不完美，但我在这里和以前的文章中描述的课程计划帮助学生从他们的入门编程课程过渡到他们的第一个数据结构。</p></div></div>    
</body>
</html>