<html>
<head>
<title>A simple lesson in coding, revisited</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一堂简单的编程课，重温</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-simple-lesson-in-coding-revisited-fbc9add1e599?source=collection_archive---------26-----------------------#2021-08-17">https://medium.com/codex/a-simple-lesson-in-coding-revisited-fbc9add1e599?source=collection_archive---------26-----------------------#2021-08-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2d7b60b0fe31e3239e73b86dd487fb3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y28O2Mghyaf-VbOMqLtUBQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">伊利诺伊州春田市伊利诺伊州游乐场牲畜棚里的马车。(作者照片，2021)。</figcaption></figure><p id="0433" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我今天重温的这堂简单的编程课是从我的<em class="js">数据结构</em>课第一周的课程计划开始的。该计划旨在帮助学生更新他们的入门编码技能。为此，我使用了一个简单的任务，比如<a class="ae jt" rel="noopener" href="/@leoirakliotis/a-simple-lesson-in-coding-38334e9d8608">编写一个方法来评估一个字符串是否是回文</a>，来讨论编码实践。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="d48b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">左边的简单方法使用for循环来扫描字符串的回文属性。它从字符串的开头和结尾开始查看成对的字母，并向中间移动。只要每对中的字母彼此相等，Boolean <code class="du ka kb kc kd b">palindrome</code>就保持为真。当坏的一对出现时，布尔<code class="du ka kb kc kd b">palindrome</code>变为假。即使后续字母对中的字母相等，它也不会从这种状态中恢复。这是在第7行完成的，这里我们评估字母(<code class="du ka kb kc kd b">pairMatched</code>)和(<code class="du ka kb kc kd b">&amp;&amp;</code>)的两两相等以及<code class="du ka kb kc kd b">palindrome.</code>的当前状态</p><p id="7fde" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在<code class="du ka kb kc kd b">palindrome</code>的当前状态和两个字母之间的相等性之间取条件AND是至关重要的:它确保一旦发现字母不匹配，<code class="du ka kb kc kd b">palindrome</code>将保持为假。因为AND运算中的<code class="du ka kb kc kd b">false</code>值就像乘法中的零一样。一旦一个变量被乘以0，它本身就会变成0，不管我们用非零的数乘以多少次。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用<strong class="ak"> replace() </strong>和<strong class="ak"> replaceAll() </strong>是出于说明的目的，如本系列的<a class="ae jt" rel="noopener" href="/@leoirakliotis/a-simple-lesson-in-coding-38334e9d8608">上一篇文章</a>中所述。</figcaption></figure><p id="2465" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在意识到for循环不是一个非常有效的技术之后，我们切换到while循环，如左图所示。有朋友注意到7号线可以简化。我们不再需要在评估中保留<code class="du ka kb kc kd b">palindrome</code>的当前值。我们在for循环版本的方法中需要它，因为我们评估了字符串<code class="du ka kb kc kd b">s</code>中的每一对字母。在while循环中，我们并不评估<code class="du ka kb kc kd b">s</code>中每一对可能的字母。当我们发现不匹配时，循环就结束了。因此，简化第7行就足够了，如下所示。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="eec7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们在第7行把<code class="du ka kb kc kd b">palindrome</code>放在评估的右边，这不是一个可怕的错误。但是有必要反思一下我们是如何结束第7行的:我们从使用for循环的方法开始。接下来，我们修改了该方法，使用while循环来提高效率。专注于用<code class="du ka kb kc kd b">while</code>代替<code class="du ka kb kc kd b">for</code>，我们可能忘记了7号线右侧的<code class="du ka kb kc kd b">palindrome</code>。这种方法在不改变那条线的情况下工作得很好。</p><p id="ab42" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们关注新版本的方法中<code class="du ka kb kc kd b">palindrome</code>的作用，我们可以看到为什么在第7行的右边不需要它。该方法首先假设字符串<code class="du ka kb kc kd b">s</code>是一个回文。它继续比较字符串两端的字母对，向内移动。每次比较都会更新<code class="du ka kb kc kd b">palindrome</code>的值。当我们点击两个不同的字母时，它们的比较将产生错误。这将成为<code class="du ka kb kc kd b">palindrome</code>的值。这将导致while循环结束。接下来是return语句，将<code class="du ka kb kc kd b">palindrome</code>的false值推出。</p><p id="57e4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">或者，我们可能会进行最后一次两两比较，发现字符串<code class="du ka kb kc kd b">s</code>中的每一对字母都匹配。在这种情况下，while循环结束，因为<code class="du ka kb kc kd b">pos</code>不再小于<code class="du ka kb kc kd b">s.length()/2</code>。<code class="du ka kb kc kd b">palindrome</code>的当前值现在为真。我们也完了！</p><p id="6b0c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当我完成这个例子并为第一周的课程做准备时，我还需要做两件事:将测试(和通过测试进行设计)引入讨论，并将这个例子转换成某种数据结构的应用程序。我将在下一篇文章中讨论这两件事。</p><p id="f66d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">接下来:</em> <a class="ae jt" rel="noopener" href="/@leoirakliotis/a-simple-lesson-in-coding-testing-first-91b3da7b9925"> <em class="js">一堂简单的编码课:先测试</em> </a> <em class="js">！</em></p></div></div>    
</body>
</html>