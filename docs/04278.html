<html>
<head>
<title>How to Build a C Compiler Using Lex and Yacc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Lex和Yacc构建C编译器</h1>
<blockquote>原文：<a href="https://medium.com/codex/building-a-c-compiler-using-lex-and-yacc-446262056aaa?source=collection_archive---------0-----------------------#2021-11-18">https://medium.com/codex/building-a-c-compiler-using-lex-and-yacc-446262056aaa?source=collection_archive---------0-----------------------#2021-11-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9e9c507fb7e29dbd8ed662960928231e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzX8tGLXv1v2SzlUeXoVEQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@helloimnik?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">你好我是尼克</a>在<a class="ae iu" href="https://unsplash.com/s/photos/build?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="d3b0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建我们自己的编译器并执行程序该有多酷？听起来很神奇，不是吗？嗯，你来对地方了！</p><h1 id="aaad" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">介绍</h1><p id="fee0" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">编译器是一个<strong class="ix hj">程序，它将编程语言</strong>(高级)<strong class="ix hj">中的代码转换成机器可理解的格式</strong>(低级)。然后，这个编译器生成一个可执行程序，可以用来解析和执行特定语言的输入文件。</p><p id="5654" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将看看编译器ie的前端阶段。构建符号表、生成语法树、识别语义错误以及生成中间代码。</p><p id="be36" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文共分六个部分。</p><blockquote class="kw kx ky"><p id="cc78" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">第1部分:创建词法分析器</p><p id="3a7e" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">第2部分:添加语法规则</p><p id="14cd" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">第3部分:创建符号表</p><p id="433b" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">第4部分:添加语法树</p><p id="208d" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">第5部分:执行语义分析</p><p id="6b6c" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">第6部分:中间代码生成</p></blockquote><p id="42d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你想直接跳到代码，就去我的<a class="ae iu" href="https://github.com/AnjaneyaTripathi/c-compiler" rel="noopener ugc nofollow" target="_blank"> GitHub </a>库开始吧。⭐️如果你喜欢它的内容。😃</p><h2 id="aee4" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kh jk lm ln kl jo lo lp kp lq bi translated">莱克斯是什么？</h2><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/58bcc1d4230d319550c0528a3ce48806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*daK4-Bl8GCoesto5mmCrxQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:<a class="ae iu" href="https://www.looper.com/img/gallery/the-untold-truth-of-lex-luthor/intro-1577203159.jpg" rel="noopener ugc nofollow" target="_blank">活套</a></figcaption></figure><p id="2924" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不，不是莱克斯·卢瑟。</p><p id="3ad5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Lex是一个用来创建词法分析器的工具。那么什么是词法分析呢？这是<strong class="ix hj">过程，在这个过程中，一个字符流被转换成一个令牌序列</strong>。这种程序被称为词法分析器或分词器。该文件包含一组正则表达式以及与每个表达式相关联的操作。输出是一个表驱动的扫描器——它告诉我们当我们根据我们所处的状态看到一个特定的输入字符时该做什么。该输出保存在一个名为lex.yy.c的文件中。所有lex文件的结构都类似于下面给出的结构。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="fcf2" class="ld ju hi lx b fi mb mc l md me">{declarations}<br/>%%<br/>{rules}<br/>%%<br/>{subroutines}</span></pre><p id="0a66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">声明</strong>有两种类型，在C和Lex中。所有的导入和全局声明都在C中完成，并包含在<code class="du mf mg mh lx b">%{</code>和<code class="du mf mg mh lx b">%}</code>中。除此之外，Lex文件可以包含正则表达式和符号的定义。</p><p id="d060" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">规则</strong>由同一行中的动作所遵循的模式组成。</p><p id="cd4a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，<strong class="ix hj">子程序</strong>包含了我们自己想要编写的函数。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/da05797251e4f5f4e91e769f74f31975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*qRLR5Wi0KF42KV4m6P_PiQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:<a class="ae iu" href="https://me.me/i/lex-and-yacc-gcc-18487540" rel="noopener ugc nofollow" target="_blank">迷因</a></figcaption></figure><h2 id="a398" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kh jk lm ln kl jo lo lp kp lq bi translated">看看Yacc</h2><p id="e2b9" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Yacc(又一个编译器)是一个用来创建解析器的工具。它解析来自Lex文件的标记流，并执行语义分析。Yacc将给定的上下文无关语法(CFG)规范翻译成C实现y.tab.c。这个C程序在编译时会生成一个可执行的解析器。Yacc文件在许多方面与Lex文件相似。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="45be" class="ld ju hi lx b fi mb mc l md me">{declarations}<br/>%%<br/>{rules}<br/>%%<br/>{subroutines}</span></pre><p id="e3d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">声明</strong>和<strong class="ix hj">子程序</strong>与Lex中的相同，但规则略有不同。这里，<strong class="ix hj">规则</strong>不是正则表达式，而是CFG中的语法定义。这些规则，像Lex中一样，有两个部分——产生和动作。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/69c6c1ff9bfc2066f8acfd3213701b16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ng7oLRGZisHCQUj7avsxZQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1: <a class="ae iu" href="https://arcb.csc.ncsu.edu/~mueller/codeopt/codeopt00/y_man.pdf" rel="noopener ugc nofollow" target="_blank">托马斯·尼曼</a></figcaption></figure><p id="c7a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还创建了另一个文件——y . tab . h，我们还没有谈到它。这是我们编译Yacc文件时创建的文件。它告诉我们的Lex文件在我们的Yacc程序中定义的所有有效的令牌声明。</p><p id="bb50" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们知道了Lex和Yacc文件的样子，我们可以更深入地开始构建我们自己的C编译器。</p><h2 id="da0b" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kh jk lm ln kl jo lo lp kp lq bi translated">我们编译器的能力是什么？</h2><p id="53a1" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在我们开始编码之前，<strong class="ix hj"> <em class="kz">我们的编译器将接受</em> </strong>:</p><ol class=""><li id="7c88" class="mk ml hi ix b iy iz jc jd jg mm jk mn jo mo js mp mq mr ms bi translated">有效的C语句，如声明、初始化等。</li><li id="2a1b" class="mk ml hi ix b iy mt jc mu jg mv jk mw jo mx js mp mq mr ms bi translated"><code class="du mf mg mh lx b">if-else</code>报表</li><li id="f561" class="mk ml hi ix b iy mt jc mu jg mv jk mw jo mx js mp mq mr ms bi translated"><code class="du mf mg mh lx b">for</code>循环</li><li id="cb54" class="mk ml hi ix b iy mt jc mu jg mv jk mw jo mx js mp mq mr ms bi translated">嵌套的<code class="du mf mg mh lx b">for</code>和<code class="du mf mg mh lx b">if-else</code>语句</li></ol><p id="cf9a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将<strong class="ix hj"> <em class="kz">实现为前端阶段</em> </strong>的编译器，即:</p><ol class=""><li id="e065" class="mk ml hi ix b iy iz jc jd jg mm jk mn jo mo js mp mq mr ms bi translated">生成符号表</li><li id="80d9" class="mk ml hi ix b iy mt jc mu jg mv jk mw jo mx js mp mq mr ms bi translated">创建解析树</li><li id="0f0a" class="mk ml hi ix b iy mt jc mu jg mv jk mw jo mx js mp mq mr ms bi translated">执行语义分析</li><li id="c5b2" class="mk ml hi ix b iy mt jc mu jg mv jk mw jo mx js mp mq mr ms bi translated">生成中间代码</li></ol><p id="6240" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了目标，让我们开始编码吧！</p></div><div class="ab cl my mz gp na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hb hc hd he hf"><h1 id="5a38" class="jt ju hi bd jv jw nf jy jz ka ng kc kd ke nh kg kh ki ni kk kl km nj ko kp kq bi translated">第1部分:创建词法分析器</h1><p id="f5a0" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们现在知道，Lex文件有3个部分。我们将从声明开始，然后转到规则，最后添加所有必要的函数。</p><p id="e92f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 1。声明</strong></p><p id="8ce2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们首先声明编译器所需的所有导入和全局变量。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="e074" class="ld ju hi lx b fi mb mc l md me">%{    <br/>     #include "y.tab.h"    <br/>     int countn=0;       /* for keeping track of the line number */<br/>%}</span></pre><p id="2d24" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们包括<code class="du mf mg mh lx b">y.tab.h</code>和一个计数器来记录我们所在的行号。这将在后面的符号表中使用，并帮助我们调试。</p><p id="01fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来我们有我们的常规定义。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="eaf9" class="ld ju hi lx b fi mb mc l md me">%option yylineno</span><span id="1e2a" class="ld ju hi lx b fi nk mc l md me">alpha          [a-zA-Z]<br/>digit          [0-9]<br/>unary          "++"|"--"</span></pre><p id="80e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh lx b">%option yylineno</code>创建存储行号的扫描仪。</p><p id="c90a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2。规则</strong></p><p id="d679" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我们Lex文件中最重要的部分之一。我们定义了对从C程序获得的输入流进行标记化所需的所有规则。这些标记将被我们的Yacc文件使用。</p><p id="0e45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们为关键字定义规则。在这里，如果我们遇到<code class="du mf mg mh lx b">printf</code>或<code class="du mf mg mh lx b">scanf</code>，我们的lexer将识别它并分别返回令牌<code class="du mf mg mh lx b">PRINTFF</code>和<code class="du mf mg mh lx b">SCANFF</code>。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="1b3a" class="ld ju hi lx b fi mb mc l md me">"printf"    { strcpy(yylval.nd_obj.name,(yytext)); return PRINTFF; }<br/>"scanf"     { strcpy(yylval.nd_obj.name,(yytext)); return SCANFF; }</span></pre><p id="400c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们同样描述其他关键字的规则，如<code class="du mf mg mh lx b">int</code>、<code class="du mf mg mh lx b">float</code>、<code class="du mf mg mh lx b">for</code>、<code class="du mf mg mh lx b">if</code>、<code class="du mf mg mh lx b">else</code>等。为了理解其他规则，熟悉正则表达式语法是必不可少的。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="e2f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以上代码是我们最后的<strong class="ix hj"><em class="kz">Lex程序</em> </strong>。子程序部分将在下面解释。</p><p id="d406" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3。子程序</strong></p><p id="0174" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的子程序很简单，只有一个函数叫做<code class="du mf mg mh lx b">yywrap()</code>。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="3e8f" class="ld ju hi lx b fi mb mc l md me">int yywrap() {<br/>    return 1;<br/>}</span></pre><p id="b5fa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一点上，可能会有一些困惑，这些<code class="du mf mg mh lx b">yy</code>函数— <code class="du mf mg mh lx b">yywrap, yylval, yytext</code>等都是什么？？</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/5c644bf7acfd5bfec866c481862009c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fhl6RRTb9tVIpRq_83RMAw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图2: <a class="ae iu" href="https://arcb.csc.ncsu.edu/~mueller/codeopt/codeopt00/y_man.pdf" rel="noopener ugc nofollow" target="_blank">托马斯·尼曼</a></figcaption></figure><p id="1f4a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完成后，我们的Lex文件就完成了！</p><p id="34f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在可以使用下面的命令编译我们的Lex文件</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="cac4" class="ld ju hi lx b fi mb mc l md me">lex lexer.l</span></pre><p id="316c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，我们已经介绍了什么是编译器，什么是Lex和Yacc，以及它们如何帮助我们制作自己的编译器。最后，我们编写了自己的Lex程序来为任何输入C程序生成令牌。</p><p id="6c85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在接下来的章节中，我们将致力于创建我们的Yacc程序，并最终创建我们自己的C编译器。</p></div><div class="ab cl my mz gp na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hb hc hd he hf"><h1 id="d8d1" class="jt ju hi bd jv jw nf jy jz ka ng kc kd ke nh kg kh ki ni kk kl km nj ko kp kq bi translated">第2部分:添加语法规则</h1><p id="9756" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在这一节中，我们的目标是用解析输入C程序所必需的所有语法规则创建Yacc文件。未来的文章将讨论创建符号表、解析树、语义分析和中间代码生成。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es no"><img src="../Images/c8678e0080fde90eaeb8c58e4f65608a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cU13zWe6J77lk18gF7RoyA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">迈克尔·泽兹奇在<a class="ae iu" href="https://unsplash.com/s/photos/compiler?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="2d04" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kh jk lm ln kl jo lo lp kp lq bi translated">编写我们的YACC程序</h2><p id="2324" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如前所述，Yacc项目包括三个部分。我们将依次讲解每个部分。</p><p id="b806" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 1。声明</strong></p><p id="6ae3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的声明中，我们导入了将在Yacc程序中使用的必要的头文件和函数声明。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="6eef" class="ld ju hi lx b fi mb mc l md me">%{<br/>    #include&lt;stdio.h&gt;<br/>    #include&lt;string.h&gt;<br/>    #include&lt;stdlib.h&gt;<br/>    #include&lt;ctype.h&gt;<br/>    #include"lex.yy.c"<br/>    <br/>    void yyerror(const char *s);<br/>    int yylex();<br/>    int yywrap();<br/>%}</span><span id="63c7" class="ld ju hi lx b fi nk mc l md me">%token VOID CHARACTER PRINTFF SCANFF INT FLOAT CHAR FOR IF ELSE TRUE FALSE NUMBER FLOAT_NUM ID LE GE EQ NE GT LT AND OR STR ADD MULTIPLY DIVIDE SUBTRACT UNARY INCLUDE RETURN</span></pre><p id="d778" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">头文件直接来自C，所以我们将跳过它们。我们定义了3个函数— <code class="du mf mg mh lx b">yyerror(const char *s)</code>、<code class="du mf mg mh lx b">yylex()</code>和<code class="du mf mg mh lx b">yywrap()</code>。后两个已经在第1部分讨论过了，到了<code class="du mf mg mh lx b">yyerror()</code>，它是一个显示错误信息的库函数。</p><p id="fe88" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继续，我们看到<code class="du mf mg mh lx b">%token</code>后面跟着一堆单词。这些话实际上是YACC文件可以接受的象征。这存储在Lex程序使用的<code class="du mf mg mh lx b">y.tab.h</code>中。</p><p id="5d6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2。规则</strong></p><p id="af57" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">定义完成后，是时候开始学习解析器的规则了。在我们开始之前，让我们了解规则是如何定义的以及它们的基本结构。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="5661" class="ld ju hi lx b fi mb mc l md me">production-name: definition 1    { action }<br/>| definition 2                   { more action }<br/>|                                { some more action }<br/>;</span></pre><p id="186f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du mf mg mh lx b">definition 2</code>之后，我们看到的下一个生产是空生产。对应于每个定义的操作是可选的。它们是根据每个产品所满足的定义来执行的。</p><p id="0175" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看一个简单的c语言声明语句。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="003f" class="ld ju hi lx b fi mb mc l md me">int x = 35;</span><span id="a4c4" class="ld ju hi lx b fi nk mc l md me">or</span><span id="3c17" class="ld ju hi lx b fi nk mc l md me">float x;</span></pre><p id="dd73" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在定义这种语法在这种声明性语句之上的外观。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="b020" class="ld ju hi lx b fi mb mc l md me">declaration: datatype ID '=' value<br/>| datatype ID<br/>;</span><span id="b09b" class="ld ju hi lx b fi nk mc l md me">datatype: INT<br/>| FLOAT<br/>| CHAR<br/>;</span><span id="68d0" class="ld ju hi lx b fi nk mc l md me">value: NUMBER<br/>| FLOAT_NUM<br/>| CHARACTER<br/>;</span></pre><p id="8028" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在将系统地编写将用于创建我们的解析器的所有语法定义。</p><p id="8bbb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一个语法是针对整个C程序结构的。每个C程序都有一组头文件，声明了<code class="du mf mg mh lx b">main</code>函数，后面是主体和<code class="du mf mg mh lx b">return</code>语句。我们的编译器假设C代码中只有一个函数——<code class="du mf mg mh lx b">main</code>函数。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="6097" class="ld ju hi lx b fi mb mc l md me">program: headers main '(' ')' '{' body return '}'<br/>;</span></pre><p id="c10f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们讨论标题。<code class="du mf mg mh lx b">INCLUDE</code>是在我们的Lex程序中定义的一个令牌。我们使用<code class="du mf mg mh lx b">headers headers</code>的原因是为了适应多个头文件。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="97c1" class="ld ju hi lx b fi mb mc l md me">headers: headers headers<br/>| INCLUDE<br/>;</span></pre><p id="2de7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh lx b">main</code>是另一种产品，定义如下。我们假设没有参数传递给这个<code class="du mf mg mh lx b">main</code>函数。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="56b2" class="ld ju hi lx b fi mb mc l md me">main: datatype ID<br/>;</span></pre><p id="1676" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，datatype不在上面定义的标记中，而是另一种产品。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="416b" class="ld ju hi lx b fi mb mc l md me">datatype: INT <br/>| FLOAT <br/>| CHAR<br/>| VOID<br/>;</span></pre><p id="f309" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">main之后是我们的C代码体。主体可以有大量可能的语句和循环。它们在规则中的定义如下。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="b759" class="ld ju hi lx b fi mb mc l md me">body: FOR '(' statement ';' condition ';' statement ')' '{' body '}'<br/>| IF '(' condition ')' '{' body '}' else<br/>| statement ';' <br/>| body body<br/>| PRINTFF '(' STR ')' ';'<br/>| SCANFF '(' STR ',' '&amp;' ID ')' ';'<br/>;</span></pre><p id="65e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">经过仔细检查，我们发现<code class="du mf mg mh lx b">for</code>循环和<code class="du mf mg mh lx b">if</code>语句中的代码块再次包含了<code class="du mf mg mh lx b">body</code>。这允许我们的编译器接受不同复杂度的嵌套语句。</p><p id="0492" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh lx b">if-else</code>声明包含最后的<code class="du mf mg mh lx b">else</code>生产。这允许我们拥有<code class="du mf mg mh lx b">if-else</code>以及简单的<code class="du mf mg mh lx b">if</code>语句。我们将<code class="du mf mg mh lx b">else</code>定义为:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="dbbc" class="ld ju hi lx b fi mb mc l md me">else: ELSE '{' body '}'<br/>|<br/>;</span></pre><p id="e3c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有两个产品是需要讨论的<code class="du mf mg mh lx b">body</code>的一部分，即<code class="du mf mg mh lx b">condition</code>和<code class="du mf mg mh lx b">statement</code>。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="1611" class="ld ju hi lx b fi mb mc l md me">condition: value relop value <br/>| TRUE <br/>| FALSE<br/>;</span><span id="69e4" class="ld ju hi lx b fi nk mc l md me">statement: datatype ID init <br/>| ID '=' expression <br/>| ID relop expression<br/>| ID UNARY <br/>| UNARY ID;</span></pre><p id="d26a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经知道了<code class="du mf mg mh lx b">condition</code>和<code class="du mf mg mh lx b">statement</code>的制作规则，我们可以继续查看它们所使用的其他制作。</p><p id="9e31" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh lx b">value</code>可以是整数、十进制值、字符或变量。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="79f2" class="ld ju hi lx b fi mb mc l md me">value: NUMBER<br/>| FLOAT_NUM<br/>| CHARACTER<br/>| ID<br/>;</span></pre><p id="5025" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh lx b">relop</code>是一个产品，它定义了可以执行的所有可能的关系操作。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="8448" class="ld ju hi lx b fi mb mc l md me">relop: LT<br/>| GT<br/>| LE<br/>| GE<br/>| EQ<br/>| NE<br/>;</span></pre><p id="2503" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到了<code class="du mf mg mh lx b">statement</code>，我们可以看到我们有初始化、声明以及赋值操作。在C中声明变量时，没有必要将其初始化为特定的值。这就是为什么<code class="du mf mg mh lx b">init</code>生产是<strong class="ix hj">可空</strong>生产。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="fad8" class="ld ju hi lx b fi mb mc l md me">init: '=' value <br/>|<br/>;</span></pre><p id="ea26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继续，我们有<code class="du mf mg mh lx b">expression</code>。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="d888" class="ld ju hi lx b fi mb mc l md me">expression: expression arithmetic expression<br/>| value<br/>;</span></pre><p id="68dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些表达式可以有算术运算，所以我们为其定义了另一个产品。算术运算被定义为但不限于加法、减法、乘法和除法。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="2c73" class="ld ju hi lx b fi mb mc l md me">arithmetic: ADD<br/>| SUBTRACT<br/>| MULTIPLY<br/>| DIVIDE<br/>;</span></pre><p id="b60f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完成所有这些产品后，我们就完成了C程序的<code class="du mf mg mh lx b">body</code>。C代码的最后一部分是<code class="du mf mg mh lx b">return</code>语句。我们定义<code class="du mf mg mh lx b">return</code>如下。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="180f" class="ld ju hi lx b fi mb mc l md me">return: RETURN value ';' <br/>|<br/>;</span></pre><p id="9bf7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh lx b">return</code>也是可空生产。</p><p id="4d79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完成所有这些定义后，我们就完成了Yacc文件的第二部分。我们现在可以进入最后一个部分——子程序。</p><p id="c7b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3。子程序</strong></p><p id="6058" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的子程序由两个函数组成— <code class="du mf mg mh lx b">main</code>和<code class="du mf mg mh lx b">yyerror</code>。它们的定义如下。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="254e" class="ld ju hi lx b fi mb mc l md me">int main() {<br/>    yyparse();<br/>}</span><span id="5f8b" class="ld ju hi lx b fi nk mc l md me">void yyerror(const char* msg) {<br/>    fprintf(stderr, "%s\n", msg);<br/>}</span></pre><p id="1bf9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh lx b">main</code>函数告诉我们解析输入文件，而<code class="du mf mg mh lx b">yyerror</code>打印出编译和执行Yacc文件时出现的错误。</p><p id="2268" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在规则部分、声明和子例程中定义的所有产品的完整集成代码如下所示。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="d316" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了编译我们的Yacc程序，我们运行以下命令:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="87f6" class="ld ju hi lx b fi mb mc l md me">yacc -v -d parser1.y</span></pre><p id="8f26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了生成可执行文件，我们运行:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="efbf" class="ld ju hi lx b fi mb mc l md me">gcc -ll y.tab.c</span></pre><p id="8bdc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了测试我们的编译器，我们执行下面给出的命令。(假设你有一个叫<code class="du mf mg mh lx b">input1.c</code>的C程序。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="f794" class="ld ju hi lx b fi mb mc l md me">./a.out&lt;input1.c</span></pre><p id="1d99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">至此，我们完成了Yacc文件。我们在规则部分、声明和子例程中定义的所有产品的完整集成代码如下所示。</p><p id="6d5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">目前，尚未定义任何操作。因此，如果程序是有效的C代码，则在执行时不会显示任何<code class="du mf mg mh lx b">syntax error</code>。</p><p id="ca2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下一节，我们将讨论如何为我们的编译器创建符号表。</p></div><div class="ab cl my mz gp na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hb hc hd he hf"><h1 id="b4e0" class="jt ju hi bd jv jw nf jy jz ka ng kc kd ke nh kg kh ki ni kk kl km nj ko kp kq bi translated">第3部分:创建符号表</h1><p id="cc2a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在这一部分中，我们的目标是构建符号表并存储头文件、变量、关键字和常量以及行号、类型和数据类型等细节。本文将对它们进行更详细的讨论。我们的目标是实现下面的符号表。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es np"><img src="../Images/a7b40a59de010ae18b099ada2bd55f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*xk_7lBSqo2kRMJrDtf232Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1:符号表</figcaption></figure><p id="c92d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">符号表存储标识符、数据类型(仅适用于变量)、标识符的类型或类别以及行号。</p><p id="d245" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也就是说，让我们开始在前面的代码中添加符号表功能。</p><h2 id="7c53" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kh jk lm ln kl jo lo lp kp lq bi translated">添加符号表</h2><p id="48cb" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了添加我们的符号表，我们必须首先定义结构和细节。我们的符号表将有像符号名称，数据类型，符号类型(关键字，常数，变量等)的细节。)和行号。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="56ae" class="ld ju hi lx b fi mb mc l md me">struct dataType {<br/>        char * id_name;<br/>        char * data_type;<br/>        char * type;<br/>        int line_no;<br/>} symbol_table[40];</span></pre><p id="6fa5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">注意</strong>:行号在编译器的所有阶段都有很大的帮助，因为每当程序崩溃时，它会告诉我们错误在哪一行。</p><p id="013d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，<code class="du mf mg mh lx b">40</code>表示我们符号表中的最大条目数，可以根据我们的要求增加或减少。</p><p id="6eee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一个需要解决的部分是<code class="du mf mg mh lx b">insert_type()</code>函数。每当向符号表中添加函数或变量时，都会调用此函数。它将要添加的变量或函数的数据类型复制到名为<code class="du mf mg mh lx b">type</code>的字符数组中。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="e9bf" class="ld ju hi lx b fi mb mc l md me">void insert_type() {<br/>    strcpy(type, yytext);<br/>}</span></pre><p id="3f1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们来看符号表功能的主要部分-将符号添加到表中。我们使用<code class="du mf mg mh lx b">add</code>函数来达到这个目的。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="98b1" class="ld ju hi lx b fi mb mc l md me">void add(char c) {<br/>  q=search(yytext);<br/>  if(!q) {<br/>    if(c == 'H') {<br/>      symbol_table[count].id_name=strdup(yytext);        <br/>      symbol_table[count].data_type=strdup(type);     <br/>      symbol_table[count].line_no=countn;    <br/>      symbol_table[count].type=strdup("Header");<br/>      count++;  <br/>    }  <br/>    else if(c == 'K') {<br/>      symbol_table[count].id_name=strdup(yytext);<br/>      symbol_table[count].data_type=strdup("N/A");<br/>      symbol_table[count].line_no=countn;<br/>      symbol_table[count].type=strdup("Keyword\t");   <br/>      count++;  <br/>    }  else if(c == 'V') {<br/>      symbol_table[count].id_name=strdup(yytext);<br/>      symbol_table[count].data_type=strdup(type);<br/>      symbol_table[count].line_no=countn;<br/>      symbol_table[count].type=strdup("Variable");   <br/>      count++;  <br/>    }  else if(c == 'C') {<br/>      symbol_table[count].id_name=strdup(yytext);<br/>      symbol_table[count].data_type=strdup("CONST");<br/>      symbol_table[count].line_no=countn;<br/>      symbol_table[count].type=strdup("Constant");   <br/>      count++;  <br/>    }  else if(c == 'F') {<br/>      symbol_table[count].id_name=strdup(yytext);<br/>      symbol_table[count].data_type=strdup(type);<br/>      symbol_table[count].line_no=countn;<br/>      symbol_table[count].type=strdup("Function");   <br/>      count++;  <br/>    }<br/>}</span></pre><p id="884d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了确保我们的表中不会重复出现相同的符号，我们使用了<code class="du mf mg mh lx b">search</code>函数。它被定义为:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="386d" class="ld ju hi lx b fi mb mc l md me">int search(char *type) { <br/>    int i; <br/>    for(i=count-1; i&gt;=0; i--) {<br/>        if(strcmp(symbol_table[i].id_name, type)==0) {   <br/>            return -1;<br/>            break;  <br/>        }<br/>    } <br/>    return 0;<br/>}</span></pre><p id="58b0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦函数完成并准备好了，我们要做的就是开始在相关的地方插入函数调用。我们有5种类型的符号:</p><ol class=""><li id="6ba2" class="mk ml hi ix b iy iz jc jd jg mm jk mn jo mo js mp mq mr ms bi translated">h-Headers:用于所有头文件</li><li id="f97c" class="mk ml hi ix b iy mt jc mu jg mv jk mw jo mx js mp mq mr ms bi translated">K —关键字:针对<code class="du mf mg mh lx b">for</code>、<code class="du mf mg mh lx b">if</code>、<code class="du mf mg mh lx b">else</code>等关键字。</li><li id="dc11" class="mk ml hi ix b iy mt jc mu jg mv jk mw jo mx js mp mq mr ms bi translated">V —变量:仅在变量声明期间调用</li><li id="94fb" class="mk ml hi ix b iy mt jc mu jg mv jk mw jo mx js mp mq mr ms bi translated">C —常量:任何赋值，如<code class="du mf mg mh lx b">9</code>、<code class="du mf mg mh lx b">'A'</code>、<code class="du mf mg mh lx b">-3.14</code>等。</li><li id="af72" class="mk ml hi ix b iy mt jc mu jg mv jk mw jo mx js mp mq mr ms bi translated">F —功能:目前只有<code class="du mf mg mh lx b">main</code></li></ol><p id="7cd5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在正确的地方添加了函数调用之后，我们需要做的就是在Yacc文件的<code class="du mf mg mh lx b">main</code>函数中打印表格。下面可以看到对<code class="du mf mg mh lx b">add</code>的函数调用和更新后的<code class="du mf mg mh lx b">main</code>函数。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="c25f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在需要做的就是编译并运行我们的编译器。这些命令是:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="d6a0" class="ld ju hi lx b fi mb mc l md me">yacc -v -d parser2.y<br/>lex lexer.l<br/>gcc -ll y.tab.c<br/>./a.out&lt;input1.c</span></pre><p id="61e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了得到图1所示的输出，相应的C代码如下。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="2373" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们终于完成了符号表的创建。恭喜你走到这一步！当我们潜得更深时，喝点咖啡。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nq"><img src="../Images/f2ab9cd142a8b6bc1fcf7306ed7c69c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bWk4xbDF5AwcCx1AJR-2A.jpeg"/></div></div></figure><p id="2d8e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下一节中，我们将讨论为我们的C程序创建解析树。你可以随意摆弄我们到目前为止所做的任何东西。</p></div><div class="ab cl my mz gp na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hb hc hd he hf"><h1 id="e7c8" class="jt ju hi bd jv jw nf jy jz ka ng kc kd ke nh kg kh ki ni kk kl km nj ko kp kq bi translated">第4部分:添加语法树</h1><p id="4d4a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们现在处理使用我们的编译器为C程序创建解析树。最后，我们将打印C代码解析树的有序遍历。让我们开始吧！</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nr"><img src="../Images/0ddb37cf172dfb3c4bc2998c24b38a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iguVW2x6exipW7-JeewODA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">西蒙·威尔克斯在<a class="ae iu" href="https://unsplash.com/s/photos/tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="6972" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kh jk lm ln kl jo lo lp kp lq bi translated">创建抽象语法树</h2><p id="93a8" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们的解析树将是一棵二叉树——它将有两个子树。树的根将是程序的开始。结构极其简单直观。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="581c" class="ld ju hi lx b fi mb mc l md me">                      program<br/>                         |<br/>   _________________________________________<br/>  |                                         |<br/>headers                                   main<br/>                                            |<br/>                               __________________________<br/>                              |                          |<br/>                             body                     return</span></pre><p id="3f7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">主体将由多个语句、循环和if-else块组成。为了构建这样的树，我们需要首先创建节点。完成后，我们编写一个函数将元素添加到树中，最后打印树。</p><p id="34a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将一步一步地解决这个问题，从定义我们的节点开始。</p><p id="508f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 1。我们树的节点</strong></p><p id="d99c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像二叉树的任何节点一样，它将有一个左右子节点以及关于该节点的数据，这里它被称为<code class="du mf mg mh lx b">token</code>。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="0aa9" class="ld ju hi lx b fi mb mc l md me">struct node {<br/>  struct node *left;<br/>  struct node *right;<br/>  char *token;     <br/>};</span></pre><p id="ec75" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还需要重新定义令牌和产品的类型。</p><p id="6798" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们称这种新型为<code class="du mf mg mh lx b">nd_obj</code>。其定义如下。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="533e" class="ld ju hi lx b fi mb mc l md me">struct var_name {<br/>   char name[100];<br/>   struct node* nd;<br/>} nd_obj;</span></pre><p id="df00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在编译器的后期，我们将添加不同的节点类型。它们将被称为<code class="du mf mg mh lx b">nd_obj2</code>、<code class="du mf mg mh lx b">nd_obj3</code>等等。</p><p id="034f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的定义中，我们通过添加类型做了一点小小的修改。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="c07b" class="ld ju hi lx b fi mb mc l md me">%token VOID</span><span id="1560" class="ld ju hi lx b fi nk mc l md me">%token &lt;nd_obj&gt; CHARACTER PRINTFF SCANFF INT FLOAT CHAR FOR IF ELSE TRUE FALSE NUMBER FLOAT_NUM ID LE GE EQ NE GT LT AND OR STR ADD MULTIPLY DIVIDE SUBTRACT UNARY INCLUDE RETURN<br/> <br/>%type &lt;nd_obj&gt; headers main body return datatype expression statement init value arithmetic relop program</span></pre><p id="db2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个阶段，我们还必须修改我们的Lex文件。所有的令牌现在都是时间的<code class="du mf mg mh lx b">nd_obj</code>，所以我们现在可以保存令牌的名称。</p><p id="0047" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更新后的Lex文件如下所示。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="e214" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如本系列的第1部分所示，<code class="du mf mg mh lx b">yylval</code>是与令牌相关联的值。使用<code class="du mf mg mh lx b">yytext</code>，我们将<code class="du mf mg mh lx b">name</code>分配给我们的令牌。</p><p id="0b11" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2。制作节点并将它们添加到解析树</strong></p><p id="9220" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们定义树的原点为<code class="du mf mg mh lx b">head</code>。它的类型是<code class="du mf mg mh lx b">node</code>。这将作为访问解析树的入口点。我们在YACC文件的第一段中定义了这一点。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="4539" class="ld ju hi lx b fi mb mc l md me">struct node *head;</span></pre><p id="c095" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一步是创建一个将节点添加到树中的函数。这将被称为<code class="du mf mg mh lx b">mknode()</code>。该函数将接受3个参数——节点的左子节点、右子节点和名称。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="1092" class="ld ju hi lx b fi mb mc l md me">struct node* mknode(struct node *left, struct node *right, char *token) {<br/>  struct node *newnode = (struct node*) malloc(sizeof(struct node));<br/>  char *newstr = (char*) malloc(strlen(token)+1);<br/>  strcpy(newstr, token);<br/>  newnode-&gt;left = left;<br/>  newnode-&gt;right = right;<br/>  newnode-&gt;token = newstr;<br/>  return(newnode);<br/>}</span></pre><p id="3187" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如你所看到的，这个函数将帮助我们制作我们的树。下一步是调用这个函数并传递必要的参数。</p><p id="9b30" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们开始这一部分之前，有必要了解我们如何访问语法中的结果和元素。假设我们有以下产品:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="1403" class="ld ju hi lx b fi mb mc l md me">print: PRINTFF { add('K'); } '(' STR ')' ';'</span></pre><p id="144b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要访问<code class="du mf mg mh lx b">PRINTFF</code>，我们使用<code class="du mf mg mh lx b">$1</code>。为了访问<code class="du mf mg mh lx b">STR</code>，我们使用<code class="du mf mg mh lx b">$4</code>。这些元素从1开始索引，在<code class="du mf mg mh lx b">{}</code>之间发生的任何动作都算作一个元素。这就是为什么<code class="du mf mg mh lx b">STR</code>是<code class="du mf mg mh lx b">$4</code>而不是<code class="du mf mg mh lx b">$3</code>。我们将用它来调用<code class="du mf mg mh lx b">mknode()</code>函数，并在必要时将产品作为子产品传递。为了访问生产ie。<code class="du mf mg mh lx b">print</code>我们用<code class="du mf mg mh lx b">$$.nd</code>。</p><p id="6c1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们开始从<code class="du mf mg mh lx b">program</code>产品中生成我们的树。然后，我们将根据我们在本系列第3部分制作的<code class="du mf mg mh lx b">parser2.y</code>按顺序移动。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="ef14" class="ld ju hi lx b fi mb mc l md me">program: headers main '(' ')' '{' body return '}' { <br/>    $2.nd = mknode($6.nd, $7.nd, "main"); <br/>    $$.nd = mknode($1.nd, $2.nd, "program"); <br/>    head = $$.nd; <br/>} <br/>;</span></pre><p id="74aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里，我们指定<code class="du mf mg mh lx b">main</code>有子节点<code class="du mf mg mh lx b">body</code>和<code class="du mf mg mh lx b">return</code>，而节点被称为“主节点”。<code class="du mf mg mh lx b">program</code>叫做“程序”，它的孩子是<code class="du mf mg mh lx b">header</code>和<code class="du mf mg mh lx b">main</code>。由于这将是我们解析树的入口点，我们将<code class="du mf mg mh lx b">program</code>赋给<code class="du mf mg mh lx b">head</code>。</p><p id="740c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们接下来继续到<code class="du mf mg mh lx b">header</code>节点。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="713c" class="ld ju hi lx b fi mb mc l md me">headers: headers headers { <br/>    $$.nd = mknode($1.nd, $2.nd, "headers"); }<br/>| INCLUDE { <br/>    add('H'); <br/>    $$.nd = mknode(NULL, NULL, $1.name); <br/>}<br/>;</span></pre><p id="c088" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在多个头的情况下，我们再次创建一个具有子节点<code class="du mf mg mh lx b">header</code>的新节点。如果只有一个<code class="du mf mg mh lx b">header</code>,我们将它保存为头文件的名称，并且没有子文件。</p><p id="e6c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在进入<code class="du mf mg mh lx b">body</code>。我们跳过<code class="du mf mg mh lx b">main</code>，因为它已经在<code class="du mf mg mh lx b">program</code>生产中处理过了。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="887d" class="ld ju hi lx b fi mb mc l md me">body: FOR { add('K'); } '(' statement ';' condition ';' statement ')' '{' body '}' { <br/>    struct node *temp = mknode($6.nd, $8.nd, "CONDITION"); <br/>    struct node *temp2 = mknode($4.nd, temp, "CONDITION"); <br/>    $$.nd = mknode(temp2, $11.nd, $1.name); <br/>}<br/>| IF { add('K'); } '(' condition ')' '{' body '}' else { <br/>    struct node *iff = mknode($4.nd, $8.nd, $1.name);  <br/>    $$.nd = mknode(iff, $11.nd, "if-else"); <br/>}<br/>| statement ';' { $$.nd = $1.nd; }<br/>| body body { $$.nd = mknode($1.nd, $2.nd, "statements"); }<br/>| PRINTFF { add('K'); } '(' STR ')' ';' { $$.nd = mknode(NULL, NULL, "printf"); }<br/>| SCANFF { add('K'); } '(' STR ',' '&amp;' ID ')' ';' { <br/>    $$.nd = mknode(NULL, NULL, "scanf"); <br/>}<br/>;</span></pre><p id="372d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh lx b">for</code>循环有一个复杂的结构，这将在下面解释。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="a581" class="ld ju hi lx b fi mb mc l md me">for<br/>                          |<br/>                  ________________________________________<br/>                 |                                        |<br/>             condition                                 body<br/>                 |<br/>     __________________________<br/>    |                          |<br/>   declaration            condition<br/>                               |<br/>                      ___________________________<br/>                     |                           |<br/>                   check                     iterator</span></pre><p id="0c39" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是为什么我们的代码中有两个临时节点——处理检查条件和迭代，而另一个临时节点处理迭代器的声明以及上面的临时节点。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="e26e" class="ld ju hi lx b fi mb mc l md me">condition: value relop value { <br/>    $$.nd = mknode($1.nd, $3.nd, $2.name); <br/>}<br/>| TRUE { add('K'); $$.nd = NULL; }<br/>| FALSE { add('K'); $$.nd = NULL; }<br/>| { $$.nd = NULL; };</span></pre><p id="cc2b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh lx b">if-else</code>块的实现类似，可以随意生成一个如上的树来理解它是如何工作的。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="0882" class="ld ju hi lx b fi mb mc l md me">else: ELSE { add('K'); } '{' body '}' { <br/>    $$.nd = mknode(NULL, $4.nd, $1.name); <br/>}<br/>| { $$.nd = NULL; };</span></pre><p id="d754" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了简单起见，我们不在解析树中存储<code class="du mf mg mh lx b">printf</code>函数的字符串，因为现在它们是叶节点。请随意将它们添加到您的代码中！</p><p id="a37a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们接下来看看<code class="du mf mg mh lx b">statement</code>。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="1000" class="ld ju hi lx b fi mb mc l md me">statement: datatype ID { add('V'); } init { <br/>    $2.nd = mknode(NULL, NULL, $2.name); <br/>    $$.nd = mknode($2.nd, $4.nd, "declaration"); <br/>}<br/>| ID '=' expression { <br/>    $1.nd = mknode(NULL, NULL, $1.name); <br/>    $$.nd = mknode($1.nd, $3.nd, "="); <br/>}<br/>| ID relop expression { <br/>    $1.nd = mknode(NULL, NULL, $1.name); <br/>    $$.nd = mknode($1.nd, $3.nd, $2.name); <br/>}<br/>| ID UNARY { <br/>    $1.nd = mknode(NULL, NULL, $1.name); <br/>    $2.nd = mknode(NULL, NULL, $2.name); <br/>    $$.nd = mknode($1.nd, $2.nd, "ITERATOR"); <br/>}<br/>| UNARY ID { <br/>    $1.nd = mknode(NULL, NULL, $1.name); <br/>    $2.nd = mknode(NULL, NULL, $2.name); <br/>    $$.nd = mknode($1.nd, $2.nd, "ITERATOR"); <br/>}<br/>;</span></pre><p id="8b07" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，我们在本节中为各种语句创建了节点。创建节点的逻辑已经介绍过了，所以我们可以直接写下代码。</p><p id="5fe2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看一看<code class="du mf mg mh lx b">init</code>。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="ee86" class="ld ju hi lx b fi mb mc l md me">init: '=' value { $$.nd = $2.nd; }<br/>| { $$.nd = mknode(NULL, NULL, "NULL"); }<br/>;</span></pre><p id="6d12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在来看看<code class="du mf mg mh lx b">expression</code>。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="cbdc" class="ld ju hi lx b fi mb mc l md me">expression: expression arithmetic expression { <br/>    $$.nd = mknode($1.nd, $3.nd, $2.name); <br/>}<br/>| value { $$.nd = $1.nd; }<br/>;</span></pre><p id="0589" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh lx b">value</code>是将添加到树中的另一个产品。但是，它将始终是一个叶节点。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="abd4" class="ld ju hi lx b fi mb mc l md me">value: NUMBER { add('C'); $$.nd = mknode(NULL, NULL, $1.name); }<br/>| FLOAT_NUM { add('C'); $$.nd = mknode(NULL, NULL, $1.name); }<br/>| CHARACTER { add('C'); $$.nd = mknode(NULL, NULL, $1.name); }<br/>| ID { $$.nd = mknode(NULL, NULL, $1.name); }<br/>;</span></pre><p id="1b80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们最终到达需要包含在我们的解析树中的最后一个产品，<code class="du mf mg mh lx b">return</code>。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="d01a" class="ld ju hi lx b fi mb mc l md me">return: RETURN { add('K'); } value ';' { <br/>    $1.nd = mknode(NULL, NULL, "return"); <br/>    $$.nd = mknode($1.nd, $3.nd, "RETURN"); <br/>}<br/>| { $$.nd = NULL; }<br/>;</span></pre><p id="4f8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的解析树最终被构建。我们所需要做的就是对树进行有序的遍历。</p><p id="1e34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3。抽象语法树的有序遍历</strong></p><p id="aeb2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们所要做的就是以一种有序的方式遍历树。inorder遍历的代码如下。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="2e7c" class="ld ju hi lx b fi mb mc l md me">void printInorder(struct node *tree) {<br/>    int i; <br/>    if (tree-&gt;left) {<br/>        printInorder(tree-&gt;left); <br/>    } <br/>    printf("%s, ", tree-&gt;token); <br/>    if (tree-&gt;right) {  <br/>        printInorder(tree-&gt;right); <br/>    }<br/>}</span></pre><p id="a2e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完整的代码如下所示。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="a799" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在需要做的就是编译并运行我们的编译器。这些命令是:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="5724" class="ld ju hi lx b fi mb mc l md me">yacc -v -d parser3.y<br/>lex lexer.l<br/>gcc -ll y.tab.c<br/>./a.out&lt;input1.c</span></pre><p id="b2d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">恭喜你！我们还成功地执行了语法分析，并通过我们的编译器生成了抽象语法树。也在你自己的C程序上测试一下。</p></div><div class="ab cl my mz gp na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hb hc hd he hf"><h1 id="c35c" class="jt ju hi bd jv jw nf jy jz ka ng kc kd ke nh kg kh ki ni kk kl km nj ko kp kq bi translated">第5部分:执行语义分析</h1><p id="8d2d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们现在将在编译器中实现语义阶段。这个阶段将检查类型转换、未声明的变量、变量的多重声明等。我们将打印错误(如果有的话)以及行号。隐式类型转换将显示在带注释的语法树或AST中。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ns"><img src="../Images/08e17ffb48a36a0aba428e948d9edc6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rqfkdUc8hRvay1dQmQY-TA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:<a class="ae iu" href="https://people.howstuffworks.com/semantics.htm" rel="noopener ugc nofollow" target="_blank"> HowStuffWorks </a></figcaption></figure><h2 id="68f1" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kh jk lm ln kl jo lo lp kp lq bi translated">向我们的编译器添加语义</h2><p id="df68" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们的语义分析器将涵盖4种类型的静态检查。</p><p id="2580" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 1。未声明的变量</strong></p><p id="4a30" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们使用<code class="du mf mg mh lx b">check_declaration()</code>函数检查作为参数传递的标识符是否出现在符号表中。如果没有，将打印一条错误消息，指出该变量尚未声明。除声明性语句外，每次在<code class="du mf mg mh lx b">statement</code>中遇到标识符时，都会调用检查声明函数。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="6c72" class="ld ju hi lx b fi mb mc l md me">void check_declaration(char *c) {    <br/>    q = search(c);    <br/>    if(!q) {        <br/>        sprintf(errors[sem_errors], "Line %d: Variable \"%s\" not declared before usage!\n", countn+1, c);  <br/>        sem_errors++;    <br/>    }<br/>}</span></pre><p id="fa89" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2。变量的多重声明</strong></p><p id="a08c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的编译器假设C程序只有一个作用域，因此，即使在循环中，变量也不能被重声明。对于该检查，修改<code class="du mf mg mh lx b">add()</code>函数，以在插入前检查符号是否出现在符号表中。如果该符号已经存在，并且属于<code class="du mf mg mh lx b">type</code>变量，则打印一条错误消息，通知用户该标识符有多个声明。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="f8f6" class="ld ju hi lx b fi mb mc l md me">if(c == 'V' &amp;&amp; q) {<br/>    sprintf(errors[sem_errors], "Line %d: Multiple declarations of \"%s\" not allowed!\n", countn+1, yytext);  <br/>    sem_errors++;    <br/>}</span></pre><p id="9f1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3。变量不是保留字</strong></p><p id="5af1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们通过查看变量是否属于保留关键字列表来执行简单的检查。这是在声明期间将它添加到符号表之前执行的。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="3ceb" class="ld ju hi lx b fi mb mc l md me">if(c == 'V') {  <br/>    for(int i=0; i&lt;10; i++) {   <br/>        if(!strcmp(reserved[i], strdup(yytext))) {<br/>            sprintf(errors[sem_errors], "Line %d: Variable name  \"%s\" is a reserved keyword!\n", countn+1, yytext);<br/>            sem_errors++;    <br/>            return;<br/>        }  <br/>    } <br/>}</span></pre><p id="cac2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码段被添加到<code class="du mf mg mh lx b">add()</code>函数中。</p><p id="6849" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 4。类型检查</strong></p><p id="2a91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，使用了<code class="du mf mg mh lx b">check_types</code>函数，它将两个变量的类型作为输入。如果类型匹配，则不采取任何操作。如果一个变量需要转换成另一个类型，那么在语法树中插入相应的类型转换节点(<code class="du mf mg mh lx b">inttofloat</code>或<code class="du mf mg mh lx b">floattoint</code>)。将<code class="du mf mg mh lx b">type</code>字段添加到表示值和表达式标记的结构中，以跟踪复合表达式的类型。结果，一个名为<code class="du mf mg mh lx b">nd_obj2</code>的新结构被创建。这个阶段的<strong class="ix hj">输出是带注释的语法树</strong>。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="dd8e" class="ld ju hi lx b fi mb mc l md me">int check_types(char *type1, char *type2) { <br/>    // declaration with no init <br/>    if(!strcmp(type2, "null")) return -1; <br/>    // both datatypes are same <br/>    if(!strcmp(type1, type2)) return 0; <br/>    // both datatypes are different <br/>    if(!strcmp(type1, "int") &amp;&amp; !strcmp(type2, "float")) return 1;<br/>    if(!strcmp(type1, "float") &amp;&amp; !strcmp(type2, "int")) return 2;<br/>    if(!strcmp(type1, "int") &amp;&amp; !strcmp(type2, "char")) return 3;<br/>    if(!strcmp(type1, "char") &amp;&amp; !strcmp(type2, "int")) return 4;<br/>    if(!strcmp(type1, "float") &amp;&amp; !strcmp(type2, "char")) return 5;<br/>    if(!strcmp(type1, "char") &amp;&amp; !strcmp(type2, "float")) return 6;<br/>}</span></pre><p id="8104" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">变量初始化期间，返回的值用于<code class="du mf mg mh lx b">statement</code>生产。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="df2a" class="ld ju hi lx b fi mb mc l md me">statement: datatype ID { add('V'); } init {<br/>    $2.nd = mknode(NULL, NULL, $2.name);  <br/>    int t = check_types($1.name, $4.type);  <br/>    if(t&gt;0) {   <br/>        if(t == 1) {    <br/>            struct node *temp = mknode(NULL, $4.nd, "floattoint");<br/>            $$.nd = mknode($2.nd, temp, "declaration");   <br/>        }   <br/>        else if(t == 2) {<br/>            struct node *temp = mknode(NULL, $4.nd, "inttofloat");<br/>            $$.nd = mknode($2.nd, temp, "declaration");   <br/>        }   <br/>        else if(t == 3) {    <br/>            struct node *temp = mknode(NULL, $4.nd, "chartoint");<br/>            $$.nd = mknode($2.nd, temp, "declaration");   <br/>        }   <br/>        else if(t == 4) {    <br/>            struct node *temp = mknode(NULL, $4.nd, "inttochar");<br/>            $$.nd = mknode($2.nd, temp, "declaration");   <br/>        }   <br/>        else if(t == 5) {    <br/>            struct node *temp = mknode(NULL, $4.nd, "chartofloat");<br/>            $$.nd = mknode($2.nd, temp, "declaration");   <br/>        }   <br/>        else {   <br/>            struct node *temp = mknode(NULL, $4.nd, "floattochar");<br/>            $$.nd = mknode($2.nd, temp, "declaration");   <br/>        }<br/>    }<br/>    else {   <br/>        $$.nd = mknode($2.nd, $4.nd, "declaration");  <br/>    } <br/>}</span></pre><p id="32a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">语句产生的其余部分将在下面讨论。</p><p id="7f47" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们已经定义了另一个名为<code class="du mf mg mh lx b">get_type</code>的函数，它将用于剩余的<code class="du mf mg mh lx b">statement</code>生产。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="4261" class="ld ju hi lx b fi mb mc l md me">char *get_type(char *var) { <br/>    for(int i=0; i&lt;count; i++) {  <br/>        if(!strcmp(symbol_table[i].id_name, var)) {   <br/>            return symbol_table[i].data_type;  <br/>        }<br/>    }<br/>}</span></pre><p id="d71f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们对<code class="du mf mg mh lx b">statement</code>中的第二个产品进行了如下修改。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="169c" class="ld ju hi lx b fi mb mc l md me">statement: ID { check_declaration($1.name); } '=' expression { <br/>  $1.nd = mknode(NULL, NULL, $1.name);  <br/>  char *id_type = get_type($1.name);  <br/>  if(strcmp(id_type, $4.type)) {  <br/>    if(!strcmp(id_type, "int")) {   <br/>      if(!strcmp($4.type, "float")) {    <br/>        struct node *temp = mknode(NULL, $4.nd, "floattoint");<br/>        $$.nd = mknode($1.nd, temp, "=");    <br/>      }   <br/>      else {    <br/>        struct node *temp = mknode(NULL, $4.nd, "chartoint");<br/>        $$.nd = mknode($1.nd, temp, "=");    <br/>      }     <br/>    }  <br/>    else if(!strcmp(id_type, "float")) {   <br/>      if(!strcmp($4.type, "int")) {    <br/>        struct node *temp = mknode(NULL, $4.nd, "inttofloat");<br/>        $$.nd = mknode($1.nd, temp, "=");    <br/>      }   <br/>      else {    <br/>        struct node *temp = mknode(NULL, $4.nd, "chartofloat");<br/>        $$.nd = mknode($1.nd, temp, "=");    <br/>      }     <br/>    }  <br/>    else {   <br/>      if(!strcmp($4.type, "int")) {    <br/>        struct node *temp = mknode(NULL, $4.nd, "inttochar");<br/>        $$.nd = mknode($1.nd, temp, "=");    <br/>      }   <br/>      else {    <br/>        struct node *temp = mknode(NULL, $4.nd, "floattochar");<br/>        $$.nd = mknode($1.nd, temp, "=");    <br/>      }<br/>    } <br/>  } <br/>  else {  <br/>    $$.nd = mknode($1.nd, $4.nd, "=");  <br/>  }<br/>}</span></pre><p id="cd26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在给变量赋值<code class="du mf mg mh lx b">expression</code>时执行类型转换。</p><p id="f5de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，对于<code class="du mf mg mh lx b">expression</code>，我们也必须检查类型转换。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="ce02" class="ld ju hi lx b fi mb mc l md me">expression: expression arithmetic expression {  <br/>    if(!strcmp($1.type, $3.type)) {  <br/>        sprintf($$.type, $1.type);  <br/>        $$.nd = mknode($1.nd, $3.nd, $2.name);  <br/>    } <br/>    else {  <br/>        if(!strcmp($1.type, "int") &amp;&amp; !strcmp($3.type, "float")) {<br/>            struct node *temp = mknode(NULL, $1.nd, "inttofloat");<br/>            sprintf($$.type, $3.type);   <br/>            $$.nd = mknode(temp, $3.nd, $2.name);  <br/>        }  <br/>        else if(!strcmp($1.type, "float") &amp;&amp; !strcmp($3.type, "int")) {   <br/>            struct node *temp = mknode(NULL, $3.nd, "inttofloat");<br/>            sprintf($$.type, $1.type);   <br/>            $$.nd = mknode($1.nd, temp, $2.name);  <br/>        }  <br/>        else if(!strcmp($1.type, "int") &amp;&amp; !strcmp($3.type, "char")){   <br/>            struct node *temp = mknode(NULL, $3.nd, "chartoint");<br/>            sprintf($$.type, $1.type);   <br/>            $$.nd = mknode($1.nd, temp, $2.name);  <br/>        }  <br/>        else if(!strcmp($1.type, "char") &amp;&amp; !strcmp($3.type, "int")) {   <br/>            struct node *temp = mknode(NULL, $1.nd, "chartoint");<br/>            sprintf($$.type, $3.type);   <br/>            $$.nd = mknode(temp, $3.nd, $2.name);  <br/>        }  <br/>        else if(!strcmp($1.type, "float") &amp;&amp; !strcmp($3.type, "char")) {   <br/>            struct node *temp = mknode(NULL, $3.nd, "chartofloat");<br/>            sprintf($$.type, $1.type);   <br/>            $$.nd = mknode($1.nd, temp, $2.name);  <br/>        }  <br/>        else {   <br/>            struct node *temp = mknode(NULL, $1.nd, "chartofloat");<br/>            sprintf($$.type, $3.type);   <br/>            $$.nd = mknode(temp, $3.nd, $2.name);  <br/>        } <br/>    }<br/>}<br/>| value { <br/>    strcpy($$.name, $1.name); <br/>    sprintf($$.type, $1.type); <br/>    $$.nd = $1.nd; <br/>}<br/>;</span></pre><p id="bb48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦完成了这些更改，我们就完成了语义阶段。需要注意的一点是，我们有一个名为<code class="du mf mg mh lx b">sem_errors</code>的变量，它跟踪代码中出现的语义错误。这在我们的Yacc程序的<code class="du mf mg mh lx b">main</code>函数中用来打印相关的消息。</p><p id="9011" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面给出了实现语义阶段后的最终代码。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="ffb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在需要做的就是编译并运行我们的编译器。这些命令是:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="d211" class="ld ju hi lx b fi mb mc l md me">yacc -v -d parser4.y<br/>lex lexer.l<br/>gcc -ll y.tab.c<br/>./a.out&lt;input1.c</span></pre><p id="9ff7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du mf mg mh lx b">input1.c</code>在本系列的第3部分中提供。</p><p id="a744" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们终于完成了编译器的语义阶段！剩下的就是中间代码生成，然后我们就完成了自己的C编译器的前端阶段。</p></div><div class="ab cl my mz gp na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hb hc hd he hf"><h1 id="e29c" class="jt ju hi bd jv jw nf jy jz ka ng kc kd ke nh kg kh ki ni kk kl km nj ko kp kq bi translated">第6部分:中间代码生成</h1><h2 id="c728" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kh jk lm ln kl jo lo lp kp lq bi translated">介绍</h2><p id="adf5" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们现在讨论编译器前端的最后一个阶段——中间代码生成。为此，使用三个地址码表示。变量用于跟踪下一个临时变量和要生成的标签。<code class="du mf mg mh lx b">if</code>和<code class="du mf mg mh lx b">for</code>的<code class="du mf mg mh lx b">condition</code>语句也被声明为根据条件是否满足来存储要转到的标签。这一步的输出是中间代码。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nt"><img src="../Images/e866e1a73c5335e49394afb581ab064c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81oVjlRcufPVKjZ2kuWXqg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在<a class="ae iu" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae iu" href="https://unsplash.com/@ffstop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></figcaption></figure><h2 id="0838" class="ld ju hi bd jv le lf lg jz lh li lj kd jg lk ll kh jk lm ln kl jo lo lp kp lq bi translated">中间代码生成</h2><p id="2560" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了实现这一点，将创建第三个结构，称为<code class="du mf mg mh lx b">nd_obj3</code>。它有以下细节。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="2d57" class="ld ju hi lx b fi mb mc l md me">struct var_name3 {<br/>   char name[100];<br/>   struct node* nd;<br/>   char if_body[5];<br/>   char else_body[5];  <br/>} nd_obj3;</span></pre><p id="152d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在也声明<code class="du mf mg mh lx b">condition</code>是<code class="du mf mg mh lx b">nd_obj3</code>类型的。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="b81b" class="ld ju hi lx b fi mb mc l md me">%type &lt;nd_obj3&gt; condition</span></pre><p id="ea9e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除此之外，我们还必须跟踪正在使用的临时变量、标签计数器以及检查代码块是<code class="du mf mg mh lx b">for</code>还是<code class="du mf mg mh lx b">if-else</code>的标志。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="d18a" class="ld ju hi lx b fi mb mc l md me">int temp_var=0; <br/>int label=0; <br/>int is_for=0;</span></pre><p id="9003" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们继续打印程序的中间代码。让我们来看看<code class="du mf mg mh lx b">for</code>回路。之后，我们可以将相同的逻辑扩展到整个程序。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="b2da" class="ld ju hi lx b fi mb mc l md me">body: FOR { add('K'); is_for = 1; } '(' statement ';' condition ';' statement ')' '{' body '}' {  <br/>    struct node *temp = mknode($6.nd, $8.nd, "CONDITION");  <br/>    struct node *temp2 = mknode($4.nd, temp, "CONDITION");  <br/>    $$.nd = mknode(temp2, $11.nd, $1.name);  <br/>    sprintf(icg[ic_idx++], buff); <br/>    sprintf(icg[ic_idx++], "JUMP to %s\n", $6.if_body);<br/>    sprintf(icg[ic_idx++], "\nLABEL %s:\n", $6.else_body);<br/>}</span></pre><p id="e879" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，<code class="du mf mg mh lx b">if_body</code>和<code class="du mf mg mh lx b">else_body</code>是什么，我们的<code class="du mf mg mh lx b">condition</code>设置在哪里？让我们来看看。<code class="du mf mg mh lx b">if_body</code>和<code class="du mf mg mh lx b">else_body</code>存储标签，根据我们的条件结果，控件应该被重定向到这些标签。</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="6db2" class="ld ju hi lx b fi mb mc l md me">condition: value relop value {  <br/>    $$.nd = mknode($1.nd, $3.nd, $2.name);  <br/>    if(is_for) {  <br/>        sprintf($$.if_body, "L%d", label++);  <br/>        sprintf(icg[ic_idx++], "\nLABEL %s:\n", $$.if_body);<br/>        sprintf(icg[ic_idx++], "\nif NOT (%s %s %s) GOTO L%d\n", $1.name, $2.name, $3.name, label);  <br/>        sprintf($$.else_body, "L%d", label++); <br/>    } <br/>    else {  <br/>        sprintf(icg[ic_idx++], "\nif (%s %s %s) GOTO L%d else GOTO L%d\n", $1.name, $2.name, $3.name, label, label+1);<br/>        sprintf($$.if_body, "L%d", label++);  <br/>        sprintf($$.else_body, "L%d", label++); <br/>    }<br/>}<br/>| TRUE { add('K'); $$.nd = NULL; }<br/>| FALSE { add('K'); $$.nd = NULL; }<br/>| { $$.nd = NULL; };</span></pre><p id="2ee9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们修改<code class="du mf mg mh lx b">condition</code>产品来存储关于中间代码的细节。<code class="du mf mg mh lx b">if_body</code>和<code class="du mf mg mh lx b">else_body</code>存储控件必须重定向的标签，而我们将实际打印存储在一个名为<code class="du mf mg mh lx b">icg</code>的字符缓冲区中。这里，我们使用了<code class="du mf mg mh lx b">is_for</code>来区分<code class="du mf mg mh lx b">for</code>和<code class="du mf mg mh lx b">if-else</code>，因为需要生成的中间代码略有不同。</p><p id="2c15" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，我们将更多关于ICG的语句添加到这个缓冲区中，并最终打印出来。下面是完整的代码。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="nl nm l"/></div></figure><p id="4854" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在需要做的就是编译并运行我们的编译器。这些命令是:</p><pre class="ls lt lu lv fd lw lx ly lz aw ma bi"><span id="eb9f" class="ld ju hi lx b fi mb mc l md me">yacc -v -d parser5.y<br/>lex lexer.l<br/>gcc -ll y.tab.c<br/>./a.out&lt;input1.c</span></pre><h1 id="bd3d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="d855" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">哒哒！我们已经成功地制作了自己的C编译器，并实现了它的前端阶段。我们从一个简单的词法分析器开始，随着我们在这个系列中的进展，我们添加了更多的特性，最终有了一个实现前端阶段的合适的编译器。学习什么是编译器，它是如何工作的，并最终亲手构建一个编译器，这是一个令人惊奇的旅程。希望你们都玩得开心，再见！</p></div><div class="ab cl my mz gp na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hb hc hd he hf"><p id="ef82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个项目的完整代码可以在我的GitHub上找到。如果你觉得它有帮助，请开始吧！⭐️</p><div class="nu nv ez fb nw nx"><a href="https://github.com/AnjaneyaTripathi/c-compiler" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab dw"><div class="nz ab oa cl cj ob"><h2 class="bd hj fi z dy oc ea eb od ed ef hh bi translated">GitHub-AnjaneyaTripathi/c-compiler:一个自定义编译器，接受for循环，if else语句…</h2><div class="oe l"><h3 class="bd b fi z dy oc ea eb od ed ef dx translated">一个自定义编译器，它接受for循环、if else语句和嵌套出现的相同语句，并打印…</h3></div><div class="of l"><p class="bd b fp z dy oc ea eb od ed ef dx translated">github.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol io nx"/></div></div></a></div><p id="dfc1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请随时在LinkedIn上与我联系！</p><div class="nu nv ez fb nw nx"><a href="https://www.linkedin.com/in/anjaneya-tripathi-610234183/" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab dw"><div class="nz ab oa cl cj ob"><h2 class="bd hj fi z dy oc ea eb od ed ef hh bi translated">软件开发人员——蜘蛛R&amp;D | LinkedIn</h2><div class="oe l"><h3 class="bd b fi z dy oc ea eb od ed ef dx translated">查看Anjaneya Tripathi在全球最大的职业社区LinkedIn上的个人资料。Anjaneya有6份工作列在…</h3></div><div class="of l"><p class="bd b fp z dy oc ea eb od ed ef dx translated">www.linkedin.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol io nx"/></div></div></a></div></div></div>    
</body>
</html>