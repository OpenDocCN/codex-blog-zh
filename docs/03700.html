<html>
<head>
<title>Extend Backend Application With WebAssembly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用WebAssembly扩展后端应用程序</h1>
<blockquote>原文：<a href="https://medium.com/codex/extend-backend-application-with-webassembly-ba19c17016d3?source=collection_archive---------2-----------------------#2021-09-17">https://medium.com/codex/extend-backend-application-with-webassembly-ba19c17016d3?source=collection_archive---------2-----------------------#2021-09-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c37d26ae5fe8e202d100b9cbd41ab15b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEuMJWtUlTzzmkqO_CAGGg.png"/></div></div></figure><h1 id="8464" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">1.WebAssembly简介</h1><p id="1d31" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">随着互联网的演进，越来越多的应用借助JavaScript迁移到web上，但人们也注意到，下载、解析、编译JavaScript需要耗费大量时间，导致页面加载时间过长，最终造成用户流失。</p><p id="4c3c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了解决这些问题，来自Mozilla的工程师Alon Zakai在2012年提出了Asm.js。经过几年的发展，终于在2015年演变成了WebAssembly。</p><blockquote class="kr ks kt"><p id="90da" class="jo jp ku jq b jr km jt ju jv kn jx jy kv ko kb kc kw kp kf kg kx kq kj kk kl hb bi translated">WebAssembly(缩写为Wasm)是基于堆栈的虚拟机的二进制指令格式。Wasm被设计为编程语言的可移植编译目标，支持客户端和服务器应用程序在web上的部署。</p></blockquote><p id="c74b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这是webassembly.org官方对WebAssembly的定义。从这个定义可以看出，WebAssembly是一种二进制指令格式。但是WebAssembly文本格式也经常被称为WebAssembly，而事实上，这种文本格式是一种编程语言。</p><p id="d098" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在官方宣布之后，WebAssembly得到了快速发展。到2017年11月，Mozilla宣布所有主流浏览器包括Chrome、Firefox、Safari等。支持WebAssembly。并且根据2021年7月的数据，正在使用的浏览器中，94%已经支持WebAssembly。</p><p id="8374" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在得到浏览器的广泛支持后，一些重量级的应用也逐渐移植到了Web上，包括:</p><ul class=""><li id="ce44" class="kz la hi jq b jr km jv kn jz lb kd lc kh ld kl le lf lg lh bi translated"><a class="ae ky" href="https://earth.google.com/web/" rel="noopener ugc nofollow" target="_blank">谷歌地球</a>——一款主要基于卫星图像呈现地球三维图像的软件。</li><li id="e118" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><a class="ae ky" href="https://web.autocad.com/" rel="noopener ugc nofollow" target="_blank"> AutoCAD </a> —计算机辅助设计和绘图软件应用。这是一个运行在带有内部图形控制器的微型计算机上的桌面应用程序。</li><li id="f4f6" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated">毁灭——一款由第一人称射击游戏组成的视频游戏</li><li id="bbba" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><a class="ae ky" href="https://blog.tensorflow.org/2020/03/introducing-webassembly-backend-for-tensorflow-js.html" rel="noopener ugc nofollow" target="_blank">tensor flow</a>——机器学习和人工智能的免费开源软件库。</li></ul><p id="31b1" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这些案例也表明WebAssembly已经达到了它的设计目标——支持桌面应用程序在web上的部署。</p><p id="83e5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">WebAssembly的快速发展源于其特殊的特性:</p><ul class=""><li id="ede4" class="kz la hi jq b jr km jv kn jz lb kd lc kh ld kl le lf lg lh bi translated"><strong class="jq hj">近乎本机的性能</strong>:基准测试显示，它只比本机代码慢10%左右。</li><li id="e2ef" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><strong class="jq hj">尺寸小，加载快</strong>，WebAssembly是一种紧凑的二进制格式，通常比同等的Javascript代码小得多。</li><li id="0f3b" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><strong class="jq hj">安全稳妥</strong>，WebAssembly代码运行在沙箱中，默认不允许外部访问。</li><li id="9c67" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><strong class="jq hj">支持多种语言</strong>。WebAssembly不限制用户用于开发的语言。只要有相应的编译器，任何语言都可以编译成WebAssembly。</li></ul><h1 id="e279" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">2.后端的web程序集</h1><p id="7c2f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在WebAssembly的官方定义中，短语“<em class="ku">for a stack-based virtual machine</em>”也值得关注，因为它引领了WebAssembly这种原本是为Web而设计的技术，并且名称中包含“Web”一词，最终进入后端领域。</p><p id="f9b2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这是因为，从早期的VMWare WorkStation和VirtualBox到今天的Docker，虚拟化技术一直是云计算的基础。因此，WebAssembly作为一种具有诸多优势的虚拟机代码格式，进入后端应用领域是必然趋势。Docker的创始人Solomon Hykes在2019年表示，“<em class="ku">如果WASM+WASI在2008年就存在，我们就不需要创建Docker </em>”，这显示了后端应用采用WebAssembly的前景。</p><p id="230b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">当然，Solon Hykes说的并不是指“WebAssembly会在稍晚的时候取代Docker”。这也是当今业界的普遍观点:WebAssembly和Docker各有优势，互为补充。具体来说:</p><ul class=""><li id="420b" class="kz la hi jq b jr km jv kn jz lb kd lc kh ld kl le lf lg lh bi translated">WebAssembly程序的大小通常在1M左右，而Docker镜像往往轻松超过100M，因此WebAssembly的加载速度要快得多。</li><li id="8ed8" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated">WebAssembly程序的冷启动速度比Docker容器快大约100倍。</li><li id="00cd" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated">WebAssembly运行在沙盒中，任何与外界的交互都要获得显式的权限后才能进行，安全性极佳。</li><li id="cdfc" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated">WebAssembly模块只是一个二进制程序，不包含操作系统环境，所以不能像我们在Docker中可以做的那样，在编译后执行。</li></ul><p id="20d9" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接下来，让我们通过例子来了解WebAssembly在后端的用法。</p><h1 id="8795" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">2.1.在应用程序中嵌入WebAssembly</h1><p id="0f48" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如下图所示，无论是web应用还是非web应用，我们都需要在宿主程序中嵌入WebAssembly运行时来使用WebAssembly。唯一不同的是，在web应用中，宿主程序是浏览器，而在非web场景中，宿主程序是我们自己的应用，具体到本文重点讨论的后端应用，宿主程序是我们的后端服务。</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/6991352a48265de672e75cfca3b55bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kJy31LcnK8ss5sVE"/></div></div></figure><p id="7db3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">目前可用的WebAssembly运行时包括<a class="ae ky" href="https://wasmtime.dev/" rel="noopener ugc nofollow" target="_blank"> Wasmtime </a>、<a class="ae ky" href="https://wasmedge.org/" rel="noopener ugc nofollow" target="_blank"> WasmEdge </a>、<a class="ae ky" href="https://wavm.org/" rel="noopener ugc nofollow" target="_blank"> WAVM </a>、<a class="ae ky" href="https://wasmer.io/" rel="noopener ugc nofollow" target="_blank"> Wasmer </a>等。，各有利弊。本文将以Wasmtime为例，介绍如何在用Go语言开发的宿主程序中嵌入WebAssembly。</p><p id="408c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">嵌入WebAssembly运行时和实例化WebAssembly模块非常简单，下面几行代码完成了所有这些工作(如果忽略错误处理的话)。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="6221" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">但这段代码片段涉及几个重要概念，简单介绍如下:</p><ul class=""><li id="196d" class="kz la hi jq b jr km jv kn jz lb kd lc kh ld kl le lf lg lh bi translated"><strong class="jq hj">引擎</strong>:wasm模块编译和管理的全局上下文。</li><li id="5e94" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><strong class="jq hj">模块</strong>:编译后的WebAssembly模块。这个结构表示在被实例化后准备执行的内存中JIT代码。</li><li id="b20a" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><strong class="jq hj">存储</strong>:所有的WebAssembly对象和主机值都将“连接”到一个存储。</li><li id="f909" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><strong class="jq hj">实例</strong>:一个实例化的WebAssembly模块，在这里你可以实际获取一个函数，比如调用。在实例化的时候，模块的启动函数被调用。</li><li id="6f23" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated"><strong class="jq hj">链接器</strong>(仅限Wasmtime):将wasm模块/实例链接在一起的助手结构。</li></ul><p id="cd87" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">虽然上面的代码创建了一个WebAssembly模块的实例，并且根据WebAssembly规范，会执行start函数。但是由于安全限制，执行结果无法输出，所以“执行”是没有用的。因此，我们需要实现宿主程序和WebAssembly程序之间的互操作性，并为WebAssembly程序提供输入/输出接口。</p><h1 id="876f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">2.2.宿主调用WebAssembly</h1><p id="bb27" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">假设我们的WebAssembly程序有一个名为sum的函数，它接收两个整数变量作为参数并返回它们的和，宿主程序可以使用以下代码来调用此函数:</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="6717" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">虽然具体的调用方法与宿主程序的编程语言和所使用的WebAssembly运行时不同，但是运行时的文档通常都有相关的说明，所以按照文档就可以了。</p><p id="a006" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这里的难点是如何从WebAssembly程序中导出sum函数，以便宿主程序可以找到并调用它。如前所述，只要有编译器，任何语言都可以编译成WebAssembly，但大多数语言的设计都没有考虑WebAssembly的需求，也没有办法导出WebAssembly中的函数。所以这个问题只能通过特定编译器的非标准扩展来解决。换句话说，找到这个非标准的扩展是解决问题最关键的一步。但是，也由于“不规范”，相关信息往往不容易获得。</p><p id="5e7e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">下面举例说明如何在C/C++(使用Emscripten作为编译器)和AssemblyScript中导出函数:</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="05bd" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">2.3.WebAssembly调用主机</h1><p id="569e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">类似于宿主调用WebAssembly，WebAssembly运行时的文档通常描述宿主如何将函数导出到WebAssembly程序。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="8118" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">问题的难点还在于如何使用语言的非标准扩展在WebAssembly程序中导入这个函数。以下是C/C++和AssemblyScript中的具体方法:</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="c756" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">2.4.非原始参数</h1><p id="b9c9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当宿主和WebAssembly程序调用对方的函数时，也需要传递参数和返回值。如果是整数之类的原语数据类型，直接传递就好了。但是，当参数或返回值是非原始类型(如字符串)时，我们会遇到新的问题:</p><ul class=""><li id="8513" class="kz la hi jq b jr km jv kn jz lb kd lc kh ld kl le lf lg lh bi translated">宿主程序和WebAssembly程序的编程语言一般不一样，所以非原语参数的内存布局也不一样。如果直接传递，接收者根本无法理解，更不用说使用了。</li><li id="9ed4" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated">由于安全设计，主机程序和WebAssembly程序的内存是隔离的，WebAssembly程序无法访问主机的内存。</li></ul><p id="a4a7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因为宿主程序可以访问WebAssembly的内存，所以第二个问题的解决方案是WebAssembly程序导出内存管理函数，使宿主能够操纵其内存，例如:</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="ae39" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">之后，我们可以利用这些内存管理函数通过相关数据类型的封送/解封来传递参数/返回值。例如，下面的WebAssembly函数调用一个主机函数，参数和返回值最初都是字符串，但是在封送/解封之后，我们将字符串转换为WebAssembly内存中的地址(整数):</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="9514" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">2.5.软件开发工具包(Software Development Kit)</h1><p id="b963" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在经历了宿主程序和WebAssembly程序互操作的过程后，相信你已经发现它和RPC调用的过程非常相似。不同的是，在RPC调用中，枯燥的封送/解封操作是由相关工具自动生成的代码完成的，用户根本不需要关心</p><p id="a32a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在WebAssembly应用程序的开发中，用户也不希望处理这么多的细节。因此，作为主机程序的开发者，我们需要为用户提供相关的SDK来隐藏底层细节，以便用户可以专注于业务逻辑的开发。</p><p id="035b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">由于用户可以用多种语言开发WebAssembly应用程序，我们需要为不同的语言提供SDK，或者至少为用户使用的主要语言提供SDK。</p><h1 id="53e8" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">2.6.宿主处理WebAssembly中的错误</h1><p id="12fb" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">和其他程序一样，WebAssembly程序也会有各种bug。虽然，作为一个主机程序开发者，我们无法预测一个具体的bug，但是我们必须限制这些bug对WebAssembly虚拟机的影响，防止它们影响主机。</p><p id="1a99" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">宿主程序必须防止的第一类错误是无限循环。实际上，宿主程序没有办法知道是否存在无限循环。因此，折衷的解决方案是为WebAssembly程序设置一个超时持续时间。一旦超过这个持续时间，我们就认为存在一个无限循环，并终止WebAssembly程序的执行。终止执行的代码如下:</p><p id="58de" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj"> ih，_ := store。中断句柄()<br/> ih。中断()</strong></p><h1 id="cc25" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">3.Easegress中的WebAssembly</h1><p id="73ac" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><a class="ae ky" href="https://github.com/megaease/easegress" rel="noopener ugc nofollow" target="_blank"> Easegress </a>是由<a class="ae ky" href="https://github.com/megaease" rel="noopener ugc nofollow" target="_blank"> MegaEase </a>开发的下一代流量网关，是云原生的、高可用的、可观察的、可扩展的。在Easegress之前，市场上已经有很多成熟的网关产品，包括Nginx。然而，MegaEase认为网关不仅仅是一个反向代理，还需要能够协调和调度流量。此外，还涉及到各种业务逻辑入侵，因此它也必须具有高度的可扩展性。</p><p id="8cd1" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">基于以上观点，MegaEase从Easegress开发的第一天起就把可扩展性作为一个重要的需求，并在几个方面进行了相关的设计。</p><p id="844b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">首先，是开发语言的选择。</p><ul class=""><li id="aa6b" class="kz la hi jq b jr km jv kn jz lb kd lc kh ld kl le lf lg lh bi translated">使用C/C++或者Rust肯定会给Easegress带来最好的性能，但是这些语言太硬，用户很难掌握，所以如果选择了这些语言，他们是不可能通过修改代码来扩展业务逻辑的。</li><li id="7c3d" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated">Java易学易用，生产力非常好。但其尺寸和性能不能满足要求；</li><li id="7343" class="kz la hi jq b jr li jv lj jz lk kd ll kh lm kl le lf lg lh bi translated">相对来说，Go简单易学，性能更好，尤其是在Easegress针对的网络应用领域，因为设计优秀，Go和C++的性能差距往往可以忽略不计。所以Easegress选择Go作为开发语言。但是不管使用什么语言，源代码级的扩展都不可避免地会将用户限制在特定的语言上，并且会涉及重新编译、重新部署和重新启动，从而导致服务中断。</li></ul><p id="db24" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">第二种提供可扩展性的方法是FaaS，Easegress已经支持FaaS。FaaS不限制用户的开发语言，也具有良好的可扩展性。缺点是严重依赖Kubernetes等外部依赖，带来了操作的复杂性。</p><p id="8abc" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">第三种方法是嵌入一个解释器。起初，我们把重点放在Lua上，这是一种为嵌入到其他程序中而设计的语言，但是在详细评估之后，我们认为Lua有两个弱点。一个是表达能力不够，不适合写复杂的业务逻辑；另一个就是人气不够，很难找到有相关经验的程序员。因此，Easegress决定嵌入WebAssembly，主要基于两点考虑:一是近乎原生的性能；二是它不限制用户的开发语言，用户可以使用自己喜欢或熟悉的语言来开发业务逻辑。</p><p id="9280" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">作为用WebAssembly扩展业务逻辑的例子，我们发布了“<a class="ae ky" href="https://github.com/megaease/easegress/blob/main/doc/cookbook/flash_sale.md" rel="noopener ugc nofollow" target="_blank">用Easegress和WebAssembly </a>处理闪购”。如果您有任何反馈，请随时告诉我们，并欢迎向我们提供更多的用例。</p><p id="7645" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">正如我上面提到的，选择WebAssembly意味着我们需要为多种语言开发SDK。我们已经完成了汇编脚本的<a class="ae ky" href="https://github.com/megaease/easegress-assemblyscript-sdk" rel="noopener ugc nofollow" target="_blank"> SDK的开发。我们相信，通过MegaEase和整个开源社区的努力，我们可以在不久的将来支持越来越多的语言。</a></p></div></div>    
</body>
</html>