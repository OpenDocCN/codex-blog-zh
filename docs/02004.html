<html>
<head>
<title>Finding the Underlying Value of a Stock with a Simple Approach in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python中的一种简单方法寻找股票的潜在价值</h1>
<blockquote>原文：<a href="https://medium.com/codex/finding-the-underlying-value-of-a-stock-with-a-simple-approach-in-python-514d18df2758?source=collection_archive---------4-----------------------#2021-06-22">https://medium.com/codex/finding-the-underlying-value-of-a-stock-with-a-simple-approach-in-python-514d18df2758?source=collection_archive---------4-----------------------#2021-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b3cc" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">关于用Python实现CCA方法评估股票的简单指南</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/63e2f611084921beca8cd529eac72f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jX2KaFBibxEj3psT"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由乔纳斯·德尼尔在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ad37" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所有在股票市场上市的股票都不是按照其内在价值进行交易，而是高于或低于其内在价值。但是，有了一些金融概念和基本面分析的基本知识，我们可以很容易地计算出一家公司股票的基础价格或实际价格，并据此进行投资。有很多方法可以完成这项工作，但在本文中，我们将采用一种简单而有效的方法，即可比公司分析，简称CCA。我们将首先探索CCA方法是什么，然后，我们将继续到编程部分，我们将使用Python编写完整的方法，并找到苹果股票的内在价值。事不宜迟，让我们进入文章吧！</p><p id="7f2c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在继续阅读本文之前，请确保您熟悉以下财务概念:收入、市值、企业价值(EV)、市盈率、EBITDA、EBIT，以及一些Python编程的基础知识。</p><h1 id="c312" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">可比公司分析(CCA)</h1><p id="e246" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">可比公司分析是通过比较同行业其他类似公司股票的财务指标来评估股票潜在价值的过程。这种方法的基本思想是相似的公司有相似的指标。为了使这种方法成功，我们必须以正确的方式做两件事:</p><ul class=""><li id="737f" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated"><strong class="jq hj">汇集相似的公司:</strong>这是我们遵循CCA方法时必须完成的首要任务。CCA就是将一只股票与一堆其他股票进行比较，我们必须选择正确的相似股票。否则，我们可能会高估或低估股票。例如，如果我们试图计算特斯拉的内在价值，我们必须考虑只属于汽车行业的股票，而不是其他行业的股票，如苹果或英特尔。</li><li id="005f" class="lh li hi jq b jr lq ju lr jx ls kb lt kf lu kj lm ln lo lp bi translated"><strong class="jq hj">选择正确的估值倍数:</strong>这就是挑选用于比较股票的指标的过程。就像选择股票的第一个过程一样，选择错误的倍数可能会导致低估或高估股票。最常用的倍数是市盈率、EV/EBITDA等等。</li></ul><p id="50de" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本文中，我们将确定苹果股票的内在价值，方法是首先汇集属于技术板块的正确的类似股票，并考虑估值倍数P/E比率、EV/EBITDA、EV/EBIT和EV/收入。这就是关于共同国家评估方法的全部内容。现在，让我们继续编程，我们将使用Python对整个方法进行编码。在继续之前，关于免责声明的一个注意事项:本文的唯一目的是教育人们，必须被视为一个信息，而不是投资建议等。</p><h1 id="2d34" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">用Python实现</h1><p id="6849" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">编码部分可以分为如下不同的步骤:</p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="09a6" class="ma kl hi lw b fi mb mc l md me"><strong class="lw hj">1. Importing Packages<br/>2. Extracting the Financial Metrics with IEX Cloud<br/>3. Formatting the Extracted Data<br/>4. Calculating the Valuation Multiples<br/>5. Calculating the Average and Difference of Multiples<br/>6. Determining the Underlying Value</strong></span></pre><p id="d49f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h2 id="b5a3" class="ma kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤1:导入包</h2><p id="ec9c" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包将会是Pandas来处理数据帧、数据操作等等，请求进行API调用，NumPy来处理数组和科学函数。第二个包是用于字体定制的Termcolor(可选的，但是很好用)。让我们将所有这些包导入到Python环境中。</p><p id="0a76" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="c5c2" class="ma kl hi lw b fi mb mc l md me"><strong class="lw hj"># IMPORTING PACKAGES<br/></strong><br/>import pandas as pd<br/>import requests<br/>import numpy as np<br/>from termcolor import colored as cl</span></pre><p id="901f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经将所有需要的包导入到python中。让我们用IEX云强大的API端点来拉一些科技股和苹果的财务指标。</p><h2 id="35f9" class="ma kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤2: <strong class="ak">用IEX云提取财务指标</strong></h2><p id="fa6f" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将借助IEX云提供的几个API端点，提取十只科技股(微软、亚马逊、谷歌、脸书、阿里巴巴、英伟达、PayPal、英特尔、网飞和苹果)的财务指标(股价、市值、市盈率、EBITDA、EBIT、收入和企业价值)。</p><p id="e6b3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">这里有一个关于IEX云的说明:</strong> IEX云提供了大量的API端点，包括股票、商品、外汇、期权和加密货币的市场数据。数据是可靠的，在任何编程语言中使用它们的API都很容易。API带有高度可定制的参数，可以帮助获得所需的信息，我真正欣赏IEX云的一点是他们在创建精彩文档方面投入的工作和时间。此外，请确保您在<a class="ae jn" href="https://iexcloud.io/" rel="noopener ugc nofollow" target="_blank"> IEX云</a>上拥有一个开发者帐户，只有这样，您才能访问您的API密钥(使用API提取数据的重要元素)。说到这里，我们来看一些数据。</p><p id="d471" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="4484" class="ma kl hi lw b fi mb mc l md me"><strong class="lw hj"># EXTRACTING THE FINANCIAL METRICS<br/></strong><br/>ticker = ['MSFT', 'AMZN', 'GOOGL', 'FB', 'BABA', 'NVDA', 'PYPL', 'INTC', 'NFLX', 'AAPL']<br/><br/>def get_metrics(stock):<br/>    iex_api_key = 'YOUR SANDBOX API KEY'<br/>    fundamentals = []<br/>    <br/>    # 1. PRICE<br/>    <br/>    price_url = f'https://sandbox.iexapis.com/stable/stock/{stock}/price?token={iex_api_key}'<br/>    raw_price = requests.get(price_url)<br/>    price = raw_price.json()    <br/>    fundamentals.append(price)<br/>    <br/>    # 2. MARKET CAP<br/>    <br/>    marketcap_url = f'https://sandbox.iexapis.com/stable/stock/{stock}/stats?token={iex_api_key}'<br/>    raw_marketcap = requests.get(marketcap_url)<br/>    marketcap = raw_marketcap.json()['marketcap']<br/>    fundamentals.append(marketcap)<br/>    <br/>    # 3. PE RATIO<br/>    <br/>    peRatio_url = f'https://sandbox.iexapis.com/stable/stock/{stock}/stats?token={iex_api_key}'<br/>    raw_peRatio = requests.get(peRatio_url)<br/>    peRatio = raw_peRatio.json()['peRatio']<br/>    fundamentals.append(peRatio)<br/>    <br/>    # 4. EBITDA<br/>    <br/>    ebitda_url = f'https://sandbox.iexapis.com/stable/time-series/fundamentals/{stock}/quarterly?token={iex_api_key}'<br/>    raw_ebitda = requests.get(ebitda_url)<br/>    ebitda = raw_ebitda.json()[0]['ebitdaReported']<br/>    fundamentals.append(ebitda)<br/>    <br/>    # 5. EBIT<br/>    <br/>    ebit_url = f'https://sandbox.iexapis.com/stable/time-series/fundamentals/{stock}/quarterly?token={iex_api_key}'<br/>    raw_ebit = requests.get(ebit_url)<br/>    ebit = raw_ebit.json()[0]['ebitReported']<br/>    fundamentals.append(ebit)<br/>    <br/>    # 6. REVENUE<br/>    <br/>    revenue_url = f'https://sandbox.iexapis.com/stable/time-series/fundamentals/{stock}/quarterly?token={iex_api_key}'<br/>    raw_revenue = requests.get(revenue_url)<br/>    revenue = raw_revenue.json()[0]['revenue']<br/>    fundamentals.append(revenue)<br/>    <br/>    # 7. ENTERPRISE VALUE<br/>    <br/>    entvalue_url = f'https://sandbox.iexapis.com/stable/stock/{stock}/advanced-stats?token={iex_api_key}'<br/>    raw_entvalue = requests.get(entvalue_url)<br/>    entvalue = raw_entvalue.json()['enterpriseValue']<br/>    fundamentals.append(entvalue)<br/>    <br/>    print(cl(f'Extracted {stock} Fundamentals', attrs = ['bold']))<br/>    <br/>    return fundamentals<br/><br/>msft_fundamentals = get_metrics(ticker[0])<br/>amzn_fundamentals = get_metrics(ticker[1])<br/>googl_fundamentals = get_metrics(ticker[2])<br/>fb_fundamentals = get_metrics(ticker[3])<br/>baba_fundamentals = get_metrics(ticker[4])<br/>nvda_fundamentals = get_metrics(ticker[5])<br/>pypl_fundamentals = get_metrics(ticker[6])<br/>intc_fundamentals = get_metrics(ticker[7])<br/>nflx_fundamentals = get_metrics(ticker[8])<br/>aapl_fundamentals = get_metrics(ticker[9]))</span></pre><p id="8f1c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="5f0e" class="ma kl hi lw b fi mb mc l md me"><strong class="lw hj">Extracted MSFT Fundamentals<br/>Extracted AMZN Fundamentals<br/>Extracted GOOGL Fundamentals<br/>Extracted FB Fundamentals<br/>Extracted BABA Fundamentals<br/>Extracted NVDA Fundamentals<br/>Extracted PYPL Fundamentals<br/>Extracted INTC Fundamentals<br/>Extracted NFLX Fundamentals<br/>Extracted AAPL Fundamentals</strong></span></pre><p id="c796" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们首先定义一个名为“get_metrics”的函数，它将股票的符号作为参数。在函数内部，我们首先定义了一个名为‘iex _ api _ key’的变量，在这里我们存储了API密钥。你可能注意到我提到了<code class="du ms mt mu lw b">SANDBOX API KEY</code>，它只不过是IEX云提供给我们的沙盒API密钥。更明确地说，在我们创建IEX云的开发者账户的同时，团队将为我们提供两种类型的API密钥:一种是帮助我们与云环境交互的云API密钥，另一种是帮助我们从沙盒环境中拉取数据的沙盒API密钥。</p><p id="3194" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们在这里使用沙盒API，因为我们试图获取的财务指标数据在云环境中不受支持或不可用，只能通过访问沙盒环境来提取。</p><p id="ab64" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在存储了API键之后，我们将创建另一个名为“fundamentals”的变量，其中存储了一个空列表，每个财务指标的值将被附加到该列表中。接下来是使用IEX云提供的相应API端点提取每个财务指标的流程。我在这里不打算解释提取它们的代码，而只解释提取股票价格指标的第一个代码，因为代码结构是相似的。在提取股票价格指标的代码中，我们首先将API URL存储到‘price _ URL’变量中。使用请求提供的“get_function ”,我们调用API，然后将数据以JSON格式存储到“price”变量中。</p><p id="b7b5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们将提取的值添加到我们之前创建的“基础”列表中。这同样适用于其余的指标，但只有API URL发生了变化。最后，我们调用创建的函数来存储10只科技股的财务指标。</p><h2 id="f857" class="ma kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤3: <strong class="ak">格式化数据</strong></h2><p id="4651" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将清理和格式化提取的数据。这一步是必不可少的，因为使用API端点提取的数据很笨拙，很难直接使用。</p><p id="e881" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="aa05" class="ma kl hi lw b fi mb mc l md me"><strong class="lw hj"># FORMATTING THE DATA<br/></strong><br/>raw_data = [msft_fundamentals, amzn_fundamentals, googl_fundamentals, fb_fundamentals, baba_fundamentals, <br/>            nvda_fundamentals, pypl_fundamentals, intc_fundamentals, nflx_fundamentals, aapl_fundamentals]<br/><br/>fundamentals = pd.DataFrame(columns = ['price', 'marketcap', 'pe', 'ebitda', 'ebit', 'revenue', 'ev'])<br/>fundamentals.iloc[:,0] = range(0, 10)<br/><br/>for i in range(len(fundamentals)):<br/>    fundamentals.iloc[i] = raw_data[i]<br/><br/>fundamentals['symbol'] = ticker<br/>fundamentals = fundamentals.set_index('symbol')<br/>fundamentals</span></pre><p id="5082" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/0b8a4482980c180e962cf9357d182274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVPGb8Icdz21cENiHPpa7w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="5031" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们创建一个名为‘raw _ data’的变量，其中存储了所有提取的十只股票的财务指标。接下来，我们将创建一个新的数据框架“fundamentals”来存储所有原始数据。下一行代码没什么大不了的，只是填充从0到10的数字，并使其长度适合“raw_data”变量的长度。在下一步中，我们将创建一个for循环，用每只股票的实际财务指标填充“基本面”数据，并生成一个结果，如上面的输出所示。清理和格式化数据的整个过程使我们更容易处理数据，并帮助我们更容易理解数据。</p><h2 id="870d" class="ma kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤4:计算估值倍数</h2><p id="b2c4" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将借助之前清理和格式化的数据框架来计算估值倍数，即市盈率、EV/EBITDA、EV/EBIT和EV/收入。这些估值倍数将被用作后续步骤的核心组成部分。</p><p id="1d60" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="b363" class="ma kl hi lw b fi mb mc l md me"><strong class="lw hj"># VALUATION MULTIPLES CALCULATION<br/></strong><br/>valuation_multiples = fundamentals.copy().iloc[:, 2:].drop('ev', axis = 1)<br/>valuation_multiples = valuation_multiples.rename(columns = {'ebitda':'ev/ebitda', 'ebit':'ev/ebit', 'revenue':'ev/revenue'})<br/><br/>valuation_multiples.iloc[:, 1] = fundamentals['ev'] / fundamentals['ebitda']<br/>valuation_multiples.iloc[:, 2] = fundamentals['ev'] / fundamentals['ebit']<br/>valuation_multiples.iloc[:, 3] = fundamentals['ev'] / fundamentals['revenue']<br/><br/>valuation_multiples</span></pre><p id="aece" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mw"><img src="../Images/4f7ccd8a4ec85cc0c4ea2a63b261fb71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*0vkbWCFu8MDp52fIMe6kSA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="9470" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们做的第一步是复制我们在使用Pandas包提供的“复制”功能之前创建的“基本面”数据帧，并将其存储到“估值_倍数”中。我们还删除了三个财务指标股票价格、市场资本总额和企业价值，因为这些都是不需要的。同样，这样做的主要思想是匹配长度，这样我们就可以很容易地计算并将结果附加到数据帧中。</p><p id="f495" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我们根据需要对列进行重命名，然后计算每个估值倍数，我们将EBITDA、EBIT和收入分别除以企业价值，并将它们存储到数据框架中的相关列中。从上面的输出可以看出最终的结果，我们得到了10只科技股的所有四个预期估值倍数。</p><h2 id="7be0" class="ma kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤5: <strong class="ak">计算倍数的平均值和差值</strong></h2><p id="351b" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将考虑除苹果以外的所有股票的估值倍数，并求出每个倍数的平均值。然后，我们会发现差异只不过是苹果公司的估值倍数与所有九只股票的平均估值倍数之比。</p><p id="96fc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="781e" class="ma kl hi lw b fi mb mc l md me"><strong class="lw hj"># AVERAGE AND DIFFERENCE OF MULTIPLES<br/></strong><br/>index = ['avg', 'diff']<br/>avg_diff = pd.DataFrame(columns = ['pe', 'ev/ebitda', 'ev/ebit', 'ev/revenue'])<br/>avg_diff.iloc[:, 0] = np.arange(0,2)<br/><br/>avg_diff.iloc[0] = valuation_multiples[:9].sum() / 10<br/>avg_diff.iloc[1] = valuation_multiples.iloc[9] / avg_diff.iloc[0]<br/>avg_diff['avg/diff'] = index<br/>avg_diff = avg_diff.set_index('avg/diff')<br/>avg_diff</span></pre><p id="c23e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mx"><img src="../Images/ce7e9e6e6060e1b0bca8e95b626c92f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwQNIi1vfnvi4IKbB3Le-w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="cf56" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>前三行没有什么内容，我们只是创建了一个名为“avg_diff”的新数据帧，用于存储计算的读数，我们用0到2之间的数字临时填充数据帧，以匹配长度，而不是使用空数据帧，这样有助于我们附加将要计算的值。</p><p id="c31d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">剩下的几行是计算，我们首先计算除苹果以外的股票的每个估值倍数的平均值，并将这些值附加到“avg_diff”数据帧中，然后，我们计算苹果的估值倍数与平均值之间的比率，我们刚刚计算了该比率，并将其存储到“avg_diff”数据帧的相应行中。可以观察到代码中有很多“iloc”函数的用法，所以对于那些不知道这个函数是什么的人来说，“iloc”函数是一个切片函数，主要用于选择数据帧中的特定行或列。</p><h2 id="2dc2" class="ma kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤6: <strong class="ak">确定基础价值</strong></h2><p id="f19a" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">这是最后也是最有趣的一步，我们将利用之前确定的读数来计算苹果股票的内在或潜在价值。此外，这一步也是最容易的一步。</p><p id="1486" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="94fd" class="ma kl hi lw b fi mb mc l md me"><strong class="lw hj"># CALCULATING THE INTRINSIC VALUE<br/></strong><br/>price_diff = raw_data[9][0] / avg_diff.iloc[1]<br/>intrinsic_price = round((sum(price_diff) / 4), 2)<br/>percentage_difference = round(((raw_data[9][0] / intrinsic_price) * 100), 2)<br/><br/>print(cl(f'The listed price of Apple : {raw_data[9][0]}', attrs = ['bold']))<br/>print(cl(f'The intrinsic value of Apple : {intrinsic_price}', attrs = ['bold']))<br/>if intrinsic_price &gt; raw_data[9][0]:<br/>    print(cl(f'The Underlying Value of Apple stock is {percentage_difference}% Higher than the Listed price', attrs = ['bold']))         <br/>else:<br/>    print(cl(f'The Underlying Value of Apple stock is {percentage_difference}% Lower than the Listed price', attrs = ['bold']))</span></pre><p id="13a0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="283f" class="ma kl hi lw b fi mb mc l md me"><strong class="lw hj">The listed price of Apple : 133.8</strong><br/><strong class="lw hj">The intrinsic value of Apple : 181.21</strong><br/><strong class="lw hj">The Underlying Value of Apple stock is 73.84% Higher than the Listed price</strong></span></pre><p id="27cd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>这里重要的代码只是前三行，其他的都是可选的(但是推荐)。在第一行中，我们定义了一个名为“price_diff”的变量，用于存储苹果当前的上市价格与之前计算的差异读数之间的比率(苹果估值倍数与所有估值倍数平均值之间的比率)。然后，我们通过对刚刚计算出的“price_diff”取平均值来计算苹果股票的内在或潜在价值。在下一行代码中，我们将确定苹果股票的实际上市价格和基础价值之间的百分比差异，并将其存储到“percentage_difference”中。</p><p id="c5d3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从输出可以看出，苹果股票的当前或最后交易价格为133.8美元，基础价值为181.21美元，比当前交易价格高出73.84%。这是一些迷人的数字，不是吗？通过观察我们从我们的方法中获得的读数，我们可以做多(买入)，因为苹果的股票目前被低估，并有可能在不远的将来出现大幅增长(不是一条投资建议，只是我对结果的想法)。</p><h1 id="8bfb" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后的想法！</h1><p id="7163" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">经过一个势不可挡的过程，我们已经成功地了解了可比公司分析(CCA)是怎么一回事，以及它对现实市场的实际影响。与金融分析领域的其他方法相比，我们所做的甚至比不上一点点。因此，我们在这篇文章中采用的方法仅仅是一个开始，或者是对金融领域更广泛观点的介绍，这篇文章也可以作为一个例子，表明金融不再是一个枯燥或干燥的领域，而是在未来的日子里会变得令人着迷。</p><p id="631f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">话虽如此，你已经到了文章的结尾。如果您忘记了遵循任何编码部分，不要担心。我在最后提供了完整的源代码。就是这样！希望你能从这篇文章中学到一些新的有用的东西。</p><h2 id="c885" class="ma kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">完整代码:</h2><pre class="iy iz ja jb fd lv lw lx ly aw lz bi"><span id="1f4c" class="ma kl hi lw b fi mb mc l md me"># IMPORTING PACKAGES<br/><br/>import pandas as pd<br/>import requests<br/>import numpy as np<br/>from termcolor import colored as cl<br/><br/># EXTRACTING THE FINANCIAL METRICS<br/><br/>ticker = ['MSFT', 'AMZN', 'GOOGL', 'FB', 'BABA', 'NVDA', 'PYPL', 'INTC', 'NFLX', 'AAPL']<br/><br/>def get_metrics(stock):<br/>    iex_api_key = 'YOUR SANDBOX API KEY'<br/>    fundamentals = []<br/>    <br/>    # 1. PRICE<br/>    <br/>    price_url = f'https://sandbox.iexapis.com/stable/stock/{stock}/price?token={iex_api_key}'<br/>    raw_price = requests.get(price_url)<br/>    price = raw_price.json()    <br/>    fundamentals.append(price)<br/>    <br/>    # 2. MARKET CAP<br/>    <br/>    marketcap_url = f'https://sandbox.iexapis.com/stable/stock/{stock}/stats?token={iex_api_key}'<br/>    raw_marketcap = requests.get(marketcap_url)<br/>    marketcap = raw_marketcap.json()['marketcap']<br/>    fundamentals.append(marketcap)<br/>    <br/>    # 3. PE RATIO<br/>    <br/>    peRatio_url = f'https://sandbox.iexapis.com/stable/stock/{stock}/stats?token={iex_api_key}'<br/>    raw_peRatio = requests.get(peRatio_url)<br/>    peRatio = raw_peRatio.json()['peRatio']<br/>    fundamentals.append(peRatio)<br/>    <br/>    # 4. EBITDA<br/>    <br/>    ebitda_url = f'https://sandbox.iexapis.com/stable/time-series/fundamentals/{stock}/quarterly?token={iex_api_key}'<br/>    raw_ebitda = requests.get(ebitda_url)<br/>    ebitda = raw_ebitda.json()[0]['ebitdaReported']<br/>    fundamentals.append(ebitda)<br/>    <br/>    # 5. EBIT<br/>    <br/>    ebit_url = f'https://sandbox.iexapis.com/stable/time-series/fundamentals/{stock}/quarterly?token={iex_api_key}'<br/>    raw_ebit = requests.get(ebit_url)<br/>    ebit = raw_ebit.json()[0]['ebitReported']<br/>    fundamentals.append(ebit)<br/>    <br/>    # 6. REVENUE<br/>    <br/>    revenue_url = f'https://sandbox.iexapis.com/stable/time-series/fundamentals/{stock}/quarterly?token={iex_api_key}'<br/>    raw_revenue = requests.get(revenue_url)<br/>    revenue = raw_revenue.json()[0]['revenue']<br/>    fundamentals.append(revenue)<br/>    <br/>    # 7. ENTERPRISE VALUE<br/>    <br/>    entvalue_url = f'https://sandbox.iexapis.com/stable/stock/{stock}/advanced-stats?token={iex_api_key}'<br/>    raw_entvalue = requests.get(entvalue_url)<br/>    entvalue = raw_entvalue.json()['enterpriseValue']<br/>    fundamentals.append(entvalue)<br/>    <br/>    print(cl(f'Extracted {stock} Fundamentals', attrs = ['bold']))<br/>    <br/>    return fundamentals<br/><br/>msft_fundamentals = get_metrics(ticker[0])<br/>amzn_fundamentals = get_metrics(ticker[1])<br/>googl_fundamentals = get_metrics(ticker[2])<br/>fb_fundamentals = get_metrics(ticker[3])<br/>baba_fundamentals = get_metrics(ticker[4])<br/>nvda_fundamentals = get_metrics(ticker[5])<br/>pypl_fundamentals = get_metrics(ticker[6])<br/>intc_fundamentals = get_metrics(ticker[7])<br/>nflx_fundamentals = get_metrics(ticker[8])<br/>aapl_fundamentals = get_metrics(ticker[9])<br/><br/># FORMATTING THE DATA<br/><br/>raw_data = [msft_fundamentals, amzn_fundamentals, googl_fundamentals, fb_fundamentals, baba_fundamentals, <br/>            nvda_fundamentals, pypl_fundamentals, intc_fundamentals, nflx_fundamentals, aapl_fundamentals]<br/><br/>fundamentals = pd.DataFrame(columns = ['price', 'marketcap', 'pe', 'ebitda', 'ebit', 'revenue', 'ev'])<br/>fundamentals.iloc[:,0] = range(0, 10)<br/><br/>for i in range(len(fundamentals)):<br/>    fundamentals.iloc[i] = raw_data[i]<br/><br/>fundamentals['symbol'] = ticker<br/>fundamentals = fundamentals.set_index('symbol')<br/>fundamentals<br/><br/># VALUATION MULTIPLES CALCULATION<br/><br/>valuation_multiples = fundamentals.copy().iloc[:, 2:].drop('ev', axis = 1)<br/>valuation_multiples = valuation_multiples.rename(columns = {'ebitda':'ev/ebitda', 'ebit':'ev/ebit', 'revenue':'ev/revenue'})<br/><br/>valuation_multiples.iloc[:, 1] = fundamentals['ev'] / fundamentals['ebitda']<br/>valuation_multiples.iloc[:, 2] = fundamentals['ev'] / fundamentals['ebit']<br/>valuation_multiples.iloc[:, 3] = fundamentals['ev'] / fundamentals['revenue']<br/><br/>valuation_multiples<br/><br/># AVERAGE AND DIFFERENCE OF MULTIPLES<br/><br/>index = ['avg', 'diff']<br/>avg_diff = pd.DataFrame(columns = ['pe', 'ev/ebitda', 'ev/ebit', 'ev/revenue'])<br/>avg_diff.iloc[:, 0] = np.arange(0,2)<br/><br/>avg_diff.iloc[0] = valuation_multiples[:9].sum() / 10<br/>avg_diff.iloc[1] = valuation_multiples.iloc[9] / avg_diff.iloc[0]<br/>avg_diff['avg/diff'] = index<br/>avg_diff = avg_diff.set_index('avg/diff')<br/>avg_diff<br/><br/># CALCULATING THE INTRINSIC VALUE<br/><br/>price_diff = raw_data[9][0] / avg_diff.iloc[1]<br/>intrinsic_price = round((sum(price_diff) / 4), 2)<br/>percentage_difference = round(((raw_data[9][0] / intrinsic_price) * 100), 2)<br/><br/>print(cl(f'The listed price of Apple : {raw_data[9][0]}', attrs = ['bold']))<br/>print(cl(f'The intrinsic value of Apple : {intrinsic_price}', attrs = ['bold']))<br/>if intrinsic_price &gt; raw_data[9][0]:<br/>    print(cl(f'The Underlying Value of Apple stock is {percentage_difference}% Higher than the Listed price', attrs = ['bold']))         <br/>else:<br/>    print(cl(f'The Underlying Value of Apple stock is {percentage_difference}% Lower than the Listed price', attrs = ['bold']))</span></pre></div></div>    
</body>
</html>