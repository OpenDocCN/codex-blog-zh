<html>
<head>
<title>Android Tutorial Part 3: Using Room with RxJava 2, Dagger 2, Kotlin and MVVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android教程第3部分:使用RxJava 2，Dagger 2，Kotlin和MVVM的房间</h1>
<blockquote>原文：<a href="https://medium.com/codex/android-tutorial-part-3-using-room-with-rxjava-2-dagger-2-kotlin-and-mvvm-13487515207f?source=collection_archive---------2-----------------------#2020-06-16">https://medium.com/codex/android-tutorial-part-3-using-room-with-rxjava-2-dagger-2-kotlin-and-mvvm-13487515207f?source=collection_archive---------2-----------------------#2020-06-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="714a" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><figure class="ev ex ip iq ir is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es io"><img src="../Images/e37f30d730064dce5e57577a957ed412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMQun4oLQWF6w-6XH617tw.jpeg"/></div></div><figcaption class="iz ja et er es jb jc bd b be z dx translated"><a class="ae jd" href="https://unsplash.com/@fabioha?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">法比奥</a>在<a class="ae jd" href="https://unsplash.com/s/photos/database-storage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="20b5" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这是教程的第三部分:使用RxJava 2，Dagger 2，Kotlin和MVVM的房间。</p><p id="c537" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在第2部分中，我们完成了房间数据库的实现。</p><h1 id="4aa2" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">现在我们需要一个项目申请</strong></h1><p id="ce96" class="pw-post-body-paragraph je jf hi jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">转到您的根包，其中包含包<strong class="jg hs">数据</strong>、<strong class="jg hs"> di </strong>、<strong class="jg hs">模型</strong>等。在根包<strong class="jg hs"> <em class="lf">中创建GiphyApplication.kt </em> </strong>。</p><figure class="lh li lj lk fd is er es paragraph-image"><div class="er es lg"><img src="../Images/46b0e433084baaed16ee8ac658c59d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*wqqgmQbrLuaJj1k9ssgV1A.png"/></div></figure><p id="8755" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这个类必须从<strong class="jg hs">Android . app . application</strong>扩展而来。当你的类从<a class="ae jd" href="https://developer.android.com/reference/android/app/Application" rel="noopener ugc nofollow" target="_blank">应用程序</a>扩展时，只要应用程序还在内存中，你的类就会一直存在。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="7297" class="lq kd hi lm b fi lr ls l lt lu">class GiphyApplication : Application() {<br/>}</span></pre><p id="9ee5" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">然后头转向<strong class="jg hs"><em class="lf">androidmanifest . XML</em></strong>并在标签<strong class="jg hs"> &lt;应用&gt; </strong>内添加你的<strong class="jg hs"><em class="lf">GiphyApplication</em></strong>作为名字。所以你的应用知道这个你的<a class="ae jd" href="https://developer.android.com/reference/android/app/Application" rel="noopener ugc nofollow" target="_blank">应用</a>类。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="0c0f" class="lq kd hi lm b fi lr ls l lt lu">&lt;application<br/>    android:name=".GiphyApplication"</span></pre><p id="9f66" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">当你使用完<strong class="jg hs"><em class="lf">androidmanifest . XML</em></strong>后，回到<strong class="jg hs"><em class="lf">giphyapplication . kt</em></strong>并创建两个<strong class="jg hs">同伴</strong>对象。一个字段用于<strong class="jg hs"><em class="lf">GiphyApplication</em></strong>实例，一个字段用于<strong class="jg hs"> <em class="lf">趋势数据库</em> </strong>。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="069b" class="lq kd hi lm b fi lr ls l lt lu">companion object {<br/>    lateinit var instance: GiphyApplication<br/>    lateinit var database: TrendingDatabase<br/>}</span></pre><p id="05c7" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">接下来在init构造函数中实例化您的<strong class="jg hs"><em class="lf">GiphyApplication</em></strong>实例。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="84d0" class="lq kd hi lm b fi lr ls l lt lu">init {<br/>    instance = this<br/>}</span></pre><p id="862d" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">当应用程序类来到<strong class="jg hs"> <em class="lf"> onCreate() </em> </strong>这里我们要实例化数据库实例。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="0a45" class="lq kd hi lm b fi lr ls l lt lu">override fun onCreate() {<br/>    super.onCreate()<br/>    database = TrendingDatabase.invoke(this)<br/>}</span></pre><h1 id="d9f8" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">再次回到存储库</h1><p id="bd3c" class="pw-post-body-paragraph je jf hi jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">还记得<strong class="jg hs"><em class="lf">trending repository . kt</em></strong>类吗？在添加了一个<strong class="jg hs"> GiphyApi </strong>实例、<strong class="jg hs"> MutableLiveData </strong>对象、<strong class="jg hs"> LiveData </strong>对象并在构造函数中使用了<strong class="jg hs"> Dagger 2 </strong>依赖注入之后，我们离开了这个类。</p><h2 id="9119" class="lq kd hi bd ke lv lw lx ki ly lz ma km jp mb mc kq jt md me ku jx mf mg ky ho bi translated">将数据插入数据库。</h2><p id="60a5" class="pw-post-body-paragraph je jf hi jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">首先，我们需要在<strong class="jg hs"> <em class="lf"> Constant.kt </em> </strong>中增加两个全局常量。这两个常量分别用于giphies限制和评级，它们都将作为参数附加到URL上。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="cee6" class="lq kd hi lm b fi lr ls l lt lu">const val <em class="lf">LIMIT </em>= "25"<br/>const val <em class="lf">RATING </em>= "G"</span></pre><p id="026c" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">完成后，我们需要一个将数据从端点插入数据库的方法。回到<strong class="jg hs">T5【trending repository . ktT7】对于这个方法<strong class="jg hs"> RxJava 2 </strong>是需要的。因为数据库操作必须在后台线程上进行。</strong></p><figure class="lh li lj lk fd is"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="b384" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">将数据插入数据库的逻辑在subscribeToDatabase()中。这些方法包含三个基本的子方法:<strong class="jg hs">on next(trending result:trending result？)</strong>，<strong class="jg hs"> onError(t: Throwable？)</strong>和<strong class="jg hs"> onComplete() </strong>。</p><p id="e984" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们先从<strong class="jg hs">on next(trending result:trending result？)</strong>。第一步是检查从端点返回的对象是否不为空。第二步是使用<strong class="jg hs"><em class="lf">todayataentillist</em>()</strong>方法从<strong class="jg hs"><em class="lf">data mapper . kt</em></strong>列表中得到数据。为从端点返回的对象创建一个新的局部变量。第三步是使用<strong class="jg hs"><em class="lf">GiphyApplication</em></strong>的数据库实例，用DAO将上一步的局部变量插入数据库。</p><figure class="lh li lj lk fd is"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="bdff" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">但是当错误发生时会发生什么呢？这就是为什么我们有<strong class="jg hs"> onError(t: Throwable？)</strong>。下面来了<strong class="jg hs"> <em class="lf">可变可变数据</em> </strong>对象<strong class="jg hs"> _isInProgress </strong>和<strong class="jg hs"> _isError </strong>派上用场。不要忘记，我们还应该在控制台上记录一个错误，以便于调试。</p><figure class="lh li lj lk fd is"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="4c78" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果没有发生错误并且<strong class="jg hs">on next(trending result:trending result？完了我们来到<strong class="jg hs">。这里将创建一个新方法，用于从数据库中获取数据，并将其显示在UI上。</strong></strong></p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="96fb" class="lq kd hi lm b fi lr ls l lt lu">override fun onComplete() {<br/>    getTrendingQuery()<br/>}</span></pre><h2 id="63f5" class="lq kd hi bd ke lv lw lx ki ly lz ma km jp mb mc kq jt md me ku jx mf mg ky ho bi translated">从数据库中取出数据</h2><p id="63e3" class="pw-post-body-paragraph je jf hi jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">这里再次需要<strong class="jg hs"><em class="lf">GiphyApplication</em></strong>和<strong class="jg hs"> RxJava 2 </strong>。正如您所记得的，数据库操作必须在后台线程上进行。首先，我们需要来自数据库实例的DAO来查询数据。然后我们需要<strong class="jg hs"> Schedulers.io() </strong>用于后台线程化，需要<strong class="jg hs">androidschedulers . main thread()</strong>用于在UI上显示结果。所有的逻辑都发生在<strong class="jg hs"> subscribe() </strong>中。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="8a61" class="lq kd hi lm b fi lr ls l lt lu">private fun getTrendingQuery(): Disposable {<br/>    return GiphyApplication.database.dataDao()<br/>        .queryData()<br/>        .subscribeOn(Schedulers.io())<br/>        .observeOn(AndroidSchedulers.mainThread())<br/>        .subscribe()<br/>}</span></pre><p id="97e2" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="jg hs"> onSuccess() </strong>我们得到一个<strong class="jg hs">列表&lt; DataEntity &gt; </strong>如果列表不为null或空，我们将它传递给<strong class="jg hs"> MutableLiveData &lt;列表&lt;数据&gt; &gt; </strong>否则我们必须调用之前创建的<strong class="jg hs"> insertData() </strong>方法。</p><figure class="lh li lj lk fd is"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="64cc" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">好了，现在休息一会儿，看看上面来自<strong class="jg hs"> onSuccess() </strong>的要点。这是现在教程最重要的部分！正如您在<em class="lf"> else {} </em>中看到的，方法<strong class="jg hs"><em class="lf"/></strong><em class="lf">insert data()</em>被调用。这是整个项目中唯一调用<em class="lf"> insertData() </em>的地方。我们总是首先尝试从数据库中获取数据，只是在数据库为空的情况下，然后<em class="lf"> insertData() </em>被触发<em class="lf">。</em>第一次安装并启动应用程序时，如果您有互联网连接(向Giphy API发出GET请求),方法<em class="lf"> insertData() </em>将会触发，因为本地数据库为空。比方说，您关闭应用程序，几分钟、几小时或几天后重新启动，然后每次直接从数据库获取数据，并且<em class="lf"> insertData() </em>从未调用过<strong class="jg hs">！这样，本地<strong class="jg hs">房间</strong>数据库是我们唯一的真实来源，我们甚至可以在飞行模式下离线访问数据。</strong></p><p id="4be2" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="jg hs"> onError() </strong>我们可以从<strong class="jg hs"> insertData() </strong>中得到相同的逻辑，我建议使用另一个Logcat消息。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="7131" class="lq kd hi lm b fi lr ls l lt lu"><strong class="lm hs">{<br/>    </strong>_isInProgress.postValue(true)<br/>    Log.e("getTrendingQuery()", "Database error: ${<strong class="lm hs">it</strong>.message}")<br/>    _isError.postValue(true)<br/>    _isInProgress.postValue(false)<br/><strong class="lm hs">}</strong></span></pre><p id="4af5" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">下面是对方法<em class="lf"> getTrendingQuery() </em>的总结:</p><figure class="lh li lj lk fd is"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="5ee5" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="jg hs"><em class="lf">trending repository</em></strong>中的最后一个方法是<strong class="jg hs"> ViewModel </strong>开始从数据库中获取的公共方法。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="fb95" class="lq kd hi lm b fi lr ls l lt lu">fun fetchDataFromDatabase(): Disposable = getTrendingQuery()</span></pre><h1 id="0c47" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">为MVVM创建的最后一个类</h1><p id="508d" class="pw-post-body-paragraph je jf hi jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">转到您的根包，其中包含包<strong class="jg hs">数据</strong>、<strong class="jg hs"> di </strong>、<strong class="jg hs">模型</strong>等。创建一个新包，命名为<strong class="jg hs"> viewmodel </strong>。在<strong class="jg hs"> viewmodel </strong>里面创建类<strong class="jg hs">T55】trending viewmodel . ktT57】。这个类必须继承自<strong class="jg hs"> <em class="lf"> ViewModel() </em> </strong>。</strong></p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="c58a" class="lq kd hi lm b fi lr ls l lt lu">class TrendingViewModel: ViewModel() {<br/>}</span></pre><h2 id="aa6d" class="lq kd hi bd ke lv lw lx ki ly lz ma km jp mb mc kq jt md me ku jx mf mg ky ho bi translated">又到了依赖注入的时候了</h2><p id="9642" class="pw-post-body-paragraph je jf hi jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">回到<strong class="jg hs"> <em class="lf"> AppModule </em> </strong>这里我们需要一个提供存储库的方法。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="35a6" class="lq kd hi lm b fi lr ls l lt lu">@Provides<br/>fun provideTrendingRepository() = TrendingRepository()</span></pre><p id="4cb7" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">然后当然我们需要<strong class="jg hs"> <em class="lf"> AppComponent </em> </strong>，这里我们要告诉<strong class="jg hs"> Dagger 2 </strong>需要注入<strong class="jg hs"><em class="lf">TrendingViewModel</em></strong>。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="0b1e" class="lq kd hi lm b fi lr ls l lt lu">fun inject(viewModel: TrendingViewModel)</span></pre><p id="2d9d" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">现在我们可以使用<strong class="jg hs">视图模型</strong>中的存储库。我们还需要一个字段来存储从存储库发出的所有一次性调用。在<strong class="jg hs"><em class="lf">{ init }</em></strong>构造函数中已经发生了<strong class="jg hs">匕首2 </strong>注入和添加一次性调用。当<strong class="jg hs"> ViewModel </strong>被Android生命周期破坏时，不要忘记清除/删除所有一次性调用。</p><figure class="lh li lj lk fd is"><div class="bz dy l di"><div class="mh mi l"/></div></figure><h1 id="0d14" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">最后，是完成主要活动的时候了</h1><p id="989e" class="pw-post-body-paragraph je jf hi jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">跳回<strong class="jg hs"> <em class="lf"> AppModule </em> </strong>并为<strong class="jg hs"><em class="lf">ArrayList&lt;Data&gt;</em></strong>和<strong class="jg hs"> <em class="lf"> TrendingAdapter创建一个提供方法。</em> </strong></p><figure class="lh li lj lk fd is"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="d103" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="jg hs"> Dagger 2 </strong>自动将<em class="lf"> provideListData() </em>的结果链接到<em class="lf"> provideTrendingAdapter()。</em>正如你在<strong class="jg hs"> <em class="lf"> AppComponent </em> </strong>中已经知道的，我们需要<strong class="jg hs"> <em class="lf"> MainActivity </em> </strong>的inject方法。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="0d17" class="lq kd hi lm b fi lr ls l lt lu">fun inject(mainActivity: MainActivity)</span></pre><p id="32ce" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">让我们再次回到<strong class="jg hs"> <em class="lf"> MainActivity </em> </strong>，现在我们可以创建一个字段<strong class="jg hs"><em class="lf"/></strong>和<strong class="jg hs"><em class="lf">trending adapter</em></strong>。将<strong class="jg hs"> <em class="lf">趋势适配器</em> </strong>标注为<strong class="jg hs">@注入</strong>。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="84a7" class="lq kd hi lm b fi lr ls l lt lu">@Inject<br/>lateinit var trendingAdapter: TrendingAdapter<br/><br/>private val viewModel: TrendingViewModel by <em class="lf">viewModels</em>()</span></pre><p id="de5a" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在<em class="lf">on creteae()</em>中，首先使用<strong class="jg hs"><em class="lf">DaggerAppComponent</em></strong>注入<em class="lf"> TrendingAdapter </em>属性，然后创建<em class="lf"> setUpRecyclerView() </em>和<em class="lf"> observeLiveData()方法。</em></p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="0fde" class="lq kd hi lm b fi lr ls l lt lu">override fun onCreate(savedInstanceState: Bundle?) {<br/>    super.onCreate(savedInstanceState)<br/>    setContentView(R.layout.<em class="lf">activity_main</em>)<br/><br/>    DaggerAppComponent.create().inject(this)<br/><br/>    setUpRecyclerView()<br/><br/>    observeLiveData()<br/>}</span></pre><p id="2ba6" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在方法<strong class="jg hs"> setUpRecyclerView() </strong>中，我们使用<a class="ae jd" href="https://antonioleiva.com/kotlin-android-extensions/" rel="noopener ugc nofollow" target="_blank"> KAE </a>从<strong class="jg hs">r . layout .<em class="lf">activity _ main</em></strong>中访问<strong class="jg hs"> recycler_view </strong>(这是RecyclerView的ID)。在那里我们设置了固定的大小，动画和适配器。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="4ba1" class="lq kd hi lm b fi lr ls l lt lu">private fun setUpRecyclerView() {<br/>    recycler_view.<em class="lf">apply </em><strong class="lm hs">{<br/>        </strong>setHasFixedSize(true)<br/>        <em class="lf">itemAnimator </em>= DefaultItemAnimator()<br/>        <em class="lf">adapter </em>= trendingAdapter<br/>    <strong class="lm hs">}<br/></strong>}</span></pre><p id="dfba" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">好了，现在<strong class="jg hs"> setUpRecyclerView() </strong>实现了，让我们继续实现<strong class="jg hs"> observeLiveData() </strong>。在<strong class="jg hs"> observeLiveData() </strong>里面创建三个方法:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="29c8" class="lq kd hi lm b fi lr ls l lt lu">private fun observeLiveData() {<br/>    observeInProgress()<br/>    observeIsError()<br/>    observeGiphyList()<br/>}</span></pre><p id="90fc" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">从<strong class="jg hs">观察程序()开始。</strong>该方法用于检查数据是否仍在加载。如果是，则显示<strong class="jg hs"> <em class="lf">进度条</em> </strong>，隐藏空文本和<strong class="jg hs"> <em class="lf">回收视图。</em> </strong>否则，只需隐藏<strong class="jg hs"> <em class="lf">进度条</em> </strong>。</p><figure class="lh li lj lk fd is"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="308a" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">第二种方法<em class="lf"> observeIsError() </em>只是检查加载数据时是否发生了错误(比如没有互联网连接)。如果是的话，我们需要可以在方法<em class="lf">observegiphlist()</em>中重用的特定逻辑。如果不是错误，应禁用空文本，并启用<strong class="jg hs"> <em class="lf">进度条</em></strong><strong class="jg hs"><em class="lf">。</em>T11】</strong></p><figure class="lh li lj lk fd is"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="bcf4" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果发生了错误。最初应该可以看到<strong class="jg hs"> <em class="lf">进度条</em> </strong>。当然空文本也是如此。<strong class="jg hs"> <em class="lf"> RecyclerView </em> </strong>应该是不可见的，被禁用。适配器的列表应该设置为空列表。最后，<strong class="jg hs"> <em class="lf">进度条</em> </strong>应该是不可见的，被禁用了。</p><figure class="lh li lj lk fd is"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="1f23" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">最后，我们到达了要实现的最后一个方法。跳转到<em class="lf">observegiphlist()</em>这里首先检查是否为空或者列表是否为空。然后<strong class="jg hs"> <em class="lf">进度条</em> </strong>应该首先可见。使<strong class="jg hs"> <em class="lf">回收视图</em> </strong>可见，并将数据列表设置到适配器中。最后，空文本和<strong class="jg hs"> <em class="lf">进度条</em> </strong>应该是<em class="lf">而不是</em>可见并被禁用。在数据列表为null或空列表的情况下，我们重用<em class="lf"> disableViewsOnError() </em>的逻辑。</p><figure class="lh li lj lk fd is"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="4ab1" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">就是这样！祝贺迄今为止的成绩！我希望这篇教程对你有用。这里是已完成的项目，你可以结帐分公司<strong class="jg hs"> part3 </strong>:</p><div class="mj mk ez fb ml mm"><a href="https://github.com/fahrican/GiphyApiAndRoom/tree/part3" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hs fi z dy mr ea eb ms ed ef hr bi translated">fahrican/GiphyApiAndRoom</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">在GitHub上创建一个帐户，为fahrican/GiphyApiAndRoom的发展做出贡献。</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">github.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na ix mm"/></div></div></a></div><h1 id="1f7d" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">感谢</h1><p id="2858" class="pw-post-body-paragraph je jf hi jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">特别感谢<a class="ae jd" href="https://developers.giphy.com/docs/api#quick-start-guide" rel="noopener ugc nofollow" target="_blank"> <strong class="jg hs"> GIPHY API </strong> </a>提供这个免费API。</p></div></div>    
</body>
</html>