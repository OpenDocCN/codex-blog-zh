<html>
<head>
<title>Are you discarding async functions correctly?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你丢弃异步函数是正确的吗？</h1>
<blockquote>原文：<a href="https://medium.com/codex/are-you-discarding-async-functions-correctly-405da846766d?source=collection_archive---------0-----------------------#2022-05-24">https://medium.com/codex/are-you-discarding-async-functions-correctly-405da846766d?source=collection_archive---------0-----------------------#2022-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/ad3bd06cfade7df20c7c6e3411532db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AYcl9CIyz1nN8LpL17kzsQ.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">C#中的异步/等待</figcaption></figure><div class=""/><p id="0ad1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">用async/await做正确的事情通常很棘手。这篇文章将帮助你识别在C#异步函数中使用丢弃操作符时的一个常见陷阱。</p><h1 id="da20" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">异步和等待简介</h1><p id="b8ce" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">您很可能已经知道了这一点，但让我们先快速了解一下基础知识:</p><p id="385e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">异步函数是一个非阻塞函数，它运行在一个单独的线程上，因此不会阻塞UI运行的主线程。异步函数用<strong class="iw hy"> <em class="kv"> async </em> </strong>关键字声明:</p><figure class="kx ky kz la fd hk er es paragraph-image"><div class="er es kw"><img src="../Images/eb013b7d0cb315c0000a37eace09685f.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*Yq_HYO15YeAavRdQXRdIQg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">异步函数声明</figcaption></figure><p id="5e1c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果上述<strong class="iw hy"> <em class="kv"> async </em> </strong>函数的返回类型是一个对象或类型，只需将返回类型括在任务关键字后的&lt; &gt;中即可:</p><figure class="kx ky kz la fd hk er es paragraph-image"><div class="er es lb"><img src="../Images/9fbd78073280c6b762ecd92196ff8305.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*JwqPpmCcGzrJPiuWNRmPGQ.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">具有返回类型的异步函数</figcaption></figure><p id="1203" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当调用<strong class="iw hy"> <em class="kv">异步</em> </strong>函数并等待结果时，使用<strong class="iw hy"> <em class="kv"> await </em> </strong>关键字:</p><figure class="kx ky kz la fd hk er es paragraph-image"><div class="er es lc"><img src="../Images/0be48ab9d75b027396bd662316d40f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*s917QY8dgML11gZckXazDw.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">使用await调用异步函数</figcaption></figure><p id="0f50" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这段代码不会阻塞UI，只要点击了<strong class="iw hy"> <em class="kv"> await </em> </strong>关键字，代码就会等待结果并释放UI线程。一旦从底层函数获得结果，代码将继续执行下面的命令。</p><h1 id="26b9" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">什么是丢弃运算符？</h1><p id="1615" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">当你需要调用一个长时间运行的任务，但是<strong class="iw hy"> <em class="kv">不想等待结果</em> </strong>时，你使用一个丢弃操作符。这将任务抛出到不同的线程上，main函数中的代码继续执行，而不等待长时间运行的任务的结果。</p><p id="617d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以下是放弃异步函数的方法:</p><figure class="kx ky kz la fd hk er es paragraph-image"><div class="er es kw"><img src="../Images/73f890fba0dcb849b18a5bd4d90ef002.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*9bvuq01pnKKQXTlIS-GHYA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">调用异步函数时使用丢弃运算符</figcaption></figure><p id="1755" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">简单来说就是把<strong class="iw hy"> <em class="kv"> async </em> </strong>函数的结果赋给一个_(下划线)代码就不会等待函数返回。即使<strong class="iw hy"><em class="kv">LongRunningTask</em></strong>内部有异常，调用任务也不会知道。</p><h1 id="ffe8" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">丢弃操作符的捕捉</h1><p id="7215" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">要记住的一件主要事情是，目标函数(其结果被丢弃)应该以这样一种方式设计，即它独立地处理异常并记录它们。因为调用函数永远得不到结果，所以您不知道它内部是否发生了错误。</p><h1 id="80c6" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在丢弃的函数中使用await</h1><p id="2ed5" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">由于<strong class="iw hy"><em class="kv">LongRunningTask</em></strong>是一个<strong class="iw hy"><em class="kv"/></strong>异步函数，它也可以使用<strong class="iw hy"> <em class="kv"> await </em> </strong>运算符！太混乱了？让我们看看这段代码:</p><figure class="kx ky kz la fd hk er es paragraph-image"><div class="er es ld"><img src="../Images/9e56b58dedce78a594ef51bb8449565c.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*G-665PmAXTeK9QrPXlTCZQ.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">在被丢弃的异步函数中使用await</figcaption></figure><p id="defd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">然而，这是绝对不应该的！</strong>这就是这篇文章的全部意义。当您在一个原本被调用函数丢弃的函数中使用<strong class="iw hy"> <em class="kv"> await </em> </strong>时，任何出现在<strong class="iw hy"> <em class="kv"> await </em> </strong>关键字之后的语句都不会被执行！</p><p id="01b0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看看这个例子:</p><figure class="kx ky kz la fd hk er es paragraph-image"><div class="er es le"><img src="../Images/ae99c8851a3861981e320689ce5807e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*qcRdKHWh-WVz8FyD5qpUVA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">await之后的代码不会在被丢弃的异步函数中执行</figcaption></figure><p id="2c87" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果执行上面的代码，你会注意到<strong class="iw hy"> <em class="kv"> before.txt </em> </strong>生成了而<strong class="iw hy"> <em class="kv"> after.txt </em> </strong>没有！</p><figure class="kx ky kz la fd hk er es paragraph-image"><div class="er es lf"><img src="../Images/e8c587cc56c714a24e67e956134bb3ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*fg5mCFwmIcnFJorX39dK-Q.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">文件丢失</figcaption></figure><p id="4dd2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此外，即使您将代码包装在try/catch块中，也不会引发任何异常。</p><h1 id="f3d9" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="47d4" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">因此，您可以看到使用discard操作符是有用的，但也是危险的。如果您不小心在丢弃的函数中使用了await，之后的代码将永远不会执行，您也永远不会知道！在某个地方记录被丢弃函数的结果并跟踪可能的错误变得极其重要。</p><p id="46bf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">希望这对您的编程之旅有所帮助！</p><h1 id="a3b9" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">编辑后</h1><p id="c513" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这篇文章从这个领域的其他专家那里获得了一些意想不到的评论。因此，我认为我应该在这里澄清一两件事。</p><ol class=""><li id="741b" class="lg lh hx iw b ix iy jb jc jf li jj lj jn lk jr ll lm ln lo bi translated">当你丢弃一个<em class="kv">长时间运行的</em>函数，该函数需要比如说5秒钟才能完成，并且<em class="kv">主</em>(调用)函数在5秒钟之前(丢弃后)就退出了，那么<em class="kv">长时间运行的</em>函数中<code class="du lp lq lr ls b">await</code>之后的语句的执行将<strong class="iw hy">而不是</strong>被执行。</li><li id="9ad7" class="lg lh hx iw b ix lt jb lu jf lv jj lw jn lx jr ll lm ln lo bi translated">如果<em class="kv">主</em>函数丢弃后有更多的工作要做，并且完成<em class="kv">本身</em>需要5秒以上，那么<em class="kv">长时间运行</em> <strong class="iw hy">中<code class="du lp lq lr ls b">await</code>之后的语句将被执行</strong>。</li><li id="41ea" class="lg lh hx iw b ix lt jb lu jf lv jj lw jn lx jr ll lm ln lo bi translated">因此，<strong class="iw hy">不能保证<em class="kv">长运行</em>会完全执行，除非你确定只要<em class="kv">长运行</em>完成，你的<em class="kv">主</em>就会继续运行。</strong></li></ol><p id="2aaf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这篇文章背后的想法是避免一个可能导致意外行为的陷阱，我没有提到这是一个绝对的情况。这是基于我的实践经验，我在产品代码中看到的情况，而不仅仅是我随意提出的理论:)</p></div></div>    
</body>
</html>