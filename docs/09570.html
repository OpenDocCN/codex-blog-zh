<html>
<head>
<title>MicroServices Architecture to Solve Distributed Transaction Management Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决分布式事务管理问题的微服务架构</h1>
<blockquote>原文：<a href="https://medium.com/codex/solving-distributed-transaction-management-problem-in-microservices-architecture-586ab3087efe?source=collection_archive---------0-----------------------#2022-10-28">https://medium.com/codex/solving-distributed-transaction-management-problem-in-microservices-architecture-586ab3087efe?source=collection_archive---------0-----------------------#2022-10-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/a59691f4c7159617fa86ded7e0bac7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*2mk2x_uBae7ZB3_-jxVtMQ.jpeg"/></div></figure><p id="ade3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">问题:处理跨越多个服务/数据库的事务。跨微服务维护ACID(原子性、一致性、完整性、持久性)属性具有挑战性，因为每个服务都执行本地事务。</p><p id="8d4f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">分布式事务管理的重要问题:</p><ul class=""><li id="fb4f" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">如何维护事务的原子性？原子性意味着事务中的所有步骤都必须成功，否则如果一个步骤失败，所有已经完成的步骤都应该回滚。另一方面，一个事务可以由多个本地事务组成，这些本地事务由微服务架构中的各种微服务处理。因此，如果其中一个本地事务失败，如何回滚以前成功的事务？</li><li id="b5fb" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">如何控制并发查询的事务隔离级别。事务隔离级别指定事务中语句可见的数据量，特别是当多个服务调用同时访问同一数据源时。如果来自任何微服务的对象被持久化到数据库，而另一个请求同时读取相同的对象，服务应该返回旧的还是新的数据？</li></ul><p id="a14c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">提议的解决方案:</p><ol class=""><li id="7e44" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jy jq jr js bi translated">两阶段提交:</li></ol><p id="964c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">分布式事务也可以通过使用这种模式的微服务来实现。有一个控制节点容纳了大部分逻辑和参与节点(微服务),在两阶段提交中在这些节点上执行操作。它分两个阶段发挥作用:</p><ul class=""><li id="6f73" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">准备阶段(阶段1):控制节点查询所有参与节点，看它们是否准备好提交。参与节点给出是或否的响应。</li><li id="011d" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">提交阶段(阶段2):如果所有节点的回答都是“是”，则控制节点请求它们提交。即使一个节点做出否定响应，控制节点也会请求回滚。</li></ul><p id="30f9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">阶段的数量对整体性能也有影响。因为任何就绪节点都必须等待来自较慢节点的确认，所以由于协调器的喋喋不休，整个系统受到最慢资源的限制。此外，这种协调器的典型实现的同步特性会导致未来吞吐量的降低。</p><p id="3ed6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2PC仍然有以下缺点:</p><ul class=""><li id="b063" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated">如果一个微服务在提交阶段关闭，就没有办法回滚另一个事务。</li><li id="96a5" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">其他服务的确认必须等到最慢的服务完成。服务的资源被锁定，直到整个事务完成。</li><li id="d6aa" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated">由于它们依赖于事务协调器，两阶段提交被设计得很慢。特别是，在涉及许多服务和基于微服务的应用程序的回滚场景中，这会导致可伸缩性问题。</li></ul><p id="622c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">关于实施，请参考以下内容:</p><ul class=""><li id="491a" class="jk jl hi io b ip iq it iu ix jm jb jn jf jo jj jp jq jr js bi translated"><a class="ae jz" href="https://pynative.com/python-mysql-transaction-management-using-commit-rollback/" rel="noopener ugc nofollow" target="_blank">使用提交和回滚来管理Python中的MySQL事务</a> — Python</li><li id="6e1e" class="jk jl hi io b ip jt it ju ix jv jb jw jf jx jj jp jq jr js bi translated"><a class="ae jz" href="https://sehannrathnayake.medium.com/how-to-handle-mysql-database-transactions-with-nodejs-b7a2bf1fd203" rel="noopener">如何用NodeJS处理MySQL数据库事务</a> — NodeJS</li></ul><h1 id="3ee0" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">2.世家建筑</h1><p id="dc37" class="pw-post-body-paragraph im in hi io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">Saga模式使用一系列本地事务来管理跨多个微服务的事务。恢复事务通常被称为“补偿事务/动作”。</p><p id="a1b7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">补偿动作有能力逆转传奇中的任何动作。Saga保证所有操作成功完成，或者对所有操作执行适当的补偿操作，以撤销任何先前的工作。</p><p id="aee4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了确保系统的稳定性，我们需要实现Saga执行控制器。该控制器确保在出现故障时触发补偿查询。</p><p id="c218" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它确定发生故障时的回滚事件，并保留所有分布式事务事件的顺序记录。</p><p id="5b87" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">此外，SEC确保回滚事件除了反转本地事务之外没有任何其他影响。补偿事务应该是幂等的和可重试的。执行补偿查询的顺序应该与原始事务发生的顺序相反。</p><p id="bdda" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="ld">注意:SEC内部使用一个名为Saga log的“堆栈/日志”来跟踪所有交易</em></p><p id="d13b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">嗯，我想为一个在多个数据库上处理事务的API实现SAGA Arch，所以我做了一些修改来满足我的需要。</p><p id="5d89" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">附上我如何实现它的流程图</p><figure class="lf lg lh li fd ij er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es le"><img src="../Images/40bcaf059ae8107a2c72b98773f50563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SWCxXm5QtyBmsrZ_"/></div></div></figure><p id="13b1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">原来你是这么做的，谢谢。</p></div></div>    
</body>
</html>