<html>
<head>
<title>Using Spring Data JPA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spring数据JPA</h1>
<blockquote>原文：<a href="https://medium.com/codex/using-spring-data-jpa-f5c1a501c301?source=collection_archive---------10-----------------------#2022-06-15">https://medium.com/codex/using-spring-data-jpa-f5c1a501c301?source=collection_archive---------10-----------------------#2022-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="ad7f" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">文章</h2><div class=""/><div class=""><h2 id="7966" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated"><em class="jg">来自</em> <a class="ae jh" href="https://www.manning.com/books/java-persistence-with-spring-data-and-hibernate?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=book_tudose2_java_10_26_21" rel="noopener ugc nofollow" target="_blank"> <em class="jg"> Java持久化与Spring数据和Hibernate </em> </a> <em class="jg">由Catalin图多塞</em></h2></div><p id="09e5" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">本文深入研究了使用Spring Data JPA访问数据库。</em></p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="bc2f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">通过在<a class="ae jh" href="https://www.manning.com/books/java-persistence-with-spring-data-and-hibernate?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=book_tudose2_java_10_26_21" rel="noopener ugc nofollow" target="_blank">manning.com</a>的结账处将<strong class="jk hs"> fcctudose2 </strong>输入折扣框，用Spring Data和Hibernate   <em class="ke"> </em>获得35%的折扣。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="3f43" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">本文假设您了解主要的Spring数据模块。</p><p id="e26e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这里我们将重点讨论Spring Data JPA，因为它用于与数据库交互。Spring Data JPA主要用于从Java程序访问数据库。它在JPA提供者(例如Hibernate)之上提供了一个新的抽象层，控制配置和事务管理。下面我们就来深入分析一下它的能力。我们仍然可以使用JPA和Hibernate定义和管理我们的实体，但是我们将提供Spring Data JPA作为与它们交互的替代方案。</p><h2 id="4f8d" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated">用Spring数据定义查询方法</h2><p id="0d71" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">假设我们有一个名为“买者自负”的拍卖系统，我们想增加功能。我们将通过添加字段<code class="du ll lm ln lo b">email</code>、<code class="du ll lm ln lo b">level,</code>和<code class="du ll lm ln lo b">active</code>来扩展<code class="du ll lm ln lo b">User</code>类。一个用户可能有不同的级别，这将允许他或她执行特定的操作(例如，出价高于某个金额)。用户可以是活动的，也可以是退休的(即先前在买者自负拍卖系统中是活动的)。这是购买者应用程序需要保留的关于其用户的重要信息。演示的源代码可以在<code class="du ll lm ln lo b">springdatajpa2</code>文件夹中找到。</p><p id="980a" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单1修改后的用户类</strong></p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="7163" class="km kn hi lo b fi lx ly l lz ma"><strong class="lo hs">Path: Ch04/springdatajpa2/src/main/java/com/manning/javapersistence/springdatajpa/model/User.java<br/></strong> @Entity<br/> @Table(name = "USERS")<br/> public class User {<br/>  <br/>     @Id<br/>     @GeneratedValue<br/>     private Long id;<br/>  <br/>     private String username;<br/>  <br/>     private LocalDate registrationDate;<br/>  <br/>     private String email;<br/>  <br/>     private int level;<br/>  <br/>     private boolean active;<br/>  <br/>     public User() {<br/>  <br/>     }<br/>  <br/>     public User(String username) {<br/>         this.username = username;<br/>     }<br/>  <br/>     public User(String username, LocalDate registrationDate) {<br/>         this.username = username;<br/>         this.registrationDate = registrationDate;<br/>     }<br/>  <br/>     //getters and setters<br/> }</span></pre><p id="7797" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们将开始向<code class="du ll lm ln lo b">UserRepository</code>接口添加新方法，并在新创建的测试中使用它们。</p><p id="fd1e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><code class="du ll lm ln lo b">UserRepository</code>接口将扩展<code class="du ll lm ln lo b">JpaRepository</code>，后者扩展<code class="du ll lm ln lo b">PagingAndSortingRepository</code>，后者又扩展<code class="du ll lm ln lo b">CrudRepository</code>。</p><p id="bf15" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><code class="du ll lm ln lo b">CrudRepository</code>提供基本的CRUD功能。<code class="du ll lm ln lo b">PagingAndSortingRepository</code>提供了对记录进行排序和分页的便捷方法(将在本章的后面讨论)。<code class="du ll lm ln lo b">JpaRepository</code>提供JPA相关的方法，比如批量刷新持久上下文和删除记录。另外，<code class="du ll lm ln lo b">JpaRepository</code>将<code class="du ll lm ln lo b">CrudRepository,</code>中的一些方法覆盖为<code class="du ll lm ln lo b">findAll</code>、<code class="du ll lm ln lo b">findAllById,</code>或<code class="du ll lm ln lo b">saveAll</code>，返回<code class="du ll lm ln lo b">List</code>而不是<code class="du ll lm ln lo b">Iterable</code>。</p><p id="ba5e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们还将向<code class="du ll lm ln lo b">UserRepository</code>接口添加一系列查询方法，如下所示:</p><p id="b7bd" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单2带有新方法的UserRepository接口</strong></p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="9227" class="km kn hi lo b fi lx ly l lz ma"><strong class="lo hs">Path: Ch04/springdatajpa2/src/main/java/com/manning/javapersistence/springdatajpa/repositories/UserRepository.java<br/></strong> public interface UserRepository extends JpaRepository&lt;User, Long&gt; {<br/>  <br/>    User findByUsername(String username);<br/>    List&lt;User&gt; findAllByOrderByUsernameAsc();<br/>    List&lt;User&gt; findByRegistrationDateBetween(LocalDate start, LocalDate end);<br/> List&lt;User&gt; findByUsernameAndEmail(String username, String email);<br/> List&lt;User&gt; findByUsernameOrEmail(String username, String email);<br/> List&lt;User&gt; findByUsernameIgnoreCase(String username);<br/> List&lt;User&gt; findByLevelOrderByUsernameDesc(int level);<br/> List&lt;User&gt; findByLevelGreaterThanEqual(int level);<br/> List&lt;User&gt; findByUsernameContaining(String text);<br/> List&lt;User&gt; findByUsernameLike(String text);<br/> List&lt;User&gt; findByUsernameStartingWith(String start);<br/> List&lt;User&gt; findByUsernameEndingWith(String end);<br/> List&lt;User&gt; findByActive(boolean active);<br/> List&lt;User&gt; findByRegistrationDateIn(Collection&lt;LocalDate&gt; dates);<br/> List&lt;User&gt; findByRegistrationDateNotIn(Collection&lt;LocalDate&gt; dates);<br/>  <br/> }</span></pre><p id="92c2" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">查询方法的目的是从数据库中检索信息。Spring Data JPA提供了一个查询构建器机制，它将根据存储库方法的名称来创建存储库方法的行为。我们稍后将分析修改查询，现在我们深入到以查找信息为目的的查询中。这个查询机制从方法名中删除前缀和后缀<code class="du ll lm ln lo b">find...By</code>、<code class="du ll lm ln lo b">get...By</code>、<code class="du ll lm ln lo b">query...By</code>、<code class="du ll lm ln lo b">read...By</code>、<code class="du ll lm ln lo b">count...By</code>，并解析剩下的内容。</p><p id="30ec" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">您可以将包含表达式的方法声明为<code class="du ll lm ln lo b">Distinct</code>来设置一个distinct子句，将运算符声明为<code class="du ll lm ln lo b">LessThan</code>、<code class="du ll lm ln lo b">GreaterThan</code>、<code class="du ll lm ln lo b">Between</code>和<code class="du ll lm ln lo b">Like</code>，或者将复合条件声明为<code class="du ll lm ln lo b">And</code>或<code class="du ll lm ln lo b">Or</code>。您可以在引用属性并提供排序方向的查询方法名称中使用<code class="du ll lm ln lo b">OrderBy</code>子句来应用静态排序(<code class="du ll lm ln lo b">Asc</code>或<code class="du ll lm ln lo b">Desc</code>)。对于支持这种子句的属性，可以使用<code class="du ll lm ln lo b">IgnoreCase</code>。要删除行，必须在方法名中用<code class="du ll lm ln lo b">delete</code>替换<code class="du ll lm ln lo b">find</code>。另外，Spring Data JPA会查看方法的返回类型。如果你想找到一个<code class="du ll lm ln lo b">User</code>并在一个<code class="du ll lm ln lo b">Optional</code>容器中返回它，方法返回类型将是<code class="du ll lm ln lo b">Optional&lt;User&gt;</code>。可能的返回类型的完整列表以及详细的解释可以在<a class="ae jh" href="https://docs.spring.io/spring-data/jpa/docs/2.5.2/reference/html/#appendix.query.return.types" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-data/JPA/docs/2 . 5 . 2/reference//html/# appendix . query . return . types</a>中找到。</p><p id="390a" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">方法的名称需要遵循规则来确定结果查询。如果方法命名错误(例如，查询方法中的实体属性不匹配)，则在加载应用程序上下文时会出现错误。</p><p id="ee0f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">表1描述了Spring Data JPA支持的关键字，以及每个方法名在JPQL中是如何转换的。</p><figure class="lp lq lr ls fd mc er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mb"><img src="../Images/fbec606af2189cec65231fe2298c99df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mV1rKIaL9zEwZVzxvA04KA.png"/></div></div></figure><figure class="lp lq lr ls fd mc er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mb"><img src="../Images/6ea85cb8c69ea822bdd345d679f283e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ffHjGn8Ru6oeWW2prUfpFw.png"/></div></div></figure><figure class="lp lq lr ls fd mc er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mj"><img src="../Images/1196847becbc38a67544d80a034f6778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R1SrYUwvW_XSTKaJ7-0MNg.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated">表1 Spring数据JPA和生成的JPQL中的关键字用法</figcaption></figure><p id="2062" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">作为所有未来测试的基类，我们将编写<code class="du ll lm ln lo b">SpringDataJpaApplicationTests</code>抽象类。</p><p id="ece7" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单SpringDataJpaApplicationTests抽象类</strong></p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="85d5" class="km kn hi lo b fi lx ly l lz ma"><strong class="lo hs">Path: Ch04/springdatajpa2/src/test/java/com/manning/javapersistence/springdatajpa/SpringDataJpaApplicationTests.java<br/></strong> @SpringBootTest                                                             #A<br/> @TestInstance(TestInstance.Lifecycle.<em class="ke">PER_CLASS</em>)                             #B<br/> abstract class SpringDataJpaApplicationTests {<br/>     @Autowired                                                              #C<br/>     UserRepository userRepository;                                          #C<br/>  <br/>     @BeforeAll                                                              #D<br/>     void beforeAll() {                                                      #D<br/>         userRepository.saveAll(<em class="ke">generateUsers</em>());                            #D<br/>     }                                                                       #D<br/>  <br/>     private static List&lt;User&gt; generateUsers() {                             #E<br/>         List&lt;User&gt; users = new ArrayList&lt;&gt;();<br/> <br/>        User john = new User("john", LocalDate.<em class="ke">of</em>(2020, Month.<em class="ke">APRIL</em>, 13));<br/>         john.setEmail("john@somedomain.com");<br/>         john.setLevel(1);<br/>         john.setActive(true);<br/>  <br/>         //create and set a total of 10 users<br/>  <br/>         users.add(john);<br/>         //add a total of 10 users to the list<br/>  <br/>         return users;<br/>     }<br/>     @AfterAll                                                               #F<br/>     void afterAll() {                                                       #F<br/>         userRepository.deleteAll();                                         #F<br/>     }                                                                       #F<br/>  <br/> }</span></pre><p id="a576" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A由Spring Boot添加到最初创建的类中的@SpringBootTest注释将告诉Spring Boot搜索主配置类(例如@SpringBootApplication注释类)并创建将在测试中使用的ApplicationContext。理解由Spring Boot添加到包含main方法的类中的@SpringBootApplication注释将启用Spring Boot自动配置机制，并将启用对应用程序所在的包的扫描，以及允许在上下文中注册额外的beans，这一点很重要。</strong></p><p id="6cd1" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B使用@TestInstance(测试实例。Lifecycle.PER_CLASS)注释，我们要求JUnit 5创建测试类的一个实例，并在所有测试方法中重用它。这将允许我们使@BeforeAll和@AfterAll带注释的方法成为非静态的，并在其中直接使用自动连接的UserRepository实例字段。</strong></p><p id="e645" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #C我们自动连接一个用户存储库实例。由于@SpringBootApplication注释，这种自动连接是可能的，它允许对应用程序所在的包进行扫描，并在上下文中注册beans。</strong></p><p id="171e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在执行来自扩展SpringDataJpaApplicationTests的类的所有测试之前，@BeforeAll注释方法将被执行一次。这个方法不会是静态的。</p><p id="f333" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">【The @ TestInstance(测试实例。Lifecycle.PER_CLASS)注释强制创建测试类的单个实例。它将把generateUsers方法创建的用户列表保存到数据库中。</p><p id="dac4" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在执行了扩展SpringDataJpaApplicationTests的类中的所有测试之后，@AfterAll注释方法将被执行一次。这个方法不会是静态的。@TestInstance(测试实例。Lifecycle.PER_CLASS)注释强制创建测试类的单个实例。</p><p id="0c11" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">接下来的测试将扩展这个类，并使用已经填充的数据库。为了测试现在属于<code class="du ll lm ln lo b">UserRepository</code>的方法，我们将创建<code class="du ll lm ln lo b">FindUsersUsingQueriesTest</code>类并遵循相同的编写测试的方法:调用存储库方法并验证其结果。</p><p id="9ef7" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单FindUsersUsingQueriesTest类</strong></p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="4be1" class="km kn hi lo b fi lx ly l lz ma"><strong class="lo hs">Path: Ch04/springdatajpa2/src/test/java/com/manning/javapersistence/springdatajpa/FindUsersUsingQueriesTest.java<br/></strong> public class FindUsersUsingQueriesTest extends SpringDataJpaApplicationTests {<br/>  <br/>     @Test<br/>     void testFindAll() {<br/>         List&lt;User&gt; users = userRepository.findAll();<br/>         <em class="ke">assertEquals</em>(10, users.size());<br/>     }<br/>  <br/>     @Test<br/>     void testFindUser() {<br/>         User beth = userRepository.findByUsername("beth");<br/>         <em class="ke">assertEquals</em>("beth", beth.getUsername());<br/>     }<br/>  <br/>     @Test<br/>     void testFindAllByOrderByUsernameAsc() {<br/>         List&lt;User&gt; users = userRepository.findAllByOrderByUsernameAsc();<br/>         <em class="ke">assertAll</em>(() -&gt; <em class="ke">assertEquals</em>(10, users.size()),<br/>                 () -&gt; <em class="ke">assertEquals</em>("beth", users.get(0).getUsername()),<br/>                 () -&gt; <em class="ke">assertEquals</em>("stephanie",<br/>                        users.get(users.size() - 1).getUsername()));<br/>     }<br/>  <br/>     @Test<br/>     void testFindByRegistrationDateBetween() {<br/>         List&lt;User&gt; users = userRepository.findByRegistrationDateBetween(<br/>                 LocalDate.<em class="ke">of</em>(2020, Month.<em class="ke">JULY</em>, 1),<br/>                 LocalDate.<em class="ke">of</em>(2020, Month.<em class="ke">DECEMBER</em>, 31));<br/>         <em class="ke">assertEquals</em>(4, users.size());<br/>     }<br/>  <br/>     //more tests<br/> }</span></pre><h2 id="f293" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated">限制查询结果、排序和分页</h2><p id="79c4" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated"><code class="du ll lm ln lo b">first</code>和<code class="du ll lm ln lo b">top</code>关键字(等价使用)可以限制查询方法的结果。<code class="du ll lm ln lo b">top</code>和<code class="du ll lm ln lo b">first</code>关键字后面可以跟一个可选的数值，以指示要返回的最大结果大小。如果缺少该数值，结果大小将为1。</p><p id="1e0e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><code class="du ll lm ln lo b">Pageable</code>是分页信息的接口。在实践中，我们使用实现它的<code class="du ll lm ln lo b">PageRequest</code>类。它可以指定页码、页面大小和排序标准。</p><p id="f700" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们将向<code class="du ll lm ln lo b">UserRepository</code>接口添加以下方法:</p><p id="a5db" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单5在用户存储库接口中限制查询结果、排序和分页</strong></p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="cf4b" class="km kn hi lo b fi lx ly l lz ma"><strong class="lo hs">Path: Ch04/springdatajpa2/src/main/java/com/manning/javapersistence/springdatajpa/repositories/UserRepository.java<br/></strong> User findFirstByOrderByUsernameAsc();<br/> User findTopByOrderByRegistrationDateDesc();<br/> Page&lt;User&gt; findAll(Pageable pageable);<br/> List&lt;User&gt; findFirst2ByLevel(int level, Sort sort);<br/> List&lt;User&gt; findByLevel(int level, Sort sort);<br/> List&lt;User&gt; findByActive(boolean active, Pageable pageable);</span></pre><p id="ba84" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们将编写以下测试来验证这些新添加的方法是如何工作的:</p><p id="4a6b" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单6测试限制查询结果、排序和分页</strong></p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="f18c" class="km kn hi lo b fi lx ly l lz ma"><strong class="lo hs">Path: Ch04/springdatajpa2/src/test/java/com/manning/javapersistence/springdatajpa/FindUsersSortingAndPagingTest.java<br/></strong> public class FindUsersSortingAndPagingTest extends                        <br/>              SpringDataJpaApplicationTests {                               <br/>     @Test<br/>     void testOrder() {<br/>  <br/>         User user1 = userRepository.findFirstByOrderByUsernameAsc();        #A<br/>         User user2 = userRepository.findTopByOrderByRegistrationDateDesc(); #A<br/>         Page&lt;User&gt; userPage = userRepository.findAll(PageRequest.<em class="ke">of</em>(1, 3)); #B<br/>         List&lt;User&gt; users = userRepository.findFirst2ByLevel(2,              #C<br/>                                           Sort.<em class="ke">by</em>("registrationDate"));     #C<br/>  <br/>         <em class="ke">assertAll</em>(                                                         <br/>                 () -&gt; <em class="ke">assertEquals</em>("beth", user1.getUsername()),           <br/>                 () -&gt; <em class="ke">assertEquals</em>("julius", user2.getUsername()),         <br/>                 () -&gt; <em class="ke">assertEquals</em>(2, users.size()),     <br/>                 () -&gt; <em class="ke">assertEquals</em>(3, userPage.getSize()),                 <br/>                 () -&gt; <em class="ke">assertEquals</em>("beth", users.get(0).getUsername()),    <br/>                 () -&gt; <em class="ke">assertEquals</em>("marion", users.get(1).getUsername())   <br/>         );                                                                 <br/>  <br/>     }<br/>  <br/>     @Test<br/>     void testFindByLevel() {<br/>         Sort.TypedSort&lt;User&gt; user = Sort.<em class="ke">sort</em>(User.class);                  #D<br/>  <br/>         List&lt;User&gt; users = userRepository.findByLevel(3,                    #E<br/>                    user.by(User::getRegistrationDate).descending());        #E<br/>         <em class="ke">assertAll</em>(                                                         <br/>                 () -&gt; <em class="ke">assertEquals</em>(2, users.size()),             <br/>                 () -&gt; <em class="ke">assertEquals</em>("james", users.get(0).getUsername())    <br/>         );                                                                 <br/>  <br/>     }<br/>  <br/>     @Test<br/>     void testFindByActive() {<br/>         List&lt;User&gt; users = userRepository.findByActive(true,                #F<br/>                    PageRequest.<em class="ke">of</em>(1, 4, Sort.<em class="ke">by</em>("registrationDate")));      #F<br/>         <em class="ke">assertAll</em>(                                                       <br/>                 () -&gt; <em class="ke">assertEquals</em>(4, users.size()),           <br/>                 () -&gt; <em class="ke">assertEquals</em>("burk", users.get(0).getUsername())    <br/>         );<br/>  <br/>     }<br/> }</span></pre><p id="a05e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A第一个测试将按照用户名的升序查找第一个用户，按照注册日期的降序查找第一个用户。</strong></p><p id="217c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B查找所有用户，拆分成页，返回大小为3的页码1(页码从0开始)。</strong></p><p id="1d36" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #C查找级别2的前两个用户，按注册日期排序。</strong></p><p id="1337" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #D第二个测试将定义用户类的排序标准。排序。TypedSort扩展了Sort，并可以使用方法句柄来定义排序所依据的属性。</strong></p><p id="f74f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #E我们找到级别3的用户，并按注册日期降序排列。</strong></p><p id="bd1f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #F第三个测试会找到按注册日期排序的活跃用户，将他们拆分成页面，返回大小为4的页码1(页码从0开始)。</strong></p><p id="90da" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">本文到此为止。感谢阅读。</p></div></div>    
</body>
</html>