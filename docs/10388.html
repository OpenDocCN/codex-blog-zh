<html>
<head>
<title>Apache Dolphinscheduler integrates Linkis task plugin, greatly improving computing governance capabilities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Dolphinscheduler集成了Linkis任务插件，极大地提高了计算治理能力</h1>
<blockquote>原文：<a href="https://medium.com/codex/apache-dolphinscheduler-integrates-linkis-task-plugin-greatly-improving-computing-governance-5c8eae9f31ea?source=collection_archive---------4-----------------------#2022-12-27">https://medium.com/codex/apache-dolphinscheduler-integrates-linkis-task-plugin-greatly-improving-computing-governance-5c8eae9f31ea?source=collection_archive---------4-----------------------#2022-12-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f91bc7e070a0cb159736a01f0ccb74b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gqsq-_zrtnTRzMCKjgCfmg.png"/></div></div></figure><p id="b163" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">今天，我们来看看Apache DolphinScheduler是如何与Apache Linkis集成的。两个月前，Apache DolphinScheduler社区PMC邀请我一起做这项工作，我觉得这很有趣，所以我接受了。</p><p id="367c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我今天的分享主要分为两部分。一个是解释Apache DolphinScheduler的任务插件扩展是如何以及为什么这样设计的；另一个是如何整合Apache DolphinScheduler和Linkis，包括我和Linkis PMC的相关讨论。也欢迎大家加入，为doDolphinScheduler贡献更多插件。</p><h1 id="88ba" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">任务插件扩展简介</h1><h2 id="f5d6" class="km jp hi bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated">阿帕奇海豚调度程序</h2><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e0644548cd22567ada79b716a7066243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ld7u9WFg3QSH9lwPB9W3cg.png"/></div></div></figure><p id="dd69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Apache DolphinScheduler是一个分布式、去中心化、易于扩展的可视化DAG工作流项目调度平台，致力于解决数据处理流程中的复杂依赖问题，允许调度系统开箱即用地处理数据。</p><p id="d10d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上图是Apache DolphinScheduler目前的架构，主要分为Master和Worker。Master用于分发和调度，Worker用于任务执行，包括UI、API、Alert alarm、ZK分布式处理等。，最后执行各种任务。</p><p id="e3c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Apache DolphinScheduler有四个特点，一个是高可靠性，去中心化的多主&amp;多工服务对等架构，避免单个主的压力过大，使用任务缓冲队列避免过载；</p><p id="34ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二，简单易用。DAG定义是通过拖放完成的。与Airflow只对具有一定Python技能、擅长统计的工程师和分析师友好不同，DolphinScheduler可以通过拖拽的方式定义工作流；</p><p id="397b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第三，使用场景丰富，支持多租户，支持暂停和恢复操作。它非常适合大数据生态系统，并提供了Spark、Hive、M/R、Python、Sub_process、Shell和其他任务类型。现在随着3.0版本的发布，支持的任务类型更加丰富；第四，高可扩展性，因为Master和Worker都有无中心的分布式设计，所以可以一直横向扩展，即使业务场景越来越多，调度规模越来越大，也可以通过动态在线和离线进行调度。</p><h2 id="ab72" class="km jp hi bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated">Dolphinscheduler任务组件使用示例</h2><p id="5940" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">接下来，我们以SparkSQL为例，介绍如何使用Apache DolphinScheduler任务组件。具体来说，我们需要创建一个视图表terms，并以Parquet格式写入三行数据和一个表wc，以确定该表是否存在。程序类型是SQL，视图表术语的数据被插入到格式为Parquet的表wc中。</p><p id="afd2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在工作流定义部分，可以看到DolphinScheduler目前支持的任务组件，包括一些简单的shells，以及逻辑组件，比如子流程，以及依赖组件。</p><p id="7fbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有些是通用节点，有些是任务执行节点。拖动这些节点后，界面如下所示:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a2a6cee6db9444a5f6c09bdb4250cbc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NED5iHBJcq259gW7C9oNiw.png"/></div></div></figure><p id="76ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个任务都不一样。我们编辑需要执行的内容，设置SPI等。，然后单击“确认”以成功定义工作流、监控状态、获取日志等。</p><h2 id="7c14" class="km jp hi bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated">SPI服务发现</h2><p id="75ab" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">我们有这么多的任务组件，我们是怎么做的呢？这就涉及到我们刚刚提到的SPI服务发现功能。</p><p id="ac95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">SPI的全称是服务提供者接口，它是内置于JDK中的服务提供者发现机制。大多数人可能很少使用，因为它的定位主要是面向开发者，在java.util.ServiceLoader的文档中有详细介绍，它的抽象概念是指动态加载某个服务实现。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/6a6cc0b0078ede90df0c859c5cdc9a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPeTJsmmRnwTicej5SYOkg.jpeg"/></div></div></figure><p id="b42e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这显示了加载整个动态的服务实现。从DolphinScheduler的worker Server启动服务开始，一个名为TaskpluginManager的类就会加载并监控，然后触发SPI类加载器加载这些类。</p><p id="f259" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那些在DolphinScheduler上重新开发过的人，无论何时工作者启动，都会在日志中看到这些信息。</p><p id="773a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Apache DolphinScheduler执行的任务分为逻辑任务和物理任务。逻辑任务指的是DependTask、SwitchTask等逻辑任务；物理任务指的是ShellTask、SQLTask等任务。在Apache DolphinScheduler中，我们一般会扩展物理任务，物理任务是由Worker执行的，所以我们需要理解的是，当我们有多个Worker时，我们需要将自定义任务分发到每台有Worker的机器上，当我们启动Worker服务时，Worker会启动一个ClassLoader来加载实现规则的相应任务库。我在整合Linkis时也遵循这个过程。</p><h2 id="ae2e" class="km jp hi bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated">构建任务实现</h2><p id="c22c" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">通过TaskChannel，我们得到可执行的物理任务，但是我们需要在当前任务中添加相应的实现，这样Apache DolphinScheduler才能执行你的任务。首先，我们需要在编写任务之前了解任务之间的关系:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/6a6cc0b0078ede90df0c859c5cdc9a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPeTJsmmRnwTicej5SYOkg.jpeg"/></div></div></figure><p id="4d66" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上图是该类的示意图。最上面的角是抽象任务类，下面集成了抽象任务类和任务执行器。该类分为3个主要类型，分别是基于YARN、Python和Shell的集成。</p><h2 id="ec91" class="km jp hi bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated">任务插件开发流程(基于Shell的任务)</h2><p id="0621" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated"><strong class="is hj"><em class="lk"/></strong>(参见MapReduceTask)</p><ul class=""><li id="26c9" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">您需要在org . Apache . dolphin scheduler . server . worker . task下的TaskManager类中创建一个自定义任务(您还需要在task type中注册相应的任务类型)</li><li id="a461" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">org . Apache . dolphin scheduler . server . worker . task下的AbstractYarnTask需要集成</li><li id="17ac" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">构造函数调度抽象任务构造函数</li><li id="1c89" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">集成抽象参数自定义任务参数实体</li><li id="a536" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">在重写AbstractTask的init方法中解析自定义任务参数</li><li id="bf79" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">重写buildCommand包装命令</li></ul><p id="fbbe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="lk"/></strong>非基于纱线的计算(参见ShellTask)</p><ul class=""><li id="3bf7" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">定制任务需要在org . Apache . dolphin scheduler . server . worker . task下的TaskManager中创建</li><li id="45b8" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">org . Apache . dolphin scheduler . server . worker . task下的AbstractTask需要集成</li><li id="0f94" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">在构造函数中实例化ShellCommandExecutor</li></ul><pre class="la lb lc ld fd lz ma mb bn mc md bi"><span id="63d0" class="me jp hi ma b be mf mg l mh mi">public ShellTask(TaskProps props, Logger logger) {<br/>         super(props, logger);<br/>         this.taskDir = props.getTaskDir();<br/>         this.processTask = new ShellCommandExecutor(this::logHandle,<br/>                 props.getTaskDir(), props.getTaskAppId(),<br/>                 props.getTenantCode(), props.getEnvFile(), props.getTaskStartTime(),<br/>                 props. getTaskTimeout(), logger);<br/>         this.processDao = DaoFactory.getDaoInstance(ProcessDao.class);<br/>}</span></pre><ul class=""><li id="46b2" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">放入自定义任务的TaskProps和自定义日志记录器，TaskProps封装任务信息，Logger封装自定义日志信息</li><li id="ff44" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">集成抽象参数自定义任务参数实体</li><li id="bc7d" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">重写AbstractTask的init方法以解析自定义任务参数实体</li><li id="d99d" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">重写handle方法，调用ShellCommandExecutor的run方法，将第一个参数传入您的命令，将第二个参数放入ProcessDao，并设置相应的exitStatusCode</li></ul><p id="242c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="lk">基于非SHELL的任务(参见SqlTask) </em> </strong></p><ul class=""><li id="352f" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">定制任务需要在org . Apache . dolphin scheduler . server . worker . task下的TaskManager中创建</li><li id="36ee" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">org . Apache . dolphin scheduler . server . worker . task下的AbstractTask需要集成</li><li id="6a37" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">集成抽象参数自定义任务参数实体</li><li id="4914" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">在AbstractTask的构造方法或重写init方法中，解析自定义任务参数实体</li><li id="a5be" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">重写handle方法以实现业务逻辑并设置相应的exitStatusCode</li></ul><p id="580e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看起来很麻烦，但是不用担心，等我解释完Linkis集成流程，你就知道任务插件流程很简单了。</p><h1 id="5b0c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Apache DolphinScheduler和Linkis的集成</h1><p id="e78d" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">接下来我就说说DolphinScheduler是怎么和Linkis集成的。</p><h2 id="a6d8" class="km jp hi bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated">Linkis建筑</h2><p id="67a7" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">本着开源的思想，我们集成了优秀的计算中间件Linkis作为任务插件。作为一个计算中间件，Linkis提供了强大的连接、重用、编排、扩展和治理能力。应用层和引擎层通过计算中间件解耦，简化了复杂的网络调用关系，降低了整体的复杂度，节省了整体的开发和维护成本。</p><p id="868f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Linkis提供三大服务:计算治理服务、公共增强服务、微服务治理服务。我们主要使用它的计算治理服务。在提交和准备执行阶段，我们可以在Linkis计算中间件中执行许多类型的任务。如果任务太多，Linkis可以帮助我们抽象和重用这些计算过程。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/8a15bd6b283d7b6c12a6874807a6947c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9uvesap7rQsro2rR6T1nHQ.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated">Linkis建筑</figcaption></figure><h2 id="b9f0" class="km jp hi bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated">应用方法1 (JAVA SDK)</h2><p id="e429" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">接下来说说DolphinScheduler是如何在过程中整合Linkis和我的思考的。</p><p id="f85c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Linkis提供了两个对我们非常有用的集成类，一个是Java SDK，一个是Linkis-Cli，也就是Shell的能力。</p><p id="7755" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Java SDK是由Linkis官方提供的Java包。您可以在引用之前的pom中的依赖项后定义版本。后面我们可以在里面定义引擎及其参数，包括Spark的运行参数，Linkis本身的纱线队列参数等。在定义了执行和提交之后。</p><p id="283e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例代码如下:</p><pre class="la lb lc ld fd lz ma mb bn mc md bi"><span id="85c9" class="me jp hi ma b be mf mg l mh mi">private static JobExecuteResult toSubmit(String user, String code) {<br/>         // 1. build params<br/>         // set label map :EngineTypeLabel/UserCreatorLabel/EngineRunTypeLabel/Tenant<br/>         Map labels = new HashMap();<br/>         labels.put(LabelKeyConstant.ENGINE_TYPE_KEY, "spark-2.4.3"); // rrequired engineType Label<br/>         labels.put(LabelKeyConstant.USER_CREATOR_TYPE_KEY, user + "-APPName");// required execute user and creator eg:hadoop-IDE<br/>         labels.put(LabelKeyConstant.CODE_TYPE_KEY, "py"); // required codeType<br/>         // set start up map :engineConn start params<br/>         Map startupMap = new HashMap(16);<br/>         // Support setting engine native parameters, For example: parameters of engines such as spark/hive<br/>         startupMap.put("spark.executor.instances", 2);<br/>         // setting link is params<br/>         startupMap.put("wds.linkis.rm.yarnqueue", "dws");<br/>// 2. build jobSubmitAction<br/>         JobSubmitAction jobSubmitAction = JobSubmitAction. builder()<br/>                 .addExecuteCode(code)<br/>                 .setStartupParams(startupMap)<br/>                 .setUser(user) //submit user<br/>                 .addExecuteUser(user) // execute user<br/>                 .setLabels(labels)<br/>                 .build();<br/>         // 3. to execute<br/>         return client. submit(jobSubmitAction);<br/>     }</span></pre><p id="0f1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">导入从属模块和创建客户机的过程:</p><pre class="la lb lc ld fd lz ma mb bn mc md bi"><span id="e942" class="me jp hi ma b be mf mg l mh mi">org.apache.linkis<br/>   linkis-computation-client<br/>   ${linkis.version}<br/>Such as:<br/>   org.apache.linkis<br/>   linkis-computation-client<br/>   1.0.3</span></pre><p id="7c17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不过，虽然这是一个非常好的SDK包，理论上非常容易集成到DolphinScheduler中，但是它有一个致命的弱点，就是需要适配Linkis的版本。但是要适应Linkis的每个版本是不现实的，所以最后，我们放弃了这个方法。</p><h2 id="4b73" class="km jp hi bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated">应用方法2 (Linkis-Cli)</h2><p id="3272" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">在与Linkis社区的PPMC沟通后，我们最终选择在shell模式下调用Flink任务，以减少多版本兼容性的差异，避免这个问题。</p><p id="2008" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">于是我们想到了使用Linkis提供的打包客户端，只需要运行Linkis安装目录下的一段代码就可以运行SparkSQL。详情如下:</p><p id="9dab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一步是检查默认配置文件linkis-cli.properties是否存在于conf/目录中，该文件包含以下配置:</p><pre class="la lb lc ld fd lz ma mb bn mc md bi"><span id="24ba" class="me jp hi ma b be mf mg l mh mi">#linkis-mg-gateway service address<br/>    wds.linkis.client.common.gatewayUrl=http://127.0.0.1:9001<br/>    #Authentication authentication strategy token/static<br/>    wds.linkis.client.common.authStrategy=token<br/>    #static mode is username/password, and token mode is token_name and logal_users in linkis-mg-gateway_auth_token table<br/>    wds.linkis.client.common.tokenKey=Validation-Code<br/>    wds.linkis.client.common.tokenValue=BML-AUTH</span></pre><p id="46a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二步是进入Linkis安装目录并输入命令</p><pre class="la lb lc ld fd lz ma mb bn mc md bi"><span id="4cc6" class="me jp hi ma b be mf mg l mh mi">sh ./bin/linkis-cli -engineType spark-2.4.3 -codeType sql -code "select count(*) from testdb.test;" -submitUser hadoop -proxyUser hadoop</span></pre><p id="1ce5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第三步中，您将看到一条消息，表明任务已经提交给Linkis并开始在控制台上执行。</p><p id="6200" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法不需要关心Linkis的版本。它只需要确定执行引擎是什么，执行什么用户，执行什么内容，然后就可以提交给Linkis执行了。</p><p id="9153" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在DolphinScheduler集成Linkis的整个过程中都使用了这种思想。</p><p id="30c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您想在生产环境中使用Linkis任务类型，您需要首先配置所需的环境。配置文件如下所示:</p><pre class="la lb lc ld fd lz ma mb bn mc md bi"><span id="0401" class="me jp hi ma b be mf mg l mh mi">/dolphinscheduler/conf/env/dolphinscheduler_env.sh</span></pre><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ada8f434f50e1d94f2fab8609e94464a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3QwgUwwGswJwaXbBiMNUnQ.png"/></div></div></figure><p id="95d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">定义完成后，可以在其他类中选择Linkis，可以看到Linkis的参数:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4153ea3cc6742b0a6cc8ac607f105de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crzmL6OOaEC4mYgINO5ZWA.png"/></div></div></figure><p id="60c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们刚才提到的，可以定义引擎的类型、代码类型等。可以添加到Linkis的Prop和值，第一个属性的创建就完成了。</p><p id="5c17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们可以单击加号，填充尽可能多的属性，然后创建我们的Linkis任务。</p><h2 id="4720" class="km jp hi bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated">整合过程</h2><p id="36b2" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">我到底是怎么进行整合的？这是我开发的任务链接的集成。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/38af4790294116d2507218049ba859b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G2LyA3nKOwAh_-VRlmykZA.png"/></div></div></figure><p id="71fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Linkis插件的目录结构主要分为四个文件:</p><ul class=""><li id="acec" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">LinkisParameters(参数)</li><li id="1444" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">LinkisTask(任务执行)</li><li id="bf49" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">LinkisTaskChannel(创建、取消等。实现类)</li><li id="43ec" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">LinkisTaskChannelFactory(task channel的工厂实现类)</li></ul><p id="cdc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">参数和任务执行是比较上层的方法，主要开发的主要是这两种方法。</p><p id="cbdb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当集成流程时，主要是提交任务和构建我们的命令。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/41c5be90a4cd8340b3bc294010a2c8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8lMDYC5ouKgNMxEGnCTAQ.png"/></div></div></figure><p id="f21b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们来看看这种提交方式。根据用户的输入和参数配置，构造一个Linkis Shell执行字符串。通过我们定义的shellCommandExecutor执行命令，根据命令的任务响应获取任务ID作为App ID。以此类推，最终实现Linkis任务的提交。如果有异常，您可以将退出代码定义为失败或其他类型，</p><p id="a4e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">温馨提示:</strong></p><p id="5d9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">可以通过Linkis-cli的状态来实现。</strong></p><p id="13d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">DolphinScheduler在提交Linkis任务时会自动添加参数— async true，实现异步提交。</p><p id="3372" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们来说说Build命令的流程。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/5ec482f1f37c22b0611b10613009f2ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SQqYH0faTL1z7R0SpTnVQ.png"/></div></div></figure><p id="0435" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们刚刚提到的共享清理选项是刚刚定义的op t/soft/linkis的目录。定义之后，我们就可以连接到刚才提到的Linkis客户端的命令行了。Linkis的异步提交参数是默认值。然后把我的Prop和Value键-值对拼接到ArrayList里面，然后一步一步的添加，形成ArrayList的命令。解析后可以看到，它通过空间拆分成命令，然后提交给ShellCommandExecutor执行。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/1dc7d850a4a1585bbf9ce8a612fc1db8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwOFvdBPZE66tohrV1sTEg.png"/></div></div></figure><p id="3eef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看似复杂的集成主要就是用这种方法。您只需要构建命令，并将其放在我们为执行而定义的上层类中。</p><p id="0b06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们来看监控任务状态的方法，它会定期运行监控方法，根据返回的日志中的状态检查获取最新的任务状态，并随着Linkis的状态变化更新DolphinScheduler。任务状态。</p><p id="d26a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">温馨提示:可以通过Linkis-cli的状态来实现。</p><p id="f6c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然击杀任务也是如此，这里就不赘述了。</p><h1 id="7589" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">我的期望</h1><p id="2904" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">可以看到，DolphinScheduler对Linkis的集成是非常简单的，像这样的集成还有很多，包括PyTorch、Flink、Spark等。希望大家都能参与到DolphinScheduler的开源共建中来。我们鼓励任何形式的社区参与，例如:</p><ul class=""><li id="fffa" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated">GitHub问题遇到的问题反馈</li><li id="c2e9" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">回答其他人在这些问题上遇到的问题</li><li id="7a2b" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">帮助改进文档</li><li id="bf8f" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">帮助向项目添加测试用例</li><li id="0b49" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">向代码中添加注释</li><li id="7850" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">提交PR来修复bug或特性</li><li id="6887" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">分享你的应用案例，与调度相关的技术文章</li><li id="058e" class="ll lm hi is b it lu ix lv jb lw jf lx jj ly jn lq lr ls lt bi translated">帮助推广DolphinScheduler，参与技术会议或meetup分享等。</li></ul><p id="3ca0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我详细讲了集成Dolphinscheduler任务插件的过程，希望你能贡献你的工作来丰富我们的任务插件，让我们一起构建一个欣欣向荣的开源大数据生态！</p><p id="4b44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相信参与DolphinScheduler社区会让你从开源中受益！</p></div></div>    
</body>
</html>