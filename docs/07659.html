<html>
<head>
<title>LeetCode 53. Maximum Subarray — Python Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 53。最大子阵列Python解决方案</h1>
<blockquote>原文：<a href="https://medium.com/codex/leetcode-53-maximum-subarray-python-solution-dab6b038c2c7?source=collection_archive---------5-----------------------#2022-06-21">https://medium.com/codex/leetcode-53-maximum-subarray-python-solution-dab6b038c2c7?source=collection_archive---------5-----------------------#2022-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2bf3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">盲75 —编程和技术面试问题—解释系列</h2></div><h2 id="d54b" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">问题是:</h2><p id="3b89" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">给定一个整数数组<strong class="jx hj"> <em class="ko"> nums </em> </strong>，找出具有最大和的连续子数组(至少包含一个数)并返回其和。<br/> <strong class="jx hj">注意</strong>:子数组是一个数组的连续部分。</p><h2 id="3618" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">制约因素:</h2><ul class=""><li id="e728" class="kp kq hi jx b jy jz kb kc ji kr jm ks jq kt kn ku kv kw kx bi translated">1&lt;= <strong class="jx hj"><em class="ko"/></strong>&lt;= 105</li><li id="32f7" class="kp kq hi jx b jy ky kb kz ji la jm lb jq lc kn ku kv kw kx bi translated">-104&lt;= <strong class="jx hj"><em class="ko">nums【I】</em></strong>&lt;= 104</li></ul><h2 id="ed1e" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">示例:</h2><p id="f930" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated"><strong class="jx hj">例1: </strong></p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="88c5" class="ix iy hi li b fi lm ln l lo lp"><strong class="li hj">Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]<br/><strong class="li hj">Output:</strong> 6<br/><strong class="li hj">Explanation:</strong> [4,-1,2,1] has the largest sum = 6.</span></pre><p id="8ce1" class="pw-post-body-paragraph jv jw hi jx b jy lq ij ka kb lr im kd ji ls kf kg jm lt ki kj jq lu kl km kn hb bi translated"><strong class="jx hj">例2: </strong></p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="a1e1" class="ix iy hi li b fi lm ln l lo lp"><strong class="li hj">Input:</strong> nums = [1]<br/><strong class="li hj">Output:</strong> 1</span></pre><p id="3691" class="pw-post-body-paragraph jv jw hi jx b jy lq ij ka kb lr im kd ji ls kf kg jm lt ki kj jq lu kl km kn hb bi translated"><strong class="jx hj">例3: </strong></p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="6951" class="ix iy hi li b fi lm ln l lo lp"><strong class="li hj">Input:</strong> nums = [5,4,-1,7,8]<br/><strong class="li hj">Output:</strong> 23</span></pre><figure class="ld le lf lg fd lw er es paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="er es lv"><img src="../Images/661dcd1a1f10ddeb96ea31cea93c2a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HDiqqKBthX_DvZfQ.png"/></div></div></figure><h2 id="b696" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">解释是:</h2><p id="dd90" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">这是一个动态编程问题，即使考虑到这一点，也很容易被这个问题绊倒。与大多数DP问题一样，您创建一个数组来跟踪您计算的值。对于这个问题，这将是子阵列的总和。当然还有强力解决方案O(n ),其中使用嵌套的for循环并计算每一个和，但是DP解决方案是O(n ),并且代码行更少。如果面试官说你有无限的时间，但空间只能容纳1个变量，即最大和(这是假设的，可能不会发生)，那么理解暴力解决方案是有好处的。继续DP解决方案，您需要一个与nums长度相同的数组，以及一个要跟踪以返回的max sum。对于数组中的每个元素，它将等于先前的总和加上当前元素<strong class="jx hj"> nums </strong>或当前元素<strong class="jx hj">nums<em class="ko">nums</em>T26】中的较大值。那么最大和将被更新为其自身和这个新计算的和的最大值。一旦<strong class="jx hj"> <em class="ko"> nums </em> </strong>数组迭代完毕，返回最大和。</strong></p><h2 id="1996" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">强力解— O(n)</h2><p id="f7d6" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">LeetCode上的这个解决方案会超过时间限制，但会起作用。我只是把它放在这里让大家看看。首先保存<strong class="jx hj"> <em class="ko"> nums </em> </strong>数组的长度只是为了一点时间提升。然后检查拐角情况，如果长度是1，那么只返回一个元素。之后，将最大和设置为数组的第一个元素。然后遍历数组从0到长度为<strong class="jx hj"> <em class="ko"> nums </em> </strong>减1，做一个当前的sum变量并设置为<strong class="jx hj"><em class="ko">nums【I】</em></strong>，然后使用嵌套for-loop从i + 1迭代到长度为<strong class="jx hj"> <em class="ko"> nums </em> </strong>。将<strong class="jx hj"> <em class="ko"> nums[j] </em> </strong>加到当前总和，并将最大总和设置为自身、当前总和和<strong class="jx hj"> <em class="ko"> nums[j]的最大值。一旦循环结束，返回最大和。</em></strong></p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="d8e5" class="ix iy hi li b fi lm ln l lo lp">class Solution:<br/> def maxSubArray(self, nums: List[int]) -&gt; int:<br/>  len_n = len(nums)</span><span id="afae" class="ix iy hi li b fi md ln l lo lp">  if len_n == 1:<br/>   return nums[0]<br/> <br/>  max_sum = nums[0]<br/> <br/>  for i in range(len_n — 1):<br/>   curr_sum = nums[i]<br/> <br/>  for j in range(i + 1, len_n):<br/>   curr_sum += nums[j]<br/>   max_sum = max(max_sum, curr_sum, nums[j])<br/> <br/>  return max_sum</span></pre><h2 id="ee86" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">动态规划解— O(n):</h2><p id="5dfe" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">同样，由于<strong class="jx hj"> <em class="ko"> nums </em> </strong>数组的长度将被多次使用，将其保存到一个变量中。然后检查拐角情况，如果长度为1，则返回数组中唯一的元素。然后创建一个数组来保存总和。然后追加第一个元素<strong class="jx hj"> <em class="ko"> nums </em> </strong>，因为元素0永远只是它自己。然后将最大总和设置为该值。然后从1开始迭代到<strong class="jx hj"> <em class="ko"> nums </em> </strong>的长度，并在这个for循环中追加前一个总和的最大值加上<strong class="jx hj"><em class="ko">nums【I】</em></strong>和just<strong class="jx hj"><em class="ko">nums【I】</em></strong>。然后将max sum设置为自身和当前sum的最大值(<strong class="jx hj"><em class="ko">【sums【I】</em></strong>)。一旦完成这个循环的迭代，返回最大和。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="ea16" class="ix iy hi li b fi lm ln l lo lp">class Solution:<br/> def maxSubArray(self, nums: List[int]) -&gt; int:<br/>  len_n = len(nums)<br/> <br/>  if len_n == 1:<br/>   return nums[0]<br/> <br/>  sums = []<br/>  sums.append(nums[0])<br/>  max_sum = nums[0]<br/> <br/>  for i in range(1, len_n):<br/>   sums.append(max(sums[i — 1] + nums[i], nums[i]))<br/>   max_sum = max(max_sum, sums[i])<br/> <br/>  return max_sum</span></pre><figure class="ld le lf lg fd lw er es paragraph-image"><div class="er es me"><img src="../Images/2f72450fb85934b0629ca1f8367778e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/0*aV7vcNFF9OhCSDVS.png"/></div></figure><h1 id="2719" class="mf iy hi bd iz mg mh mi jd mj mk ml jh io mm ip jl ir mn is jp iu mo iv jt mp bi translated">信息:</h1><p id="7862" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">网址:<a class="ae mq" href="http://www.nkwade.dev/" rel="noopener ugc nofollow" target="_blank">nkwade . dev</a><br/>LinkedIn:<a class="ae mq" href="http://www.linkedin.com/in/nkwade/" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/nkwade</a><br/>GitHub:<a class="ae mq" href="http://www.github.com/nkwade" rel="noopener ugc nofollow" target="_blank">github.com/nkwade</a><br/>邮箱:<a class="ae mq" href="mailto:nicholas@nkwade.dev" rel="noopener ugc nofollow" target="_blank"> nicholas@nkwade.dev </a></p></div></div>    
</body>
</html>