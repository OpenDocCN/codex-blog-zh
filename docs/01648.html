<html>
<head>
<title>Sorting Algorithms 101: Bubble Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排序算法101:冒泡排序</h1>
<blockquote>原文：<a href="https://medium.com/codex/sorting-algorithms-101-bubble-sort-cfc7df8fb6aa?source=collection_archive---------13-----------------------#2021-05-18">https://medium.com/codex/sorting-algorithms-101-bubble-sort-cfc7df8fb6aa?source=collection_archive---------13-----------------------#2021-05-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/da7d5ff1ab3ceeea1ace5eb8b911929b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nOXKRGkthEVOeWi4"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@renolaithienne?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雷诺·莱蒂恩</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6d79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于编码技术面试，我发现最令人畏惧的事情之一是对数据结构和算法的过分强调。也许是因为我来自一个训练营的背景，这不是很重要的话题——但不管我和谁说话(是否有计算机科学学位),这都是一个经过严格测试的话题，也是面试时必须知道的。</p><p id="884c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在这个由五部分组成的迷你系列中，我将介绍五种最流行的排序算法。今天，我将回顾冒泡排序，选择、插入、合并和快速排序将在后续文章中讨论。</p><p id="6182" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你准备好了，让我们开始吧！</p><h1 id="a99a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">冒泡排序:工作原理</strong></h1><p id="0e87" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">冒泡排序是最简单的排序算法。它的工作原理是比较相邻的元素，如果它们的顺序不对，就交换它们。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8928" class="lf ju hi lb b fi lg lh l li lj">list = [ 4, 7, 1, 6, 10, 8, 3, 9, 7, 5, 2 ]</span></pre><p id="bd7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就拿上面的<code class="du lk ll lm lb b">list</code>来说吧。目标是从升序对这个列表进行排序。所以，在上面的例子中，从1一直到10。</p><p id="3e99" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第一次迭代中，冒泡排序从列表中的第一个元素(本例中为4)开始，并与第二个元素(7)进行比较。如果第一个元素大于第二个元素，则两者交换位置。如果第一个元素<em class="ln">不比第二个数字</em>大，那么什么都不会发生，我们继续处理列表中的下两个元素(7和1)。</p><p id="9c7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为7大于1，所以这两个数字交换了位置，我们再次移动到下两个元素(7和6)。当7大于6时，这两个数字交换位置，我们继续下两个元素(7和10)。因为7不大于10，所以没有交换发生，我们移到10和8。这个过程一直持续到我们到达列表的末尾，在那里10和2交换了位置，产生了下面的列表:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4cea" class="lf ju hi lb b fi lg lh l li lj">list = [ 4, 1, 6, 7, 8, 3, 9, 7, 5, 2, 10 ]</span></pre><p id="13e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，10是列表中最高的数字，并且位于正确的位置，但是列表的其余部分仍然是无序的。因此，我们将再次遍历列表，重复循环。</p><p id="5b7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继续第二次迭代，我们从4开始，重复上面的过程。在第二次迭代结束时，我们得到下面的列表:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3ab6" class="lf ju hi lb b fi lg lh l li lj">list = [ 1, 4, 6, 7, 3, 8, 7, 5, 2, 9, 10 ]</span></pre><p id="5bda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，9和10都在正确的位置上，但是有几个数字仍然是乱序的。为了解决这个问题，我们需要对这个列表执行<em class="ln"> n </em>次迭代<em class="ln"> n </em>次，以将所有内容排序(<em class="ln"> * n表示列表中元素的数量)。</em></p><p id="f133" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最终，当不再发生交换时，排序算法停止，这意味着所有元素都在正确的位置，列表最终按升序排序。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3ab4" class="lf ju hi lb b fi lg lh l li lj">list = [ 1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10 ]</span></pre><h1 id="1811" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">时间复杂度</h1><p id="925e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">由于我们需要遍历列表<em class="ln"> n </em>次来完成排序，所以冒泡排序具有<strong class="ix hj">时间复杂度</strong>或<strong class="ix hj">大O符号</strong>的<strong class="ix hj"> O(n2) </strong>。</p><p id="1b9e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为什么是O(n2)？</p><p id="f144" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，我们有<em class="ln"> n = 11 </em>个元素。当我们遍历数组长度时，我们第一次遍历了<em class="ln"> n </em> (11)个元素。然后，我们一次又一次地遍历这个列表。理论上，对于一个完全未排序的列表，我们遍历列表中的每个元素(<em class="ln"> n </em>，对于列表的大小(<em class="ln"> n </em>，导致时间复杂度为(<em class="ln"> n x n </em>，或者(<em class="ln"> n2 </em>)。</p><h1 id="39d4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">算法</h1><p id="d4da" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在我们已经有了理论，让我们建立自己的冒泡排序算法！<em class="ln"> *下面的代码是用Python写的，但是无论你选择什么语言，一般的逻辑应该是一样的。</em></p><p id="1efe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简单来说，首先选择并比较列表中的前两个数字:<code class="du lk ll lm lb b">arr[0] &gt; arr[1]</code>。</p><p id="8080" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们不只是处理前两个数字，所以让我们添加一个for循环，让它遍历数组。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3ef1" class="lf ju hi lb b fi lg lh l li lj">for num in range (len(arr) - 1):<br/>    arr[num] &gt; arr[num + 1]</span></pre><p id="a8eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请记住，我们使用<code class="du lk ll lm lb b">len(arr) - 1</code>是因为我们不需要遍历最后一个数字，因为没有第二个数字可供比较！</p><p id="b7d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在要执行实际的交换，我们可以动态地重新分配这两个值:<code class="du lk ll lm lb b">arr[num], arr[num + 1] = arr[num + 1], arr[num]</code></p><p id="d634" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们只希望交换发生在<em class="ln">if</em>arr[num]&gt;arr[num+1]的情况下，我们将抛出一个if语句:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4193" class="lf ju hi lb b fi lg lh l li lj">for num in range (len(arr) - 1):<br/>    if arr[num] &gt; arr[num + 1]:<br/>        <!-- -->arr[num], arr[num + 1] = arr[num + 1], arr[num]</span></pre><p id="fbc0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不过，这还不完全是。上面的代码将只覆盖列表的第一次迭代。那么，如何通过<em class="ln">迭代n次</em>呢？</p><p id="a684" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一种方法是针对列表中的元素数量运行一个循环。例如，使用文章开头的<code class="du lk ll lm lb b">list</code>，我们运行上面的代码11次。虽然这不是非常有效的代码，因为如果你在第四次或第五次迭代中得到一个排序列表，循环仍然会继续，这使得效率很低。</p><p id="4a40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实现这一点的另一种方法是在布尔值的帮助下加入状态跟踪器。当状态跟踪器为<code class="du lk ll lm lb b">True</code>时，我们进入while循环，在这里我们将状态跟踪器重置为<code class="du lk ll lm lb b">False</code>(以防止无限while循环)，然后进入for循环。</p><p id="06f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">for循环将继续贯穿数组的长度(减1)，直到一个数大于另一个数。当这种情况发生时，交换最终会发生。然后，我们将状态跟踪器重置为<code class="du lk ll lm lb b">True</code>，跳出for循环，并重新开始while循环。</p><p id="e88d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在最后一次迭代中，当列表被完全排序，并且没有交换发生时，状态跟踪器将永远不会被重置为<code class="du lk ll lm lb b">True</code>，从而脱离while循环并结束排序算法。</p><p id="d3d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我知道—这有很多措辞，但是下面的代码总结了所有这些:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b078" class="lf ju hi lb b fi lg lh l li lj">def bubble_sort(arr):<br/>    swap_happened = True  <br/>    while swap_happened:<br/>        swap_happened = False <br/>        for num in range(len(arr) - 1):<br/>            if arr[num] &gt; arr[num + 1]:<br/>                arr[num], arr[num + 1] = arr[num + 1], arr[num]<br/>                swap_happened = True</span></pre><p id="2073" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而且，就是这样！希望这篇冒泡排序教程给了你一个良好的基础。如果你仍然有疑问，最好是进行一些练习。我最好的建议是查看Leet代码上的练习题，然后从那里开始。</p><p id="4a8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请继续关注本系列的下一个主题:选择排序！回头见。感谢阅读！</p></div></div>    
</body>
</html>