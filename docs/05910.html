<html>
<head>
<title>Golang Wrapper for Receiver Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">接收器函数的Golang包装器</h1>
<blockquote>原文：<a href="https://medium.com/codex/golang-wrapper-for-receiver-function-277921d93edd?source=collection_archive---------5-----------------------#2022-04-02">https://medium.com/codex/golang-wrapper-for-receiver-function-277921d93edd?source=collection_archive---------5-----------------------#2022-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a1c02072a37b8da6558ea429c43f4f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gi4oPFgGbfwupZgyzWg85g.png"/></div></div></figure><p id="3f92" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里讨论的包装器是Golang中的一种设计模式，用另一个函数包装一个结构的函数。包装函数可以在不改变原始函数的情况下，在原始函数之前或之后运行一组执行。您可能会发现这类似于适配器、代理或装饰设计模式的术语。</p><p id="0ea3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">面向对象编程中的对象或类可以用Golang中的struct来表示。接收器函数是在函数参数列表中有接收器(其结构)的结构的方法。<a class="ae jo" href="https://go.dev/tour/methods/1" rel="noopener ugc nofollow" target="_blank"> <em class="jp">巡回围棋</em> </a></p><h1 id="9c33" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">基本包装</h1><p id="b93c" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">与接收方函数不同，普通函数可以用一个函数包装，该函数接收原始函数作为参数，并将其作为输出返回。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="f8bc" class="lc jr hi ky b fi ld le l lf lg"><strong class="ky hj">type </strong>handlerFunc <strong class="ky hj">func</strong>(param int) <strong class="ky hj">error</strong></span><span id="d03f" class="lc jr hi ky b fi lh le l lf lg"><strong class="ky hj">func </strong>Wrapper(aFunc handlerFunc) handlerFunc {<br/>   <strong class="ky hj">return func</strong>(param int) <strong class="ky hj">error </strong>{<br/>      // Do wrapper stuff<br/>      <strong class="ky hj">defer func</strong>() { // Do post-wrapper stuff }()<br/>      <strong class="ky hj">return </strong>aFunc(param)<br/>   }<br/>}</span></pre><p id="6e06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接收器功能有一个不同的故事。它有自己的结构作为专门的参数。因此，函数总是可以访问结构值。基本上，接收器函数是在结构类型内部定义的函数，只能从结构中调用。为了制作这种功能的包装器，可以像以前一样用基本的普通包装器来实现。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="30bd" class="lc jr hi ky b fi ld le l lf lg"><strong class="ky hj">type </strong>app <strong class="ky hj">struct </strong>{}</span><span id="dc34" class="lc jr hi ky b fi lh le l lf lg"><strong class="ky hj">func </strong>(app *app) Run() <strong class="ky hj">error </strong>{<br/>   // Execute application<br/>}</span><span id="9477" class="lc jr hi ky b fi lh le l lf lg"><strong class="ky hj">func </strong>appRun(app *app) <strong class="ky hj">error </strong>{<br/>   // Do wrapper stuff<br/>   <strong class="ky hj">defer </strong>func() { // Do post-wrapper stuff }<br/>   <strong class="ky hj">return </strong>app.Run()<br/>}</span><span id="92f8" class="lc jr hi ky b fi lh le l lf lg"><strong class="ky hj">func </strong>main() {<br/>   myApp := &amp;app{}</span><span id="2b6f" class="lc jr hi ky b fi lh le l lf lg">   // Run without wrapper<br/>   err := myApp.Run()</span><span id="9ca4" class="lc jr hi ky b fi lh le l lf lg">   // Run with wrapper<br/>   err = appRun(myApp)<br/>}</span></pre><p id="34e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然这种包装方法很简单，但是它有很多缺点。</p><ul class=""><li id="0980" class="li lj hi is b it iu ix iy jb lk jf ll jj lm jn ln lo lp lq bi translated">如果struct有很多函数，并且也想要包装器效果，该怎么办？</li><li id="0a17" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">如何实现对所有使用接收器函数的下游依赖项的包装？</li><li id="8050" class="li lj hi is b it lr ix ls jb lt jf lu jj lv jn ln lo lp lq bi translated">如果结构体有一个新的函数也需要包装器效果，会发生什么呢？</li></ul><h1 id="8dc0" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">接收器包装</h1><p id="ac60" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">接收器函数的包装类型必须是<strong class="is hj">可伸缩的</strong>和<strong class="is hj">可靠的</strong>。可伸缩意味着包装器支持接收方函数的任何扩展，而无需花费太多精力来维护它。可靠意味着包装器在任何时候都跨依赖项产生一致的结果和性能。</p><p id="726d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解决方案之一是创建一个新的包装结构来模仿原始结构。为了完全模仿原始结构，包装器结构将具有与原始接收器函数相同的所有函数。最后，包装接收器函数将在调用原始函数之前或之后包含前置或后置指令。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="0f98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，该方法可以应用于将包装器集成到任何现有的代码中，而不改变其行为和结构，同时在将来仍然是可伸缩的和可靠的。</p><h1 id="bafa" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">应用程序</h1><h2 id="00f6" class="lc jr hi bd js ly lz ma jw mb mc md ka jb me mf ke jf mg mh ki jj mi mj km mk bi translated">公用事业服务</h2><p id="fd04" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">老实说，可以应用于包装器的实用服务可以是任何东西。例如，常用的是<strong class="is hj">缓存、验证、认证、授权或监控工具</strong>。与功能目的无关的其他服务或指令也可以在包装器中执行。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure><h2 id="b57a" class="lc jr hi bd js ly lz ma jw mb mc md ka jb me mf ke jf mg mh ki jj mi mj km mk bi translated">记录</h2><p id="44b7" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在包装器中，在函数之前或之后将数据或信息打印到日志中可能很有用。尤其是在出于分析或监控目的将数据打印到日志之前，需要首先处理或重构数据时。</p><h2 id="db2f" class="lc jr hi bd js ly lz ma jw mb mc md ka jb me mf ke jf mg mh ki jj mi mj km mk bi translated">版本控制</h2><p id="2387" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">假设我们有一个不推荐使用的特性，需要更新一个新版本。问题是代码有大量的下游依赖，需要在不影响多方的情况下部分推出。用验证包装函数是解决方案之一。这样，任何与新版本兼容的请求都将被重定向到新版本，而另一个请求仍然使用旧版本。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lw lx l"/></div></figure></div></div>    
</body>
</html>