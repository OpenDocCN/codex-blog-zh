<html>
<head>
<title>How I implemented Command Pattern in Spring boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在Spring boot中实现命令模式</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-i-implemented-command-pattern-in-spring-boot-870c1f2c73b0?source=collection_archive---------3-----------------------#2021-01-05">https://medium.com/codex/how-i-implemented-command-pattern-in-spring-boot-870c1f2c73b0?source=collection_archive---------3-----------------------#2021-01-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/f7f540d0edad398f9f99c9e4d3927c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TsxFJWjRX0VBHX27"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">汉娜·乔舒亚在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="e504" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您熟悉命令设计模式，当您看到这一点并开始思考该实现与标准java或任何其他编程语言有何不同时，您可能会感到困惑。别担心，这样想很正常。相信我，当我第一次开始思考这个问题时，我也有同样的感觉。</p><p id="f52f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事实是，从根本上来说没有什么不同，但是让我们来探索如何利用Spring强大的IoC(控制反转)框架，并简化命令模式的实现。</p><p id="4465" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一个命令设计模式组件交互的概览。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es jt"><img src="../Images/20e21e698a590d1d0961737e672cd408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/0*6oUbVtWy6-wRlZ6C.jpg"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">来源:维基百科</figcaption></figure><p id="5122" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上图中，我们可以看到这个模式中的3个主要组件</p><p id="7822" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">调用者</strong>是第一个接收请求(用户交互、web API调用等)的人。示例代码可以在这里找到。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es jy"><img src="../Images/126640b81222798731df516e6178695b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*THiIe8uNEY5AX6zeMoomJQ.png"/></div></figure><p id="eda8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">‘Command’</strong>是一个命令接口的具体实现，它抽象了如何执行用户请求。对于给定的应用程序，可以有许多具体的命令类。通常，应用程序必须通过构建一个映射来收集所有这样的命令，并使其对调用者可用。本文更多地关注如何利用Spring的IoC来创建这个映射，它删除了样板代码。</p><figure class="ju jv jw jx fd hk er es paragraph-image"><div class="er es jz"><img src="../Images/a0cccd984361b03814c96d064af29967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*g1iiECeUV-ART11g-VL8lw.png"/></div></figure><p id="a580" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">‘接收者</strong>’是实际执行业务逻辑的人。Receiver可以是一个单独类中的方法，也可以是command类本身的一部分，以保持简单。</p><p id="6132" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Spring中简化了大量代码的两件事。</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="98c9" class="kf kg hy kb b fi kh ki l kj kk">@Autowired<br/>private Map&lt;String, CommandInterface&gt; commandHandlersMap;</span></pre><p id="5ed7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">和</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="87aa" class="kf kg hy kb b fi kh ki l kj kk">@Service(CommandType.<em class="kl">ADD_</em>)<br/>public class Add implements CommandInterface{</span></pre><p id="093d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们只是用Spring的组件/服务/bean注释来注释所有的命令类，那么spring-context将拥有关于你的类的所有信息。</p><blockquote class="km kn ko"><p id="c1f2" class="iv iw kl ix b iy iz ja jb jc jd je jf kp jh ji jj kq jl jm jn kr jp jq jr js hb bi translated">最好的部分是当我们自动连线命令地图时，如上所示，它完全让我大吃一惊。它用我们作为类定义及其实例的一部分提供的命令名自动填充映射。从字面上看，我们不必手动创建地图并不断添加命令名和它们的实例。这显然去掉了一堆代码行和链接，从而也提高了可读性。</p></blockquote><p id="849b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，缺点是我们将业务逻辑与Spring框架紧密耦合，当我们考虑这一点的好处时，这在我看来并不坏，而且我猜我们不会那么容易地频繁切换到其他平台。</p><p id="ca61" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此处提供了代码示例</p><div class="hh hi ez fb hj ks"><a href="https://github.com/krishnarama/SpringSample" rel="noopener  ugc nofollow" target="_blank"><div class="kt ab dw"><div class="ku ab kv cl cj kw"><h2 class="bd hz fi z dy kx ea eb ky ed ef hx bi translated">克里希纳摩/春天样本</h2><div class="kz l"><h3 class="bd b fi z dy kx ea eb ky ed ef dx translated">示范命令模式的示例springboot应用程序- krishnarama/SpringSample</h3></div><div class="la l"><p class="bd b fp z dy kx ea eb ky ed ef dx translated">github.com</p></div></div><div class="lb l"><div class="lc l ld le lf lb lg hp ks"/></div></div></a></div></div></div>    
</body>
</html>