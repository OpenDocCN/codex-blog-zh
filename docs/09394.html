<html>
<head>
<title>Options API vs. Composition API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">选项API与组合API</h1>
<blockquote>原文：<a href="https://medium.com/codex/options-api-vs-composition-api-4a745fb8610?source=collection_archive---------3-----------------------#2022-10-18">https://medium.com/codex/options-api-vs-composition-api-4a745fb8610?source=collection_archive---------3-----------------------#2022-10-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="71bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您正在Vue 3中开始一个新项目，或者如果您仍在决定是否将现有项目迁移到最新的Vue.js版本，那么这篇文章是为您准备的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/9d7726a570c7da5d52be65a0eb8ee893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QpBrPVr7sTsIY_ocShru1g.png"/></div></div></figure><h1 id="8cf3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我们开始吧</h1><p id="e4f7" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在Vue 2之前，有一种在Vue中创建组件的方法，这种方法现在被称为Options API。在Vue 3中，引入了一种新的方法，称为组合API，您可能想知道区别在哪里？在这篇文章中，我们将看看这两者有什么不同。</p><p id="d036" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从一个简单的选项API设置开始:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="31a7" class="kx jq hi kt b fi ky kz l la lb">export default {<br/>  data() {<br/>    return {<br/>      name: 'Vue 3 App',<br/>    };<br/>  },<br/>  methods: {<br/>    showTxt() {<br/>      console.log(`this is ${this.name}`);<br/>    },<br/>  },<br/>  mounted() {<br/>    this.showTxt();<br/>  },<br/>};</span></pre><p id="1bfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们看一下代码，我们会注意到3件事，它们是<a class="ae lc" href="https://vuejs.org/api/options-state.html" rel="noopener ugc nofollow" target="_blank">选项API </a>的构建块:</p><ul class=""><li id="5824" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated"><a class="ae lc" href="https://vuejs.org/api/options-state.html#data" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">数据:</strong> </a> <strong class="ih hj"> </strong>为组件实例返回初始反应状态的函数，</li><li id="99dc" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated"><a class="ae lc" href="https://vuejs.org/api/options-state.html#methods" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">方法:</strong> </a>声明要混合到组件实例中的方法。声明的方法可以在组件实例上直接访问，或者在模板表达式中使用。声明方法时避免使用箭头函数，因为它们不能通过<em class="lr"> this，</em>访问组件实例</li><li id="7a8e" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated"><a class="ae lc" href="https://vuejs.org/api/options-lifecycle.html#mounted" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">挂载:</strong> </a>这是一个<strong class="ih hj">生命周期钩子</strong>，当组件被创建并插入到DOM中时，组件被挂载。</li></ul><p id="d6a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以在Options API中遇到的、上面代码中没有的其他常见情况有:</p><ul class=""><li id="a4bc" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated"><a class="ae lc" href="https://vuejs.org/guide/components/props.html#props-declaration" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">道具:</strong> </a>组件需要显式的道具声明，这样Vue才知道传递给组件的外部道具应该被当作fallthrough属性，</li><li id="4d1a" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated"><a class="ae lc" href="https://vuejs.org/api/options-state.html#watch" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">观察器</strong> : </a>声明在数据改变时调用观察器回调。监视选项需要一个对象，其中键是要监视的反应组件实例属性(例如，通过数据声明或计算的属性)，值是相应的回调。</li></ul><p id="46fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看一下同一个例子，但是使用了组合API:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="7554" class="kx jq hi kt b fi ky kz l la lb">export default {<br/>  setup() {<br/>    const name = ref('Vue 3 App');<br/>    <br/>    const showTxt = () =&gt; console.log(`This is ${name.value}`);<br/>    <br/>    onMounted(() =&gt; {<br/>      showTxt();<br/>    });<br/>    <br/>    return { name };<br/>  },<br/>};</span></pre><p id="0723" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从代码中我们可以看到，Composition API只使用了<a class="ae lc" href="https://vuejs.org/api/composition-api-setup.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> setup hook </strong> </a>来定义组件，意味着代码少了很多。代码的另一个重要部分是<strong class="ih hj"> ref、</strong>，它使数据具有反应性。它返回一个带有值属性的对象。</p><h1 id="8bcf" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">代码共享</h1><p id="6c00" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Options API和Composition API最大的区别之一就是它们实现代码共享的方式。<strong class="ih hj"> Options API </strong>有两种共享代码的方式，<strong class="ih hj"> mixins </strong>和<strong class="ih hj"> renderless components </strong>。Mixins使用起来可能有点棘手，因为它们很难确定部分代码来自哪里。</p><p id="f958" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据文档，mixins是一种为Vue组件分发可重用功能的灵活方式。mixin对象可以包含任何组件选项。当一个组件使用mixin时，mixin中的所有选项都将“混合”到组件自己的选项中。下面是一个混音的例子:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="f620" class="kx jq hi kt b fi ky kz l la lb">// define a mixin object<br/>var myMixin = {<br/>  created: function () {<br/>    this.helloWorld()<br/>  },<br/>  methods: {<br/>    helloWorld: function () {<br/>      console.log('hello from my mixin!')<br/>    }<br/>  }<br/>}<br/><br/>// define a component that uses this mixin<br/>var Component = Vue.extend({<br/>  mixins: [myMixin]<br/>})</span></pre><p id="9594" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，对于新开发人员来说，使用mixin可能<strong class="ih hj">难以调试和理解</strong>，尤其是当他们处理全局mixin时。它们的使用也会导致<strong class="ih hj">与组件的</strong>命名冲突。</p><p id="0547" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了<strong class="ih hj">组合API，</strong>就不需要mixins了。在设置钩子内部，我们可以<strong class="ih hj">按照逻辑关系</strong>对代码的各个部分进行分组。然后，我们可以提取一些反应式逻辑，并与其他组件共享。</p><p id="239f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们来看看<strong class="ih hj">无渲染组件。</strong>无渲染组件<strong class="ih hj"> </strong>是<strong class="ih hj">不渲染任何自己的HTML </strong>的组件。相反，它只管理状态和行为，让父组件完全控制应该呈现的内容。这意味着，如果你把逻辑从一个UI组件移到一个无渲染组件中，你可以重用它。</p><h1 id="dedd" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">可组合物</h1><p id="d32a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Composition API也支持<strong class="ih hj"> renderless components </strong>，事实上，这是Composition API和Options API的共同点之一。然而，组合API的一个主要优势是<strong class="ih hj"> composables </strong>。它们是可重用的代码，由于它们，我们可以在任何地方编写反应式代码。我们不再局限于Vue组件的范围。下面是一个可组合计数器的简单示例:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="d16f" class="kx jq hi kt b fi ky kz l la lb">import { computed, ref } from 'vue';<br/><br/>export function count() {<br/>  const counter = ref(0);<br/>  const addOne = () =&gt; { counter.value += 1 };<br/>  <br/>  return {<br/>    counter,<br/>    addOne,<br/>  };<br/>}</span></pre><p id="f71c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们可以看到，如何在组件中使用它。</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="ba8d" class="kx jq hi kt b fi ky kz l la lb">&lt;template&gt;<br/>  &lt;div&gt;Count: {{ counter }}&lt;/div&gt;<br/>  &lt;button @click="addOne"&gt; <br/>     +<br/>  &lt;/button&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>import { count } from '../composables/counter-example';<br/><br/>export default {<br/>  setup() {<br/>    const {<br/>      counter,<br/>      addOne,<br/>    } = count();<br/><br/>    return {<br/>      counter,<br/>      addOne,<br/>    };<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="0616" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Composables充当一个外部函数，它提取反应状态和功能，以便跨几个其他组件使用。它们也可以被称为复合函数。有了组件，我们可以准确地告诉<strong class="ih hj">我们的可重用数据和功能来自</strong>。</p><p id="4096" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Composition API的另一个主要优点是，它使模板中的常量和依赖项可用:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="3c20" class="kx jq hi kt b fi ky kz l la lb">&lt;template&gt;<br/>  &lt;div&gt;<br/>  &lt;button @click="create"&gt;<br/>   Save<br/>  &lt;/button&gt;<br/>&lt;/div&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>import { create } from './services';<br/><br/>export default {<br/>  setup() {<br/>    return {<br/>      create,<br/>    };<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="50a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当使用Options API做同样的事情时，会感觉很尴尬。您要么必须将常量和依赖项添加到数据选项中，要么使用创建的钩子将非反应性变量添加到这个上下文中。Composition API为我们省去了一些麻烦，因为我们可以简单地从setup hook中导出它们，并使它们在模板中可用。</p><p id="364c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是对比较的总结和总结，如果你决定迁移到Vue的最新版本，由于上述原因，Composition API可能值得麻烦，因为它非常好地优化了代码，因此会给你的应用程序带来更好的性能。如果你是从零开始，建议使用Composition API。</p></div></div>    
</body>
</html>