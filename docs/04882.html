<html>
<head>
<title>Advanced Python: Abstract Base Class &amp; abc Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级Python:抽象基类和abc模块</h1>
<blockquote>原文：<a href="https://medium.com/codex/advanced-python-abstract-base-class-abc-module-b9b7f60cc289?source=collection_archive---------6-----------------------#2022-01-14">https://medium.com/codex/advanced-python-abstract-base-class-abc-module-b9b7f60cc289?source=collection_archive---------6-----------------------#2022-01-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="435a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python提供了一个包抽象基类(ABC)来帮助实现抽象类，这个模块被称为<code class="du jd je jf jg b">abc</code>是有原因的。抽象类允许开发人员为子类产生蓝图，使其具有特定的行为，所以让我们从一个常见的数据工程场景的用例来看看我们是如何做到这一点的…</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/49fadf49d70e1524a09e357a83131b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fquRvGFZGMQZVHo-"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">Joshua Aragon 在<a class="ae jx" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="8f4d" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">背景上下文</h1><p id="bd6a" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">假设我们正在编写代码，为您的机器学习摄取系统开发一个数据格式转换器，转换成您选择的客户格式。因为数据系统是活的有机体，它们的内部化学一直在变化，而且有大量不同的数据格式可用，所以最好用面向对象的方法来解决这个问题。因此，让我们为转换器创建一个类。</p><p id="3768" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，我们面临的两个主要设计挑战是多种数据格式和输入数据的可能变化。因此，为了解决这个问题，我们需要一个基类，它提供了一个蓝图，必须在我们不同的转换器子类中具有功能。</p><p id="603f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们创建一个抽象类来定义我们的基本转换器的蓝图。我的自定义格式的名称将是<code class="du jd je jf jg b">Naruto</code>。</p><pre class="ji jj jk jl fd lb jg lc ld aw le bi"><span id="de9f" class="lf jz hi jg b fi lg lh l li lj">class NarutoConverter():<br/>    def convert(self): pass<br/>    def clean_string(self): pass</span><span id="2530" class="lf jz hi jg b fi lk lh l li lj">class JSONtoNaruto(NarutoConverter):<br/>    def __init__(self, input_file):<br/>        self.__input = input_file</span></pre><p id="9b28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的转换器有两种方法<code class="du jd je jf jg b">convert</code>将输入格式转换成<code class="du jd je jf jg b">Naruto</code>格式，还有<code class="du jd je jf jg b">clean_string</code>方法处理输入字符串的不同字符串质量。</p><p id="eaa5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，由于我们正在创建抽象类，我们不希望任何人创建这个类的实例，因为它只是转换器的蓝图。然而，我们创建上面这个类的方式并不妨碍这个类的实例化。</p><p id="9dc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述代码的第二个问题是，它没有强制子类实现<code class="du jd je jf jg b">convert</code>和<code class="du jd je jf jg b">clean_string</code>方法的功能。在这种情况下，即使方法没有实现，上面的<code class="du jd je jf jg b">JSONtoNaruto</code>代码也不会抛出错误。让我们在下一节看看如何处理这些问题。</p><h1 id="a0cf" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Python的abc模块</h1><p id="54bb" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">现在让我们看看如何用<code class="du jd je jf jg b">abc</code>库声明<code class="du jd je jf jg b">NarutoConverter</code>并实现我们的抽象目标。</p><pre class="ji jj jk jl fd lb jg lc ld aw le bi"><span id="3269" class="lf jz hi jg b fi lg lh l li lj">from abc import ABC, abstractmethod</span><span id="ed2b" class="lf jz hi jg b fi lk lh l li lj">class NarutoConverter(ABC):</span><span id="902c" class="lf jz hi jg b fi lk lh l li lj">    @abstractmethod<br/>    def convert(self): pass</span><span id="7bf0" class="lf jz hi jg b fi lk lh l li lj">    @abstractmethod<br/>    def clean_string(self): pass</span></pre><p id="d715" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本方法包括从<code class="du jd je jf jg b">abc</code>模块创建一个抽象类作为<code class="du jd je jf jg b">ABC</code>的子类，并在每个抽象方法声明之前使用装饰器<code class="du jd je jf jg b">@abstractmethod</code>。这有助于将抽象类功能增强到您的自定义子类中。现在，如果我们试图实例化<code class="du jd je jf jg b">NarutoConverter</code>类，它将引发一个异常并阻止这个抽象类的实例化。现在让我们看看子类<code class="du jd je jf jg b">JSONtoNaruto</code>的实现。</p><pre class="ji jj jk jl fd lb jg lc ld aw le bi"><span id="2d52" class="lf jz hi jg b fi lg lh l li lj">class JSONtoNaruto(NarutoConverter):</span><span id="193c" class="lf jz hi jg b fi lk lh l li lj">def __init__(self, input_file):<br/>        self.__input = input_file<br/>   <br/>    def convert(self):<br/>        naruto_file = self.__input<br/>        return naruto_file</span><span id="f91d" class="lf jz hi jg b fi lk lh l li lj">    def clean_string(self):<br/>        clean_str = self.__input.str<br/>        return clean_str</span></pre><p id="b9a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们实现了这两种方法。如果我们在没有实现任何一个方法的情况下运行代码，那么<code class="du jd je jf jg b">python</code>会引发以下错误。这种行为是通过使用<code class="du jd je jf jg b">@abstractmethod</code> decorator来实现的，它可以防止没有方法实现的类实例化。</p><pre class="ji jj jk jl fd lb jg lc ld aw le bi"><span id="ec24" class="lf jz hi jg b fi lg lh l li lj">TypeError: Can't instantiate abstract class JSONtoNaruto with abstract methods convert</span><span id="94a6" class="lf jz hi jg b fi lk lh l li lj">TypeError: Can't instantiate abstract class JSONtoNaruto with abstract methods clean_string</span></pre><h1 id="54ae" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="4a92" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">数据工程处理管道，由于管道DAG中有许多移动部分，面向对象是设计管道代码时非常常见的方法。设计类的蓝图是数据工程师经常处理的事情(除非你是一个函数式编程范型的人),以产生可重用的管道组件。抽象类提供了一种简单的方法来为各种管道组件提供设计蓝图，并在扩展时保持代码库的整洁、逻辑和可管理性。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h2 id="8c86" class="lf jz hi bd ka ls lt lu ke lv lw lx ki iq ly lz km iu ma mb kq iy mc md ku me bi translated">请务必关注并订阅，以便尽早获取内容。</h2><p id="df8f" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated"><strong class="ih hj"> <em class="mf">关于我:我是一名数据工程师，在GCP、SQL和Python堆栈方面经验丰富，帮助初创公司设置和扩展他们的数据基础设施。想合作吗？在</em></strong><a class="ae jx" href="https://www.linkedin.com/in/yuvrender-gill/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="mf">Linkedin</em></strong></a><strong class="ih hj"><em class="mf">上联系我。</em> </strong></p></div></div>    
</body>
</html>