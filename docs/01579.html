<html>
<head>
<title>Let’s make a Swift property wrapper that ignores variables when en/decoding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们制作一个Swift属性包装器，在编码/解码时忽略变量</h1>
<blockquote>原文：<a href="https://medium.com/codex/lets-make-a-swift-property-wrapper-that-ignores-variables-when-en-decoding-7a2e270519eb?source=collection_archive---------3-----------------------#2021-05-14">https://medium.com/codex/lets-make-a-swift-property-wrapper-that-ignores-variables-when-en-decoding-7a2e270519eb?source=collection_archive---------3-----------------------#2021-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d3ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们创建了一个属性包装器，可以用来在编码或解码对象时“跳过”属性。当我们想给一个不需要编码的对象添加属性时，这是很有用的，特别是当这些属性本身不可编码时。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d1e17daed245e5cc72563ce1f13022b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1UHZAgitB4CYniTbtx3zWg.jpeg"/></div></div></figure><h2 id="38c2" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">可编码协议和Swift的自动一致性综合</h2><p id="e614" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">让我们首先回顾一下可编码协议的基础，看看Swift综合符合该协议的能力。</p><p id="3b79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您正在Swift中定义一个模型:</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="c8fd" class="jp jq hi kq b fi ku kv l kw kx"><strong class="kq hj">struct</strong> MyModel {<br/>   <strong class="kq hj">let</strong> id: Int<br/>   <strong class="kq hj">let</strong> name: String<br/>}</span></pre><p id="d5ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您决定这个模型应该是“可编码的”——您希望能够将其编码到<em class="ky">编码器</em>中，或者从<em class="ky">解码器中解码。</em>幸运的是，Swift非常聪明，让这一切变得非常简单。你所要做的就是声明这个模型是可编码的:</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="7044" class="jp jq hi kq b fi ku kv l kw kx"><strong class="kq hj">struct</strong> MyModel: Codable {<br/>   <strong class="kq hj">let</strong> id: Int<br/>   <strong class="kq hj">let</strong> name: String<br/>}</span></pre><p id="36cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Swift已经为我们综合了协议的实现，因为结构中的每个字段都已经符合Codable。</p><h2 id="fc07" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">添加一个不可编码的属性，以及我们为什么要跳过它</h2><p id="c17e" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">Swift综合符合可编码协议的能力，除了简单地在结构名后添加<code class="du kz la lb kq b">: Codable</code>之外，我们无需编写任何代码，这非常方便，但它也有一个警告。结构或类<em class="ky">中的每个属性必须</em>本身是可编码的。如果我们添加了一个不可编码的属性，我们就失去了神奇的一致性。</p><p id="6611" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们现在就开始吧:</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="58ed" class="jp jq hi kq b fi ku kv l kw kx"><strong class="kq hj">struct</strong> MyModel: Codable {<br/>   <strong class="kq hj">let</strong> id: Int<br/>   <strong class="kq hj">let</strong> name: String<br/>   <br/>   /// Cached formatted name<br/>   <strong class="kq hj">var</strong> formattedName: NSAttributedString? = nil<br/>}</span></pre><p id="66ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kz la lb kq b">NSAttributedString</code>不符合<code class="du kz la lb kq b">Codable</code>，所以Swift无法再合成一致性。整个结构亮起来，显示错误“类型‘my model’不符合协议‘Codable’”。</p><p id="57e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想在这个模型上持久化所有数据，我们必须为我们的结构实现协议存根(即<code class="du kz la lb kq b">encode(to:)</code>和<code class="du kz la lb kq b">init(from:)</code>)。在这样做的时候，即使我们只添加了一个不可编码的字段，我们现在负责编码和解码每一个字段。</p><p id="3dac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，仔细看看我们刚刚做出的改变，我们可能会意识到一些事情:我们实际上并不想坚持新的领域！我们只是想在显示模型时，用它作为缓存来存储一些格式化的文本。如果我们能以某种方式告诉Swift，这个字段在对对象进行编码时并不重要——它应该被跳过——那么我们可能会重新获得自动合成。</p><p id="d471" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，我们的目标是能够像这样声明我们的模型，并让Swift自动为我们处理编码和解码:</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="5fde" class="jp jq hi kq b fi ku kv l kw kx"><strong class="kq hj">struct</strong> MyModel: Codable {<br/>   <strong class="kq hj">let</strong> id: Int<br/>   <strong class="kq hj">let</strong> name: String<br/>   <br/>   /// Cached formatted name<br/>   @NotCoded <strong class="kq hj">var</strong> formattedName: NSAttributedString<br/>}</span></pre><h2 id="f450" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">实施时间</h2><p id="7da6" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们如何实现这一点？首先，它显然将是一个<a class="ae lc" href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html" rel="noopener ugc nofollow" target="_blank">属性包装器</a>。此外，要实现这一点，包装的属性必须符合Codable，这样Swift就能够为任何具有NotCoded属性的结构合成协议一致性。重要的是，当我们为属性包装器实现一致性时，我们实际上并不关心实现；我们基本上对Swift撒谎，说一个<code class="du kz la lb kq b">NotCoded</code>属性是可编码的，然后实际上让它不做任何编码或解码工作。</p><p id="e7cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这提出了一个问题:如果我们实际上不打算解码任何东西，那么当解码时，<code class="du kz la lb kq b">NotCoded</code>属性的值应该是什么呢？我们需要某种默认值。在Swift中做到这一点最简单的方法是默认使用<code class="du kz la lb kq b">nil</code>，这就是我们在这里要做的，但是如果你的项目中已经有了类似于<code class="du kz la lb kq b">DefaultInitable</code>的协议，允许你在一致性实例上调用<code class="du kz la lb kq b">init()</code>，你可以在其中工作。</p><p id="d167" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是实施的时候了:</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="e40b" class="jp jq hi kq b fi ku kv l kw kx">/// A property wrapper for properties of a type that should be "skipped" when the type is encoded or decoded.</span><span id="9ec3" class="jp jq hi kq b fi ld kv l kw kx"><strong class="kq hj">@propertyWrapper<br/>public</strong> <strong class="kq hj">struct</strong> NotCoded&lt;Value&gt; {<br/>  <strong class="kq hj">private</strong> <strong class="kq hj">var</strong> value: Value?</span><span id="66b0" class="jp jq hi kq b fi ld kv l kw kx"><strong class="kq hj">  public</strong> <strong class="kq hj">init</strong>(wrappedValue: Value?) {<br/>    <strong class="kq hj">self</strong>.value = wrappedValue<br/>  }</span><span id="2b9e" class="jp jq hi kq b fi ld kv l kw kx"><strong class="kq hj">  public</strong> <strong class="kq hj">var</strong> wrappedValue: Value? {<br/>    <strong class="kq hj">get</strong> { value }<br/>    <strong class="kq hj">set</strong> { <strong class="kq hj">self</strong>.value = newValue }<br/>  }<br/>}</span><span id="eef6" class="jp jq hi kq b fi ld kv l kw kx"><strong class="kq hj">extension</strong> NotCoded: Codable {<br/>  <strong class="kq hj">public</strong> <strong class="kq hj">func</strong> encode(to encoder: Encoder) <strong class="kq hj">throws</strong> {<br/>    // Skip encoding the wrapped value.<br/>  }</span><span id="d541" class="jp jq hi kq b fi ld kv l kw kx"><strong class="kq hj">  public</strong> <strong class="kq hj">init</strong>(from decoder: Decoder) <strong class="kq hj">throws</strong> {<br/>    // The wrapped value is simply initialised to nil when decoded.<br/>    <strong class="kq hj">self</strong>.value = <strong class="kq hj">nil<br/>  </strong>}<br/>}</span></pre><p id="fc0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们用<code class="du kz la lb kq b">nil</code>表示未解码的字段，我们必须对我们的模型结构做一个小小的改变；缓存的值是可选的:</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="63bf" class="jp jq hi kq b fi ku kv l kw kx"><strong class="kq hj">struct</strong> MyModel: Codable {<br/>   <strong class="kq hj">let</strong> id: Int<br/>   <strong class="kq hj">let</strong> name: String<br/>   <br/>   /// Cached formatted name<br/>   @NotCoded <strong class="kq hj">var</strong> formattedName: NSAttributedString?<br/>}</span></pre><h2 id="0aaf" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">我们还可以用这个模式做什么？</h2><p id="588a" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们可以使用这种模式将一个字段标记为“跳过”，这样Swift就可以为我们的类型合成协议一致性。除了可编码之外，我们还可以用可散列的(例如，如果一个结构包含本身不可散列的字段)、可等价的等等来实现。</p><p id="a1c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是除了保留自动协议一致性合成，我们还可以使用这种模式来改变代码的行为。考虑一个非散列属性包装，其工作原理与非编码相同。当然，我们可以包装<em class="ky">任何</em>属性来跳过散列，包括那些会修改对象散列的属性。假设我们有这样一个模型:</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="4da2" class="jp jq hi kq b fi ku kv l kw kx">struct BookModel {<br/>  let id: Int<br/>  let name: String<br/>  let rating: Int<br/>}</span></pre><p id="5ada" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据我们的使用情况，我们可能不希望在散列时包括一本书的评级。例如，如你所知，当一个类型是可散列的，它也是等价的。如果我们想检查两本书是否相同，比如说，在一个数组中查找重复的内容，我们不希望ID和名称相同的两本书因为评级不同而被认为不同。</p><p id="3b26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，一旦我们基于上面演示的模式定义了我们的<code class="du kz la lb kq b">NotHashed</code>包装器，我们就可以修改我们的模型，如下所示:</p><pre class="je jf jg jh fd kp kq kr ks aw kt bi"><span id="7380" class="jp jq hi kq b fi ku kv l kw kx">struct BookModel: Hashable {<br/>  let id: Int<br/>  let name: String<br/>  @NotHashed let rating: Int<br/>}</span></pre><p id="bb57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然你在做这样的事情时应该小心；也许可以添加清晰的文档，解释一些字段被排除在对象的散列之外。但是如果你在散列、编码、解码等时需要跳过字段，希望这种模式能让你的生活更轻松。</p></div></div>    
</body>
</html>