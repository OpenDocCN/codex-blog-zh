<html>
<head>
<title>Communication inside a Kubernetes Pod — Why do we need multi-container pods?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes Pod内部的通信——为什么我们需要多容器Pod？</h1>
<blockquote>原文：<a href="https://medium.com/codex/communication-inside-a-kubernetes-pod-why-do-we-need-multi-container-pods-3d8d0d64c2c9?source=collection_archive---------0-----------------------#2022-06-09">https://medium.com/codex/communication-inside-a-kubernetes-pod-why-do-we-need-multi-container-pods-3d8d0d64c2c9?source=collection_archive---------0-----------------------#2022-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ae09" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">从“进程内”和“进程外”的设计理念来探讨pod中的多容器模式。</h2></div><p id="ff88" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了理解对多容器容器的需求，我想后退一点，从容器不可知环境中的一般应用程序开始。</p><p id="91d7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">传统上，一个应用程序将由一个单一的流程组成，该流程具有业务逻辑以及横切&amp;基础设施关注点(如日志记录、弹性、配置)。通常会有专用的SDK库(例如。NET Polly，这是一个错误处理库)&amp;该应用程序是围绕这样的库实现的，主要使用依赖注入。或者有一个自定义实现。两种方法都遵循“<strong class="iz hj">过程中”</strong>设计<strong class="iz hj">。</strong></p><p id="7747" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们将应用程序和横切关注点放在一起时，我们将业务逻辑与运营/基础设施逻辑耦合在一起，我们正在创建一个<strong class="iz hj">高耦合&amp;低内聚设计</strong>。</p><p id="476a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是“过程中”的设计有它的好处—</p><ol class=""><li id="06f6" class="jt ju hi iz b ja jb jd je jg jv jk jw jo jx js jy jz ka kb bi translated">直接实施和调试。</li><li id="1273" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">简单的部署和监控。</li><li id="b9f2" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">较少的连接/移动部件会导致故障。</li><li id="b896" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">极低的延迟。根据另一个进程运行的位置(同一台机器或远程机器)，会有一定程度的延迟。</li></ol><p id="fc36" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，对于较简单的服务，或者当服务寿命较短时，这可能是一个很好的设计。或者当减少延迟是关键的NFR时。</p><p id="a281" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一方面，随着服务随着时间的推移开始增长,“过程中”设计开始出现一些问题——</p><ol class=""><li id="1400" class="jt ju hi iz b ja jb jd je jg jv jk jw jo jx js jy jz ka kb bi translated">由于它是一个单独的进程，这意味着SDK的运行时必须与应用程序的运行时兼容。如果有更适合的SDK，但需要不同的平台/运行时，这可能是一个问题。或者我们希望将应用程序迁移到SDK不支持的不同平台。</li><li id="14d2" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">即使其中一个外设发生变化，这种设计也需要改变代码。因此，当代码不可用或者更改代码所需的技能已经丢失时，它不是一个选项。</li><li id="081c" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">如果一个应用程序是基于几个第三方SDK构建的，那么保持SDK的版本是一个挑战。</li><li id="3a60" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">在定制实现的情况下，应用程序代码被基础结构代码所膨胀。其可以在所有应用中重复。</li></ol><p id="9151" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一种选择，另一种可能性是将横切关注点提取到一个支持服务的独立流程中，从而创建一个"<strong class="iz hj">流程外"</strong>设计。其中应用程序本身只对其业务目标负责，并与不同的流程讨论横切关注点。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/b8a9a7de7a9262437957bc227f60006c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1u8mAXCMM2WcCJWndaCdw.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">示例:进程内架构与进程外架构</figcaption></figure><p id="f511" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如上图所示，进程外架构促进了可扩展的、灵活的、可伸缩的、松散耦合的架构，它有几个好处</p><ol class=""><li id="e298" class="jt ju hi iz b ja jb jd je jg jv jk jw jo jx js jy jz ka kb bi translated">横切过程可以是任何技术，只要与主应用程序的通信是可能的。</li><li id="aa86" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">因为混合技术更容易，所以有可能为每项工作带来最适合的工具，而不是寻找一个好的通用解决方案。</li><li id="6889" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">横切过程可以在不影响主应用程序的情况下被更新或替换。</li><li id="78c8" class="jt ju hi iz b ja kc jd kd jg ke jk kf jo kg js jy jz ka kb bi translated">它支持自主扩展。</li></ol></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><p id="e16a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Kubernetes的上下文中，pod是Kubernetes中最小的实体，每个pod都有一个唯一的IP地址。Pod就像是容器的虚拟机，因此容器可以访问Pod的网络和存储。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es le"><img src="../Images/4f790b472831da2c2014b7dd176e700f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*sr0fi4KMJbOEB6j6l2-zlA.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">托管在端口4000运行监听的容器的Pod</figcaption></figure><p id="1f4e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个pod可以有一个或多个容器。拥有多个容器的目的与<strong class="iz hj">“进程外”</strong>设计的目的相同(除了缩放，因为Kubernetes使用Pod作为最小的缩放单位)。</p><p id="e6dc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Kubernetes环境中，有更多的理由将跨领域/基础设施问题排除在应用之外，因为我们需要最先进的工具来支持可观察性、应用安全性和合规性策略以及处理流量管理。这意味着应该可以在不改变应用程序代码的情况下切换基础设施技术。</p><p id="4ae3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实现这种进程外设计的常见模式是将主应用程序打包成一个独立的容器。并将助手服务打包成单独的容器。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lf"><img src="../Images/d308cc84adcdf858d345e8713a603348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*jGTRmYTrD_EkwEQ8P9Ki0g.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">示例—同一pod中的多个容器共享网络命名空间和存储。</figcaption></figure><p id="26af" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，在上面的图像中，应用程序容器使用代理与外部世界对话，由于两个容器都在同一个网络名称空间中，代理可以作为localhost访问。并且日志可以由日志代理(数据拉出器)使用公共存储卷(日志代理可以将其流式传输到日志收集服务器)来收集。</p><p id="ebdf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本质上，主应用程序进程和助手进程位于同一位置，共同管理，并且具有相同的生存期。它们在一个pod中有着相同的命运&amp;由Kubernetes作为一个整体来管理。此外，请注意，助手应用程序除了支持主应用程序之外没有其他用途。这种模式被称为<strong class="iz hj">侧车模式</strong>。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lg"><img src="../Images/01856d7e0476ed51f978c5eee2a90197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gZ5aPTv2EAFGBZNW"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">带边车的摩托车。边车的目的是提高摩托车的性能。没有摩托车就没有意义。照片由<a class="ae lh" href="https://unsplash.com/@philpotophoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">菲利普·波托尼克</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="cd3f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们来谈谈<strong class="iz hj">大使-边车</strong>模式—</p><p id="de06" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">国家或软件的大使，是代表国家/软件对外对话的实体，代表国家/软件。</p><p id="976e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然Ambassador模式是一个独立的模式，但是，当它作为一个助手容器被实现在与主应用程序相同的pod中时，由于它的用途和生命周期，它是sidecar模式的一个专门化。</p><p id="d2b5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们花几分钟时间来欣赏这样一个代理，它在每个pod中作为边站与主应用程序一起运行，因为<strong class="iz hj">这是一个分布式代理</strong>(不同于中央代理)。它没有中心跳或远程代理的延迟，是监控流量和应用任何网络管理规则的好地方。</p><p id="b110" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果所有pod内的所有通信都通过这样的代理发生，那么所有的通信都是可观察的和可操作的。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es li"><img src="../Images/aa94e1452b64715e4ec50d278bd715c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NvunqjeZXniJYex41qa2qA.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">与主应用程序一起运行的大使边车。</figcaption></figure><p id="15cd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">总结</strong></p><p id="9269" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我采用了一种容器不可知的方法来描述“进程内”设计如何简化手头的任务，但却创建了一个高耦合、低内聚的设计。而“进程外”设计以复杂性为代价促进了高内聚、低耦合的设计。因此，考虑权衡以决定什么是适当的，什么是过度的，这是至关重要的。</p><p id="37e9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Sidecar是实现进程外架构的一种模式。pod中的容器可以像sidecar一样工作，因为它们共享网络和存储，它们是同处一地和共同管理的。因为我们希望在不改变应用程序的情况下保持最先进的基础设施，所以它们更受欢迎。</p><p id="77fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在pod中使用sidecar代理会在集群级别产生一个分布式代理，这是服务网格利用的一个概念。</p><p id="d732" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你觉得这篇文章有用，请告诉我你的想法。</p></div></div>    
</body>
</html>