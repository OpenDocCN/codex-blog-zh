<html>
<head>
<title>Using Multiple Dispatch in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Julia中使用多重分派</h1>
<blockquote>原文：<a href="https://medium.com/codex/using-multiple-dispatch-in-julia-c09b5f38b4d9?source=collection_archive---------8-----------------------#2022-09-13">https://medium.com/codex/using-multiple-dispatch-in-julia-c09b5f38b4d9?source=collection_archive---------8-----------------------#2022-09-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="3bf2" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">文章节选</h2><div class=""/><div class=""><h2 id="e79c" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated"><em class="jg">摘自</em><a class="ae jh" href="https://www.manning.com/books/julia-for-data-analysis?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=book_kaminski2_julia_3_17_22" rel="noopener ugc nofollow" target="_blank"><em class="jg">Julia for Data Analysis</em></a><em class="jg">作者Bogumil Kaminski </em></h2></div><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/2c8866375242cd3eb9ada63b90426467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5NUP_GMYu_M7BjuIF7Mbw.jpeg"/></div></div></figure><p id="3644" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated"><em class="kq">这篇文章向你展示了如何在Julia中使用多重分派。</em></p><p id="2e95" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">如果你是一名数据科学家或任何处理大量数据的人，或者如果你对Julia语言感兴趣，请阅读这本书。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="6048" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">通过在<a class="ae jh" href="https://www.manning.com/books/julia-for-data-analysis?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=book_kaminski2_julia_3_17_22" rel="noopener ugc nofollow" target="_blank">manning.com</a>的结账处将<strong class="jw hs"> fcckaminski </strong>输入折扣代码框，为数据分析Julia打八五折。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="6ada" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">让我们学习如何定义具有不同方法的函数，并将这些知识应用到一个名为<code class="du ky kz la lb b">winsorized_mean</code>的函数中。</p><h2 id="597a" class="lc ld hi bd le lf lg lh li lj lk ll lm kd ln lo lp kh lq lr ls kl lt lu lv ho bi translated">为函数定义方法的规则</h2><p id="2de9" class="pw-post-body-paragraph ju jv hi jw b jx lw is jz ka lx iv kc kd ly kf kg kh lz kj kk kl ma kn ko kp hb bi translated">幸运的是，如果你理解了Julia类型系统的工作原理，定义方法就相对容易了。您只需将类型限制添加到<code class="du ky kz la lb b">::</code>之后的函数的参数中。如果省略了类型说明部分，那么Julia假设允许使用<code class="du ky kz la lb b">Any</code>类型的值。</p><p id="f7f4" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">假设我们想创建一个函数<code class="du ky kz la lb b">fun</code>,它采用一个位置参数，行为如下:</p><ul class=""><li id="8187" class="mb mc hi jw b jx jy ka kb kd md kh me kl mf kp mg mh mi mj bi translated">如果传递的是一个数字，它应该打印<code class="du ky kz la lb b">"a number was passed"</code>，除非它是一个Float64类型的值，在这种情况下，我们希望打印<code class="du ky kz la lb b">"a Float64 value"</code>；</li><li id="3280" class="mb mc hi jw b jx mk ka ml kd mm kh mn kl mo kp mg mh mi mj bi translated">在所有其他情况下，我们希望打印<code class="du ky kz la lb b">"unsupported type"</code>。</li></ul><p id="855e" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">下面是一个例子，说明如何通过为函数<code class="du ky kz la lb b">fun</code>定义三个方法来实现这种行为。</p><pre class="jj jk jl jm fd mp lb mq mr aw ms bi"><span id="665b" class="lc ld hi lb b fi mt mu l mv mw">julia&gt; fun(x) = println("unsupported type")<br/> fun (generic function with 1 method)<br/>  <br/> julia&gt; fun(x::Number) = println("a number was passed")<br/> fun (generic function with 2 methods)<br/>  <br/> julia&gt; fun(x::Float64) = println("a Float64 value")<br/> fun (generic function with 3 methods)<br/>  <br/> julia&gt; methods(fun)<br/> # 3 methods for generic function "fun":<br/> [1] fun(x::Float64) in Main at REPL[3]:1<br/> [2] fun(x::Number) in Main at REPL[2]:1<br/> [3] fun(x) in Main at REPL[1]:1<br/>  <br/> julia&gt; fun("hello!")<br/> unsupported type<br/>  <br/> julia&gt; fun(1)<br/> a number was passed<br/>  <br/> julia&gt; fun(1.0)<br/> a Float64 value</span></pre><p id="0398" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">在上面的例子中，注意到例如<code class="du ky kz la lb b">1</code>是一个<code class="du ky kz la lb b">Number</code>(因为它是<code class="du ky kz la lb b">Int</code>)但它不是<code class="du ky kz la lb b">Float64</code>，所以最具体的匹配方法是<code class="du ky kz la lb b">fun(x::Number)</code>。</p><h2 id="1404" class="lc ld hi bd le lf lg lh li lj lk ll lm kd ln lo lp kh lq lr ls kl lt lu lv ho bi translated">方法模糊问题</h2><p id="6c97" class="pw-post-body-paragraph ju jv hi jw b jx lw is jz ka lx iv kc kd ly kf kg kh lz kj kk kl ma kn ko kp hb bi translated">在为一个函数定义多个方法时，您必须记住的是避免方法模糊。当Julia编译器不能决定应该为给定的一组参数选择哪种方法时，就会发生这种情况。举个例子最容易理解这个问题。假设您想要定义一个带有两个位置参数的bar函数。它会告诉你其中是否有数字。这是实现这种功能的第一次尝试:</p><pre class="jj jk jl jm fd mp lb mq mr aw ms bi"><span id="ee72" class="lc ld hi lb b fi mt mu l mv mw">julia&gt; bar(x, y) = "no numbers passed"<br/> foo (generic function with 1 method)<br/>  <br/> julia&gt; bar(x::Number, y) = "first argument is a number"<br/> foo (generic function with 2 methods)<br/>  <br/> julia&gt; bar(x, y::Number) = "second argument is a number"<br/> foo (generic function with 3 methods)<br/>  <br/> julia&gt; bar("hello", "world")<br/> "no numbers passed"<br/>  <br/> julia&gt; bar(1, "world")<br/> "first argument is a number"<br/>  <br/> julia&gt; bar("hello", 2)<br/> "second argument is a number"<br/>  <br/> julia&gt; bar(1, 2)<br/> ERROR: MethodError: foo(::Int64, ::Int64) is ambiguous. Candidates:<br/>   bar(x::Number, y) in Main at REPL[2]:1<br/>   bar(x, y::Number) in Main at REPL[3]:1<br/> Possible fix, define<br/>   bar(::Number, ::Number)</span></pre><p id="ed1e" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">正如你所看到的，在我们想要通过传递一个数字作为第一个和第二个参数来调用<code class="du ky kz la lb b">bar</code>之前，一切都运行得很好。在这种情况下，Julia抱怨说，它不知道应该调用哪个方法，因为有两个方法可以选择。幸运的是，我们得到了如何解决这种情况的提示。我们需要定义一个额外的方法来解决这种不确定性:</p><pre class="jj jk jl jm fd mp lb mq mr aw ms bi"><span id="81ee" class="lc ld hi lb b fi mt mu l mv mw">julia&gt; bar(x::Number, y::Number) = "both arguments are numbers"<br/> foo (generic function with 4 methods)<br/>  <br/> julia&gt; bar(1, 2)<br/> "both arguments are numbers"<br/>  <br/> julia&gt; methods(bar)<br/> # 4 methods for generic function "foo":<br/> [1] bar(x::Number, y::Number) in Main at REPL[8]:1<br/> [2] bar(x::Number, y) in Main at REPL[2]:1<br/> [3] bar(x, y::Number) in Main at REPL[3]:1<br/> [4] bar(x, y) in Main at REPL[1]:1</span></pre><h2 id="faab" class="lc ld hi bd le lf lg lh li lj lk ll lm kd ln lo lp kh lq lr ls kl lt lu lv ho bi translated"><strong class="ak">为什么多次派遣有用？</strong></h2><p id="4820" class="pw-post-body-paragraph ju jv hi jw b jx lw is jz ka lx iv kc kd ly kf kg kh lz kj kk kl ma kn ko kp hb bi translated">理解Julia中的方法是如何工作的，这是你应该掌握的知识的重要部分。正如你在上面的例子中看到的，它允许用户根据函数的任何位置参数的类型来区分函数的行为。结合灵活的类型层次系统，多重分派允许Julia程序员编写高度灵活和可重用的代码。请注意，通过在适当的抽象级别指定类型，用户不必考虑将传递给函数的每一种可能的具体类型，同时仍然保留对接受何种值的控制。例如，如果您定义了自己的<code class="du ky kz la lb b">Number</code>子类型，例如，decimals . JL(<a class="ae jh" href="https://github.com/JuliaMath/Decimals.jl" rel="noopener ugc nofollow" target="_blank">https://github.com/JuliaMath/Decimals.jl</a>)包提供了支持任意精度十进制浮点计算的类型，您不必重写代码。即使原始代码不是专门针对这个用例开发的，所有代码都可以使用新的类型。</p><h2 id="f0e8" class="lc ld hi bd le lf lg lh li lj lk ll lm kd ln lo lp kh lq lr ls kl lt lu lv ho bi translated">改进了winsorized mean的实现</h2><p id="4c76" class="pw-post-body-paragraph ju jv hi jw b jx lw is jz ka lx iv kc kd ly kf kg kh lz kj kk kl ma kn ko kp hb bi translated">我们准备改进我们的<code class="du ky kz la lb b">winsorized_mean</code>函数定义。下面是您实现它的方法:</p><pre class="jj jk jl jm fd mp lb mq mr aw ms bi"><span id="b514" class="lc ld hi lb b fi mt mu l mv mw">julia&gt; function winsorized_mean(x::AbstractVector, k::Integer)<br/>            k &gt;= 0 || throw(ArgumentError("k must be non-negative"))<br/>            length(x) &gt; 2 * k || throw(ArgumentError("k is too large"))<br/>            y = sort!(collect(x))<br/>            for i in 1:k<br/>                y[i] = y[k + 1]<br/>                y[end - i + 1] = y[end - k]<br/>            end<br/>            return sum(y) / length(y)<br/>        end<br/> winsorized_mean (generic function with 1 method)</span></pre><p id="7788" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">首先注意，我们已经限制了<code class="du ky kz la lb b">x</code>和<code class="du ky kz la lb b">k</code>的允许类型，因此如果您尝试调用该函数，它的参数必须匹配所需的类型:</p><pre class="jj jk jl jm fd mp lb mq mr aw ms bi"><span id="cdeb" class="lc ld hi lb b fi mt mu l mv mw">julia&gt; winsorized_mean([8, 3, 1, 5, 7], 1)<br/> 5.0<br/>  <br/> julia&gt; winsorized_mean(1:10, 2)<br/> 5.5<br/>  <br/> julia&gt; winsorized_mean(1:10, "a")<br/> ERROR: MethodError: no method matching winsorized_mean(::UnitRange{Int64}, ::String)<br/> Closest candidates are:<br/>   winsorized_mean(::AbstractVector{T} where T, ::Integer) at REPL[6]:1<br/>  <br/> julia&gt; winsorized_mean(10, 1)<br/> ERROR: MethodError: no method matching winsorized_mean(::Int64, ::Int64)<br/> Closest candidates are:<br/>   winsorized_mean(::AbstractVector{T} where T, ::Integer) at REPL[6]:1</span></pre><p id="86a3" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">此外，我们可以在代码中看到一些使它变得健壮的东西。首先，我们检查传递的参数是否一致，也就是说，如果<code class="du ky kz la lb b">k</code>是负的或者太大，那么它就是无效的，在这种情况下，我们通过调用以<code class="du ky kz la lb b">ArgumentError</code>作为参数的<code class="du ky kz la lb b">throw</code>函数来抛出一个错误。看看如果我们通过错误的<code class="du ky kz la lb b">k</code>会发生什么:</p><pre class="jj jk jl jm fd mp lb mq mr aw ms bi"><span id="44a2" class="lc ld hi lb b fi mt mu l mv mw">julia&gt; winsorized_mean(1:10, -1)<br/> ERROR: ArgumentError: k must be non-negative<br/>  <br/> julia&gt; winsorized_mean(1:10, 5)<br/> ERROR: ArgumentError: k is too large</span></pre><p id="2948" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">接下来，在排序之前，复制一份存储在<code class="du ky kz la lb b">x</code>向量中的数据。为了实现这一点，我们使用了<code class="du ky kz la lb b">collect</code>函数，该函数接受任何可迭代的集合并返回一个存储相同值的对象，该对象具有<code class="du ky kz la lb b">Vector</code>类型。我们将这个向量传递给<code class="du ky kz la lb b">sort!</code>函数，对其进行就地排序。</p><p id="95bc" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">你可能会问为什么需要使用<code class="du ky kz la lb b">collect</code>函数来分配一个新的<code class="du ky kz la lb b">Vector</code>。原因是，例如像<code class="du ky kz la lb b">1:10</code>这样的范围是只读的，因此以后我们将无法用<code class="du ky kz la lb b">y[i] = y[k + 1]</code>和<code class="du ky kz la lb b">y[end - i + 1] = y[end - k]</code>更新<code class="du ky kz la lb b">y</code>。此外，一般来说，Julia可以支持数组中非基于1的索引(参见<a class="ae jh" href="https://github.com/JuliaArrays/OffsetArrays.jl" rel="noopener ugc nofollow" target="_blank">https://github.com/JuliaArrays/OffsetArrays.jl</a>)。但是，<code class="du ky kz la lb b">Vector</code>使用基于1的索引。总之，使用<code class="du ky kz la lb b">collect</code>函数可以将任何集合或通用<code class="du ky kz la lb b">AbstractVector</code>转换成Julia中定义的标准<code class="du ky kz la lb b">Vector</code>类型，这种类型是可变的，并且使用基于1的索引。</p><p id="b904" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">最后注意，我们没有手动执行for循环，而是使用了更简单、更健壮的<code class="du ky kz la lb b">sum</code>函数。</p><h2 id="7cce" class="lc ld hi bd le lf lg lh li lj lk ll lm kd ln lo lp kh lq lr ls kl lt lu lv ho bi translated"><strong class="ak">在方法中加入参数类型注释是否提高了方法的执行速度？</strong></h2><p id="7682" class="pw-post-body-paragraph ju jv hi jw b jx lw is jz ka lx iv kc kd ly kf kg kh lz kj kk kl ma kn ko kp hb bi translated">向函数参数添加类型注释使得Julia代码更容易阅读，也更安全。用户经常问的一个自然问题是，它是否提高了代码执行速度。</p><p id="dd57" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">如果某个函数只有一个方法，那么添加类型注释并不能提高代码执行速度。原因是，当调用某个函数时，Julia编译器知道您传递给它的参数的类型，并使用这些信息生成本机代码。换句话说:类型限制信息不影响代码生成。</p><p id="85b7" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">但是，如果为某个函数定义了多个方法，情况就不同了。原因是类型限制会影响方法调度。然后，使用针对给定类型的值优化的算法，每个方法可以有不同的实现。使用多重分派允许Julia编译器选择最适合您的数据的实现。</p><p id="b9b6" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">我来举例说明一下。考虑我们在第2章中介绍的<code class="du ky kz la lb b">sort</code>函数。通过调用<code class="du ky kz la lb b">methods(sort)</code>，您可以了解到它在基本Julia中定义了五种不同的方法(如果您加载了一些Julia包，可能会更多)。有一种对带有签名<code class="du ky kz la lb b">sort(v::AbstractVector; kws...)</code>的向量进行排序的通用方法和一种对带有签名<code class="du ky kz la lb b">sort(r::AbstractUnitRange)</code>的1:3范围进行排序的专用方法。</p><p id="a99a" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">拥有这种专门的方法有什么好处？答案是第二种方法被定义为<code class="du ky kz la lb b">sort(r::AbstractUnitRange) = r</code>。因为我们知道类型<code class="du ky kz la lb b">AbstractUnitRange</code>的对象已经排序(它们是增量等于1的值的范围),所以我们可以返回传递的值。在这种情况下，利用方法签名中的类型限制可以显著提高<code class="du ky kz la lb b">sort</code>操作的性能。</p><p id="b052" class="pw-post-body-paragraph ju jv hi jw b jx jy is jz ka kb iv kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">目前就这些。感谢阅读。</p></div></div>    
</body>
</html>