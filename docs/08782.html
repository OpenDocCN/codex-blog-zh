<html>
<head>
<title>SOLID Principles in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android的坚实原则</h1>
<blockquote>原文：<a href="https://medium.com/codex/solid-principles-in-android-cdc226605111?source=collection_archive---------3-----------------------#2022-09-03">https://medium.com/codex/solid-principles-in-android-cdc226605111?source=collection_archive---------3-----------------------#2022-09-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0f53a108abc41cd586f692dbea51b4eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oKgd9vo9EKkNsC1GXKV2fw.png"/></div></div></figure><p id="ad9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">坚实的原则是面向对象设计的最重要的原则之一。它们告诉我们如何将函数和数据结构组织成类，以及这些类应该如何相互连接。</p><p id="6bf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只要记住这些原则，就可以帮助我们不仅在Android/Java中，而且在任何软件中编写干净的代码。</p><p id="70bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些原则的目标是创建一个软件结构</p><ul class=""><li id="7715" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">能容忍变化</li><li id="dcc6" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">很容易理解</li><li id="5a27" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">是其他组件的构建模块。</li></ul><p id="ea8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">固体代表</p><p id="472b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">单一责任原则</p><p id="f349" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">o:开闭原则</p><p id="f48c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">李:里斯科夫替代原理</p><p id="8632" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">I:界面分离原理</p><p id="709a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">依赖倒置原则</p><p id="d2f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们试着用一个例子来理解每一个原理。</p><p id="51f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">单一责任原则:</strong></p><p id="14b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是最容易被误解的原则，因为这个名字可能会误导我们认为每个模块/类/函数应该只做一件事。然而，它真正意思是</p><p id="815c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kc">一个模块应该有且只有一个改变的理由。</em></p><p id="4f57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这也意味着一个模块只对一个参与者负责。</p><p id="e721" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这用一个常见的例子就很好理解了。有一个雇员类。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/d8566536f7ac70d109c97cd8df8568c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MhLzkPTiGpWfxdkLPaMMyQ.png"/></div></div></figure><p id="75ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管Employee类及其方法看起来合乎逻辑，但它们违反了单一责任原则。正如我们所看到的，calculateHours()的变化可能会影响calculateSalary()，因此不同的参与者或用例会因为一个用例的变化而受到影响。</p><p id="3232" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，在这种情况下，最好创建3个不同的类。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ki"><img src="../Images/673ec543ee14558216f7d9e65cba97f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TzKMLDgnrIWgmXmNAVtudw.png"/></div></div></figure><p id="2d4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Android中，有一种非常常见的违法行为。</p><p id="3aa2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“Context”类有150多个方法，这些方法互不相关。他们绝对有不止一个改变的理由。</p><p id="a3d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，考虑几个上下文类的方法</p><p id="be67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">getSystemService(字符串)</p><p id="84d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">checkSelfPermission(字符串)</p><p id="a555" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">getString(int)</p><p id="b376" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些显然是不相关的。</p><p id="f2c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，经常可以看到一个片段或活动处理比UI更多的逻辑。</p><p id="e684" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“上帝”类通常会成为后来的瓶颈，因为它们很难更改，而且很多时候，一个小的更改会导致新的错误。</p><p id="b989" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">MVP，MVVM建筑在某种程度上帮助我们遵循这个原则。</p><p id="3ec1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">开启关闭原理:</strong></p><p id="7f3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">软件工件应该对扩展开放，但对修改关闭。</p><p id="3c42" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">换句话说，软件工件的行为应该是可扩展的，而不必修改工件。</p><p id="b12f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这绝对是最重要的原则之一，因为简单的改变永远不会导致巨大的变化。</p><p id="64cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这也可以广义地概括为，任何新功能都应该通过添加新的类、属性和方法来实现，而不是改变现有的类、属性和方法。</p><p id="0fc8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实现OCP最简单的方法是在新的派生类中实现新的功能，并允许客户端通过抽象接口访问该功能。</p><p id="9840" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们的代码中有许多If和else条件，我们通常会违反这个原则。例如Util类。</p><p id="5f33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果不遵循OCP，就会导致以下问题:</p><ul class=""><li id="2183" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">很容易理解</li><li id="3bf2" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">是其他组件的构建模块。</li><li id="833d" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">我们需要测试整个功能，导致更多的测试工作和回归测试。</li><li id="d2bd" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">维护开销增加</li><li id="716c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">单一责任原则也遭到违反。</li></ul><p id="cecc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们的应用程序中有一个NotificationSender模块，它处理所有传入的通知。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><pre class="ke kf kg kh fd kq kr ks kt aw ku bi"><span id="1b9e" class="kv kw hi kr b fi kx ky l kz la">public class NotificationHandler <em class="kc">{</em></span><span id="7601" class="kv kw hi kr b fi lb ky l kz la">    private Sender sender;</span><span id="6ca3" class="kv kw hi kr b fi lb ky l kz la">   void send<em class="kc">(</em>String message, Notification notification, Module   module<em class="kc">){</em></span><span id="be84" class="kv kw hi kr b fi lb ky l kz la">     if<em class="kc">(</em>notification.type==BILLING<em class="kc">){</em></span><span id="67f4" class="kv kw hi kr b fi lb ky l kz la">        sender.send<em class="kc">(</em>message,module,notification.isSuccess<em class="kc">() )</em>;</span><span id="737b" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">    }</em>else if<em class="kc">(</em>notification.type==USER<em class="kc">){</em></span><span id="03a2" class="kv kw hi kr b fi lb ky l kz la">       sender.send<em class="kc">(</em>message, module<em class="kc">)</em>;</span><span id="1777" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">    }</em></span><span id="8a9a" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">   }</em></span><span id="4a18" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">}</em></span></pre><p id="c93e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这不仅违反了开闭原则，还会使这个类知道所有其他模块。如果一个模块必须接收通知，那么我们需要代码中的另一个If条件。</p><p id="beb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相反，我们可以创建一个界面</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><pre class="ke kf kg kh fd kq kr ks kt aw ku bi"><span id="e5bf" class="kv kw hi kr b fi kx ky l kz la">interface Notifiable <em class="kc">{</em></span><span id="649e" class="kv kw hi kr b fi lb ky l kz la">    void notify(String message, Notification notification);</span><span id="16fc" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">}</em></span></pre><p id="d00e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有需要通知的模块都可以实现这个接口。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><pre class="ke kf kg kh fd kq kr ks kt aw ku bi"><span id="1f50" class="kv kw hi kr b fi kx ky l kz la">public class NotificationHandler <em class="kc">{</em></span><span id="ec2b" class="kv kw hi kr b fi lb ky l kz la">    void send<em class="kc">(</em>String message, Notification notification,List<em class="kc">&lt;</em>Notifiable<em class="kc">&gt; </em>notifiableList<em class="kc">){</em></span><span id="7654" class="kv kw hi kr b fi lb ky l kz la">        for<em class="kc">(</em>Notifiable notifiable:notifiableList<em class="kc">){</em></span><span id="fec6" class="kv kw hi kr b fi lb ky l kz la">            if<em class="kc">(</em>notifiable.shouldNotify<em class="kc">(</em>notification<em class="kc">))</em></span><span id="1503" class="kv kw hi kr b fi lb ky l kz la">                notifiable.notify<em class="kc">(</em>message,notification<em class="kc">)</em>;</span><span id="f026" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">        }</em></span><span id="5053" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">   }</em></span><span id="3d7c" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">}</em></span></pre><p id="7d11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，任何新模块都可以添加到这个列表中，而不需要改变代码中的任何内容。</p><p id="dcbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是这个原理的力量。</p><p id="fb88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">利斯科夫替代原理。</strong></p><p id="eb87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kc">这个原则声明子类型必须完全可以替换它们的基本类型。</em></p><p id="cb9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基本上，我们需要仔细考虑什么时候子类型可以替换它的超类型，也就是说，客户应该能够很容易地用相应的派生类替换基类。</p><p id="fd1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">行为子类型化意味着子类型不仅提供父类型中的所有方法，而且它<em class="kc">必须遵守父类型</em>的行为规范。这确保了子类型满足客户对超类型行为的任何假设。</p><p id="bc5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每当我们使用继承时，这个原则可以作为指导方针。</p><p id="a6c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一个电商app中常见的例子。可以有多种商品，但是假设只有服装有折扣。因此，我们可以创建一个新方法“getDiscountedPrice()，仅用于服装。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/d83974becffe9c0f9e65ff23a23a968c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*RzDljuZCNkqpdHoM0X0gcg.png"/></div></figure><p id="132b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这显然违反了里斯科夫替代原理。现在物品不能到处都被衣服代替，因为它可能不考虑折扣价格。</p><p id="4cd8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们该如何处理？</p><p id="a206" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们必须在getPrice()方法本身中处理折扣，以便将来任何其他项目，如配件或鞋类，也可以处理折扣。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/b9f1323f93840e1c62a0b694e02595f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*NQ5tfyW9ytVS0-VpiFYD1w.png"/></div></figure><p id="0274" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，getPrice()和getDiscount的实现如下所示:</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><pre class="ke kf kg kh fd kq kr ks kt aw ku bi"><span id="652a" class="kv kw hi kr b fi kx ky l kz la">```long getPrice()<em class="kc">{</em></span><span id="8895" class="kv kw hi kr b fi lb ky l kz la">    return price-getDisocunt<em class="kc">()</em>;</span><span id="0fdd" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">}</em></span><span id="054f" class="kv kw hi kr b fi lb ky l kz la">long getDiscount()<em class="kc">{</em></span><span id="9652" class="kv kw hi kr b fi lb ky l kz la">    return discount;<em class="kc">// 0 if no discount</em></span><span id="cdb0" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">}</em></span></pre><p id="e662" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">界面偏析原理</strong></p><p id="9496" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个原则声明，“客户不应该被迫依赖他们不使用的接口”。</p><p id="e9cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个原则的目标是通过将应用程序接口分解成较小的接口来减少使用较大接口的副作用。这也可以认为是将单一责任原则应用于接口。</p><p id="c482" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在android中，假设我们有一个BaseFragment，并且从这个BaseFragment扩展了多个片段。使用接口从BaseFragment到其他片段进行通信是非常常见的。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/4191027114ce62f6216f6988a40d6be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PAmn8M7poqFZ_tuL34bWbg.png"/></div></div></figure><p id="30c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这三个片段都实现了侦听器。现在，FragmentA可能只对changeA和changeB感兴趣，而FragmentB可能只对changeD()感兴趣，但是所有的片段都被强制实现所有这些不必要的方法，从而使类膨胀。即使我们在接口中添加了一个额外的方法，所有3个片段都必须改变。</p><p id="9c25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这也违反了其他原则。</p><p id="9074" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相反，我们可以将接口分离成更小的接口，这些方法在逻辑上属于同一个接口。这导致了更清晰的设计和可维护的代码。</p><p id="c914" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">依存倒置原则:</strong></p><p id="b483" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Robert C Martin对依赖倒置原则的定义包括两个部分:</p><ol class=""><li id="fea5" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn lf ju jv jw bi translated">高级模块不应该依赖于低级模块。两者都应该依赖于抽象。</li><li id="38d1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn lf ju jv jw bi translated">抽象不应该依赖于细节。细节应该取决于抽象。</li></ol><p id="df31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这不是光看原理就能理解的那么简单。</p><p id="dd81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们试着用一个例子来理解。</p><p id="48b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设有3个类，A类依赖于B类，B类又依赖于c类。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/2d896fbfc911d3714036eb6ca8bbd5cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xRKDQvqbcfME6p7F2QcsYw.png"/></div></div></figure><p id="242b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">乍一看，这种依赖似乎没什么不好。然而，这带来了几个问题，如</p><ul class=""><li id="4b89" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">编写单元测试变得很困难，因为我们需要模拟我们的类所依赖的所有类。</li><li id="6223" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">更改一个类会导致更改许多其他类。</li><li id="6cda" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">类变得紧密耦合</li></ul><p id="3fc5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这可以通过使类依赖于抽象来解决，即接口而不是另一个类。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/32b8972e7605fe722888ab2ef21f213d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ofmBFcfvgkh7ST2JQTedpA.png"/></div></div></figure><p id="7d5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，这两个类都依赖于接口，而不是具体的类，这使得编写单元测试更容易，并且还解耦了有助于更好地管理变更的类。</p><p id="ff3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为另一个例子，假设我们在Android应用程序中有一个缓存，这是一个共享的偏好。</p><p id="cb01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的共享首选项类包含以下方法。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><pre class="ke kf kg kh fd kq kr ks kt aw ku bi"><span id="4f92" class="kv kw hi kr b fi kx ky l kz la">public class SharedPrefHelper <em class="kc">{</em></span><span id="9f17" class="kv kw hi kr b fi lb ky l kz la">    private SharedPreferences.Editor mEditor;</span><span id="c86a" class="kv kw hi kr b fi lb ky l kz la">    private SharedPreferences mSharedPreference;</span><span id="4cc1" class="kv kw hi kr b fi lb ky l kz la">    public SharedPrefHelper<em class="kc">(</em>@NonNull Context context<em class="kc">) {</em></span><span id="e116" class="kv kw hi kr b fi lb ky l kz la">         mSharedPreference =   context.getApplicationContext<em class="kc">()</em>.getSharedPreferences<em class="kc">(</em>PublicDefine.<em class="kc">SHARED_PREF_NAME</em>, Context.<em class="kc">MODE_PRIVATE)</em>;</span><span id="641d" class="kv kw hi kr b fi lb ky l kz la">        mEditor = mSharedPreference.edit<em class="kc">()</em>;</span><span id="c065" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">   }</em></span><span id="ebd9" class="kv kw hi kr b fi lb ky l kz la">     public void putLong<em class="kc">(</em>String key, long value<em class="kc">) {</em></span><span id="53f2" class="kv kw hi kr b fi lb ky l kz la">        mEditor.putLong<em class="kc">(</em>key, value<em class="kc">)</em>;</span><span id="05d3" class="kv kw hi kr b fi lb ky l kz la">        mEditor.apply<em class="kc">()</em>;</span><span id="37b8" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">    }</em></span><span id="b430" class="kv kw hi kr b fi lb ky l kz la">    public long getLong<em class="kc">(</em>String key, long defaultValue<em class="kc">) {</em></span><span id="423a" class="kv kw hi kr b fi lb ky l kz la">        return mSharedPreference.getLong<em class="kc">(</em>key, defaultValue<em class="kc">)</em>;</span><span id="c87c" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">    }</em></span><span id="e78a" class="kv kw hi kr b fi lb ky l kz la">    public long getLong<em class="kc">(</em>String key<em class="kc">) {</em></span><span id="835f" class="kv kw hi kr b fi lb ky l kz la">        return mSharedPreference.getLong<em class="kc">(</em>key, 0<em class="kc">)</em>;</span><span id="46a8" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">    }</em></span><span id="780e" class="kv kw hi kr b fi lb ky l kz la">    public void remove<em class="kc">(</em>String key<em class="kc">) {</em></span><span id="26ec" class="kv kw hi kr b fi lb ky l kz la">        mEditor.remove<em class="kc">(</em>key<em class="kc">)</em>.apply<em class="kc">()</em>;</span><span id="70be" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">    }</em></span><span id="c8b3" class="kv kw hi kr b fi lb ky l kz la">    public void clear<em class="kc">() {</em></span><span id="f4f4" class="kv kw hi kr b fi lb ky l kz la">        mEditor.clear<em class="kc">()</em>.apply<em class="kc">()</em>;</span><span id="276d" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">    }</em></span><span id="2296" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">}</em></span></pre><p id="f8e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们的片段直接依赖于这个类，那么这些方法实现中的任何变化都会导致我们所有的UI类发生变化。</p><p id="0ebc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以创建一个这样的界面:</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><pre class="ke kf kg kh fd kq kr ks kt aw ku bi"><span id="7cb5" class="kv kw hi kr b fi kx ky l kz la">public interface AppCacheStore <em class="kc">{</em></span><span id="aa56" class="kv kw hi kr b fi lb ky l kz la">    public void putLong<em class="kc">(</em>String key, long value<em class="kc">)</em>;</span><span id="1da4" class="kv kw hi kr b fi lb ky l kz la">    public long getLong<em class="kc">(</em>String key, long defaultValue<em class="kc">)</em>;</span><span id="c6ea" class="kv kw hi kr b fi lb ky l kz la">    public long getLong<em class="kc">(</em>String key<em class="kc">)</em>;</span><span id="66ae" class="kv kw hi kr b fi lb ky l kz la">    public void remove<em class="kc">(</em>String key<em class="kc">)</em>;</span><span id="e90f" class="kv kw hi kr b fi lb ky l kz la">    public void clear<em class="kc">()</em>;</span><span id="a1d5" class="kv kw hi kr b fi lb ky l kz la"><em class="kc">}</em></span></pre><p id="2cc5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们的UI层依赖于这个接口，而不是具体的类，我们可以很容易地改变实现并使用数据存储而不是共享首选项，我们的UI层将不会受到影响。</p><p id="6c79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结论</strong></p><p id="e22d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">坚实的原则很容易记住，在编写代码时牢记这些原则将创建干净、可测试、可重用和模块化的代码。</p></div></div>    
</body>
</html>