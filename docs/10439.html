<html>
<head>
<title>A Practical Guide To Containerize Your C++ Application With Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Docker封装C++应用程序的实用指南</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-practical-guide-to-containerize-your-c-application-with-docker-50abb197f6d4?source=collection_archive---------0-----------------------#2022-12-31">https://medium.com/codex/a-practical-guide-to-containerize-your-c-application-with-docker-50abb197f6d4?source=collection_archive---------0-----------------------#2022-12-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a2ab15b511724c49c33e76cf3d41c31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4xyRPtlm2_86yXdH6yHuGQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/es/@liodp?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Lionello DelPiccolo </a>在<a class="ae iu" href="https://unsplash.com/photos/Dv65oNf9UI4?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6fe2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您有希望作为Docker容器部署的C++代码，本指南将帮助您编写第一个Docker文件，并构建和运行您的C++应用程序。</p><p id="b1a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇博客文章主要针对C++开发人员，他们没有太多的Docker经验，但是想开始通过容器部署他们的应用程序。如果您已经知道一些概念，请随意跳到下一节。</p><h1 id="6cd4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">今天的例子:simplehttpserver</h1><p id="7358" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在这个练习中，我重复使用了一个来自精彩的<a class="ae iu" href="https://www.boost.org/doc/libs/1_81_0/libs/beast/doc/html/index.html" rel="noopener ugc nofollow" target="_blank"> Boost的例子。野兽</a>库。这个例子是一个异步HTTP服务器，它从本地目录提供静态文件。服务器由一个单独的<code class="du kw kx ky kz b">main.cpp</code>文件和我写的相应的<code class="du kw kx ky kz b">CMakeLists.txt</code>文件组成。</p><p id="4308" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Beast library的<a class="ae iu" href="https://www.boost.org/doc/libs/1_81_0/libs/beast/doc/html/beast/examples.html#beast.examples.servers" rel="noopener ugc nofollow" target="_blank">网站</a>上有几个例子，我用过相当简单的<a class="ae iu" href="https://www.boost.org/doc/libs/1_81_0/libs/beast/example/http/server/async/http_server_async.cpp" rel="noopener ugc nofollow" target="_blank"> http_server_async.cpp </a>。也许将来我会转而使用C++20的协程——它们确实能提高性能。asio(Beast库基于它)可以说更容易编写和阅读。</p><p id="0414" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该代码使用Boost的异步IO处理来服务每个HTTP请求。simplehttpserver提供命令行参数来配置主机、端口、文档根和使用的线程数量。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="a53a" class="li ju hi kz b be lj lk l ll lm">Allowed command line options:<br/>  --help                      produce help message<br/>  --host arg (=0.0.0.0)       host address to bind to<br/>  --port arg (=8080)          port to expose to<br/>  --doc_root arg (=/var/www/) root directory to serve<br/>  --threads arg (=1)          number of threads to use</span></pre><h1 id="25aa" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">最快的码头工人游戏攻略</h1><p id="2fa3" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果你还不知道Docker，让我快速地向你介绍最重要的概念。最需要记住的是:Docker不是虚拟机。Docker是一种封装应用程序并隔离运行这些应用程序的进程的机制。</p><blockquote class="ln lo lp"><p id="5020" class="iv iw lq ix b iy iz ja jb jc jd je jf lr jh ji jj ls jl jm jn lt jp jq jr js hb bi translated">虚拟机是关于隔离硬件的，Docker是关于隔离进程的。</p></blockquote><p id="b2c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Docker世界有两个中心实体:<em class="lq">图片</em>和<em class="lq">容器</em>。从所谓的<em class="lq">Docker文件</em>中创建<em class="lq"> Docker映像</em>。该文件描述了构建映像的命令。从这个图像中可以创建一个<em class="lq"> Docker容器</em>:它们是图像的实际运行实例。<em class="lq"> Docker引擎</em>负责实例化和运行容器。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/d900e7c9d987f3a9e58316196eab13bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*qc5C2L6fjkBSVIH-X1wRJQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">Docker构建和运行时</figcaption></figure><p id="be5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于这篇博文中的例子，还有一些不重要的概念。不过，我想提一下它们，以防你想进一步调查。</p><ul class=""><li id="d073" class="lv lw hi ix b iy iz jc jd jg lx jk ly jo lz js ma mb mc md bi translated">Docker卷是一种在容器间共享Docker管理的文件的机制。您可以通过所谓的<em class="lq">绑定挂载</em>将这些卷映射到一个容器中。</li><li id="9468" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated"><em class="lq"> Docker网络</em>允许您指定虚拟Docker网络。进出容器的网络流量通过Docker代理进行路由。这允许不同容器之间不同的网络设置。</li><li id="9d0e" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated">Docker Compose 是一个从单个<code class="du kw kx ky kz b">docker-compose.yml</code>文件构建和运行几个不同容器的特性。您可以指定docker容器的确切图像、容器名称、网络、卷等等。例如，如果您想运行MySQL容器和自定义REST API服务容器以及REDIS容器进行缓存，那么您可以使用Docker compose进行设置。</li></ul><h1 id="1e8c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">安装Docker引擎</h1><p id="096a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在开始之前，您需要安装<a class="ae iu" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>。Docker网站推荐使用Docker desktop，但并不要求运行我们的示例。说到Docker容器的构建、运行和其他一切，我更喜欢命令行而不是GUI应用程序。</p><p id="08f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，在MacOS上，我发现只为引擎安装Docker Desktop更容易。如果你仍然想只安装引擎而不安装桌面应用程序，请遵循这些针对带有WSL 的<a class="ae iu" href="https://unix.stackexchange.com/questions/667940/how-to-install-docker-engine-in-macos-without-docker-desktop" rel="noopener ugc nofollow" target="_blank"> MacOS </a>或<a class="ae iu" href="https://www.paulsblog.dev/how-to-install-docker-without-docker-desktop-on-windows/" rel="noopener ugc nofollow" target="_blank"> Windows的优秀教程。</a></p><p id="bd5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下命令将Docker引擎安装在以<code class="du kw kx ky kz b">apt</code>作为包管理器的Linux发行版上:</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="fba9" class="li ju hi kz b be lj lk l ll lm">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span></pre><p id="4735" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae iu" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中找到更多关于安装Docker引擎的信息，包括添加正确的库和故障排除。</p><h1 id="4d46" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">编写Dockerfile文件</h1><p id="d555" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">最初的项目结构是一个简单的C++项目，只有一个源代码目录和一个CMake文件。该目录包含前面提到的<code class="du kw kx ky kz b">main.cpp</code>文件。CMake文件通过链接所需的<em class="lq"> Beast </em>和<em class="lq"> Threads </em>库来构建项目。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="9236" class="li ju hi kz b be lj lk l ll lm">src/<br/>CMakeLists.txt</span></pre><p id="5fa9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要开始容器化，请在项目目录中创建一个新的docker文件:</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="f25d" class="li ju hi kz b be lj lk l ll lm">touch Dockerfile</span></pre><p id="0328" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个Docker文件将包含构建Docker映像所需的所有命令。Dockerfile文件中最重要的命令如下:</p><ul class=""><li id="3258" class="lv lw hi ix b iy iz jc jd jg lx jk ly jo lz js ma mb mc md bi translated"><code class="du kw kx ky kz b">FROM</code>从现有的Docker映像创建新的阶段</li><li id="cb6f" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated"><code class="du kw kx ky kz b">RUN</code>在镜像中执行一个Linux命令</li><li id="25e2" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated"><code class="du kw kx ky kz b">COPY</code>将本地文件系统中的文件或文件夹复制到映像中</li><li id="5bee" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated">当图像实例化为容器时，执行<code class="du kw kx ky kz b">CMD</code>或<code class="du kw kx ky kz b">ENTRYPOINT</code></li></ul><p id="5fef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，记住映像(构建时)和容器(运行时)之间的区别也很重要。命令<code class="du kw kx ky kz b">FROM</code>、<code class="du kw kx ky kz b">RUN</code>和<code class="du kw kx ky kz b">COPY</code>在构建时执行。命令<code class="du kw kx ky kz b">CMD</code>或<code class="du kw kx ky kz b">ENTRYPOINT</code>在运行时执行。</p><p id="853a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们为我们的图像使用了<a class="ae iu" href="https://docs.docker.com/build/building/multi-stage/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>。如果在容器中构建应用程序，多阶段构建是最佳实践。我们计划有一个<em class="lq">构建</em>阶段，在此阶段，我们安装构建工具和依赖项，将所需的源文件复制到映像中，并运行CMake配置和构建来构建应用程序二进制文件。在构建最终映像的第二阶段，我们将安装运行时依赖项并创建一个运行时用户。在此之后，我们只需将构建好的二进制文件复制到最终映像中，并定义启动simplehttpserver的入口点。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/9deabe41d437a5e1047cdb20373987da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sfgM2vi8ovMq5JREF3lmag.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Docker多阶段构建</figcaption></figure><h1 id="c357" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">构建阶段</h1><p id="18f6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><code class="du kw kx ky kz b">FROM</code>命令指定要构建的图像。在这种情况下，我们使用的是小<em class="lq">阿尔卑斯山</em>的图像。最佳实践是指定映像的确切版本(在本例中为3.17.0)。下面的关键字<code class="du kw kx ky kz b">AS</code>指定了阶段的名称，在我们的例子中是<em class="lq"> build </em>。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="793a" class="li ju hi kz b be lj lk l ll lm">FROM alpine:3.17.0 AS build</span></pre><p id="9737" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一个命令安装构建simplehttpserver应用程序所需的依赖项。最好也指定版本号。这确保了可重复的构建。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="e287" class="li ju hi kz b be lj lk l ll lm">RUN apk update &amp;&amp; \<br/>    apk add --no-cache \<br/>        build-base=0.5-r3 \<br/>        cmake=3.24.3-r0 \<br/>        boost1.80-dev=1.80.0-r3</span></pre><p id="582f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用<code class="du kw kx ky kz b">WORKDIR</code>命令切换到一个用于构建应用程序的目录(如果还不存在的话会创建这个目录，所以您不需要事先运行<code class="du kw kx ky kz b">mkdir</code>)。然后，我们将源文件夹和CMake文件复制到这个目录中。我更喜欢明确说明要复制的文件夹或单个文件，以确保不会意外复制其他内容。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="f6ec" class="li ju hi kz b be lj lk l ll lm">WORKDIR /simplehttpserver<br/><br/>COPY src/ ./src/<br/>COPY CMakeLists.txt .</span></pre><p id="9d69" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在复制步骤之后，我们再次使用<code class="du kw kx ky kz b">WORKDIR</code>命令创建并切换到<em class="lq">构建</em>目录。这里只是执行CMake和构建应用程序的简单问题。请注意，parallel参数是可选的，最好作为<code class="du kw kx ky kz b">ARG</code>传递给docker file——但这超出了本文的范围。比如GitHub runners，据我所知有两个可用线程。在我的本地机器上，我使用了所有八个可用的线程。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="51bd" class="li ju hi kz b be lj lk l ll lm">WORKDIR /simplehttpserver/build<br/><br/>RUN cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; \<br/>    cmake --build . --parallel 8</span></pre><h1 id="b5eb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">最终图像</h1><p id="ffb1" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对于最后的图像，我们再次用另一个<code class="du kw kx ky kz b">FROM</code>声明来声明这个阶段。我们也使用同样的<em class="lq"> alpine </em>图像作为基础，就像我们在构建阶段所做的一样。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="01da" class="li ju hi kz b be lj lk l ll lm">FROM alpine:3.17.0</span></pre><p id="c3fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们正在安装运行时库——在我们的例子中是Boost的程序选项，我们用它来扫描命令行参数。此外还有libstdc++库，它不是所使用的alpine base映像的一部分。我们不需要使用的Beast库，因为它只是头文件，并且已经在我们构建的二进制文件中。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="4a15" class="li ju hi kz b be lj lk l ll lm">RUN apk update &amp;&amp; \<br/>    apk add --no-cache \<br/>    libstdc++=12.2.1_git20220924-r4 \<br/>    boost1.80-program_options=1.80.0-r3</span></pre><p id="58b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为下一步和最佳实践，我们将创建一个名为<em class="lq"> shs </em>的用户来运行我们的simplehttpserver应用程序。否则，应用程序将作为root用户运行(在容器内部)。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="af6e" class="li ju hi kz b be lj lk l ll lm">RUN addgroup -S shs &amp;&amp; adduser -S shs -G shs<br/>USER shs</span></pre><p id="f4bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，我们将构建的simplehttpserver二进制文件从构建阶段复制到我们的最终映像。<code class="du kw kx ky kz b">--chown</code>选项指定所有权，而<code class="du kw kx ky kz b">--from</code>选项指定从哪里复制的阶段的名称。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="9e9d" class="li ju hi kz b be lj lk l ll lm">COPY --chown=shs:shs --from=build \<br/>    ./simplehttpserver/build/src/simplehttpserver \<br/>    ./app/</span></pre><p id="5806" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一个命令是从这个映像实例化容器时在运行时执行的起点。这也允许传递任何命令行参数。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="94ff" class="li ju hi kz b be lj lk l ll lm">ENTRYPOINT [ "./app/simplehttpserver" ]</span></pre><p id="6b91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在我的<a class="ae iu" href="https://github.com/mostsignificant/simplehttpserver/blob/main/Dockerfile" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到完整的Dockerfile文件。</p><h1 id="6398" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">建立码头工人形象</h1><p id="87c8" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Docker映像可以通过在项目目录中执行以下命令来构建。选项<code class="du kw kx ky kz b">-t</code>用于根据模式<code class="du kw kx ky kz b">&lt;repository&gt;/&lt;name&gt;:&lt;tag&gt;</code>指定存储库、名称和可选的图像标签。如果在冒号后面没有声明标签，Docker将使用标签<em class="lq"> latest </em>。以下命令构建图像<em class="lq">most significant/simple http server:latest</em>，稍后可以使用它来指定实例化容器。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="c9b1" class="li ju hi kz b be lj lk l ll lm">docker build . -t mostsignificant/simplehttpserver</span></pre><p id="0e0c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在构建过程中，您可以看到正在构建的不同阶段和层。docker文件中的每个命令都会添加一个新层。因此，重要的是要有一个多阶段的构建，其中只包含已构建的二进制文件和运行时依赖项。构建完成后，运行以下命令列出所有本地映像及其信息。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="8073" class="li ju hi kz b be lj lk l ll lm">docker image ls</span></pre><pre class="mk le kz lf bn lg lh bi"><span id="bda4" class="li ju hi kz b be lj lk l ll lm">REPOSITORY                        TAG     IMAGE ID      CREATED      SIZE<br/>mostsignificant/simplehttpserver  latest  afb9c03f8849  2 hours ago  14.4MB</span></pre><p id="447a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">14.4 MB对于这个图像来说是一个合理的大小——如果您使用<em class="lq"> debian:bullseye-slim </em>作为这个图像的基础，那么最终的大小将会是104 MB。缩小图像的尺寸可能是一项艰巨的任务，但有一些工具可以支持这项任务，例如<a class="ae iu" href="https://github.com/wagoodman/dive" rel="noopener ugc nofollow" target="_blank"> dive </a>可以帮助检查图像的不同层。请注意，在构建过程中添加到早期图层中的文件可以在后期图层中删除，但原始数据仍保留在生成的图像中。因此，您可以:</p><ul class=""><li id="20b1" class="lv lw hi ix b iy iz jc jd jg lx jk ly jo lz js ma mb mc md bi translated">使用多阶段构建，仅将早期阶段所需的文件复制到最终映像中</li><li id="fd8c" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated">或者使用远程存储库进行安装，而不是将安装包复制到映像中</li><li id="b4be" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated">或者下载，解压，安装和删除软件包在一个单一的<code class="du kw kx ky kz b">RUN</code>命令</li></ul><h1 id="897b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">将Docker映像作为容器运行</h1><p id="3e72" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">以下命令运行映像并实例化一个容器:</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="c04a" class="li ju hi kz b be lj lk l ll lm">docker run \<br/>  --mount type=bind,source="$(pwd)",target=/var/www \<br/>  -p 8080:8080 \<br/>  -d \<br/>  mostsignificant/simplehttpserver:latest</span></pre><p id="5121" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用以下命令行参数:</p><ul class=""><li id="d587" class="lv lw hi ix b iy iz jc jd jg lx jk ly jo lz js ma mb mc md bi translated"><code class="du kw kx ky kz b">--mount</code>将本地路径挂载到容器中的路径:我们将当前路径映射到<code class="du kw kx ky kz b">/var/www</code>目录，从而使simplehttpserver应用程序能够通过HTTP服务于当前目录中的所有文件</li><li id="4794" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated"><code class="du kw kx ky kz b">-p</code>将容器内部的一个端口映射到主机:simplehttpserver的默认端口<em class="lq"> 8080 </em>映射到同一个主机端口，但是您可以使用任何其他可用的端口</li><li id="0d7d" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated"><code class="du kw kx ky kz b">-d</code>以分离模式启动容器</li></ul><p id="984f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还可以检查正在运行的码头集装箱:</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="0d0e" class="li ju hi kz b be lj lk l ll lm">docker ps</span></pre><pre class="mk le kz lf bn lg lh bi"><span id="8df9" class="li ju hi kz b be lj lk l ll lm">CONTAINER ID   IMAGE                                   <br/>635e4dafcdb6   mostsignificant/simplehttpserver:latest<br/>COMMAND                  CREATED         STATUS <br/>"./app/simplehttpser…"   3 seconds ago   Up 2 seconds<br/>PORTS                    NAMES<br/>0.0.0.0:8080-&gt;8080/tcp   serene_torvalds</span></pre><p id="685d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果没有另外指定的话，容器名是随机生成的——在我们的例子中是<em class="lq"> serene_torvalds </em>(我认为让Linus保持平静的心情总是好的)。您可以使用容器id(哈希)或名称来访问它，例如:</p><ul class=""><li id="53d3" class="lv lw hi ix b iy iz jc jd jg lx jk ly jo lz js ma mb mc md bi translated"><code class="du kw kx ky kz b">docker stop 635e4dafcdb6</code>停止容器(及其进程)</li><li id="84fb" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated"><code class="du kw kx ky kz b">docker rm 635e4dafcdb6</code>移除停止的容器(但不是图像！)</li><li id="6f89" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated"><code class="du kw kx ky kz b">docker inspect 635e4dafcdb6</code>获取关于容器的更多信息</li></ul><h1 id="2ce7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">发布Docker图像</h1><p id="169d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了发布你的docker图片，你需要先在<a class="ae iu" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>创建一个账户。请注意，您的帐户名需要是您之前使用的存储库名(或者您只是重命名图像)。在我的例子中，我的账户名是<em class="lq">最重要的</em>，因此我相应地给图片命名为:*最重要的/:*。</p><p id="d284" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建帐户后，您必须通过以下命令登录Docker Hub并提供凭据:</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="531c" class="li ju hi kz b be lj lk l ll lm">docker login</span></pre><p id="70ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">登录后，可以将图像推送到Docker Hub。</p><pre class="la lb lc ld fd le kz lf bn lg lh bi"><span id="c597" class="li ju hi kz b be lj lk l ll lm">docker push mostsignificant/simplehttpserver:latest</span></pre><p id="778b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅此而已。现在任何人都可以下载并运行你的Docker镜像。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/b9daaf6359d32dd76db171f172413171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-qQawL4KWCKCxRc-WyDRg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">码头枢纽</figcaption></figure><h1 id="0728" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">后续步骤</h1><p id="0ad7" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在，您得到了应用程序运行时的第一个Docker映像。一如既往，有一些TLC步骤来改善你的形象和周围的一切。以下是一些建议:</p><ul class=""><li id="d879" class="lv lw hi ix b iy iz jc jd jg lx jk ly jo lz js ma mb mc md bi translated"><strong class="ix hj">构建管道</strong>:您可以将Docker构建和推送步骤集成到您的构建管道中。如果你正在使用GitHub Actions，有一个很好的文档<a class="ae iu" href="https://docs.github.com/en/actions/publishing-packages/publishing-docker-images" rel="noopener ugc nofollow" target="_blank">告诉你如何去做:或者到GitHub自己的库GitHub Packages或者Docker Hub。</a></li><li id="07c4" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated"><strong class="ix hj">测试</strong>:您也可以在构建阶段包含一个测试步骤(例如通过<em class="lq"> CTest </em>)。只要以这样一种方式包含测试，即使测试失败，Docker映像构建也不会失败——这样您就可以将您的测试结果文件<a class="ae iu" href="https://stackoverflow.com/a/51186557" rel="noopener ugc nofollow" target="_blank">从映像</a>中复制出来，并将其传递到您的构建管道。则如果先前的测试失败，构建管道可以阻止图像的发布。</li><li id="a7ac" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated"><strong class="ix hj">林挺</strong>:您可以使用类似<a class="ae iu" href="https://hadolint.github.io/hadolint/" rel="noopener ugc nofollow" target="_blank"> hadolint </a>的Docker linter来检查您的Docker文件中常见的最佳实践违规。</li><li id="cc22" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated"><strong class="ix hj">文档</strong>:使用<a class="ae iu" href="https://docs.docker.com/engine/reference/builder/#label" rel="noopener ugc nofollow" target="_blank">标签</a>来改进Docker文件的文档，并在Docker Hub上添加一个关于你的图片的自述文件。</li><li id="6515" class="lv lw hi ix b iy me jc mf jg mg jk mh jo mi js ma mb mc md bi translated"><strong class="ix hj">。dockerignore </strong>:增加一个<a class="ae iu" href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" rel="noopener ugc nofollow" target="_blank">。dockerignore文件</a>到您的项目目录，以防止docker构建将不需要的文件或文件夹复制到您的映像中(并且一般要小心使用<code class="du kw kx ky kz b">COPY</code>命令)</li></ul><h1 id="a27b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="6ea1" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我希望这篇小教程能帮助任何不熟悉Docker的C++开发人员开始容器化他们的应用程序。完整的例子可以在我的<a class="ae iu" href="https://github.com/mostsignificant/simplehttpserver" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>和我的<a class="ae iu" href="https://hub.docker.com/repository/docker/mostsignificant/simplehttpserver" rel="noopener ugc nofollow" target="_blank"> Docker Hub repo </a>上找到。关于Docker世界还有很多东西需要学习，官方的<a class="ae iu" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae iu" href="https://docs.docker.com/reference/" rel="noopener ugc nofollow" target="_blank">参考文献</a>是一个很好的开始。</p><p id="7d76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继续编码，继续创造！新年快乐</p></div></div>    
</body>
</html>