<html>
<head>
<title>Clean Code — Function (Summary)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干净代码—功能(摘要)</h1>
<blockquote>原文：<a href="https://medium.com/codex/clean-code-function-sumarry-7cc1b0ce1c19?source=collection_archive---------15-----------------------#2021-08-13">https://medium.com/codex/clean-code-function-sumarry-7cc1b0ce1c19?source=collection_archive---------15-----------------------#2021-08-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/06e826fe27868d540d5b2df0b81811e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DdPbeAEV1e2uRT17"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">沙哈达特·拉赫曼</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="2b09" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">小！</h1><blockquote class="jt"><p id="b092" class="ju jv hi bd jw jx jy jz ka kb kc kd dx translated">“函数的首要规则是它们应该很小。函数的第二个规则是它们应该比那个小。”</p></blockquote><p id="c800" class="pw-post-body-paragraph ke kf hi kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la kd hb bi translated">这不是一个合理的说法。但是作者编写了几个100到300行的函数，也编写了20到30行的函数。有一个建议，经过长时间的反复试验，是应该小的。</p><p id="62c3" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">你的函数应该有多短？</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="b018" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">到</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/3fa28e8992a030ee5018bd15c1524c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Wpu82qoF5A5WhYupySgsQ.png"/></div></div></figure><p id="7bd6" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">从上面的例子中，我们知道我们可以通过创建一个处理特定事情的子函数来使函数变得更小。</p><p id="8533" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">函数不应该大到足以容纳嵌套结构。<br/>因此，一个函数的缩进量不能大于<strong class="kg hj">一个</strong>或<strong class="kg hj">两个</strong>。当然，这使得函数<strong class="kg hj">更容易阅读和理解。</strong></p><h1 id="d036" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">做一件事</h1><blockquote class="jt"><p id="4d25" class="ju jv hi bd jw jx jy jz ka kb kc kd dx translated">“功能应该做一件事。他们应该做好这件事。他们只应该这样做。”</p></blockquote><p id="d776" class="pw-post-body-paragraph ke kf hi kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la kd hb bi translated">现在，问题是“一件事”是什么意思？</p><p id="e9ba" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">如果一个函数只做一些比它的名字低一级的步骤，那么这个函数只做一件事。了解一个函数不仅仅做“一件事”的另一种方法是，你是否可以从中提取另一个函数。</p><h1 id="710d" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">每个功能一个抽象层次</h1><p id="a449" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">如果你想让你的函数做“一件事”，确保函数中的<br/>语句都在同一抽象层次。</p><h1 id="de17" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">Switch语句</h1><p id="7de9" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">很难做一个小小的<code class="du ls lt lu lv b">switch</code>声明。即使只有两种情况的switch语句也比单个块或函数要长。就其本质而言，开关盒执行N种职责。如果可能的话，不应该使用switch语句。但是有些情况下我们无法避免switch语句。在这种情况下，使用多态性，确保每个switch语句都隐藏在一个低级类中，并且永远不要重复。</p><h1 id="7aeb" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">使用描述性名称</h1><p id="ff68" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">名字对于编写干净的代码是很重要的。不要害怕让名字变长。一个长的描述性的名字比一个短的神秘的名字更好。一个长的描述性名称比一个长的描述性注释更好。不要害怕花时间选择一个名字。名字应该听起来像一个故事，函数名应该是一个动词。</p><h1 id="acf4" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">函数参数</h1><p id="3fac" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">一个函数的理想参数个数是零(niladic)。接下来是<strong class="kg hj">一个</strong>(一元)，紧接着是<strong class="kg hj">两个</strong>(二元)。应尽可能避免三个参数(三元组)。<strong class="kg hj">反正三个以上</strong>(多元数)不应该用！。</p><p id="8956" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">从测试的角度来看，论证更加困难。如果没有争论，这是微不足道的。如果有一个论点，也不是太难。有了两个参数，问题变得更具挑战性。如果有两个以上的参数，测试每个适当值的组合可能会令人困惑。</p><h2 id="50b9" class="lw iw hi bd ix lx ly lz jb ma mb mc jf kp md me jj kt mf mg jn kx mh mi jr mj bi translated">常见的一元形式(一个参数)</h2><p id="5c70" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">将单个参数传递给函数有三个常见原因:</p><ul class=""><li id="45fe" class="mk ml hi kg b kh lb kl lc kp mm kt mn kx mo kd mp mq mr ms bi translated"><strong class="kg hj">提问:</strong>你可能会问一个关于布尔值<code class="du ls lt lu lv b">fileExists(“MyFile”).</code>的问题</li><li id="68a1" class="mk ml hi kg b kh mt kl mu kp mv kt mw kx mx kd mp mq mr ms bi translated"><strong class="kg hj">操作、转换和返回:</strong>你可以操作那个参数，把它转换成别的东西并返回。InputStream <code class="du ls lt lu lv b">fileOpen(“MyFile”).</code>将字符串文件名参数转换成一个<code class="du ls lt lu lv b">InputStream </code>返回值。</li><li id="9834" class="mk ml hi kg b kh mt kl mu kp mv kt mw kx mx kd mp mq mr ms bi translated"><strong class="kg hj">事件:</strong>将函数调用解释为<strong class="kg hj">事件</strong>，并使用参数<strong class="kg hj">改变系统的状态</strong>。比如void <code class="du ls lt lu lv b">passwordAttemptFailedNtimes(int attempts)</code>。</li></ul><h2 id="3044" class="lw iw hi bd ix lx ly lz jb ma mb mc jf kp md me jj kt mf mg jn kx mh mi jr mj bi translated">标志参数</h2><p id="7a2c" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">标志参数很难看。将布尔值传递给函数是一种非常糟糕的做法。根据设计，该函数不止做一件事。如果标志为真，它做一件事；如果标志为假，它做另一件事！</p><h2 id="893f" class="lw iw hi bd ix lx ly lz jb ma mb mc jf kp md me jj kt mf mg jn kx mh mi jr mj bi translated">二元函数(两个自变量)</h2><p id="0a78" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">有两个参数的函数比只有一个参数的函数更难理解。但是，有时两个论点是恰当的。例如，<code class="du ls lt lu lv b">Point p = new Point(0,0);</code>是完全合理的。笛卡尔点自然带有两个参数。</p><p id="5ab7" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">但是，本例中的两个参数是单个值的<strong class="kg hj">有序组件！。</strong>比如<code class="du ls lt lu lv b">assertEquals(expected, actual)</code>都有问题。每次你都可以检查<code class="du ls lt lu lv b">expected </code>是第一个参数还是第二个参数。</p><p id="5b39" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">二元结构并不邪恶，如果有必要，只要在论点有自然衔接或自然排序时使用它们。</p><h2 id="b655" class="lw iw hi bd ix lx ly lz jb ma mb mc jf kp md me jj kt mf mg jn kx mh mi jr mj bi translated">三元组(三个参数)</h2><p id="9ef0" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">带有三个参数的函数比带有两个参数的函数更难理解。排序、暂停和忽略的问题增加了一倍多。尽量避免吧！。</p><h2 id="e4a8" class="lw iw hi bd ix lx ly lz jb ma mb mc jf kp md me jj kt mf mg jn kx mh mi jr mj bi translated">参数对象</h2><p id="3985" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">当函数需要两个或三个以上的参数时，它们(参数)可能被包装成自己的类。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es my"><img src="../Images/fb522e019ac1af0275674190200eada4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*-iVDGkhL-g5rTfZlmZRt_w.png"/></div></figure><h2 id="cd20" class="lw iw hi bd ix lx ly lz jb ma mb mc jf kp md me jj kt mf mg jn kx mh mi jr mj bi translated">参数列表</h2><p id="2272" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">有时函数可以传递可变数量的参数。如果变量参数都被同等对待，那么它们就等同于类型为<code class="du ls lt lu lv b">List</code>的单个参数。</p><h2 id="fe87" class="lw iw hi bd ix lx ly lz jb ma mb mc jf kp md me jj kt mf mg jn kx mh mi jr mj bi translated">动词和关键词</h2><p id="1a78" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">同样，为函数选择好的名字可以解释函数的意图，而且可以解释参数的意图。比如<code class="du ls lt lu lv b">write(name)</code>。不管这个<code class="du ls lt lu lv b">name</code>是什么，它正在被“书写”</p><h1 id="766c" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">没有副作用</h1><p id="4661" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">该函数应该做一件事。有时，它会对自己类的变量进行意外的更改，这会导致<strong class="kg hj">时间耦合</strong>和<strong class="kg hj">顺序依赖</strong>。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/d3c3db29578c47fdbc60e07c4acacf25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgW3dJS0umOI6HhY5-tn5w.png"/></div></div></figure><p id="ced5" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated"><code class="du ls lt lu lv b">checkPassword </code>函数应该只返回布尔值。但是它有可能引起副作用的<code class="du ls lt lu lv b">Session.initialize()</code>。调用<code class="du ls lt lu lv b">Session.initialize()</code>会导致在检查用户合法性时删除现有会话数据的风险。</p><p id="263f" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">如果你必须有一个时间上的耦合，你应该在函数的名字里说清楚。在这种情况下，您可以将上面的函数重命名为<code class="du ls lt lu lv b">checkPasswordAndInitializeSession()</code>。记住，那肯定违反了“做一件事”</p><h2 id="33e1" class="lw iw hi bd ix lx ly lz jb ma mb mc jf kp md me jj kt mf mg jn kx mh mi jr mj bi translated">避免输出参数</h2><p id="b57c" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">输出参数比输入参数更难理解，因为我们通常不期望信息通过参数传递出去。因此，不使用输入参数，而是使用返回值。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es na"><img src="../Images/8c6f88b680a2cdfd25a9be855a9e08d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*o-uNPowI260uMbFsyyX0NA.png"/></div></figure><h1 id="601b" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">命令查询分离</h1><p id="e98f" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">函数应该做些什么或者回答些什么，但不能两者都做。两者都做往往会导致混乱。例如</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/c0f18e5fe9f5e120d19b0b47334b5db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*LOIBFX0vZPbJgcHne_NULQ.png"/></div></figure><p id="d783" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">从读者的角度想象一下。这是什么意思？是在问“用户名”属性之前是否设置为“Andiko”？还是在问“用户名”属性是否成功设置为“Andiko”？</p><p id="f05d" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">解决方案是通过创建一个新函数<code class="du ls lt lu lv b">attributeExists(atribute)</code>将命令与查询分开，这样就不会出现歧义。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/f576f7021aef27d12cbce82df806044d.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*3gatU55jMLfX4hsswz6fuw.png"/></div></figure><h1 id="ce12" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">首选异常，而不是返回错误代码</h1><p id="9516" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">从命令函数返回错误代码是对命令查询分离的微妙违反。它可能会导致深度嵌套的结构。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/5f907522e4efcb96b667d0c0b5f7c6d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQ6AfOV9Jap16kFDOHSaUQ.png"/></div></div></figure><p id="2656" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">您可以使用异常来代替返回的错误代码。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es ne"><img src="../Images/2c799ac33b903bbf9925ad24a79aeea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*O8DKcgkp6bm7Th6YfUcedA.png"/></div></figure><h2 id="c7e0" class="lw iw hi bd ix lx ly lz jb ma mb mc jf kp md me jj kt mf mg jn kx mh mi jr mj bi translated">提取Try/Catch块</h2><p id="8120" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">最好将try和catch块的主体提取到它们自己的函数中</p><h2 id="f96c" class="lw iw hi bd ix lx ly lz jb ma mb mc jf kp md me jj kt mf mg jn kx mh mi jr mj bi translated">错误处理是一回事</h2><p id="a2b1" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">函数应该做一件事。错误处理是一回事。如果关键字<code class="du ls lt lu lv b">try </code>存在于一个函数中，它应该是函数中的第一个单词，并且在catch/finally块之后应该是空的。</p><h1 id="4054" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">干(不重复)</h1><p id="806b" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">你不应该每次都重复你的代码，当它需要改变的时候，它会折磨你或者其他人。<strong class="kg hj">复制可能是软件中一切罪恶的根源。</strong></p><h1 id="a1cb" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结构化程序设计</h1><p id="1ebe" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">保持你的函数小一些，偶尔出现多个<code class="du ls lt lu lv b">return</code>、<code class="du ls lt lu lv b">break</code>或<code class="du ls lt lu lv b">continue </code>语句可能没有坏处，有时甚至比单入口单出口规则更有表现力。您应该避免使用<code class="du ls lt lu lv b">goto </code>语句，因为它只在大型函数中有意义。</p><h1 id="0502" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论</h1><p id="219f" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">每一个系统都是由程序员设计的领域特定语言构建而成，以<strong class="kg hj">描述该系统</strong>。函数是该语言的<strong class="kg hj">动词</strong>，类是<strong class="kg hj">名词</strong>。</p><p id="d024" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">编程大师认为<strong class="kg hj">系统是要被<strong class="kg hj">讲述的</strong>故事，而不是要被</strong>编写的<strong class="kg hj">程序。函数描述了系统中发生的所有动作。</strong></p><p id="e8c3" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">如果你遵循这些规则，你的函数将会很短，命名良好，组织良好。但是，不要忘记，我们的目标是讲述系统的故事。所以你需要调整它，让它变得干净，来帮助你写一个好故事。</p></div><div class="ab cl nf ng gp nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="hb hc hd he hf"><p id="ba2a" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated">这些都是我一直在努力学习的那本书的第三章的总结，并且得到了书名为《干净的代码》的那本书的要点，作者是Robert C. Martin。</p><p id="0072" class="pw-post-body-paragraph ke kf hi kg b kh lb kj kk kl lc kn ko kp ld kr ks kt le kv kw kx lf kz la kd hb bi translated"><strong class="kg hj">请随时给出一些建议和反馈。谢了。</strong></p><h1 id="34aa" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">参考</h1><p id="a4f0" class="pw-post-body-paragraph ke kf hi kg b kh ln kj kk kl lo kn ko kp lp kr ks kt lq kv kw kx lr kz la kd hb bi translated">罗伯特·c·马丁的《干净的代码》</p></div></div>    
</body>
</html>