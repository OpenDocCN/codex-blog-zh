<html>
<head>
<title>Need to know Property Wrappers in Swift UI.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">需要了解Swift UI中的属性包装器。</h1>
<blockquote>原文：<a href="https://medium.com/codex/need-to-know-property-wrappers-in-swift-ui-bc9f4ce6e328?source=collection_archive---------9-----------------------#2021-05-16">https://medium.com/codex/need-to-know-property-wrappers-in-swift-ui-bc9f4ce6e328?source=collection_archive---------9-----------------------#2021-05-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1e7475c4540eae2fc533982c95fb43a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*17DSLBAYKwA214z7"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@jexo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jexo </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d7cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">属性包装器是Swift UI编码的基础部分。当您开始使用Swift UI创建您的第一个应用程序时，您会遇到几个属性包装器，需要利用它们来实现您正在寻找的功能。在后面的文章中，我们将深入探讨几个属性包装器，但是今天我们将重点关注@State、@ObservedObject、@Binding和@Published属性包装器。</p><h2 id="1072" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">状态属性包装:</strong></h2><p id="b869" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">状态属性包装器是一个非常强大的属性包装器，允许您的代码以比原生Swift代码更具反应性的方式运行。Swift UI使用状态来管理您声明的任何属性的存储。“State”实例不是属性本身，而是一种读写值的方法。如果您希望访问值本身，您可能希望使用它的变量名来访问包装的属性。当您将一个变量声明为@State变量时，您让应用程序知道当变量的状态改变时，UI也应该改变以反映新的值。这将允许您的UI自动刷新新存储的数据。使用@State变量的一个常见例子是在使用TextField时。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="26f1" class="jt ju hi ky b fi lc ld l le lf">struct MyView: View {<br/>   @State text = ""</span><span id="316f" class="jt ju hi ky b fi lg ld l le lf">   var body: some view {<br/>      TextField("Enter name...", text: $text)<br/>   }<br/>}</span></pre><p id="634d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此示例创建一个变量，并将其声明为@State对象。当用户输入文本时，UI将根据更改进行刷新，并将值发送回变量“text”。需要注意的是，状态变量必须在视图本身中声明。当写入状态变量时，您还需要将控制器绑定到变量本身。在上面的例子中，我们通过使用“$”符号将文本字段绑定到状态变量“text”。</p><h2 id="fcd0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">观察对象和发布的包装:</strong></h2><p id="dfec" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">ObservedObject包装器用于管理外部对象的状态。ObservedObject包装器在Swift UI中直接使用ObservableObject协议。要利用ObservedObject包装器，首先要创建一个符合ObservableObject协议的类，方法是在类名后声明它:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="18b6" class="jt ju hi ky b fi lc ld l le lf">class TestClass: ObservableObject {<br/>   @Published var views = 0<br/>}</span></pre><p id="b899" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在ObservableObject中，您将希望用@Published属性包装器包装要观察的任何变量。Published属性包装器让视图知道，只要这个变量的值改变，它就应该更新。这方面的一个例子如下:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="b6fa" class="jt ju hi ky b fi lc ld l le lf">struct MyView: View {<br/>   @ObservedObject var testClass: TestClass</span><span id="f134" class="jt ju hi ky b fi lg ld l le lf">   var body: some view {<br/>      Button("Increase Views") {<br/>         testClass.views += 1<br/>      }<br/>   }<br/>}</span></pre><p id="6c97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个例子中，我们创建了一个ObservableObject类的变量“TestClass ”,以便在我们的视图中使用。然后，我们在按钮中访问该类中的变量，以增加视图计数。由于这是ObservableObject中的一个已发布变量，我们的视图知道重新加载自己以反映新的视图计数。</p><h2 id="dcee" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">装订包装:</strong></h2><p id="a10f" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">绑定属性包装器是我们今天要讨论的最后一个重要的属性包装器。这个包装器的主要功能是让声明一个对象来自另一个文件，并且应该在两个位置之间共享。绑定属性包装不同于ObservedObject，因为它不像ObservedObject变量那样通过引用传递对象。这方面的一个例子如下:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="1ed1" class="jt ju hi ky b fi lc ld l le lf">struct TestView: View {<br/>   @State var isShowing = true</span><span id="ce5e" class="jt ju hi ky b fi lg ld l le lf">   var body: some view {<br/>      VStack {<br/>         Text("Something something code")<br/>      }.sheet(isPresented: $isShowing) {<br/>         SecondView(bindingBool: $isShowing)<br/>      }<br/>   }<br/>}</span><span id="d15f" class="jt ju hi ky b fi lg ld l le lf">struct SecondView: View {<br/>   @Binding var bindingBool: Bool</span><span id="bec0" class="jt ju hi ky b fi lg ld l le lf">   var body: some view {<br/>      Button("Close") {<br/>         bindingBool = false<br/>      }<br/>   }<br/>}</span></pre><p id="9dad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们检查上面的代码，我们可以看到我们创建了两个不同的视图。第一个视图“TestView”有一个状态变量，该变量的布尔值被设置为true。这个布尔值让我们的视图知道，如果它被设置为true，它应该显示第二个视图。好的，一旦第二个视图打开，我们希望能够将boolean转换为false，这样我们就可以返回到上一个视图。我们可以通过在第二个视图中创建一个布尔类型的绑定变量来实现这一点。在第二个视图按钮中，我们将bool设置为false。现在，当我们从第一个视图中调用第二个视图时，我们将绑定布尔值设置为原始布尔值“isShowing”。因为这是一个绑定变量，当它改变它的值时,“isShowing”布尔值也会改变为false。</p><h1 id="61fb" class="lh ju hi bd jv li lj lk jz ll lm ln kd lo lp lq kg lr ls lt kj lu lv lw km lx bi translated"><strong class="ak">结论:</strong></h1><p id="fdc1" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">这就结束了我们今天关于一些重要属性包装器的文章，在开始您的Swift UI之旅时，您会想知道这些属性包装器。如果你还没有看过，请务必点击查看本系列的第一篇文章<a class="ae iu" href="https://abeck-lb.medium.com/understanding-hstack-vstack-and-groups-in-swift-ui-e2f2e138f0e6" rel="noopener">。如果您喜欢我的文章，请关注我的页面，并关注更多有趣的Swift UI文章！</a></p></div></div>    
</body>
</html>