<html>
<head>
<title>Rust — Modules and Project Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust —模块和项目结构</h1>
<blockquote>原文：<a href="https://medium.com/codex/rust-modules-and-project-structure-832404a33e2e?source=collection_archive---------0-----------------------#2021-09-15">https://medium.com/codex/rust-modules-and-project-structure-832404a33e2e?source=collection_archive---------0-----------------------#2021-09-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/6f59e1b04940ec60587f6e9a9a879583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*canxw_IfsJZStetm"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由<a class="ae hv" href="https://unsplash.com/@alain_pham?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿兰·范</a>在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><div class=""><h2 id="7fbc" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated">探索一个Rust项目的结构，板条箱，模块，可见性和什么是前奏！？</h2></div><p id="5bc5" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在本系列的<a class="ae hv" href="https://gian-lorenzetto.medium.com/rust-a-beginner-cheat-sheet-8fd7b0ce49de" rel="noopener">第一篇文章</a>中，我讨论了如何安装Rust并使用<em class="kj"> cargo </em> cli工具创建新项目。在这篇文章中，我想更详细地介绍Rust项目的结构，并深入了解箱子、模块和前奏的概念。</p><p id="df35" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果你还没有，那么<a class="ae hv" href="https://gian-lorenzetto.medium.com/rust-a-beginner-cheat-sheet-8fd7b0ce49de" rel="noopener">去安装Rust</a>并确保你可以创建一个新项目</p><p id="dbbb" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du kk kl km kn b">$ cargo new hello_rust</code></p><p id="a4cc" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">提醒一下，这将创建一个新的<em class="kj">二进制应用程序</em>，所以您可以在一个终端上运行这个程序，使用——</p><p id="ba22" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du kk kl km kn b">$ cargo run</code></p><p id="d7ba" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您应该会看到cargo首先编译，然后运行您的应用程序，并将以下内容写入控制台—</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="38b2" class="kw kx hy kn b fi ky kz l la lb">$ cargo run<br/>“Hello, World!”</span></pre><p id="36b2" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">太好了！在本文的剩余部分，我将讨论—</p><ul class=""><li id="ffa5" class="lc ld hy jp b jq jr jt ju jw le ka lf ke lg ki lh li lj lk bi translated">默认的Rust项目结构</li><li id="cfdf" class="lc ld hy jp b jq ll jt lm jw ln ka lo ke lp ki lh li lj lk bi translated"><em class="kj"> main.rs </em>文件</li><li id="12b4" class="lc ld hy jp b jq ll jt lm jw ln ka lo ke lp ki lh li lj lk bi translated">生锈<em class="kj">模块</em>(基于文件)</li><li id="0168" class="lc ld hy jp b jq ll jt lm jw ln ka lo ke lp ki lh li lj lk bi translated">生锈模块和<em class="kj">可见度</em></li><li id="f638" class="lc ld hy jp b jq ll jt lm jw ln ka lo ke lp ki lh li lj lk bi translated">Rust模块(基于文件夹)</li><li id="e7b9" class="lc ld hy jp b jq ll jt lm jw ln ka lo ke lp ki lh li lj lk bi translated">什么是<em class="kj">前奏</em>？</li></ul><p id="4d55" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先，让我们打开默认项目中的内容。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="39bd" class="lx kx hy bd ly lz ma mb mc md me mf mg je mh jf mi jh mj ji mk jk ml jl mm mn bi translated">默认的Rust项目</h1><p id="1019" class="pw-post-body-paragraph jn jo hy jp b jq mo iz js jt mp jc jv jw mq jy jz ka mr kc kd ke ms kg kh ki hb bi translated">默认的Rust控制台应用程序非常简单，但是文件夹结构是<em class="kj">有意为之的</em>，不应该被改变</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="7462" class="kw kx hy kn b fi ky kz l la lb">hello_rust<br/>  - src<br/>    - main.rs<br/>  - .gitignore<br/>  - Cargo.toml</span></pre><p id="499e" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">注意你可以在任何时候使用<code class="du kk kl km kn b">cargo check</code>命令来验证你的文件夹结构和<em class="kj"> Cargo.toml </em>文件。如果你犯了一个错误(在这种情况下，我把<code class="du kk kl km kn b">src</code>改名为<code class="du kk kl km kn b">src1</code>)，Cargo会告诉你需要做什么</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="2dce" class="kw kx hy kn b fi ky kz l la lb">error: failed to parse manifest at `/Users/gian/_working/scratch/hello_rust/Cargo.toml`</span><span id="6c92" class="kw kx hy kn b fi mt kz l la lb">Caused by:<br/> no targets specified in the manifest<br/> <strong class="kn hz">either src/lib.rs, src/main.rs, a [lib] section, or [[bin]] section must be present</strong></span></pre><p id="f0cc" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在我们的例子中，我们必须有一个<code class="du kk kl km kn b">src/main.rs</code>，因为我们创建了一个<em class="kj">二进制</em> <em class="kj">应用程序</em>。如果我们创建了一个新的库(将<code class="du kk kl km kn b">--lib</code>传递给<code class="du kk kl km kn b">cargo new</code>命令)，那么cargo会为我们创建<code class="du kk kl km kn b">src/lib.rs</code>。</p><p id="6111" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><em class="kj"> Cargo.lock </em>文件是自动生成的文件，不可编辑。因为Cargo默认为你初始化一个Git repo，它还包括一个.<em class="kj"> gitignore </em>，有一个条目—</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="eb7e" class="kw kx hy kn b fi ky kz l la lb">/target</span></pre><p id="855d" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在<code class="du kk kl km kn b"> cargo build</code>上自动创建<code class="du kk kl km kn b">target</code>文件夹，并在<em class="kj">调试</em>或<em class="kj">发布</em>文件夹中包含构建<em class="kj">工件</em>(取决于构建配置，记得默认为<em class="kj">调试</em>)。</p><p id="0c38" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果您交叉编译到另一个平台，那么您将看到一个指定目标平台的附加级别，然后是构建配置。</p><p id="b40f" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最后，还有main.rs文件，这是我们应用程序的入口点。让我们仔细看看它的内容。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="735a" class="lx kx hy bd ly lz ma mb mc md me mf mg je mh jf mi jh mj ji mk jk ml jl mm mn bi translated"><em class="mu"> main.rs </em>文件</h1><p id="9c05" class="pw-post-body-paragraph jn jo hy jp b jq mo iz js jt mp jc jv jw mq jy jz ka mr kc kd ke ms kg kh ki hb bi translated">默认的<em class="kj"> main.rs </em>文件非常简单</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="4944" class="kw kx hy kn b fi ky kz l la lb">fn main() {<br/>  println!("Hello, world!");<br/>}</span></pre><p id="3381" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们有<code class="du kk kl km kn b">main()</code>函数，这是我们应用程序的主要入口点，它只打印“Helo，World！”到标准输出。</p><p id="1c31" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您可能已经注意到了<code class="du kk kl km kn b">println!</code>中的<code class="du kk kl km kn b">!</code>——这表明<code class="du kk kl km kn b">println</code>函数是一个Rust宏(一个高级Rust语法特性),除了记住它不是一个常规函数之外，您可以安全地忽略它的大部分内容。</p><p id="a8da" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">虽然您现在可以愉快地在<em class="kj"> main.rs </em>文件中编写所有Rust代码，但这通常并不理想；)这就是模块的用武之地！</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="8e52" class="lx kx hy bd ly lz ma mb mc md me mf mg je mh jf mi jh mj ji mk jk ml jl mm mn bi translated">模块</h1><p id="4c12" class="pw-post-body-paragraph jn jo hy jp b jq mo iz js jt mp jc jv jw mq jy jz ka mr kc kd ke ms kg kh ki hb bi translated">让我们从给<em class="kj"> main.rs </em>添加一个结构开始。我们将逐步将这段代码从主文件中移走，但是现在只需将您的<em class="kj"> main.rs </em>修改成这样——</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="ffed" class="kw kx hy kn b fi ky kz l la lb"><strong class="kn hz">struct MyStruct {}</strong></span><span id="cda7" class="kw kx hy kn b fi mt kz l la lb">fn main() {<br/>  <strong class="kn hz">let _ms = MyStruct {}; </strong>   &lt;-- Note the '_'<br/>}</span></pre><p id="de46" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这是你能写的最简单的程序，但是它能很好地说明Rust的模块。注意变量名前面的<code class="du kk kl km kn b">_</code>——Rust不喜欢未使用的变量(确实如此！)但是通过使用<code class="du kk kl km kn b">_</code>前缀，我们告诉编译器这是有意的，这将防止编译器发出警告。这<em class="kj">不是</em>何时使用这个特性的好例子(“忽略”模式匹配)，但是它在其他情况下也有合法的用途。</p><p id="d40e" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，假设我们的代码失控了，我们想把非常复杂的结构转移到另一个文件中。我们希望我们的代码是<em class="kj">松散耦合的</em>和<em class="kj">高度内聚的</em>！让我们这样做，并创建一个名为<em class="kj"> my_struct.rs </em>的新文件</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="3790" class="kw kx hy kn b fi ky kz l la lb">hello_rust<br/>  - src<br/>    - main.rs<br/>    <strong class="kn hz">- my_struct.rs</strong></span></pre><p id="26a1" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">注意，我们<em class="kj">必须</em>将文件添加到<code class="du kk kl km kn b">src/</code>文件夹下，这样编译器才能找到它。虽然文件名并不重要，但是使用<em class="kj"> snake_case </em>是习惯用法，所以这就是我们在这里要做的。</p><p id="bbfb" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">将结构声明从<em class="kj"> main.rs </em>中取出，放入<em class="kj"> my_struct.rs — </em></p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="cefb" class="kw kx hy kn b fi ky kz l la lb">// Contents of my_struct.rs</span><span id="efbb" class="kw kx hy kn b fi mt kz l la lb">struct MyStruct {}</span></pre><p id="3dfc" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">试着建立这个项目—</p><p id="5e4e" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du kk kl km kn b">$ cargo build</code></p><p id="6907" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果您从<em class="kj"> main.rs </em>中删除了结构声明，您将会看到如下错误</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="f05b" class="kw kx hy kn b fi ky kz l la lb">Compiling hello_rust v0.1.0 (/scratch/hello_rust)<br/>error[E0422]: cannot find struct, variant or union type `MyStruct` in this scope<br/> → src/main.rs:2:15<br/>  |<br/>2 | let _ms = MyStruct {};<br/>  |           <strong class="kn hz">^^^^^^^^ not found in this scope</strong><br/>error: aborting due to previous error</span><span id="5d3f" class="kw kx hy kn b fi mt kz l la lb">For more information about this error, try `rustc — explain E0422`. error: could not compile `hello_rust`</span></pre><p id="548b" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Rust告诉我们，它再也找不到结构的定义了。这就是<em class="kj">模块</em>的用武之地——不像其他一些语言，你必须<em class="kj">明确地将代码</em>包含到你的应用程序中。Rust不会简单地找到文件并为您编译/包含它。</p><p id="ab5d" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了包含结构声明，我们需要更新我们的<em class="kj"> main.rs </em>来添加一个<em class="kj">模块</em>引用，就像这样—</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="c1ed" class="kw kx hy kn b fi ky kz l la lb"><strong class="kn hz">mod my_struct;</strong></span><span id="1661" class="kw kx hy kn b fi mt kz l la lb">fn main() {<br/>  let _ms = MyStruct {};<br/>}</span></pre><p id="0645" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在Rust中，所有的文件和文件夹都是<em class="kj">模块</em>。为了在一个模块中使用代码，你需要首先用<code class="du kk kl km kn b">mod</code>语法<em class="kj">导入</em>它。本质上，这是在找到<code class="du kk kl km kn b">mod my_struct;</code>语句的地方插入来自模块的代码。稍后将详细介绍文件夹模块。</p><p id="7fff" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">尝试重新构建。等等，这是什么！？还是不行…嗯。让我们来看看错误信息—</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="2616" class="kw kx hy kn b fi ky kz l la lb">Compiling hello_rust v0.1.0 (/scratch/hello_rust)<br/>error[E0422]: cannot find struct, variant or union type `MyStruct` in this scope<br/> → src/main.rs:4:15<br/>  |<br/>4 | let _ms = MyStruct {};<br/>  |           <strong class="kn hz">^^^^^^^^ not found in this scope</strong><br/>  |<br/>help: consider importing this struct<br/>  |<br/>1 | <strong class="kn hz">use crate::my_struct::MyStruct;</strong><br/>  |</span></pre><p id="5236" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">虽然错误是相同的，但现在有一个关于添加的有用提示—</p><p id="22c5" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du kk kl km kn b">use crate::my_struct::MyStruct;</code></p><p id="c1e3" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们试一试——把<em class="kj"> main.rs </em>改成这个样子(但是<em class="kj">还没有</em>构建！剧透一下，我们还有另一个问题，稍后我会谈到)—</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="cb07" class="kw kx hy kn b fi ky kz l la lb">mod my_struct;<br/><strong class="kn hz">use crate::my_struct::MyStruct;</strong></span><span id="f372" class="kw kx hy kn b fi mt kz l la lb">fn main() {<br/>  let _ms = MyStruct {};<br/>}</span></pre><p id="837b" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里有一点需要解开。当您使用<code class="du kk kl km kn b">mod</code>语句导入一个模块时，Rust <em class="kj">会自动</em>为它创建一个模块名称空间(以避免冲突),因此我们不能直接访问我们的结构类型。模块名称空间自动取自文件名(因为在这种情况下模块是一个文件)，因此是<code class="du kk kl km kn b">use</code>语句的<code class="du kk kl km kn b"><strong class="jp hz">my_struct</strong>::MyStruct;</code>部分——它首先来自文件名<em class="kj"> my_struct.rs </em>(没有文件扩展名)。</p><p id="07f4" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><code class="du kk kl km kn b">use</code>语句中<code class="du kk kl km kn b">crate::</code>部分的原因是<em class="kj">所有</em>锈项目都是板条箱。正如你现在看到的，Rust项目可以由多个文件组成(这些文件是<em class="kj">模块</em>，它们可以嵌套在文件夹中(这些文件夹也是<em class="kj">模块</em>)。为了访问模块树的根，你可以使用前缀<code class="du kk kl km kn b">crate::</code>。</p><p id="7682" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所以再看一下我们的主页面，我们有——</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="d688" class="kw kx hy kn b fi ky kz l la lb">mod my_struct;                 <strong class="kn hz"> &lt;-- Import the module code, placing<br/>                                    it into the 'my_struct'<br/>                                    namespace</strong></span><span id="d3b5" class="kw kx hy kn b fi mt kz l la lb">use crate::my_struct::MyStruct; <strong class="kn hz">&lt;-- Map the fully qualified (from <br/>                                    the crate root) struct <br/>                                    declaration to just 'MyStruct'</strong></span><span id="25e7" class="kw kx hy kn b fi mt kz l la lb">fn main() {<br/>  let _ms = MyStruct {};        <strong class="kn hz">&lt;-- Yay, we found it! .. or did we?</strong><br/>}</span></pre><p id="5585" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果这看起来令人困惑(我必须说，我发现来自C#的这一点有点令人困惑)，请记住这一点—</p><ul class=""><li id="e22d" class="lc ld hy jp b jq jr jt ju jw le ka lf ke lg ki lh li lj lk bi translated">您<em class="kj">必须</em>使用<code class="du kk kl km kn b">mod</code>将一个模块(文件或文件夹)包含到您的应用程序中。</li><li id="0ad8" class="lc ld hy jp b jq ll jt lm jw ln ka lo ke lp ki lh li lj lk bi translated"><code class="du kk kl km kn b">use</code>关键字可以方便地将完全限定的类型名映射到它的类型名(你甚至可以重命名类型，但那是另一篇文章)。</li></ul></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="0a5d" class="lx kx hy bd ly lz ma mb mc md me mf mg je mh jf mi jh mj ji mk jk ml jl mm mn bi translated">模块—可见性</h1><p id="15f8" class="pw-post-body-paragraph jn jo hy jp b jq mo iz js jt mp jc jv jw mq jy jz ka mr kc kd ke ms kg kh ki hb bi translated">如果你不耐烦了(继续，承认吧！)那么您将试图构建先前的<em class="kj"> main.rs </em>实例，并得到另一个错误——</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="c53b" class="kw kx hy kn b fi ky kz l la lb">Compiling hello_rust v0.1.0 (/scratch/hello_rust)<br/>error[E0603]: struct `MyStruct` is private<br/> → src/main.rs:2:23<br/>  |<br/>2 | use crate::my_struct::MyStruct;<br/>  |                       <strong class="kn hz">^^^^^^^^ private struct</strong><br/>  |</span></pre><p id="66bc" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这告诉我们，尽管我们已经找到了struct声明，但是模块的可见性是私有的，因此我们不能在这里访问它。</p><p id="f42f" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">Rust中的可见性与C#等语言略有不同，但记住一些规则是有好处的——</p><ul class=""><li id="6036" class="lc ld hy jp b jq jr jt ju jw le ka lf ke lg ki lh li lj lk bi translated">模块中的所有内容(即文件夹<code class="du kk kl km kn b">/src</code>中的文件或子文件夹)都可以访问模块<em class="kj">中的其他内容</em>。</li><li id="332c" class="lc ld hy jp b jq ll jt lm jw ln ka lo ke lp ki lh li lj lk bi translated">模块之外的一切<em class="kj">只能<em class="kj">访问该模块的公共成员。</em></em></li></ul><p id="4d85" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这乍一看可能很奇怪，但是它有一些非常吸引人的副作用——模块内的私有函数对于该模块内的测试仍然是可访问的(习惯性Rust将单元测试保持在模块内)。第二，每个模块都被强制声明一个公共接口，定义模块外部可以访问的成员。</p><p id="22a4" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">要使一个模块的成员成为公共的，我们必须添加<code class="du kk kl km kn b">pub</code>关键字。让我们再次访问我们的<em class="kj"> my_struct.rs </em>文件，并将内容替换为—</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="7ee4" class="kw kx hy kn b fi ky kz l la lb"><strong class="kn hz">pub</strong> struct MyStruct {}         &lt;-- Add the 'pub' keyword</span></pre><p id="9e8b" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">就是这样！您现在可以成功地构建我们异常复杂的应用程序:)注意，您可以将<code class="du kk kl km kn b">pub</code>放在大多数声明上，包括结构、结构字段、函数(关联的或其他的)、常量等等。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="2c50" class="lx kx hy bd ly lz ma mb mc md me mf mg je mh jf mi jh mj ji mk jk ml jl mm mn bi translated">模块—文件夹</h1><p id="6398" class="pw-post-body-paragraph jn jo hy jp b jq mo iz js jt mp jc jv jw mq jy jz ka mr kc kd ke ms kg kh ki hb bi translated">现在假设我们的<code class="du kk kl km kn b">MyStruct</code>结构失控了，我们想把它分成多个文件。我们想把这些收集到一个文件夹里，当然是为了保持整洁。</p><p id="d86c" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">正如上面提到的，Rust以同样的方式对待文件和文件夹(作为模块),只有一个关键的不同。</p><p id="9ef2" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们首先创建一个名为<code class="du kk kl km kn b">foo/</code>的文件夹，因为我们已经意识到<code class="du kk kl km kn b">MyStruct</code>实际上是我们应用程序的foo功能的一部分。接下来将文件<em class="kj"> my_struct.rs </em>移动到<code class="du kk kl km kn b">/src/foo</code>中。也就是说，新的文件夹结构应该是这样的—</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="f890" class="kw kx hy kn b fi ky kz l la lb">- src/<br/>  - main.rs<br/>  - <strong class="kn hz">foo/<br/>    - my_struct.rs</strong></span></pre><p id="1666" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在编辑<em class="kj"> main.rs </em>来包含我们的新模块<code class="du kk kl km kn b">foo</code>替换<code class="du kk kl km kn b">my_struct</code> —</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="4577" class="kw kx hy kn b fi ky kz l la lb">mod <strong class="kn hz">foo</strong>;                   &lt;-- Change the module to match the folder<br/>use crate::<strong class="kn hz">foo</strong>::MyStruct;  &lt;-- Update the namespace to 'foo'</span><span id="7791" class="kw kx hy kn b fi mt kz l la lb">fn main() {<br/>  let _ms = MyStruct {};<br/>}</span></pre><p id="65f5" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们现在可以构建这个(<code class="du kk kl km kn b">cargo build</code>)，但是我们会得到一个错误。和往常一样，Rust的错误信息很有启发性</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="21e6" class="kw kx hy kn b fi ky kz l la lb">Compiling hello_rust v0.1.0 (/scratch/hello_rust)<br/>error[E0583]: <strong class="kn hz">file not found for module `foo`</strong><br/> → src/main.rs:1:1<br/>  |<br/>1 | mod foo;<br/>  | ^^^^^^^^<br/>  |<br/>  = help: <strong class="kn hz">to create the module `foo`, create file “src/foo.rs” or “src/foo/mod.rs”</strong></span></pre><p id="c987" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当试图导入一个定义为文件夹的模块时，我们使用文件夹名(就像我们之前对基于文件的模块所做的那样)，但是Rust期望文件夹中存在一个名为<em class="kj"> mod.rs </em>的文件。</p><p id="7c7b" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这种情况下，我们可以简单地将我们的<em class="kj"> my_struct.rs </em>重命名为<em class="kj"> mod.rs </em>，瞧！我们的应用程序正在重新构建。</p><p id="fbd1" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了完整起见，让我们用另一个结构定义(虚构地命名为另一个)将一个文件添加到<code class="du kk kl km kn b">foo/</code>文件夹中</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="1b29" class="kw kx hy kn b fi ky kz l la lb">// Contents of src/foo/another.rs</span><span id="19f3" class="kw kx hy kn b fi mt kz l la lb"><strong class="kn hz">pub</strong> struct Another {}   &lt;-- We're going to expose this as public<br/>                            from the 'foo' module so that we can<br/>                            use it in main.rs</span></pre><p id="5e2f" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将新模块导入到<em class="kj"> mod.rs </em>文件中——</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="16e7" class="kw kx hy kn b fi ky kz l la lb">// Contents of src/foo/mod.rs</span><span id="9613" class="kw kx hy kn b fi mt kz l la lb"><strong class="kn hz">pub mod another;        </strong>&lt;-- Add the module import for 'another'<br/>                            Note the use of 'pub' to expose the <br/>                            module 'another' as public from the <br/>                            module 'foo'<br/>pub struct MyStruct {}</span></pre><p id="63f3" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最后，尝试在main.rs中使用我们新的另一个结构</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="850f" class="kw kx hy kn b fi ky kz l la lb">mod foo;<br/>use crate::foo::MyStruct;<br/><strong class="kn hz">use crate::foo::another::Another;</strong> &lt;-- Note that 'another' is a<br/>                                      module within 'foo'</span><span id="0216" class="kw kx hy kn b fi mt kz l la lb">fn main() {<br/>  let _ms = MyStruct {};<br/>  <strong class="kn hz">let _a = Another {};           </strong> &lt;-- Using prefix '_' as before<br/>}</span></pre><p id="e0d2" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果这看起来有点繁琐，那是因为它是。然而，有一个更好的方法。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="8751" class="lx kx hy bd ly lz ma mb mc md me mf mg je mh jf mi jh mj ji mk jk ml jl mm mn bi translated">序幕</h1><p id="8684" class="pw-post-body-paragraph jn jo hy jp b jq mo iz js jt mp jc jv jw mq jy jz ka mr kc kd ke ms kg kh ki hb bi translated">让我们重新查看一下<code class="du kk kl km kn b">foo/</code>文件夹中的<em class="kj"> mod.rs </em>文件。将内容更改为以下内容—</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="1b9c" class="kw kx hy kn b fi ky kz l la lb"><strong class="kn hz">mod another;              </strong>&lt;-- Remove the 'pub' modifier<strong class="kn hz"><br/>pub use another::Another;</strong> &lt;-- Add a use'ing to map Another directly<br/>                              into 'foo' and make it public<br/>pub struct MyStruct {}</span></pre><p id="49eb" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里我们不再希望模块another是公共的，所以我们去掉了<code class="du kk kl km kn b">pub</code>关键字。然后，<code class="du kk kl km kn b">use</code>语句将把<code class="du kk kl km kn b">Another</code>的完全限定类型映射到<em class="kj"> foo </em>名称空间(因为我们在foo模块中)。</p><p id="bc3b" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最后，让我们更新一下我们的主页</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="892c" class="kw kx hy kn b fi ky kz l la lb">mod foo;<br/>use crate::foo::{MyStruct<strong class="kn hz">,Another</strong>};</span><span id="ce33" class="kw kx hy kn b fi mt kz l la lb">fn main() {<br/>  let _ms = MyStruct {};<br/>  let _a = Another {};<br/>}</span></pre><p id="4ab7" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">好多了！注意，由于我们已经将类型名<code class="du kk kl km kn b">Another</code>映射到了<em class="kj"> foo </em>模块中，我们可以利用扩展的<code class="du kk kl km kn b">use</code>语法一次导入多个名称。</p><p id="9091" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这里的关键要点是，你应该把<em class="kj"> mod.rs </em>文件看作是定义你的模块的接口。虽然一开始看起来有点令人生畏，但是它给了您对公开内容的很多控制，同时仍然允许在模块内进行完全访问(例如测试)。</p><p id="0531" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">好，那太好了…那么我听到你问什么是前奏？嗯，prelude只是一种模式，以一种惯用的方式，使您想要公开的所有类型都可用。并不是所有的箱子都定义了前奏(虽然很多都定义了),你也不总是需要前奏，但是不管怎样，让我们继续为我们的小项目定义一个前奏。</p><p id="edd3" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">回到我们的主题，我们开始吧</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="b96a" class="kw kx hy kn b fi ky kz l la lb">mod foo;</span><span id="a4d9" class="kw kx hy kn b fi mt kz l la lb"><strong class="kn hz">mod prelude {                             </strong>&lt;-- Create module inline<strong class="kn hz"><br/>  pub use crate::foo::{MyStruct,Another}; </strong>&lt;-- Note the 'pub' here!<strong class="kn hz"><br/>}</strong></span><span id="c1b3" class="kw kx hy kn b fi mt kz l la lb"><strong class="kn hz">use crate::prelude::*;                    </strong>&lt;-- Make the types exposed<br/>                                              in the prelude<br/>                                              available<strong class="kn hz"><br/></strong>fn main() {<br/>  let _ms = MyStruct {};<br/>  let _a = Another {};<br/>}</span></pre><p id="b856" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将prelude定义为另一个模块(使用<code class="du kk kl km kn b">mod</code>)，只是这次我们直接指定模块，而不是让Rust寻找相应的文件或文件夹。</p><p id="b460" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在我们也可以像使用其他模块一样使用<code class="du kk kl km kn b">prelude</code>模块，例如在<em class="kj"> mod.rs </em>文件中——</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="e52c" class="kw kx hy kn b fi ky kz l la lb">mod another;<br/>pub use another::Another;</span><span id="db26" class="kw kx hy kn b fi mt kz l la lb"><strong class="kn hz">use crate::prelude::*;</strong></span><span id="8cb5" class="kw kx hy kn b fi mt kz l la lb">pub struct MyStruct {}</span></pre><p id="0582" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这种人为的情况下，前奏完全没有必要。但是您可以看到，如果您在prelude中声明了多个板条箱、标准库类型、常量和其他模块，那么您可以立即访问它们，只需一条<code class="du kk kl km kn b">use</code>语句。</p><p id="66e8" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">它还强调了模块使用的其他一些有趣的部分——</p><ul class=""><li id="e167" class="lc ld hy jp b jq jr jt ju jw le ka lf ke lg ki lh li lj lk bi translated">您可以使用通配符<code class="du kk kl km kn b">::*</code>从模块中导入所有公共名称</li><li id="068c" class="lc ld hy jp b jq ll jt lm jw ln ka lo ke lp ki lh li lj lk bi translated">您可以使用<code class="du kk kl km kn b">crate::</code>来访问模块树的根(也就是本例中的主模块),并且您可以在应用程序的任何地方这样做。</li></ul></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><h1 id="1d45" class="lx kx hy bd ly lz ma mb mc md me mf mg je mh jf mi jh mj ji mk jk ml jl mm mn bi translated">摘要</h1><p id="66fa" class="pw-post-body-paragraph jn jo hy jp b jq mo iz js jt mp jc jv jw mq jy jz ka mr kc kd ke ms kg kh ki hb bi translated">Rust中的模块系统无疑是该语言中更令人困惑的方面之一。来自C++/C#背景，结合模块可见性规则(和前奏)，这是彻头彻尾的混乱！但是一旦你理解了什么是模块(文件，文件夹)以及如何导入它们(<code class="du kk kl km kn b">mod</code>)然后将名字映射到不同的模块(<code class="du kk kl km kn b">use</code>)就开始有意义了。</p><p id="e5eb" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">记住Rust项目结构非常具体也很重要(应用程序vs库=<em class="kj">main . RS</em>vs<em class="kj">lib . RS</em>)，要求某些文件存在于不同的上下文中(<em class="kj"> mod.rs </em>)。</p><p id="10ba" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">希望这是有帮助的(它是为我写的！).</p><p id="7ea5" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">接下来，<a class="ae hv" href="https://gian-lorenzetto.medium.com/rust-structs-functions-and-methods-d60fd597d956" rel="noopener">结构，相关的函数和方法</a>。</p></div></div>    
</body>
</html>