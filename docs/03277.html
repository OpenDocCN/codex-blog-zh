<html>
<head>
<title>Next Generation Node.js server Dev Tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下一代Node.js服务器开发工具</h1>
<blockquote>原文：<a href="https://medium.com/codex/next-generation-node-js-server-dev-tool-857859ce7c65?source=collection_archive---------15-----------------------#2021-08-25">https://medium.com/codex/next-generation-node-js-server-dev-tool-857859ce7c65?source=collection_archive---------15-----------------------#2021-08-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/4fd6e430c8c686abc9f80c67f795d70c.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*gP6gdDgVJTjfe6aKtUDSvg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">插件节点</figcaption></figure><p id="b104" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">TL；博士</strong></p><blockquote class="jo jp jq"><p id="3d0d" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="hi">使用我制作的牛逼</em> <a class="ae jv" href="https://github.com/axe-me/vite-plugin-node" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> vite插件</em> </a> <em class="hi">实现快速节点服务器开发体验！喜欢就开始吧！</em></p></blockquote><h1 id="ea83" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">动机</h1><p id="200d" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">我最近在做一个相对较大的nestjs后端项目。缓慢的开发服务器让我发疯！每次代码更新，需要几秒钟来重启开发服务器。我尝试用webpack替换nest CLI，希望webpack HMR可以帮助提高重新编译的速度。尽管HMR工作得很好，但在模块更新后，它仍然会重启dev服务器以使更新后的模块生效。这使得从HMR节省的时间都浪费了，因为服务器重启是相当耗时的，因为它需要杀死当前的进程，并重生一个新的。一个模块更新后服务器根本不需要重启怎么办？如果那些令人惊奇的新前端工具也适用于后端开发会怎么样？经过几天的研究/工作，我为Vitejs制作了一个插件，允许我用vite运行我的节点服务器！</p><h1 id="0786" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">石器时代后端工具</h1><p id="45c8" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">在进一步了解这个神奇的插件之前。让我们谈谈现在后端开发的现有开发工具。我会解释为什么没有一个是理想的。</p><h2 id="5ac2" class="kz jx hi bd jy la lb lc kc ld le lf kg jb lg lh kk jf li lj ko jj lk ll ks lm bi translated">nodemon</h2><p id="c873" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">这个工具背后的想法非常简单:</p><blockquote class="jo jp jq"><p id="7975" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="hi">监视node.js应用程序中的任何变化，并自动重启服务器</em></p></blockquote><p id="68c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这对于编写一些启动时间可以忽略不计的小型纯javascript节点服务器很有好处。另一方面，这意味着大型项目的重新加载时间很慢，并且缺乏类型脚本支持。</p><h2 id="9b09" class="kz jx hi bd jy la lb lc kc ld le lf kg jb lg lh kk jf li lj ko jj lk ll ks lm bi translated">ts节点</h2><p id="bf5a" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">这是直接运行typescript文件的最流行的工具之一。然而，该工具本身不会为您处理服务器重载。您必须使用nodemon之类的工具来帮助您重新加载服务器。这意味着它也有nodemon带来的缺点。</p><h2 id="31fd" class="kz jx hi bd jy la lb lc kc ld le lf kg jb lg lh kk jf li lj ko jj lk ll ks lm bi translated">nodejs寄存器/ esm加载程序</h2><p id="30c0" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">很多人使用构建在nodejs之上的各种工具，这些工具需要hook(或者ESM的新加载器)。这实际上是让nodejs原生支持运行typescript代码的一个非常聪明的方法。在此基础上实现HMR系统实际上也很容易。我们需要做的就是在缓存中缓存所有转换后的代码，并在模块更新后使缓存失效。然后下次当其他模块需要/导入该模块时，转换将重新编译更新后的模块。这有点像JIT编译，比从头开始编译要好得多。我实际上试图用ESBuild/SWC作为类型脚本编译器编写自己的ESM加载程序，并使用内存缓存来实现这个POC。但是当它几乎完成一半时，我意识到我正在实现一些已经存在于Vitejs源代码中的东西！我在这里重新发明轮子！</p><h1 id="dee9" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">Vite到底是什么？</h1><p id="eb0d" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">来自Vite github描述:</p><blockquote class="jo jp jq"><p id="4ec9" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="hi"> Vite(法语“快速”的意思，读作/vit/)是一种新型的前端构建工具，可以显著改善前端开发体验。它由两大部分组成:</em></p><p id="75ff" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="hi"> -一个开发服务器，通过本地es模块提供您的源文件，具有丰富的内置功能和惊人的快速热模块替换(HMR)。</em></p><p id="99e1" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="hi"> -一个构建命令，将您的代码与Rollup捆绑在一起，预先配置为输出高度优化的静态资产用于生产。</em></p><p id="f899" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">此外，Vite通过其插件API和JavaScript API具有高度的可扩展性，并支持完整的类型。</p></blockquote><p id="5fd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我知道，它本来是为前端开发做的。但我们一些调整，我们可以用它作为后端我保证！我们在描述中看到的一些关键词是<code class="du ln lo lp lq b">fast HMR</code>、<code class="du ln lo lp lq b">Dev Server</code>、<code class="du ln lo lp lq b">extensible</code>。请允许我解释我们如何在节点服务器开发中利用这些特性。</p><h2 id="8a7b" class="kz jx hi bd jy la lb lc kc ld le lf kg jb lg lh kk jf li lj ko jj lk ll ks lm bi translated">超快速HMR</h2><p id="0581" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">怎么会？Vite在内部构建了一个模块图来跟踪所有的依赖项，并在开始时缓存所有转换后的源代码。这使得像HMR这样的JIT就像我们前面谈到的那样。</p><h2 id="e4c0" class="kz jx hi bd jy la lb lc kc ld le lf kg jb lg lh kk jf li lj ko jj lk ll ks lm bi translated">开发服务器</h2><p id="eafd" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">Vite内部使用connect作为HTTP服务器，该服务器可通过Vite插件/javascript API进行定制和扩展。这意味着我们可以将来自vite dev服务器的原始nodejs HTTP请求传递给我们自己的应用程序。所有这些便利的配置，如本地https，对本地开发也非常有帮助。</p><h2 id="505c" class="kz jx hi bd jy la lb lc kc ld le lf kg jb lg lh kk jf li lj ko jj lk ll ks lm bi translated">高度可扩展</h2><p id="98dd" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">感谢出色的API设计。我们几乎可以自定义vite中的所有内容。默认情况下，Vite使用esbuild来转换typescript，想使用swc来处理一些esbuild还不支持的装饰特性吗？没问题，用swc插件处理typescript转换就行了，ez！pz！</p><h2 id="82a5" class="kz jx hi bd jy la lb lc kc ld le lf kg jb lg lh kk jf li lj ko jj lk ll ks lm bi translated">最后一点，但并非最不重要</h2><p id="4b0e" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">Vite是尤雨溪创建的，他也是Vue.js的作者。我无耻地承认我是他的超级粉丝。艾凡总能找到非常独特的方法来解决一些常见的问题。</p><h2 id="1209" class="kz jx hi bd jy la lb lc kc ld le lf kg jb lg lh kk jf li lj ko jj lk ll ks lm bi translated">Vite节点插件</h2><p id="2e55" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">最后，我来介绍一下我的宝贝插件。回购位于<a class="ae jv" href="https://github.com/axe-me/vite-plugin-node" rel="noopener ugc nofollow" target="_blank">axe-me/vite-plugin-node</a>。如果试用后喜欢，请给它一颗星。</p><h1 id="3b42" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">它是如何工作的？</h1><p id="1023" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">Vite设计有一个middlewareMode，它允许我们在其他模块中以编程方式使用vite。最初是为SSR web app做的。因此对于每个请求，vite可以加载渲染器来呈现您对应用程序所做的最新更改。这个插件利用这个特性来加载和执行带有传入HTTP请求的服务器应用程序条目。</p><p id="4e3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可能会问是不是超级慢，因为它从入口重新编译/重新加载整个应用程序？答案是否定的，因为vite很聪明。请使用内置模块图作为缓存层，该图是在首次加载应用程序时构建的。在那之后，当你更新一个文件时，vite将只使它自己和它的父模块无效，因此对于下一个请求，只有那些无效的模块需要重新编译，这是由于ESBuild和SWC的超级快。</p><h1 id="7fd0" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">怎么用？</h1><p id="766b" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">你可以阅读回购的自述文件，因为这是唯一的真相文件来源。或者继续阅读这篇文章，先了解一些情况:</p><ol class=""><li id="7fcb" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn lw lx ly lz bi translated">用你最喜欢的软件包管理器安装vite和这个插件，这里用npm作为例子:</li></ol><p id="623c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ln lo lp lq b">npm install vite vite-plugin-node -D</code></p><p id="fc5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.在您的项目根目录中创建一个<code class="du ln lo lp lq b">vite.config.ts</code>文件来配置vite以实际使用这个插件:</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="9a12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.更新您的服务器条目以导出名为<code class="du ln lo lp lq b">viteNodeApp</code>或您配置的名称的应用。</p><ul class=""><li id="a0d1" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn mg lx ly lz bi translated">ExpressJs</li></ul><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="me mf l"/></div></figure><ul class=""><li id="819c" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn mg lx ly lz bi translated">KoaJs</li></ul><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="me mf l"/></div></figure><ul class=""><li id="af19" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn mg lx ly lz bi translated">Fastify</li></ul><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="me mf l"/></div></figure><ul class=""><li id="5e61" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn mg lx ly lz bi translated">NestJs</li></ul><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="8e5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.添加一个npm脚本来运行开发服务器:</p><p id="a7a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ln lo lp lq b">"scripts": { "dev": "vite" },</code></p><p id="8d37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.运行脚本！<code class="du ln lo lp lq b">npm run dev</code></p><h2 id="1f07" class="kz jx hi bd jy la lb lc kc ld le lf kg jb lg lh kk jf li lj ko jj lk ll ks lm bi translated">自定义适配器</h2><p id="0c82" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">如果你最喜欢的框架还不被支持，你可以创建一个问题来请求它，或者使用<code class="du ln lo lp lq b">adapter</code>选项来告诉插件如何将请求传递给你的应用程序。您可以从<code class="du ln lo lp lq b">./src/server</code>文件夹中查看支持的框架是如何实现的。<br/>举例:</p><pre class="ma mb mc md fd mh lq mi mj aw mk bi"><span id="cbca" class="kz jx hi lq b fi ml mm l mn mo">import { defineConfig } from 'vite';<br/>import { VitePluginNode } from 'vite-plugin-node';</span><span id="4552" class="kz jx hi lq b fi mp mm l mn mo">export default defineConfig({<br/>  plugins: [<br/>    ...VitePluginNode({<br/>      adapter: function(app, req, res) {<br/>        app(res, res)<br/>      },<br/>      appPath: './app.ts'<br/>    })<br/>  ]<br/>})</span></pre><h1 id="f9cb" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">例子</h1><p id="6a85" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">repo中有一个包含不同用例的examples文件夹。</p><h1 id="c5bb" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结束了</h1><p id="0263" class="pw-post-body-paragraph iq ir hi is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hb bi translated">这个插件帮助我更有效率，只是因为我不需要等待几秒钟来重新加载服务器，这样我的大脑就可以不停地转动，中间没有任何休息。希望更多的人可以开始用我的插件来开发后端服务器。我的最终目标是取代nodemon/ts-node等石器时代的工具。<br/>快乐编码！</p><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="er es mq"><img src="../Images/6d0535a9bb564126cc86d046f6f74196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B6A_lYKve3BWmptu.jpg"/></div></div></figure></div></div>    
</body>
</html>