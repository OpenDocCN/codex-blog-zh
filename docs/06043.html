<html>
<head>
<title>Making Go errors play nicely with Sentry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使Go错误与哨兵玩得很好</h1>
<blockquote>原文：<a href="https://medium.com/codex/making-go-errors-play-nicely-with-sentry-3ac2cc423cd0?source=collection_archive---------8-----------------------#2022-04-07">https://medium.com/codex/making-go-errors-play-nicely-with-sentry-3ac2cc423cd0?source=collection_archive---------8-----------------------#2022-04-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2446" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://incident.io/" rel="noopener ugc nofollow" target="_blank"> incident.io </a>这里，我们提供了一个基于Slack的事件响应工具。该产品由一个单片Go后端服务提供支持，为一个支持Slack交互的API提供服务，为我们的web仪表板提供API，并运行后台作业来帮助运行我们的客户事件。</p><p id="7dd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事件是高风险的，我们想知道什么时候出了问题。我们使用的工具之一是<a class="ae jd" href="https://sentry.io/welcome/" rel="noopener ugc nofollow" target="_blank"> Sentry </a>，这是我们的Go后端发送错误的地方。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/4f05408d7a24f3678fd5c33b0decab80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JFNSYPyJz417Rcugixm7kA.png"/></div></div></figure><p id="342a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当出现问题时，我们:</p><ul class=""><li id="5951" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">打开岗哨中的错误</li><li id="8fff" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">使用stacktrace找到出错的代码</li><li id="51ba" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">进入代码以应用修复</li></ul><p id="bff2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">遗憾的是，标准的Go错误没有堆栈跟踪。事实上，Go想要对错误建模的方式使得它很难从像Sentry这样的工具中获得太多的价值。</p><p id="a8d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经做了一个让错误为我们工作的噩梦。虽然我们离完美还有很长的路要走，但我们的设置更接近我们在其他语言中所习惯的，因此Sentry更有用。</p><p id="9adc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们是这样做的。</p><h1 id="8cea" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">麻烦你了。</h1><p id="e0d3" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">没有堆栈跟踪，哨兵几乎是无用的。</p><p id="17bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于Go的标准库选择不实现它们，我们需要找到一个实现它们的库。</p><p id="ab10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">戴夫·切尼写的<a class="ae jd" href="https://github.com/pkg/errors" rel="noopener ugc nofollow" target="_blank"> pkg/errors </a>是Go应用程序事实上的标准。多年来，这个包一直是Go的标准错误库，尽管这个项目现在已经存档了。我建议我们忽略这一点，因为库的无处不在意味着它不太可能消失，并且没有替代方案提供相同的功能。</p><p id="675e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/pkg/errors" rel="noopener ugc nofollow" target="_blank"> pkg/errors </a>实现了一个StackTracer错误，它提供了我们需要的东西。许多工具都是针对这个接口构建的——包括Sentry——所以只要我们使用它的<code class="du lh li lj lk b">errors.New</code> , Sentry就能够提取跟踪信息并呈现出来。</p><pre class="jf jg jh ji fd ll lk lm ln aw lo bi"><span id="6d55" class="lp kf hi lk b fi lq lr l ls lt">import (<br/>  "github.com/pkg/errors"<br/>)</span><span id="5839" class="lp kf hi lk b fi lu lr l ls lt">func main() {<br/>  errors.New("it ded") // will include a stacktrace<br/>}</span></pre><p id="4c64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺便说一下，理解使用哪个包花了一些时间。虽然<a class="ae jd" href="https://github.com/pkg/errors" rel="noopener ugc nofollow" target="_blank"> pkg/errors </a>似乎已经赢了，但它已经存档且无人维护，这不是最好的迹象。然后<a class="ae jd" href="https://pkg.go.dev/golang.org/x/xerrors" rel="noopener ugc nofollow" target="_blank"> xerrors </a>也有类似的目标，但是也关闭了，只是部分并入了标准库中。</p><p id="1e2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于像如何处理错误这样重要的事情，你会发现自己处在一个混乱的生态系统中。</p><h1 id="c44e" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">所有错误都会得到堆栈跟踪</h1><p id="7f44" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">使用pkg/errors，我们现在可以创建包含堆栈跟踪的错误。但是并不总是我们的代码产生错误，虽然我们可以lint我们自己的代码来确保我们总是使用pkg/errors，但是我们的许多依赖项(包括标准库)不会。</p><p id="2950" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如果我们有:</p><pre class="jf jg jh ji fd ll lk lm ln aw lo bi"><span id="91b8" class="lp kf hi lk b fi lq lr l ls lt">f, err := os.Open(filename)</span></pre><p id="03e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们吃饱了，因为<code class="du lh li lj lk b">err</code>根本没有堆栈跟踪。</p><p id="4fa7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从stdlib返回的错误是非常基本的，不想为构建stacktrace付出性能代价。作为一个例子，下面是<code class="du lh li lj lk b">fs.PathError</code>的定义，如果<code class="du lh li lj lk b">Open</code>找不到文件，就会收到这个定义:</p><pre class="jf jg jh ji fd ll lk lm ln aw lo bi"><span id="a8d0" class="lp kf hi lk b fi lq lr l ls lt">type PathError struct {<br/>	Op   string<br/>	Path string<br/>	Err  error<br/>}</span></pre><p id="19b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，在该结构中找不到stacktrace。</p><p id="cd48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，我们将尝试使用pkg/errors附带的<code class="du lh li lj lk b">Wrap</code>函数来“包装”我们的错误。</p><p id="bc18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的代码库中，当处理错误时，您几乎总是会看到以下模式:</p><pre class="jf jg jh ji fd ll lk lm ln aw lo bi"><span id="5a58" class="lp kf hi lk b fi lq lr l ls lt">f, err := os.Open(filename)<br/>if err != nil {<br/>  return errors.Wrap(err, "opening configuration file")<br/>}</span></pre><p id="305d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lh li lj lk b">Wrap</code>在这里做了两件事:首先，它创建了一个错误，将stacktrace设置为您调用<code class="du lh li lj lk b">Wrap</code>的位置。当我们将这个错误发送给Sentry时，它将包含一个stacktrace，帮助我们进行调试。</p><p id="370c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其次，它用我们的上下文提示作为错误消息的前缀。完整的消息包装后可能是:</p><pre class="jf jg jh ji fd ll lk lm ln aw lo bi"><span id="b4c4" class="lp kf hi lk b fi lq lr l ls lt">opening configuration file: open /etc/config.json: no such file or directory</span></pre><p id="c3c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过始终如一地包装我们的错误，我们有助于在尽可能深的框架中生成stacktraces，帮助Sentry异常给出尽可能多的关于这个错误是如何发生的上下文。</p><h1 id="0a89" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">包装的危险</h1><p id="e7ac" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">你可能认为这就是全部:可悲的是，还有更多。</p><p id="ef1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然包装错误确保了任何到达Sentry的错误都有一个堆栈跟踪，但我们的一些错误在最终到达Sentry时看起来非常奇怪。</p><p id="c367" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以这段代码为例:</p><pre class="jf jg jh ji fd ll lk lm ln aw lo bi"><span id="f609" class="lp kf hi lk b fi lq lr l ls lt">package main</span><span id="aaea" class="lp kf hi lk b fi lu lr l ls lt">import (<br/>	"time"</span><span id="d6d0" class="lp kf hi lk b fi lu lr l ls lt">	"github.com/getsentry/sentry-go"<br/>	"github.com/pkg/errors"<br/>)</span><span id="1e31" class="lp kf hi lk b fi lu lr l ls lt">func main() {<br/>	sentry.CaptureException(one())<br/>}</span><span id="0967" class="lp kf hi lk b fi lu lr l ls lt">func one() error {<br/>	return errors.Wrap(two(), "trying one")<br/>}</span><span id="17e3" class="lp kf hi lk b fi lu lr l ls lt">func two() error {<br/>	return errors.Wrap(three(), "trying three")<br/>}</span><span id="8b47" class="lp kf hi lk b fi lu lr l ls lt">func three() error {<br/>	return errors.New("it ded")<br/>}</span></pre><p id="83ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然是人为设计的，但您的大多数应用程序代码最终都是这样的，其中一个源错误被包装了几次。</p><p id="d2dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这让Sentry很难过，因为不是得到一个stacktrace，而是每次包装一个错误都会得到一个stack trace:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lv"><img src="../Images/88dfe6da832b5aef4dc2168565bf11bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*8YmzYRSrV9rKGjws.png"/></div></figure><p id="a270" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这并不理想:每个stacktrace只是另一个stack trace的子集，因为它们是在删除单个帧的情况下一次拍摄一个。更大的调用堆栈可能会变得更糟，从而更难从报告中获得价值。</p><p id="298b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更糟糕的是，有时错误会超过Sentry的大小限制，并在您看到它之前被丢弃。</p><p id="f4eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，这个需要修理。</p><h1 id="934f" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">我们自己的pkg/错误</h1><p id="9acb" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">在这一点上，很明显，如果我们希望我们的工具能够很好地相互协作，我们需要控制我们是如何产生错误的。</p><p id="74d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，第一步:我们创建了自己的pkg/errors，并应用了禁止任何<code class="du lh li lj lk b">errors</code>或<code class="du lh li lj lk b">github.com/pkg/errors</code>导入的林挺规则，以确保一致性。</p><p id="bfe5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的包导出了几个关键的pkg/errors函数，因为我们没有理由改变它们的行为方式:</p><pre class="jf jg jh ji fd ll lk lm ln aw lo bi"><span id="e676" class="lp kf hi lk b fi lq lr l ls lt">package errors</span><span id="6400" class="lp kf hi lk b fi lu lr l ls lt">import (<br/>	"github.com/pkg/errors"<br/>)</span><span id="3535" class="lp kf hi lk b fi lu lr l ls lt">// Export a number of functions or variables from pkg/errors.<br/>// We want people to be able to use them, if only via the<br/>// entrypoints we've vetted in this file.<br/>var (<br/>	As     = errors.As<br/>	Is     = errors.Is<br/>	Cause  = errors.Cause<br/>	Unwrap = errors.Unwrap<br/>)</span></pre><p id="b92d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，我们想要改变的是<code class="du lh li lj lk b">Wrap</code>的行为方式。原来的每次调用都会添加一个stacktrace，而我们的应该只添加一个stacktrace，如果错误还没有我们的祖先的踪迹的话。</p><p id="891f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">术语祖先可能需要一些解释，所以让我们回到我们以前的例子。让我们对在1和3的调用点包装每个错误时创建的stacktraces进行注释:</p><pre class="jf jg jh ji fd ll lk lm ln aw lo bi"><span id="1769" class="lp kf hi lk b fi lq lr l ls lt">// main<br/>// one<br/>func one() error {<br/>	return errors.Wrap(two(), "trying one")<br/>}</span><span id="6b28" class="lp kf hi lk b fi lu lr l ls lt">// main<br/>// one<br/>// two<br/>// three<br/>func three() error {<br/>	return errors.New("it ded")<br/>}</span></pre><p id="6983" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们在<code class="du lh li lj lk b">one</code>中包装错误时，它已经有了一个从我们在<code class="du lh li lj lk b">three</code>中包装它时附加的stacktrace。我们的<code class="du lh li lj lk b">Wrap</code>功能将:</p><ul class=""><li id="0ba7" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">在包装点评估当前堆栈跟踪(主，一)</li><li id="1938" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">查看现有stacktrace的原始错误(我们将找到一个，它将是main、one、two、three)</li><li id="e442" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">如果我们当前的stacktrace前缀与现有的stacktrace匹配，我们知道我们是祖先，可以避免生成新的跟踪</li></ul><p id="4126" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将我们的示例代码切换为使用去重复<code class="du lh li lj lk b">Wrap</code>意味着我们将只生成一个跟踪，并且它将是最全面的(也就是最深入的)。</p><p id="ed68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是《哨兵》中的场景:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lv"><img src="../Images/bc545d895c3d443985dc4b0c511f5d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*df8GrCtOxc4UpIp5.png"/></div></figure><p id="6964" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">去杜平可以很好地工作，因为前缀匹配堆栈跟踪意味着:</p><ul class=""><li id="b06b" class="jq jr hi ih b ii ij im in iq js iu jt iy ju jc jv jw jx jy bi translated">只有直接祖先堆栈跟踪被消除重复</li><li id="27e0" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">如果您包装来自其他go routine的错误，您将保留单独的stacktraces，因为go routine从一个空堆栈开始</li><li id="e582" class="jq jr hi ih b ii jz im ka iq kb iu kc iy kd jc jv jw jx jy bi translated">沿着通道传递的错误也无法进行前缀匹配，从而保留了单个堆栈跟踪</li></ul><p id="1388" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这很难实现，所以如果你想自己使用，我们已经上传了一份副本到这个要点。</p><h1 id="e4d4" class="ke kf hi bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">这是一个总结！</h1><p id="29c8" class="pw-post-body-paragraph if ig hi ih b ii lc ik il im ld io ip iq le is it iu lf iw ix iy lg ja jb jc hb bi translated">有时候，围棋是一门复杂的语言。作为一名Rails工作背景的人，我在构建web应用程序时认为理所当然的许多东西要么不存在，要么没有那么好，而且很难从更广泛的社区中找到一致的答案。</p><p id="75e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">异常/错误报告就是一个例子。作为一个团队，我们惊讶于在我们的应用程序中配置好错误报告是多么困难，特别是当它在其他语言中可以正常工作的时候。</p><p id="fe25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢天谢地，我们已经找到了一些变通办法，让我们更接近我们错过的东西。这是一个循序渐进的过程，寻找并移除笨拙的活板门，就像这篇文章一样，让语言与我们熟悉的工具一起玩。</p><p id="b7c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此后，我们扩展了我们的pkg/errors，以支持错误紧急性和一般元数据，我们将在另一篇文章中保存这些内容。对于那些面临类似问题的人来说，这应该是一个良好的开端，并避免其他团队遇到同样的障碍！</p></div></div>    
</body>
</html>