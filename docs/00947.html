<html>
<head>
<title>Encoding awkward types with minimal boilerplate using `withUnsafeBytes`</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用“withUnsafeBytes”用最少的样板文件对笨拙的类型进行编码</h1>
<blockquote>原文：<a href="https://medium.com/codex/encoding-awkward-types-with-minimal-boilerplate-using-withunsafebytes-4032dd861d9f?source=collection_archive---------19-----------------------#2021-03-26">https://medium.com/codex/encoding-awkward-types-with-minimal-boilerplate-using-withunsafebytes-4032dd861d9f?source=collection_archive---------19-----------------------#2021-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/58c6d55845ae44347955b553f656a4bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uuhsaEPY4zSfd9Uvmr2Lrg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来自<a class="ae iu" href="https://unsplash.com/@flowforfrank" rel="noopener ugc nofollow" target="_blank">费伦茨·阿尔马西</a></figcaption></figure><h1 id="3c76" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">历史</h1><p id="d0eb" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">多年来，编码和解码Swift类型到<code class="du kr ks kt ku b">JSON</code>的首选方式一直是<code class="du kr ks kt ku b">Codable</code>协议。</p><p id="5568" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">这提供了一种比它的前身<code class="du kr ks kt ku b">JSONSerialization</code>更安全的处理json的方式，后者产生了<code class="du kr ks kt ku b">[String: Any]</code>字典。相反的，<code class="du kr ks kt ku b">Codable</code>提前处理转换，处理所有的类型转换，如果对象不能成功转换则失败。</p><p id="390a" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated"><code class="du kr ks kt ku b">Codable</code>的另一个优点是，如果许多对象只包含其他<code class="du kr ks kt ku b">Codable</code>或简单类型，那么它们的一致性可以被合成。</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">综合可编码一致性</figcaption></figure><h1 id="d68a" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">问题是</h1><p id="9e84" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">一个常见的不能合成一致性的地方是使用带有关联值的枚举。编译器会告诉我们类型不符合<code class="du kr ks kt ku b">Decodable</code>或者<code class="du kr ks kt ku b">Encodable</code>。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/9c5671ce3d645682a55084b74c5e5ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vwcejpRWcCspDIU_V1Mv7w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">不可合成的可编码一致性</figcaption></figure><p id="40ba" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">有许多方法可以解决这个问题，最常见的是使用<code class="du kr ks kt ku b">Decodable</code>或<code class="du kr ks kt ku b">Encodable</code>协议的定制实现。一个实现可能看起来像这样:</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="1a17" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">尽管这增加了大量的样板代码，但它也是不可重用的。如果我们有另一个不同格式的枚举，我们将不得不全部重写。</p><p id="edd9" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated"><a class="ae iu" href="https://forums.swift.org/t/codable-synthesis-for-enums-with-associated-values/41493" rel="noopener ugc nofollow" target="_blank">提议</a>将<code class="du kr ks kt ku b">Codable</code>合成添加到具有相关值的枚举中，但截至目前，Swift语言中尚未添加任何内容。</p><h1 id="b2c5" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">解决方案:<code class="du kr ks kt ku b">withUnsafeBytes</code>来救援！</h1><p id="f05d" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">解决不同类型的可重用一致性问题的一个简单解决方案是使用<code class="du kr ks kt ku b">withUnsafeBytes</code>。这允许我们访问Swift对象的底层内存。然后，我们可以直接使用底层内存，或者将其作为更大的JSON对象的一部分。下面是一个简单(且可重用)的协议，它为我们完成了编码:</p><figure class="la lb lc ld fd ij"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="929d" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">应该注意的是，这并不是一种可靠的序列化数据的方法，只是一种非常简单的方法。理想情况下，这些数据不应写入磁盘或在设备之间传输，因为Swift版本之间或不同设备之间的数据格式可能会发生变化。话虽如此，具有ABI稳定性的新版Swift可能会在一定程度上缓解这种担忧。</p><p id="db1e" class="pw-post-body-paragraph jt ju hi jv b jw kv jy jz ka kw kc kd ke kx kg kh ki ky kk kl km kz ko kp kq hb bi translated">我将使用这种方法在我的单元测试和我的应用程序之间传输数据，以便在不同的启动条件下进行测试。我认为这相对安全，因为设备类型和Swift版本总是匹配的。</p></div></div>    
</body>
</html>