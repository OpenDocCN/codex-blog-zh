# 编码的一个简单教训:测试第一！

> 原文：<https://medium.com/codex/a-simple-lesson-in-coding-testing-first-91b3da7b9925?source=collection_archive---------22----------------------->

![](img/7eed5d132739e58c989761e0727c3c38.png)

在阿肯色州本顿维尔的 21C 酒店展出的亚历山大·阿雷契亚的 ***橘子树、*** *。(作者照片，2021)。*

这是四篇系列文章中的第三篇，讲述了一个简单的想法是如何演变成学生第一堂数据结构课的课程计划的。第一篇文章描述了一个简单的例子，我们将在这里继续使用:一个判断字符串是否是回文的方法。[第二篇](/@leoirakliotis/a-simple-lesson-in-coding-revisited-fbc9add1e599)提炼了方法，结果如下图。

代码看起来不错，但正如我们将要发现的，它仍然是不完整的。它适用于大小写混合的参数，因为`.toLowerCase`首先强制所有内容小写。代码删除了带有`.replace`的空格，将类似“赛车”的参数识别为回文。它甚至删除了标点符号和带有`.replaceAll`的数字，以处理类似“一个人，一个计划，一条运河:巴拿马”的回文。(是的，我们可以将`replace`和`replaceAll`合并成一个`replaceAll`。出于说明的目的，我将它们分开)。

如果我们编写一些简单的测试，我们甚至会对代码的准确性印象深刻:

对托管在名为**回文的类中的方法 **isPalindrome()** 进行简单测试。**

所以，这是可行的，对吧？看方法告诉我们这些字符串是回文的时候我们是什么感受:`"5A"`、`"..."`、`"101"`、`"123"`、`"..-"`、`""`(空字符串)。

字符串`"..."`和`"101"`可以被认为是回文。它们是向前和向后的相同字符序列。但这不是我们的方法如何确定它们是回文。我们方法的第 4 行从这些字符串中删除了所有非字母字符。`"..."`和`"101"`都被还原为空字符串。空字符串的长度为 0。第 6 行的 while 循环不会运行(因为条件`pos < s.length`为`false`)。并且该方法返回被设置为`true`的`palindrome`的初始值。

基本上，该方法为任何包含非字母字符的字符串返回`true`，例如`"@123.456"`、`"3.14"`等。而像`"555A"`这样只有一个字母的字符串，经过 4 号线的`replaceAll()`和`toLowerCase()`方法清洗后，会还原为`"a"`。我们的方法会将`"555A"`识别为一个回文。

最后，想象下面的代码:

```
String s = null;
isPalindrome(s);
```

这将导致空指针异常，这是我们希望避免的运行时错误。

早先的繁荣现在正在消退。我们的方法没有我们想象的那么酷那么牛逼。它可以处理像“一个人，一个计划，一条运河:巴拿马”这样的回文，但也会产生错误的结果。那是因为我赶着写代码，感觉*过-* 对实现很有信心。我没有花时间去消化这个方法的需求，也没有计划如何测试它。让我们现在解决这个问题。

首先，让我们描述一下我们希望方法做什么:return true 是一个非空字符串是一个回文。回文只包含字母。空格、字母大小写和标点符号不影响回文属性。像`“Race car!”`这样的字符串是回文。像`“3.14PIIP41.3”`这样的字符串，都不是。

接下来，让我们考虑一些更多的测试。除了前面显示的`assertTrue`调用，我们还希望我们的方法通过下面的测试。

为了满足这些期望，我们必须走到谈判桌前。我们应该早点去那里，但是我们必须先吸取教训。我们需要的伪代码如下所示，它包括我们到目前为止讨论的所有三个主要条件:检查空值、检查有效内容和检查空字符串。

```
boolean isPalindrome(String s)
  if s is not null
    **if s has valid content
**      remove spaces and punctuation from s
      if s not empty after removal of spaces and punctuation
        determine palindromic property
```

这花了我们一段时间，但我们终于在讨论我们想要评估什么样的字符串。我们只需要字母、空格和标点符号。因此，我们首先需要一个 helper 方法来确定我们的字符串是否是有效的输入，即只包含允许的字符。

编写一个助手方法似乎很容易。一个字符一个字符地取一个字符串，当我们发现一个不允许的值时，就声明它不适合我们的回文方法。但是可能有一个陷阱。这样的帮助器方法可能会取消像`"555A"`这样的字符串，因为不允许使用数字。像`".!!."`这样的字符串将被验证，因为它们包含标点符号。我们同意吗？我们需要至少有一封信吗？假设我们有。字符串必须至少有一个字母，并且不能包含除字母、空格和标点符号之外的任何内容。下面的方法`isValid`，似乎符合这个规范。

上面的方法返回两个变量的 AND:`hasValidCharacters`和`atLeastOneLetterPresent`。当字符串中的每个字符都有效时，即一个字母*或*一个标点符号*或*一个空格，第一个变量为真。当至少有一个字符串字符是字母时，第二个变量为真。第 11 行评估有效字符。该行检查字符是否在 *a* 和 *z* 之间，或者该字符是否出现在允许的字符序列中。在第 12 行评估至少一个字母的存在。一旦条件`'a' <= c && c <= 'z'`评估为真，无论接下来发生什么，它都将变量`atLeastOneLetterPresent`设置为真。

在`isValid`的帮助下，我们现在可以完成回文方法了，如下所示。

*接下来:* [*一堂简单的编码课:操场*](/@leoirakliotis/3ef0326b6506) *。*