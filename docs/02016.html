<html>
<head>
<title>How to Write an Ansible Module — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写一个可解析的模块—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-write-an-ansible-module-part-1-3d93bfd4dd7e?source=collection_archive---------2-----------------------#2021-06-23">https://medium.com/codex/how-to-write-an-ansible-module-part-1-3d93bfd4dd7e?source=collection_archive---------2-----------------------#2021-06-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/22aab307ea16f62ae2e38d26721e8cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-BnJQQKjcJP_gaVilQ2fPw.png"/></div></div></figure><p id="bee1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你肯定还记得你第一次运行一个可行的剧本:几行代码组合成一堆<code class="du jo jp jq jr b">tasks</code>,发挥了很大的作用。出于好奇，你肯定会问自己，那个叫做<code class="du jo jp jq jr b">module</code>的东西背后隐藏着什么。几个键/值对怎么可能抽象出通常几十行的bash代码？嗯，我们知道在软件工程中没有魔法这种东西，对于Ansible和Ansible模块也是如此。</p><p id="60da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">来自Ansible <a class="ae js" href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html" rel="noopener ugc nofollow" target="_blank">文档</a>的一个<code class="du jo jp jq jr b">module</code>是:</p><p id="af74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">"<em class="jt">ansi ble代表您在本地或远程运行的可重用的独立脚本。模块与您的本地机器、API或远程系统交互，以执行特定的任务…模块提供定义的接口，接受参数，并在退出前通过将JSON字符串打印到stdout将信息返回给Ansible。</em></p><p id="8fd5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们感兴趣的部分(仍然来自Ansible docs):</p><p id="72e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jt">如果您需要集合中数以千计的Ansible模块中没有的功能，您可以轻松地编写自己的定制模块。当你编写一个本地使用的模块时，你可以选择任何编程语言并遵循你自己的规则。</em></p><p id="5477" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简而言之，模块是一个抽象层，它隐藏了一段与机器交互的代码。如果您不喜欢Ansible repo上已经提供的内容，或者您需要一些不同的内容，您仍然可以轻松地编写自己的模块。</p><p id="e50b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑到这一点，在本文和后续文章中，我们将看到如何应用NTC最佳实践编写一个Ansible模块。在本文的第一部分，我们将介绍编写名为<code class="du jo jp jq jr b">ntc_snmp</code>的Cisco IOS和NXOS SNMP模块示例所需的所有步骤，我们将在其中配置SNMP社区字符串、联系人和位置。作为一个要求，该模块应该是<a class="ae js" href="https://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation" rel="noopener ugc nofollow" target="_blank">幂等的</a>，并且如果传入的操作系统不是IOS或NXOS，它会优雅地出错。</p><p id="065f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可完成的任务示例:</p><pre class="ju jv jw jx fd jy jr jz ka aw kb bi"><span id="c70a" class="kc kd hi jr b fi ke kf l kg kh">ntc_snmp:<br/>  os: ""<br/>  provider:<br/>    username: "ntc_user"<br/>    password: "ntc_password"<br/>    hostname: ""<br/>  community_strings:<br/>    - type: "ro"<br/>      string: "public"<br/>  contact: "info@networktocode.com"<br/>  location: "New_York"<br/>  replace: true</span></pre><p id="f543" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们卷起袖子投入其中吧！</p><h1 id="3eef" class="ki kd hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">模块参数和代码入口点</h1><p id="f713" class="pw-post-body-paragraph iq ir hi is b it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn hb bi translated">首先，我们需要找到一种方法来传递我们的模块参数(例如，<code class="du jo jp jq jr b">contact</code>、<code class="du jo jp jq jr b">location</code>等)。)到我们的代码。我们可以用<code class="du jo jp jq jr b">AnsibleModule</code> import很容易地做到这一点，它给了我们一个漂亮的字典，里面有我们起草模块所需的所有信息。</p><p id="2633" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看<code class="du jo jp jq jr b">import</code>部分和模块参数:</p><pre class="ju jv jw jx fd jy jr jz ka aw kb bi"><span id="6d94" class="kc kd hi jr b fi ke kf l kg kh">#!/usr/bin/python3<br/>try:<br/>    from netmiko import ConnectHandler<br/>    HAS_NETMIKO = True<br/>except ImportError:<br/>    HAS_NETMIKO = False</span><span id="0134" class="kc kd hi jr b fi lk kf l kg kh">from ansible.module_utils.basic import AnsibleModule<br/>from ansible.module_utils.basic import missing_required_lib<br/></span><span id="4651" class="kc kd hi jr b fi lk kf l kg kh">def main():</span><span id="9d8b" class="kc kd hi jr b fi lk kf l kg kh">    if not HAS_NETMIKO:<br/>        module.fail_json(msg=missing_required_lib("netmiko"))</span><span id="65f4" class="kc kd hi jr b fi lk kf l kg kh">    provider_options = dict(<br/>        username=dict(required=True),<br/>        password=dict(required=True),<br/>        hostname=dict(required=True),<br/>    )</span><span id="5edd" class="kc kd hi jr b fi lk kf l kg kh">    community_options = dict(<br/>        type=dict(required=True, choices=['ro','rw']),<br/>        string=dict(required=True, no_log=True),<br/>    )<br/>    <br/>    argument_spec = dict(<br/>        os=dict(type='list', required=True, choices=['ios','nxos']),<br/>        provider=dict(type='dict', required=True, options=provider_options),<br/>        community_strings=dict(type='list', elements='dict', subrequired=True, options=community_options),<br/>        contact=dict(required=False),<br/>        location=dict(required=False),<br/>        replace=dict(type='bool', default=False)<br/>      )</span><span id="0198" class="kc kd hi jr b fi lk kf l kg kh">    module = AnsibleModule(<br/>        argument_spec=argument_spec,<br/>        supports_check_mode=True,<br/>        required_one_of=[['community_strings', 'contact', 'location']],<br/>        )</span></pre><p id="b3ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们暂停一下，分析一下上面的代码。</p><p id="04d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，我们使用Netmiko来处理SSH会话，所以首先我们要检查是否安装了库。我们用一个<code class="du jo jp jq jr b">try</code>和<code class="du jo jp jq jr b">except</code>来创建一个布尔常量，稍后我们将使用它来验证是否安装了库。我们还进口了一些实用工具，如<code class="du jo jp jq jr b">AnsibleModule</code>和<code class="du jo jp jq jr b">missing_required_lib</code>，这将使我们以后的生活变得更加轻松。在这个例子中，我们只利用了几个<code class="du jo jp jq jr b">module_utils</code>进口，但我鼓励你在这里探索<a class="ae js" href="https://docs.ansible.com/ansible/latest/dev_guide/developing_module_utilities.html#standard-module-utilities" rel="noopener ugc nofollow" target="_blank">看看有什么可用的，因为有一些可以为你做很多繁重的工作。</a></p><p id="5e83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们定义我们的模块入口点<code class="du jo jp jq jr b">main()</code>，我们创建一个名为<code class="du jo jp jq jr b">argument_spec</code>的字典，包含我们来自模块参数的键/值对，其中value是一个字典，包含一些定义接受的模块参数类型的kwargs。在我们的例子中，对于<code class="du jo jp jq jr b">os</code>、<code class="du jo jp jq jr b">provider</code>和<code class="du jo jp jq jr b">community_strings</code>，我们有<code class="du jo jp jq jr b">required=True</code>，这意味着这些是必须传递给我们的模块的参数。如果参数数据类型不同于字符串，您将需要指定，正如我们在其中一些类型中所做的那样:<code class="du jo jp jq jr b">type='list'</code>、<code class="du jo jp jq jr b">type='bool'</code>或<code class="du jo jp jq jr b">type='dict'</code>(注意，对于<code class="du jo jp jq jr b">list</code>，我们还指定了<code class="du jo jp jq jr b">elements</code>类型)。您也可以像我们在<code class="du jo jp jq jr b">os</code>(即<code class="du jo jp jq jr b">choices=["ios", "nxos"]</code>)中那样缩小到一组可能的选择，并像在<code class="du jo jp jq jr b">replace</code>(即<code class="du jo jp jq jr b">default=False</code>)中那样设置一个默认值。</p><p id="25b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简而言之,<code class="du jo jp jq jr b">argument_spec</code>的作用类似于模式验证，确保将正确的变量作为参数传递给模块。在这里，你可以探索所有可用的选项。</p><p id="fd7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查看Ansible <a class="ae js" href="https://docs.ansible.com/ansible/latest/reference_appendices/module_utils.html" rel="noopener ugc nofollow" target="_blank">文档</a>我们可以看到<code class="du jo jp jq jr b">AnsibleModule</code>采用了不同类型的kwargs。目前，我们传递包含模块参数的<code class="du jo jp jq jr b">argument_spec</code>;我们设置为<code class="du jo jp jq jr b">supports_check_mode=True</code>，所以我们的模块也可以在干模式下运行(所以现在你知道<code class="du jo jp jq jr b">ansible-playbook foo.yml --check</code>后面是什么了)；我们用<code class="du jo jp jq jr b">required_one_of</code>做了一种断言，在我们的模块中至少指定了<code class="du jo jp jq jr b">community_strings</code>、<code class="du jo jp jq jr b">contact</code>或<code class="du jo jp jq jr b">location</code>。简而言之，我们需要在我们的设备上推动这三个选项中的至少一个——否则，这个模块的目的是什么？。我鼓励你也研究一下<code class="du jo jp jq jr b">mutually_exclusive</code>、<code class="du jo jp jq jr b">required_together</code>，它们是对你的模块实施特定模式的一种强有力的方法。查看<a class="ae js" href="https://mobygeek.net/blog/2016/02/16/ansible-module-development-parameters/" rel="noopener ugc nofollow" target="_blank">和</a>中的一些例子。</p><p id="2ee4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们继续编码之前，我们需要了解幂等工作流是如何在Ansible上构建的。每当我们运行一个模块时，Ansible首先查看我们想要更改的设备或服务器配置。如果实际配置不同于我们的预期配置，则应用更改；否则，跳过该任务。</p><p id="fa23" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于我们的示例，现在让我们假设我们想要更改snmp位置。模块做的第一件事是从模块参数构建预期的配置。然后，它将运行<code class="du jo jp jq jr b">show runninng-config</code>命令，在配置中找到snmp位置行，并将我们拥有的配置行(实际运行配置)与我们想要的(预期的)进行比较。不是100%清楚？不要担心，当我们构建代码时，它会更有意义。</p><p id="d473" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们为cisco IOS创建一个名为<code class="du jo jp jq jr b">ios_map_config_to_obj</code>的功能。我们将传递一个SSH会话(在单独的函数中创建)给它。然后，我们将ssh到我们的设备中，获取SNMP配置行，进行一些解析(如果需要)，并将配置映射到一个字典中。代码是不言自明的，所以，让我们来看看它:</p><pre class="ju jv jw jx fd jy jr jz ka aw kb bi"><span id="44fe" class="kc kd hi jr b fi ke kf l kg kh">def ios_map_config_to_obj(ssh_session):</span><span id="72b9" class="kc kd hi jr b fi lk kf l kg kh">    # initiate defualt "have" dict()<br/>    have = {<br/>        'location': None,<br/>        'contact': None,<br/>        'community_strings': None,<br/>    }<br/>    <br/>    # send show command for "location" and map into dictionary<br/>    location_output = ssh_session.send_command("show snmp location")<br/>    if location_output:<br/>        have['location'] = location_output<br/>    <br/>    # send show command for "contact" and map into dictionary<br/>    contact_output = ssh_session.send_command("show snmp contact")<br/>    if contact_output:<br/>        have['contact'] = contact_output</span><span id="f9c5" class="kc kd hi jr b fi lk kf l kg kh">    # initiate "community" dict() as we might have more than one community <br/>    community_dict = dict()</span><span id="49d0" class="kc kd hi jr b fi lk kf l kg kh">    # send show command for "community"<br/>    community_output = ssh_session.send_command("show running-config | include snmp-server community")</span><span id="1064" class="kc kd hi jr b fi lk kf l kg kh">    # parse "community" output and map into "community_output" dict()<br/>    if community_output:<br/>        for comm in community_output.splitlines():<br/>            comm_string = comm.split()[-2]<br/>            comm_type = comm.split()[-1]</span><span id="38c5" class="kc kd hi jr b fi lk kf l kg kh">            community_dict[comm_string] = comm_type</span><span id="1c0c" class="kc kd hi jr b fi lk kf l kg kh">        # update "have" dict() with "community_output" dict()<br/>        have['community_strings'] = community_dict</span><span id="d70a" class="kc kd hi jr b fi lk kf l kg kh">    # "have" dict() example<br/>    #<br/>    #  have = {<br/>    #   "community_strings": {<br/>    #       "ntc-private": "RW",<br/>    #       "ntc-public": "RO",<br/>    #       "public": "RW",<br/>    #       "testro": "RW",<br/>    #       "testwr": "RW"<br/>    #     },<br/>    #   "contact": "Mike",<br/>    #   "location": "VG"<br/>    # }<br/>    return have</span></pre><p id="8b7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，我们运行了一系列show命令，并将它们映射到一个字典中。这将更容易比较实际配置和预期配置，并应用幂等原理。</p><p id="8fc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们现在必须将我们的模块参数映射到实际的IOS命令，这些命令稍后将被发送到设备。让我们定义一个名为<code class="du jo jp jq jr b">ios_map_obj_to_com</code>的函数，并传递<code class="du jo jp jq jr b">AnsibleModule</code>(它保存我们的模块参数)以及我们从<code class="du jo jp jq jr b">ios_map_config_to_obj</code>返回的字典。</p><p id="0f8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了简洁起见，我们将只考虑<code class="du jo jp jq jr b">contact</code>和<code class="du jo jp jq jr b">location</code>配置行。在注释行的帮助下，代码应该是不言自明的。</p><pre class="ju jv jw jx fd jy jr jz ka aw kb bi"><span id="2ff5" class="kc kd hi jr b fi ke kf l kg kh">def ios_map_obj_to_commands(module, have):<br/>    # module args unpacking<br/>    want_contact = module.params.get('contact')<br/>    want_location = module.params.get('location')<br/>    want_replace = module.params.get('replace')</span><span id="145f" class="kc kd hi jr b fi lk kf l kg kh">    # have dict() unpacking<br/>    have_contact = have.get('contact')<br/>    have_location = have.get('location')</span><span id="d68b" class="kc kd hi jr b fi lk kf l kg kh">    commands = list()</span><span id="5c95" class="kc kd hi jr b fi lk kf l kg kh">    # from module args, if we don't want to replace running-config<br/>    if not replace:<br/>        # if "contact" in module arg is different from "contact" in running-config,<br/>        # append new config line to command list<br/>        if want_contact != have_contact:<br/>            commands.append('snmp-server contact {0}'.format(want_contact))</span><span id="a288" class="kc kd hi jr b fi lk kf l kg kh">        # if "location" in module arg is different from "location" in running-config,<br/>        # append new config line to command list<br/>        if want_location != have_location:<br/>            commands.append('snmp-server location {0}'.format(want_location))</span><span id="229a" class="kc kd hi jr b fi lk kf l kg kh">        # return list of commands to push to device<br/>        return commands</span><span id="cd01" class="kc kd hi jr b fi lk kf l kg kh">    # from module args: if we want to replace running-config<br/>    if replace:<br/>        # if we do not have "contact" in running-config and we have "contact" in module args<br/>        if want_contact is None and have_contact:<br/>            commands.append('no snmp-server contact {0}'.format(have_contact))<br/>        # if we have "contact" in running-config and it's different from "contact" in module args<br/>        if (want_contact is not None) and (want_contact != have_contact):<br/>            commands.append('snmp-server contact {0}'.format(want_contact))<br/>        <br/>        # same above logic applies to "location"<br/>        if want_location is None and have_location: <br/>            commands.append('no snmp-server location {0}'.format(have_location))<br/>        if (want_location is not None) and (want_location != have_location):<br/>            commands.append('snmp-server location {0}'.format(want_location))<br/>        <br/>        # return list of commands to push to device<br/>        return commands</span></pre><p id="5968" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们解包<code class="du jo jp jq jr b">want</code>参数(模块参数)以及<code class="du jo jp jq jr b">have</code>参数。基于<code class="du jo jp jq jr b">replace</code>模块参数，我们触发不同的逻辑，并将我们的<code class="du jo jp jq jr b">have</code>与我们的<code class="du jo jp jq jr b">want</code>进行比较。在此基础上，我们将一个配置行添加到一个列表中，这个列表稍后将被推送到设备上——就这么简单。</p><p id="4ced" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们推送我们的配置并以json格式生成著名的Ansible <code class="du jo jp jq jr b">result</code>。</p><p id="0c40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的<code class="du jo jp jq jr b">mian()</code>功能下，我们添加:</p><pre class="ju jv jw jx fd jy jr jz ka aw kb bi"><span id="85cf" class="kc kd hi jr b fi ke kf l kg kh"># This is required in order to call the right function based on OS<br/>    want_call_dict = {<br/>        'ios': ios_map_obj_to_commands,<br/>        'nxos': nxos_map_obj_to_commands,<br/>    }</span><span id="a9ce" class="kc kd hi jr b fi lk kf l kg kh">    # Same here<br/>    have_call_dict = {<br/>        'ios': ios_map_config_to_obj,<br/>        'nxos': nxos_map_config_to_obj,<br/>    }</span><span id="25a1" class="kc kd hi jr b fi lk kf l kg kh">    # result dict() initialization with default changed=False<br/>    result = dict(changed=False)</span><span id="40dd" class="kc kd hi jr b fi lk kf l kg kh">    # call the right have function based on OS. Pass ssh_session as arg<br/>    have = have_call_dict[module.params.get('os')[0]](ssh_session(module))</span><span id="edb8" class="kc kd hi jr b fi lk kf l kg kh">    # call the right want function based on OS. Pass have result and module args<br/>    want = want_call_dict[module.params.get('os')[0]](module, have)</span><span id="6741" class="kc kd hi jr b fi lk kf l kg kh">    # if we have want config...<br/>    if want:<br/>        # ...and not check_mode...<br/>        if not module.check_mode:<br/>            # ...then push cofig to device...<br/>            ssh_session(module).send_config_set(want)<br/>            # ...and update result dict()<br/>            result.update(<br/>                changed=True,<br/>                have=have,<br/>                cmds=want,<br/>            )<br/>            <br/>    # return result dict() in json format.<br/>    if result:<br/>        module.exit_json(**result)<br/></span><span id="2c90" class="kc kd hi jr b fi lk kf l kg kh">if __name__ == "__main__":<br/>    main()</span></pre><p id="1ce0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是这篇文章的第一部分。在第二部分中，我们将看到如何编写<code class="du jo jp jq jr b">DOCUMENTATION</code>和<code class="du jo jp jq jr b">EXAMPLES</code>，以及如何为我们的模块构建和运行一些测试。</p><p id="4931" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">费德里科</p></div></div>    
</body>
</html>