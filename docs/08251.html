<html>
<head>
<title>What really are Channels in Kotlin?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林的频道到底是什么？</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-really-are-channels-in-kotlin-3dccce4c5351?source=collection_archive---------2-----------------------#2022-07-27">https://medium.com/codex/what-really-are-channels-in-kotlin-3dccce4c5351?source=collection_archive---------2-----------------------#2022-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f63c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当许多其他编程语言完全依赖线程的概念时，Kotlin利用<a class="ae jd" href="https://kotlinlang.org/docs/coroutines-guide.html" rel="noopener ugc nofollow" target="_blank">协程</a>提供了一套直观、不易出错且高效的工具来执行异步工作。毫不奇怪，Kotlin应用程序经常使用许多需要相互通信的协程，通道为此提供了一个优雅的解决方案。本文通过深入有用的例子向您介绍了通道。我们开始吧！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/ead608551627eb03ce9beff1e5088f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JT9v_PZ063jLYUmv9tWuiQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片由<a class="ae jd" href="https://pixabay.com/photos/craftsman-loom-craftsmanship-hands-1839920/" rel="noopener ugc nofollow" target="_blank"> pixabay </a>提供</figcaption></figure><h1 id="2e75" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">先决条件</h1><p id="ce75" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">本文假设您理解创建和使用<em class="kx">协程</em>的概念。如果你不知道，我建议你先看一下<a class="ae jd" href="https://kotlinlang.org/docs/coroutines-guide.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="732a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">基本概念</h1><p id="5f43" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">从概念上讲，<em class="kx">通道</em>是通信路径，允许您将一系列值从一个<em class="kx">协程</em>传递到另一个协程。元素按照它们到达的顺序被处理，这是通道和<a class="ae jd" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html" rel="noopener ugc nofollow" target="_blank">阻塞队列</a>的相似之处之一。简而言之，</p><blockquote class="ky kz la"><p id="2df6" class="if ig kx ih b ii ij ik il im in io ip lb ir is it lc iv iw ix ld iz ja jb jc hb bi translated">一个协程，即<strong class="ih hj">生产者</strong>，可以<em class="hi">发送</em>一些数据给一个通道，而另一个协程，即<strong class="ih hj">接收者</strong>，可以<em class="hi">从它那里接收</em>这些数据。虽然一个通道可以有多个接收者，但是通过该通道发送的每个元素只被接收者处理一次。</p></blockquote><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es le"><img src="../Images/7cd97bf9085a09d36b6644138c3c2920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwNGh7hZC12oIDS9LSPZgg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片由<a class="ae jd" rel="noopener" href="/@joaofoltran">作者</a></figcaption></figure><p id="ffef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，通道是使用通用的<code class="du lf lg lh li b">Channel</code>接口实现的，允许它传输任何类型的数据。<code class="du lf lg lh li b">Channel</code>还实现了<code class="du lf lg lh li b">SendChannel</code>和<code class="du lf lg lh li b">ReceiveChannel</code>接口，它们将公开的功能分开以避免错误。例如，只有<em class="kx">发送通道</em>可以发送元素并完全关闭通道，只有<em class="kx">接收通道</em>可以接收元素并检查通道是否为空。</p><p id="d5c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使用这种封装，通道在生产者对象中使用时被转换为<code class="du lf lg lh li b">SendChannel</code>，在接收者对象中使用时被转换为<code class="du lf lg lh li b">ReceiveChannel</code>。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="f250" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在进一步讨论之前，让我们看一个通过通道发送<code class="du lf lg lh li b">Animals</code>的简单例子，让事情变得更具体。在本文的这个例子和其他例子中，为了清楚起见，我们显式地声明了变量，即使我们并不需要这样做。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="8914" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如预期的那样，<code class="du lf lg lh li b">Animals.RABBIT</code>通过通道被发送，被接收，其值被打印在控制台中。</p><h1 id="f70d" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">通道容量</h1><p id="45ee" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在深入了解<em class="kx">频道</em>如何工作之前，了解不同类型的可用频道至关重要。简而言之，</p><blockquote class="ky kz la"><p id="7965" class="if ig kx ih b ii ij ik il im in io ip lb ir is it lc iv iw ix ld iz ja jb jc hb bi translated">在被正确接收之前，信道内部可以存储的元素数量是不同的。这个缓冲区的大小会影响<code class="du lf lg lh li b">send</code>操作的执行，因为我们不能简单地将元素发送到一个已经满了的通道。</p></blockquote><p id="50a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在幕后，我们可以使用4个容量选项来初始化通道。我们将在下面详细探讨它们。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="5c67" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">无限频道</h1><p id="c61a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">无限通道可以无限缓冲发送给它的元素。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ll"><img src="../Images/1b25782e3e0dc3c30b016a766a05fc6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*25SRthcj5jTKb3Uuvvhqdg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片作者<a class="ae jd" rel="noopener" href="/@joaofoltran">作者</a></figcaption></figure><p id="6ebd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于上面的<code class="du lf lg lh li b">Animals</code>例子，这意味着你可以调用任意多的<code class="du lf lg lh li b">Animals</code>中的<code class="du lf lg lh li b">send</code>，通道将存储这些元素，直到你决定开始调用<code class="du lf lg lh li b">receiver.receive()</code>。换句话说，<code class="du lf lg lh li b">send</code>操作永远不会被挂起。</p><blockquote class="ky kz la"><p id="f870" class="if ig kx ih b ii ij ik il im in io ip lb ir is it lc iv iw ix ld iz ja jb jc hb bi translated">请注意，在<code class="du lf lg lh li b">SendChannel</code>接口的定义中，<code class="du lf lg lh li b"><em class="hi">send</em></code>是一个挂起函数，简单来说，这意味着它可以被暂停，稍后再恢复。尽管在无限制的通道中情况并非如此，但在我们将在下面分析的情况中，如果通道不能支持发送更多的元素，那么<code class="du lf lg lh li b">send</code>可能会暂停。</p></blockquote><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="ab11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使无限通道有无限的缓冲区大小，如果没有可用的内存，并且您试图向它发送更多的元素，您最终会得到一个<code class="du lf lg lh li b">OutOfMemoryException</code>。</p><h1 id="d397" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">缓冲通道</h1><p id="f2de" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">缓冲通道最多可以在内部缓冲在通道的构造函数中传递给它的元素数。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lm"><img src="../Images/cc828263a1c2ae332da9e3819b533afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUGjFiiMrlMnhNleVo-7cg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片作者<a class="ae jd" rel="noopener" href="/@joaofoltran">作者</a></figcaption></figure><p id="1e6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于这个缓冲区限制，如果我们在通道已满时<code class="du lf lg lh li b">send</code>一个元素，这个调用将被挂起，直到更多的空间被释放。例如，可以通过调用<code class="du lf lg lh li b">receive</code>来释放缓冲区。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="63bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果这个例子仍然有点抽象，不要担心，因为我们将在本文后面更详细地讨论这个暂停机制。</p><h1 id="81dd" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">会合通道</h1><p id="d9fe" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">集合信道是容量为0的缓冲信道。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lm"><img src="../Images/12a4225f5b266cddcf3b904d6434cd95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hfdN41jLh_UhJaqxGVr6_Q.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片作者<a class="ae jd" rel="noopener" href="/@joaofoltran">作者</a></figcaption></figure><p id="7777" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着<code class="du lf lg lh li b">send</code>操作被暂停，直到相应的<code class="du lf lg lh li b">receive</code>操作被调用。默认情况下，通道是集合通道，这意味着要初始化集合通道，只需调用不带参数的构造函数即可:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="1695" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">合并河道</h1><p id="50e6" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">合并的信道恰好缓冲一个元素，并且如果还没有接收到之前发送的元素，则依次覆盖它们。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lm"><img src="../Images/b8c44f20d99c12d0087885f4d5a31918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lpgd8U-xjMdugRxXTbUU1w.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片作者<a class="ae jd" rel="noopener" href="/@joaofoltran">作者</a></figcaption></figure><p id="94e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，在上面的图像中，如果通道发送了蓝球，并且在它被接收之前，它发送了黄球，黄球覆盖了蓝球，这意味着对<code class="du lf lg lh li b">receive</code>的调用现在获取了黄球。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="0d95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，<code class="du lf lg lh li b">send</code>操作永远不会被挂起，因为对它的后续调用将简单地覆盖未收到的值。</p><h1 id="f0e7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">接受价值观呢？</h1><p id="db4c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们已经讨论了不同的通道是如何发送值的，以及在什么情况下<code class="du lf lg lh li b">send</code>操作会被挂起，现在我们将仔细看看通道是如何接收元素的。</p><p id="b400" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意<code class="du lf lg lh li b">receive</code>也是一个挂起函数，正如在<code class="du lf lg lh li b">ReceiveChannel</code>接口中声明的，这意味着它可以像<code class="du lf lg lh li b">send</code>操作一样被挂起。简而言之，对于任何渠道类型:</p><blockquote class="ky kz la"><p id="d6e5" class="if ig kx ih b ii ij ik il im in io ip lb ir is it lc iv iw ix ld iz ja jb jc hb bi translated">如果通道不为空，调用<code class="du lf lg lh li b">receive</code>检索元素，否则它暂停执行，直到通道中的元素可用。</p></blockquote><p id="6216" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了巩固这些知识，我们来看一些例子。</p><h1 id="f59e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">兔子、大象和树懒</h1><p id="bf7c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们将在本文开头的<code class="du lf lg lh li b">Animals</code>示例的基础上，探索每种通道类型在相同条件下的行为。</p><p id="1636" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">共享代码非常简单，我们初始化一个通道，启动一个发送<code class="du lf lg lh li b">Animals.RABBIT</code>，然后发送<code class="du lf lg lh li b">Animals.ELEPHANT</code>的协程。在另一个协程中，我们发送<code class="du lf lg lh li b">Animals.SLOTH</code>，而在另一个协程中，我们接收所有三个<code class="du lf lg lh li b">Animals</code>。以下部分解释了当<code class="du lf lg lh li b">channel</code>是4种可能的通道类型中的每一种时的输出。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="3572" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">会合。</strong>在这种情况下，通道没有缓冲区，因此任何<code class="du lf lg lh li b">send</code>操作将被暂停，直到相应的<code class="du lf lg lh li b">receive</code>被调用。这正是我们通过下图观察到的。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ln"><img src="../Images/8c6d791227431ebba9a733c119792afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ahSlHJg3s8fVS1-SSkscsA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片作者<a class="ae jd" rel="noopener" href="/@joaofoltran">作者</a></figcaption></figure><ol class=""><li id="6111" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated">来自协程#1的<code class="du lf lg lh li b">producerA</code>发送<code class="du lf lg lh li b">RABBIT</code>，但是被挂起，因为还没有相应的接收者；</li><li id="27f6" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">来自协程#2的<code class="du lf lg lh li b">producerB</code>发送<code class="du lf lg lh li b">SLOTH</code>，但是由于同样的原因被挂起；</li><li id="7af4" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">在执行协程#3时，接收并打印两个暂停值。并且协程#1和#2被释放，以此顺序。但是还没有接收第三个值，所以协程#3也被挂起；</li><li id="1425" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">来自协程#1的<code class="du lf lg lh li b">producerA</code>发送<code class="du lf lg lh li b">ELEPHANT</code>但不挂起，因为已经有来自协程#3的相应<code class="du lf lg lh li b">receiver</code>挂起。事实上，由于通道不再是空的，协程#3现在也是自由的；</li><li id="9ef3" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">协程#1继续完成执行，由于协程#2中不再有操作，它也完成了。最后，协程#3接收到<code class="du lf lg lh li b">ELEPHANT</code>并完成执行。</li></ol><blockquote class="ky kz la"><p id="2f1c" class="if ig kx ih b ii ij ik il im in io ip lb ir is it lc iv iw ix ld iz ja jb jc hb bi translated">注意，这里的“释放”意味着协程不再需要保持挂起，并且一旦当前协程和任何其他预先调度的协程完成执行，将被调度执行。请记住，我们是在单线程上操作的，因此在给定时刻只能执行一个协程。</p></blockquote><p id="9ad6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出显示以下内容:</p><pre class="jf jg jh ji fd mc li md me aw mf bi"><span id="bcf7" class="mg jv hi li b fi mh mi l mj mk">RABBIT<br/>SLOTH<br/>coroutine 1 done<br/>coroutine 2 done<br/>ELEPHANT<br/>coroutine 3 done</span><span id="d726" class="mg jv hi li b fi ml mi l mj mk">Process finished with exit code 0</span></pre><p id="07b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">无限制。</strong>在这种情况下，通道的缓冲区大小不受任何值的限制，因此<code class="du lf lg lh li b">send</code>操作不会暂停。您可以在下图中查看代码是如何执行的。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mm"><img src="../Images/e8c5a134a4537d56a884f9e078ffb206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ED8jtYmc7QmlUd2VGehRHQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片作者<a class="ae jd" rel="noopener" href="/@joaofoltran">作者</a></figcaption></figure><p id="0930" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出显示以下内容:</p><pre class="jf jg jh ji fd mc li md me aw mf bi"><span id="8ee2" class="mg jv hi li b fi mh mi l mj mk">coroutine 1 done<br/>coroutine 2 done<br/>RABBIT<br/>ELEPHANT<br/>SLOTH<br/>coroutine 3 done</span><span id="abd2" class="mg jv hi li b fi ml mi l mj mk">Process finished with exit code 0</span></pre><p id="7f95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在快速说明一下。对于这个例子和下一个例子，我们将抽象出书面的解释，因为图表应该能够清楚地显示所有的步骤。如果你有任何问题，不要犹豫，在文章中留下评论！</p><p id="5633" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">缓冲</strong>(更具体地说，容量为2的缓冲器)。在这种情况下，当缓冲区容量为2并且我们试图发送一个额外的元素时，<code class="du lf lg lh li b">send</code>操作被挂起。下图描述了执行流程的剩余部分。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mn"><img src="../Images/abc7bcbc9a969470881f518a5520b3cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lp_XzVvxdNKIX_EK9YLwuQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片作者<a class="ae jd" rel="noopener" href="/@joaofoltran">作者</a></figcaption></figure><p id="cca5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出显示以下内容:</p><pre class="jf jg jh ji fd mc li md me aw mf bi"><span id="8a41" class="mg jv hi li b fi mh mi l mj mk">coroutine 1 done<br/>RABBIT<br/>ELEPHANT<br/>SLOTH<br/>coroutine 3 done<br/>coroutine 2 done</span><span id="2d6a" class="mg jv hi li b fi ml mi l mj mk">Process finished with exit code 0</span></pre><p id="1267" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">混为一谈。</strong>这是一个有趣的案例，因为接收器协程的完成实际上永远不会结束。由于合并通道的性质，<code class="du lf lg lh li b">send</code>操作会相互覆盖，但是当实际的<code class="du lf lg lh li b">receive</code>操作被调用时，通道中只包含一个元素，所以第二个<code class="du lf lg lh li b">receive</code>调用被挂起，协程保持空闲，没有完成执行，如下图所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mo"><img src="../Images/548e5b06f05de8bd07388f47db1d359a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ocsIxg4tSWtAnV0T8R3Qtg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片作者<a class="ae jd" rel="noopener" href="/@joaofoltran">作者</a></figcaption></figure><p id="4f25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出显示如下内容(注意，退出代码0没有显示，因为进程仍在运行):</p><pre class="jf jg jh ji fd mc li md me aw mf bi"><span id="36ba" class="mg jv hi li b fi mh mi l mj mk">coroutine 1 done<br/>coroutine 2 done<br/>SLOTH</span></pre></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="47f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！希望你喜欢读这篇文章，就像我喜欢写它一样。如果你喜欢这些内容，别忘了留下掌声，关注更多内容！</p></div></div>    
</body>
</html>