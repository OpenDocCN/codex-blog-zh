<html>
<head>
<title>React  Cognito</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对…作出反应</h1>
<blockquote>原文：<a href="https://medium.com/codex/react-cognito-f8bc43ccf404?source=collection_archive---------6-----------------------#2021-11-06">https://medium.com/codex/react-cognito-f8bc43ccf404?source=collection_archive---------6-----------------------#2021-11-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/37fa8dbca9a5d7bae77141fb8a729871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KUOrDk8uZw33tgJuRjki-Q.png"/></div></div></figure><p id="8fc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae jo" href="https://www.xtages.com" rel="noopener ugc nofollow" target="_blank">x ages</a>，我们使用<a class="ae jo" href="https://aws.amazon.com/cognito/" rel="noopener ugc nofollow" target="_blank"> Amazon Cognito </a>来管理我们的用户及其认证。</p><p id="8afa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Cognito收集用户的属性，它可以为web和移动应用程序实现简单、安全的用户身份验证、授权和用户管理。</p><p id="88fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本节中，我们将从5000英尺的高度来看Cognito如何与web应用程序集成。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jp"><img src="../Images/d485c967e2e5c0d4014c991fee5bd415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-RDQsMj7Ibbk4rXiZX6cIA.png"/></div></div></figure><p id="696f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Cognito要求用户验证他们的电子邮件或电话号码，以启用密码恢复流程。验证工作的方式是通过向用户的电子邮件或电话号码发送一个数字代码(使用SMS ),然后用户应用程序调用<code class="du ju jv jw jx b">CognitoAuth.confirmSignUp</code>,如上图的步骤6。</p><p id="4e3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将了解如何:</p><ul class=""><li id="79a2" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">使用<code class="du ju jv jw jx b">create-react-app</code>创建一个新的React webapp</li><li id="7906" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">创建认证的和未认证的<code class="du ju jv jw jx b">Route</code></li><li id="4a12" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">使用<a class="ae jo" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>提供认知用户池</li></ul><h1 id="a9e4" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">与React集成</h1><p id="5132" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">我们可以使用Cognito来保护React应用程序的某些部分，确保只有经过身份验证的用户才能访问它们。</p><blockquote class="lp lq lr"><p id="08cf" class="iq ir ls is b it iu iv iw ix iy iz ja lt jc jd je lu jg jh ji lv jk jl jm jn hb bi translated">注意:您应该确保您的服务器端API正在适当地检查向它发出的请求是否经过了正确的身份验证和授权。有了Cognito，当用户认证时，我们得到一个<a class="ae jo" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JWT </a>令牌，这个令牌应该传递给你的服务器或API。在本文中，我们不会深入讨论适当的服务器API实现的细节，因为它高度依赖于您的服务器所使用的技术。</p></blockquote><h1 id="c057" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">设置</h1><p id="b4bf" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">我们将从使用<code class="du ju jv jw jx b"><a class="ae jo" href="https://create-react-app.dev" rel="noopener ugc nofollow" target="_blank">create-react-app</a></code>创建一个新的React web应用程序开始:</p><pre class="jq jr js jt fd lw jx lx ly aw lz bi"><span id="341d" class="ma kn hi jx b fi mb mc l md me">npx create-react-app demo-app --template typescript</span></pre><h1 id="8d20" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><code class="du ju jv jw jx b">useAuth</code>钩子</h1><p id="1fec" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">这个集成的核心部分是基于<a class="ae jo" href="https://usehooks.com/useAuth/" rel="noopener ugc nofollow" target="_blank">https://usehooks.com/useAuth/</a>的<code class="du ju jv jw jx b">useAuth</code>钩子，它适应于使用Cognito的API。</p><p id="7c22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在安装了亚马逊的Cognito API包和<code class="du ju jv jw jx b">use-async-effect</code>包之后</p><pre class="jq jr js jt fd lw jx lx ly aw lz bi"><span id="718f" class="ma kn hi jx b fi mb mc l md me">npm install --save @aws-amplify/auth use-async-effect</span></pre><p id="545d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将继续在<code class="du ju jv jw jx b">src/hooks/</code>下为我们的<code class="du ju jv jw jx b">useAuth</code>钩子创建一个新文件，我们将其命名为<code class="du ju jv jw jx b">useAuth.tsx</code>。</p><p id="b6d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将使用AWS区域、co gno用户池Id和Cognito Web客户端Id来配置Cognito Auth对象。您可以看到这些值包含在<a class="ae jo" href="https://create-react-app.dev/docs/adding-custom-environment-variables" rel="noopener ugc nofollow" target="_blank">环境变量</a>中，因此可以根据应用的运行环境(本地开发、持续集成、试运行、生产等)轻松配置我们的应用。).</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="fff3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们为钩子的API创建一些类型:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="15a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类型拥有我们期望用户拥有的属性。<code class="du ju jv jw jx b">User.country</code>属性是<a class="ae jo" href="https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-attributes.html#user-pool-settings-custom-attributes" rel="noopener ugc nofollow" target="_blank">认知定制属性</a>的一个例子。</p><p id="ccf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ju jv jw jx b">Credentials</code>型将用于我们的<code class="du ju jv jw jx b">logIn</code>和<code class="du ju jv jw jx b">signUp</code>功能。</p><p id="7ad3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">值得注意的是<code class="du ju jv jw jx b">CognitoUserWithChallenge</code>有点像我们需要的拐杖，让Typescript编译器高兴。由<code class="du ju jv jw jx b">CognitoAuth.signIn</code>函数返回的对象(来自<code class="du ju jv jw jx b">amazon-cognito-identity-js</code>包)可以包含一个名为<code class="du ju jv jw jx b">challengeName</code>的属性，但是在<code class="du ju jv jw jx b">CognitoAuth.signIn</code>的类型中，这个属性不存在，因此我们必须在代码中补充这个类型。<code class="du ju jv jw jx b">challengeName</code>属性用于表示用户需要响应一个挑战来验证他们的身份。例如，当用户注册时，他们会通过电子邮件收到一个代码，他们必须输入该代码作为质询响应。有关更多信息，请参见<a class="ae jo" href="https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-authentication-flow.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/cogn ITO/latest/developer guide/Amazon-cogn ITO-user-pools-authentic ation-flow . html</a></p><p id="1b74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们将讨论钩子的实现。实际上，我们有一个私有钩子<code class="du ju jv jw jx b">useProvideAuth</code>和一个，所有的钩子都是通过公共钩子<code class="du ju jv jw jx b">useAuth</code>公开的。</p><p id="3bcd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们将剖析拥有大部分代码的<code class="du ju jv jw jx b">useProvideAuth</code>私有钩子:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="057f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ju jv jw jx b">useProvideAuth</code>钩子有三个公共函数:</p><ul class=""><li id="d5fb" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated"><code class="du ju jv jw jx b">logIn</code>:包装<code class="du ju jv jw jx b">CognitoAuth.signIn</code>，如果调用结果有一个<code class="du ju jv jw jx b">challengeName</code>返回，否则转换返回的<code class="du ju jv jw jx b">CognitoUser</code>设置<code class="du ju jv jw jx b">user</code>状态，同时将<code class="du ju jv jw jx b">authInProgress</code>状态切换为假。</li><li id="832c" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><code class="du ju jv jw jx b">logOut</code>:将<code class="du ju jv jw jx b">user</code>状态设置为<code class="du ju jv jw jx b">null</code>，调用<code class="du ju jv jw jx b">CognitoAuth.signOut</code>使用户令牌失效。</li><li id="b9af" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated"><code class="du ju jv jw jx b">signUp</code>:使用所需的用户属性和密码调用<code class="du ju jv jw jx b">CognitoAuth.signUp</code>。</li></ul><p id="6547" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于这个钩子的另外几个有趣的地方是使用了<code class="du ju jv jw jx b">useAsyncEffect</code>(来自<code class="du ju jv jw jx b">use-async-effect</code>包)，它具有与普通<code class="du ju jv jw jx b">useEffect</code>相同的语义，但是允许使用<code class="du ju jv jw jx b">async</code>函数。我们需要这个钩子，因为我们在渲染时确定用户是否通过调用<code class="du ju jv jw jx b">getUser</code>函数登录，这个函数本身就是<code class="du ju jv jw jx b">async</code>。我们还通过AWS <code class="du ju jv jw jx b">Hub</code>类设置了一个监听器，它将通知我们已经发生的不同的与auth相关的事件。</p><p id="7b96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我们的钩子已经准备好了，我们将继续设置一个<code class="du ju jv jw jx b">Context</code>,这样我们的应用程序就可以利用这个基础设施:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="e73a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的代码片段中，我们创建了一个类型为<code class="du ju jv jw jx b">Auth | null</code>的<code class="du ju jv jw jx b">Context</code>，其中<code class="du ju jv jw jx b">Auth</code>是<code class="du ju jv jw jx b">ReturnType&lt;typeof useProvideAuth&gt;</code>，我们还创建了一个小组件<code class="du ju jv jw jx b">&lt;AuthProvider&gt;</code>，它将<code class="du ju jv jw jx b">Auth</code>的一个实例传递给<code class="du ju jv jw jx b">&lt;AuthContext.Provider&gt;</code>。最后<code class="du ju jv jw jx b">useAuth</code>包裹<code class="du ju jv jw jx b">useContext(AuthContext)</code>并确保返回的<code class="du ju jv jw jx b">Auth</code>不是<code class="du ju jv jw jx b">null</code>。</p><h1 id="2a38" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用</h1><p id="49be" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">在授权基础设施就位后，我们现在需要开始在我们的应用程序中使用，第一步是将我们的组件层次结构包装在一个<code class="du ju jv jw jx b">&lt;AuthProvider&gt;</code>中，就像这样:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="f658" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您会注意到上面代码片段中的几点:</p><ul class=""><li id="2777" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">我们使用<code class="du ju jv jw jx b">react-router-dom</code>进行导航。</li><li id="80ea" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">我们已经将我们的应用程序包装在刚刚创建的<code class="du ju jv jw jx b">&lt;AuthProvider&gt;</code>中，这意味着<code class="du ju jv jw jx b">useAuth</code>钩子现在可用于我们所有的组件。</li><li id="1fdf" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">我们有几个不属于<code class="du ju jv jw jx b">react-router-dom</code>的公用线路组件，即<code class="du ju jv jw jx b">&lt;UnauthenticatedOnlyRoute&gt;</code>和<code class="du ju jv jw jx b">&lt;AuthenticatedRoute&gt;</code>。</li></ul><h1 id="6516" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">安全路由</h1><p id="d4b7" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">下面，<code class="du ju jv jw jx b">&lt;AuthenticatedRoute&gt;</code>使用<code class="du ju jv jw jx b">useAuth</code>来确定身份验证是否正在进行(如果是，显示一个空页面)，如果我们有一个经过身份验证的用户，那么我们将路由到指定的组件，如果我们没有经过身份验证的用户，那么我们将重定向到<code class="du ju jv jw jx b">/login</code>页面，将<code class="du ju jv jw jx b">location</code>保留在状态中，这样一旦用户成功登录，我们就可以重定向到它。</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="0865" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基本上是<code class="du ju jv jw jx b">&lt;AuthenticatedRoute&gt;</code>的镜像，因为如果用户没有通过<strong class="is hj">认证</strong>，它将只呈现<code class="du ju jv jw jx b">Route</code>，否则重定向到<code class="du ju jv jw jx b">/</code>。</p><h1 id="35ec" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">登录页面</h1><p id="b932" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">下面是一个非常简单的登录页面，仅用于说明目的，使用了<code class="du ju jv jw jx b">useAuth</code>钩子，尽管您可能希望使用一个适当的react表单库，也可能使用某种UI库。</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><h1 id="8497" class="km kn hi bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用Terraform提供认知</h1><p id="1b2c" class="pw-post-body-paragraph iq ir hi is b it lk iv iw ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn hb bi translated">以下Terraform模块用于提供这篇博文中使用的Cognito <a class="ae jo" href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html" rel="noopener ugc nofollow" target="_blank">用户池</a>:</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="788f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本模块的一些有趣部分:</p><ul class=""><li id="8fab" class="jy jz hi is b it iu ix iy jb ka jf kb jj kc jn kd ke kf kg bi translated">第24–34行:<code class="du ju jv jw jx b">password_policy</code>块是我们配置有效密码要求的地方。为了获得更好的UX，请确保您的注册页面表单使用相同的要求在客户端验证用户的密码。你也可以利用像<code class="du ju jv jw jx b">react-password-strength-bar</code>这样的包来提醒用户创建强密码。</li><li id="59c3" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">第37–73行:<code class="du ju jv jw jx b">schema</code>块是我们定义用户概要文件属性的地方。自定义属性必须在其名称中使用<code class="du ju jv jw jx b">custom:</code>前缀。</li><li id="89b8" class="jy jz hi is b it kh ix ki jb kj jf kk jj kl jn kd ke kf kg bi translated">第80行:<code class="du ju jv jw jx b">username_attributes</code>数组表明我们使用<code class="du ju jv jw jx b">email</code>属性作为用户的用户名。</li></ul><p id="4aee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ju jv jw jx b">aws_cognito_user_pool_client</code>资源为我们的用户池声明了一个web客户端，也就是我们的React应用程序。这是我们为Cognito在第104-111行返回的令牌配置有效期的地方。第119行，<code class="du ju jv jw jx b">generate_secret = false</code>确保不为这个客户机生成秘密，这是必要的，因为浏览器Cognito js库不支持秘密。</p><p id="54d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第123–134行表示哪些属性(如用户池本身所定义的)可由web客户端读取和/或写入。</p><p id="d355" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在用户认证和管理方面，AWS Cognito是一个很好的选择。当你已经购买了AWS生态系统时，它特别有用，而且比其他一些替代产品更便宜。</p><p id="b4c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">集成React和Cognito并不太难，但是Cognito的Javascript/Typescript包的参考文档缺乏一些深入的细节，他们也有几个看起来重叠的包(<code class="du ju jv jw jx b">amplify</code>、<code class="du ju jv jw jx b">@aws-amplify/auth</code>和<code class="du ju jv jw jx b">amazon-cognito-identity-js</code>)，这使得很难准确指出哪一个是Cognito工作所必需的。当没有必要将所有代码添加到应用程序中时，亚马逊也倾向于将Amplify作为auth解决方案的一个整体。</p><p id="f4a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在</strong><a class="ae jo" href="https://www.xtages.com" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">x ages</strong></a><strong class="is hj">我们正在构建一个用于CI/CD和应用托管的一体化解决方案，所有这些都只需最少的配置，无需管理基础架构。我们最近推出了一个免费的</strong> <a class="ae jo" href="https://www.xtages.com/pricing" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">计划</strong> </a> <strong class="is hj">(不需要信用卡)，让你更容易上手。</strong></p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><p id="3d85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ls">原载于2021年11月6日https://www.xtages.com</em><em class="ls">的</em> <a class="ae jo" href="https://www.xtages.com/blog/posts/react-and-cognito/" rel="noopener ugc nofollow" target="_blank"> <em class="ls">。</em></a></p></div></div>    
</body>
</html>