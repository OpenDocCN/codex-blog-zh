<html>
<head>
<title>How HTTP Data Travels Through the Internet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP数据如何在互联网中传输</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-http-packets-travel-through-internet-9fd447f90bb3?source=collection_archive---------5-----------------------#2022-06-17">https://medium.com/codex/how-http-packets-travel-through-internet-9fd447f90bb3?source=collection_archive---------5-----------------------#2022-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="dffa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今年，在做了4年多的软件工程师后，我决定是时候回归基础了，老实说，我一开始并没有理解好。</p><p id="66bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不太了解的一个方面是互联网实际上是如何工作的。我知道我们进行API调用(可能是HTTP ),然后通过线路传输数据，但除了我们在大学里获得的那些高级细节之外，中间发生的事情对我来说大部分都是一个黑盒。</p><p id="fb0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更好地掌握基础知识，我试图从OSI模型的第7层开始，深入研究HTTP数据包是如何从源机器路由到目的地的，并尽我所能在本文中与大家分享这些信息:)</p><h1 id="305b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">术语</h1><p id="4763" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在我进入实际细节之前，我想先了解一些定义或术语。</p><ol class=""><li id="189a" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated"><strong class="ih hj"> MAC地址</strong>:-MAC地址是唯一标识网络上每个设备的硬件标识号。MAC地址是制造在每个网卡中的，因此不能更改。在OSI模型中，MAC地址用作第2层地址。例如00:0d:83:b1:c0:8e。</li><li id="a244" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">地址解析协议</strong> :-通俗地说，ARP协议是用来为一个IP地址识别MAC地址的。通过使用ARP协议识别的MAC地址，路由器知道数据包的下一跳是什么。我们将在后面详细讨论如何使用ARP在本地网络和互联网上向目的地发送数据包。</li><li id="41e5" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">网络地址转换</strong>:——同样，用外行人的话来说，NAT是用来把私有地址转换成公有地址的。由于有限的IP4地址，并不是每个设备都有公有地址。在家中，您的设备(如笔记本电脑和手机)会由wifi路由器分配一个本地唯一的IP地址。当设备发送数据包时，源IP地址是设备的私有IP，数据包被发送到路由器/网关。然后，路由器将此私有IP地址替换为自己的公有IP地址，并在NAT表中添加条目后通过互联网发送数据。然后，此NAT条目使路由器能够将响应发送回您的设备。一个NAT条目看起来类似于<a class="ae ku" href="https://gist.github.com/himanishm07/82668dfab657d0d419e4ffffcdd313f0" rel="noopener ugc nofollow" target="_blank">这个</a>。(请记住，这是一种严重的过度简化)。因此，当路由器看到来自7.12.9.14:443的响应时，它知道数据需要返回到192.168.1.23:8091。</li><li id="eddb" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">代理服务器</strong> :-代理服务器是一台专用计算机或运行在计算机上的软件系统，充当端点设备之间的中介。如果您有一个转发HTTP代理设置，您的所有请求将被发送到该代理，然后该代理将代表您向目的地发出HTTP请求，并向您发回响应。</li></ol><h1 id="c2ad" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">分组路由</h1><p id="ba5b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在到了有趣的部分。如下所述，我将在本文中讨论3个用例。</p><h2 id="18fd" class="kv je hi bd jf kw kx ky jj kz la lb jn iq lc ld jr iu le lf jv iy lg lh jz li bi translated">本地网络中带有源和目的地的HTTP请求</h2><p id="c065" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在这种情况下，数据包不必通过互联网传输。下面提到所涉及的高级步骤</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div class="er es lj"><img src="../Images/dd03cf75b17e237cabc22ecc9cdcf19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*7LeOeCah8sE2sZ_5-RB-Pg.png"/></div></figure><p id="e7bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">源机</strong></p><ol class=""><li id="8cc4" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">IP为192.168.1.200的源计算机从向IP为192.168.1.129的目标计算机发出HTTP /Get请求。</li><li id="a0a0" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">数据包被传输到源机器的第4层，在那里添加源端口和目的端口。</li><li id="15b0" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">数据包被传输到第3层，在那里添加源和目的IP地址。</li><li id="03ec" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">然后数据包被传递到第2层。这就是ARN出现的原因。<br/>4.1<em class="lr">。</em>源机器通过使用子网掩码计算目的机器是否在其网络中。<br/> <em class="lr"> 4.2。</em>在这种情况下，由于目的地在局域网内，源广播一个ARP请求，询问目的IP的MAC地址。<br/>4.3<em class="lr">。</em>目标机器以其MAC地址响应。<br/>4.4<em class="lr">。</em>最后，源附加该MAC地址作为目的MAC地址，并附加源MAC地址作为自己的MAC地址。</li></ol><p id="21bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">路由器</strong></p><p id="22e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后数据包被发送到路由器。这些路由还会做一些如下所述的事情</p><ol class=""><li id="80e2" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">它检查目的MAC地址，以了解数据包是否发往它。在我们的例子中，MAC用于网络中的其他机器。</li><li id="11e7" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">根据路由表，将数据包路由到目的机器。在这里，<strong class="ih hj">路由器仅作为交换机工作。</strong></li><li id="e1cf" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">由于数据包需要在本地传输，而且源和目的地都知道彼此的IP地址，因此不需要<strong class="ih hj">NAT</strong>。</li></ol><p id="1917" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">目的机器</strong></p><ol class=""><li id="39a1" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">当数据包到达目的地机器时，它首先检查MAC地址，然后检查目的地的IP地址。当两者都与机器匹配时，机器然后在第7层打开GET消息并处理它。</li><li id="daef" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">基于该请求，目的服务器然后生成响应。</li><li id="1e32" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">现在，目标机器成为源机器，源机器成为目标机器，并且重复该过程以使响应到达最初的源机器。</li></ol><figure class="lk ll lm ln fd lo er es paragraph-image"><div class="er es ls"><img src="../Images/b66ff57afbbd97fc70c762fa7cd41c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*_LnBGwrhqkpf4a04P-vVqQ.png"/></div></figure><h2 id="e524" class="kv je hi bd jf kw kx ky jj kz la lb jn iq lc ld jr iu le lf jv iy lg lh jz li bi translated">来源和目的地在不同网络中的HTTP请求</h2><p id="c7a6" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这里，遍历变得有点复杂，因为数据包需要通过Internet。这个遍历中增加的一个过程是NAT。由于私有IP地址仅在本地网络中有意义，路由器在收到数据包时会将数据包的源IP地址替换为自己的地址，并在其NAT表中创建一个条目。因为来自目的机器的响应将被发送到路由器的IP地址，所以这个NAT条目告诉路由器在专用网络中什么是要发送响应的实际机器。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div class="er es lt"><img src="../Images/1984a9d9dcaf25c300ea47ff4b51d603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*usI3yKktlLXcyDZ-BI2TaA.png"/></div></figure><p id="8b33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">源机器</strong></p><ol class=""><li id="034a" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">IP为192.168.1.200的源计算机向IP为1.2.3.4的目标计算机发出HTTP /Get请求。</li><li id="02e7" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">数据包被传输到源机器的第4层，在那里添加源端口和目的端口。</li><li id="8e3a" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">数据包被传输到第3层，在那里添加源和目的IP地址。</li><li id="7dbc" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">然后数据包被传递到第2层。在这里，<strong class="ih hj">流程与用例1 </strong>没有什么不同。<br/>4.1<em class="lr">。</em>源机器通过使用子网掩码计算目的机器是否在其网络中。<br/> <em class="lr"> 4.2。</em>在这种情况下，目的地是<strong class="ih hj">而不是</strong>局域网的一部分。<br/> <em class="lr"> 4.3 </em>由于数据包不在本地网络中，源决定将数据包发送到其网关<strong class="ih hj">。</strong>大多数情况下，是路由器。<br/> <em class="lr"> 4.4 </em> Source向网关IP发出ARP请求，在我们的例子中是192.168.1.1。<br/> <em class="lr"> 4.5。</em>目标机器以其MAC地址响应。在我们的例子中，FF是网关/路由器的MAC地址。<br/>4.4<em class="lr">。</em>最后，源附加该MAC地址作为目的MAC地址，并附加源MAC地址作为自己的MAC地址。</li></ol><figure class="lk ll lm ln fd lo er es paragraph-image"><div class="er es ls"><img src="../Images/448246175d1ba23e5e6f3a8e1e671fb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*xYpTfcXNT-ISw3vwSEBckA.png"/></div></figure><p id="4572" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">路由器</strong></p><p id="e987" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后数据包被发送到路由器。在这个用例中，路由器做了很多繁重的工作。</p><ol class=""><li id="e11c" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">路由器检查MAC地址，以了解数据包是否发往它。在我们的例子中，MAC是针对路由器本身的。</li><li id="6e34" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">然后检查目的IP地址。检查IP地址后，意识到数据包实际上不是发送给它，而是发送给公共网络，因为数据包中的目的IP地址是1.2.3.4。</li><li id="e828" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">然后，路由器将源IP地址(192.168.1.200)更改为自己的公有IP地址，即7.7.7.7。</li><li id="d0e9" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">然后，它在NAT表中创建一个条目，其中源为192.168.1.200:端口，目的地为1.2.3.4:端口。</li><li id="ae1e" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">有趣的部分来了。现在，当路由器知道数据包需要发送到Internet时，它会检查路由表，看是否知道数据包要发送的下一跳。</li><li id="3737" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">如果路由器的路由表中有该地址的条目，它会将数据包发送到该路径，否则，它会将数据包发送到默认路由，通常是其ISP。</li><li id="38b7" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">在这两个用例中，基于IP地址，它发出一个ARP请求来查找下一跳的MAC地址。</li><li id="6775" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">现在，数据包的源MAC地址属于路由器本身，目的MAC地址属于下一跳。</li></ol><p id="074a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的示例中，在步骤1到4中，路由器作为网关工作，因为它将私有IP替换为公共IP。从5到8，路由器充当路由器。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div class="er es lu"><img src="../Images/42e03e46a923c7f044212700af9a6b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*lMFA8FNyR0y-oh9ZAyBezA.png"/></div></figure><p id="ef99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">中间节点/路由器</strong></p><p id="9845" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于源和目的地之间的所有中间节点，遵循上述步骤5-8，直到数据包到达目的地。</p><p id="40ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">目的地机</strong></p><ol class=""><li id="a36f" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">该机器首先检查MAC地址，然后检查IP地址，并意识到数据包是发给自己的。</li><li id="474f" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">然后，Destination生成响应，并将其发送回请求的源地址。在我们的用例中，这将是7.7.7.7，即路由器的<strong class="ih hj">公共地址。</strong></li></ol><h2 id="07bc" class="kv je hi bd jf kw kx ky jj kz la lb jn iq lc ld jr iu le lf jv iy lg lh jz li bi translated">HTTP请求的源和目标位于不同的网络中，在源处有转发代理</h2><p id="4a36" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在这种情况下，来自源机器的所有数据包都被发送到代理服务器。然后，代理创建一个对目的服务器的请求，获取对请求的响应，打包对源的响应，并将其发送回来。<br/>代理提供了各种好处，如为源隐藏IPs，提供了额外的安全层。除此之外，代理还可以缓存响应。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/8e6f76dde208fa96fbc559d05959bc2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbd-6NNu167rUtVSTLjCgg.png"/></div></div></figure><p id="4816" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">源机</strong></p><ol class=""><li id="54b7" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">IP为192.168.1.200的源计算机向IP为1.2.3.4的目标计算机发出HTTP /Get请求。这就是添加目的IP作为HTTP请求的一部分变得很重要的用例，我们将在下面看到。<br/>注意:- "Host "头是在HTTP 1.1中引入的。这个“主机”属性是目标机器IP地址被提及的地方(在我们的用例中是1.2.3.4)</li><li id="2f56" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">包被传送到源机器的第4层，在那里源和<strong class="ih hj">代理端口</strong>被添加。</li><li id="541c" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">数据包被传输到第3层，在此添加源和<strong class="ih hj">代理IP </strong>地址。<br/>注:-如上所述，在代理的情况下，所有请求仅向代理提出。这就是目的IP和端口用于代理的原因。</li><li id="e941" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">然后数据包被传递到第2层。这里的<strong class="ih hj">流程同</strong> <br/>用例2 <br/> <em class="lr"> 4.1。</em>源机器通过使用子网掩码来计算目的机器是否在其网络中。<br/> <em class="lr"> 4.2。</em>在这种情况下，目的地是<strong class="ih hj">而不是</strong>局域网的一部分。<br/> <em class="lr"> 4.3 </em>由于数据包不在本地网络中，源决定将数据包发送到其网关<strong class="ih hj">。</strong>大多数情况下，是路由器。<br/> <em class="lr"> 4.4 </em>源对网关IP发出ARP请求，在我们的例子中是192.168.1.1。<br/> <em class="lr"> 4.5。</em>目的机器用它的MAC地址来响应。在我们的例子中，FF是网关/路由器的MAC地址。<br/>4.4<em class="lr">。</em>最后，源附加该MAC地址作为目的MAC地址，并附加源MAC地址作为自己的MAC地址。</li></ol><figure class="lk ll lm ln fd lo er es paragraph-image"><div class="er es ls"><img src="../Images/9a0624ec3d4f80e0545d53556337167f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*5rUhdzvXQRHP3H8YD6NykA.png"/></div></figure><p id="a0f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">本地网络路由器和中间路由</strong></p><p id="db02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的过程与用例2中的过程相同。唯一的区别是，在用例2中，目的地实际上是目的地机器，而在这个用例中，目的地是代理服务器，但是路由器完全不知道它。</p><figure class="lk ll lm ln fd lo er es paragraph-image"><div class="er es lu"><img src="../Images/fb90c1cd823665138a475bffa36c259c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*jzKs1qEBzCKhjOt4EJBiXg.png"/></div></figure><p id="8571" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">代理服务器</strong></p><p id="73bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当数据包到达代理服务器时，它的代理负责将数据包发送到实际目的地。这就是“主机”标题出现的地方。</p><ol class=""><li id="5041" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">代理以HTTP请求的形式从源机器获取数据包。</li><li id="3b2e" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">由于这是一个HTTP代理，代理读取HTTP数据并读取主机头以了解目的IP。</li><li id="bb60" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">从这里，代理服务器向目标机器(在我们的用例中是1.2.3.4)发出一个HTTP请求。此过程与用例2<strong class="ih hj">相同，其中代理是源，目的地是目的地。</strong></li><li id="88db" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">然后，代理从目的机器获得HTTP响应，在点1中为来自源机器的请求创建一个响应，并将其发送回去。</li></ol><p id="ef82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">目的服务器</strong></p><p id="e884" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里的目的服务器根本不知道源机器，它得到的包都有源地址作为代理服务器的地址。目标服务器处理请求并将响应发送回代理服务器。<br/>然后，代理服务器接收到这个响应，并通过它的路由器(7.7.7.7)将其传输回实际的源机器(在我们的用例中是192.168.1.200)</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><p id="6eac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章到此为止。希望你能从中了解到一些新的东西。如果你喜欢这篇文章，那么请喜欢并关注。如果你想了解像HTTP，HTTP/2和3，TCP UDP QUIC等网络概念，你也可以查看我的其他文章。</p><p id="c8ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另外，在linkedIn上关注我</p></div></div>    
</body>
</html>