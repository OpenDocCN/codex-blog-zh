<html>
<head>
<title>Git Under The Hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">藏在引擎盖下</h1>
<blockquote>原文：<a href="https://medium.com/codex/git-under-the-hood-82c027b00b17?source=collection_archive---------7-----------------------#2021-10-05">https://medium.com/codex/git-under-the-hood-82c027b00b17?source=collection_archive---------7-----------------------#2021-10-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="e903" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">git是如何存储信息的？</h1><p id="8fa1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在其核心，git就像一个键值存储。这里的key指的是将要存储的数据或内容的散列，value指的是实际的内容</p><p id="dab4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">git在给出一段数据时生成的散列密钥使用SHA1散列函数，它是一个<strong class="jf hj"> 40位十六进制数</strong>。如果给定的输入数据相同，则生成的哈希键将总是相同的。这种类型的系统也称为内容可寻址系统</p><p id="3546" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">git存储信息的方式是以<strong class="jf hj"> Git对象</strong>的形式，即所谓的</p><ul class=""><li id="2b51" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">一滴</li><li id="bacf" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">树</li><li id="4ae5" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">犯罪</li></ul><p id="37a8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">让我们一个一个去揭开它们的神秘面纱吧！</p><h1 id="392f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">斑点:</strong></h1><p id="f8c4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Git将压缩数据存储在一个blob中，并在它的头中存储一些元数据。</p><p id="b2fd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">存储在git对象中的信息有:</p><ul class=""><li id="d99c" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">类型，即斑点</li><li id="afa9" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">内容的大小</li><li id="ce65" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">\0空字符</li><li id="c056" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">内容</li></ul><p id="eba8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">git用来生成git blobs的管道或内部命令是git hash-object。因此，如果我们要求git生成字符串的SHA1，即"<strong class="jf hj">解密git <em class="ku">，</em> </strong>，我们得到散列"<strong class="jf hj">a1f 544d 55619 fab 2909286d 9 c 6 b 5 C5 fa 7b 8825 db "</strong></p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/dd34c817cabb7ba6c772339f3e8d451f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*veghZ3C3Z18hSZuZxNGogQ.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">使用git hash-object命令生成了sha1哈希</figcaption></figure><p id="576e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在让我们生成内容的相同SHA1，就像使用任何其他工具存储在git中一样。我使用OpenSSL命令行工具，用于演示目的。python或node等编程语言的所有其他工具或库都会产生相同的结果</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ll"><img src="../Images/9daeac26218b14d0d8b9fd6b20a37438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LvnYpO3nuaNu19GuFAdZbA.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">使用第三方工具openssl生成的哈希</figcaption></figure><p id="755a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">请参见OpenSSL为字符串生成的哈希</p><blockquote class="lm ln lo"><p id="ed62" class="jd je ku jf b jg kb ji jj jk kc jm jn lp kd jq jr lq ke ju jv lr kf jy jz ka hb bi translated">“blob 30 \解密git的内部”与git哈希对象生成的相同</p></blockquote><h2 id="406f" class="ls ig hi bd ih lt lu lv il lw lx ly ip jo lz ma it js mb mc ix jw md me jb mf bi translated">那么git在哪里存储这些git对象呢？</h2><p id="df44" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Git将这些对象存储在。git目录。它是在空的git目录中运行git init命令时创建的。下面是GitUnderTheHood git存储库的屏幕截图，正如您所看到的，生成的blob对象存储在。git/objects目录，前2个字符代表目录名，其余字符代表文件</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mg"><img src="../Images/3892ec05cd4c75ca81f423c3180cb261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajS38p9Vy-zK6kanvo2KxA.png"/></div></div></figure><h1 id="0712" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">树:</strong></h1><p id="f687" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Blob是git对象的基本单元，但它遗漏了一些信息，即</p><ul class=""><li id="48ee" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">文件名</li><li id="e8ca" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">目录结构</li></ul><p id="4024" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因此，如果我们将一个文件保存为blob，我们如何知道关于该文件的信息以及它存储的目录结构。Git将这些信息存储在一个称为树的特殊git对象中。</p><p id="3bb0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所以git中的树是一个<strong class="jf hj">有向无环图，也称为DAG </strong>。它包含一个使用SHA1的指针</p><ul class=""><li id="1d38" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">到blobs</li><li id="8220" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">到另一棵树</li></ul><p id="b55e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">以及一些元数据</p><ul class=""><li id="e4e7" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">指针的类型(blob或树)</li><li id="720d" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">文件名</li><li id="021c" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">文件模式<em class="ku">(文件模式提供关于文件类别的信息，例如它是目录、可执行文件还是符号链接？)</em></li></ul><p id="e42c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这是我的git存储库的示例截图，其中a.txt内容与/copy目录中的a-copy.txt内容相同，因此其哈希也相同。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mh"><img src="../Images/20f9962ed0776baa269e0d29d891113d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vdtU10qLQ--E25Q9tHOD9g.png"/></div></div></figure><p id="5773" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">DAG将看起来像这样:</strong></p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mi"><img src="../Images/b5dcd3f558e48101c1015227a32f5952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5dvFD8ST19u0EhlMCgiG2A.jpeg"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">git回购的DAG</figcaption></figure><p id="7ab3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">因为sha1散列键对于给定的内容是唯一的，所以在git中，相同的内容总是存储一次。这就是git优化内存使用的方式。这就是为什么在git中检查分支会非常快。这只是从一个git对象到另一个对象的指针引用的变化。</p><h1 id="1d81" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">提交:</h1><p id="5b6b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">提交是项目在那个时间点的代码快照。这是指向树的第三种类型的git对象，它还包含一些元数据，比如</p><ul class=""><li id="eeb3" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">委托人或作者</li><li id="fd1b" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">日期</li><li id="f2ab" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">消息</li><li id="23c0" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">父提交</li></ul><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mj"><img src="../Images/fcf29361a33cd75866bd81d77a61341d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78eWdIi1oWjElSPNsT_fZA.png"/></div></div></figure><p id="003b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果您更改了关于提交的任何数据，提交将会生成一个新的SHA1。即使提交指向相同的树/文件内容，日期和时间也会发生变化，因此会创建新的哈希。</p><p id="e3d1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如果您想查看存储在。git/objects目录使用cat，你不会找到任何有用的东西，因为这些是二进制压缩对象。为了查看对象的内容和类型，我们可以使用git的另一个管道命令，即分别带有-p或-t标志的git cat-file</p><ul class=""><li id="0158" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">git cat-file -t <hash>将打印git对象的类型</hash></li><li id="0f51" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">git cat-file -p <hash>将打印git对象的内容</hash></li></ul></div></div>    
</body>
</html>