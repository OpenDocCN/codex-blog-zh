# 动态编程简介

> 原文：<https://medium.com/codex/introduction-to-dynamic-programming-24666933ae6?source=collection_archive---------6----------------------->

## 为国家优化！

![](img/2d8d09bded3e8d76e4314f865595e537.png)

# 观众

本文的目标读者是对算法有初步经验的工程师，他们希望迈出动态编程的第一步。需要扎实的递归知识，并对位操作符有所了解。

我们将在 Java 中实现这些技术，所以对这种语言有一个基本的了解是有帮助的，尽管不是必需的。

# 争吵

动态编程可以被认为是递归的优化。如果我们有一个递归问题，需要我们解决同一个问题两次，那么存储和重用那个问题的结果就更容易了。

从形式上来说，它用下面的公式表示:

1.  **最优子结构:**一个问题可以分解成子问题，子问题的最优解可以用来寻找主问题的最优解。
2.  **重叠子问题:**有些子问题的解会被多次使用，我们可以缓存以提高性能。

虽然这听起来有点抽象，但还是用一个例子具体说一下吧。斐波纳契数列的计算公式如下:

```
f(n) = f(n - 1) + f(n - 2)
```

这里我们有起始条件`f(1) = 1`和`f(0) = 0`。让我们走一遍。

```
f(0) = 0
f(1) = 1
f(2) = f(1) + f(0) = 1
f(3) = f(2) + f(1) = 1 + 1 = 2
f(4) = f(3) + f(2) = 2 + 1 = 3
...
```

我们可以很快看到一种模式的出现。那么我们该如何编码呢？一种解决方案是使用:

```
**public int** fibonacci(**int** n) {
    **if**(n <= 1) {
        **return** n;
    }
    **return** fibonacci(n - 1) + fibonacci(n - 2);
}
```

然而，如果我们考虑一下这对`f(4)`来说是如何执行的，它将计算`f(3) + f(2)`，而`f(3)`也需要计算`f(2)`(由于`f(3) = f(2) + f(1)`)。因此，这种计算发生了两次，浪费资源！

更好的方法可能是使用数组结构来存储前面的两个斐波纳契数。一旦计算出来，这将允许我们重复使用它们！

```
**private static int** fibonacci(**int** n) {
    **int**[] fibonacciNumbers = **new int**[n + 1];

    fibonacciNumbers[0] = 0;
    fibonacciNumbers[1] = 1;

    **for**(**int** i = 2; i <= n; i++) {
        fibonacciNumbers[i] = fibonacciNumbers[i - 1] +  
                              fibonacciNumbers[i - 2];
    }

    **return** fibonacciNumbers[n];
}
```

需要注意的一件重要事情是**我们经常用空间换取时间。**这里我们有一系列的解决方案，占用了空间。在一些动态编程问题中，我们会发现自己为了寻找更快的解决方案而耗尽了更多的内存。

## 自上而下与自下而上

动态编程有两种主要方法:自顶向下(记忆化)和自底向上(制表)。

自底向上(听起来是这样)，是一种我们想要达到一种状态`n`的技术，我们需要从一些初始条件开始，并计算我们向上的方式。我们对斐波那契的动态编程回答就是一个很好的例子。注意我们如何计算`f(0)`，然后`f(1)`，然后`f(2)`。我们从底层做起，一路向上。

自上而下则相反。我们的非 DP Fibonacci 解决方案就是一个很好的例子。我们从我们希望找到的解决方案开始`f(n)`，然后从该解决方案返回进行我们需要的计算。

一些人发现用下面的术语来表达这些想法是很清楚的:

*   **自下而上(memoization):** 我要学习 Java，我要学习在线课程，我要阅读 James 的所有文章，我要成为一名编程大师。
*   **自上而下(制表):**我要成为一名编程大师，所以我会读完 James 的所有文章，但是先学习一门在线课程，但是先学习 Java。

我们可以看到一个从一开始就朝着我们的目标前进，而另一个则相反。

## 最优化与组合问题

通常有两种类型的问题我们可以应用动态编程来解决。

1.  **优化问题:**到目前为止，这些都是本文的重点。在这些类型的应用中，我们希望找到给定问题的最佳解决方案。
2.  **组合问题:**在这类问题中，我们要寻找一个因素可能的不同组合的数量。这可以用来计算某件事情发生的概率。

让我们使用来自 [LeetCode](https://leetcode.com/) 的一些例子来探索这些想法。

看看优化，我们有下面的问题[。](https://leetcode.com/explore/featured/card/top-interview-questions-easy/97/dynamic-programming/576/)

> 你是一个专业的强盗，计划沿街抢劫房屋。每栋房子都藏了一定数量的钱，阻止你抢劫每栋房子的唯一限制是相邻的房子都连接了安全系统，如果两栋相邻的房子在同一个晚上被闯入，它会自动联系警察。
> 
> 给定一个表示每栋房子的钱数的整数数组`nums`，返回你今晚可以抢劫的最大金额**而不惊动警察**。

那么这是一个怎样的动态规划问题呢？我们想**最大化**我们能偷的数量，这是我们的第一个线索。此外，我们在房子 A 能偷的最大值与我们在房子 A 后面第二栋房子能偷的最大值相同(因为不想惊动警察，我们不能抢劫后面第一栋房子)，加上当前房子的价值。

我们可以对一个组合问题做类似的事情。让我们再举一个来自 [LeetCode](https://leetcode.com/explore/featured/card/top-interview-questions-easy/97/dynamic-programming/569/) 的例子。

> 你正在爬楼梯。到达顶端需要`n`步。
> 
> 每次你可以爬`1`或`2`台阶。有多少种不同的方式可以让你爬上顶峰？

## 比特屏蔽

有时在动态编程中，我们需要表示一个集合。我们将探讨 DP 之外的位屏蔽的概念，因为孤立地研究更容易。再来看[另一个 LeetCode 问题](https://leetcode.com/problems/maximum-product-of-word-lengths/)。

> 给定一个字符串数组`words`，返回 `length(word[i]) * length(word[j])` *的最大值*，其中两个单词不共享公共字母*。如果没有这两个字，返回`0`。*

当我们寻找有共同字母的单词时，将这两个单词表示为它们的字母集合就足够了，然后检查是否有交集。

```
hello = {h, e, l, l, o}
jealous = {j, e, a, l, o, u, s}
hello ∩ jealous = {e, l, o}
```

如果交集非空，我们知道存在冲突。我们可以用比特来表示这些集合，只要一个字母出现在单词中，我们就把它设为 1。

请注意，我们并不关心一个字母出现了多少次，或者出现在哪里，只关心它们出现了多少次。

从这里我们可以看到这个问题的一个相当清晰的解决方案。创建每个单词的位掩码，同时跟踪带有该掩码的单词的最大长度。然后，我们遍历所有掩码，找到没有共同位的掩码，并计算它们的字长乘积。

## 数字动态编程

好的，戴上你们的帽子，因为这里有点危险。我花了很长时间才明白过来，但也许你比我聪明一点！

有时，将一个数字视为其数字数组会很有用。例如`1234`变成了数组`[4, 3, 2, 1]`。注意它是如何被颠倒的，所以最左边的数字变成了最重要的数字。从 4 开始，我们可以生成它下面的所有数字，同时动态地检查它们的属性。我们稍后将引入一个示例，所以如果这暂时看起来很奇怪，请不要担心。

但是，您应该看到，生成 4 之后的数字并不像看起来那么简单。一个基本的生成算法可能会得出:

```
40**
41**
42**
43**
44**
```

其中`*`代表一些还需要在递归中计算的数字。`40**` 可能变成`4000`、`4001`、……但是，如果我们看一下，最后一个条目太高了！我们需要一种方法来限制这种行为。输入`tight`。

`tight`变量用于告诉我们是否需要查看初始数字中的数字。例如，如果我们在寻找`40**`之后的数字，那么`tight`将被设置为`0`(或 off)。这意味着下一个数字可以取从`400*`到`409*`的任何值(明白我为什么开始困惑了吧？).

开始时`tight`将被设置为`1`。这意味着我们需要在生成下一个数字之前检查我们的原始数字。我们需要记住我们最初的数字:`4321`。

```
40** - Is 0 less than 3? Yes, keep going
41** - Is 0 less than 3? Yes, keep going
42** - Is 0 less than 3? Yes, keep going
43** - Is 0 less than 3? No, stop!
```

一旦我们知道我们只生成无法达到上限的数字，我们就可以将`tight`设置为 off。

```
400* - Generate any numbers after this, they'll all be fine
401* - Generate any numbers after this, they'll all be fine
...
```

这是一个棘手的问题，但希望在通读几遍后，你会明白。从本质上说，这是一个聪明的方法，可以生成所有小于一个数的不同数。

当我们以这种方式生成数字时，我们也可以检查它们的任何我们需要的属性。一个有用的事实是，如果我们在两个边界`a`和`b`之间寻找一个属性`f(x)`，那么我们可以使用`f(b) — f(a)`计算这个属性的结果。同样，有点抽象，所以让我们来看我们的例子！我们从[极客那里借了一个给极客](https://www.geeksforgeeks.org/digit-dp-introduction/)。

> 给定两个整数 **a** 和 **b** 。找出 a 和 b 之间的整数中出现的所有数字的总和。例如，如果 a = 5，b = 11，则答案是 38 (5 + 6 + 7 + 8 + 9 + (1 + 0) + (1 + 1))

希望有了上面的内容和下面的解决方案，情况会变得明朗一些。

数字 DP 是一个相当容易混淆的领域，所以可能需要补充阅读。然而，我希望这个粗略的介绍能提供一个直观的基础。

# 结论

总之，我们已经讨论了动态编程，它的定义，动机和一些用例。