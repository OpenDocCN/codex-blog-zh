<html>
<head>
<title>Identifying songs I like with an algorithm in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用R语言中的算法识别我喜欢的歌曲</h1>
<blockquote>原文：<a href="https://medium.com/codex/identifying-songs-i-like-with-an-algorithm-in-r-a0c51cc44ec5?source=collection_archive---------9-----------------------#2021-07-11">https://medium.com/codex/identifying-songs-i-like-with-an-algorithm-in-r-a0c51cc44ec5?source=collection_archive---------9-----------------------#2021-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/85839c805d657fc884aaea51b2f0aefd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4SIAoaw_KOBBfyPi"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">布雷特·乔丹在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="61dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我锻炼或学习的时候，有一件事总是萦绕在我心头。是音乐。如果我经常听音乐，我能改进什么？</p><h1 id="f4bf" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">问题陈述</strong></h1><p id="3564" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">因为我大部分时间都和音乐在一起，所以经常觉得手机里存的歌不够用。另外，我真正喜欢的歌曲并不多。所以，跳歌找喜欢的每次都会发生。因此，我的工作流程经常被打乱。所以我经常不得不花额外的时间去寻找新歌。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/c3f4bc8143db82cc375701893ceafba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dqP39Qp3pFJ9-9vrLahAFw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">我用来查找新歌的Youtube播放列表示例</figcaption></figure><p id="f514" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Youtube上的各种播放列表是我寻找新歌的地方。但是，这种方法仍然存在许多问题。随着我在Youtube上花的时间越来越多，找到新歌变得越来越难，因为大多数人都使用类似的歌曲来创建他们的播放列表。另一个问题是，我倾向于从每个播放列表中只喜欢2或3首歌曲。因此，我不得不花比预期更多的时间去寻找我喜欢的新歌。</p><p id="0ded" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果有一种算法可以识别我喜欢的歌曲，事情会好得多。如果有可能，那我就不用付出额外的努力了。如果我想听新歌，我只需要随时运行这个算法。这可以节省我很多时间，所以我开始了这个项目。</p><h1 id="aced" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">数据探索</strong></h1><p id="6f6f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">既然一首歌怎么作曲决定了我喜不喜欢，我就需要一个数据集，把歌曲的特征转化成变量。它还应该给出这些变量的数值度量。</p><p id="bcd5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Spotify API是一个完美的工具。不幸的是，它在我住的地方不起作用。感谢Sumat Singh上传了他在Kaggle.com的作品，我可以使用他的Spotify数据集。</p><p id="6f0c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，为了确定哪些歌曲是我喜欢的，哪些是我不喜欢的，我首先从数据集中抽取了300首歌曲的样本，并将1标记为喜欢，0标记为不喜欢，因为由于时间问题，我无法浏览整个数据集。下图是数据集中的行的样子。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/0b2283e60e19c8a73665a148be7ee9a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsQdmYh-Gvr4UYlPP0Q1oA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">spotify数据集的前三行</figcaption></figure><p id="a48d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个数据集的一个潜在问题是它是不平衡的。也就是说，积极和消极的观察值在数据集中分布不均。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/94b85cfc8bc8ec18f6b9f46b68105023.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*UHlDfusJ4ThSn4HZQBdO8w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">显示0和1的不平等分布的表格</figcaption></figure><p id="6e61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这降低了模型的性能，因为对于模型来说，从样本较少的类中学习歌曲的特征并将其与其他歌曲区分开来是一项挑战。另一个问题是，根据不同的情况，假阴性和假阳性可能被不平等地对待。因此，选择合适的指标至关重要。</p><p id="74a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">包含大量变量的数据集的另一个潜在问题是共线性。由于共线性不能保证基于系数估计的基本假设，所以当我解释结果时会产生问题。然而，这并没有削弱模型的预测能力。因此，能量与响度和能量与声音之间的轻微共线性在这个项目中不会成为问题，因为目标是正确识别我喜欢的歌曲。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/156fb204029742d4e20ebaf457f3a359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*1etcEkLT1-NoZivh-7klpA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">用corrplot包中的corrplot()生成的相关矩阵</figcaption></figure><h1 id="bb54" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">公制</strong></h1><p id="795d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">正如我上面提到的，我应该小心选择最佳模型的度量标准。但是为什么会这样呢？例如，假设有1%的阳性病例，其余的都是阴性。当我们使用准确性时</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/5de11402c284e32242f3279357a99d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZ26be2J_0UfrOVjDQLCvw.png"/></div></div></figure><p id="aa1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一个评估标准——正确分类的观察值与整个数据集的比率——什么是好的模型？</p><p id="6977" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以试着找到一个能正确分类所有观察结果的模型。但是有一个更简单的方法。一个简单的零模型将所有情况分类为负面的，给你99%的准确率，当我们只看数字时，这已经足够好了。然而，这是一个误导的结果。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/59198a4623cddc21e2417cf6bdfacd4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*o49H8tDAl9lWVmC36hWsrA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">具有零模型的混淆矩阵达到99%的准确度</figcaption></figure><p id="aeca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们深入研究这些错误时，这个模型没有发现任何积极的方面。因此，当我们需要找到真正的积极因素时，这个模型就完全失败了。因此，该模型变得无用。因此，当我有一个不平衡的数据集时，准确性不是一个合适的衡量标准。那么，在这种情况下，我还可以使用什么其他指标呢？</p><p id="d0d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">换句话说，对于这个项目，我的主要兴趣是识别我喜欢的歌曲或真正积极的东西。因此，精确度</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/53f837448307fc22320399645ebe5526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pkwetHIGFkdfNXCASHUzXQ.png"/></div></div></figure><p id="10ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对我来说至关重要。同时也不想错过绝大多数正面标签的歌曲。如果一个模型给出了100%的精确度，但是在35个阳性标记的病例中只识别了两个，那么这个模型有什么用呢？因此，回想一下</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/fd089fed1a4623b5334e3e6ac7b514a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BeXkNoZPVFtdDorKaA8kJw.png"/></div></div></figure><p id="9241" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个项目中也很重要。</p><h1 id="6ef7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">算法</strong></h1><p id="ce41" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">两类分类的方法之一是逻辑回归。与直接估计响应值的线性回归不同，逻辑回归估计响应属于某类的概率。因为它是关于概率的，当模型形成S形时，通过逻辑回归获得的值在0和1之间。根据我选择的阈值，每一类有多少变化。所以选择一个合适的门槛至关重要。</p><p id="ab9d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个要考虑的方面是变量。由于我在数据集中有9个预测因子，我必须选择在预测反应中有意义的因子。在这里，我可以使用套索或岭回归。两者的区别在于他们如何给每个变量赋予权重。</p><div class="kx ky kz la fd ab cb"><figure class="li ij lj lk ll lm ln paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/099e1c794be4149870719c7a34d04910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*rFQWAxVq7607dM_aXKYU2g.png"/></div></figure><figure class="li ij lo lk ll lm ln paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/39ad7722a104bcb12fcf87e0c0aa082d.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*mchsWtNTyfHJ0_unnURU4Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx lp di lq lr translated">lasso和ridge如何用系数区别对待无关紧要的变量|(左)lasso /(右)ridge</figcaption></figure></div><p id="fe72" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Lasso保留重要变量，但对无关紧要的变量给出0系数。另一方面，ridge总是在每个变量上保留不同权重的所有变量。因此，当几乎没有强有力的预测因素，并且所有其他因素都不重要时，套索往往能很好地发挥作用。相反，当大多数变量对响应具有同样强的能力时，脊是优选的。在执行任何分析之前，无法知道数据集中的真实关系。因此，我将在这个项目中使用这两种方法。</p><p id="ecb2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">即使我有逻辑回归进行分类，也有其他方法更好的时候。当类被很好地分开或当样本量很小时，逻辑回归往往是不稳定的。所以在这些情况下，用线性判别分析——LDA会更好。</p><p id="1538" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">LDA首先假设观测值来自具有特定类别的均值向量和共同方差的高斯分布。然后，它将来自假设的估计值插入到贝叶斯分类器中，以预测观测值属于某个类别的概率。</p><p id="8b96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与LDA不同，二次判别分析(QDA)假设每个类别都有自己的协方差矩阵。这导致了偏差-方差权衡的差异。因为LDA假设共享协方差矩阵，所以它不如QDA灵活。因此，LDA具有较低的方差。然而，如果假设不成立，就会导致LDA中的高偏差。</p><p id="5951" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，《统计学习简介》一书的作者说</p><blockquote class="lt"><p id="387d" class="lu lv hi bd lw lx ly lz ma mb mc js dx translated">如果训练观测值相对较少，LDA往往比QDA更好，因此减少方差至关重要。相比之下，如果训练集非常大，因此分类器的方差不是主要问题，或者如果K个类的公共协方差矩阵的假设明显不成立，则推荐使用QDA(James，150)。</p></blockquote><h1 id="c9e3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke md kg kh ki me kk kl km mf ko kp kq bi translated"><strong class="ak">数据预处理</strong></h1><p id="0536" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">多亏了Sumat Singh，数据集已经相当整洁了。所以我只需要稍微调整一下，就能符合我项目的目的了。因为我是根据一首歌是如何创作的来预测我是否喜欢这首歌，所以诸如年份和流行度之类的列是不合适的。因此，我删除了它们。</p><pre class="kx ky kz la fd mg mh mi mj aw mk bi"><span id="62bc" class="ml ju hi mh b fi mm mn l mo mp">spotify.top2000 = read.csv("spotify_top2000_sample_labeled.csv")<br/>spotify.top2000.s = spotify.top2000[,c(3,5,8:16)]</span></pre><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/fd3055e8fcbec22cd58f8dbd3d9831ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*en43Kd8Wyw0jP3P3TM0MiQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">删除不必要的列后spotify数据集的前三行</figcaption></figure><p id="1ab9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上面可以看出，预测值的范围变化很大。这将导致一个问题，当我执行脊和套索回归，因为他们不是规模等变。这意味着，不管真实的关系如何，1000厘米比1美元的影响要大得多，因为1000是一个比1大得多的数字。因此，我将所有预测值标准化为均值为0，标准差为1。</p><pre class="kx ky kz la fd mg mh mi mj aw mk bi"><span id="677d" class="ml ju hi mh b fi mm mn l mo mp">predictors.sca = scale(spotify.top2000.s[,-c(1,2)])<br/>response = spotify.top2000.s$Like</span><span id="7d72" class="ml ju hi mh b fi mr mn l mo mp">predictors.sca.df = as.data.frame(predictors.sca)<br/>predictors.sca.df$Like = response</span></pre><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/6ec2a5efc270ff30b59cc35fe9db42f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Pw4CV8ew59L9J6HhMAKAw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">标准化预测值后spotify数据集的前三行</figcaption></figure><p id="fd7e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我将数据集随机分成50:50比例的训练集和测试集，用测试集在后面的步骤中评估哪个模型优于其他模型。</p><pre class="kx ky kz la fd mg mh mi mj aw mk bi"><span id="9db1" class="ml ju hi mh b fi mm mn l mo mp"># set.seed(1) for reproducibility<br/>set.seed(1)<br/>train = sample(1:nrow(predictors.sca), nrow(predictors.sca)/2)<br/>test = (-train)<br/>response.test = response[test]</span></pre><p id="791e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是因为原始数据集是不平衡的，所以训练集也是不平衡的。解决这个问题的一种方法是对训练集进行上采样或下采样，这两种方法各有利弊。</p><p id="e395" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下采样是通过从多数类中移除一些观察值以粗略匹配多数类和少数类之间的观察值数量来实现的。这种方法的一个缺点是我可能会丢失有价值的信息，因为它删除了数据集的一部分。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/45b0580c976c615a301e5277b768f333.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*hcRh5_Y1ecQZ-kHIoS91DQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">缩减采样的工作原理</figcaption></figure><p id="ca8f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相比之下，上采样在少数类中复制观察值。这样做的一个缺点是，由于原始数据集中没有的额外观察，它可能会给模型带来偏差。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/de26646c3a664a7afaec27f2502e5ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*_91HTlBWd2opQhTH5TYh0Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">上采样的工作原理</figcaption></figure><p id="d1ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以一般来说，当我有很多观察值时，下采样是合适的，这样删除一些观察值就不会影响模型的性能。在这个项目中，我没有足够的数据。因此，我认为上采样会更合适，并在我的训练集中使用了脱字符号包中的<em class="ls"> upSample() </em>。</p><pre class="kx ky kz la fd mg mh mi mj aw mk bi"><span id="152f" class="ml ju hi mh b fi mm mn l mo mp">train.up = upSample(x=predictors.sca[train,], <br/>                    y=as.factor(response[train]))<br/>colnames(train.up)[10] = "Like"</span></pre><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/9ac8536e41d38ba2cc8249481f96101a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kfXpyY_ms0bW1Edf4T0S6g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">上采样后的前几行以及0和1的数量</figcaption></figure><h1 id="c7a4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">实施</strong></h1><h2 id="cc8e" class="ml ju hi bd jv mw mx my jz mz na nb kd jg nc nd kh jk ne nf kl jo ng nh kp ni bi translated">逻辑回归</h2><p id="dddc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了用lasso实现逻辑回归，我首先创建了一个从1e+10到0.01的100个数字的列表，以测试识别最佳模型时的lambda值范围。该列表存储在<em class="ls">网格</em>变量中，并在函数构建逻辑回归模型时提供给<em class="ls"> glmnet() </em>。要使用脊而不是套索，我只需将<em class="ls"> alpha=1 </em>参数改为<em class="ls"> alpha=0 </em>。</p><pre class="kx ky kz la fd mg mh mi mj aw mk bi"><span id="2ac3" class="ml ju hi mh b fi mm mn l mo mp">grid = 10^seq(10, -2, length=100)</span><span id="eee7" class="ml ju hi mh b fi mr mn l mo mp">lasso.mod = glmnet(train.up[,1:9], train.up[,10], family="binomial",  <br/>                   alpha=1, lambda=grid)<br/>ridge.mod = glmnet(train.up[,1:9], train.up[,10], family="binomial", <br/>                   alpha=0, lambda=grid)</span></pre><p id="f5b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后通过<em class="ls">图()</em>，我可以直观地看到随着L1范数或L2范数的增加，变量是如何被包含或排除的，这对应于λ的减少。</p><div class="kx ky kz la fd ab cb"><figure class="li ij nj lk ll lm ln paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/5efd4b5bbd8bdfeb7fe99141c6f45f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*VzkH97Qkx8AqwwzDEnVGOw.png"/></div></figure><figure class="li ij nj lk ll lm ln paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/a2eaf57db2a6d911f5f72d63b289eb6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Za103ziCT1mJSCczJCqryg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx nk di nl lr translated">当lambda变化时，lasso和ridge之间如何不同地包含或排除预测因子|(左)lasso /(右)ridge</figcaption></figure></div><p id="457a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我必须为我的模型选择一个最佳的lambda值，所以我使用了与<em class="ls"> cv.glmnet() </em>的交叉验证来选择一个给出最低交叉验证误差的lambda值。利用从<em class="ls"> cv.10.out </em>变量获得的lambda值，我预测了测试集中的观察值属于某个类别的概率。</p><pre class="kx ky kz la fd mg mh mi mj aw mk bi"><span id="3f2f" class="ml ju hi mh b fi mm mn l mo mp">cv.10.out = cv.glmnet(as.matrix(train.up[,1:9]), <br/>                      as.integer(train.up[,10]), alpha=1,<br/>                      family="binomial", type.measure="class")<br/>bestlambda.l = cv.10.out$lambda.min</span><span id="682d" class="ml ju hi mh b fi mr mn l mo mp">lasso.probs = predict(lasso.mod, s=bestlambda.l, <br/>                      newx=predictors.sca[test,], type="response")</span></pre><p id="905b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常，当你考虑两类分类时，比如掷硬币，你会认为每一类都有50%的机会发生。因此，人们可能会尝试使用0.5作为阈值。然而，在这个项目中，情况有所不同。</p><p id="3431" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，测试集是不平衡的。所以每一类发生的概率都不是0.5，所以套用0.5作为阈值是没有意义的。其次，我要使用的度量标准不是一个错误分类的错误。因此，我需要使用不同度量的交叉验证来选择概率阈值。</p><p id="54a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我在指标部分提到的，精确度和召回率将帮助我确定最佳模型。但是两者之间，哪个更重要呢？</p><p id="9bf8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个项目的目标是分发我喜欢的歌曲，这样我就不必花额外的时间去寻找它们。因此，拥有更高的精度比召回率更重要，并且有一种方法可以同时评估这两者。</p><p id="487e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">F1衡量标准是精确度和召回率之间的调和平均值，它同等地重视精确度和召回率。然而，在我的项目中，精度更为关键。因此，我没有使用F1度量，而是使用了F0.5度量，与F1度量相比，f 0.5度量使用了不同的公式，更加注重精度。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/2fa7463f11e1e00039012d5bdee348df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VSdJKljFxod6v8b8ULWvA.png"/></div></div></figure><p id="6f87" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我知道了用交叉验证来度量什么，我使用了一个for循环来遍历不同的概率阈值，并存储了F0.5度量，以便以后进行比较。</p><pre class="kx ky kz la fd mg mh mi mj aw mk bi"><span id="3c54" class="ml ju hi mh b fi mm mn l mo mp">probs.grid = seq(0,1,0.01)<br/>cv.error.precision = rep(0,101)<br/>cv.error.recall = rep(0,101)</span><span id="d325" class="ml ju hi mh b fi mr mn l mo mp">for (i in 1:101){<br/>    lasso.pred = rep(1, length(response.test))<br/>    lasso.pred[lasso.probs&lt;probs.grid[i]]=0<br/>    t = table(lasso.pred, response.test)</span><span id="e676" class="ml ju hi mh b fi mr mn l mo mp">    tunlike = t[1]<br/>    flike = t[2]<br/>    funlike = t[3]<br/>    tlike = t[4]</span><span id="2dcf" class="ml ju hi mh b fi mr mn l mo mp">    # this deal with cases when the table only has one row     <br/>    if (length(t)==2){<br/>        if (probs.grid[i]&lt;control.point){<br/>            tunlike = 0<br/>            flike = t[1]<br/>            funlike = 0<br/>            tlike = t[2]<br/>        }else{<br/>            tunlike = t[1]<br/>            flike = 0<br/>            funlike = t[2]<br/>            tlike = 0<br/>        }<br/>    }</span><span id="57cd" class="ml ju hi mh b fi mr mn l mo mp">    cv.error.precision[i] = tlike / (tlike+flike)<br/>    cv.error.recall[i] = tlike / (tlike +funlike)<br/>}</span><span id="ce09" class="ml ju hi mh b fi mr mn l mo mp">lasso.f0.5 = (1.25*cv.error.precision*cv.error.recall) /<br/>             (0.25*cv.error.precision+cv.error.recall)<br/>lasso.f0.5[is.na(lasso.f0.5)] = 0</span></pre><p id="bcc0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为具有较高F0.5度量的模型意味着该模型比其他模型更好，所以我从上一步中创建的<em class="ls"> lasso.f0.5 </em>列表中选择了一个给出最高F0.5度量的模型。然后，通过使用用于创建F0.5度量的概率阈值，我生成了如下所示的混淆矩阵。</p><pre class="kx ky kz la fd mg mh mi mj aw mk bi"><span id="5662" class="ml ju hi mh b fi mm mn l mo mp">lasso.pred = rep(1, length(response.test))<br/>lasso.pred[lasso.probs&lt;probs.grid[which.max(lasso.f0,5)]] = 0<br/>table(lasso.pred, response.test)</span></pre><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es nn"><img src="../Images/b93ff297f5df06467bf5fa27e90a749e.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*LXWWjdE6QWWEbrbf5Fz9Rg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">显示f0.5如何测量变化的图，以及来自具有最高f0.5值的逻辑回归(lasso)模型的混淆矩阵</figcaption></figure><p id="6f23" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，在23首被正面预测的歌曲中，有11首是真正的正面。所以模特给的歌有47.8%是我会喜欢的。</p><p id="eb89" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为从套索到脊的改变只需要改变一个参数，同样的过程可以用于脊的逻辑回归。正如你在下面看到的，这些是由山脊而不是套索产生的情节和混乱矩阵。在18首被正面预测的歌曲中，有8首是真正的正面。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es no"><img src="../Images/17d4be8f16759e49a5bce21020ad2839.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*BPB3MR7Fyn0sTXvF0UVkww.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">显示f0.5如何测量变化的图，以及来自具有最高f0.5值的逻辑回归(岭)模型的混淆矩阵</figcaption></figure><h2 id="70fd" class="ml ju hi bd jv mw mx my jz mz na nb kd jg nc nd kh jk ne nf kl jo ng nh kp ni bi translated">线性和二次判别分析</h2><p id="83cd" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">LDA遵循与逻辑回归相似的过程。首先，我制作了一个<em class="ls"> lda.fit </em>，它使用训练集来制作模型。然后，我提供了<em class="ls"> lda.fit </em>和测试集来预测每个观察值属于每个类的概率。最后，我使用for循环进行交叉验证，以选择合适的概率阈值。</p><pre class="kx ky kz la fd mg mh mi mj aw mk bi"><span id="1f55" class="ml ju hi mh b fi mm mn l mo mp">lda.fit = lda(Like~., data=train.up)<br/>lda.pred = predict(lda.fit, predictors.sca.df[test,])</span></pre><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es np"><img src="../Images/feccbf33004c8ae311a419bcf38472e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*iOvzPiwCwYK0ncyr7bHmew.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">LDA产生的概率</figcaption></figure><p id="5eb9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过交叉验证选择最佳模型，我得到了这个图和一个混淆矩阵。26首歌中，11首是真正的阳性。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es nn"><img src="../Images/2bdff6b7e6d375d7e4014f3017c36dd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*EhlABTn_56UZPfO4JzDWJg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">显示f0.5如何测量变化的图，以及来自具有最高f0.5值的LDA模型的混淆矩阵</figcaption></figure><p id="c266" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了使用<em class="ls"> qda() </em>代替<em class="ls"> lda() </em>之外，二次判别分析的过程完全相同。下面的图片是QDA的输出。与LDA不同，它给出了29首阳性歌曲，但只有12首是真正的阳性。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es nq"><img src="../Images/8265bd2d14f829ee2d33a4d6fa9648b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*_nZhYnceIst5zRGzJgqEMw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">显示f0.5如何衡量变化的图，以及来自具有最高f0.5值的QDA模型的混淆矩阵</figcaption></figure><h1 id="37a2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">模型评估</h1><p id="38cf" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">即使二次判别分析输出包含了最多的真阳性，我也应该考虑用户体验。作为一个想减少我寻找歌曲的时间的人，我不想在输出中有很多误报。因此，我认为使用lasso的逻辑回归识别与QDA相似数量的真阳性，但具有最低的假阳性率是更可取的。</p><p id="b05a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最初，我认为一个能够正确识别80%的正面标签歌曲并且在结果中给出少于20%的误报的模型将是一个好模型。不幸的是，我用逻辑回归模型得到的结果和我最初想的不太一样。测试结果有47%的假阳性，而不是20%。</p><p id="d9eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">即使预期和现实之间存在这种差异，该模型也比随机预测要好。在原始数据集中，300首歌曲中有227首被分类为不喜欢，73首被分类为喜欢。所以，如果我随机预测我可能喜欢的歌曲，大概只有24.3%的几率是正确的。考虑到模型的输出包含大约52.6%的真阳性，我相信这是一个改进。</p><h1 id="3b07" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">反思&amp;改进</strong></h1><p id="1187" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">项目中最具挑战性和最耗时的步骤是数据收集。由于没有数据集知道我喜欢或不喜欢什么歌曲，我不得不听所有的歌曲，并分别用0和1标记它们。正因为如此，这个项目花费的时间比我最初预计的要长。回过头来看，我想知道如果我先选择我喜欢的歌曲，然后随机添加我不喜欢的歌曲来制作样本数据集，是否会更节省时间，因为用这种方法我不必听所有花费大部分时间的歌曲。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nr"><img src="../Images/a9fb0e681b94f899963f291609f4f0bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80wYQf8AWtij7X0NzO92Qw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">新的数据收集方法如何工作/rawpixel.com<a class="ae iu" href="https://www.freepik.com/free-vector/digital-device-mockup_4122505.htm#page=1&amp;query=phone&amp;position=0" rel="noopener ugc nofollow" target="_blank">制作的手机图像</a></figcaption></figure><p id="19ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该模型缺乏的另一点是，它没有从结果中学习。在它输出结果并且我使用它之后，那就是一个循环的结束。因此，为了改进，如果我在单独确认积极标记的歌曲后，将结果添加到训练集中，可能会更好。通过这种改进，当我重复使用模型时，模型可能会随着时间的推移而改进。</p></div><div class="ab cl ns nt gp nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="hb hc hd he hf"><h1 id="a07b" class="jt ju hi bd jv jw nz jy jz ka oa kc kd ke ob kg kh ki oc kk kl km od ko kp kq bi translated">Github知识库</h1><p id="1249" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://github.com/bbeat2782/my_projects.git" rel="noopener ugc nofollow" target="_blank">https://github.com/bbeat2782/my_projects.git</a></p><h1 id="15aa" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">参考</h1><p id="9d80" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">[1]詹姆斯，加雷斯。<em class="ls">统计学习导论:在r中的应用</em>。斯普林格，2013。</p><p id="a02c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[2]辛格，苏马特。“Spotify——前所未有的2000年大数据集。”www.kaggle.com/iamsumat/spotify-top-2000s-mega-dataset.2020年2月4日<em class="ls">卡格尔</em></p></div></div>    
</body>
</html>