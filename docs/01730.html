<html>
<head>
<title>Algorithmic Trading with Williams %R in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现Williams %R的算法交易</h1>
<blockquote>原文：<a href="https://medium.com/codex/algorithmic-trading-with-williams-r-in-python-5a8e0db9ff1f?source=collection_archive---------0-----------------------#2021-05-25">https://medium.com/codex/algorithmic-trading-with-williams-r-in-python-5a8e0db9ff1f?source=collection_archive---------0-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ce36" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">学习用python建立一个强大的技术指标的杀手交易策略</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/567a850a9aceb0f5ede0c565c1561140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FJklM9vuFLTdhFMR"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">马克西姆·霍普曼在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="57e9" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">介绍</h1><p id="8890" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在查看由相对强弱指数和随机振荡指标组成的最受欢迎的动量指标列表时，我们今天要讨论的这个指标在考虑其在现实市场中的用途和效率时也加入了列表。不是别人，正是威廉姆斯夫妇。</p><p id="796e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在这篇文章中，我们将探讨威廉姆斯%R是什么，这个指标背后的数学，以及如何在python的帮助下建立基于它的交易策略。作为额外的一步，我们将比较我们的Williams %R策略回报与SPY ETF(一种专门设计用于跟踪标准普尔500指数走势的ETF)的回报，以了解我们的策略在现实市场中的表现如何，并可以作为评估策略的一个步骤。考虑到你的好奇心被激起，让我们深入这篇文章吧！</p><p id="b3d9" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在继续之前，如果你想在没有任何代码的情况下回溯测试你的交易策略，有一个解决方案。这是<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">的后验区</a>。这是一个平台，可以免费对不同类型的可交易资产的任意数量的交易策略进行回溯测试，无需编码。点击这里的链接，你可以马上使用这个工具:<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">https://www.backtestzone.com/</a></p><h1 id="6fbd" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">威廉姆斯%R</h1><p id="9c85" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">由拉里·威廉姆斯创立的威廉姆斯%R是一个动量指标，其值在0到-100之间波动。这个指标和随机振荡指标非常相似，但是计算方法不同。交易者使用这个指标，通过构建超买和超卖两个级别来发现交易的潜在进场点和出场点。在讨论超买和超卖水平之前，先说一句:当市场趋势看起来非常看涨并注定要盘整时，股票被认为是超买。类似地，当市场趋势似乎极度看跌并有反弹趋势时，股票到达超卖区域。超买和超卖水平的传统阈值分别是20和80，但也没有任何禁止采取其他价值。</p><p id="10a8" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">为了用14作为回望周期的传统设置来计算Williams %R的值，首先，确定14天时间范围内每个周期的最高价和最低价。然后，取两个差值:从最高价到收盘价，从最高价到最低价。最后，将第一个差值除以第二个差值，再乘以-100，以获得Williams %R的值。该计算可数学表示如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="699d" class="lm jp hi li b fi ln lo l lp lq"><strong class="li hj">W%R 14</strong> = [ <strong class="li hj">H.HIGH</strong> - <strong class="li hj">C.PRICE</strong> ] / [ <strong class="li hj">L.LOW</strong> - <strong class="li hj">C.PRICE</strong> ] * (<strong class="li hj"> - 100</strong> )</span><span id="6c70" class="lm jp hi li b fi lr lo l lp lq">where,<br/>W%R 14 = 14-day Williams %R of the stock<br/>H.HIGH = 14-day Highest High of the stock<br/>L.LOW = 14-day Lowest Low of the stock<br/>C.PRICE = Closing price of the stock</span></pre><p id="697e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这个指标的基本思想是，当它是一个强劲的上升趋势时，股票将不断达到新高，同样，当它跟随一个强劲的下降趋势时，股票将达到新低。话虽如此，我们还是来讨论一下本文中要实施的交易策略吧。</p><p id="ee19" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">关于我们的交易策略:</strong>有很多基于Williams %R的交易策略可以在现实市场中实施，但我们今天要讨论的是基于超买和超卖水平的策略。当威廉姆斯%R的前一个读数低于-20，当前读数高于-20时，该策略显示买入信号。同样，当威廉姆斯%R的前一个读数高于-80，当前读数低于-80时，就会产生卖出信号。我们的交易策略可以表述如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="76b4" class="lm jp hi li b fi ln lo l lp lq">IF <strong class="li hj">PREV.W%R</strong> &lt; [<strong class="li hj"> - 20 </strong>] AND <strong class="li hj">CURRENT.W%R</strong> &gt; [<strong class="li hj"> - 20</strong> ] ==&gt; <strong class="li hj">BUY SIGNAL</strong><br/>IF <strong class="li hj">PREV.W%R</strong> &gt; [ <strong class="li hj">- 80</strong> ] AND <strong class="li hj">CURRENT.W%R</strong> &lt; [ <strong class="li hj">- 80</strong> ] ==&gt; <strong class="li hj">SELL SIGNAL</strong></span></pre><p id="69b3" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这就结束了我们关于威廉姆斯%R的理论部分，它的计算和交易策略。现在，让我们用Python从头开始构建这个指标，构建我们讨论过的交易策略，在网飞数据上对其进行回溯测试，并将回报与SPY ETF的回报进行比较。事不宜迟，我们来做点编码吧！<strong class="ki hj">在继续之前，免责声明:本文的唯一目的是教育人们，必须被视为一个信息，而不是投资建议等。</strong></p><h1 id="98ff" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">用Python实现</h1><p id="fe52" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">编码部分分为以下几个步骤:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="7cca" class="lm jp hi li b fi ln lo l lp lq"><strong class="li hj">1. Importing Packages<br/>2. Extracting Stock Data from Twelve Data<br/>3. Williams %R Calculation<br/>4. Williams %R Indicator Plot<br/>5. Creating the Trading Strategy<br/>6. Plotting the Trading Lists<br/>7. Creating our Position<br/>8. Backtesting<br/>9. SPY ETF Comparison</strong></span></pre><p id="aadf" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h2 id="ddd7" class="lm jp hi bd jq ls lt lu ju lv lw lx jy kp ly lz ka kt ma mb kc kx mc md ke me bi translated">步骤1:导入包</h2><p id="b7e5" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="c20f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="c2ca" class="lm jp hi li b fi ln lo l lp lq">import pandas as pd<br/>import numpy as np<br/>import requests<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.rcParams['figure.figsize'] = (20,10)<br/>plt.style.use('fivethirtyeight')</span></pre><p id="269b" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在我们已经将所有需要的包导入到python中。让我们用12个数据的API端点来获取网飞的历史数据。</p><h2 id="04d3" class="lm jp hi bd jq ls lt lu ju lv lw lx jy kp ly lz ka kt ma mb kc kx mc md ke me bi translated">步骤2:从12个数据中提取数据</h2><p id="f0a1" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这一步，我们将使用由<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>提供的API端点提取网飞的历史股票数据。在此之前，请注意twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank"/>:十二数据公司是领先的市场数据提供商之一，拥有大量各种市场数据的API端点。它非常容易与十二数据提供的API进行交互，并且拥有有史以来最好的文档。此外，确保你有一个twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">的账户，只有这样，你才能访问你的API密匙(用API提取数据的重要元素)。</a></p><p id="430e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="3c4a" class="lm jp hi li b fi ln lo l lp lq">def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>nflx = get_historical_data('NFLX', '2020-01-01')<br/>nflx</span></pre><p id="d825" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mf"><img src="../Images/0747a9ec09e5eb6c9acbada9d6ee8faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHD0WARFDY3ylRw5Od970Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="77fd" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>我们做的第一件事是定义一个名为‘get _ historical _ data’的函数，该函数将股票的符号(‘symbol’)和历史数据的起始日期(‘start _ date’)作为参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们调用创建的函数从2020年开始提取网飞的历史数据，并将其存储到“nflx”变量中。</p><h2 id="e764" class="lm jp hi bd jq ls lt lu ju lv lw lx jy kp ly lz ka kt ma mb kc kx mc md ke me bi translated">步骤3:威廉姆斯%R计算</h2><p id="a625" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这一步中，我们将按照之前讨论的公式计算Williams %R的值。</p><p id="945e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="9696" class="lm jp hi li b fi ln lo l lp lq">def get_wr(high, low, close, lookback):<br/>    highh = high.rolling(lookback).max() <br/>    lowl = low.rolling(lookback).min()<br/>    wr = -100 * ((highh - close) / (highh - lowl))<br/>    return wr<br/><br/>nflx['wr_14'] = get_wr(nflx['high'], nflx['low'], nflx['close'], 14)<br/>nflx = nflx.dropna()<br/>nflx</span></pre><p id="c427" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/d13d3bf00cbc6e051a3a8a677a033f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVQ_A_1Uyii0qJwefwQNBw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="acde" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>我们首先定义一个名为“get_wr”的函数，它将股票的高价格数据(“高”)、低价格数据(“低”)、收盘价数据(“收盘”)和回望期(“周期”)作为参数。在该函数中，我们首先借助Pandas软件包提供的“滚动”和“最大”函数来确定特定回看时段内的最高高点，并将其存储到“high”变量中。“滚动”函数的作用是考虑我们指定的n周期时间框架，而“最大值”函数过滤给定数据框架中的最大值。</p><p id="0a9f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">接下来，我们将定义一个名为“lowl”的变量来存储指定回看周期时间范围内的最低低点，我们使用Pandas包提供的“滚动”和“最小”函数(顾名思义，过滤给定数据帧中的最小值)来确定该时间范围。</p><p id="4d2e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">然后，我们将确定的最高最高值和最低低值代入之前讨论的公式，计算Williams %R的值，并将其存储到“wr”变量中。最后，我们返回并调用创建的函数来存储网飞的Williams %R读数，其中14为回看周期。</p><h2 id="f476" class="lm jp hi bd jq ls lt lu ju lv lw lx jy kp ly lz ka kt ma mb kc kx mc md ke me bi translated">步骤4:威廉姆斯%R图</h2><p id="6650" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这一步中，我们将绘制计算出的网飞的Williams %R值，以便更好地理解它们。这一部分的主要目的不是在编码部分，而是观察情节，以获得对Williams %R技术指标的牢固理解。</p><p id="8715" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="22f7" class="lm jp hi li b fi ln lo l lp lq">ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(nflx['close'], linewidth = 2)<br/>ax1.set_title('NFLX CLOSING PRICE')<br/>ax2.plot(nflx['wr_14'], color = 'orange', linewidth = 2)<br/>ax2.axhline(-20, linewidth = 1.5, linestyle = '--', color = 'grey')<br/>ax2.axhline(-80, linewidth = 1.5, linestyle = '--', color = 'grey')<br/>ax2.set_title('NFLX WILLIAMS %R 14')<br/>plt.show()</span></pre><p id="f05a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/0ff4c5fa83478577c9dfe9c21e332439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h5PWUP67R7y2rx5m7J-Dbg.png"/></div></div></figure><p id="5e24" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">上面的图表分为两个面板:上面的面板是网飞股票数据的收盘价，下面的面板是网飞的Williams %R的14天读数。现在，该图表可以通过两种方式使用。第一种方法是使用图表作为工具来识别市场的超买和超卖状态。你可以观察到在市场的上方和下方有两条水平的灰色线，这是超买和超卖水平，分别位于-20和-80。如果威廉姆斯%R的读数高于上线或超买线，您可以认为市场处于超买状态。同样，如果威廉姆斯%R的读数低于较低的线或超卖线，你可以假设市场处于超卖状态。</p><p id="ce2c" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">使用威廉姆斯%R的第二种方法是识别市场中的虚假动量。在强劲的上升趋势中，威廉姆斯%R的读数往往达到-20以上。如果该指标下跌，并在下一次下跌前努力达到-20以上，表明市场的动力不是真实的，可能会出现巨大的下跌趋势。同样，在健康的下降趋势中，威廉姆斯%R的读数必然会经常低于-80。如果该指标上涨，但在下一次上涨前未能达到-80，表明市场将遵循积极的趋势。</p><p id="fd17" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">由于威廉姆斯%R是一个方向指标(其运动与实际市场的运动成正比)，交易者也用这个指标来寻找和确认市场中的强劲上涨趋势或下跌趋势，并沿着它进行交易。一些指标在用于识别或确认市场趋势时没有多大用处，因为它们可能在本质上是滞后的(考虑历史数据点以确定当前读数的指标)，但Williams %R是一个有效的指标，因为它是领先指标(考虑先前数据点以预测未来走势的指标)。</p><h2 id="8adc" class="lm jp hi bd jq ls lt lu ju lv lw lx jy kp ly lz ka kt ma mb kc kx mc md ke me bi translated">步骤5:创建交易策略</h2><p id="d587" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这一步中，我们将使用python实现讨论过的Williams %R交易策略。</p><p id="6bc0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="c815" class="lm jp hi li b fi ln lo l lp lq">def implement_wr_strategy(prices, wr):    <br/>    buy_price = []<br/>    sell_price = []<br/>    wr_signal = []<br/>    signal = 0<br/><br/>    for i in range(len(wr)):<br/>        if wr[i-1] &gt; -80 and wr[i] &lt; -80:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                wr_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                wr_signal.append(0)<br/>        elif wr[i-1] &lt; -20 and wr[i] &gt; -20:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                wr_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                wr_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            wr_signal.append(0)<br/>            <br/>    return buy_price, sell_price, wr_signal<br/>            <br/>buy_price, sell_price, wr_signal = implement_wr_strategy(nflx['close'], nflx['wr_14'])</span></pre><p id="742e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>首先，我们定义一个名为“implement_wr_strategy”的函数，它将股票价格(“prices”)和Williams %R指标(“wr”)的值作为参数。</p><p id="a427" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在该函数中，我们创建了三个空列表(buy_price、sell_price和wr_signal ),在创建交易策略时，将在这些列表中追加值。</p><p id="1921" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">之后，我们通过for循环实施交易策略。在for循环内部，我们传递某些条件，如果条件得到满足，相应的值将被追加到空列表中。如果购买股票的条件得到满足，买入价将被追加到“buy_price”列表中，信号值将被追加为1，表示购买股票。类似地，如果卖出股票的条件得到满足，卖价将被追加到“sell_price”列表中，信号值将被追加为-1，表示卖出股票。</p><p id="1949" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">最后，我们返回附加了值的列表。然后，我们调用创建的函数并将值存储到各自的变量中。除非我们画出这些值，否则这个列表没有任何意义。所以，让我们画出创建的交易列表的值。</p><h2 id="2d74" class="lm jp hi bd jq ls lt lu ju lv lw lx jy kp ly lz ka kt ma mb kc kx mc md ke me bi translated">步骤6:绘制交易信号</h2><p id="11c6" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这一步，我们将绘制已创建的交易列表，以使它们有意义。</p><p id="a9b0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="00cc" class="lm jp hi li b fi ln lo l lp lq">ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(nflx['close'], linewidth = 2)<br/>ax1.plot(nflx.index, buy_price, marker = '^', markersize = 12, linewidth = 0, color = 'green', label = 'BUY SIGNAL')<br/>ax1.plot(nflx.index, sell_price, marker = 'v', markersize = 12, linewidth = 0, color = 'r', label = 'SELL SIGNAL')<br/>ax1.legend()<br/>ax1.set_title('NFLX TRADING SIGNALS')<br/>ax2.plot(nflx['wr_14'], color = 'orange', linewidth = 2)<br/>ax2.axhline(-20, linewidth = 1.5, linestyle = '--', color = 'grey')<br/>ax2.axhline(-80, linewidth = 1.5, linestyle = '--', color = 'grey')<br/>ax2.set_title('NFLX WILLIAMS %R 14')<br/>plt.show()</span></pre><p id="8b2e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/738183f245cbb1618546bf0cc5cd6500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pfJN5nakp8trYxKMLM1lg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="2e19" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">代码解释:我们正在绘制威廉姆斯%R的读数以及交易策略产生的买入和卖出信号。我们可以观察到，当威廉姆斯%R线从下方穿越到-20以上时，图表中就会出现绿色的买入信号。类似地，当威廉姆斯%R线从上面交叉到-80和下面时，红色的卖出信号会出现在图表中。</p><h2 id="97ab" class="lm jp hi bd jq ls lt lu ju lv lw lx jy kp ly lz ka kt ma mb kc kx mc md ke me bi translated">步骤7:创建我们的职位</h2><p id="8b42" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在这一步中，我们将创建一个列表，如果我们持有股票，该列表将指示1；如果我们不拥有或持有股票，该列表将指示0。</p><p id="9923" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="d0cf" class="lm jp hi li b fi ln lo l lp lq">position = []<br/>for i in range(len(wr_signal)):<br/>    if wr_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(nflx['close'])):<br/>    if wr_signal[i] == 1:<br/>        position[i] = 1<br/>    elif wr_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = nflx['close']<br/>wr = nflx['wr_14']<br/>wr_signal = pd.DataFrame(wr_signal).rename(columns = {0:'wr_signal'}).set_index(nflx.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'wr_position'}).set_index(nflx.index)<br/><br/>frames = [close_price, wr, wr_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy.head()</span></pre><p id="44a5" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/1eac64a165e202b68a3d565525f8dae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VZZGzc0rLxMBmax61T20VQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="b6db" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>首先，我们创建一个名为‘position’的空列表。我们传递两个for循环，一个是为“位置”列表生成值，以匹配“信号”列表的长度。另一个for循环是我们用来生成实际位置值的循环。在第二个for循环中，我们对“signal”列表的值进行迭代，而“position”列表的值被附加到满足哪个条件上。如果我们持有股票，头寸的价值仍为1；如果我们卖出或不持有股票，头寸的价值仍为0。最后，我们正在进行一些数据操作，将所有创建的列表合并到一个数据帧中。</p><p id="4ad4" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">从显示的输出中，我们可以看到，在第一行中，我们在股票中的位置仍然是1(因为威廉姆斯%R信号没有任何变化)，但是当威廉姆斯%R交易信号代表卖出信号(-1)时，我们的位置突然变成-1。我们的头寸将保持为0，直到交易信号发生一些变化。现在是时候实现一些回溯测试过程了！</p><h2 id="6ea5" class="lm jp hi bd jq ls lt lu ju lv lw lx jy kp ly lz ka kt ma mb kc kx mc md ke me bi translated">步骤8:回溯测试</h2><p id="1d00" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在继续之前，有必要知道什么是回溯测试。回溯测试是查看我们的交易策略在给定股票数据上表现如何的过程。在我们的例子中，我们将对网飞股票数据的Williams %R交易策略实施回溯测试过程。</p><p id="0f0e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="9dbb" class="lm jp hi li b fi ln lo l lp lq">nflx_ret = pd.DataFrame(np.diff(nflx['close'])).rename(columns = {0:'returns'})<br/>wr_strategy_ret = []<br/><br/>for i in range(len(nflx_ret)):<br/>    returns = nflx_ret['returns'][i]*strategy['wr_position'][i]<br/>    wr_strategy_ret.append(returns)<br/>    <br/>wr_strategy_ret_df = pd.DataFrame(wr_strategy_ret).rename(columns = {0:'wr_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/nflx['close'][-1])<br/>wr_investment_ret = []<br/><br/>for i in range(len(wr_strategy_ret_df['wr_returns'])):<br/>    returns = number_of_stocks*wr_strategy_ret_df['wr_returns'][i]<br/>    wr_investment_ret.append(returns)<br/><br/>wr_investment_ret_df = pd.DataFrame(wr_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(wr_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the W%R strategy by investing $100k in NFLX : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the W%R strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre><p id="1fff" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="6bc9" class="lm jp hi li b fi ln lo l lp lq"><strong class="li hj">Profit gained from the W%R strategy by investing $100k in NFLX : 57772.45</strong><br/><strong class="li hj">Profit percentage of the W%R strategy : 57%</strong></span></pre><p id="fee3" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>首先，我们使用NumPy包提供的‘diff’函数计算网飞股票的回报率，并将其作为数据帧存储到‘nflx _ ret’变量中。接下来，我们传递一个for循环来迭代' nflx_ret '变量的值，以计算我们从Williams %R交易策略中获得的回报，这些回报值被追加到' wr_strategy_ret '列表中。接下来，我们将“wr_strategy_ret”列表转换为数据帧，并将其存储到“wr_strategy_ret_df”变量中。</p><p id="3901" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">接下来是回溯测试过程。我们将通过投资10万美元到我们的交易策略中来回测我们的策略。首先，我们将投资金额存储到“投资值”变量中。之后，我们将使用投资金额计算我们可以购买的网飞股票数量。你可以注意到，我使用了Math软件包提供的“下限”函数，因为当投资金额除以网飞股票的收盘价时，它会输出一个十进制数。股票数量应该是整数，而不是小数。使用“底数”函数，我们可以去掉小数。请记住,“floor”函数比“round”函数要复杂得多。然后，我们传递一个for循环来查找投资回报，后面是一些数据操作任务。</p><p id="b392" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">最后，我们打印了我们通过投资10万到我们的交易策略中得到的总回报，并且显示我们在一年中获得了大约57，000美元的利润。那还不错！现在，让我们将我们的回报与SPY ETF(一种旨在跟踪标准普尔500股票市场指数的ETF)的回报进行比较。</p><h2 id="ef26" class="lm jp hi bd jq ls lt lu ju lv lw lx jy kp ly lz ka kt ma mb kc kx mc md ke me bi translated">步骤9: SPY ETF对比</h2><p id="476f" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">这一步是可选的，但强烈推荐，因为我们可以了解我们的交易策略相对于基准(间谍ETF)的表现如何。在这一步中，我们将使用我们创建的“get_historical_data”函数提取SPY ETF的数据，并将我们从SPY ETF获得的回报与我们在网飞的Williams %R交易策略回报进行比较。</p><p id="a90e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="2297" class="lm jp hi li b fi ln lo l lp lq">def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/><br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('W%R Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre><p id="6a13" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">输出:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="d396" class="lm jp hi li b fi ln lo l lp lq"><strong class="li hj">Benchmark profit by investing $100k : 22431.5</strong><br/><strong class="li hj">Benchmark Profit percentage : 22%</strong><br/><strong class="li hj">W%R Strategy profit is 35% higher than the Benchmark Profit</strong></span></pre><p id="27e3" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">代码解释:</strong>这一步使用的代码几乎与前一个回溯测试步骤中使用的代码相似，但我们不是投资网飞，而是通过不实施任何交易策略来投资SPY ETF。从输出可以看出，我们的Williams %R交易策略已经跑赢SPY ETF 35%。太好了！</p><h1 id="0d3c" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">最后的想法！</h1><p id="12bf" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在Williams %R上经过一个粉碎理论和编码部分的漫长过程后，我们成功地建立了一个盈利的交易策略，其回报超过了间谍ETF。这很好，但这还不够。当我运行一个单独的回溯测试过程来获得更多关于我们的交易策略性能的信息时，我发现我们基于Williams %R的策略回报低于网飞股票的实际回报。这背后最重要的原因可能是策略优化。</p><p id="fcae" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">什么是策略优化？这是一个调整交易策略的过程，以达到最佳效果。调整策略，尤其是领先指标交易策略的最好方法是添加另一个技术指标作为过滤器。这个过滤器作为一个标尺，确保策略揭示的交易信号是真实的，而不是虚假的。在使用威廉姆斯%R时，这部分应该被认为是必不可少的，因为这个指标容易暴露很多错误的信号，最终导致我们做了糟糕的交易。回到策略优化，它不仅仅是增加另一个技术指标，还包括有效的风险管理步骤和更好的交易环境。</p><p id="84c0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如果你做到了这些，你就有了一个强大的交易算法，可以在现实市场中做更好的交易。所以我强烈推荐你尝试这些东西。你可能会问我，为什么我没有在文章中提到这些话题，因为文章的唯一动机不是鼓励人们创造有利可图的交易策略，从市场中赚钱，而是教育人们一个强大的交易指标。就是这样！您已到达文章结尾。希望你能从这篇文章中学到一些新的有用的东西。如果您忘记了遵循任何编码部分，不要担心。我在文章末尾提供了完整的源代码。</p><h2 id="8854" class="lm jp hi bd jq ls lt lu ju lv lw lx jy kp ly lz ka kt ma mb kc kx mc md ke me bi translated">完整代码:</h2><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="db5c" class="lm jp hi li b fi ln lo l lp lq">import pandas as pd<br/>import numpy as np<br/>import requests<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.rcParams['figure.figsize'] = (20,10)<br/>plt.style.use('fivethirtyeight')<br/><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>nflx = get_historical_data('NFLX', '2020-01-01')<br/>print(nflx)<br/><br/>def get_wr(high, low, close, lookback):<br/>    highh = high.rolling(lookback).max() <br/>    lowl = low.rolling(lookback).min()<br/>    wr = -100 * ((highh - close) / (highh - lowl))<br/>    return wr<br/><br/>nflx['wr_14'] = get_wr(nflx['high'], nflx['low'], nflx['close'], 14)<br/>nflx = nflx.dropna()<br/>pint(nflx)<br/><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(nflx['close'], linewidth = 2)<br/>ax1.set_title('NFLX CLOSING PRICE')<br/>ax2.plot(nflx['wr_14'], color = 'orange', linewidth = 2)<br/>ax2.axhline(-20, linewidth = 1.5, linestyle = '--', color = 'grey')<br/>ax2.axhline(-80, linewidth = 1.5, linestyle = '--', color = 'grey')<br/>ax2.set_title('NFLX WILLIAMS %R 14')<br/>plt.show()<br/><br/>def implement_wr_strategy(prices, wr):    <br/>    buy_price = []<br/>    sell_price = []<br/>    wr_signal = []<br/>    signal = 0<br/><br/>    for i in range(len(wr)):<br/>        if wr[i-1] &gt; -80 and wr[i] &lt; -80:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                wr_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                wr_signal.append(0)<br/>        elif wr[i-1] &lt; -20 and wr[i] &gt; -20:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                wr_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                wr_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            wr_signal.append(0)<br/>            <br/>    return buy_price, sell_price, wr_signal<br/>            <br/>buy_price, sell_price, wr_signal = implement_wr_strategy(nflx['close'], nflx['wr_14'])<br/><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(nflx['close'], linewidth = 2)<br/>ax1.plot(nflx.index, buy_price, marker = '^', markersize = 12, linewidth = 0, color = 'green', label = 'BUY SIGNAL')<br/>ax1.plot(nflx.index, sell_price, marker = 'v', markersize = 12, linewidth = 0, color = 'r', label = 'SELL SIGNAL')<br/>ax1.legend()<br/>ax1.set_title('NFLX TRADING SIGNALS')<br/>ax2.plot(nflx['wr_14'], color = 'orange', linewidth = 2)<br/>ax2.axhline(-20, linewidth = 1.5, linestyle = '--', color = 'grey')<br/>ax2.axhline(-80, linewidth = 1.5, linestyle = '--', color = 'grey')<br/>ax2.set_title('NFLX WILLIAMS %R 14')<br/>plt.show()<br/><br/>position = []<br/>for i in range(len(wr_signal)):<br/>    if wr_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(nflx['close'])):<br/>    if wr_signal[i] == 1:<br/>        position[i] = 1<br/>    elif wr_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = nflx['close']<br/>wr = nflx['wr_14']<br/>wr_signal = pd.DataFrame(wr_signal).rename(columns = {0:'wr_signal'}).set_index(nflx.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'wr_position'}).set_index(nflx.index)<br/><br/>frames = [close_price, wr, wr_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>print(strategy)<br/><br/>nflx_ret = pd.DataFrame(np.diff(nflx['close'])).rename(columns = {0:'returns'})<br/>wr_strategy_ret = []<br/><br/>for i in range(len(nflx_ret)):<br/>    returns = nflx_ret['returns'][i]*strategy['wr_position'][i]<br/>    wr_strategy_ret.append(returns)<br/>    <br/>wr_strategy_ret_df = pd.DataFrame(wr_strategy_ret).rename(columns = {0:'wr_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/nflx['close'][-1])<br/>wr_investment_ret = []<br/><br/>for i in range(len(wr_strategy_ret_df['wr_returns'])):<br/>    returns = number_of_stocks*wr_strategy_ret_df['wr_returns'][i]<br/>    wr_investment_ret.append(returns)<br/><br/>wr_investment_ret_df = pd.DataFrame(wr_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(wr_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the W%R strategy by investing $100k in NFLX : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the W%R strategy : {}%'.format(profit_percentage), attrs = ['bold']))<br/><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/><br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('W%R Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre></div></div>    
</body>
</html>