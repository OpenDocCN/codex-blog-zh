<html>
<head>
<title>Flutter User Authentication Part 1: Models and API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter用户认证第1部分:模型和API</h1>
<blockquote>原文：<a href="https://medium.com/codex/flutter-user-authentication-part-1-models-and-api-acf33cf42f83?source=collection_archive---------0-----------------------#2021-05-24">https://medium.com/codex/flutter-user-authentication-part-1-models-and-api-acf33cf42f83?source=collection_archive---------0-----------------------#2021-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9662b0522e9dd3d43d0fa8d502188081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mYRcBvkOQ76tt_9BuunQA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Artur Shamsutdinov 在<a class="ae iu" href="https://unsplash.com/s/photos/flutter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="36ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用户注册、进出几乎是每种应用的通用功能。在这个系列中，我将教你如何构建一个简单的认证系统。第1部分将介绍API调用和模型的基础知识。在第2部分中，我将教你如何使用Cubit包在你的应用程序中存储认证用户，在第3部分中，我们将学习如何在应用程序关闭后使用共享首选项包来维护登录<strong class="ix hj"> <em class="jt">。</em> </strong></p><p id="0f16" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">播客:<a class="ae iu" href="https://podcasts.apple.com/us/podcast/coreys-corner/id1479097455" rel="noopener ugc nofollow" target="_blank">https://podcast . apple . com/us/podcast/coreys-corner/id 1479097455</a></p><p id="a6d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一定要看看我的<a class="ae iu" href="https://www.youtube.com/watch?v=89jsvjHhBp4" rel="noopener ugc nofollow" target="_blank"> Flutter UI教程</a>！</p><h1 id="6541" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">创建基本API类:</h1><p id="8571" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">我们的第一步是构建一个BaseAPI类来保存我们API的所有URL。在我的<a class="ae iu" href="https://c0reygardner63.medium.com/making-flutterapi-calls-easy-38ef7ea4e5d4" rel="noopener"> <em class="jt">如何让Flutter API调用变得简单</em> </a> <em class="jt"> </em>中，我教了你如何使用类继承来简化和组织你的API调用。这个类并不复杂，它只是存储我们将要请求的路线，查看下面的代码。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="cf1c" class="lg jv hi lc b fi lh li l lj lk">Class BaseAPI{</span><span id="0186" class="lg jv hi lc b fi ll li l lj lk">    static String base = "http://localhost:3000"; <br/>    static var api = base + "/api/v1";<br/>    var customersPath = api + "/customers";<br/>    var authPath = api + "/auth"; <br/>   // more routes</span><span id="b284" class="lg jv hi lc b fi ll li l lj lk">   Map&lt;String,String&gt; headers = {                           <br/>       "Content-Type": "application/json; charset=UTF-8" };                                      <br/>              <br/>}</span></pre><p id="f0cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最终创建我们的基类使我们更容易管理我们的API端点。</p><h1 id="7f04" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">创建客户API类</strong></h1><p id="e969" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">接下来，我们将创建一个类来存储所有用于客户身份验证的API调用。</p><p id="66f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用darts <a class="ae iu" href="https://flutter.dev/docs/cookbook/networking/fetch-data" rel="noopener ugc nofollow" target="_blank"> HTTP库</a>发出请求，我们发送的任何数据都将以JSON格式编码。每个请求将返回一个HTTP响应类型的Future。在我们的小部件中，我们将使用响应的statusCode属性来确定我们的调用是否成功。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="8f6f" class="lg jv hi lc b fi lh li l lj lk">import 'dart:convert';<br/><br/>import 'package:resteraunt_starter/api/BaseAPI.dart';<br/>import 'package:http/http.dart' as http;<br/><br/>class AuthAPI extends BaseAPI {</span><span id="5818" class="lg jv hi lc b fi ll li l lj lk">  Future&lt;http.Response&gt; signUp(String name, String email, String phone,<br/>      String password, String passwordConfirmation) async {<br/>    var body = jsonEncode({<br/>      'customer': {<br/>        'name': name,<br/>        'email': email,<br/>        'phone': phone,<br/>        'password': password,<br/>        'password_confirmation': passwordConfirmation<br/>      }<br/>    });<br/><br/>    http.Response response =<br/>        await http.post(super.customersPath, headers: super.headers, body: body);<br/>    return response;<br/>  }<br/><br/>  Future&lt;http.Response&gt; login(String email, String password) async {<br/>    var body = jsonEncode({'email': email, 'password': password});<br/><br/>    http.Response response =<br/>        await http.post(super.authPath, headers: super.headers, body: body);<br/><br/>    return response;<br/>  }<br/><br/><br/>  Future&lt;http.Response&gt; logout(int id, String token) async {<br/>    var body = jsonEncode({'id': id, 'token': token});<br/><br/>    http.Response response = await http.post(super.logoutPath,<br/>        headers: super.headers, body: body);<br/><br/>    return response;<br/>  }<br/><br/>}</span></pre><p id="7e0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在是时候创建我们的客户类了！</p><h1 id="2c90" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">创建客户对象</h1><p id="af17" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">当我们创建一个对象时，我们就创建了我们自己的数据类型，我们创建了一个蓝图，概述了我们每个客户将拥有的所有属性。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="6d7f" class="lg jv hi lc b fi lh li l lj lk">import 'dart:convert';<br/><br/>class Customer{<br/>  int id;<br/>  String email;<br/>  String phone;<br/>  String name;<br/>  String token;<br/><br/>  User({this.id, this.email, this.phone, this.name, this.token});<br/><br/>  factory Customer.fromReqBody(String body) {<br/>    Map&lt;String, dynamic&gt; json = jsonDecode(body);<br/><br/>    return Customer(<br/>      id: json['id'],<br/>      email: json['email'],<br/>      name: json['name'],<br/>      phone: json['phone'],<br/>      token: json['token'],<br/>    );<br/><br/>  }<br/><br/>  void printAttributes() {<br/>    print("id: ${this.id}\n");<br/>    print("email: ${this.email}\n");<br/>    print("phone: ${this.phone}\n");<br/>    print("name: ${this.name}\n");<br/>    print("token: ${this.token}\n");<br/>  }<br/><br/>}</span></pre><p id="4f03" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们做的第一件事是创建类构造函数来初始化客户对象的新实例。我们使用<strong class="ix hj">工厂构造函数，因为可能有一段时间我们不需要创建一个全新的类实例。</strong>我们的工厂方法将从我们的API调用请求体接收一个JSON对象，我们将把它解码成一个动态类型字符串的映射&amp;。从他们那里，只需要将我们的客户属性设置为映射中相应的键。最后，<strong class="ix hj"> printAttributes() </strong> helper方法将打印出所有的属性及其值，这对调试非常有用。</p><h1 id="8138" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">在我们的小部件中</h1><h2 id="72a5" class="lg jv hi bd jw lm ln lo ka lp lq lr ke jg ls lt ki jk lu lv km jo lw lx kq ly bi translated">../身份验证/身份验证. dart</h2><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="5772" class="lg jv hi lc b fi lh li l lj lk">class Auth extends StatefulWidget {<br/>  @override<br/>  _AuthState createState() =&gt; _AuthState();<br/>}<br/><br/>class _AuthState extends State&lt;Auth&gt; {<br/>  bool showSignUp = true;<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return Scaffold(<br/>        appBar: AppBar(<br/>            title: Text(<br/>              "Corey's Corner",<br/>            ),<br/>          elevation: 16.0,<br/>          actions: [<br/>            IconButton(<br/>                icon: Icon(Icons.swap_horiz),<br/>                onPressed: () {<br/>                  setState(() {</span><span id="0612" class="lg jv hi lc b fi ll li l lj lk">                    showSignUp = !showSignUp;<br/>                  });<br/>                })<br/>          ],<br/>        ),<br/>        // ternary operator <br/>      body: Container(child: showSignUp ? SignUp() : SignIn()));<br/>  }<br/>}</span></pre><p id="bb89" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个小部件中，我们设置了一个容器来存放我们的Signup() &amp; SignIn()小部件。我们使用一个布尔函数在不同的页面之间来回切换，这样可以避免用户不得不编写push函数来访问不同的页面。</p><h2 id="07d3" class="lg jv hi bd jw lm ln lo ka lp lq lr ke jg ls lt ki jk lu lv km jo lw lx kq ly bi translated">../authentication/sign_in .镖</h2><p id="d316" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">为了简洁起见，我将把所有的表单、文本和按钮样式从图片中去掉，本教程将只讨论登录页面。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="4356" class="lg jv hi lc b fi lh li l lj lk">class SignIn extends StatefulWidget {<br/><br/>  @override<br/>  _SignInState createState() =&gt; _SignInState();<br/>}<br/><br/>class _SignInState extends State&lt;SignIn&gt; {<br/>  AuthAPI _authAPI = AuthAPI();<br/>  final _key =  GlobalKey&lt;FormState&gt;();<br/>  String email;<br/>  String password;<br/>  @override<br/>  Widget build(BuildContext context) {<br/><br/>    return  Container(<br/>        padding: EdgeInsets.symmetric(vertical: 20.0, horizontal: 25.0),<br/>        child: Form(<br/>            key: _key,<br/>            child: Column(<br/>              mainAxisAlignment: MainAxisAlignment.start,<br/>              children: &lt;Widget&gt;[<br/>                SizedBox(height: 70),<br/>                Text("Sign In", style: formTitleStyle(),),<br/>                SizedBox(height: 30),<br/>                Container(<br/>                    width: 400,<br/>                    child: TextFormField(<br/>                      decoration: textInputDecoration("Email", context),<br/>             onChanged: (val) =&gt; setState(() =&gt; email = val),<br/>                    )<br/>                ),<br/>                SizedBox(height: 30),<br/>                Container(<br/>                  width: 400,<br/>                  child: TextFormField(<br/>                    obscureText: true,<br/>                    decoration: textInputDecoration("Password", context),<br/>                    onChanged: (val) =&gt; setState(() =&gt; password = val),<br/>                  ),<br/>                ),<br/>                SizedBox(height: 25),<br/>                GestureDetector(<br/>                  child: Text("Forgot Password ?", style: TextStyle(<br/>                      fontSize: 18.0,<br/>                      decoration: TextDecoration.underline<br/>                  ),),<br/>                  onTap: (){<br/>                  // todo <br/>                  },<br/>                ),<br/>                SizedBox(height: 25),<br/>                Container(<br/>                    width: 400,<br/>                    child: customRaisedIconButton("Sign In !", Icons.send, context, () async {<br/>                      if(_key.currentState.validate()){<br/>                        try{<br/>                          var req = await <br/>                       _authAPI.login(email,  password);<br/>                          if(req.statusCode == 200){</span><span id="5ad4" class="lg jv hi lc b fi ll li l lj lk">print(req.body);<br/>var customer = <br/>                              Customer.fromReqBody(req.body);</span><span id="4ed7" class="lg jv hi lc b fi ll li l lj lk">customer.printAttributes();<br/>                        Navigator.push(context, MaterialPageRoute(<br/>                         builder: (context) =&gt; MyHomePage(customer:                 customer)));<br/>                          } else {<br/>                            pushError(context);<br/>                          }<br/>                        } on Exception catch (e){<br/>                        print(e.toString());<br/>                        pushError(context);<br/>                        }<br/>                      }<br/>                    })<br/>                )<br/>              ],<br/>            )<br/>        )<br/>    );<br/>  }<br/>void PushError(){<br/>    Navigator.push(context, MaterialPageRoute(<br/>        builder: (context) =&gt; Error()<br/>    ));<br/>}</span></pre><p id="58ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们要做的第一件事是在状态中创建电子邮件和密码字符串。在文本表单中，我们调用setState将有状态字段设置为客户输入的值。在我们的API调用之前，我们将使用验证器来确保我们的电子邮件和密码不被泄露，这样我们就不会进行任何必要的API调用。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="67b1" class="lg jv hi lc b fi lh li l lj lk">AuthAPI _authAPI = AuthAPI();</span></pre><p id="29f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这行代码中，我们初始化了AuthAPI对象的一个实例，并将其存储在一个变量中。</p><p id="9a00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的API调用是<em class="jt">异步的</em>，因为我们必须等待我们的数据。我们使用<em class="jt"> await </em>语句来等待我们的请求。<strong class="ix hj">异步编程允许我们的代码非线性执行。</strong>我们将调用封装在try语句中，以捕捉任何错误，我们调用登录函数，并通过代码行将存储在state中的对象传递给它:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="dc4d" class="lg jv hi lc b fi lh li l lj lk">var req = await _authAPI.login(email,  password);</span></pre><p id="cce1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们收到请求，我们就使用它的statusCode属性来决定下一步做什么。如果我们的代码读取200，我们将把请求体属性(JSON类型)传递给客户模型的工厂构造函数。在那里，我们打印出用户的新属性、请求体并推送到主页。如果我们没有收到正确的statusCode或者我们捕捉到一个异常，我们就会进入一个错误页面。</p><p id="e2b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！在下一篇文章中，我们将讨论如何使用<a class="ae iu" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank"> Cubits </a>在我们的应用程序中存储我们的客户，使其对我们所有的小部件可用。</p><p id="56a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">务必检查<a class="ae iu" rel="noopener" href="/codex/flutter-user-authentication-part-2-storing-users-with-the-cubit-6d60c537ce82">第二部分</a>和<a class="ae iu" href="https://c0reygardner63.medium.com/flutter-user-authentication-part-3-persistent-login-with-shared-preferences-d0ffb64e1745" rel="noopener">第三部分</a>！</p><p id="dfe4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">学习编码:<a class="ae iu" href="https://www.youtube.com/channel/UCfd8A1xfzqk7veapUhe8hLQ" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/channel/UCfd8A1xfzqk7veapUhe8hLQ</a></p><p id="c5e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">播客:<a class="ae iu" href="https://podcasts.apple.com/us/podcast/coreys-corner/id1479097455" rel="noopener ugc nofollow" target="_blank">https://podcast . apple . com/us/podcast/coreys-corner/id 1479097455</a></p></div></div>    
</body>
</html>