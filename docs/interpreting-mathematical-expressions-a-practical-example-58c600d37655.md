# 解释数学表达式，一个实际的例子

> 原文：<https://medium.com/codex/interpreting-mathematical-expressions-a-practical-example-58c600d37655?source=collection_archive---------6----------------------->

## 解释高级的、基于表达式的用户输入，以大大增强您的工业或专业应用程序的可用性。

随着工业应用的发展，需要解释更复杂的用户输入，并且通常不需要很长时间就需要将数学表达式从用户(通常是工程师或机器操作员)传递给软件。

能够直接从最终用户或系统的某种形式的中间程序员那里获得复杂的数学输入的巨大优势应该是显而易见的:如果软件的设计者和开发者能够依靠他们的用户直接通过数学语言的复杂性来做他们自己的微调，而不是必须自己做所有的事情，这对于他们来说是一种极大的解脱。

当试图让软件解释表达式时，有很多方法可以实现。例如，您可以编写一个严格适用于特定领域的解释器，您可以编写一个硬编码数学的某个子集的解释器，或者您可以尝试编写一个更通用的计算机可识别的表达式解析器。

在尝试编写通用表达式解析器时，我开始编写 [IX。Math](https://www.nuget.org/packages/IX.Math/) 包(源代码可在 [GitHub](https://adrianmos.eu/Redirect?label=github-ix.math) 上获得，文档可在[这里](https://adrianmos.eu/Pages/Projects/ixmath.md)获得)，最初是作为一种练习数学和软件开发的方式，以及提供一种简单的方法来识别和评估数学，这是我想象中我女儿未来的学校项目。只是过了一段时间，在一个大型项目中用于解析用户输入之后，这个库才被纳入我的商业工作中。

在这篇文章中，我希望能够展示我在软件中识别表达式的方法，希望对这个主题有所启发，并希望能启发其他人。在任何时候，如果您希望看到更深入的实现，请参考库源代码。

# 序言:一种表达

让我们以一个非常复杂的数学表达式为例，它可以尽可能多地展示我们的基本解析需求:

> (x + 7 - 2 + 27*y + sin(x) ) / strlen("这是一个("+ s +")字符串")= ( min(x，y)*(37–2^z)+z)* 5

让我们分析一下这个表达包含了什么。

首先，我们有一个两边都是等式(注意中间的“=”号)。在左边，我们有函数( *sin* 和 *strlen* )，我们有括号中的表达式块，我们有字符串(包括字符串的连接)，这些字符串包含括号。在右边，我们有多层括号。两边都包含运算符、常量值和变量。这个表达式展示了数学表达式解析器应该具备的许多功能。

当[九世。Math](https://www.nuget.org/packages/IX.Math/) 遇到这个表达式，它开始多次运算，试图找出什么是什么。

# 第一个挑战:分解到最低限度

当处理复杂的常量表达式时，尤其是那些来自用户输入的表达式时，使我们的生活变得更容易的首要任务之一是尽可能多地取出复杂的常量，如果我们的算法中存在任何错误，这些常量可能会破坏我们的结果。

## 第一步:常数提取

从表述上看，目前最大的风险是字符串。不仅里面的括号可以被认为是表达式的一部分，而且谁知道用户输入的全部破坏性潜力是什么。因此，让我们用一些生成的名称替换字符串，并将字符串保存为单独的常量表达式。

> (x+7–2+27 * y+sin(x))/strlen(const 1+s+const 2)=(min(x，y)*(37–2^z)+z)* 5
> 
> 使用:
> 
> const1 = "这是一个("
> 
> const2 = ")字符串"

这是在第九章中实现的。数学是通过常量提取器实现的——这些类的目的是给定表达式并从中提取尽可能多的常量，也是库的第一个扩展点。

一旦我们有了所有特别认可的常数，让我们进入下一个挑战:子表达式

## 第二步:分解成多个表达式

我们看到的是，我们有一个复杂的表达式，可以相对容易地分解成多个子表达式。

让我们以括号为例。括号内的每个表达式都可以被看作是一个子表达式，它可以生成一个类似于主表达式的表达式树，这将清除我们的解释任务。让我们努力做到这一点:

> 子 expr1 / strlen(子 expr2) =子 expr4 * 5
> 
> 使用:
> 
> sub expr 1 = x+7–2+27 * y+sin(x)
> 
> subexpr2 =常量 1 + s +常量 2
> 
> sub expr 3 = 37–2^z
> 
> subexpr4 = min(x，y)*subexpr3+ z
> 
> const1 = "这是一个("
> 
> const2 = ")字符串"

现在，表达式看起来更容易管理了，不是吗？让我们继续，并确定我们看到了什么。

## 第三步:拿出所有我们知道的

让我们看看我们的主要表达，现在是:

> 子 expr1 / strlen(子 expr2) =子 expr4 * 5

让我们删除解析器可以识别的所有操作符。我们只剩下这个:

> 子 expr1 字符串(子 expr2)子 expr4 5

如果我们去掉所有我们已经认识到的东西，我们只剩下这个:

> strlen( ) 5

现在让我们看看我们能从中推断出什么。

首先，我们有一个函数，它叫 IX。数学可以通过名字后面的括号识别。在第九章。数学，函数是由库集合或任何其他被询问的集合中的类定义的，用特殊的属性修饰，告诉库在表达式中寻找什么，并且是 IX 中的第二个扩展点。数学(更多文档[此处](https://adrianmos.eu/Pages/Projects/ixmath/Functions.md))。 *strlen* ，在这种情况下，驻留在 IX 内部。数学，而且是公认的函数。

除此之外，我们还剩下 5，这是一个很容易被识别为原始类型的常数，瞧！我们已经认出了我们的表情。当然，其他子表达式也是如此。

这里要提到的一点是，如果我们有比“5”更复杂的东西，例如，我们需要能够定义某种方式来查看某个文本实际上是否是一个常量，或者更确切地说是一个外部参数。在第九章。数学，在这一步结束时没有被识别的任何东西都被认为是一个外部参数，所以在库中存在另一个扩展点是有意义的，即常数解释器——接收未被识别的文本以判断它们是否是常数的特殊类。

这一步完成后，我们的表情就剩下这种情况了:

> subexpr1 / subexpr5= subexpr4 * 5
> 
> 使用:
> 
> sub expr 1 = x+7–2+27 * y+sub expr 6
> 
> subexpr2 =常量 1 + s +常量 2
> 
> sub expr 3 = 37–2^z
> 
> subexpr4 = subexpr7*subexpr3+ z
> 
> subexpr5 = strlen(subexpr2)
> 
> subexpr6 = sin(x)
> 
> subexpr7 = min(x，y)
> 
> const1 = "这是一个("
> 
> const2 = ")字符串"
> 
> 带参数:x，y，s，z

…我们已经为下一步做好了准备。

# 第二个挑战:构建表达式树

既然我们已经尽可能清晰地表达了，是时候开始解释它们了。我们通过查看操作符将所有的表达式转换成表达式树，然后将表达式分成左右两个节点，直到没有任何节点需要分割，然后我们将所有的表达式连接起来，最终形成一个大的表达式树。

## 第四步:建造小树

我们拥有的每个表达式和子表达式都可以转换成一个[二进制表达式树](https://en.wikipedia.org/wiki/Binary_expression_tree)，然后进行计算。九。Math 通过为所有操作符设置优先级，然后根据优先级拆分表达式来实现这一点。让我们来看看最初的表述:

> subexpr1 / subexpr5= subexpr4 * 5

…让我们试着找到一个分割它的方法。

从这一点开始，使用绘制的图像来表达我们想要说的东西将会容易得多。

从数学上讲，优先级最低的运算符应该是等式运算符，因为它应该是最后一个被计算的。我们可以用它作为第一次分割，我们得到如下分割:

![](img/e168cf83ee17b57810d0a76301b21eb2.png)

我们表情的第一次分裂

然后我们可以继续下一个优先级，在左边的分支上，用除法运算符进行分割，就像这样:

![](img/ea29fe360ddc8e026cf2f81c1f100af2.png)

我们表情的第二次分裂

然后对于右侧:

![](img/856a1e943fafa592a0a58947e0c0ccd8.png)

第三次分裂为我们的表达

现在我们已经对主表达式进行了拆分，让我们对所有其他表达式进行同样的操作，让我们看看我们的小表达式树都排好队了。请注意，我已经根据节点的用途对其进行了着色。

![](img/c26a78d20ee0d0c660eddeb961a9e864.png)

第四个也是最后一个拆分为表达式

## 第五步:构建我们最后的树

构建过程的最后一步是将所有的子树连接成一棵更大的树:

![](img/bdbfb095ae94769ae0b51a7f1a04af4d.png)

最终表达式树

从这一点出发，就不难想出整棵树怎么解了。每个节点被要求提供它的值。根据节点的类型，每个节点请求其分支/叶的值，然后对它们进行一些操作。反过来，在父节点可以计算其值之前，也请求分支/叶(如果有的话)计算它们的值，然后根据其类型进行一些操作，等等。

查看上面的树，操作顺序如下:

> 请求“x”的值。加 7，然后减 2。
> 
> 7 乘以“x”的请求值，然后加上“x”的请求值的正弦。结果会添加到先前的值中。
> 
> 这是一个(“连接到所请求的值“s”，并具有”)连接到它的字符串。它的长度除以前一个值。
> 
> “x”和“y”的请求值的最小值乘以值 2，减去值 27 的“y”请求值的幂，加上“z”的请求值，然后全部乘以 5。
> 
> 将获得的值与先前获得的值相加得到结果。

简而言之，这就是算法以表达式树结束的方式。但是接下来呢？

# 第三个挑战:验证表达式

在获得如上所示的树之后，需要验证表达式，以确保它在逻辑上是合理的，并且可以计算出有用的东西。

## 第六步:验证可能性

可能性的验证从基节点向叶子进行。给定被识别的表达式，每个节点可能只能服务于一定范围的可能性，并且这应该在表达式树中被强制执行。

例如，从基节点开始的右分支。在加法运算符的结果和数字常数 5 之间有一个乘法运算符。当然，除非加法运算符的结果也是数字，否则这没有意义。这又迫使加法运算符具有数值结果，这意味着它的左分支(乘法运算符的结果，数值)和左叶(参数“z”)也必须是数值(或数值可转换的二进制)。在这个上下文中，参数“z”是一个字符串是没有意义的。

另一方面，如果我们从左分支的右分支看最下面的加法运算符，我们有一个添加到参数的字符串常量。在这种情况下，根据您的用户可能熟悉的大多数软件的规则，参数“s”可以取任何值:结果将是附加到字符串常量末尾的字符串表示。

九。Math 执行这一步骤，并检查每个节点(从其基节点)接收它可以产生的数据类型，并依次将其传输给其子节点。如果它不能提供这样的数据类型，节点将简单地停止验证过程，因为在这种情况下，表达式在逻辑上是不合理的。

让我们举一个逻辑上不合理的表达式的例子:

> (“+ x +”的第一部分很棒)^ 5

该表达式执行字符串连接，并尝试将结果字符串提升到 5 的幂。因为幂运算符不能处理字符串，所以表达式不会计算成逻辑有效的树。

## 步骤 7:确定性的验证

一旦可能性验证结束，可能会使节点(尤其是参数节点)仍然不确定它们应该包含什么数据类型。让我们举一个简单的例子:

> x + y

这个表达式看起来很简单，但实际上是一个口译员的噩梦。加法运算符，按照已建立的数学和计算机语言的规则，基本上是最通用的运算符:它可以做数学加法，它可以做字符串连接，它可以做数组拼接，等等。

当这样的表达式验证可能性时，它将两个参数都留在一个不确定的状态，因为它可能会接受我们可以扔给它的任何参数集:

1.  x = 5，y = 7，结果= 12
2.  x = 0101110111101001，y = 0000011110001001，结果= 0101110111110010010000111110001001
3.  x =“串是”，y =“漂亮”，结果=“串是漂亮”
4.  x = 5，y = "是数！"，Result = "5 是数字！"

…等等。

因此，一旦我们确定了参数实际拥有的数据类型，就有必要对我们的树进行自底向上的验证。

以上面的例子 1 和 3 为例。如果操作符是数字类型，那么操作的性质与字符串类型完全不同。然而，运营商有相同的符号。

九。一旦参数值已知，Math 通过反转其验证流程来解决这个问题，并以相反的节点顺序重复上述相同的过程。同样，如果在任何时候，节点值和父节点要求的值之间存在不一致，整个过程就会停止，因为表达式在逻辑上也是不合理的。

# 第四个挑战:计算

## 第八步:翻译

一旦表达式树被完全解释，它需要被翻译成可以执行的东西。

数学表达式被解释为一棵树，这绝不是巧合。。NET 提供了一个很好的方法，通过表达式树的方式将这样的树转换成可执行代码。

在深入本章之前，最好先熟悉一下[二进制表达式树](https://en.wikipedia.org/wiki/Binary_expression_tree)的概念，然后是微软的。NET 实现的[表达式树](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/)，因为这些知识对于理解正在发生的事情非常重要。

九。Math 的树不是严格意义上的二进制表达式树，也不是微软的实现，尽管它们最终会被编译成二进制表达式树。可识别表达式的复杂性和引擎的可扩展性对于任何一个来说都太大了，不能直接作为一个选项。例如，取一个带 3 个参数的函数(在 IX 中完全支持。数学):不再可以称之为“二叉树”了。

而是 IX。Math 将自己的一组节点保存在内存缓存中的某个地方，并且只在以下任一情况下将表达式翻译成它们的机器可执行的等价物:

1.  该表达式没有参数，它是一个常量表达式，在这种情况下会计算并缓存一个静态值
2.  该表达式仅具有特定类型的参数，该表达式被缓存为机器可执行的
3.  表达式已经被充分限定，因此没有可以有多种数据类型的参数，这是最典型的情况

您会注意到场景 1 是一个有趣的选项:如果表达式是静态的，那么我们可以静态地计算一个值。这是通过一个叫做简化的过程来完成的:如果满足条件，表达式有机会简化自己。

让我们以下面的表达式为例:

> x+10–2

这个表达式基本上相当于写 x+8，事实上，如果+运算符找到一组都是常数的叶节点，它将试图将其自身简化为常数表达式。通过这样做，它还可以提示本身是的叶的节点也简化成常数表达式，等等，直到根节点得到那个机会。如果最后一个根节点也是一个常量表达式，那么整个表达式将被缓存为一个常量值，该常量值将在解释表达式时返回。

当然，如果有任何节点，根据定义，不管它们的输入如何，都不提供常量值(像 *random* 函数)，这种情况就不会发生，但这将是另一篇文章的素材。

到目前为止，第三种情况应该是最常见的，也是本章的重点:当参数仍然不明确时会发生什么？

九。Math 缓存表达式节点，就像解释过程给它们的那样。当一组特定的参数类型已知时，就创建了节点集的完整副本，以及它的参数注册表，然后该注册表计算参数和具有参数的节点的结果类型(参见步骤 7)。如果达到的表达式在逻辑上不合理，IX。Math 缓存无效的结果，这样就不会一次又一次地解释带有这些参数类型的进一步请求。

如果达到一个逻辑上合理的表达式，那么 IX。Math 请求根节点将其自身转换为表达式。该节点反过来请求它的所有分支将自己转换成表达式，以此类推，当它拥有了它需要的所有子表达式时，它返回一个包含这些子表达式的表达式。

最后，IX。Math 从返回根表达式结果的原始表达式中创建一个块表达式，并查看它的参数注册表以了解它需要什么参数。块表达式成为 lambda 表达式的主体，其参数作为表达式本身的参数保存在参数注册表中。

然后，所有内容都存储到一个由表达式和参数类型定义的并发字典中，下一步就可以开始了。

## 第九步:执行

执行简单明了:从并发字典中获取 lambda 表达式委托，并使用它的参数集调用它。

九。在这种情况下，Math 多做了一步:如果表达式在逻辑上不合理，它将返回原始表达式。这背后的逻辑是用户输入很复杂。Math 不能自己决定它看到的是否是一个实际的表达式，或者用户只是想写一些 mathematicky 和库只是失控。因此，决定简单地返回原始表达式，因为无论是谁写的，都知道如何处理它。

# 结论和进一步阅读

这就是今天对识别数学表达式世界的所有尝试。我希望整个介绍清楚地表明，这个主题对于开发人员来说绝不是不可及的，甚至可能让您尝试自己做。虽然这不是一个容易或快速的任务，但它是可行的。

我会在最后留一些资源给你试用，让你了解和发现更多关于这个话题的内容:

*   二元表达式树概念:[https://en.wikipedia.org/wiki/Binary_expression_tree](https://en.wikipedia.org/wiki/Binary_expression_tree)
*   微软在。NET:[https://docs . Microsoft . com/en-us/dot NET/cs harp/programming-guide/concepts/expression-trees/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/)
*   九。数学源代码:【https://adrianmos.eu/Redirect?label=github-ix.math 
*   九。数学文档:[https://adrianmos.eu/Pages/Projects/ixmath.md](https://adrianmos.eu/Pages/Projects/ixmath.md)
*   九。数学 NuGet 包:[https://www.nuget.org/packages/IX.Math/](https://www.nuget.org/packages/IX.Math/)

如果你想了解更多关于其他人(可能比我聪明得多，受教育程度也高得多)如何解释数学表达式的信息，你可以查阅以下资源:

*   Edsger Dijkstra 的调车场算法:[调车场算法—维基百科](https://en.wikipedia.org/wiki/Shunting_yard_algorithm)
*   运算符优先级解析:[运算符优先级解析器—维基百科](https://en.wikipedia.org/wiki/Operator-precedence_parser)
*   LR 解析器: [LR 解析器—维基百科](https://en.wikipedia.org/wiki/LR_parser)
*   Shift-reduce 解析器: [Shift-reduce 解析器—维基百科](https://en.wikipedia.org/wiki/Shift-reduce_parser)

玩得开心！