# 我懂 Java，但不会搭建大型应用——象棋教程

> 原文：<https://medium.com/codex/i-know-java-but-i-cant-build-a-big-application-chess-tutorial-96c7f29aa66b?source=collection_archive---------3----------------------->

## 从头开始构建一个双人象棋游戏

![](img/1b8307f3399b7b2bf94bb4e9c87bc85e.png)

照片由 [Elisa Ventur](https://unsplash.com/@elisa_ventur?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

我遇到许多人，他们告诉我他们在编程方面的问题，他们都有一个共同的主题。

> 讲课和作业我都能听懂；但是我真的不知道怎么靠自己创造一个大项目。

三年前，我也在那个地方。想到要编写一千多行代码是非常令人畏惧和沮丧的。然而，有一天，我决定开始一个名为“象棋”的项目，4 个月后，它变成了我当时最大的项目。

[](https://github.com/cybercoder-naj/Chess) [## GitHub - cybercoder-naj/Chess:我用 IntelliJ IDEA 完全在 Java 上做的象棋程序

### 此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…

github.com](https://github.com/cybercoder-naj/Chess) 

# 我是如何开始我的项目的？

2018 年 12 月，我开始为我的项目写代码。我为继承了抽象类的每一部分创建了单独的类。然后我为棋盘和实际的游戏制作了一些工具类。然而，我到了一个地步，我不能设计任何逻辑来推进我的计划。我的程序中有几个问题。

1.  不可能包含“撤销”功能。
2.  检测到死锁或将死导致堆栈溢出错误。
3.  过滤掉非法移动也会导致 StackOverflow 错误。
4.  允许复杂的移动，像易位和顺道是不可行的。

所以在一月份，当我放弃这个项目时，**我删除了整个项目，只是为了从头再做一遍**。我后悔吗？号码

# 我是如何重启我的项目的？

我放弃了整个项目，开始用另一种方式思考程序——一种更加面向对象的方式。以下是我的改进(不幸的是，我并不精通 git，并且我没有项目的原始版本):

1.  我的`Board.java`是一个**单例对象**(以前只是一个实例)，在整个运行时保持*静态*。对该类进行了其他改进。
2.  我引入了另一个名为`Player.java`的类，它托管棋盘上所有的 16 个棋子，并为每一个可能的动作提供功能。
3.  我记录了每件物品最后的已知位置。这有助于确定非法移动和“撤销”移动(后来，在学习了状态的核心概念后，我意识到这仍然不是最好的解决方案)。

这个项目还有很多其他的改进，大约两个月后，我完成了我的象棋项目。但文章并没有到此结束。关于上面分享的 GitHub 库，我们将一部分一部分地讨论如何开始你的项目。

# #0 —规划阶段

> 软件工程的第一阶段是什么？
> 
> 这不是编码，也不是设计，而是规划。

扔掉我的初始程序后，我预见到了我需要写的代码；我需要创建的类和对象。

# 第一名——Board.java

要创建一个国际象棋游戏，你需要一个棋盘，然后是棋子，然后是玩家。从改进中，我们可以创建一个板将所有静态实例方法和数据成员。

如果你仔细观察`[Board.java](https://github.com/cybercoder-naj/Chess/blob/master/src/com/nishant/games/chess/game/Board.java)`，你会发现在整个程序中使用了一些静态定义的常量和一些帮助函数来在板上进行初始设置。我们还有一个打印电路板当前状态的函数。

# 第二名——Pieces.java

**免责声明:**我本应该把它命名为`Piece.java`，但是谁会坐下来回顾一个三年前的项目呢？

作为一名面向对象的程序员，我决定让每一部分都成为一个对象。自然，每件作品都有共同点，它们有共同的特征。它们是:

1.  棋盘上的当前点。
2.  棋盘上最后一个已知的点。
3.  演奏这首曲子的演奏者。
4.  这件作品还活着吗？
5.  返回所有合法移动的列表。
6.  将棋子移动到新的点。
7.  将棋子移动到最后一个已知点(撤消)。

如果你注意一下`[Pieces.java](https://github.com/cybercoder-naj/Chess/blob/master/src/com/nishant/games/chess/pieces/Pieces.java)`文件，你会发现所有这些细节都被写成了代码。第 5 点用**粗体**表示，因为— *虽然每个棋子都有不同的合法移动规则，但每个棋子都可以向玩家发出合法移动。这正是我们稍后要做的。*

# # 3—[件]。Java 语言（一种计算机语言，尤用于创建网站）

一旦我成功地编码了所有棋子的共同点，是时候定义每一个棋子的*实现*来检索它们的合法移动了。我有一个特殊的功能:

```
public List<Point> getMoves() {
  // ...
}
```

参照`Bishop.java`，你会发现这里还没有说明的几件事。这是因为，在开发过程中，代码被略微修改以给出正确的结果。`getMoves()`功能的逻辑是只获取特定棋子的所有可用合法移动**。**

你重复这个过程，想出棋盘上每个棋子的逻辑。

# 第四名——Player.java

播放器是输入/输出和后端进程之间的桥梁。我们可以收集关于状态的信息，并对棋盘上的每个棋子执行许多动作。

在我的文件中，我定义了如下几个函数:

```
public class Player { private Pieces[] pieces = new Pieces[16]; private void setPieces() {...}
  public Pieces getPiece(Point p) {...}
  public List<Point> getMoves() {...}
  public void killPiece(Piece p) {...}
  public void revivePiece(Piece p) {...}
}
```

还定义了一些函数，但它们对本教程并不重要。

# 第五名——Start.java

老实说，我不知道为什么要创建这个类，因为我可以把所有东西都塞进`Main.java`里。无论如何，我们必须实际上开始与用户输入交互，并将所有的类连接在一起，以制定游戏。很难解释我的代码是如何工作的。然而，基本的想法是:

1.  输入用户选择玩的棋盘上棋子的(x，y)坐标。
2.  运行验证检查，看看用户是否选择了他的作品。
3.  列出所选棋子的可用走法，并接受坐标来玩该棋子。
4.  对于交替的玩家，重复该过程多次。

你可以检查当一个玩家没有任何动作时游戏的终止。在这种状态下，如果玩家被过牌，就是将死，否则就是相持。

# 最后的想法

回头看看我在*年前*写的代码，我发现了许多我可以改进的地方。这是一件好事，因为它显示了你在编程方面的成长。没有一个程序是完美的。

如果你会编程，你就有能力创造一个大程序。从计划好程序开始，慢慢地构建微小的组件。稍后，开始连接这些组件，在应用程序中形成一个更大的功能。一开始，会让人望而生畏；但是如果你一开始不尝试，你将无法克服这个问题。

我希望你喜欢读我的文章，并学到了一些东西。谢谢大家！✌️

```
**Want to connect?**My [GitHub](https://github.com/cybercoder-naj) profile.
My [Portfolio](https://cybercoder-naj.github.io) website.
```