<html>
<head>
<title>OOP in JavaScript: Encapsulation, Inheritance, Polymorphism, Abstraction, and Association</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的OOP:封装、继承、多态、抽象和关联</h1>
<blockquote>原文：<a href="https://medium.com/codex/oop-in-javascript-encapsulation-inheritance-polymorphism-abstraction-and-association-2cbcd93bbb4f?source=collection_archive---------2-----------------------#2022-07-22">https://medium.com/codex/oop-in-javascript-encapsulation-inheritance-polymorphism-abstraction-and-association-2cbcd93bbb4f?source=collection_archive---------2-----------------------#2022-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/bcfff54eff7745d754425129750c1358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*XFVtjH6kCb1K0sSfSjjCng.png"/></div></figure><p id="f37c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">面向对象编程是一种常用的软件设计模式，是一种非常流行的编程范式。它用于以可重用、易读和可伸缩的方式构建代码。它涉及到类和对象的使用，几乎所有的编程语言都支持这种模式。</p><p id="f9cb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在JavaScript中，函数是对象。所以我们可以在不使用类的情况下实现OOP模式。</p><p id="6311" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们学习OOP的基础知识，并使用JavaScript实现它。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="1ca8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">类别和对象:</strong></p><p id="055e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">类是创建对象/变量的蓝图。它是包含属性和方法的自定义数据类型。对象是使用类的方法和属性的类的实例。让我们通过javascript来理解和实现这一点:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="be89" class="ka kb hi jw b fi kc kd l ke kf">class Animal{<br/>    constructor(name){<br/>        this.name = name;<br/>    }<br/>}</span><span id="ee7b" class="ka kb hi jw b fi kg kd l ke kf">// Let's create Object from the class Animal<br/>var animal = new Animal("Dog");</span></pre><p id="edcb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="kh"> A </em> <strong class="io hj"> <em class="kh">构造函数</em> </strong>是一个特殊的关键字，用来创建一个构造函数。在创建一个类的对象/实例时，总是自动调用构造函数。它隐式返回新创建的对象的实例。默认的构造函数内置于类中，我们通过实现自己的来覆盖它。<strong class="io hj"> <em class="kh"> new </em> </strong>关键字对于对象创建是必要的，因为它将告诉编译器调用构造函数。</p><p id="f6e9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在Javascript中，我们可以使用函数创建对象，而不使用class关键字。</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="9fbd" class="ka kb hi jw b fi kc kd l ke kf">function Animal(name){<br/>    this.name = name;<br/>}</span><span id="2efd" class="ka kb hi jw b fi kg kd l ke kf">var animal = new Animal("Dog");</span></pre><p id="54c3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是我们如何在javascript中从函数和类创建对象。现在我们知道了类和对象，让我们学习更多的OOP概念。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="3b7c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">封装:</strong></p><p id="d31e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">封装是隐藏和保护对象属性的过程。直接访问封装的属性是不可能的，我们必须提供其他机制来操作/读取这些数据。通常，这是通过将类变量属性设为私有并提供公共类方法来访问必要的数据来实现的。</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="0da9" class="ka kb hi jw b fi kc kd l ke kf">function Animal(val){<br/>    var name = val;<br/>    var publicApi = {<br/>        setName: function (val){<br/>            name = val;<br/>        },<br/>        getName: function (){<br/>            return name;<br/>        }<br/>    }<br/>    <br/>    return publicApi;<br/>}</span><span id="66a4" class="ka kb hi jw b fi kg kd l ke kf">var animal = new Animal("DOG");<br/>animal.setName("CAT");<br/>console.log(animal.getName());   output: CAT<br/>console.log(animal.name);        output: undefined</span></pre><p id="b84f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在上面的代码中，动物的<strong class="io hj"> <em class="kh"> name </em> </strong>属性不能直接访问，只能通过<strong class="io hj"> <em class="kh"> publicApi </em> </strong>方法访问。这是因为我们返回的publicApi对象没有name属性。它的属性(setName和getName)利用其词法范围中的Name属性。</p><p id="8150" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过class，这可以通过在变量名称前使用#使类变量私有来实现。</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="72d3" class="ka kb hi jw b fi kc kd l ke kf">class Animal{<br/>    #name;<br/>    constructor(name){<br/>        this.#name = name;<br/>    }<br/>    <br/>    setName(val){<br/>        this.#name = val;<br/>    }<br/>    <br/>    getName(){<br/>        return this.#name;<br/>    }<br/>}<br/>var animal = new Animal("DOG");<br/>animal.setName("CAT");<br/>console.log(animal.getName());    output: CAT<br/>console.log(animal.name);         output: undefined</span></pre><blockquote class="ki kj kk"><p id="24b4" class="im in kh io b ip iq ir is it iu iv iw kl iy iz ja km jc jd je kn jg jh ji jj hb bi translated">封装也可以通过用代码制作模块来完成</p></blockquote><p id="1415" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">摘要:</strong></p><p id="f0d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">抽象意味着隐藏实现细节，只显示行为。它是在设计级别完成的，而不是在应用程序级别实现的封装。通过抽象，只向用户显示必要的细节。</p><p id="09ca" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">考虑以下代码片段:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="79fa" class="ka kb hi jw b fi kc kd l ke kf">class Employee{<br/>    #name;<br/>    #baseSalary;<br/>    <br/>    <br/>    setName(val){<br/>        this.#name = val;<br/>    }<br/>    setBaseSalary(val){<br/>        this.#baseSalary = val;<br/>    }<br/>    <br/>    getName(){<br/>        return this.#name;<br/>    }<br/>    <br/>    getSalary(){<br/>        let bonus = 1000;<br/>        return this.#baseSalary + bonus;<br/>    }<br/>}<br/>var emp = new Employee();<br/>emp.setName("abc");<br/>emp.setBaseSalary(100);<br/>console.log(emp.getName());<br/>console.log(emp.getSalary());</span></pre><p id="f90e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">注意<strong class="io hj"> <em class="kh"> getSalary </em> </strong>方法是如何在最终用户不知道的后端更新薪水的。在实际应用中，可以从一些数据库中提取奖金，并将其添加到基本工资中。</p><p id="56c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过函数，这可以使用以下代码来完成:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="db08" class="ka kb hi jw b fi kc kd l ke kf">function Employee(){<br/>    let name;<br/>    let baseSalary;<br/>    <br/>    var publicApi = {};<br/>    <br/>    publicApi.setName = function (val){<br/>        name = val;<br/>    }<br/>    publicApi.setBaseSalary = function (val){<br/>        baseSalary = val;<br/>    }<br/>    <br/>    publicApi.getName = function (){<br/>        return name;<br/>    }<br/>    <br/>    publicApi.getSalary = function (){<br/>        let bonus = 1000;<br/>        return baseSalary + bonus;<br/>    }<br/>    return publicApi;<br/>}<br/>var emp = new Employee();<br/>emp.setName("abc");<br/>emp.setBaseSalary(100);<br/>console.log(emp.getName());<br/>console.log(emp.getSalary());<br/>console.log(emp.name);</span></pre></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="35e6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">传承:</strong></p><p id="bd9c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">继承是面向对象编程范式中的一个重要概念。这是一个子对象继承父对象属性的过程。在javascript中，继承内置于对象中，每个对象都有一个称为prototype的属性，该属性引用该对象的父对象，这一链一直向上，直到prototype指向null。</p><figure class="jr js jt ju fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/f4933451de63df032621a0b851639a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*ynd6bGI7YwpHgIjeA4WBcQ.png"/></div></figure><p id="f358" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如您在上面看到的，Obj有一个默认的prototype属性，它引用了Object，这是一个内置的数据类型。</p><p id="4fb3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们通过类和对象实现继承:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="726d" class="ka kb hi jw b fi kc kd l ke kf">class Person{<br/>    constructor(name){<br/>        this.name = name;<br/>    }<br/>    sayName(){<br/>        console.log(this.name);<br/>    }<br/>}</span><span id="f304" class="ka kb hi jw b fi kg kd l ke kf">class Student extends Person{<br/>    constructor(name, rollNumber){<br/>        super(name);<br/>        this.rollNumber = rollNumber;<br/>    }<br/>    logDetails(){<br/>        console.log(`Name: ${this.name}, Roll number: ${this.rollNumber}`)<br/>    }<br/>}<br/>var student = new Student("Heisenberg", 1);<br/>student.logDetails();    // Name: Heisenberg, Roll number:1<br/>student.sayName();       // Heisenberg</span></pre><p id="9547" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">学生类可以访问person类的所有属性。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="c54c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">多态性:</strong></p><p id="a2f8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">多态是以共享和覆盖父对象行为的方式设计对象的实践。</p><p id="0ae4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当一个属性被一个对象(无论是方法还是变量)引用时，该对象首先在自己的作用域中查找它，如果找不到，则向上一级，在父作用域中查找它。它会一直继续下去，直到找到那个属性，或者返回未定义的属性。javascript对象的这种行为可以以这样的方式被利用，即子对象可以在需要时覆盖它们的父对象的功能，而无需修改父对象。</p><p id="ea84" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在上面继承的代码中，student对象调用了<strong class="io hj"> <em class="kh"> sayName </em> </strong>函数，该函数不在Student类中，但在它的父类中，但它是可调用的。我们可以在学生类中覆盖这个函数，并定制它的行为。</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="0a76" class="ka kb hi jw b fi kc kd l ke kf">class Person{<br/>    constructor(name){<br/>        this.name = name;<br/>    }<br/>    sayName(){<br/>        console.log(this.name);<br/>    }<br/>}</span><span id="1ce4" class="ka kb hi jw b fi kg kd l ke kf">class Student extends Person{<br/>    constructor(name, rollNumber){<br/>        super(name);<br/>        this.rollNumber = rollNumber;<br/>    }<br/>    logDetails(){<br/>        console.log(`Name: ${this.name}, Roll number: ${this.rollNumber}`)<br/>    }<br/>    sayName(){<br/>        // do stuff<br/>        console.log("From Student");<br/>        super.sayName();<br/>    }<br/>}<br/>var student = new Student("Heisenberg", 1);<br/>student.logDetails();<br/>student.sayName();      // From Student   Heisenberg</span></pre><p id="c7dd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="kh"> super </em> </strong>关键字用于引用父对象并调用其方法。在这里，我们可以在<strong class="io hj"> Student.sayName </strong>方法中执行特定于学生的操作，然后可以将学生和Person类的其他子类的通用操作抽象为<strong class="io hj"> Person.sayName </strong>方法。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="73ff" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">联想:</strong></p><p id="8fa2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">关联是一种设计原则，通过这种原则，不同的对象可以相互关联以执行某些任务。它有两种类型:</p><p id="c43d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 1-聚合:</strong></p><p id="b605" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在聚合中，对象是松散耦合的，可以独立存在。这意味着一个对象即使在它的关联对象被销毁后也可以存在。</p><p id="8ad0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们通过javascript来实现它:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="a0de" class="ka kb hi jw b fi kc kd l ke kf">class Wall{<br/>    constructor(width, height){<br/>        this.width= width;<br/>        this.height = height;<br/>    }<br/>}<br/>class Room{<br/>    constructor(wall){<br/>        this.wall = wall;<br/>    }<br/>    print(){<br/>        console.log(this.wall);<br/>    }<br/>}</span><span id="577d" class="ka kb hi jw b fi kg kd l ke kf">var wall = new Wall(1,1);<br/>var room = new Room(wall);<br/>wall = null;<br/>room.print();</span></pre><p id="c68e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这里，墙和房间对象独立存在。</p><blockquote class="ki kj kk"><p id="68b9" class="im in kh io b ip iq ir is it iu iv iw kl iy iz ja km jc jd je kn jg jh ji jj hb bi translated">聚集也称为弱关联。</p></blockquote><p id="ac94" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> 2-构成:</strong></p><p id="b3d5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在构图中，对象是紧密耦合的，不能独立存在。</p><p id="aba0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面是组合的javascript实现:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="2478" class="ka kb hi jw b fi kc kd l ke kf">class Wall{<br/>    constructor(width, height){<br/>        this.width= width;<br/>        this.height = height;<br/>    }<br/>}<br/>class Room{<br/>    constructor(width, height){<br/>        this.wall = new Wall(width,height);<br/>    }<br/>    print(){<br/>        console.log(this.wall);<br/>    }<br/>}</span><span id="58ad" class="ka kb hi jw b fi kg kd l ke kf">var room = new Room(1,1);<br/>room.print();</span></pre><p id="1966" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们破坏房间对象，墙也会被破坏，因为它被包围在房间对象内。</p><blockquote class="ki kj kk"><p id="c53f" class="im in kh io b ip iq ir is it iu iv iw kl iy iz ja km jc jd je kn jg jh ji jj hb bi translated"><strong class="io hj">构图</strong>也叫强联想。</p></blockquote></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="b209" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">面向对象的应用非常广泛，所有现代软件都是基于面向对象架构的设计模式构建的。因此，要构建软件应用程序，必须对上述OOP概念有坚实的理解。</p></div></div>    
</body>
</html>