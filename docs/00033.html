<html>
<head>
<title>Protocol oriented programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向协议的编程</h1>
<blockquote>原文：<a href="https://medium.com/codex/protocol-oriented-programming-a566054c0fae?source=collection_archive---------2-----------------------#2019-11-05">https://medium.com/codex/protocol-oriented-programming-a566054c0fae?source=collection_archive---------2-----------------------#2019-11-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a5dbaf00d9fec51a4647bbbbfbe32230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWpwwGfgoJzjdTnKhYWUtA.png"/></div></div></figure><p id="d63d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated">面向协议的编程(<strong class="is hj"> POP </strong>)是一种随着Swift的出现而备受瞩目的范例。不同时期的不同语言都有一些流行的味道，但是Swift的流行中心有一些独特的特征，这使它们比<a class="ae jx" href="https://www.geeksforgeeks.org/object-oriented-programming-oops-concept-in-java/" rel="noopener ugc nofollow" target="_blank"> OOP </a>有明显的优势。这并不是说OOP有缺陷，或者POP是穿着闪亮盔甲的骑士。POP只是用一些新的东西扩展了OOP，从而有助于编写更好的代码，更好的系统</p><p id="a8ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jy">内容</em> </strong></p><p id="1179" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> a .现有系统示例</strong></p><p id="162c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> b .继承问题</strong></p><p id="0995" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> c .输入协议</strong></p><p id="50d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> d .协议扩展</strong></p><p id="9475" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> e .协议&amp;值类型</strong></p></div><div class="ab cl jz ka gp kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="hb hc hd he hf"><h2 id="0662" class="kg kh hi bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated"><strong class="ak"> 1。现有系统示例</strong></h2><p id="cc28" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">让我们举一个简单的例子来看看OOP和POP是如何处理同一个问题的。考虑到我们签订了建造一辆可以驾驶的汽车的合同。要求是，我们将被要求制造许多车辆，这些车辆将具有不同的颜色、车轮数量、不同的发动机容量等。从面向对象的世界来看，解决方案的核心应该是这样的</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/18c10aaf523c42c6d1fff99aff3b68d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BF3AD-IhKn5pM3SM2DDHyg.png"/></div></div></figure><p id="6614" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一切正常。<strong class="is hj"> <em class="jy">小型车</em> </strong>，<strong class="is hj"> <em class="jy">赛车</em> </strong>都可以驾驶。他们也可以有自己独特的特质。(<strong class="is hj"> <em class="jy"> noOfSeats() </em> </strong>，<strong class="is hj"><em class="jy">nitro booster capacity()</em></strong>等)。没有一个范例像OOP那样有效地映射真实世界，因此我们可以在对象建模中应用真实世界的原则，如<a class="ae jx" href="https://www.webopedia.com/TERM/O/object_oriented_programming_OOP.html" rel="noopener ugc nofollow" target="_blank">继承</a>。这就是它的美妙之处。</p><p id="7cc7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，现实世界远非完美，这渗透到它的衍生物如OOP中。考虑上面的同一个例子。客户现在已经与您签订合同，让您为现有类别的车辆开发雨刷。所以现在车辆可以被改装成能够擦拭</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e5e6f2d58ff8f1ff6a8a7158aafdeba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QxY5WmWUBHjXBeBMEHY-YA.png"/></div></div></figure><p id="f004" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">礼貌，继承，迄今为止创造的所有类别的车辆可以擦它的屏幕。<strong class="is hj"> <em class="jy">赛车</em> </strong>或<strong class="is hj"> <em class="jy">小型车</em> </strong>可以简单地叫<strong class="is hj"> <em class="jy">擦()</em> </strong>和<strong class="is hj"><em class="jy">start driving()</em></strong>安全在雨中！客户现在很高兴，因为你在构建系统方面如此出色，他现在要求引入一种新的交通工具，一种被称为摩托车的两轮车。第一反应会是将<a class="ae jx" href="https://www.geeksforgeeks.org/referencing-subclass-objects-subclass-vs-superclass-reference/" rel="noopener ugc nofollow" target="_blank">子类</a> <strong class="is hj"> <em class="jy">摩托车</em> </strong>从<strong class="is hj"> <em class="jy">车辆</em> </strong>。在这种情况下，<strong class="is hj">车辆<em class="jy">车辆</em>车辆</strong>就没用了。为什么？从语义上来说，摩托车是一种交通工具，所以我们应该能够使用<strong class="is hj"> <em class="jy">交通工具</em> </strong>类。但问题是如果一辆<strong class="is hj"> <em class="jy">摩托车</em> </strong>继承了<strong class="is hj"> <em class="jy">车辆</em> </strong>它也会继承<strong class="is hj"><em class="jy"/></strong>的能力。不必要的和荒谬的！所以如果我们不把<strong class="is hj"> <em class="jy">摩托车</em> </strong>从<strong class="is hj"> <em class="jy">车辆</em> </strong>中扩展出来，那么<strong class="is hj"> <em class="jy">车辆</em> </strong>中所有复杂的逻辑和业务规则，也就是说<strong class="is hj"><em class="jy">start driving()</em></strong>中的逻辑和业务规则，对于一辆<strong class="is hj"> <em class="jy">摩托车</em> </strong>都是不可用的。我们可以简单地争辩说，忽略一辆<strong class="is hj"><em class="jy"/></strong>摩托车中的<strong class="is hj"> <em class="jy"> wipe() </em> </strong>的能力，但那是故意在系统中引入一个不需要的关联。那么<strong class="is hj">我们的设计有什么问题？</strong></p><h2 id="5859" class="kg kh hi bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated"><strong class="ak">哎呀，OOP又来了！</strong></h2><p id="3022" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">子类可能不需要父类的所有特性。如果一个孩子有一个富有的酗酒的父亲，他会很高兴地选择继承他的财富，但会远离他父亲的酗酒恶习(但愿如此！).类似地，子类可能不需要其超类的所有特征。由于大多数语言不支持多重继承，我们不能将超类特性分成多个更小的类，并让子类继承所需的类。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c079403bec6cdff68836c552278bf1ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tNnXrZU2LM6yS4CxfklwrQ.png"/></div></div></figure><p id="2c2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">OOP在这方面做得并不好。</p><h2 id="78ca" class="kg kh hi bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated"><strong class="ak"> 2。继承问题</strong></h2><p id="ba58" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">继承是重用代码和构建软件的一个很好的机制，但是当涉及到选择性关联时，它就不是特别好了。<strong class="is hj"> <em class="jy">无论喜欢与否，被继承的类都被吸取在子类的DNA中</em> </strong>。这就像一个移动数据计划，它有很多你感兴趣的功能，但也有一些不足之处！如果单独出售，您可能不想要的功能。但既然这是计划的一部分，你就无法逃避。</p><h2 id="eedd" class="kg kh hi bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated"><strong class="ak"> 3。输入协议</strong></h2><p id="0f8c" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">自OOP本身以来，协议就已经存在，它提供了另一种设计和建模类的方法。让我们考虑上面的交通工具的例子，以及我们如何使用协议来设计同样的交通工具</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/faf66ffb6cddeaaf4693c003ccc90823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uS_CkSOEpR9YZVxan41hBQ.png"/></div></div></figure><p id="da37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我们所看到的，通过协议，我们已经能够在类<strong class="is hj"> <em class="jy">【摩托车】</em> </strong>继承<strong class="is hj"> <em class="jy">车辆</em> </strong>时，打破继承所强加的依赖性。现在任何不需要雨刷的<strong class="is hj"> <em class="jy">车辆</em> </strong>新品类都不会有同样的负担。它根本不符合它。不需要它，不要求它，所以不要背负它！例如用于小型摩托车。Swift中使用的协议通常在许多其他语言中作为抽象 <em class="jy">(虚拟类、接口等等)</em>来实现。没什么新东西。读者会注意到，现在需要定义驾驶逻辑的是实现<strong class="is hj"> <em class="jy">车辆</em> </strong>的具体类，即<strong class="is hj"> <em class="jy">赛车</em> </strong>和<strong class="is hj"> <em class="jy">小型赛车</em> </strong>现在必须定义如何<strong class="is hj"> <em class="jy">启动驾驶</em> </strong>()。这可能导致代码和逻辑的重复。此外，如果协议已经在许多其他语言中可用，那么Swift中的POP有什么特别之处呢？答案是协议扩展。</p><h2 id="7188" class="kg kh hi bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated"><strong class="ak"> 4。协议扩展</strong></h2><p id="876e" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">POP的基础是协议扩展。<strong class="is hj"> <em class="jy"> Swift (v2.0及以后)允许一个协议有一个通用的行为，也可以被覆盖</em> </strong>。默认情况下，这种通用行为允许每个实现“继承”它。如果他们不喜欢通用行为，那么很简单，改变它，即覆盖它。</p><p id="8d9c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jy">例如，上面的例子现在可以写成</em></p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f5878601edd2565860b47540f118e0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqzGS94F2MC5HHpXWNQhFg.png"/></div></div></figure><p id="fa65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就像继承与<strong class="is hj"> <em class="jy"> startWiper() </em> </strong>的额外关联现在被分解为一个需要的基础。车辆的每个实现现在都具有默认可用的复杂的<strong class="is hj"><em class="jy">start driving()</em></strong><em class="jy"/>逻辑，即它从协议“继承”了相同的逻辑。此外，摩托车与雨刷没有任何关联。因此，协议扩展有助于实现具有从协议“继承”的能力，并将依赖性保持在原子级别。也就是说，协议应该只包含实现或具体对象必须实现的那些契约。否则，它会出现胖接口问题。例如，<strong class="is hj"> <em class="jy"> Vehicle </em> </strong>是一个fat接口，因为它包含了并非所有子类都需要的<strong class="is hj"> <em class="jy"> startWiper() </em> </strong>。</p><p id="55b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 5。协议&amp;值类型</strong></p><p id="2582" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Swift提倡尽可能使用值类型而不是引用类型。两者的使用案例和优点都有很好的记录，在本文中不做讨论。像<strong class="is hj"> <em class="jy"> struct </em> </strong>，<strong class="is hj"> <em class="jy"> enum </em> </strong>这样的值类型也可以扩展协议，从而将使用协议设计的好处扩展到偶数值类型。这是苹果鼓吹使用协议而不是类的主要原因之一。</p><h2 id="056a" class="kg kh hi bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated"><strong class="ak">底线</strong></h2><p id="4aca" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">POP扩展了OOP以提供另一个抽象层次，帮助开发人员编写更好的代码和设计可重用的组件。在阳光下，每样东西都有它的位置，OOP当然不能完全被POP取代。仅在需要时。决定使用POP还是OOP可能是特定于上下文的</p></div></div>    
</body>
</html>