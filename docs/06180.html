<html>
<head>
<title>Chapter 02</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第02章</h1>
<blockquote>原文：<a href="https://medium.com/codex/chapter-2-d2a3afebd049?source=collection_archive---------17-----------------------#2022-04-11">https://medium.com/codex/chapter-2-d2a3afebd049?source=collection_archive---------17-----------------------#2022-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b0d6" class="pw-subtitle-paragraph ig hh hi bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dx translated"><strong class="ak"> <em class="if">类和对象</em> </strong></h2></div><p id="f257" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">类是对象的蓝图。它告诉VM如何创建一个特定类型的对象。</p><p id="6455" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj"> <em class="ju">制作物件。</em> </strong></p><p id="769c" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj"> 1。编写类。</strong></p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es jv"><img src="../Images/22a2610576a0c183dedef2773799fb6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/0*9BpL2R4WSLaaiByZ"/></div></figure><p id="8160" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj"> 2。编写一个测试类(TestDrive)。</strong></p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es jv"><img src="../Images/610ee451d804555d0fc7d1f5b93a19cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/0*cEHXfbO-1kRXnlYt"/></div></figure><p id="71b2" class="pw-post-body-paragraph iy iz hi ja b jb jc ik jd je jf in jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="ja hj"> 3。在测试类中，创建一个对象并访问该对象的变量和方法。</strong></p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es jv"><img src="../Images/fffcd311e96108015ddaec795ef7e0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/0*UWWRgwAehRDgONQ5"/></div></figure><h2 id="ebcb" class="kd ke hi bd kf kg kh ki kj kk kl km kn jh ko kp kq jl kr ks kt jp ku kv kw kx bi translated"><strong class="ak"> <em class="if"> Java拿出垃圾</em> </strong></h2><p id="45ca" class="pw-post-body-paragraph iy iz hi ja b jb ky ik jd je kz in jg jh la jj jk jl lb jn jo jp lc jr js jt hb bi translated">用Java创建的对象进入堆。Java堆实际上被称为“垃圾收集堆”。当您需要回收该空间时，会发生什么情况？当你使用完一个对象时，如何把它从堆中取出来呢？JVM可以“看到”一个对象再也不能被使用，这个对象就有资格进行垃圾收集。如果内存不足，垃圾收集器将运行，丢弃不可到达的对象，并释放空间，以便可以重用空间。</p><h2 id="dfa2" class="kd ke hi bd kf kg kh ki kj kk kl km kn jh ko kp kq jl kr ks kt jp ku kv kw kx bi translated">如果我需要全局变量，并且所有的东西都必须放在一个类中，那该怎么办？ </h2><p id="e751" class="pw-post-body-paragraph iy iz hi ja b jb ky ik jd je kz in jg jh la jj jk jl lb jn jo jp lc jr js jt hb bi translated">Java OO程序中没有“全局”变量和方法的概念。Phrase-O-Matic app中的random()方法；这是一个可以从任何地方调用的方法。作为公共和静态的方法使它的行为更像一个“全局”方法。应用程序的任何类都可以访问公共静态方法。public、static和final这样的变量实际上是一个全局可用的常量。</p><h2 id="aa1f" class="kd ke hi bd kf kg kh ki kj kk kl km kn jh ko kp kq jl kr ks kt jp ku kv kw kx bi translated"><strong class="ak"> <em class="if">如果还能做全局函数和全局数据，这怎么是面向对象？</em>T25】</strong></h2><p id="86e3" class="pw-post-body-paragraph iy iz hi ja b jb ky ik jd je kz in jg jh la jj jk jl lb jn jo jp lc jr js jt hb bi translated">pi的常量和random()的方法，虽然都是公共的和静态的，但都是在Math类中定义的。静态(类似全局)的东西在Java中是例外而不是规则，代表一种非常特殊的情况，它没有多个实例/对象。</p><h2 id="d453" class="kd ke hi bd kf kg kh ki kj kk kl km kn jh ko kp kq jl kr ks kt jp ku kv kw kx bi translated"><strong class="ak"> <em class="if">什么是Java程序，你实际交付的是什么？</em>T29】</strong></h2><p id="5c4f" class="pw-post-body-paragraph iy iz hi ja b jb ky ik jd je kz in jg jh la jj jk jl lb jn jo jp lc jr js jt hb bi translated">Java程序是一堆类，必须有一个main方法。如果最终用户没有JVM，那么您也需要将它包含在您的应用程序的类中，这样它就可以运行程序。有许多安装程序将类与各种JVM捆绑在一起，并把它们都放在CD-ROM上。然后，最终用户可以安装正确版本的JVM。</p><h2 id="ef76" class="kd ke hi bd kf kg kh ki kj kk kl km kn jh ko kp kq jl kr ks kt jp ku kv kw kx bi translated"><strong class="ak"> <em class="if">有几百个类怎么办？还是一千？交付所有这些单独的文件不是很痛苦吗？它能把它们捆绑成一个应用程序吗？</em> </strong></h2><p id="8b81" class="pw-post-body-paragraph iy iz hi ja b jb ky ik jd je kz in jg jh la jj jk jl lb jn jo jp lc jr js jt hb bi translated">将所有应用程序文件放入一个Java档案——一个. jar文件——它基于pkzip格式，在一个jar文件中，包含一个简单的文本文件，格式为一个叫做manifest的东西，它定义了jar中的哪个类包含应该运行的main()方法，</p><ul class=""><li id="d0ff" class="ld le hi ja b jb jc je jf jh lf jl lg jp lh jt li lj lk ll bi translated">一个对象知道的关于它自己的事情叫做实例变量。它们代表一个对象的状态。</li><li id="7755" class="ld le hi ja b jb lm je ln jh lo jl lp jp lq jt li lj lk ll bi translated">一个对象做的事情叫做方法。它们代表一个对象的行为。</li><li id="6ada" class="ld le hi ja b jb lm je ln jh lo jl lp jp lq jt li lj lk ll bi translated">一个类可以从一个更抽象的超类继承实例变量和方法。</li></ul></div></div>    
</body>
</html>