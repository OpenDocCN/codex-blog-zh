<html>
<head>
<title>Why You Should Upgrade Now: All The New Goodness In Python 3.11</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么您应该现在升级:Python 3.11中所有的新优点</h1>
<blockquote>原文：<a href="https://medium.com/codex/why-you-should-upgrade-now-all-the-new-goodness-in-python-3-11-998d8c31efb5?source=collection_archive---------1-----------------------#2022-10-26">https://medium.com/codex/why-you-should-upgrade-now-all-the-new-goodness-in-python-3-11-998d8c31efb5?source=collection_archive---------1-----------------------#2022-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a3397017a56dbfd1e384961c5b4906f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TE6MuPHh1rJCdTuJ3_iEAg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">安德斯·吉尔登在Unsplash<a class="ae iu" href="https://unsplash.com/s/photos/skyline?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></figcaption></figure><p id="de84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">新的Python 3.11版本已经发布，带来了一些不错的新特性和功能。该概述列出了说服您升级Python的最重要的更改。</p><p id="360b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://docs.python.org/3.11/whatsnew/3.11.html#" rel="noopener ugc nofollow" target="_blank">新版本</a>带来了Python中异常和异常处理的改进，一个用于处理TOML文件的新模块，解释器的改进，新的类型和特性，同时也摒弃了该语言的一些旧模块和API。此外，Python基准测试声称Python 3.11比Python 3.10快10-60%:你可以在这里看到结果<a class="ae iu" href="https://github.com/faster-cpython/ideas#published-results" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="6097" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">如何安装和升级</h1><h2 id="04cc" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">Linux操作系统</h2><p id="6483" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">在Linux(本例中是Ubuntu)上，您可以通过本地包管理器安装和更新Python。你可以使用<a class="ae iu" href="https://launchpad.net/~deadsnakes/+archive/ubuntu/ppa" rel="noopener ugc nofollow" target="_blank">死蛇PPA </a>来安装最新版本的Python。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="95f9" class="kr ju hi lp b fi lt lu l lv lw">sudo apt-get install software-properties-common<br/>sudo add-apt-repository ppa:deadsnakes/ppa</span></pre><p id="5bbb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">添加存储库后，您可以通过apt安装Python 3.11:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="1e7d" class="kr ju hi lp b fi lt lu l lv lw">sudo apt-get update<br/>sudo apt-get install python3.11</span></pre><h2 id="c871" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">马科斯</h2><p id="9ea5" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">在macOS上，我推荐使用软件包管理器<a class="ae iu" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">自制软件</a>。您可以通过以下方式安装homebrew:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="5096" class="kr ju hi lp b fi lt lu l lv lw">/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</span></pre><p id="7b67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">安装完homebrew，就可以安装Python 3.11了:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="5e30" class="kr ju hi lp b fi lt lu l lv lw">brew install python@3.11</span></pre><p id="1268" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，如果您已经通过homebrew安装了早期版本的Python(并更新了包管理器本身)，请通过以下命令将Python包升级到版本3.11:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="fd7f" class="kr ju hi lp b fi lt lu l lv lw">brew upgrade python -v 3.11</span></pre><h2 id="30e1" class="kr ju hi bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">Windows操作系统</h2><p id="3d95" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">在Windows上，有两种方法可以更新Python:通过Python安装程序或<a class="ae iu" href="https://chocolatey.org/" rel="noopener ugc nofollow" target="_blank"> Chocolatey </a>包管理器。你可以在官方<a class="ae iu" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank">下载页面</a>上找到Python安装程序，它会引导你完成整个过程。如果您想使用软件包管理器Chocolatey，您可以通过以下方式安装它:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="94ed" class="kr ju hi lp b fi lt lu l lv lw">Set-ExecutionPolicy Bypass -Scope Process -Force; \<br/>iex <strong class="lp hj">((</strong>New-Object System.Net.WebClient<strong class="lp hj">)</strong>.DownloadString<strong class="lp hj">(</strong>'https://chocolatey.org/install.ps1'<strong class="lp hj">))</strong></span></pre><p id="e3bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后可以使用Chocolatey通过命令行安装Python 3.11:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="d2ba" class="kr ju hi lp b fi lt lu l lv lw">choco install python -y --version 3.11</span></pre><p id="8d13" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者升级Python(如果已经安装):</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="3ef6" class="kr ju hi lp b fi lt lu l lv lw">choco upgrade python -y --version 3.11</span></pre><h1 id="0f3f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">例外组，除了*和注释</h1><p id="a2ed" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">现在可以同时引发和处理多个不相关的异常。新引入的类型<code class="du lx ly lz lp b">ExceptionGroup</code>可以捆绑不相关的异常:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="3008" class="kr ju hi lp b fi lt lu l lv lw">exceptions <strong class="lp hj">=</strong> ExceptionGroup(<br/>    "all",<br/>    [<br/>        TypeError(1),<br/>        ExceptionGroup("ex", [TypeError(2), ValueError(3)]),<br/>        ExceptionGroup("os", [OSError(4)])<br/>    ]<br/>)</span></pre><p id="e58f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些包给出了非常清晰的层次结构:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="c834" class="kr ju hi lp b fi lt lu l lv lw">import traceback<br/>traceback.print_exception(exceptions)</span><span id="5ff8" class="kr ju hi lp b fi ma lu l lv lw">| ExceptionGroup: all <strong class="lp hj">(</strong>3 sub-exceptions<strong class="lp hj">)</strong><br/>  +-+---------------- 1 ----------------<br/>    | TypeError: 1<br/>    +---------------- 2 ----------------<br/>    | ExceptionGroup: ex <strong class="lp hj">(</strong>2 sub-exceptions<strong class="lp hj">)</strong><br/>    +-+---------------- 1 ----------------<br/>      | TypeError: 2<br/>      +---------------- 2 ----------------<br/>      | ValueError: 3<br/>      +------------------------------------<br/>    +---------------- 3 ----------------<br/>    | ExceptionGroup: os <strong class="lp hj">(</strong>1 sub-exception<strong class="lp hj">)</strong><br/>    +-+---------------- 1 ----------------<br/>      | OSError: 4<br/>      +------------------------------------</span></pre><p id="b7c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以在这些异常组上使用匹配条件，您可以对它们进行子类化，为处理所谓的叶异常的<a class="ae iu" href="https://peps.python.org/pep-0654/#handling-exception-groups" rel="noopener ugc nofollow" target="_blank">构建自己的处理程序，等等。</a></p><p id="9188" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Python 3.11引入了一个新的(或增强的)关键字来更容易地处理异常组:<code class="du lx ly lz lp b">except*</code>。*字符应表示可以处理多个异常:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="1b64" class="kr ju hi lp b fi lt lu l lv lw"><strong class="lp hj">try</strong>:<br/>    ...<br/><strong class="lp hj">except*</strong> CustomError:<br/>    ...<br/><strong class="lp hj">except*</strong> OSError <strong class="lp hj">as</strong> e:<br/>    ...<br/><strong class="lp hj">except*</strong> (TypeError, ValueError) <strong class="lp hj">as</strong> e:<br/>    ...</span></pre><p id="ea2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://peps.python.org/pep-0654/" rel="noopener ugc nofollow" target="_blank"> PEP-0654 </a>的描述为新的<code class="du lx ly lz lp b">except*</code>关键字提供了额外的<a class="ae iu" href="https://peps.python.org/pep-0654/#except" rel="noopener ugc nofollow" target="_blank">文档</a>，例如<a class="ae iu" href="https://peps.python.org/pep-0654/#recursive-matching" rel="noopener ugc nofollow" target="_blank">递归匹配</a>、<a class="ae iu" href="https://peps.python.org/pep-0654/#raising-exceptions-in-an-except-block" rel="noopener ugc nofollow" target="_blank">在except*块中引发异常</a>或<a class="ae iu" href="https://peps.python.org/pep-0654/#chaining" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="6baf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">异常的基类<code class="du lx ly lz lp b"><a class="ae iu" href="https://docs.python.org/3.11/library/exceptions.html#BaseException" rel="noopener ugc nofollow" target="_blank">BaseException</a></code>也成为了一个新方法。添加此方法是因为在捕获并重新引发异常时可以添加附加信息。</p><blockquote class="mb mc md"><p id="9aea" class="iv iw me ix b iy iz ja jb jc jd je jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated"><code class="du lx ly lz lp b">add_note(note)</code></p><p id="f5bd" class="iv iw me ix b iy iz ja jb jc jd je jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated">将字符串<code class="du lx ly lz lp b">note</code>添加到异常注释中，该注释出现在异常字符串之后的标准回溯中。如果<code class="du lx ly lz lp b">note</code>不是字符串，则引发<code class="du lx ly lz lp b"><a class="ae iu" href="https://docs.python.org/3.11/library/exceptions.html#TypeError" rel="noopener ugc nofollow" target="_blank">TypeError</a></code>。</p></blockquote><h1 id="aab3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">欢迎新模块:tomllib</h1><p id="1083" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">Tom的显而易见的极简语言(<a class="ae iu" href="https://mostsignificant.github.io/python/2022/10/26/Tom's%20Obvious%20Minimal%20Language" rel="noopener ugc nofollow" target="_blank"> TOML </a>)旨在成为一种极简易读的配置文件格式。语法类似于INI文件——但是它提供了一个实际的标准，而INI有多种风格。TOML支持多种数据类型:字符串、整数、浮点、布尔、日期时间、数组和表格。因为它由键值对组成，所以它的结构可以轻松地解析为一个散列映射。以下是一个最小的例子:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="1d93" class="kr ju hi lp b fi lt lu l lv lw"><em class="me"># this is a TOML config file example</em></span><span id="ba57" class="kr ju hi lp b fi ma lu l lv lw">title = "Config"</span><span id="9ce0" class="kr ju hi lp b fi ma lu l lv lw">[general]<br/>name = "Database"<br/>created = 2022-11-26T08:30:00+02:00</span><span id="bf3f" class="kr ju hi lp b fi ma lu l lv lw">[database]</span><span id="3145" class="kr ju hi lp b fi ma lu l lv lw">  [database.connection]<br/>  server = "192.168.1.1"<br/>  ports = [ 8000, 8001, 8002 ]</span><span id="0b4e" class="kr ju hi lp b fi ma lu l lv lw">  [database.auth]<br/>  username = "root"<br/>  password = "root"</span></pre><p id="11bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在Python 3.11在标准库中增加了一个模块来解析TOML文件，名为<a class="ae iu" href="https://docs.python.org/3.11/library/tomllib.html#module-tomllib" rel="noopener ugc nofollow" target="_blank"> tomllib </a>。不幸的是，目前该模块只支持解析TOML文件，而不支持写入它们。如果你需要写功能，有两个备选方案:Tomli-W包和TOML工具包。</p><p id="b151" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，如果您只需要读取一个TOML文件，您可以使用标准库中的新模块。请注意，任何TOML文件都必须以二进制模式打开，这样<code class="du lx ly lz lp b">tomllib</code>才能在所有系统上正确处理UTF-8编码<a class="ae iu" href="https://peps.python.org/pep-0680/#types-accepted-as-the-first-argument-of-tomllib-load" rel="noopener ugc nofollow" target="_blank">。以下示例显示了如何解析上面的示例TOML文件:</a></p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="31ac" class="kr ju hi lp b fi lt lu l lv lw">import tomllib</span><span id="6222" class="kr ju hi lp b fi ma lu l lv lw"><strong class="lp hj">with</strong> open("config.toml", "rb") <strong class="lp hj">as</strong> f:<br/>    config <strong class="lp hj">=</strong> tomllib.load(f)</span><span id="416b" class="kr ju hi lp b fi ma lu l lv lw">    server <strong class="lp hj">=</strong> config['database']['connection']['server']<br/>    <strong class="lp hj">for</strong> port <strong class="lp hj">in</strong> config['database']['connection']['ports']:<br/>        <strong class="lp hj">print</strong>(f'{server}:{port}')</span></pre><p id="f979" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以在RealPython的文章中找到使用<code class="du lx ly lz lp b">tomllib</code>模块的其他提示和技巧，例如指定一个float方法来控制浮点数的解析和表示方式。</p><h1 id="2787" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">解释器改进</h1><p id="4ea8" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">Python 3.11赶上了更现代编译器的能力，现在还会指出导致错误的<a class="ae iu" href="https://docs.python.org/3.11/whatsnew/3.11.html#whatsnew311-pep657" rel="noopener ugc nofollow" target="_blank">特定表达式</a>，而不仅仅是指向下面的行:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="bbd3" class="kr ju hi lp b fi lt lu l lv lw">Traceback <strong class="lp hj">(</strong>most recent call last<strong class="lp hj">)</strong>:<br/>  File "distance.py", line 11, <strong class="lp hj">in</strong> &lt;module&gt;<br/>    print<strong class="lp hj">(</strong>manhattan_distance<strong class="lp hj">(</strong>p1, p2<strong class="lp hj">))</strong><br/>          ^^^^^^^^^^^^^^^^^^^^^^^^^^<br/>  File "distance.py", line 6, <strong class="lp hj">in </strong>manhattan_distance<br/>    <strong class="lp hj">return </strong>abs<strong class="lp hj">(</strong>point_1.x - point_2.x<strong class="lp hj">)</strong> + abs<strong class="lp hj">(</strong>point_1.y - point_2.y<strong class="lp hj">)</strong><br/>                           ^^^^^^^^^<br/>AttributeError: 'NoneType' object has no attribute 'x'</span></pre><p id="1bde" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，还有一个新的命令行选项<code class="du lx ly lz lp b">-P</code>，它和一个名为<code class="du lx ly lz lp b"><a class="ae iu" href="https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH" rel="noopener ugc nofollow" target="_blank">PYTHONSAFEPATH</a></code>的环境变量一起，禁止自动为<code class="du lx ly lz lp b"><a class="ae iu" href="https://docs.python.org/3.11/library/sys.html#sys.path" rel="noopener ugc nofollow" target="_blank">sys.path</a></code>预设潜在的不安全路径。这个特性可以集成到您的持续集成环境中，以确保安全性和可移植性。</p><blockquote class="mb mc md"><p id="0dde" class="iv iw me ix b iy iz ja jb jc jd je jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated"><code class="du lx ly lz lp b">-P</code></p><p id="57f2" class="iv iw me ix b iy iz ja jb jc jd je jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated">不要在<code class="du lx ly lz lp b"><a class="ae iu" href="https://docs.python.org/3.11/library/sys.html#sys.path" rel="noopener ugc nofollow" target="_blank">sys.path</a></code>前添加潜在的不安全路径:</p><p id="0410" class="iv iw me ix b iy iz ja jb jc jd je jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated"><code class="du lx ly lz lp b">python -m module</code>命令行:不要预置当前工作目录。</p><p id="5662" class="iv iw me ix b iy iz ja jb jc jd je jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated"><code class="du lx ly lz lp b">python script.py</code>命令行:不要前置脚本的目录。如果是符号链接，则解析符号链接。</p><p id="29ba" class="iv iw me ix b iy iz ja jb jc jd je jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated"><code class="du lx ly lz lp b">python -c code</code>和<code class="du lx ly lz lp b">python</code> (REPL)命令行:不要在前面加上空字符串，这意味着当前的工作目录。</p><p id="a0ee" class="iv iw me ix b iy iz ja jb jc jd je jf mf jh ji jj mg jl jm jn mh jp jq jr js hb bi translated">参见<code class="du lx ly lz lp b"><a class="ae iu" href="https://docs.python.org/3.11/using/cmdline.html#envvar-PYTHONSAFEPATH" rel="noopener ugc nofollow" target="_blank">PYTHONSAFEPATH</a></code>环境变量，以及<code class="du lx ly lz lp b"><a class="ae iu" href="https://docs.python.org/3.11/using/cmdline.html#cmdoption-E" rel="noopener ugc nofollow" target="_blank">-E</a></code>和<code class="du lx ly lz lp b"><a class="ae iu" href="https://docs.python.org/3.11/using/cmdline.html#cmdoption-I" rel="noopener ugc nofollow" target="_blank">-I</a></code>(隔离)选项。</p></blockquote><h1 id="9dff" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">更多类型和类型特征</h1><p id="363e" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">新版本带来了新的打字功能。下面几节将简要介绍它们。</p><h1 id="9ebe" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">可变泛型</h1><p id="d8fd" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">Python 3.5已经为用单一类型参数化的泛型带来了<code class="du lx ly lz lp b">TypeVar</code>。Python 3.11带来了<code class="du lx ly lz lp b">TypeVarTuple</code>，它允许用任意数量的类型进行参数化。以下示例来自<a class="ae iu" href="https://peps.python.org/pep-0646/" rel="noopener ugc nofollow" target="_blank"> PEP-646 </a>，展示了这一新功能的用法:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="72ae" class="kr ju hi lp b fi lt lu l lv lw">from typing import TypeVar, TypeVarTuple</span><span id="7af2" class="kr ju hi lp b fi ma lu l lv lw">DType <strong class="lp hj">=</strong> TypeVar('DType')<br/>Shape <strong class="lp hj">=</strong> TypeVarTuple('Shape')</span><span id="35be" class="kr ju hi lp b fi ma lu l lv lw"><strong class="lp hj">class</strong> <strong class="lp hj">Array</strong>(Generic[DType, <strong class="lp hj">*</strong>Shape]):</span><span id="3487" class="kr ju hi lp b fi ma lu l lv lw">    <strong class="lp hj">def</strong> <strong class="lp hj">__abs__</strong>(self) <strong class="lp hj">-&gt;</strong> Array[DType, <strong class="lp hj">*</strong>Shape]: ...<br/>    <strong class="lp hj">def</strong> <strong class="lp hj">__add__</strong>(self, other: Array[DType, <strong class="lp hj">*</strong>Shape]) <strong class="lp hj">-&gt;</strong> Array[DType, <strong class="lp hj">*</strong>Shape]: ...</span><span id="5df1" class="kr ju hi lp b fi ma lu l lv lw">from typing import NewType</span><span id="ad67" class="kr ju hi lp b fi ma lu l lv lw">Height <strong class="lp hj">=</strong> NewType('Height', int)<br/>Width <strong class="lp hj">=</strong> NewType('Width', int)</span><span id="25cc" class="kr ju hi lp b fi ma lu l lv lw">x: Array[float, Height, Width] <strong class="lp hj">=</strong> Array()</span></pre><h1 id="afbd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">将单个类型的直接项目标记为必需或非必需</h1><p id="0c16" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">现在可以标记<code class="du lx ly lz lp b">TypedDict</code>中的单个项目是否必须存在。默认情况下，为了向后兼容，所有字段仍然是必需的。然而，还有一个<code class="du lx ly lz lp b">total</code>参数可以设置为<code class="du lx ly lz lp b">False</code>:在这种情况下，默认情况下<code class="du lx ly lz lp b">TypedDict</code>的所有字段都不是必需的。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="ad80" class="kr ju hi lp b fi lt lu l lv lw"><strong class="lp hj">class</strong> <strong class="lp hj">Movie</strong>(TypedDict):<br/>   title: str<br/>   year: NotRequired[int]</span><span id="b471" class="kr ju hi lp b fi ma lu l lv lw">m1: Movie <strong class="lp hj">=</strong> {"title": "Black Panther", "year": 2018}  <em class="me"># OK<br/></em>m2: Movie <strong class="lp hj">=</strong> {"title": "Star Wars"}  <em class="me"># OK (year is not required)<br/></em>m3: Movie <strong class="lp hj">=</strong> {"year": 2022}  <em class="me"># ERROR (missing required field title)</em></span></pre><h1 id="96d2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">自身类型</h1><p id="9c5f" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated"><a class="ae iu" href="https://peps.python.org/pep-0673/" rel="noopener ugc nofollow" target="_blank"> PEP-673 </a>为返回类实例的方法引入了<code class="du lx ly lz lp b">Self</code>注释。下列范例显示替代建构函式的使用案例:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="6094" class="kr ju hi lp b fi lt lu l lv lw"><strong class="lp hj">class</strong> <strong class="lp hj">MyInt</strong>:<br/>    <strong class="lp hj">@</strong>classmethod<br/>    <strong class="lp hj">def</strong> <strong class="lp hj">fromhex</strong>(cls, s: str) <strong class="lp hj">-&gt;</strong> Self:<br/>        <strong class="lp hj">return</strong> cls(int(s, 16))</span></pre><h1 id="b46e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">任意文字字符串类型</h1><p id="cc1e" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">Python 3.11引入了一个新的注释来增加字符串的安全性:<code class="du lx ly lz lp b"><a class="ae iu" href="https://docs.python.org/3.11/library/typing.html#typing.LiteralString" rel="noopener ugc nofollow" target="_blank">LiteralString</a></code>。该注释允许函数接受任意的文字字符串类型，以及从其他文字字符串创建的字符串。您可以对敏感函数实施要求，例如那些执行SQL语句以防止SQL注入攻击的函数。</p><p id="a15e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相应的<a class="ae iu" href="https://peps.python.org/pep-0675/" rel="noopener ugc nofollow" target="_blank"> PEP-675 </a>显示了该注释如何用于SQL查询:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="0d51" class="kr ju hi lp b fi lt lu l lv lw"><strong class="lp hj">def</strong> <strong class="lp hj">run_query</strong>(sql: LiteralString) <strong class="lp hj">-&gt;</strong> ...<br/>    ...</span><span id="019a" class="kr ju hi lp b fi ma lu l lv lw"><strong class="lp hj">def</strong> <strong class="lp hj">caller</strong>(<br/>    arbitrary_string: str,<br/>    query_string: LiteralString,<br/>    table_name: LiteralString,<br/>) <strong class="lp hj">-&gt;</strong> None:<br/>    run_query("SELECT * FROM students")       <em class="me"># ok<br/></em>    run_query(query_string)                   <em class="me"># ok<br/></em>    run_query("SELECT * FROM " <strong class="lp hj">+</strong> table_name)  <em class="me"># ok<br/></em>    run_query(arbitrary_string)               <em class="me"># type checker error<br/></em>    run_query(                                <em class="me"># type checker error<br/></em>        f"SELECT * FROM students WHERE name = {arbitrary_string}"<br/>    )</span></pre><h1 id="76dc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">旧的必须去:折旧</h1><p id="9859" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">以下传统标准库模块已被弃用，并将在Python 3.13中移除:</p><ul class=""><li id="3556" class="mi mj hi ix b iy iz jc jd jg mk jk ml jo mm js mn mo mp mq bi translated"><code class="du lx ly lz lp b">aifc</code></li><li id="413b" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">chunk</code></li><li id="e7e2" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">msilib</code></li><li id="a731" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">pipes</code></li><li id="761b" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">telnetlib</code></li><li id="d0e9" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">audioop</code></li><li id="50bf" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">crypt</code></li><li id="61d4" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">nis</code></li><li id="8ac3" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">sndhdr</code></li><li id="3e6b" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">uu</code></li><li id="6224" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">cgi</code></li><li id="590e" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">imghdr</code></li><li id="b6cd" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">nntplib</code></li><li id="fadc" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">spwd</code></li><li id="93ea" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">xdrlib</code></li><li id="86e4" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">cgitb</code></li><li id="ebf5" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">mailcap</code></li><li id="736a" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">ossaudiodev</code></li><li id="879b" class="mi mj hi ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated"><code class="du lx ly lz lp b">sunau</code></li></ul><p id="662f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，<code class="du lx ly lz lp b">asynchat</code>、<code class="du lx ly lz lp b">asyncore</code>和<code class="du lx ly lz lp b">smtpd</code>模块(已经被弃用)已经更新，注意它们将在Python 3.12中被移除。此外，<code class="du lx ly lz lp b">lib2to3</code>包和<code class="du lx ly lz lp b">2to3</code>工具现在已经过时，可能无法解析Python 3.10或更新版本。未记录的模块<code class="du lx ly lz lp b">sre_compile</code>、<code class="du lx ly lz lp b">sre_constants</code>和<code class="du lx ly lz lp b">sre_parse</code>现在也不推荐使用。</p><p id="0e3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://docs.python.org/3.11/c-api/unicode.html#c.Py_UNICODE" rel="noopener ugc nofollow" target="_blank"> Py_UNICODE </a>编码器API已经被<a class="ae iu" href="https://docs.python.org/3.11/whatsnew/3.11.html#whatsnew311-pep624" rel="noopener ugc nofollow" target="_blank">移除</a>，因为它们已经被弃用，并且因为有更好、更有效的替代方案而不再被使用。如果您仍在使用这些API，相应的<a class="ae iu" href="https://peps.python.org/pep-0624/" rel="noopener ugc nofollow" target="_blank"> PEP-624 </a>提供了一个迁移指南。</p><p id="a536" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一些宏已经被转换成静态内联函数，以避免<a class="ae iu" href="https://gcc.gnu.org/onlinedocs/cpp/Macro-Pitfalls.html" rel="noopener ugc nofollow" target="_blank">宏陷阱</a>。您可以在相关的<a class="ae iu" href="https://peps.python.org/pep-0670/" rel="noopener ugc nofollow" target="_blank"> PEP-670 </a>中找到关于这些宏的更多信息。</p><h1 id="3fce" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="5c2d" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">新的<a class="ae iu" href="https://docs.python.org/3.11/whatsnew/3.11.html#" rel="noopener ugc nofollow" target="_blank"> Python版本3.11 </a>带来了许多新的好东西:更好的性能、更多的异常处理可能性、解析TOML文件的新模块、解释器的改进、附加的类型、注释和类型特性，以及对一些旧语言包袱的摒弃和移除。</p><p id="adb2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">自己决定，这是否值得升级，但最重要的是:继续编码，继续创造！</p></div></div>    
</body>
</html>