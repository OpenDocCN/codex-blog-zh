<html>
<head>
<title>A Mysterious Bug with Nginx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nginx的一个神秘Bug</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-mysterious-bug-with-nginx-7e19d3d4eea9?source=collection_archive---------5-----------------------#2021-06-10">https://medium.com/codex/a-mysterious-bug-with-nginx-7e19d3d4eea9?source=collection_archive---------5-----------------------#2021-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6c10d804d6a7f536215b8f2202141da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xhyCkn9d15q_xhk9"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯文·Ku</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="61f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在API维护过程中遇到了一个神秘的API bug，这是由于客户端在使用<strong class="ix hj"> Nginx </strong>时意外超时造成的，在本文中，我将谈谈:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="59ec" class="kc kd hi jy b fi ke kf l kg kh">* Before we dive in<br/>    - The Overview of the Service<br/>    - The Workflow of API<br/>* So, What is the bug?<br/>* How to reproduce?<br/>* How to solve it?<br/>    - Minimize the Request Time<br/>    - Kubernetes Routing<br/>    - Event-Driven Queue<br/>    - API Authentication<br/>* Why does it happen?<br/>    - Why timed out?<br/>    - Why does timed out cause another server to run the request?<br/>    - Can we adjust the timed-out?<br/>* Summary<br/>* References</span></pre></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="82a0" class="kp kd hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">在我们开始之前</h1><h2 id="e3ca" class="kc kd hi bd kq lm ln lo ku lp lq lr ky jg ls lt lc jk lu lv lg jo lw lx lk ly bi translated">服务概述</h2><p id="aa65" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">在深入研究这个bug之前，这里有一个我们服务的简单概述，让你知道这个API是如何工作的:</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/e28ad315afdaef9c050a2e9de43c5bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWnSokIlo-hZMARYRq0ljQ.png"/></div></div></figure><ul class=""><li id="fef9" class="mf mg hi ix b iy iz jc jd jg mh jk mi jo mj js mk ml mm mn bi translated"><strong class="ix hj"> Azure函数</strong>:该函数每天都会触发API(<a class="ae iu" href="https://en.wikipedia.org/wiki/Cron" rel="noopener ugc nofollow" target="_blank">Cron job</a>)。</li><li id="be15" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mk ml mm mn bi translated"><strong class="ix hj">服务(Generate-Mail)</strong>:API提供者，一旦调用API，就会开始检索用户的信息，然后生成临时数据，用于以后发送用户邮件。</li><li id="11b9" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mk ml mm mn bi translated"><strong class="ix hj"> Azure MySQL </strong>:存储临时数据。</li></ul><p id="383f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更详细的解释:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="e27a" class="kc kd hi jy b fi ke kf l kg kh">- <a class="ae iu" href="https://azure.microsoft.com/en-us/services/functions/" rel="noopener ugc nofollow" target="_blank">Azure Function</a>: A serverless solution in Azure, it’s like a single-runnable function on the cloud. </span><span id="cb8f" class="kc kd hi jy b fi mt kf l kg kh">— <a class="ae iu" href="https://azure.microsoft.com/en-us/services/kubernetes-service" rel="noopener ugc nofollow" target="_blank">Azure Kubernetes</a>: A container-orchestration system, it can automating deployment, scaling and management, etc. </span><span id="c9f6" class="kc kd hi jy b fi mt kf l kg kh">— Service: Our backend service that provides API service. </span><span id="1b6a" class="kc kd hi jy b fi mt kf l kg kh">— Pod: Like a single VM, it’s like a replica of the service. </span><span id="9ad9" class="kc kd hi jy b fi mt kf l kg kh">— <a class="ae iu" href="https://azure.microsoft.com/en-us/free/mysql/search/" rel="noopener ugc nofollow" target="_blank">Azure MySQL</a>: same as MySQL but it’s run on the cloud.</span></pre><h2 id="a14e" class="kc kd hi bd kq lm ln lo ku lp lq lr ky jg ls lt lc jk lu lv lg jo lw lx lk ly bi translated">API的工作流程</h2><p id="710b" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">让我们来看看API工作流程:</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/63d52c4559a7d2664b6279e7007360d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g5shmJNv0PKnyZdcB7k0wA.png"/></div></div></figure><ol class=""><li id="dce1" class="mf mg hi ix b iy iz jc jd jg mh jk mi jo mj js mv ml mm mn bi translated">由CRON作业触发的函数</li><li id="7ed8" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mv ml mm mn bi translated"><a class="ae iu" href="https://azure.microsoft.com/en-us/blog/understanding-serverless-cold-start/" rel="noopener ugc nofollow" target="_blank">冷启动</a>:这是无服务器应用的一个行为，总而言之，你的功能需要时间启动(比如分配内存)。</li><li id="eebf" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mv ml mm mn bi translated">API调用。</li><li id="dee2" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mv ml mm mn bi translated">Kubernetes将请求路由到<strong class="ix hj">空闲Pod </strong>。Pod执行请求，开始生成数据。</li><li id="22a8" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mv ml mm mn bi translated">将数据插入SQL数据库。</li><li id="8363" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mv ml mm mn bi translated">插入成功/失败(错误)</li><li id="c373" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mv ml mm mn bi translated">发送响应。</li><li id="d46c" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mv ml mm mn bi translated">如果函数收到响应或者执行时间超过2分钟，结束执行:<code class="du mw mx my jy b">2 min</code>可以在<a class="ae iu" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-scale" rel="noopener ugc nofollow" target="_blank"> Azure </a>上配置。</li><li id="acef" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mv ml mm mn bi translated">另一个服务(电子邮件发送服务)将使用临时数据发送电子邮件。(我们将跳过这一部分，专注于bug是如何产生的)</li></ol></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="ba4e" class="kp kd hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">那么，什么是bug呢？</h1><p id="7db4" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">有一天早上，我发现我收到了来自我们服务部门的<code class="du mw mx my jy b">2</code>封邮件，每个人包括客户都收到了2封邮件。让我们做一些自上而下的调查。</p><ul class=""><li id="684d" class="mf mg hi ix b iy iz jc jd jg mh jk mi jo mj js mk ml mm mn bi translated">发邮件服务:这是一个生产者-消费者的关系，根本原因应该在生产者一方，而不是这一部分。</li><li id="de9d" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mk ml mm mn bi translated">Azure函数日志(简化):API似乎被很好地触发了(我们知道由于执行时间很长，函数会超时)。</li></ul><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="db0e" class="kc kd hi jy b fi ke kf l kg kh">2021-05-30 22:01:05 Executing 'Functions'<br/>2021-05-30 22:01:05 Queue trigger function <br/>2021-05-30 22:01:06 Run POST API request <br/>2021-05-30 22:03:05 Timeout<br/>2021-05-30 22:03:05 Executed 'Functions' (Failed, Duration=120000ms)</span></pre><ul class=""><li id="43e3" class="mf mg hi ix b iy iz jc jd jg mh jk mi jo mj js mk ml mm mn bi translated">Azure Kubernetes日志(Pod A):好的，看起来API调用正确。</li></ul><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="86e6" class="kc kd hi jy b fi ke kf l kg kh">2021-05-30 22:01:06 Start API request with API key <br/>2021-05-30 22:02:06 Send 123 emails out <br/>2021-05-30 22:02:07 End API request</span></pre><ul class=""><li id="775e" class="mf mg hi ix b iy iz jc jd jg mh jk mi jo mj js mk ml mm mn bi translated">天蓝色库伯内特原木(B舱)</li></ul><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7417" class="kc kd hi jy b fi ke kf l kg kh">2021-05-30 22:03:06 Start API request with API key <br/>2021-05-30 22:04:09 Send 123 emails out <br/>2021-05-30 22:04:09 End API request</span></pre><p id="0f5d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们知道Pod A已经在运行API请求，但是为什么Pod B同时也在运行请求呢？</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="de0d" class="kp kd hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">如何繁衍后代？</h1><p id="6aa8" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">为了挖掘这个错误，我试图重现它，看看它是否只是一个罕见的情况，我用相同的参数、头、API键调用了API，它确实在Pods A和B中调用了两次！</p><p id="bff6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果这不是一个罕见的情况，一切似乎都很顺利，那么应该是什么问题呢？我们可以假设:</p><ul class=""><li id="535f" class="mf mg hi ix b iy iz jc jd jg mh jk mi jo mj js mk ml mm mn bi translated">一些原因导致Azure函数重试请求。</li><li id="2428" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mk ml mm mn bi translated">让Kubernetes(或者更准确地说，Kubernetes内部的<strong class="ix hj"> Nginx </strong>重试。</li><li id="15ce" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mk ml mm mn bi translated">API本身就有缺陷。</li></ul><p id="13d0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">甚至错误的根本原因也很难说，但它确实对我们的客户产生了巨大的影响(没有人希望重复的邮件填满他们可怜的邮箱，尤其是已经充满大量垃圾邮件的邮箱)。第一要务是:<strong class="ix hj">修复那个bug </strong>！</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="e01c" class="kp kd hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">怎么解决？</h1><p id="af05" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">问题很清楚:<strong class="ix hj">让API请求只发生一次</strong>，我们在试图重现它的时候有一些线索，所以让我们考虑不同的方面:</p><h2 id="e3b4" class="kc kd hi bd kq lm ln lo ku lp lq lr ky jg ls lt lc jk lu lv lg jo lw lx lk ly bi translated">最小化请求时间</h2><p id="4134" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">如果是API请求时间过长导致客户端(Azure函数)超时，那么我们只需要减少执行时间。然而，该服务与来自其他内部服务的多个API调用相结合，加上我们仍然不知道API对客户端的响应应该有多短，这样做太冒险了。</p><h2 id="b0a5" class="kc kd hi bd kq lm ln lo ku lp lq lr ky jg ls lt lc jk lu lv lg jo lw lx lk ly bi translated">Kubernetes路由</h2><p id="959b" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">Kubernetes帮助我们以一种简单的方式路由API请求，但是在这种情况下，也许这也是一个根本原因？工作流和日志显示，如果我们只有一个pod，那么只能在一个pod中调用API(即使有人想再次调用，pod A也很忙，因此应该阻塞请求，并告诉客户端服务器端很忙)。</p><p id="340d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，<strong class="ix hj">我们不能保证我们服务的高可用性</strong>，这意味着如果API调用发生在Pod A关闭时，没有人能够处理API请求。</p><h2 id="8b07" class="kc kd hi bd kq lm ln lo ku lp lq lr ky jg ls lt lc jk lu lv lg jo lw lx lk ly bi translated">事件驱动队列</h2><p id="8a8b" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">为了确保一件事情只由一个实例处理，队列可以很容易地解决消费者-生产者问题。我们可以通过在Azure Function和Kubernetes之间添加一个队列来稍微改变一下工作流，当一个请求生成时，将其发送到一个队列，Kubernetes使用其中的数据来确保只有一个pod接收到请求。</p><p id="7222" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然这是一个干净的解决方案，但我们需要更多地关注通过添加新服务来修复2个服务，这将需要很多时间。</p><h2 id="5bf8" class="kc kd hi bd kq lm ln lo ku lp lq lr ky jg ls lt lc jk lu lv lg jo lw lx lk ly bi translated">API认证</h2><p id="05f1" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">回到开始，如果我们让请求发生两次，但禁止一次执行，会怎么样？<strong class="ix hj">过期的密钥？</strong><a class="ae iu" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj">JWT(JSON Web Token)</strong></a><strong class="ix hj">！</strong></p><p id="a477" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">JSON Web Token是一个提议的互联网标准，用于创建带有可选签名和/或可选加密的数据，其有效负载包含断言一些声明的JSON。使用私有秘密或公共/私有密钥对令牌进行签名。— <a class="ae iu" href="https://en.wikipedia.org/wiki/JSON_Web_Token" rel="noopener ugc nofollow" target="_blank">维基</a></p><p id="419b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要的是JWT的一个标准字段— <code class="du mw mx my jy b">exp</code>(到期时间)，JWT将到期，在<code class="du mw mx my jy b">exp</code>之后，该请求将被视为无效请求，不予处理。</p><p id="eb44" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们只对Azure函数中的API键做了微小的改动，让服务器能够用JWT(已经内置)处理请求。</p><p id="449c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对其工作原理的详细解释(假设:请求执行时间= 150秒，函数超时= 120秒):</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/a541e054e3183cda6e9df9b8c2e2ad38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TaCROvwnjLor2_jXtZzdng.png"/></div></div></figure><p id="569b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好在bug已经修复了，但是挥之不去的调试过程推动着我们去寻找根源，对吧？既然范围太大找不到根本原因，那就做一个删减版来找为什么会发生。</p><h1 id="c8a6" class="kp kd hi bd kq kr nb kt ku kv nc kx ky kz nd lb lc ld ne lf lg lh nf lj lk ll bi translated">为什么会这样？</h1><p id="ec9c" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">你可以用这个GitHub库找到所有代码并自己运行它们。首先，我们使用两个带有Nginx的容器作为负载均衡器来模拟与上面相同的工作流(但是经过了简化):</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/6cfae698c5db6bd000658621e10b2629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZxSqWNxPPAtqTsIzO6BbPQ.png"/></div></div></figure><p id="9fa4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du mw mx my jy b">docer-compose.yml</code>中，我们为我们的服务器定义了Nginx和2个实例(称为node1、node2)</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="bd03" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du mw mx my jy b">nginx.conf</code>中，我们赋予2台服务器同等的权重:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="be8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在app.ts中，我们定义了2个API:</p><ul class=""><li id="c24b" class="mf mg hi ix b iy iz jc jd jg mh jk mi jo mj js mk ml mm mn bi translated">我们使用一个空的URL来进行健康检查</li></ul><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="nh ni l"/></div></figure><ul class=""><li id="caa0" class="mf mg hi ix b iy iz jc jd jg mh jk mi jo mj js mk ml mm mn bi translated"><code class="du mw mx my jy b">/sleep</code>会休眠120秒然后发送消息给客户端</li></ul><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="c4d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以看到一段时间后(2分钟)，客户端得到一个超时，Nginx也向每个服务器发送一个请求。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/337168a48d50cb3682b2ac4359087e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YsjaGUgQOlMP4wYDJ_Tt6g.png"/></div></div></figure><p id="4c37" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看看日志:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="6a1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们发现了一些东西，Nginx得到了一个<em class="mz">上游超时</em>，这意味着它认为这个服务器不能处理请求，然后它应该转向另一个服务器寻求帮助，但事实上，服务器只是很忙，但仍在处理原始请求，这就是为什么我们得到重复数据！</p><p id="8191" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以把它分成三部分:</p><ol class=""><li id="a6f9" class="mf mg hi ix b iy iz jc jd jg mh jk mi jo mj js mv ml mm mn bi translated">为什么超时了？</li><li id="e2a4" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mv ml mm mn bi translated">为什么超时会导致另一个服务器运行请求？</li><li id="17f6" class="mf mg hi ix b iy mo jc mp jg mq jk mr jo ms js mv ml mm mn bi translated">我们能调整超时吗？</li></ol><h2 id="0060" class="kc kd hi bd kq lm ln lo ku lp lq lr ky jg ls lt lc jk lu lv lg jo lw lx lk ly bi translated">为什么超时了？</h2><p id="eca5" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">超时是为了防止客户端无休止地等待服务器，客户端可以把它作为一个信号，这个服务器没有运行或有麻烦，它不能解决我的请求。</p><h2 id="2b6a" class="kc kd hi bd kq lm ln lo ku lp lq lr ky jg ls lt lc jk lu lv lg jo lw lx lk ly bi translated">为什么超时会导致另一个服务器运行请求？</h2><p id="6144" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">使用Nginx时，一旦当前服务器无法处理请求，请求就会被路由，也就是说，请求会转到另一个服务器。更具体地说，<code class="du mw mx my jy b">nginx.conf</code>用<code class="du mw mx my jy b">upstream</code>定义我们的一组服务器:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="13e6" class="kc kd hi jy b fi ke kf l kg kh">upstream node-app {<br/>        server node1:3000 weight=1;<br/>        server node2:3000 weight=1;<br/>    }</span></pre><blockquote class="nk nl nm"><p id="eda0" class="iv iw mz ix b iy iz ja jb jc jd je jf nn jh ji jj no jl jm jn np jp jq jr js hb bi translated"><strong class="ix hj"> <em class="hi">如果在与服务器通信的过程中出现错误，请求将被传递到下一个服务器</em> </strong> <em class="hi">，以此类推，直到所有运行正常的服务器都被尝试。如果无法从任何服务器获得成功的响应，客户端将收到与最后一个服务器通信的结果。— </em> <a class="ae iu" href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> Nginx </em> </a></p></blockquote><h2 id="6a36" class="kc kd hi bd kq lm ln lo ku lp lq lr ky jg ls lt lc jk lu lv lg jo lw lx lk ly bi translated">我们能调整超时吗？</h2><p id="0e67" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">我们可以将<code class="du mw mx my jy b">proxy_read_timeout</code>添加到比你的请求时间更长的<code class="du mw mx my jy b">Nginx.conf</code>中，API现在可以继续处理它的请求并正确地返回给客户端。</p><blockquote class="nk nl nm"><p id="47cd" class="iv iw mz ix b iy iz ja jb jc jd je jf nn jh ji jj no jl jm jn np jp jq jr js hb bi translated"><code class="du mw mx my jy b"><em class="hi">proxy_read_timeout</em></code> <em class="hi">定义从代理服务器读取响应的超时。仅在两次连续读取操作之间设置超时，而不是针对整个响应的传输。如果代理服务器在此时间内没有传输任何内容，则连接关闭。— </em> <a class="ae iu" href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_read_timeout" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> Nginx </em> </a></p></blockquote><p id="19ad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是它，我们变通，终于找到了根本原因！</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="bde7" class="kp kd hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">摘要</h1><p id="3812" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">因此，下一次当使用Nginx作为服务器的负载平衡器时，记得检查API的超时时间，如果API执行时间超过60秒，请尝试减少超时时间或将<code class="du mw mx my jy b">proxy_read_timeout</code>添加到Nginx配置中。</p><p id="f57d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我要回去在Nginx中再次修复这个问题……</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="6705" class="kp kd hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">参考</h1><div class="nq nr ez fb ns nt"><a href="https://stackoverflow.com/questions/18740635/nginx-upstream-timed-out-110-connection-timed-out-while-reading-response-hea" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab dw"><div class="nv ab nw cl cj nx"><h2 class="bd hj fi z dy ny ea eb nz ed ef hh bi translated">NGINX:从上游读取响应头时，上游超时(110:连接超时)</h2><div class="oa l"><h3 class="bd b fi z dy ny ea eb nz ed ef dx translated">我将Puma作为上游应用服务器运行，将Riak作为我的后台数据库集群。当我发送一个请求…</h3></div><div class="ob l"><p class="bd b fp z dy ny ea eb nz ed ef dx translated">stackoverflow.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh io nt"/></div></div></a></div><div class="nq nr ez fb ns nt"><a href="https://superuser.com/questions/746028/configuring-nginx-to-retry-a-single-upstream-server" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab dw"><div class="nv ab nw cl cj nx"><h2 class="bd hj fi z dy ny ea eb nz ed ef hh bi translated">配置nginx重试单个上游服务器</h2><div class="oa l"><h3 class="bd b fi z dy ny ea eb nz ed ef dx translated">感谢给超级用户贡献一个答案！请务必回答问题。提供详细信息并分享您的…</h3></div><div class="ob l"><p class="bd b fp z dy ny ea eb nz ed ef dx translated">superuser.com</p></div></div><div class="oc l"><div class="oi l oe of og oc oh io nt"/></div></div></a></div><div class="nq nr ez fb ns nt"><a href="https://blogs.oracle.com/ravello/beware-http-requests-automatic-retries" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab dw"><div class="nv ab nw cl cj nx"><h2 class="bd hj fi z dy ny ea eb nz ed ef hh bi translated">小心HTTP请求自动重试</h2><div class="oa l"><h3 class="bd b fi z dy ny ea eb nz ed ef dx translated">在本帖中，我将讨论我们最近遇到的一起由于HTTP协议令人惊讶的行为而导致的事件。我会…</h3></div><div class="ob l"><p class="bd b fp z dy ny ea eb nz ed ef dx translated">blogs.oracle.com</p></div></div></div></a></div><div class="nq nr ez fb ns nt"><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab dw"><div class="nv ab nw cl cj nx"><h2 class="bd hj fi z dy ny ea eb nz ed ef hh bi translated">模块ngx _ http _代理服务器_模块</h2><div class="oa l"><h3 class="bd b fi z dy ny ea eb nz ed ef dx translated">ngx_http_proxy_module模块允许将请求传递到另一个服务器。示例配置位置/ {…</h3></div><div class="ob l"><p class="bd b fp z dy ny ea eb nz ed ef dx translated">nginx.org</p></div></div></div></a></div></div></div>    
</body>
</html>