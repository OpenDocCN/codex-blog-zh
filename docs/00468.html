<html>
<head>
<title>Testing your app’s data layer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试应用程序的数据层</h1>
<blockquote>原文：<a href="https://medium.com/codex/testing-your-apps-data-layer-3328d69abd02?source=collection_archive---------1-----------------------#2021-02-09">https://medium.com/codex/testing-your-apps-data-layer-3328d69abd02?source=collection_archive---------1-----------------------#2021-02-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f881" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">有多种技术，您使用的技术取决于您的测试策略。</h2></div><p id="e791" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">测试数据层的技术可以是<strong class="iz hj">直接</strong>，比如针对<a class="ae jt" href="https://en.wikipedia.org/wiki/List_of_in-memory_databases" rel="noopener ugc nofollow" target="_blank">内存数据库</a>(比如<a class="ae jt" href="https://www.h2database.com/html/main.html" rel="noopener ugc nofollow" target="_blank"> H2 </a>)或者针对真实数据库(比如使用Docker)或者<strong class="iz hj">间接</strong>，比如启动后端应用或者作为最终用户进行测试(UI测试)。让我们回顾一下直接选项。无论数据库技术如何(例如PostgreSQL、Redis、MongoDB)，都可以应用所提出的技术。</p><p id="69dd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">📝<em class="ju">在决定您将使用的技术时，请记住</em> <a class="ae jt" rel="noopener" href="/swlh/automated-testing-goals-d3ace8fd223a"> <em class="ju">测试自动化目标</em> </a> <em class="ju">以及它在您的</em> <a class="ae jt" rel="noopener" href="/swlh/visualizing-your-automated-testing-strategy-d25ca06abc4e"> <em class="ju">自动化测试策略</em> </a> <em class="ju">中的位置。</em></p><h1 id="fbb9" class="jv jw hi bd jx jy jz ka kb kc kd ke kf io kg ip kh ir ki is kj iu kk iv kl km bi translated">针对内存数据库进行测试</h1><p id="c783" class="pw-post-body-paragraph ix iy hi iz b ja kn ij jc jd ko im jf jg kp ji jj jk kq jm jn jo kr jq jr js hb bi translated">为了对数据层进行单元测试，我们需要对其进行适当的隔离。假设我们已经使用了<a class="ae jt" href="https://deviq.com/design-patterns/repository-pattern" rel="noopener ugc nofollow" target="_blank">存储库模式</a>。存储库的依赖组件(DoC)是一个数据库；计划是用内存数据库代替它。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ks"><img src="../Images/e1ee7abfd30c74d0c9e8d3faf1d87512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMNyXcamQdEdHTDENZnjuQ.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">内存数据库测试策略</figcaption></figure><p id="e6eb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">测试将调用被测存储库(控制点)的方法。然后，我们可以通过调用其他SUT方法(观察点)来断言。这里有一个存储用户(<code class="du li lj lk ll b">save(user)</code>)然后用<code class="du li lj lk ll b">findAll()</code>断言它的例子。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="8378" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种技术的主要好处是我们不需要任何额外的螺栓和零件，因为数据库是完全以编程方式管理的。</p><p id="bbb0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">⚠️:单元测试应该只针对你的存储库。不要测试实现细节，比如数据库模式、 <a class="ae jt" href="https://lsoares.medium.com/stop-testing-your-serializers-9b568ecd652f" rel="noopener"> <em class="ju">【解串器】</em> </a> <em class="ju">、查询以及类似的细节。为了实施它，</em> <a class="ae jt" href="https://levelup.gitconnected.com/when-magic-numbers-are-not-magic-fcdf034295a5" rel="noopener ugc nofollow" target="_blank"> <em class="ju">使它们成为私有的</em> </a> <em class="ju">(在它们的库内)。</em></p><h1 id="5bc3" class="jv jw hi bd jx jy jz ka kb kc kd ke kf io kg ip kh ir ki is kj iu kk iv kl km bi translated">针对真实数据库进行测试</h1><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lo"><img src="../Images/d4a081ea6bf041ee21969ecdf57a52f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MhrDnUsP1x-C0OgnLtlJdQ.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">真实数据库测试策略</figcaption></figure><p id="1039" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如您在图中看到的，这只是<em class="ju">内存数据库</em>技术的一个变种。在这种情况下，我们将使用真实数据库的一个实例；它给了我们更多的信心，因为它更接近生产环境。当生产数据库与内存数据库略有差异时，这样做是有好处的。因此，它加强了我们的测试安全网。</p><p id="5e8b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了让它工作，您需要确保在这些测试开始之前，一个真实的数据库正在运行。我们将使用Docker <code class="du li lj lk ll b">run</code>命令启动MySQL:</p><pre class="kt ku kv kw fd lp ll lq bn lr ls bi"><span id="0fec" class="lt jw hi ll b be lu lv l lw lx">mysqld<br/><br/># CREATE DATABASE clean_demo;<br/># CREATE USER 'clean_demo'@'localhost' IDENTIFIED BY 'my-secret-pw';<br/># GRANT ALL PRIVILEGES ON clean_demo.* TO 'clean_demo'@'localhost';<br/># FLUSH PRIVILEGES;</span></pre><p id="79e4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们只是在测试设置中使用那些数据库连接细节:</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="e7c0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的建议是将它放在一个脚本(<code class="du li lj lk ll b">test.sh</code>)中，您可以在本地和您的<a class="ae jt" href="https://en.wikipedia.org/wiki/CI/CD" rel="noopener ugc nofollow" target="_blank"> CI/CD </a>中运行，这样您就可以尽可能地在本地体验CI/CD中发生的事情。这是一个Gradle项目的例子:</p><pre class="kt ku kv kw fd lp ll lq bn lr ls bi"><span id="c94a" class="lt jw hi ll b be lu lv l lw lx">#!/bin/bash<br/><br/>./gradlew clean test</span></pre><h1 id="6c2e" class="jv jw hi bd jx jy jz ka kb kc kd ke kf io kg ip kh ir ki is kj iu kk iv kl km bi translated">测试容器</h1><p id="ec4f" class="pw-post-body-paragraph ix iy hi iz b ja kn ij jc jd ko im jf jg kp ji jj jk kq jm jn jo kr jq jr js hb bi translated">Testcontainers 是一个很棒的工具，它集合了前两种方法的优点。只要运行Docker，就可以在容器中运行任何类型的数据库。这种方法的好处是容器的生命周期是以编程方式控制的。</p><div class="ly lz ez fb ma mb"><a rel="noopener follow" target="_blank" href="/codex/testing-the-data-layer-with-testcontainers-59a3a7141707"><div class="mc ab dw"><div class="md ab me cl cj mf"><h2 class="bd hj fi z dy mg ea eb mh ed ef hh bi translated">用Testcontainers测试数据层</h2><div class="mi l"><h3 class="bd b fi z dy mg ea eb mh ed ef dx translated">使用Testcontainers库是测试应用程序数据层的方法之一(用JVM语言)。让我们看一个基本的…</h3></div><div class="mj l"><p class="bd b fp z dy mg ea eb mh ed ef dx translated">medium.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp lc mb"/></div></div></a></div><h1 id="2c72" class="jv jw hi bd jx jy jz ka kb kc kd ke kf io kg ip kh ir ki is kj iu kk iv kl km bi translated">🛑嘲笑数据库驱动程序</h1><p id="2b02" class="pw-post-body-paragraph ix iy hi iz b ja kn ij jc jd ko im jf jg kp ji jj jk kq jm jn jo kr jq jr js hb bi translated">模仿数据库客户端/驱动程序并不是对存储库进行单元测试的合适技术，因为<a class="ae jt" href="https://tech.findmypast.com/dont-mock-what-you-dont-own/" rel="noopener ugc nofollow" target="_blank">你会模仿你不拥有的东西</a>——在这里是数据库客户端库——创建对你不拥有的代码的依赖。你最终会得到你无法控制的复杂的模仿类。</p><p id="0276" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也有人创建了“<a class="ae jt" href="https://blog.jooq.org/2013/02/20/easy-mocking-of-your-database/" rel="noopener ugc nofollow" target="_blank"> void drivers </a>”库，这样你就不必自己创建mocks了。与使用内存数据库进行测试相比，我看不出这样做有什么价值。你将使用一个在现实生活中没有使用的驱动程序，因此不会再现任何真实的场景。测试安全网几乎不会改变。</p></div></div>    
</body>
</html>