<html>
<head>
<title>What are the SOLID principles?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有哪些扎实的原则？</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-are-solid-principles-1a863b782e91?source=collection_archive---------12-----------------------#2021-08-24">https://medium.com/codex/what-are-solid-principles-1a863b782e91?source=collection_archive---------12-----------------------#2021-08-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="40e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时在你的代码中使用软件原则是完美的。它在许多方面帮助你提高代码质量。每项原则在《守则》中都有具体的用法。然而，在选择原则时最好要小心，因为它有时会增加复杂性而不是好处。所以今天，我想谈谈坚实的原则。</p><p id="616f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">罗伯特·c·马丁在2000年提出了坚实的原则，从那时起，它一直很受欢迎。坚实原则的主要目标是提高开发质量。</p><p id="6472" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">坚实的原则代表着:</p><ol class=""><li id="75a0" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">s——单一责任原则</li><li id="fbe8" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">O —开闭原则</li><li id="037f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">李斯科夫替代原理</li><li id="655e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">I——界面分离原则</li><li id="114c" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">依赖倒置原则</li></ol><p id="b0f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们将讨论所有的原则。</p><h2 id="5d26" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">什么是单一责任原则？(温泉)</h2><blockquote class="km kn ko"><p id="42d9" class="if ig kp ih b ii ij ik il im in io ip kq ir is it kr iv iw ix ks iz ja jb jc hb bi translated">一个类应该只有一个改变的理由</p></blockquote><p id="7baf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有一个通知类，负责通知用户即将发生的事件。用户可以选择在哪里接收通知，可以是电子邮件，也可以是电话。因此，如果事件发生，我们应该根据用户的设置向她发送通知。</p><p id="1429" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看这个例子</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ky kz l"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">实现细节是隐藏的。</figcaption></figure><p id="cb23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么代码有什么问题呢？正如您已经注意到的，我们的NotificationService已经有两个职责。首先，它发送电子邮件，其次，它发送短信到手机。有时，我们的代码会变大，变得混乱不堪，以至于一个变化可能会破坏系统的其他部分，这导致我们将时间花在维护上，而不是开发上。</p><p id="9b7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了避免这样的问题，我们需要划分责任。NotificationService已经有多个责任。例如，它通过NotificationService向手机发送电子邮件和短信。为了利用SRP，我们需要有单独的类，并赋予它们各自的职责。</p><p id="1fd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们做一些重构，把所有的东西放回原处。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ky kz l"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">重构后</figcaption></figure><p id="22ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们的NotificationService责任已经被分成了几个类。每个阶层都有一个改变的理由。</p><h2 id="5a6e" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">开闭原理是什么？(OCP)</h2><blockquote class="km kn ko"><p id="e849" class="if ig kp ih b ii ij ik il im in io ip kq ir is it kr iv iw ix ks iz ja jb jc hb bi translated">软件实体(类、模块、功能等)。)应该对扩展开放，但对修改关闭</p></blockquote><p id="aa51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">改变现有的代码总是很危险的。已经在生产中测试和部署。但幸运的是，有很多方法可以避免这样的问题。其中之一是利用开闭原理。</p><p id="7357" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设我们正在开发一个用户可以画多边形的画布工具。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ky kz l"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">实现细节是隐藏的。</figcaption></figure><p id="9d94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的代码可以看出，我们有Figure类负责绘制多边形。此外，我们有一些方法用于绘制特定的图形，例如，三角形。但是如果我想增加更多的数字呢？更改现有代码可能会导致我们破坏某些东西。另外，代码本身看起来很糟糕。因此，矩形、三角形和圆形方法在Figure类中是公开的。因此，我不能添加更多的数字，因为我最终会一塌糊涂。此外，这个人物还有许多责任。我们已经说过，一个类必须只有一个改变的理由。因此，要利用SRP和OCP，我们应该分离责任。</p><p id="74dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们必须创建一个抽象类，负责根据参数绘制图形。最后，我们必须为数字创建类。</p><p id="4ca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">抽象类帮助我们在不改变图形类的情况下添加更多的图形。此外，它已经包含了为派生类绘制图形的必要方法。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="4c31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重构之后，我们可以安全地添加任意数量的图形，而不需要接触图形类。</p><h2 id="a95e" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">什么是利斯科夫替代原理？</h2><blockquote class="km kn ko"><p id="3399" class="if ig kp ih b ii ij ik il im in io ip kq ir is it kr iv iw ix ks iz ja jb jc hb bi translated"><em class="hi">设φ(x)是关于T类型的对象x的一个可证明的性质。那么φ(y)对于S类型的对象y应该是真的，其中S是T的子类型"</em></p></blockquote><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/6cdfd62a73d50bc3a75a4693c3af66a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8wVfXZX-AUA-F7bo0mE_w.jpeg"/></div></div></figure><p id="8dfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设我们有能走路、飞和吃东西的鸟抽象类。我们根据这种鸟创建了一个企鹅类。所以我们期待一只企鹅会飞，但是出乎意料的是，该方法没有在Penguin类中实现，导致了意外的行为。</p><p id="fd31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个例子，假设你正在开发一个开放的API，你有一个抽象类和派生类，一些派生类不支持抽象类。然后，当一个开发者开始使用你的API时，他会很困惑，有些派生类不能用了。</p><p id="a171" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一下鸟的例子:</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="b68d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您在Penguine类中看到的，我们扩展了Fly方法，该方法没有实现，因为企鹅不会飞。但是用户预计Fly方法将适用于所有Bird派生类。但是Penguin类会让用户产生意想不到的行为，因为它不支持抽象类。</p><p id="fb60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了改进代码，我们可以有两个抽象类，一个用于能飞的鸟，另一个用于不能飞的鸟。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="aa9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们的企鹅和麻雀类支持抽象类。</p><h2 id="674e" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">什么是界面分离原理？</h2><blockquote class="km kn ko"><p id="40d3" class="if ig kp ih b ii ij ik il im in io ip kq ir is it kr iv iw ix ks iz ja jb jc hb bi translated">不应该强迫客户端依赖他们不使用的接口。</p></blockquote><p id="6c7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们开发软件时，代码总是在增长，更多的需求会不时地被添加进来。于是，一些界面不断增长，变得凌乱不堪。因此，让接口尽可能小总是一个好习惯。</p><p id="9656" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看这个例子:</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="0a09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们有在电话和计算器中使用的IDevice接口。然而，由于它们都是设备，你只能用电话打电话给别人。因此，根本不使用计算器中实现的Call方法。此外，设备的功能非常丰富。如果我们把它们都包括在内，我们最终会陷入一片混乱。我们的类将依赖于他们不使用的方法。</p><p id="5a62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了避免这样的问题，我们可以将接口分成更小的组件，并为设备使用合适的接口。</p><p id="c2ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看这个例子。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="6233" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，我们可以利用ISP。</p><h2 id="bae0" class="jr js hi bd jt ju jv jw jx jy jz ka kb iq kc kd ke iu kf kg kh iy ki kj kk kl bi translated">依赖倒置原理是什么？</h2><blockquote class="km kn ko"><p id="7a98" class="if ig kp ih b ii ij ik il im in io ip kq ir is it kr iv iw ix ks iz ja jb jc hb bi translated">1.高层模块不应该依赖低层模块。两者都应该依赖于抽象</p><p id="71a0" class="if ig kp ih b ii ij ik il im in io ip kq ir is it kr iv iw ix ks iz ja jb jc hb bi translated">2.抽象不应该依赖于细节。细节应该依赖于抽象。</p></blockquote><p id="3a71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑一个场景，其中有一个类被上百个类引用。有一天，你决定改变引用，所以你必须经历一百个类，然后一个一个地改变它们。所以你会花很多时间去修改代码。此外，您必须测试系统的每个部分，以确保您没有破坏任何东西，这是一项耗时的任务，我们开发人员需要始终避免。</p><p id="6134" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看这个例子。</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="7833" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们的应用程序支持两个数据库，SQL和Mongo。此外，我们还有用户存储库</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="5f1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，存储库直接引用了一个数据库。出于几个原因，这并不好。首先，存储库关心的是谁做操作，而不是它做什么。其次，如果我们想用SQL修改Mongo，我们必须遍历所有引用Mongo的存储库，并逐个修改它们。最后，我们正在向我们的存储库引入复杂性。所以基本上，它与Mongo紧密耦合。</p><p id="5424" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要应用DIP，我们必须更改我们的用户存储库:</p><figure class="kt ku kv kw fd kx"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="d198" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们的用户存储库依赖于高层抽象。它只关心写操作，而不关心谁做写操作。</p><p id="841d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望它给了你一些什么是坚实的原则的基本概念。</p><p id="c539" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是一些有用的参考资料:</p><ol class=""><li id="403b" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><a class="ae ll" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/SOLID</a></li><li id="5352" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">https://daedtech.com/dependency-injection-or-inversion/<a class="ae ll" href="https://daedtech.com/dependency-injection-or-inversion/" rel="noopener ugc nofollow" target="_blank"/></li></ol></div></div>    
</body>
</html>