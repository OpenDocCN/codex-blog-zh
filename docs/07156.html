<html>
<head>
<title>Immutability in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的不变性</h1>
<blockquote>原文：<a href="https://medium.com/codex/immutability-in-java-283d8bc9e634?source=collection_archive---------1-----------------------#2022-06-02">https://medium.com/codex/immutability-in-java-283d8bc9e634?source=collection_archive---------1-----------------------#2022-06-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0b267f9c86be09c4bd62af6797d0320e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zTFoXvGSAHExdmIq0jy1NQ.jpeg"/></div></div></figure><h2 id="d6b0" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">什么是不变性？！！</h2><p id="0e76" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">如果一个对象的状态在构造后不能改变，那么它就被认为是<em class="kj">不可变的</em>。最大限度地依赖不可变对象被广泛认为是创建简单、可靠代码的合理策略。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="f25e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">字符串是不可变的对象！</h2><p id="59ce" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">字符串是一个不可变的对象，我们可以改变字符串变量中的值。字符串中发生了什么？</p><p id="178d" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated">例如:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="532d" class="iq ir hi lb b fi lf lg l lh li">String name = "John";<br/>name = "Jane";</span></pre><p id="3e31" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated">上面的代码没有任何错误，是一个成功的编译。</p><p id="1e59" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated">实际上，Jvm在幕后工作<strong class="jq hj"/>，上面例子中的JVM将创建一个新对象并指向新值，但是直到现在最后一个值已经存在于内存中。但是更改后我们无法访问它。</p><blockquote class="lj lk ll"><p id="b365" class="jo jp kj jq b jr kr jt ju jv ks jx jy lm kt ka kb ln ku kd ke lo kv kg kh ki hb bi translated">为了更好的理解，请看下图。</p></blockquote><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/5737c175ef2b6be2486746334848f1c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNjC5noZ9rcE_2YlfDskFg.jpeg"/></div></figure><p id="d7bf" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated">在Java中我们有一个字符串池，你指的是什么？我们来解释一下。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="b2e6" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">字符串池:</h2><p id="7535" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">例如，如果我们有如下代码所示的3个变量:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="0628" class="iq ir hi lb b fi lf lg l lh li">String name = "John";<br/>String person = "John";<br/>String employee = "John";</span></pre><p id="2500" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated">如果我们需要在内存中保存这个值，内存将重复这个值3次。</p><p id="8d00" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated">但是字符串池第一次会为值创建一个新的位置，第二次和第三次会指向第一个位置而不创建新的分配。</p><blockquote class="lj lk ll"><p id="bb66" class="jo jp kj jq b jr kr jt ju jv ks jx jy lm kt ka kb ln ku kd ke lo kv kg kh ki hb bi translated">为了更好的理解，请看下图。</p></blockquote><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/ba41fb6c2f4a87235e8a1dc45da79fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bzz5TmTou14tVjoV1ZpTw.jpeg"/></div></figure><p id="a607" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated">并且您可以使用<code class="du lq lr ls lb b">==</code>来检查两个<code class="du lq lr ls lb b">String</code>之间的位置是否相同。</p><p id="4a4d" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated">String bool是一个有效的搜索和节省值，也可以考虑。</p><p id="40b3" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated">JVM使用的<strong class="jq hj">栈</strong>和<strong class="jq hj">堆</strong>你可以从这个<a class="ae lt" href="https://blog.devgenius.io/what-is-garbage-collector-stack-heap-in-java-80c33c2a0234" rel="noopener ugc nofollow" target="_blank">链接</a>中读到这个。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="6ccd" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated"><strong class="jq hj">新字符串:对象:</strong></p><p id="8529" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated">我们可以检索最后一个示例代码，并添加一个新行，如下所示。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4f6e" class="iq ir hi lb b fi lf lg l lh li">String name = "John";<br/>String person = "John";<br/>String employee = "John";<br/>String cricketer = new String(“John”);</span></pre><p id="69f2" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated">从上面的代码中，我们强制<strong class="jq hj"> JVM </strong>创建一个新对象和新位置，而不查看新对象的值或者检查该值是否存在于<strong class="jq hj">字符串池中。</strong></p><blockquote class="lj lk ll"><p id="ed4a" class="jo jp kj jq b jr kr jt ju jv ks jx jy lm kt ka kb ln ku kd ke lo kv kg kh ki hb bi translated">为了更好的理解，请看下图。</p></blockquote><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/dd8deff91a0fb2262cb65eb4e638645b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*94s3rz89Hd3U-zIkGf5DCw.jpeg"/></div></figure><p id="5abc" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated">现在，如果我们想检查字符串池中的位置，我们可以编写如下代码。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3833" class="iq ir hi lb b fi lf lg l lh li">name == person // will print true<br/>name == cricketer // will print false</span></pre></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="4aea" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated"><strong class="jq hj">分配的字符串:</strong></p><p id="d70b" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated">例如，当把字符串的值改为另一个值时，JVM会怎么做呢？让我们看看下面的例子。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="fa66" class="iq ir hi lb b fi lf lg l lh li">String name = "John";<br/>String person = "John";<br/>name = "jane"</span></pre><p id="c517" class="pw-post-body-paragraph jo jp hi jq b jr kr jt ju jv ks jx jy jb kt ka kb jf ku kd ke jj kv kg kh ki hb bi translated">在这种情况下，在堆中创建新值后，会将字符串池中的位置从John位置更改为Jane位置。就这么简单。</p><blockquote class="lj lk ll"><p id="1d7b" class="jo jp kj jq b jr kr jt ju jv ks jx jy lm kt ka kb ln ku kd ke lo kv kg kh ki hb bi translated">为了更好的理解，请看下图。</p></blockquote><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/9ce71bafcc32a500c3bac57421f94d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*zACQDIG361qkys4BnKgung.jpeg"/></div></div></figure></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><blockquote class="lj lk ll"><p id="e893" class="jo jp kj jq b jr kr jt ju jv ks jx jy lm kt ka kb ln ku kd ke lo kv kg kh ki hb bi translated">不要忘记在文章上拍手，每篇文章可以拍手50次。还有你在这里找到我的<a class="ae lt" href="https://www.linkedin.com/in/abd-alrhman-alkraien-83a93a1b1/" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">LinkedIn</strong></a></p></blockquote><h2 id="d9e9" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">参考资料:</h2><ul class=""><li id="9d33" class="lv lw hi jq b jr js jv jw jb lx jf ly jj lz ki ma mb mc md bi translated"><a class="ae lt" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html#:~:text=An%20object%20is%20considered%20immutable,particularly%20useful%20in%20concurrent%20applications" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/tutorial/essential/concurrency/immutable . html #:~:text = An % 20 object % 20 is % 20视为% 20不可变，特别是% 20 useful % 20 in % 20 concurrent % 20 applications</a>。</li><li id="6498" class="lv lw hi jq b jr me jv mf jb mg jf mh jj mi ki ma mb mc md bi translated"><a class="ae lt" href="https://blog.devgenius.io/what-is-garbage-collector-stack-heap-in-java-80c33c2a0234" rel="noopener ugc nofollow" target="_blank">https://blog . dev genius . io/what-is-garbage-collector-stack-heap-in-Java-80 c 33 C2 a 0234</a></li></ul></div></div>    
</body>
</html>