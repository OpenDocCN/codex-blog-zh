<html>
<head>
<title>Can Pandas take on SQL?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫能承担SQL吗？</h1>
<blockquote>原文：<a href="https://medium.com/codex/can-pandas-take-on-sql-7fd6dedca5a5?source=collection_archive---------12-----------------------#2022-06-04">https://medium.com/codex/can-pandas-take-on-sql-7fd6dedca5a5?source=collection_archive---------12-----------------------#2022-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a708" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">谁会赢？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d0030843adaf7442d6f3f7b00406296c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1aVEOpoYTSFlamCh.jpeg"/></div></div></figure><p id="110c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">SQL 已经存在很多年了，它是一个受欢迎的选择，因为它易于学习和理解。后来来了<em class="kf">熊猫。</em>今天我们开始比较这两个。</p><p id="511c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj"> <em class="kf">那么，没有任何进一步的到期让我们开始吧！！</em> </strong></p><p id="51fe" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf"> SQL </em>和<em class="kf"> Python </em>是现在现实世界中数据分析师和科学家必备的两种语言。当任何人开始探索数据分析时，他们通常首先从<em class="kf"> SQL </em>开始，然后慢慢转向<em class="kf"> Python </em>。</p><p id="30cf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将尝试比较一下<em class="kf"> SQL </em>和<em class="kf"> Pandas </em>中的一些非常重要的命令。<em class="kf"> SQL </em>是一种用于在关系数据库中存储、操作和检索数据的语言。Pandas是python中的一个库，用于数据分析和操作。</p><h1 id="0960" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">导入数据</h1><h1 id="db6f" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">结构化查询语言</h1><p id="47dd" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">在SQL中导入数据比在Pandas中要难一些。我们必须首先使用<strong class="jl hj"> CREATE TABLE </strong>语句创建一个表，其字段类似于文件中提到的字段，然后从文件中复制数据。检查下面的代码:</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="2f1a" class="li kh hi le b fi lj lk l ll lm">CREATE TABLE dataset_name (<br/>    column1 character data_type(30),<br/>    column2 character data_type(50),<br/>    column3 data_type,<br/>);copy fert_data from ‘Path\to\file’ with delimiter ‘,’ csv header encoding ‘windows-1251’;</span></pre><h1 id="949b" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">熊猫</h1><p id="0f17" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">现在将上面的工作与<em class="kf">熊猫</em>中的这段代码进行比较，用于导入文件。</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="357f" class="li kh hi le b fi lj lk l ll lm">df = pd.read_csv(’Path\to\your\dataset’)</span></pre><p id="1423" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">就这样，您已经成功导入了所有文件🎊</p><h1 id="420f" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">挑选</h1><h1 id="f42e" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">结构化查询语言</h1><p id="887d" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">在<em class="kf"> SQL </em>中，我们使用一个<strong class="jl hj"> SELECT </strong>语句从表中获取记录。这种说法应该是:</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="6e9e" class="li kh hi le b fi lj lk l ll lm">SELECT column_name1, column_name2,…<br/>FROM table_name;</span></pre><p id="3bbf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你的数据集中有一百万条记录会怎样…，现在你可能会犹豫这样看它们，以避免我们使用<strong class="jl hj"> LIMIT() </strong>并传递一个整数值给它</p><p id="535b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在熊猫中，我们用<strong class="jl hj"> head() </strong>和<strong class="jl hj"> tail() </strong>分别取前5行和后5行。这在字面上等于<em class="kf"> SQL </em>中的<code class="du ln lo lp le b">SELECT * FROM table LIMIT 5</code>。如果必须从数据框中选择特定的列，则语法应为:</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="0dce" class="li kh hi le b fi lj lk l ll lm">df[[‘column_name1’, ‘column_name2’]]</span></pre><h1 id="7eb0" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">在哪里</h1><h1 id="7a6b" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">结构化查询语言</h1><p id="aa0f" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">在<em class="kf"> SQL </em>中，一个<strong class="jl hj"> WHERE </strong>子句用于根据条件过滤记录。子句通常与条件和逻辑运算符结合使用，以形成过滤条件。语法应该是:</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="274c" class="li kh hi le b fi lj lk l ll lm">SELECT *<br/>FROM table_name<br/>WHERE condition_expression;</span></pre><h1 id="100f" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">熊猫</h1><p id="412b" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">Pandas中没有像<em class="kf"> SQL </em>这样的过滤记录的单一命令。我们可以使用布尔索引和位置索引。在<em class="kf">中，熊猫</em>过滤是通过逻辑条件计算的。其语法应该是:</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="3144" class="li kh hi le b fi lj lk l ll lm">df[df[‘column_name’] == value] # for Boolean indexingdf[df.loc[‘column_name’] == value] # for positional indexing</span></pre><p id="3bb6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<em class="kf"> SQL </em>和<em class="kf">熊猫</em>中，我们都可以使用比较(&gt;、&lt;、&gt; =、&lt; =、！=、==)和逻辑运算符(' and '、' or '、' not '或符号，如' | '、'【T57'、' ~ ')</p><h1 id="459c" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">插入</h1><h1 id="4e03" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">结构化查询语言</h1><p id="caef" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated"><strong class="jl hj"> Insert </strong>语句用于在数据库表中插入行。语法应该是:</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="80b4" class="li kh hi le b fi lj lk l ll lm">INSERT INTO table_name(column_name_1, column_name_2,…) VALUES (value1, value2,…);</span></pre><h1 id="7682" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">熊猫</h1><p id="bf86" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">在<em class="kf">熊猫</em>中，没有在数据框中插入新行的特定功能。我们可以使用诸如<strong class="jl hj"> concat() </strong>或<strong class="jl hj"> append() </strong>这样的工具来执行这个任务。但是最常用的是<strong class="jl hj"> append() </strong>。</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="0ba1" class="li kh hi le b fi lj lk l ll lm">df = df.append(new_row_to_be_inserted, ignore_index=True)</span></pre><h1 id="18d6" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">更新</h1><h1 id="6049" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">结构化查询语言</h1><p id="21e6" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">在<em class="kf"> SQL </em>中，<strong class="jl hj"> UPDATE </strong>语句用于更新或修改现有记录的值。update语句的语法是:</p><pre class="iy iz ja jb fd ld le lf lg aw lh bi"><span id="4caf" class="li kh hi le b fi lj lk l ll lm">UPDATE table_name<br/>SET column_name = ‘modified_value’<br/>WHERE condition;</span></pre><h1 id="db41" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">熊猫</h1><p id="6205" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">在<em class="kf"> Pandas </em>中，没有更新现有行的功能。一个常见的程序是通过使用我们之前在<strong class="jl hj">过滤器</strong>的比较中讨论的位置索引来定位应该更新或修改的位置，然后为其分配一个新值。这几乎就像给一个变量赋值。</p><h1 id="c69a" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">结论</h1><p id="71fd" class="pw-post-body-paragraph jj jk hi jl b jm ky ij jo jp kz im jr js la ju jv jw lb jy jz ka lc kc kd ke hb bi translated">如你所见，SQL和熊猫T21在某些方面都更好，没有明显的赢家。对于一些任务，比如插入和更新，<em class="kf"> SQL </em>是一个支配者，因为它的代码可读性更强，更容易理解，而<em class="kf"> Pandas </em>不需要你预先为数据创建一个数据结构，这可以节省大量的时间。想象一下，创建一个包含50多列数据的表，或者将50多列数据分成多个表，并使用连接，这真的很痛苦。</p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><p id="01a1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">别忘了留下你的回答。✌</p><p id="fdc5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">大家敬请关注！！为了把我的故事发到你的邮箱里，请订阅我的时事通讯。感谢您的阅读！不要忘记鼓掌，分享你的回答，并与朋友分享。</p></div></div>    
</body>
</html>