<html>
<head>
<title>Cloudfront, Function, and Edge@Lambda with Cloudformation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有云形成的云锋、函数和边缘@λ</h1>
<blockquote>原文：<a href="https://medium.com/codex/cloudfront-function-and-edge-lambda-with-cloudformation-e6aae6d87517?source=collection_archive---------20-----------------------#2022-06-18">https://medium.com/codex/cloudfront-function-and-edge-lambda-with-cloudformation-e6aae6d87517?source=collection_archive---------20-----------------------#2022-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="fade" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我把我们的登陆/博客页面从EC2服务器转移到了S3的一个静态网站，并通过CloudFront提供服务。该站点有多个重写配置(692)，我必须随之迁移重写配置。</p><p id="516d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我最初的想法是使用<strong class="ih hj"> S3网页重定向</strong>。但是它有每个桶50个重定向的限制，我必须编写692个重定向规则。</p><p id="9331" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">后来，我决定使用<strong class="ih hj"> Cloudfront函数</strong>，它类似于Lambda函数，成本更低，有200多个边缘缓存。此外，它的执行时间(1毫秒)和内存(2MB)也更少。而<strong class="ih hj"> Edge@Lambda </strong>执行时间从5秒(查看器触发)到30秒(原点触发)和128MB(查看器触发)内存。Cloudfront函数只支持<strong class="ih hj"> 10KB的包大小</strong>并且<strong class="ih hj">不能访问请求体</strong>。</p><p id="dddc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我编译的包有64KB，我不得不使用Edge@lambda。总之，在这篇博客中，我已经包括了Cloudfront功能部分及其与Cloudfront发行版的关联</p><blockquote class="jd je jf"><p id="6d66" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">在本教程的<!-- -->中，我将使用<strong class="ih hj"> cloudformation tamplate </strong>来部署all stack和CICD管道，以实现多种环境(中转和生产)的自动化和部署</p><p id="252d" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">在这里找到云形成的完整代码<a class="ae jk" href="https://github.com/5sfayas/Cloudfront-Function-EdgeLambda" rel="noopener ugc nofollow" target="_blank">https://github.com/5sfayas/Cloudfront-Function-EdgeLambda</a></p></blockquote><h2 id="3c85" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">云形成变量</h2><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="8b72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的代码中，我有两个部署，<code class="du kn ko kp kq b">DomainName: stage.fayas.com</code>用于阶段，<code class="du kn ko kp kq b">fayas.com</code>用于生产。为了指定部署阶段，我在模板中配置了参数。基于它的价值、暂存或生产，模板用相应的定制域名或CNAME和ACM ARN配置CloudFront发行版。</p><h2 id="cc4b" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">CloudFront函数</h2><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="4df5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kn ko kp kq b">Type: AWS::CloudFront::Function</code>属性用于创建CloudFront函数资源。<br/>T3】！Sub用EnvType替换/替代参数。<br/> <code class="du kn ko kp kq b">FunctionCode:</code>定义了Cloudfront功能代码和<br/> <code class="du kn ko kp kq b">Domain: !FindInMap [EnvType, !Ref EnvType, DomainName]</code>！FindInMap获取给定参数的<strong class="ih hj">域名</strong>，并存储到<strong class="ih hj">域</strong>变量中。<strong class="ih hj"> <br/> </strong> <code class="du kn ko kp kq b">Fn::Sub:</code>是从给定参数中替换域的数组。</p><p id="4731" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，如果我的EnvType是stage，并且代码块如下所示。</p><pre class="kg kh ki kj fd kr kq ks kt aw ku bi"><span id="b7d9" class="jl jm hi kq b fi kv kw l kx ky">var mapping = {</span><span id="9617" class="jl jm hi kq b fi kz kw l kx ky">"/who": "https://stage.fayas.com/fayas-akram/",</span><span id="a6a7" class="jl jm hi kq b fi kz kw l kx ky">"/about-me": "https://stage.fayas.com/fayas-akram/",</span><span id="201c" class="jl jm hi kq b fi kz kw l kx ky">"/home": "https://stage.fayas.com/",</span><span id="af95" class="jl jm hi kq b fi kz kw l kx ky">"/root": "https://stage.fayas.com/"</span><span id="d270" class="jl jm hi kq b fi kz kw l kx ky">}</span></pre><h2 id="1f18" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">边缘@λ</h2><p id="daa3" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">正如我前面提到的，由于它的局限性，我不得不使用Edge@Lambda来代替Cloudfront函数。如果你的函数规模较小，请考虑使用函数，如果你想使用Edge@Lambda忽略以上配置。</p><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="2ef7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Lambda函数资源创建类似于Cloudfront函数，其中使用了<code class="du kn ko kp kq b">Code:</code>而不是<code class="du kn ko kp kq b">FunctionCode:</code> <br/> <code class="du kn ko kp kq b">Type: AWS::Lambda::Version</code>定义的函数，当代码有新的变化时，它将创建一个新的Lambda函数版本。</p><h2 id="b334" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">云锋</h2><p id="bf6f" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我将创建一个带有自定义s3源域的默认缓存行为，Cloudfront将为查看器请求触发Edge Lambda。</p><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="22e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为部署CloudFront堆栈而定义的资源<code class="du kn ko kp kq b">Type: AWS::CloudFront::Distribution</code>。<code class="du kn ko kp kq b">LambdaFunctionAssociations:</code>与我们之前创建的Edge Lambda函数相关的块。<br/> <code class="du kn ko kp kq b">EventType: viewer-request</code> Cloudfront将触发Edge Lambda进行查看请求。！连接函数将连接带有版本号的λARN。</p><p id="15b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kn ko kp kq b">Origins:</code>定义了自定义S3源属性和<code class="du kn ko kp kq b">OriginProtocolPolicy:</code> http-only，这将把http流量发送到源</p><p id="c0e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想使用Cloudfront函数，使用<code class="du kn ko kp kq b">FunctionAssociations:</code>属性。</p><p id="87a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是基于Cloudfront的静态站点的内容缓存重定向。</p><p id="f5fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里找到<a class="ae jk" href="https://github.com/5sfayas/Cloudfront-Function-EdgeLambda" rel="noopener ugc nofollow" target="_blank">的完整代码。</a></p><p id="0899" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢！！！</p></div></div>    
</body>
</html>