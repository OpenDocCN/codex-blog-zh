<html>
<head>
<title>How To Do a High-Level React Code Review</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何进行高级的React代码评审</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-do-a-high-level-javascript-code-review-76eff9c56d3?source=collection_archive---------19-----------------------#2021-07-29">https://medium.com/codex/how-to-do-a-high-level-javascript-code-review-76eff9c56d3?source=collection_archive---------19-----------------------#2021-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/36843d8aff29f6e2393ba50be7b442e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*2CkBjxxE469BAWUXSsfqcA.png"/></div></figure><p id="84ee" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你好。今天，您将了解一个有经验的React开发人员如何进行代码审查。我会和你分享我的清单，如果我还有什么需要补充的，请在评论中告诉我。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="b94f" class="jt ju hi jp b fi jv jw l jx jy"><strong class="jp hj">Note</strong>: Some basic things like checking for better variable/functions names etc. are not added since this is supposed to a high level code review guide.</span></pre><h2 id="3af8" class="jt ju hi bd jz ka kb kc kd ke kf kg kh ix ki kj kk jb kl km kn jf ko kp kq kr bi translated">1.新包</h2><p id="b822" class="pw-post-body-paragraph im in hi io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">你应该寻找的第一件事是添加新的包。确保开发者添加的包是绝对必要的，并且没有简单的代码可供选择。每个开发人员的意图应该是使用简单的脚本而不是包，因为随着时间的推移，包的大小将会增长，并且会给应用程序带来很多问题。</p><h2 id="37c1" class="jt ju hi bd jz ka kb kc kd ke kf kg kh ix ki kj kk jb kl km kn jf ko kp kq kr bi translated">2.复杂的编码</h2><p id="1f82" class="pw-post-body-paragraph im in hi io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">第二步是寻找棘手的代码。现在让我通过一个例子向您展示我所说的棘手代码是什么意思。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="b7a2" class="jt ju hi jp b fi jv jw l jx jy">const hasData = !!result.length;</span></pre><p id="497d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du kx ky kz jp b">!!</code>是向<code class="du kx ky kz jp b">true</code>或<code class="du kx ky kz jp b">false</code>赋值的一种方式。假设<code class="du kx ky kz jp b">result.length</code>等于<code class="du kx ky kz jp b">0</code>，第一个<code class="du kx ky kz jp b">0</code>将转换为<code class="du kx ky kz jp b">false</code>，然后第一个<code class="du kx ky kz jp b">!</code>将转换为<code class="du kx ky kz jp b">true</code>，然后第二个<code class="du kx ky kz jp b">!</code>将再次转换为<code class="du kx ky kz jp b">false</code>。所以简而言之，<code class="du kx ky kz jp b">!!result.length</code>将返回<code class="du kx ky kz jp b">false</code>。我们可以简单地使用<code class="du kx ky kz jp b">result.length</code>,而不是经历如此复杂的过程，如果在代码中的某个地方没有严格地从<code class="du kx ky kz jp b">hasData</code>中预期一个布尔值，那么它会完全一样地工作。所以一定要寻找那些不必要的复杂代码。</p><h2 id="b2b4" class="jt ju hi bd jz ka kb kc kd ke kf kg kh ix ki kj kk jb kl km kn jf ko kp kq kr bi translated">3.应用程序破解代码</h2><p id="b862" class="pw-post-body-paragraph im in hi io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">考虑以下片段:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="0337" class="jt ju hi jp b fi jv jw l jx jy">const profile = fetchProfile();<br/>const username = profile.username;</span></pre><p id="a99b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">开发人员大多很乐观，他们会假设<code class="du kx ky kz jp b">profile</code>总是有一个有效的对象，因为这个应用在他们的本地环境中从来没有崩溃过。现在假设由于某种原因<code class="du kx ky kz jp b">fetchProfile</code>失败并返回一个<code class="du kx ky kz jp b">null/undefined</code>值。<code class="du kx ky kz jp b">profile.username</code>会使应用程序崩溃，因为JS会抛出一个异常。现在这个问题有两个解决方案:</p><ol class=""><li id="db91" class="la lb hi io b ip iq it iu ix lc jb ld jf le jj lf lg lh li bi translated">使用异常处理</li><li id="d18c" class="la lb hi io b ip lj it lk ix ll jb lm jf ln jj lf lg lh li bi translated">使用<code class="du kx ky kz jp b">lodash</code></li></ol><p id="383a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我不喜欢到处使用第一种解决方案，因为这会使代码变得复杂，使用<code class="du kx ky kz jp b">lodash</code>有很多好处，而且它非常健壮和简单。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="2c59" class="jt ju hi jp b fi jv jw l jx jy">import _ from 'lodash';</span><span id="bf7f" class="jt ju hi jp b fi lo jw l jx jy">const profile = fetchProfile();<br/>const username = _.get(profile, 'username');<br/>const category = _.get(profile, 'category', 'social');</span></pre><p id="e461" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用<code class="du kx ky kz jp b">lodash</code>的第一个好处是它不会让你的代码在变量没有想要的属性时中断。在上面的代码片段中，在<code class="du kx ky kz jp b">username</code>的情况下，如果<code class="du kx ky kz jp b">profile</code>有<code class="du kx ky kz jp b">undefined/null</code>或其他任何值或者<code class="du kx ky kz jp b">profile</code>有一个对象但不包含<code class="du kx ky kz jp b">username</code>，那么它将简单地返回<code class="du kx ky kz jp b">null</code>。在<code class="du kx ky kz jp b">category</code>的情况下，如果<code class="du kx ky kz jp b">profile</code>不包含<code class="du kx ky kz jp b">category</code>属性，它将始终返回您作为第三个参数传递的默认值。默认值是使用<code class="du kx ky kz jp b">lodash</code>的第二个好处。第三个优点是代码更简单，阅读起来不会太复杂。</p><h2 id="d0a1" class="jt ju hi bd jz ka kb kc kd ke kf kg kh ix ki kj kk jb kl km kn jf ko kp kq kr bi translated">4.处理人员隔离</h2><p id="09c6" class="pw-post-body-paragraph im in hi io b ip ks ir is it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj hb bi translated">考虑以下片段:</p><ol class=""><li id="0988" class="la lb hi io b ip iq it iu ix lc jb ld jf le jj lf lg lh li bi translated"><code class="du kx ky kz jp b">onChange</code>单独定义，然后传递到<code class="du kx ky kz jp b">Input</code></li></ol><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="2b51" class="jt ju hi jp b fi jv jw l jx jy">const onChange = () =&gt; {<br/>  ... <br/>  ...<br/>  ...<br/>  ...<br/>  ...<br/>}</span><span id="8fb2" class="jt ju hi jp b fi lo jw l jx jy">&lt;Input<br/> fieldHasError={hasError}<br/> value={selectedDay}<br/> onChange={onChange}<br/>/&gt;</span></pre><p id="5c12" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.匿名函数直接传递给<code class="du kx ky kz jp b">Input</code>中的<code class="du kx ky kz jp b">onChange</code></p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="2f0b" class="jt ju hi jp b fi jv jw l jx jy">&lt;Input<br/> fieldHasError={hasError}<br/> value={selectedDay}<br/> onChange={() =&gt; {<br/>  ...<br/>  ...<br/>  ...<br/>  ...<br/>  ...<br/>/&gt;</span></pre><p id="2d1c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果代码传递函数很短(3-5行),第二种方法是可以接受的，但是如果<code class="du kx ky kz jp b">onChange</code>有50多行呢？第二种方法会导致令人费解的代码，并且会损害可读性。这就是为什么我总是喜欢适当的代码分离，并且将单独定义的处理程序传递给组件，即使这些处理程序只包含几行代码。</p><h2 id="8cba" class="jt ju hi bd jz ka kb kc kd ke kf kg kh ix ki kj kk jb kl km kn jf ko kp kq kr bi translated">5.进口</h2><ol class=""><li id="4bc1" class="la lb hi io b ip ks it kt ix lp jb lq jf lr jj lf lg lh li bi translated">杂乱无序的进口商品</li></ol><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="87b7" class="jt ju hi jp b fi jv jw l jx jy"><strong class="jp hj">import</strong> PropTypes <strong class="jp hj">from</strong> 'prop-types';<br/><strong class="jp hj">import</strong> DayPicker <strong class="jp hj">from</strong> 'react-day-picker';<br/><strong class="jp hj">import</strong> SVGIcon <strong class="jp hj">from</strong> '@ABC/components/SVGIcon';<br/><strong class="jp hj">import</strong> styled <strong class="jp hj">from</strong> 'styled-components';<br/><strong class="jp hj">import</strong> get <strong class="jp hj">from</strong> 'lodash/get';<br/><strong class="jp hj">import</strong> Input <strong class="jp hj">from</strong> '@ABC/components/Input';<br/><strong class="jp hj">import</strong> 'react-day-picker/lib/style.css';<br/><strong class="jp hj">import</strong> React, { useEffect, useRef, useState } <strong class="jp hj">from</strong> 'react';<br/><strong class="jp hj">import</strong> { dateTimeFromJSDate, isValidDate } <strong class="jp hj">from</strong> '../../utils/date';</span></pre><p id="d926" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.隔离(且不杂乱)的进口</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="aab2" class="jt ju hi jp b fi jv jw l jx jy"><strong class="jp hj">import</strong> React, { useEffect, useRef, useState } <strong class="jp hj">from</strong> 'react';<br/><strong class="jp hj">import</strong> PropTypes <strong class="jp hj">from</strong> 'prop-types';<br/><strong class="jp hj">import</strong> DayPicker <strong class="jp hj">from</strong> 'react-day-picker';<br/><strong class="jp hj">import</strong> styled <strong class="jp hj">from</strong> 'styled-components';<br/><strong class="jp hj">import</strong> get <strong class="jp hj">from</strong> 'lodash/get';<br/><strong class="jp hj">import</strong> 'react-day-picker/lib/style.css';</span><span id="034a" class="jt ju hi jp b fi lo jw l jx jy"><strong class="jp hj">import</strong> Input <strong class="jp hj">from</strong> '@ABC/components/Input';<br/><strong class="jp hj">import</strong> ClickOutside <strong class="jp hj">from</strong> '@ABC/utilities/click-outside';<br/><strong class="jp hj">import</strong> SVGIcon <strong class="jp hj">from</strong> '@ABC/components/SVGIcon';</span><span id="0c5d" class="jt ju hi jp b fi lo jw l jx jy"><strong class="jp hj">import</strong> YearMonth <strong class="jp hj">from</strong> './YearMonth';<br/><strong class="jp hj">import</strong> { dateTimeFromJSDate, isValidDate } <strong class="jp hj">from</strong> '../../utils/date';</span></pre><p id="363a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在你可以看到第二个片段更具可读性和组织性。我推荐的通常顺序是第三方导入，本地应用导入，然后本地导入。如果您有多个本地应用程序，请确保在导入每个应用程序后添加一个空格。在第二个代码片段中，我们有第三方导入，然后一些导入来自(local) <code class="du kx ky kz jp b">ABC</code>应用程序，然后我们有一些本地导入。</p></div></div>    
</body>
</html>