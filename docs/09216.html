<html>
<head>
<title>Get Started with Azure Blobs in Databricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Databricks中的Azure Blobs开始</h1>
<blockquote>原文：<a href="https://medium.com/codex/get-started-with-azure-blobs-in-databricks-a6c965b7af4d?source=collection_archive---------9-----------------------#2022-10-04">https://medium.com/codex/get-started-with-azure-blobs-in-databricks-a6c965b7af4d?source=collection_archive---------9-----------------------#2022-10-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="34d8" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">以天蓝色拱顶和火花熊猫为特色</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/318d6d622ddff7f3385e338edde9ee19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ldc1UqQlwbPcKQ2k1sxe2w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">数据块中的蓝色斑点</figcaption></figure><p id="c6ff" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">本教程将介绍如何在Databricks中使用Spark Pandas从Azure blobs中读取和写入数据。blob连接是通过Azure Key Vault访问的。</p><p id="e3ea" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这是关于数据块系列的第3部分:</p><ol class=""><li id="dbe1" class="kj kk hi jp b jq jr jt ju jw kl ka km ke kn ki ko kp kq kr bi translated"><a class="ae ks" href="https://selectfrom.dev/get-started-with-pandas-in-databricks-70b184be0ad3" rel="noopener ugc nofollow" target="_blank">从数据砖块中的熊猫开始</a></li><li id="f046" class="kj kk hi jp b jq kt jt ku jw kv ka kw ke kx ki ko kp kq kr bi translated"><a class="ae ks" rel="noopener" href="/codex/get-started-with-azure-sql-in-databricks-9bfa8d590c64">开始使用Databricks中的Azure SQL</a></li><li id="477f" class="kj kk hi jp b jq kt jt ku jw kv ka kw ke kx ki ko kp kq kr bi translated">从Databricks中的Azure Blobs开始</li></ol><h1 id="3f0a" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">先决条件</h1><ol class=""><li id="be1b" class="kj kk hi jp b jq lq jt lr jw ls ka lt ke lu ki ko kp kq kr bi translated">通过<a class="ae ks" href="https://docs.microsoft.com/en-us/azure/databricks/scenarios/quickstart-create-databricks-workspace-portal?tabs=azure-portal" rel="noopener ugc nofollow" target="_blank"> Azure </a>的数据块实例</li><li id="5f4c" class="kj kk hi jp b jq kt jt ku jw kv ka kw ke kx ki ko kp kq kr bi translated">一个<a class="ae ks" href="https://learn.microsoft.com/en-us/azure/storage/common/storage-account-create?tabs=azure-portal" rel="noopener ugc nofollow" target="_blank"> Azure存储帐户</a></li><li id="210d" class="kj kk hi jp b jq kt jt ku jw kv ka kw ke kx ki ko kp kq kr bi translated">熟悉Databrick的基本功能</li><li id="c14b" class="kj kk hi jp b jq kt jt ku jw kv ka kw ke kx ki ko kp kq kr bi translated">对蟒蛇熊猫有些熟悉</li></ol><h1 id="b062" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">我们的演示案例</h1><p id="20f5" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw lv jy jz ka lw kc kd ke lx kg kh ki hb bi translated">作为示例数据，我们有一个保存课程评估的CSV文件。将这个文件上传到Azure blob后，我们用每个学生的平均评价来丰富数据，然后将结果写回另一个Azure blob。你会在Github 这里找到文件<a class="ae ks" href="https://raw.githubusercontent.com/chpatola/databricks_tutorials/main/data/course_feedback.csv" rel="noopener ugc nofollow" target="_blank">(双击<strong class="jp hj">另存为)</strong>。</a></p><p id="a4a1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了保护对blob的访问，我们将通过一个密钥库来访问它。我们还将遵循<a class="ae ks" href="https://deviq.com/principles/dont-repeat-yourself" rel="noopener ugc nofollow" target="_blank"> DRY原则</a>，创建一个可重复使用的连接函数，供我们的Databricks笔记本使用。</p><h1 id="664c" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">Blob设置</h1><p id="503a" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw lv jy jz ka lw kc kd ke lx kg kh ki hb bi translated">我们为原始数据创建一个blob，为转换后的输出数据创建一个blob。然后，我们将<em class="ly"> course_feedback </em> CSV文件(参见上面的演示案例)上传到原始数据blob。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lz"><img src="../Images/3aa4800996e81ded0f36b9e6fd8e0e81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*kOQeirHy48qppyix4eQ0wQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Blob设置</figcaption></figure><h1 id="46cf" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">密钥库设置</h1><p id="2a09" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw lv jy jz ka lw kc kd ke lx kg kh ki hb bi translated">密钥库是一个“凭据存储库”，用户可以在其中安全地保存和访问凭据。我们应该始终避免在代码或相关文件中写出凭证，因为它们很容易从那里泄露或者意外地出现在版本控制系统中。</p><h2 id="a9fc" class="ma kz hi bd la mb mc md le me mf mg li jw mh mi lk ka mj mk lm ke ml mm lo mn bi translated">在Azure中创建密钥库</h2><p id="d174" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw lv jy jz ka lw kc kd ke lx kg kh ki hb bi translated">要在Azure中创建密钥库，请在门户顶部的资源搜索窗口中搜索“密钥库”。</p><p id="53fa" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">创建密钥库(默认设置)后，转到左窗格中的<strong class="jp hj">机密</strong>。从那里，点击<strong class="jp hj">生成/导入。</strong>为字段<strong class="jp hj">名称</strong>和<strong class="jp hj">秘密值设置一个值。</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/18c25394a4b0f5b5f4829db9b2ba13aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3BV6xph4wQN_GxkhDqFmQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">创造一个秘密</figcaption></figure><ul class=""><li id="c917" class="kj kk hi jp b jq jr jt ju jw kl ka km ke kn ki mp kp kq kr bi translated"><strong class="jp hj">Name</strong>—因为我们将存储帐户密钥作为我们的秘密值，所以我们相应地命名它</li><li id="533f" class="kj kk hi jp b jq kt jt ku jw kv ka kw ke kx ki mp kp kq kr bi translated"><strong class="jp hj">秘密值— </strong>点击您的存储账户，进入<strong class="jp hj">访问密钥</strong>，您将找到存储账户访问密钥。您可以使用key1或key2。点击<strong class="jp hj">显示</strong>查看密钥并复制。</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/32fd58a70a289e120c025a797d13b054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNp1X5F1yKG9SYtugIrOOw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">存储帐户访问密钥</figcaption></figure><h2 id="05a7" class="ma kz hi bd la mb mc md le me mf mg li jw mh mi lk ka mj mk lm ke ml mm lo mn bi translated">数据块中的秘密范围设置</h2><p id="a5dc" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw lv jy jz ka lw kc kd ke lx kg kh ki hb bi translated">建立密钥库之后，我们需要创建一个Databricks secret作用域。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/72ae6dd270bad0a924c70559b1bcf1df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*568S-zbwkz0PJsLf7Pdihw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">设置数据块秘密范围</figcaption></figure><ul class=""><li id="5148" class="kj kk hi jp b jq jr jt ju jw kl ka km ke kn ki mp kp kq kr bi translated">当您位于Databricks实例的起始页时，将<strong class="jp hj"> secrets/createScope </strong>添加到URL的末尾</li><li id="5619" class="kj kk hi jp b jq kt jt ku jw kv ka kw ke kx ki mp kp kq kr bi translated">在该页面上，您被引导在<strong class="jp hj">作用域名称</strong>字段中给出您的Azure密钥库的名称</li><li id="2485" class="kj kk hi jp b jq kt jt ku jw kv ka kw ke kx ki mp kp kq kr bi translated">将<strong class="jp hj">管理主体</strong>下拉菜单设置为<em class="ly">所有用户。</em>这意味着所有的<em class="ly"> </em>用户都被允许读写这个秘密范围。你可以在这里找到更多关于这些设置的信息<a class="ae ks" href="https://learn.microsoft.com/en-us/azure/databricks/security/access-control/secret-acl" rel="noopener ugc nofollow" target="_blank"/></li><li id="642d" class="kj kk hi jp b jq kt jt ku jw kv ka kw ke kx ki mp kp kq kr bi translated">在<strong class="jp hj"> DNS字段</strong>中，插入您在密钥库的<strong class="jp hj">属性</strong>下找到的库URI</li></ul><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/231df6e0b1d391456f8c5f24de6513d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZkWsPf4TgoCuAySnnbzgg.png"/></div></div></figure><ul class=""><li id="660a" class="kj kk hi jp b jq jr jt ju jw kl ka km ke kn ki mp kp kq kr bi translated">将<strong class="jp hj">资源ID </strong>设置为您在密钥库的<strong class="jp hj">属性</strong>下找到的资源ID</li></ul><p id="609e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">密钥存储库设置现已完成，可以从数据块中访问存储帐户密钥。</p><h1 id="659c" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">从数据块访问存储帐户Blobs</h1><p id="278b" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw lv jy jz ka lw kc kd ke lx kg kh ki hb bi translated">我们将通过使用WASB驱动程序将blobs挂载到一个文件夹结构来访问它们。这样，我们可以像访问本地文件一样访问CSV文件。</p><p id="39ee" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将创建可重用的安装和卸载函数，并将其保存在单独的Databricks笔记本中。我们的Databricks实例中的任何笔记本都可以调用这些函数。函数调用是通过从调用笔记本中运行函数笔记本来完成的。在此之后，来自另一个笔记本的所有数据(函数、变量、常数……)对于调用笔记本都是可用的。</p><p id="163f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">你可以在下面的GitHub(<a class="ae ks" href="https://github.com/chpatola/databricks_tutorials/blob/main/Notebooks/connect_azure_blob.html" rel="noopener ugc nofollow" target="_blank"><em class="ly">connect _ azure _ blob</em></a>&amp;<em class="ly">course _ feedback _ blob</em>)上找到我们演示的全部代码。</p><h2 id="8887" class="ma kz hi bd la mb mc md le me mf mg li jw mh mi lk ka mj mk lm ke ml mm lo mn bi translated"><strong class="ak">安装斑点</strong></h2><p id="8d5f" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw lv jy jz ka lw kc kd ke lx kg kh ki hb bi translated">我们首先检查blob是否已经挂载。如果没有，我们继续连接属性，通过我们的密钥库中的秘密访问。如果安装不成功，我们会以一条错误消息结束。</p><pre class="iy iz ja jb fd mt mu mv mw aw mx bi"><span id="4c8e" class="ma kz hi mu b fi my mz l na nb">def mount_blob(storage_account,kv_scope, kv_secret, blob):<br/>    if not any(mount.mountPoint == '/mnt/'+blob+'/' <br/>               for mount in dbutils.fs.mounts()):<br/>        try:<br/>            dbutils.fs.mount(<br/>                source = wasbs://'+blob+'@'+storage_account<br/>                +'.blob.core.windows.net',<br/>                mount_point = '/mnt/'+blob,<br/>                extra_configs = {'fs.azure.account.key.'<br/>                                 +storage_account+<br/>                                 '.blob.core.windows.net':<br/>                                 dbutils.secrets.get(scope=kv_scope,<br/>                                                     key=kv_secret)<br/>                                }<br/>            )<br/>        except Exception as e:<br/>            print('Could not mount. Possible already mounted')</span></pre><h2 id="1a40" class="ma kz hi bd la mb mc md le me mf mg li jw mh mi lk ka mj mk lm ke ml mm lo mn bi translated">卸载Blob</h2><p id="ed12" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw lv jy jz ka lw kc kd ke lx kg kh ki hb bi translated">当我们完成并且不再需要blob连接时，卸载它被认为是一个好的做法。为了处理一种可能的情况，即blob已经被卸载，我们包含了一个检查。</p><pre class="iy iz ja jb fd mt mu mv mw aw mx bi"><span id="b268" class="ma kz hi mu b fi my mz l na nb">def unmount_blob(blob):<br/>    if any(mount.mountPoint == '/mnt/'+blob<br/>           for mount in dbutils.fs.mounts()):<br/>        dbutils.fs.unmount('/mnt/'+blob)<br/>    else:<br/>        print(blob + ' is already unmounted')</span></pre><h2 id="5f24" class="ma kz hi bd la mb mc md le me mf mg li jw mh mi lk ka mj mk lm ke ml mm lo mn bi translated">完成笔记本的安装</h2><p id="536e" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw lv jy jz ka lw kc kd ke lx kg kh ki hb bi translated">为了使安装笔记本的使用更简单，我们添加了一些关于它的功能的信息。静态信息可以写入降价(%md)单元格。当笔记本运行时，这些信息将被打印出来。当笔记本准备好时，我们在共享工作区下创建一个<em class="ly"> Functions </em>文件夹，并保存在那里。我把笔记本命名为<em class="ly"> connect_azure_blob。</em></p><pre class="iy iz ja jb fd mt mu mv mw aw mx bi"><span id="672a" class="ma kz hi mu b fi my mz l na nb">import inspect #Needed to get a list of parameters for functions</span><span id="668a" class="ma kz hi mu b fi nc mz l na nb">print("Parameters for mount_blob function:")<br/>print(inspect.signature(mount_blob))</span><span id="4768" class="ma kz hi mu b fi nc mz l na nb">print("\nParameters for unmount_blob function:")<br/>print(inspect.signature(unmount_blob))</span></pre><h2 id="b7eb" class="ma kz hi bd la mb mc md le me mf mg li jw mh mi lk ka mj mk lm ke ml mm lo mn bi translated">争吵笔记本</h2><p id="618e" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw lv jy jz ka lw kc kd ke lx kg kh ki hb bi translated">在创建了我们的新笔记本——我将其命名为<em class="ly">course _ feedback _ blob</em>——并将其保存在共享工作区中，与<em class="ly"> Functions </em>文件夹在同一层，我们继续导入Spark Pandas并使用<strong class="jp hj"> %run </strong>命令运行<em class="ly"> connect_azure_blob </em>笔记本。</p><pre class="iy iz ja jb fd mt mu mv mw aw mx bi"><span id="7752" class="ma kz hi mu b fi my mz l na nb">import pyspar.pandas as ps</span><span id="cd21" class="ma kz hi mu b fi nc mz l na nb">%run ./Functions/connect_azure_blob</span></pre><p id="01a4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">笔记本运行时，会显示笔记本信息。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/89c8ee173bee6d5739a625b72f6e44a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5rZK5JbLei0CxrbgMRNxg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">通话记录中显示的功能信息</figcaption></figure><p id="a969" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">访问Blob数据</strong></p><p id="c057" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，我们挂载了<em class="ly"> rawdata-courses </em> blob和t<em class="ly">transformed data-courses</em>blob。如果您经常从同一个存储帐户进行读取和写入，那么最好在函数定义中给出前三个参数的默认值。<strong class="jp hj"> read_csv </strong>现在将读取csv文件并将其保存为pandas数据帧，就像它是一个本地文件一样。我们只需要记住路径必须以<em class="ly"> /mnt/name_of_our_blob </em>开头。</p><pre class="iy iz ja jb fd mt mu mv mw aw mx bi"><span id="ee7c" class="ma kz hi mu b fi my mz l na nb">#Mount rawdata-courses blob<br/>mount_blob(storage_account="chpatoladatabricks",<br/>           kv_scope="chpatoladatabricks",<br/>           kv_secret="chpatoladatabricks-storage-account-key",<br/>           blob="rawdata-courses")</span><span id="1a22" class="ma kz hi mu b fi nc mz l na nb">#Mount transformeddata-courses blob<br/>mount_blob(storage_account="chpatoladatabricks",<br/>           kv_scope="chpatoladatabricks",<br/>           kv_secret="chpatoladatabricks-storage-account-key",<br/>           blob="transformeddata-courses")</span><span id="cae3" class="ma kz hi mu b fi nc mz l na nb"><br/>#Read in and inspect raw data from theblob<br/>course_feedback = ps.read_csv(<br/>    '/mnt/rawdata-courses/course_feedback.csv')<br/>course_feedback.info()</span></pre><p id="ee1a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">扯皮</strong></p><p id="01c1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将做的唯一修改是计算每个课程反馈行的总分。</p><pre class="iy iz ja jb fd mt mu mv mw aw mx bi"><span id="8df8" class="ma kz hi mu b fi my mz l na nb"># Transform and inspect data<br/>ps.set_option('compute.ops_on_diff_frames', True)³<br/>course_feedback['Overall'] = course_feedback.iloc[:, 4:7].mean(axis=1).round(2)<br/>course_feedback.head(5)</span></pre><p id="4596" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">将输出写入Blob </strong></p><p id="80d0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">转换后的数据帧现在准备写入到<em class="ly">transformed data-courses</em>blob中。为了确保它安全到达，我们可以读一遍并检查它。</p><pre class="iy iz ja jb fd mt mu mv mw aw mx bi"><span id="915c" class="ma kz hi mu b fi my mz l na nb">#Save transformed data to blob<br/>path = '/mnt/transformeddata-courses/course_feedback_overall.csv'<br/>course_feedback.to_csv(path,index=False)<br/>course_feedback_overall = ps.read_csv(path)<br/>course_feedback_overall.head(5)</span></pre><p id="8f11" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最后一步是卸载已使用的blobs。</p><pre class="iy iz ja jb fd mt mu mv mw aw mx bi"><span id="e55e" class="ma kz hi mu b fi my mz l na nb">unmount_blob("rawdata-courses")<br/>unmount_blob("transformeddata-courses")</span></pre><h1 id="13bb" class="ky kz hi bd la lb lc ld le lf lg lh li io lj ip lk ir ll is lm iu ln iv lo lp bi translated">状态</h1><p id="b9f5" class="pw-post-body-paragraph jn jo hi jp b jq lq ij js jt lr im jv jw lv jy jz ka lw kc kd ke lx kg kh ki hb bi translated">我们现在已经成功地建立了一个密钥库，将其连接到数据块，创建了一个具有装载和卸载Azure blobs功能的笔记本，并最终在笔记本中使用它们，我们从一个blob中读取数据，与Spark Pandas争论并将其写入另一个blob。</p></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><p id="6e76" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[1]:众所周知的熊猫功能，但在Spark上——你可以在这里阅读更多信息<a class="ae ks" href="https://spark.apache.org/docs/latest/api/python/user_guide/pandas_on_spark/index.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="474f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[2]:还有其他方法连接到Azure blob，例如，<a class="ae ks" href="https://learn.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-abfs-driver" rel="noopener ugc nofollow" target="_blank">这里的</a>是关于ABFS驱动的信息。</p><p id="27c7" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">[3]:为了能够在spark python数据帧中创建新列，需要此设置。您可以在本笔记本中找到更多信息和示例。</p></div></div>    
</body>
</html>