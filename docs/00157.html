<html>
<head>
<title>Repeat Yourself — sometimes it is a good thing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重复你自己——有时这是一件好事</h1>
<blockquote>原文：<a href="https://medium.com/codex/repeat-yourself-sometimes-it-is-a-good-thing-141179c11dad?source=collection_archive---------1-----------------------#2020-12-10">https://medium.com/codex/repeat-yourself-sometimes-it-is-a-good-thing-141179c11dad?source=collection_archive---------1-----------------------#2020-12-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9ac3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">DRY原则可能会扰乱您的代码</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/ab593bce2daeb5f9afc6e5ca7087a7a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*6L-lZIqukanp_7_tUj-JSg.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">来自不可能的多个人</figcaption></figure><p id="ed95" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在本文中，我们讨论了DRY(不要重复自己)编程原则的使用。我们将研究一个不应使用干燥剂的情况。我们将看到遵循DRY原则的一步一步的代码重构，它显示了什么该做，什么不该做。</p><p id="34df" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里的所有代码都是过程化的JavaScript。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="7295" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">干燥原则</h1><p id="9aa4" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">在所有的编程原则中，综合各种原因，DRY最吸引我。干是一个常见的名字，这表明它是什么。还有，DRY是一见钟情短语的首字母缩写:不要重复自己。</p><p id="f74a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">可能是因为有道理(谁要双份工作？)如此容易，又容易记忆，我们往往高估了它。在不该用的时候用，没必要的时候用，或者用错了方法。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="4ee2" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">现实生活中的类比</h1><p id="d1e9" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">这一部分是以防干已经成为你的一种信仰。</p><p id="ecef" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">举例A </strong> <br/>想象一栋拥有30套公寓的豪华建筑。每套公寓有4间卧室，带独立浴室和两间公共浴室。也就是说每个公寓有6个卫生间。大楼内的浴室总数为<strong class="jl hj"> 180 </strong> (30 x 6)加上公寓外的一些浴室。这种类型的建筑有几个水箱？<strong class="jl hj">两个</strong>(一个常用一个备用)；不是<strong class="jl hj"> 30 </strong>或<strong class="jl hj"> 180 </strong>。</p><p id="5897" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在世界各地，土木工程师和建筑师使用干式原理来定义每栋建筑只有两个水箱。但是他们<strong class="jl hj"> <em class="kf">忽略了</em> </strong> <em class="kf">在设置豪华公寓卫生间数量时的干燥原则</em>。</p><p id="85b1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">例B </strong> <br/>所有汽车都有4个轮子，但只有一个备胎。这似乎是合理的。对于阶梯轮胎，干燥是可以的。但是如果你在设计一辆汽车时将干燥原则的使用激进化，你将不会生产出一辆汽车，而是一辆独轮车。</p><p id="7174" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">例子C</strong>T32】特斯拉汽车公司决定违背干原则。他们创造了Model S AWD，在Model S中增加了一个<strong class="jl hj">额外的</strong>引擎。他们的工程师担心增加汽车的重量会减少其行驶里程。发生了什么事？里程增加了，因为汽车变得更经济了。你可以在www.fueleconomy.gov的<a class="ae lk" href="https://www.fueleconomy.gov/feg/bymodel/2016_Tesla_Model_S.shtml" rel="noopener ugc nofollow" target="_blank">和</a>检查。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="1c7c" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">不要擦干它</h1><p id="87e7" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">考虑2.5D游戏机制的(过于简化的)代码如下。它的环境就像一个100x100的棋盘，意思是一万个方块。在广场上，我们放置了2000棵树和5000面墙，创造了一个迷宫。这个迷宫将由33个怪物和一个代表玩家的化身组成。神通必须用箭射死怪物:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/9c97dde45c1818f44890f77d1accb1dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*BDHXWvCJt32j27risdEtxw.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">过于简单的游戏代码</figcaption></figure><p id="ea98" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">遵循干燥原则，我们会说列表<em class="kf">生物</em>和<em class="kf">导弹</em>对于列表<em class="kf">方块</em>来说是多余的。我们可以删除那些列表，直接从<em class="kf">方块</em>中读取生物和导弹，调整函数<em class="kf">更新生物</em>和<em class="kf">更新导弹</em>，这样:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/8e732a9e39df8d49ff7d8eab71914439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*RWg2e4O2qXkmzh2vfhtUKQ.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">替代代码</figcaption></figure><p id="5fdf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果我们以这种方式修改代码，我们将会降低应用程序的性能。对于一款游戏来说，性能至关重要。</p><p id="cbec" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">以前，要更新生物(或导弹)，我们需要迭代一个不超过34个元素的列表(箭头的情况下是6个)。现在，我们需要迭代一个包含10，000个元素(正方形)的列表，并且仍然要问10.000次正方形中是否有生物。</p><p id="41cf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是我们必须忽略干原则的情况之一。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="8f8c" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">把它擦干</h1><p id="9871" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">考虑一个小型web应用程序:一个在绘制画布时监视浏览器性能的页面。这个代码示例是关于最近的信息存储在两个列表中的部分，每个列表有40个条目。</p><p id="2e46" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意:这里的代码示例在每一个开头都没有“use strict”。js文件。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/0ad23a19680aea09d7c4019611461ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*immgzE5LixxSlhhZSvuNKw.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">原始代码(可接受)</figcaption></figure><p id="56ea" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上面的代码运行良好。它是以一种轻松的方式编写的，考虑到它是一个小的测试应用程序(1个文件，不到200行)，这是可以接受的。</p><p id="b872" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf">寄存器开始</em>和<em class="kf">寄存器持续时间</em>功能之间的唯一区别在于名称。所以我们可以考虑对它们使用干燥原理。其实<strong class="jl hj">干在这里没必要</strong>(一个小代码里的两个小函数)。但是，让我们来看看会发生什么:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/45cfe7f8389aad6ae7adcda8b8946ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*TNH9nkTaJsifci6ZEqtabw.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">重构代码— 1(坏)</figcaption></figure><p id="320e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在我看来，应用DRY原则的正确方法是在一个库中创建辅助功能:一个特定的模块只为其他模块服务。让我们开始吧。</p><p id="6cd4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf"> main.js </em>模块很棒。清晰多了。我们甚至不需要注释来理解一个<em class="kf">开始</em>或<em class="kf">持续时间</em>是如何注册的。我们知道该值将被放在各自列表的末尾。我们可以在眨眼之间检查每个功能！</p><p id="de8e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<em class="kf"> library.js </em>文件中，我们为helper函数取了一个极好的名字:<em class="kf"> placeTailInList </em>。光是名字，我们就可能猜到它的内部机制。placeTailInList 只使用我们习惯的通用名称，如“n”、“List”和“tail”。简单。</p><p id="44ac" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，我们为未来的制造了一个<strong class="jl hj">问题:如果不改变<em class="kf">持续时间</em>的长度，我们将无法改变<em class="kf">开始</em>的期望长度。让我们来解决这个问题:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/3a183b9d9c82008ba108f78854e2bdf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*wTFGmMZLQg-jOj8JXN_otg.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">重构代码— 2(坏代码)</figcaption></figure><p id="cec7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">好消息:我们实现了<em class="kf">开始</em>和<em class="kf">持续时间</em>列表的独立性。我们能够消除<strong class="jl hj">在<em class="kf"> placeTailInList </em>的(底部)任意使用数字40和39。</strong></p><p id="914f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">坏消息:我们召唤了一个有着许多狂热之手的可怕生物:混乱。还有其他问题，但我们的重点必须是消除混乱:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/73e7afe2251bdb93eb6263366d8a29c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*_vGd_UPCOqGXmslVSW68_w.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">重构代码— 3(坏代码)</figcaption></figure><p id="473f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">通过将<em class="kf"> placeTailInList </em>分成两个功能(<strong class="jl hj"> BOSS </strong>和<strong class="jl hj"> WORKER </strong>，我们能够消除混乱！！</p><blockquote class="lm"><p id="09ed" class="ln lo hi bd lp lq lr ls lt lu lv ke dx translated">boss函数准备供worker函数使用的参数，worker函数完全运行，忽略其上下文。</p></blockquote><p id="ab58" class="pw-post-body-paragraph jj jk hi jl b jm lw ij jo jp lx im jr js ly ju jv jw lz jy jz ka ma kc kd ke hb bi translated">我们有一个缺点:我们使用了字符串形式的标志。它非常实用，但是很容易产生一个编译器和解释器都无法识别的错误。这种技术只适用于小程序。</p><p id="a3bc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们有一个问题:boss函数正在对每个列表的最大长度(40)进行假设。禁止对库函数进行假设。这是一个库函数的完整禁止列表:</p><ol class=""><li id="4034" class="mb mc hi jl b jm jn jp jq js md jw me ka mf ke mg mh mi mj bi translated"><strong class="jl hj"> <em class="kf">它不能读取全局变量</em> </strong></li><li id="fdc8" class="mb mc hi jl b jm mk jp ml js mm jw mn ka mo ke mg mh mi mj bi translated"><strong class="jl hj"> <em class="kf">它不能写全局变量</em> </strong></li><li id="6df6" class="mb mc hi jl b jm mk jp ml js mm jw mn ka mo ke mg mh mi mj bi translated"><strong class="jl hj"> <em class="kf">不能调用其他模块的函数</em> </strong></li><li id="08fe" class="mb mc hi jl b jm mk jp ml js mm jw mn ka mo ke mg mh mi mj bi translated"><strong class="jl hj"> <em class="kf">它无法对上下文做出假设</em> </strong></li></ol><p id="eae5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果我们可以打破所有的规则，并且代码运行顺畅，为什么要有这么多的规则呢？因为违反这些规则会降低代码的可维护性，并且<strong class="jl hj">更容易在未来版本中引发bug</strong>。</p><p id="0585" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此外，如果不是2个列表(<em class="kf">开始</em>和<em class="kf">持续时间</em>)我们有20个列表要处理呢？我们的老板职能不会有一个干巴巴的外观。我们来纠正一下:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/2a711bc5915b7dd7be961c38fb0f6afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*BuvHgC_I7f58zpABD9BEZQ.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">重构代码— 4(坏)</figcaption></figure><p id="411c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们改进了boss函数(<em class="kf"> placeTailInList </em>)。它现在可以处理任意数量的列表，而不需要修改。我们正在检查它收到的每个字符串标志。此外，我们将每个列表的最大长度(40)放在一个地方，可以全局访问。</p><p id="2421" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们有麻烦了。boss函数正在读取一个全局变量(<em class="kf">长度</em>)，这对于库函数是禁止的。</p><p id="eddf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们还有一个问题。字符串标志的检查发生在运行时。我们正在降低应用程序的执行性能，以进行一项应该在编译时完成的检查。是时候进行更多的修复了:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/e4e218564c36b580e04d060cf2b0b5de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*8WEArnB3V40NC33ghb_vEA.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">重构代码— 5(好)</figcaption></figure><p id="9f72" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">朋友，我们终于成功了！我们的代码如此之好，以至于我们不再需要<em class="kf"> library.js </em>中的boss函数。</p><p id="81d0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在的代码比原来的更易读、更健壮、更易维护。它的行数比…哎呀！在所有的重构之后，我们的代码现在比原始代码多了30% <strong class="jl hj">行。它不是应该是干的吗？</strong></p><p id="1636" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">嗯……我们还有最后一张王牌。<em class="kf"> registerStart </em>和<em class="kf"> registerDuration </em>函数…它们的内容只是简单的一行。我们可以删除它们，把它们的内容直接放在它们被调用的地方。这将使代码更短。好吧，让我们试试:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/5853082890963ca092c78cf9a5d41c76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*8yLvxcpEBqiN7ysdDEsRFQ.png"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">重构代码— 6(坏)</figcaption></figure><p id="d031" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">哦不！我们又召集了混乱。似乎这两个只有一行的函数都有一个<strong class="jl hj">重要的角色</strong>:滤波器复杂度。现在我们已经将它们的复杂性(内部细节)直接抛给了它们的调用者…</p><p id="ef1a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们必须退一步重构！</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h1 id="c6c7" class="kn ko hi bd kp kq kr ks kt ku kv kw kx io ky ip kz ir la is lb iu lc iv ld le bi translated">结论</h1><p id="2893" class="pw-post-body-paragraph jj jk hi jl b jm lf ij jo jp lg im jr js lh ju jv jw li jy jz ka lj kc kd ke hb bi translated">这篇文章的第一大教训是“干不应该是个顾虑”。拥有可维护的代码是一个问题。拥有一个高性能的应用程序是一个问题。拥有一个没有被窃听的应用程序是一个问题。但是干…这不是一个问题。这是一种有时很好使用的技术。</p><p id="7b57" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这篇文章的第二个重要教训是，如果你要烘干，就用正确的方式烘干。如果你不打算用正确的方法擦干，那就不要开始。否则你会弄乱你的代码。</p><p id="671d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">谢谢你。</p></div></div>    
</body>
</html>