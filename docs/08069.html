<html>
<head>
<title>Casting in Kotlin — Do you really know it?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在科特林选角——你真的知道吗？</h1>
<blockquote>原文：<a href="https://medium.com/codex/casting-in-kotlin-do-you-really-know-it-73532a727a64?source=collection_archive---------2-----------------------#2022-07-14">https://medium.com/codex/casting-in-kotlin-do-you-really-know-it-73532a727a64?source=collection_archive---------2-----------------------#2022-07-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/25fbd12916caf8ad82d15aba597b9dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTZFusvq1EPSkC5dT0lgWw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">由<a class="ae hv" href="https://pixabay.com/photos/video-production-video-movie-film-4223885/" rel="noopener ugc nofollow" target="_blank"> Bokskapet </a>拍摄的图像</figcaption></figure><div class=""/><p id="8da3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在造型方面，Kotlin编译器相当聪明。它减少了重复代码的数量，并有助于预测运行时的强制转换异常。让编译器变得智能的部分原因是智能强制转换，它是在必要时自动插入安全强制转换。此外，编译器会对可能导致运行时异常的代码抛出警告。本文帮助您进行自我测试，检查您是否能够预测Kotlin编译器在涉及类型转换的不同情况下会做什么。每个问题下面都有详细的解释。我们开始吧！</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="2fb8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"> 1。简单本地值</strong></p><p id="8abf" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们用一个简单的例子来热身，这个函数定义了一个可空的字符串val，检查它的无效性并尝试对它进行大写。</p><p id="ad7a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"> <em class="ka">问:</em> </strong>下面的代码会编译吗？</p><figure class="kb kc kd ke fd hk"><div class="bz dy l di"><div class="kf kg l"/></div></figure><blockquote class="kh ki kj"><p id="bba2" class="iv iw ka ix b iy iz ja jb jc jd je jf kk jh ji jj kl jl jm jn km jp jq jr js hb bi translated"><strong class="ix hz"> A: </strong>可以，编译器自动加a (test as String)。转换，因为它可以保证在第3行的空值检查之后，本地声明的val不会改变值(因此不会变成null)。</p></blockquote><p id="1f17" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"> 2。简单全局变量</strong></p><p id="2f75" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们把变量移出函数，</p><p id="2e44" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"> <em class="ka">问:</em> </strong>下面的代码会编译吗？</p><figure class="kb kc kd ke fd hk"><div class="bz dy l di"><div class="kf kg l"/></div></figure><blockquote class="kh ki kj"><p id="19f0" class="iv iw ka ix b iy iz ja jb jc jd je jf kk jh ji jj kl jl jm jn km jp jq jr js hb bi translated"><strong class="ix hz">答:</strong>否，因为现在在执行第4行之后，第5行之前，一些其他函数可以访问测试变量并为其赋值null。因此，Kotlin编译器不能保证test不为空，代码不会编译。</p></blockquote><p id="bb05" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"> 3。委托本地值</strong></p><p id="5972" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个案子和以前的案子相似。唯一改变的是val的初始化被委托给了lazy函数。</p><p id="c8e7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"> <em class="ka">问:</em> </strong>下面的代码会编译吗？</p><figure class="kb kc kd ke fd hk"><div class="bz dy l di"><div class="kf kg l"/></div></figure><blockquote class="kh ki kj"><p id="71b3" class="iv iw ka ix b iy iz ja jb jc jd je jf kk jh ji jj kl jl jm jn km jp jq jr js hb bi translated"><strong class="ix hz">答:</strong>不会，在使用lazy函数时，编译器无法确定每次调用变量的get()函数都会返回相同的值，也就是说即使第5行的调用不返回null，第6行的调用也可能。因此，上面的代码无法编译。</p></blockquote><p id="5c72" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你好奇的话，我已经在这里贴了一个例子，说明对惰性定义变量的顺序调用产生不同的结果<a class="ae hv" href="https://gist.github.com/frezafoltran/34b6da95762417f5952efdc20525129b" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="eac9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"> 4。简单数据类变量</strong></p><p id="1ff2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们有了一个具有可变属性的数据类<em class="ka"> test </em>。</p><p id="a0c2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"> <em class="ka">问:</em> </strong>下面的代码会编译吗？</p><figure class="kb kc kd ke fd hk"><div class="bz dy l di"><div class="kf kg l"/></div></figure><blockquote class="kh ki kj"><p id="f9d4" class="iv iw ka ix b iy iz ja jb jc jd je jf kk jh ji jj kl jl jm jn km jp jq jr js hb bi translated"><strong class="ix hz">答:</strong>不，在SampleDataClass的实现内部，可空变量test可以将其值更改为null。这种变化可能发生在第7行和第8行的执行之间，因此，上面的代码不会编译。</p></blockquote><p id="2147" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"> 5。类型擦除</strong></p><p id="7762" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种情况涉及类型擦除。简而言之，根据科特林文件:</p><blockquote class="kh ki kj"><p id="3e7e" class="iv iw ka ix b iy iz ja jb jc jd je jf kk jh ji jj kl jl jm jn km jp jq jr js hb bi translated">Kotlin在编译时确保涉及<a class="ae hv" href="https://kotlinlang.org/docs/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>的操作的类型安全，而在运行时，泛型类型的实例不保存关于它们实际类型参数的信息。</p></blockquote><p id="310a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上，在运行时，这意味着<code class="du kn ko kp kq b">List&lt;Int&gt;</code>和<code class="du kn ko kp kq b">List&lt;String&gt;</code>被擦除到<code class="du kn ko kp kq b">List&lt;*&gt;</code>。考虑到这一点，</p><p id="db97" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"> <em class="ka">问:</em> </strong>下面的代码会编译吗？</p><figure class="kb kc kd ke fd hk"><div class="bz dy l di"><div class="kf kg l"/></div></figure><blockquote class="kh ki kj"><p id="0b3d" class="iv iw ka ix b iy iz ja jb jc jd je jf kk jh ji jj kl jl jm jn km jp jq jr js hb bi translated"><strong class="ix hz">答:</strong>否，因为在运行时<code class="du kn ko kp kq b">List&lt;String&gt;</code>被擦除到<code class="du kn ko kp kq b">List&lt;*&gt;</code>，第二条if语句编译失败。编译器识别出这种检查会在运行时失败，并立即失败。</p></blockquote><p id="f192" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的第一个if编译通过。只要<em class="ka"> x </em>是任何类型的<code class="du kn ko kp kq b"><em class="ka">List</em></code>，if条件实际上将评估为真。</p><p id="d321" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">奖金</strong></p><p id="5b02" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">了解类型擦除及其对泛型的影响(如<code class="du kn ko kp kq b"><em class="ka">List</em></code> <em class="ka">)，</em></p><p id="edfe" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz"> <em class="ka">问:</em> </strong>下面的代码会编译吗？</p><figure class="kb kc kd ke fd hk"><div class="bz dy l di"><div class="kf kg l"/></div></figure><blockquote class="kh ki kj"><p id="507b" class="iv iw ka ix b iy iz ja jb jc jd je jf kk jh ji jj kl jl jm jn km jp jq jr js hb bi translated"><strong class="ix hz">答:</strong>会，会编译。在运行时，<code class="du kn ko kp kq b">MutableList&lt;Int&gt;</code>和<code class="du kn ko kp kq b">MutableList&lt;String&gt;</code>具有相同的类型，所以没有办法检查测试<code class="du kn ko kp kq b"><em class="hy">MutableList</em></code> <em class="hy">是否具有int或Strings。为了帮助我们避免不必要的行为，我们确实从编译器那里得到了一个警告，指出有一个未检查的强制转换(在第3行)，正是因为类型擦除。</em></p></blockquote><p id="b9fc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">暂时就这样了。我希望你对科特林的选角工作有了更多的了解。如果你喜欢这些内容，一定要关注我！</p></div></div>    
</body>
</html>