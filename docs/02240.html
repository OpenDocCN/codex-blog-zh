<html>
<head>
<title>Fibonacci Sequence — JavaScript, Recursion &amp; Memoization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">斐波那契数列——JavaScript、递归和记忆</h1>
<blockquote>原文：<a href="https://medium.com/codex/fibonacci-sequence-javascript-recursion-memoization-74d997900ff8?source=collection_archive---------5-----------------------#2021-07-09">https://medium.com/codex/fibonacci-sequence-javascript-recursion-memoization-74d997900ff8?source=collection_archive---------5-----------------------#2021-07-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8bc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">斐波纳契数列到底是什么？我们先来分解一下——什么是序列，什么是数列。数学中的数列是创造某种模式或遵循某种规则的一系列数字的总和。当这组数字遵循某种模式时，这就被归类为一个序列。</p><p id="0fe7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">斐波纳契数列是一系列数字，其中每个数字称为一个斐波纳契数。在这个序列中，fib数是它前面两个数的和。请参见下面的示例:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/897022f3caa1996063aa9699cade055d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gyX_6jGy23XWUO0qYArn_Q.png"/></div></div></figure><p id="af47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了斐波纳契数列的线索，让我们做一些递归问题的解决。</p><p id="49a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jp">问题:</em> </strong>写一个函数‘fib(n)’,它接受一个数作为参数。该函数应该返回斐波那契数列的第n个数字。在我们的例子中，让我们做第8个数字。</p><p id="ab7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们想要序列中的第8个数字——你要怎么做呢？让我们把它画出来:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/2d011ed4e0abe1075f8987f6096f5a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MpN_oReaBNQBGuK3VobAnw.png"/></div></div></figure><p id="3300" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你能认出它遵循的模式吗？这种模式将最终结束，并触及其基本情况。请记住，这些向下计数的数字是n，而不是序列中的实际数字。下面我们来试试这个功能:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/e5f3cece50b091e4485dc1efcdbc3d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cW1mZOHasMDD2kEqS6I85Q.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">原始纤维功能</figcaption></figure><p id="4975" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看函数的第一行:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="8b19" class="jz ka hi jv b fi kb kc l kd ke">if (n≤2) return 1; </span></pre><ul class=""><li id="7498" class="kf kg hi ih b ii ij im in iq kh iu ki iy kj jc kk kl km kn bi translated">这是因为序列的前两个数字(不包括0)是1。</li></ul><p id="0a17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看第二部分:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="3d22" class="jz ka hi jv b fi kb kc l kd ke">return fib(n-1) + fib(n-2); </span></pre><ul class=""><li id="e759" class="kf kg hi ih b ii ij im in iq kh iu ki iy kj jc kk kl km kn bi translated">将n之前的数字和该数字之前的数字相加。</li></ul><p id="60d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在您的控制台中键入此内容，并测试其功能。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="65b5" class="jz ka hi jv b fi kb kc l kd ke">console.log(fib(6)); //8 - Great this works<br/>console.log(fib(7)); //13 - Great this works as well<br/>console.log(fib(8)); //21 - Great this works, did we solve it?</span></pre><p id="532a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你尝试时会发生什么:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="36fc" class="jz ka hi jv b fi kb kc l kd ke">console.log(fib(50)); <br/>// oh no it's like it's taking forever! What's happening?</span><span id="6c22" class="jz ka hi jv b fi ko kc l kd ke">this is JS... remember the callstack and that JS is single threaded!</span></pre><p id="1bd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住这是JavaScript——单线程程序。一句话就让你意识到发生了什么，<strong class="ih hj"> <em class="jp"> callstack </em> </strong> <em class="jp">。如果我们考虑时间和空间复杂性类别，我们会意识到时间复杂性是花费这么长时间的原因= &gt; O(2^n)时间是问题所在。换句话说，这在调用堆栈中花费了太长时间。它在说:</em></p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="d929" class="jz ka hi jv b fi kb kc l kd ke">fib(50) ≈ 2^50 steps <br/>answer: 1.12e + 15 // This is a big number!</span></pre><p id="0efd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显然这需要很长时间，因为这是一个很大的数字。所以我们发现了问题…怎么才能修复我们的函数呢？让我们做一些记忆。什么是记忆化？</p><p id="fa96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">记忆化</strong>是<em class="jp">一种优化技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序。</em>换句话说，我们将存储以前的结果，然后我们不必再次计算它们。</p><p id="8a6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转换函数的第一步——让我们回到节点树，你能看到所有重复的节点吗？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/169782b9e03fdaca72b881c3a1d5d748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WEi8Ely24kCqcSsk4VyALQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">让我们使用记忆化，因为我们在树中看到重复的子节点</figcaption></figure><p id="7f14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很好，你可以看到模式和树中的子节点。现在你能想象树从50开始，会有多少重复的子节点吗？！难怪计算答案要花很长时间。让我们添加更多的逻辑来包含我们函数中的记忆。</p><p id="03ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用JavaScript来思考。JS里什么是快动作？在这种情况下，我们将使用一个JavaScript对象。键将是一个参数，值将是返回值。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="84cf" class="jz ka hi jv b fi kb kc l kd ke">const fib = (n, memo={}) =&gt; {<br/> ....<br/>}</span></pre><p id="0ac1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">memo对象在这里做的是，如果你没有传入第二个参数，默认情况下它会创建一个“memo”JS对象。</p><p id="0ab1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将添加另一个条件来检查memo内部是否存在(n ),如果存在，则返回。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="36fe" class="jz ka hi jv b fi kb kc l kd ke">if (n in memo) return memo[n];</span></pre><p id="f372" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们需要写出:如果不在memo中，计算它，然后存储在memo对象中。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="8787" class="jz ka hi jv b fi kb kc l kd ke">memo[n] = fib(n-1) + fib(n-2)</span></pre><p id="3356" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么让我们返回备忘录:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="4c2a" class="jz ka hi jv b fi kb kc l kd ke">return memo[n];</span></pre><p id="de3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">太好了，它来了！等等，我们好像遗漏了什么。让我们再来看看这个:</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="5b25" class="jz ka hi jv b fi kb kc l kd ke">const fib = (n, memo={}) =&gt; {<br/>            if (n in memo) return memo[n];<br/>            if (n ≤ 2) return 1;<br/>            memo[n] = fib(n-1) + fib(n-2) //what's missing here?<br/>            return memo[n];<br/>};</span></pre><p id="6776" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要确保memo对象正在被使用——通过引用传递。在代码中引用备忘录，在那里你将数字相加。好了，现在它应该是这样的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/7c44794b74d9ae50ae24e516ab84e1a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rDZdD6_Xnw7v08FnyDmraQ.png"/></div></div></figure><p id="da47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">恭喜你，你现在已经在这个函数中使用记忆来加速结果了！测试它—键入<em class="jp">console . log(fib(50))；</em>在你的控制台看看你做了什么！你会意识到，通过使用记忆化来解决这个问题，你减少了从原始函数中进行递归调用的次数。</p><p id="131b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们把这一课带回家——回想一下节点树的图表。既然我们将前面的节点存储在memo对象中，那么我们的最终函数现在看起来是什么样的呢？在下图中，您可以看到我们确实缩小了树或整体时间复杂度，这意味着现在速度快了很多。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/7701163a6877b8ddb59d52969cd7cb07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z2YwUKjaiohK7M-E3h_1FQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">采油树的记忆图—最终</figcaption></figure><p id="e92d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你逗留了这么长时间并阅读了——谢谢！我很高兴我可以教一些人，一些我今天为了好玩而学的东西！没有奋斗，就没有进步——继续学习！</p><p id="6795" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">❤️xoxo-尼科尔</p></div></div>    
</body>
</html>