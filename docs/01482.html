<html>
<head>
<title>Algorithmic Trading with Stochastic Oscillator in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中带随机振荡器的算法交易</h1>
<blockquote>原文：<a href="https://medium.com/codex/algorithmic-trading-with-stochastic-oscillator-in-python-7e2bec49b60d?source=collection_archive---------0-----------------------#2021-05-05">https://medium.com/codex/algorithmic-trading-with-stochastic-oscillator-in-python-7e2bec49b60d?source=collection_archive---------0-----------------------#2021-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="81ee" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">学习用python实现和回溯测试最流行的交易指标之一</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/53c47dda712dd1b58ee2054f771f8581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zWrlQq4swc0P6Qkk"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">克里斯·利维拉尼在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="562f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有很多技术指标可以用来研究和分析，但我们今天要讨论的是交易者最常用的交易指标之一。这不是别人，正是随机振荡器技术指标。在本文中，我们将使用python创建一个基于随机振荡指标的交易策略，并对该策略进行回溯测试，看看它在现实市场中的表现如何。此外，我们还将我们的交易结果与SPY ETF(一种专门设计用于跟踪标准普尔500市场指数的ETF)进行比较，以此来验证我们的策略。事不宜迟，让我们直接进入文章。</p><p id="24be" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在继续之前，如果你想在没有任何代码的情况下回溯测试你的交易策略，有一个解决方案。这是<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">的后验区</a>。这是一个平台，可以免费对不同类型的可交易资产的任意数量的交易策略进行回溯测试，无需编码。点击这里的链接，你可以马上使用这个工具:<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">https://www.backtestzone.com/</a></p><h1 id="a317" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">随机振荡器</h1><p id="3e06" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">随机振荡器是一种基于动量的领先指标，广泛用于识别市场是处于超买还是超卖的状态。这就引出了我们的下一个问题。在令人担忧的市场中，什么是超买和超卖？当市场的趋势看起来非常看涨并且一定会盘整时，股票被认为是超买。类似地，当市场趋势似乎极度看跌并有反弹趋势时，股票到达超卖区域。</p><p id="52d2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于其归一化功能，随机振荡器的值总是在0到100之间。一般超买和超卖水平分别被认为是80和20，但它可能因人而异。随机振荡器包括两个主要组件:</p><ul class=""><li id="0fe8" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated"><strong class="jq hj"> %K线:</strong>这条线是随机振荡器指标中最重要、最核心的组成部分。它也被称为快速随机指标。这条线的唯一目的是表达市场的当前状态(超买或超卖)。这条线的计算方法是从股票的收盘价中减去股票在指定时间段内达到的最低价格，然后将该差值除以从最高股票价格中减去股票在指定时间段内达到的最低价格所得的值。通过将上述步骤计算出的值乘以100，得到最终值。用最流行的设置14作为周期数来计算%K线的方法可以表示如下:</li></ul><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="7441" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">%K = 100 * ((14 DAY CLOSING PRICE - 14 DAY LOWEST PRICE) - (14 DAY HIGHEST PRICE - 14 DAY LOWEST PRICE))</strong></span></pre><ul class=""><li id="ddda" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated"><strong class="jq hj"> %D线:</strong>又称慢随机指标，无非是%K线在特定时期的移动平均线。它也被称为%K线的平滑版本，因为%D线的线图看起来比%K线更平滑。%D行的标准设置是周期数为3。</li></ul><p id="7230" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经了解了随机振荡器实际上是什么。让我们根据指标对我们的交易策略有一些直觉。</p><p id="464e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">随机振荡器交易策略:</strong>我们的交易策略会在以下情况下显示买入信号:</p><ul class=""><li id="d1e3" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated">%K线在20以下</li><li id="61fe" class="lh li hi jq b jr ma ju mb jx mc kb md kf me kj lm ln lo lp bi translated">%D线低于20</li><li id="f856" class="lh li hi jq b jr ma ju mb jx mc kb md kf me kj lm ln lo lp bi translated">%K线在%D线下方</li></ul><p id="61cf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">同样，我们的策略会在以下情况下显示卖出信号:</p><ul class=""><li id="46eb" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated">%K线在80以上</li><li id="7247" class="lh li hi jq b jr ma ju mb jx mc kb md kf me kj lm ln lo lp bi translated">%D线高于80</li><li id="bb0b" class="lh li hi jq b jr ma ju mb jx mc kb md kf me kj lm ln lo lp bi translated">%K线在%D线之上</li></ul><p id="4a6e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如你所看到的，三个条件必须得到满足，才能显示买入信号或卖出信号。我们的交易策略可以表述如下:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="ad03" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">IF %K LINE &lt; 20 AND %D LINE &lt; 20 AND %K LINE &lt; %D LINE =&gt; BUY<br/>IF %K LINE &gt; 80 AND %D LINE &gt; 80 AND %K LINE &gt; %D LINE =&gt; SELL</strong></span></pre><p id="2c06" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就结束了我们关于随机振荡器和交易策略的理论部分。现在让我们用python编写交易策略代码，看看一些令人兴奋的结果。在继续之前，免责声明:本文的唯一目的是教育人们，必须被视为信息，而不是投资建议或其他。</p><h1 id="79cf" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">用Python实现</h1><p id="1fce" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">编码部分分为以下几个步骤:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="e530" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">1. Importing Packages<br/>2. Extracting Data from Alpha Vantage<br/>3. Extracting the Stochastic Oscillator values<br/>4. Stochastic Oscillator Plot<br/>5. Creating the Trading Strategy<br/>6. Plotting the Trading Lists<br/>7. Creating our Position<br/>8. Backtesting<br/>9. SPY ETF Comparison</strong></span></pre><p id="1dc0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h2 id="22fd" class="lv kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤1:导入包</h2><p id="9e8c" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="fe39" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="4af9" class="lv kl hi lr b fi lw lx l ly lz">import pandas as pd<br/>import numpy as np<br/>import requests<br/>from termcolor import colored as cl<br/>from math import floor<br/>import matplotlib.pyplot as plt</span><span id="4dc2" class="lv kl hi lr b fi ms lx l ly lz">plt.rcParams[‘figure.figsize’] = (20, 10)<br/>plt.style.use(‘fivethirtyeight’)</span></pre><p id="b967" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">既然我们已经将所有基本的包导入到python环境中。让我们用Alpha Vantage强大的股票API提取网飞的历史数据。</p><h2 id="b32f" class="lv kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤2:从Alpha Vantage中提取数据</h2><p id="eb21" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将使用Alpha Vantage提供的API端点提取网飞的历史数据。在此之前，关于Alpha Vantage的一个说明:Alpha Vantage提供免费的股票API，用户可以通过这些API访问各种数据，如实时更新，以及股票、货币和加密货币的历史数据。确保你在Alpha Vantage上有一个帐户，只有这样，你才能访问你的秘密API密匙(使用API提取数据的一个关键元素)。</p><p id="c23c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="3bf1" class="lv kl hi lr b fi lw lx l ly lz">def get_historical_data(symbol, start_date = None):<br/>    api_key = open(r'api_key.txt')<br/>    api_url = f'https://www.alphavantage.co/query?function=TIME_SERIES_DAILY_ADJUSTED&amp;symbol={symbol}&amp;apikey={api_key}&amp;outputsize=full'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df[f'Time Series (Daily)']).T<br/>    df = df.rename(columns = {'1. open': 'open', '2. high': 'high', '3. low': 'low', '4. close': 'Close', '5. adjusted close': 'adj close', '6. volume': 'volume'})<br/>    for i in df.columns:<br/>        df[i] = df[i].astype(float)<br/>    df.index = pd.to_datetime(df.index)<br/>    df = df.iloc[::-1].drop(['7. dividend amount', '8. split coefficient'], axis = 1)<br/>    if start_date:<br/>        df = df[df.index &gt;= start_date]<br/>    return df<br/><br/>nflx = get_historical_data('NFLX', '2020-01-01')<br/>nflx</span></pre><p id="a94e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mt"><img src="../Images/ed9d1798147d27b33d7e66792c1a4258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0dh3R5pNe7Wz7b9xYQMSNA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="3d28" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们做的第一件事是定义一个名为‘get _ historical _ data’的函数，该函数将股票的符号(‘symbol’)作为必需参数，将历史数据的开始日期(‘start _ date’)作为可选参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们调用创建的函数从2020年开始提取网飞的历史数据，并将其存储到“nflx”变量中。</p><h2 id="da32" class="lv kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤3:提取随机振荡器值</h2><p id="41c2" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将借助Alpha Vantage提供的API端点来提取网飞的随机振荡器值。这一步和我们上一步做的差不多。</p><p id="fd68" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="1f3d" class="lv kl hi lr b fi lw lx l ly lz">def get_stoch(symbol, k_period, d_period, start_date):<br/>    api_key = open(r'api_key.txt')<br/>    url = f'https://www.alphavantage.co/query?function=STOCH&amp;symbol={symbol}&amp;interval=daily&amp;fastkperiod={k_period}&amp;slowdperiod={d_period}&amp;apikey={api_key}'<br/>    raw = requests.get(url).json()<br/>    df = pd.DataFrame(raw['Technical Analysis: STOCH']).T.iloc[::-1]<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    df = df.astype(float)<br/>    return df['SlowK'], df['SlowD']<br/><br/>nflx['%k'], nflx['%d'] = get_stoch('NFLX', 14, 3, '2020-01-01')<br/>nflx = nflx.dropna()<br/>nflx.head()</span></pre><p id="f4c6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/1bfd50adca02a9282947bcf61a625689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ml-DR1SVEoSElTB55iejJA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="6942" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为“get_stoch”的函数，它将股票的符号(' symbol ')、%K线的周期数(' k_period ')、%D线的周期数(' d_period ')和数据的开始日期(' start_date ')作为参数。在函数内部，我们首先分配两个名为“api_key”和“url”的变量，分别存储api键和API URL。使用Requests包提供的“get”函数，我们调用API并将响应存储到“raw”变量中。在进行了一些数据操作之后，我们将返回%K值和%D值。最后，我们调用这个函数来提取网飞的随机振荡值。</p><h2 id="2834" class="lv kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤4: <strong class="ak">随机振荡器图</strong></h2><p id="eb6a" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将绘制提取的网飞随机振荡器值，以使其更有意义。这一部分的主要目的不是在编码部分，而是观察图形以获得对随机振荡器的牢固理解。</p><p id="c663" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="36d3" class="lv kl hi lr b fi lw lx l ly lz">def plot_stoch(symbol, price, k, d):<br/>    ax1 = plt.subplot2grid((9, 1), (0,0), rowspan = 5, colspan = 1)<br/>    ax2 = plt.subplot2grid((9, 1), (6,0), rowspan = 3, colspan = 1)<br/>    ax1.plot(price)<br/>    ax1.set_title(f'{symbol} STOCK PRICE')<br/>    ax2.plot(k, color = 'deepskyblue', linewidth = 1.5, label = '%K')<br/>    ax2.plot(d, color = 'orange', linewidth = 1.5, label = '%D')<br/>    ax2.axhline(80, color = 'black', linewidth = 1, linestyle = '--')<br/>    ax2.axhline(20, color = 'black', linewidth = 1, linestyle = '--')<br/>    ax2.set_title(f'{symbol} STOCH')<br/>    ax2.legend()<br/>    plt.show()<br/>    <br/>plot_stoch('NFLX', nflx['Close'], nflx['%k'], nflx['%d'])</span></pre><p id="cee4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/69b65ba2b97467add8103b12a0086141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hT7F8MmVnEAcyx7aV-nE0A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="6afb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该图细分为两个面板:上面板和下面板。上部面板代表网飞收盘价的折线图。下面的面板包括随机振荡器的组件。作为领先指标，随机振荡指标不能和收盘价一起绘制，因为指标值和收盘价变化很大。因此，它与收盘价(在我们的例子中低于收盘价)分开绘制。我们之前讨论过的成分%K线和%D线分别用蓝色和橙色绘制。您还可以注意到%K和%D线上方和下方的两条额外的黑色虚线。它是被称为波段的随机振荡器的附加组件。这些波段用来突出超买和超卖的区域。如果%K线和%D线都在高波段上方交叉，那么股票被认为是超买。同样，当%K和%D线都穿过低波段时，股票被认为超卖。</p><h2 id="4b90" class="lv kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤5:创建交易策略</h2><p id="9267" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将在python中实现所讨论的随机振荡交易策略。</p><p id="2607" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="38c6" class="lv kl hi lr b fi lw lx l ly lz">def implement_stoch_strategy(prices, k, d):    <br/>    buy_price = []<br/>    sell_price = []<br/>    stoch_signal = []<br/>    signal = 0<br/><br/>    for i in range(len(prices)):<br/>        if k[i] &lt; 20 and d[i] &lt; 20 and k[i] &lt; d[i]:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                stoch_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                stoch_signal.append(0)<br/>        elif k[i] &gt; 80 and d[i] &gt; 80 and k[i] &gt; d[i]:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                stoch_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                stoch_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            stoch_signal.append(0)<br/>            <br/>    return buy_price, sell_price, stoch_signal<br/>            <br/>buy_price, sell_price, stoch_signal = implement_stoch_strategy(nflx['Close'], nflx['%k'], nflx['%d'])</span></pre><p id="699c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为‘implement _ stoch _ strategy’的函数，它将股票价格(‘price’)以及% K(‘K’)和%D行值(‘D’)作为参数。</p><p id="31eb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在该函数中，我们创建了三个空列表(buy_price、sell_price和stoch_signal ),在创建交易策略时，将在这些列表中追加值。</p><p id="c59c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之后，我们通过for循环实施交易策略。在for循环内部，我们传递某些条件，如果条件得到满足，相应的值将被追加到空列表中。如果购买股票的条件得到满足，买入价将被追加到“buy_price”列表中，信号值将被追加为1，表示购买股票。类似地，如果卖出股票的条件得到满足，卖价将被追加到“sell_price”列表中，信号值将被追加为-1，表示卖出股票。</p><p id="14ce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们返回附加了值的列表。然后，我们调用创建的函数并将值存储到各自的变量中。除非我们画出这些值，否则这个列表没有任何意义。所以，让我们画出创建的交易列表的值。</p><h2 id="b071" class="lv kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤6:绘制交易信号</h2><p id="c9a5" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将绘制已创建的交易列表，以使它们有意义。</p><p id="585e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="ca92" class="lv kl hi lr b fi lw lx l ly lz">ax1 = plt.subplot2grid((9, 1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((9, 1), (6,0), rowspan = 3, colspan = 1)<br/>ax1.plot(nflx['Close'], color = 'skyblue', label = 'NFLX')<br/>ax1.plot(nflx.index, buy_price, marker = '^', color = 'green', markersize = 10, label = 'BUY SIGNAL', linewidth = 0)<br/>ax1.plot(nflx.index, sell_price, marker = 'v', color = 'r', markersize = 10, label = 'SELL SIGNAL', linewidth = 0)<br/>ax1.legend(loc = 'upper left')<br/>ax1.set_title('NFLX STOCK PRICE')<br/>ax2.plot(nflx['%k'], color = 'deepskyblue', linewidth = 1.5, label = '%K')<br/>ax2.plot(nflx['%d'], color = 'orange', linewidth = 1.5, label = '%D')<br/>ax2.axhline(80, color = 'black', linewidth = 1, linestyle = '--')<br/>ax2.axhline(20, color = 'black', linewidth = 1, linestyle = '--')<br/>ax2.set_title('NFLX STOCH')<br/>ax2.legend()<br/>plt.show()</span></pre><p id="0f77" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/74c66c3793944c9f5fe5511f80c0a764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-3iXavMbeoFrSNdQxeWmVw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="622d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们在绘制随机振荡器的成分，以及交易策略产生的买入和卖出信号。我们可以观察到，当%K线和%D线都在低波段下方交叉，并且%K线在%D线下方交叉时，图表中就会出现绿色的买入信号。类似地，当%K线和%D线都在高波段上方交叉，并且%K线在%D线上方交叉时，图表中就会出现红色的卖出信号。</p><h2 id="a61e" class="lv kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤7:创建我们的职位</h2><p id="c50e" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将创建一个列表，如果我们持有股票，该列表将指示1；如果我们不拥有或持有股票，该列表将指示0。</p><p id="bbda" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="09c2" class="lv kl hi lr b fi lw lx l ly lz">position = []<br/>for i in range(len(stoch_signal)):<br/>    if stoch_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(nflx['Close'])):<br/>    if stoch_signal[i] == 1:<br/>        position[i] = 1<br/>    elif stoch_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>k = nflx['%k']<br/>d = nflx['%d']<br/>close_price = nflx['Close']<br/>stoch_signal = pd.DataFrame(stoch_signal).rename(columns = {0:'stoch_signal'}).set_index(nflx.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'stoch_position'}).set_index(nflx.index)<br/><br/>frames = [close_price, k, d, stoch_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy.tail()</span></pre><p id="3b50" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/55225c148eed32122cd0b1ced8f5a849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eiBemwr5RMN0TyEBCGtaBg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="571a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们创建一个名为‘position’的空列表。我们传递两个for循环，一个是为“位置”列表生成值，以匹配“信号”列表的长度。另一个for循环是我们用来生成实际位置值的循环。在第二个for循环中，我们对“signal”列表的值进行迭代，而“position”列表的值被附加到满足哪个条件上。如果我们持有股票，头寸的价值仍为1；如果我们卖出或不持有股票，头寸的价值仍为0。最后，我们正在进行一些数据操作，将所有创建的列表合并到一个数据帧中。</p><p id="aede" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从显示的输出中，我们可以看到，在第一行中，我们在股票中的位置保持为0(因为随机振荡器信号没有任何变化)，但当随机振荡器交易信号代表买入信号(1)时，我们的位置突然变为1。我们的头寸将保持在1，直到交易信号发生一些变化。现在是时候实现一些回溯测试过程了！</p><h2 id="d68e" class="lv kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤8:回溯测试</h2><p id="36b8" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在继续之前，有必要知道什么是回溯测试。回溯测试是查看我们的交易策略在给定股票数据上表现如何的过程。在我们的例子中，我们将对网飞股票数据的随机振荡器交易策略进行回溯测试。</p><p id="561a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="d168" class="lv kl hi lr b fi lw lx l ly lz">nflx_ret = pd.DataFrame(np.diff(nflx['Close'])).rename(columns = {0:'returns'})<br/>stoch_strategy_ret = []<br/><br/>for i in range(len(nflx_ret)):<br/>    try:<br/>        returns = nflx_ret['returns'][i]*strategy['stoch_position'][i]<br/>        stoch_strategy_ret.append(returns)<br/>    except:<br/>        pass<br/>    <br/>stoch_strategy_ret_df = pd.DataFrame(stoch_strategy_ret).rename(columns = {0:'stoch_returns'})<br/><br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/nflx['Close'][-1])<br/>stoch_investment_ret = []<br/><br/>for i in range(len(stoch_strategy_ret_df['stoch_returns'])):<br/>    returns = number_of_stocks*stoch_strategy_ret_df['stoch_returns'][i]<br/>    stoch_investment_ret.append(returns)<br/><br/>stoch_investment_ret_df = pd.DataFrame(stoch_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(stoch_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the STOCH strategy by investing $100k in NFLX : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the STOCH strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre><p id="2bfd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="1b0a" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">Profit gained from the STOCH strategy by investing $100k in NFLX : 45001.44<br/>Profit percentage of the STOCH strategy : 45%</strong></span></pre><p id="cbac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们使用NumPy包提供的“diff”函数计算网飞股票的回报率，并将其作为数据帧存储到“nflx_ret”变量中。接下来，我们将传递一个for循环来迭代' nflx_ret '变量的值，以计算我们从随机振荡器交易策略中获得的回报，这些回报值将被附加到' stoch_strategy_ret '列表中。接下来，我们将“stoch_strategy_ret”列表转换为数据帧，并将其存储到“stoch_strategy_ret_df”变量中。</p><p id="65cb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是回溯测试过程。我们将通过投资10万美元到我们的交易策略中来回测我们的策略。首先，我们将投资金额存储到“投资值”变量中。之后，我们将使用投资金额计算我们可以购买的网飞股票数量。你可以注意到，我使用了Math软件包提供的“下限”函数，因为当投资金额除以网飞股票的收盘价时，它会输出一个十进制数。股票数量应该是整数，而不是小数。使用“底数”函数，我们可以去掉小数。请记住,“floor”函数比“round”函数要复杂得多。然后，我们传递一个for循环来寻找投资回报，随后是一些数据操作任务。</p><p id="9d6d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们打印了我们通过投资10万美元到我们的交易策略中得到的总回报，并且显示我们在一年中获得了大约4万美元的利润。那还不错！现在，让我们将我们的回报与SPY ETF(一种旨在跟踪标准普尔500股票市场指数的ETF)的回报进行比较。</p><h2 id="62c9" class="lv kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">步骤9: SPY ETF对比</h2><p id="a9d1" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">这一步是可选的，但强烈推荐，因为我们可以了解我们的交易策略相对于基准(间谍ETF)的表现如何。在这一步，我们将使用我们创建的“get_historical_data”函数提取SPY ETF的数据，并将我们从SPY ETF获得的回报与我们在网飞的随机振荡器策略回报进行比较。</p><p id="00df" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="977b" class="lv kl hi lr b fi lw lx l ly lz">def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['Close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('STOCH Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre><p id="e058" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="5a57" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">Benchmark profit by investing $100k : 21780.0</strong><br/><strong class="lr hj">Benchmark Profit percentage : 21%</strong><br/><strong class="lr hj">STOCH Strategy profit is 24% higher than the Benchmark Profit</strong></span></pre><p id="40bf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>此步骤中使用的代码几乎与前一个回溯测试步骤中使用的代码相似，但我们不是投资网飞，而是通过不实施任何交易策略来投资SPY ETF。从输出可以看出，我们的随机振荡器交易策略跑赢了SPY ETF 24%。太好了！</p><h1 id="4572" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后的想法！</h1><p id="0b78" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">经过理论和编码部分的漫长过程，我们最终用python构建了一个随机振荡器交易策略。我不能保证我们建立的这种特定策略在现实市场中表现良好，但是您可以通过遵循两个最重要的步骤来期待非凡的结果:</p><ul class=""><li id="dc94" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated"><strong class="jq hj">策略调整:</strong>随机振荡指标就是这样一种指标，它往往会多次揭示错误信号。如果你实施随机振荡交易策略而不做任何调整，那么面对灾难性结果的可能性是巨大的。你如何调整随机振荡策略？最推荐的调整策略的步骤是添加一个额外的技术指标。这个额外的指标将作为策略的验证指标，并有助于揭示真实的交易进出。我们没有讨论这一部分，因为这篇文章的唯一目的只是探索随机指标，而不是使用该指标进行任何有利可图的交易。</li><li id="72de" class="lh li hi jq b jr ma ju mb jx mc kb md kf me kj lm ln lo lp bi translated"><strong class="jq hj">挑选股票:</strong>在这篇文章中，我们没有采取任何步骤来挑选具有特定因素的股票，而是随机进行，这不是进入现实世界市场的好方法。出于交易目的挑选股票有很多步骤，确保你执行了其中一个步骤来挑选适合你的股票。这一步至关重要，也是必须知道的一步，因为你可能会面临负面交易，即使你有很好的交易策略，但没有在正确的股票上实施。</li></ul><p id="51b3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就是这样！如果您忘记了遵循任何编码部分，不要担心。我在本文末尾提供了完整的源代码。希望你能从这篇文章中学到一些有用的东西。</p><h2 id="1187" class="lv kl hi bd km mf mg mh kq mi mj mk ku jx ml mm kw kb mn mo ky kf mp mq la mr bi translated">完整代码:</h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="8ed6" class="lv kl hi lr b fi lw lx l ly lz">import pandas as pd<br/>import numpy as np<br/>import requests<br/>from termcolor import colored as cl<br/>from math import floor<br/>import matplotlib.pyplot as plt<br/><br/>plt.rcParams['figure.figsize'] = (20, 10)<br/>plt.style.use('fivethirtyeight')<br/><br/>def get_historical_data(symbol, start_date = None):<br/>    api_key = open(r'api_key.txt')<br/>    api_url = f'https://www.alphavantage.co/query?function=TIME_SERIES_DAILY_ADJUSTED&amp;symbol={symbol}&amp;apikey={api_key}&amp;outputsize=full'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df[f'Time Series (Daily)']).T<br/>    df = df.rename(columns = {'1. open': 'open', '2. high': 'high', '3. low': 'low', '4. close': 'Close', '5. adjusted close': 'adj close', '6. volume': 'volume'})<br/>    for i in df.columns:<br/>        df[i] = df[i].astype(float)<br/>    df.index = pd.to_datetime(df.index)<br/>    df = df.iloc[::-1].drop(['7. dividend amount', '8. split coefficient'], axis = 1)<br/>    if start_date:<br/>        df = df[df.index &gt;= start_date]<br/>    return df<br/><br/>nflx = get_historical_data('NFLX', '2020-01-01')<br/>nflx.head()<br/><br/>def get_stoch(symbol, k_period, d_period, start_date):<br/>    api_key = open(r'api_key.txt')<br/>    url = f'https://www.alphavantage.co/query?function=STOCH&amp;symbol={symbol}&amp;interval=daily&amp;fastkperiod={k_period}&amp;slowdperiod={d_period}&amp;apikey={api_key}'<br/>    raw = requests.get(url).json()<br/>    df = pd.DataFrame(raw['Technical Analysis: STOCH']).T.iloc[::-1]<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    df = df.astype(float)<br/>    return df['SlowK'], df['SlowD']<br/><br/>nflx['%k'], nflx['%d'] = get_stoch('NFLX', 14, 3, '2020-01-01')<br/>nflx = nflx.dropna()<br/>nflx.head()<br/><br/>def plot_stoch(symbol, price, k, d):<br/>    ax1 = plt.subplot2grid((9, 1), (0,0), rowspan = 5, colspan = 1)<br/>    ax2 = plt.subplot2grid((9, 1), (6,0), rowspan = 3, colspan = 1)<br/>    ax1.plot(price)<br/>    ax1.set_title(f'{symbol} STOCK PRICE')<br/>    ax2.plot(k, color = 'deepskyblue', linewidth = 1.5, label = '%K')<br/>    ax2.plot(d, color = 'orange', linewidth = 1.5, label = '%D')<br/>    ax2.axhline(80, color = 'black', linewidth = 1, linestyle = '--')<br/>    ax2.axhline(20, color = 'black', linewidth = 1, linestyle = '--')<br/>    ax2.set_title(f'{symbol} STOCH')<br/>    ax2.legend()<br/>    plt.show()<br/>    <br/>plot_stoch('NFLX', nflx['Close'], nflx['%k'], nflx['%d'])<br/><br/>def implement_stoch_strategy(prices, k, d):    <br/>    buy_price = []<br/>    sell_price = []<br/>    stoch_signal = []<br/>    signal = 0<br/><br/>    for i in range(len(prices)):<br/>        if k[i] &lt; 20 and d[i] &lt; 20 and k[i] &lt; d[i]:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                stoch_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                stoch_signal.append(0)<br/>        elif k[i] &gt; 80 and d[i] &gt; 80 and k[i] &gt; d[i]:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                stoch_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                stoch_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            stoch_signal.append(0)<br/>            <br/>    return buy_price, sell_price, stoch_signal<br/>            <br/>buy_price, sell_price, stoch_signal = implement_stoch_strategy(nflx['Close'], nflx['%k'], nflx['%d'])<br/><br/>ax1 = plt.subplot2grid((9, 1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((9, 1), (6,0), rowspan = 3, colspan = 1)<br/>ax1.plot(nflx['Close'], color = 'skyblue', label = 'NFLX')<br/>ax1.plot(nflx.index, buy_price, marker = '^', color = 'green', markersize = 10, label = 'BUY SIGNAL', linewidth = 0)<br/>ax1.plot(nflx.index, sell_price, marker = 'v', color = 'r', markersize = 10, label = 'SELL SIGNAL', linewidth = 0)<br/>ax1.legend(loc = 'upper left')<br/>ax1.set_title('NFLX STOCK PRICE')<br/>ax2.plot(nflx['%k'], color = 'deepskyblue', linewidth = 1.5, label = '%K')<br/>ax2.plot(nflx['%d'], color = 'orange', linewidth = 1.5, label = '%D')<br/>ax2.axhline(80, color = 'black', linewidth = 1, linestyle = '--')<br/>ax2.axhline(20, color = 'black', linewidth = 1, linestyle = '--')<br/>ax2.set_title('NFLX STOCH')<br/>ax2.legend()<br/>plt.show()<br/><br/>position = []<br/>for i in range(len(stoch_signal)):<br/>    if stoch_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(nflx['Close'])):<br/>    if stoch_signal[i] == 1:<br/>        position[i] = 1<br/>    elif stoch_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>k = nflx['%k']<br/>d = nflx['%d']<br/>close_price = nflx['Close']<br/>stoch_signal = pd.DataFrame(stoch_signal).rename(columns = {0:'stoch_signal'}).set_index(nflx.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'stoch_position'}).set_index(nflx.index)<br/><br/>frames = [close_price, k, d, stoch_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy.tail()<br/><br/>nflx_ret = pd.DataFrame(np.diff(nflx['Close'])).rename(columns = {0:'returns'})<br/>stoch_strategy_ret = []<br/><br/>for i in range(len(nflx_ret)):<br/>    try:<br/>        returns = nflx_ret['returns'][i]*strategy['stoch_position'][i]<br/>        stoch_strategy_ret.append(returns)<br/>    except:<br/>        pass<br/>    <br/>stoch_strategy_ret_df = pd.DataFrame(stoch_strategy_ret).rename(columns = {0:'stoch_returns'})<br/><br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/nflx['Close'][-1])<br/>stoch_investment_ret = []<br/><br/>for i in range(len(stoch_strategy_ret_df['stoch_returns'])):<br/>    returns = number_of_stocks*stoch_strategy_ret_df['stoch_returns'][i]<br/>    stoch_investment_ret.append(returns)<br/><br/>stoch_investment_ret_df = pd.DataFrame(stoch_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(stoch_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the STOCH strategy by investing $100k in NFLX : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the STOCH strategy : {}%'.format(profit_percentage), attrs = ['bold']))<br/><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['Close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('STOCH Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre></div></div>    
</body>
</html>