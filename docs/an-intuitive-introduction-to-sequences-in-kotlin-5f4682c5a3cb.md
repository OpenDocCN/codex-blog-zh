# 科特林序列的直观介绍

> 原文：<https://medium.com/codex/an-intuitive-introduction-to-sequences-in-kotlin-5f4682c5a3cb?source=collection_archive---------4----------------------->

![](img/b5521db4183792e6fcdfe73954299acf.png)

照片由 [thegermankid](https://pixabay.com/photos/mountains-sky-river-stream-water-5435903/) 拍摄

Kotlin 有众所周知的集合类型来处理 iterables，比如列表、集合和映射。然而，当涉及到可以通过使用另一种集合类型(序列)来改进的大型数据集或繁重计算时，这些类型具有局限性。本文的目标是通过分析序列优于其他集合和不优于其他集合的情况，向您介绍序列。让我们开始吧！

# 基本定义和区别

集合类型如`List`、`Set`和`Map`，也被称为*急切集合*，因为一旦它们被实例化，它们包含的所有值都是现成的，可以被访问。尽管也是集合并共享相同的函数，`Sequences`只在被请求时才计算单个值。换句话说，它们是*懒惰的集合*，按需生产每一个项目。

为了使事情更具体，看看这个产生质数的例子:

请注意，序列的值直到您在第 5 行中使用`take`函数实际请求它们时才被计算出来，而列表值是立即被计算出来的。这有一些重要的含义，我们将在下面更详细地探讨。

> 另一个值得注意的点是，序列输出 10 个值，而列表只输出 4 个值，即使它们都被输入了相同的参数`n`。也许用简单的英语来解释更好:上面的序列生成素数，我们要求它的前 10 个值；上面的列表过滤了质数，我们输入了前 10 个正数，在这个范围内有 4 个质数。

# 无限序列

上面的例子展示了序列的强大之处:它们可以产生无限满足某个条件的元素。也就是说，我们可以将`*n*` 更改为任何值，序列将总是产生第一个`*n*`质数。这种行为在列表中是不可能的，因为它们没有从以前的值(如序列)构建的构造函数。

其实这就解释了语法`*generateSequence(0){ it + 1}*` *。*传递给函数的参数是初始种子值(本例中为 0)，lambda 表示每次需要一个新项目时如何处理它(递增 1)。在上面的例子中，只有当序列满足`*filter*`中的条件时，才会返回一个值，确保我们总是得到`*n*` 素数。还有其他的语法来初始化序列，你可以在这里查看。

# 操作顺序

根据上面的例子，假设我们现在想要找到`*0..10*` 范围中第一个二进制形式为 2 的数(即其[汉明权重](https://en.wikipedia.org/wiki/Hamming_weight)为 2)。我们可以通过构建一个序列或列表并调用 find 函数来实现这一点。

通过查看日志，我们注意到尽管两种方法都正确地返回数字 3，但它们处理问题的方式不同。序列只评估`*bitCount*`条件，直到找到匹配条件的数字，而列表检查范围内每个数字的条件，然后返回匹配条件的数字。

如果我们将`*bitCount*` 操作替换为一个更大的操作，这种差异就变得更加重要。由于序列在满足条件后不需要处理元素，所以它会比列表更快地完成执行。

> 简而言之，序列在移动到下一个元素之前处理给定元素的所有操作，如果已经满足了所需的条件，则允许它们避免执行额外的工作。而列表在移动到下一个操作之前对所有元素执行给定的操作，这意味着即使已经满足了某个条件，它们也会做不必要的额外工作。

# 存储器分配

速度不是使用序列的唯一优势，它们还可以处理大型数据集，分配更少的内存并避免潜在的错误。为了说明这一点，考虑对前面例子的一个小修改，在检查`*bitCount*` 之前，我们将集合中的每个元素加倍。

两种方法都正确地返回`*6*`,和以前一样，一旦找到结果，序列就停止处理。现在一个重要的区别是，当我们映射列表使其值加倍时，会创建一个新的集合，分配内存来存储所有加倍的列表值。事实上，即使我们简单地调用`*onEach*`函数来打印值，也会创建一个新的集合。当我们使用序列时，因为每个元素都是按需计算的，所以没有必要为整个集合重复分配内存。

如果我们有一个包含大量条目的数据集，甚至是一个包含大量条目的小数据集，那么列表需要的这种重复内存分配很快就会成为一个问题，并可能引发内存不足错误。

# 为什么不总是使用序列呢？

序列不索引它们的内容，也不跟踪它们的大小，这意味着默认情况下，我们不能像访问列表那样访问它以前的元素。

除此之外，还存在列表或序列的所有元素都需要处理的情况，所以我们是逐个元素地处理集合还是逐个操作地处理集合是无关紧要的。例如，如果我们希望`*sort*`整个集合，我们需要查看每个元素，因此下面的操作不会有显著的性能差异。

# 结论

在通常情况下，您将主要使用像列表这样的可迭代集合，因为它们更容易处理。要在项目中使用`*Sequences*`，您可能需要将`*List*`转换为`*Sequence*`，执行操作，然后再将其转换回`*List*`，以便您可以存储和访问它。然而，您可能希望在以下情况下考虑使用`*Sequences*`来获得显著的性能提升:

*   您正在处理的数据集包含大量条目和/或重对象。
*   您需要执行的处理步骤的数量和/或复杂性很高。
*   您需要无限期地处理元素，直到达到给定的条件。

感谢您的阅读，如果您喜欢其中的内容，请不要忘记鼓掌并关注更多内容！