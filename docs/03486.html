<html>
<head>
<title>Four Python programming tips you should absolutely learn before going pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">成为专业人士之前，你绝对应该学习的四个Python编程技巧</h1>
<blockquote>原文：<a href="https://medium.com/codex/four-python-programming-tips-you-should-absolutely-learn-before-going-pro-7ca1ff8ecc4?source=collection_archive---------9-----------------------#2021-09-05">https://medium.com/codex/four-python-programming-tips-you-should-absolutely-learn-before-going-pro-7ca1ff8ecc4?source=collection_archive---------9-----------------------#2021-09-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/bb6f2f3884a794b12c2f78efd9c8f79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PvUJKRcJCLwox4R8"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae hv" href="https://unsplash.com/@homajob?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯科特·格雷厄姆</a>在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><div class=""/><p id="da1a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编程的一个规则是，我们总是试图让我们的代码更易读，更简洁和干净。这里有四种方法可以让你的代码更直接，更有逻辑性。这当然是有用的，因为它避免了复杂繁琐的代码的干扰。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="d886" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak"> <em class="ky"> 1。条件表达式</em> </strong></h1><p id="a5ff" class="pw-post-body-paragraph iv iw hy ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">Python支持可用于普通控制结构的条件表达式语法。语法的形式是-</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="ffa6" class="ln kb hy lj b fi lo lp l lq lr">expression1 <strong class="lj hz">if</strong> condition <strong class="lj hz">else</strong> expression2</span></pre><p id="14bd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个复合表达式的含义是:如果条件设置为true，则计算表达式1；否则，计算表达式2。这有点类似于C++或Java语言中的表达式，等价于语法等价于语法，<strong class="ix hz"> condition？expr1 : expr2v。</strong>下面介绍这样一个例子。它检查n的值。如果n的值大于等于100，那么它将打印n。否则它将打印-1。</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="5c13" class="ln kb hy lj b fi lo lp l lq lr">param = n if n&gt;=100 else -1<br/>print(param)<br/>#This would print 100</span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="5e6a" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">2.理解句法</h1><p id="f3f2" class="pw-post-body-paragraph iv iw hy ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">理解语法可以用于我们需要根据另一个序列找到一系列值的情况。理解语法最常见的应用是<strong class="ix hz">列表理解</strong>。一般形式描述为-</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="cbfa" class="ln kb hy lj b fi lo lp l lq lr">[expression <strong class="lj hz">for</strong> value <strong class="lj hz">in</strong> iterable <strong class="lj hz">if</strong> condition]</span></pre><p id="a88b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里<em class="ls">表达式</em>和<em class="ls">条件</em>都可能依赖于<em class="ls">值</em>和<em class="ls">，如果</em>子句是可选的。传统上它被描述为-</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="f3c9" class="ln kb hy lj b fi lo lp l lq lr">result = [ ] <br/><strong class="lj hz">for</strong> value <strong class="lj hz">in</strong> iterable:<br/>   <strong class="lj hz">if</strong> condition: <br/>      result.<strong class="lj hz">append</strong>(expression)</span></pre><p id="d581" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过list comprehension，我们可以如下定义打印数字的平方:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="2af5" class="ln kb hy lj b fi lo lp l lq lr">squares = [k*k <strong class="lj hz">for</strong> k <strong class="lj hz">in</strong> <strong class="lj hz">range</strong>(1, n+1)]<br/>#It prints the square of the numbers from 1 till n+1</span></pre><p id="b0fc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其他类似的用法包括:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="53e0" class="ln kb hy lj b fi lo lp l lq lr">[ k*k for k in range(1, n+1) ]   -- <strong class="lj hz"><em class="ls">list comprehension</em></strong><br/>{ k*k for k in range(1, n+1) }   -- <strong class="lj hz"><em class="ls">set comprehension</em></strong> <br/>( k*k for k in range(1, n+1) )   -- <strong class="lj hz"><em class="ls">generator comprehension</em></strong><br/>{ k:k*k for k in range(1, n+1) } -- <strong class="lj hz">dictionary comprehension</strong></span></pre></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="0f62" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak"> 3。包装和拆包顺序</strong></h1><p id="bf04" class="pw-post-body-paragraph iv iw hy ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">Python提供了额外的便利，包括元组和其他序列类型的处理。如果我们有一些用逗号分隔的数列。它们将被视为单个元组，即使没有提供括号。</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="78ff" class="ln kb hy lj b fi lo lp l lq lr"><strong class="lj hz">my_list</strong> = 2, 4, 6, 8</span></pre><p id="a6ed" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将把<strong class="ix hz"> my_list </strong>分配给元组(2，4，6，8)。这被称为元组的自动打包。另一种方式是当我们从一个函数返回多个值时，比如:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="d2c1" class="ln kb hy lj b fi lo lp l lq lr"><strong class="lj hz">return</strong> maximum_val, minimum_val<br/>#returns a single object that is the tuple (maximum_val, minimum_val).</span></pre><p id="07ce" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">反过来叫做<strong class="ix hz">拆包。</strong>它允许为序列元素分配一系列单独的标识符。举个例子:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="2c99" class="ln kb hy lj b fi lo lp l lq lr"><strong class="lj hz">a, b, c, d</strong> = <strong class="lj hz">range</strong>(1, 5)<br/>#Here <strong class="lj hz">a</strong>=1,<strong class="lj hz">b</strong>=2,<strong class="lj hz">c</strong>=3 and <strong class="lj hz">d</strong>=4</span></pre><p id="8584" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于这种语法，右边的表达式可以是任何可迭代的类型。值得注意的是，只要左侧变量的数量与迭代中元素的数量相同。否则，就会导致错误。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="099f" class="ka kb hy bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak"> 4。同时分配</strong></h1><p id="5636" class="pw-post-body-paragraph iv iw hy ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">自动打包和解包的结合形成了一种称为同时分配的技术。在这里，我们显式地将一系列值分配给一系列标识符。比如:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="8e83" class="ln kb hy lj b fi lo lp l lq lr"><strong class="lj hz">x,y,z</strong> = 1,2,3<br/>#It assigns <strong class="lj hz">x</strong>=1, <strong class="lj hz">y</strong>=2, <strong class="lj hz">z</strong>=3</span></pre><p id="a9ae" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当使用同时赋值时，在对左边的变量进行任何赋值之前，所有的表达式都在右边求值。这很重要，因为它提供了一种方便的方法来交换与两个变量相关的值:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="2464" class="ln kb hy lj b fi lo lp l lq lr"><strong class="lj hz">j, k</strong> = <strong class="lj hz">k, j</strong></span></pre><p id="d1a0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了这个命令，<strong class="ix hz"> j </strong>将被赋给<strong class="ix hz"> k </strong>的旧值，<strong class="ix hz"> k </strong>将被赋给<strong class="ix hz"> j </strong>的旧值。如果没有同时赋值，交换通常需要更精细地使用临时变量，例如:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="88b1" class="ln kb hy lj b fi lo lp l lq lr"><strong class="lj hz">temp</strong> = <strong class="lj hz">j</strong><br/><strong class="lj hz">j = k </strong><br/><strong class="lj hz">k = temp</strong></span></pre><p id="bb34" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在同时赋值的情况下，在执行这种交换时，右边表示打包值的未命名元组隐式地充当临时变量。假设我们用python定义了一个斐波那契函数。我们首先将a，b的值初始化为0，1。然后打印a+b的值。通过使用上述技巧，我们可以将其定义为:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="5d52" class="ln kb hy lj b fi lo lp l lq lr"><strong class="lj hz">def</strong> fibonacci(a):<br/>   a, b = 0, 1<br/>   <strong class="lj hz">while</strong> <strong class="lj hz">True</strong>:<br/>     return a <br/>     a, b = b, a+b</span></pre><p id="0bf9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你能够理解这些提示和技巧，并能够在日常编码中使用它们，因为这将使你的代码脱颖而出。如果你喜欢这个帖子，请分享。</p></div></div>    
</body>
</html>