<html>
<head>
<title>Change Data Capture (CDC) from Postgres to Snowflake</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将数据捕获(CDC)从Postgres更改为雪花</h1>
<blockquote>原文：<a href="https://medium.com/codex/change-data-capture-cdc-from-postgres-to-snowflake-60c9c577fb87?source=collection_archive---------2-----------------------#2022-12-07">https://medium.com/codex/change-data-capture-cdc-from-postgres-to-snowflake-60c9c577fb87?source=collection_archive---------2-----------------------#2022-12-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5e3c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何在Postgres数据库上执行变更数据捕获</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/60789306bd71e024365ea8add970cbf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t-KoKfECKamI7nRG"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">布莱克·康纳利在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="bb28" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">改变数据捕获传统旨在开启许多数据驱动的用例。在某些情况下，组织更喜欢近乎实时地获得可操作的见解，许多下游应用程序正在等待消费和整合业务用例。这一点非常重要。在这篇文章中，我们将设计并实现一个Postgres表上的变更数据捕获，我们将把这个数据放入雪花表中。有趣的是，您可以将本文中使用的方法应用于任何数据库或任何关系数据库。但需要注意的是，CDC针对不同数据库的内部工作方式是不同的，针对这些数据库的CDC实施也是不同的。</p><p id="9a11" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是，在我们走得太远之前，让我们看一下变更数据捕获(CDC)。CDC是识别源系统中数据何时发生变化的过程，以便下游流程或系统可以处理并捕获该变化。例如，一个常见的用例是在不同的目标数据库或系统中填充变更，以便系统中的数据保持同步。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es kk"><img src="../Images/fd3156512ff35751b15266374ce6a6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NHJtjCKaKhK7HISu"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">更改数据捕获(图片由作者提供)</figcaption></figure><p id="2b42" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，在您的源系统上实现CDC时，一定要注意在您的数据库上启用CDC对性能的影响，这可能会以不同的方式来捕获生产中更改的数据。在数据库上启用CDC之前，我们可能希望增加vCores的数量或提高性能水平来进行补偿。我们可能需要密切监控空间利用率，并保持较短的保留期。</p><p id="a338" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里要注意的一件有趣的事情是，您可以利用CDC的能力在不同的数据库或下游系统之间同时移动数据。在这篇文章中，我们将只讨论一个数据库(雪花),但是您可以使用这里提供的方法为许多数据源实现它。幸运的是，Debezium是一个基于Apache Kafka的开源工具，它允许我们使用事件流轻松地在不同的数据库/系统之间移动数据。</p><p id="24b1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，我们将介绍CDC，并了解最常见的变更数据捕获方法。然后，我们将设计部署所需的docker映像，设置一个雪花帐户，并设计一个雪花数据库，以随时使用Postgres数据库中的数据。我们将向Postgres发送几行数据，并期望Postgres数据事件流消息由Debezium和Kafka Connect监控。这里的最终目标是将数据从Postgres数据库近乎实时地放入雪花表。</p><h2 id="d8af" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated">变更数据捕获(CDC)简介</h2><p id="28d5" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">使用Debezium，您可以捕获MySQL、MongoDB、Postgres、SQL Server、Oracle、Db2、Cassandra和Vitess中的数据变化。它通过使用Debezium来监控数据库，以查看不同的操作正在发生。您可以监视数据库的操作插入、更新、删除等。其中一个有趣的部分是，Debezium可以将一个现有的数据库快照放入一个事件流中，这样您的下游应用程序就可以根据更改进行操作，或者使用事件流，并对向前移动的事件流执行一些操作。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ll"><img src="../Images/72ab6c6a4d8680f43ed4f8f7a726e467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N3uw3rMdRqxZIuZbjpw4sA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Debezium(图片由作者提供)</figcaption></figure><p id="a154" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Debezium构建在Apache Kafka之上，它提供了Kafka Connect兼容的连接器来监控特定的数据库系统。Debezium监控这些数据库系统的方式是不同的，因为每个数据库的开发策略是不同的。Debezium在Kafka日志中记录数据更改的历史，从那里，您的应用程序可以使用它们。有趣的是，Debezium配置为与这些数据库一起工作的方式在内部是不同的，因为不同的关系数据库和NoSQL数据库是以不同的方式创建的。因此Debezium Postgres的设计实现将与MySQL不同，与Cassandra也不同。你可以在这里阅读更多关于这个<a class="ae jn" href="https://debezium.io/documentation/reference/stable/tutorial.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="791f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我喜欢Debezium的一点是，即使你的应用程序意外停止，它也不会错过任何东西；一旦应用程序重新启动，它将从停止的地方继续使用事件。出于这篇博文的目的，我们将设计并实现一个CDC管道，以近乎实时的方式插入到雪花数据库中。在此之前，我们将了解最常见的变更数据捕获方法。</p><h2 id="c76c" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated">最常见的变更数据捕获方法</h2><p id="1df4" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">有不同的CDC方法可用，选择这些方法完全取决于您的应用程序要求以及CDC在为源系统启用时可能导致的性能开销。我们将看看两种最常见的CDC方法，基于查询的和基于日志的变更数据捕获。</p><ul class=""><li id="cfa3" class="lm ln hi jq b jr js ju jv jx lo kb lp kf lq kj lr ls lt lu bi translated"><strong class="jq hj">基于查询的变更数据捕获:</strong>基于查询的方法使用常规的数据库查询从数据库中提取信息。关于这种方法需要注意的一点是，流程和执行需要大量资源来计算第二个数据库中的数据和流出数据库的数据之间的差异。此外，资源消耗至少随着数据量的增长而线性增长。</li><li id="a01b" class="lm ln hi jq b jr lv ju lw jx lx kb ly kf lz kj lr ls lt lu bi translated"><strong class="jq hj">基于日志的变更数据捕获:</strong>执行数据库变更数据捕获的最强大的方法是基于日志的变更数据捕获。这是因为数据库将所有更改存储在事务日志中，以便在数据库因任何原因崩溃时恢复数据库的提交状态。基于日志的CDC利用事务数据库的这一方面从日志中读取更改。基于日志是强大的，因为它可以给出所有关于历史的信息，以及针对数据库将会发生什么。所有的变化都记录在事务日志中，在我们的例子中，我们将实现基于日志的CDC。就这样，让我们把手弄脏。</li></ul></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h2 id="1470" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated"><strong class="ak">第一步:克隆代码为</strong>的GitHub repo</h2><p id="8134" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">该存储库包含启动和运行开发所需的所有文件。我已经提供了您的环境变量的样子，还提供了一个GitHub Readme页面来指导您的开发。有了这些，我们现在可以开始开发了。</p><pre class="iy iz ja jb fd mh mi mj bn mk ml bi"><span id="ac0f" class="mm km hi mi b be mn mo l mp mq">git clone https://github.com/yTek01/CDC-postgres-snowflake.git</span></pre><h2 id="c444" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated"><strong class="ak">步骤2:设计部署所需的Docker映像</strong></h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mr ms l"/></div></figure><h2 id="8e16" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated"><strong class="ak">第三步:在终端上指定Debezium版本</strong></h2><pre class="iy iz ja jb fd mh mi mj bn mk ml bi"><span id="d0f4" class="mm km hi mi b be mn mo l mp mq">  export DEBEZIUM_VERSION=1.9</span></pre><h2 id="cf92" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated"><strong class="ak">第四步:启动所有资源</strong></h2><pre class="iy iz ja jb fd mh mi mj bn mk ml bi"><span id="c98f" class="mm km hi mi b be mn mo l mp mq">docker-compose -f docker-compose-postgres.yaml up -d</span></pre><p id="a6bd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一切准备就绪，我们可以开始了。输出应该如下所示。使用命令确认这一点。</p><pre class="iy iz ja jb fd mh mi mj bn mk ml bi"><span id="6dcb" class="mm km hi mi b be mn mo l mp mq">docker ps</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mt"><img src="../Images/492a4231d8ecf4670f0ccec512babadd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z6ulZF3dFbgBPtFa"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">运行Docker容器(图片由作者提供)</figcaption></figure><h2 id="0ecd" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated"><strong class="ak">步骤5:启动并创建Postgres数据库连接器</strong></h2><pre class="iy iz ja jb fd mh mi mj bn mk ml bi"><span id="3c84" class="mm km hi mi b be mn mo l mp mq">curl -i -X POST -H "Accept:application/json" -H  "Content-Type:application/json" http://localhost:8083/connectors/ -d @postgres-connection-credential.json</span></pre><p id="4350" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您应该会看到类似下面的截图。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/5a22c872a479dbda5ea6961251c299ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b5DBPY1goVZnD1II"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">数据库连接(图片由作者提供)</figcaption></figure><h2 id="6d09" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated"><strong class="ak">第六步:启动Debezium和Kafka连接</strong></h2><p id="301c" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">值得注意的是，Debezium内部重用Kafka和Kafka Connect来实现其耐用性、可靠性和容错性。但是请注意，我们已经将主题指定为“dbserver1.inventory.customers ”,当您想要配置应用程序以从Kafka消费时，将需要该主题。下面的命令执行Kafka容器，并启动Kafka消费者开始监听来自Postgres数据库的事件流。</p><pre class="iy iz ja jb fd mh mi mj bn mk ml bi"><span id="1a03" class="mm km hi mi b be mn mo l mp mq">docker-compose -f docker-compose-postgres.yaml exec kafka /kafka/bin/kafka-console-consumer.sh \<br/>   --bootstrap-server kafka:9092 \<br/>   --from-beginning \<br/>   --property print.key=true \<br/>   --topic dbserver1.inventory.customers</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/796da147627616778b7fb5df701eb0a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YdBSh5kNZVGFJbfri9GUcg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">卡夫卡消费输出(作者图片)</figcaption></figure><h2 id="8250" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated"><strong class="ak">第七步:建立雪花账户和雪花数据库</strong></h2><p id="1329" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">为了帖子的目的，我建立了一个免费试用的雪花账号，来建立一个免费的数据库。雪花提供了40天的免费试用，以尝试他们的资源，这很酷。你可以在这里注册<a class="ae jn" href="https://signup.snowflake.com/" rel="noopener ugc nofollow" target="_blank">而不用信用卡，有了这个账号，你就可以为你的工作量建立一个免费的雪花数据仓库、数据库和表格。</a></p><p id="53a6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我的例子中，我只建立了一个简单表的数据库，一个有四列的表。我将写入Postgres表，正如预期的那样，我们应该能够看到雪花表中的数据，如果CDC设置在任何时候出现故障，我们的设置应该能够恢复并继续进行近乎实时的数据捕获。在开始启动应用程序之前，请确保安装了必要的库，将您的数据库凭证附加到环境变量，并按照下面提供的时间顺序启动应用程序。</p><p id="1f0e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">成功创建雪花帐户后，转到工作表选项卡，为来自Kafka Consumer的数据创建数据库和表模式。我们的数据库模式如下所示:</p><pre class="iy iz ja jb fd mh mi mj bn mk ml bi"><span id="3d6c" class="mm km hi mi b be mn mo l mp mq">CREATE TABLE inventory."PUBLIC".customers (id int, first_name string, last_name string, email string);</span></pre><h2 id="6c4f" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated"><strong class="ak">步骤8:将数据插入Postgres </strong></h2><pre class="iy iz ja jb fd mh mi mj bn mk ml bi"><span id="cca4" class="mm km hi mi b be mn mo l mp mq">docker-compose -f docker-compose-postgres.yaml exec postgres env PGOPTIONS="--search_path=inventory" bash -c 'psql -U $POSTGRES_USER postgres'</span></pre><pre class="mw mh mi mj bn mk ml bi"><span id="eb4a" class="mm km hi mi b be mn mo l mp mq">INSERT INTO customers (id, first_name, last_name, email) VALUES (1, 'Bob', 'Frank', 'XXXXXXXXXXXXXXXX@gmail.com');</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mx"><img src="../Images/aa2fa914f87d7e07e965c8bc1f7c328b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JN67WyvuFv5ghrxujNuJig.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">消费者产出和Postgres数据库中的产出(图片由作者提供)</figcaption></figure><h2 id="dc62" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated"><strong class="ak">第9步:安装所有必要的库</strong></h2><p id="7346" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">在我的例子中，我已经在requirements.txt文件中指定了我将使用的所有Python库:然后我们的Python应用程序可以使用来自Kafka Connect的数据</p><pre class="iy iz ja jb fd mh mi mj bn mk ml bi"><span id="91cf" class="mm km hi mi b be mn mo l mp mq">python -m pip install -r requirements.txt</span></pre><h2 id="649b" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated">步骤10:在ENV中包含所有雪花数据库凭证</h2><pre class="iy iz ja jb fd mh mi mj bn mk ml bi"><span id="c98d" class="mm km hi mi b be mn mo l mp mq">USER=XXXXXXXX<br/>PASSWORD=XXXXXXXXX<br/>ACCOUNT=XXXXXXXX.eu-central-1<br/>ROLE_ACCOUNT=XXXXXXXXXXXX<br/>WAREHOUSE=COMPUTE_WH<br/>DATABASE=INVENTORY</span></pre><h2 id="34b7" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated"><strong class="ak">步骤11:打开另一个终端，启动Python消费者</strong></h2><p id="153e" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">此时，我们的应用程序已经准备好开始监听、获取和处理数据，因为数据已经从Debezium发布到我们的下游应用程序。</p><pre class="iy iz ja jb fd mh mi mj bn mk ml bi"><span id="001a" class="mm km hi mi b be mn mo l mp mq">python consumer.py</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/535b0385bec1e1653178dd31ed3ca8bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZokKuOZs3CPBnHi0"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来自消费者应用程序的数据(图片由作者提供)</figcaption></figure><h2 id="ed9e" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated"><strong class="ak">步骤12:转到雪花确认所有数据都可用</strong></h2><p id="5a6a" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">正如你在截图中看到的，我们所有的数据现在都在雪花中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/7efed9922c11332536486a0de999c252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rm-feh-ZEleGeRDm"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">雪花数据库中的数据(作者图片)</figcaption></figure></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><h2 id="df47" class="kl km hi bd kn ko kp kq kr ks kt ku kv jx kw kx ky kb kz la lb kf lc ld le lf bi translated"><strong class="ak">结论</strong></h2><p id="bafb" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">变更数据捕获允许下游应用程序近乎实时地使用来自上游数据源的数据。多年来已经开发了不同的方法，但最常用的CDC方法是基于日志的变更数据捕获。如前所述，如果在数据库上启用CDC后没有考虑性能影响，CDC可能会导致数据库在生产中出现问题。在将实现部署到生产环境之前，请确保对数据库和数据工作负载进行了适当的测试，并确保为数据库分配了足够的资源。</p><p id="0212" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于将数据发送到雪花表中的应用程序，请确保您设计的应用程序不会在每次将一行数据发送到数据库时都命中数据库，只对所有插入使用会话对象，并将数据库凭据放在应用程序之外。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><p id="f107" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">来源和进一步阅读</strong></p><p id="d0c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">[1] <a class="ae jn" href="https://github.com/debezium/debezium-examples/tree/main/tutorial" rel="noopener ugc nofollow" target="_blank"> Debezium — github回购</a> (2022)</p><p id="18fa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">感谢您的阅读。</strong></p></div></div>    
</body>
</html>