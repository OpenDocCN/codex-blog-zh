<html>
<head>
<title>Build a REST API with NodeJS, Express and MongoDB — Part III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NodeJS、Express和MongoDB构建一个REST API第三部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/build-a-rest-api-with-nodejs-express-and-mongodb-part-iii-f146665d3e3b?source=collection_archive---------9-----------------------#2021-08-14">https://medium.com/codex/build-a-rest-api-with-nodejs-express-and-mongodb-part-iii-f146665d3e3b?source=collection_archive---------9-----------------------#2021-08-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6480" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个博客系列是用NodeJS，Express和MongoDB创建一个REST API。在本教程中，我们将使用PassportJS对后端进行身份验证和授权</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/92712292c4ba8499245580f714540492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1uqt6nCd57rb7RyUbeQFjw.png"/></div></div></figure><h1 id="7ba4" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">先决条件</h1><p id="f2a9" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">本教程是上一篇博客的延续，<a class="ae ks" rel="noopener" href="/@dmmnissanka/build-a-rest-api-with-nodejs-express-and-mongodb-2ed0fd7a90cf">用NodeJS、Express和MongoDB构建REST API第二部分</a>。</p><h1 id="be12" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">入门指南</h1><p id="d379" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在前一篇博客中，我们为一个博客管理系统创建了一个REST API，它能够创建和获取用户，并从系统中创建、获取、更新和删除博客。我们使用<code class="du kt ku kv kw b">Joi</code>实现了一个请求验证机制，并使用<code class="du kt ku kv kw b">mongoose</code>连接数据库。</p><p id="48f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们没有在REST端点中实现身份验证。因此，CRUD操作可以由系统中的任何用户执行，这不是一个好的实现。在本教程中，让我们探索如何使用<a class="ae ks" href="http://www.passportjs.org/" rel="noopener ugc nofollow" target="_blank"> PassportJs </a>实现认证和授权。</p></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h1 id="b62d" class="jp jq hi bd jr js le ju jv jw lf jy jz ka lg kc kd ke lh kg kh ki li kk kl km bi translated">认证和授权</h1><h2 id="d497" class="lj jq hi bd jr lk ll lm jv ln lo lp jz iq lq lr kd iu ls lt kh iy lu lv kl lw bi translated">什么是身份验证和授权？</h2><p id="4333" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">身份验证和授权代表着根本不同的活动。<strong class="ih hj">认证</strong>是识别用户的过程，<strong class="ih hj">授权</strong>是识别用户权限的过程。</p><p id="9c8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">举个例子，我们拿一个学校来说。进入大门时，安检人员会检查你的学校身份证。这是认证。只有持有有效身份证的人才能进入学校。学生不允许进入教师办公室。这是授权书。只有有进入教员室特权的人才能进入教员室。我相信现在您已经知道身份验证和授权之间的区别了。</p><p id="0d42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的博客管理API中，我们有几个不受保护的端点。</p><ul class=""><li id="d8ee" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mc md me mf bi translated">任何用户都可以访问所有端点</li><li id="fb92" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">博客上的所有CUD操作都可以由任何用户进行</li></ul><p id="103a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述两个问题都可以通过在系统中实现API认证和API授权来解决。首先，让我们看看如何在我们的API中实现一个简单的身份验证模块。</p><h2 id="0f39" class="lj jq hi bd jr lk ll lm jv ln lo lp jz iq lq lr kd iu ls lt kh iy lu lv kl lw bi translated">证明</h2><p id="fe6b" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">身份验证是API开发的重要组成部分。身份验证将确保API端点只对系统可以识别的用户可用。<code class="du kt ku kv kw b">PassportJS</code>是一款出色的认证中间件，提供多种认证策略。对于本教程，我们将使用<code class="du kt ku kv kw b">PassportJS</code> JWT认证策略。<br/>在我们当前的项目中，用户可以从<code class="du kt ku kv kw b">/api/vi/users</code>端点创建。我们将删除所有与用户相关的端点，并为用户注册和用户登录活动创建新的API端点。</p><p id="3c90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，安装必要的依赖项。</p><pre class="je jf jg jh fd ml kw mm mn aw mo bi"><span id="0bf2" class="lj jq hi kw b fi mp mq l mr ms">npm install --save passport passport-jwt jsonwebtoken bcrypt</span></pre><p id="39f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装开发依赖项</p><pre class="je jf jg jh fd ml kw mm mn aw mo bi"><span id="39d1" class="lj jq hi kw b fi mp mq l mr ms">npm install --save-dev @types/passport-jwt @types/bcrypt </span></pre><p id="f08d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们把重点放在代码实现上。</p><p id="4a81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们尝试为用户生成一个JSON Web令牌。当用户被创建或登录时，会生成一个JWT并发送给用户。然后，用户可以使用该JWT来访问其他API端点。我们需要做的第一件事是，我们需要删除当前的用户API端点。请从项目中删除<code class="du kt ku kv kw b">user.controller.ts</code>和<code class="du kt ku kv kw b">user.route.ts</code>文件。</p><p id="8454" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将添加两个新的API端点</p><ul class=""><li id="14e4" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mc md me mf bi translated">用户注册的端点</li><li id="19d0" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">用户登录的端点</li></ul><p id="9353" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，用户模型不包含任何存储用户密码的字段。通过添加一个<code class="du kt ku kv kw b">password</code>字段来修改<code class="du kt ku kv kw b">user.model.ts</code>。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="2c21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们应该始终避免以纯文本形式存储密码。在上面的代码片段中，我们已经使用<a class="ae ks" href="https://github.com/kelektiv/node.bcrypt.js#readme" rel="noopener ugc nofollow" target="_blank"> bcrypt </a>模块对密码进行了加密，并在将密码存储到数据库之前将其替换为原始密码。此外，还引入了一种比较纯文本密码和存储的哈希密码的新方法。</p><p id="0c9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更换<code class="du kt ku kv kw b">user.service.ts</code></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="40fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们引进了两种新的服务方法。一个是验证用户登录，另一个是验证用户创建。最后，两个函数都返回一个带有用户id的JWT令牌。它需要一个<code class="du kt ku kv kw b">ttl</code>值和一个私钥来生成JWT令牌，我们可以提供所需的参数作为环境变量。</p><p id="46f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新转换器函数、用户类型和验证模式</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="6462" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为身份验证失败创建异常类。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="d703" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建<code class="du kt ku kv kw b">auth.controller.ts</code>和<code class="du kt ku kv kw b">auth.route.ts</code></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="4500" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们尝试通过新的注册端点创建一个用户。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mv"><img src="../Images/a69d1b0de82b992ca56a8427be1dc408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HnCh7Tk6lZNnsmKx2d0u3A.png"/></div></div></figure><p id="cc93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们验证它是如何存储在数据库中的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mw"><img src="../Images/9ce26466a193c1792632c500df1372a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQ_hnzWTkAmvUl3cvuZ2nQ.png"/></div></div></figure><p id="7da6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">验证登录端点</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mx"><img src="../Images/bbae88c78c6394c17519aff728428c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XN8geAq-6655b1OkTYEG9w.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es my"><img src="../Images/fe3f3ea4375122f71a8aa3bb5cbaccae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ryD9ft2Ikl3mRG_OzL3Epg.png"/></div></div></figure><p id="3bd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">太好了。现在，我们已经为用户创建和用户登录定义了两个端点，它们返回一个令牌作为响应。让我们看看如何使用这个带有<code class="du kt ku kv kw b">PassportJS</code>的令牌来实现认证。</p><p id="68d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kt ku kv kw b">PassportJS</code>提供大量认证<a class="ae ks" href="http://www.passportjs.org/packages/" rel="noopener ugc nofollow" target="_blank">策略</a>。在本教程中，我们将使用PassportJS <a class="ae ks" href="http://www.passportjs.org/packages/passport-jwt/" rel="noopener ugc nofollow" target="_blank">策略</a>通过JSON web令牌进行身份验证</p><p id="bd61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du kt ku kv kw b">middlewares</code>里面创造<code class="du kt ku kv kw b">auth.middleware.ts</code>。该文件包含身份验证策略和身份验证中间件功能。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="61ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du kt ku kv kw b">authStrategy</code>函数中定义了认证的<code class="du kt ku kv kw b">PassportJS</code>策略。在<code class="du kt ku kv kw b">authStrategy</code>函数中，我们从请求中提取<code class="du kt ku kv kw b">Authorization</code>头。这里我们使用了默认的<code class="du kt ku kv kw b">fromAuthHeaderAsBearerToken</code>函数，如果您想将<code class="du kt ku kv kw b">Authorization</code>头从<code class="du kt ku kv kw b">Bearer</code>改为其他的，您可以简单地创建您自己的提取函数并获取令牌。然后passport将尝试解密提取的令牌。为此，我们需要通过环境变量提供一个好的私钥。如果出现任何错误，这意味着无法用给定的密钥解密所提供的令牌。如果解密和用户获取成功，<code class="du kt ku kv kw b">PassportJS</code>将用从服务层获取的用户对象替换请求中的用户组件。</p><p id="dd62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新<code class="du kt ku kv kw b"> blog.route.ts</code></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="71a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新创建的<code class="du kt ku kv kw b">authenticate</code>中间件功能已经应用于所有博客路径。</p><p id="702f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用认证策略更新<code class="du kt ku kv kw b">app.ts</code>。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="becf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们通过访问博客端点来验证身份验证。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mv"><img src="../Images/3d70eec30b681cf8f6f5b8af31facc6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XSmg5QxW7FJOhInD3hYklQ.png"/></div></div></figure><p id="be22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当<code class="du kt ku kv kw b">Authorization</code>头丢失时，端点返回一个未授权的错误响应。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mz"><img src="../Images/1cfa4481c1820c262c6ecb8fbfa28f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rsLlpi374YX2vDkjnlAbqw.png"/></div></div></figure><p id="69b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用正确的授权头，它返回预期的响应。</p><p id="6955" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用PassportJS及其JSON web令牌认证策略成功地创建了一个认证中间件。现在让我们来关注一下授权。</p><h2 id="0ec7" class="lj jq hi bd jr lk ll lm jv ln lo lp jz iq lq lr kd iu ls lt kh iy lu lv kl lw bi translated">批准</h2><p id="b6c5" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">尽管我们在API中实现了身份验证，但实现仍然缺乏授权。任何有权访问API端点的用户都可以创建、更新和删除博客。这不是一个很好的实现。应该只有作者能够执行创建、更新和删除操作。为了解决这个问题，我们应该为每个用户引入一个角色。</p><p id="1c64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于本教程，让我们考虑两个用户角色</p><ul class=""><li id="fa12" class="lx ly hi ih b ii ij im in iq lz iu ma iy mb jc mc md me mf bi translated">作者</li><li id="5651" class="lx ly hi ih b ii mg im mh iq mi iu mj iy mk jc mc md me mf bi translated">读者</li></ul><p id="6392" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作者可以创建博客、更新博客、删除博客和阅读博客，而读者只有阅读博客的能力。</p><p id="ec47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建一个新文件夹<code class="du kt ku kv kw b">constants</code>并添加<code class="du kt ku kv kw b">user-role.ts</code></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="fc4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用角色更新<code class="du kt ku kv kw b">user.model.ts</code>。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="f872" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新<code class="du kt ku kv kw b">user.schema.ts</code>、<code class="du kt ku kv kw b">user.transformer.ts</code>和<code class="du kt ku kv kw b">user.type.ts</code></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="58b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好了，现在角色已经被添加到每个必需的文件中，我们可以专注于实现授权中间件了。</p><p id="61c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du kt ku kv kw b">middlewares</code>内部创建<code class="du kt ku kv kw b">authorize.middleware.ts</code></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="9f67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">授权中间件功能将接收有权访问端点的角色数组，并且它将检查给定的角色数组是否包含用户的角色。但是在实现的时候，上面的代码片段会给你一个错误，指出user类型上不存在属性role。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es na"><img src="../Images/f43c4ddaf295cd6065b36b432f68936b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jdAXRuB6fO2vu1rliC1flA.png"/></div></div></figure><p id="3f60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是因为<code class="du kt ku kv kw b">Express.Request</code>中用户对象的类型是默认的<code class="du kt ku kv kw b">Express.User</code>类型。我们需要用我们的用户类型中的字段来改变默认类型<code class="du kt ku kv kw b">Express.User</code>。首先，在<code class="du kt ku kv kw b">types/express</code>文件夹中创建<code class="du kt ku kv kw b">index.d.ts</code>。请在<code class="du kt ku kv kw b">src</code>之外创建这个文件夹，这样就不会与代码库中使用的类型混淆。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="dabf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后更新<code class="du kt ku kv kw b">tsconfig.json</code></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="242f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您将能够正确无误地从请求中获得用户的角色。</p><p id="00c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为授权失败创建一个异常类</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="cfad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用授权中间件更新<code class="du kt ku kv kw b">blog.route.ts</code>内的端点。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="574d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">博客创建、更新和删除端点由授权中间件包装，这三个端点只对角色为<code class="du kt ku kv kw b">AUTHOR</code>的用户可用。</p><p id="4c27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里请确保在认证函数之后应用授权函数，因为认证函数是更新请求中的用户对象的中间件，而授权中间件需要更新的用户对象来获取用户角色。</p><p id="ab1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后更改现有的创建博客和更新博客端点。在现有的API中，我们在创建和更新博客时发送作者id。但是现在我们可以从请求本身提取用户详细信息。</p><p id="2699" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新<code class="du kt ku kv kw b">blog.controller.ts</code>中的<code class="du kt ku kv kw b">createBlogHandler</code>，更新<code class="du kt ku kv kw b">blog.schema.ts</code>和<code class="du kt ku kv kw b">blog.type.ts</code></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="5bd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们验证一下授权中间件。由于我们已经将用户的默认角色值定义为<code class="du kt ku kv kw b">READER</code>，所以现有用户只有阅读能力。尝试从现有用户令牌创建博客。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mv"><img src="../Images/0a1e7a97acc1114a30c43e9c0e9462af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KrnuA4Hdj1BKNmthaegOZA.png"/></div></div></figure><p id="d8f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在创建一个角色为<code class="du kt ku kv kw b">AUTHOR</code>的用户，并尝试从该用户创建一个博客</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nb"><img src="../Images/6bbe074302b2ace042a1286d3b70d2ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3rSqEgsvSE2CFXThz0HZzg.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nc"><img src="../Images/afd778ae6bc6bb7b7a2035bff30edb41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E0sMCXrTlgU4mUNkFLVgmg.png"/></div></div></figure><p id="3713" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">授权模块如我们预期的那样工作。但这是更高级别的授权，我们只检查用户的角色。但是，拥有<code class="du kt ku kv kw b">AUTHOR</code>角色的用户仍然可以删除或更新其他用户的博客。因此，我们需要确保用户只能更新或删除自己创建的博客。</p><p id="1ef3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更改<code class="du kt ku kv kw b">blog.service.ts</code>中的<code class="du kt ku kv kw b">updateBlog</code>和<code class="du kt ku kv kw b">deleteBlog</code>来验证请求用户的博客作者</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="59d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在尝试更新另一个用户的博客，你会得到一个错误响应</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nd"><img src="../Images/177e304e1a385f448ae9e43fbffe60a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kcBanwSgQuTZRiUWO5Wmcw.png"/></div></div></figure><h1 id="ddd5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="fcdb" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在本系列教程中，我们使用<code class="du kt ku kv kw b">NodeJS</code>和<code class="du kt ku kv kw b">Express</code>为博客管理系统创建了一个简单的基本REST API。系统使用<code class="du kt ku kv kw b">PassportJS</code>提供的JSON web令牌认证策略进行认证。并且根据用户角色对端点进行授权。我们使用<code class="du kt ku kv kw b">MongoDB</code>作为系统的数据库，并使用<code class="du kt ku kv kw b">Joi</code>验证API请求。我们还设法使用<code class="du kt ku kv kw b">morgan</code>和<code class="du kt ku kv kw b">winston</code>创建了一个可以覆盖大多数基本日志实例的日志记录器。希望这一系列教程能够帮助您理解NodeJS中REST API实现的基础知识。</p><p id="1543" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在<a class="ae ks" href="https://github.com/Dinindu-Nissanka/nodejs-typescript-rest-api/tree/build_rest_api_with_nodejs_part_3" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到本教程的完整源代码。</p></div></div>    
</body>
</html>