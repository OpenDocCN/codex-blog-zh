<html>
<head>
<title>Refactoring for better testability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构以获得更好的可测试性</h1>
<blockquote>原文：<a href="https://medium.com/codex/refactoring-for-better-testability-f38ad469c114?source=collection_archive---------12-----------------------#2021-01-05">https://medium.com/codex/refactoring-for-better-testability-f38ad469c114?source=collection_archive---------12-----------------------#2021-01-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/36598f866038467da9a9ce13be7ed143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pTb_dWn79MDb4Ov-k5lVvg.jpeg"/></div></div></figure><p id="c83d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们谈论软件设计时，我们经常使用非常普通和抽象的词语。但是，实践呢？它在现实世界的项目中看起来如何？今天，你和我将开始重构一个小的待办事项应用程序，以获得更好的可测试性和可维护性。在本文中，我们将使应用程序可测试。我们将编写黑盒测试来防止一些错误，并使未来的重构更加容易和安全。</p><p id="5c1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文是迷你系列的第一部分，在这个系列中，我们对现有代码进行代码审查，并试图对其进行改进。在以后的文章中，我们将从项目中提取域，并修复一些错误。所以，敬请期待！</p><p id="1236" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完整的源代码可以在<a class="ae jo" href="https://github.com/bkielbasa/gotodo" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。当你看一看这个项目时，你可以了解项目的结构。没那么糟糕，但是有一个大问题让我们无法毫无顾虑地重构逻辑——它没有测试。这是我们今天的目标——让项目可测试。为了能够重构应用程序，我们必须有一些监护人来关注你所做的改变。怎么做？</p><h1 id="9b9b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">重构main()函数</h1><p id="c25b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在main.go文件中，我们有两个函数。<code class="du ks kt ku kv b">main</code>函数保存整个应用程序的初始化，并启动HTTP服务器。<code class="du ks kt ku kv b">getDB()</code>只是返回一个到数据库的连接。我们可以看到一些处理程序的定义。我为您阅读了代码，并准备了一些示例请求，我们可以用它们来手动测试应用程序。</p><p id="f89e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建新项目:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="38f5" class="le jq hi kv b fi lf lg l lh li">curl --request POST \ --url http://localhost:8090/project/create \ --header 'content-type: application/json' \ --data '{ "name": "Home" } '</span></pre><p id="5295" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">列出所有可用项目:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="36b3" class="le jq hi kv b fi lf lg l lh li">curl --request GET \ --url <a class="ae jo" href="http://localhost:8090/projects" rel="noopener ugc nofollow" target="_blank">http://localhost:8090/projects</a></span></pre><p id="dc46" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">添加待办事项:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="7db5" class="le jq hi kv b fi lf lg l lh li">curl --request POST \<br/>  --url <a class="ae jo" href="http://localhost:8090/todo/create" rel="noopener ugc nofollow" target="_blank">http://localhost:8090/todo/create</a> \<br/>  --header 'content-type: application/json' \<br/>  --data '{<br/>	"name": "lala"<br/>}<br/>'</span></pre><p id="537a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将待办事项标记为完成:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="aa02" class="le jq hi kv b fi lf lg l lh li">curl --request POST \ --url http://localhost:8090/todo/TASK_ID/done \ --header 'content-type: application/json'</span></pre><p id="283c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">标记为未完成</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="d4cc" class="le jq hi kv b fi lf lg l lh li">curl --request POST \ --url http://localhost:8090/todo/TASK_ID/undone \ --header 'content-type: application/json'</span></pre><p id="113f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">诸如此类。手动测试可以工作，但是不可扩展。你想用自动测试取代它们，对吗？让我们用简单的方法做它。创建一个新文件main_test.go，您将在其中保存应用程序的所有测试。想想你想如何与程序互动。你不想在项目中做太多的改变，所以你会忽略里面有一个真实的数据库的事实。您只想运行应用程序。这是它的样子。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="2bf3" class="le jq hi kv b fi lf lg l lh li">func TestRunServer(t *testing.T) {<br/>  ctx := context.Background()<br/>  run, shutdown := todo.App(ctx, port)<br/>  defer shutdown()<br/>  go run()<br/><br/>  // run your tests here<br/>}</span></pre><p id="ce0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您创建一个使用指定上下文的新应用程序，并在端口上运行它。然后，您启动应用程序，当测试结束时—关闭它。听起来很简单，不是吗？</p><p id="3d92" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了实现这一点，你必须将<code class="du ks kt ku kv b">main()</code>函数重命名为<code class="du ks kt ku kv b">App.</code></p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="8189" class="le jq hi kv b fi lf lg l lh li">func App(ctx context.Context, port int) (func() error, func() error)</span></pre><p id="0776" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该函数接受上下文，HTTP服务器将在这个端口上运行，并返回两个函数:启动服务器和关闭服务器。这将使我们完全控制服务器，这将在一会儿有用。函数中值得注意的变化是直接创建一个HTTP服务器，这样您就可以控制它。这是修改后的完整功能。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="6241" class="le jq hi kv b fi lf lg l lh li">func App(ctx context.Context, port int) (func() error, func() error) {<br/>	m := http.NewServeMux()<br/>	s := http.Server{Addr: fmt.Sprintf(":%d", port), Handler: m}<br/>	log.Printf("starting on port %d", port)<br/><br/>	db := getDB()<br/>	repo := repositories.NewPostgres(db)<br/>	todoHandler := handlers.ToDo{Repo: repo}<br/>	projectHandler := handlers.Project{Repo: repo}<br/>	m.HandleFunc("/projects", projectHandler.List)<br/>	m.HandleFunc("/project/create", projectHandler.Create)<br/>	m.HandleFunc("/project/{id:[0-9a-z\\-]+}/archive", projectHandler.Archive)<br/>	m.HandleFunc("/todos", todoHandler.List)<br/>	m.HandleFunc("/todo/create", todoHandler.Create)<br/>	m.HandleFunc("/todo/{id:[0-9a-z\\-]+}", todoHandler.Get)<br/>	m.HandleFunc("/todo/{id:[0-9a-z\\-]+}/done", todoHandler.MarkAsDone)<br/>	m.HandleFunc("/todo/{id:[0-9a-z\\-]+}/undone", todoHandler.MarkAsUndone)<br/>	return s.ListenAndServe, func() error {<br/>		return s.Shutdown(ctx)<br/>	}<br/>}</span></pre><p id="141a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">至此，测试几乎运行完毕。您需要做的是添加您删除的缺少的main()函数。您可以在下面找到当前代码。deferred shutdown()函数现在没有意义，因为当它被执行时，服务器已经不在了，但是接下来您将处理它。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="1508" class="le jq hi kv b fi lf lg l lh li">func main() {<br/>	ctx := context.Background()<br/>	run, shutdown := App(ctx, 8090)<br/>	defer shutdown()<br/>	err := run()<br/>	if !errors.Is(err, http.ErrServerClosed) {<br/>		fmt.Println(err)<br/>		os.Exit(1)<br/>	}<br/>}</span></pre><p id="e840" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，测试通过，应用程序仍然可以运行！您几乎什么都不测试，但测试将在以后得到改进。在此之前，main()函数中还缺少一样东西——除了杀死它之外，没有其他方法可以关闭应用程序。你需要一个<a class="ae jo" href="https://developer20.com/golang-tips-and-trics-iii/" rel="noopener ugc nofollow" target="_blank">优雅的关机</a>。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="9d9a" class="le jq hi kv b fi lf lg l lh li">func main() {<br/>	var gracefulStop = make(chan os.Signal)<br/>	signal.Notify(gracefulStop, syscall.SIGTERM)<br/>	signal.Notify(gracefulStop, syscall.SIGINT)<br/><br/>	ctx := context.Background()<br/>	run, shutdown := App(ctx, 8090)<br/><br/>	go func() {<br/>		_ = &lt;-gracefulStop<br/>		fmt.Println("shutting down...")<br/>		err := shutdown()<br/>		if err != nil {<br/>			log.Fatal(err)<br/>		}<br/>		os.Exit(0)<br/>	}()<br/>	err := run()<br/>	if !errors.Is(err, http.ErrServerClosed) {<br/>		fmt.Println(err)<br/>		os.Exit(1)<br/>	}<br/>}</span></pre><p id="2ab3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在启动服务器之前，会创建一个新的<code class="du ks kt ku kv b">os.Signal</code>通道，在那里您会收到一个信号，表明是时候停止进程了。您使用我们的<code class="du ks kt ku kv b">shutdown()</code>函数来停止HTTP服务器并退出。</p><h1 id="bb11" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">编写第一个测试</h1><p id="2d58" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">您的测试将包含三个步骤:创建一个新项目，获得一个可用项目的列表，并检查我们的新品牌项目是否在列表中可见。让我们将测试名重命名为<code class="du ks kt ku kv b">TestAddingNewProject</code>，并更新它的代码以满足需求。每次都会创建一个新的(唯一的)项目名称，以确保该项目是用正确的名称创建的。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="17fd" class="le jq hi kv b fi lf lg l lh li">name := uuid.New().String()<br/>	reqBody := fmt.Sprintf(`{"name": "%s"}`, name)<br/>	url := "<a class="ae jo" href="http://localhost:8090/project/create" rel="noopener ugc nofollow" target="_blank">http://localhost:8090/project/create</a>"<br/>	client := http.Client{<br/>		Timeout: time.Second,<br/>	}<br/><br/>	// create a new project<br/>	resp, err := client.Post(url, "application/json", strings.NewReader(reqBody))<br/>	require.NoError(t, err)<br/>    require.Equal(t, http.StatusOK, resp.StatusCode)<br/><br/>	respBody, err := ioutil.ReadAll(resp.Body)<br/>	require.NoError(t, err)<br/>    r := struct{ ID string }{}<br/>	json.Unmarshal(respBody, &amp;r)<br/>	require.NotEmpty(t, r.ID)</span></pre><p id="d1ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一件值得注意的事情是，您创建了一个标准HTTP客户机的新实例。<code class="du ks kt ku kv b">http.DefaultClient</code>没有任何超时设置，在某些情况下，这可能会降低测试速度。等待超时可能需要一些时间:)</p><p id="7914" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您收到了项目创建正确的反馈，并将其ID放入匿名结构中。现在，是时候检查新项目是否被保存在数据库中并被读取了。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="7e33" class="le jq hi kv b fi lf lg l lh li">        // list existing projects<br/>	url = "<a class="ae jo" href="http://localhost:8090/projects" rel="noopener ugc nofollow" target="_blank">http://localhost:8090/projects</a>"<br/>	resp, err = client.Get(url)<br/>	require.NoError(t, err)<br/>	require.Equal(t, http.StatusOK, resp.StatusCode)<br/><br/>	listResp := projectsListResponse{}<br/>	respBody, err = ioutil.ReadAll(resp.Body)<br/>	require.NoError(t, err)<br/>	json.Unmarshal(respBody, &amp;listResp)<br/><br/>	// check if the projects are on the list<br/>	found := false<br/><br/>	for _, proj := range listResp.Projects {<br/>		if proj.ID == r.ID {<br/>			require.Equal(t, name, proj.Name)<br/>			require.False(t, proj.Archived)<br/>			found = true<br/>		}<br/>	}<br/><br/>	require.True(t, found, "cannot found the project on the list")<br/>}</span></pre><p id="4087" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是通过检查<code class="du ks kt ku kv b">/projects</code>端点完成的。首先，检查HTTP状态，当它成功时，你检查每个项目，一个接一个，并寻找全新的。当您找到它时，您要确保名称是正确的，并且项目没有从一开始就被归档。如果一切正常，测试通过！</p><h1 id="7279" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">摘要</h1><p id="1e60" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">今天，我们对项目进行了一点重构，这有助于我们为它编写第一个测试。你会发现我们今天在https://github.com/bkielbasa/gotodo/pull/1做的改变有所不同。</p><p id="0305" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你的作业是为其他端点编写测试。您可以编写的一个场景是创建一个新项目，将其存档，并检查其状态是否更改为存档。正如我所说的，这是重构迷你系列的第一部分。该项目在设计和良好实践方面存在更多问题。在修复之前，我们必须做一些测试，对吗？:)</p><p id="a0ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望你喜欢这篇文章，如果你有任何问题，请在下面的评论区留言。</p><p id="f473" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是重构的另一步。</p><p id="b356" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://www.buymeacoffee.com/bklimczak" rel="noopener ugc nofollow" target="_blank">给我买杯咖啡</a></p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="2069" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">【https://developer20.com】最初发表于<a class="ae jo" href="https://developer20.com/refactoring-for-better-testability/" rel="noopener ugc nofollow" target="_blank"><em class="lq"/></a><em class="lq">。</em></p></div></div>    
</body>
</html>