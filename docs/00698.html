<html>
<head>
<title>A quick little note about tab completion on the local Scala REPL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于本地Scala REPL上的制表符补全的一个小提示</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-quick-little-note-about-tab-completion-on-the-local-scala-repl-7850f332edfa?source=collection_archive---------8-----------------------#2021-03-11">https://medium.com/codex/a-quick-little-note-about-tab-completion-on-the-local-scala-repl-7850f332edfa?source=collection_archive---------8-----------------------#2021-03-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="8aee" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">药典</h2><div class=""/><figure class="ev ex ip iq ir is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es io"><img src="../Images/f1ef61e03170ace7fa94bd55d70d287a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7EkTLIiqARV3pJhk"/></div></div><figcaption class="iz ja et er es jb jc bd b be z dx translated">照片由<a class="ae jd" href="https://unsplash.com/@christinhumephoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·休姆</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="bd74" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在IntelliJ IDEA这样的集成开发环境(IDE)上编程Scala时，完成建议非常有用。像本地Scala REPL这样的REPL(读取-评估-打印-循环)是快速尝试可行或不可行的方法。</p><p id="04a5" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">糟糕的是，在本地Scala REPL上没有完成建议。其实有…</p><p id="979f" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">它需要按一个键，特别是Tab键。这有点像在Eclipse和NetBeans上用Ctrl-或Command-Space完成。</p><p id="7d54" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">嗯，这取决于你的设置。显然，在某些设置中，本地Scala REPL可以正常工作，但缺少制表符补全(我写“本地Scala REPL”是为了区别于像<a class="ae jd" href="https://scastie.scala-lang.org/" rel="noopener ugc nofollow" target="_blank"> Scastie </a>这样的在线REPL)。</p><p id="12d8" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">制表符结束在你的系统上工作吗？我们很快就会知道了。让你的本地Scala REPL运行起来如果你还没有启动并运行它，用任何东西做一些计算。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="7e22" class="kl km hi kh b fi kn ko l kp kq">C:\Users\AL&gt;scala<br/>Welcome to Scala 2.13.1 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_281).<br/>Type in expressions for evaluation. Or try :help.</span><span id="f217" class="kl km hi kh b fi kr ko l kp kq">scala&gt; Long.MaxValue : BigInt<br/>res0: BigInt = 9223372036854775807</span><span id="31e7" class="kl km hi kh b fi kr ko l kp kq">scala&gt; res0 * 2<br/>res1: scala.math.BigInt = 18446744073709551614</span></pre><p id="b515" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">好的，目前为止，一切顺利。但是我忘记了我可以在<code class="du ks kt ku kh b">BigInt</code>实例上使用什么函数和过程。因此，我键入“<code class="du ks kt ku kh b">res1</code>”，后跟一个句点，然后按Tab键。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="4269" class="kl km hi kh b fi kn ko l kp kq">scala&gt; res1.<br/>%    &lt;     bigInteger   doubleValue       isValidByte     longValue      setBit        toChar     unary_~<br/>&amp;    &lt;&lt;    bitCount     equals            isValidChar     lowestSetBit   shortValue    toDouble   underlying<br/>&amp;~   &lt;=    bitLength    flipBit           isValidDouble   max            sign          toFloat    until<br/>*    &gt;     byteValue    floatValue        isValidFloat    min            signum        toInt      |<br/>+    &gt;=    charValue    gcd               isValidInt      mod            testBit       toLong<br/>-    &gt;&gt;    clearBit     hashCode          isValidLong     modInverse     to            toShort<br/>/    ^     compare      intValue          isValidShort    modPow         toByte        toString<br/>/%   abs   compareTo    isProbablePrime   isWhole         pow            toByteArray   unary_-</span><span id="8526" class="kl km hi kh b fi kr ko l kp kq">scala&gt; res1.</span></pre><p id="15e5" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">注意，Scala REPL填充了您在调用制表符结束之前已经输入的内容，因此您不必再次输入。但是你仍然需要输入你从建议中选择的内容。</p><p id="4d74" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我要去试试<code class="du ks kt ku kh b">bitLength()</code>和<code class="du ks kt ku kh b">gcd()</code>:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="4908" class="kl km hi kh b fi kn ko l kp kq">scala&gt; res1.gcd(res0)<br/>res3: scala.math.BigInt = 9223372036854775807</span><span id="dab1" class="kl km hi kh b fi kr ko l kp kq">scala&gt; res1.bitLength<br/>res4: Int = 64</span></pre><p id="87ec" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我觉得跳过<code class="du ks kt ku kh b">res2</code>有点意思。你可能会觉得有点意思，也可能不会。</p><p id="e42e" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">嗯，那个<code class="du ks kt ku kh b">underlying()</code>功能是干什么的？</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="2b59" class="kl km hi kh b fi kn ko l kp kq">scala&gt; res1.underlying<br/>res5: java.math.BigInteger = 18446744073709551614</span></pre><p id="0fc8" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">哦，对了，它检索底层Java <code class="du ks kt ku kh b">BigInteger</code>。</p><p id="3f2c" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果我知道我想要的东西的前几个字母，我可以缩小建议的范围，例如“是”函数:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="a1df" class="kl km hi kh b fi kn ko l kp kq">scala&gt; res1.is<br/>isInstanceOf      isValidByte   isValidDouble   isValidInt    isValidShort<br/>isProbablePrime   isValidChar   isValidFloat    isValidLong   isWhole</span><span id="02bc" class="kl km hi kh b fi kr ko l kp kq">scala&gt; res1.is</span></pre><p id="ac2d" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">和之前一样，Scala REPL填充了我们之前输入的内容，所以我们不需要再次输入。</p><p id="b73e" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这并没有告诉我们这些函数采用什么参数，但是因为我们是在REPL中，最糟糕的事情可能是我们得到一个错误消息。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="4996" class="kl km hi kh b fi kn ko l kp kq">scala&gt; res1.isProbablePrime<br/>            ^<br/>       error: missing argument list for method isProbablePrime in class BigInt<br/>       Unapplied methods are only converted to functions when a function type is expected.<br/>       You can make this conversion explicit by writing `isProbablePrime _` or `isProbablePrime(_)` instead of `isProbablePrime`.</span><span id="4fef" class="kl km hi kh b fi kr ko l kp kq">scala&gt;</span></pre><p id="e8ca" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们还可以通过按Tab键两次来扩大建议的范围，这样完成建议也包括从超类继承而没有覆盖的项，比如从<code class="du ks kt ku kh b">java.lang.Object</code>继承<code class="du ks kt ku kh b">wait()</code>。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="92d5" class="kl km hi kh b fi kn ko l kp kq">scala&gt; res1.<br/>%    &lt;     bigInteger   doubleValue       isValidByte     longValue      setBit        toChar     unary_~<br/>&amp;    &lt;&lt;    bitCount     equals            isValidChar     lowestSetBit   shortValue    toDouble   underlying<br/>&amp;~   &lt;=    bitLength    flipBit           isValidDouble   max            sign          toFloat    until<br/>*    &gt;     byteValue    floatValue        isValidFloat    min            signum        toInt      |<br/>+    &gt;=    charValue    gcd               isValidInt      mod            testBit       toLong<br/>-    &gt;&gt;    clearBit     hashCode          isValidLong     modInverse     to            toShort<br/>/    ^     compare      intValue          isValidShort    modPow         toByte        toString<br/>/%   abs   compareTo    isProbablePrime   isWhole         pow            toByteArray   unary_-</span><span id="d1e0" class="kl km hi kh b fi kr ko l kp kq">scala&gt; res1.<br/>!=   /    ^              compare       gcd               isValidFloat   mod          sign           toFloat      <strong class="kh hs">wait</strong>   <br/><strong class="kh hs">##</strong>   /%   abs            compareTo     <strong class="kh hs">getClass</strong>          isValidInt     modInverse   signum         toInt        |      <br/>%    &lt;    <strong class="kh hs">asInstanceOf</strong>   doubleValue   hashCode          isValidLong    modPow       <strong class="kh hs">synchronized</strong>   toLong       ?      <br/>&amp;    &lt;&lt;   bigInteger     ensuring      intValue          isValidShort   ne           testBit        toShort             <br/>&amp;~   &lt;=   bitCount       eq            <strong class="kh hs">isInstanceOf</strong>      isWhole        notify       to             toString            <br/>*    ==   bitLength      equals        isProbablePrime   longValue      notifyAll    toByte         unary_-             <br/>+    &gt;    byteValue      flipBit       isValidByte       lowestSetBit   pow          toByteArray    unary_~             <br/>-    &gt;=   charValue      floatValue    isValidChar       max            setBit       toChar         underlying          <br/>-&gt;   &gt;&gt;   clearBit       formatted     isValidDouble     min            shortValue   toDouble       until</span><span id="e74f" class="kl km hi kh b fi kr ko l kp kq">scala&gt; res1.</span></pre><p id="684c" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我发现这对于标准Java和Scala类以及我编写的类都很方便。</p><p id="afcc" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">有时，您可能会根据您的REPL用法决定，您不喜欢您为某个特定函数指定的名称。您可以继续使用IntelliJ并更改函数的名称。如果您这样做，请记住，您必须退出并重新启动REPL，以使更改生效。</p></div></div>    
</body>
</html>