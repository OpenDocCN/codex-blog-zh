<html>
<head>
<title>How do View Models know how to survive configuration changes?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">视图模型如何知道如何在配置变化中生存？</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-do-view-models-know-how-to-survive-configuration-changes-66aef641f59c?source=collection_archive---------0-----------------------#2022-08-02">https://medium.com/codex/how-do-view-models-know-how-to-survive-configuration-changes-66aef641f59c?source=collection_archive---------0-----------------------#2022-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="160a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你关闭一个Android应用，你会破坏它的<em class="jd">活动</em>和<em class="jd">视图模型</em>。如果你旋转你的设备，你的<em class="jd">活动</em>将被销毁并重新创建，然而，你的<em class="jd">视图模型</em>仍然存在。但是在这两种情况下，您的<em class="jd">活动</em>都被销毁了，那么您的应用程序如何知道何时保留或何时销毁ViewModel呢？这就是我们将在下面发现的！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/6e04e985485042ef772a8a204f0a34e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_EVcYoYVIAM03I0zSN7ZA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">照片由<a class="ae ju" href="https://www.pexels.com/photo/green-and-brown-concrete-blocks-4874228/" rel="noopener ugc nofollow" target="_blank"> cottonbro </a>拍摄</figcaption></figure><h1 id="e130" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">基本用法</h1><p id="9227" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">考虑一个简单的应用程序，其中一个<code class="du ky kz la lb b">MainActivity</code>引用了一个<code class="du ky kz la lb b">MainViewModel</code>。像往常一样，我们从<code class="du ky kz la lb b">AppCompatActivity</code>扩展了<code class="du ky kz la lb b">MainActivity</code>，这给了我们一个方便的委托属性来访问我们的视图模型:<code class="du ky kz la lb b">viewModels()</code>。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="610e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的<code class="du ky kz la lb b">viewModels()</code>委托完成了一个典型的<a class="ae ju" href="https://kotlinlang.org/docs/delegated-properties.html" rel="noopener ugc nofollow" target="_blank">惰性属性</a>的工作，它确保<code class="du ky kz la lb b">MainViewModel</code>只有在你第一次引用它时才被初始化，并记住结果以备将来使用。</p><p id="4d92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在某种程度上，这描述了我们希望从<em class="jd">视图模型中得到的行为。</em>只要<em class="jd">活动</em>存在，我们就不会重新初始化<em class="jd">视图模型。</em>例如，假设我们第一次打开<code class="du ky kz la lb b">MainActivity</code>，然后在我们的Android设备中按下home键，然后再次点击打开<code class="du ky kz la lb b">MainActivity</code>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es le"><img src="../Images/38f418706d5d3233713a6c73c3180dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5ibQ9tjIeZ6HA_6gDs2hA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片作者<a class="ae ju" rel="noopener" href="/@joaofoltran">作者</a></figcaption></figure><p id="1840" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ky kz la lb b">MainActivity</code>将被创建，将进入开始然后恢复状态。按下home按钮后，<code class="du ky kz la lb b">MainActivity</code>将被置于created状态，但仍将在内存中，这意味着下次我们使用<code class="du ky kz la lb b">MainViewModel</code>时，我们将获得相同的原始引用，从而获得离开活动前存在的任何状态。</p><h1 id="b266" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">如果我们关掉整个应用程序呢？</h1><p id="05b2" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">我们对<code class="du ky kz la lb b">MainViewModel</code>的惰性初始化确保了只要<code class="du ky kz la lb b">MainActivity</code>在内存中，我们总是得到相同的<em class="jd">视图模型</em>引用。但是如果我们手动关闭应用程序，从而从内存中删除<code class="du ky kz la lb b">MainActivity</code>会怎么样呢？</p><p id="cc65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们手动关闭应用程序时，<code class="du ky kz la lb b">MainActivity</code>被销毁，活动从内存中删除。正如所料，<code class="du ky kz la lb b">MainViewModel</code>也被从内存中删除，当我们重新打开应用程序时，它将被重新初始化。</p><p id="1266" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就引出了一个问题:当我们有一个配置改变(例如旋转设备)时，<code class="du ky kz la lb b">MainActivity</code>也被销毁(在被重新创建之前)并且活动被从内存中删除，但是正如我们所知，<em class="jd">视图模型</em>在配置改变后仍然存在。他们是怎么做到的？</p><h1 id="eb8b" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">ViewModelStore类</h1><p id="1b73" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">要回答这个问题，我们需要深入了解一下<code class="du ky kz la lb b">viewModels()</code> lazy属性是如何工作的。注意，<code class="du ky kz la lb b">viewModels()</code>是<code class="du ky kz la lb b">ComponentActivity</code>的扩展函数，可从<code class="du ky kz la lb b">MainActivity</code>访问，层次如下:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lf"><img src="../Images/325ab486526b7a276c3059372a1f982f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0gs18xWWO4UoV3i8XmJmrg.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片作者<a class="ae ju" rel="noopener" href="/@joaofoltran">作者</a></figcaption></figure><p id="cace" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在来看看扩展函数本身。为了简单起见，我们将抽象出一些关于其实现的细节。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="5cc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们讨论的重要部分是该函数返回一个惰性委托来提供对<em class="jd">视图模型</em>本身<em class="jd">的访问。</em>这个委托正是我们从<code class="du ky kz la lb b">MainActivity</code>访问<em class="jd">视图模型</em>的方式，它接收一个<code class="du ky kz la lb b">viewModelStore</code>参数，该参数可从扩展函数访问，因为它是<code class="du ky kz la lb b">ComponentActivity</code>的属性。</p><p id="5734" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，<code class="du ky kz la lb b">viewModelStore</code>就像它的名字所暗示的那样:它为它的所有者存储和管理<em class="jd">视图模型</em>，在本例中就是<code class="du ky kz la lb b">MainActivity</code>本身。简而言之，</p><blockquote class="lg lh li"><p id="443a" class="if ig jd ih b ii ij ik il im in io ip lj ir is it lk iv iw ix ll iz ja jb jc hb bi translated">ViewModelStore为其所有者维护一个id到视图模型的HashMap，它是<code class="du ky kz la lb b">ComponentActivity</code>的子类。ViewModelStore的实例通过配置更改得以保留，并且如果其所有者被销毁并且不会被重新创建，则清除其视图模型。</p></blockquote><h1 id="a4a5" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">ComponentActivity类</h1><p id="626f" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">太好了，我们有一个<code class="du ky kz la lb b">viewModelStore</code>来为我们的<code class="du ky kz la lb b">MainActivity</code>管理<em class="jd">视图模型</em>。但是管理代码本身是父<code class="du ky kz la lb b">ComponentActivity</code> <em class="jd"> </em>类<em class="jd">的一部分。</em></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="839a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的摘录中，您可以看到<code class="du ky kz la lb b">ComponentActivity</code>的构造函数添加了一个生命周期事件侦听器，该侦听器在活动被销毁时执行回调。<code class="du ky kz la lb b">getViewModelStore.clear()</code>调用基本上清除了由<code class="du ky kz la lb b">viewModelStore</code>维护的<em class="jd">散列表</em>，只有在<code class="du ky kz la lb b">onDestroy</code>不是由于配置改变而被调用时才会发生。</p><p id="e3b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就结束了，因为如果<em class="jd">活动</em>由于配置更改而被销毁，上面的行<code class="du ky kz la lb b">14</code>将不会执行，<code class="du ky kz la lb b">viewModelStore</code>也不会被清除，因此<em class="jd">视图模型</em>将保持其状态。</p></div><div class="ab cl lm ln gp lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hb hc hd he hf"><p id="3cc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！如果您喜欢该内容，请不要忘记鼓掌并关注更多内容！</p></div></div>    
</body>
</html>