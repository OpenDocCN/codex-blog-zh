<html>
<head>
<title>When DRY becomes an anti-pattern: Abstraction Layers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当DRY成为反模式时:抽象层</h1>
<blockquote>原文：<a href="https://medium.com/codex/when-dry-becomes-an-anti-pattern-abstraction-layers-540b9f0cb831?source=collection_archive---------1-----------------------#2021-10-17">https://medium.com/codex/when-dry-becomes-an-anti-pattern-abstraction-layers-540b9f0cb831?source=collection_archive---------1-----------------------#2021-10-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6452" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在构建Web服务时，我逐渐意识到了这一组反模式。我找到了解决方案，而且大部分都留给了自己，因为我能够更快地构建软件，而且错误和延迟更少。那是我的秘制调味汁。</p><p id="a64c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我觉得是时候分享了，因为我真的很想挑战常规思维，给大家提供更多的概念设计工具。请注意，这更像是一篇学术文章，因为没有正确的工具，您不应该实现我的方法。相反，我希望你能帮助我要求正确的编码原则，这样有一天你会得到你的工具。</p><p id="febb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(这些天来，我已经超越到一个更好的方法，我希望在来年分享这个方法。)</p><h1 id="4850" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">一抹亮色</h1><p id="0741" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在我的上一篇文章<a class="ae kg" rel="noopener" href="/codex/when-dry-becomes-an-anti-pattern-code-in-code-87b1caab791f">https://medium . com/codex/when-dry-been-a-anti-pattern-code-in-code-87 B1 caab 791 f</a>中，我强调了可读性的重要性。</p><p id="4871" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在那篇文章的一个回复中，有人指出了我的有限定义的一个潜在缺陷:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="37df" class="kq je hi km b fi kr ks l kt ku">the "more readable" code does not scale because one will need to read too much.</span></pre><p id="3ab5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我仍然需要花时间来写一篇完整的专门文章，但现在，我只会添加一些颜色。</p><figure class="kh ki kj kk fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kv"><img src="../Images/8de8a8fc44b759d4f9699fd014d6d02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EnYb2G-K3ZBCpfVuSzVpwg.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">萨拉·帕克斯顿艺术品— <a class="ae kg" href="https://sarapaxtonartworks.com/shop-2/" rel="noopener ugc nofollow" target="_blank">在此购物</a></figcaption></figure><p id="8e5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">色彩理论在视觉艺术中很好理解，然而软件到目前为止只有伪科学。我们在探索枯燥科学的缺点，但我仓促发明的哲学，可读性是最重要的(RIMI)，也有所欠缺。</p><p id="9a86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在单个函数中编写“更多行”代码是理想的。另一种方法是将这些代码行分散到多个代码片段中。每个片段都需要自己的函数声明仪式，可能还需要类声明。当你试图阅读抽象的代码时，你不能像阅读这个句子一样按顺序阅读，你不得不像随机存取一样在代码中跳跃。计算机在随机存取方面效率较低，人类在这方面很糟糕。人类的工作记忆大约有7个符号，在抽象的代码图中跳来跳去很快就达到了这个极限，除了10x程序员，他们喜欢写这样的抽象。</p><p id="26d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，简单地增加代码行并不能达到可读性的目标。你需要设计和理解大量的决定性例子和边缘案例。我倾向于尝试建立一个“高级流程”功能。这样的函数每个“步骤”大约有1行，并且大量使用子函数来隐藏细节。</p><p id="0b2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f55b" class="kq je hi km b fi kr ks l kt ku">void ImportMechanics(sourceQuery, tableRoot, transformQuery, loadQuery)<br/>{<br/>    var sourceData = ReadFromSource("SELECT *...");<br/>    WriteToStaging(sourceData, Mechanics_Staging);<br/>    TransformData("UPDATE Mechanics_Staging...");<br/>    TransformData("UPDATE Mechanics_Staging..."); //Second transformation<br/>    LoadData("UPSERT Mechanics...");<br/>}</span></pre><p id="6472" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着函数可以用作“索引”。读码的时候，这里是大本营。这种好处在本章中被进一步放大。</p><h1 id="5950" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">抽象意大利面</h1><p id="17bb" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">接下来的3章将涵盖基于Asp.Net的Web服务中常见的3个抽象领域。它们是:管道；自定义适配器代码；还有ORM。</p><figure class="kh ki kj kk fd kw er es paragraph-image"><div class="er es lh"><img src="../Images/7b3adf8cf5f526f4a9caf2a206a8a6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*4q26-Bt0B79H8N3QDje9EQ.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">一些人如何编写ASP.Net Web服务</figcaption></figure><p id="674b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上图显示了如何处理web请求。在端口443上发出请求，在Windows上是HTTP。SYS模块将请求封送到主机匹配的正确进程。Asp.Net是在这个过程中处理请求的库。软件开发人员最终需要将Asp.Net粘合到ORM上，然后ORM与数据库进行通信。逻辑理想地与胶水分离，以使单元测试和重用逻辑更容易。</p><p id="0598" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这一章中，我将重点介绍管道。</p><h1 id="fe70" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">Asp。Net MVC管道</h1><p id="ed11" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">Asp。Net是一个固执己见的框架，随着时间的推移，这些观点已经发生了变化和改进，通常是越来越好。在最新版本<a class="ae kg" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank">Asp.Net Core 5</a>中，常用中间件这个词。</p><figure class="kh ki kj kk fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es li"><img src="../Images/0e2ca36673f31b5a14650144b97f7e7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PPWV6PDqSkYIQMowTeIIig.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">来自https://wakeupandcode.com/middleware-in-asp-net-core/<a class="ae kg" href="https://wakeupandcode.com/middleware-in-asp-net-core/" rel="noopener ugc nofollow" target="_blank">的一张非常有用的图表</a></figcaption></figure><p id="53e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Asp.Net管道处理基本的Web服务器活动，如HSTS、HTTPS重定向和静态文件。我说的不是那些。相反，应该关注Cookie策略、Auth、Session，当然还有MVC。</p><h1 id="e4c3" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">以前</h1><p id="8910" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">ASP.NET MVC模式已经很好地建立起来，而且功能强大，但是它们并不适合阅读。代码示例看起来“很少”，甚至可能是“手工制作的”，但这并没有使它更容易阅读，这是一种虚假的安慰。相反，代码是分散的，高级流程功能没有完全定义。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="fddf" class="kq je hi km b fi kr ks l kt ku">[ApiController]<br/>[Authorise(Role="Sales")]<br/>[Route("api/[controller]")]<br/>public class CarsController: ControllerBase<br/>{<br/>    private readonly CarsContext db;<br/><br/>    public TodoItemsController(TodoContext context)<br/>    {<br/>        _context = context;<br/>    }<br/><br/>    [HttpPost()]<br/>    public IActionResult Create(CarDetails newCar)<br/>    {<br/>        db.Cars.Add(newCar);<br/>        db.SaveChanges();<br/><br/>        return Ok();<br/>    } <br/>}</span></pre><p id="19b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">熟悉Asp.Net框架的人在这里会有宾至如归的感觉。但是它不像实际代码那样可读，你不能读你看不见的东西。把代码塞到壁橱里让它看起来“整洁”,但这并不真正整洁，不是吗？</p><ul class=""><li id="a501" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated"><strong class="ih hj">属性</strong>用于修饰成员，在运行时动态注册Web服务。无法调试属性。</li><li id="e912" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj">授权</strong>使用属性来注释Web服务方法的需求，但是在方法被调用之前，它们在黑盒中被强制执行。错误配置的授权很难调试。</li><li id="f361" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj">反序列化</strong>隐含在方法的参数类型中，发生在中间件的黑盒中。如果配置不当，它将会失败。</li><li id="698d" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj"> URI </strong>来源于反思。</li><li id="39fa" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj">错误</strong>处理可以集中配置</li><li id="30b9" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj">缓存</strong>可以集中配置，每个方法都有属性。这可能会变得非常复杂。不要做缓存。</li><li id="32a6" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj">依赖注入</strong>将在构建期间提供服务。这是DbContexts的推荐模式，因为框架会在结果写入响应流之后处理上下文。</li></ul><p id="b80f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要调试一个问题，你需要知道Asp.Net是如何工作的，你需要查看几个地方，看看它是如何配置的。</p><h1 id="033a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">在...之后</h1><p id="cb58" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">考虑命令式代码方法:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a909" class="kq je hi km b fi kr ks l kt ku">public class CarsController: HttpController<br/>{<br/>    public void Create(HttpContext ctx)<br/>    {<br/>        try<br/>        {<br/>            ctx.Request.DemandAuthorisedUser("Staff"); //Throws an exception if not<br/>            var newCar = CarDetails.Deserialize(ctx.Request); //Real code<br/>            using (var db = LocalDatabase.Create())<br/>            {<br/>                db.Cars.Add(newCar);<br/>                db.SaveChanges();<br/>            }<br/>            ctx.Response.Ok();<br/>        }<br/>        catch (Exception ex)<br/>        {<br/>            ctx.Response.Error(ex); //Break-point here if you like<br/>        }<br/>    } <br/>}<br/><br/>public void RegisterWebApis(IApplicationBuilder app)<br/>{<br/>    var carsController = new CarsController();<br/>    app.Use("api/Cars/Create", context =&gt; carsController.Create);<br/><br/>}</span></pre><p id="8739" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一点伪代码，因为这主要是学术性的。</p><p id="1bfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有的代码都可以在一个地方被一个刚毕业的学生阅读。</p><ul class=""><li id="a0eb" class="lj lk hi ih b ii ij im in iq ll iu lm iy ln jc lo lp lq lr bi translated">不需要依赖注入，因为有一个工厂方法。如果你需要的话，这是可以改变的——但是这实际上永远不会发生。</li><li id="0715" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj">授权</strong>现在是单行代码。这是一行你可以调试的代码。这是一行你可以修改的代码。您想禁用该功能的授权吗？注释掉该行。您是否希望此功能仅使用一次性令牌？简单。</li><li id="fbaf" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj"> URI </strong>就是专门为此功能定义的。在Create函数中，按CTRL+F12，找到它绑定到特定相对URI的位置。</li><li id="0bed" class="lj lk hi ih b ii ls im lt iq lu iu lv iy lw jc lo lp lq lr bi translated"><strong class="ih hj">错误</strong>处理明显。您可以在调试时设置断点来调查异常的深度。(如果有这样一个函数返回数据，您甚至可以捕获响应序列化错误)。</li></ul><h1 id="6b6a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="7a6c" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">因此，尽管按照预期的方式使用Asp.Net仍然是最佳实践，但我已经演示了如何使Web服务代码更具可读性。隐藏代码逻辑确实使控制器“最小化”，但这就像把一堆乱七八糟的东西塞进橱柜。复杂性是不可避免的，它应该集中在一个地方展示。</p><p id="4881" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我确信微软的工程师坚持DRY原则，许多人对提供的API非常满意。我希望看到工具和对RIMI原则开发者的支持。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="acea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这个例子是针对Web服务的，但这只是DRY原则局限性的另一个例子。如果看得太远，可读性就会受损。</p><p id="b01b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的下一篇文章中，我将继续关注Web服务管道上下文，并向您展示RIMI原理如何改进ORM抽象层。</p><p id="084d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(如果您希望我展示应用的RIMI方法，请使用注释给我发送代码示例)</p></div></div>    
</body>
</html>