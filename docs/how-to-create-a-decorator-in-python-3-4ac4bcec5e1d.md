# 如何在 Python 3 中创建装饰器

> 原文：<https://medium.com/codex/how-to-create-a-decorator-in-python-3-4ac4bcec5e1d?source=collection_archive---------7----------------------->

![](img/cd39b7c20e508d391fa6a57388f91669.png)

由[沙希·查图尔维达](https://unsplash.com/@thephotographermom?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

装饰器是编程中非常有用的设计模式，Python 使得它非常容易实现。装饰器是一个用来 *d* 装饰另一个函数的函数，其中*装饰*的意思是增加功能。开发人员使用 decorators 来扩展他人编写的代码，并实现其他目标。

在 python 中，装饰者是用`@`符号指定的。你可能熟悉 Python 的一些内置装饰器，比如`property`、`classmethod`、`staticmethod`、`abstractmethod`。下面是一个使用装饰器的例子:

在 Python 中，decorators 可以用来修改函数或类。需要注意的是，装饰者只是简写。这两个是相同的:

装饰器将函数重新定义为其自身的修改版本。利用这种理解，让我们创建一个简单的装饰器。假设我们有一个创建偶数列表的函数。让我们制作一个总结这些元素的装饰器:

装饰器接受一个函数作为参数。然后，它创建一个包装函数，调用该函数并扩展其功能。然后，它返回包装器，该包装器被指定为函数的别名。你可以直接使用函数的返回值，如果你愿意也可以返回一个新值。这是最简单的装饰类型之一。然而，它并不适用于所有场景；大多数函数都有一些参数。不仅如此，也许你希望装饰器本身有参数。让我们创建一个通用的装饰器来满足大多数目的:

# 通用装饰器

首先，当在装饰器中使用包装器时，你最好使用`functools.wraps`装饰器。 [Python 文档](https://docs.python.org/3/library/functools.html)说:

> 如果不使用这个装饰器工厂，示例函数的名称将会是`'wrapper'`，而原来的`func()`的 docstring 将会丢失。

使用这个装饰器可以让你创建一个更精炼、破坏性更小的装饰器。

现在，请注意这三个层次。外面是装饰工厂。这是一个创建函数的函数，因此是工厂设计模式。这个函数的名字定义了你为装饰器使用的名字。它还允许您向装饰器提供参数，如`functools.wraps`所示。

下一层是真正的装饰者。这将为原始函数返回一个包装器(另一种设计模式)。创建包装器的方式可以通过提供给装饰器工厂的参数来修改。

最后，还有包装函数。这个函数是原始函数的别名，这就是为什么它接受原始函数的参数。确保向函数提供这些参数，并使用返回值(如果适用)；您的函数可能不需要任意参数，也可能没有返回值。

如果你想看，下面是第 15 到 17 行做的事情(不包括`wraps`做的事情):

对于一个单一的设计模式，你已经接触到了三个。我建议花时间继续学习编程设计模式，因为它们是在程序中提供主要好处的抽象概念。困难的部分是决定何时使用某些模式而不是其他模式。当你想扩展一个函数或者一个类的功能，而不修改原始代码的时候，应该使用 Decorators。它们还提供了一种简单的方法来以同样的方式修改多个函数。有些时候你应该避免使用装饰器，但是希望现在你能够在应该使用装饰器的时候实现它们。