<html>
<head>
<title>Part 6 of Building Workflow Driven .NET Applications with Elsa 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建工作流驱动的第6部分。使用Elsa 2的. NET应用程序</h1>
<blockquote>原文：<a href="https://medium.com/codex/part-6-of-building-workflow-driven-net-applications-with-elsa-2-9b3167c612dd?source=collection_archive---------1-----------------------#2021-08-04">https://medium.com/codex/part-6-of-building-workflow-driven-net-applications-with-elsa-2-9b3167c612dd?source=collection_archive---------1-----------------------#2021-08-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="63e4" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">定制活动</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e6772d9958e27fe7c6cf77354749f520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GDcj0rEH9P102mdrS9RaBQ.png"/></div></div></figure><p id="d089" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<a class="ae kf" href="https://sipkeschoorstra.medium.com/part-4-of-building-workflow-driven-net-applications-with-elsa-2-d6699a6a247e" rel="noopener">的前一部分</a>中，我们做了一些非常酷的事情:我们调用了一个工作流来响应一个域事件。虽然这个工作流是相当无害的，但现在我们已经有了重要的部分，我们可以做更多的破坏:)</p><p id="9323" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">随着Elsa越来越丰富的活动库在您附近的NuGet feed中出现，您已经可以在不编写自定义活动的情况下做很多事情了。但是在许多自定义工作流驱动的应用程序中，您可能需要编写自定义活动的能力。这就是我们在这一部分要做的事情。</p><p id="e00e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<a class="ae kf" href="https://sipkeschoorstra.medium.com/building-workflow-driven-net-applications-with-elsa-2-part-1-44e08a9ba94b" rel="noopener">简介</a>中，我提到了以下定制活动:</p><ul class=""><li id="fccd" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko bi translated">获取文档</li><li id="d660" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">存档文档</li><li id="7b1a" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">压缩文件</li><li id="c112" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">更新区块链</li></ul><p id="fcc0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们将仔细检查每项活动，并逐一实施。</p><h1 id="fd17" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">获取文档</h1><p id="e85b" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">此活动的目的是将文档及其相关的上传文件放入内存，以便工作流可以对其进行处理。为此，它只需要一个输入:要加载的文档的ID。它的输出将是一个新记录类型的对象，同时携带文档和文件流。</p><p id="ced3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">由于这是创建的第一个活动，我将更详细地介绍它的各个方面。</p><p id="03c9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先在<code class="du lr ls lt lu b">DocumentManagement.Workflows</code>项目中创建一个新的<code class="du lr ls lt lu b">Activities</code>文件夹。然后创建一个名为<code class="du lr ls lt lu b">GetDocument</code>的新类。</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="8d17" class="lz kv hi lu b fi ma mb l mc md">using Elsa.Attributes;<br/>using Elsa.Services;<br/><br/>namespace DocumentManagement.Workflows.Activities<br/>{<br/>    public class GetDocument : Activity<br/>    {       <br/>    }<br/>}</span></pre><p id="d6fc" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上面的代码对通过实现从<code class="du lr ls lt lu b">Activity</code>基类继承的<code class="du lr ls lt lu b">IActivity</code>接口来实现活动有绝对的最低要求。</p><p id="1c1a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了让工作流设计器的用户更容易理解此活动，建议通过在类上应用<code class="du lr ls lt lu b">ActivityAttribute</code>来提供类别和描述作为元数据:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="6c5f" class="lz kv hi lu b fi ma mb l mc md">[Action(Category = "Document Management", Description = "Gets the specified document from the database.")]<br/>public class GetDocument : Activity<br/>{<br/>}</span></pre><p id="cb60" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在同一个文件中，在<code class="du lr ls lt lu b">GetDocument</code>类的上面或后面添加以下记录类型(也包括必要的名称空间):</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="1097" class="lz kv hi lu b fi ma mb l mc md">+ using System.IO;<br/>+ using DocumentManagement.Core.Models;</span><span id="9408" class="lz kv hi lu b fi me mb l mc md">public record DocumentFile(Document Document, Stream FileStream);</span></pre><h2 id="fec9" class="lz kv hi bd kw mf mg mh la mi mj mk le js ml mm lg jw mn mo li ka mp mq lk mr bi translated">IsExternalInit</h2><p id="fd8d" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">此时，您可能会收到来自IDE的抱怨，说预定义的类型系统。必须定义或导入“runtime . compiler services . isexternalInit ”,才能声明仅限init的setter。”。我们以前见过这种情况，所以我们知道该怎么做:只需将<code class="du lr ls lt lu b">IsExternalInit.cs</code>文件从<code class="du lr ls lt lu b">DocumentManagement.Core</code>项目复制到<code class="du lr ls lt lu b">DocumentManagement.Workflows</code>项目的根目录中。</p></div><div class="ab cl mt mu gp mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="hb hc hd he hf"><h2 id="509f" class="lz kv hi bd kw mf mg mh la mi mj mk le js ml mm lg jw mn mo li ka mp mq lk mr bi translated">投入</h2><p id="2d3f" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">解决了这个问题，让我们继续添加活动的输入属性<code class="du lr ls lt lu b">DocumentId</code>:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="d718" class="lz kv hi lu b fi ma mb l mc md">+ using Elsa.Expressions;</span><span id="e192" class="lz kv hi lu b fi me mb l mc md">[ActivityInput(<br/>    Label = "Document ID",<br/>    Hint = "The ID of the document to load",<br/>    SupportedSyntaxes = new[] {SyntaxNames.JavaScript, SyntaxNames.Liquid}<br/>)]<br/>public string DocumentId { get; set; } = default!;</span></pre><p id="bd3d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于引擎和设计者来说,<code class="du lr ls lt lu b">ActivityInputAttribute</code>都是必要的。引擎使用属性作为标记来确定要序列化的属性，而设计器使用额外的元数据，如<code class="du lr ls lt lu b">Label</code>和<code class="du lr ls lt lu b">Hint</code>，以用户友好的方式显示活动。在显示属性时，活动编辑器利用了<code class="du lr ls lt lu b">SupportedSyntaxes</code>属性，并允许用户从属性的默认输入编辑器切换到JavaScript或Liquid编辑器。</p><h2 id="3797" class="lz kv hi bd kw mf mg mh la mi mj mk le js ml mm lg jw mn mo li ka mp mq lk mr bi translated">输出</h2><p id="bea0" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">接下来，添加以下输出属性:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="866b" class="lz kv hi lu b fi ma mb l mc md">[ActivityOutput(<br/>    Hint = "The document + file.",<br/>    DefaultWorkflowStorageProvider = TransientWorkflowStorageProvider.ProviderName)]<br/>public DocumentFile Output { get; set; } = default!;</span></pre><p id="363b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">工作流引擎和设计者也以类似于<code class="du lr ls lt lu b">ActivityInputAttribute</code>的方式使用<code class="du lr ls lt lu b">ActivityOutputAttribute</code>。设计者目前没有利用<code class="du lr ls lt lu b">Hint</code>属性，但是在未来的版本中这可能会改变，所以最好做好准备。</p><p id="bfd1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><code class="du lr ls lt lu b">DefaultWorkflowStorageProvider</code>属性告诉引擎使用什么<em class="ms">工作流存储提供者</em>来保存<code class="du lr ls lt lu b">DocumentFile</code>的值。</p><p id="2600" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">默认情况下，所有活动属性都作为工作流实例的一部分进行序列化。但这并不是所有类型都需要的。例如，我们的<code class="du lr ls lt lu b">DocumentFile</code>记录包含一个类型为<code class="du lr ls lt lu b">Stream</code>的属性。这通常表明这里可能储存了大量的东西。如果我们将其序列化为base64，工作流实例可能会变得非常大，这将在每次从数据库加载实例时对性能产生负面影响，这也意味着它需要被反序列化。</p><p id="40f3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">通过使用不同的存储提供程序，如<code class="du lr ls lt lu b">TransientWorkflowStorageProvider</code>，对象将仅存储在内存中。</p><blockquote class="na nb nc"><p id="4e7e" class="jj jk ms jl b jm jn ij jo jp jq im jr nd jt ju jv ne jx jy jz nf kb kc kd ke hb bi translated">用户可以基于每个属性来控制使用哪个存储提供商。<code class="du lr ls lt lu b">DefaultWorkflowStorageProvider</code>仅提供默认设置。如果您想完全阻止用户拥有选项，请将<code class="du lr ls lt lu b">DisableWorkflowProviderSelection</code>属性设置为<code class="du lr ls lt lu b">true</code>。</p></blockquote><h2 id="14c6" class="lz kv hi bd kw mf mg mh la mi mj mk le js ml mm lg jw mn mo li ka mp mq lk mr bi translated">执行</h2><p id="b370" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">当活动执行时，我们希望它做以下事情:</p><ol class=""><li id="f4de" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke ng km kn ko bi translated">从数据库中按ID加载文档。</li><li id="5b1e" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke ng km kn ko bi translated">将相关文件作为流读取。</li><li id="218a" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke ng km kn ko bi translated">将这些东西作为输出返回。</li></ol><p id="4f65" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要加载文档，我们需要注入<code class="du lr ls lt lu b">IDocumentStore</code>。而要读取文件，需要注入<code class="du lr ls lt lu b">IFileStorage</code>。用以下字段和构造函数更新该类:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="cd42" class="lz kv hi lu b fi ma mb l mc md">+ using DocumentManagement.Core.Services;</span><span id="7a38" class="lz kv hi lu b fi me mb l mc md">private readonly IDocumentStore _documentStore;<br/>private readonly IFileStorage _fileStorage;<br/><br/>public GetDocument(IDocumentStore documentStore, IFileStorage fileStorage)<br/>{<br/>    _documentStore = documentStore;<br/>    _fileStorage = fileStorage;<br/>}</span></pre><p id="8053" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，如下重写<code class="du lr ls lt lu b">OnExecuteAsync</code>方法:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="ce1f" class="lz kv hi lu b fi ma mb l mc md">+ using System.Threading.Tasks;<br/>+ using Elsa.ActivityResults;<br/>+ using Elsa.Providers.WorkflowStorage;<br/>+ using Elsa.Services.Models;</span><span id="2f1f" class="lz kv hi lu b fi me mb l mc md">protected override async ValueTask&lt;IActivityExecutionResult&gt; OnExecuteAsync(ActivityExecutionContext context)<br/>{<br/>    var document = await _documentStore.GetAsync(DocumentId, context.CancellationToken);<br/>    var fileStream = await _fileStorage.ReadAsync(document!.FileName, context.CancellationToken);<br/><br/>    Output = new DocumentFile(document, fileStream);<br/>    return Done();<br/>}</span></pre><p id="7514" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">完整的文件应该如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div></figure><h2 id="4d1a" class="lz kv hi bd kw mf mg mh la mi mj mk le js ml mm lg jw mn mo li ka mp mq lk mr bi translated">注册活动</h2><p id="b6a8" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">在我们实际使用工作流上的活动之前，我们需要向Elsa注册它。为此，更新<code class="du lr ls lt lu b">ServiceCollectionExtensions</code>类并在<code class="du lr ls lt lu b">.AddHttpActivities()</code>调用之后添加以下代码:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="b539" class="lz kv hi lu b fi ma mb l mc md">// Add custom activities<br/>.AddActivitiesFrom&lt;GetDocument&gt;()</span></pre><p id="70d0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这不仅会注册<code class="du lr ls lt lu b">GetDocument</code>活动，还会注册我们在这个项目中创建的任何附加活动。</p><h2 id="f5d4" class="lz kv hi bd kw mf mg mh la mi mj mk le js ml mm lg jw mn mo li ka mp mq lk mr bi translated">尝试一下</h2><p id="a954" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">虽然在下一部分之前我们不会实现任何文档处理工作流，但是让我们通过以下步骤来确保活动正常运行:</p><ol class=""><li id="a05b" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke ng km kn ko bi translated">启动web应用程序。</li><li id="eb2d" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke ng km kn ko bi translated">启动艾尔莎工作室。</li><li id="6cd8" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke ng km kn ko bi translated">创建新的工作流。</li><li id="c965" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke ng km kn ko bi translated">添加新的<strong class="jl hj">获取文档</strong>活动，并将其文档ID设置为以下JavaScript语法:<code class="du lr ls lt lu b">correlationId</code>。</li><li id="4a02" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke ng km kn ko bi translated">用以下液体内容连接一个新的<strong class="jl hj"> HTTP响应</strong>活动:<code class="du lr ls lt lu b">The document’s file name is {{ Input.Document.FileName }}</code></li><li id="a028" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke ng km kn ko bi translated">发布工作流并记下其ID(导航回工作流定义屏幕，单击新创建的工作流并从浏览器的地址栏复制工作流ID)。</li><li id="1b8e" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke ng km kn ko bi translated">转到web应用程序的主页并上传文档。记下生成的文档ID。</li><li id="3e8e" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke ng km kn ko bi translated">打开Postman或您自己喜欢的HTTP客户端，并执行以下请求，以使用Elsa API调用工作流(用您自己的值替换“{your-workflow-id}”和“{your-document-id}”):</li></ol><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="27ca" class="lz kv hi lu b fi ma mb l mc md">curl --location --request POST 'https://localhost:5001/v1/workflows/<strong class="lu hj">{your-workflow-id}</strong>/execute' \<br/>--header 'Content-Type: application/json' \<br/>--data-raw '{<br/>"correlationId": "<strong class="lu hj">{your-document-id}</strong>"<br/>}'</span></pre><p id="40a3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">响应应该是这样的:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="7d26" class="lz kv hi lu b fi ma mb l mc md">The document's file name is</span></pre><p id="a377" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这可能不是你所期望的。尽管我们清楚而正确地应用了一个液体表达式:<code class="du lr ls lt lu b">The document’s file name is {{ Input.Document.FileName }}</code>，并且我们知道文档以一个实际的文件名存储在数据库中，但是由于某种原因，它没有呈现文件名。</p><h2 id="3538" class="lz kv hi bd kw mf mg mh la mi mj mk le js ml mm lg jw mn mo li ka mp mq lk mr bi translated">流动和允许上市</h2><p id="dd82" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">为了理解为什么，我们需要知道Elsa使用<a class="ae kf" href="https://github.com/sebastienros/fluid" rel="noopener ugc nofollow" target="_blank">流体库</a>来评估流体表达式。虽然液体完全可以进入。NET对象，<a class="ae kf" href="https://elsa-workflows.github.io/elsa-core/docs/next/expressions/expressions-liquid#allow-listing-a-specific-type" rel="noopener ugc nofollow" target="_blank">需要告诉用户允许访问哪些类型</a>。这使得Liquid成为一种安全的模板语言。</p><p id="6ad9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为我们的liquid表达式访问了<code class="du lr ls lt lu b">DocumentFile</code>和<code class="du lr ls lt lu b">Document</code>类型(因为<code class="du lr ls lt lu b">Document </code>是它的一个属性)，这意味着我们需要用Liquid允许列出它们。让我们马上做那件事。</p><p id="28c3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<code class="du lr ls lt lu b">DocumentManagement.Workflows</code>项目中，创建一个名为<code class="du lr ls lt lu b">Scripting</code>的新文件夹和一个名为<code class="du lr ls lt lu b">Liquid</code>的子文件夹。然后创建以下类:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="35cd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意，这是一个处理<code class="du lr ls lt lu b">EvaluatingLiquidExpression</code>事件的通知处理程序。每次引擎要对给定活动属性的液体表达式求值时，都会发布此事件。</p><p id="df17" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在事件处理程序中，我们访问流体的<code class="du lr ls lt lu b">TemplateContext</code>，并通过注册我们的<code class="du lr ls lt lu b">DocumentFile</code>类型来配置它的<code class="du lr ls lt lu b">MemberAccessStrategy</code>。</p><p id="b1af" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因为我们已经从<code class="du lr ls lt lu b">ServiceCollectionExtensions</code>类中调用了<code class="du lr ls lt lu b">.AddNotificationHandlersFrom&lt;StartDocumentWorkflows&gt;()</code>，这个事件处理程序将自动注册到服务容器中。</p><p id="266d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当我们再次执行HTTP请求时，我们现在会看到类似这样的内容:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="458b" class="lz kv hi lu b fi ma mb l mc md">The document's file name is a3fe4f2b-8ef1-4984-ac98-1b571171a6d6.docx</span></pre><p id="7923" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">光荣。让我们花点时间思考一下我们刚刚学到的内容:</p><ul class=""><li id="e5ee" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko bi translated">我们创建了一个自定义活动，它接收文档ID作为输入，并提供加载的文档和文件流作为输出。</li><li id="4271" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">我们可以对文档ID值进行硬编码，但是我们以JavaScript表达式的形式提供输入。</li><li id="70fd" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">然后，我们连接HTTP响应活动，利用Liquid写回加载的文档的文件名。</li><li id="88ed" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">我们了解到，如果我们想要访问这些类型的对象，我们必须配置Liquid并允许列出我们的自定义类型。</li><li id="ebe0" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">我们使用Elsa API来执行我们的工作流程。</li></ul><p id="1fd7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来，让我们处理<strong class="jl hj">归档文档</strong>活动。</p><h1 id="8f2d" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">存档文档</h1><p id="1031" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated"><strong class="jl hj">存档文档</strong>活动非常简单，它只需要执行两个任务:</p><ol class=""><li id="7865" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke ng km kn ko bi translated">将给定<code class="du lr ls lt lu b">Document</code>的<code class="du lr ls lt lu b">Status</code>属性设置为<code class="du lr ls lt lu b">Archived</code>。</li><li id="d16c" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke ng km kn ko bi translated">更新数据库中的文档。</li></ol><p id="b436" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">该活动将接受一个输入，即要更新的<code class="du lr ls lt lu b">Document</code>。</p><p id="8fb4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">要创建的完整文件<code class="du lr ls lt lu b">ArchiveDocument.cs</code>如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="4317" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">虽然这个活动很无聊，但是它展示了快速实现一个有用的自定义活动是多么容易。</p><p id="232e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了测试这个活动，将它连接到我们之前创建的工作流的Get Document活动，并使用下面的JS表达式作为它的<code class="du lr ls lt lu b">Document</code>属性:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="0262" class="lz kv hi lu b fi ma mb l mc md">input.Document</span></pre><p id="cc38" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是因为Get Document活动的输出返回一个类型为<code class="du lr ls lt lu b">DocumentFile</code>的对象，它包含一个<code class="du lr ls lt lu b">Document</code>和一个<code class="du lr ls lt lu b">FileStream</code>属性。由于<strong class="jl hj">存档文档</strong>活动在<strong class="jl hj">获取文档</strong>活动之后立即执行，因此前者的输出可作为后者的输入。</p><p id="c284" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然而，有一个很大的警告:HTTP响应活动现在不再直接连接到Get Document活动，所以它不能再使用<code class="du lr ls lt lu b">Input</code>变量。</p><p id="69c4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为了解决这个问题，我们需要给<strong class="jl hj">获取文档</strong>活动一个名称。为活动命名允许您从工作流中的任何其他活动访问这些活动的输出。</p><p id="ca69" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">所以我们要做的是:</p><ol class=""><li id="7dc4" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke ng km kn ko bi translated">将<strong class="jl hj">获取文件</strong>命名为<code class="du lr ls lt lu b">GetDocument1</code>。</li><li id="ae3c" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke ng km kn ko bi translated">用以下液体内容更新<strong class="jl hj"> HTTP响应</strong>活动:</li></ol><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="f2c5" class="lz kv hi lu b fi ma mb l mc md">The document's file name is {{ Activities.GetDocument1.Output.Document.FileName }} and the document's status is {{ Activities.GetDocument1.Output.Document.Status }}</span></pre><p id="99a1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">工作流应该是这样的:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nj"><img src="../Images/f06d5e1451d05b56d430c5cae34dce18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEPlfymt20ud2shXAHtbmA.png"/></div></div></figure><p id="7ba6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">回应应该是这样的:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="e726" class="lz kv hi lu b fi ma mb l mc md">The document's file name is b01bd191-2891-44d2-84e5-c8d4bfbb6917.docx and the document's status is 1</span></pre><p id="1e18" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来我们来看一个更有趣的活动。</p><h1 id="3888" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">压缩文件</h1><p id="2fe0" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">这个活动更有趣，因为它做了一些我不是每天都在做的事情。这个函数的唯一目的是获取一个流并返回它的压缩版本。</p><p id="a7da" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">它有两个输入属性:</p><ol class=""><li id="3d6a" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke ng km kn ko bi translated">要压缩的流。</li><li id="8951" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke ng km kn ko bi translated">将条目写入zip存档时使用的文件名。</li></ol><p id="2f26" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下面是要创建的代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="c843" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">没什么特别的，但是应用程序很棒。通过更新工作流程进行尝试，并使用以下设置将<strong class="jl hj"> Zip文件</strong>活动连接到<strong class="jl hj">存档文档</strong>:</p><ul class=""><li id="6988" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko bi translated">流(JS): <code class="du lr ls lt lu b">activities.GetDocument1.Output().FileStream</code></li><li id="64cd" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">文件名(JS): <code class="du lr ls lt lu b">activities.GetDocument1.Output().Document.FileName</code></li></ul><p id="2004" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后更新<strong class="jl hj"> HTTP响应</strong>，通过配置以下设置将压缩流写回下载:</p><ul class=""><li id="b162" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko bi translated">内容(JS): <code class="du lr ls lt lu b">input</code></li><li id="f38d" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">内容类型(文字):<code class="du lr ls lt lu b">application/zip</code></li><li id="189e" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">回复标题(高级选项卡):<code class="du lr ls lt lu b">{ \"Content-Disposition\": \"attachment; filename=download.zip\" }</code></li></ul><p id="eec1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">完整的工作流应该如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nk"><img src="../Images/acc4e31286f49c0f4e701f7fe9ff97ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hIST1SkvlcO19qKo8Z5pgQ.png"/></div></div></figure><p id="d042" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当您现在上传文档并使用Postman执行工作流时，您应该会收到二进制内容。使用Postman将响应保存为zip文件，以确保您可以打开文件并签出内容。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nl"><img src="../Images/8cd15cd5b3e5e41d31c71bedb5b415b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*lzeROeIV76H6ro5tUGJ8Jw.png"/></div></figure><p id="e463" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你觉得这很酷，那我同意！</p><p id="18cd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">接下来进入最后要实现的活动:<strong class="jl hj">更新区块链</strong>。</p><h1 id="0e20" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">更新区块链</h1><p id="855e" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">尽管这个活动的名字可能非常令人兴奋，但我们实际上并没有给任何区块链写任何东西。这也不仅仅是一个诡计；我完全可以想象有人编写一个活动，将文档签名写入区块链，作为文档管理系统的一部分，使其防篡改。</p><p id="818e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里更重要的一点是:当工作流进入休眠状态并等待后台任务完成时，有些活动最好在后台运行。</p><p id="8fea" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这就是我们接下来要展示的内容:编写一个活动来启动一个任务，在任务运行时暂停工作流，然后在任务完成后让任务恢复工作流。</p><p id="231a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为此，我们将利用Hangfire作为在后台运行任务的引擎。</p><p id="7800" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">作为第一步，让我们这样定义活动框架:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="9aa3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">活动接收一个<code class="du lr ls lt lu b">File</code>作为输入。这可以通过一个<code class="du lr ls lt lu b">Stream</code>或一个<code class="du lr ls lt lu b">byte[]</code>来实现。然后，它会计算一个哈希并挂起工作流。</p><p id="7c78" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这一点上，没有什么会恢复这一活动。接下来我们来处理这个问题。</p><p id="6b2b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，让我们注入Hangfire的<code class="du lr ls lt lu b">IBackgroundJobClient</code>服务，并定义一个新的<code class="du lr ls lt lu b">record</code>类型，它将为后台工作提供一些上下文:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="386a" class="lz kv hi lu b fi ma mb l mc md">public record UpdateBlockchainContext(string WorkflowInstanceId, string ActivityId, string FileSignature);</span></pre><p id="d523" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后用下面一行替换<code class="du lr ls lt lu b">OnExecuteAsync</code>中的<code class="du lr ls lt lu b">TODO</code>注释:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="02d3" class="lz kv hi lu b fi ma mb l mc md">// Schedule background work using Hangfire.<br/>_backgroundJobClient.Enqueue(() =&gt; SubmitToBlockChainAsync(new UpdateBlockchainContext(context.WorkflowInstance.Id, context.ActivityId, fileSignature), CancellationToken.None));</span></pre><p id="2d7a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这将使一个以<code class="du lr ls lt lu b">SubmitToBlockChainAsync</code>方法形式实现的新作业入队，接下来我们将把它定义为(作为activity类中的一个公共方法):</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="4bdd" class="lz kv hi lu b fi ma mb l mc md">/// &lt;summary&gt;<br/>/// Invoked by Hangfire as a background job.<br/>/// &lt;/summary&gt;<br/>public async Task SubmitToBlockChainAsync(UpdateBlockchainContext context, CancellationToken cancellationToken)<br/>{<br/>    // Simulate storing it on an imaginary blockchain out there.<br/>    await Task.Delay(TimeSpan.FromSeconds(15), cancellationToken);<br/>}</span></pre><p id="6423" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">一旦工作完成(等待15秒)，我们需要恢复工作流。一个好的方法是利用<code class="du lr ls lt lu b">IWorkflowInstanceDispatcher</code>，它让我们通过ID调度一个现有的工作流实例来执行。</p><p id="b676" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">继续注入<code class="du lr ls lt lu b">IWorkflowInstanceDispatcher</code>，然后将下面一行添加到<code class="du lr ls lt lu b">SubmitToBlockChainAsync</code>方法:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="598b" class="lz kv hi lu b fi ma mb l mc md">// Resume the suspended workflow.<br/>await _workflowInstanceDispatcher.DispatchAsync(new ExecuteWorkflowInstanceRequest(context.WorkflowInstanceId, context.ActivityId, new WorkflowInput(context.FileSignature)), cancellationToken);</span></pre><p id="5b6a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在您也看到了为什么我们的小<code class="du lr ls lt lu b">UpdateBlockchainContext</code>记录类型携带工作流实例ID和我们的活动ID——我们需要这两个值来恢复将被我们的活动阻塞的工作流。</p><p id="a479" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们还简单地通过将<code class="du lr ls lt lu b">FileSignature</code>作为工作流输入发送来回应它。</p><p id="9933" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当工作流恢复时，工作流引擎将调用我们的activitiy的<code class="du lr ls lt lu b">OnResumeAsync</code>方法。现在让我们更新它，以接收文件签名并将其存储为活动的输出。用以下内容替换<code class="du lr ls lt lu b">TODO</code>注释:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="e49e" class="lz kv hi lu b fi ma mb l mc md">var fileSignature = context.GetInput&lt;string&gt;();<br/>Output = fileSignature;</span></pre><p id="d95c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">完整的活动应该如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="nh ni l"/></div></figure><h2 id="769c" class="lz kv hi bd kw mf mg mh la mi mj mk le js ml mm lg jw mn mo li ka mp mq lk mr bi translated">尝试</h2><p id="4eeb" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">我们来试试吧！</p><p id="b5d9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">通过将<strong class="jl hj">更新区块链</strong>活动连接到<strong class="jl hj"> Zip文件</strong>活动来更新工作流，并配置如下:</p><ul class=""><li id="0d90" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko bi translated">文件(JS): <code class="du lr ls lt lu b">input</code></li></ul><p id="4c42" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们还要确保替换掉<strong class="jl hj"> HTTP Response </strong>活动，因为区块链活动会让工作流休眠，并在不再有任何HTTP上下文可用的背景中恢复工作流。</p><p id="6138" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们这样做:</p><ol class=""><li id="af93" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke ng km kn ko bi translated">删除<strong class="jl hj"> HTTP响应</strong>活动。</li><li id="f50c" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke ng km kn ko bi translated">使用以下设置连接新的写入行活动:</li></ol><ul class=""><li id="cd37" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko bi translated">文本(液体):<code class="du lr ls lt lu b">File signature: {{ Input }}</code></li></ul><p id="5b02" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">发布更改并调用工作流。请注意，现在完成工作流大约需要15秒钟。还要注意，当您等待时，工作流处于<em class="ms">暂停</em>状态:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nm"><img src="../Images/323d63de8cef854affd2017181121aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jEFC6xnR9lmq7iPetTMhPg.png"/></div></div></figure><p id="2497" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">大约15秒钟后，控制台窗口应该会打印出如下输出:</p><pre class="iy iz ja jb fd lv lu lw lx aw ly bi"><span id="6e93" class="lz kv hi lu b fi ma mb l mc md">File signature: ojPRr24fjiSUC0rQdVI4ieYoyy7Uhb1QfChtTKgStr4=</span></pre><h1 id="6480" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">然后</h1><p id="a146" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">我不知道你怎么想，但我认为编写自定义活动非常有趣！</p><p id="b745" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在<a class="ae kf" href="https://sipkeschoorstra.medium.com/part-7-of-building-workflow-driven-net-applications-with-elsa-2-e369e7784555" rel="noopener">的下一部分</a>中，我们将把它们放在一起，为每种文档类型创建一个工作流，并充分利用这些自定义活动以及一些内置活动。</p><p id="1e2e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那里见！</p></div></div>    
</body>
</html>