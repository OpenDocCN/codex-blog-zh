<html>
<head>
<title>A Guide to Pointers in C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C语言中的指针指南</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-guide-to-pointers-in-c-15379a2d44ce?source=collection_archive---------4-----------------------#2021-07-28">https://medium.com/codex/a-guide-to-pointers-in-c-15379a2d44ce?source=collection_archive---------4-----------------------#2021-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/47b12193e00518f19f56537e40792ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SVIkP15DiQmMWqzS"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@helloimnik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">你好我是尼克</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="9447" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在C和C++编程领域，指针是开发人员的必备工具。许多现代编程语言将指针的功能从开发人员的直接控制中抽象出来，而是自己处理它。在低级语言中，开发人员能够直接与内存交互。<strong class="ix hj">从根本上说，指针只是指向内存中某个位置的地址。</strong></p><h1 id="869a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">变量如何存储在内存中</h1><p id="ac86" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">c将所有变量存储在某种内存中。这可能在堆栈、堆或其他形式的内存中。然而，除非它们存储在寄存器中，否则它们将有一个内存地址。事实上，这是c语言中使用类型的主要原因。<strong class="ix hj">变量的类型在声明时告诉编译器在堆栈上为变量分配多少内存。这就是为什么C有这么多类型，比如char，short，int，long等等。这些类型的确切大小取决于编译器；不过一般来说，char是一个字节，short是两个字节，int是四个字节，long是八个字节。我怀疑C没有本地boolean类型的原因是因为单个位是不可寻址的，而boolean最小只能是一个字节。普通的变量声明和定义如下:</strong></p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d1a8" class="lf ju hi lb b fi lg lh l li lj">int sum = 0;</span></pre><p id="d38d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们告诉编译器在堆栈上分配四个字节，并在内存中设置这些字节的值，这样，当被视为一个整数时，该整数的值为0。请理解，内存的每个单元(一个字节)都是可单独寻址的。这意味着任何占用超过一个字节的数据都必须以某种方式拆分。对于整数，这是非常直观的；只需将数字写成二进制，并将连续的字节视为连续的数字。然而，对于像floats这样的数据类型，情况就不同了(我们甚至不会提到像structs这样的定制数据类型)。此外，即使是整数也不是那么简单，因为有符号整数使用一种称为二进制补码的系统来表示正负整数。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2936" class="lf ju hi lb b fi lg lh l li lj">float cash = 5.25f;</span></pre><p id="557b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">浮点数通常以二进制存储在科学记数法中，在四个字节以内。一位用于符号，然后(通常但不总是)八位用于指数，剩余的23位用于有效值，也称为尾数。因此，虽然整数5可以存储为<code class="du lk ll lm lb b">00000000 00000000 00000000 00000101</code>，但是浮点数5.25可以存储为<code class="du lk ll lm lb b">01000000 10101000 00000000 00000000</code>。整数可以简单地解释为二进制补码整数<code class="du lk ll lm lb b">00000000000000000000000000000101</code>，但是浮点必须解释为<code class="du lk ll lm lb b">0</code>表示正，<code class="du lk ll lm lb b">1000000 1</code>表示-2的指数，<code class="du lk ll lm lb b">01010000000000000000000</code>表示尾数525。这不是很明显。首先，二进制中的所有尾数都将以1开头，所以没有必要存储它。有很多聪明的策略被用来解释一个浮动的价值，我建议<a class="ae iu" href="https://www.log2base2.com/storage/how-float-values-are-stored-in-memory.html" rel="noopener ugc nofollow" target="_blank">你继续研究</a>，如果你感兴趣的话。</p><p id="0670" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的主要观点是简单地让你明白，你存储在变量中的数字不是简单地复制粘贴到一个内存地址中；它们必须以某种方式编码，并在访问时被解码。如果您想继续研究这种编码和解码，Python提供了一种简单的方法:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">格式字符见<a class="ae iu" href="https://docs.python.org/3/library/struct.html" rel="noopener ugc nofollow" target="_blank"> Python文档</a></figcaption></figure><h1 id="8db5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用指针</h1><p id="fefc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">C语言中有几个与指针相关的操作符，主要有两个:地址操作符<code class="du lk ll lm lb b">&amp;</code>和取消引用操作符<code class="du lk ll lm lb b">*</code>。注意，这些操作符在C语言中用于其他事情；然而，当用作左一元运算符时，这些符号表示地址或取消引用。左一元运算符是接受一个操作数的运算符，表示在它的左边。为了在C中声明一个指针，你只需在你想指向的类型的右边添加一个<code class="du lk ll lm lb b">*</code>。以下是声明整数指针的正确方法:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9324" class="lf ju hi lb b fi lg lh l li lj">int* pointer;<br/>int * pointer;<br/>int *pointer;</span></pre><p id="bd6c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看你个人喜好了；我更喜欢用C++写<code class="du lk ll lm lb b">int* pointer</code>，用C写<code class="du lk ll lm lb b">int *pointer</code>，两者都有好处；然而，这是一个简单的风格选择，只要你始终如一，任何都可以。类似于你声明了一个变量而没有定义它，一个新声明的指针将会有一个垃圾值，这个值就是之前在内存中的值。这就是事情开始变得棘手的地方，但是指针只是一个花哨的整数。一个<strong class="ix hj">指针存储一个内存地址，是一个整数。这意味着指针本身只是一个整数，因此，指针有自己的内存地址。</strong>就像《盗梦空间》一样，可以有指针对指针的指针。</p><p id="7c8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">指针存储内存地址。指针指向存储在该地址中的值，因此得名。你也可以说指针引用了这个值。为了获得存储在内存地址的值，必须取消对指针的引用:</p><p id="c41b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lk ll lm lb b">int value = *pointer;</code></p><p id="1e2c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于指针被声明为类型<code class="du lk ll lm lb b">int *</code>，编译器知道它是一个指向整数的指针。当我们在指针上使用解引用操作符时，编译器知道如何找到值；基础整数。请记住，指针中存储的地址只是内存中底层值的第一个地址。<strong class="ix hj">之前我们提到声明一个int在内存中分配四个字节。指向该整数的指针将存储第一个字节的地址。编译器可以找到所有四个字节，因为它们是顺序分配的，int类型告诉编译器要查看多少字节。</strong></p><p id="774b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，您也可以通过执行<code class="du lk ll lm lb b">*pointer = 5;</code>来写入底层整数，例如。这就是说将指针引用的值设置为5。如果你做了<code class="du lk ll lm lb b">pointer = 5;</code>，那将意味着设置指针指向内存地址5。总而言之，要获取或设置声明指针的值，请使用<code class="du lk ll lm lb b">*pointer</code>。要获取或设置由声明的指针存储的内存地址，只需使用<code class="du lk ll lm lb b">pointer</code>。现在，让我们展示如何实际指向变量:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3ece" class="lf ju hi lb b fi lg lh l li lj">float x = 0.0f;<br/>float *p = &amp;x;</span><span id="99d0" class="lf ju hi lb b fi lp lh l li lj">// *p = x = 0.0f while p = &amp;x = 0x6aff (or some memory address)</span><span id="8492" class="lf ju hi lb b fi lp lh l li lj">*p = 5.0f;</span><span id="a377" class="lf ju hi lb b fi lp lh l li lj">// *p = x = 5.0f</span></pre><p id="5ab0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了指向一个变量，你需要设置指针指向变量的内存地址。这是通过使用地址操作符<code class="du lk ll lm lb b">&amp;</code>完成的，它返回其操作数的内存地址。<strong class="ix hj">一旦一个指针指向一个变量，你就可以用那个指针修改变量的值。</strong>回想一下，变量只是内存中字节数组的别名；指针可以修改这些字节。指针可以根据需要多次重定义。如果你想创建一个指向指针的指针，这很简单:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="429f" class="lf ju hi lb b fi lg lh l li lj">char z = 'z';<br/>char *single = &amp;z;<br/>char **double = &amp;single;</span><span id="30a4" class="lf ju hi lb b fi lp lh l li lj">// We can set z to 'a' one of three ways:<br/>z = 'a' // ||<br/>*single = 'a' // ||<br/>**double = 'a'</span><span id="1ff5" class="lf ju hi lb b fi lp lh l li lj">// We can also tell single to point to a new char one of two ways:<br/>char y = 'y';</span><span id="9e11" class="lf ju hi lb b fi lp lh l li lj">single = &amp;y; // ||<br/>*double = &amp;y;</span></pre><p id="e353" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能想要创建指向指针的指针，这是有原因的，稍后我们将深入探讨这些原因。</p><h2 id="c023" class="lf ju hi bd jv lq lr ls jz lt lu lv kd jg lw lx kh jk ly lz kl jo ma mb kp mc bi translated"><strong class="ak">用</strong> <code class="du lk ll lm lb b"><strong class="ak">const</strong></code> <strong class="ak">带指针</strong></h2><p id="b803" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在C语言中，尤其是在C++中，有时你想使用一个常量数据类型的指针。有时候你也想使用一个常量指针。这可能会令人困惑，坦率地说，这不是最好的符号，但它非常简单:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c0a7" class="lf ju hi lb b fi lg lh l li lj">int a = 0;<br/>const int b = 1;</span><span id="b814" class="lf ju hi lb b fi lp lh l li lj">const int *pointer = &amp;b; // A pointer to a constant variable<br/>int *const pointer = &amp;a; // A constant pointer to a variable<br/>const int *const pointer = &amp;b; // Both</span></pre><p id="34b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关键字<code class="du lk ll lm lb b">const</code>修改直接在它右边的内容；当它在类型的左边时，意味着类型是常量。当它在指针名称的左边时，意味着指针是常量。这可能是一种很好的记忆方式。在C中，类型只是告诉编译器如何解释一个值。这意味着很容易创建未定义的行为。例如，除非C编译器明确禁止，否则可以简单地创建一个指向常数值的非常数指针并修改它。然而，一般来说，最好使用带有常量值的常量指针，以确保没有意外的修改。</p><p id="31c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你的指针是常量，那么你不能改变它的值。所以，它只能指向一个地址。如果它指向一个常量，那么您不能使用指针来修改基础值，但是您可以将指针指向一个不同的常量值。</p><p id="b434" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于大型数据(如结构),将指向结构的指针传递给函数而不是结构本身可以提高性能。这是因为，如前所述，指针只是一个整数。您可以简单地传递struct对象的内存地址，而不是在函数内部创建一个新对象并复制它的所有数据。使用const，您可以(大部分)确保这些数据不会被修改。</p><h2 id="0f47" class="lf ju hi bd jv lq lr ls jz lt lu lv kd jg lw lx kh jk ly lz kl jo ma mb kp mc bi translated">数组和其他运算符</h2><p id="db46" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在C #中，数组元素存储在连续的内存地址中。要创建整数数组，有几个符号选项:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="682f" class="lf ju hi lb b fi lg lh l li lj">(1) int list[5];<br/>(2) int list[] = {0, 0, 0, 0, 0};<br/>(3) int *list = {0, 0, 0, 0, 0};</span></pre><p id="e420" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有这些都可以用来“创建列表”。然而，它们有很大的不同。</p><ol class=""><li id="11d8" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated"><code class="du lk ll lm lb b">int list[5];</code> <br/>这个符号创建一个大小为五的整数列表。它将在堆栈上分配20个连续的字节。这是因为有五个整数，每个整数占用四个字节。它们将保留先前在这些位置的任何垃圾值。</li><li id="5e3a" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><code class="du lk ll lm lb b">int list[] = {0, 0, 0, 0, 0);</code> <br/>这使用一个初始化列表来创建数组。由于该列表被认为是详尽的，所以方括号中不需要大小。这将在堆栈上分配20个连续的字节，并用提供的整数填充它们。</li><li id="ca76" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated"><code class="du lk ll lm lb b">int *list;</code> <br/>这就是事物变化的地方；这一行不创建数组。但是，它创建了一个潜在数组的访问点。让我告诉你我的意思。</li></ol><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e1ff" class="lf ju hi lb b fi lg lh l li lj">int list[] = {1, 2, 3, 4, 5};<br/>int *pointer = list;</span></pre><p id="7a32" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，指针和列表是彼此的别名。要在堆栈上创建数组，需要使用方括号符号。然而，这只是告诉编译器分配空间；基本上，我们的变量<code class="du lk ll lm lb b">list</code>只是一个int指针。现在是时候引入更多的指针操作了。您可能熟悉许多语言的数组索引:<code class="du lk ll lm lb b">list[2] = 6;</code>；这个符号只是一种速记。以下三个模块都是等效的:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c1b3" class="lf ju hi lb b fi lg lh l li lj">int list[] = {5, 6, 7};</span></pre></div><div class="ab cl mr ms gp mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hb hc hd he hf"><pre class="la lb lc ld aw le bi"><span id="63e2" class="lf ju hi lb b fi my mz na nb nc lh l li lj">int list[3];</span><span id="7578" class="lf ju hi lb b fi lp lh l li lj">list[0] = 5;<br/>list[1] = 6;<br/>list[2] = 7;</span></pre></div><div class="ab cl mr ms gp mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hb hc hd he hf"><pre class="la lb lc ld aw le bi"><span id="b072" class="lf ju hi lb b fi my mz na nb nc lh l li lj">int list[3];</span><span id="38bb" class="lf ju hi lb b fi lp lh l li lj">*list = 5;<br/>*(list + 1) = 6;<br/>*(list + 2) = 7;</span></pre><p id="5d3f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">下标操作符</strong> <code class="du lk ll lm lb b"><strong class="ix hj">x[a]</strong></code> <strong class="ix hj">只是</strong> <code class="du lk ll lm lb b"><strong class="ix hj">*(x + a)</strong></code>的一个更简洁的符号。这是如何工作的？同样，指针的类型告诉C如何使用它。对于一个指向T类型的指针，当你给这个指针加1时，编译器获取指针的值(某个T的内存地址)并增加一个sizeof(T)。以int为例，加一等于加四。</p><p id="0b0e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个简单的方法是使用一个空指针。<code class="du lk ll lm lb b">void</code>在C语言中是一个奇怪的类型，意思是零或者什么都不是。如果一个函数不返回任何东西，它实际上会返回void。如果它不带参数，它实际上带void。在C #中，可以创建空指针。这些可能很无聊，但是可以做一些非常有用的事情。一个空指针可以访问一个数组的单个字节，绕过C前面提到的类型解码。让我们看看下面的例子，它也与前面的例子相同:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3a50" class="lf ju hi lb b fi lg lh l li lj">int arr[3];<br/>void *list = (void *)arr;</span><span id="6f63" class="lf ju hi lb b fi lp lh l li lj">*(int *)list = 5;<br/>*(int *)(list + 4) = 6;<br/>*(int *)(list + 8) = 7;</span></pre><p id="a698" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意强制转换的使用。您可以将指针强制转换为不同的类型，就像您可以强制转换任何其他变量一样。那么这段代码在做什么呢？让我们一行一行地来:</p><ol class=""><li id="b5fa" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated">这将创建一个名为“arr”的指针，指向12个顺序分配的内存字节。编译器期望这些字节包含三个整数。</li><li id="56d6" class="md me hi ix b iy mm jc mn jg mo jk mp jo mq js mi mj mk ml bi translated">我们创建一个指向void的指针，名为“list ”,并将其设置为等于第一个元素的内存地址，并将其转换为一个void内存地址。</li></ol><p id="8525" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面几行都写着“将这个地址的值，解释为一个int指针，设置为下面的整数”。但是请注意，我们必须手动添加四个或八个，因为list在这个上下文中是一个空指针。还要注意所涉及的<a class="ae iu" href="https://en.cppreference.com/w/c/language/operator_precedence" rel="noopener ugc nofollow" target="_blank">操作顺序</a>。以下是一些有用的操作顺序，其中<code class="du lk ll lm lb b">===</code>表示“相当于”:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f099" class="lf ju hi lb b fi lg lh l li lj">*list++; === *list; list += 1;<br/>*list--; === *list; list -= 1;</span><span id="96c9" class="lf ju hi lb b fi lp lh l li lj">*++list; === *(list += 1);<br/>*--list; === *(list -= 1);</span><span id="5137" class="lf ju hi lb b fi lp lh l li lj">++*list; === (*list) += 1;<br/>--*list; === (*list) -= 1;</span><span id="2a02" class="lf ju hi lb b fi lp lh l li lj">*(int *)list; === *((int *)list);<br/>(int *)*list; === (int *)(*list);</span><span id="3900" class="lf ju hi lb b fi lp lh l li lj">*list[x]; === *(list[x]);</span><span id="fc30" class="lf ju hi lb b fi lp lh l li lj">*list.x; === *(list.x);<br/>*list-&gt;x; === *(list-&gt;x);</span></pre><p id="0f46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，对于所有的左一元运算符，优先级是相同的，但是运算是从右向左执行的。对于右一元运算符，它们优先于左一元运算符，如<code class="du lk ll lm lb b">*</code>；然而，在后缀递增和递减的情况下，虽然首先执行该操作，但是那些操作首先返回值，然后递增/递减。所以是原始值被解引用。确保记住顺序，如果你不得不不时查看<a class="ae iu" href="https://en.cppreference.com/w/c/language/operator_precedence" rel="noopener ugc nofollow" target="_blank">备忘单</a>，也不要感到不舒服。</p><p id="b6f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这也是第一次引入箭头运算符。如果你熟悉结构和联合，你知道你可以使用下面的符号访问它们的成员(假设我们有一个预定义的<code class="du lk ll lm lb b">struct animal</code>):</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3c62" class="lf ju hi lb b fi lg lh l li lj">struct animal cat = // some initialization</span><span id="3139" class="lf ju hi lb b fi lp lh l li lj">cat.name = "Sarah";</span></pre><p id="3a21" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">箭头操作符是点操作符的指针版本。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="aee8" class="lf ju hi lb b fi lg lh l li lj">struct animal *pointer = &amp;cat;</span><span id="f1a0" class="lf ju hi lb b fi lp lh l li lj">cat.name = "Sarah"; // ||<br/>pointer-&gt;name = "Sarah";</span></pre><p id="c194" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这适用于获取和设置值。如果你理解指针如何指向一个值，这应该是非常直观的。写<code class="du lk ll lm lb b">pointer-&gt;x</code>相当于写<code class="du lk ll lm lb b">(*pointer).x</code>；然而，与下标操作符类似，它只是一种更简洁的符号。特别是因为点操作符比取消引用操作符具有更高的优先级，需要括号。</p><h2 id="e945" class="lf ju hi bd jv lq lr ls jz lt lu lv kd jg lw lx kh jk ly lz kl jo ma mb kp mc bi translated">用线串</h2><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/9c8040238fcdc1af3e9021a7aae8d89b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8DvRxi1bChjzWbqr"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@derekstory?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">德里克故事</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="33c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就像许多语言一样，字符串只是C语言中的字符数组。在C语言中，字符串有一个至关重要的方面你必须理解。首先，让我们展示一些创建字符串的等效方法:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ebaa" class="lf ju hi lb b fi lg lh l li lj">char str[] = {'H', 'i', '\0'};<br/>char *str = "Hi";</span><span id="18d3" class="lf ju hi lb b fi lp lh l li lj">char str[3];<br/>str[0] = 'H';<br/>str[1] = 'i';<br/>str[2] = '\0';</span></pre><p id="e94a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与其他语言类似，有一个双引号符号可以很容易地构造字符串。但是，您必须意识到C中的字符串必须以称为空字符的字符' \0 '结尾。<strong class="ix hj">C中的字符串以空终止</strong>。这是因为，与Java或Python等语言不同，C语言中的数组不跟踪自己的大小。为了在C中迭代一个数组，你要么需要单独跟踪大小，要么在数组的末尾有一个可识别的终端。从技术上讲，只要您自己跟踪大小，就不需要在字符串中包含空终端。但是，如果您打算在C中使用任何内置函数来处理您的字符串，它们必须以空字符结束，否则C将一直读取内存，直到遇到随机的空字符，或者出现故障。使用引号符号会自动添加一个空终端。请记住，这意味着您的字符串需要一个额外的字符大小。</p><h2 id="b4c0" class="lf ju hi bd jv lq lr ls jz lt lu lv kd jg lw lx kh jk ly lz kl jo ma mb kp mc bi translated">循环</h2><p id="7338" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">利用这些知识和我们之前讨论过的操作符，我们可以遍历数组。假设我们想自动创建一个包含100个整数的数组。我们可以按以下方式来做:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="30b5" class="lf ju hi lb b fi lg lh l li lj">const int size = 100;<br/>int numbers[size];</span><span id="3c65" class="lf ju hi lb b fi lp lh l li lj">for(int *p = numbers; p &lt; numbers + size; ++p) *p = 1;</span></pre><p id="3ab6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将创建一个100的数组。创建一个新的指针来修改通常是一个好主意。否则，您将修改指向数组开头的那个。循环中的条件可以是几样东西。您可以跟踪已经发生了多少次迭代，并简单地将其保持在大小以下。但是，由于我知道指针是如何工作的，所以我知道数组的最后一个元素在<code class="du lk ll lm lb b">numbers + size — 1</code>；回想一下，这相当于<code class="du lk ll lm lb b">numbers[size — 1]</code>。一旦我们的伪指针传递了那个值，我们就在数组之外了。然而，我们也可以使用下面的循环来代替:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9fd0" class="lf ju hi lb b fi lg lh l li lj">for(int i = 0; i &lt; size; ++i) numbers[i] = 1;</span></pre><p id="e4f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这应该看起来更熟悉，而且在大多数情况下，没有理由不使用这种符号。遍历一个字符串是同样执行的；但是，回想一下，字符串是以null结尾的。这是前一种符号真正闪耀的地方:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ed39" class="lf ju hi lb b fi lg lh l li lj">char *str = "Hello World!";<br/>for(char *p = str; *p != '\0'; ++p) printf("%c", *p);</span></pre><p id="56b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个循环只是一个字符一个字符地打印出字符串。我们知道一旦到达无效终端就应该停止。同样，我们也可以使用下面的循环:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b3a3" class="lf ju hi lb b fi lg lh l li lj">for(int i = 0; str[i] != '\0'; ++i) printf("%c", str[i]);</span></pre><p id="5fd5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，以这种方式构造的字符串是字符串文字，在c中是不可移植的。这意味着p和str应该真正属于<code class="du lk ll lm lb b">const char *</code>类型。如果修改它们，会导致未定义的行为。还要注意<code class="du lk ll lm lb b">printf</code>和<code class="du lk ll lm lb b">scanf</code>中的字符串与其他类型的行为不同。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="02fb" class="lf ju hi lb b fi lg lh l li lj">const char *str = "Hello World!";<br/>printf("%s", str);</span><span id="19b5" class="lf ju hi lb b fi lp lh l li lj">const char c = 'c';<br/>const char *letter = &amp;c;<br/>printf("%c", *letter);</span></pre><p id="4748" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当你使用<code class="du lk ll lm lb b">%s</code>时，C正在期待一个<code class="du lk ll lm lb b">char *</code>。然而，当你使用<code class="du lk ll lm lb b">%c</code>时，C正在期待一个<code class="du lk ll lm lb b">char</code>。这意味着在某些情况下，您需要取消引用，而在其他情况下，您不需要。记住，解引用一个字符串会给出该字符串中的第一个字符。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="79e1" class="lf ju hi lb b fi lg lh l li lj">char str[255];<br/>scanf(" %s", str);</span><span id="498d" class="lf ju hi lb b fi lp lh l li lj">int num;<br/>scanf(" %i", &amp;num);</span></pre><p id="de13" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，<code class="du lk ll lm lb b">scanf</code>使用一个内存地址来存放输入的值。这意味着，由于字符串已经是一个内存地址，您只需输入字符串名称；但是，对于其他类型，必须使用地址运算符。<strong class="ix hj">请注意，我在scanf的开头包含了一个空格，因为它将捕获所有空格或不捕获空格，这防止了需要刷新缓冲区的问题。</strong>还要注意，在c中数组不能调整大小。这意味着如果你将输入放入一个字符串，你必须提前分配足够的空间(称为缓冲区)。您只能通过创建新的数组来修改数组的大小，因为数组必须是顺序的，并且数组周围的内存被其他东西占用。</p><h1 id="f953" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">堆栈和堆内存</h1><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/1596b2d5fdf907552e302d57e413d1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j29rEXNYcl9rn1Xr"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">公共领域，<a class="ae iu" href="https://commons.wikimedia.org/w/index.php?curid=36294" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=36294</a></figcaption></figure><p id="1309" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我非常频繁地提到了堆栈。是时候讨论一下c中的内存类型了，首先，我来说说寄存器。CPU有寄存器，在计算进行的同时保存数据。这种记忆快得令人难以置信，但却少得令人难以置信。如果您经常使用某个值，您可以使用<code class="du lk ll lm lb b">register</code>关键字告诉C，它可以通过将该值放入寄存器来提高性能。请注意，编译器可能会也可能不会将其放入寄存器中。下面是一个寄存器变量的例子:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="24c4" class="lf ju hi lb b fi lg lh l li lj">// Sums up the elements of a list<br/>int sum_up(const int* list, const int size) <br/>{<br/>    register int sum = 0;</span><span id="d718" class="lf ju hi lb b fi lp lh l li lj">    for(const int* p = list; p &lt; list + size; ++p) sum += *p;</span><span id="0853" class="lf ju hi lb b fi lp lh l li lj">    return sum;<br/>}</span></pre><p id="8b61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里的<code class="du lk ll lm lb b">sum</code>的值是不断修改的，所以尝试使用一个寄存器可能是有意义的。寄存器可以快得令人难以置信；然而，由于它们不在主存中，寄存器变量没有内存地址。这意味着您不能创建指向它们的指针。</p><p id="8ba9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，到堆栈和堆上。如果你熟悉数据结构，你应该知道栈和堆的结构名。堆栈是一种后进先出(LIFO)的数据结构。想象主轴上有一叠CD。您只能通过将CD放在堆栈的顶部来将其添加到堆栈中。您只能取出顶部的CD。因此，您添加的最后一张CD必须是您移除的第一张CD。这就是堆栈的全部内容；一个奇特的列表，限制了如何添加和删除元素。运行程序时，程序会创建堆栈帧。假设您启动了主函数，然后调用了一个调用函数的函数。这些功能都有自己的记忆。当被调用时，函数有自己的堆栈框架和自己的内存。由于后进先出原理，这种记忆通常很快。它也很小，这使得查找存储在其中的变量更容易。</p><p id="9de6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，如果使用大数据，堆栈的有限大小是一个问题。不仅如此，一旦函数终止，它的堆栈框架关闭，内存被操作系统释放。堆是系统内存的主要部分。堆也是另一种数据结构；它是一种特殊类型的二叉树，满足几个要求:</p><ol class=""><li id="1e69" class="md me hi ix b iy iz jc jd jg mf jk mg jo mh js mi mj mk ml bi translated">在最小堆中，每个子堆必须小于等于其父堆。在max-heap中，每个子级必须大于或等于其父级。</li></ol><p id="7ee9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在堆内存中创建的变量会一直存在，直到被移除或程序关闭。为了在C中与堆内存交互，必须包含<code class="du lk ll lm lb b">stdlib.h</code>。在这个库中有四个有用的函数:<code class="du lk ll lm lb b">malloc</code>、<code class="du lk ll lm lb b">calloc</code>、<code class="du lk ll lm lb b">realloc</code>和<code class="du lk ll lm lb b">free</code>。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/dad59bdf159aa5cd944c8901177fa89d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h-1I40cra6mmPumY.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者:凯罗特——自己的作品，CC BY-SA 4.0，<a class="ae iu" href="https://commons.wikimedia.org/w/index.php?curid=99968794" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=99968794</a></figcaption></figure><p id="ab9e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在堆内存中创建的变量会一直存在，直到被移除或程序关闭。为了在C中与堆内存交互，必须包含<code class="du lk ll lm lb b">stdlib.h</code>。在这个库中有四个有用的函数:<code class="du lk ll lm lb b">malloc</code>、<code class="du lk ll lm lb b">calloc</code>、<code class="du lk ll lm lb b">realloc</code>和<code class="du lk ll lm lb b">free</code>。</p><h2 id="102b" class="lf ju hi bd jv lq lr ls jz lt lu lv kd jg lw lx kh jk ly lz kl jo ma mb kp mc bi translated"><code class="du lk ll lm lb b">mallo</code> c</h2><p id="bbe4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://www.tutorialspoint.com/c_standard_library/c_function_malloc.htm" rel="noopener ugc nofollow" target="_blank"> malloc </a>的声明为<code class="du lk ll lm lb b">void *malloc(size_t size)</code>。为了保持泛型，它返回一个空指针。<code class="du lk ll lm lb b">size_t</code>是一种类型，表示您正在使用的特定编译器支持的最大可能无符号整数类型。这只是用来允许最大可能的内存大小。</p><p id="dddd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">size是您希望在堆上按顺序分配的大小，以字节为单位。假设我们想在堆上创建一个整数数组。我们可以用下面的代码做到这一点:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="1881" class="lf ju hi lb b fi lg lh l li lj">int *list = (int *)malloc(sizeof(int) * 5);</span></pre><p id="c80f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将在堆上创建一个由五个int组成的数组。<code class="du lk ll lm lb b">sizeof</code>操作符简单地返回给定类型的字节大小。由于malloc返回一个void指针，我们必须将结果转换成一个int指针。从这里开始，我们可以像往常一样使用这个数组。除了，在最后，我们应该释放内存。</p><p id="3aa7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您的系统内存不足或者无法分配内存，malloc将返回NULL(即0)。原则上，在对一个指针做任何事情之前，你需要检查它是否为空。然而，这种情况很少发生。<code class="du lk ll lm lb b">malloc</code>是内存分配的缩写。</p><h2 id="fade" class="lf ju hi bd jv lq lr ls jz lt lu lv kd jg lw lx kh jk ly lz kl jo ma mb kp mc bi translated">自由的</h2><p id="bedf" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://www.tutorialspoint.com/c_standard_library/c_function_free.htm" rel="noopener ugc nofollow" target="_blank">自由</a>的宣言是<code class="du lk ll lm lb b">void free(void *ptr)</code>。它接受一个空指针(所以任何类型的指针)。请注意，在这种情况下，C将隐式地将任何指针转换为空指针。因此，我们可以通过简单地做以下事情来释放我们之前制作的列表:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="de96" class="lf ju hi lb b fi lg lh l li lj">free(list);</span></pre><p id="6f1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在一个简单的程序中，这是不必要的。但是，在较大的程序中释放内存是非常重要的；否则，可能会发生内存泄漏，并最终导致崩溃。如果您传入一个空指针—一个值为空的指针—什么也不会发生。如果你双倍释放内存或者释放堆栈上分配的内存，那会导致不确定的行为。</p><h2 id="b101" class="lf ju hi bd jv lq lr ls jz lt lu lv kd jg lw lx kh jk ly lz kl jo ma mb kp mc bi translated">卡洛克</h2><p id="8a60" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://www.tutorialspoint.com/c_standard_library/c_function_calloc.htm" rel="noopener ugc nofollow" target="_blank"> calloc </a>的声明为<code class="du lk ll lm lb b">void *calloc(size_t nitems, size_t size)</code>。这与malloc的行为类似，只是它将所有分配的值都设置为0，而malloc没有。这意味着malloc更快，但calloc对于某些安全目的是必不可少的，以防止敏感的垃圾值永久存在。无论如何，当您打算将值设置为0时，这也很有用。它的不同之处还在于它接受两个参数:项目的数量和每个项目的大小。</p><p id="908b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">calloc将再次返回一个必须强制转换的空指针，如果它不能分配内存，它将返回NULL。似乎calloc代表明确分配，尽管还没有达成共识。如果你想在堆上创建一个四个零的数组，这里有两种方法。首先，使用malloc:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="60ec" class="lf ju hi lb b fi lg lh l li lj">const unsigned int count = 1000;<br/>int *list = (int *)malloc(sizeof(int) * count);</span><span id="c5e2" class="lf ju hi lb b fi lp lh l li lj">for(unsigned int i = 0; i &lt; count; ++i) list[i] = 0;</span></pre><p id="a51d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用calloc:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="bbf9" class="lf ju hi lb b fi lg lh l li lj">const unsigned int count = 1000;<br/>int *list = (int *)calloc(count, sizeof(int));</span></pre><h2 id="a893" class="lf ju hi bd jv lq lr ls jz lt lu lv kd jg lw lx kh jk ly lz kl jo ma mb kp mc bi translated">realloc</h2><p id="ab6c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://www.tutorialspoint.com/c_standard_library/c_function_realloc.htm" rel="noopener ugc nofollow" target="_blank"> realloc </a>的声明是<code class="du lk ll lm lb b">void *(void *ptr, size_t size)</code>。这个函数试图调整现有数组的大小。如果<code class="du lk ll lm lb b">ptr</code>为空，那么这将与malloc的行为完全一样。如果<code class="du lk ll lm lb b">size</code>为0，并且<code class="du lk ll lm lb b">ptr</code>指向一个非空数组，那么它将会像free一样返回空值。如果请求失败，它将返回NULL。</p><p id="acb9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这主要是在分配后修改数组的大小。注意，在内部，它将简单地创建一个新数组并复制数据。如果增加数组，新元素将像malloc一样未初始化。如果缩小数组，数据将从末尾被剪切掉。很直观地，realloc代表重新分配。假设我们想在堆上创建并增长一个字符串。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e105" class="lf ju hi lb b fi lg lh l li lj">char *str = (char *)malloc(2);</span><span id="a5c7" class="lf ju hi lb b fi lp lh l li lj">str[0] = 'a';<br/>str[1] = '\0';</span><span id="f15c" class="lf ju hi lb b fi lp lh l li lj">printf("%s\n", str); // Results in "a"</span></pre><p id="84a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为一个字符的大小是一个字节，所以我可以简单地把字符数放在malloc中。然后，我可以根据自己的需要设置每个角色。现在，让我们将字符串扩展为“abc”。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="df23" class="lf ju hi lb b fi lg lh l li lj">str = (char *)realloc(str, 4);</span><span id="50e7" class="lf ju hi lb b fi lp lh l li lj">printf("%s\n", str); // Still results in "a", as our string is:<br/>                     // {'a', '\0', something, something}</span><span id="99ef" class="lf ju hi lb b fi lp lh l li lj">str[1] = 'b';<br/>str[2] = 'c';<br/>str[3] = '\0';</span><span id="04fd" class="lf ju hi lb b fi lp lh l li lj">printf("%s\n", str); // Prints out "abc"</span></pre><p id="2cfc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，我们也可以缩短字符串:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6df0" class="lf ju hi lb b fi lg lh l li lj">str = (char *)realloc(str, 3);</span><span id="d566" class="lf ju hi lb b fi lp lh l li lj">// Be sure to add a null terminal again<br/>str[2] = '\0';</span><span id="2470" class="lf ju hi lb b fi lp lh l li lj">printf("%s\n", str); // Prints out "abc"</span></pre><p id="e978" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们完成了，我们可以调用<code class="du lk ll lm lb b">free(str)</code>，或者潜在的<code class="du lk ll lm lb b">str = (char *)realloc(str, 0)</code>来清理我们的记忆。</p><h2 id="b96f" class="lf ju hi bd jv lq lr ls jz lt lu lv kd jg lw lx kh jk ly lz kl jo ma mb kp mc bi translated">堆内存和指针的必要使用</h2><p id="77f0" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果您想使用函数来修改存在于函数之外的数据(假设它不是全局数据),您有两种选择:要么从函数返回新值并对其赋值，要么通过指针传入值并修改它:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8478" class="lf ju hi lb b fi lg lh l li lj">int increment(int i) { return i + 1; }</span><span id="0919" class="lf ju hi lb b fi lp lh l li lj">...</span><span id="5caf" class="lf ju hi lb b fi lp lh l li lj">int i = 0; // stack integer<br/>int *j = (int *)calloc(1, 4); // heap integer</span><span id="7fcf" class="lf ju hi lb b fi lp lh l li lj">i = increment(i);<br/>*j = increment(*j);</span></pre><p id="03a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3546" class="lf ju hi lb b fi lg lh l li lj">void increment(int *i) { *i += 1; }</span><span id="3954" class="lf ju hi lb b fi lp lh l li lj">...</span><span id="b1c1" class="lf ju hi lb b fi lp lh l li lj">int i = 0; // stack integer<br/>int *j = (int *)calloc(1, 4); // heap integer</span><span id="ee5e" class="lf ju hi lb b fi lp lh l li lj">increment(j);<br/>increment(&amp;i);</span></pre><p id="d073" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于更大的数据，如字符串或结构，通常最好通过指针传递并直接修改它。您不希望复制所有的数据，对于堆中的某些数据，赋值可能会很困难。</p><p id="e834" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一种需要在堆上使用数据的情况。考虑以下处理堆栈指针的函数:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="396f" class="lf ju hi lb b fi lg lh l li lj">char *doubleString(const char *str, unsigned int size)<br/>{<br/>    const unsigned long doubleSize = size * 2 + 1;<br/>    char result[doubleSize];</span><span id="3641" class="lf ju hi lb b fi lp lh l li lj">    for(unsigned long i = 0; i &lt; doubleSize - 1; ++i) <br/>    { <br/>        result[i] = str[i % size];<br/>    }</span><span id="4e04" class="lf ju hi lb b fi lp lh l li lj">    result[doubleSize - 1] = '\0';</span><span id="3c3f" class="lf ju hi lb b fi lp lh l li lj">    return result;<br/>}</span></pre><p id="6ca2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这段代码不起作用，因为我们在堆栈上分配了结果字符串。一旦我们返回了指针，堆栈就被清空，所指向的内存地址也不再被分配。因此，如果我们想在函数中创建一个数组，并在函数结束后继续使用该数组，就必须使用堆:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c5f6" class="lf ju hi lb b fi lg lh l li lj">char *doubleString(const char *str, unsigned int size)<br/>{<br/>    const unsigned long doubleSize = size * 2 + 1;<br/>    char *result = (char *)malloc(doubleSize);</span><span id="54a4" class="lf ju hi lb b fi lp lh l li lj">    for(unsigned long i = 0; i &lt; doubleSize - 1; ++i) <br/>    { <br/>       result[i] = str[i % size];<br/>    }</span><span id="918c" class="lf ju hi lb b fi lp lh l li lj">    result[doubleSize - 1] = '\0';</span><span id="43c5" class="lf ju hi lb b fi lp lh l li lj">    return result;<br/>}</span></pre><p id="c4ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用完内存后，请务必再次释放内存！内存崩溃很难调试和诊断。我们最不需要的就是更多的软件由于内存泄漏而崩溃。我推荐使用<a class="ae iu" href="https://valgrind.org/" rel="noopener ugc nofollow" target="_blank"> Valgrind </a>来确保你生成的任何产品代码都不会泄漏内存。</p><h1 id="0c45" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="d2ec" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">你有它！指针并不太复杂，不是吗？对于C开发人员来说，它们是非常有用的——事实上是必不可少的——工具。指针对于在C语言中使用字符串、数组和堆内存是必需的，同时也为堆栈内存提供了实用工具。它们还可以提高效率，因为它们可以避免不必要地将数据复制到函数中或从函数中复制出来。如果你坚持练习，你最终会对指针以及如何使用它们进行迭代有一个直观的理解。祝你在C开发之旅中好运。</p><p id="f3e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你感兴趣，我正在创建一种叫做<a class="ae iu" href="https://github.com/DavidMacDonald11/Sea-Programming-Language" rel="noopener ugc nofollow" target="_blank"> Sea </a>的语言，它是C编程语言的变体，语法更类似于Python。我在记录我的过程，这样你甚至可以<a class="ae iu" href="https://davidjmacdonald.medium.com/list/how-to-create-a-programming-language-0ee2bcc7bccd" rel="noopener">创造你自己的语言</a>！</p><h2 id="e558" class="lf ju hi bd jv lq lr ls jz lt lu lv kd jg lw lx kh jk ly lz kl jo ma mb kp mc bi translated">额外收获:C++引用</h2><p id="c2c3" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">本文主要讨论的是C语言，它是C++的基础。C中的许多特性在C++中也能工作；但是，C++往往有更好的做事方法。例如，你可以在C++中使用malloc和free话虽如此，还是用<code class="du lk ll lm lb b">new</code>和<code class="du lk ll lm lb b">delete</code>比较好。如果你确实使用C风格的分配，一定要坚持。只对用new创建的对象调用delete，只对用malloc创建的对象调用free。</p><p id="ab23" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">C++有一个美丽的特性，叫做引用，非常类似于指针。引用是另一个变量的别名；更准确地说，引用被绑定到内存地址。因此，引用不能为空，也不能被重新分配。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9ac6" class="lf ju hi lb b fi lg lh l li lj">int i = 0;</span><span id="5893" class="lf ju hi lb b fi lp lh l li lj">int* iPoint = &amp;i; // Pointer to i<br/>int&amp; iRef = i; // Reference to i</span></pre><p id="b986" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">引用可以完全用作变量；它不需要被取消引用。引用如此重要有两个主要原因:它们比指针更容易使用，也更安全，因为它们不能为空。</p><p id="b71c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">引用的最佳用途之一是作为常量参数。以下两个代码块基本上是等效的:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2373" class="lf ju hi lb b fi lg lh l li lj">void func(const int* ptr);</span><span id="5c93" class="lf ju hi lb b fi lp lh l li lj">int i = 0;<br/>func(&amp;i);</span><span id="a838" class="lf ju hi lb b fi lp lh l li lj">void func(const int&amp; ref);</span><span id="afbf" class="lf ju hi lb b fi lp lh l li lj">int i = 0;<br/>func(i);</span></pre><p id="7fda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在C #中，取消引用也称为间接引用。这就好像你在使用一个指针的时候翻转了两次，就好像它是一个引用；你需要“翻转”一次来谈论地址，然后翻转回来谈论价值。</p><p id="1bc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过引用，您可以避免(或隐藏)间接性。在许多情况下，C++编译器只是用指针来定义引用，所以间接引用是隐藏的；这简化了语法。但是，引用可以独立定义，在这种情况下，它们可以避免间接引用，并且可以获得多种性能优势。因为你避免了间接操作，你也就避免了多重操作。由于引用不能为空，编译器不需要(你也不需要)检查它是否为空。如果您对更多优化感兴趣，请查看这个<a class="ae iu" href="https://stackoverflow.com/questions/6167285/may-a-reference-be-more-efficient-than-a-pointer" rel="noopener ugc nofollow" target="_blank">讨论</a>。</p></div></div>    
</body>
</html>