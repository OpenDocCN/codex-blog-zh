<html>
<head>
<title>MobX in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤动中的MobX</h1>
<blockquote>原文：<a href="https://medium.com/codex/mobx-in-flutter-51dbd984ace6?source=collection_archive---------2-----------------------#2022-08-25">https://medium.com/codex/mobx-in-flutter-51dbd984ace6?source=collection_archive---------2-----------------------#2022-08-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2f1d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">MobX的核心是三个重要的概念:可观察性、动作和反应。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/3579b8103bb14bc08f94095200eda18f.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*C4oFRHg8NVKebvJ241WvnQ.png"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jg jh di ji bf jj"><div class="er es jf"><img src="../Images/5614e293d56f72fb825f27371e3dcb93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fW1Fh7QDOfBFtZCY5i3vLA.png"/></div></div></figure></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h2 id="9c37" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">Dart语言的MobX。</h2><blockquote class="kp kq kr"><p id="89ec" class="ks kt ku kv b kw kx ij ky kz la im lb lc ld le lf lg lh li lj lk ll lm ln lo hb bi translated"><em class="hi">通过透明函数式反应式编程(TFRP)增强Dart应用的状态管理</em></p><p id="551c" class="ks kt ku kv b kw kx ij ky kz la im lb lc ld le lf lg lh li lj lk ll lm ln lo hb bi translated">MobX是一个状态管理库，它使应用程序的反应数据与UI的连接变得简单。这种布线是完全自动化的，感觉非常自然。作为应用程序开发人员，您只需关注UI(和其他地方)中需要使用哪些反应性数据，而不必担心保持两者同步。</p><p id="d309" class="ks kt ku kv b kw kx ij ky kz la im lb lc ld le lf lg lh li lj lk ll lm ln lo hb bi translated">这不是真正的魔术，但它确实有一些关于什么被消费(可观察)和哪里(反应)的智能，并自动为您跟踪它。当<em class="hi">观察值</em>改变时，所有<em class="hi">反应</em>重新运行。有趣的是，这些反应可以是任何事情，从简单的控制台日志、网络调用到重新呈现UI。</p><p id="6cf3" class="ks kt ku kv b kw kx ij ky kz la im lb lc ld le lf lg lh li lj lk ll lm ln lo hb bi translated">对于JavaScript应用程序来说，MobX是一个非常有效的库，这个Dart语言的移植旨在带来相同水平的生产力。</p></blockquote><h1 id="f111" class="lp js hi bd jt lq lr ls jx lt lu lv kb io lw ip kf ir lx is kj iu ly iv kn lz bi translated">核心概念</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jg jh di ji bf jj"><div class="er es ma"><img src="../Images/a4200b0beac8ae574190244619e3b42a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t35rHutdTskpsHqUdSC7cg.png"/></div></div></figure><blockquote class="kp kq kr"><p id="b457" class="ks kt ku kv b kw kx ij ky kz la im lb lc ld le lf lg lh li lj lk ll lm ln lo hb bi translated">在IDE中打开项目后，导航到您的<code class="du mb mc md me b">/pubspec.yaml</code>文件以添加依赖项。用以下代码片段替换<code class="du mb mc md me b">dependencies</code>部分:</p></blockquote><pre class="iy iz ja jb fd mf me mg mh aw mi bi"><span id="b4ea" class="jr js hi me b fi mj mk l ml mm">dependencies:<br/>  flutter:<br/>    sdk: flutter<br/>  mobx: ^0.3.5<br/>  flutter_mobx: ^0.3.0+1<br/>  shared_preferences: ^0.5.3+4</span></pre><blockquote class="kp kq kr"><p id="b649" class="ks kt ku kv b kw kx ij ky kz la im lb lc ld le lf lg lh li lj lk ll lm ln lo hb bi translated">然后用这段代码替换<code class="du mb mc md me b">dev_dependencies</code>部分:</p></blockquote><pre class="iy iz ja jb fd mf me mg mh aw mi bi"><span id="c99d" class="jr js hi me b fi mj mk l ml mm">dev_dependencies:<br/>  flutter_test:<br/>    sdk: flutter<br/>  build_runner: ^1.6.5<br/>  mobx_codegen: ^0.3.3+1</span></pre><blockquote class="kp kq kr"><p id="f172" class="ks kt ku kv b kw kx ij ky kz la im lb lc ld le lf lg lh li lj lk ll lm ln lo hb bi translated">现在，在项目的根目录下运行这个命令来下载依赖项:</p></blockquote><pre class="iy iz ja jb fd mf me mg mh aw mi bi"><span id="74e3" class="jr js hi me b fi mj mk l ml mm">$ flutter packages get</span></pre><h2 id="3f81" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">MobX的核心是三个重要的概念:可观察性、动作和反应。</h2><blockquote class="kp kq kr"><p id="12af" class="ks kt ku kv b kw kx ij ky kz la im lb lc ld le lf lg lh li lj lk ll lm ln lo hb bi translated">一个简单的反应式计数器由以下可观察值表示:</p></blockquote><pre class="iy iz ja jb fd mf me mg mh aw mi bi"><span id="03e3" class="jr js hi me b fi mj mk l ml mm"><strong class="me hj">import</strong> 'package:mobx/mobx.dart';</span><span id="3fdf" class="jr js hi me b fi mn mk l ml mm"><strong class="me hj">final</strong> counter = Observable(0);</span></pre><blockquote class="kp kq kr"><p id="7d4f" class="ks kt ku kv b kw kx ij ky kz la im lb lc ld le lf lg lh li lj lk ll lm ln lo hb bi translated">乍一看，这确实像是一些样板代码，很快就会失控！这就是为什么我们将<a class="ae mo" href="https://github.com/mobxjs/mobx.dart/tree/master/mobx_codegen" rel="noopener ugc nofollow" target="_blank"> mobx_codegen </a>添加到组合中，允许您用以下代码替换上面的代码:</p></blockquote><pre class="iy iz ja jb fd mf me mg mh aw mi bi"><span id="0b2c" class="jr js hi me b fi mj mk l ml mm"><strong class="me hj">import</strong> 'package:mobx/mobx.dart';</span><span id="6555" class="jr js hi me b fi mn mk l ml mm"><strong class="me hj">part</strong> 'counter.g.dart';</span><span id="8997" class="jr js hi me b fi mn mk l ml mm"><strong class="me hj">class</strong> <strong class="me hj">Counter</strong> = <strong class="me hj">CounterBase</strong> <strong class="me hj">with</strong> <strong class="me hj">_</strong>$<strong class="me hj">Counter</strong>;</span><span id="0ea1" class="jr js hi me b fi mn mk l ml mm"><strong class="me hj">abstract</strong> <strong class="me hj">class</strong> <strong class="me hj">CounterBase</strong> <strong class="me hj">with</strong> <strong class="me hj">Store</strong> {<br/>  <strong class="me hj">@observable</strong><br/>  int value = 0;</span><span id="ed2d" class="jr js hi me b fi mn mk l ml mm">  <strong class="me hj">@action</strong><br/>  <strong class="me hj">void</strong> increment() {<br/>    value++;<br/>  }<br/>}</span></pre><h1 id="2a61" class="lp js hi bd jt lq lr ls jx lt lu lv kb io lw ip kf ir lx is kj iu ly iv kn lz bi translated">计算可观测量</h1><blockquote class="kp kq kr"><p id="3110" class="ks kt ku kv b kw kx ij ky kz la im lb lc ld le lf lg lh li lj lk ll lm ln lo hb bi translated"><em class="hi">能衍生的，就应该衍生。自动地。</em></p></blockquote><p id="5cf4" class="pw-post-body-paragraph ks kt hi kv b kw kx ij ky kz la im lb kc ld le lf kg lh li lj kk ll lm ln lo hb bi translated">您的应用程序的状态由<em class="ku">核心状态</em>和<em class="ku">派生状态</em>组成。核心状态是你正在处理的领域所固有的状态。例如，如果您有一个<code class="du mb mc md me b">Contact</code>实体，<code class="du mb mc md me b">firstName</code>和<code class="du mb mc md me b">lastName</code>构成了<code class="du mb mc md me b">Contact</code>的<em class="ku">核心状态</em>。然而，<code class="du mb mc md me b">fullName</code>是<em class="ku">派生状态</em>，由<code class="du mb mc md me b">firstName</code>和<code class="du mb mc md me b">lastName</code>组合而成。</p><p id="2267" class="pw-post-body-paragraph ks kt hi kv b kw kx ij ky kz la im lb kc ld le lf kg lh li lj kk ll lm ln lo hb bi translated">这种<em class="ku">派生状态</em>，依赖于<em class="ku">核心状态</em>或<em class="ku">其他派生状态</em>被称为计算可观测。当它的潜在可观测量发生变化时，它会自动保持同步。</p><blockquote class="kp kq kr"><p id="52bc" class="ks kt ku kv b kw kx ij ky kz la im lb lc ld le lf lg lh li lj lk ll lm ln lo hb bi translated"><em class="hi">MobX中的状态=核心状态+派生状态</em></p></blockquote><pre class="iy iz ja jb fd mf me mg mh aw mi bi"><span id="4777" class="jr js hi me b fi mj mk l ml mm"><strong class="me hj">import</strong> 'package:mobx/mobx.dart';</span><span id="db60" class="jr js hi me b fi mn mk l ml mm"><strong class="me hj">part</strong> 'counter.g.dart';</span><span id="d1b6" class="jr js hi me b fi mn mk l ml mm"><strong class="me hj">class</strong> <strong class="me hj">Contact</strong> = <strong class="me hj">ContactBase</strong> <strong class="me hj">with</strong> <strong class="me hj">_</strong>$<strong class="me hj">Contact</strong>;</span><span id="7218" class="jr js hi me b fi mn mk l ml mm"><strong class="me hj">abstract</strong> <strong class="me hj">class</strong> <strong class="me hj">ContactBase</strong> <strong class="me hj">with</strong> <strong class="me hj">Store</strong> {<br/>  <strong class="me hj">@observable</strong><br/>  String firstName;</span><span id="1915" class="jr js hi me b fi mn mk l ml mm">  <strong class="me hj">@observable</strong><br/>  String lastName;</span><span id="022f" class="jr js hi me b fi mn mk l ml mm">  <strong class="me hj">@computed</strong><br/>  String <strong class="me hj">get</strong> fullName =&gt; '$firstName, $lastName';</span><span id="9c66" class="jr js hi me b fi mn mk l ml mm">}</span></pre><p id="efac" class="pw-post-body-paragraph ks kt hi kv b kw kx ij ky kz la im lb kc ld le lf kg lh li lj kk ll lm ln lo hb bi translated">在上例中，如果<code class="du mb mc md me b">firstName</code>和/或<code class="du mb mc md me b">lastName</code>发生变化，则<code class="du mb mc md me b">fullName</code>会自动保持同步。</p><h1 id="8041" class="lp js hi bd jt lq lr ls jx lt lu lv kb io lw ip kf ir lx is kj iu ly iv kn lz bi translated">观察者</h1><blockquote class="kp kq kr"><p id="857c" class="ks kt ku kv b kw kx ij ky kz la im lb lc ld le lf lg lh li lj lk ll lm ln lo hb bi translated">应用程序中最直观的反应之一是用户界面。Observer小部件(是<code class="du mb mc md me b"><a class="ae mo" href="https://github.com/mobxjs/mobx.dart/tree/master/flutter_mobx" rel="noopener ugc nofollow" target="_blank">flutter_mobx</a></code>包的一部分)提供了一个在<code class="du mb mc md me b">builder</code>函数中使用的可观察对象的粒度观察器。每当这些可观的变化，<code class="du mb mc md me b">Observer</code>重建和渲染。</p><p id="7641" class="ks kt ku kv b kw kx ij ky kz la im lb lc ld le lf lg lh li lj lk ll lm ln lo hb bi translated">下面是<em class="hi">计数器</em>的完整示例。</p></blockquote><pre class="iy iz ja jb fd mf me mg mh aw mi bi"><span id="a1f0" class="jr js hi me b fi mj mk l ml mm"><strong class="me hj">import</strong> 'package:flutter/material.dart';<br/><strong class="me hj">import</strong> 'package:flutter_mobx/flutter_mobx.dart';<br/><strong class="me hj">import</strong> 'package:mobx/mobx.dart';</span><span id="d746" class="jr js hi me b fi mn mk l ml mm"><strong class="me hj">part</strong> 'counter.g.dart';</span><span id="e11c" class="jr js hi me b fi mn mk l ml mm"><strong class="me hj">class</strong> <strong class="me hj">Counter</strong> = <strong class="me hj">CounterBase</strong> <strong class="me hj">with</strong> <strong class="me hj">_</strong>$<strong class="me hj">Counter</strong>;</span><span id="d47f" class="jr js hi me b fi mn mk l ml mm"><strong class="me hj">abstract</strong> <strong class="me hj">class</strong> <strong class="me hj">CounterBase</strong> <strong class="me hj">with</strong> <strong class="me hj">Store</strong> {<br/>  <strong class="me hj">@observable</strong><br/>  int value = 0;</span><span id="79cb" class="jr js hi me b fi mn mk l ml mm">  <strong class="me hj">@action</strong><br/>  <strong class="me hj">void</strong> increment() {<br/>    value++;<br/>  }<br/>}</span><span id="901c" class="jr js hi me b fi mn mk l ml mm"><strong class="me hj">class</strong> <strong class="me hj">CounterExample</strong> <strong class="me hj">extends</strong> <strong class="me hj">StatefulWidget</strong> {<br/>  <strong class="me hj">const</strong> CounterExample({Key key}) : <strong class="me hj">super</strong>(key: key);</span><span id="84f7" class="jr js hi me b fi mn mk l ml mm">  <strong class="me hj">@override</strong><br/>  _CounterExampleState createState() =&gt; _CounterExampleState();<br/>}</span><span id="939e" class="jr js hi me b fi mn mk l ml mm"><strong class="me hj">class</strong> <strong class="me hj">_CounterExampleState</strong> <strong class="me hj">extends</strong> <strong class="me hj">State</strong>&lt;<strong class="me hj">CounterExample</strong>&gt; {<br/>  <strong class="me hj">final</strong> _counter = Counter();</span><span id="e9ba" class="jr js hi me b fi mn mk l ml mm">  <strong class="me hj">@override</strong><br/>  Widget build(BuildContext context) =&gt; Scaffold(<br/>        appBar: AppBar(<br/>          title: <strong class="me hj">const</strong> Text('Counter'),<br/>        ),<br/>        body: Center(<br/>          child: Column(<br/>            mainAxisAlignment: MainAxisAlignment.center,<br/>            children: &lt;Widget&gt;[<br/>              <strong class="me hj">const</strong> Text(<br/>                'You have pushed the button this many times:',<br/>              ),<br/>              Observer(<br/>                  builder: (_) =&gt; Text(<br/>                        '${_counter.value}',<br/>                        style: <strong class="me hj">const</strong> TextStyle(fontSize: 20),<br/>                      )),<br/>            ],<br/>          ),<br/>        ),<br/>        floatingActionButton: FloatingActionButton(<br/>          onPressed: _counter.increment,<br/>          tooltip: 'Increment',<br/>          child: <strong class="me hj">const</strong> Icon(Icons.add),<br/>        ),<br/>      );<br/>}</span></pre><h1 id="e218" class="lp js hi bd jt lq lr ls jx lt lu lv kb io lw ip kf ir lx is kj iu ly iv kn lz bi translated">自动运行</h1><p id="976a" class="pw-post-body-paragraph ks kt hi kv b kw mp ij ky kz mq im lb kc mr le lf kg ms li lj kk mt lm ln lo hb bi translated">Autorun将在每次特定的可观察到的变化时运行。例如，如果我们想在每次计数器值改变时打印它，我们可以这样做:</p><pre class="iy iz ja jb fd mf me mg mh aw mi bi"><span id="92d6" class="jr js hi me b fi mj mk l ml mm">autorun((_) {<br/>  print(counter.value);<br/>});</span></pre><h1 id="761f" class="lp js hi bd jt lq lr ls jx lt lu lv kb io lw ip kf ir lx is kj iu ly iv kn lz bi translated">反应</h1><p id="8dbd" class="pw-post-body-paragraph ks kt hi kv b kw mp ij ky kz mq im lb kc mr le lf kg ms li lj kk mt lm ln lo hb bi translated">Reaction类似于autorun，但是它在跟踪可观察值时给了我们更多的控制。它接收两个参数:第一个是一个简单的函数，返回第二个参数中使用的数据。</p><p id="38af" class="pw-post-body-paragraph ks kt hi kv b kw kx ij ky kz la im lb kc ld le lf kg lh li lj kk ll lm ln lo hb bi translated">第二个参数是效果函数；这个效果函数只会对第一个函数参数中传递的数据做出反应。只有当您在第一个参数中传递的数据发生变化时，才会触发这个效果函数。</p><pre class="iy iz ja jb fd mf me mg mh aw mi bi"><span id="5b77" class="jr js hi me b fi mj mk l ml mm">reaction((_) {<br/>  return counter.value;<br/>}, (_) {<br/>  print('Counter changed to ${counter.value}');<br/>});</span></pre><h1 id="df6f" class="lp js hi bd jt lq lr ls jx lt lu lv kb io lw ip kf ir lx is kj iu ly iv kn lz bi translated">当...的时候</h1><p id="7f58" class="pw-post-body-paragraph ks kt hi kv b kw mp ij ky kz mq im lb kc mr le lf kg ms li lj kk mt lm ln lo hb bi translated">When与reaction非常相似，但更具体。这个函数只会对与第一个参数中传递的数据相匹配的数据做出反应。</p><pre class="iy iz ja jb fd mf me mg mh aw mi bi"><span id="7f8c" class="jr js hi me b fi mj mk l ml mm">when((_) {<br/>  return counter.value == 0;<br/>}, (_) {<br/>  print('Counter is zero');<br/>});</span></pre></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><h2 id="3ec9" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">在<a class="ae mo" href="https://pub.dev/packages/mobx" rel="noopener ugc nofollow" target="_blank"> MobX </a>中查看深层驱动</h2><h1 id="0244" class="lp js hi bd jt lq lr ls jx lt lu lv kb io lw ip kf ir lx is kj iu ly iv kn lz bi translated">源代码</h1><div class="mu mv ez fb mw mx"><a href="https://github.com/inamhusain/mobX_flutter.git" rel="noopener  ugc nofollow" target="_blank"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hj fi z dy nc ea eb nd ed ef hh bi translated">GitHub - inamhusain/mobX_flutter</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">一个新的颤振项目。这个项目是颤振应用的起点。一些帮助您入门的资源…</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">github.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl jd mx"/></div></div></a></div></div></div>    
</body>
</html>