<html>
<head>
<title>100 Doors Problem, a Simple Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">100扇门问题，一个简单的解决方案</h1>
<blockquote>原文：<a href="https://medium.com/codex/100-doors-problem-a-simple-solution-b2116f38e985?source=collection_archive---------14-----------------------#2022-06-19">https://medium.com/codex/100-doors-problem-a-simple-solution-b2116f38e985?source=collection_archive---------14-----------------------#2022-06-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b05d86df70a8b133daa7596ee4834976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-XLddeNC8PniiVVwCsReA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">简单的计数序列(照片由来自Pexels的玛格达·埃勒斯拍摄:<a class="ae iu" href="https://www.pexels.com/photo/number-cutout-decors-1329302/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/photo/number-cutout-decors-1329302/</a></figcaption></figure><h1 id="6b31" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">介绍</h1><p id="95b5" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">这个周末，我花时间磨练我的Python技能，并与罗宾·安德鲁斯在LinkedIn Learning 上开设了一门名为<a class="ae iu" href="https://www.linkedin.com/learning-login/share?forceAccount=false&amp;redirect=https%3A%2F%2Fwww.linkedin.com%2Flearning%2Falgorithmic-thinking-with-python-foundations%3Ftrk%3Dshare_ent_url%26shareId%3DZAopLAdcRTii1PFCKPcLSA%253D%253D" rel="noopener ugc nofollow" target="_blank">“Python算法思维:基础”的课程。我过去上过算法课程，但从来没有在老师讲解任何内容之前给我一个挑战去解决。幸运的是，他从一个简单的问题开始，100扇门的问题。</a></p><p id="70b9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我知道在我之前有无数人解决了这个问题，在我之后还会有无数人解决这个问题。我只是想分享我的经验，因为我在解决它和看到它揭示的模式后感到眩晕的喜悦，尽管它很简单。</p><h1 id="8cfd" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">100门问题是什么？</h1><p id="cb66" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们从一个有100扇门的走廊开始，所有的门在开始时都是关闭的。我们总共会在走廊上走过100次。在第一遍中，我们将打开每扇门，将其状态从关闭切换到打开。在第二遍中，我们将只切换每隔一个门的状态(即2、4、6……)。在第三遍中，我们将切换每第三个门的状态(即3、6、9……)。这将持续到第100次通过，此时只有第100扇门被触发。</p><p id="b81a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在所有这些之后，我们应该以一个非常具体的开门和关门的模式结束。</p><p id="1335" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">那么，哪些门将会打开呢？我向你挑战，在找到解决方案之前，尝试用任何你想要的方法来解决这个问题。如果你想出了一个不同的解决方案，或者对揭示的模式有所了解，请在评论中告诉我！</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><h1 id="8388" class="iv iw hi bd ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js bi translated">我是如何解决这个问题的</h1><p id="fe82" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">首先，让我们看看整个解决方案:</p><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="lm ln l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">百门问题的众多解决方案之一</figcaption></figure><p id="135d" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">因为我正在探索用Python实现算法，所以我从编程的角度，而不是从基于数学的角度来处理这个问题。希望很快我将开始能够通过数学的应用解决算法问题，但是现在，我开始考虑如何用代码表示<code class="du lo lp lq lr b">doors</code>的状态。</p><pre class="li lj lk ll fd ls lr lt lu aw lv bi"><span id="6bee" class="lw iw hi lr b fi lx ly l lz ma"># initial state of the doors<br/>num_doors = 100<br/>doors = [False] * num_doors</span></pre><p id="5fd6" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">幸运的是，教练给了我们一个起点，尽管我也会这么做。我们将用一个列表来表示我们的<code class="du lo lp lq lr b">doors</code>走廊，一个可变的布尔值序列来表示<code class="du lo lp lq lr b">doors</code>是打开还是关闭的(分别是<code class="du lo lp lq lr b">True</code>或<code class="du lo lp lq lr b">False</code>)。在这一点上，我暂停了视频，因为剩下的只是提示，我想尝试自己解决它。为了便于测试，我创建了<code class="du lo lp lq lr b">num_doors</code>变量，因为我们将在几个地方使用它。</p><p id="9f4b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">从那时起，我想知道第一次迭代会是什么样子。因为我知道我们将切换每一扇门，所以我使用了一个<code class="du lo lp lq lr b">for</code>循环来迭代这个序列。我很快意识到我需要用一个索引来跟踪我在哪扇门上，这就是我使用Python提供的<code class="du lo lp lq lr b">range()</code>函数的原因。我尝试使用Python的<code class="du lo lp lq lr b">enumerate()</code>函数，但是决定在这种情况下不需要将元素的索引和值分开。</p><pre class="li lj lk ll fd ls lr lt lu aw lv bi"><span id="6239" class="lw iw hi lr b fi lx ly l lz ma"># first pass over doors<br/>for i in range(0, num_doors):<br/>doors[i] = not doors[i]</span></pre><p id="f134" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这给我留下了一个<code class="du lo lp lq lr b">True</code>值的列表，我花了几分钟试图弄清楚第二次、第三次、第四次等等迭代会是什么样子。很明显，使用嵌套的<code class="du lo lp lq lr b">for</code>循环对于完成这个算法是必要的，因为我需要对所有的门迭代100次，同时跟踪我正在进行的迭代。</p><pre class="li lj lk ll fd ls lr lt lu aw lv bi"><span id="99d1" class="lw iw hi lr b fi lx ly l lz ma"># the algorithm I used<br/>for i in range(0, num_doors);<br/>    for j in range(i, num_doors, i+1):<br/>        doors[j] = not doors[j]</span></pre><p id="f6a0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">基本上，外部循环在门列表上迭代100次，范围从0到100。提醒一下，Python <code class="du lo lp lq lr b">range()</code>函数排除了范围的上限，默认情况下所有列表都是零索引的。</p><p id="e3cb" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这个外部循环和之前写的是一样的。</p><p id="ec73" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">内部循环是算法有趣的部分。这里，被切换的元素是通过改变for循环将使用的范围来决定的。在每次迭代中，起始点等于外部循环的索引，以模拟“每第n个”门条件。</p><p id="1acd" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">例如，在迭代3中，起始索引是2，因为列表是零索引的。这类似于从第三扇门开始。</p><p id="3936" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">接下来，在这个算法中，循环的终点总是列表的末尾。</p><p id="f0c2" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">最后，使该算法工作的部分是内部循环的步骤，因为这完成了每次迭代的“每第n次”条件的实现。</p><p id="14cd" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果我们在迭代3中，从第三个门开始，我们必须继续通过<em class="mb">每隔第三个门切换一次。</em>这通过将步骤设置为<code class="du lo lp lq lr b">i+1</code>来完成。我们必须使用<code class="du lo lp lq lr b">i+1</code>的原因是因为列表是零索引的，但是我们的基本步骤是1。</p><p id="1a05" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">可以这样想:如果我们的步长直接等于<code class="du lo lp lq lr b">i</code>，那么我们如何在迭代0上步进0次呢？我们至少需要步进1次才能使循环工作，因此我们给<code class="du lo lp lq lr b">i</code>加1来解决这个问题。</p><p id="a09a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">最后，我们简单地用<code class="du lo lp lq lr b">doors[j] = not doors[j]</code>为新范围中的每个元素切换每个门，以产生答案。这是Python翻转位的语法，不同的编程语言会有所不同。</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><h1 id="9ce8" class="iv iw hi bd ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js bi translated">解决方案</h1><figure class="li lj lk ll fd ij"><div class="bz dy l di"><div class="mc ln l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">来自<a class="ae iu" href="https://compucademy.net/100Doors/" rel="noopener ugc nofollow" target="_blank">https://compucademy.net/100Doors/</a>的100门算法可视化</figcaption></figure><p id="1960" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果您已经自己解决了这个问题，或者运行了上面链接的要点中的代码，您可能已经有了解决方案。因为我想要一种简单的方法来查看发生了什么，所以我利用Python内置的字符串格式来查看<code class="du lo lp lq lr b">doors</code>列表的最终状态。</p><pre class="li lj lk ll fd ls lr lt lu aw lv bi"><span id="7399" class="lw iw hi lr b fi lx ly l lz ma"># quick printout of open doors<br/>print("\nFinal State of doors:\n")<br/>for index,door in enumerate(doors):<br/>    if door: # evaluates door as a Boolean value<br/>        print(f'{index+1}: Open; Square: {int(sqrt(index+1))}')</span></pre><p id="66a4" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">好吧，不仅仅是看看哪些门被打开了。为了给我的门编号，我很好地利用了Python内置的<code class="du lo lp lq lr b">enumerate()</code>函数。然后，我简单地检查每个门，看它是否打开(<code class="du lo lp lq lr b">True</code>)，并打印出门的编号(偏移1，以便人们可以阅读)、状态和人们可以阅读的门编号的平方根。</p><p id="b564" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在我深入解释为什么我包括了那个门号的平方根之前，让我说这就是解决方案。对于100个门，以下门将打开:</p><pre class="li lj lk ll fd ls lr lt lu aw lv bi"><span id="96ee" class="lw iw hi lr b fi lx ly l lz ma">1: Open; Square: 1<br/>4: Open; Square: 2<br/>9: Open; Square: 3<br/>16: Open; Square: 4<br/>25: Open; Square: 5<br/>36: Open; Square: 6<br/>49: Open; Square: 7<br/>64: Open; Square: 8<br/>81: Open; Square: 9<br/>100: Open; Square: 10</span></pre><p id="9d65" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果您手动解决这个问题(我不建议这样做)，您将在第100次通过后发现这个配置。</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><h1 id="da61" class="iv iw hi bd ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js bi translated">一种模式显露出来？</h1><p id="6f46" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">如果你像我一样，你可能会看着仍然开着的门的号码，看到一个模式:这是一个从1到100的完美方块的列表，包括1和100。为了证实这一点，我找到了每个门牌号的平方根，它显示在我上面的快速打印输出中。</p><p id="b8b9" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我在网上做了相当多的搜索，看看是否有人对为什么会出现这种情况进行了适当的数学分析。相反，我主要找到了“优化的”代码，它通过简单地打开{1…10}的完美正方形的门，一次性解决了这个问题。</p><p id="f74e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我不能做一个真正的数学分析，因为我不知道怎么做(还不知道)，但我怀疑以下对任何数量的门都是正确的。</p><ul class=""><li id="1a40" class="md me hi jv b jw kr ka ks ke mf ki mg km mh kq mi mj mk ml bi translated">这个问题的解集将是<code class="du lo lp lq lr b">{1,4,9,...,n}</code>，其中<code class="du lo lp lq lr b">n</code>是门的数量。如果<code class="du lo lp lq lr b">n</code>不是一个完美的正方形，最高的门号将是集合中最高的完美正方形。</li><li id="fd78" class="md me hi jv b jw mm ka mn ke mo ki mp km mq kq mi mj mk ml bi translated">给定<code class="du lo lp lq lr b">n</code>扇门，<code class="du lo lp lq lr b">1</code>和<code class="du lo lp lq lr b">n</code>之间的完美正方形的数量等于<code class="du lo lp lq lr b">nth</code>迭代后打开的门的数量。</li><li id="b1ad" class="md me hi jv b jw mm ka mn ke mo ki mp km mq kq mi mj mk ml bi translated">给定<code class="du lo lp lq lr b">n</code>个门，打开的门的数量将是集合<code class="du lo lp lq lr b">{1...floor(√n)}</code>的平方，其中<code class="du lo lp lq lr b">floor()</code>是一个函数，如果<code class="du lo lp lq lr b">n</code>不是一个完美的平方，则向下舍入到最接近的整数。</li></ul><p id="4c53" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">例如,“10扇门”显示门1、4和9保持打开，因为它们是集合中唯一的完美正方形。</p><p id="6d1f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">对于100个门，打开的门是1、4、9、16、25、36、49、64、81和100。我们可以预测会有10扇门打开，因为<code class="du lo lp lq lr b">√100 = 10</code>。</p><p id="bc71" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">那么，对于一万扇门，会打开多少扇门呢？嗯，<code class="du lo lp lq lr b">√10,000 = 100</code>。</p><p id="bed3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这种模式成立，尽管像42，501门这样更复杂的数字可能会产生我作为一个人无法用脑子算出来的结果。我知道肯定有一个公式可以简洁地解决这个问题，但正如我所说的，我目前缺乏创建这个公式所必需的分析技能。</p></div><div class="ab cl kw kx gp ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hb hc hd he hf"><h1 id="a729" class="iv iw hi bd ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js bi translated">后续步骤</h1><p id="667c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">为了最大限度地利用这种解决方案，并考虑其实际应用，最明显的下一步是优化算法。虽然一个嵌套的for循环对于一小组数据来说没那么糟糕，但是它的时间复杂度是O(n)，如果一个集合中有1，000，000个元素，这当然是可怕的。基本上，如果我们有1，000，000个门，我们最坏的情况会涉及<em class="mb">万亿</em>次迭代。对于翻转一万亿次来说，没那么糟糕，但是当你在内部循环中添加任何更复杂的操作时，速度就会变慢。</p><p id="f956" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我可以想象，在这里，优化是从适当的数学分析开始的。我想，如果给我时间，我可能可以通过编程来优化它，但如果我不太理解底层公式的约束，这将是一个较慢的过程。</p><p id="f569" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">希望第二部分能够带来优化的运行时间和对这个解决方案的数学基础的透彻理解。</p><h1 id="6737" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">这有什么意义？</h1><p id="ada6" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">从中最重要的发现是，我在研究这个问题时获得了很多乐趣。总的来说，我在大约十分钟内解决了这个问题，然后花了两个小时试图找到一个好的数学分析模式，并写了这篇文章。</p><p id="9537" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">不得不承认，我其实还没想过这个算法的实际应用。这有望出现在第二部分！</p><p id="24df" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我希望你和我一样觉得这个练习很有趣！如果你有不同的解决方法，或者知道如何对这个问题进行复杂的数学分析，请在评论中告诉我！</p></div></div>    
</body>
</html>