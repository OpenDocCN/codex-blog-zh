<html>
<head>
<title>Monitor PostgreSQL Performance Using a Database Health Dashboard</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用数据库健康仪表板监控PostgreSQL性能</h1>
<blockquote>原文：<a href="https://medium.com/codex/monitor-postgresql-performance-using-a-database-health-dashboard-71123ec52da5?source=collection_archive---------14-----------------------#2021-06-18">https://medium.com/codex/monitor-postgresql-performance-using-a-database-health-dashboard-71123ec52da5?source=collection_archive---------14-----------------------#2021-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9945005211e3a859cca5d9f537c95aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Tx7n1F_gASHjDWLpzhBSQ.jpeg"/></div></div></figure><h1 id="4981" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">为什么要监控PostgreSQL数据库的健康状况？</h1><p id="8204" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">就像监控我们的应用程序一样，监控我们的数据库系统是非常必要的。我们希望监控比系统级流程更精细的事情，例如:</p><ul class=""><li id="bd9f" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated">有多少查询实际上使用了索引？</li><li id="63bc" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">数据库缓存的效率如何？</li><li id="70dc" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">打开的连接数。</li></ul><p id="2730" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">诸如此类。</p><p id="7e69" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">硬件指标是必不可少的，但只能让我们到此为止，并不能帮助我们做出具体的决策——比如优化哪些查询，以及我们一般如何使用我们的数据库。由于PostgreSQL是一个开源数据库，它免费提供了许多见解，而不必依赖昂贵的工具。我们将要跟踪的大多数指标都是默认可用的，因为它们是<a class="ae lf" href="https://arctype.com/blog/postgresql-query-plan-anatomy/" rel="noopener ugc nofollow" target="_blank">查询计划器</a>所必需的，但是对于其他关键领域，我们必须启用PostgreSQL附带的某些扩展/contrib模块。</p><h1 id="4ac5" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Arctype工具简介</h1><p id="26a5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Arctype 是一个非常简洁的数据库工具，不仅可以用作SQL编辑器，还可以作为一个平台，在这个平台上可以定制复杂的仪表板，并与开发人员/用户共享。为了理解它的真正威力，我们将考虑一个实际的用例——监控PostgreSQL数据库的健康状况。</p><h1 id="5eca" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Arctype仪表盘入门</h1><p id="2424" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了熟悉仪表板功能，我们将构建一个非常简单的仪表板，仅包含三个组件。Arctype仪表盘内置于Arctype工具本身。要访问该功能，只需点击如下所示的<code class="du lg lh li lj b">Dashboards</code>按钮。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/73c500c7c41abd164578898d37b9d9b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iOqKQVUNpwEFplL8.png"/></div></div></figure><p id="e2f7" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">单击加号图标，创建一个名为— <code class="du lg lh li lj b">Postgres Health Monitoring</code>的仪表板。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/8ee7b4c37805b04e0b5674c5d6253aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/0*pnNb9fbPgLZcrsHU.png"/></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/64678804633af6bfe914f02c6d29a92d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/0*yR0egRnTbndvo8ab.png"/></div></figure><p id="640d" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">现在已经创建了仪表板，让我们创建一些组件。</p><h1 id="ecc7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">从Information_Schema创建PostgreSQL表列表</h1><p id="f1c4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">添加表格组件/图表组件在我们之前的文章<a class="ae lf" href="https://arctype.com/blog/analytics-dashboard-django/#creating-a-dashboard-for-your-database" rel="noopener ugc nofollow" target="_blank">中有所涉及。将<code class="du lg lh li lj b">Table</code>拖放到空的仪表板窗格中。接下来，我们将使用一个简单的查询，该查询与底层数据库(PostgreSQL)对话，并获取所有表及其模式，不包括<code class="du lg lh li lj b">information_schema</code>和系统表。</a></p><pre class="ll lm ln lo fd lr lj ls lt aw lu bi"><span id="3353" class="lv ir hi lj b fi lw lx l ly lz">SELECT<br/>  table_schema, table_name<br/>FROM<br/>  information_schema.tables<br/>WHERE<br/>  table_schema &lt;&gt; 'information_schema'<br/>  AND table_name NOT LIKE 'pg_%'<br/>ORDER BY<br/>  table_schema,<br/>  table_name;</span></pre><h1 id="ac7f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">可视化数据库模式中表的行数</h1><p id="904d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们在使用以下查询的表组件旁边添加一个图表组件(类似于表):</p><pre class="ll lm ln lo fd lr lj ls lt aw lu bi"><span id="c8ea" class="lv ir hi lj b fi lw lx l ly lz">SELECT<br/>  relname as table_name,<br/>  reltuples as rows<br/>FROM<br/>  pg_class C<br/>  LEFT JOIN pg_namespace N ON (N.oid = C .relnamespace)<br/>WHERE<br/>  nspname NOT IN ('pg_catalog', 'information_schema')<br/>  AND relkind = 'r'<br/>ORDER BY<br/>  reltuples DESC;</span></pre><p id="8426" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这个查询只是对数据库中所有表的记录进行计数。在右窗格中，为X轴选择<code class="du lg lh li lj b">table_name</code>，为Y轴选择<code class="du lg lh li lj b">rows</code>。</p><h1 id="dfb2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">向Arctype仪表盘添加图像</h1><p id="a35c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">添加完表格和图表后，让我们从<a class="ae lf" href="https://www.postgresql.org/media/img/about/press/elephant.png" rel="noopener ugc nofollow" target="_blank"> PostgreSQL网站</a>添加一张图片到我们的仪表板上，同时添加一个文本字段进行解释。添加完上述所有步骤后，我们的仪表板将如下所示:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/c24fa53b7ae610d5c2b92ae96fb1b716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uCChhPJfn92AxTBe.png"/></div></div></figure><p id="6e55" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">至此，您应该对仪表板有了相当好的感觉，所以现在，让我们构建一个真正的健康仪表板，看看它如何帮助我们可视化我们的数据库健康状况。</p><h1 id="eb21" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">识别PostgreSQL数据库中的关键区域</h1><p id="24ba" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了了解数据库的健康状况，PostgreSQL有许多我们可以关注的领域。在下面的章节中，我们将会看到其中的一小部分，并演示如何使用Arctype来可视化它们。</p><h1 id="4dfc" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">查询以检查PostgreSQL开放连接</h1><p id="d57e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">监视数据库集群中当前有多少个打开的连接总是一个好主意。我们可以从<code class="du lg lh li lj b">pg_stat_activity</code>表中得到这一点:</p><pre class="ll lm ln lo fd lr lj ls lt aw lu bi"><span id="6f5e" class="lv ir hi lj b fi lw lx l ly lz">SELECT<br/>  COUNT(*) as connections,<br/>  backend_type<br/>FROM<br/>  pg_stat_activity<br/>GROUP BY<br/>  backend_type<br/>ORDER BY<br/>  connections DESC</span></pre><h1 id="d677" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">确定PostgreSQL数据库的大小</h1><p id="ede4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">随着数据库的不断扩展，控制数据库的大小是非常重要的。我们可以使用下面的查询获得数据库列表及其各自的大小:</p><pre class="ll lm ln lo fd lr lj ls lt aw lu bi"><span id="f941" class="lv ir hi lj b fi lw lx l ly lz">SELECT<br/>  datname as database_name,<br/>  pg_database_size(datname)/1024/1024 as size<br/>FROM<br/>  pg_database<br/>WHERE<br/>  datistemplate = false;</span></pre><p id="ea8b" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">我们可以使用<code class="du lg lh li lj b">pg_size_pretty</code>来代替直接计算MB，但是我们想把它绘制成一个条形图来查看和比较大小。记录单个数据库的大小有助于我们了解全局。</p><p id="282a" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">注意:这些大小可能与磁盘大小不同，因为PostgreSQL在后台进行了大量压缩。</p><h1 id="0d7b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">在PostgreSQL中计算数据库缓存命中率</h1><p id="312f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">任何关系数据库/操作数据库都从其缓存中提供大部分流量。如果这种情况没有发生，我们肯定需要调查一下。PostgreSQL缓存区域被称为<code class="du lg lh li lj b"><a class="ae lf" href="https://www.postgresql.org/docs/current/runtime-config-resource.html" rel="noopener ugc nofollow" target="_blank">shared_buffers</a></code>，它在操作系统提供的缓存之上充当数据库层缓存。我们可以使用下面的查询来了解缓存命中率:</p><pre class="ll lm ln lo fd lr lj ls lt aw lu bi"><span id="abe6" class="lv ir hi lj b fi lw lx l ly lz">SELECT<br/>  sum(heap_blks_read) as reads,<br/>  sum(heap_blks_hit) as hits,<br/>  ROUND(<br/>    sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)),<br/>    4<br/>  ) as hit_ratio<br/>FROM<br/>  pg_statio_user_tables;</span></pre><p id="fb51" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">在<a class="ae lf" href="https://arctype.com/blog/postgresql-query-plan-anatomy/#what-are-buffers-and-caches-in-a-database" rel="noopener ugc nofollow" target="_blank">查询计划博客</a>中，有几个元组来自堆读取和堆命中。<code class="du lg lh li lj b">pg_statio_user_tables</code>有这方面的信息。在上面的查询中，我们只是获得命中和读取的值(来自磁盘)并计算四舍五入到四位数的比率。值得注意的是，在一个健康的生产数据库中，这一比率应该达到97%或接近97 %, 97%的命中来自缓存。</p><h1 id="8f60" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">扫描未使用的索引</h1><p id="406c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">PostgreSQL中的统计信息收集器记录了哪些索引被访问的频率。我们可以从一个叫做<code class="du lg lh li lj b">pg_stat_all_indexes</code>的统计表中构造一个查询。</p><pre class="ll lm ln lo fd lr lj ls lt aw lu bi"><span id="4555" class="lv ir hi lj b fi lw lx l ly lz">SELECT<br/>  COUNT(*) as count,<br/>  relname as table_name<br/>FROM<br/>  pg_stat_all_indexes<br/>WHERE<br/>  idx_scan = 0<br/>  and schemaname = 'public'<br/>GROUP BY<br/>  table_name</span></pre><p id="40cf" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这给了我们一个具有最大数量未使用索引的表的指示。<code class="du lg lh li lj b">idx_scan=0</code>给了我们从未使用过的索引。我们可以根据数据库流量模式定制这个值。</p><h1 id="fdf9" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">检查PostgreSQL数据库缓存</h1><p id="cd3b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了从缓存中获得更多信息，我们需要启用另一个名为<code class="du lg lh li lj b"><a class="ae lf" href="https://www.postgresql.org/docs/current/pgbuffercache.html" rel="noopener ugc nofollow" target="_blank">pg_buffercache</a></code>的contrib模块。启用它并运行一些查询后，我们现在可以检查缓存:</p><pre class="ll lm ln lo fd lr lj ls lt aw lu bi"><span id="8eb4" class="lv ir hi lj b fi lw lx l ly lz">SELECT<br/>  c .relname AS entity_name,<br/>  count(*) AS buffers<br/>FROM<br/>  pg_buffercache b<br/>  INNER JOIN pg_class c ON b.relfilenode = pg_relation_filenode(c .oid)<br/>  AND b.reldatabase IN (<br/>    0,<br/>    (<br/>      SELECT<br/>        oid<br/>      FROM<br/>        pg_database<br/>      WHERE<br/>        datname = current_database()<br/>    )<br/>  )<br/>WHERE<br/>  c .relname NOT LIKE 'pg_%'<br/>GROUP BY<br/>  c .relname<br/>ORDER BY<br/>  2 DESC;</span></pre><p id="17be" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这个查询取自<a class="ae lf" href="https://www.postgresql.org/docs/current/pgbuffercache.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>，然后稍加修改。它显示了<code class="du lg lh li lj b">shared_buffers</code>中有多少页面被不同的表和索引占用。您可以假设页面是与行数成正比的指标——被查询的表越大，移动到缓存中的页面就越多。这也意味着可以将一些表移动到应用程序缓存或快速键值存储(如Redis)中，以便进行更快的查询，并为索引释放数据库缓存。</p><h1 id="898b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">监控平均Postgres查询性能</h1><p id="66f1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对于这一部分，我们需要启用<code class="du lg lh li lj b"><a class="ae lf" href="https://www.postgresql.org/docs/current/pgstatstatements.html" rel="noopener ugc nofollow" target="_blank">pg_stat_statements</a></code>扩展。它是一个内置的扩展/贡献模块，在一些云提供商中，它是默认启用的。如果没有，可以使用<code class="du lg lh li lj b">shared_preload_libraries</code>轻松启用。这个扩展帮助我们捕获大量关于查询性能的信息。使用这个扩展，我们将构建一个查询，根据查询扫描的行数输出查询性能:</p><pre class="ll lm ln lo fd lr lj ls lt aw lu bi"><span id="7674" class="lv ir hi lj b fi lw lx l ly lz">SELECT<br/>  mean_time as "timing in ms",<br/>  rows<br/>FROM<br/>  pg_stat_statements<br/>ORDER BY<br/>  mean_time DESC<br/>LIMIT<br/>  100;</span></pre><p id="036f" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">限制行数并执行<code class="du lg lh li lj b">order by</code>会给出前100个消耗最多的查询，而<code class="du lg lh li lj b">rows</code>列表示语句检索或影响的<em class="mb">总行数。我们还可以使用上表通过运行时间获得前10个最差的查询。这可以作为慢速日志分析的替代方法，因为它更加实时。</em></p><h1 id="eb59" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">使用PostgreSQL指标构建仪表板</h1><p id="5d68" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果我们将提到的图表类型中的所有查询结合起来，它应该看起来像一个可以轻松可视化/消费的适当的分析仪表板:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/d6ebac17a31e6e2dbbfafc5b3e774510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bvFU_g9bupD9wyk4.png"/></div></div></figure><p id="e081" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">下表显示了每个组件的映射。Arctype并不局限于下面的图表，它有一个功能极其丰富的平台，我们可以在这个平台上展示我们的可视化。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/7bd95245052030a56c1e0574d6e1ae9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7uHqrwhFhE9RsqvDbtDclg.png"/></div></div></figure><p id="fac9" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这里的每个小部件都有自己的描述，图表中有X轴和Y轴上的详细信息。仪表盘不言自明很重要，毕竟一图胜千言。根据基础数据的不同，这些图表可能看起来有所不同。在编辑模式下，只需拖动它们的边框就可以放大和缩小它们，如果数据集较大，这将非常有用，因为图表可能会溢出。</p><p id="1473" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">上面的仪表板是在我以前使用的示例数据库中创建的。让我们在一个更真实的数据库上创建仪表板，比如Arctype内置的<code class="du lg lh li lj b">Covid DB</code>(在注册流程中可用)。由于数据集很大，我创建了两个部分的仪表板:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/7366562dea7f1542b3454d72f69b9ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZlW8W9nLQxR__NkL.png"/></div></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/3d886d0f6d7c83612f76ee7dc892b666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YtGfipqz73YuXWlr.png"/></div></div></figure><p id="f0da" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">随着数据点越来越多，仪表盘看起来更加丰富，也更有意义。我们的目标不是成为一个“银弹”解决方案，而是提供一些关于运营数据库的潜在关注领域的观点。有很多工具可以提供不同的功能，但最终，我相信数据库开发人员应该更深入地了解他们的数据库。有什么工具能让我们轻松地将查询转换成非常好的图表，而且几乎不需要额外的学习呢？回答:大概不多。</p><h1 id="94d7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">来自健康仪表板的见解和情报</h1><p id="134a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这个仪表板允许我们实时监控数据库，并帮助我们更全面地了解PostgreSQL独有的一些特性。在进行数据库优化时，通常的规则是“您不能改进您不能度量的东西”，这个仪表板解决了第一步(但经常被忽略)，这实际上是度量东西。<code class="du lg lh li lj b">Covid DB</code>演示数据库具有99%的缓存命中率，这意味着几乎所有的流量都由缓存(shared_buffers)提供服务，并且响应速度非常快。这是数据库优化良好的一个好迹象。</p><p id="30d8" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">在交通高峰期监控我们的数据库将使我们深入了解哪些方面可以改进，以及如何衡量这种改进。我们可以根据这些指标提高数据库性能的一些方法有:</p><ul class=""><li id="e278" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated">使用客户端/服务器端连接池。</li><li id="9bd7" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">代码优化，以便在工作完成后将连接释放回池/关闭连接。</li><li id="80cc" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">进行适当的数据库建模，并在不同的集群之间划分流量。</li><li id="bd07" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">增加共享缓冲区的大小，以便在内存中容纳更多的数据/索引。</li><li id="91bc" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">通过添加索引或完全重写来优化写得不好的查询。</li><li id="007b" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">删除未使用的索引以加快写入速度。</li></ul><p id="ff27" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">到目前为止，我们所看到的只是冰山一角。数据库维护和改进是一门艺术，需要几年的实践经验。但是使用友好的、经济的、能帮助我们轻松实现目标的工具链总是很重要的。</p><h1 id="a361" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">保持仪表板最新</h1><p id="626e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">构建完成后，保持仪表板最新是很重要的。这可以根据我们的需要通过各种方式来实现。</p><h1 id="8937" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">手动刷新Arctype仪表盘</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/63935a85ef8f14a3e858d77f741bcf85.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/0*UuY-yfpMrVUL4770.png"/></div></figure><p id="ba4e" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">在编辑模式按钮的右上方，有一个重新加载按钮，我们可以单击它来重新加载整个仪表板。</p><h1 id="2a3c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">自动刷新整个仪表板</h1><p id="e7f5" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们还可以将整个仪表板配置为定期刷新。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/5ada32190f741429afc37bb5643f16f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/format:webp/0*wVObiIDoRacOvdoN.png"/></div></figure><h1 id="c7c2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">自动刷新单个组件</h1><p id="43ec" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">通过单击单个组件并单击<code class="du lg lh li lj b">Advanced</code>，我们可以配置该组件，使其在指定的时间间隔自动刷新。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/705545649c4d51832dde2baa2f6b92e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/0*fCSR_hQVHaecgQ8w.png"/></div></figure><p id="aac6" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">我们可以选择我们想要的刷新类型，但是请记住，监视数据库本身的查询可能会占用大量资源，因此会降低性能。</p><h1 id="8f93" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">共享仪表板(和总结想法)</h1><p id="a1db" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">许多数据库工具缺少的另一个非常重要的功能是共享仪表盘的能力，但Arctype提供了这一功能。</p><p id="1d49" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">通过点击仪表板查看器右上方屏幕上的<code class="du lg lh li lj b">Share</code>按钮，我们可以共享各种选项。</p><h1 id="bb55" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">通过电子邮件共享Arctype工作空间</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/33641802e1de924ab14da35e46990169.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/0*4AdbmQrNazv13-vz.png"/></div></figure><p id="a029" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这将邀请用户成为工作空间的一部分。对于更高级的控制，请查看<a class="ae lf" href="https://docs.arctype.com/ogranizations/create-a-new-organization" rel="noopener ugc nofollow" target="_blank">团队功能</a>。</p><h1 id="b41e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">链接到您的工作区</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/21d66bc1f10971041812e7dd53e9d2c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/0*aX6c7h6XaXVQwh50.png"/></div></figure><p id="8909" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这和上面的一样，除了任何有链接的人都可以加入工作区。</p><h1 id="2637" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">创建公共只读链接</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/46af93eb6cc86893604acf7ed97147f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/0*gmSP15HAMML-EcNF.png"/></div></figure><p id="c837" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">这将发送一个也可以在浏览器中查看的只读链接。这对于与团队中不同的(可能是非技术的)涉众共享仪表板来说非常方便。</p><p id="b071" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">注意:您不能共享本地托管的数据库(或任何附属的仪表板)</p><h1 id="14a2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="ef16" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这些仪表板在以下情况下非常有用:</p><ul class=""><li id="11a9" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated">运行性能测试。</li><li id="470e" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">在指定时间段内监视实时数据库。</li><li id="1a19" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">常规数据库监控。</li></ul><p id="d11a" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">Arctype提供的细粒度控制使该仪表盘可以在同事、团队甚至整个互联网上轻松共享。如果您还没有下载Arctype，请继续下载，并开始创建这些仪表盘-了解数据库健康状况并对其进行监控不应再局限于某些工具或人员！</p></div></div>    
</body>
</html>