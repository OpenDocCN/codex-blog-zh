<html>
<head>
<title>The Lifecycle of a React Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React组件的生命周期</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-lifecycle-of-a-react-component-8e01332a068d?source=collection_archive---------1-----------------------#2021-01-05">https://medium.com/codex/the-lifecycle-of-a-react-component-8e01332a068d?source=collection_archive---------1-----------------------#2021-01-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/112cfaf3139cb4ef84cdd576f333baf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gJ_5USJgVkXW1S8E"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">再来说说生活的React组件圈！</figcaption></figure><p id="1034" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在React应用程序中，我们使用组件将web用户界面的不同部分分割和隔离成单独的部分。这些部分独立工作，并使用渲染函数返回JSX中的React元素。这些元素描述了应该如何向用户显示该部分。</p><p id="22b2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每个组件都经过<strong class="iw hj">三个</strong>阶段:<strong class="iw hj">安装</strong>、<strong class="iw hj">更新</strong>和<strong class="iw hj">卸载</strong>。你也可以把它想象成我们的自然生命周期:我们出生，我们成长(青春期和成年期)，最终，我们死亡。React组件是通过挂载到DOM上来创建的，它们通过更新来改变或增长，最后，它们可以从DOM中移除或卸载。这三个里程碑被称为React <strong class="iw hj">组件生命周期</strong>。</p><p id="1387" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">(<strong class="iw hj">注</strong> : <em class="js">一个反应元件</em> <strong class="iw hj"> <em class="js">可能会也可能不会</em> </strong> <em class="js">经历所有阶段。有时它们永远不会更新。其他时候，它们从不被卸载。一个组件甚至可以在没有更新的情况下连续经历安装和卸载阶段。)</em></p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/7d3bfdbefd997fe5250862068206ec16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YQbu93jW_il8q84V.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">React组件生命周期的现代图表。</figcaption></figure><p id="dd73" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上图显示了React组件的整个现代生命周期及其相应的生命周期方法。React提供了特定的生命周期方法，可用于在不同阶段执行特定的操作。这些被称为React <strong class="iw hj">组件生命周期方法。</strong>让我们仔细看看！</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="1f46" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated"><strong class="ak">安装阶段</strong></h1><p id="84c4" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">这个阶段指的是组件的创建。这是组件被添加到DOM的地方。</p><p id="39cd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以下是可用于此阶段的生命周期方法:</p><h2 id="bf66" class="li kg hi bd kh lj lk ll kl lm ln lo kp jf lp lq kt jj lr ls kx jn lt lu lb lv bi translated"><strong class="ak">构造函数()</strong></h2><p id="cae9" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">在安装阶段开始之前，我们可能需要使用<code class="du lw lx ly lz b">constructor()</code>方法初始化我们的组件。当我们需要初始化状态并将方法绑定到组件时，就会用到它。这是唯一明确指定<code class="du lw lx ly lz b">this.state</code>的地方。(<em class="js">这里不要用</em> <code class="du lw lx ly lz b"><em class="js">setState</em></code> <em class="js">。</em>)</p><p id="e0f3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">同样，在这一步中会发生两件重要的事情:</p><ol class=""><li id="8a0f" class="ma mb hi iw b ix iy jb jc jf mc jj md jn me jr mf mg mh mi bi translated">一个对象被分配给<code class="du lw lx ly lz b">this.state</code></li><li id="0b65" class="ma mb hi iw b ix mj jb mk jf ml jj mm jn mn jr mf mg mh mi bi translated">方法通过props传递/绑定到类的实例</li></ol><h2 id="1dc1" class="li kg hi bd kh lj lk ll kl lm ln lo kp jf lp lq kt jj lr ls kx jn lt lu lb lv bi translated">静态getDerivedStateFromProps()</h2><p id="86f7" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">初始化后，下一个被调用的函数是<code class="du lw lx ly lz b">static getDerivedStateFromProps()</code>。这个方法在组件的render函数之前(以及初始挂载之前)被调用。</p><p id="a7ce" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该方法允许组件根据其属性的变化来更新其状态。它很少使用，应该谨慎使用，因为它可能会导致错误。一般规则作为初学者，你可能不需要它，应该避免使用它。</p><h2 id="97bb" class="li kg hi bd kh lj lk ll kl lm ln lo kp jf lp lq kt jj lr ls kx jn lt lu lb lv bi translated">渲染()</h2><p id="5e34" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated"><code class="du lw lx ly lz b">render()</code>方法是组件<strong class="iw hj"> <em class="js">需要</em> </strong>拥有的唯一方法。它总是被调用，它的工作是将组件挂载到DOM。<code class="du lw lx ly lz b">render()</code>方法可以返回以下任何内容:</p><ul class=""><li id="25e0" class="ma mb hi iw b ix iy jb jc jf mc jj md jn me jr mo mg mh mi bi translated">React Elements :用JSX写的，这些简单的对象描述了我们希望用户看到的东西</li><li id="6aa6" class="ma mb hi iw b ix mj jb mk jf ml jj mm jn mn jr mo mg mh mi bi translated"><strong class="iw hj">数组或片段</strong>:这些允许你返回多个React元素。使用<code class="du lw lx ly lz b">[]</code>声明数组，使用空标签<code class="du lw lx ly lz b">&lt;&gt; &lt;/&gt;</code>声明片段</li><li id="1687" class="ma mb hi iw b ix mj jb mk jf ml jj mm jn mn jr mo mg mh mi bi translated"><strong class="iw hj">门户</strong>:这些允许你将孩子渲染到不同的DOM子树中(在DOM层次结构之外)</li><li id="fd30" class="ma mb hi iw b ix mj jb mk jf ml jj mm jn mn jr mo mg mh mi bi translated"><strong class="iw hj">布尔值或空值</strong>:本质上，这不会呈现任何内容，但可用于条件情况</li><li id="513b" class="ma mb hi iw b ix mj jb mk jf ml jj mm jn mn jr mo mg mh mi bi translated"><strong class="iw hj">普通数字和字符串</strong></li></ul><p id="bda9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">React文档将渲染函数描述为“纯粹的”。这意味着函数<strong class="iw hj"> <em class="js">返回的任何东西都不应该</em> </strong>改变组件的状态。<em class="js">(千万不要在这里使用</em> <code class="du lw lx ly lz b">setState</code> <em class="js">或者发出网络请求。)</em></p><h2 id="8ff2" class="li kg hi bd kh lj lk ll kl lm ln lo kp jf lp lq kt jj lr ls kx jn lt lu lb lv bi translated">componentDidMount()</h2><p id="7cc1" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">这个阶段的最后一个功能是<code class="du lw lx ly lz b">componentDidMount()</code>。在执行render函数后，将立即调用该方法。如果我们需要直接与浏览器交互，这就是我们要做的。我们可以进行API调用，并根据它的响应更新组件状态。我们可以从另一个端点加载数据来填充内容。这里应该使用调用<code class="du lw lx ly lz b">setState()</code>,因为它将再次调用render函数并处理像fetch请求这样的异步进程。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/6587d8e88315cc6efe2d60fd35bcfbf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VAWYPrHryoAM6HOH3SdhA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">概述安装阶段生命周期方法。</figcaption></figure></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="015a" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">更新</h1><p id="d23e" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">这个第二阶段表示组件由于其属性或状态的改变而需要更新的时间。这些变化可以在组件内部发生，也可以通过后端发生。这些变化将再次触发渲染功能。</p><p id="473d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以下是生命周期方法:</p><h2 id="0abc" class="li kg hi bd kh lj lk ll kl lm ln lo kp jf lp lq kt jj lr ls kx jn lt lu lb lv bi translated">静态getDeprivedStateFromProps()(再次)</h2><p id="1223" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">这是此阶段调用的第一个方法。该方法与安装阶段使用的方法相同。</p><h2 id="c577" class="li kg hi bd kh lj lk ll kl lm ln lo kp jf lp lq kt jj lr ls kx jn lt lu lb lv bi translated">shouldComponentUpdate()</h2><p id="b1c8" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">下一个要调用的方法是<code class="du lw lx ly lz b">shouldComponentUpdate()</code>方法。顾名思义，这个方法使您能够控制组件是否应该根据其属性或状态的变化而更新。默认情况下，组件在更新时总是会重新呈现。这个方法可以返回一个<code class="du lw lx ly lz b">true </code>或者<code class="du lw lx ly lz b">false</code>。此外，该方法接收<code class="du lw lx ly lz b">nextProps</code>和<code class="du lw lx ly lz b">nextState</code>作为参数，因此您可以随时将其与组件的当前属性和状态值进行比较。这种方法有助于性能优化，但也很少使用。</p><h2 id="9b54" class="li kg hi bd kh lj lk ll kl lm ln lo kp jf lp lq kt jj lr ls kx jn lt lu lb lv bi translated">渲染()</h2><p id="f8f5" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">如果<code class="du lw lx ly lz b">shouldComponentUpdate()</code>返回<code class="du lw lx ly lz b">true</code>，渲染函数立即被调用。</p><h2 id="97bd" class="li kg hi bd kh lj lk ll kl lm ln lo kp jf lp lq kt jj lr ls kx jn lt lu lb lv bi translated">getSnapshotBeforeUpdate()</h2><p id="0d19" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">在这个方法中，在更新提交到DOM之前，我们可以访问props和state值。即使已经调用了render函数，我们仍然能够看到以前的值。这种情况并不常见，但可以用来获取我们可能需要的任何信息。值得注意的是，该方法与<code class="du lw lx ly lz b">componentDidUpdate()</code>协同工作，这是我们将讨论的下一个生命周期方法。</p><h2 id="9448" class="li kg hi bd kh lj lk ll kl lm ln lo kp jf lp lq kt jj lr ls kx jn lt lu lb lv bi translated">componentDidUpdate()</h2><p id="25ec" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">此方法是此阶段调用的最后一个方法。像前面的方法一样，它也接收前面的属性和状态值作为参数，但是它也接收返回值<code class="du lw lx ly lz b">getSnapshotBeforeUpdate()</code>作为第三个参数(如果存在)。</p><p id="ba0b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它通常用于在比较当前和先前的属性和状态值的情况下进行更多的获取请求。因此，您可以调用<code class="du lw lx ly lz b">setState</code>，但是在条件语句中。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/3ff9b95e157284d6ffebc544c2e9ee0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7uyxPYNmBql9g7kjmEPvg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">概述更新阶段生命周期方法。</figcaption></figure></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="2b10" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">卸载</h1><p id="9e91" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">最后，卸载阶段是从DOM中删除组件的阶段。这标志着组件生命周期的结束。在这个阶段，我们有一个可用的生命周期方法:</p><h2 id="8fdb" class="li kg hi bd kh lj lk ll kl lm ln lo kp jf lp lq kt jj lr ls kx jn lt lu lb lv bi translated">componentWillUnmount()</h2><p id="89ce" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">这个方法在组件从DOM中卸载之前执行。您可以将此方法视为在销毁组件之前清理任何需要移除的内容的一种方式。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h1 id="96d9" class="kf kg hi bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">额外收获:错误处理</h1><p id="1bb5" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">除了这些生命周期方法之外，当渲染过程中出现错误时，还会调用一些方法。React 16引入了“错误边界”的概念，它只是捕捉JS错误的React组件。他们将捕捉这些错误，记录它们，然后显示一个“回退”UI。这很有用，因为一个JS错误不会破坏用户的整个应用程序。</p><p id="7460" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们实现这个概念的方法是创建一个新的类组件(通常称为<code class="du lw lx ly lz b">ErrorBoundary</code>)。我们将组件包装在子组件周围。您应该只创建这个类一次，并在React应用程序的不同部分重用它。</p><p id="d802" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有两种相关的方法:</p><h2 id="7752" class="li kg hi bd kh lj lk ll kl lm ln lo kp jf lp lq kt jj lr ls kx jn lt lu lb lv bi translated">静态getDerivedStateFromError()</h2><p id="e103" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">如果子组件中出现错误，将调用此方法。错误将作为参数传递，该方法将返回一个值，该值将更新类组件的状态。此方法对于呈现自定义回退用户界面(而不是呈现损坏的组件)非常有用。</p><h2 id="b0bb" class="li kg hi bd kh lj lk ll kl lm ln lo kp jf lp lq kt jj lr ls kx jn lt lu lb lv bi translated">componentDidCatch()</h2><p id="49fd" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">此方法接收作为参数的错误以及包含错误信息的对象。这种方法非常适合记录错误！</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/9270294d74f06827fc033bf2d5dd4978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNQI9-FY8m5F9FDu8ZFOmA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">直接来自React文档的示例。</figcaption></figure></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><h2 id="1dfc" class="li kg hi bd kh lj lk ll kl lm ln lo kp jf lp lq kt jj lr ls kx jn lt lu lb lv bi translated">结论</h2><p id="885a" class="pw-post-body-paragraph iu iv hi iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr hb bi translated">就是这样！react组件生命周期一开始可能会令人生畏，可能会有点混乱，但是希望这已经让您对这个概念有了更好的理解。</p><h2 id="4fad" class="li kg hi bd kh lj lk ll kl lm ln lo kp jf lp lq kt jj lr ls kx jn lt lu lb lv bi translated">参考资料:</h2><div class="mr ms ez fb mt mu"><a href="https://reactjs.org/docs/react-component.html" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">做出反应。成分-反应</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">该页面包含React组件类定义的详细API参考。它假设您熟悉…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">reactjs.org</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni io mu"/></div></div></a></div><div class="mr ms ez fb mt mu"><a href="https://www.w3schools.com/react/react_lifecycle.asp" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">反应生命周期</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">React中的每个组件都有一个生命周期，您可以在它的三个主要阶段对其进行监控和操作。三个…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">www.w3schools.com</p></div></div><div class="nd l"><div class="nj l nf ng nh nd ni io mu"/></div></div></a></div><div class="mr ms ez fb mt mu"><a href="https://reactjs.org/docs/error-boundaries.html" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">错误边界-反应</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">过去，组件内部的JavaScript错误会破坏React的内部状态，导致它发出神秘的…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">reactjs.org</p></div></div><div class="nd l"><div class="nk l nf ng nh nd ni io mu"/></div></div></a></div><div class="mr ms ez fb mt mu"><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">反应生命周期方法图</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">完全交互式和可访问的React生命周期方法图。</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">projects.wojtekmaj.pl</p></div></div><div class="nd l"><div class="nl l nf ng nh nd ni io mu"/></div></div></a></div></div></div>    
</body>
</html>