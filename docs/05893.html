<html>
<head>
<title>Strings in JAVA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JAVA中的字符串</h1>
<blockquote>原文：<a href="https://medium.com/codex/strings-in-java-e562c599b7d1?source=collection_archive---------13-----------------------#2022-04-01">https://medium.com/codex/strings-in-java-e562c599b7d1?source=collection_archive---------13-----------------------#2022-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="2e49" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">创建字符串</h1><p id="5fdd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">JAVA中的每个字符都是以UTF-16格式存储的，所以String中的每个字符都使用16位或2字节的内存。在Java中有四种创建字符串的方法:</p><ul class=""><li id="beb5" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">字符的数组或数组列表</li><li id="9eb8" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">字符串类。</li><li id="b2d0" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">StringBuffer类</li><li id="9336" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">StringBuilder类</li></ul><p id="d59e" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">String类创建不可变的字符串，而StringBuffer和StringBuilder类使用可变的字符串。StringBuffer和StringBuilder的区别在于，StringBuffer是一个线程安全的类，也就是说，我们可以在多线程应用程序中使用StringBuffer。同时，StringBuilder不是一个线程安全的类。StringBuilder类的好处是它比StringBuffer类快，因为StringBuffer类提供了线程安全的额外开销。</p><h1 id="d28d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">字符串类的函数</h1><p id="8bd3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">假设我们创建了一个字符串s = "Mrigank "。现在我们将对这个字符串执行所有的功能。</p><ul class=""><li id="90bd" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated"><strong class="jf hj"><em class="ku">s . length()</em></strong><strong class="jf hj"><em class="ku">→</em></strong>它会给出字符串的长度。输出将是7。</li><li id="3860" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj"><em class="ku">s . charat(index)→</em></strong>它会给出字符串中特定索引处的字符。对于<strong class="jf hj"> <em class="ku"> s.charAt(2) </em> </strong>，输出将为<strong class="jf hj"> <em class="ku"> i </em> </strong>。</li></ul><p id="1252" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj"> <em class="ku">注意:</em> </strong> <em class="ku">我们不能在Java中使用s[index]。这是不允许的。这将给出一个错误，说明</em> <strong class="jf hj"> <em class="ku">需要Java: array，但找到了Java.lang.String。</em>T29】</strong></p><ul class=""><li id="277d" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated"><strong class="jf hj"><em class="ku">s.substring(beginIndex)或s . substring(begin index，endIndex) → </em> </strong>这是Java中string类中存在的substring函数的2种变体。第一个返回从开始索引到字符串结尾的字符串，第二个返回字符串的[beginIndex，endIndex。</li></ul><p id="bcdb" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">s.substring(3) → gank</p><p id="eb58" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">s.substring(3，6) → gan</p><ul class=""><li id="0e58" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated"><strong class="jf hj"><em class="ku">s1 . contains(s2)→</em></strong>如果S2作为子串出现在S1中，则返回true否则，它将返回false。</li></ul><p id="3c5b" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">String s1 = " MrigankString s2 = " rigas1.contains(s2)将给出true</p><ul class=""><li id="80aa" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated"><strong class="jf hj"><em class="ku">S1 . equals(S2)→</em></strong>检查两个字符串的内容是否相等，如果相等则返回true，否则返回false。</li></ul><p id="4861" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">对于上面的例子，s1.equals(s2)将给出false。</p><ul class=""><li id="53c8" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated"><strong class="jf hj"><em class="ku">s1 . compare to(s2)→</em></strong>如果两个字符串在字典上相同，则返回0，如果S1在字典上大于S2，则返回正值，反之亦然。</li><li id="ad8d" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj"> <em class="ku"> s1.indexOf(s2)或s1.indexOf(s2，fromIndex) → </em> </strong>这将在第一种情况下返回字符串s1中第一个出现的子串s2的索引，在第二种情况下，从fromIndex的<strong class="jf hj"> <em class="ku">开始返回字符串s1中第一个出现的子串s2。</em> </strong>如果该子串不在字符串中，则返回-1。</li><li id="179e" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj"><em class="ku">S1 . equalsignorecase(S2)→</em></strong>如果两个字符串相等，则返回true，忽略字符的大小写，否则返回false。</li><li id="c9ec" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj"><em class="ku">s1 . toupper case()→</em></strong>这将把字符串S1的所有字符转换成大写。</li><li id="7d7c" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj"><em class="ku">s . chars()→</em></strong>Java String chars()方法返回一个IntStream。该流包含字符串对象中字符的整数码位值。</li></ul><h1 id="47d0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">字符串的内存分配</strong></h1><p id="ecfd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> String literal pool: </strong>这是Java堆中的一个存储区域，String literal存储在这里。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/e6e49f63d4ade302f30641f3048a0a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcAfUsI3bITJqbDXeJqldw.png"/></div></div></figure><p id="afed" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj"> <em class="ku"> == → </em> </strong>该标志检查引用的相等性，而不是对象内容。</p><p id="b949" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">所以，在上面的图像中，如果我们做<strong class="jf hj"> <em class="ku"> s == s2，</em> </strong>它会给出true，如果我们做<strong class="jf hj"> <em class="ku"> s == s1，</em> </strong>它会给出false。</p><h1 id="5052" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">字符串和StringBuffer，字符串连接时的StringBuilder行为</h1><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lh"><img src="../Images/f22b0a69ea675d05d1f17c61ef49bcd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Px9qew5CZTNfpejvEMpiAw.jpeg"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">字符串行为</figcaption></figure><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lm"><img src="../Images/34b34f10729d28ff06d0933a9e8b6862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQ4OmbuL0C8A5GvAj7I_kg.jpeg"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">StringBuilder和StringBuffer</figcaption></figure><h1 id="ea5a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">StringBuilder和StringBuffer类的函数</h1><p id="5f7d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> <em class="ku"> length()、charAt(index)、indexOf(string)、indexOf(string、fromIndex)、lastIndexOf(string、fromIndex)、compareTo(string)、subString(beginIndex)、subString(beginIndex、endIndex)、chars() </em> </strong>等众多函数。StringBuilder和StringBuffer类的唯一函数是:</p><ul class=""><li id="dcaf" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated"><strong class="jf hj"> <em class="ku"> s.append(x) → </em> </strong>这将把x追加到字符串s的末尾，这里的x可以是整数、双精度、布尔、浮点或对象。</li><li id="6aab" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj"> <em class="ku"> s.insert(position，x) → </em> </strong>这样会在字符串s中的位置x处插入x，这里的x是指任意对象。</li><li id="faf4" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj"> <em class="ku"> s.setCharAt(index，character) → </em> </strong>这将在字符串的特定索引处插入字符。</li><li id="a70d" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj"> <em class="ku"> reverse() → </em> </strong>这将反转字符串s，这个函数在String类内部是不存在的。</li><li id="52c3" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj"><em class="ku">s . delete charat(index)→</em></strong>删除字符串s中特定索引处的字符</li><li id="0615" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj"> <em class="ku"> s.delete(startIndex，endIndex) </em> </strong> →从[startIndex，end index]中删除字符。</li><li id="d539" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj"> <em class="ku"> s.capacity() → </em> </strong>这给出了字符串s的缓冲容量。StringBuffer的初始容量是<strong class="jf hj"> <em class="ku"> 16 </em> </strong>但是随着StringBuffer的大小增加，它的容量按照公式<strong class="jf hj"><em class="ku">(old capacity * 2)+2</em></strong>增长。StringBuilder也是如此。</li><li id="ee7d" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated"><strong class="jf hj"> <em class="ku"> s.replace(startIndex，endIndex，str) </em> </strong> →用str替换[startIndex，end index]中的字符串。</li></ul></div></div>    
</body>
</html>