<html>
<head>
<title>Databricks CICD using Repo approach using Azure DevOps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Databricks CICD采用回购方法，使用Azure DevOps</h1>
<blockquote>原文：<a href="https://medium.com/codex/databricks-cicd-using-repo-approach-using-azure-devops-8c4f64332761?source=collection_archive---------0-----------------------#2022-07-16">https://medium.com/codex/databricks-cicd-using-repo-approach-using-azure-devops-8c4f64332761?source=collection_archive---------0-----------------------#2022-07-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ddd1bc81c74a811edaf6a5b9e2da012c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D5Gt_ZRsw7rMiI5W"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Jez Timms 在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2ae2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据砖块的CICD真的很有挑战性。使用回购方式让我们的生活变得轻松许多。为此，我们利用了存储库集成和来自Databricks的构建良好的API，我们将对此进行详细研究。</p><h1 id="c5fc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">概观</h1><p id="355a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在这篇博客中，我将向您展示如何使用Databricks存储库方法实现令人信服的CICD管道。这将通过使用Azure DevOps来完成，但该演示的功能可在所有CICD工具上重用。这条CICD管道的整个理念与<a class="ae iu" href="https://docs.microsoft.com/en-us/azure/databricks/repos/ci-cd-best-practices-with-repos" rel="noopener ugc nofollow" target="_blank"> Databricks回购工作流程</a>紧密相连。在这个演示之后，我还将讨论这种方法的替代方案，以及我们何时应该考虑使用它。</p><h1 id="fe7c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">回购方法</h1><h2 id="3747" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">准备</h2><p id="c85c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在我们开始之前，让我们讨论一下我们必须遵守的要求，以便能够实现这种方法。我们需要在Databricks中配置我们的Git集成，还需要一个Azure DevOps项目。</p><p id="0f2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于我们的Git集成，第一步是进入设置&gt;用户设置&gt; Git集成。在这里，您需要插入您的Git凭证。例如，在使用GitHub Enterprise的情况下。之后，您可以在回购文件夹上导航，并在此创建您的回购克隆。最佳实践是创建一个名为“Repos”的空文件夹，并将克隆的存储库插入到这里。您需要为您的Databricks开发环境以及您希望用您的CICD管道作为目标的每个环境执行这个步骤。完成这些步骤后，您应该有一个回购文件夹，它应该是这样的:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/1e60da5d229a1fa65f40638a0268b1c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ry3vQVaTswXyka_eGrDdwA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">集成知识库</figcaption></figure><h2 id="52a3" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">数据块API</h2><p id="da09" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">管道的工作方式如下。它由您定义的事件触发(例如您的主分支机构的PR ),并调用Databricks <a class="ae iu" href="https://docs.databricks.com/dev-tools/api/latest/repos.html" rel="noopener ugc nofollow" target="_blank"> repos API </a>。使用这个API，您能够在您的目标工作空间中更新或者替换您的存储库的当前分支。这意味着，如果您从您的开发数据块提交到您的主分支，您可以通过使用这个API调用，自动更新您的TST和PRD数据块环境中的存储库的每个克隆。这是使用以下API完成的:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="9846" class="kw ju hi lq b fi lu lv l lw lx">/repos/{repo_id}</span><span id="910e" class="kw ju hi lq b fi ly lv l lw lx">#full example<br/>https://adb-66210.0.azuredatabricks.net/api/2.0/repos/629 </span></pre><p id="5252" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用Databricks API来完成这个任务，我们需要一些信息来使它工作。这包括:</p><ul class=""><li id="8f7a" class="lz ma hi ix b iy iz jc jd jg mb jk mc jo md js me mf mg mh bi translated">数据块访问令牌(针对每个环境)</li><li id="f35d" class="lz ma hi ix b iy mi jc mj jg mk jk ml jo mm js me mf mg mh bi translated">数据块工作空间URL(针对每个环境)</li><li id="31a3" class="lz ma hi ix b iy mi jc mj jg mk jk ml jo mm js me mf mg mh bi translated">存储库ID(针对每个环境)</li><li id="9a58" class="lz ma hi ix b iy mi jc mj jg mk jk ml jo mm js me mf mg mh bi translated">您要使用的分支</li></ul><p id="2959" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以在设置&gt;用户设置&gt;访问令牌&gt;生成令牌下创建令牌。</p><p id="c9ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对应于您的Databricks工作区的URL就是您打开Databricks环境时浏览器显示的URL。复制所有内容直到。网(如<a class="ae iu" href="https://adb-66210.0.azuredatabricks.net" rel="noopener ugc nofollow" target="_blank">https://adb-66210.0.azuredatabricks.net</a>)。</p><p id="d14c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果右键单击克隆的repo文件夹&gt; Git，可以找到存储库ID...&gt;设置，您可以在这里看到它。</p><p id="0cb7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个分支就是您想要更新到目标环境中的分支。它可以是你的主分支或者任何其他类似的发布分支。</p><p id="b02d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果使用CURL，将所有内容放在一起看起来像这样:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="4a21" class="kw ju hi lq b fi lu lv l lw lx">curl -X PATCH "https://adb-66210.0.azuredatabricks.net/api/2.0/repos/629"</span><span id="3f8c" class="kw ju hi lq b fi ly lv l lw lx">-H "Authorization: Bearer 1234"</span><span id="220d" class="kw ju hi lq b fi ly lv l lw lx">-H "Content-Type: application/json"</span><span id="cb56" class="kw ju hi lq b fi ly lv l lw lx">-d '{"branch": "main"}'</span></pre><h2 id="e50d" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">管道</h2><p id="11e5" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在让我们看看基于yaml的Azure DevOps管道是什么样子的。因为我们使用的是之前的curl命令，所以我们将使用bash任务。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="bf7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，在本例中，如果主分支发生变化，我们将触发管道。管道只是从前面调用curl语句来更新我们的目标Databricks环境中的存储库。</p><p id="d942" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Azure DevOps环境变量$(Build。SourceBrancheName)被用作curl主体的输入，这为我们提供了灵活性，我们可以添加更多的分支来触发这个管道。那么触发管道的分支将在我们的目标管道中得到更新。</p><p id="c840" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您想在生产环境中使用这段代码，也要记住使用类似Azure Key Vault的东西来获取秘密。这只是为了演示而简化的。</p><h1 id="cd88" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">供选择的</h1><p id="91b6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">除了使用回购方式，你还可以使用<a class="ae iu" href="https://docs.microsoft.com/en-us/azure/databricks/dev-tools/ci-cd/ci-cd-azure-devops" rel="noopener ugc nofollow" target="_blank">更经典的方式</a>。这是通过创建您的数据块代码的工件，将它们捆绑到您的CI管道中，然后通过将它们推入共享工作区，将它们推向您的目标环境来实现的。</p><p id="8a68" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种方式比回购方式复杂得多，也容易出错，但它也有一个很大的优势。您能够执行<a class="ae iu" href="https://docs.microsoft.com/en-us/azure/databricks/dev-tools/ci-cd/ci-cd-azure-devops" rel="noopener ugc nofollow" target="_blank">单元测试，并与库</a>进行更深入的集成。</p><p id="48ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为结论，您可以说，如果您只需要将代码部署到其他数据块环境，请使用repo方法。但是如果你需要做更复杂的事情，比如单元测试，你应该研究一下经典的方法。</p></div></div>    
</body>
</html>