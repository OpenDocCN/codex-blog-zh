<html>
<head>
<title>A Closer Look into the Perceptron Model in Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入研究深度学习中的感知机模型</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-closer-look-into-the-perceptron-model-in-deep-learning-eea75fb4084?source=collection_archive---------15-----------------------#2021-07-05">https://medium.com/codex/a-closer-look-into-the-perceptron-model-in-deep-learning-eea75fb4084?source=collection_archive---------15-----------------------#2021-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a4e5" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用步长增量学习算法在真实数据集上训练</h2></div><h1 id="b757" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated"><strong class="ak">内容</strong></h1><p id="20ea" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">1.<a class="ae kl" href="#a95a" rel="noopener ugc nofollow">简介</a> <br/> 2。<a class="ae kl" href="#c8c8" rel="noopener ugc nofollow">新车型的需求</a> <br/> 3。<a class="ae kl" href="#ea5b" rel="noopener ugc nofollow">感知器</a> <br/> 4。<a class="ae kl" href="#3e9d" rel="noopener ugc nofollow">算法是什么？</a> <br/> 5。<a class="ae kl" href="#a423" rel="noopener ugc nofollow">用Python实现我们的模型</a></p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="a95a" class="ix iy hi bd iz ja kt jc jd je ku jg jh io kv ip jj ir kw is jl iu kx iv jn jo bi translated">1.介绍</h1><p id="7472" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在我们之前的讨论中，<a class="ae kl" rel="noopener" href="/codex/getting-started-with-artificial-intelligence-and-deep-learning-eb6d4694e652?source=friends_link&amp;sk=c23ab7c45fc975e5a4f0034007b13d1d"> <em class="ky">人工智能和深度学习入门</em> </a>，我们开始构建一些基本概念，定义一些介绍性术语，并研究用手机玩具数据集对<em class="ky"> MP神经元</em>进行训练。最后，我们为我们的神经元编写了一个Python类，给定一个训练数据集，它将实现<em class="ky">强力</em>算法。</p><p id="5631" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">从那里开始，我们现在将研究MP神经元和暴力算法的一些缺点，然后介绍一个新的模型。也是时候开始我们的技术在现实生活中的应用了，为此我们将加载并馈入我们的新模型，一个<em class="ky">乳腺癌预测数据集，</em>稍后详述。</p><p id="5db3" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">所以让我们开始吧。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es le"><img src="../Images/22566791fe7b760f16653013b87401e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*erVqlTKQ7b1wnZhdBRMNKQ.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">照片由<a class="ae kl" href="https://unsplash.com/@ffstop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae kl" href="https://unsplash.com/s/photos/machine-learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="c8c8" class="ix iy hi bd iz ja kt jc jd je ku jg jh io kv ip jj ir kw is jl iu kx iv jn jo bi translated">2.对新模式的需求</h1><p id="12eb" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">为了讨论MP神经元模型的一些局限性，我们将再次查看我们的玩具数据集<em class="ky"> </em>。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lu"><img src="../Images/93c933bb3b5ca02bf159271f4958bf8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vbGnfhfhE0ngbeI9nJMsrg.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">按作者分类的表格</figcaption></figure><p id="1a63" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">我们可以从这里的数据中得出以下结论:</p><ul class=""><li id="2420" class="lv lw hi jr b js kz jv la jy lx kc ly kg lz kk ma mb mc md bi translated">我们的数据集中的输入必须以<em class="ky">二进制、</em>二进制给出，这是现实生活数据中很少见到的特征。使用真实值的模型可以更好地训练，提供更高的精度，并使用更多样化的数据集。</li><li id="7cfd" class="lv lw hi jr b js me jv mf jy mg kc mh kg mi kk ma mb mc md bi translated">输出也是<em class="ky">二进制。</em>这限制了我们可以处理的数据。在许多应用中，有些涉及到<em class="ky">自然语言处理，</em>我们可能不得不做所谓的<em class="ky">多类分类，</em>也就是说，我们的输出必须归入几个类别中的一个。要做到这一点，我们必须从前面定义的阈值概念(如果sum &gt; = threshold，output = 1，否则为0)中找到一个变通方法，并处理概率。这个想法会在以后的帖子里详细阐述。</li><li id="8b66" class="lv lw hi jr b js me jv mf jy mg kc mh kg mi kk ma mb mc md bi translated">由于我们只限于二进制数据，所以我们所有的输入参数都具有相同的权重和同等的重要性，即价格或屏幕尺寸对输出的影响是同等的。然而，现实生活中的决策必须能够分配<em class="ky">、</em>权重，并确保更重要的属性得到充分的体现。例如，价格是许多人购买时最重要的方面。</li><li id="d01d" class="lv lw hi jr b js me jv mf jy mg kc mh kg mi kk ma mb mc md bi translated">我们的<em class="ky">蛮力</em>算法太原始，没有充分利用我们可用的<em class="ky">计算资源</em>。此外，我们的模型只需要学习一个参数，在我们的玩具数据集中预测的阈值，也仅限于整数值。然而，在深度学习中，同时处理数百万个取<em class="ky">实</em>值的参数是很常见的。在这种情况下，尝试每种组合是不可能的。即使在简单的数据集中，大量的样本也会使该算法效率低下。我们将在后面的旅程中看到，在这种情况下，数学解决方案会帮助我们。</li></ul></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="ea5b" class="ix iy hi bd iz ja kt jc jd je ku jg jh io kv ip jj ir kw is jl iu kx iv jn jo bi translated">3.感知器</h1><p id="f8ed" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">既然我们已经讨论了对更新模型的需求，那么是时候引入<em class="ky">感知器了，</em>这是深度学习中更复杂但更基本的单元。这里最重要的升级是，我们可以对我们的输入进行加权表示，这使得神经元在训练过程中更加灵活。感知器模型如下图所示。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mj"><img src="../Images/815cc46a6a4083d57916e71f9ab2a736.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*2XtL7zwcYRucdAYDLOz_ng.png"/></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">作者图片</figcaption></figure><p id="e884" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">我们可以看到，现在我们将对所有这些参数进行加权表示，并为每个<code class="du mk ml mm mn b"><strong class="jr hj">xn</strong></code>定义一个权重<code class="du mk ml mm mn b"><strong class="jr hj">wn</strong></code>，而不仅仅是输入<code class="du mk ml mm mn b"><strong class="jr hj">x1</strong> </code>到<code class="du mk ml mm mn b"><strong class="jr hj">xn</strong></code>。因为我们要处理更多的参数，建议开始使用矩阵和向量来表示。</p><p id="9eed" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">我们的权重和输入值可以用以下格式表示:</p><p id="ea05" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">重量:[w1 w2 w3 w4。。。wn]</p><p id="a2fd" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">输入值:[x1 x2 x3 x4。。。xn]</p><p id="b856" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">这里需要注意的是，这些权重不是给我们的，也不是我们数据的一部分。这些权重由我们的模型学习，即通过训练确定适当的值，以便我们的模型可以准确预测。在我们的模型中，</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mo"><img src="../Images/5c1110bef140143d532924b1f32c17f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/0*IhOIkV4J6pOf8QZc"/></div></figure><p id="06e7" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">为了将这些输入关联到我们的输出，我们将遵循类似的方法。给定我们从<code class="du mk ml mm mn b"><strong class="jr hj">w1x1</strong> </code>到<code class="du mk ml mm mn b"><strong class="jr hj">wnxn</strong></code>的加权输入，我们可以取它们的总和。现在，如果这个总和大于给定的阈值，我们的模型将预测1，否则为0。这可以表示为，</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mp"><img src="../Images/f36cb9d4da6f23968fa74daec500bf05.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/0*vBV503WxZolxWAgA"/></div></figure></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="3e9d" class="ix iy hi bd iz ja kt jc jd je ku jg jh io kv ip jj ir kw is jl iu kx iv jn jo bi translated">4.算法是什么？</h1><p id="27b6" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">现在我们已经定义了我们的模型，是时候看看我们将用来训练我们的模型的学习算法了。由于我们没有任何特定的学习权重可以使用，我们将开始初始化我们所有的权重为1。我们的阈值也是未知的，所以我们将其赋值为0。</p><p id="b63d" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">然后，我们将输入传递给模型，计算预测值，并将其与我们从数据中获得的真实值进行比较。这里，可能会出现两种不希望出现的情况。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mq"><img src="../Images/cf08a84566655ca10104bf32e6017ad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/0*eZMkMI79fEvPRnYm"/></div></figure><p id="a3c5" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">让我们看看我们的学习算法能做些什么来纠正这一点。我们将考虑第一种情况。</p><p id="e389" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">这里有个小改动。我们将使用简写符号<strong class="jr hj"> w.x </strong>来表示权重和输入的向量积。下图说明了这一点。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mr"><img src="../Images/1555d335adfbd87d47e34064fadb05af.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*dQiPhv-VyWU65Aymo1O_Pw.png"/></div></figure><p id="3e35" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">我们可以将上面的第一种情况改写为:</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es ms"><img src="../Images/21a30f442e62f2c2e38eac9e61ae04d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/0*qC-uYm06SJSqTy3i"/></div></figure><p id="5b57" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">上式中，<code class="du mk ml mm mn b"><em class="ky">-b</em></code> <em class="ky"> </em>可以表示为<code class="du mk ml mm mn b"><strong class="jr hj">w₀x₀</strong></code>，其中<code class="du mk ml mm mn b"><strong class="jr hj">w₀</strong><em class="ky"> </em>= -b</code>和<code class="du mk ml mm mn b"><strong class="jr hj">x₀</strong><em class="ky"> </em>= 1</code>。</p><p id="ada3" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">这样，我们以最简洁的方式写下我们的等式，如下所示:</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mt"><img src="../Images/f3bcba78d8c6c75f3ebf6e69b9dbb736.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/0*4Or_tCC5fnst6dFt"/></div></figure><p id="0084" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">现在是算法的关键。</p><p id="c51f" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">如果神经元要正确预测，乘积<strong class="jr hj"> w.x </strong>必须为&gt; = 0。由于此时&lt; = 0，我们需要给<strong class="jr hj"> w.x </strong>加上一些<em class="ky">正数</em>，使其值增加并越过0。所以我们需要的是，</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mu"><img src="../Images/5d1778aca335207de413187ad9af8111.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/0*u5UAHZHkOcHHnxbF"/></div></figure><p id="92fa" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">我们需要确定这些正项是什么。因为我们只有输入数据，所以让我们看看如何从中获得一些正的量。给定我们的输入，我们可以得到它的和。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mv"><img src="../Images/551c79647248d5c7f88ebb4864c87dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/0*YRYd7byTfQf5EJut"/></div></figure><p id="a1df" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">因此，我们可以对所有输入的平方求和，我们将得到一个正数，它可以添加到加权输入的总和中。即使它们仍然没有越过0的阈值，我们也可以肯定这是朝着正确方向的一步，因此这将在我们的学习算法中实现。</p><p id="4136" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">加上正项，我们的等式就变成了，</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mw"><img src="../Images/edd28ea8acb3574b0f0f3e79917ff13b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/0*58EjDBd9sOFCce3r"/></div></figure><p id="0d64" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">修改和分解，</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mw"><img src="../Images/0a7fdffa0df5db08e59c9f3d1b0e561c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/0*1LLbBBb31csEj41C"/></div></figure><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mx"><img src="../Images/d0eda55c2cce757c4523bc005deac0f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/0*NtAex9Xk35j55aCF"/></div></figure><p id="fd48" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">或者</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es my"><img src="../Images/e5e2b61d94ef5c11bcacaf5e510afc9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/0*koHhhnJV1Ohn1WuS"/></div></figure><p id="d821" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">在哪里，</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mz"><img src="../Images/00493bdfaa1e7cb7000f4337b08cf020.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/0*mItNzlQNFJCa0MNv"/></div></figure><p id="42d3" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">万一情况是这样，</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es na"><img src="../Images/267ff8adef4f072aa18904f29b3c8777.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/0*AQtdT7tEAZy41GLZ"/></div></figure><p id="ad5a" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">更新应该是，</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es nb"><img src="../Images/2b8a5679905aff10aa4d541477a94a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/0*6oI4t9kcJAT3vlUE"/></div></figure><p id="07ec" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">这样，所需的负项将是，</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es nc"><img src="../Images/435f518ba179f696a9885d564c7d04ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/0*_-wEgZgiHA2GJ1iL"/></div></figure><p id="18e9" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">这是我们新的学习算法，即<em class="ky">步长增量</em>方法，我们遍历数据中的每个样本，将其传递给神经元，并更新我们的权重和阈值以与之匹配。一些样本点可能需要负增量，一些需要正增量，目标是找到平衡点，使我们的精度最大化。</p><p id="4057" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">在培训期间，我们将浏览所有示例，并对每个示例进行更新。有时，为了获得更好的结果，需要多次遍历整个数据，因此我们可以选择查看所有样本的次数。这个数字被称为<em class="ky">时代</em>，这是你在培训网络时会遇到的一个流行术语。</p><p id="14c1" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">这里需要注意的是，我们为了更新而增加的正负项可能太大了。有时，通过将这个值乘以一个适当的分数(称为<em class="ky">学习率</em>)来缩小这个值是有帮助的。这确保了增量得到控制，从而使培训过程顺利进行。如果我们实现了学习率，我们的更新将如下所示。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mx"><img src="../Images/2099e67acbd4759c7b7bbec16370abe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/0*mdw-kOx4MRbDoLMG"/></div></figure><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mx"><img src="../Images/61ae46d7c7af5c5c613fcda1668ded2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/0*jrB-xiwxaOcsRSWD"/></div></figure><p id="ae9f" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">这会将正负项缩小<em class="ky"> lr。</em></p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es nd"><img src="../Images/5133b916e2828d1c23a08cdd026dcdc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/0*D0jILoEPnVKbS0sI"/></div></figure><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es ne"><img src="../Images/d0ac7109142498f7125e78c211f88a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/0*LidSJI08QSFdmPDx"/></div></figure><p id="dde5" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">现在我们已经看到了我们的算法是如何工作的，让我们看看它是如何实现的。我们将运行一个由直觉决定的设定次数的外部循环。对于循环的每次迭代，我们将运行一个内部循环，迭代每个数据样本并更新我们的权重。在每个时期之后，我们将计算训练数据本身的精确度。一旦整个过程完成，我们将找到精确度最高的砝码，然后<em class="ky">瞧！我们已经完成了学习。</em></p><p id="63a9" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">这里有一个旁注。我们提到了两个术语，<em class="ky">学习率</em>和<em class="ky">纪元</em>。这些属性属于<em class="ky">超参数</em>的类别。之所以这样称呼它们，是因为这些值控制着我们网络的结构，决定着我们的训练进度，但并不直接参与给定输入的输出计算。与经过<em class="ky">训练的砝码不同，</em>砝码经过<em class="ky">调整，</em>即尝试不同的组合，选择表现最佳的组合。对于ML从业者来说，超参数调整是非常关键的，以确保任何开发模型的最佳性能。如果网络经过仔细调整，并且训练过程平稳，没有任何干扰波动，就可以达到非常高的精确度。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="a423" class="ix iy hi bd iz ja kt jc jd je ku jg jh io kv ip jj ir kw is jl iu kx iv jn jo bi translated">5.用Python实现我们的模型</h1><p id="ef4d" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我们现在已经建立了我们的理论基础，并准备开始将这些概念付诸实践。让我们转到Python，用步长增量学习算法实现我们的感知器模型。</p><p id="a554" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">对于那些刚刚踏上旅程并且还没有意识到的人来说，使用<em class="ky"> Google Colaboratory构建和处理许多数据科学和ML项目是很常见的。这是谷歌研究院提供的一款产品，允许用户在浏览器上编写和执行代码，无需任何预先设置。Colab允许用户连接到Google的计算引擎后端并利用其资源，因此您可以自由地处理复杂的项目，而不必担心任何系统需求。一个基于网络的交互环境，称为<em class="ky"> Jupyter Notebook，</em>用于构建代码和处理数据。所有内容都存储在您的硬盘上，因此您可以随时与他人分享。你可以在这里开始使用Colab <a class="ae kl" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank">。</a></em></p><p id="4af6" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">在Python中，我们将实现我们上面看到的感知器模型，以解决从加州大学欧文分校机器学习库导入的<em class="ky">乳腺癌数据库</em>的分类问题。数据最初是从麦迪逊的威斯康星大学医院收集的。</p><p id="4fb3" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">数据集的性质是多变量的，即有几个输入参数将用于二进制分类成两类，<em class="ky">良性</em>(未检测到)或<em class="ky">恶性</em>(检测到)。</p><p id="4d08" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">让我们训练我们的模型来准确预测这些数据。</p><p id="c278" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">我们将首先导入该任务所需的库。</p><pre class="lf lg lh li fd nf mn ng nh aw ni bi"><span id="ece1" class="nj iy hi mn b fi nk nl l nm nn">import sklearn.datasets</span><span id="553d" class="nj iy hi mn b fi no nl l nm nn">import numpy as np</span><span id="0908" class="nj iy hi mn b fi no nl l nm nn">import seaborn as sns</span><span id="a963" class="nj iy hi mn b fi no nl l nm nn">import pandas as pd</span><span id="8a9e" class="nj iy hi mn b fi no nl l nm nn">from sklearn.model_selection import train_test_split</span></pre><p id="580d" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">接下来，我们将从<code class="du mk ml mm mn b">sklearn.datasets</code>加载这些数据。两个变量X和Y (NumPy数组)将用于存储输入值及其相应的<em class="ky">基础事实</em>(真实分类值)。</p><pre class="lf lg lh li fd nf mn ng nh aw ni bi"><span id="bf37" class="nj iy hi mn b fi nk nl l nm nn">breast_cancer = sklearn.datasets.load_breast_cancer()</span><span id="137a" class="nj iy hi mn b fi no nl l nm nn">X = breast_cancer.data</span><span id="a101" class="nj iy hi mn b fi no nl l nm nn">Y = breast_cancer.target</span></pre><p id="9c86" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">我们可以使用<code class="du mk ml mm mn b">pandas.Dataframe</code>以表格的方式可视化我们的数据。我们可以将目标值追加到表中名为class的列下，然后查看表的前5行。</p><pre class="lf lg lh li fd nf mn ng nh aw ni bi"><span id="d738" class="nj iy hi mn b fi nk nl l nm nn">data = pd.DataFrame(breast_cancer.data, columns = breast_cancer.feature_names)</span><span id="bcff" class="nj iy hi mn b fi no nl l nm nn">data['class'] = breast_cancer.target</span><span id="cdd5" class="nj iy hi mn b fi no nl l nm nn">data.head()</span></pre><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es np"><img src="../Images/0e21d9098fc9f403848e2f3bc0ee5f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xLRKxW0xmOZmaVLmT9yq3g.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">按作者分类的表格</figcaption></figure><p id="e4fa" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">我们不想对我们的全部数据进行训练，相反，我们会忽略一些点，我们的模型只有在完成训练后才会看到这些点。这被称为<em class="ky">评估</em>数据，将作为我们模型的测试，看看它如何实际预测给定的新样本。</p><p id="1eed" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">我们可以使用来自<code class="du mk ml mm mn b">sklearn </code>的<code class="du mk ml mm mn b">train_test_split</code>来帮助我们拆分数据。</p><pre class="lf lg lh li fd nf mn ng nh aw ni bi"><span id="b1c4" class="nj iy hi mn b fi nk nl l nm nn">X_train, X_test, Y_train, Y_test = train_test_split(X,Y, test_size = 0.05, stratify = Y, random_state = 1)</span></pre><p id="bf8f" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">我们将X(输入)和标签传递给函数。此外，我们指定了几个参数。</p><ul class=""><li id="82cd" class="lv lw hi jr b js kz jv la jy lx kc ly kg lz kk ma mb mc md bi translated"><code class="du mk ml mm mn b">test_size </code>将决定测试数据与我们整个数据集相比的大小。</li><li id="30b1" class="lv lw hi jr b js me jv mf jy mg kc mh kg mi kk ma mb mc md bi translated"><code class="du mk ml mm mn b">stratify = Y</code>确保Y的分布在训练和测试数据集中保持相等。我们不想在所有Y都等于1的情况下进行训练，然后传递一个正确输出为0的样本。</li><li id="92d1" class="lv lw hi jr b js me jv mf jy mg kc mh kg mi kk ma mb mc md bi translated"><code class="du mk ml mm mn b">random_state = 1</code>确保结果的重现性。每次调用该函数时，将返回具有相同样本的相同除法。</li></ul><p id="e24b" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">让我们打印出我们创建的所有数据集的大小。</p><pre class="lf lg lh li fd nf mn ng nh aw ni bi"><span id="965a" class="nj iy hi mn b fi nk nl l nm nn">print(X_train.shape, Y_train.shape, X_test.shape, Y_test.shape)</span><span id="8f5b" class="nj iy hi mn b fi no nl l nm nn"><strong class="mn hj">Output:</strong> <br/>(540, 30) (540,) (29, 30) (29,)</span></pre><p id="86fd" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">我们的训练数据有540个不同的样本，30个不同的输入参数。相应的，<code class="du mk ml mm mn b">X_train</code>中每个样本有540个不同的真标签。测试数据集的大小是29而不是540。</p><p id="97c2" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">好了，现在我们已经处理并准备好了用于训练的数据，让我们为我们的感知器模型构建一个类，它将训练数据作为输入来实现我们上面讨论的整个管道。</p><p id="365d" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">在这里写类的一个旁注。在深度学习中，将网络的整个结构集成到单个类中是一种很好的做法，我们可以实例化并调用我们的训练数据。虽然这需要程序员付出更多的努力，但将网络的全部功能捆绑到单个对象中，可以很容易地实例化、运行训练循环和预测任何给定的数据。此外，与我们将孤立的函数放在周围相比，调试的过程也简化了。当我们开始使用像<em class="ky"> PyTorch </em>这样的流行库时，这种编写整洁和结构化代码的过程就有了回报，在这些库中，我们只需一行代码就可以轻松调用整个预先训练好的网络，并从父类继承构建我们自己的网络。</p><p id="96ca" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">这是我们的感知器类和学习算法的实现。</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="nq nr l"/></div></figure><p id="2ac4" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">我们的<code class="du mk ml mm mn b">__init__ </code>函数将两个参数<code class="du mk ml mm mn b">self.w</code>和<code class="du mk ml mm mn b">self.b</code>初始化为<em class="ky">无</em>。这些将被训练在我们的数据集上进行预测。对于具有<em class="ky"> n </em>个参数的每个样本，<code class="du mk ml mm mn b">model</code>函数使用<code class="du mk ml mm mn b">self.w</code>和<code class="du mk ml mm mn b">self.b</code>返回预测。<code class="du mk ml mm mn b">predict </code>函数帮助我们为整个数据中的每个样本调用<code class="du mk ml mm mn b">model </code>函数，并将结果存储在一个将被返回的列表中。</p><p id="2f38" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated"><code class="du mk ml mm mn b">train </code>函数是我们实现算法的地方。首先，我们需要确保<code class="du mk ml mm mn b">self.w</code>的大小与我们预测所需的参数或属性的数量相同(向量的大小必须相同)。我们初始化另外两个列表，一个存储我们得到的所有精度值，另一个存储我们在更新后得到的所有不同的权重。对于我们指定的<code class="du mk ml mm mn b">epochs </code>的数量，我们将遍历每个样本(x)及其对应的标签并进行更新。在我们传递数据一次后，我们将使用来自<code class="du mk ml mm mn b">sklearn</code>的<code class="du mk ml mm mn b">accuracy_score </code>计算精度，并将其添加到我们的精度列表中。此时的权重也存储在权重矩阵中。</p><p id="e564" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">保持最大准确度的连续计数，并且每当超过最大准确度时，存储该更新的权重和准确度。在所有时期完成后，最佳值被分配给权重。还可以绘制精度列表，以便进一步了解。</p><p id="a0e7" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">为了对我们现有的数据进行训练，让我们将它的类型改为NumPy数组。然后我们可以实例化这个类，并对我们的数据调用<code class="du mk ml mm mn b">train </code>函数。在我们的训练完成后，我们将对测试数据进行预测，并计算准确性。</p><pre class="lf lg lh li fd nf mn ng nh aw ni bi"><span id="7d9b" class="nj iy hi mn b fi nk nl l nm nn">X_train_np = X_train.to_numpy()</span><span id="a1ce" class="nj iy hi mn b fi no nl l nm nn">X_test_np = X_test.to_numpy()</span><span id="b3da" class="nj iy hi mn b fi no nl l nm nn">percep_model = Perceptron()</span><span id="7be5" class="nj iy hi mn b fi no nl l nm nn">percep_model.train(X_train_np,Y_train,epochs = 200,lr =0.5)</span><span id="fbc6" class="nj iy hi mn b fi no nl l nm nn">y_prediction = percep_model.predict(X_test_np)</span><span id="c24e" class="nj iy hi mn b fi no nl l nm nn">print('Accuracy on test data is',accuracy_score(y_prediction,Y_test))</span></pre><p id="2686" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">执行这段代码，我们得到以下输出和绘图。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es ns"><img src="../Images/4f427cfa19514ee365fc2ab53b2af404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*Vb8vZVVU-B9ZLPJ7uDaPfw.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">按作者分类的图表</figcaption></figure><pre class="lf lg lh li fd nf mn ng nh aw ni bi"><span id="cc92" class="nj iy hi mn b fi nk nl l nm nn"><strong class="mn hj">Output:</strong><br/>max accuracy occurs at epoch value equal to 185 and is equal to  0.9203703703703704</span><span id="13a7" class="nj iy hi mn b fi no nl l nm nn">Accuracy on test data is 0.896551724137931</span></pre><p id="d7b8" class="pw-post-body-paragraph jp jq hi jr b js kz ij ju jv la im jx jy lb ka kb kc lc ke kf kg ld ki kj kk hb bi translated">至此，我们结束了感知器模型的实现。我们已经看到了如何导入外部数据集，并使用<em class="ky"> Pandas </em>的基础知识来可视化它。在创建了训练和测试数据集之后，我们编写了一个类来实现整个训练管道。在以后的文章中，我们将在讨论感知器模型的一些局限性之后，介绍<em class="ky"> Sigmoid </em>神经元。我们还将从组合几个神经元来形成一个完整的<em class="ky">神经网络</em>开始，并深入研究更复杂和有效的学习算法。在那之前，快乐训练！</p><h2 id="ce43" class="nj iy hi bd iz nt nu nv jd nw nx ny jh jy nz oa jj kc ob oc jl kg od oe jn of bi translated">引文(<em class="og">乳腺癌威斯康星数据集</em>)</h2><ol class=""><li id="3f7b" class="lv lw hi jr b js jt jv jw jy oh kc oi kg oj kk ok mb mc md bi translated">O.L. Mangasarian和W. H. Wolberg:“通过线性<br/>规划进行癌症诊断”，《暹罗新闻》，第23卷，第5期，1990年9月，第1页&amp;第18页。</li><li id="a07e" class="lv lw hi jr b js me jv mf jy mg kc mh kg mi kk ok mb mc md bi translated">William H. Wolberg和O.L. Mangasarian:“用于乳腺细胞学医疗诊断的多表面<br/>模式分离方法”，<br/>美国国家科学院学报，第87卷，<br/>1990年12月，第9193–9196页。</li><li id="4e54" class="lv lw hi jr b js me jv mf jy mg kc mh kg mi kk ok mb mc md bi translated">O.L. Mangasarian、R. Setiono和W.H. Wolberg:“通过线性规划的模式识别<br/>:理论和在医学诊断中的应用”，<br/>《大规模数值优化》，Thomas F. Coleman和<br/> Li编辑，SIAM Publications，费城，1990年，第22-30页。</li><li id="8bf4" class="lv lw hi jr b js me jv mf jy mg kc mh kg mi kk ok mb mc md bi translated">K.P. Bennett &amp; O. L. Mangasarian:“鲁棒线性规划<br/>两个线性不可分集合的判别”，最优化方法<br/>与软件1，1992，23–34(戈登&amp;违约科学出版社)。</li></ol></div></div>    
</body>
</html>