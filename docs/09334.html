<html>
<head>
<title>Immutable objects in C# 9</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C# 9中的不可变对象</h1>
<blockquote>原文：<a href="https://medium.com/codex/immutable-objects-in-c-9-4b934e7755a7?source=collection_archive---------2-----------------------#2022-10-13">https://medium.com/codex/immutable-objects-in-c-9-4b934e7755a7?source=collection_archive---------2-----------------------#2022-10-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b503" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有些情况下，我们希望使用不可变的对象，而不是可变的对象。不可变对象是线程安全的，但另一方面，在许多情况下，它们会导致性能问题(尤其是在GUI应用程序中)。每个开发人员日常使用的最流行的不可变对象是<em class="jd">字符串</em>。</p><h2 id="79b3" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">C#中的不变性:</h2><p id="d946" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">一般来说，在C#中，不可变性是需要付出代价的，因为在默认情况下，它是一种主要可变的语言。如果我们想选择不变性，我们可以为对象的属性设置一些像只读或非设置方法这样的结构。</p><p id="a2ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es ke"><img src="../Images/e165cf36b8718a15a73a1754b9c16669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*i9c6vKBdwHEtXi8Q9f3t0A.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">C# 8中的不可变类</figcaption></figure><p id="728d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们不能使用<a class="ae kq" href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers" rel="noopener ugc nofollow" target="_blank">对象初始化器</a>语法。这将迫使我们使用长构造函数，增加类型的样板代码的成本。“更改”对象的属性可以通过创建一个新方法来完成，该方法返回一个新实例，其中包含对属性的所需更改。创建一个新方法需要我们维护更多的代码。基本上，这意味着我们必须在易用性和不变性之间做出选择。</p><h2 id="c241" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">C# 9中的新特性:</h2><p id="811e" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated"><strong class="ih hj">记录:</strong></p><blockquote class="kr ks kt"><p id="a5c6" class="if ig jd ih b ii ij ik il im in io ip ku ir is it kv iv iw ix kw iz ja jb jc hb bi translated">C# 9引入了<a class="ae kq" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record" rel="noopener ugc nofollow" target="_blank"> <em class="hi">记录</em> </a>，这是一个新的引用类型，你可以创建它来代替类或结构。记录与类的区别在于记录类型使用基于值的等式<em class="hi"/></p></blockquote><p id="00c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，记录是不可变的，所以如果我们想要创建一个不可变的对象，我们只需要将它声明为记录。这可以在一行代码中完成，如下例所示:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es kx"><img src="../Images/20d15d29853ae8d4a267896d626dddd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*t6O-zGfxKbCon6R1FVoqLA.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">记录定义</figcaption></figure><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ky"><img src="../Images/0732cb4583655ae5c36a9f2116a77208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s7V8B-ueZWQvsZVM-kuXuQ.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">创建员工记录，并尝试更改其属性失败</figcaption></figure><p id="fd7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“改变”不可变记录的属性可以通过<code class="du ld le lf lg b">with</code>表达式来完成。<code class="du ld le lf lg b"><a class="ae kq" href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/with-expression" rel="noopener ugc nofollow" target="_blank">With</a></code>生成其操作数的副本，并修改指定的属性和字段:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es lh"><img src="../Images/e491ab5a1384d4378aade9607061b18a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*UpFdEAW8RkqmOU7NbGKcHQ.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">通过创建具有不同名称属性值的新实例来“更改”记录值</figcaption></figure><p id="f691" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记录也可能是可变的。要将记录从不可变类型转换为可变类型，我们需要执行以下操作:</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es li"><img src="../Images/02e43f3e663ee7839d7e8d7fb7ce77a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ltemBR9d9Jbe-DL1Knkxg.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">可变记录</figcaption></figure><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lj"><img src="../Images/5f3f9be721bbd23de3c334ef4aae9e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGpB1djyqgzcV7yaY1O1LA.png"/></div></div></figure><p id="441b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">初始化:</strong></p><p id="fc26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Init属性很像setters，但是它们只能在对象的构造阶段使用。<em class="jd"> Init属性</em>，意味着它们可以在构造函数中设置或者使用属性初始化器。这意味着对象的不可变属性可以参与对象初始化器，从而消除了类型中所有构造函数样板文件的需要。</p><p id="92cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，你可以看到我们有一个带有<em class="jd"> init properties </em>的<em class="jd"> Department </em>类，我们不必创建复杂的构造函数，因为我们可以使用<a class="ae kq" href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers" rel="noopener ugc nofollow" target="_blank">对象初始化器</a>语法。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lk"><img src="../Images/6cf9b9088b8d765c9135208e6daf84ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8tvl5N4pRUSl5euECqz4mA.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">具有<strong class="bd jg"> init </strong>属性的类</figcaption></figure><p id="dc80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们试图在对象创建后更改<em class="jd"> init属性</em>时，我们会失败，因为我们已经脱离了对象的构建阶段。</p><p id="25cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样我们就得到一个完全不可变的对象，或者只有一些不可变的属性，这取决于我们的目的。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ll"><img src="../Images/34b58c2e6abac639bbbaf3c34e9d6d95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwmFszyYg2jfWMCYLkux7g.png"/></div></div></figure></div></div>    
</body>
</html>