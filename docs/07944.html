<html>
<head>
<title>How to Setup WebSockets like a Pro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何像专业人士一样设置WebSockets</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-setup-websockets-like-a-pro-8fcf920353d9?source=collection_archive---------5-----------------------#2022-07-06">https://medium.com/codex/how-to-setup-websockets-like-a-pro-8fcf920353d9?source=collection_archive---------5-----------------------#2022-07-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/53e8ed26c00069e775d8542dd42bb174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6XxE0XKss8AjzkvY4RsvNA.png"/></div></div></figure><p id="4c37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我最近才开始大规模使用WebSockets，有很多事情是我在做小项目时没有考虑到的。在这篇文章中，我将分享我所学到的一些东西。</p><p id="eddb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">什么是网络套接字🤔</p><p id="5cf6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您正在开发一个应用程序，并且想要实时发送数据或者跟踪实时发生的变化，那么您将需要使用WebSockets</p><p id="255e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">WebSocket是一个单一的TCP(传输连接协议),支持节点之间的全双工通信。</p><p id="277c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们来分解一下🤓</p><p id="be63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TCP是数据在互联网上传输的方式；全双工通信意味着双方可以同时传输和接收数据；节点可以是连接到网络的任何设备</p><p id="69c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">按照<a class="ae jo" href="https://socket.io/docs/v4/" rel="noopener ugc nofollow" target="_blank"> Socket.io </a>基本文档或任何其他WebSocket JS库，在Node.js中设置WebSockets可以非常快速简单地完成</p><p id="5f80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这很好，但是在处理更大的项目时，您可能需要考虑运行认证中间件、其他中间件、处理自定义错误和伸缩，这是我将在本文中向您展示的。</p><p id="53bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将用<a class="ae jo" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> Socket.io </a>来解释。我们首先要看的是在您的套接字连接上运行中间件。</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jp"><img src="../Images/df737b5bf705da9a4a6e634bbfba12a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*5YIuWz2rDlEy5KC18XD-Iw.jpeg"/></div></figure><p id="a161" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">认证&amp;定制中间件🕵️ </strong></p><p id="e4c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以通过这种方式向您的套接字连接添加中间件</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="cd1b" class="jz ka hi jv b fi kb kc l kd ke">io.use((socket, next) =&gt; {<br/>    // Middleware function<br/>    return require("./middleware/auth")(socket, next);<br/>})</span></pre><p id="1cc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在套接字实例上，您可以访问随连接传递的任何身份验证凭证或查询</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="531d" class="jz ka hi jv b fi kb kc l kd ke">// Client<br/>const socket = io.connect("ws://localhost:4000", {<br/>    auth:{<br/>        token: `${token}`<br/>    },<br/>    query:{<br/>        field: `${value}`<br/>    }<br/>});</span></pre><p id="7c85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要访问这些信息，服务器端的中间件函数应该看起来有点像这样。您还可以将经过身份验证的用户的信息附加到套接字上</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="e749" class="jz ka hi jv b fi kb kc l kd ke">async function auth(socket, next) {<br/>    try {<br/>        const { token } = socket.handshake.auth;<br/>        const { field } = socket.handshake.query;</span><span id="0106" class="jz ka hi jv b fi kf kc l kd ke">        if (!token) return next(new Error("No token provided"));<br/>        if (!field) return next(new Error("No field provided"));<br/> <br/>        const user = await decode(token)<br/>        socket.$user = user</span><span id="b26d" class="jz ka hi jv b fi kf kc l kd ke">   } catch (error) {<br/>        return next(error);<br/>   }<br/>}</span></pre><p id="d2e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了捕捉中间件中的任何错误，客户端应该监听“connection_error”</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="45fb" class="jz ka hi jv b fi kb kc l kd ke">// Client<br/>socket.on("connect_error", function (error) {<br/>    console.log(error);<br/>});</span></pre><p id="619f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦当前用户已经附加到“套接字”上，就可以在连接中使用它来执行自定义检查和逻辑</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="bb62" class="jz ka hi jv b fi kb kc l kd ke">io.use((socket, next) =&gt; {<br/>    // Middleware function<br/>    return require("./middleware/auth")(socket, next);<br/>})<br/>.on("connection", (socket) =&gt; {<br/>    console.log(socket.$user)<br/>})</span></pre><p id="d761" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">接球&amp;投掷失误⚠️ </strong></p><p id="cd2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于一些套接字事件，您可能需要查询数据库或调用外部API或运行一些复杂的逻辑；这些事情中的任何一个都可能导致错误</p><p id="6f7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与其让错误导致停机，不如充分捕捉它并向客户机发送一条包含相关信息的消息</p><p id="a8e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实现这一点的一个简单方法是在try/catch块中rap所有的套接字事件，并发出一个错误(如果有的话)</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="3c20" class="jz ka hi jv b fi kb kc l kd ke">io.use((socket, next) =&gt; {<br/>    // Middleware function<br/>    return require("./middleware/auth")(socket, next);<br/>})<br/>.on("connection", (socket) =&gt; {<br/>    try{<br/>        // Emit and listener events<br/>    }catch{<br/>        socket.emit("error", error);<br/>    }<br/>})</span></pre><p id="0f9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个解决方案还为您提供了抛出自定义错误并捕获它们的空间</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="d790" class="jz ka hi jv b fi kb kc l kd ke">if (userNotAllowed) throw new Error("Access blocked")</span></pre><p id="299d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在客户端处理它的方法是这样的</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="ef3d" class="jz ka hi jv b fi kb kc l kd ke">socket.on("error", function (error) {<br/>    console.log(error);<br/>});</span></pre><p id="f4c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">回调🙋‍♂️ </strong></p><p id="6bd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回调允许您调用服务器上的客户端函数；我知道这很疯狂🤓</p><p id="206b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以这样想，服务器决定何时在客户端调用回调函数</p><p id="e983" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个很好的用例是当你加入一个房间或发送一条消息时；您可以使用它在客户端确认事件已成功处理</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="930a" class="jz ka hi jv b fi kb kc l kd ke">// Client<br/>socket.emit("send-msg", { sender, msg, recipient }, (data) =&gt; {<br/>    if(data.success) console.log("message sent succesfully")<br/>    else console.log("message not sent")<br/>})</span></pre><p id="aee4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回调函数不是自动调用的，而是服务器调用的</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="5b8e" class="jz ka hi jv b fi kb kc l kd ke">// Server<br/>socket.on("message", (payload, cb) =&gt; {<br/>    socket.to(payload.recipient).emit("new-msg", payload)<br/>    cb({ success: true })<br/>})</span></pre><p id="c683" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种实现意味着当消息被发送时，确认消息被记录到客户机上的控制台</p><p id="9153" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回调函数应该总是最后一个参数</p><p id="fb86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在多个服务器上扩展&amp;适配器🚀🚀</strong></p><p id="cd5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如今，水平扩展变得越来越普遍，同一个应用程序的多个实例同时运行，并由一个负载平衡器负责</p><p id="145a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">WebSockets的水平扩展不像简单地增加新的服务器实例那么简单</p><p id="f83c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是因为当事件发送到服务器时，信息不会在所有服务器实例间传播</p><p id="a2b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，您需要使用一个套接字适配器</p><p id="daf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其工作原理是，当一个事件被发送到一个服务器实例时，它被发送到一个适配器，该适配器将数据转发到一个数据库，然后该数据库被转发到所有服务器实例</p><figure class="jq jr js jt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kg"><img src="../Images/d6b562a7dc75a8620fb51ad43c9ff2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ap8f9kScsjC_1n1J.png"/></div></div><figcaption class="kh ki et er es kj kk bd b be z dx translated">来源:<a class="ae jo" href="https://socket.io/assets/images/emitter-e18de5957df3bbdcb7425a405af5b823.png" rel="noopener ugc nofollow" target="_blank">https://socket . io/assets/images/emitter-e18de 5957 df 3 bbd CB 7425 a 405 af5b 823 . png</a></figcaption></figure><p id="3a1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个如何使用<a class="ae jo" href="https://socket.io/docs/v4/mongo-adapter/" rel="noopener ugc nofollow" target="_blank"> Socket.io Mongo适配器</a>和MongoDB作为数据库的例子</p><figure class="jq jr js jt fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="a55b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">添加适配器后，您还需要在负载平衡器上启用粘性会话，并减少连接超时</p><p id="b4ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您使用的是AWS ALB，您可以将默认超时从60秒更改为稍长一点的值；然后在目标组上启用粘性会话</p><p id="e35f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">带有Socket.io 🧑‍的管理用户界面💼</strong></p><p id="e0bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Socket.io可能是一件非常复杂的事情，能够监控正在发生的事情是一个巨大的优势</p><p id="b7ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只需添加几行代码，您就可以将Socket.io实例连接到官方的<a class="ae jo" href="https://admin.socket.io/" rel="noopener ugc nofollow" target="_blank">管理控制台仪表板，</a>在那里您可以监视正在发生的事情并拥有完全的控制权</p><p id="50d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还可以设置一个接受用户名和bcrypt加密密码的基本身份验证类型，或者您可以使用JWT或其他选项执行更复杂的身份验证</p><p id="9a4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里查看<a class="ae jo" href="https://socket.io/docs/v4/admin-ui/" rel="noopener ugc nofollow" target="_blank">代码示例</a></p><p id="ede5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结论</strong></p><p id="fe55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想我越来越擅长写中型文章了😅😅💃💃</p><p id="a0fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">WebSockets如果设置不当，将来可能会导致严重的问题</p><p id="adb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记下本文中的所有内容，这将为您节省大量调试时间。我是根据🥲的经验说这番话的</p><figure class="jq jr js jt fd ij er es paragraph-image"><div class="er es jp"><img src="../Images/812e43308a5974464f9cb3a26310493e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*evCqHMc_Tr9ELbkk7lf0Og.jpeg"/></div></figure><p id="7db9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">伸出手来给我，<a class="ae jo" href="https://toluolatubosun.com/contact" rel="noopener ugc nofollow" target="_blank">这里</a>还有一个驼子time🖖</p></div></div>    
</body>
</html>