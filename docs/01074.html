<html>
<head>
<title>Poker Face</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扑克脸</h1>
<blockquote>原文：<a href="https://medium.com/codex/poker-face-9503e7901e57?source=collection_archive---------17-----------------------#2021-04-02">https://medium.com/codex/poker-face-9503e7901e57?source=collection_archive---------17-----------------------#2021-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/0b4cabf68513c29376cdae89be5b9b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TcyLk_slFKcDpmjX.jpg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">木星图像/Stockbyte/Getty图像</figcaption></figure><div class=""/><div class=""><h2 id="a2db" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">排序算法:插入排序JavaScript</h2></div><blockquote class="jm jn jo"><p id="ac4e" class="jp jq jr js b jt ju iy jv jw jx jb jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="js hy">插入排序</strong> <a class="ae km" href="https://en.wikipedia.org/wiki/Iteration" rel="noopener ugc nofollow" target="_blank">迭代</a>，每次重复消耗一个输入元素，增长一个排序后的输出列表。在每次迭代中，插入排序从输入数据中删除一个元素，找到它在排序列表中的位置，并将其插入到那里。它重复进行，直到没有输入元素。</p><p id="e66c" class="jp jq jr js b jt ju iy jv jw jx jb jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">排序通常是就地完成的，方法是遍历数组，在数组后面增加排序后的列表。在每个数组位置，它将根据排序列表中的最大值检查那里的值(在检查的前一个数组位置中，最大值恰好在它的旁边)。如果更大，它会将元素留在原位，并移动到下一个元素。如果较小，它会在排序列表中找到正确的位置。(<a class="ae km" href="https://en.wikipedia.org/wiki/Insertion_sort" rel="noopener ugc nofollow" target="_blank">维基百科</a>)</p></blockquote><p id="a53f" class="pw-post-body-paragraph jp jq hx js b jt ju iy jv jw jx jb jy kn ka kb kc ko ke kf kg kp ki kj kk kl hb bi translated">插入排序类似于大多数人如何安排一手扑克牌(或者去钓鱼，如果你喜欢)。当你抽一张新卡时，它的价值可能会比你手里的一些牌小。因此，你将新卡片与每张已分类的卡片进行比较，直到你在已分类的卡片中找到合适的位置。</p><figure class="kr ks kt ku fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kq"><img src="../Images/45b9a0848b6653e15ff790d239c2d89c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hLSVESItGndxTfIf.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae km" href="https://www.w3resource.com/php-exercises/searching-and-sorting-algorithm/searching-and-sorting-algorithm-exercise-3.php" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kv">图示展示:插入排序</strong> </a></figcaption></figure><p id="91ac" class="pw-post-body-paragraph jp jq hx js b jt ju iy jv jw jx jb jy kn ka kb kc ko ke kf kg kp ki kj kk kl hb bi translated">插入排序将数组分成2个子部分:排序后的<strong class="js hy">元素(在前面)和剩余的<strong class="js hy">未排序的</strong>元素。在第一遍开始时，<strong class="js hy">排序的</strong>子段只是第一个元素。因此，我们从第二个元素(<code class="du kw kx ky kz b">array[i], i = 1</code>)开始外部循环，这是第一个<strong class="js hy">未排序的</strong>元素。</strong></p><p id="5ead" class="pw-post-body-paragraph jp jq hx js b jt ju iy jv jw jx jb jy kn ka kb kc ko ke kf kg kp ki kj kk kl hb bi translated">我们将第一个<strong class="js hy">未排序的</strong>元素分配给一个变量(<code class="du kw kx ky kz b">currentValue = array[i]</code>)来保存该元素，同时我们进行比较并可能交换它。</p><p id="3636" class="pw-post-body-paragraph jp jq hx js b jt ju iy jv jw jx jb jy kn ka kb kc ko ke kf kg kp ki kj kk kl hb bi translated">我们使用一个内部循环来比较第一个<strong class="js hy">未排序的</strong>元素(<code class="du kw kx ky kz b">currentValue</code>)和它左边的元素(<code class="du kw kx ky kz b">array[j], j = i — 1</code>)。该元素是<strong class="js hy">排序的</strong>子节中最大的元素。</p><blockquote class="jm jn jo"><p id="51a8" class="jp jq jr js b jt ju iy jv jw jx jb jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在第一遍中，最大的<strong class="js hy">排序的</strong>元素是第一个元素<code class="du kw kx ky kz b">(array[0], j = 1 — 1)</code>。</p></blockquote><p id="a035" class="pw-post-body-paragraph jp jq hx js b jt ju iy jv jw jx jb jy kn ka kb kc ko ke kf kg kp ki kj kk kl hb bi translated">如果<code class="du kw kx ky kz b">array[j]</code>大于<code class="du kw kx ky kz b">currentValue</code>，我们将<code class="du kw kx ky kz b">array[j]</code>赋给它右边的元素(<code class="du kw kx ky kz b">arr[j + 1]</code>)。现在，<code class="du kw kx ky kz b">array[j]</code>和<code class="du kw kx ky kz b">array[j + 1]</code>具有相同的值。</p><blockquote class="jm jn jo"><p id="b9e6" class="jp jq jr js b jt ju iy jv jw jx jb jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在第一遍中，第一个和第二个元素现在具有相同的值，即第一个元素的值<code class="du kw kx ky kz b">(array[0])</code>。幸运的是，我们用变量<code class="du kw kx ky kz b">currentValue</code>保存了第二个元素<code class="du kw kx ky kz b">(array[1])</code>的值，因为我们刚刚替换了它。</p></blockquote><p id="fd2a" class="pw-post-body-paragraph jp jq hx js b jt ju iy jv jw jx jb jy kn ka kb kc ko ke kf kg kp ki kj kk kl hb bi translated">当<code class="du kw kx ky kz b">j &lt; 0</code>或<code class="du kw kx ky kz b">array[j]</code>不大于<code class="du kw kx ky kz b">currentValue</code>时，内环<strong class="js hy">减少</strong> <code class="du kw kx ky kz b">j</code>并断开。否则，我们继续将排序后的<strong class="js hy">元素向右移动。</strong></p><blockquote class="jm jn jo"><p id="cca9" class="jp jq jr js b jt ju iy jv jw jx jb jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在第一次内部循环中，<code class="du kw kx ky kz b">j</code>从0递减到-1，因此我们中断内部循环。</p></blockquote><p id="aeea" class="pw-post-body-paragraph jp jq hx js b jt ju iy jv jw jx jb jy kn ka kb kc ko ke kf kg kp ki kj kk kl hb bi translated">现在，我们将<code class="du kw kx ky kz b">currentValue</code>放置在<strong class="js hy">排序的</strong>子部分的适当位置。</p><blockquote class="jm jn jo"><p id="ea23" class="jp jq jr js b jt ju iy jv jw jx jb jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在第一遍中，我们用第二个元素<code class="du kw kx ky kz b">(array[0] = currentValue)</code>替换第一个元素。</p></blockquote><p id="fa24" class="pw-post-body-paragraph jp jq hx js b jt ju iy jv jw jx jb jy kn ka kb kc ko ke kf kg kp ki kj kk kl hb bi translated">现在，<strong class="js hy">已排序的</strong>子段包含2个元素，而<strong class="js hy">未排序的</strong>子段包含少一个元素。</p><p id="6b1e" class="pw-post-body-paragraph jp jq hx js b jt ju iy jv jw jx jb jy kn ka kb kc ko ke kf kg kp ki kj kk kl hb bi translated">我们继续在外循环中递增<code class="du kw kx ky kz b">i</code>以抓取第一个<strong class="js hy">未排序的</strong>元素，将其与<strong class="js hy">排序的</strong>元素进行比较，并将其放入<strong class="js hy">排序的</strong>子节中的正确位置，直到数组排序。</p><figure class="kr ks kt ku fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es la"><img src="../Images/b33ff449c70d9beffcb3f562fd0d0ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qrz6ScGEjqh6CDDUuF4A6g.gif"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae km" href="https://visualgo.net/en/sorting?slide=9" rel="noopener ugc nofollow" target="_blank">visualgo.net—插入排序</a></figcaption></figure><h2 id="bf82" class="lb lc hx bd kv ld le lf lg lh li lj lk kn ll lm ln ko lo lp lq kp lr ls lt lu bi translated">提高赌注</h2><p id="bbb1" class="pw-post-body-paragraph jp jq hx js b jt lv iy jv jw lw jb jy kn lx kb kc ko ly kf kg kp lz kj kk kl hb bi translated">JavaScript示例</p><figure class="kr ks kt ku fd hk"><div class="bz dy l di"><div class="ma mb l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae km" href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/" rel="noopener ugc nofollow" target="_blank">插入排序</a></figcaption></figure><h2 id="7c99" class="lb lc hx bd kv ld le lf lg lh li lj lk kn ll lm ln ko lo lp lq kp lr ls lt lu bi translated">疲乏到极点</h2><p id="f869" class="pw-post-body-paragraph jp jq hx js b jt lv iy jv jw lw jb jy kn lx kb kc ko ly kf kg kp lz kj kk kl hb bi translated">样本问题</p><ul class=""><li id="8a6c" class="mc md hx js b jt ju jw jx kn me ko mf kp mg kl mh mi mj mk bi translated"><a class="ae km" href="https://leetcode.com/problems/insertion-sort-list/" rel="noopener ugc nofollow" target="_blank">插入排序列表</a></li><li id="c410" class="mc md hx js b jt ml jw mm kn mn ko mo kp mp kl mh mi mj mk bi translated"><a class="ae km" href="https://www.hackerrank.com/challenges/insertionsort1/problem" rel="noopener ugc nofollow" target="_blank">插入分类—第1部分</a></li><li id="61e1" class="mc md hx js b jt ml jw mm kn mn ko mo kp mp kl mh mi mj mk bi translated"><a class="ae km" href="https://www.hackerrank.com/challenges/insertionsort2/problem" rel="noopener ugc nofollow" target="_blank">插入分类—第二部分</a></li></ul><blockquote class="jm jn jo"><p id="e9e8" class="jp jq jr js b jt ju iy jv jw jx jb jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">📚资源👀</p><p id="04ec" class="jp jq jr js b jt ju iy jv jw jx jb jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><a class="ae km" href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/" rel="noopener ugc nofollow" target="_blank"> <em class="hx"> Udemy — JavaScript算法与数据结构大师班</em> </a></p><p id="9844" class="jp jq jr js b jt ju iy jv jw jx jb jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">【visualgo.net T4】插入排序</p><p id="dd16" class="jp jq jr js b jt ju iy jv jw jx jb jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><a class="ae km" href="https://www.geeksforgeeks.org/insertion-sort/" rel="noopener ugc nofollow" target="_blank">插入排序</a></p></blockquote></div></div>    
</body>
</html>