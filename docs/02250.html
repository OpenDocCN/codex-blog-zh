<html>
<head>
<title>Case Study: Web Service call is timed out when multiple instances are called in parallel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">案例研究:当并行调用多个实例时，Web服务调用超时</h1>
<blockquote>原文：<a href="https://medium.com/codex/web-service-is-timing-out-when-multiple-instances-is-called-in-parallel-361454ad4d6d?source=collection_archive---------15-----------------------#2021-07-09">https://medium.com/codex/web-service-is-timing-out-when-multiple-instances-is-called-in-parallel-361454ad4d6d?source=collection_archive---------15-----------------------#2021-07-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b825" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我遇到了一种情况，当并行调用多个实例时，ASP.NET Web服务(ASMX)超时。我想分享我的旅行经验来解决这个问题。</p><p id="10f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从问题陈述“ASP。并行调用多个实例时，NET Web服务(ASMX)超时”。控制台应用程序，开发于。运行在服务器A上的. NET Core 2.1向服务器b上的ASP.NET Web服务发出200–300个请求。同时，20个线程使用IHttpClientFactory和System.Threading.Tasks并行向Web服务发出请求。对于20–30个请求，向服务发出请求与控制台应用程序收到响应之间的时间间隔超过100秒。当向服务连续发出请求时，它会在不到一秒的时间内返回响应。另外一条信息是，Web服务调用第三方服务作为其流程的一部分。</p><p id="3ed0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最初，我们认为以下任何一个都可能是这个问题的原因。</p><ol class=""><li id="886f" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">服务器A中的系统资源争用导致了启动请求的延迟。</li><li id="5dde" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">网络延迟了到达服务器B的请求</li><li id="e335" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">服务器B中的系统资源争用导致IIS中的性能问题</li><li id="af17" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">应用程序中的内存泄漏导致IIS工作进程挂起</li><li id="46d5" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">第三方服务需要时间来响应</li><li id="cdaa" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">Web服务无法处理多个实例</li></ol><p id="f431" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据以下足迹，在此分析的早期阶段，上述原因中的一些已从列表中删除。</p><p id="f8a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">控制台应用程序日志中记录的请求时间与服务器b的IIS日志中记录的请求时间之间没有差距。这表明服务器A中不存在系统资源问题，并且服务器A和服务器b之间没有网络延迟</p><p id="1404" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们查看了服务器B中的IIS日志和Web服务应用程序跟踪，IIS中的请求时间和服务跟踪中的服务方法启动时间之间存在巨大差距。(注意:方法开始时间记录在Web服务方法的第一行中)。这种延迟大约占请求和响应之间总时间的95%到98%。</p><p id="d164" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当IIS接收到请求的第一个字节时，它会记录请求的开始时间，并且在IIS完全接收到请求之前不会花费太多时间。当请求很大时，它将被分割成多个块。由于网络中的延迟，接收几个请求块时可能会有延迟，但第一个请求块可能会按时收到。我们检查了请求和响应的大小，它们并不大(&lt; 1000 bytes).</p><p id="6dda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">What so worth we checked the time between request and response of third-party service, it is always in sub-seconds.</p><p id="f1de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Next, We thought about the resource contention in Server B. We collected few performance counters from Server B.</p><ul class=""><li id="a39d" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated"><strong class="ih hj">处理器</strong>(所有实例— %处理器时间):进程的CPU消耗</li><li id="1b19" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated"><strong class="ih hj">内存</strong>(可用兆字节):Windows Server中的可用内存</li><li id="7e8a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated"><strong class="ih hj"> HTTP服务请求队列</strong>(CurrentQueueSize):IIS队列中的请求数</li></ul><p id="00f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在收集的性能计数器中没有发现任何问题。在这个阶段，很明显，服务器B系统资源中不存在争用，应用程序中存在内存泄漏。六个原因中有五个已经从列表中删除了。在确认系统资源没有问题之后，IIS和服务执行之间的延迟是如此奇怪。我们也没有从互联网上获得足够的信息。</p><p id="497e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从网上得到一个建议，增加工作进程可以解决这个问题。性能计数器没有显示任何问题，IIS也没有显示工作进程中的高CPU或内存问题。因此，我们认为增加工作进程数没有帮助。</p><p id="ccb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们得到了一个额外的信息，ASMX不能处理多线程(多个实例),最好将服务改为REST API。由于这将导致大量的开发工作，并需要时间来完成，我们暂时搁置这一选择，并继续寻找其他解决方案。</p><p id="47cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个阶段，唯一悬而未决的问题是ASMX Web服务不能处理多个实例，我们必须解决这个问题，而不是将其重新开发为REST API。</p><p id="1ab9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们最后一次检查了代码，有一件事让我们印象深刻(<strong class="ih hj"> enableSessionState = true </strong>)。为Web服务方法启用了会话状态，20个并行请求来自同一个应用程序。因为所有的请求都来自同一个客户端，所以有可能第一个请求持有会话锁，而其余的请求等待会话。这使得多线程进程以单线程方式运行。同样，我们知道会话状态在ASP.NET是默认启用的，我们的应用程序出于任何原因都不需要它。我们尝试禁用Web服务方法的会话状态，它真的很神奇！！！。</p><p id="1dcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结论是，即使一个未被注意到的默认设置也会对应用程序的行为产生巨大的影响。检查默认设置并根据我们的应用程序需要更改它们总是更好。我非常享受解决这个特殊案件的过程。我希望你也喜欢阅读这篇文章。如果您认为应该以不同的方式分析这个问题，或者我们遗漏了任何其他可能的原因，请随时分享您的想法。感谢你阅读这篇文章。喜欢请分享。</p></div></div>    
</body>
</html>