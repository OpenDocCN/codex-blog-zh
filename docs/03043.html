<html>
<head>
<title>Who did it better? Guava or Java?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谁做得更好？番石榴还是爪哇？</h1>
<blockquote>原文：<a href="https://medium.com/codex/who-did-it-better-guava-or-java-b7155cebeafd?source=collection_archive---------6-----------------------#2021-08-16">https://medium.com/codex/who-did-it-better-guava-or-java-b7155cebeafd?source=collection_archive---------6-----------------------#2021-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4394" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">不可变集合与集合。不可修改集合等等</h2></div><p id="8be9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Guava是最流行的Java库之一。但是它已经存在很长时间了，而且Java已经实现了许多可以与Guava中的特性相媲美的特性。现在的问题是，哪一个做得更好？</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/4f28ab19cadbe90d20bebaeb1a69282a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_C-W8KOuT5xVSg84"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">胡安·卡米洛·瓜林P 在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="79b0" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">不可变集合</h1><p id="4d41" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">Guava对Java的所有公共集合都有不可变的实现，当然还有它自己的集合。虽然Java没有为它提供接口，但它提供了两种创建不可变集合的方法:<code class="du lh li lj lk b"><a class="ae jt" href="https://docs.oracle.com/javase/9/docs/api/java/util/Collections.html#unmodifiableCollection-java.util.Collection-" rel="noopener ugc nofollow" target="_blank">Collections.unmodifiableXXX</a></code>包装现有集合，<code class="du lh li lj lk b"><a class="ae jt" href="https://docs.oracle.com/javase/9/docs/api/java/util/List.html#of--" rel="noopener ugc nofollow" target="_blank">XXX.of</a></code>创建新集合。</p><p id="980e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了简化起见，我以<code class="du lh li lj lk b">ImmutableList</code>、<code class="du lh li lj lk b">Collections.unmodifiableList</code>和<code class="du lh li lj lk b">List.of</code>为例，但同样的事情也适用于所有其他版本。</p><h2 id="925d" class="ll kl hi bd km lm ln lo kq lp lq lr ku jg ls lt kw jk lu lv ky jo lw lx la ly bi translated">额外的依赖</h2><p id="a974" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">使用Guava会给你的代码引入一个新的依赖项。依我看，这很值得。即使对于这里的例子，您选择使用Java的实现，Guava仍然提供了许多实用程序，这是值得的。</p><p id="4952" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个不同的故事是在你的公共API中包含了番石榴类。在这种情况下，你会强迫该API的每个用户使用番石榴<em class="lz">和你的特定版本</em>。您也无法将其作为依赖项删除。</p><p id="4c52" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个<em class="lz">可能</em>对你知道用户也将使用番石榴的图书馆来说是好的，但是即使在那里也应该避免。</p><h2 id="dfa1" class="ll kl hi bd km lm ln lo kq lp lq lr ku jg ls lt kw jk lu lv ky jo lw lx la ly bi translated">明确的诉说</h2><p id="ba2b" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">当你在某处看到<code class="du lh li lj lk b">ImmutableList</code>时，你知道那个值是不可变的。Java的方法则不然，它们将简单地返回一个<code class="du lh li lj lk b">List</code>。</p><p id="0d3e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种显式告诉非常有用:</p><ul class=""><li id="c0a0" class="ma mb hi iz b ja jb jd je jg mc jk md jo me js mf mg mh mi bi translated"><strong class="iz hj">在参数中:</strong>调用者被保证方法不会改变列表。另一方面，用户必须首先将他们的集合包装在一个不可变的集合中。</li><li id="8ec1" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="iz hj">返回值:</strong>调用者知道这个集合不应该被改变。这也有助于实现，因为您通常可以避免创建新的实例，只在需要时更新列表。您不必查看方法的文档来判断改变返回的集合是否合适。</li><li id="6161" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="iz hj">在字段和变量中:</strong>当阅读代码时，很明显这个字段或变量没有也不应该变异。这有助于减轻一些精神负担。它还能捕捉到“林挺时间”的一些潜在错误。</li></ul><h2 id="e80c" class="ll kl hi bd km lm ln lo kq lp lq lr ku jg ls lt kw jk lu lv ky jo lw lx la ly bi translated">较少的防御性副本</h2><p id="90af" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">为了更好地保证给定的列表在给定的上下文中不被更改，通常会创建防御性副本。“防御性副本”指的是首先创建一个给定集合的不可变版本，然后严格地对该版本进行操作。</p><p id="bda8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种做法有助于确保列表不会在不应该发生变化的时候发生变化。然而，这只会在运行时被注意到，并且与直接使用列表相比会花费一些运行时间。</p><p id="3f0c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">直接使用不可变版本作为参数可能会迫使用户创建一个不可变版本，但这也向他们表明，它可以在其他不改变列表的方法中重用。这可能会导致生成更少的副本，但肯定会导致更加清晰，因为我不需要看到实现就可以知道列表是否会发生变化。</p><h2 id="62f9" class="ll kl hi bd km lm ln lo kq lp lq lr ku jg ls lt kw jk lu lv ky jo lw lx la ly bi translated">不可变列表是真正不可变的</h2><p id="6219" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">Java的<code class="du lh li lj lk b">Collections.unmodifiableList</code>只会在集合上提供一个不可变的<strong class="iz hj">视图</strong>。这是一个重要的区别。</p><p id="ee79" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，也是最重要的，这意味着它们不是真正不可变的:如果原始实例改变了，它们也会改变。</p><p id="b42a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这也意味着他们不能像Guava的实现那样充分利用不变性。它们仍然必须包括不必要的并发检查，可能会分配不必要的空间等等。</p><p id="5d19" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些差异对于<code class="du lh li lj lk b">List.of</code>方法来说不太相关，它无论如何都会创建一个新的列表——即使使用了接受一个字符串数组的重载。然而，需要注意的是，我在任何官方文档中都没有提到这一点，所以，从技术上来说，不能保证这种情况会持续下去，或者在所有实现中都是一样的。</p><p id="93bc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而,<code class="du lh li lj lk b">ImmutableList</code>和Java的不可修改列表都不能阻止它们的元素被修改。为此，您必须创建一个深层副本。在我的研究过程中，我偶然发现了这篇漂亮的博客文章，它以一种漂亮、直观的方式概述了这些方法的不同之处。</p><h2 id="8207" class="ll kl hi bd km lm ln lo kq lp lq lr ku jg ls lt kw jk lu lv ky jo lw lx la ly bi translated">ImmutableList是一个列表</h2><p id="980c" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">这可能不是关于Guava实现的争论，而是一个重要的注意事项:<code class="du lh li lj lk b">ImmutableList</code>实现了<code class="du lh li lj lk b">List</code>接口。</p><p id="3810" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这意味着您可以在任何可以使用Java中不可修改列表的地方使用<code class="du lh li lj lk b">ImmutableList</code>的实例。</p><p id="b102" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，有一种情况需要注意:当被调用的方法使用Java方法创建防御性副本时。在这种情况下，当您传递一个<code class="du lh li lj lk b">ImmutableList</code>时，它将创建一个新的实例，而不是重用旧的实例。当提供Java的不可修改列表时，它会直接使用那个实例。</p><p id="ba72" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">反过来也是一样:<code class="du lh li lj lk b">ImmutableList.copyOf</code>不会创建一个新的实例，如果传递给它的是一个<code class="du lh li lj lk b">ImmutableList</code>的话，但是如果传递的是一个不可修改的列表，它就会创建一个新的实例。</p><p id="1d57" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实现<code class="du lh li lj lk b">List</code>接口也意味着它们有一个共同的大问题:你仍然可以调用修改集合的方法。它只会在运行时失败，而不会在编译时失败。Guava的版本更好地缓解了这一问题，因为他们主动将这些方法标记为<code class="du lh li lj lk b">deprecated</code>，这将出现在大多数编辑器中。当然，这只在使用raw <code class="du lh li lj lk b">ImmutableList</code>时有效，而当它用作<code class="du lh li lj lk b">List</code>时无效。</p><h2 id="4e8e" class="ll kl hi bd km lm ln lo kq lp lq lr ku jg ls lt kw jk lu lv ky jo lw lx la ly bi translated">裁决</h2><p id="8726" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">我相信与Java标准库方法相比，Guava的集合带来了很多价值，所以如果项目中有Guava，我会一直使用这些方法。我甚至可能会考虑为他们添加番石榴，但幸运的是番石榴有很多其他好的特性，这使得添加它变得非常容易。</p><h1 id="e3b8" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">可选择的</h1><p id="5bca" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">在Java添加可选之前，Guava添加了可选。在这种情况下，最好的比较可能是在Guava自己的文档中找到的<a class="ae jt" href="https://guava.dev/releases/19.0/api/docs/com/google/common/base/Optional.html" rel="noopener ugc nofollow" target="_blank">:</a></p><blockquote class="mo mp mq"><p id="e74d" class="ix iy lz iz b ja jb ij jc jd je im jf mr jh ji jj ms jl jm jn mt jp jq jr js hb bi translated">Java 8增加了一个新的<code class="du lh li lj lk b">Optional</code>类。这两个类非常相似，但是不兼容(它们不能共享一个公共的超类型)。<em class="hi">所有已知的差异都列在这里或用下面的相关方法列出。</em></p><p id="64fb" class="ix iy lz iz b ja jb ij jc jd je im jf mr jh ji jj ms jl jm jn mt jp jq jr js hb bi translated">-此类是可序列化的；<code class="du lh li lj lk b">java.util.Optional</code>不是。</p><p id="450d" class="ix iy lz iz b ja jb ij jc jd je im jf mr jh ji jj ms jl jm jn mt jp jq jr js hb bi translated">- <code class="du lh li lj lk b">java.util.Optional</code>有另外的方法<code class="du lh li lj lk b">ifPresent</code>、<code class="du lh li lj lk b">filter</code>、<code class="du lh li lj lk b">flatMap</code>和<code class="du lh li lj lk b">orElseThrow</code>。</p><p id="7591" class="ix iy lz iz b ja jb ij jc jd je im jf mr jh ji jj ms jl jm jn mt jp jq jr js hb bi translated">- <code class="du lh li lj lk b">java.util</code>提供原始专用版本<code class="du lh li lj lk b">OptionalInt</code>、<code class="du lh li lj lk b">OptionalLong</code>和<code class="du lh li lj lk b">OptionalDouble</code>，推荐使用；番石榴没有这些。</p><p id="6c40" class="ix iy lz iz b ja jb ij jc jd je im jf mr jh ji jj ms jl jm jn mt jp jq jr js hb bi translated">在可预见的将来，没有计划弃用该职业。然而，我们温和地建议您尽可能喜欢新的标准Java类。</p></blockquote><p id="8c47" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以根据Google自己的推荐，你应该选择Java库版本。我倾向于同意，主要是因为你可以在公共API中安全地使用那个版本。额外的方法(主要是<code class="du lh li lj lk b">filter</code>和<code class="du lh li lj lk b">flatMap</code>)也是一个不错的奖励。</p><p id="f7d4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">奇怪的是，出于某种原因，这两个方法以及<code class="du lh li lj lk b">map</code>在它们的原始对应物中不见了。我猜甲骨文认为它们不够有用。</p><h1 id="27fa" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">字符集与标准字符集</h1><p id="fd75" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">这两个实际上是一样的。两者都提供了与静态字段相同的字符集列表:UTF-8、UTF-16、UTF-16BE、UTF-16LE、US-ASCII和ISO-8859–1。</p><p id="5f60" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这也有助于<a class="ae jt" href="https://guava.dev/releases/19.0/api/docs/com/google/common/base/Charsets.html" rel="noopener ugc nofollow" target="_blank">番石榴的文档</a>对每个常量都有这样的句子:</p><blockquote class="mo mp mq"><p id="e2fb" class="ix iy lz iz b ja jb ij jc jd je im jf mr jh ji jj ms jl jm jn mt jp jq jr js hb bi translated"><strong class="iz hj">Java 7及更高版本注意:</strong>该常量应被视为已弃用；用<code class="du lh li lj lk b">StandardCharsets.XXX</code>代替。</p></blockquote><p id="2ff2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，出于与<code class="du lh li lj lk b">Optional</code>相同的原因，我建议使用Java版本。</p><h1 id="1620" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">摘要</h1><p id="de9a" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">总之，我会使用Guava版本的不可变集合，但是使用标准库版本的<code class="du lh li lj lk b">Optional</code>和字符集。对于后两者，没有足够的理由在现有的基础上使用一个库。</p><p id="4834" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">概括地说，不可变集合的原因是:</p><ul class=""><li id="8954" class="ma mb hi iz b ja jb jd je jg mc jk md jo me js mf mg mh mi bi translated">明确告诉我们某件事是不可改变的。</li><li id="89bd" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mf mg mh mi bi translated">它们可以作为简单的<code class="du lh li lj lk b">List</code>使用，就像Java的实现一样。</li><li id="3858" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mf mg mh mi bi translated">如果源集合被修改(如果存在的话)，它们也不会被修改。</li><li id="4391" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mf mg mh mi bi translated">他们可以在实现集合时利用不变性。这意味着有时方法的运行时间更好，需要的内存更少。</li></ul><p id="84f5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，它们也有一些缺点:</p><ul class=""><li id="dbb7" class="ma mb hi iz b ja jb jd je jg mc jk md jo me js mf mg mh mi bi translated">它们需要额外的依赖，如果您想在公共API中使用这些类/方法，这尤其成问题。</li><li id="906c" class="ma mb hi iz b ja mj jd mk jg ml jk mm jo mn js mf mg mh mi bi translated">他们仍然有来自实现<code class="du lh li lj lk b">List</code>的相同问题。</li></ul></div><div class="ab cl mu mv gp mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hb hc hd he hf"><p id="55eb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一点:番石榴也有自己处理未来的方式，而Java现在有<code class="du lh li lj lk b">CompletableFuture</code>。这个话题应该有自己的博文，然而，<a class="ae jt" href="https://oscarablinger.medium.com/the-ultimate-guide-to-futures-in-java-and-guava-c53263dd69dc" rel="noopener">所以我在这里写了一篇</a>。</p></div></div>    
</body>
</html>