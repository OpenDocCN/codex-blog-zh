<html>
<head>
<title>Making Your Own JavaScript Linter (part 4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制作您自己的JavaScript Linter(第4部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/making-your-own-javascript-linter-part-4-de4f106a9785?source=collection_archive---------5-----------------------#2021-01-16">https://medium.com/codex/making-your-own-javascript-linter-part-4-de4f106a9785?source=collection_archive---------5-----------------------#2021-01-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="a3ae" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><div class=""><h2 id="5e9a" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">综合教程</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/4da05bb083e28dcdb1b617a7f702ba6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ibAVb-O17lvkW1kEP01VEw.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">奔跑的棉绒</figcaption></figure><p id="b5b5" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这是关于构建JavaScript linter的综合教程的第四部分，也是最后一部分。你可以在这里阅读<a class="ae ks" rel="noopener" href="/codex/making-your-own-javascript-linter-part-3-da14e2aaf051">第三部</a>。</p><p id="318d" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这里是GitHub 中dirtyrat的<a class="ae ks" href="https://github.com/JoanaBLate/dirtyrat" rel="noopener ugc nofollow" target="_blank">源代码。</a></p><h1 id="4f5d" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">注册名称</h1><p id="eb6a" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">正如我们在本教程的其他部分所看到的，当linter在逐个解析令牌时，发现一个名为的令牌时，它会调用某个函数将这个名称(令牌)注册为已声明的或已使用的。</p><p id="d855" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">让我们来看看模块<em class="lq">寄存器</em>。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="f8b3" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">基本上，注册名称意味着使用模式<strong class="jy hs"><em class="lq">dictionary【branch edname】= token</em></strong>填充源代码文件对象(rat)的字典。</p><p id="b2d4" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">除了为以后的名称匹配准备数据之外，寄存器还会立即指出双重声明错误。</p><h1 id="031c" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">检查姓名</h1><p id="6a13" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">虽然在模块<em class="lq"> check-names </em>中没有技巧部分，但它的代码有点难读，因为我最近对它进行了修改，使其能够与JavaScript模块一起工作，但没有时间对它进行润色。因此，我们将查看该模块的示意图:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="dbe7" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">真正的代码要复杂得多，因为它关心的是每种警告的组织。因此，它必须用来自每个rat(代表源代码文件的对象)的警告来填充列表。然后，逐个列表显示。</p><p id="ecc2" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">还记得我们有一个相同的名字有许多标识符(全名)的问题吗？这是我们解决问题的方法。我们使用一个函数递归地调整外部作用域/块的全名(分支名)。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><h1 id="72f7" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">解析表达式</h1><p id="6daa" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">Dirtyrat有一个用于解析标准表达式的模块，还有一个用于解析文字表达式的模块。文字表达式是那些里面没有名字(变量或函数调用)的表达式。对于全局变量的初始化，dirtyrat只接受文字表达式。</p><p id="6d10" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这是标准表达式模块:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="05f7" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">解析表达式的代码完全是以递归方式编写的。基于主循环编写机制只会使事情复杂化。</p><p id="aff2" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">尽管模块<em class="lq">扫描器</em>是完全线性的(一个接一个地服务一个令牌),模块<em class="lq">表达式</em>是完全递归的，但它们完全匹配。</p><h1 id="521c" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">该模块主要</h1><p id="ab60" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">只剩下一个模块需要检查了。而且是第一个运行的:模块<em class="lq">主</em>。它开始分析命令行参数，并将哪些文件设置为lint:单个JS文件、由HTML文件链接的JS文件，或者文件夹和子文件夹中的JS文件。然后，它读取每个文件并发送要解析的文本。解析完所有文件后，它调用模块<em class="lq"> check-names </em>。</p><h1 id="2474" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">额外收获:如何解析Python的缩进</h1><p id="681b" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">首先，我们必须理解<strong class="jy hs">缩进只是另一种关闭块</strong>的语法。打开块不是缩进的职责。我知道新积木需要新的(更大的)压痕。这里有一个问题:</p><blockquote class="lt"><p id="1381" class="lu lv hi bd lw lx ly lz ma mb mc kr dx translated"><em class="md">并不是更大的缩进量打开了一个新的区块。它是一个像“for”一样的语句，创建一个新的块，需要更大的缩进。</em></p></blockquote><p id="1528" class="pw-post-body-paragraph jw jx hi jy b jz me is kb kc mf iv ke kf mg kh ki kj mh kl km kn mi kp kq kr hb bi translated">你可能认为这只是废话。但是这是一个基本的概念(虽然很微妙)，就像其他的一样，在你写linter的时候，这是一个完全不同的概念。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="6fa8" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">其次，我们必须保持我们良好的架构，将源代码文件的所有信息放入一个标记列表中。我们如何做到这一点？我们必须在值和种类等于“{”或“}”的标记中转换源代码中的不同边距。</p><p id="4639" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">因此，分词器有工作要做。我们不能改变任何其他模块。任何其他模块都不知道源代码的缩进是有意义的。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="c9d0" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们修改了记号赋予器，但没有弄乱它。</p><p id="5739" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">1)记号赋予器必须在每一行的开始知道该行的空白是否应该被忽略。有三种情况。a)这是一个空行。b)该行仅包含备注。c)该行是上一行的延续(例如以“+”结尾)。</p><p id="57ad" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">2)当页边空白的大小不是4的倍数时，记号赋予器必须“引发”错误。</p><p id="b8c9" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">3)记号赋予器必须记住先前的缩进，并且对于每4个空白，当前缩进不同于先前的缩进，它插入左(或右)花括号记号。</p><h1 id="ca41" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">我创建dirtyrat的原因</h1><p id="f787" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">在JavaScript有模块之前，我正在处理两个前端应用程序，每个大约有100个文件。性能对这两款应用都至关重要。因为性能至关重要，所以我用不同的代码测试每个功能。</p><p id="7078" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">曾经有一段时间，V8引擎运行循环“for (var fruit of fruits) { … }”比运行循环“for(var I = 0；I </p><p id="2238" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">因此，由于担心对性能有任何负面影响，我用最简单明了的方式编写了所有代码。不要在任何类型的对象中构造函数，也不要使用内部函数来保护隐私。我需要一个工具来帮我检查名字冲突和拼写错误，比如“if (a = b) {”。此外，一个工具，以加强我选择的代码风格。</p><p id="21fe" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">当时我尝试了著名的JSLint。JSLint检查了我的第一个文件，告诉我在文件顶部使用“use strict”(仅一次)是错误的。我应该把它从顶部移走，放在文件的每个函数里面…我能说什么呢？“你没有帮助！”。</p><p id="1925" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">所以我决定创造我自己的棉绒。我认为这是一个挑战，也是一个学习更多编程知识的机会。</p><p id="d432" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">注意:dirtyrat当前版本的目标是JavaScript模块。你可以在GitHub上了解更多。</p><h1 id="a420" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">结论</h1><p id="8b45" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">dirtyrat最初的想法只是为了补充JavaScript引擎检查。久而久之，得到了改善。但绝不是为了公共用途。它在这里的作用只是说明概念。如果我想让dirtyrat被广泛使用，我会给它起一个更迷人的名字，比如“CleanCat”。</p><p id="c268" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果你有任何问题，请写在“回复”部分，我会尽力回答。</p><p id="46fd" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">谢谢大家！</p></div></div>    
</body>
</html>