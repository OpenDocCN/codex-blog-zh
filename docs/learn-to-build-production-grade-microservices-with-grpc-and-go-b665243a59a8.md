# 学习使用 gRPC 和 Go 构建生产级微服务

> 原文：<https://medium.com/codex/learn-to-build-production-grade-microservices-with-grpc-and-go-b665243a59a8?source=collection_archive---------0----------------------->

## 新书

## *节选自侯赛因·巴贝尔*的《Go *中的* [*gRPC 微服务》*](https://www.manning.com/books/grpc-microservices-in-go?utm_source=medium&utm_medium=referral&utm_campaign=book_babal_grpc_6_29_22)

*本节选涵盖:*

*Go gRPC 微服务简介*

*比较 gRPC 和 REST*

*了解何时使用 gRPC*

*通过生产级用例更好地理解 gRPC 微服务*

*如果你有 Go 的基础知识，想用 gRPC 框架构建生产级的微服务，就去读吧。*

通过在[manning.com](https://www.manning.com/books/grpc-microservices-in-go?utm_source=medium&utm_medium=referral&utm_campaign=book_babal_grpc_6_29_22)的结账处将 **fccbabal** 输入折扣代码框，在 Go 中享受 [*gRPC 微服务七五折优惠。*](https://www.manning.com/books/grpc-microservices-in-go?utm_source=medium&utm_medium=referral&utm_campaign=book_babal_grpc_6_29_22)

良好的架构设计和适当的技术选择通过消除重复性工作和为软件开发和维护提供最佳工具包，对构建高质量的产品大有帮助。Go 语言是构建像 Kubernetes 中的微服务这样的大规模高性能云原生分布式应用程序的良好候选语言。具有 gRPC 通信的微服务已经使许多公司能够基于他们的业务能力用小型服务实现他们的产品，并让这些服务彼此之间以及与公共世界顺畅地通信。在 Go 的帮助下，这些服务的分发变得更加容易，这是因为它的快速编译、生成可执行二进制文件的能力以及其他许多原因，我们将在本书中通过真实的例子详细了解这些原因。

gRPC 是一个开源的远程过程调用框架，最初由 Google 在 2015 年开发，基本上可以帮助您连接内置支持负载平衡、跟踪、容错和安全的服务。该框架的主要优势在于能够为多种语言生成服务器和客户端存根(客户端的一个对象，实现与服务相同的方法),您可以在您的使用者项目中使用它们来调用远程服务方法，并在您的服务器项目中定义这些服务方法背后的业务逻辑。

微服务架构是面向服务架构的另一种形式，它将应用程序定义为松散耦合的细粒度服务，可以独立实现、部署和扩展。

本书的主要目标是提供 gRPC 微服务的生产级最佳实践，通过这种方式，到本书结束时，您将有自信自己实现整个系统。

## **gRPC 微服务的优势**

在一个典型的单块应用程序中，调用不同的业务操作，比如从结帐服务中调用支付服务，意味着在单独的模块中访问一个类方法，这非常容易。如果使用微服务，这样的通话会转换成一种网络通信。它可以是通过 TCP、HTTP 或某种事件队列的调用，以便在服务之间交换数据。处理网络调用比调用另一个类方法更具挑战性，这可以通过简单的错误处理机制(如 try catch 块)来处理。即使 Monoliths 在开始时很容易使用，您也可能出于几个原因需要分解它们，包括缓慢的部署和低效的资源利用，这显然会影响特性开发和产品维护。这并不意味着单片是坏的，微服务是好的；相反，微服务像服务间通信一样带来了自己的挑战。在 gRPC 的帮助下，微服务中的大多数挑战，如处理网络故障、将 TLS(传输层安全性)应用于服务通信，都可以消除。通过使用 gRPC 中的内置功能，您可以通过使用 Go 微服务来提高产品的可靠性和整个团队的生产率。

## **表演**

gRPC 比其他协议(如 REST with JSON 或 XML communication)提供更好的性能和安全性，因为它使用协议缓冲区和 TLS 上的 HTTP/2。协议缓冲区，也称为 Protobuf，是一种语言和平台中立的机制，用于序列化结构化数据。这种机制使 gRPC 能够在服务器端和客户端快速地将消息序列化为小而紧凑的消息。同样，HTTP/2 支持服务器端推送、多路复用和报头压缩。

## **代码生成&互通**

假设您有结帐服务和付款服务，客户可以结帐一个篮子，并调用付款服务来支付篮子中所述的产品。要访问支付服务，您需要在某个地方拥有请求和响应模型，比如共享库，以便您可以轻松地访问它们。重用共享的请求和响应模型在微服务中似乎很方便，但实际上这并不是一个好的实践，尤其是如果您为每个微服务使用不同的语言。在 Checkout 服务中复制模型是更好的选择，这通常是创建另一个数据类来构建请求对象和反序列化响应对象。这一切都是为了防止错误的抽象，你可能已经听说过“一点点重复远比错误的抽象便宜”([https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction))这句话。有一种更简单的方法，那就是选择 gRPC 来定义您的消息并生成客户端存根，这样您就可以注入这种依赖，并在您喜欢的语言中直接使用它。

gRPC 工具和库兼容多种平台和语言，包括 Go、Java、Python、Ruby、Javascript、C#等。拥有 Protobuf 二进制线路格式、像在网络中一样在线路上传输的数据格式以及为几乎所有平台精心设计的代码生成，使开发人员能够在保持跨平台支持的同时构建高性能的应用程序。

gRPC 正变得越来越流行(【https://star-history.com/#grpc/grpc】T2&日期)，因为你可以很容易地生成客户端存根来提供不同语言服务的 SDK。你唯一需要决定的是你需要有什么样的业务对象。一旦决定了结帐模型需要哪些字段，就可以引入各自的请求和响应模型。请记住，那些对象只是定义，它被称为 IDL(接口定义语言)，独立于任何语言规范。在定义了消息规范之后，您可以生成特定于语言的实现，以便任何消费者都可以依赖于该来源。这也意味着服务器端的开发语言在客户端可以不同，因为服务器端的方法可以在客户端生成为 gRPC 支持的特定语言的存根。

除了业务对象，您还可以定义服务方法，并以同样的方式生成实际的实现。在消费者端初始化 gRPC 客户端之后，可以调用这些服务功能，同样，这个客户端是开箱即用的。

## **容错**

容错是指尽管系统出现故障，系统仍能继续运行的能力。幂等运算是一种即使调用多次也不会产生额外效果的运算。幂等性是成功容错环境的关键，因为您需要确保，一旦在失败或没有预期状态的情况下使用相同的参数重试操作，它不应该改变实际资源的内容。例如，如果网络响应失败，我们可能希望重试用户删除操作。如果操作返回相同的结果，即使你调用它不止一次，我们说这个操作是幂等的。

如果一个操作不适合幂等用例，那么您需要在响应消息中提供适当的验证错误，帮助您知道何时停止重试操作。一旦保证了这种幂等性或正确的验证，它就只是 gRPC 端重试策略的一个定义。容错还关注其他主题，如速率限制、断路器和故障注入。

## **安全**

在大多数系统中，您可能需要设置一个安全层来保护您的产品免受未验证来源的攻击。gRPC 鼓励 HTTP/2 over SSL/TLS 对客户端和服务器之间交换的数据进行身份验证和加密。更具体地说，您可以通过使用 SSL/TLS、ALTS(应用层传输安全)或基于令牌的身份验证系统来轻松设置身份验证系统。

## **流媒体**

有时，您可能需要将响应数据分成几个块，以分页的方式提供给用户，以减少带宽并快速返回给用户。而且，如果他们只对某些页面感兴趣，那么一次返回所有数据是没有意义的。在 gRPC 中，除了分页之外，您还可以将这些数据流式传输给消费者，而不是强迫用户进行分页来迭代获取数据。流式传输不一定在服务器端，也可以在客户端，甚至同时在两端，这就是所谓的双向流式传输。在一个典型的流用例中，您打开一次连接，数据将通过这个打开的连接进行流传输。当我们在本书中实现一个完整的应用时，您将看到不同种类的流用例。

## **REST vs gRPC**

REST(表述性状态转移)是微服务广泛采用的协议，但如果您有严格的要求，如低延迟、多语言系统支持等，您可能会开始考虑使用 gRPC。REST 基于 HTTP 1.0 协议，该协议允许您在客户机和服务器之间交换 JSON 或 XML 格式的消息。另一方面，gRPC 是基于 RPC(远程过程调用)的体系结构，使用协议缓冲区二进制格式通过 HTTP 2.0 协议交换数据。这并不意味着 REST 与 HTTP 2.0 不兼容，您可以使用自己的自定义实现来设置基于该协议的 REST 服务，这是 gRPC 中的一个内置特性。

由于 gRPC 有内置的 HTTP 2.0 支持，您还可以利用客户机和服务器之间的单向和双向流，从而实现非常快速的通信。使用 REST 服务的默认设置，多个客户机服务器通信可能会对您的整体系统性能带来延迟。

也有 REST 比 gRPC 更有益的情况，例如 REST 协议在各种浏览器中都得到支持。由于 gRPC 支持非常有限，您可能需要使用某种代理层来完成 HTTP 1.0 和 HTTP 2.0 之间的转换。

gRPC 有很多优点，比如能够定义消息来方便地在服务之间交换数据。然而，就可读性而言，REST 中 JSON 和 XML 的使用有一些优势，比如，如果对更改后的字段没有明确的业务验证，就可以自由地进行更改，而您需要遵循 gRPC 中的一些规则来进行更改。我们将在第五章详细解释这一点。

gRPC 有内置的客户端和服务器存根生成机制，您需要使用 REST 中的框架(如 Swagger Codegen)来生成客户端模型。这一点变得至关重要，尤其是当您拥有多种服务并同时为客户维护多个 SDK 时。

现在我们已经了解了 REST 和 gRPC 之间的区别，让我们看看什么时候使用 gRPC 是有意义的。"

## **何时使用 gRPC**

如果您对浏览器支持有严格的要求，那么您需要考虑使用 REST，因为您将最终为 HTTP/2 和 HTTP/1 之间的转换设置另一个层。但是，您仍然可以使用 gRPC 进行服务间通信，并将 gRPC 负载平衡器([https://AWS . Amazon . com/blogs/AWS/new-application-load-balancer-support-for-end-to-end-http-2-and-gRPC/](https://aws.amazon.com/blogs/aws/new-application-load-balancer-support-for-end-to-end-http-2-and-grpc/))附加到该服务池，以便将 API 公开，从而具有 REST 兼容性。还有其他选择，比如 Twirp(【https://github.com/twitchtv/twirp】)，一个基于 Protobuf 的 RPC 框架。Twirp 允许您为 gRPC 服务启用 REST 层，您可以访问您的端点，如下例所示，发送一个带有 JSON 有效负载的 POST 请求。

```
curl -X "POST" \
       - H "Content-Type: application/json" \
       -d '{"name": "dev-cluster"}' \    [http://localhost:8080/twirp/github.com/huseyinbabal/microservices-proto/cluster/Create](http://localhost:8080/twirp/github.com/huseyinbabal/microservices-proto/cluster/Create)
```

多语言开发环境是 gRPC 集成的最佳场所，因为能够在 Checkout 服务中使用 Python 客户端来访问使用 Java 编写的支付服务，很容易生成客户端存根。您可以将相同的策略应用到面向公共消费者的 SDK 产品中。此外，每当您更改服务定义时，客户端的测试就会开始失败，这对于您的微服务来说是一个很好的验证机制。

gRPC 可能不适合非常简单的应用程序，比如只包含 1-2 个服务的启动项目，因为维护包含服务定义的原型文件并不容易，尤其是对于没有经验的用户。

在内部服务之间使用 gRPC 通信是可以的，但是向客户公开 gRPC 接口可能并不理想，尤其是在没有用于 gRPC 服务通信的客户端 SDK 的情况下。如果您喜欢公开 gRPC 而不为您的消费者维护 SDK，那么最好与他们共享您的服务定义，或者提供一个关于如何对您的 gRPC 服务进行 gRPC 调用的清晰解释。

这本书包含了大量的解释、代码示例、提示和技巧，并辅以现实生活中的例子，对以下角色非常有用。

*   *不了解 Go 或微服务的开发者*:可以利用先从关于 Go、微服务、gRPC 的入门章节开始，学习 gRPC Go 微服务的量产级技术。对于已经了解微服务架构的读者来说，可以用 Go 中描述的资源更新他们的知识，这些资源可以很容易地适应他们当前使用的任何其他语言。
*   *工程经理:*通过将这里描述的最佳实践添加到他们的行动手册中，可以提高他们团队中开发人员的生产力。应用实践将在整个产品上引入良好的可见性，这将有助于新员工容易地加入团队。
*   *软件架构师:有很多方便的例子和架构设计*，它们是他们新产品或新特性决策的潜在参考。

本书中会有以下格式的生产级示例。

*   本书结尾完成的项目
*   代码示例可以更好地理解特定主题及其工作原理
*   自动化示例，特别是使用 Github 操作来减少重复操作
*   为部署准备工件
*   安全最佳实践

## **生产级用例**

如图 1 所示，我们将在本书中尝试使用 Go gRPC 微服务创建一个电子商务产品，该产品在一个适当的 CI/CD 管道中自动运行，并存在于 Kubernetes 环境中。在本书中，我们将访问图表的关键部分，以了解它们对于典型的开发生命周期有多重要，gRPC 如何使这些部分更容易处理，以及在哪里使用哪些技术。

![](img/5730cf85658589e806fbc3622331d062.png)

图一。基于 Kubernetes 的 Go 微服务构建的电子商务产品的架构图，包括 CI/CD 流和可观察性

## **总结**

*   gRPC 在服务间通信中表现良好，因为它对数据使用二进制序列化，并通过 HTTP/2 协议传输数据。
*   gRPC 允许您进行客户端流、服务器流和双向流，允许您并行发送多个请求或接收多个响应。
*   由于自动代码生成，gRPC 微服务中稳定的客户端-服务器交互非常容易实现。
*   REST 非常受欢迎，尤其是因为它有更广泛的浏览器支持，但是你仍然可以使用 gRPC web 代理(例如[https://github.com/grpc/grpc-web](https://github.com/grpc/grpc-web))进行 REST 到 gRPC 的转换。
*   Go 是云原生应用程序的最佳语言之一，比如 kubernetes 中的微服务，因为它具有高度的可移植性。
*   在 gRPC 中使用 HTTP/2 over SSL/TLS 端到端加密连接消除了微服务的大部分安全顾虑
*   到本书结束时，你会对这一切了如指掌！

更多信息，请点击查看本书[。](https://www.manning.com/books/grpc-microservices-in-go?utm_source=medium&utm_medium=referral&utm_campaign=book_babal_grpc_6_29_22)