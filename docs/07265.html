<html>
<head>
<title>Preventing &amp; Handling Errors in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中预防和处理错误</h1>
<blockquote>原文：<a href="https://medium.com/codex/preventing-handling-errors-in-python-c1ae1f2fa689?source=collection_archive---------18-----------------------#2022-06-07">https://medium.com/codex/preventing-handling-errors-in-python-c1ae1f2fa689?source=collection_archive---------18-----------------------#2022-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0f1768dd9b31317d066082be4ce3a258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z9TlctQ4Q6uZdM8r"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">克里斯里德在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b4ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">处理错误是任何编程语言中最常见的问题之一。在Python中，您可以在错误发生之前阻止它们，或者在错误发生之后处理它们。在编程中，面对错误有两种截然相反的方法——<strong class="ix hj">三思而后行(LBYL) </strong>和<strong class="ix hj">请求原谅比请求允许容易(EAFP) </strong>。在本教程中，我们将快速探究这两种策略。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/a278066541710ef3ad8542be92bc8fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YPWn1twIdgwRJn83y0h69g.png"/></div></div></figure><h1 id="0869" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">三思而后行(LBYL)风格</strong></h1><p id="d6df" class="pw-post-body-paragraph iv iw hi ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">在这种编码方法中，首先检查他们的条件是否成功，然后才进一步进行。Python文档将这种编码风格定义为:</p><blockquote class="lb lc ld"><p id="af0b" class="iv iw le ix b iy iz ja jb jc jd je jf lf jh ji jj lg jl jm jn lh jp jq jr js hb bi translated">这种编码风格在进行调用或查找之前显式测试前置条件。这种风格与EAFP方法形成对比，其特点是存在许多if语句。(<a class="ae iu" href="https://docs.python.org/3/glossary.html#term-LBYL" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></blockquote><p id="4f09" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了更好地理解这一点，假设你有一些文本，你想写一个函数来计算每个字符的频率。因此，使用这种方法，我们最终编写了以下代码:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/e6f40eeedfa6666a6a0383489c222026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FLkoFbWosEKp6WjQSThYaA.png"/></div></div></figure><p id="350c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个函数将一个文本作为输入，并返回一个以字符作为键的字典。为了构建字典，我们对 循环使用了一个<strong class="ix hj"> <em class="le">，其中我们逐个字符地进行。然后，我们检查该字符是否存在于字典中，我们简单地将它的计数器加1，否则，如果是第一次，我们将计数器初始化为1(否则块)。</em></strong></p><p id="98cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用一些示例文本调用这个函数，下面是结果:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/d92d59fe566340c52ec4a6134bf50be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p5eYn82Xrdg38dNFgYQ61Q.png"/></div></div></figure><p id="e3c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很简单，对吧？让我们稍微分析一下这种方法。一旦函数已经处理了一些样本文本，那么很明显，当执行检查时，目标字符已经在字典中了(if语句)。最终，所有这些不必要的检查都会增加代码的性能成本。如果一个人正在处理一大段文本，这一点尤其正确。</p><p id="944e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如何避免这种间接成本？这就是EAFP风格出现的时候了！</p><h1 id="a26a" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">请求原谅比许可容易(EAFP式)</strong></h1><blockquote class="lb lc ld"><p id="64b0" class="iv iw le ix b iy iz ja jb jc jd je jf lf jh ji jj lg jl jm jn lh jp jq jr js hb bi translated">请求原谅比请求允许容易。这种常见的Python编码风格假设存在有效的键或属性，并在假设证明为假时捕捉异常。这种干净快速的风格的特点是存在许多<code class="du lk ll lm ln b">try</code>和<code class="du lk ll lm ln b">except</code>语句。这种技术与许多其他语言中常见的LBYL风格形成对比，比如C.( <a class="ae iu" href="https://docs.python.org/3/glossary.html#term-EAFP" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></blockquote><p id="84f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如官方定义所说，EAFP编码风格的特点是使用<code class="du lk ll lm ln b">try</code> … <code class="du lk ll lm ln b">except</code>语句来捕捉和处理代码执行过程中可能出现的错误和异常情况。这种编码方法在Python社区中非常流行。主要是因为Python中快速高效的错误处理。</p><p id="2e61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们使用与上面相同的例子，看看如何使用EAFP来实现这个问题。该函数将如下所示:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/1ddd2e00d86f7a2a424886cbe7a09d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VTLYMok4-zoVSc6sW13hGQ.png"/></div></div></figure><p id="7272" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该函数接收样本集。这次也是如此，我们用一个<strong class="ix hj"> <em class="le">来代替</em> </strong>循环。但是我们没有使用if-else条件，而是简单地将代码放入一个try-except块中。现在，不是检查char是否已经存在于字典中，而是尝试增加counter[char]的值。如果它能增值，那当然好。如果不是，它进入except块并将其初始化为1。</p><p id="92e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用上面使用的sample_text调用该函数。我们得到相同的结果，但是正如人们可以容易地指出的，它减少了在LBYL的许多开销。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/1ce60f09c4eaa42ffb72bf873f12ed14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIdASbNnhidf-zCLVo5GLA.png"/></div></div></figure><p id="c4b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是我们如何在Python中实现这两种编码风格！你编码的时候更喜欢哪个？</p></div></div>    
</body>
</html>