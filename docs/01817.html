<html>
<head>
<title>Decorator Pattern in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中的装饰模式</h1>
<blockquote>原文：<a href="https://medium.com/codex/decorator-pattern-in-c-45d19337dc69?source=collection_archive---------8-----------------------#2021-06-03">https://medium.com/codex/decorator-pattern-in-c-45d19337dc69?source=collection_archive---------8-----------------------#2021-06-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e5e4eda33c8d12919f793111027926ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7lMd2CB9riGlyJiNn9rYgg.jpeg"/></div></div></figure><p id="0b10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">软件世界中的设计模式有助于开发更快且经过测试的范例。它解决了代码(或开发人员)在实现代码之前不会遇到的未来问题。</p><p id="504e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一般来说，设计模式增加了代码的可重用性，提高了代码的可读性。有三种类型——创造型、结构型和行为型。</p><p id="960d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Creational处理类实例化技术。结构化处理类对象组合，并提供向类添加新功能的方法。行为处理类的对象如何通信。</p><p id="3e1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇博客中，我们将会看到一个属于结构类的装饰模式。让我们先看看什么是装饰模式，然后理解上面提到的设计模式解决了什么问题。</p><p id="ae86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录</strong></p><ol class=""><li id="9be4" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">什么是装饰模式？</li><li id="cebd" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">如何在C#中实现装饰模式</li><li id="a54f" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">结论</li></ol><h1 id="67f9" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是装饰模式？</h1><p id="4964" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">装饰模式解决了在不影响开闭原则的情况下向现有类添加责任的问题。这不需要对现有的类进行任何动态修改。</p><p id="c563" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是通过向现有的类添加一个包装器来实现的。装饰模式由四个主要元素组成</p><ol class=""><li id="dff1" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">成分</li><li id="f38b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">混凝土构件</li><li id="2d50" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">装饰者</li><li id="ca83" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">混凝土装饰工</li></ol><p id="7cd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">组件是提供由具体组件消费的操作的接口。具体组件是实现该组件的类，并且具有需要执行的原始操作。装饰器为所有需要添加到具体组件的动态操作定义了接口。具体装饰者是需要添加到具体组件中的单个操作。它继承了一个装饰器。</p><p id="b2f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">围绕这四个项目，已经构建了装饰器模式。它是在功能被扩展而不修改现有类的地方实现的。</p><h1 id="6374" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">如何在C#中实现Decorator模式？</h1><p id="3a46" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">让我们借助现实生活中的情况来解释这一点。</p><p id="402c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑一家冰淇淋店，用户可以在那里定制他/她的订单。用户必须选择冰淇淋的基本口味，然后选择浇头。</p><p id="cfec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，为了计算冰淇淋的总价，我们需要将冰淇淋的基价和各种配料的基价相加。</p><p id="3b29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用C#中的装饰模式来实现这个简单的场景。</p><p id="4c3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为此，我们将使用一个简单的基于控制台的。Net应用程序。我们将专注于在C#中实现该模式，而不是在可以使用。网络图书馆。</p><h2 id="d98d" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">第一步</h2><p id="592d" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">创建基于. Net Core的控制台应用程序，并为解决方案提供有效的名称和路径。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/6abad8dbcf3e3b2ea49e52eed5d47cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tszpGXL9-8HF4Eny"/></div></div></figure><h2 id="d3a6" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">第二步</h2><p id="3d14" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">创建解决方案后，打开Program.cs文件。这是将要做出改变的地方。默认情况下，该文件如下所示。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/6b377bbd38dd4154e864a7b2badd2d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/0*ZXnatqUoB99QgElB"/></div></figure><h2 id="d5c5" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">第三步</h2><p id="0269" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">如前一节所述，其思想是实现装饰模式实现所需的四个主要元素。作为第一步，我们将实现组件。因为这是一家冰淇淋店，所以我们正在为冰淇淋创建一个组件。</p><pre class="lu lv lw lx fd lz ma mb mc aw md bi"><span id="0e0a" class="lf kd hi ma b fi me mf l mg mh">public interface Icecream ​ { ​ double CalculatePrice(); ​ }</span></pre><h2 id="5acc" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">第四步</h2><p id="6dd1" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">创建具体的组件，在我们的例子中是冰淇淋口味。这里，我们将考虑vanilla并实现它的逻辑。具体组件继承组件并实现方法CalculatePrice。</p><pre class="lu lv lw lx fd lz ma mb mc aw md bi"><span id="7d78" class="lf kd hi ma b fi me mf l mg mh">public class VanillaIcecream : Icecream ​ { ​ public double CalculatePrice() ​ { ​ return 15; ​ } ​ }</span></pre><h2 id="8b47" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">第五步</h2><p id="40b3" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">创建将被混凝土装饰者使用的装饰者。这用于将浇头值添加到冰淇淋的基础价格中。在这里，装饰器继承了组件并实现了所需的方法，还拥有一个期望组件被传递的构造函数。</p><pre class="lu lv lw lx fd lz ma mb mc aw md bi"><span id="7926" class="lf kd hi ma b fi me mf l mg mh">public abstract class ToppingDecorator : Icecream ​ { ​ readonly Icecream _icecream; ​ public ToppingDecorator(Icecream icecream) ​ { ​ _icecream = icecream; ​ } ​ public virtual double CalculatePrice() ​ { ​ return _icecream.CalculatePrice(); ​ } ​ }</span></pre><h2 id="43d9" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">第六步</h2><p id="3cb2" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">创建继承ToppingDecorator并覆盖CalculatePrice方法的concrete decorator。因此，当更新后的concrete组件或decorator concrete被传递时，将会计算总和值。</p><p id="b6a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个继承了toppingdecorator并实现了CalculatePrice方法的Wafers示例，其中包含了将额外金额与产品的基本价格相加的逻辑。</p><pre class="lu lv lw lx fd lz ma mb mc aw md bi"><span id="8be7" class="lf kd hi ma b fi me mf l mg mh">public class Wafers : ToppingDecorator ​ { ​ public Wafers(Icecream icecream) : base(icecream) ​ { ​ } ​ public override double CalculatePrice() ​ { ​ return base.CalculatePrice() + 3; ​ } ​ }</span></pre><p id="d165" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似于薄饼，任何其他浇头也可以根据需要添加。下面是另一个巧克力片浇头的例子。</p><pre class="lu lv lw lx fd lz ma mb mc aw md bi"><span id="0d09" class="lf kd hi ma b fi me mf l mg mh">public class Chocochip : ToppingDecorator ​ { ​ public Chocochip(Icecream icecream) : base(icecream) ​ { ​ ​ } ​ public override double CalculatePrice() ​ { ​ return base.CalculatePrice() + 2; ​ } ​ }</span></pre><h2 id="6007" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">第七步</h2><p id="19a1" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">现在我们已经实现了组件(冰激凌接口)、具体组件(VaniallaIceCream)、装饰器(ToppingDecorator)和具体装饰器(waves和Chocochip)。让我们看看如何使用它们来实现装饰模式。</p><p id="d1fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">打开Program.cs文件并包含以下代码行。</p><pre class="lu lv lw lx fd lz ma mb mc aw md bi"><span id="de33" class="lf kd hi ma b fi me mf l mg mh">var icecreamOrder = new VanillaIcecream(); Console.WriteLine($"Total price of icecream - { icecreamOrder.CalculatePrice() }."); var wafer = new Wafers(icecreamOrder); Console.WriteLine($"Total price of icecream with wafer - { wafer.CalculatePrice() }."); var chocoChip = new Chocochip(wafer); Console.WriteLine($"Total price of icecream with wafer and chocochip - { chocoChip.CalculatePrice() }."); Console.ReadLine();</span></pre><p id="14bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，首先，创建了混凝土组件(VanillaIcecream)的对象。在下一行中，打印的是基本冰淇淋的价格。</p><p id="9b6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，为wafer创建一个对象，并将vanillaicecream对象作为输入参数传递给它。所以，价格可以在包括香草冰淇淋上面的威化之后计算出来。</p><p id="a083" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们在晶圆上添加一个choco-chip，那么晶圆的对象将作为输入参数传递给choco-chip类。然后在包括香草冰淇淋、威化饼和巧克力片的基础价格之后计算价格。</p><p id="4427" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是将在控制台窗口中显示的最终数据。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/f5a12b4c0bd968d63e6aa2fa504133b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/0*-lNFF7j0WdMZ0RKu"/></div></figure><h1 id="292a" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="068f" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">多亏了C#中的Decorator模式，您能够在不修改现有类的情况下实现额外的功能。这对开发人员来说非常方便，因为它有助于代码的可重用性和可读性。除此之外，它还有助于实现开闭原则。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="53ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mq">原载于</em><a class="ae mr" href="https://www.partech.nl/nl/publicaties/2021/05/decorator-pattern-in-c-sharp" rel="noopener ugc nofollow" target="_blank"><em class="mq">https://www . partech . nl</em></a><em class="mq">。</em></p></div></div>    
</body>
</html>