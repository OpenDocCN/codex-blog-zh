<html>
<head>
<title>Building a Real-Time Data Warehouse with TiDB and Pravega</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TiDB和Pravega构建实时数据仓库</h1>
<blockquote>原文：<a href="https://medium.com/codex/building-a-real-time-data-warehouse-with-tidb-and-pravega-a44fba92b3fa?source=collection_archive---------6-----------------------#2021-09-02">https://medium.com/codex/building-a-real-time-data-warehouse-with-tidb-and-pravega-a44fba92b3fa?source=collection_archive---------6-----------------------#2021-09-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b9af49c7e0d2a6e03a0ea84467f48fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FF0tz8mozfZyRU2Q.jpg"/></div></div></figure><p id="e5d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">作者:</em><a class="ae jp" href="https://github.com/wangtianyi2004" rel="noopener ugc nofollow" target="_blank"><em class="jo"/></a><em class="jo">(平盖数据库架构师)。</em></p><p id="ec48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">拥有大量数据的公司依赖数据仓库进行数据处理和分析。要实现业务敏捷性，<strong class="is hj">离线数据仓库已经不够用了，实时数据仓库正逐渐接管</strong>。目前，实时数据仓库通常使用Apache Flink来消费来自Apache Kafka的数据，并将数据流式传输到数据库中。然而，由于Kafka不在磁盘中保存数据，在极端情况下，数据会丢失。</p><p id="50f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在研究了市场上的数据库和存储系统后，<strong class="is hj">我们找到了一个更高效、更准确的实时数据仓库解决方案:</strong><a class="ae jp" href="https://pravega.io/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">Pravega</strong></a><strong class="is hj">+</strong><a class="ae jp" href="https://pingcap.com/products/tidb" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">TiDB</strong></a>。</p><p id="f2af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将介绍分布式流存储系统Pravega和分布式SQL数据库TiDB。这种结合解决了Kafka的数据持久性困境，并提供了自动伸缩能力，提高了实时数据仓库的并发性、可用性和安全性。我还提供了一个docker-compose演示供您尝试Pravega和TiDB。我希望这篇文章对你有所帮助。</p><h1 id="5f22" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Pravega，一个流存储系统</h1><p id="c529" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">由戴尔EMC开源的<a class="ae jp" href="https://github.com/pravega/pravega" rel="noopener ugc nofollow" target="_blank"> Pravega </a>是一个流存储系统和云本地计算基金会(CNCF)沙盒项目。它类似于Kafka和Apache Pulsar，并提供流和模式注册。但是Pravega提供了更多的功能:</p><ul class=""><li id="30a3" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">无需应用感知的自动扩展。</li><li id="cadf" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">具有基于流的抽象的完整存储接口，支持上层计算引擎的统一访问。</li></ul><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/5f53e1931d483216fa53f61536beefd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6gBviWgubebB1FOo.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">Pravega建筑</figcaption></figure><p id="1502" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在分布式系统中，客户端应用程序和消息传递系统通常使用消息队列来异步传输消息。说到消息队列，大家都会想到卡夫卡。Kafka是一个基于Zookeeper的分布式日志系统。它支持多个分区、多个副本和多个消费者。</p><p id="9b0f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相比之下，Pravega是一个新的流存储系统，旨在解决卡夫卡无法解决的问题。它重构了流存储的架构。作为一个实时流存储解决方案，Pravega本身支持长期数据保留。Pravega将数据写入Hadoop分布式文件系统(HDFS)或S3，从而消除了对数据持久性的担忧。此外，Pravega在整个系统中只存储一份数据副本。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/d420e6e607e251ea9a861c665abbb901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cMbaO-RhN8jPknjP.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">普拉维加的设计解决了卡夫卡无法解决的问题</figcaption></figure><h2 id="8229" class="lr jr hi bd js ls lt lu jw lv lw lx ka jb ly lz ke jf ma mb ki jj mc md km me bi translated">为什么普拉维加胜过卡夫卡</h2><p id="b1bb" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">你可能会想，“既然已经有了卡夫卡，为什么还要重新发明轮子？”我用Kafka的时候，被三个问题困扰:数据丢失，数据留存，消费者再平衡。</p><p id="e801" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">卡夫卡接受的信息比它给出的要多。提交偏移后，存在数据丢失的风险。</p><ul class=""><li id="5f34" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">当您设置<code class="du mf mg mh mi b">acks = all</code>时，只有当所有消费者确认消息已保存时，才会返回ACK，因此不会丢失数据。</li><li id="5ed2" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">当<code class="du mf mg mh mi b">acks = 1</code>时，如果领导消费者保存消息，则返回ACK。如果领导者在备份数据之前关机，数据将会丢失。</li><li id="9bb9" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">当<code class="du mf mg mh mi b">acks = 0</code>出现时，卡夫卡没有等待消费者的认可。当用户关闭时，数据会丢失。</li></ul><p id="04c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kafka没有提供简单有效的解决方案来将数据保存到HDFS或S3，因此数据保留成为一个问题。尽管Confluent提供了解决方案，但您必须使用两组存储接口来访问不同层的数据。</p><ul class=""><li id="9c4c" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">使用Apache Flume通过卡夫卡-&gt; Flume -&gt; HDFS访问数据。</li><li id="35ef" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">使用kafka-hadoop-loader通过Kafka-&gt; Kafka-Hadoop-loader-&gt; HDFS访问数据。</li><li id="883b" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">使用Kafka Connect HDFS通过Kafka -&gt; Kafka Connect HDFS -&gt; HDFS访问数据。</li></ul><p id="f12f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">消费者再平衡也是有害的。因为队列中添加了新的使用者，所以队列可能会在重新平衡期间停止使用消息。由于提交间隔很长，使用者可能会重复处理数据。无论哪种方式，重新平衡都可能导致消息积压，从而增加延迟。</p><p id="9a28" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与Kafka相比，Pravega提供了更多功能:</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/445dc7300c1c5c00242baa13c82866c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uRWn3a79uS-Q33WA.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">普拉维加与卡夫卡</figcaption></figure><p id="58b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Pravega使用Apache BookKeeper以低延迟写入并发的实时数据。但是，BookKeeper只作为批量写入的缓存层。对Pravega的所有读取请求都直接发送到HDFS或S3，以利用它们的高吞吐量能力。</p><p id="c9c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">换句话说，Pravega不使用BookKeeper作为数据缓冲层，而是提供一个基于HDFS或S3的存储层。该存储层支持对<strong class="is hj">低延迟尾随读写和高吞吐量追赶读取</strong>的抽象。当数据在簿记员和HDFS或S3之间移动时，使用簿记员作为单独层的系统可能性能很差。相比之下，Pravega确保了令人满意的性能。</p><h2 id="d631" class="lr jr hi bd js ls lt lu jw lv lw lx ka jb ly lz ke jf ma mb ki jj mc md km me bi translated">Pravega的优势</h2><p id="cdab" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">通常，DBA主要关注三个方面:<strong class="is hj">数据准确性、系统稳定性和系统可用性。</strong></p><ul class=""><li id="2d4f" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">数据准确性至关重要。任何数据丢失、损坏或复制都将是一场灾难。</li><li id="a53c" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">系统稳定性和可用性将DBA从繁琐的维护过程中解放出来，这样他们就可以将时间投入到改进系统上。</li></ul><p id="3a1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Pravega解决了这些DBA关心的问题。它的长期保留确保了数据安全，精确一次语义保证了数据准确性，自动扩展使系统维护变得轻而易举。</p><h1 id="ce33" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">实时数据仓库体系结构</h1><p id="9503" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">一个实时数据仓库通常有四个组成部分:<strong class="is hj">数据采集层、数据存储层、实时计算层、实时应用层。</strong>通过将多种技术集成到无缝架构中，我们可以构建可扩展的大数据架构，支持数据分析和挖掘、在线交易以及统一的批处理和流处理。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/0737c718a5fe756f5a732099e2d70f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5PePctVPHxIGRZCQ.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">实时数据仓库中的四个组件</figcaption></figure><p id="e6fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据存储层有多种选择，但并非所有选择都适合实时数据仓库:</p><ul class=""><li id="fc2f" class="kt ku hi is b it iu ix iy jb kv jf kw jj kx jn ky kz la lb bi translated">Hadoop或传统的OLAP数据库无法提供令人满意的实时处理。</li><li id="044a" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">像HBase这样的NoSQL解决方案可以实时扩展和处理数据，但不能提供分析。</li><li id="08c2" class="kt ku hi is b it lc ix ld jb le jf lf jj lg jn ky kz la lb bi translated">独立的关系数据库不能向外扩展以容纳海量数据。</li></ul><p id="77f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，TiDB解决了所有这些需求。</p><h2 id="abef" class="lr jr hi bd js ls lt lu jw lv lw lx ka jb ly lz ke jf ma mb ki jj mc md km me bi translated">分布式HTAP数据库TiDB</h2><p id="6a37" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated"><a class="ae jp" href="https://pingcap.com/products/tidb" rel="noopener ugc nofollow" target="_blank"> TiDB </a>是一个开源的分布式SQL数据库，支持混合事务和分析处理(HTAP)工作负载。它与MySQL兼容，具有水平可伸缩性、强一致性和高可用性。</p><p id="58b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">相比其他开源数据库，TiDB的HTAP架构更适合构建实时数据仓库。</strong> TiDB拥有一个混合存储层，由基于行的存储引擎TiKV和列存储引擎TiFlash组成。这两个存储引擎使用TiDB作为共享SQL层。TiDB回答联机事务处理(OLTP)和联机分析处理(OLAP)查询，并根据执行计划的成本从任一引擎获取数据。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/df864d474e335d48319ab5a486cdfc00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gqiz1_i8aN55nuAV.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">TiDB HTAP建筑</figcaption></figure><p id="6317" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，TiDB 5.0引入了<a class="ae jp" href="https://docs.pingcap.com/tidb/stable/release-5.0.0#mpp-architecture" rel="noopener ugc nofollow" target="_blank">大规模并行处理(MPP)架构</a>。在MPP模式下，TiFlash补充了TiDB的计算能力。在处理OLAP工作负载时，TiDB成为一个主节点。用户向TiDB服务器发送请求，所有TiDB服务器执行表连接，并将结果提交给优化器进行决策。优化器评估所有可能的执行计划(基于行、基于列、索引、单服务器引擎和MPP引擎)并选择最佳的一个。</p><figure class="li lj lk ll fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/ef6b2f924ff23cc3445da3fe56d9a9aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zD2QIR-Owp6MJJre.jpg"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">TiDB的MPP模式</figcaption></figure><p id="8298" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，在销售活动期间，订单处理系统可能会遇到突然的流量高峰。在高峰期，企业需要执行快速分析，以便能够及时对客户行为做出反应。传统的数据仓库很难在短时间内处理海量数据，后续的数据分析处理可能需要很长时间。</p><p id="9cab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">借助MPP计算引擎，<strong class="is hj"> TiDB可以预测即将到来的流量高峰，并动态扩展集群，为活动提供更多资源。</strong> It可以在几秒钟内轻松响应聚合和分析请求。</p><h2 id="c2d8" class="lr jr hi bd js ls lt lu jw lv lw lx ka jb ly lz ke jf ma mb ki jj mc md km me bi translated">当TiDB遇到Pravega</h2><p id="67c2" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">在Flink的帮助下，TiDB与Pravega合作建立了一个实时、高吞吐量、稳定的数据仓库。该数据仓库能够满足用户对大数据的各种需求，并一站式处理OLTP和OLAP工作负载。</p><p id="2a25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更好地展示Pravega和TiDB的用法，我们提供了一个基于docker-compose 的<a class="ae jp" href="https://github.com/wangtianyi2004/tidb-pravega-quick-start" rel="noopener ugc nofollow" target="_blank">演示，演示了数据如何从Pravega通过Flink流向TiDB。您可以通过Flink SQL客户端编写和提交Flink作业，并在<code class="du mf mg mh mi b">&lt;HOST_IP&gt;:8081</code>观察执行情况。</a></p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><p id="979a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">原载于2021年8月19日</em><a class="ae jp" href="https://pingcap.com/blog/building-a-real-time-data-warehouse-with-tidb-and-pravega" rel="noopener ugc nofollow" target="_blank"><em class="jo">www.pingcap.com</em></a><em class="jo"/></p></div></div>    
</body>
</html>