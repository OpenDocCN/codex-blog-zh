<html>
<head>
<title>Implementation of Server-Sent Events and EventSource- Live Progress Indicator using React and Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React和Spring Boot实现服务器发送的事件和事件源-实时进度指示器</h1>
<blockquote>原文：<a href="https://medium.com/codex/implementation-of-server-sent-events-and-eventsource-live-progress-indicator-using-react-and-723596f35225?source=collection_archive---------0-----------------------#2021-07-26">https://medium.com/codex/implementation-of-server-sent-events-and-eventsource-live-progress-indicator-using-react-and-723596f35225?source=collection_archive---------0-----------------------#2021-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="aa86" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解SSE如何使用现实生活中的用例——使用Spring Boot和React进行文件上传时的加载百分比指标。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/46821b3bf119bd16578e57d86e9d6d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OW43FHM49m8wOCVw"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae jn" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>拍摄的照片</figcaption></figure><p id="da54" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你心里有这个疑问- <strong class="jq hj"> <em class="kk">什么是服务器发送事件？</em> </strong> <em class="kk"> </em>那么我强烈推荐你通读这篇文章——<a class="ae jn" rel="noopener" href="/codex/getting-started-with-server-sent-events-and-understanding-when-to-use-polling-websockets-and-sse-87465f3bcf63"><strong class="jq hj">服务器发送事件入门</strong> </a> <strong class="jq hj">。</strong></p><blockquote class="kl"><p id="d05d" class="km kn hi bd ko kp kq kr ks kt ku kj dx translated"><a class="ae jn" href="https://github.com/arpan-banerjee7/sse-progressbar" rel="noopener ugc nofollow" target="_blank"> GitHub链接到我要在这里解释的演示。</a></p></blockquote><h2 id="3199" class="kv kw hi bd kx ky kz la lb lc ld le lf jx lg lh li kb lj lk ll kf lm ln lo lp bi translated">这里是为那些着急的人准备的关于SSE的简要信息！</h2><p id="e3b9" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated"><em class="kk"> SSE是HHTP流之上的一个轻量级协议，允许客户端拥有超轻量级的仅订阅功能。与WebSockets不同，SSE不提供双向通信的能力，但是可以被服务器用来实时地将数据推送到客户端。SSE使客户端能够通过HTTP连接从服务器接收自动更新。它旨在使用JavaScript EventSource API在任何流行的浏览器中订阅数据流。</em> <em class="kk">通过这个接口，客户端请求一个特定的URL来接收一个事件流。</em></p><p id="5ba7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当您有一些快速更新的数据要显示，但您不想轮询服务器时，您可以考虑使用服务器发送的事件。示例可能包括显示长期运行的业务流程的状态，跟踪股票价格更新，或显示社交媒体网络上帖子的当前赞数。</p><p id="7235" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，你知道什么是SSE，我将向你解释以下事情-</p><ul class=""><li id="d7b9" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated"><strong class="jq hj">使用案例是什么？</strong></li><li id="08c5" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated"><strong class="jq hj">我为什么选择使用SSE？</strong></li><li id="4e78" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">什么是事件？</li><li id="94cb" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated"><strong class="jq hj">实施细节。</strong></li></ul><h1 id="9f4e" class="mj kw hi bd kx mk ml mm lb mn mo mp lf io mq ip li ir mr is ll iu ms iv lo mt bi translated">用例</h1><p id="e6ec" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">系统处理文件，提取某些信息，然后保存。根据网速的不同，有时用户可能要等很长时间。因此，为了使用户体验尽可能愉快，<strong class="jq hj">在文件上传时，显示一个实时进度条，显示服务器到目前为止已经处理了多少，而不是在进度条中重复点击端点。</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/c6e09fb6133e4819c25e52b8e8264fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0vS1rW0x0cKei76R2WzrVQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">服务器发送的事件</figcaption></figure><h1 id="6d24" class="mj kw hi bd kx mk ml mm lb mn mo mp lf io mq ip li ir mr is ll iu ms iv lo mt bi translated">为什么选择SSE？</h1><p id="91f0" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">要求是显示一个百分比，指示该文件中处理(解析/读取)了多少数据，然后在处理完成后保存文件时最终显示100%。因此，我需要一种方法来持续地与客户机通信，向它发送已处理文件的百分比。</p><p id="a498" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">服务器发送的事件是实现这个用例的一个很好的解决方案。我不得不<em class="kk">显示快速更新的数据，而不必轮询服务器，因为它是关于同一HTTP请求的进度。</em></p><p id="1067" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">要理解SSE是如何工作的，首先需要知道什么是事件。</strong></p><h1 id="dc7e" class="mj kw hi bd kx mk ml mm lb mn mo mp lf io mq ip li ir mr is ll iu ms iv lo mt bi translated">什么是事件？</h1><p id="9740" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">服务器可以在关闭连接之前发送多个事件。服务器发送的消息应该是基于文本的，消息以关键字开头，后跟冒号(:)，然后是字符串消息。“数据”是代表给客户的消息的关键字。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="2acb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在多条消息的情况下，消息应该用空行分开，否则客户端将把它们作为一个事件处理。浏览器将上述四行连接起来，并发出一个事件。为了将消息彼此分开，服务器需要在每条消息后发送一个空行。当你在Spring中发送多条消息时，用于发送消息的SseEmitter 会处理下一行和关键字格式。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="05c2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了在浏览器中处理这些事件，应用程序需要为<code class="du mx my mz na b">message</code>事件注册一个监听器。事件对象的属性<code class="du mx my mz na b">data</code>包含消息。浏览器过滤掉关键字<code class="du mx my mz na b">data</code>和冒号，只将冒号后的字符串赋给<code class="du mx my mz na b">event.data</code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div></figure><h2 id="e5f6" class="kv kw hi bd kx ky nb la lb lc nc le lf jx nd lh li kb ne lk ll kf nf ln lo lp bi translated">命名事件</h2><p id="640c" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">服务器可以给带有<code class="du mx my mz na b">event:</code>关键字的消息分配一个事件名称。<code class="du mx my mz na b">event:</code>行可以在<code class="du mx my mz na b">data:</code>行之前或之后。在本例中，服务器发送4条消息。第一个消息是一个<code class="du mx my mz na b">add</code>事件，第二个<code class="du mx my mz na b">remove</code>事件接着又是一个<code class="du mx my mz na b">add</code>事件，最后一个消息是一个未命名的事件。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="8409" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">客户端以不同的方式处理命名事件。它们不会触发<code class="du mx my mz na b">message</code>处理程序。命名事件发出一个与事件本身同名的事件。对于这个例子，我们需要3个监听器来处理所有的消息。您不能使用<code class="du mx my mz na b">on...</code>语法向这些事件注册监听器。它们必须在<code class="du mx my mz na b">addEventListener</code>功能中注册。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="4bac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这个演示中，我将使用<strong class="jq hj">命名事件</strong>来解决并发问题。使用命名事件，多个客户端可以同时调用我的“上传文件”服务，而不会出现任何问题。每个客户端的进度百分比将根据他们的文件处理和上传状态。一个客户端的进度百分比不会搞乱另一个。请仔细阅读实现细节，了解我是如何做到这一点的。</p><h1 id="2925" class="mj kw hi bd kx mk ml mm lb mn mo mp lf io mq ip li ir mr is ll iu ms iv lo mt bi translated">实施细节</h1><p id="fe71" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">在这个演示中，我将使用<strong class="jq hj"> Spring Boot </strong>和<strong class="jq hj">反应</strong>。</p><p id="7704" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Spring Boot提供了一种通过使用Flux来实现SSE的方法，Flux是事件流的反应式表示，然而，在本文中，我将使用Spring的<a class="ae jn" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/SseEmitter.html" rel="noopener ugc nofollow" target="_blank"> SseEmitter </a>类来创建一个异步控制器，它将向客户端发出多条消息。</p><p id="9212" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是应用程序的高层架构图。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ng"><img src="../Images/dde63b3d0e6fde80b030caae15a74db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1aD6rliNjyImmFwbzDj8KA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">高层架构</figcaption></figure><h2 id="9cd1" class="kv kw hi bd kx ky nb la lb lc nc le lf jx nd lh li kb ne lk ll kf nf ln lo lp bi translated">SSE中涉及的一般步骤是-</h2><ol class=""><li id="524f" class="lv lw hi jq b jr lq ju lr jx nh kb ni kf nj kj nk mb mc md bi translated">客户端打开一个HTTP连接。</li><li id="5e7e" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj nk mb mc md bi translated">服务器可以向该连接异步发送任意数量的事件(消息)。</li><li id="6cad" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj nk mb mc md bi translated">服务器可以关闭一个连接，也可以因为一些网络错误或服务器端的任何异常而关闭。</li><li id="f0d3" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj nk mb mc md bi translated">如果由于服务器的任何错误或任何网络错误导致连接关闭，客户端将自动尝试重新连接</li></ol><h1 id="f866" class="mj kw hi bd kx mk ml mm lb mn mo mp lf io mq ip li ir mr is ll iu ms iv lo mt bi translated">Spring Boot的服务器端实现</h1><h2 id="da38" class="kv kw hi bd kx ky nb la lb lc nc le lf jx nd lh li kb ne lk ll kf nf ln lo lp bi translated">项目结构</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nl"><img src="../Images/d8277a69c7c346a8a55d53aaa56f0f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*5vdCjzSkPKfhwDYKD9SilA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">项目结构</figcaption></figure><p id="85e2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我创建了一个异步<code class="du mx my mz na b">REST</code>控制器，用两种方法响应HTTP请求。一个带<code class="du mx my mz na b">@GetMapping</code>标注，另一个带<code class="du mx my mz na b">@PostMapping</code>标注。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">ProgressController.java</figcaption></figure><pre class="iy iz ja jb fd nm na nn no aw np bi"><span id="df66" class="kv kw hi na b fi nq nr l ns nt">private Map&lt;String, SseEmitter&gt; sseEmitters = new ConcurrentHashMap&lt;&gt;();</span></pre><ol class=""><li id="a0ef" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj nk mb mc md bi translated">在类级别声明的这个<strong class="jq hj">映射</strong>跟踪为每个客户端创建的SseEmitters。我使用了<a class="ae jn" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html" rel="noopener ugc nofollow" target="_blank"> ConcurrentHashMap </a>来实现并发性和线程安全。</li><li id="f894" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj nk mb mc md bi translated">在第一个带有<code class="du mx my mz na b">@GetMapping("/progress")</code>注释的方法中，我创建了一个SseEmitter对象，并在构造函数中使用了一个可选的超时参数。我将超时设置为一个很大的值，这样它就不会自动超时。<strong class="jq hj">该方法生成随机UUID，创建SseEmitter的对象，存储在map中，key为随机UUID，value为SseEmitter的对象。</strong>该UUID用于唯一识别每个客户。随着阅读的深入，你会明白这是怎么做到的。</li><li id="48bc" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj nk mb mc md bi translated">带<code class="du mx my mz na b">@PostMapping("upload/local</code>注释的第二个方法是监听<code class="du mx my mz na b">POST</code>上传文件的请求。它以多部分请求的形式接收文件，以字符串的形式接收唯一的UUID。然后，它从map中检索SseEmitter对象(在步骤1中定义)，并将该对象传递给<code class="du mx my mz na b">FileStorageService</code>。</li></ol><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">FileStorageService.java</figcaption></figure><p id="157e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">4.<code class="du mx my mz na b">FileStorageService</code>逐行读取文件并运行一些内部逻辑来计算百分比。在这里，您必须编写逻辑来计算百分比，并使用传递给它的SseEmitter对象来发出它。出于演示目的，我编写了一个简单的逻辑来计算逐行读取文件时的百分比。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">应用程序.属性</figcaption></figure><p id="cadf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可以通过在<code class="du mx my mz na b">application.properties</code>文件中写入这两个属性来定义可以上传的最大文件大小。</p><p id="9392" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">–<code class="du mx my mz na b">spring.servlet.multipart.max-file-size</code>:每个请求的最大文件大小。<br/>–<code class="du mx my mz na b">spring.servlet.multipart.max-request-size</code>:多部分/表单数据的最大请求大小。</p><p id="320a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果出现错误，可以用完整的错误<strong class="jq hj"> </strong>方法发送一个特殊事件。这将向客户端指示错误。</p><p id="dafc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，在发送完所有消息后，您必须通过调用一个<strong class="jq hj"> complete </strong>方法关闭连接来完成发射器，然后使用UUID键将其从地图中移除。</p><h1 id="e3ea" class="mj kw hi bd kx mk ml mm lb mn mo mp lf io mq ip li ir mr is ll iu ms iv lo mt bi translated">React.js中的客户端实现</h1><p id="64e9" class="pw-post-body-paragraph jo jp hi jq b jr lq ij jt ju lr im jw jx ls jz ka kb lt kd ke kf lu kh ki kj hb bi translated">事件可以在任何javascript库或框架中处理，如react、angular等。我在这个演示中使用了<strong class="jq hj"> React </strong>。</p><h2 id="85b3" class="kv kw hi bd kx ky nb la lb lc nc le lf jx nd lh li kb ne lk ll kf nf ln lo lp bi translated">项目结构</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nu"><img src="../Images/a64ec0ab45d6c4098c7ecd33d8f1b24e.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*VaL2lLk5FtiQFdrCLerW2A.png"/></div></figure><p id="927b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我简单地用<code class="du mx my mz na b">create-react-app</code>创建了一个react项目，并使用<code class="du mx my mz na b">EventSource</code>接口订阅端点，如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">ProgressBarComponent.js</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nv"><img src="../Images/213651602457c5e04973a7a0f32fd576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3gUz_VugItaHpcca84lKxw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">用户界面</figcaption></figure><p id="3288" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当用户选择一个文件并单击upload按钮时，客户机打开一个与带有服务器API URL的EventSource对象的连接。</p><pre class="iy iz ja jb fd nm na nn no aw np bi"><span id="f572" class="kv kw hi na b fi nq nr l ns nt">const eventSource = new EventSource("http://localhost:8080/progress");</span></pre><p id="ef25" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它还为名为<code class="du mx my mz na b">GUID</code>的事件注册了一个EventListener，以处理从服务器返回的事件。同时，服务器发送一个名为<code class="du mx my mz na b">GUID</code>的事件，其中的数据是唯一的UUID。这个UUID用于唯一地标识客户。客户端捕获这个UUID，并设置另一个唯一UUID类型的EventListener。</p><p id="19cd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="kk">对于所有来自服务器的成功事件，在注册事件监听器时作为第二个参数传递的回调方法将被调用，其中一个参数作为事件对象。从服务器发送的消息可以使用属性' data '从事件对象中检索，所以</em><strong class="jq hj"><em class="kk">event . data</em></strong><em class="kk">将保存服务器发送的消息。这个event.data可以是一个简单的字符串或JSON字符串。如果它是一个JSON字符串，你必须解析它:</em></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="c083" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，在读取文件时，用某种逻辑计算百分比，并将其作为数据发送给唯一UUID类型的事件，该事件是在客户端首次打开连接时生成的。</p><p id="90da" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果在上传过程中另一个客户端调用上传API，则会生成一个新的唯一UUID，创建一个新的SseEmitter对象并将其放入映射中。现在，百分比值是为这次调用新计算的，不会影响之前正在进行的进度条。</p><p id="c5b9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">还有另外两个内置事件，一个是'<strong class="jq hj"> open </strong>，一旦从服务器收到200 status，就会调用这个事件。另一个事件是'<strong class="jq hj"> error </strong>'，每当出现网络错误时，以及当服务器通过调用发射器上的'<strong class="jq hj"> complete </strong>'或'<strong class="jq hj"> completeWithError </strong>'方法关闭连接时，都会调用这个事件。您可以通过调用<code class="du mx my mz na b"><strong class="jq hj">event.target.close</strong>();</code>在客户端关闭连接，否则，如果您在创建SseEmitters时使用了<code class="du mx my mz na b">.reconnectTime(1000)</code>，客户端将会在出错时继续重试连接。</p><blockquote class="nw nx ny"><p id="05d4" class="jo jp kk jq b jr js ij jt ju jv im jw nz jy jz ka oa kc kd ke ob kg kh ki kj hb bi translated">我使用了<a class="ae jn" href="https://ant.design/components/progress/#header" rel="noopener ugc nofollow" target="_blank"> Ant设计进度组件</a>作为进度指示器。</p></blockquote><p id="8a1b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是使用服务器发送的事件在文件上传中显示实时百分比的方式。</p><p id="54af" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是应用程序的演示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oc"><img src="../Images/70dcf02ad53ebfc2ea3145c9a8730987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2ato7dGklnwxuupvApQbOQ.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">现场演示</figcaption></figure><p id="db6b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">完整代码可以在我的<a class="ae jn" href="https://github.com/arpan-banerjee7/sse-progressbar" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> GitHub </strong> </a> repo中找到。</p></div><div class="ab cl od oe gp of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="hb hc hd he hf"><p id="d841" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是这篇博客的全部内容。请在<a class="ae jn" href="https://arpan-banerjee7.medium.com/" rel="noopener"> Medium </a>、<a class="ae jn" href="https://www.linkedin.com/in/banerjee-arpan7/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>和<a class="ae jn" href="https://github.com/arpan-banerjee7" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我，以获得更多类似的博客！</p></div></div>    
</body>
</html>