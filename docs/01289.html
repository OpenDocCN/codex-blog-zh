<html>
<head>
<title>Building a Simple Sudoku Solver in Python with numPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用numPy在Python中构建一个简单的数独求解器</h1>
<blockquote>原文：<a href="https://medium.com/codex/building-a-simple-sudoku-solver-in-python-with-numpy-1a8ea6f5bff5?source=collection_archive---------1-----------------------#2021-04-17">https://medium.com/codex/building-a-simple-sudoku-solver-in-python-with-numpy-1a8ea6f5bff5?source=collection_archive---------1-----------------------#2021-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="bc95" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">让你思考基本算法的10分钟项目</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/429831a48424be7bd6eddcec3e9beb05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06UafLHYBIhRdn7Fu0Uqaw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">一个数独谜题，来源:<a class="ae jn" href="https://en.wikipedia.org/wiki/Sudoku" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="303d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">【如果你只想看最终的算法，我已经在本文末尾链接了我的完整笔记本】。</strong></p><p id="b1f0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">数独是一个非常普遍的谜题，它甚至有<a class="ae jn" href="http://World_Sudoku_Championship" rel="noopener ugc nofollow" target="_blank">自己的世界冠军</a>你相信吗？</p><p id="aac7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这是一个从超级简单到难度令人沮丧的“拔头发”的难题。</p><p id="94ea" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于外行来说，规则如下:</p><ul class=""><li id="876f" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">您从一个9x9的网格(如上)开始，填充一些数字</li><li id="8201" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">您必须用1-9之间的数字填充网格中的所有空白方块</li></ul><p id="a1af" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有点棘手的是，必须遵循以下规则:</p><ul class=""><li id="2f6d" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">任何行中都不能有重复的数字</li><li id="d55d" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">任何列中都不能有重复的数字</li><li id="d308" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">在任何3x3子网格中，数字都不能重复*</li></ul><p id="fc41" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">a*子网格是9个不重叠的3x3网格之一，如下所示，由较粗的黑线分隔。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ky"><img src="../Images/20bab404fdd41f71519abd018aa4831c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*9yTe9ysYGZKppRrB.jpg"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">一个“子网格”，来源:<a class="ae jn" href="https://sudoku.com/how-to-play/sudoku-rules-for-complete-beginners/" rel="noopener ugc nofollow" target="_blank">sudoku.com</a></figcaption></figure><p id="8896" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以到最后，你将得到一个9x9的网格，其中从1到9的所有数字重复<strong class="jq hj">正好</strong> 9次:每行1个，每列1个，每个子网格1个。</p><p id="9fff" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个谜题的美妙之处在于，假设它已经被<a class="ae jn" href="https://puzzling.stackexchange.com/questions/2/what-is-the-maximum-number-of-solutions-a-sudoku-puzzle-can-have" rel="noopener ugc nofollow" target="_blank">恰当地设计</a>，那么只有一个解决方案，并且这个解决方案可以不需要任何猜测而仅仅通过逻辑来实现。</p><h1 id="e364" class="kz la hi bd lb lc ld le lf lg lh li lj io lk ip ll ir lm is ln iu lo iv lp lq bi translated">自动化的机会</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/7c7d085ac9c32d42519ce22a402c53ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6_n15bO6xLWG7rX4"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">罗伯特·威德曼在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5dad" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果这是一个仅用逻辑就能解决的问题，那么我们没有理由不能使用编程来获得解谜的乐趣！</p><p id="7b13" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们需要什么？</p><ul class=""><li id="c040" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">将数独棋盘表示为矩阵的一种方式(用数字的行和列来表示的奇特方式)</li><li id="fc60" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">一种检查每个空单元格可能接受的数字的方法</li><li id="14cf" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">当只有一个可能的数字时填充单元格的一种方式</li></ul><p id="fa86" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们开始吧！</p><p id="b0d4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们首先制作一个由0组成的9x9网格(其中0代表一个空单元格)。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="aa32" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们快速看一下输出。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lu"><img src="../Images/2a64c2635b6163e693c4a9d6145c3765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*KHS1_DRWoHslHjDoFpVv5Q.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="8d32" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它有点像是在工作，但它可以更整洁——能够看到3x3的子网格将非常有帮助。</p><p id="9b05" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们为什么不创建一个函数来使黑板看起来更好一点呢？</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="bcdf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们来看看这个新函数。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lv"><img src="../Images/4b03c805f5550ca7d2590fb7dbf7ff66.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*_4zsy5WCyOttw3s-SVaRkg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="0be5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">可能有一些库可以让它看起来更好，但是现在这样就可以了。</p><h2 id="cd46" class="lw la hi bd lb lx ly lz lf ma mb mc lj jx md me ll kb mf mg ln kf mh mi lp mj bi translated">设置初始电路板</h2><p id="cfda" class="pw-post-body-paragraph jo jp hi jq b jr mk ij jt ju ml im jw jx mm jz ka kb mn kd ke kf mo kh ki kj hb bi translated">我在这里使用了一个随机的拼图作为例子，但是你可以随意使用你自己的拼图——或者一个更有创造性的方法来设置初始的板。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mp"><img src="../Images/104baf4dca7952de0b8e737de6ca695e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*X_KJ7pZ7dirHM2stjt9hhg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="0663" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在开始有趣的部分！</p><h2 id="2c25" class="lw la hi bd lb lx ly lz lf ma mb mc lj jx md me ll kb mf mg ln kf mh mi lp mj bi translated">逻辑</h2><p id="5660" class="pw-post-body-paragraph jo jp hi jq b jr mk ij jt ju ml im jw jx mm jz ka kb mn kd ke kf mo kh ki kj hb bi translated">当解决任何涉及逻辑的问题时，在编写任何代码之前，在纸上写下你要做的事情会有所帮助。</p><p id="916c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这种情况下，我们希望:</p><ol class=""><li id="6bd0" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj mq kq kr ks bi translated">从左上角开始遍历每个空单元格(0)</li><li id="7584" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj mq kq kr ks bi translated">将该单元格的可能值设置为从1到9的数字列表，即第一次检查时的<strong class="jq hj"/></li><li id="78a3" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj mq kq kr ks bi translated">检查同一行中的所有数字，从可能匹配的值列表中删除所有数字</li><li id="b18c" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj mq kq kr ks bi translated">对同一列中的数字执行上述操作</li><li id="4df4" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj mq kq kr ks bi translated">对同一子网格中的数字执行上述操作</li><li id="59e3" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj mq kq kr ks bi translated">对剩余的空单元格重复步骤1-5</li><li id="f9c8" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj mq kq kr ks bi translated">如果棋盘被解决(没有剩余的0)，则完成，否则重复步骤1-6<strong class="jq hj">，不包括</strong>步骤2</li></ol><p id="d06c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">检查矩阵中的行和列的数字很简单，但是检查子网格中的数字需要更多的思考。</p><h2 id="4903" class="lw la hi bd lb lx ly lz lf ma mb mc lj jx md me ll kb mf mg ln kf mh mi lp mj bi translated">子网格</h2><p id="f5af" class="pw-post-body-paragraph jo jp hi jq b jr mk ij jt ju ml im jw jx mm jz ka kb mn kd ke kf mo kh ki kj hb bi translated">我们需要能够选取任何一个细胞，并计算出它位于哪个子网格中。</p><p id="986e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，第4行第3列的单元格位于从左上角向下的第二个子网格中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mr"><img src="../Images/97d94258187df89a05057bb8ab051e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*C1gZSEMgFw39pRku0yWtAQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="dab7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以将一个子网格表示为一个3x3的矩阵，矩阵中包含的数字。</p><p id="f144" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了得到一个单元格所在的3×3矩阵，我们需要能够将该单元格的行和列位置向上舍入到3的下一个最大倍数。</p><p id="8b76" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在上例中，行位置(4)的下一个最大倍数3是<strong class="jq hj"> 6 </strong>，列位置(3)的下一个最大倍数3是<strong class="jq hj"> 3 </strong>。</p><p id="00cb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后我们可以简单地取这些末端位置，并从每个位置减去3，得到子网格的起始位置。</p><p id="7660" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，上面的子网格可以用board_init[3:6，0:3]表示，记住Python从0开始索引(计数)。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ms"><img src="../Images/b52fb2ba213cc5d9231d7c0ed5d4bca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*RjfGQt59N6LKH3ZrY8yb4A.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="3da4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们来做一个函数，它可以向上舍入到3的下一个最大倍数。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="62c3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们来看看行索引-3(同样，行位置 4在Python中表示3的行索引<strong class="jq hj">并看看它会做什么:</strong></p><ul class=""><li id="bdd4" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">取指数+ 1 (4)</li><li id="b6a1" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">除以3 (1.333…)</li><li id="1f33" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">使用<code class="du mt mu mv mw b">ceil</code> (2)将其向上舍入为最接近的整数</li><li id="2bf4" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">把它乘以3 (6)</li></ul><h2 id="7341" class="lw la hi bd lb lx ly lz lf ma mb mc lj jx md me ll kb mf mg ln kf mh mi lp mj bi translated">独特的价值观</h2><p id="07bb" class="pw-post-body-paragraph jo jp hi jq b jr mk ij jt ju ml im jw jx mm jz ka kb mn kd ke kf mo kh ki kj hb bi translated">现在，我们可以进入逻辑的核心了——获取与给定单元格共享的行、列和子单元格中的唯一值的列表。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="7b3c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不要担心它会在这里拾取0，因为我们会在后面的步骤中处理它们。</p><p id="b116" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于我们之前的例子，我们预计是这样的:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mr"><img src="../Images/62bfec46cc6f8a7ea5c3f0278011f878.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*AaHH-GDZjxBL3HhdZltj-g.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="d056" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">独特的价值观:</p><ul class=""><li id="69bc" class="kk kl hi jq b jr js ju jv jx km kb kn kf ko kj kp kq kr ks bi translated">第5、6、7、8排</li><li id="d55e" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">列:1，5</li><li id="dfd1" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated">子单元:1，2，3，5，8</li><li id="f38a" class="kk kl hi jq b jr kt ju ku jx kv kb kw kf kx kj kp kq kr ks bi translated"><strong class="jq hj">总体:</strong> 1，2，3，5，6，7，8</li></ul><p id="172c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于这个单元格，我们希望将<code class="du mt mu mv mw b">4,9</code>存储为唯一可能的值，因为它们是从1到9中唯一没有出现在我们的行/列/子单元格唯一列表中的数字。</p><p id="b537" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我们发现一个单元格只有<strong class="jq hj">个</strong>可能值，我们希望将该值写入该单元格。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="abd5" class="kz la hi bd lb lc ld le lf lg lh li lj io lk ip ll ir lm is ln iu lo iv lp lq bi translated">付诸行动</h1><p id="9fee" class="pw-post-body-paragraph jo jp hi jq b jr mk ij jt ju ml im jw jx mm jz ka kb mn kd ke kf mo kh ki kj hb bi translated">最难的部分已经过去了，现在来试运行一下吧！</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="1f63" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我将省去中间的打印输出，但这是最终输出的样子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mx"><img src="../Images/e3b58487184aa134a5f62715b43896d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*nFuBHV-tm88BX0YRGX5atQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="5011" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是我们的，一个简单的数独解算器。</p><p id="2106" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">如果你想看到上面所有代码的完整笔记本，这里有</strong><a class="ae jn" href="https://github.com/jack-cook-repo/python/blob/master/Sudoku%20solver.ipynb" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj"/></a><strong class="jq hj">。</strong></p><p id="b0dd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>