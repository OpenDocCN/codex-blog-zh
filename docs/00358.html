<html>
<head>
<title>Read YAML content of Zip file with a ZipInputStream</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用ZipInputStream读取Zip文件的YAML内容</h1>
<blockquote>原文：<a href="https://medium.com/codex/read-yaml-content-of-zip-file-with-a-zipinputstream-2b12b3f92f97?source=collection_archive---------3-----------------------#2021-01-22">https://medium.com/codex/read-yaml-content-of-zip-file-with-a-zipinputstream-2b12b3f92f97?source=collection_archive---------3-----------------------#2021-01-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f024df32cd9347ca4d711b8d0cfa0dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KCtaWgup06Bg5ZjO49vIw.png"/></div></div></figure><p id="6262" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我最近遇到的一个问题是，我需要读取一些压缩文件的内容，我不想将它们解压缩到temp中，因为我真的只需要字符串形式的内容。我有一些Zip文件，其中包含一个Metadata.yaml文件，其中包含一些信息，如id或标题。我想读取Metadata.yaml文件的内容，并将值放入一个数据类，然后存储在一个HashMap中。</p><p id="429c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我的一些文件不包含Metadata.yaml文件，所以为了弥补这一点，我们使用documentTitle作为HashMap的id，也作为数据类的id和标题。</p><p id="0c66" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在对Kotlin中的解压缩文件进行了相当长时间的研究后，我偶然发现了ZipInputStream，它本质上只是一个数据流，可以像任何其他数据类型一样进行处理。</p><h1 id="b71f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">getMetadata函数</h1><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="2e28" class="kv jp hi kr b fi kw kx l ky kz"><em class="la">fun </em>getMetadata(filePath: File): Meta {<br/>    <em class="la">val </em>inputStream = ZipInputStream(filePath.<em class="la">inputStream</em>())<br/>    <em class="la">val </em>documentTitle = filePath.<em class="la">name</em>.<em class="la">substringBefore</em>(".zip")<br/><br/>    <em class="la">return </em>mapObjects(getStringFromZip(inputStream, documentTitle), documentTitle)<br/>}</span></pre><p id="fa03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个函数用filePath创建一个ZipInputStream。该文件需要存在，此操作才能进行。documentTitle只是zip文件的名称，但没有。zip扩展。</p><p id="f127" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该函数触发mapObjects函数并为其提供两个字符串，其中一个由getStringFromZip方法生成。第二个字符串就是我们之前定义的documentTitle。我们将在这里查看getStringFromZip函数。</p><h1 id="26b5" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">getStringFromZip函数</h1><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="d2ac" class="kv jp hi kr b fi kw kx l ky kz"><em class="la">fun </em>getStringFromZip(zis: ZipInputStream, filePath: String) :String{<br/>    <em class="la">var </em>metadataString = ""<br/>    zis.<em class="la">use </em><strong class="kr hj">{ </strong>zipStream <strong class="kr hj">-&gt;<br/>        </strong><em class="la">generateSequence </em><strong class="kr hj">{ </strong>zipStream.<em class="la">nextEntry </em><strong class="kr hj">}<br/>            </strong>.<em class="la">filter </em><strong class="kr hj">{ it</strong>.<em class="la">name </em>== "$filePath" <strong class="kr hj">}</strong>.<em class="la">forEach </em><strong class="kr hj">{<br/>                </strong>metadataString = zipStream.<em class="la">reader</em>().<em class="la">readText</em>()<br/>            <strong class="kr hj">}<br/>    }<br/>    </strong><em class="la">return </em>metadataString<br/>}</span></pre><p id="2cd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该函数从getMetadata函数获取ZipInputStream和documentTitle，并创建一个名为metadataString的新字符串。它使用ZipInputStream并从中创建一个zipStream。每个zipStream都是ZipFile中的一个条目。它生成一个序列，确保所有的条目都被访问。因为我只想要Metadata.yaml文件，所以我向序列添加了一个过滤器，它将条目的名称与Metadata.yaml相匹配。</p><p id="4f8e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于过滤标准为真的每个条目(在我的例子中只有一个)，它覆盖metadataString并将其设置为清单文件的内容。最后，我只是返回metadataString。</p><h1 id="7f9a" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">mapObjects函数</h1><p id="79d1" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">由于我们现在从前面的方法中获得了字符串形式的文件内容，我们只需读出字符串的YAML值。</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="140d" class="kv jp hi kr b fi kw kx l ky kz"><em class="la">val </em>mapper = ObjectMapper(YAMLFactory()) //creates Object Mapper</span><span id="c511" class="kv jp hi kr b fi lg kx l ky kz"><em class="la">fun </em>mapObjects(str: String, documentTitle: String): Meta {<br/>    mapper.findAndRegisterModules()<br/>    <em class="la">return if </em>(str != "") {<br/>        <em class="la">val </em>meta: Meta = mapper.readValue&lt;Meta&gt;(str, Meta::<em class="la">class</em>.<em class="la">java</em>)<br/>        meta<br/>    } <em class="la">else </em>{<br/>        Meta(documentTitle, documentTitle)<br/>    }<br/>}</span><span id="2aec" class="kv jp hi kr b fi lg kx l ky kz"><em class="la">data class </em>Meta(<em class="la">val </em>id: String, <em class="la">val </em>title: String)</span></pre><p id="1f86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们必须创建一个带有YAMLFactory的ObjectMapper。我在函数之外的位置定义了它，因为我想多次使用同一个映射器，不想每次都创建它。</p><p id="333d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我之前提到的，不是每个文件都有Manifest.yaml文件，也不是有内容的字符串。如果字符串为空，我只返回documentTitle作为id和标题。如果字符串不为空，它会让映射器读取YAML值，并将它们放入数据类的构造函数中。</p><p id="f919" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">映射器的梯度依赖关系:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="4047" class="kv jp hi kr b fi kw kx l ky kz">compile "com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.11.1"</span></pre><h1 id="0191" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">将值添加到散列表中</h1><p id="e9fc" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">只需创建一个新的hashMap，并将两个函数调用放入其中。散列表的id将是清单的id，散列表的值将是包含值的数据类。</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="b1f7" class="kv jp hi kr b fi kw kx l ky kz"><em class="la">val </em>metadata = <em class="la">hashMapOf</em>&lt;String, Meta&gt;()</span><span id="4998" class="kv jp hi kr b fi lg kx l ky kz">metadata.put(getMetadata(zipFile).id, getMetadata(zipFile))</span></pre></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="c150" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这篇文章是有用的，你现在能够读出Zip文件的内容。</p></div></div>    
</body>
</html>