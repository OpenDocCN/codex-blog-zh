<html>
<head>
<title>Performance tuning for an AWS Lambda-based API (Detecting Paris’ locked bicycle stations 5/5)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于AWS Lambda的API的性能调优(检测巴黎的5/5锁定自行车站)</h1>
<blockquote>原文：<a href="https://medium.com/codex/performance-tuning-for-an-aws-lambda-based-api-b8b49b2d07db?source=collection_archive---------1-----------------------#2021-11-21">https://medium.com/codex/performance-tuning-for-an-aws-lambda-based-api-b8b49b2d07db?source=collection_archive---------1-----------------------#2021-11-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ca382dcdc23666771acf6e2b427cb35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sWhVQaw2n8ms7Rga"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">亚采克·迪拉格在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="iv iw ix"><p id="b1d3" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这一系列文章是关于我在学习如何使用AWS无服务器堆栈的同时，花了太多时间试图解决一个小问题(检测巴黎上锁的自行车站，见<a class="ae iu" rel="noopener" href="/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-1-95dcdb477649">第一部分</a>)。要查找其他文章，请跳到页面底部。</p></blockquote></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="17e1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">在第4部分的<a class="ae iu" rel="noopener" href="/codex/creating-a-serverless-api-and-hosting-a-frontend-with-s3-b50e61a8f707">中，我为我的</a><a class="ae iu" href="http://www.velinfo.fr" rel="noopener ugc nofollow" target="_blank"> www.velinfo.fr </a> web应用程序创建了前端和API，该应用程序计算并显示1500个巴黎自行车站点的状态。</p><p id="a101" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">一切都很好，但网站相当慢。静态内容的加载需要一些时间，API的响应速度也不是很快。我该如何改进呢？</p><h1 id="7668" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">使用CloudFront进行前端缓存</h1><p id="6538" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">当您想要更快地提供静态内容(如网站的静态文件)时，一个简单的解决方案是使用CDN或<a class="ae iu" href="https://en.wikipedia.org/wiki/Content_delivery_network" rel="noopener ugc nofollow" target="_blank">内容交付网络</a>。这是一个由服务器组成的分布式网络，将用来缓存你的内容(从简单的文件到视频)，尽可能地靠近你的用户。更准确地说，CDN将位于您的应用程序的“前面”，这意味着客户端将调用它而不是您的站点。如果CDN在缓存中没有内容，它将调用您的站点。</p><p id="b9b7" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">有很多独立的cdn可以选择，从Akamai到Cloudflare。但是，由于AWS有自己的CDN ( <a class="ae iu" href="https://aws.amazon.com/cloudfront" rel="noopener ugc nofollow" target="_blank"> CloudFront </a>)，我就用这个吧。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/8deb66fd3e35223115d614c126b497e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jeMugTgDQX-81GQEYw1d6A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">云锋位置</figcaption></figure><p id="ac2f" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">在CloudFormation模板中设置CloudFront很简单。您需要定义一个“分布”(CloudFront将如何缓存以及缓存什么)，并定义:</p><ul class=""><li id="f0bc" class="lp lq hi jb b jc jd jg jh ke lr kf ls kg lt jw lu lv lw lx bi translated">您想要缓存的HTTP方法(GET and HEAD for me)</li><li id="0036" class="lp lq hi jb b jc ly jg lz ke ma kf mb kg mc jw lu lv lw lx bi translated">“来源”是什么(CDN代理的内容的来源，在我们的例子中是网站的S3桶)</li><li id="8aad" class="lp lq hi jb b jc ly jg lz ke ma kf mb kg mc jw lu lv lw lx bi translated">什么是缓存行为(内容应该缓存多长时间，在丢失内容的情况下会发生什么……)</li><li id="21a3" class="lp lq hi jb b jc ly jg lz ke ma kf mb kg mc jw lu lv lw lx bi translated">要使用的<a class="ae iu" href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PriceClass.html" rel="noopener ugc nofollow" target="_blank">价格等级</a>是什么(对应于要使用的位置数量)</li></ul><p id="cfe1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">并且不要忘记更新“www.velinfo.fr”的CNAME DNS记录，以便它指向分布而不是S3桶。</p><p id="9fd5" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">所有这些都可以通过AWS web控制台完成，但至于我的应用程序的其余部分，我将直接在我的CloudFormation文件中定义它。</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="md me l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用CloudFormation建立的CloudFront发行版</figcaption></figure><h2 id="52ed" class="mf ki hi bd kj mg mh mi kn mj mk ml kr ke mm mn kv kf mo mp kz kg mq mr ld ms bi translated">性能改进</h2><p id="884c" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">为了评估性能提升，我将使用<a class="ae iu" href="https://tools.keycdn.com/performance" rel="noopener ugc nofollow" target="_blank">key dn的性能测试</a>并重点关注欧洲城市。最重要的指标是TTFB(到达第一个字节的时间)，它表示呼叫被应答之前的等待时间。</p><p id="672f" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">改进是显而易见的:从大约55毫秒到大约25毫秒。不错！</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/2cdba79d29d50d204055fd300a91be42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSsMvCQVuBxaiYgjfkf0qg.png"/></div></div></figure><blockquote class="iv iw ix"><p id="37c4" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hj">注意</strong>:现在CloudFront已经建立，我不再需要公开访问网站S3·巴特。只有CloudFront发行版可以访问它。</p></blockquote><h2 id="180b" class="mf ki hi bd kj mg mh mi kn mj mk ml kr ke mm mn kv kf mo mp kz kg mq mr ld ms bi translated">这要花多少钱？</h2><p id="b783" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">CloudFront <a class="ae iu" href="https://aws.amazon.com/cloudfront/pricing/" rel="noopener ugc nofollow" target="_blank">定价</a>基于三个轴:</p><ul class=""><li id="0618" class="lp lq hi jb b jc jd jg jh ke lr kf ls kg lt jw lu lv lw lx bi translated">从CloudFront传输到互联网的数据量:0.085美元/GB(流量越大越便宜)</li><li id="f776" class="lp lq hi jb b jc ly jg lz ke ma kf mb kg mc jw lu lv lw lx bi translated"><strong class="jb hj">从原点传输到CloudFront的数据量</strong>:0.020美元/GB</li><li id="f4dc" class="lp lq hi jb b jc ly jg lz ke ma kf mb kg mc jw lu lv lw lx bi translated"><strong class="jb hj">HTTP(S)调用的数量</strong>:0.0120美元/ 10.000 HTTPS调用</li></ul><p id="a399" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">目前，加载主页执行大约10个调用到我的前端域，大约300KB。对源的调用次数可以忽略不计，因为内容只会在部署后更改，所以它可以在缓存中保留很长时间。</p><p id="95e6" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">实际上，我不期望超过几千个用户。假设每天有10.000个用户，那么我每天会有大约3 GB的传出流量和大约100.000个呼叫，因此<strong class="jb hj">每天大约0.375美元</strong>。这并没有考虑到大部分静态内容将被缓存在客户端浏览器中的事实。</p><h1 id="9dc6" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">用X射线分析Lambda性能</h1><p id="07fd" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">我的站点的静态内容加载得更快了，但是我的API还是太慢了。</p><p id="7218" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">例如，<em class="ja"> GET /stations </em>端点，它返回每个自行车站点的当前状态、状况和特征，需要12秒以上才能完成！</p><p id="38c7" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">我已经确保我的DynamoDb调用是并行进行的，所以我不确定还能做些什么来进一步改进它。幸运的是，我可以使用AWS <a class="ae iu" href="https://aws.amazon.com/xray/" rel="noopener ugc nofollow" target="_blank"> X射线</a>更好地了解我的性能瓶颈在哪里。</p><p id="21f5" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">X-Ray是一个跟踪应用程序中每个调用的系统，有助于识别性能问题。要在NodeJs Lambda函数上使用它，您需要为您的函数启用它(例如，在web控制台中)，导入<code class="du mu mv mw mx b">aws-xray-sdk</code>包并使用<code class="du mu mv mw mx b">AWSXRay.CapureAWS()</code>方法包装对函数依赖项的调用(在我的例子中是对DynamoDb的调用)。</p><p id="f7fc" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">然后，在X射线web控制台中，您将能够看到函数执行过程中每个调用的详细轨迹:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/1b8879dfcd43a4db31c28c500b2cf1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRtDscXQiToWQmxFt37lKA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">GetStations函数调用的X射线跟踪。</figcaption></figure><p id="9377" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">在这里，我可以清楚地看到我的三个DynamoDb调用是正确地并行进行的，但是最长的一个调用持续了8秒钟！</p><p id="eca8" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">对于一个简单的读取操作来说，这似乎非常慢，那么DynamoDb有什么问题吗？嗯，这8秒钟不仅代表数据库端花费的时间，还代表函数端整理/解组数据花费的时间(DynamoDb将对象存储为类型化的JSON，需要在使用前进行处理)。并且这些类型的操作是CPU密集型的。</p><p id="cd2f" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">我们真正看到的是标准Lambda函数的CPU限制。</p><h2 id="64f9" class="mf ki hi bd kj mg mh mi kn mj mk ml kr ke mm mn kv kf mo mp kz kg mq mr ld ms bi translated">提高Lambda函数的CPU性能</h2><p id="c2a9" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">默认情况下，Lambda函数只使用128MB的内存，并且可以访问一小部分vCPU内核。增加内存很容易(通过在SAM/CloudFormation模板中设置<code class="du mu mv mw mx b">MemorySize</code>参数，最大可达10240MB)，但是没有办法分配更多的CPU。这是因为CPU能力会随着分配的内存自动扩展。</p><p id="c3de" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">简单来说:<strong class="jb hj">要有更多的CPU能力，你需要更多的内存</strong>。</p><p id="58c5" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">更具体地说，<a class="ae iu" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#configuration-memory-console" rel="noopener ugc nofollow" target="_blank">您在1769MB标记处达到了一个完整的vCPU内核</a>。一旦你分配了更多的内存，你将开始拥有不止一个线程，但是单线程的性能已经达到了1769MB。</p><p id="0dfd" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">因此，让我们将GetStations Lambda函数设置为1769MB，看看我们在全内核的情况下会获得什么样的性能提升。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/22af0850687a1a453bddba667e6d3e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yFaJrQfF4M17QhpiA21M1w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">增加内存达到一个完整的vCPU线程后的x射线跟踪。</figcaption></figure><p id="f7da" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">从12.6秒降到811毫秒，还不错😊。</p><p id="abbb" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">费用呢？内存的增加成比例地影响每毫秒的成本。这意味着我的1769MB Lambda的运行成本是标准128MB Lambda的14倍。但它的运行速度也快了15倍。因此，在我的例子中，增加内存(和性能)更便宜！</p><p id="b78a" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">对其他端点进行同样的优化可以获得类似的性能提升。我还可以为作为内部检测系统一部分的Lambda函数增加<em class="ja">内存大小</em>，但是我没有性能限制，因为它们只是每分钟运行一次。</p><h1 id="5d04" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">缓存API的多种方法</h1><p id="401a" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">既然服务于端点的每个Lambda函数都已优化，让我们做一个简单的性能测试。我会连续调用50次其中一个最重的端点(<em class="ja">GET/prediction/by-station</em>)。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es na"><img src="../Images/43c9303859ae2a3fd1eec61ce32ac243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*j0tm2aRExggtNWBv-Pkr7g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">对预测/按站端点的连续调用的响应时间。</figcaption></figure><p id="fede" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">对于前20次呼叫，端点表现一致。大约需要3秒钟完成。然后响应时间开始增加，一些调用失败，最后10个调用完全失败。</p><p id="8ce6" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">发生了什么事？嗯，我们刚刚检查了DynamoDb表的读取容量，所以我们的读取操作受到了限制。更糟糕的是，当端点失败时，内部检测管道的一些功能也失败了，因为它们从同一个表中读取数据，并且也被抑制了。</p><blockquote class="iv iw ix"><p id="662f" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">Y <!-- -->你会在第二部分的<a class="ae iu" href="https://ouvreboite.medium.com/detecting-locked-bicycle-stations-an-aws-serverless-story-part-2-b1967d639699" rel="noopener">中找到更多关于DynamoDb RCU(读容量单位)和WCU(写容量单位)的细节。</a></p></blockquote><p id="738a" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">换句话说:如果在我的API上有太多的调用，API就会失败，更糟糕的是，它可能会破坏内部检测管道。</p><p id="cb2d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">我能做什么？</p><p id="e0a1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">增加所有相关表的读取容量将是最简单的解决方案，但这可能很快变得代价高昂，因为我已经达到了自由层的极限。这只会推迟问题的解决，只是在失败前需要更多的呼叫。</p><p id="2f37" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">我还可以创建一组新的表，这些表只能由管道函数写入，由API函数读取。它们将作为隔离层。但是，要让这些表支持大量的呼叫，仍然需要更多的RCU，这是我无法承受的。</p><p id="8b53" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">与其试图增加我的表的吞吐量，也许我应该专注于寻找一种方法来缓存我的数据，这样我的表就更少被调用。</p><h2 id="7ebc" class="mf ki hi bd kj mg mh mi kn mj mk ml kr ke mm mn kv kf mo mp kz kg mq mr ld ms bi translated">命中率</h2><p id="9ed5" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">评估任何缓存解决方案的有用性和成本的一个重要指标是命中率。它是缓存能够应答的呼叫数与总呼叫数的比率。命中率越大，缓存就越有用。</p><p id="daf0" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">显然，命中率取决于我的API的设计和用例。例如，返回为调用者定制的数据的端点会导致低命中率，因为给定的响应只能为单个用户缓存。</p><p id="0af3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">幸运的是，我的API非常简单，只包含一些端点，没有参数，独立于用户，内容大约每60秒更新一次。所以我可以期待一个非常好的命中率。</p><h2 id="7789" class="mf ki hi bd kj mg mh mi kn mj mk ml kr ke mm mn kv kf mo mp kz kg mq mr ld ms bi translated">电动加速器</h2><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/e09eb7965dec42a434913f5ea78bea3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*ReLhGg_-UbnSaZFhYN2q7A.png"/></div></figure><p id="9208" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated"><a class="ae iu" href="https://aws.amazon.com/dynamodb/dax/" rel="noopener ugc nofollow" target="_blank"> DynamoDb加速器</a>(或DAX)是DynamoDb的托管缓存。</p><p id="77cd" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">更具体地说，它是一个<a class="ae iu" href="https://aws.amazon.com/blogs/database/amazon-dynamodb-accelerator-dax-a-read-throughwrite-through-cache-for-dynamodb/" rel="noopener ugc nofollow" target="_blank">通读/直写</a>缓存。这将极大地提高它缓存的DynamoDb表的读取性能，并且DAX响应的每个读取操作都不会消耗表中的任何读取容量。</p><p id="a9d6" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">在内部，它由一个或多个缓存节点的集群组成。可以把这些节点想象成AWS以您的名义创建的小型EC2实例。至于任何EC2实例，它们需要设置在子网中(VPC或虚拟私有云)。您需要为这些节点的大小和数量付费。最小的节点起价约为每月30美元。</p><p id="4d17" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">✅Fixed成本，将有利于所有功能，将提高所有调用的性能。</p><p id="a761" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">❌Requires更新数据层，需要建立一个VPC，不会减少Lambda或网关调用的数量，基础成本对于一个宠物项目来说是昂贵的。</p><h2 id="abca" class="mf ki hi bd kj mg mh mi kn mj mk ml kr ke mm mn kv kf mo mp kz kg mq mr ld ms bi translated">弹性缓存</h2><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/f64922e28691f008ef59faf6064c3aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*4_a6nWDDO_QoIkkRmn049Q.png"/></div></figure><p id="79e7" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated"><a class="ae iu" href="https://aws.amazon.com/elasticache" rel="noopener ugc nofollow" target="_blank">elastic cache</a>是AWS管理的分布式缓存。缓存技术可以是Memcached或Redis，这取决于您的需要。</p><p id="6c0e" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">Lamba可以连接到Elasticache集群来获取数据，剩下的实现就交给我了。我可以简单地将它用作副缓存，或者更新管道的函数，直接写入缓存，让API从缓存中读取数据，而不是DynamoDb表。</p><p id="9718" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">至于DAX，Elasticache内部由一组托管EC2实例组成，需要创建一个VPC。价格取决于节点的数量和大小，最小的节点大约每月10美元。但是，根据缓存的实现方式，您可能希望至少有两个节点来确保高可用性。</p><p id="e745" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">✅Fixed成本，缓存逻辑取决于你。</p><p id="b17c" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">❌Requires重写应用程序的一部分来实现缓存逻辑，需要设置一个VPC，不会减少Lambda或网关调用的数量。</p><h2 id="9e9f" class="mf ki hi bd kj mg mh mi kn mj mk ml kr ke mm mn kv kf mo mp kz kg mq mr ld ms bi translated">使用Lambda实例自己的内存</h2><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/aa6dd4dd17a551efab6e70c37487a0b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*Tul4Kz_iRXmBXR9KtEbDoA.png"/></div></figure><p id="47e3" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">当一个调用到达API网关时，相应的Lambda的一个实例开始应答它。</p><p id="efc7" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">但是启动Lambda需要一些时间(这是一个“冷启动”)。因此，为了最大限度地减少这种情况，Lambda会在调用结束后保持实例存活几分钟，以防再次调用相同的函数。</p><p id="df0e" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">我们可以利用这一点，直接在Lambda的实例中缓存一些数据(例如，在事件处理函数之外分配一个变量)。下次调用这个Lambda时，如果重用同一个实例，数据仍然会在那里。</p><p id="bf26" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">这种解决方案有两个主要限制:</p><ul class=""><li id="5d02" class="lp lq hi jb b jc jd jg jh ke lr kf ls kg lt jw lu lv lw lx bi translated"><strong class="jb hj">可预测性</strong>:我们无法控制实例何时被释放或保留，因此无法预测这种缓存解决方案的命中率</li><li id="1f77" class="lp lq hi jb b jc ly jg lz ke ma kf mb kg mc jw lu lv lw lx bi translated"><strong class="jb hj">并发</strong>:当一个Lambda函数需要启动时，如果对应的实例存在但当前正在使用中(比如回答并发调用)，Lambda别无选择，只能创建一个新的实例。这意味着在高负载情况下“命中率”会更差，因为会创建越来越多的新实例…</li></ul><p id="f462" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">✅Free！</p><p id="abbd" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">❌Only边际改进，不会在负载下提供任何保证，不会减少Lambda或网关调用的数量。</p><h2 id="8f1a" class="mf ki hi bd kj mg mh mi kn mj mk ml kr ke mm mn kv kf mo mp kz kg mq mr ld ms bi translated">API网关的缓存</h2><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/b83730aa20494114a052119e227c360d.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*MV1-pNOAnyMmEPaheT5ltA.png"/></div></figure><p id="db0e" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated"><a class="ae iu" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> API网关</a>提供了缓存功能，可以缓存它返回的数据。</p><p id="d017" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">与DAX或Elasticache相反，不需要设置VPC，因为缓存节点是由网关“拥有”的。事实上，您不必选择节点的数量或类型，只需选择缓存所需的总内存，一切都由网关处理。</p><p id="4b07" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">设置相当简单:您只需要选择一个内存大小、一个保持期，并标记您希望包含在缓存中的端点。</p><blockquote class="iv iw ix"><p id="444f" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">ApiGateway有两种风格:RestAPI和HttpApi。RestApi提供了更多功能。HttpApi的性能更高，价格便宜大约3倍。只有RestApi支持缓存。</p></blockquote><p id="caf6" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">定价基于这一内存大小，最低0.5GB，每月约15美元。</p><p id="a985" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">与前一个解决方案相比，这个解决方案提供了一个额外的优势:由于缓存“更早”，每次它可以应答一个调用，不需要调用Lambda函数。</p><p id="f4fc" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">✅Fixed成本，减少Lambda调用次数，设置简单</p><p id="e769" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">❌Requires使用比HttpApi更贵的RestApi口味，固定成本适中</p><h2 id="edd6" class="mf ki hi bd kj mg mh mi kn mj mk ml kr ke mm mn kv kf mo mp kz kg mq mr ld ms bi translated">云锋</h2><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/1289c904a2cbc131eeb4a27eaf3664f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*O_5RoMwaMwcpprEPu6QZMg.png"/></div></figure><p id="bd9d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">至于静态网站内容，也可以使用CDN(这里是CloudFront)来缓存数据。事实上，从CloudFront的角度来看，缓存一个API或一个网站大多是一样的。</p><p id="6521" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">使用CloudFront还有其他好处:</p><ul class=""><li id="27b1" class="lp lq hi jb b jc jd jg jh ke lr kf ls kg lt jw lu lv lw lx bi translated">数据缓存在离用户更近的地方(即使这对于只涉及单个城市的服务来说不是很有用)</li><li id="908f" class="lp lq hi jb b jc ly jg lz ke ma kf mb kg mc jw lu lv lw lx bi translated">Cloudfront可以处理一些其他特性，比如内容压缩</li></ul><p id="85f8" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">设置发行版与我刚才对网站静态内容所做的类似，但有一些例外:</p><ul class=""><li id="67ba" class="lp lq hi jb b jc jd jg jh ke lr kf ls kg lt jw lu lv lw lx bi translated">TTL会更短(60秒)</li><li id="141d" class="lp lq hi jb b jc ly jg lz ke ma kf mb kg mc jw lu lv lw lx bi translated">我需要转发CORS需要的标题</li></ul><p id="f881" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">这次我将定义一个合适的缓存策略，而不是使用内联参数:</p><figure class="ll lm ln lo fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="1fc1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated"><a class="ae iu" href="https://aws.amazon.com/cloudfront/pricing/" rel="noopener ugc nofollow" target="_blank">定价</a>更复杂，因为它取决于通话的数量和规模。但是，这就是事情变得有趣的地方:<strong class="jb hj">由CloudFront应答的呼叫比由ApiGateway应答的呼叫便宜</strong>:</p><ul class=""><li id="8f66" class="lp lq hi jb b jc jd jg jh ke lr kf ls kg lt jw lu lv lw lx bi translated"><strong class="jb hj">通话成本</strong> : HttpApi每10.000美元0.035美元，CloudFront每10.000美元0.012美元</li><li id="4815" class="lp lq hi jb b jc ly jg lz ke ma kf mb kg mc jw lu lv lw lx bi translated"><strong class="jb hj">数据传输成本</strong> : HttpApi每GB 0.09美元，CloudFront每GB 0.085美元</li></ul><p id="c580" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">显然，这只是因为我的命中率会很高，而且因为CloudFront不必经常调用底层API网关(这会增加成本)。</p><p id="018d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">✅Cost节约，成本随使用量而增加</p><p id="94ce" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">❌Setup是乏味的，成本随使用情况而变化</p><h2 id="93ad" class="mf ki hi bd kj mg mh mi kn mj mk ml kr ke mm mn kv kf mo mp kz kg mq mr ld ms bi translated">获胜者是…</h2><p id="42a7" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">仅从成本角度来看，CloudFront是明显的赢家。设置不需要重写我的函数，这将使设置变得简单。</p><p id="e945" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">如果我的API更复杂(这会产生更低的命中率)，我可能会使用DAX，因为它会提供最健壮、最简单的解决方案。</p><p id="073a" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated"><strong class="jb hj">获胜者:👑云锋👑</strong></p><p id="8d72" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">那么，它的效果如何呢？</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es na"><img src="../Images/09d480ae7fd6793085e169bcc5fed63b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*3kFP-ai8WPvlpjHoQt0mDw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">小心，刻度是对数的</figcaption></figure><p id="f022" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">和以前一样，第一次通话大约需要3秒钟才能结束。但是后面的通话都只有~10ms。我认为我们可以说这是成功的😊</p><h1 id="6d8f" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">结论</h1><p id="7fee" class="pw-post-body-paragraph iy iz hi jb b jc lf je jf jg lg ji jj ke lh jm jn kf li jq jr kg lj ju jv jw hb bi translated">即使AWS希望您认为Lambda将允许您<em class="ja">运行代码，而无需考虑服务器或集群</em>，但一旦您必须提高性能，这显然会变得更加复杂。</p><p id="411d" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">但我认为这是一件好事:这意味着即使在无服务器堆栈的墙内，当我面临问题时，我也不会局限于单一的解决方案。我可以利用几个工具，甚至可以依赖像Elasticache这样的“非无服务器”工具。</p><p id="c7cc" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">对于本文的特定主题(性能)和本系列中的其他主题来说都是如此。</p><p id="9cdf" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">我开始做这个项目已经一年多了。它仍然有点不可靠，前端设计是基本的，但我实现了我真正想做的事情:理解这个“无服务器”的东西是什么，更适应AWS，并构建一个“真正的”应用程序。</p><p id="b000" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">我希望你读我的时候和我写这篇文章的时候一样开心！如果你想看一些乱七八糟的代码，可以在Github上找到源码:【https://github.com/ouvreboite/velinfo<a class="ae iu" href="https://github.com/ouvreboite/velinfo" rel="noopener ugc nofollow" target="_blank"/></p><p id="748a" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">节约成本是我的主要目标，这将使我不用考虑太多钱就能在线维护应用程序。我也很高兴地告诉大家，Velib的团队似乎致力于改善他们的服务。希望我的应用程序很快就会过时！</p><p id="1e16" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj ke jl jm jn kf jp jq jr kg jt ju jv jw hb bi translated">至于我，我选择了一个更激进的解决方案:我买了自己的自行车。🚴</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><ul class=""><li id="9682" class="lp lq hi jb b jc jd jg jh ke lr kf ls kg lt jw lu lv lw lx bi translated">第1部分:为原型选择AWS无服务器堆栈</li><li id="19fa" class="lp lq hi jb b jc ly jg lz ke ma kf mb kg mc jw lu lv lw lx bi translated">第2部分:无服务器应用的主干:Lambda函数和DynamoDb表</li><li id="2e16" class="lp lq hi jb b jc ly jg lz ke ma kf mb kg mc jw lu lv lw lx bi translated"><a class="ae iu" rel="noopener" href="/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-3-d532318dfca7">第3部分</a>:用Lambda函数和DynamoDb流实现实时检测算法</li><li id="b36a" class="lp lq hi jb b jc ly jg lz ke ma kf mb kg mc jw lu lv lw lx bi translated">第4部分:创建一个无服务器的API，用S3托管一个前端</li><li id="0813" class="lp lq hi jb b jc ly jg lz ke ma kf mb kg mc jw lu lv lw lx bi translated"><a class="ae iu" rel="noopener" href="/codex/performance-tuning-for-an-aws-lambda-based-api-b8b49b2d07db">第5部分</a>:基于Lambda的API的性能调优</li></ul></div></div>    
</body>
</html>