<html>
<head>
<title>Technical challenge: The non-dup collection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">技术挑战:非重复数据收集</h1>
<blockquote>原文：<a href="https://medium.com/codex/technical-challenge-the-non-dup-collection-92f1cb261d0a?source=collection_archive---------19-----------------------#2021-07-01">https://medium.com/codex/technical-challenge-the-non-dup-collection-92f1cb261d0a?source=collection_archive---------19-----------------------#2021-07-01</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><div class=""><h2 id="feaf" class="pw-subtitle-paragraph ig hi hj bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dy translated"><em class="iy">招聘人员，说真的，请停止… </em></h2></div><p id="b536" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">在过去的几个月里，我的LinkedIn个人资料收到了太多的工作邀请，有些真的很有吸引力(主要是那些考虑为非智利公司工作，月收入以美元计)，其他的只是超出范围。</p><p id="914a" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">为了记录在案，如果你的读者中有人是招聘人员，请阅读候选人的简历，并看看他们简介中的链接。这通常能很好地反映候选人的专业知识。<br/>根据我们的经验，收到要求一些专业知识的邀请真的很烦人。</p><figure class="jw jx jy jz fe ka es et paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="es et jv"><img src="../Images/4f9e4939e70a578344cf26134a9478df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWPTwnLBSgrKVb3uqAvdvw.jpeg"/></div></div><figcaption class="kh ki eu es et kj kk bd b be z dy translated">叠树一直是一项挑战——由Michał Parzuchowski在Unsplash 上<a class="ae kl" href="https://unsplash.com/@mparzuchowski?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄</a></figcaption></figure><p id="34b8" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">在不止一个这样的提议中，涉及到了一种技术挑战，可悲的是，大多数情况下，所有的问题和挑战都来自于“书本”。我所说的“<em class="km">这本书</em>”是指在大多数文章、论坛帖子甚至一些出版的书籍中发现的典型的编码挑战。</p></div><div class="ab cl kn ko gq kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hc hd he hf hg"><p id="cd9a" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">怀着和每个招聘人员上床的心情，我将回答“<em class="km">非重复收集挑战</em>”这个同样的编码挑战。</p><p id="739d" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">让我们假设你有一个简单的对象集合。他们中的一些人不断重复。您需要从这个集合中获取唯一的值，还需要获取哪个元素的重复次数最多。</p><p id="15e7" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">我至少见过这个问题的两种不同版本。</p><ol class=""><li id="e0a1" class="ku kv hj jb b jc jd jf jg ji kw jm kx jq ky ju kz la lb lc bi translated">输入不是一个集合，而是一个字符串，其中每个字母至少可以重复一次；例如<code class="dv ld le lf lg b">"aaaaaaaabbbccddddcccceeee"</code></li><li id="bd79" class="ku kv hj jb b jc lh jf li ji lj jm lk jq ll ju kz la lb lc bi translated">输入是一个字符串数组，例如公司名称<br/> <code class="dv ld le lf lg b">["Google", "Apple", "Apple", "Microsoft", "Facebook", "Google", "Apple", "Facebook", "Apple", "Microsoft", "Microsoft", "Google"]</code></li></ol><p id="e2e1" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">其他变体可以考虑使用更复杂对象的集合来代替，但是逻辑保持不变。第二种情况通常隐藏在以下内容之后:</p><blockquote class="lm ln lo"><p id="0789" class="iz ja km jb b jc jd ik je jf jg in jh lp jj jk jl lq jn jo jp lr jr js jt ju hc bi translated">我们公司有几个项目，每个项目都与一个特定的客户相关联。我们有一个代表我们所有项目和所有客户的数组。你的任务是获得所有独特客户的列表，并告诉我们哪个客户拥有我们开发的最多项目。”</p></blockquote><p id="e5b7" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">如你所见，问题是一样的:</p><ul class=""><li id="093c" class="ku kv hj jb b jc jd jf jg ji kw jm kx jq ky ju ls la lb lc bi translated">某种集合<em class="km">(字符串是字符的集合(单字符字符串))</em></li><li id="99eb" class="ku kv hj jb b jc lh jf li ji lj jm lk jq ll ju ls la lb lc bi translated">获取唯一值</li><li id="e96a" class="ku kv hj jb b jc lh jf li ji lj jm lk jq ll ju ls la lb lc bi translated">获取具有最大重复次数的项目…</li></ul><p id="0c2a" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated"><em class="km">易</em>“…</p><p id="279e" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">因此，让我们为此建立一个解决方案。我们将使用案例1，并且我们将用Typescript编码:</p><pre class="jw jx jy jz fe lt lg lu lv aw lw bi"><span id="1fc1" class="lx ly hj lg b fj lz ma l mb mc">// Note: This is one possible solution. You can get as creative as you want.<br/>// Step by step ... (uuuuh baby !) &lt;- NKOTB someone? :P<br/>// 1. Get original collection <br/>// 2. Dedup the values<br/>// 1. &amp; 2. can be joined in teh same function<br/>function dedupeStringSet(data: string): string {<br/>  // result is initialized with the input string just to have something to return when testing without any code<br/>  let result: string = data;<br/>  // As the string is not a collection (per se) turn it into  a char Array<br/>  const dataArr: Array&lt;string&gt; = data.split('');<br/>  // Sets a a "new" (not that new) datatype, also a collection but it doesn't admit any duplicates. <br/>  //Google for *javascript unique values* and it's one of the first results<br/>  const dataSet = new Set(dataArr);<br/>  // Turn the Set again into an Array (using Array.from) and then to a string<br/>  result = Array.from(dataSet).join('');</span><span id="f14c" class="lx ly hj lg b fj md ma l mb mc">  // We're ready so return<br/>  return result;<br/>}<br/>// 3. Get max repeated item<br/>// I see a problem here. This deduping strategy gives no information on how many repetitions per char</span></pre><p id="af6d" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">由于我们的第一次尝试未能获得最大值，我们将尝试另一种方法。我将在代码的不同部分添加一些注释。</p><pre class="jw jx jy jz fe lt lg lu lv aw lw bi"><span id="6b55" class="lx ly hj lg b fj lz ma l mb mc">// The object is declared outside the function so we can use it in any other place we require (for eg. the getMax function)<br/>// Every char/letter on the string has a counter<br/>let cntObj: { [key: string]: number } = {}<br/>function dedupStringObj(data: string): string {<br/>  // Initialize the object on every run <br/>  cntObj = {};<br/>  let result: string = data;<br/>  const dataArr: Array&lt;string&gt; = data.split('');<br/>  // We'll iterate through all chars  in the string<br/>  for (let index = 0; index &lt; dataArr.length; index++) {<br/>    // This would be a char<br/>    const element    = dataArr[index];<br/>    // If the char does exist as an attribute/key in the object the add 1, else first value is 1<br/>    cntObj[element] = (cntObj[element]) ? cntObj[element]+1 : 1;       <br/>  }<br/>  result = (Object.keys(cntObj)).join('');<br/>  <br/>  return result;<br/>}</span><span id="57b5" class="lx ly hj lg b fj md ma l mb mc">// 3. Get max repeated item<br/>/**<br/> * Get the most repeated char in a non-unique char string<br/> * @param dataObj JSON object used as a dictionary where each char stores its repetition counter<br/> * @returns the string corresponding to the most repeated item<br/> */<br/>function mostRepeatedObj(dataObj: { [key: string]: number }): string {<br/>  // Initializes the key and maxValue to have a starting pivot<br/>  let maxValue: number = 0;<br/>  let maxKey: string   = '';<br/>  // Gets all object keys in an array so we can iterate through them and get the most repeated item<br/>  const keys: Array&lt;string&gt; = Object.keys(dataObj);<br/>  for (let index = 0; index &lt; keys.length; index++) {<br/>    // Get the key and counter value for that key<br/>    const key: string       = keys[index];<br/>    const currValue: number = dataObj[key];<br/>    // Typical max value strategy, currValue replaces maxValue when &gt;<br/>    // If this happens also keep track of the key (which would be the most repeated item)<br/>    if (currValue &gt;= maxValue) {<br/>      maxValue = currValue;<br/>      maxKey   = key;<br/>    }         <br/>  }</span><span id="0f6c" class="lx ly hj lg b fj md ma l mb mc">  return maxKey;<br/>}</span></pre><p id="be19" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">我们还需要一些代码来进行测试运行:</p><pre class="jw jx jy jz fe lt lg lu lv aw lw bi"><span id="2e33" class="lx ly hj lg b fj lz ma l mb mc">const input = 'aaaaabbbcccccceeeccccdd';<br/>console.log(input, '\n');</span><span id="5b99" class="lx ly hj lg b fj md ma l mb mc">let dedup = dedupStringSet(input);<br/>console.log(dedup, '\n');</span><span id="2361" class="lx ly hj lg b fj md ma l mb mc">dedup = dedupStringObj(input);<br/>console.log(dedup);<br/>console.log(cntObj);</span><span id="53ee" class="lx ly hj lg b fj md ma l mb mc">const maxObj: string = mostRepeatedObj(cntObj);<br/>console.log(maxObj, '\n');</span><span id="d5b6" class="lx ly hj lg b fj md ma l mb mc">/**<br/>aaaaabbbcccccceeeccccdd &lt;- input</span><span id="a145" class="lx ly hj lg b fj md ma l mb mc">abced &lt;- dedupStringSet</span><span id="49ad" class="lx ly hj lg b fj md ma l mb mc">abced &lt;- dedupStringObj<br/>{ a: 5, b: 3, c: 10, e: 3, d: 2 } &lt;- cntObj<br/>c &lt;- mostRepeatedObj<br/>**/</span></pre><p id="0c98" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">来运行这个程序。</p><ol class=""><li id="7836" class="ku kv hj jb b jc jd jf jg ji kw jm kx jq ky ju kz la lb lc bi translated">将它存储在一个单独的文件夹中，在一个名为<code class="dv ld le lf lg b">&lt;whatever you want&gt;.ts</code>的文件中(替换成你想要的:P)</li><li id="4dd8" class="ku kv hj jb b jc lh jf li ji lj jm lk jq ll ju kz la lb lc bi translated">运行<code class="dv ld le lf lg b">npm install typescript ts-node @types/node</code></li><li id="5434" class="ku kv hj jb b jc lh jf li ji lj jm lk jq ll ju kz la lb lc bi translated">跑<code class="dv ld le lf lg b">./node_modules/.bin/ts-node &lt;whatever you want&gt;.ts</code></li></ol><p id="68a2" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">但是…性能可能是一个问题。我希望您已经阅读过它(如果没有，您现在正在做:)，使用JSON对象作为hashmap/dictionary可能会很慢，因为您必须检查对象中的每个属性是否都存在。那将会是这条特别的线:</p><p id="b03f" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated"><code class="dv ld le lf lg b">cntObj[element] = (cntObj[element]) ? cntObj[element]+1 : 1;</code></p><p id="230d" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">所以让我们尝试一个使用Map对象而不是JSON对象的解决方案。</p><pre class="jw jx jy jz fe lt lg lu lv aw lw bi"><span id="2833" class="lx ly hj lg b fj lz ma l mb mc">// Almost the same as the object version, but using a Map<br/>let cntMap: Map&lt;string, number&gt; = new Map&lt;string, number&gt;();<br/>function dedupStringMap(data: string): string {<br/>  cntMap = new Map&lt;string, number&gt;();<br/>  let result: string = data;<br/>  const dataArr: Array&lt;string&gt; = data.split('');<br/>  for (let index = 0; index &lt; dataArr.length; index++) {<br/>    const element = dataArr[index];<br/>    // Checks if the char exist as a key, if it does double check when getting (??0 else the Typescript trasnpiler will throw an error)<br/>    // and increment. If it doesn exist then first value is 1.<br/>    const inc: number = (cntMap.has(element)) ? (cntMap.get(element)??0) + 1 : 1;    <br/>    // Store the value in the map  <br/>    cntMap.set(element, inc);<br/>  }<br/>  // As Sets, Maps do not admit duplicates, so take the key and turn the iterator into an array. Then <br/>  // turn the Array back into a string.<br/>  result = Array.from(cntMap.keys()).join('');<br/>  <br/>  return result;<br/>}</span><span id="4e89" class="lx ly hj lg b fj md ma l mb mc">function mostRepeatedMap(dataMap: Map&lt;string, number&gt;): string {<br/>  let maxValue: number = 0;<br/>  let maxKey: string   = '';<br/>  const keys: Array&lt;string&gt; = Array.from(dataMap.keys());<br/>  for (let index = 0; index &lt; keys.length; index++) {<br/>    const key: string       = keys[index];<br/>    const currValue: number = dataMap.get(key) || 0;<br/>    if (currValue &gt;= maxValue) {<br/>      maxValue = currValue;<br/>      maxKey   = key;<br/>    }         <br/>  }<br/>  return maxKey;<br/>}</span></pre><p id="3a7c" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">仅与对象版本略有不同。要运行:</p><pre class="jw jx jy jz fe lt lg lu lv aw lw bi"><span id="a555" class="lx ly hj lg b fj lz ma l mb mc">let dedup = dedupStringMap(input);<br/>console.log(dedup);<br/>console.log(cntMap);</span><span id="eb2a" class="lx ly hj lg b fj md ma l mb mc">const maxMap: string = mostRepeatedMap(cntMap);<br/>console.log(maxMap, '\n');</span><span id="2a6e" class="lx ly hj lg b fj md ma l mb mc">/**<br/>aaaaabbbcccccceeeccccdd </span><span id="c210" class="lx ly hj lg b fj md ma l mb mc">abced<br/>Map(5) { 'a' =&gt; 5, 'b' =&gt; 3, 'c' =&gt; 10, 'e' =&gt; 3, 'd' =&gt; 2 }<br/>c <br/>**/</span></pre><p id="6e07" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">好了，我们有3种方法对一个字符串(或者一个集合，如果你适当地调整代码)进行非重复数据删除，还有2种方法从结果对象中获得最大值。</p><h1 id="da6c" class="me ly hj bd mf mg mh mi mj mk ml mm mn ip mo iq mp is mq it mr iv ms iw mt mu bi translated">性能呢？</h1><p id="51ba" class="pw-post-body-paragraph iz ja hj jb b jc mv ik je jf mw in jh ji mx jk jl jm my jo jp jq mz js jt ju hc bi translated">让我们挑选所有的代码并混合起来，添加一些时间测量信息(希望你不介意增量复制和粘贴):</p><pre class="jw jx jy jz fe lt lg lu lv aw lw bi"><span id="a638" class="lx ly hj lg b fj lz ma l mb mc">function dedupStringSet(data: string): string {<br/>  let result: string = data;<br/>  const dataArr: Array&lt;string&gt; = data.split('');<br/>  const dataSet = new Set(dataArr);<br/>  result = Array.from(dataSet).join('');<br/>  return result;<br/>}</span><span id="ca8b" class="lx ly hj lg b fj md ma l mb mc">let cntObj: { [key: string]: number } = {}<br/>function dedupStringObj(data: string): string {<br/>  cntObj = {};<br/>  let result: string = data;<br/>  const dataArr: Array&lt;string&gt; = data.split('');<br/>  for (let index = 0; index &lt; dataArr.length; index++) {<br/>    const element = dataArr[index];<br/>    cntObj[element] = (cntObj[element]) ? cntObj[element]+1 : 1;       <br/>  }<br/>  result = (Object.keys(cntObj)).join('');<br/>  <br/>  return result;<br/>}</span><span id="6b34" class="lx ly hj lg b fj md ma l mb mc">// Almost the same as the object version, but using a Map<br/>let cntMap: Map&lt;string, number&gt; = new Map&lt;string, number&gt;();<br/>function dedupStringMap(data: string): string {<br/>  cntMap = new Map&lt;string, number&gt;();<br/>  let result: string = data;<br/>  const dataArr: Array&lt;string&gt; = data.split('');<br/>  for (let index = 0; index &lt; dataArr.length; index++) {<br/>    const element = dataArr[index];<br/>    // Checks if the char exist as a key, if it does double check when getting (??0 else the Typescript trasnpiler will throw an error)<br/>    // and increment. If it doesn exist then first value is 1.<br/>    const inc: number = (cntMap.has(element)) ? (cntMap.get(element)??0) + 1 : 1;    <br/>    // Store the value in the map  <br/>    cntMap.set(element, inc);<br/>  }<br/>  // As Sets, Maps do not admit duplicates, so take the key and turn the iterator into an array. Then <br/>  // turn the Array back into a string.<br/>  result = Array.from(cntMap.keys()).join('');<br/>  <br/>  return result;<br/>}</span><span id="bd90" class="lx ly hj lg b fj md ma l mb mc">/**<br/> * Get the most repeated char in a non-unique char string<br/> * @param dataObj JSON object used as a dictionary where each char stores its repetition counter<br/> * @returns the string corresponding to the most repeated item<br/> */<br/>function mostRepeatedObj(dataObj: { [key: string]: number }): string {<br/>  // Initializes the key and maxValue to have a starting pivot<br/>  let maxValue: number = 0;<br/>  let maxKey: string   = '';<br/>  // Gets all object keys in an array so we can iterate through them and get the most repeated item<br/>  const keys: Array&lt;string&gt; = Object.keys(dataObj);<br/>  for (let index = 0; index &lt; keys.length; index++) {<br/>    // Get the key and counter value for that key<br/>    const key: string       = keys[index];<br/>    const currValue: number = dataObj[key];<br/>    // Typical max value strategy, currValue replaces maxValue when &gt;<br/>    // If this happens also keep track of the key (which would be the most repeated item)<br/>    if (currValue &gt;= maxValue) {<br/>      maxValue = currValue;<br/>      maxKey   = key;<br/>    }         <br/>  }</span><span id="e8dc" class="lx ly hj lg b fj md ma l mb mc">  return maxKey;<br/>}</span><span id="b781" class="lx ly hj lg b fj md ma l mb mc">function mostRepeatedMap(dataMap: Map&lt;string, number&gt;): string {<br/>  let maxValue: number = 0;<br/>  let maxKey: string   = '';<br/>  const keys: Array&lt;string&gt; = Array.from(dataMap.keys());<br/>  for (let index = 0; index &lt; keys.length; index++) {<br/>    const key: string       = keys[index];<br/>    const currValue: number = dataMap.get(key)??0;<br/>    if (currValue &gt;= maxValue) {<br/>      maxValue = currValue;<br/>      maxKey   = key;<br/>    }         <br/>  }<br/>  return maxKey;<br/>}</span><span id="875a" class="lx ly hj lg b fj md ma l mb mc">const input = 'aaaaabbbcccccceeeccccdd';<br/>console.log(input, '\n');</span><span id="9234" class="lx ly hj lg b fj md ma l mb mc">console.time('set');<br/>let dedup = dedupStringSet(input);<br/>console.timeEnd('set');<br/>console.log(dedup, '\n');</span><span id="ce33" class="lx ly hj lg b fj md ma l mb mc">console.time('obj');<br/>dedup = dedupStringObj(input);<br/>console.timeEnd('obj');<br/>console.log(dedup);<br/>console.log(cntObj);</span><span id="1867" class="lx ly hj lg b fj md ma l mb mc">console.time('maxObj');<br/>const maxObj: string = mostRepeatedObj(cntObj);<br/>console.timeEnd('maxObj');<br/>console.log(maxObj, '\n');</span><span id="f7b7" class="lx ly hj lg b fj md ma l mb mc">console.time('map');<br/>dedup = dedupStringMap(input);<br/>console.timeEnd('map');<br/>console.log(dedup);<br/>console.log(cntMap);</span><span id="af1f" class="lx ly hj lg b fj md ma l mb mc">console.time('maxMap');<br/>const maxMap: string = mostRepeatedMap(cntMap);<br/>console.timeEnd('maxMap');<br/>console.log(maxMap, '\n');</span><span id="693e" class="lx ly hj lg b fj md ma l mb mc">/**<br/>aaaaabbbcccccceeeccccdd </span><span id="69b2" class="lx ly hj lg b fj md ma l mb mc">set: 0.108ms<br/>abced </span><span id="a9d8" class="lx ly hj lg b fj md ma l mb mc">obj: 0.08ms<br/>abced<br/>{ a: 5, b: 3, c: 10, e: 3, d: 2 }<br/>maxObj: 0.045ms<br/>c </span><span id="c44a" class="lx ly hj lg b fj md ma l mb mc">map: 0.076ms<br/>abced<br/>Map(5) { 'a' =&gt; 5, 'b' =&gt; 3, 'c' =&gt; 10, 'e' =&gt; 3, 'd' =&gt; 2 }<br/>maxMap: 0.079ms<br/>c <br/>**/</span></pre><p id="e02d" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">你可以根据结果做出自己的结论。<br/>最后，在我写这篇文章的时候，我有了另一个想法:<em class="km">如果集合是降序排列的，并且第一项被取为最大值，那么重复次数最多的函数的性能会提高吗？</em></p><p id="789d" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">我将把它作为一个有趣的编码练习留给读者(也许比本文的挑战好得多)。这将需要重写某些函数中的一些行，并且很可能改变cntObj的类型(我在考虑一个<em class="km">数组&lt; { key: string，counter: number } &gt;)。<br/> </em>如果你想以编码为乐，以下几个链接会有所帮助:</p><ul class=""><li id="7ea8" class="ku kv hj jb b jc jd jf jg ji kw jm kx jq ky ju ls la lb lc bi translated"><a class="ae kl" href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/es/docs/Web/JavaScript/Reference/Global _ Objects/Array/sort</a></li><li id="e0df" class="ku kv hj jb b jc lh jf li ji lj jm lk jq ll ju ls la lb lc bi translated"><a class="ae kl" href="https://stackoverflow.com/questions/37982476/how-to-sort-a-map-by-value-in-javascript" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/37982476/how-to-sort-a-map-by-value-in-JavaScript</a>(查看<a class="ae kl" href="https://stackoverflow.com/users/8494762/miroslav-savovski" rel="noopener ugc nofollow" target="_blank"> Miroslav Savovski </a>的回答)</li></ul><p id="d18a" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">因此，如果你在面试中遇到这个问题(或类似问题)的技术挑战，我希望你能记住这篇文章。</p></div><div class="ab cl kn ko gq kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hc hd he hf hg"><p id="dc5c" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">所以招聘人员，请停止。一个需要记忆任何库或包方法签名的技术编码挑战，或者诸如从底部到顶部遍历二叉树的复杂算法，将不会精确地评估候选人是否能够覆盖工作职位，也不会评估他们是否很适合组织。最坏的情况是，大多数公司已经考虑了试用期(并且已经考虑了所有相关成本)，在此期间，管理层决定雇佣候选人是否是一个好的选择。</p><p id="4bf5" class="pw-post-body-paragraph iz ja hj jb b jc jd ik je jf jg in jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">有更好的方法来雇佣高水平的开发者。<br/>保持安全。</p></div></div>    
</body>
</html>