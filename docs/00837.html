<html>
<head>
<title>Dijkstra’s Shortest Path finding Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dijkstra最短路径查找算法</h1>
<blockquote>原文：<a href="https://medium.com/codex/dijkstras-shortest-path-finding-algorithm-d8b85248c911?source=collection_archive---------12-----------------------#2021-03-21">https://medium.com/codex/dijkstras-shortest-path-finding-algorithm-d8b85248c911?source=collection_archive---------12-----------------------#2021-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="486d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Dijkstra算法用于使用贪婪方法找到图中任意两个节点之间的最短路径。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/37606f3be010c82cab84a1d9daf3c81e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*po5MgNLNu-j-h5sjO5ARvg.jpeg"/></div></div></figure><h2 id="3e7f" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">图表</h2><p id="6a1a" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们先说图。图形是一种用于表示连接元素的数据结构。这些元素被称为<strong class="ih hj">节点</strong>，代表一个对象或一个人。这些节点之间的连接被称为<strong class="ih hj">边</strong>。如果两个节点之间存在边，则认为它们是连通的。</p><p id="24b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图形可以有各种类型。</p><p id="6a42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">无向图</strong> —对于两个相连的节点，你可以从一个节点向两个方向连接到另一个节点。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kp"><img src="../Images/34e6407f3dd146d5abbe3784d01ce81a.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*ADKhaSWEn41dtQUP-DXJdA.png"/></div></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">无向图</figcaption></figure><p id="a6a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">有向图</strong>——对于两个相连的节点，只能往边上指定的方向走。方向用边上的箭头表示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ku"><img src="../Images/42c23c284f646ee5d026ac915970898e.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/0*zFbyGvPZeN9Z0W8o.png"/></div></figure><p id="2f22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">加权图</strong> -这些图有加权边。边的“权重”或“成本”可以表示像距离、时间或任何建模边之间的连接的属性。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kv"><img src="../Images/6affea0b8d2ad7d7cc41b8e9dd941198.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/0*RMKdDm65fTJp9hgw.png"/></div></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">加权无向图</figcaption></figure><h2 id="f0de" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">基本概念</h2><p id="06d0" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">Dijkstra算法用于加权图，以找到图中任意两个节点之间的最短路径。它以最短路径树的形式给出了从源节点到图中所有其他节点的最短路径。</p><ul class=""><li id="3de6" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">Dijkstra的算法基本上从您选择的节点(源节点)开始，它分析图形以找到该节点和图形中所有其他节点之间的最短路径。</li><li id="296b" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">该算法跟踪从每个节点到源节点的当前已知最短距离，并且如果它发现更短的路径，它更新这些值。</li><li id="65df" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">一旦算法找到了源节点和另一个节点之间的最短路径，该节点就被标记为“已访问”并被添加到路径中。</li><li id="fae7" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">该过程继续，直到图中的所有节点都被添加到路径中。这样，我们就有了一条连接源节点和所有其他节点的路径，这条路径可能是到达每个节点的最短路径。</li></ul><h2 id="7325" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">要求</h2><p id="de2b" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">Dijkstra的只能应用于权重为正的图，因为边的权重必须相加才能找到最短路径。负权重会导致算法出现故障。一旦节点被标记为“已访问”，则到该节点的当前路径被标记为到该节点的最短路径。如果在这一步之后总重量可以进一步减少，负重量可以改变这一点。</p><h2 id="abeb" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated"><strong class="ak">初始化</strong></h2><p id="e0c1" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">在我们开始探索一个图中的所有路径之前，我们首先需要初始化所有具有无限距离和未知前任的节点，除了源节点。</p><p id="cd40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为初始化过程的一部分，我们需要将值0赋给节点A，因为它是我们的源节点。</p><p id="07fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，图的其余部分中的每个节点将用一个前任和一个距离来表征:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/9399263017777f00c7587067247d622b.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*mMyRv80gTY9GUYUX.png"/></div></figure><p id="13c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了完成初始化过程，我们需要将节点A添加到未访问的节点中，并在评估步骤中将它设置为首先被选取。请记住，已访问的节点集仍然是空的。</p><h2 id="1280" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">估价</h2><p id="3ae7" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">现在我们已经初始化了我们的图，我们从未访问过的集合中挑选距离最小的节点，然后我们评估所有不在已访问过的集合中的相邻节点:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/574747e6a44286fb63c097b8250ea8f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*JvEaXvCsMWkHrnWE.png"/></div></figure><p id="492f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想法是将边权重添加到评估节点距离，然后将其与目的地的距离进行比较。例如，对于节点B，0+10小于无穷大，因此节点B的新距离是10，新的前任是A，这同样适用于节点c</p><p id="d638" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，节点A从未访问节点集移动到已访问节点集。</p><p id="82b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">节点B和C被添加到未访问的节点中，因为它们可以被访问，但是需要被评估。</p><p id="c1b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们在未访问的集合中有两个节点，我们选择具有最低距离的一个(节点B)，然后我们重复直到我们解决了图中的所有节点:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lk"><img src="../Images/0b9d638ca925033cda92a83edb57451b.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*3hi_V0Sn1QLRzVP3.png"/></div></figure><p id="4859" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此表总结了评估步骤中执行的迭代:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/02c3fcc0b0fecebda529c58906be4c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BEHG5KeOvx2Qxh9jU8dafw.png"/></div></div></figure><p id="190e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，符号D-24表示节点D是直接的前趋节点，与节点a的总距离为24。</p><p id="4af8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从源节点A开始的最短路径可以计算如下:</p><ul class=""><li id="2ded" class="kw kx hi ih b ii ij im in iq ky iu kz iy la jc lb lc ld le bi translated">节点B : A到B(总距离= 10)</li><li id="f65d" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">节点C : A到C(总距离= 15)</li><li id="48ca" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">节点D:从A到B到D(总距离= 22)</li><li id="730c" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">节点E : A到B到D到E(总距离= 24)</li><li id="b6fc" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">节点F : A到B到D到F(总距离= 23)</li></ul><h2 id="393f" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">伪代码</h2><p id="3a0c" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们需要保持每个顶点的路径距离。我们可以将它存储在一个大小为v的数组中，其中v是顶点的数量。</p><p id="7d99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还希望能够得到最短路径，而不仅仅是知道最短路径的长度。为此，我们将每个顶点映射到最后更新其路径长度的顶点。</p><p id="21e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦算法结束，我们可以从目的顶点回溯到源顶点来找到路径。</p><p id="ada4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以使用最小优先级队列来有效地接收具有最小路径距离的顶点。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="9ca0" class="jp jq hi ln b fi lr ls l lt lu">function dijkstra(G, S)<br/>    for each vertex V in G<br/>        distance[V] &lt;- infinite<br/>        previous[V] &lt;- NULL<br/>        If V != S, add V to Priority Queue Q<br/>    distance[S] &lt;- 0<br/>	<br/>    while Q IS NOT EMPTY<br/>        U &lt;- Extract MIN from Q<br/>        for each unvisited neighbour V of U<br/>            tempDistance &lt;- distance[U] + edge_weight(U, V)<br/>            if tempDistance &lt; distance[V]<br/>                distance[V] &lt;- tempDistance<br/>                previous[V] &lt;- U<br/>    return distance[], previous[]</span></pre><h2 id="cb76" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">Dijkstra算法的复杂性</h2><p id="140a" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">时间复杂度:O(ElogV)</p><p id="3f6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">空间复杂度:O(V)</p><p id="78ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中E表示图中边的数量，V表示图中顶点/节点的数量。</p><h2 id="0ee3" class="jp jq hi bd jr js jt ju jv jw jx jy jz iq ka kb kc iu kd ke kf iy kg kh ki kj bi translated">应用程序</h2><ul class=""><li id="4075" class="kw kx hi ih b ii kk im kl iq lv iu lw iy lx jc lb lc ld le bi translated">寻找最短的路径</li><li id="791f" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">在社交网络应用中</li><li id="f594" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">在电话网络中</li><li id="c2c2" class="kw kx hi ih b ii lf im lg iq lh iu li iy lj jc lb lc ld le bi translated">在网络路由中</li></ul></div></div>    
</body>
</html>