<html>
<head>
<title>Compiling and running GROMACS natively on Windows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Windows上编译和运行GROMACS</h1>
<blockquote>原文：<a href="https://medium.com/codex/compiling-and-running-gromacs-natively-on-windows-9bc40d9bc830?source=collection_archive---------0-----------------------#2021-07-19">https://medium.com/codex/compiling-and-running-gromacs-natively-on-windows-9bc40d9bc830?source=collection_archive---------0-----------------------#2021-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b370" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经在分子动力学(MD)模拟项目上工作了几个月。在此之前，我对分子动力学模拟并不特别熟悉，但我必须学会使用NAMD和格罗马科斯——这两个非常流行的软件可以使用力场运行各种类型的计算(即原子被视为服从牛顿动力学的经典粒子，它们之间的力由参数化方程表示)。还有其他用于MD模拟的软件，比如OpenMM，但是我猜想GROMACS和NAMD占据了发表的关于MD的论文的绝大部分。</p><p id="13e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">NAMD为Windows提供了预编译的二进制文件，但GROMACS没有，所以需要编译。在Linux或类似POSIX的系统上，编译非常容易。在Windows上，可以编译，但是程序有点难。</p><p id="3a9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> TL，</strong>博士:如果你只想要编译好的二进制文件，不想进一步阅读，那么请访问<a class="ae jd" href="https://github.com/ShoubhikRaj/gromacs-windows" rel="noopener ugc nofollow" target="_blank">这个</a> github仓库，我在那里放了GROMACS的预编译Windows二进制文件。</p><p id="c8bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是如何为Windows原生编译GROMACS(即没有Cygwin或WSL):</p><h2 id="68ac" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">要求—</h2><ol class=""><li id="1b07" class="jz ka hi ih b ii kb im kc iq kd iu ke iy kf jc kg kh ki kj bi translated">Windows 10 (Windows 8和7应该也可以运行，但还没有经过测试)</li><li id="80d8" class="jz ka hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">微软Visual Studio 2019 (2017也可以，旧版本可能可以)</li><li id="dde3" class="jz ka hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">[英特尔oneAPI基本工具包(MKL版)]或[FFTW3库]</li><li id="6ea0" class="jz ka hi ih b ii kk im kl iq km iu kn iy ko jc kg kh ki kj bi translated">(可选)介子和忍者</li></ol><h2 id="32db" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">正在安装Visual Studio 2019</h2><p id="ac3e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Visual Studio 2019(或2017)的社区版可以从微软网站免费下载。社区版足以满足我们的目的。(下载页面:<a class="ae jd" href="https://visualstudio.microsoft.com/downloads/" rel="noopener ugc nofollow" target="_blank">最新版本(VS2019) </a>、<a class="ae jd" href="https://visualstudio.microsoft.com/vs/older-downloads/" rel="noopener ugc nofollow" target="_blank"> VS2017及更老版本</a>)</p><p id="1ee8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下载并运行安装程序。当安装程序询问应该安装哪些组件时，请确保选择“使用C++进行桌面开发”。其他选项对于安装GROMACS来说不是必需的，所以如果您愿意，可以不选中它们。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ks"><img src="../Images/d5dbb0d6bc906117899c3383edc6802c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Patnk1DtTVO_iw7GSIiFgg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">Visual Studio 2019安装程序</figcaption></figure><p id="50b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我建议不要改变右侧的任何可选安装。构建GROMACS需要“C++ CMake tools for Windows”。单击“安装”下载并安装Visual Studio。</p><p id="8889" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用命令行编译。为此，必须启动编译器命令行环境。请检查“开始”菜单中是否有“用于VS2019的x64本机工具命令提示符”选项，如下所示:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es li"><img src="../Images/0ca85c6a5b1b8efcb7f51b1dd9a66fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4dAix2gqtt_6kXN3Cc9R-Q.png"/></div></div></figure><p id="a19b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">打开编译器命令提示符，检查运行<code class="du lj lk ll lm b">cl</code>是否给出如下输出:(cl.exe是MSVC++编译器)</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ln"><img src="../Images/c912b0fba79df44c1c999328bab1fc94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ob8nhlNVEOruORtan0XPJA.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">测试命令行上是否存在cl.exe(MSVC ++编译器)</figcaption></figure><h2 id="433a" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">安装面向MKL的英特尔oneAPI(FFT w3的替代产品)</h2><p id="d7c4" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">GROMACS需要快速傅立叶变换库用于许多模拟选项，如粒子网格ewald静电学。这些库可以由英特尔MKL(数学内核库)提供。英特尔MKL非常快，尤其是在英特尔芯片上。(我不确定在AMD之类的其他芯片上是否一样快；前段时间有报道称，英特尔在MKL中插入代码，检查处理器是否是英特尔的，如果不是，则运行速度较慢的代码。但是在2020年的更新3中，英特尔声称已经修复了它们。)</p><p id="b988" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你为GROMACS选择MKL，MKL也将用于线性代数(BLAS和LAPACK)。英特尔MKL现已作为英特尔oneAPI基础工具包的一部分免费提供(下载页面:<a class="ae jd" href="https://software.intel.com/content/www/us/en/develop/tools/oneapi/base-toolkit/download.html" rel="noopener ugc nofollow" target="_blank">基础工具包</a>)。选择Windows作为操作系统。我建议下载在线安装程序，因为本地安装程序有完整的oneAPI基础工具包，这是不必要的。然后点击下载，网站会提示你登录——如果没有账号就点击下载为访客。</p><p id="492a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下载后运行安装程序。请确保仅选择“英特尔oneAPI数学内核库”选项，因为其他选项并不需要。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lo"><img src="../Images/7aa7cdb8c28ea0d2455d5537ed503556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MmYTE-soyxCp13pU39yEQQ.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">英特尔oneAPI安装程序2021(它显示安装在MKL旁边，因为我已经安装了它)</figcaption></figure><p id="5f8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意左下角的安装位置。确保可以从安装目录中找到库<code class="du lj lk ll lm b">mkl_intel_lp64.lib</code>、<code class="du lj lk ll lm b">mkl_sequential.lib</code>和<code class="du lj lk ll lm b">mkl_core.lib</code>。如果保留默认值，那么这些库应该在<code class="du lj lk ll lm b">C:\Program Files (x86)\Intel\oneAPI\mkl\latest\lib\intel64\</code>中。</p><h2 id="4a8b" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><strong class="ak">使用FFTW3库(替代MKL) </strong></h2><p id="cdc0" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">如果你用的是英特尔芯片，MKL会给你最好的性能。MKL也在AMD芯片上工作，但有可能其他库会提供更快的性能。您必须运行基准测试并亲自检查。FFTW3就是这样一个开源库，它提供了快速傅立叶变换功能。</p><p id="0c75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用FFTW3，请从<a class="ae jd" href="https://www.fftw.org/install/windows.html" rel="noopener ugc nofollow" target="_blank">https://www.fftw.org/install/windows.html</a>下载库。遗憾的是，FFTW3默认提供源代码，没有官方的windows预编译库。链接的页面提供了由其他用户编译的窗口库。请注意，windows库是旧版本(3.3.5)而不是最新版本(3.3.9)。如果您希望使用FFTW3，请下载64位版本的zip文件并解压到一个文件夹中。</p><p id="70e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于GROMACS的普通构建，需要单精度FFTW3库。因为这里使用了MSVC++编译器，所以这个库需要以导入库格式存在。lib)，这在档案中没有提供。</p><p id="a96f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">来制造。lib文件，打开MSVC++的编译器命令提示符(“x64本机工具……”)。导航到FFTW3文件所在的文件夹，然后运行<code class="du lj lk ll lm b">lib /machine:x64 /def:libfftw3f-3.def</code>。这将生成一个<code class="du lj lk ll lm b">libfftw3f-f.lib</code>文件。这是我们在编译GROMACS时需要的单精度FFTW3导入库。</p><h2 id="aba7" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">(可选)介子和忍者</h2><p id="c971" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Ninja是一个构建系统，它可以获取从CMake生成的构建文件，并执行编译和链接以准备最终的可执行软件。忍者和介子通常在一个<a class="ae jd" href="https://mesonbuild.com/Getting-meson.html" rel="noopener ugc nofollow" target="_blank">安装程序</a>中一起发布。(我们其实对介子没有任何需求)</p><p id="10db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要用忍者来建造格鲁马克吗？不会，因为Visual Studio已经有一个可以完成相同工作的生成系统(nmake ),并且默认情况下与Visual Studio一起安装。然而，ninja可以使用PC的所有内核来运行并行编译作业，而nmake只能顺序运行编译，因此需要的时间稍长。出于这个目的，时差不是很大，所以你可以使用<code class="du lj lk ll lm b">nmake</code>或<code class="du lj lk ll lm b">ninja</code>，随你喜欢。</p><h2 id="d434" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">下载GROMACS</h2><p id="d6a4" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">GROMACS以非常频繁的间隔发布源代码。不同版本的源代码可以从<a class="ae jd" href="https://manual.gromacs.org/documentation/" rel="noopener ugc nofollow" target="_blank">这个页面</a>下载。由于他们在每个版本中都会对源代码稍作修改，因此将来的版本可能会在编译过程中出错。本指南使用的是2021.1 <a class="ae jd" href="https://manual.gromacs.org/documentation/2021.1/download.html" rel="noopener ugc nofollow" target="_blank">版本</a>。</p><p id="45e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下载tar.gz档案，然后将其解压缩到一个文件夹中。</p><h2 id="76ca" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">一些修改</h2><p id="ee00" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">对于某些版本，可能需要进行修改。</p><p id="8e48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于2021.1版本，需要更改一个文件名。转到解压后的源文件所在的文件夹，找到文件src \ gro Macs \ nbn XM \ kernels _ SIMD _ 2 xmm \ kernel _ ElecQSTabTwinCut _ VdwLJEwCombGeom _ vgr pf . CPP 0000666，这个文件的扩展名应该只是。cpp，所以去掉那些数字。(我不确定为什么这个文件有一个奇怪的扩展名，但是如果没有这个文件，我会在链接时遇到无法解决的外部错误。)2021.2或更高版本不存在此问题。</p><p id="025b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于2021版本，不需要任何更改。我相信这同样适用于旧版本。</p><h2 id="ae2d" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">运行CMake以生成生成文件</h2><p id="d1bd" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">CMake与Visual Studio捆绑在一起，可以从x64本机工具命令提示符运行。在编译器命令提示符下，导航到GROMACS源文件被解压缩的文件夹。</p><p id="f638" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按顺序运行以下命令(如果使用MKL):</p><pre class="kt ku kv kw fd lp lm lq lr aw ls bi"><span id="b70f" class="je jf hi lm b fi lt lu l lv lw">set CC=cl<br/>set CXX=cl</span><span id="c1f2" class="je jf hi lm b fi lx lu l lv lw">cmake -G"NMake Makefiles" -S. -B./build -DGMX_GPU=off -DGMX_FFT_LIBRARY=mkl -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=off -DMKL_INCLUDE_DIR="C:/Program Files (x86)/Intel/oneAPI/mkl/latest/include" -DMKL_LIBRARIES="C:/Program Files (x86)/Intel/oneAPI/mkl/latest/lib/intel64/mkl_intel_lp64.lib;C:/Program Files (x86)/Intel/oneAPI/mkl/latest/lib/intel64/mkl_sequential.lib;C:/Program Files (x86)/Intel/oneAPI/mkl/latest/lib/intel64/mkl_core.lib"</span></pre><p id="a5a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前几行设置了一些环境变量(这些变量并不总是必需的，但我设置它们只是为了安全起见)。CC和CXX变量分别存储CMake将使用的C和C++编译器的名称(这里MSVC++用于两者)。</p><p id="72a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(注意:cmake命令是一个完整的命令，即没有分成几行)</p><p id="33bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有几点需要注意。<code class="du lj lk ll lm b">-G</code>选项决定编译使用的构建系统。这里的参数“NMake Makefiles”指定了<code class="du lj lk ll lm b">nmake</code>。如果你想使用忍者，使用参数忍者(没有引号，即<code class="du lj lk ll lm b">-GNinja</code>)。<code class="du lj lk ll lm b">-S</code>选项告诉cmake当前目录(<code class="du lj lk ll lm b">.</code>)是源目录。<code class="du lj lk ll lm b">-B</code>选项告诉它创建一个文件夹<code class="du lj lk ll lm b">./build</code>并将所有已配置的构建文件放在那里。<code class="du lj lk ll lm b">-DGMX_GPU=off</code>表示不使用GPU加速(因为我目前没有GPU；如果我得到一个，我会用一个GPU加速构建指南来更新它)。</p><p id="8061" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后<code class="du lj lk ll lm b">DGMX_FFT_LIBRARY=mkl</code>选择英特尔MKL作为傅里叶变换库。<code class="du lj lk ll lm b">-DCMAKE_BUILD_TYPE=Release</code>表示使用最高优化，没有任何调试工具。<code class="du lj lk ll lm b">-DBUILD_SHARED_LIBS=off</code>意味着GROMACS二进制文件被静态链接到gromacs库(<code class="du lj lk ll lm b">gromacs.lib</code>)并且更具可移植性。</p><p id="70c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们已经将英特尔MKL指定为快速傅立叶变换库，所以我们需要指定它的位置。<code class="du lj lk ll lm b">-DMKL_INLCUDE_DIR</code>给出包含文件的位置(如<code class="du lj lk ll lm b">mkl.h</code>这样的头文件)。英特尔oneAPI的默认安装目录是<code class="du lj lk ll lm b">C:/Program Files (x86)/Intel/oneAPI/mkl/latest/include</code>。如果您将它安装在不同的位置，请确保相应地更改路径。</p><p id="f464" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lj lk ll lm b">-DMKL_LIBRARIES</code>给出了库的位置。MKL静态链接需要三个库:<code class="du lj lk ll lm b">mkl_intel_lp64.lib</code>、<code class="du lj lk ll lm b">mkl_sequential.lib</code>和<code class="du lj lk ll lm b">mkl_core.lib</code>。必须给出每个库的完整路径，用分号隔开。和以前一样，如果您在不同的位置安装了oneAPI，请进行相应的更改。</p><p id="ffe5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，每个路径参数必须在一对双引号(<code class="du lj lk ll lm b">“ ”</code>)内，因为它们包含空格。还要注意在路径中使用了正斜杠(<code class="du lj lk ll lm b">/</code>)，而不是Windows风格的反斜杠(<code class="du lj lk ll lm b">\</code>)。这是因为CMake采用带正斜杠的路径，因为它将反斜杠视为转义字符。您必须使用正斜杠，否则CMake将无法找到文件。</p><p id="bdd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行此命令后，CMake将测试许多不同的选项，并尝试在您的PC上选择最佳的编译选项。如果有几条“—失败”的消息，不要担心。最后，它应该向您显示消息“生成完成”和“构建文件已被写入…”。这意味着CMake配置成功。</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ly"><img src="../Images/e5b8614e715a0739b4d71e3e59afca6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDTF1Ks2MpkH5AhRQwoSYg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">CMake编译成功完成时的命令行输出</figcaption></figure><p id="08ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用FFTW3库时，运行以下命令:</p><pre class="kt ku kv kw fd lp lm lq lr aw ls bi"><span id="d7e9" class="je jf hi lm b fi lt lu l lv lw">set CC=cl<br/>set CXX=cl</span><span id="2772" class="je jf hi lm b fi lx lu l lv lw">cmake -G"Nmake Makefiles" -S. -B./build -DGMX_GPU=off -DGMX_FFT_LIBRARY=fftw3 -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=off -DFFTWF_INCLUDE_DIR="G:/Installer/gromacs-2021.1/fftw/fftw-3.3.5-dll64" -DFFTWF_LIBRARY="G:/Installer/gromacs-2021.1/fftw/fftw-3.3.5-dll64/libfftw3f-3.lib"</span></pre><p id="9dea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，<code class="du lj lk ll lm b">-DFFTWF_INCLUDE_DIR</code>应该指向包含文件<code class="du lj lk ll lm b">fftw3.h</code>所在的目录。<code class="du lj lk ll lm b">-DFFTWF_LIBRARY</code>应该指向单精度FFTW3 ( <code class="du lj lk ll lm b">libfftw3f-3.lib</code>)的库文件</p><p id="61a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，CMake应该能够成功地生成构建文件。</p><h2 id="fa87" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">最终编译和链接</h2><p id="f086" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">最终的编译和链接可以通过<code class="du lj lk ll lm b">nmake</code>或<code class="du lj lk ll lm b">ninja</code>完成。NMake可以从x64本机工具命令提示符运行。如果您使用了Windows的meson-ninja安装程序，那么<code class="du lj lk ll lm b">ninja</code>会在安装过程中自动添加到路径中，因此ninja可以从任何命令提示符下运行。</p><p id="7158" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导航到GROMACS源文件夹中的build文件夹，然后运行NMake:</p><pre class="kt ku kv kw fd lp lm lq lr aw ls bi"><span id="ca96" class="je jf hi lm b fi lt lu l lv lw">cd build<br/>nmake</span></pre><p id="082e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于忍者，运行:</p><pre class="kt ku kv kw fd lp lm lq lr aw ls bi"><span id="eba5" class="je jf hi lm b fi lt lu l lv lw">cd build<br/>ninja -j 4</span></pre><p id="8753" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，<code class="du lj lk ll lm b">-j 4</code>表示Ninja将使用4个内核来运行并行编译进程。如果您的芯片中有更多的内核，则更改该值。</p><p id="1943" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编译需要一些时间(大约20分钟)。您将看到一个很长的输出，并且可能会有一些编译器警告——可以忽略它们。除非有任何错误消息，否则在最后你会看到“链接gmx.exe”或类似的消息。如果链接成功，可以在构建文件夹中找到二进制gmx.exe。</p><p id="99b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你用的是Ninja，<code class="du lj lk ll lm b">gmx.exe</code>一般在build/bin文件夹下。如果您使用NMake，那么<code class="du lj lk ll lm b">gmx.exe</code>可能就在构建文件夹本身中。</p><h2 id="fba2" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">(可选)MPI并行构建</h2><p id="6ded" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">GROMACS的默认构建可以使用OpenMP并行化，和/或它自己的基于线程的并行化(称为thread-MPI)。两者都相当高效。但是，如果有非常多的处理器，或者您在多个处理器(节点)上运行它，那么MPI并行化会更好。在笔记本电脑或家用台式机上使用基于MPI的构建，您不太可能获得任何优势。然而，如果你想使用MPI并行的GROMACS二进制文件，首先从<a class="ae jd" href="https://www.microsoft.com/en-us/download/details.aspx?id=100593" rel="noopener ugc nofollow" target="_blank">这里</a>安装MS-MPI。然后将参数<code class="du lj lk ll lm b">DGMX_MPI=on</code>添加到CMake调用命令中。CMake会自动检测MS-MPI的位置，并用它进行编译。</p><p id="834a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，打开MPI会自动关闭thread-MPI。您仍将获得OpenMP支持。还要注意，编译完成后，可执行文件将被命名为<code class="du lj lk ll lm b">gmx_mpi.exe</code>。</p><h2 id="ab95" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">为运行设置GROMACS</h2><p id="08e2" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">首先，选择运行GROMACS的目录。例如，您可以将它保存在“C:\gromacs”中。确保目录名中没有任何空格。</p><p id="9f02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个文件夹里面创建一个文件夹“bin”，然后把<code class="du lj lk ll lm b">gmx.exe</code>放到“bin”子文件夹里面。</p><p id="764b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后转到您解压缩gromacs源文件的文件夹。找到“共享”文件夹。将“共享”文件夹复制到GROMACS目录中。然后在共享文件夹中创建一个名为“gromacs”的新文件夹，并将模板和顶层目录放入其中。(如果比较混乱就看看下面的目录树)。</p><p id="d053" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GROMACS使用OpenMP并行化和Microsoft Visual C/C++运行时。这些是由提供的。dll文件(动态链接库)。我不完全确定Visual Studio是否会自动安装它们。如果没有安装，程序将不会运行。您也可以在这里只安装Visual C++可再发行软件包<a class="ae jd" href="https://support.microsoft.com/en-us/topic/the-latest-supported-visual-c-downloads-2647da03-1eea-4433-9aff-95f26a218cc0" rel="noopener ugc nofollow" target="_blank">中的dll文件。</a></p><p id="19f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果您使用英特尔MKL: </strong></p><p id="9e15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">GROMACS可执行文件静态链接到英特尔MKL，因此不需要dll。</p><p id="a989" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果您使用FFTW3: </strong></p><p id="0a85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在解压FFTW3的目录中找到<code class="du lj lk ll lm b">libfftw3f-3.dll</code>文件。将该文件复制到<code class="du lj lk ll lm b">gmx.exe</code>所在的“bin”子文件夹中。</p><p id="c4d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">(可选)复制gromacs库</strong></p><p id="987c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您完成编译时，在“lib”文件夹insider build文件夹中应该有一个gromacs.lib或gmx.lib库。只有当您要在另一个程序中使用GROMACS时，才需要这样做。你可以将这些文件复制到GROMACS安装目录下的“lib”子文件夹中，但我认为这是不必要的。</p><p id="aeed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(注意:如果你在编译时没有使用<code class="du lj lk ll lm b">-DBUILD_SHARED_LIBS=off</code>，那么可以创建一个gromacs.dll或gmx.dll文件。你必须将这些文件复制到“bin”文件夹中。)</p><p id="75fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，您的GROMACS目录树应该如下所示:</p><pre class="kt ku kv kw fd lp lm lq lr aw ls bi"><span id="9daf" class="je jf hi lm b fi lt lu l lv lw">C:\gromacs\<br/>├───bin<br/>│   ├───gmx.exe<br/>│   ├───vcomp140.dll<br/>│   └───[libfftw3f-3.dll] (only if you used FFTW3)<br/>├───lib<br/>│   └───gromacs.lib<br/>│<br/>└───share<br/>    └───gromacs<br/>        ├───template<br/>        │   └───cmake<br/>        └───top<br/>            ├───amber03.ff<br/>            ├───amber94.ff<br/>            ├───amber96.ff<br/>            ├───amber99.ff<br/>            ├───amber99sb-ildn.ff<br/>            ├───amber99sb.ff<br/>            ├───amberGS.ff<br/>            ├───charmm27.ff<br/>            ├───gromos43a1.ff<br/>            ├───gromos43a2.ff<br/>            ├───gromos45a3.ff<br/>            ├───gromos53a5.ff<br/>            ├───gromos53a6.ff<br/>            ├───gromos54a7.ff<br/>            └───oplsaa.ff</span></pre><p id="a8d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦所有的文件都准备好了，我们需要创建一种方法来从命令行访问GROMACS二进制文件和那些文件。</p><p id="4034" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，创建一个名为“GMXRC.bat”的文件，其内容如下:</p><pre class="kt ku kv kw fd lp lm lq lr aw ls bi"><span id="dd29" class="je jf hi lm b fi lt lu l lv lw">@set "PATH=C:\Gromacs\bin;%PATH%"<br/>@set GMXDATA=C:\Gromacs\share\gromacs<br/>@cmd</span></pre><p id="f275" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果使用不同的位置，请更改路径。保存这个。蝙蝠文件放在方便的地方。</p><p id="8381" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论何时，你需要运行GROMACS，只要双击bat文件，它就会打开一个命令提示窗口，你可以在那里运行GROMACS。键入<code class="du lj lk ll lm b">gmx</code>并按回车键；您应该会看到类似这样的内容:</p><figure class="kt ku kv kw fd kx er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ly"><img src="../Images/c9005f235d80ec6bb48e30c681400bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zu8iFRemnwsrkmTglFNN-w.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">格罗马科斯跑了！</figcaption></figure><p id="da5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于MPI并行构建，您必须使用MS-MPI <code class="du lj lk ll lm b">mpiexec</code>命令来启动二进制文件。因此，如果您的计算机上有4个处理器，您将使用<code class="du lj lk ll lm b">mpiexec -np 4 gmx_mpi.exe &lt;commands&gt;</code>。安装MS-MPI时,<code class="du lj lk ll lm b">mpiexec</code>命令会自动安装到您的路径中。</p><h2 id="5ae8" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">回归测试</h2><p id="4fb2" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">您可以通过运行回归测试来测试您是否正确编译了GROMACS。这些测试可以从与GROMACS源代码相同的网页上下载(例如，v2021.1下载<a class="ae jd" href="https://manual.gromacs.org/documentation/2021.1/download.html" rel="noopener ugc nofollow" target="_blank">这里</a>)。</p><p id="a6f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您还需要Perl来运行测试。测试时间不长，最多3分钟。因此，我建议运行一次测试。如果一切正常，那么最后您会看到消息“所有7个重要的动态测试都通过了”。</p><p id="9c94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果任何一个测试失败了，可能是编译出错了。</p><p id="8b06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这样吧！您已经在Windows PC上启动并运行了GROMACS。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="b1ad" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">值得吗？</h2><p id="493e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">正如您所看到的，在Windows上编译相当痛苦，因为您需要显式地指定库和包含文件等的路径。</p><p id="642a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经历这些麻烦值得吗？当我进入计算建模领域时，我经常被告知“你为什么不买Linux？”当面对不能在Windows上运行的软件时。我的笔记本电脑安装了Windows，我有所有我经常需要的文件和实用程序。试图安装一个双引导的Linux太冒险了。尽管Linux是一个相当健壮和古老的操作系统，但许多实用程序仍然不存在于Linux上。例如，我的大学工作需要使用VPN，而VPN客户端只安装在Windows或Mac上。</p><p id="f2e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">承认，对于任何主要的生产计算，您都需要使用HPC(即超级计算机)。但是大量的测试和准备工作必须在我自己的电脑上完成，如果你的电脑足够强大，小批量生产甚至可以完成。所以我认为在Windows上编译GROMACS或其他软件是值得的，如果它们能在Windows上运行的话。</p><p id="53af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一提到在Windows上编译源代码(针对Linux)就有很多人提到Cygwin和WSL。但是它们都是Linux兼容层，并且非常慢，尤其是在涉及文件I/O的情况下。使用它们应该是最后的手段，而不是第一选择。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="86e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如开始提到的，我已经把我编译的GROMACS可执行文件放在我的github repo <a class="ae jd" href="https://github.com/ShoubhikRaj/gromacs-windows" rel="noopener ugc nofollow" target="_blank">这里</a>。这些是预编译的二进制文件，但是仍然需要安装Visual C++的可再发行文件(因为二进制文件依赖于Visual C/C++ OpenMP运行时库)。存储库中的自述文件中提供了相关说明。</p><p id="bd27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上所有指南都是在只考虑64位机器(x64)的情况下编写的。对于32位机器，会有一些变化。</p></div></div>    
</body>
</html>