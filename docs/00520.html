<html>
<head>
<title>Intermediate C# [OOP &amp; Structs, delegates]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中级c#[面向对象和结构、委托]</h1>
<blockquote>原文：<a href="https://medium.com/codex/intermediate-c-oop-structs-delegates-4ffd0cd70cf?source=collection_archive---------2-----------------------#2021-02-19">https://medium.com/codex/intermediate-c-oop-structs-delegates-4ffd0cd70cf?source=collection_archive---------2-----------------------#2021-02-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="4e75" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><div class=""><h2 id="313a" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">在C#中，我们可以找到一些有用的OOP工具来使我们的代码变得更好。</h2></div><p id="fb13" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在本文中，您将找到一些可以在您的程序中使用的中间工具。</p><blockquote class="kc kd ke"><p id="8d4f" class="jg jh kf ji b jj jk is jl jm jn iv jo kg jq jr js kh ju jv jw ki jy jz ka kb hb bi translated"><strong class="ji hs">注意——操作(操作符重载，索引器)同样适用于结构。然而，这些例子将使用类。</strong></p></blockquote><figure class="kk kl km kn fd ko er es paragraph-image"><div class="er es kj"><img src="../Images/491bfeaa1a30bcfe6102d70164ed76a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*MOU6SgOM6WAhNWcALOUZ7w.png"/></div></figure></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="6160" class="ky kz hi bd la lb lc ld le lf lg lh li ix lj iy lk ja ll jb lm jd ln je lo lp bi translated">索引器</h1><p id="7be6" class="pw-post-body-paragraph jg jh hi ji b jj lq is jl jm lr iv jo jp ls jr js jt lt jv jw jx lu jz ka kb hb bi translated">如果你曾经使用过List <t>或者Dictionary <t>并且你对一个类的实例如何像数组一样拥有索引感到好奇，那么答案就是索引器。</t></t></p><p id="7cf0" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在下面的例子中，我们可以看到如何创建一个索引器。</p><p id="3df5" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">T —代表我们从索引返回的值。</p><p id="401b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">[int index] —用户作为参数给出的索引。</p><pre class="kk kl km kn fd lv lw lx ly aw lz bi"><span id="15a8" class="ma kz hi lw b fi mb mc l md me">public class SampleClass&lt;T&gt;<br/>{<br/>   protected T[] arr;</span><span id="c105" class="ma kz hi lw b fi mf mc l md me">   public SampleClass(params T[] arr2)<br/>   {<br/>     this.arr = arr2;<br/>   }</span><span id="6515" class="ma kz hi lw b fi mf mc l md me">   public T this[int index]<br/>   {<br/>     get { return arr[index]; }<br/>     set { this.arr[index] = value; }<br/>   }<br/>}</span></pre><p id="74e2" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">注意</strong>我们可以让索引器获取&amp;返回我们想要的任何类型，如果我们实现了字典&lt;字符串，例如字符串&gt;，我们可以用<strong class="ji hs">字符串键替换<strong class="ji hs"> int index </strong>。</strong></p><p id="8bc7" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">主要功能:</p><pre class="kk kl km kn fd lv lw lx ly aw lz bi"><span id="f0eb" class="ma kz hi lw b fi mb mc l md me">public static void Main(string[] args)<br/>{<br/>  SampleClass&lt;int&gt; sample = new SampleClass&lt;int&gt;(5,4,3);<br/>  sample[0] = 10; //now the array value is [10,4,3]<br/>  Console.WriteLine(sample[0]); //prints 10 to the console<br/>}</span></pre><p id="b391" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">在Visual Studio中，可以编写索引器，然后按两次tab来自动完成索引器结构。</strong></p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="1775" class="ky kz hi bd la lb lc ld le lf lg lh li ix lj iy lk ja ll jb lm jd ln je lo lp bi translated">运算符重载</h1><p id="cb5c" class="pw-post-body-paragraph jg jh hi ji b jj lq is jl jm lr iv jo jp ls jr js jt lt jv jw jx lu jz ka kb hb bi translated">如果你曾经考虑过如何创建一个能够使用像++和==这样的操作符的实例，那么答案就在这里。</p><pre class="kk kl km kn fd lv lw lx ly aw lz bi"><span id="5a34" class="ma kz hi lw b fi mb mc l md me">public class Circle<br/>{<br/>   public double radius { get; set; }<br/>   public const double PI = Math.PI;</span><span id="0656" class="ma kz hi lw b fi mf mc l md me">   public Circle(double Radius)<br/>   {<br/>     this.radius = Radius;<br/>   }<br/>   <br/>   public static Circle operator ++(Circle myCircle)<br/>   {<br/>     myCircle.radius++;<br/>     return myCircle;<br/>   }<br/>}</span><span id="855c" class="ma kz hi lw b fi mf mc l md me">public static void Main(string[] args)<br/>{  <br/>   Circle instance = new Circle(45.45);<br/>   instance++;<br/>   Console.WriteLine(instance.radius);<br/>}</span></pre><p id="8d04" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">运算符重载的语法是“public static (Type) operator(我们要重载的运算符)(Arguments)”。</p><blockquote class="kc kd ke"><p id="65ab" class="jg jh kf ji b jj jk is jl jm jn iv jo kg jq jr js kh ju jv jw ki jy jz ka kb hb bi translated"><strong class="ji hs">当我们谈到操作符重载时，第一个论据就是实例。</strong></p></blockquote><p id="b1fb" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在operator ++中，实例的唯一交互是与实例本身的交互，所以这就是++重载中的参数只能是调用方的原因。</p><p id="c3af" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">因为++是一个赋值操作符，操作符返回的类型应该和调用这个操作符的类相同，在我们的例子中是Circle。</p><p id="b669" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果你的编译器返回的值不是你的实例在++上的类，那么它将会产生一个编译时错误。</p><pre class="kk kl km kn fd lv lw lx ly aw lz bi"><span id="31df" class="ma kz hi lw b fi mb mc l md me">instance = instance + 1; //raise error if it's not a Circle type</span></pre><p id="92d6" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">但是，比如说，因为这个操作应该返回一个布尔值，那么在这种情况下，这个值是<strong class="ji hs">而不是作为实例值存储的</strong>。</p><p id="3aea" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这就是为什么我们可以让操作符重载来返回一个bool(因为值不存储在名为operator的类中，我们可以让==返回我们想要的任何类型，但是，最好的做法是返回一个boolean)。</p><pre class="kk kl km kn fd lv lw lx ly aw lz bi"><span id="8292" class="ma kz hi lw b fi mb mc l md me">public static bool operator ==(Circle myCircle, Circle myCircle2)<br/>{<br/>  if (myCircle.radius == myCircle2.radius)<br/>    return true;<br/>  return false;<br/>}</span><span id="dec6" class="ma kz hi lw b fi mf mc l md me">public static bool operator !=(Circle myCircle, Circle myCircle2)<br/>{<br/>   if (myCircle.radius != myCircle2.radius)<br/>     return true;<br/>   return false;<br/>}</span></pre><p id="0c1d" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在上面的例子中，我们比较了实例半径，如果满足条件，则返回true或false。</p><p id="d130" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">请注意，如果重载==运算符，则必须实现！=运算符。</p><p id="35f2" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">==和！=需要根据它们返回的内容进行匹配，例如我们不能说= = return bool wherever！=返回double。</p><pre class="kk kl km kn fd lv lw lx ly aw lz bi"><span id="a2fd" class="ma kz hi lw b fi mb mc l md me">public static void Main(string[] args)<br/>{<br/>  Circle first = new Circle(50);<br/>  Circle second = new Circle(60);</span><span id="273c" class="ma kz hi lw b fi mf mc l md me">  Console.WriteLine(first == second); //prints false<br/>}</span></pre><p id="2c43" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">运算符重载有一些限制，例如，我们不能重载所有类型的运算符。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es mg"><img src="../Images/5c14f7b5a40bbc490c0df8dca85e7132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLev401uMB1e9gidXVQIpw.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">该列表摘自<a class="ae mp" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/cs harp/language-reference/operators/operator-overloading</a></figcaption></figure></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="6c81" class="ky kz hi bd la lb lc ld le lf lg lh li ix lj iy lk ja ll jb lm jd ln je lo lp bi translated">扩展ˌ扩张</h1><p id="6318" class="pw-post-body-paragraph jg jh hi ji b jj lq is jl jm lr iv jo jp ls jr js jt lt jv jw jx lu jz ka kb hb bi translated">扩展是我们为已有类添加方法的方式。</p><p id="1d01" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果您曾经想给字符串类型添加一个名为PrintMe的函数，将字符串值打印到屏幕上，这是最佳的方法。</p><h2 id="ddd7" class="ma kz hi bd la mq mr ms le mt mu mv li jp mw mx lk jt my mz lm jx na nb lo ho bi translated">为什么不继承到其他类？</h2><p id="9ee0" class="pw-post-body-paragraph jg jh hi ji b jj lq is jl jm lr iv jo jp ls jr js jt lt jv jw jx lu jz ka kb hb bi translated">可以问的一个问题是，为什么不以类Random为例，并使CustomRandom类继承Random。</p><p id="05dd" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">答案是我们不能，不是所有的类都可以继承到其他类，因为它们被标记为<strong class="ji hs">密封类，</strong>这意味着其他类不能在继承中实现它们，这意味着我们为这个类定制函数的唯一方法是使用扩展。</p><h2 id="a1e7" class="ma kz hi bd la mq mr ms le mt mu mv li jp mw mx lk jt my mz lm jx na nb lo ho bi translated">我们如何进行扩展？</h2><p id="b6ee" class="pw-post-body-paragraph jg jh hi ji b jj lq is jl jm lr iv jo jp ls jr js jt lt jv jw jx lu jz ka kb hb bi translated">为了进行扩展，我们需要遵循一些规则，首先，一个扩展函数应该嵌套在一个<strong class="ji hs">静态类中。</strong></p><p id="da17" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">该方法应遵循以下规则。</p><pre class="kk kl km kn fd lv lw lx ly aw lz bi"><span id="7e0f" class="ma kz hi lw b fi mb mc l md me">public static class SampleExtentions<br/>{<br/>  public static (Return Type) SampleFunction(this (Type Name) name)<br/>  {<br/>    //implementation<br/>  }<br/>}</span></pre><p id="8a44" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在上面的例子中，<strong class="ji hs">“this(Type Name)”</strong>指的是我们要为其添加函数的类型。</p><pre class="kk kl km kn fd lv lw lx ly aw lz bi"><span id="aeee" class="ma kz hi lw b fi mb mc l md me">public static class StringExtention<br/>{<br/>   public static void PrintMe(this string value)<br/>   {<br/>      Console.WriteLine(value);<br/>   }<br/>}</span></pre><p id="aef1" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在上面的例子中，我们对string类型做了一个名为PrintMe的扩展。</p><p id="d93f" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在下面的例子中，我们在main函数上使用了那个方法。</p><pre class="kk kl km kn fd lv lw lx ly aw lz bi"><span id="ac7b" class="ma kz hi lw b fi mb mc l md me">public static void Main(string[] args)<br/>{<br/>   string myName = "Hello World!";<br/>   myName.PrintMe();<br/>}</span></pre><p id="6504" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">注意</strong> —扩展方法中的类型也可以是值类型。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><h1 id="4fb0" class="ky kz hi bd la lb lc ld le lf lg lh li ix lj iy lk ja ll jb lm jd ln je lo lp bi translated">代表</h1><h2 id="3846" class="ma kz hi bd la mq mr ms le mt mu mv li jp mw mx lk jt my mz lm jx na nb lo ho bi translated">什么是委托？</h2><p id="0c68" class="pw-post-body-paragraph jg jh hi ji b jj lq is jl jm lr iv jo jp ls jr js jt lt jv jw jx lu jz ka kb hb bi translated">总而言之，委托是一个函数指针。这意味着委托将函数的地址存储为值。</p><p id="5b14" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">委托也可以将其他地址链接到他的值，但是，所有的函数都应该使用相同的参数并返回相同的值。</p><p id="6d5c" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们可以通过说“delegate_name(arguments)”来执行所有的函数(因为它们采用相同的参数)，并返回最后一个函数添加的返回值。</p><p id="5fdb" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">要创建委托，我们需要编写:</p><pre class="kk kl km kn fd lv lw lx ly aw lz bi"><span id="b8f5" class="ma kz hi lw b fi mb mc l md me">public delegate int SampleName(int value); //declare the delegate</span><span id="2c72" class="ma kz hi lw b fi mf mc l md me">public static void Main(string[] args)<br/>{<br/>  SampleName delegate1 = Function1; //get the address of the function<br/>  delegate1 += (int value2) =&gt; return (value2 + 3); //chained them<br/>  <br/>  int val = delegate1(5); //stores 8 because of the last function chained</span><span id="9816" class="ma kz hi lw b fi mf mc l md me">  delegate1 += Function1; //by that we execute the same function twice<br/>}</span><span id="1944" class="ma kz hi lw b fi mf mc l md me">public static int Function1(int value)<br/>{<br/>  Console.Write("Hi!");<br/>  return value + 1;<br/>}</span></pre><h2 id="4cb9" class="ma kz hi bd la mq mr ms le mt mu mv li jp mw mx lk jt my mz lm jx na nb lo ho bi translated">函数<t> &amp;动作<t> &amp;谓词<t/></t></t></h2><p id="7b54" class="pw-post-body-paragraph jg jh hi ji b jj lq is jl jm lr iv jo jp ls jr js jt lt jv jw jx lu jz ka kb hb bi translated"><strong class="ji hs">普通委托的问题</strong></p><p id="b505" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">普通代表有各种各样的问题。例如，如果我们有两个委托，它们接受相同的参数并具有相同的返回类型，但委托本身有不同的名称，我们就不能将它们链接起来或使它们相等。</p><pre class="kk kl km kn fd lv lw lx ly aw lz bi"><span id="d4f7" class="ma kz hi lw b fi mb mc l md me">public delegate void FirstDelegate();<br/>public delegate void SecondDelegate();</span><span id="6642" class="ma kz hi lw b fi mf mc l md me">public static void Main(string[] args)<br/>{<br/>  FirstDelegate fi = Console.WriteLine;<br/>  SecondDelegate se = Console.WriteLine;<br/>  Func1(fi); //OK<br/>  Func2(se); //raise error because delegates not from same type<br/>}</span><span id="60cb" class="ma kz hi lw b fi mf mc l md me">public static void CallDelegate(FirstDelegate fi)<br/>{<br/>  fi(); //execute the delegate<br/>}</span></pre><p id="990d" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">由于这个问题，用户可以毫无理由地用相同的参数和相同的返回类型反复定义相同的委托。</p><h2 id="d2ef" class="ma kz hi bd la mq mr ms le mt mu mv li jp mw mx lk jt my mz lm jx na nb lo ho bi translated"><strong class="ak">解决方案</strong></h2><p id="ea7c" class="pw-post-body-paragraph jg jh hi ji b jj lq is jl jm lr iv jo jp ls jr js jt lt jv jw jx lu jz ka kb hb bi translated">不是任何问题都有解决方案，但是代表们有。</p><p id="cc21" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">C#提供了另外两个名为Func和Action的预定义类，它们是一种委托。</p><p id="6de2" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="ji hs">动作</strong> —在动作中，我们简单地编写动作&lt;参数类型&gt;，动作将获得参数类型的参数，但返回值将是空的。</p><ul class=""><li id="7a40" class="nc nd hi ji b jj jk jm jn jp ne jt nf jx ng kb nh ni nj nk bi translated"><strong class="ji hs">动作</strong>示例</li></ul><pre class="kk kl km kn fd lv lw lx ly aw lz bi"><span id="53e6" class="ma kz hi lw b fi mb mc l md me">Action&lt;int&gt; act = (int value) =&gt; Console.WriteLine(value);</span><span id="43db" class="ma kz hi lw b fi mf mc l md me">//pass a bigger function<br/>act += (int value) =&gt; <br/>{<br/>   Console.WriteLine(value);<br/>   Console.WriteLine(value);<br/>};</span></pre><p id="3fd4" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在上面的例子中，我们将一个获取整数并返回void的函数链接到委托。</p><ul class=""><li id="f94c" class="nc nd hi ji b jj jk jm jn jp ne jt nf jx ng kb nh ni nj nk bi translated">什么是<strong class="ji hs"> Func </strong></li></ul><p id="5c16" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在Func中，事情就像在运行中一样，唯一的区别是最后一个泛型类型是返回类型。</p><pre class="kk kl km kn fd lv lw lx ly aw lz bi"><span id="23ff" class="ma kz hi lw b fi mb mc l md me">Func&lt;int, string&gt; fun_ = (int value) =&gt;<br/>{<br/>  return value + " Hello";<br/>};</span><span id="52db" class="ma kz hi lw b fi mf mc l md me">string b = fun_(5); //now b stores "5 Hello"<br/>fun_ += (int value) =&gt;<br/>{<br/>   return value + " World";<br/>};<br/>b = fun_(5); //now b stores "5 World"</span></pre><ul class=""><li id="f21f" class="nc nd hi ji b jj jk jm jn jp ne jt nf jx ng kb nh ni nj nk bi translated">什么是<strong class="ji hs">谓词</strong></li></ul><p id="b52a" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">谓词很像操作，它们之间的主要区别是谓词总是返回bool而不是void。</p><pre class="kk kl km kn fd lv lw lx ly aw lz bi"><span id="3d38" class="ma kz hi lw b fi mb mc l md me">public static void Main(string[] args)<br/>{<br/>  Predicate&lt;int&gt; pre = (int value) =&gt; value == 5;<br/>  Print(pre, 1,2,3,4,5,6); //prints 5 as the number of times it shown in the params<br/>}</span><span id="2f80" class="ma kz hi lw b fi mf mc l md me">public static void Print(Predicate&lt;int&gt; pre, params int[] arr)<br/>{<br/>   foreach(int item in arr)<br/>   {<br/>     if(pre(item)) //check the condition in the predicate<br/>     {<br/>        Console.WriteLine(item);<br/>     }<br/>   }<br/>}</span></pre><h2 id="3f02" class="ma kz hi bd la mq mr ms le mt mu mv li jp mw mx lk jt my mz lm jx na nb lo ho bi translated"><strong class="ak">他们如何提供帮助？</strong></h2><p id="b627" class="pw-post-body-paragraph jg jh hi ji b jj lq is jl jm lr iv jo jp ls jr js jt lt jv jw jx lu jz ka kb hb bi translated">Func &amp; Action &amp; Predicate在全局范围内使用，所以使用它们是一个好习惯，因为每个人都使用它们，我们避免了相同的委托使用不同名称的问题。</p><p id="32eb" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">然而，考虑这样一个事实，有时创建我们自己的委托是好的，因为Func &amp; Action &amp; Predicate很难理解它们的目的是什么，并且我们不能给它们一个好的解释，因为它们已经定义了name类。</p></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="a717" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">恭喜你！你已经写完文章了！希望你喜欢。</p></div></div>    
</body>
</html>