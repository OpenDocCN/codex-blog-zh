<html>
<head>
<title>Word Embeddings — Text Representation for Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单词嵌入——神经网络的文本表示</h1>
<blockquote>原文：<a href="https://medium.com/codex/word-embeddings-text-representation-for-neural-networks-65fd934d1fa2?source=collection_archive---------5-----------------------#2022-05-30">https://medium.com/codex/word-embeddings-text-representation-for-neural-networks-65fd934d1fa2?source=collection_archive---------5-----------------------#2022-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9edc753dc72cf16cfd586d4e9862011c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7o5l8PxAI7GXuOT7"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">艾莉娜·格鲁布尼亚克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f29a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于任何ML项目，特征提取都是构建模块，模型从这些特征中导出模式，而无需显式训练。无论数据是文本、图像、视频还是语音，都需要用数字格式表示，以便用任何ML算法处理。与复杂得多的文本相比，图像、视频和语音的数学表示更为简单。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/3fd51adc7a7aece096220cca50a7f110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HfnEzlArgWJrw7hMCFcUFQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><strong class="bd jy">典型的</strong> <a class="ae iu" href="https://www.amazon.com/Practical-Natural-Language-Processing-Pragmatic/dp/1492054054/ref=sr_1_1?keywords=practical+natural+language+processing&amp;qid=1653872590&amp;sprefix=practical+natural%2Caps%2C2051&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank"> <strong class="bd jy"> NLP流水线</strong> </a></figcaption></figure><p id="9844" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在NLP世界中，这种原始文本到合适的数字形式的转换被称为文本表示。各种技术被用来收集文本，把它们分解成原子，并把它们转换成数字向量。</p><blockquote class="jz ka kb"><p id="1464" class="iv iw kc ix b iy iz ja jb jc jd je jf kd jh ji jj ke jl jm jn kf jp jq jr js hb bi translated">“与将顶级算法应用于普通文本表示相比，将好的文本表示应用于普通算法会让你走得更远。”</p></blockquote><p id="2b01" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">—第84页，<a class="ae iu" href="https://www.oreilly.com/library/view/practical-natural-language/9781492054047/" rel="noopener ugc nofollow" target="_blank">实用自然语言处理</a></p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><p id="3548" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从将原始文本转换成数字向量的方法开始。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/52933340dcf0bdcaab2bb2be1a37d56a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YiGZnX10ijjczC6xa1J10g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源:<a class="ae iu" href="https://s3.amazonaws.com/aylien-main/misc/blog/images/nlp-language-dependence-small.png" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><p id="fc52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了从一段语料库中正确地提取主要单词/标记，第一步通常是将句子分成词汇单元，然后对句子进行标记，并根据用例移除停用单词和不相关的单词/句子，这通常由<a class="ae iu" href="https://docs.python.org/3/howto/regex.html" rel="noopener ugc nofollow" target="_blank"> <em class="kc">正则表达式</em> </a>、<a class="ae iu" href="https://www.nltk.org/" rel="noopener ugc nofollow" target="_blank"> <em class="kc"> NLTK </em>、</a><a class="ae iu" href="https://spacy.io/api" rel="noopener ugc nofollow" target="_blank"> <em class="kc"> spaCy </em> </a>或<a class="ae iu" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/TextVectorization" rel="noopener ugc nofollow" target="_blank"> <em class="kc">文本向量矢量化</em> </a>来完成</p><p id="cbdd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在此之后，我们现在将有一个记号列表，这些记号只不过是数字表示的独特单词(也称为词汇)——可以转换成数字向量。</p><p id="e57a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在直接进入单词嵌入之前，让我们看看一些传统的数字编码方法，以及为什么它们不是输入神经网络的好方法。</p><h2 id="6dea" class="ko kp hi bd jy kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">标签编码</h2><p id="3f22" class="pw-post-body-paragraph iv iw hi ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">这种方法非常简单，它为语料库中的每个标记分配一个唯一的编号。它与词汇的大小成正比，并且由于其排序的性质，在获得较高数字的特征之间建立了关系，并且有偏差的模型是不可避免的。这可能导致模型性能不佳和意想不到的结果，因此在特征表示方面使用这种技术是一个很大的问题，而总是用于目标变量/标签，因此得名。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">更多阅读:<a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><h2 id="d187" class="ko kp hi bd jy kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">一个热编码器</h2><p id="91c3" class="pw-post-body-paragraph iv iw hi ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">在独热编码中，语料库词汇表中的每个记号被给予1到n之间的唯一整数表示，其中n是语料库词汇表中唯一记号的长度/数量(<em class="kc">记号集</em>)。在n维空间中，每个标记将占据其中一个维度，这意味着无论上下文如何，这些标记之间都没有任何相似性。这是通过一个n维向量来完成的，除了标记为1的索引之外，该向量都填充了0。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="ln lo l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">更多阅读:<a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><h2 id="8f71" class="ko kp hi bd jy kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">仿制品</h2><p id="6df3" class="pw-post-body-paragraph iv iw hi ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">将分类值转换为虚拟/指标值的更灵活的方法。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="e2e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，get_dummies()提供了一个热版本，为了获得虚拟版本，我们需要传递drop_first=True。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/c2dc7c5427dd1ff03b3525fb65bc3d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*1caOMI3a42Vh2tJsVvfF3g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">更多阅读:<a class="ae iu" href="https://pandas.pydata.org/docs/reference/api/pandas.get_dummies.html" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><p id="9fe4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们看到在一键编码中有一些冗余，n维向量可以用n-1维长来表示。在上面的例子中，如果任何两个城市是0，那么很明显第三个是1，因此上面的表示可以进一步转换成这样。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/0c2448e5a1afe85a1a988127858e1216.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*Cehy3U4ZudlgfM6vk2peKA.png"/></div></figure><h2 id="123b" class="ko kp hi bd jy kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">为什么这些不适合神经网络？</h2><p id="c91c" class="pw-post-body-paragraph iv iw hi ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">还有几个比如BoW，TF-IDF等。我们不会详细讨论所有问题，但所有问题的共同点是:</p><ol class=""><li id="b66b" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated">它们是离散的表示——捕捉单词之间关系的能力丧失了。</li><li id="8207" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">特征向量是稀疏的(<em class="kc">对于任何向量</em>大多数值为零)和高维的(<em class="kc">与词汇</em>的大小成比例)表示。</li><li id="705d" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">他们不能处理OOV词汇。</li></ol><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mf lo l"/></div></figure><p id="1c6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有这些都妨碍了学习能力和高维表示，使它们的计算效率低下。<strong class="ix hj"> <em class="kc">密集再现</em> </strong>前来救援。</p><blockquote class="jz ka kb"><p id="7290" class="iv iw kc ix b iy iz ja jb jc jd je jf kd jh ji jj ke jl jm jn kf jp jq jr js hb bi translated">“使用密集和低维向量的好处之一是计算上的:大多数神经网络工具包不能很好地处理非常高维、稀疏的向量。……密集表示的主要好处是泛化能力:如果我们认为某些特征可能提供相似的线索，那么提供一种能够捕捉这些相似性的表示是值得的。”</p></blockquote><p id="da03" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">—92页，<a class="ae iu" href="https://amzn.to/2wycQKA" rel="noopener ugc nofollow" target="_blank">自然语言处理中的神经网络方法</a>。</p></div><div class="ab cl kg kh gp ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hb hc hd he hf"><h2 id="fe27" class="ko kp hi bd jy kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated"><strong class="ak">单词嵌入</strong></h2><p id="d240" class="pw-post-body-paragraph iv iw hi ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">嵌入是自然语言的一种表示，可以在具有相同含义的单词具有相似表示的情况下学习。</p><p id="f857" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于语料库中的词集，嵌入是来自分布式表示的向量空间到来自分布式表示的向量空间之间的映射。如果我们给定单词“USA”，分布相似的单词可能是其他国家(例如，加拿大、德国、印度等。)或美国的城市。</p><p id="ce9a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分布式表示是基于单词的使用来学习的。这允许以相似方式使用的单词产生相似的表示，自然地捕捉它们的意思。</p><p id="d660" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个单词用一个实值向量来表示，往往是几十维或者几百维。这与稀疏单词表示所需的数千或数百万维形成对比，例如一键编码。</p><h2 id="d8dc" class="ko kp hi bd jy kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated"><strong class="ak"> <em class="mg">创建自己的嵌入层</em> </strong></h2><p id="2fdd" class="pw-post-body-paragraph iv iw hi ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">为了创建自己的word嵌入层，您需要执行以下操作:</p><ol class=""><li id="3edd" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated">文本清理</li><li id="88ec" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">标记化</li><li id="afdb" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">把...嵌入</li></ol><p id="ed25" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kc">第一步:文本清理</em> </strong></p><p id="d7f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是构建的基础，也是非常关键的一步，嵌入的质量与文本清洗成正比。噪音越小，模型越好。我们可以根据所需的清理类型来利用NLP库。在本教程中，由于显而易见的原因，我不打算介绍这一步。</p><p id="68fb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kc">第二步:标记化</em> </strong></p><p id="3bcf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记号化意味着记号到数字的直接映射。我们将使用TensorFlow的<a class="ae iu" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/TextVectorization" rel="noopener ugc nofollow" target="_blank">文本矢量化</a>，这是一个预处理层，直接将文本特征映射到整数序列。它执行以下操作:</p><ol class=""><li id="cab3" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated">标准化每个例子(通常是小写+标点符号剥离)</li><li id="f55c" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">将每个例子分成子串(通常是单词)</li><li id="b340" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">将子字符串重新组合成标记(通常是ngrams)</li><li id="0e1c" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">索引标记(将唯一的int值与每个标记相关联)</li><li id="18e4" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">使用该索引将每个示例转换为整型向量或密集浮点型向量。</li></ol><p id="dabf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们创建一个伪序列列表。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/691986ac5b3f62e154a12a89d10aea19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hop8myTrsN12nbGp6MdGkw.png"/></div></div></figure><p id="dc35" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，导入库并初始化参数。以下是一些需要注意的关键参数:</p><ul class=""><li id="f30f" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js mi lx ly lz bi translated">max_tokens =词汇表中有多少单词。</li><li id="ac9d" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js mi lx ly lz bi translated">标准化=你想应用哪种标准化，比如“lower”、“strip _标点”或“lower _ and _ strip _标点”。</li><li id="4608" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js mi lx ly lz bi translated">split =是按空白还是某些指定字符进行拆分。</li><li id="7348" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js mi lx ly lz bi translated">ngrams =创建n个单词的组，默认为None(无组)。</li><li id="016c" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js mi lx ly lz bi translated">output_sequence_length =每个序列应该有多长？</li></ul><p id="1623" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">定义output_sequence_length的一个好方法是在每个句子中放置一个大于或等于平均标记数的值，如下所示:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/92edf63829294dfc6a9c732d9ff60d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DUJDJZtLiCmOHNXqHoIaYQ.png"/></div></div></figure><p id="273d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以在这里，我可以选择值3，但我会选择4，我们最终会知道为什么。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/d4a705e17f2e11eda062cec60aad5a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQDYACABdMOEoV8qjj_VPg.png"/></div></div></figure><p id="635e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在是我们的text_vectorization实例调整语料库中的序列的时候了。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/6997a184aaa760d273d8c3dba9caf05f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djECAW8clOewVuMF8iSDWw.png"/></div></div></figure><p id="9744" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">形状在这里非常重要— (3，4)，它代表行数，然后每个序列有多长。由于我们定义了“output_sequence_length = 4 ”,因此尽管序列长度等于3，但它会用零填充到4，这同样适用于对映体，即，即使序列长于所述大小，它也会被截断到定义的限制，因此选择该参数是棘手的。即使将单个令牌传递给此方法，它也会继续使用相同的填充。</p><p id="ed6f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kc">步骤三:嵌入</em> </strong></p><p id="c546" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们到了创建单词嵌入层的最后一步！为此，我们将使用<em class="kc"> TensorFlow的</em> <a class="ae iu" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Embedding" rel="noopener ugc nofollow" target="_blank"> <em class="kc">嵌入</em> </a> <em class="kc">。同样，这里有一些需要注意的关键参数:</em></p><ul class=""><li id="05a1" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js mi lx ly lz bi translated">input_dim =词汇表的大小。</li></ul><p id="cc8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在将矢量器拟合到语料库之后，我们可以通过使用以下公式来获得词汇的长度:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/472a22c4ea5300ca0bfd06e1d63016d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzgHTqcD17y4EuNCf0Hdbg.png"/></div></div></figure><ul class=""><li id="14a2" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js mi lx ly lz bi translated">output_dim =输出嵌入向量的大小，值10将意味着每个令牌由10个向量表示</li></ul><p id="5e4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kc">注意</em> </strong> <em class="kc">:始终尝试定义容易被8整除的向量——加速计算</em></p><ul class=""><li id="02e9" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js mi lx ly lz bi translated">input_length =传递到嵌入层的序列长度，因此它应该等于<em class="kc"> output_sequence_length </em></li></ul><p id="7236" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们创建嵌入的实例，并将其安装到上一步的输出中。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/bd5d44bcbf3deafae7a7ef6b4abbf9a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*S1qWVxYg491USwX6-gJrhg.png"/></div></figure><p id="fa88" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出形状非常重要，因为该形状将负责将该嵌入馈送到任何神经网络。</p><p id="4d0a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kc">那么(3，4，4)是什么意思？</em></p><p id="7d83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3-传递三个序列，</p><p id="a8c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4-每个句子被填充为4个标记，因此所有的零将具有相同的表示。</p><p id="b76c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4-每个标记由4个特征向量表示。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/2ac91b6ba4ee9506228a9e0478f7d634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_j-3bhk1SbiI0SEQnBhkPA.png"/></div></div></figure><p id="4cd4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以看到，这次的形状是(1，4，4)。虽然只传递了一个令牌，但它被视为一个序列并被填充。因此，第一行是唯一的，其余行都具有相同的0表示。</p><p id="ad5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看看完整的工作流程。</p><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="ln lo l"/></div></figure><figure class="ju jv jw jx fd ij"><div class="bz dy l di"><div class="mp lo l"/></div></figure><p id="2759" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">恭喜你！！！现在我们知道如何在TensorFlow中高效地创建一个基本的单词嵌入层！这两个著名的算法只是这一层的扩展版本，它们是<a class="ae iu" href="https://www.tensorflow.org/tutorials/text/word2vec" rel="noopener ugc nofollow" target="_blank"> <em class="kc"> word2vec </em> </a> <em class="kc">和</em> <a class="ae iu" href="https://nlp.stanford.edu/projects/glove/" rel="noopener ugc nofollow" target="_blank"> <em class="kc"> GloVe </em> </a> <em class="kc">，我们将分别介绍它们。</em></p><h2 id="bf3c" class="ko kp hi bd jy kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">总结:</h2><ul class=""><li id="6c34" class="lr ls hi ix b iy li jc lj jg mq jk mr jo ms js mi lx ly lz bi translated">神经网络和数字一起工作，所以你不能只是把单词扔进去。</li><li id="22cc" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js mi lx ly lz bi translated">你<strong class="ix hj"> </strong>可以一次性编码所有的单词，但这将导致一个稀疏的矩阵，你将失去它们之间相似性的概念——这是一个大禁忌。</li><li id="86f3" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js mi lx ly lz bi translated">神经网络最适合密集层。</li><li id="2137" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js mi lx ly lz bi translated">因此，我们将嵌入层提供给神经网络。</li></ul><p id="05be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="kc">参考文献:</em> </strong></p><ol class=""><li id="bc12" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated">实用自然语言处理:构建真实世界自然语言处理系统的综合指南。 </li></ol><p id="fac6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kc"> 2。</em> <a class="ae iu" href="https://machinelearningmastery.com/what-are-word-embeddings/" rel="noopener ugc nofollow" target="_blank"> <em class="kc">什么是文本的单词嵌入？</em> </a></p><p id="72bf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.<a class="ae iu" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Embedding" rel="noopener ugc nofollow" target="_blank"> <em class="kc">张量流文档。</em> </a></p></div></div>    
</body>
</html>