<html>
<head>
<title>Implementing Debounce in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Javascript中实现去抖</h1>
<blockquote>原文：<a href="https://medium.com/codex/implementing-debounce-in-javascript-cf185cd2084b?source=collection_archive---------6-----------------------#2022-06-04">https://medium.com/codex/implementing-debounce-in-javascript-cf185cd2084b?source=collection_archive---------6-----------------------#2022-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="8a8b" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">软件工程</h2><div class=""/><div class=""><h2 id="23cd" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">什么是去抖，如何实现</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/e61b3044ea6e5d3ff132c29bbcbb642b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iyySjhSD7tdqG9J0YZxfdw.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">形象信用——工作</figcaption></figure><p id="ee9d" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果你的背景是移动开发，你可能已经知道什么是去抖。</p><p id="ca2e" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">无论如何，没有多少人听说过它以及它能解决什么问题，但是它非常有用，所以让我们深入研究一下。</p><p id="24e8" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">术语“<em class="ks">去抖</em>”最早起源于电子和硬件行业。</p><h1 id="4259" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">机械弹跳</h1><p id="0e8b" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">弹跳是机械按钮和开关的一种特性，当按下时会产生电噪声。这种噪声掩盖了输入信号，使系统读取错误。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lq"><img src="../Images/bda909b3a24b88cc44174f7d7af60791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9zWmigqVxVd7t6ofj2waQA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">来源— <a class="ae lr" href="https://www.pololu.com/" rel="noopener ugc nofollow" target="_blank"> Pololu机器人</a></figcaption></figure><p id="4b3c" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果你曾经使用过微控制器之类的东西，你会非常理解这个问题。</p><p id="e668" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">简单地解释一下，想象你在卧室里按下电灯开关。开关不会立即与内部接触，会有一点信号反弹。这将导致你的灯在稳定之前开/关两到三次。</p><p id="d0a4" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><a class="ae lr" href="https://www.thegeekpub.com/246471/debouncing-a-switch-in-hardware-or-software/" rel="noopener ugc nofollow" target="_blank">极客酒吧有一篇关于这方面的文章</a>。如果您对微控制器中的去抖更感兴趣，一定要去看看。</p><h1 id="3617" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">软件反弹</h1><p id="54aa" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">显而易见，反弹问题和解决方案是软件的对应部分。有些与微控制器的<em class="ks">软件方面</em>有关，因为这个问题也可以通过这种方法解决<em class="ks">。</em></p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ls"><img src="../Images/efbab82965b2942f8fe7afa961d872f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynW2oebrNowsp7GAjUwxhg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">插图由<a class="ae lr" href="https://www.freecodecamp.org/" rel="noopener ugc nofollow" target="_blank"> FreeCodeCamp </a>提供</figcaption></figure><p id="afc5" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">然而，这个故事将是关于<em class="ks"> web应用、后端和移动应用中的输入噪声，</em>以及它如何影响性能<em class="ks">。</em></p><h2 id="1a93" class="lt ku hi bd kv lu lv lw kz lx ly lz ld kf ma mb lf kj mc md lh kn me mf lj ho bi translated">输入信号反弹发生在哪里</h2><p id="572c" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">您可能遇到这种情况的最常见的地方是:</p><ul class=""><li id="b5d3" class="mg mh hi jy b jz ka kc kd kf mi kj mj kn mk kr ml mm mn mo bi translated">用户输入字段</li><li id="1259" class="mg mh hi jy b jz mp kc mq kf mr kj ms kn mt kr ml mm mn mo bi translated">按钮和开关</li><li id="fc5f" class="mg mh hi jy b jz mp kc mq kf mr kj ms kn mt kr ml mm mn mo bi translated">阅读邮件队列</li></ul><p id="31bd" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果您使用消息队列，您可能会利用<em class="ks">去抖</em>。许多消息协议和库允许您在定义的时间段内读取成批的消息，这基本上是在后台<em class="ks">去抖动</em>和聚合<em class="ks"> </em>消息，以便在单个操作中将它们提供给客户端。</p><p id="7014" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在我们手头的例子中，信号本身将由用户产生，例如在一个具有更改监听器的输入字段上。</p><p id="efce" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">诸如此类的组件可能会受到噪声或大量预期输入的影响，也可能会被最终用户滥用。</p><p id="c8d5" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">让我们考虑下面的例子:</p><pre class="jh ji jj jk fd mu mv mw mx aw my bi"><span id="7ab8" class="lt ku hi mv b fi mz na l nb nc"># HTML<br/>&lt;input onKeyUp="inputChanged()" type="text"/&gt;</span><span id="cd40" class="lt ku hi mv b fi nd na l nb nc"># JS<br/>function inputChanged() {<br/>    console.log("Input event detected.");<br/>}</span></pre><p id="b7e1" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这是当您想要监听用户输入更改时的常见情况之一。</p><p id="9d64" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><em class="ks">注意</em> <code class="du ne nf ng mv b"><em class="ks">onChange</em></code> <em class="ks">没有被使用，因为它只在</em> <code class="du ne nf ng mv b"><em class="ks">focus</em></code> <em class="ks">从输入字段移开时发出一个事件。</em></p><p id="8554" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">从这个意义上说，<code class="du ne nf ng mv b">onChange</code>正在自行缓解这个问题。然而，在您想要实时做出反应的情况下，它可能没有那么有用。</p><p id="148d" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">每当用户更改输入值时，<code class="du ne nf ng mv b">onKeyUp</code>监听器就会发出一个事件。这通常对于例如实时搜索特征是有用的。</p><p id="6183" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这里的问题是在字段<code class="du ne nf ng mv b">onKeyUp</code>中输入一些东西会在很短的时间内产生很多事件。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nh"><img src="../Images/8f5f3957bfdf79142ea46a9f6fdef053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/1*0qM3-JkwhMVHkSx1Nti_Og.gif"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">作者截屏</figcaption></figure><p id="2589" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果你正在过滤一些结果，用户界面可能会变得断断续续，你的性能将受到影响。</p><p id="edb8" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">也许您需要实现一个模糊搜索，并且搜索应该实时发生，而不需要等待用户点击提交。为了检索结果，需要发送HTTP请求，发送这么多请求显然没有好处。</p><p id="371b" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">为了进一步解释问题的本质，让我们暂时回到消息队列。例如，您可以为Kafka消费者客户端配置您想要的批量大小，以及您想要接收每个批次的时间段。</p><pre class="jh ji jj jk fd mu mv mw mx aw my bi"><span id="666e" class="lt ku hi mv b fi mz na l nb nc"># Sample pseudo consumer<br/>var consumer = kafka.client()<br/>    .batch(100)<br/>    .in(1000ms);</span><span id="e1b9" class="lt ku hi mv b fi nd na l nb nc">consumer.poll();</span></pre><p id="130b" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">上面的伪代码将配置Kafka客户端获取消息，要么每秒一次，要么一收到100个事件就获取。你明白了。</p><p id="619e" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这可能是去抖的基础，但还有更多。我们实际上并不希望每当一批事件<em class="ks">达到时间阈值</em>或<em class="ks">数量标记</em>时就消耗掉它们，但是我们希望一旦<em class="ks">完成接收</em>时就消耗掉它们。</p><p id="f813" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">本质上，对于任何给定的正在进行的流，我们都很难做出决定，因此为了缓解这个问题，我们希望在两个事件信号之间实现一个超时，如果经过了一个时间段，就会触发我们的批量读取。</p><h1 id="a213" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">解决办法</h1><p id="858e" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">如上所述，说明去抖、事件和两个接收事件信号之间的超时周期将如下所示。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ni"><img src="../Images/97eb4921895bac89bb5713613f716364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfsnGce8LCoIjO6pVACxKA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">作者插图</figcaption></figure><p id="1a39" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">对于去抖方法，我们需要一个超时或阈值时间，并且我们希望仅在超时时触发一个事件。</p><p id="adfc" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">图表显示了当定时器ie。两个事件之间经过的时间小于1000毫秒的阈值。我们只在1000毫秒过后触发一个功能。</p><p id="8bc8" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">流中的最后一个事件自然也会被使用，只是在这种情况下它自己会被使用，并且在1000毫秒后再次触发该函数。</p><p id="8aa7" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">简单地说，我们试图预测流中的最后一个事件。阈值时间应根据具体情况进行调整。如果我们想更及时地做出反应，我们应该配置一个更小的时间阈值。如果我们想确保某些逻辑只在我们确实得到“几乎最后”事件时才被触发，我们应该将它设置为一个较高的值。</p><p id="566a" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">较小的数量通常有利于面向响应用户的应用程序。当读取消息队列时，我们可能不需要立即读取事件，因此更高的阈值时间将节省我们宝贵的执行时间。</p><p id="458a" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">Javascript中有许多库，尤其是在不同的框架中。</p><p id="0fff" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">实现去抖方法的一个简单方法是使用<code class="du ne nf ng mv b">setTimeout</code>,如下面的代码片段所示:</p><pre class="jh ji jj jk fd mu mv mw mx aw my bi"><span id="67f3" class="lt ku hi mv b fi mz na l nb nc"># HTML<br/>&lt;input id="input-field" onKeyUp="inputChanged()" type="text"/&gt;</span><span id="d611" class="lt ku hi mv b fi nd na l nb nc"># JS<br/>const inputField = document.getElementById("input-field");</span><span id="9467" class="lt ku hi mv b fi nd na l nb nc">function getResult() {<br/>   console.log("Input event detected.");<br/>   console.log(inputField.value);<br/>   // Do something with the input<br/>}</span><span id="a154" class="lt ku hi mv b fi nd na l nb nc">const debounce = {<br/>   isWaiting: false,<br/>   <br/>   submit: function (func) {<br/>      if (!this.isWaiting) {<br/>        this.isWaiting = true;<br/>         <br/>         setTimeout(() =&gt; {<br/>             func.apply();<br/>             this.isWaiting = false;<br/>         }, 1000);<br/>      }<br/>   }<br/>}</span><span id="8452" class="lt ku hi mv b fi nd na l nb nc">function inputChanged() {<br/> debounce.submit(getResult);<br/>}</span></pre><p id="9e83" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">上面代码片段中的<code class="du ne nf ng mv b">debounce</code>对象将简单地允许我们<code class="du ne nf ng mv b">submit</code>任务，但是它将检测提交是否已经等待执行，如果是，简单地跳过提交另一个任务。</p><p id="7c70" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这是一个非常天真的方法，没有利用<em class="ks">阈值计时器</em>，但是它抓住了问题和可能的解决方案。</p><p id="0f5e" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">一种更复杂的方法要求我们跟踪事件之间经过的时间，因为我们希望仅在时间段<em class="ks">到期</em>时触发一个函数。</p><p id="fb36" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">普通的Javascript方法如下所示:</p><pre class="jh ji jj jk fd mu mv mw mx aw my bi"><span id="8c39" class="lt ku hi mv b fi mz na l nb nc"># HTML<br/>&lt;input id="input-field" onKeyUp="inputChanged()" type="text"/&gt;</span><span id="497a" class="lt ku hi mv b fi nd na l nb nc"># JS<br/>const inputField = document.getElementById("input-field");</span><span id="2553" class="lt ku hi mv b fi nd na l nb nc">function getResult() {<br/>   console.log("Input event detected.");<br/>   console.log(inputField.value);<br/>   // Do something with the input<br/>}</span><span id="97b0" class="lt ku hi mv b fi nd na l nb nc">const debounce = {<br/>   timerId: 0,<br/>   timeout: 1000,<br/>   <br/>   submit: function (func) {<br/>       this.cancel();<br/>       <br/>       this.timerId = setTimeout(() =&gt; {<br/>           func.apply(this);<br/>       }, this.timeout);<br/>   },<br/>   <br/>   cancel: function() {<br/>       clearTimeout(this.timerId);<br/>   }<br/>}</span><span id="3b7b" class="lt ku hi mv b fi nd na l nb nc">function inputChanged() {<br/> debounce.submit(getResult);<br/>}</span></pre><h2 id="e298" class="lt ku hi bd kv lu lv lw kz lx ly lz ld kf ma mb lf kj mc md lh kn me mf lj ho bi translated">要点</h2><p id="00f4" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">剖析上面的片段，重点是:</p><ul class=""><li id="3476" class="mg mh hi jy b jz ka kc kd kf mi kj mj kn mk kr ml mm mn mo bi translated">提交任务会设置一个带有阈值时间的计时器</li><li id="5170" class="mg mh hi jy b jz mp kc mq kf mr kj ms kn mt kr ml mm mn mo bi translated">每个随后的<em class="ks">事件</em>将取消计时器</li><li id="8af4" class="mg mh hi jy b jz mp kc mq kf mr kj ms kn mt kr ml mm mn mo bi translated">从而延长了执行时间。延迟事件的<em class="ks">读取</em></li><li id="1458" class="mg mh hi jy b jz mp kc mq kf mr kj ms kn mt kr ml mm mn mo bi translated">仅当阈值时间过去后，才执行任务</li><li id="a10f" class="mg mh hi jy b jz mp kc mq kf mr kj ms kn mt kr ml mm mn mo bi translated">即。它没有被另一个事件延长</li></ul><p id="4bdd" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">上面的代码片段复制了之前在<em class="ks">事件流</em>图中所说和说明的内容。</p><p id="a85e" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我强烈建议多看一些关于去抖的内容。网络上有许多帖子在不同的环境下更详细地解释了这个问题，并展示了不同的用例。</p><p id="d3e3" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><a class="nj nk ge" href="https://medium.com/u/47e700e59e44?source=post_page-----cf185cd2084b--------------------------------" rel="noopener" target="_blank"> Trey Huffine </a>很好地解释了这个问题，在他的<a class="ae lr" href="https://levelup.gitconnected.com/debounce-in-javascript-improve-your-applications-performance-5b01855e086" rel="noopener ugc nofollow" target="_blank"><em class="ks">Javascript Medium story</em></a>中用一种简洁的方法解决了这个问题。看看这个。</p><p id="4563" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果你是lodash的粉丝，你可能想看看<a class="ae lr" href="https://lodash.com/docs/4.17.15#debounce" rel="noopener ugc nofollow" target="_blank">他们的文档</a>，因为他们有一个<code class="du ne nf ng mv b">debounce</code>方法可以使用。</p><p id="30e7" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">RxJS显然也有一个实现，但是即使您个人没有使用它，也要确保查看文档，因为它很好地阐释了这个概念。下面的RxJS文档激发了我绘制图解的灵感——事件流。</p><ul class=""><li id="81c8" class="mg mh hi jy b jz ka kc kd kf mi kj mj kn mk kr ml mm mn mo bi translated"><a class="ae lr" href="https://rxjs.dev/api/operators/debounce" rel="noopener ugc nofollow" target="_blank">rxjs/API/操作员/去抖</a></li></ul></div><div class="ab cl nl nm gp nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="hb hc hd he hf"><p id="a056" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这个故事是关于一个没有多少人知道的概念，但是对于不同的软件工程领域、语言、平台和框架是通用的。</p><p id="5017" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如果你想知道更多关于去抖的知识，如果你有任何建议，或者如果你在故事和代码片段中发现了一个错别字，请随时写下评论！</p><p id="b3c1" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">希望你喜欢它，并且觉得读起来很有趣。如果是这样，请查看<a class="ae lr" rel="noopener" href="/@be-ja">我的个人资料，点击</a>关注并订阅我的时事通讯，收听我将要写的关于软件工程概念的新故事。</p><p id="3e4a" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">感谢您的阅读！🎉</p></div></div>    
</body>
</html>