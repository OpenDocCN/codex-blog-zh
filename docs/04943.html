<html>
<head>
<title>How to Diagnose OOMKilled Error in Kubernetes Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何诊断Kubernetes应用程序中的OOMKilled错误</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-diagnose-oomkilled-error-in-kubernetes-application-201a9966be0d?source=collection_archive---------2-----------------------#2022-01-19">https://medium.com/codex/how-to-diagnose-oomkilled-error-in-kubernetes-application-201a9966be0d?source=collection_archive---------2-----------------------#2022-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a3d2e2efc446e0edad03366f14f65f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bldc9J66MxeL723Y"/></div></div></figure><p id="0595" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://unsplash.com/photos/GCFuprAvC6A" rel="noopener ugc nofollow" target="_blank">照片</a>由<a class="ae jo" href="https://unsplash.com/@ihor_dvoretskyi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ihor Dvoretskyi </a>在Unsplash上拍摄</p><p id="b274" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> OOMKilled错误</strong>表示一个容器或箱已经被终止，因为它已经使用了比它所分配的更多的内存。首字母缩写词OOM代表“内存不足”。</p><p id="db99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> OOMKilled </strong>，俗称<a class="ae jo" href="https://komodor.com/learn/how-to-fix-oomkilled-exit-code-137/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">退出代码137 </strong> </a>，是起源于Linux的一类错误。<strong class="is hj"> OOM(内存不足管理器)</strong>是Linux系统上的一个工具，它跟踪进程的内存使用情况。如果系统即将耗尽内存，OOM黑仔将会介入并开始终止进程，试图释放内存并避免崩溃。OOM黑仔的目的是通过杀死尽可能少的进程来释放尽可能多的内存。</p><p id="5c21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kubernetes允许pods限制其容器在主机上可以使用的资源数量。一个pod可以设置一个内存限制——容器被允许使用的<strong class="is hj">内存</strong>的<strong class="is hj">最大</strong> <strong class="is hj">数量</strong>——以及一个内存请求——容器应该消耗的最小内存数量。如果容器使用的内存超过了它的内存限制，它就会以OOMKilled状态终止。如果节点上所有容器或所有单元的总内存使用量超过某个阈值，则一个或多个单元可以被终止。</p><p id="f7fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kubernetes中有两种类型的<strong class="is hj"> OOMKilled </strong> <strong class="is hj">错误</strong>。</p><ul class=""><li id="0b8d" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated"><strong class="is hj"> OOMKilled </strong>:限制超量承诺</li><li id="3414" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj"> OOMKilled </strong>:达到容器极限</li></ul><p id="ffdc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来看看每一个。</p><h1 id="1743" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">由于达到容器极限而被杀死</h1><p id="aec6" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">这是迄今为止在pod中可能发生的最基本的记忆错误。与影响节点上RAM总量的限制过量使用错误不同，如果正常达到容器限制，它只会影响一个pod。当Kubernetes发现一个pod使用的内存超过配置的限制时，该pod将被终止，并出现错误<strong class="is hj"> OOMKilled </strong> — <a class="ae jo" href="https://kubernetes.io/docs/concepts/policy/limit-range/" rel="noopener ugc nofollow" target="_blank">达到容器限制</a>。</p><p id="dcb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在大多数情况下，这会导致容器死亡，一个pod变得不健康，Kubernetes会重新启动该pod。发生这种情况时，请查看应用程序日志，了解为什么pod使用了比预期更多的内存。这可能是由于各种因素，包括流量的增加或长时间运行的Kubernetes任务占用了比平时更多的内存。</p><p id="449c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您在整个查询过程中发现程序按预期运行，但只需要额外的内存来执行，您可能希望增加请求和限制值。</p><h1 id="d44a" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">由于限额超量承诺而导致死亡</h1><p id="774a" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">当pod限制的<strong class="is hj"> </strong>总和大于节点上的可用内存时，会发生<strong class="is hj"> OOMKilled </strong> : <a class="ae jo" rel="noopener" href="/pareture/kubernetes-node-overcommitted-57ec7c3dfe9e"> <strong class="is hj">限制超量使用</strong> </a>错误。Kubernetes不会分配需要超过节点可用内存的pod。另一方面，限制可以高于请求。因此，所有限制的总和可能超过节点容量。这就是所谓的过度承诺，是一种非常常见的现象。</p><p id="a8e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际上，如果所有容器消耗的内存都比请求的多，那么节点的内存将会耗尽。释放一些内存经常会导致一些pod的死亡。</p><p id="891e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，一个具有8 GB内存的节点，Kubernetes可能运行8个容器，内存请求值为1 GB。如果这些容器的内存限制为1.5 GB，一些pod可能会使用超过最小值的内存，从而导致节点耗尽内存并强制终止一些pod。</p><h1 id="5850" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">诊断</h1><h2 id="fbc5" class="lg ke hi bd kf lh li lj kj lk ll lm kn jb ln lo kr jf lp lq kv jj lr ls kz lt bi translated">收集信息</h2><p id="996c" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">运行命令<a class="ae jo" href="https://www.tutorialspoint.com/kubernetes/kubernetes_kubectl_commands.htm" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">ku bectl</strong></a>describe pod[name]并将输出保存到文本文件中以备将来使用。</p><h2 id="5d4d" class="lg ke hi bd kf lh li lj kj lk ll lm kn jb ln lo kr jf lp lq kv jj lr ls kz lt bi translated">检查退出代码137</h2><p id="70fd" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">检查描述窗格文本文件的事件部分:</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/7cb242d9803dddc9a3efd9cffac358bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/0*p4LGwNVSKqOcwvhV"/></div></figure><p id="821d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">容器因内存不足而终止，退出代码为137。现在，回顾一下pod最近的历史事件，并尝试找出触发OOMKilled错误的原因，因为只有两个常见原因:</p><ul class=""><li id="b260" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">由于<strong class="is hj">容器</strong>和<strong class="is hj">限制</strong>，pod被终止。</li><li id="1338" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">由于<strong class="is hj">节点</strong>上的<strong class="is hj">过载</strong>，pod被终止。</li></ul><h1 id="f370" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">解决办法</h1><h2 id="79bb" class="lg ke hi bd kf lh li lj kj lk ll lm kn jb ln lo kr jf lp lq kv jj lr ls kz lt bi translated">如果Pod由于容器限制而终止</h2><p id="a945" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">检查你的应用程序是否真的需要更多的内存。如果应用程序面临增加的负载，它可能需要比原来提供的更多的内存。在这种情况下，请在pod规范中增加容器的内存限制以纠正错误。</p><p id="90b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果内存使用量意外增加，并且似乎与应用程序需求无关，则应用程序可能正在经历<a class="ae jo" href="https://en.wikipedia.org/wiki/Memory_leak" rel="noopener ugc nofollow" target="_blank">内存泄漏</a>。在这种情况下，调试应用程序并找到内存泄漏的来源。增加应用程序的内存限制会消耗更多的资源。</p><h2 id="b168" class="lg ke hi bd kf lh li lj kj lk ll lm kn jb ln lo kr jf lp lq kv jj lr ls kz lt bi translated">如果Pod由于节点上的过载而被终止</h2><p id="4d42" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">如果<strong class="is hj">pod</strong>的内存请求值小于某个<strong class="is hj">节点</strong>上的可用内存，则允许在该节点上进行调度，这可能会导致过量使用。您需要确定Kubernetes终止pod的原因，然后调整限制值和内存请求，以确保节点不会过载。</p><p id="31a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您需要不断地监控您的环境，了解pod和容器的内存行为，并检查您的设置以完全诊断和解决Kubernetes内存问题。</p><h1 id="7ace" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="db9f" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在本文中，我们仔细研究了起源于Linux的<strong class="is hj">Kubernetes</strong>T8】oom killedT10】错误。它有助于Kubernetes在调度pod时管理内存，并在资源变得稀缺时决定杀死哪些pod。记住要考虑两种类型的OOMKilled错误:达到容器限制和限制超量使用。了解这两者可以帮助您有效地进行故障排除，并减少将来遇到错误的机会。</p></div></div>    
</body>
</html>