<html>
<head>
<title>AlertDialogs in Android using Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中使用Kotlin的警报对话框</h1>
<blockquote>原文：<a href="https://medium.com/codex/optimized-androids-dialogs-management-1b899ecaedb6?source=collection_archive---------7-----------------------#2021-07-25">https://medium.com/codex/optimized-androids-dialogs-management-1b899ecaedb6?source=collection_archive---------7-----------------------#2021-07-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="82bb" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">改进您在Android项目中处理全球警报的方式</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d5435d347a2f67c0053145632e1c47fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jBPFP6Nc5ZhzDBs9QK5g4w.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">由<a class="ae jn" href="https://unsplash.com/@freegraphictoday?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">绝对视觉</a>在<a class="ae jn" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="cc53" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">介绍</h1><p id="583a" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">一旦软件项目的规模变大，保持代码的整洁就变得越来越困难，你很快就会看不到整个架构。<br/> Android开发也不例外。</p><p id="f9a9" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在做了几个项目之后，我注意到警告对话框代码散布在我所有的应用程序中，我开始复制代码来重新定义相同类型的自定义对话框。</p><p id="3eca" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">正如许多程序员已经知道的，我们工作的第一个良好实践是通过应用<strong class="ki hj">不要重复自己(DRY) </strong>原则来避免代码重复。</p><p id="2e95" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">另外，另一个问题是，通过快速点击触发对话框打开的视图，同一个对话框的多个实例出现在屏幕上。</p><p id="8072" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">我需要一种方式来集中:</p><ol class=""><li id="4a01" class="lh li hi ki b kj lc km ld kp lj kt lk kx ll lb lm ln lo lp bi translated">对话框定义</li><li id="06d2" class="lh li hi ki b kj lq km lr kp ls kt lt kx lu lb lm ln lo lp bi translated">对话框出现和消失行为</li></ol><p id="e18f" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">为了解决这两个问题，我决定定义一个对象类，并用它来定义和控制我所有的对话框。</p><p id="e881" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">以下是我的结构。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="c963" class="jo jp hi bd jq jr mc jt ju jv md jx jy io me ip ka ir mf is kc iu mg iv ke kf bi translated">对象定义和方法</h1><p id="a0da" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">首先定义一个新的Kotlin对象，姑且称之为<em class="mh"> DialogController.kt </em>。这个文件将存储你所有的对话框实例和定义。</p><p id="b358" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这个想法是为每个对话框保留一个不同的变量和一个专用的函数来实例化和显示这个对话框。</p><p id="4f77" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在我的例子中，我将指导您创建一个警告对话框和一个确认对话框。当然，你可以把这个逻辑应用到任何类型的对话中。</p><p id="592d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">首先定义两个变量，一个用于警报，一个用于确认。</p><pre class="iy iz ja jb fd mi mj mk ml aw mm bi"><span id="3894" class="mn jp hi mj b fi mo mp l mq mr">object DialogController <br/>{<br/>    private lateinit var dialogAlert: AlertDialog<br/>    private lateinit var dialogConfirmation: AlertDialog<br/>}</span></pre><p id="048b" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">正如你所看到的，我将两个变量都定义为<code class="du ms mt mu mj b">lateinit</code>，这样它们只有在你调用相关函数后才会被初始化。<br/>这很有用，因为<code class="du ms mt mu mj b">MaterialAlertDialogBuiler</code>构造函数需要一个<code class="du ms mt mu mj b">Context</code>类型的参数。<br/>该参数因活动而异，因此之前初始化这两个变量是没有用的。</p><p id="94a2" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">下一步是定义处理对话框外观的函数。<br/>这里的想法是只有在没有其他对话框被初始化和显示的情况下才显示一个对话框。</p><pre class="iy iz ja jb fd mi mj mk ml aw mm bi"><span id="afa0" class="mn jp hi mj b fi mo mp l mq mr">private fun cantShowDialog(): Boolean = <br/>    this::dialogAlert.isInitialized &amp;&amp; dialogAlert.isShowing ||<br/>    this::dialogConfirmation.isInitialized &amp;&amp; dialogConfirmation.isShowing</span></pre><p id="95c5" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">只有当屏幕上当前没有显示其他对话框时，该函数才会返回<code class="du ms mt mu mj b">true</code>。</p><p id="b86a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">最后，让我们从警报对话框开始创建初始化函数。</p><pre class="iy iz ja jb fd mi mj mk ml aw mm bi"><span id="e41d" class="mn jp hi mj b fi mo mp l mq mr">fun showDialogAlert(context: Context, title: String, msg: String) <br/>{<br/>    if (cantShowDialog()) { return }</span><span id="269d" class="mn jp hi mj b fi mv mp l mq mr">    dialogAlert = MaterialAlertDialogBuilder(context)<br/>        .setTitle(title)<br/>        .setMessage(msg)<br/>        .setPositiveButton("Close", null)<br/>        .setCancelable(false)<br/>        .create()<br/>        .apply {<br/>            setCanceledOnTouchOutside(false)<br/>            show()<br/>        }<br/>}</span></pre><p id="4b6b" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">正如您所看到的，该函数做的第一件事是检查是否有可能显示一个新的对话框，如果有，它继续定义相关的变量并显示所需的标题和消息。</p><p id="d2a1" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">用同样的逻辑，定义处理确认对话框的函数。</p><pre class="iy iz ja jb fd mi mj mk ml aw mm bi"><span id="23c9" class="mn jp hi mj b fi mo mp l mq mr">fun showDialogConfirmation(<br/>    context: Context, <br/>    title: String, <br/>    msg: String, <br/>    callback: () -&gt; Unit<br/>) {<br/>    if (cantShowDialog()) { return }</span><span id="8199" class="mn jp hi mj b fi mv mp l mq mr">    dialogConfirmation = MaterialAlertDialogBuilder(context)<br/>        .setTitle(title)<br/>        .setMessage(msg)<br/>        .setNegativeButton("Cancel", null)<br/>        .setPositiveButton("Confirm", callback)<br/>        .setCancelable(false)<br/>        .create()<br/>        .apply {<br/>            setCanceledOnTouchOutside(false)<br/>            show()<br/>        }<br/>}</span></pre><p id="89ab" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这里的主要区别是使用回调函数作为参数。<br/>这将在正面按钮点击事件时触发。</p><p id="0aed" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">现在，您可以通过整个应用程序轻松访问对话框，只需调用:</p><pre class="iy iz ja jb fd mi mj mk ml aw mm bi"><span id="1807" class="mn jp hi mj b fi mo mp l mq mr">DialogController.showDialogAlert(this, "Alert", "This is an alert")</span><span id="bc1e" class="mn jp hi mj b fi mv mp l mq mr">DialogController.showDialogConfirmation(this, "Confirmation", "Are you sure you want to proceed?") {<br/>    // Code executed once confirmed...<br/>}</span></pre><h1 id="66b9" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">最终代码</h1><p id="7b93" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">这是刚刚定义的类的完整代码。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mw mx l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">DialogController.kt</figcaption></figure></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="cbe8" class="jo jp hi bd jq jr mc jt ju jv md jx jy io me ip ka ir mf is kc iu mg iv ke kf bi translated">结论</h1><p id="f574" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">这个简单的技巧让我简化了我的整体代码，并完全控制我的警报。</p><p id="6334" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这个例子只展示了几个简单的对话框，你可以定制你的<em class="mh"> DialogController </em>类来定义你需要的更复杂的实例。</p><p id="3580" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">编码快乐！</p></div></div>    
</body>
</html>