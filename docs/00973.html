<html>
<head>
<title>Random maze from Entombed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自埋葬的随机迷宫</h1>
<blockquote>原文：<a href="https://medium.com/codex/random-maze-from-entombed-8bb3b34e8f9b?source=collection_archive---------6-----------------------#2021-03-28">https://medium.com/codex/random-maze-from-entombed-8bb3b34e8f9b?source=collection_archive---------6-----------------------#2021-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="43dc" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><div class=""><h2 id="90b6" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">从Atari 2600到Commodore 64的神秘算法</h2></div><p id="362b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">由于一个随机的Twitter列表，我发现了一篇有趣的论文，并且我已经意识到一个名为<em class="kc"> Archeogaming </em>的研究领域的存在，该领域使用来自考古学、历史学和软件工程的方法和手段来剖析和分析古代视频游戏的设计和实现。</p><p id="472b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这篇论文是<a class="ae kd" href="https://doi.org/10.22152/programming-journal.org/2019/3/4" rel="noopener ugc nofollow" target="_blank"> <em class="kc">埋葬:一个雅达利2600游戏</em> </a>的考古检查，并且是第一次，成功的(在我看来)尝试正式化研究领域。</p><p id="3b92" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这篇论文真的很有趣，读起来也很有趣，正如标题所示，它提供了对Atari 2600嵌入的视频游戏的实现的详细分析:我不会在这里详细介绍，因为这篇论文很好地解释了你需要知道的一切，但为了清楚起见，你只需要知道游戏是关于一个角色，由玩家驱动，必须跑过一个随机生成的迷宫。</p><p id="b54c" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">强调随机这个词是因为在每个新游戏中拥有不同的迷宫将极大地有利于游戏的<em class="kc">可玩性，即适合或值得玩不止一次的事实。</em></p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="kj kk l"/></div><figcaption class="kl km et er es kn ko bd b be z dx translated">Atari 2600的简单游戏机制演示</figcaption></figure><h2 id="ff71" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jp la lb lc jt ld le lf jx lg lh li ho bi translated">迷宫的新路线的产生</h2><p id="e239" class="pw-post-body-paragraph jg jh hi ji b jj lj is jl jm lk iv jo jp ll jr js jt lm jv jw jx ln jz ka kb hb bi translated">视频中清楚地显示了游戏的工作原理:玩家必须保持向下移动，同时迷宫向他滚动。迷宫由以下部分组成</p><p id="a1ec" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">该算法提供了一种简单的方法来生成新的迷宫线，只要它向上滚动。迷宫有20个街区宽，迷宫的每一行都有两个最左边和最右边的街区被一堵墙占据。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lo"><img src="../Images/394a1b96263257f95e8666da6f2514d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77yDIl8YgONnFCMsPNxPQg.png"/></div></div><figcaption class="kl km et er es kn ko bd b be z dx translated">操场的图像(图像取自原始文件)</figcaption></figure><p id="e634" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">每一个新行都是上一行的函数，它必须填充该行剩余的16个块。另一个简化也为生成的迷宫增加了某种美感，即只生成了最左边的8个块，而其余的8个块都是相同的块，但是是镜像的:在下图中，您可以看到算法的示意图。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lv"><img src="../Images/d5a34d84a922e154929dbb9658b6706e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7zc_fSPnphBhIdc5aGYzDQ.png"/></div></div><figcaption class="kl km et er es kn ko bd b be z dx translated">新线条的生成(我手写)</figcaption></figure><h2 id="3d5d" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jp la lb lc jt ld le lf jx lg lh li ho bi translated">喝醉的深夜节目</h2><p id="56e2" class="pw-post-body-paragraph jg jh hi ji b jj lj is jl jm lk iv jo jp ll jr js jt lm jv jw jx ln jz ka kb hb bi translated">每个新块的生成都考虑了该块的上下文。在下图中，您可以看到这是如何发生的:为了生成位置<em class="kc"> X </em>的块，需要考虑位置<em class="kc"> a、b、c、d、e </em>的块的内容。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es lw"><img src="../Images/ec9210182935f7d69e06278a013054e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*kw0jJDFDG5CtE6blSJBtxQ.png"/></div><figcaption class="kl km et er es kn ko bd b be z dx translated">生成块X的上下文是块a、b、c、d、e的内容(来自原始纸张的图像)</figcaption></figure><p id="6966" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">该算法使用一个表来决定块<em class="kc"> X </em>中的内容。对于块的每个组合，该表都有一个条目。在下图中，您可以看到表格的前12行:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es lx"><img src="../Images/8cbfa13559930a7a75f7a9b1d9225129.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*9i0wJmHH3vhhxRJC0c5XIw.png"/></div><figcaption class="kl km et er es kn ko bd b be z dx translated">用于迷宫生成的神秘表格映射的摘录(原始论文中的完整表格)</figcaption></figure><p id="c2dc" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">值得注意的是，该表在论文中被称为<em class="kc">神秘表</em>，因为没有清晰的模式描述行是如何定义的，最初的程序员也无法回忆起他实际上是如何做的，因为<em class="kc">“他喝醉了，神志不清，他在昏迷之前用汇编语言写了一夜，但现在无论如何也记不起算法是如何工作的了”</em></p><p id="efb9" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">根据位置<em class="kc"> a、b、c、d、</em>和<em class="kc"> e </em>中单元格的值，表格的每一行包含0、1或随机值:0表示<em class="kc"> x </em>单元格将包含空白空间，玩家的角色可以在其中行走；1将在<em class="kc"> x </em>单元格中生成一个墙块，random将随机生成一个块或空间。</p><h2 id="a24a" class="kp kq hi bd kr ks kt ku kv kw kx ky kz jp la lb lc jt ld le lf jx lg lh li ho bi translated">移植到Commodore 64 Basic</h2><p id="54c4" class="pw-post-body-paragraph jg jh hi ji b jj lj is jl jm lk iv jo jp ll jr js jt lm jv jw jx ln jz ka kb hb bi translated">在21世纪移植到Commodore 64 Basic v2是一项有趣的工作。在核心处，有一个神秘的表，它被呈现为一个从C64 Basic的<code class="du ly lz ma mb b">DATA</code>语句加载的数组。C64版本的另一个细节是，它使用标准随机数生成器，而不是伪随机数生成器的实现，如论文中所述。</p><p id="4954" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">接下来你会发现纯C64 Basic的源代码:</p><pre class="ke kf kg kh fd mc mb md me aw mf bi"><span id="6bee" class="kp kq hi mb b fi mg mh l mi mj">10 DIM Z(31):FOR I=0 TO 31:READZ(I):NEXTI:?"{CLEAR}":S=1986:K=102<br/>20 FOR I=0TO1:POKE 1984+I,K:POKE2003-I,K:NEXT I<br/>30 FOR X=S TO 1993<br/>40 A=-(PEEK(X-2)&gt;32)*16:IF X=S THEN A=16<br/>50 B=-(PEEK(X-1)&gt;32)*8:IF X=S THEN B=0<br/>60 C=-(PEEK(X-41)&gt;32)*4:IF X=S THEN C=INT(RND(1)+.5)*4<br/>70 D=-(PEEK(X-40)&gt;32)*2<br/>80 E=-(PEEK(X-39)&gt;32)<br/>90 V=Z(A+B+C+D+E):IF V=2 THEN V=(INT(RND(1)+.5))<br/>100 IF V=1 THEN POKEX,K:POKE3987-X,K<br/>110 NEXT X:SYS 59626:GOTO 20<br/>120 DATA 1,1,1,2,0,0,2,2,1,1,1,1,2,0,0,0<br/>130 DATA 1,1,1,2,0,0,0,0,2,0,1,2,2,0,0,0</span></pre><p id="5bdf" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">第10行—用从第120–130行读取的数据初始化包含神秘表的数组<code class="du ly lz ma mb b">Z</code>。几个变量的初始化:<code class="du ly lz ma mb b">S</code>是算法生成的第一个位置(屏幕左下单元格右侧两个单元格)</p><p id="45b6" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">第20行—在新生成的行的最左侧和最右侧绘制两个单元格条纹，该行始终是屏幕上的最低行</p><p id="680e" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">第30行—此处开始正确的绘图循环，其主体在第110行结束。通过查看C64屏幕存储器，在每一行上计算出<em class="kc"> a、b、c、d、</em>和<em class="kc"> e </em>的值。这五个值组合在一个位串中，其值作为一个整数，用于索引以选择神秘表中的适当行，保存在数组<code class="du ly lz ma mb b">Z()</code>中。</p><p id="6515" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">第40至80行—计算字母<em class="kc"> a、b、c、d、</em>和<em class="kc"> e </em>。请注意，第40、50和60行执行了一项特殊检查:如原始论文中所述，迷宫新线的最左侧单元的计算方式不同，因为a、b和c将与始终存在的两个单元条带(在第20行生成)相一致。在这种特殊情况下，这些值是a=1，b=0，c等于0到1之间的一个随机数。</p><p id="e740" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">第90行—通过添加<em class="kc"> a、b、c、d、</em>和<em class="kc"> e来恢复适当的行<code class="du ly lz ma mb b">Z</code>。如果数组<code class="du ly lz ma mb b">Z()</code>的值为2，则单元格可以随机为空或满。</em></p><p id="f755" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">第100行——如果在前一行中，我们从表中的查找中得到1或者生成了1，则绘制一个单元格:在这种情况下，地址为<code class="du ly lz ma mb b">X</code>的单元格用代码保存在<code class="du ly lz ma mb b">K</code>中的字符戳。</p><p id="cdbb" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">第110行—结束循环。<code class="du ly lz ma mb b">SYS</code>调用将只是向上滚动屏幕，增加一个空行。<code class="du ly lz ma mb b">GOTO</code>将重新开始绘制迷宫新线条的循环。</p><p id="dae7" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">结果如下图所示，你的跑步(希望)会有所不同。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mk"><img src="../Images/eb0c7cffdb9da6c6ef6b9a5941d27c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NjfJVKs6VjcBInYwmuBtfg.png"/></div></div><figcaption class="kl km et er es kn ko bd b be z dx translated">在仿真的C64上运行得到的迷宫的执行</figcaption></figure><h1 id="67a1" class="ml kq hi bd kr mm mn mo kv mp mq mr kz ix ms iy lc ja mt jb lf jd mu je li mv bi translated">结论</h1><p id="959f" class="pw-post-body-paragraph jg jh hi ji b jj lj is jl jm lk iv jo jp ll jr js jt lm jv jw jx ln jz ka kb hb bi translated">从这里开始，有几个提示:为了有一个紧凑的版本，并且可能参加<a class="ae kd" href="https://gkanold.wixsite.com/homeputerium/rules2021" rel="noopener ugc nofollow" target="_blank"> BASIC TENLINER竞赛</a>，可以压缩代码。下面的代码就是一个例子(注意:在功能上不完全等同于前面的代码),它只运行了5行代码:</p><pre class="ke kf kg kh fd mc mb md me aw mf bi"><span id="1355" class="kp kq hi mb b fi mg mh l mi mj">10dIZ(31):fOI=0TO31:rEZ(I):nE:?"{CLEAR}":S=1986:K=102:<br/>20fOI=0TO1:pO1984+I,K:pO2003-I,K:nE:fOX=STO1993<br/>40V=Z(-(pE(X-2)&gt;32)*16-(pE(X-1)&gt;32)*8-(pE(X-41)&gt;32)*4-(pE(X-40)&gt;32)*2-(pE(X-39)&gt;32)):IFV=2tHV=INT(rN(1)+.5)<br/>50IF V=1 THEN POKEX,K:POKE3987-X,K<br/>60NEXT:SYS59626:gO20:dA1,1,1,2,,,2,2,1,1,1,1,2,,,,1,1,1,2,,,,,2,,1,2,2,,,</span></pre><p id="4a4b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">上面的代码仍然可以被压缩，甚至更多，为添加游戏逻辑留下了空间，这是一个功能完整的嵌入式克隆。</p></div></div>    
</body>
</html>