<html>
<head>
<title>SANS Top 25 Software Errors (Part 2 of 25): CWE-79 Improper Neutralization of Input During Web Page Generation (Cross-site Scripting)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SANS Top 25软件错误(第2部分，共25部分):CWE-79在网页生成(跨站点脚本)期间不正确地消除输入</h1>
<blockquote>原文：<a href="https://medium.com/codex/sans-top-25-software-errors-part-2-of-25-cwe-79-improper-neutralization-of-input-during-web-page-65917586e2a6?source=collection_archive---------8-----------------------#2022-09-27">https://medium.com/codex/sans-top-25-software-errors-part-2-of-25-cwe-79-improper-neutralization-of-input-during-web-page-65917586e2a6?source=collection_archive---------8-----------------------#2022-09-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/eb9d04bfec46d6188384ed2740b8520e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vdjzfhv7H6u7l6yS"/></div></div></figure><h1 id="5884" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="c9e2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">攻击者使用跨站点脚本(XSS)将恶意代码注入受害者的web浏览器。通过在合法网页或应用程序中包含恶意代码，攻击者试图在受害者的web浏览器上执行恶意脚本。一旦受害者访问恶意网页或web应用程序，攻击就会发生。脚本通过网页或web应用程序传送到浏览器。允许评论的论坛、留言板和网页通常被用作跨站点脚本攻击的载体。</p><p id="2814" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果网页或web应用程序的输出包含未组织的用户输入，则容易受到XSS的影响。受害者的浏览器必须解析这个用户输入。除了JavaScript、ActiveX、Flash和CSS之外，XSS攻击在这些应用程序中也是可能的。然而，由于JavaScript在大多数浏览体验中的重要性，最常见的XSS攻击发生在JavaScript中。</p><h1 id="1df3" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">对用户的影响</h1><p id="53d2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">如果攻击者能够利用该网站或易受攻击的web应用程序上的XSS漏洞来执行任意JavaScript，那么该易受攻击的网站或易受攻击的web应用程序及其用户的安全性就会受到损害。像XSS这样的安全漏洞不是用户的错。如果它影响了你的用户，它也会影响你。攻击者还可能使用跨站点脚本来破坏网站，而不是针对用户。通过注入脚本，他们可以改变网站的内容，甚至将用户流量重定向到恶意网站。</p><h1 id="0c3f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">跨站点脚本的类型</h1><h2 id="7e18" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">1.存储的XSS</h2><p id="c83c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">将恶意内容(称为有效负载)注入目标应用程序(称为存储的XSS)是最具破坏性的一种XSS。通常，JavaScript代码被用作有效负载。如果不执行输入验证，目标应用程序会将该恶意代码存储在数据库中(持久化)。</p><p id="eef2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">例如，攻击者可能将恶意脚本插入用户输入字段，如博客或论坛帖子上的评论。作为HTML代码的一部分(就像合法的注释一样)，当受影响的网页在受害者的浏览器中被查看时，攻击有效载荷被提供给受害者的浏览器。一旦恶意脚本在受害者的浏览器中执行，就会被执行。</p><h2 id="4178" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">2.反映了XSS</h2><p id="3a38" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当恶意脚本从网站反射到受害者的浏览器上时，它们被称为反射XSS攻击，也称为非持续性攻击。通过单击该链接，恶意脚本将在具有允许执行恶意脚本的漏洞的网站上执行。当传入的请求没有得到充分的净化时，web应用程序就容易受到攻击，这就有可能操纵其功能并激活恶意脚本。</p><p id="ed05" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">犯罪者通常会在电子邮件或第三方网站(如评论区或社交媒体)中嵌入恶意链接进行分发。当用户点击锚文本中嵌入的链接时，就会暴露在XSS攻击之下，这会导致XSS请求被发送到被利用的网站。</p><h2 id="ff0b" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">3.基于DOM的XSS</h2><p id="f9c4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">基于DOM的XSS是XSS的高级形式。如果用户向DOM提供数据，web应用程序的客户端脚本可以访问DOM(文档对象模型)。数据随后由web应用程序读取，并从DOM输出到浏览器。由于不正确的数据处理，攻击者可以注入一个有效载荷，该载荷将被合并到DOM中，并在被读回时执行。</p><p id="17b4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">基于DOM的XSS攻击中的恶意负载很少发送到服务器，这使得Web应用程序防火墙(WAF)更难检测，安全工程师更难分析服务器日志来识别攻击。文档。URL、location.hash和document.referrer是最常操作的DOM对象。</p><h1 id="bc9e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">XSS的测试</h1><p id="247c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">XSS漏洞有多种类型，其中90%以上可以使用web漏洞扫描器发现。通过确定XSS的上下文，您可以选择合适的有效负载来利用它。然而，还有许多其他类型的多姆XSS可用。通常，对反射XSS的测试包括向应用程序的所有入口点提交一些独特的输入(如简短的字母数字字符串)，识别HTTP响应中返回输入的每个位置，并单独测试所有这些位置，以查看适当制作的输入是否可以执行任意JavaScript。</p><p id="bd74" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">基于DOM的XSS也可以手动测试，方法是在URL参数中放置一些文本，在DOM中搜索这些文本，然后测试每个位置以确定它是否可以被利用。如果您想在不使用URL的输入或接收(如document.cookie)或不使用HTML的接收(如setTimeout)中找到基于DOM的漏洞，那么没有什么可以替代审查JavaScript代码。通过静态和动态JavaScript分析，web漏洞扫描程序可以可靠地自动检测基于DOM的漏洞。</p><h1 id="6826" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">预防</h1><p id="884b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">跨站点脚本(XSS)很难防止。您可以根据漏洞的类型、发生的环境和编程框架来防止XSS。为了保证web应用程序的安全，您应该遵循一些通用的策略原则。</p><h2 id="05ab" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">步骤1:通过培训和维护来保持意识</h2><p id="bb3f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">XSS漏洞应该让每个在web应用程序上工作的人都知道，以确保它的安全。开发人员、QA人员、开发人员和系统管理员应该接受适当的安全培训。</p><h2 id="89f4" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">第二步:用户的输入不应该被信任</h2><p id="399c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">经过身份验证的输入和/或内部输入应与公共输入同等对待。如果使用任何用户输入来创建HTML输出，请使用一对一的方法。</p><h2 id="e74d" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">步骤3:建议使用转义/编码</h2><p id="36bd" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">可以使用HTML转义、JavaScript转义、CSS转义、URL转义等。，这取决于用户输入的使用位置。避免编写自己的转义库。</p><h2 id="0f46" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">步骤4: HTML应该被净化</h2><p id="172f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">您不能对包含HTML的用户输入进行转义/编码，因为这会破坏有效的标签。要在这种情况下解析和清理HTML，请选择一个可信且经过验证的库。您可以将HtmlSanitizer用于。NET或SanitizeHelper for Ruby on Rails，这取决于您的开发语言。</p><h2 id="bc3b" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">步骤5:应该设置HttpOnly标志</h2><p id="820b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为cookies设置HttpOnly标志，以减轻可能的XSS漏洞的影响。通过这样做，JavaScript客户端将无法访问此类cookies。</p><h2 id="a150" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">步骤6:应该对内容使用安全策略</h2><p id="0d16" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">您还可以使用内容安全策略(CSP)来减轻XSS漏洞的后果。CSP是HTTP响应头，它根据请求源声明可以加载哪些动态资源。</p><h2 id="f1e1" class="kr ir hi bd is ks kt ku iw kv kw kx ja jz ky kz je kd la lb ji kh lc ld jm le bi translated">步骤7:维护定期扫描计划</h2><p id="f61e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">web漏洞扫描器应该定期在您的web应用程序上运行。如果你使用Jenkins，它应该作为插件安装，这样每个版本都会被自动扫描。如果您使用外部库、模块和软件，XSS漏洞也可能由您的开发人员引入。</p></div></div>    
</body>
</html>