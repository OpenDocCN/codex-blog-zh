<html>
<head>
<title>Stack in Python: How, why, and where?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的堆栈:如何、为什么和在哪里？</h1>
<blockquote>原文：<a href="https://medium.com/codex/stack-in-python-df657235d015?source=collection_archive---------8-----------------------#2021-07-13">https://medium.com/codex/stack-in-python-df657235d015?source=collection_archive---------8-----------------------#2021-07-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a5e120869b6e3ae059b9b267a5e4316e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cwQIyGU5IAj_qE_oI99VmA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">信用:<a class="ae iu" href="https://unsplash.com/@eklektikum" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/@eklektikum</a></figcaption></figure><p id="1539" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">堆栈是一种线性数据结构，以后进先出的方式存储数据。Web浏览器的后退按钮是一个堆栈应用程序。</p><p id="b99c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在堆栈中执行两个主要操作，即PUSH和POP。PUSH操作将元素/值添加到堆栈中，而POP操作从堆栈中移除或删除元素/值。</p><h1 id="9090" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">堆栈中的一些基本操作</h1><ol class=""><li id="718d" class="kr ks hi ix b iy kt jc ku jg kv jk kw jo kx js ky kz la lb bi translated"><strong class="ix hj">推送</strong> —将一个元素或值添加到堆栈中。时间复杂度为O(1)</li><li id="b080" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj">弹出</strong> —从堆栈中移除最顶端的元素或值。时间复杂度为O(1)</li><li id="3264" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj"> TOP </strong> —获取堆栈的顶部元素或值，而不移除它。它也被称为PEEK。时间复杂度为O(1)</li><li id="f0ed" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj">清空</strong> —检查堆栈是否为空。时间复杂度为O(1)</li><li id="3eb4" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj">满</strong> —检查堆栈是否已满。时间复杂度为O(1)</li><li id="ea36" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj">尺寸</strong> —检查堆叠的尺寸。时间复杂度为O(1)</li></ol><h1 id="a4a5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">堆栈的实现</h1><p id="02ac" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">在Python中实现堆栈有多种选择。在这里，我们讨论使用Python及其模块的堆栈实现。Python中的堆栈可以通过以下方式实现:</p><ul class=""><li id="d368" class="kr ks hi ix b iy iz jc jd jg lk jk ll jo lm js ln kz la lb bi translated">目录</li><li id="95c3" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ln kz la lb bi translated">collections.deque</li><li id="dfcb" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ln kz la lb bi translated">排队。LifoQueue</li></ul><h1 id="c217" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用列表实现</h1><p id="5e08" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">Python list可以作为栈使用。List <strong class="ix hj"> append() </strong>用于在堆栈中添加元素的方法，类似于堆栈推送操作。List <strong class="ix hj"> pop() </strong>用于从堆栈中移除元素的方法，类似于stack <strong class="ix hj"> pop() </strong>操作。Python列表有性能问题。列表<strong class="ix hj">推送()</strong>，<strong class="ix hj">弹出()</strong>操作变得越来越慢。如果列表增长并超出内存块，python就会分配一些内存。这就是Python列表逐渐变慢的原因。时间复杂度为O(n)。</p><p id="996c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来理解下面的例子</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="73b8" class="lx ju hi lt b fi ly lz l ma mb"># Define empty stack<br/>stack = []</span><span id="9332" class="lx ju hi lt b fi mc lz l ma mb"># Add element to stack<br/>stack.append(1)<br/>stack.append(2)<br/>stack.append(3)<br/>stack.append(4)<br/>stack.append(5)</span><span id="edf0" class="lx ju hi lt b fi mc lz l ma mb">print("Display stack after PUSH operation")<br/>print(stack)</span><span id="a460" class="lx ju hi lt b fi mc lz l ma mb">print("Remove element from stack")<br/>print(stack.pop())<br/>print(stack.pop())<br/>print(stack.pop())<br/>print(stack.pop())<br/>print(stack.pop())</span><span id="b4f2" class="lx ju hi lt b fi mc lz l ma mb">print("Display stack after POP operation")<br/>print(stack)</span></pre><p id="dea3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="3525" class="lx ju hi lt b fi ly lz l ma mb">Display stack after PUSH operation<br/>[1, 2, 3, 4, 5]<br/>Remove element from stack<br/>5<br/>4<br/>3<br/>2<br/>1<br/>Display stack after POP operation<br/>[]</span></pre><p id="b27a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的代码中，我们定义了一个空列表。然后在堆栈中追加一些元素，类似于stack <strong class="ix hj"> PUSH() </strong>操作。我们还使用<strong class="ix hj"> pop() </strong>方法移除了元素。方法从列表中返回最后一个元素。</p><h1 id="093c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用collection.deque实现</h1><p id="c842" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">Python的<strong class="ix hj">集合</strong>模块提供了<strong class="ix hj">的</strong>类。通过使用<strong class="ix hj">德克</strong>，我们可以创建一个堆栈。<strong class="ix hj">队列</strong>读作<strong class="ix hj">卡牌</strong>，意为<strong class="ix hj">双端队列</strong>。<strong class="ix hj">dequee</strong>比Python <strong class="ix hj"> list </strong>好，因为它的追加和弹出操作比Python <strong class="ix hj"> list </strong>快。时间复杂度为O(1)。</p><p id="a7d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来理解下面的例子</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="4efb" class="lx ju hi lt b fi ly lz l ma mb"># Define empty stack<br/>from collections import deque</span><span id="14c1" class="lx ju hi lt b fi mc lz l ma mb">stack = deque()</span><span id="5bef" class="lx ju hi lt b fi mc lz l ma mb"># Add element to stack<br/>stack.append(1)<br/>stack.append(2)<br/>stack.append(3)<br/>stack.append(4)<br/>stack.append(5)</span><span id="958d" class="lx ju hi lt b fi mc lz l ma mb">print("Display stack after PUSH operation")<br/>print(stack)</span><span id="cd2e" class="lx ju hi lt b fi mc lz l ma mb">print("Remove element from stack")<br/>print(stack.pop())<br/>print(stack.pop())<br/>print(stack.pop())<br/>print(stack.pop())<br/>print(stack.pop())</span><span id="db95" class="lx ju hi lt b fi mc lz l ma mb">print("Display stack after POP operation")<br/>print(stack)</span></pre><p id="3f82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="c872" class="lx ju hi lt b fi ly lz l ma mb">Display stack after PUSH operation<br/>[1, 2, 3, 4, 5]<br/>Remove element from stack<br/>5<br/>4<br/>3<br/>2<br/>1<br/>Display stack after POP operation<br/>[]</span></pre><h1 id="c38c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用LifoQueue实现</h1><p id="809d" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">Python <strong class="ix hj">队列</strong>模块有<strong class="ix hj"> LifoQue </strong>，和栈一样。它有<strong class="ix hj"> put() </strong>方法将元素添加到堆栈中，有<strong class="ix hj"> put() </strong>方法将元素从堆栈中移除。</p><h1 id="1864" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">LifoQueue中的一些基本操作</h1><ol class=""><li id="80e5" class="kr ks hi ix b iy kt jc ku jg kv jk kw jo kx js ky kz la lb bi translated"><strong class="ix hj"> put() </strong> —将元素添加到堆栈中。如果队列已满，它会一直等到有空间可用。</li><li id="7d9c" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj"> put_nowait() </strong> —将元素添加到堆栈中。仅当空闲槽立即可用时，才将项目排入队列。否则，引发完整异常。</li><li id="32c9" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj"> qsize() </strong> —返回队列的大概大小(不可靠！)</li><li id="5a47" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj"> empty() </strong> —如果队列为空，则返回True，否则返回False(不可靠！)</li><li id="7bc0" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj"> maxsize </strong> —用于设置队列的最大大小。如果maxsize是&lt; = 0，那么队列大小是无限的。</li><li id="4d40" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj"> full() </strong> —如果队列已满，则返回True，否则返回False(不可靠！)</li><li id="a5c7" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj"> get() </strong> —从队列中移除并返回一个项目。</li><li id="3180" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj"> get_nowait() </strong> —从队列中移除并返回一个项目，而不阻塞。只有当一个项目立即可用时，才获取该项目。否则引发空异常。</li></ol><p id="7140" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来理解下面的例子</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="ee75" class="lx ju hi lt b fi ly lz l ma mb"># Define empty stack<br/>from queue import LifoQueue</span><span id="566c" class="lx ju hi lt b fi mc lz l ma mb">stack = LifoQueue(maxsize=5)</span><span id="581a" class="lx ju hi lt b fi mc lz l ma mb">print(f"Size of stack: {stack.qsize()}")<br/># Add element to stack<br/>stack.put(1)<br/>stack.put(2)<br/>stack.put(3)<br/>stack.put(4)<br/>stack.put(5)</span><span id="1c4d" class="lx ju hi lt b fi mc lz l ma mb">print(f"Stack is Full: {stack.full()}")<br/>print(f"Size of Stack: {stack.qsize()}")</span><span id="3703" class="lx ju hi lt b fi mc lz l ma mb">print("Remove element from stack")<br/>print(stack.get())<br/>print(stack.get())<br/>print(stack.get())<br/>print(stack.get())<br/>print(stack.get())</span><span id="0f09" class="lx ju hi lt b fi mc lz l ma mb">print(f"Stack is Empty: {stack.empty()}")</span></pre><p id="506b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">输出:</strong></p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="384c" class="lx ju hi lt b fi ly lz l ma mb">Size of stack: 0<br/>Stack is Full: True<br/>Size of Stack: 5<br/>Remove element from stack<br/>5<br/>4<br/>3<br/>2<br/>1<br/>Stack is Empty: True</span></pre><p id="244d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最初，堆栈大小为0。然后，我们使用<strong class="ix hj"> put() </strong>方法将5个元素推入堆栈。然后，我们检查堆栈是否已满。然后，我们检查堆栈大小。之后，我们使用<strong class="ix hj"> get() </strong>方法从堆栈中移除元素。最后，我们检查堆栈是否为空。</p><h1 id="b458" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Python堆栈和线程</h1><p id="f1c9" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">我们可以在多线程程序中使用Python堆栈。在多线程编程中使用<strong class="ix hj">列表</strong>可能很危险，因为它不是线程安全的。</p><p id="ebd6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> deque </strong>有点复杂，因为它的<strong class="ix hj"> append() </strong>和<strong class="ix hj"> pop() </strong>方法是原子的，这意味着它们不会被其他线程中断。</p><p id="9bd9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，用treading构建一个Python栈的程序，<strong class="ix hj"> LifoQueue </strong>比较好。它使用<strong class="ix hj"> put() </strong>和<strong class="ix hj"> get() </strong>来添加和移除堆栈元素。</p><h1 id="2c11" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">堆栈的应用</h1><p id="dced" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">虽然stack是一种实现起来很简单的数据结构，但是它非常强大。堆栈最常见的用途是:</p><ol class=""><li id="cfcf" class="kr ks hi ix b iy iz jc jd jg lk jk ll jo lm js ky kz la lb bi translated"><strong class="ix hj">把一个单词倒过来</strong>——把所有的字母堆成一堆，弹出来。由于堆栈的后进先出顺序，您将得到逆序的字母。</li><li id="ac0c" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj">在编译器中</strong> —编译器通过将表达式转换为前缀或后缀形式，使用堆栈来计算类似<code class="du md me mf lt b">2 + 4 / 5 * (7 - 9)</code>的表达式的值。</li><li id="c4fe" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj">在浏览器中</strong> —浏览器中的后退按钮将您之前访问过的所有URL保存在一个堆栈中。每次你访问一个新的页面，它都会被添加到堆栈的顶部。当您按下“后退”按钮时，当前URL将从堆栈中删除，并访问以前的URL。</li><li id="9e7b" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj">函数调用和返回过程</strong> —当我们从另一个函数调用一个函数时，那个函数调用语句可能不是第一个语句。在调用函数之后，我们也必须从函数区回到我们离开控制的地方。所以我们想继续我们的任务，而不是重新开始。为此，我们将程序计数器的地址存储到堆栈中，然后转到函数体来执行它。执行完成后，它从堆栈中弹出地址，并将其分配给程序计数器，以再次恢复任务。</li><li id="4085" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj">回溯过程</strong> —回溯是算法设计技术之一。为了这个目的，我们深入某种方式，如果这种方式没有效率，我们就回到先前的状态，进入其他路径。为了从当前状态返回，我们需要存储以前的状态。为此，我们需要一个堆栈。回溯的一些例子是寻找骑士巡游问题或N皇后问题的解决方案等。</li><li id="ca82" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated"><strong class="ix hj">内存管理</strong> —内存的分配发生在连续的内存块中。我们称之为堆栈内存分配，因为分配发生在函数调用堆栈中。编译器知道要分配的内存大小。当一个函数被调用时，它的变量获得堆栈上分配的内存。当函数调用完成时，变量的内存被释放。所有这些都是在编译器中一些预定义例程的帮助下发生的。用户不必担心内存分配和堆栈变量的释放。</li><li id="e016" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">表达式转换——将一种形式的表达式转换成另一种形式是栈的重要应用之一。</li></ol><ul class=""><li id="380b" class="kr ks hi ix b iy iz jc jd jg lk jk ll jo lm js ln kz la lb bi translated">前缀中缀</li><li id="063b" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ln kz la lb bi translated">后缀中缀</li><li id="070d" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ln kz la lb bi translated">中缀前缀</li><li id="1777" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ln kz la lb bi translated">后缀的前缀</li><li id="c0fa" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ln kz la lb bi translated">后缀到中缀</li><li id="d2b4" class="kr ks hi ix b iy lc jc ld jg le jk lf jo lg js ln kz la lb bi translated">后缀到中缀</li></ul><p id="faba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">8.括号匹配—给定一个表达式，您必须找出括号是否正确匹配。例如，考虑表达式<code class="du md me mf lt b">( a + b ) * ( c + d</code>。在上面的表达式中，括号的开始和结束被正确地给出，因此它被认为是正确匹配的括号表达式。然而，表达式<code class="du md me mf lt b">(a + b * [c + d )</code>不是有效的表达式，因为括号给得不正确。</p><p id="541b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">9.用于许多算法，如汉诺塔，树遍历，股票跨度问题，直方图问题。</p><p id="9235" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">10.在像拓扑排序和强连通分量这样的图形算法中</p><h1 id="e64f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="d7a7" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">我们已经提到了用Python实现堆栈的三种方法。以上方法各有利弊。</p><p id="f199" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用堆栈和线程，你应该使用LifoQueue，但是要确保它弹出和推送元素的性能。但是如果你没有使用线程，使用一个队列。</p><p id="037f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们也可以使用这个列表来实现堆栈，但是这个列表可能会有潜在的内存重新分配问题。list和dequee在接口中是相同的，但是dequee没有内存分配问题。</p></div></div>    
</body>
</html>