<html>
<head>
<title>Resist using an Interface like this</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抵制使用这样的界面</h1>
<blockquote>原文：<a href="https://medium.com/codex/resist-using-an-interface-like-this-c27e30c4871d?source=collection_archive---------6-----------------------#2022-07-05">https://medium.com/codex/resist-using-an-interface-like-this-c27e30c4871d?source=collection_archive---------6-----------------------#2022-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0a1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接口是面向对象编程语言中最突出的特征之一。它们展示了抽象和多态的本质。它们允许实现行为灵活性和运行时多态性。它们是许多设计模式的基础，包括但不限于策略和状态设计模式。</p><p id="95d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然接口几乎无处不在，但我们往往会过度使用它们，从而影响应用程序的可维护性。下面列出了一些应该避免的与接口相关的设计决策。</p><h1 id="3a74" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">常数库</h1><p id="2dcf" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">接口的主要目标是以预定义方法签名的形式强制执行一个契约，它的所有实现都必须遵循这个契约。这个契约产生了一个清晰的、定义良好的集成机制。虽然在接口中具有与实现相关的某些常数以及方法是有意义的；没有方法的接口不能实现它的主要目标。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/e5123e3d21240fffcaec3eec270f7f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fUD1l8P3doicMbWRXhZXw.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">常数的接口</figcaption></figure><p id="3d18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应该避免使用一个接口作为一个常量库，因为这样会很难理解该接口在应用程序中的作用。像enum这样的结构最适合这样的需求。</p><h1 id="1251" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">上帝界面</h1><p id="4ccc" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">一个接口不仅仅是任何其他的构造，它是一种能力。当一个类实现一个接口时，它就能够执行在那个特定接口中列出或声明的行为。</p><blockquote class="kw kx ky"><p id="3880" class="if ig kz ih b ii ij ik il im in io ip la ir is it lb iv iw ix lc iz ja jb jc hb bi translated">“关注点分离”的原则是每个方法只负责一件事，同样的原则也适用于接口和类。在同样的上下文中，接口应该被开发成向一个类提供单一的能力。</p></blockquote><p id="6971" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们查看一个类的实现细节，这个类实现了一个足够通用的接口，那么它必须提供该接口中所有列出的方法的定义，即使这些方法中的一些是不需要的。这就带来了关于泛型接口可能增加的附加值的问题。上帝接口给了一个实现类太多的能力，这是一个坏主意，因为所有这些能力都不是我们想要的，但是我们必须处理它们。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es ld"><img src="../Images/feb038f7e0e7f772021086bd28475fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_a8_SPOGJr4L06pUCxt5A.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">具有不同能力的界面</figcaption></figure><blockquote class="kw kx ky"><p id="e96d" class="if ig kz ih b ii ij ik il im in io ip la ir is it lb iv iw ix lc iz ja jb jc hb bi translated">拥有与特定用例相关的精益接口总是一个好的实践。</p></blockquote><h1 id="52db" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">次级接口</h1><p id="bf7a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">功能太少的界面也不是一个好主意。只提供一半功能并迫使实现依赖另一个补充接口才能真正发挥功能的接口是应该避免的。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es le"><img src="../Images/adb20137748899e6826bbda584109088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*zpB2_zuJoam_bCUpRlEguA.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">看似相关联的接口相互补充</figcaption></figure><blockquote class="kw kx ky"><p id="827d" class="if ig kz ih b ii ij ik il im in io ip la ir is it lb iv iw ix lc iz ja jb jc hb bi translated">一个接口必须为一个类提供所有必要的行为来实现某种能力，而不需要依赖第二个接口。</p></blockquote><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lf"><img src="../Images/c07954d95bbafe1efe62218d0fee12ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*jD2Y7gHRw97U3DVWhDtFCg.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">自给自足的界面</figcaption></figure><h1 id="6374" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">到处都是接口</h1><p id="25df" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">与抽象对话允许修改底层实现或用另一个替换它而不被发现。当应用程序的两个部分通过接口而不是具体实现连接时，它们都不知道另一部分的底层架构。这使得使用多态性和更新或改变构造的行为变得非常容易，而不会在编译期间破坏任何东西。</p><p id="3b74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然有争议的是拥有接口使得集成更容易，但是为每个类拥有接口并不是一个好主意。如果对接口的需求背后没有具体的原因，那么它通常只是一些不必要的样板代码，例如，如果你正在编写一个其他人会使用的库，那么将接口作为交互点是有意义的，但是为rest控制器或实用程序类编写接口就没有多大意义了。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><blockquote class="ln"><p id="7437" class="lo lp hi bd lq lr ls lt lu lv lw jc dx translated">这是我最近写的一本关于设计模式的书的链接。希望你会觉得有用。</p></blockquote><div class="ly lz ma mb mc md"><a href="https://www.amazon.in/Software-Design-Patterns-Java-Developers/dp/9391392474" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">面向Java开发人员的软件设计模式:专家主导的构建可重用软件的方法和…</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">面向Java开发人员的软件设计模式讨论了软件设计的基础，以及公认的…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">www .亚马逊. in</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr kq md"/></div></div></a></div></div></div>    
</body>
</html>