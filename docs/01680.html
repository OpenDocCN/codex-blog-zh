<html>
<head>
<title>Product Flavors — Simple Sample</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">产品风味—简单样品</h1>
<blockquote>原文：<a href="https://medium.com/codex/product-flavors-simple-sample-11541374a433?source=collection_archive---------9-----------------------#2021-05-20">https://medium.com/codex/product-flavors-simple-sample-11541374a433?source=collection_archive---------9-----------------------#2021-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1e39" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这个故事用一个简单的示例应用程序解释了Android产品风格。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/53c2752786ce36abfc234ab687f24ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*_VzyjT63GL6b8pF2rAc7AA.jpeg"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">产品风味</figcaption></figure><h2 id="bffc" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated"><strong class="ak">用例:</strong></h2><p id="56fa" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">我有一个需求，我需要从后端使用翻新/任何其他网络API获取数据，并填充我的用户界面。</p><h2 id="2a73" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated"><strong class="ak">挑战:</strong></h2><p id="016e" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">后端还没有准备好，我将无法从后端获取数据，并填充我的用户界面。</p><p id="1603" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">虽然我的开发已经准备好了，但是我不能测试我的用户界面。</p><h2 id="9380" class="jj jk hi bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated"><strong class="ak">解决方案之一:</strong></h2><p id="634b" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ju kq kr ks jy kt ku kv kc kw kx ky kz hb bi translated">与其等到后端开发完成，不如在没有任何网络交互的情况下用mock JSON测试应用程序。</p><p id="1847" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">这有助于测试用户界面流，也有助于修复遇到的缺陷。</p><p id="7c87" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">一旦后端准备就绪，我们需要用真正的API代码替换模拟JSON代码。</p><p id="85b6" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated"><strong class="kj hj">上述方法的问题:</strong></p><p id="e757" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">上述方法的问题是，我们需要用API交互代码替换包含模拟JSON的代码。此外，如果一段时间后，如果后端关闭，API不再工作，我们需要修改与API交互相关的代码，并用模拟JSON代码替换它，以继续进行应用程序开发。</p><p id="890b" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated"><strong class="kj hj">解决方案1:维护两个代码库</strong></p><p id="88e9" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">维护两个代码库，一个用于模拟JSON，另一个用于API交互。</p><p id="3f1f" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">这种方法的问题是维护困难。如果UI层有一些变化，我们需要修改两个非常困难的代码库。</p><p id="2148" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated"><strong class="kj hj">解决方案2:产品风味</strong></p><p id="a1a8" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">Android产品风格用于从单一代码库创建不同的应用程序版本。App版本可以是免费的，也可以是付费的。它们可以有不同的主题和文本。他们可以使用不同的环境或类似于我们需求的API。</p><p id="dbf8" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">简单来说，产品风格是你的应用程序的变体。当你想创建应用程序的多个版本时，这是非常有用的。这意味着你可以使用一个代码库生成不同版本或变体的应用程序。</p><p id="4655" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">产品口味是Android Studio的Gradle插件的一个强大功能，用于创建定制版本的产品。它们构成了我们称之为<strong class="kj hj">构建变体</strong>的一部分。</p><p id="0890" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">构建变体是Gradle使用一组<a class="ae lf" href="https://developer.android.com/studio/build/build-variants?authuser=1#sourceset-build" rel="noopener ugc nofollow" target="_blank">特定的规则</a>来组合在您的构建类型和产品风格中配置的设置、代码和资源的结果。虽然您不直接配置构建变体，但是您可以配置构建类型和形成它们的产品风格。</p><p id="cc6e" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated"><strong class="kj hj">为用例配置产品:</strong></p><p id="d26c" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">我们需要为上述用例配置产品风格，这意味着我们创建两个构建变体，一个从real API获取数据，另一个从mock JSON获取数据。</p><p id="2a17" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">将使用的架构是MVVM，其中viewmodel与存储库交互，存储库又与real API或mock JSON交互以将数据返回给ViewModel，ViewModel将被活动/片段观察以填充UI。</p><p id="b1ef" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">因此，我们需要在每个产品风格中都有一个具有相同名称、相同包(我使用的是相同的包)的存储库类。当选择一个特定的构建变体时，将从该特定风格中挑选存储库，并相应地获取数据。</p><p id="2b8b" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated"><strong class="kj hj">实现产品风味的步骤:</strong></p><p id="0339" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">步骤1:将下面的代码块添加到android块的应用程序级Gradle中</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="c170" class="jj jk hi lh b fi ll lm l ln lo">flavorDimensions "fetchdata"<br/>productFlavors <strong class="lh hj">{<br/>    </strong>real <strong class="lh hj">{<br/>        </strong>dimension "fetchdata"<br/>        applicationIdSuffix ".real"<br/>    <strong class="lh hj">}<br/>    </strong>mock <strong class="lh hj">{<br/>        </strong>dimension "fetchdata"<br/>        applicationIdSuffix ".mock"<br/>    <strong class="lh hj">}<br/>}</strong></span></pre><p id="2244" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">上面的代码块包含两种产品风格<strong class="kj hj">真实</strong>和<strong class="kj hj">模拟</strong>，<strong class="kj hj">真实</strong>从后端获取数据，而<strong class="kj hj">模拟</strong>从assets文件夹中的模拟JSON文件获取数据。</p><p id="8190" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">所有风味必须属于一个命名的风味维度，它是一组产品风味。您必须将所有口味分配给一个口味维度；否则，您将得到构建错误。如果一个给定的模块只指定了一个风格维度，Android Gradle插件会自动将该模块的所有风格分配给这个维度。</p><p id="03bf" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">应用程序后缀:它指定了每种口味的包名。假设在默认配置下，应用程序的applicationId为“com.android.productflavorsdemo ”,则为每个产品风格添加一个后缀，如下所示:</p><p id="0417" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">当选择“真正的”产品风味时，我们会看到包为com . Android . productflavorsdemo . real，如果选择了<strong class="kj hj"> mock </strong>风味，则会看到“com . Android . productflavorsdemo . mock”</p><p id="a9b5" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">步骤2:完成步骤1后，执行梯度同步:</p><p id="1faa" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">在Android Studio中:Build -&gt;选择Build Variant，我们应该能看到如下图:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lp"><img src="../Images/ee66d46e03eb0287d2d859f3f1f7afd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*-lGwSr0Yl0-JT8mnbDGxEA.png"/></div></figure><p id="683e" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">每个产品风格生成2个构建变体，一个用于调试，另一个用于发布构建类型。所以总共有4个版本。</p><p id="8aeb" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">第三步:源代码结构。</p><p id="a9a1" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">在src目录下创建2个目录/文件夹，如下所示，这样我们可以看到2个名为<strong class="kj hj"> real </strong>和<strong class="kj hj"> mock </strong>以及<strong class="kj hj"> main </strong>的新目录，如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lq"><img src="../Images/963db0a625ab3fb5de6e15dbf9c467e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/format:webp/1*M67ecu6EdZh_IjdrOjSIRA.png"/></div></figure><p id="a60d" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">第三步:主<strong class="kj hj">和</strong>的包装结构如下。注意“Repository”文件夹是空的，因为我们使用产品风格从基于所选构建变体的不同来源获取数据。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lr"><img src="../Images/49f65614090ee28dd5ee9ada49f95952.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*psLLbhxAgkQ2RzATRGLn6Q.png"/></div></figure><p id="cec2" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">步骤4:模拟产品风味的结构:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ls"><img src="../Images/c26937d509b96bb76a3ca07fa309e47b.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*dq1sLTGznNsRUdxGQDpQoQ.png"/></div></figure><p id="0930" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">assets文件夹包含模拟JSON，utils文件夹包含从JSON读取数据的JSONHelper。</p><p id="694b" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">PlaceHolderRepository类从JSonHelper获取数据。请在下面找到存储库类的代码示例:</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="97a5" class="jj jk hi lh b fi ll lm l ln lo">class PlaceHolderRepository(private  val apiServiceAPI: PlaceHolderServiceAPI) {<br/>     init {<br/>        <strong class="lh hj"> <em class="lt">println</em>("From Mock ")  //Debug stmt that is displayed when mock flavor repository is executed.</strong><br/>     }<br/>     <br/>     suspend fun fetchPosts(): Response&lt;PlaceHolderPostsDataModel&gt; =  JSONHelper.fetchParsedJSONForPosts()<br/>     suspend fun fetchComments(): Response&lt;PlaceHolderCommentsModel&gt; = JSONHelper.fetchParsedJSONForComments()<br/>}</span></pre><p id="28db" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">步骤4:真实产品风味的结构:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lu"><img src="../Images/00d6ef84b46d94c6883b42e8dc858a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*3j5ZophcPAQgtHrIg-qMCg.png"/></div></figure><p id="f5dd" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">在上面的截图中可以看到，真正的产品只包含了Repository类。</p><p id="d768" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">源代码如下所示，它从实际服务中获取数据:</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="d5ca" class="jj jk hi lh b fi ll lm l ln lo">class PlaceHolderRepository(private  val apiServiceAPI: PlaceHolderServiceAPI){<br/>    init {<br/>        <em class="lt">println</em>("From Real ")<br/>    }<br/>    fun  displayInfo() = "From Real"<br/>    suspend fun fetchPosts(): Response&lt;PlaceHolderPostsDataModel&gt; = <strong class="lh hj">apiServiceAPI.fetchPlaceHolderPosts()</strong><br/>    suspend fun fetchComments(): Response&lt;PlaceHolderCommentsModel&gt; = <strong class="lh hj">apiServiceAPI.fetchPlaceHolderComments()</strong><br/>}<br/>//Fetches data from backend using  Retrofit library</span></pre><p id="b48c" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">输出:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/4f759af9e6ab1322b888b0337d453270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4j0TmsCb1SGhe1SooNwvTQ.png"/></div></div></figure><p id="18ab" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">当选择了特定的构建变体时，会相应地获取数据。当在Repository类的init块中执行log语句时选择build variant时，可以检查logcat是否从mock或real接收数据？</p><p id="b7d1" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated">注意:同样，如果我们希望构建变体从prod server/syst server或white labeling获取数据，该应用程序的付费/免费版本会创建不同的产品风格，并将特定于风格的代码移动到相应的产品风格目录中。</p><p id="664e" class="pw-post-body-paragraph kh ki hi kj b kk la ij km kn lb im kp ju lc kr ks jy ld ku kv kc le kx ky kz hb bi translated"><strong class="kj hj">上述示例的来源- &gt;可从Github获得:</strong></p><div class="ma mb ez fb mc md"><a href="https://github.com/chandragithub2014/ProductFlavorsDemo" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">chandragithub 2014/ProductFlavorsDemo</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">产品风味简单样品。通过创建帐户为chandragithub 2014/ProductFlavorsDemo开发做出贡献…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">github.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr jd md"/></div></div></a></div></div></div>    
</body>
</html>