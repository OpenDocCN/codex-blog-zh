<html>
<head>
<title>Horizontally scaling up a Kafka cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">横向扩展Kafka集群</h1>
<blockquote>原文：<a href="https://medium.com/codex/horizontally-scaling-up-a-kafka-cluster-9492d3943560?source=collection_archive---------7-----------------------#2021-09-11">https://medium.com/codex/horizontally-scaling-up-a-kafka-cluster-9492d3943560?source=collection_archive---------7-----------------------#2021-09-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a7f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在Gojek的数据工程团队工作，我的工作包括管理大量的Kafka集群，以及其他种类的东西。这篇博客的灵感来自于我们的一个Kafka集群最近的一次中断，导致了消费应用程序的降级。作为一个度假村，我们必须横向扩展Kafka集群。这篇博客将让您了解Kafka集群的水平扩展，重点关注分区重新分配。</p><p id="4f92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于集群上的高负载，我们在少数代理上面临高CPU。我们可以选择简单地通过用强大的机器替换它们来增加每个代理的计算能力，即垂直扩展。垂直扩展Kafka集群意味着用更高容量的节点替换现有的代理节点，同时保留相同的代理。</p><p id="f16f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是当你这样做的时候会有一些挑战。例如，它涉及对代理配置的仔细重新考虑，以便最佳地使用新的计算能力。向群集过度调配计算和存储资源可能会给企业带来巨大的成本。我们不想花太多精力根据新的机器规格重新调整我们的代理配置，以便在一个关键的生产支持问题上节省一些时间。所以我们决定横向扩展Kafka集群。</p><p id="c491" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的Kafka代理通常是标准的Google计算引擎实例。代理配置是在可重用的IaC模块中定义的，因此许多团队可以从这些经过深思熟虑的配置中受益。您所需要做的就是使用IaC工具提供您的代理。在数据工程团队中，我们大量使用Terraform进行IaC供应。</p><h1 id="9aa4" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">过程</h1><p id="a658" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">水平扩展Kafka集群包括以下粗略步骤:</p><ol class=""><li id="3837" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">创建调配存储、网络和计算资源的新机器</li><li id="953b" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">使用您选择的配置和供应的资源启动代理</li><li id="200e" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">在集群中重新分配分区，以便新的代理分担负载，从而提高集群的整体性能</li></ol><p id="52e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您没有创建新机器并为其配置必要软件和配置的标准方法时，第1步和第2步可能具有挑战性、耗时、易出错且棘手。数据工程团队付出了大量努力，在任何部署环境中实现这些标准，无论是容器还是虚拟机。它给我们带来了指数级的好处，节省了大量时间，避免了配置偏差和人为错误。所以在这里，唯一需要解决的事情是分区的重新分配。</p><p id="69a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在向上扩展之前，集群有6个代理和大约1600个主题。正如你可能知道的，Kafka主题被进一步分割成分区以实现负载平衡。代理存储这些分区。代理按照复制配置复制分区。如果你对复习感兴趣，我在这里写了这些概念<a class="ae kv" href="https://abhisheksah.xyz/what-makes-kafka-awesome/" rel="noopener ugc nofollow" target="_blank">。当您添加新的代理时，您还需要手动重新安排集群中的分区，以便新的代理可以在所有代理之间平衡负载。</a></p><p id="efad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于一个主题的每个分区，一个代理被选为该分区的领导者，一些代理参与复制该分区。因此，例如:对于复制因子为3的主题T，分区Pi分布在作为领导者的代理1和作为跟随者的代理2和3之间。当您对此主题运行重新分配时，领导者和追随者将被修改。</p><p id="3cd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们来看一个详细的例子。下图显示了一个主题<code class="du kw kx ky kz b">test-topic</code>，有12个分区和一个跨9个代理的存储计划。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es la"><img src="../Images/023ac3447938566a35c960f161a74008.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/0*XpEz1o3les5QcFl_.png"/></div></figure><p id="f92e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ku">运行分区重新分配后:</em></p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es la"><img src="../Images/bbceebbc7fbb1e67909d8f48bdec2bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/0*01gpc6iJgFTYsi1R.png"/></div></figure><p id="b480" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，Kafka控制器节点针对不同的代理重新调整了分区存储。最初，Kafka控制器节点将分区0存储在代理3、4和5上，其中第4个作为领导者。重新分配后，它存储在1、5和9上，第5个代理作为领导者。</p><p id="dba8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当添加新的代理时，分区重新分配将确保主题分区在代理之间平衡，包括我们作为扩展的一部分添加的代理。我们需要在所有主题上这样做，以便在新添加的代理之间实现最佳负载平衡。</p><h1 id="ff6d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">执行</h1><p id="6099" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">现在，让我们快速看一下如何着手进行重新分配。</p><p id="2768" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">标准Kafka安装具有运行重新分配所需的脚本。可以查到是<code class="du kw kx ky kz b">bin/kafka-reassign-partitions.sh</code>。</p><p id="3ae2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重新分配是一个3步流程:</p><ol class=""><li id="8093" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">首先，我们将希望负载平衡的主题列表放在一个JSON文件中。</li></ol><pre class="lb lc ld le fd li kz lj lk aw ll bi"><span id="caea" class="lm je hi kz b fi ln lo l lp lq">{ "topics" : [ { "topic" : "test-topic" } ] , "version" : 1 }</span></pre><p id="c0ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.我们告诉卡夫卡集群为我们生成一个计划。它会将当前分区副本分配和建议的分区重新分配配置记录到控制台</p><pre class="lb lc ld le fd li kz lj lk aw ll bi"><span id="aa7d" class="lm je hi kz b fi ln lo l lp lq">bin/kafka-reassign-partitions.sh --bootstrap-server "my-kafka.example.com" --broker-list "1,2,3,4,5,6,7,8,9" --topics-to-move-json-file "/root/topics.json" --zookeeper "my-zookeper.example.com" --generate</span></pre><p id="2699" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将建议的分区重新分配配置放在一个JSON文件中。</p><p id="86b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.我们根据提议的计划执行任务。</p><pre class="lb lc ld le fd li kz lj lk aw ll bi"><span id="84c1" class="lm je hi kz b fi ln lo l lp lq">bin/kafka-reassign-partitions.sh --bootstrap-server "my-kafka.example.com" --reassignment-json-file "/root/plan.json" --zookeeper "my-zookeper.example.com" --execute</span></pre><p id="e277" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">执行时间取决于主题的大小，并且是异步发生的。您可以通过验证来查询该执行的状态。</p><pre class="lb lc ld le fd li kz lj lk aw ll bi"><span id="774b" class="lm je hi kz b fi ln lo l lp lq">bin/kafka-reassign-partitions.sh --bootstrap-server "my-kafka.example.com" --reassignment-json-file "/root/plan.json" --zookeeper "my-zookeper.example.com" --verify</span></pre><h1 id="9c2f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">后续步骤</h1><p id="838a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">对于拥有数千个主题的大型集群来说，手动重新分配分区<em class="ku">非常耗时。下一步，我们希望开发自动化功能，在最少干预的情况下进行分区重新分配。</em></p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><p id="c0b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ku">原载于</em><a class="ae kv" href="https://abhisheksah.xyz/kafka-scaling/" rel="noopener ugc nofollow" target="_blank"><em class="ku">https://abhisheksah . XYZ</em></a><em class="ku">。</em></p></div></div>    
</body>
</html>