<html>
<head>
<title>Spring Boot + SNS + SQS + LocalStack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot +社交网络+ SQS +本地堆栈</h1>
<blockquote>原文：<a href="https://medium.com/codex/spring-boot-sns-sqs-localstack-8e58a4add4b1?source=collection_archive---------3-----------------------#2021-07-24">https://medium.com/codex/spring-boot-sns-sqs-localstack-8e58a4add4b1?source=collection_archive---------3-----------------------#2021-07-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8162" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://turkdogan.medium.com/spring-boot-sns-localstack-619b9b75f2ac" rel="noopener">之前的</a>帖子中，我们建立了一个Spring Boot项目，并实现了几个亚马逊简单通知服务(SNS)任务。在本帖中，我们将继续集成亚马逊简单队列服务(SQS)。首先，我们将开发一个客户端来连接亚马逊SQS。然后，我们将使用这个客户端创建队列。最后一步，我们将订阅Amazon SNS，将特定消息重定向到相应的队列。</p><p id="b582" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:你可以从<a class="ae jd" href="https://github.com/turkdogan/spring-boot-guide/tree/main/spring-boot-sns-sqs-localstack" rel="noopener ugc nofollow" target="_blank">这里</a>下载代码作为Kotlin+Gradle项目</p><h1 id="413b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">运行LocalStack</h1><p id="0629" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们需要在docker-compose文件中添加Amazon SNS和SQS。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="27fa" class="kq jf hi km b fi kr ks l kt ku">@Configuration<br/>class AWSSQSConfig {</span><span id="7471" class="kq jf hi km b fi kv ks l kt ku">  @Bean(destroyMethod = "shutdown")<br/>  fun amazonSQS(): AmazonSQSAsync {<br/>    return AmazonSQSAsyncClient.asyncBuilder()<br/>         .withEndpointConfiguration(AwsClientBuilder.EndpointConfiguration(<br/>                    "http://localhost:4566", "us-east-1"))<br/>            .withCredentials(AWSStaticCredentialsProvider(<br/>                    BasicAWSCredentials("foo", "bar")))<br/>            .build()<br/>  }</span></pre><p id="9811" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们启动LocalStack服务。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2d3c" class="kq jf hi km b fi kr ks l kt ku">docker-compose up -d</span></pre><p id="0bb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从现在开始，我们可以通过使用LocalStack来测试我们的服务。</p><h1 id="5c28" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">SQS客户</h1><p id="7591" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们需要亚马逊提供的SQS图书馆。我们可以连接到亚马逊SQS和执行SQS相关的操作。让我们创建一个Spring SQS客户端组件。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="5ccf" class="kq jf hi km b fi kr ks l kt ku">@Configuration<br/>class AWSSNSConfig {</span><span id="791e" class="kq jf hi km b fi kv ks l kt ku">    @Bean(destroyMethod = "shutdown")<br/>    fun amazonSNS(): AmazonSNS {<br/>        return AmazonSNSClient.builder()<br/>                .withEndpointConfiguration(AwsClientBuilder.EndpointConfiguration(<br/>                        "http://localhost:4566", "us-east-1"))<br/>                .withCredentials(AWSStaticCredentialsProvider(<br/>                        BasicAWSCredentials("foo", "bar")))<br/>                .build()<br/>    }<br/>}</span></pre><p id="f809" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">LocalStack使用4566端口与所有AWS服务进行通信。我们不需要提供任何真实的凭证来与LocalStack通信。</p><h1 id="2e62" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">常见的SQS场景</h1><p id="eac1" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">让我们在Spring Boot写几个SQS测试:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="5ce6" class="kq jf hi km b fi kr ks l kt ku">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)<br/>@TestInstance(TestInstance.Lifecycle.PER_CLASS)<br/>@TestMethodOrder(MethodOrderer.OrderAnnotation::class)<br/>class TestSQS() {</span><span id="475e" class="kq jf hi km b fi kv ks l kt ku">    private val queue = UUID.randomUUID().toString()</span><span id="e9a2" class="kq jf hi km b fi kv ks l kt ku">    @Autowired<br/>    private lateinit var amazonSQS: AmazonSQSAsync</span><span id="ebb6" class="kq jf hi km b fi kv ks l kt ku">    private lateinit var queueUrl: String</span><span id="365c" class="kq jf hi km b fi kv ks l kt ku">    private lateinit var message: Message</span><span id="e3d1" class="kq jf hi km b fi kv ks l kt ku">    @Test<br/>    @Order(1)<br/>    fun testCreateQueue() {<br/>        val result = amazonSQS.createQueue(queue)<br/>        queueUrl = result.queueUrl<br/>        Assertions.assertEquals(200, result.sdkHttpMetadata.httpStatusCode)<br/>    }</span><span id="b2dc" class="kq jf hi km b fi kv ks l kt ku">    @Test<br/>    @Order(1)<br/>    fun testCreateFifoQueue() {<br/>        val request = CreateQueueRequest()<br/>        request.queueName = "$queue.fifo"<br/>        request.addAttributesEntry("FifoQueue", "true")<br/>        val result = amazonSQS.createQueue(request)<br/>        Assertions.assertEquals(200, result.sdkHttpMetadata.httpStatusCode)<br/>    }</span><span id="5c1f" class="kq jf hi km b fi kv ks l kt ku">    @Test<br/>    @Order(2)<br/>    fun testListQueues() {<br/>        val result = amazonSQS.listQueues()<br/>        Assertions.assertEquals(200, result.sdkHttpMetadata.httpStatusCode)<br/>        Assertions.assertTrue(result.queueUrls.isNotEmpty())<br/>        Assertions.assertTrue(result.queueUrls.contains(queueUrl))<br/>    }</span><span id="70bd" class="kq jf hi km b fi kv ks l kt ku">    @Test<br/>    @Order(3)<br/>    fun testSendMessage() {<br/>        val request = SendMessageRequest()<br/>        request.messageBody = "This is SQS message"<br/>        request.queueUrl = queueUrl<br/>        val result = amazonSQS.sendMessage(request)<br/>        val messageId = result.messageId<br/>        Assertions.assertNotNull(messageId)<br/>        val receiveMessageResult = amazonSQS.receiveMessage(queueUrl)<br/>        message = receiveMessageResult.messages.first()<br/>        Assertions.assertEquals(200, result.sdkHttpMetadata.httpStatusCode)<br/>        Assertions.assertEquals(request.messageBody, message.body)<br/>        Assertions.assertEquals(messageId, message.messageId)<br/>    }</span><span id="74f2" class="kq jf hi km b fi kv ks l kt ku">    @Test<br/>    @Order(4)<br/>    fun testDeleteMessage() {<br/>        val request = DeleteMessageRequest()<br/>        request.queueUrl = queueUrl<br/>        request.receiptHandle = message.receiptHandle<br/>        val result = amazonSQS.deleteMessage(request)<br/>        val receiveMessageResult = amazonSQS.receiveMessage(queueUrl)<br/>        Assertions.assertEquals(200, result.sdkHttpMetadata.httpStatusCode)<br/>        Assertions.assertTrue(receiveMessageResult.messages.isNullOrEmpty())<br/>    }</span><span id="358c" class="kq jf hi km b fi kv ks l kt ku">    @Test<br/>    @Order(5)<br/>    fun testDeleteQueue() {<br/>        val result = amazonSQS.deleteQueue(queueUrl)<br/>        Assertions.assertEquals(200, result.sdkHttpMetadata.httpStatusCode)<br/>    }<br/>}</span></pre><p id="f9d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们按照特定的顺序运行测试。在第一个测试中，我们创建了一个SQS队列。在第二个测试中，我们检索在亚马逊SQS中创建的队列。我们应该会看到在第一个测试中创建的队列。然后，我们将消息发送到队列，并从队列中读取该消息。在最后两个测试场景中，我们删除了队列消息和队列。</p><h1 id="1cdd" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">SQS和社交网站的整合</h1><p id="3d16" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在这一部分，我们将整合SNS和SQS。每当我们发送SNS消息时，订阅的队列应该会收到该消息。整个测试文件如下所示:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="080e" class="kq jf hi km b fi kr ks l kt ku">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)<br/>@TestInstance(TestInstance.Lifecycle.PER_CLASS)<br/>@TestMethodOrder(MethodOrderer.OrderAnnotation::class)<br/>class TestSQSIntegration {</span><span id="3885" class="kq jf hi km b fi kv ks l kt ku">    private val topic = "topic"</span><span id="ca8e" class="kq jf hi km b fi kv ks l kt ku">    private val queue1 = UUID.randomUUID().toString()</span><span id="734f" class="kq jf hi km b fi kv ks l kt ku">    private val queue2 = UUID.randomUUID().toString()</span><span id="c40b" class="kq jf hi km b fi kv ks l kt ku">    @Autowired<br/>    private lateinit var amazonSNS: AmazonSNS</span><span id="e11c" class="kq jf hi km b fi kv ks l kt ku">    @Autowired<br/>    private lateinit var amazonSQS: AmazonSQSAsync</span><span id="6ed8" class="kq jf hi km b fi kv ks l kt ku">    private lateinit var topicArn : String</span><span id="80c5" class="kq jf hi km b fi kv ks l kt ku">    private lateinit var queueUrl1: String<br/>    private lateinit var queueUrl2: String</span><span id="ff17" class="kq jf hi km b fi kv ks l kt ku">    @Test<br/>    @Order(1)<br/>    fun testCreateTopic() {<br/>        val createTopic = amazonSNS.createTopic(topic)<br/>        topicArn = createTopic.topicArn<br/>        Assertions.assertEquals(200, createTopic.sdkHttpMetadata.httpStatusCode)<br/>    }</span><span id="6f1a" class="kq jf hi km b fi kv ks l kt ku">    @Test<br/>    @Order(2)<br/>    fun testCreateQueues() {<br/>        var result = amazonSQS.createQueue(queue1)<br/>        queueUrl1 = result.queueUrl<br/>        Assertions.assertEquals(200, result.sdkHttpMetadata.httpStatusCode)</span><span id="4758" class="kq jf hi km b fi kv ks l kt ku">        result = amazonSQS.createQueue(queue2)<br/>        queueUrl2 = result.queueUrl<br/>        Assertions.assertEquals(200, result.sdkHttpMetadata.httpStatusCode)<br/>    }</span><span id="6bea" class="kq jf hi km b fi kv ks l kt ku">    @Test<br/>    @Order(3)<br/>    fun testSubscriptions() {<br/>        // first queue<br/>        var subscribeQueue = Topics.subscribeQueue(amazonSNS, amazonSQS, topicArn, queueUrl1)<br/>        Assertions.assertTrue(subscribeQueue.contains(topic))</span><span id="1586" class="kq jf hi km b fi kv ks l kt ku">        // second queue<br/>        subscribeQueue = Topics.subscribeQueue(amazonSNS, amazonSQS, topicArn, queueUrl2)<br/>        Assertions.assertTrue(subscribeQueue.contains(topic))<br/>    }</span><span id="edcd" class="kq jf hi km b fi kv ks l kt ku">    @Test<br/>    @Order(4)<br/>    fun testPublish() {<br/>        val request = PublishRequest()<br/>        request.topicArn = topicArn<br/>        request.subject = "This is a sample subject"<br/>        request.message = "This foo is a sample message"<br/>        request.messageGroupId = "ExampleGroupId"<br/>        val result = amazonSNS.publish(request)</span><span id="08f5" class="kq jf hi km b fi kv ks l kt ku">        val receiveMessageResult1 = amazonSQS.receiveMessage(<br/>                ReceiveMessageRequest()<br/>                        .withWaitTimeSeconds(5)<br/>                        .withQueueUrl(queueUrl1)<br/>        )</span><span id="bcda" class="kq jf hi km b fi kv ks l kt ku">        val receiveMessageResult2 = amazonSQS.receiveMessage(<br/>                ReceiveMessageRequest()<br/>                        .withWaitTimeSeconds(5)<br/>                        .withQueueUrl(queueUrl2)<br/>        )</span><span id="fdca" class="kq jf hi km b fi kv ks l kt ku">        val objectMapper = ObjectMapper()</span><span id="d8e3" class="kq jf hi km b fi kv ks l kt ku">        val message1 = receiveMessageResult1.messages.first()<br/>        val bodyMap1 = objectMapper.readValue(message1.body, Map::class.java)</span><span id="c9f4" class="kq jf hi km b fi kv ks l kt ku">        val message2 = receiveMessageResult2.messages.first()<br/>        val bodyMap2 = objectMapper.readValue(message2.body, Map::class.java)</span><span id="0be5" class="kq jf hi km b fi kv ks l kt ku">        Assertions.assertEquals(200, result.sdkHttpMetadata.httpStatusCode)<br/>        Assertions.assertNotNull(result.messageId)</span><span id="38a9" class="kq jf hi km b fi kv ks l kt ku">        Assertions.assertTrue(receiveMessageResult1.messages.isNotEmpty())<br/>        Assertions.assertEquals(request.message, bodyMap1["Message"])<br/>        Assertions.assertEquals(topicArn, bodyMap1["TopicArn"])<br/>        Assertions.assertEquals(request.subject, bodyMap1["Subject"])</span><span id="8c0e" class="kq jf hi km b fi kv ks l kt ku">        Assertions.assertTrue(receiveMessageResult2.messages.isNotEmpty())<br/>        Assertions.assertEquals(request.message, bodyMap2["Message"])<br/>        Assertions.assertEquals(topicArn, bodyMap2["TopicArn"])<br/>        Assertions.assertEquals(request.subject, bodyMap2["Subject"])<br/>    }<br/>}</span></pre><p id="d070" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们一个功能一个功能地解释这段代码。与第一个测试文件一样，这个文件中的测试也按照指定的顺序工作。在第一个测试中，我们创建了一个SNS主题。然后在第二个例子中，我们创建了两个亚马逊SQS定义。在第三个测试中，我们订阅了Amazon SNS主题的队列。</p><p id="4ecf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最后一个测试场景中，我们发送一条SNS消息，并期望两个队列都接收到该消息。消息内容以JSON格式发送。下面是一条典型的JSON格式的SQS消息:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2afd" class="kq jf hi km b fi kr ks l kt ku">{<br/>   "MessageId":"4e68039b-faaf-4aba-67da-fe75cfcb0b4b",<br/>   "ReceiptHandle":"xxwcwycayeifjskwiqribwcxsaxjbbsoqtwidvunpekzjhxwppszbufvvecxoyaexylajcpmyrdibhlqdjdoyfjeqihvuwkrdjhermstvyblisrhpswpznglwhcesbnskcyxymvonfyzjtykkoikyasnksafaegwsvdlkaiptjmrihzuduyzprdmg",<br/>   "MD5OfBody":"2cb3e645c71bf662f72fe8ca5b5c5d12",<br/>   "Body":{<br/>      "Type":"Notification",<br/>      "MessageId":"9774de9f-1677-4ac9-a35d-95cce390ab5a",<br/>      "TopicArn":"arn:aws:sns:us-east-1:000000000000:topic",<br/>      "Message":"This foo is a sample message",<br/>      "Timestamp":"2021-07-22T09:04:00.495Z",<br/>      "SignatureVersion":"1",<br/>      "Signature":"EXAMPLEpH+..",<br/>      "SigningCertURL":"https://sns.us-east-1.amazonaws.com/SimpleNotificationService-0000000000000000000000.pem",<br/>      "Subject":"This is a sample subject"<br/>   },<br/>   "Attributes":{<br/>      <br/>   },<br/>   "MessageAttributes":{<br/>      <br/>   }<br/>}</span></pre><p id="7319" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在测试的最后一部分，我们将JSON值转换成一个映射，以便能够检索消息的细节。然后，我们验证了队列检索的消息具有正确的内容。</p><h1 id="6f4e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">社交网络信息过滤</h1><p id="5cac" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">到目前为止，当我们发送SNS消息时，所有订阅的服务都会检索该消息。有可能只将消息重定向到相关的接收者，而不阻塞不相关的队列。Amazon SNS提供消息过滤支持，以区分消息的接收者。过滤器策略是一个JSON对象，用于将特定的策略内容映射到相应的队列。</p><h1 id="63b1" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">将过滤策略添加到社交网络</h1><p id="32d6" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">添加筛选器策略需要有效的订阅ARN。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="e1b9" class="kq jf hi km b fi kr ks l kt ku">var subscriptionArn = Topics.subscribeQueue(amazonSNS, amazonSQS, topicArn, queueUrl1)<br/>Assertions.assertTrue(subscriptionArn.contains(topic))</span><span id="e602" class="kq jf hi km b fi kv ks l kt ku">var filterPolicyString = "{\"event\":[\"${filterPolicy1}\"]}"<br/>var request = SetSubscriptionAttributesRequest(subscriptionArn, "FilterPolicy", filterPolicyString)<br/>amazonSNS.setSubscriptionAttributes(request)</span></pre><p id="73ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们必须使用<code class="du kw kx ky km b">FilterPolicy</code>属性名称来提供策略内容。</p><h1 id="cf9d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">发送带有策略的SNS消息</h1><p id="9057" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了能够添加策略消息，我们必须提供策略内容作为消息属性。在下面的例子中，过滤器策略包含一个带有值的<code class="du kw kx ky km b">event</code>键属性。该值必须与我们在主题的队列订阅过程中提供的值相匹配。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="3e04" class="kq jf hi km b fi kr ks l kt ku">@Test<br/>@Order(4)<br/>fun testRedirectToFirstQueueOnly() {<br/>    val request = PublishRequest()<br/>    request.topicArn = topicArn<br/>    request.subject = "This is a sample subject"<br/>    request.message = "This foo is a sample message"<br/>    request.messageGroupId = "ExampleGroupId"</span><span id="fc00" class="kq jf hi km b fi kv ks l kt ku">    val messageAttributeValue = MessageAttributeValue().withDataType("String.Array")<br/>            .withStringValue("[\"$filterPolicy1\"]")<br/>    request.addMessageAttributesEntry("event", messageAttributeValue)</span><span id="73e2" class="kq jf hi km b fi kv ks l kt ku">    val result = amazonSNS.publish(request)</span><span id="115a" class="kq jf hi km b fi kv ks l kt ku">    val receiveMessageResult1 = amazonSQS.receiveMessage(<br/>            ReceiveMessageRequest()<br/>                    .withWaitTimeSeconds(5)<br/>                    .withQueueUrl(queueUrl1)<br/>    )</span><span id="dca7" class="kq jf hi km b fi kv ks l kt ku">    val receiveMessageResult2 = amazonSQS.receiveMessage(<br/>            ReceiveMessageRequest()<br/>                    .withWaitTimeSeconds(5)<br/>                    .withQueueUrl(queueUrl2)<br/>    )</span><span id="e914" class="kq jf hi km b fi kv ks l kt ku">    val objectMapper = ObjectMapper()</span><span id="abe6" class="kq jf hi km b fi kv ks l kt ku">    val message1 = receiveMessageResult1.messages.first()<br/>    val bodyMap1 = objectMapper.readValue(message1.body, Map::class.java)</span><span id="f670" class="kq jf hi km b fi kv ks l kt ku">    Assertions.assertEquals(200, result.sdkHttpMetadata.httpStatusCode)<br/>    Assertions.assertNotNull(result.messageId)</span><span id="dac1" class="kq jf hi km b fi kv ks l kt ku">    Assertions.assertTrue(receiveMessageResult1.messages.isNotEmpty())<br/>    Assertions.assertEquals(request.message, bodyMap1["Message"])<br/>    Assertions.assertEquals(topicArn, bodyMap1["TopicArn"])<br/>    Assertions.assertEquals(request.subject, bodyMap1["Subject"])</span><span id="966c" class="kq jf hi km b fi kv ks l kt ku">    Assertions.assertTrue(receiveMessageResult2.messages.isEmpty())<br/>}</span></pre><p id="76fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们运行这个测试场景时，我们应该观察到只有第一个队列必须检索消息。</p><h1 id="cb54" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">摘要</h1><p id="bdf1" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在这篇文章中，我们实现了一些亚马逊SQS的功能，比如创建队列、发送消息。此外，我们集成了亚马逊SQS和SNS，并将SNS消息重定向到相应的队列。多亏了LocalStack，我们在没有连接到Amazon云的情况下离线测试了所有实现。</p></div></div>    
</body>
</html>