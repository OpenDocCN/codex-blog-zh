<html>
<head>
<title>Swift Business logic component (BLoC)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift业务逻辑组件(BLoC)</h1>
<blockquote>原文：<a href="https://medium.com/codex/swift-business-logic-component-bloc-e54aca3f5b9f?source=collection_archive---------4-----------------------#2021-07-15">https://medium.com/codex/swift-business-logic-component-bloc-e54aca3f5b9f?source=collection_archive---------4-----------------------#2021-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/adc7520a559b0afb4abef5a9286e35f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Si6WjJz7dxBsQD5Dl0dVhg.jpeg"/></div></div></figure><p id="c4d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了iOS或Android的本地开发，还有许多不同的跨平台解决方案，其中之一就是Flutter。这带来了一种有趣的划分业务逻辑和UI的方法，称为BLoC — <strong class="is hj">业务逻辑组件模式</strong>。</p><p id="56ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最初由<a class="ae js" href="https://medium.com/u/bd78eebef416?source=post_page-----c22d40f05a56--------------------------------" rel="noopener">菲利克斯·安杰洛夫</a>以颤振包<code class="du jo jp jq jr b"><a class="ae js" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank">flutter_bloc</a></code>和<code class="du jo jp jq jr b"><a class="ae js" href="https://pub.dev/packages/bloc" rel="noopener ugc nofollow" target="_blank">bloc</a></code>的形式呈现，该集团带来了一种新的声明方式，如何使用应用程序每个组件的事件/状态机制。</p><p id="a750" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个解决方案真正激发了我为iOS原生开发创建类似的东西，尽管我们已经有了一套好的架构模式——MVC、MVVM、VIPER。为什么我们需要另一个？</p><p id="8507" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就我个人而言，我认为集团模式是简化的MVVM模式，降低了反应性结合的概念。输入-输出即事件-状态的概念被认为是一个整体。那么为什么不试一试呢…</p><p id="5f9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae js" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank"> Combine </a>框架的帮助下，我能够在pure Swift中创建BLoC库，这对任何<a class="ae js" href="https://developer.apple.com/documentation/swiftui/" rel="noopener ugc nofollow" target="_blank"> SwiftUI </a>构建的应用程序都是一个很好的补充。</p><p id="c21a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以在这里查看源代码<a class="ae js" href="https://github.com/VictorKachalov/SwiftBloc" rel="noopener ugc nofollow" target="_blank"/>，当然也欢迎贡献者:)</p><p id="6611" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将尝试调整心爱的Flutter的入门应用程序“计数器”，但对于带有<a class="ae js" href="https://github.com/VictorKachalov/SwiftBloc" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> SwiftBloc </strong> </a>库的原生iOS。</p><p id="beb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该应用程序将是单视图，并且只执行两个操作——用户每次点击适当的按钮<em class="jt">时<em class="jt">增加</em>和<em class="jt">减少</em>一。</em></p><h2 id="5952" class="ju jv hi bd jw jx jy jz ka kb kc kd ke jb kf kg kh jf ki kj kk jj kl km kn ko bi translated">状态和事件</h2><p id="ad02" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn hb bi translated">应用程序工作流中发生的一切都可以分为事件和状态。事件促使状态被改变。这导致更清晰的想象，应用程序应该如何运行，而不需要描述小细节来使事情工作。</p><p id="12cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们同意计数器应用程序只能加减“1”。让我们为这些创建一个简单的枚举。</p><pre class="ku kv kw kx fd ky jr kz la aw lb bi"><span id="7668" class="ju jv hi jr b fi lc ld l le lf"><strong class="jr hj">enum</strong> CounterEvent {</span><span id="4f90" class="ju jv hi jr b fi lg ld l le lf"><strong class="jr hj">   case</strong> increment</span><span id="b9ae" class="ju jv hi jr b fi lg ld l le lf"><strong class="jr hj">   case</strong> decrement</span><span id="250c" class="ju jv hi jr b fi lg ld l le lf">}</span></pre><p id="ce55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，非常简单，因为我们同意用户在这个应用程序中只发出两个事件，所以我们不需要更多的东西。</p><p id="eaf1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们考虑一下可能的状态。我们知道这个想法是，如果两个事件<em class="jt">中的任何一个被调用，递增</em>或<em class="jt">递减</em>，计数器将增加或减少“1”。所以我们可以用一个变量创建一个<strong class="is hj">计数器</strong>，这个变量将简单地保存一个带有更新值的整数。</p><pre class="ku kv kw kx fd ky jr kz la aw lb bi"><span id="391e" class="ju jv hi jr b fi lc ld l le lf"><strong class="jr hj">struct</strong> CounterState: Equatable {</span><span id="31df" class="ju jv hi jr b fi lg ld l le lf"><strong class="jr hj">   let</strong> count: Int</span><span id="bada" class="ju jv hi jr b fi lg ld l le lf">}</span></pre><p id="4f89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">阻塞需要每个状态和事件的独特行为，这就是为什么<strong class="is hj">反状态</strong>应该符合<strong class="is hj">等价。</strong></p><p id="1bae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个阶段，我们已经可以认为，初始状态可以是<strong class="is hj"> CounterState(count: 0) </strong>，下一个状态可以是<strong class="is hj"> CounterState(count: N) </strong>，其中<strong class="is hj"> N = currentState“加”或“减”1。</strong></p><p id="85a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们创建一个Bloc类来操作事件和状态。</p><pre class="ku kv kw kx fd ky jr kz la aw lb bi"><span id="9a67" class="ju jv hi jr b fi lc ld l le lf"><strong class="jr hj">final class</strong> CounterBloc: Bloc&lt;CounterEvent, CounterState&gt; {</span><span id="79f5" class="ju jv hi jr b fi lg ld l le lf"><strong class="jr hj">   init</strong>() {</span><span id="f651" class="ju jv hi jr b fi lg ld l le lf"><strong class="jr hj">      super</strong>.init(initialState: CounterState(count: 0))</span><span id="2034" class="ju jv hi jr b fi lg ld l le lf">   }</span><span id="a586" class="ju jv hi jr b fi lg ld l le lf"><strong class="jr hj">   override</strong> <strong class="jr hj">func</strong> mapEventToState(event: CounterEvent) -&gt; CounterState {</span><span id="627d" class="ju jv hi jr b fi lg ld l le lf"><strong class="jr hj">      switch</strong> event {</span><span id="2d14" class="ju jv hi jr b fi lg ld l le lf"><strong class="jr hj">      case</strong> .increment:</span><span id="85d1" class="ju jv hi jr b fi lg ld l le lf"><strong class="jr hj">         return</strong> CounterState(count: state.count + 1)</span><span id="52ac" class="ju jv hi jr b fi lg ld l le lf"><strong class="jr hj">      case</strong> .decrement:</span><span id="b0b0" class="ju jv hi jr b fi lg ld l le lf"><strong class="jr hj">         return</strong> CounterState(count: state.count - 1)</span><span id="dfe0" class="ju jv hi jr b fi lg ld l le lf">      }</span><span id="a1b2" class="ju jv hi jr b fi lg ld l le lf">   }</span><span id="8335" class="ju jv hi jr b fi lg ld l le lf">}</span></pre><p id="bd11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要从通用的<strong class="is hj"> Bloc </strong>类继承，并为我们的事件和状态提供类型。</p><p id="233a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要提供一个<strong class="is hj"> init() </strong>并调用超级构造函数来传递<strong class="is hj"> CounterState </strong>的初始状态。</p><p id="19c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里重要的是覆盖方法<strong class="is hj"> mapEventToState — </strong>这是Bloc如何工作的主要思想:<strong class="is hj"> <em class="jt">每个事件只是映射到你需要的状态。</em> </strong>没有覆盖，<strong class="is hj">预处理失败</strong>会使app崩溃。</p><p id="8266" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">非常清楚——如果事件是<em class="jt">递增</em>，那么计数器状态将获得counter state的新值，作为计数参数提供实际的当前状态，递增1。Else —相同，但减1。</p><p id="c4b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们在一个SwiftUI视图中调整块逻辑。</p><pre class="ku kv kw kx fd ky jr kz la aw lb bi"><span id="e072" class="ju jv hi jr b fi lc ld l le lf"><strong class="jr hj">struct</strong> BlocContentView: View {</span><span id="cca3" class="ju jv hi jr b fi lg ld l le lf"><strong class="jr hj">   var</strong> body: <strong class="jr hj">some</strong> View {</span><span id="2a63" class="ju jv hi jr b fi lg ld l le lf">      BlocView(builder: { (bloc) <strong class="jr hj">in</strong></span><span id="6bc1" class="ju jv hi jr b fi lg ld l le lf">         VStack {</span><span id="5763" class="ju jv hi jr b fi lg ld l le lf">            Button(action: {</span><span id="3dcd" class="ju jv hi jr b fi lg ld l le lf">               bloc.add(event: .increment)</span><span id="d56e" class="ju jv hi jr b fi lg ld l le lf">            }, label: {</span><span id="de56" class="ju jv hi jr b fi lg ld l le lf">               Text("Send Increment event")</span><span id="92a5" class="ju jv hi jr b fi lg ld l le lf">            })</span><span id="50fa" class="ju jv hi jr b fi lg ld l le lf">            Button(action: {</span><span id="48b6" class="ju jv hi jr b fi lg ld l le lf">               bloc.add(event: .decrement)</span><span id="1590" class="ju jv hi jr b fi lg ld l le lf">            }, label: {</span><span id="87a1" class="ju jv hi jr b fi lg ld l le lf">               Text("Send Decrement event")</span><span id="5ab1" class="ju jv hi jr b fi lg ld l le lf">            })</span><span id="f6ba" class="ju jv hi jr b fi lg ld l le lf">            Text("Count: \(bloc.state.count)")</span><span id="f8c4" class="ju jv hi jr b fi lg ld l le lf">         }</span><span id="3879" class="ju jv hi jr b fi lg ld l le lf">      }, base: CounterBloc())</span><span id="9c16" class="ju jv hi jr b fi lg ld l le lf">   }</span><span id="406e" class="ju jv hi jr b fi lg ld l le lf">}</span></pre><p id="e8b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们创建一个简单的SwiftUI视图<strong class="is hj"> BlocContentView。</strong></p><p id="051e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最有趣的是<strong class="is hj"> body </strong>属性内部的<strong class="is hj"> BlocView </strong>视图。</p><p id="affb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> BlocView </strong>期望<strong class="is hj"> @ViewBuilder </strong>闭包<strong class="is hj"> builder </strong>传递一个闭包参数，该参数引用了为构造函数参数<strong class="is hj"> base </strong>提供的Bloc对象。注意——这个Bloc对象“钻取”所有子视图，因为它是一个<strong class="is hj">环境对象。</strong></p><p id="2584" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个简单的带有几个按钮和一个文本的VStack，我们可以为这个视图提供我们想要的行为。</p><p id="9127" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们建造它并四处玩耍。</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/ed93a3a14c1911fb34cfe3d6a26cd98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*Nuc6pnJsGBSd3U0Er3-pbg.png"/></div></figure><p id="2c50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的初始状态。正如计划的那样，计数器归零。</p><p id="04e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们点击两次<strong class="is hj">发送增量事件</strong>按钮</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/c09af607c4b1bdf5637b0e8251b61f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*ZJPXLMH8v9eCeHxhfsv0kQ.png"/></div></figure><p id="a0cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不要轻击5次<strong class="is hj">发送减量事件</strong>按钮</p><figure class="ku kv kw kx fd ij er es paragraph-image"><div class="er es lh"><img src="../Images/10eba29c1e82c46dcf56de4b82f46f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*Rzpfi1ECIBSLrz4Et_fB2w.png"/></div></figure><p id="25ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有一点需要注意。使用BlocView，当任何状态改变时，整个视图都不会被重建，也就是说，body属性不会被调用！只有构建器闭包被调用。</p><p id="f59b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，您仍然可以使用封装在BLoC状态之上的SwftUI绑定，而不是“@State”:</p><pre class="ku kv kw kx fd ky jr kz la aw lb bi"><span id="78cd" class="ju jv hi jr b fi lc ld l le lf">CounterView()</span><span id="0d75" class="ju jv hi jr b fi lg ld l le lf">   .alert(isPresented: Binding.constant(bloc.state.count &lt; -6)) {</span><span id="5f07" class="ju jv hi jr b fi lg ld l le lf">      Alert(</span><span id="6a0a" class="ju jv hi jr b fi lg ld l le lf">         title: Text("Hi"),</span><span id="04dd" class="ju jv hi jr b fi lg ld l le lf">         message: Text("Message"),</span><span id="a365" class="ju jv hi jr b fi lg ld l le lf">         dismissButton: .cancel {</span><span id="4997" class="ju jv hi jr b fi lg ld l le lf"><strong class="jr hj">            for</strong> _ <strong class="jr hj">in</strong> 0..&lt;6 {</span><span id="b06f" class="ju jv hi jr b fi lg ld l le lf">               bloc.add(event: .increment)</span><span id="cf9d" class="ju jv hi jr b fi lg ld l le lf">            }</span><span id="ec09" class="ju jv hi jr b fi lg ld l le lf">         }</span><span id="997e" class="ju jv hi jr b fi lg ld l le lf">      )</span><span id="a04c" class="ju jv hi jr b fi lg ld l le lf">    }</span></pre><p id="e778" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法可以让你优化你的应用程序，减少重复调用body property来重绘整个视图。</p></div></div>    
</body>
</html>