<html>
<head>
<title>Applied Text Analysis with Python: Chapter 1 — Language and Computation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python应用文本分析:第1章——语言和计算</h1>
<blockquote>原文：<a href="https://medium.com/codex/atap-chapter-1-language-and-computation-c7bdcfe1f6fb?source=collection_archive---------10-----------------------#2021-07-27">https://medium.com/codex/atap-chapter-1-language-and-computation-c7bdcfe1f6fb?source=collection_archive---------10-----------------------#2021-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="4ed6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">或者，旅程的开始…</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/54a0003edf108e37377145fd025814f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vPyQE4P3521MLXcr-mcktQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">来自https://www.publicdomainpictures.net/en/view-image.php?image = 113151&amp;picture =四元素</figcaption></figure><p id="60a3" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我在2019年亲自参加<a class="ae jt" href="https://us.pycon.org/" rel="noopener ugc nofollow" target="_blank"> PyCon </a>的时候买了Bengford，Bilbro &amp; Ojeda的<em class="ks">用Python </em>应用文本分析的实体副本。2019和亲自参加会议感觉是很久以前的事了！</p><p id="9ad1" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我意识到我怀念和人类语言数据打交道的日子。我有计算机科学和语言学的背景，自2006年获得语言学硕士学位以来，我一直在努力寻找一份能够利用这两个领域技能的工作。作为一名后端开发人员，我很满意，但是上周我和同事进行了至少三次对话，其中出现了一些语言学领域的话题。我意识到我内心的语言学家在说话！</p><p id="b641" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">于是，我看了看我的书架，拿起我的那本ATAP，开始了第1章。这是我阅读ATAP的第一篇文章，分享我的经验、想法和代码。</p><p id="d3d5" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我对这个项目的意图是:</p><ul class=""><li id="8009" class="kt ku hi jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">享受使用Python和人类语言数据的乐趣</li><li id="33e4" class="kt ku hi jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">提问和学习</li></ul><p id="a63e" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">更具体地说，我计划:</p><ul class=""><li id="77a3" class="kt ku hi jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">阅读书中的每一章</li><li id="6eaa" class="kt ku hi jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">为每一章编写至少一个代码示例，并在<a class="ae jt" href="https://github.com/annawinkler" rel="noopener ugc nofollow" target="_blank"> Github </a>上分享代码</li><li id="1f26" class="kt ku hi jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">每章至少写一篇文章，分享我的经验</li></ul><p id="f069" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们开始吧！</p><h1 id="78da" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是数据科学家？</h1><p id="5356" class="pw-post-body-paragraph ju jv hi jw b jx lh jz ka kb li kd ke kf lj kh ki kj lk kl km kn ll kp kq kr hb bi translated">本章介绍了数据科学，并将数据科学家定义为:</p><blockquote class="lm ln lo"><p id="6cbf" class="ju jv ks jw b jx jy jz ka kb kc kd ke lp kg kh ki lq kk kl km lr ko kp kq kr hb bi translated">一部分是统计学家，一部分是计算机科学家，一部分是领域专家</p></blockquote><p id="27c6" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">因为数据是不可预测的，所以作者断言数据科学并不总是适合软件开发工作流(例如敏捷工作流)。本书希望通过描述直接支持应用程序开发的数据科学工具和过程来弥合这一差距。</p><p id="0e03" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">根据作者的说法，应用文本分析:</p><blockquote class="lm ln lo"><p id="8cab" class="ju jv ks jw b jx jy jz ka kb kc kd ke lp kg kh ki lq kk kl km lr ko kp kq kr hb bi translated">支持创建“语言感知数据产品”</p></blockquote><p id="404a" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">有意义的应用程序以有意义的、可理解的和现实的方式响应语言。</p><p id="0fee" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">数据科学家创建描述语言的模型，并可用于进行预测。</p><h1 id="078d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">语言特征和元素的例子</h1><p id="ec7f" class="pw-post-body-paragraph ju jv hi jw b jx lh jz ka kb li kd ke kf lj kh ki kj lk kl km kn ll kp kq kr hb bi translated">本章中的代码示例是英语中的性别模型。这个例子今天没有引起我的共鸣，所以我决定写一个元素(火、水、空气、土)的模型。对于这个例子，我用的是一个<a class="ae jt" href="https://jupyter.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> Jupyter </a>笔记本，因为它非常简单有趣！我也用PyCharm作为我的编辑器。请随意使用您最喜欢的编辑器。这个<a class="ae jt" href="https://github.com/annawinkler/elemental" rel="noopener ugc nofollow" target="_blank">回购</a>有代码。</p><p id="6b88" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">让我们首先定义不同元素的常数:</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="1bef" class="lx ig hi lt b fi ly lz l ma mb">EARTH = 'earth'<br/>AIR = 'air'<br/>FIRE = 'fire'<br/>WATER = 'water'<br/>UNKNOWN = 'unknown'</span></pre><p id="f715" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">现在，我们将手动创建模型。每个元素都有一个代表该元素的单词列表。因为我对这些元素的看法有偏差，可能你的模型会不一样，会做出不一样的预测。这个练习的目的是创建一个简单的模型，所以我们现在不用担心那些复杂性。我们也承认手工生成单词列表，包括添加复数和其他变体，效率不高。我们知道这一点—我们正在创建一个简单的模型，所以没问题！</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="4a5b" class="lx ig hi lt b fi ly lz l ma mb"><em class="ks"># I manually generated these lists by brainstorming, searching <br/># for synonyms, and adding morphological variations of words <br/># (e.g., adding plurals)<br/></em>AIR_WORDS = {<br/>    <strong class="lt hj">'air'</strong>, <strong class="lt hj">'breeze'</strong>, <strong class="lt hj">'breezy'</strong>, <strong class="lt hj">'cloud'</strong>, <strong class="lt hj">'clouds'</strong>, <strong class="lt hj">'fog'</strong>,<br/>    <strong class="lt hj">'gray'</strong>, <strong class="lt hj">'grey'</strong>, <strong class="lt hj">'light'</strong>, <strong class="lt hj">'mist'</strong>, <strong class="lt hj">'smoke'</strong>, <strong class="lt hj">'smog'</strong>,<br/>    <strong class="lt hj">'white'</strong>, <strong class="lt hj">'wind'</strong>, <strong class="lt hj">'windy'<br/></strong>}<br/><br/>EARTH_WORDS = {<br/>    <strong class="lt hj">'brown'</strong>, <strong class="lt hj">'dirt'</strong>, <strong class="lt hj">'earth'</strong>, <strong class="lt hj">'earthy'</strong>, <strong class="lt hj">'green'</strong>, <strong class="lt hj">'ground'</strong>,<br/>    <strong class="lt hj">'grounded'</strong>, <strong class="lt hj">'grounding'</strong>, <strong class="lt hj">'root'</strong>, <strong class="lt hj">'roots'</strong>, <strong class="lt hj">'soil'</strong>, <strong class="lt hj">'tree'</strong>,<br/>    <strong class="lt hj">'trees'</strong>, <strong class="lt hj">'worm'</strong>, <strong class="lt hj">'worms'<br/></strong>}<br/><br/>FIRE_WORDS = {<br/>    <strong class="lt hj">'active'</strong>, <strong class="lt hj">'fire'</strong>, <strong class="lt hj">'flames'</strong>, <strong class="lt hj">'hot'</strong>, <strong class="lt hj">'roast'</strong>, <strong class="lt hj">'red'</strong>,<br/>    <strong class="lt hj">'orange'</strong>, <strong class="lt hj">'yellow'</strong>, <strong class="lt hj">'sun'</strong>, <strong class="lt hj">'warm'</strong>, <strong class="lt hj">'warmth'<br/></strong>}<br/><br/>WATER_WORDS = {<br/>    <strong class="lt hj">'blue'</strong>, <strong class="lt hj">'downpour'</strong>, <strong class="lt hj">'drops'</strong>, <strong class="lt hj">'flow'</strong>, <strong class="lt hj">'moist'</strong>, <strong class="lt hj">'ocean'</strong>,<br/>    <strong class="lt hj">'rain'</strong>, <strong class="lt hj">'river'</strong>, <strong class="lt hj">'sprinkle'</strong>, <strong class="lt hj">'stream'</strong>, <strong class="lt hj">'water'</strong>, <strong class="lt hj">'wave'</strong>,<br/>    <strong class="lt hj">'waves'<br/></strong>}</span></pre><p id="f8b6" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">现在，我们需要添加一个解析文本的方法。这个方法来自书中(对于这个特殊的例子有一个额外的print语句):</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="b575" class="lx ig hi lt b fi ly lz l ma mb">import nltk<br/><br/>def parse_element(text):<br/>    sentences = [<br/>        [word.lower() for word in nltk.word_tokenize(sentence)]<br/>        for sentence in nltk.sent_tokenize(text)<br/>    ]<br/><br/>    num_sentences, num_words = count_elements(sentences)<br/>    total = sum(num_words.values())<br/><br/>    print(<strong class="lt hj">f'Frequency-based score of how much of an Element (Air, Water, Fire, Earth) is in Text'</strong>)<br/>    for element, count in num_words.items():<br/>        percent = (count / total) * 100<br/>        nsents = num_sentences[element]<br/>        print(<strong class="lt hj">f'</strong>{percent}<strong class="lt hj">% </strong>{element}<strong class="lt hj"> (</strong>{nsents}<strong class="lt hj"> sentences)'</strong>)</span></pre><p id="4b17" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">方法<code class="du mc md me lt b">parse_element</code>是我们的主要方法，它被我们想要分析的文本调用。在方法<code class="du mc md me lt b">parse_element</code>中，我们使用<a class="ae jt" href="https://www.nltk.org/" rel="noopener ugc nofollow" target="_blank"> NLTK </a>库通过<code class="du mc md me lt b">sent_tokenize</code>找到文本中的句子，然后通过<code class="du mc md me lt b">word_tokenize</code>找到每个句子中的单词。</p><p id="504e" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这个主方法调用如下所示的<code class="du mc md me lt b">count_elements</code>:</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="7672" class="lx ig hi lt b fi ly lz l ma mb">from collections import Counter</span><span id="a4b5" class="lx ig hi lt b fi mf lz l ma mb">def count_elements(sentences):<br/>    num_sentences = Counter()<br/>    num_words = Counter()</span><span id="def7" class="lx ig hi lt b fi mf lz l ma mb">for sentence in sentences:<br/>        element = elementalize(sentence)<br/>        num_sentences[element] += 1<br/>        num_words[element] += len(sentence)</span><span id="ce46" class="lx ig hi lt b fi mf lz l ma mb">return num_sentences, num_words</span></pre><p id="5f39" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这个方法计算句子的数量，每个句子的字数，并调用方法<code class="du mc md me lt b">elementalize</code>来获取给定句子的元素。</p><p id="6579" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">下面是方法<code class="du mc md me lt b">elementalize</code>:</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="68a3" class="lx ig hi lt b fi ly lz l ma mb">def elementalize(words):<br/>    earth_len = len(EARTH_WORDS.intersection(words))<br/>    air_len = len(AIR_WORDS.intersection(words))<br/>    water_len = len(WATER_WORDS.intersection(words))<br/>    fire_len = len(FIRE_WORDS.intersection(words))<br/>    element_counts = {EARTH: earth_len,<br/>                      AIR: air_len,<br/>                      WATER: water_len,<br/>                      FIRE: fire_len}</span><span id="7a9d" class="lx ig hi lt b fi mf lz l ma mb"># If we don't find any element words, then we can't make any predictions.<br/>    if earth_len == 0 and air_len == 0 and water_len == 0 and fire_len == 0:<br/>        return UNKNOWN<br/>    else:<br/>        max_element_value = max(sorted(element_counts.values()))<br/>        max_element_name = [k for k, v in element_counts.items() if v == max_element_value][0]<br/>        return max_element_name</span></pre><p id="1d03" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">该方法计算单词列表中有多少个土、气、水和火单词，并返回最大数量。</p><p id="b4ee" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">对于这种方法，有一些事情是幼稚的:</p><ul class=""><li id="b646" class="kt ku hi jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">如果元素计数相同，我们将只返回具有该计数的第一个元素。例如，如果地球和空气的计数都是2，那么我们将返回列表中的第一个。</li><li id="43fc" class="kt ku hi jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">我们没有考虑多个元素匹配的情况。要么全有，要么全无，更多的粒度会给我们提供更多关于我们正在处理的文本的信息。</li></ul><p id="cdd8" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">就是这样！下一个问题是我们从哪里得到文本？为了简单起见，我使用了一个随机段落生成器来生成一个段落。我用这个文本设置了一个局部变量，并用这个文本调用了<code class="du mc md me lt b">parse_element</code>,如下所示:</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="2a12" class="lx ig hi lt b fi ly lz l ma mb">sample_text = 'The day had begun on a bright note. The sun finally peeked through the rain for the first time in a week, and the birds were singing in its warmth. There was no way to anticipate what was about to happen. It was a worst-case scenario and there was no way out of it.'</span><span id="f844" class="lx ig hi lt b fi mf lz l ma mb">parse_element(sample_text)</span></pre><p id="eca2" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在Jupyter笔记本中运行这段代码，输出是:</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="cfdb" class="lx ig hi lt b fi ly lz l ma mb">Frequency-based score of how much of an Element (Air, Water, Fire, Earth) is in Text<br/>59.32203389830508% unknown (3 sentences)<br/>40.67796610169492% fire (1 sentences)</span></pre><p id="d660" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这告诉我们什么？好吧，对于这很小的一段随机文字，59%的文字是未知元素，40%是火。我们可以用这个模型做什么？我将在以后的帖子中讨论这个问题。我保证。</p><p id="a8f9" class="pw-post-body-paragraph ju jv hi jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在我的下一篇文章中，我们将探索第2章，<em class="ks">构建自定义语料库</em>，我们将进一步扩展这个例子。那里见！</p></div></div>    
</body>
</html>