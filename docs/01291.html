<html>
<head>
<title>Introduction to Go Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go接口简介</h1>
<blockquote>原文：<a href="https://medium.com/codex/go-interfaces-for-new-gophers-3d608db99d46?source=collection_archive---------3-----------------------#2021-04-17">https://medium.com/codex/go-interfaces-for-new-gophers-3d608db99d46?source=collection_archive---------3-----------------------#2021-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/768b445472c6e8e0e21ae742375b5b66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qHPM-2K5PKtQLYDZLdU6Hw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">你好地鼠！照片由<a class="ae iu" href="https://unsplash.com/@otohp_by_sakul?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卢克亚什·vaňátko</a>在Unsplash上拍摄。</figcaption></figure><p id="0a1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我第一次开始用Go编程时，我发现Go接口是一个很难理解的话题。经过几个小时的阅读和研究，我写了这篇文章，试图为初露头角的地鼠简化Go接口。</p><p id="4760" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本教程中，我旨在用<strong class="ix hj">简单明了的英语</strong>和童趣十足的例子来回答以下问题。</p><ol class=""><li id="1d98" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">什么是Go界面？你如何使用它？</li><li id="fee3" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">Go接口为什么有用？</li><li id="3c55" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">界面是如何在引擎盖下工作的？</li></ol><p id="90bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我假设你熟悉基本的Go语法，比如函数和结构。我们开始吧！🏃</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="0c56" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">什么是Go界面？</h1><p id="97e3" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">从形式上来说，Go接口是一组<strong class="ix hj">类型</strong>可以<strong class="ix hj">实现</strong>的方法签名。迷茫？让我们将这一陈述分成三个问题来引导你的理解。</p><h2 id="7245" class="lr kp hi bd kq ls lt lu ku lv lw lx ky jg ly lz lc jk ma mb lg jo mc md lk me bi translated">🤔️What是一个类型？</h2><p id="59d6" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">类型是指<strong class="ix hj">数据类型</strong>。在Go中，每个变量、函数参数和返回值都必须有一个类型。Go使用了一个非常容易使用的极简类型系统。</p><figure class="mg mh mi mj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/8ce7c6d210a75e9c871e7c0eb9dfc523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XC81ATYW51hDGguUHgUSfQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Go中一些常见的数据类型。</figcaption></figure><p id="f054" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过<strong class="ix hj">将函数</strong>附加到Go数据类型来添加行为。与类型相关的函数称为<strong class="ix hj">方法</strong>。为了演示这个想法，让我们首先定义一个<code class="du mk ml mm mn b">Donald</code>结构和两个函数<code class="du mk ml mm mn b">Quack</code>和<code class="du mk ml mm mn b">Walk</code>。</p><pre class="mg mh mi mj fd mo mn mp mq aw mr bi"><span id="d043" class="lr kp hi mn b fi ms mt l mu mv">package main</span><span id="fb43" class="lr kp hi mn b fi mw mt l mu mv">import "fmt"</span><span id="548f" class="lr kp hi mn b fi mw mt l mu mv">type Donald struct {}</span><span id="9215" class="lr kp hi mn b fi mw mt l mu mv">func Quack() {<br/>    fmt.Println("I am Donald Duck!")<br/>}</span><span id="1aae" class="lr kp hi mn b fi mw mt l mu mv">func Walk() {<br/>    fmt.Println("I waddle")<br/>}</span><span id="8854" class="lr kp hi mn b fi mw mt l mu mv">func main() {<br/>    Quack() // I am Donald Duck!<br/>    Walk() // I waddle<br/>}</span></pre><p id="c2c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个(无聊的)例子中，<code class="du mk ml mm mn b">Quack</code>和<code class="du mk ml mm mn b">Walk</code>是与<code class="du mk ml mm mn b">Donald</code>无关的普通围棋函数。为了使它们成为<code class="du mk ml mm mn b">Donald</code>的方法，我们将代码更新如下:</p><pre class="mg mh mi mj fd mo mn mp mq aw mr bi"><span id="c039" class="lr kp hi mn b fi ms mt l mu mv">package main</span><span id="0c3d" class="lr kp hi mn b fi mw mt l mu mv">import "fmt"</span><span id="41b4" class="lr kp hi mn b fi mw mt l mu mv">type Donald struct {}</span><span id="19a4" class="lr kp hi mn b fi mw mt l mu mv">// Make Quack a method of Donald<br/>func (d Donald) Quack() {<br/>    fmt.Println("I am Donald Duck!")<br/>}</span><span id="401e" class="lr kp hi mn b fi mw mt l mu mv">// Make Walk a method of Donald<br/>func (d Donald) Walk() {<br/>    fmt.Println("I waddle")<br/>}</span><span id="ec9c" class="lr kp hi mn b fi mw mt l mu mv">func main() {<br/>    d:= new(Donald)<br/>    d.Quack()<br/>    d.Walk()<br/>}</span></pre><p id="2398" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意我们是如何在<code class="du mk ml mm mn b">Quack</code>和<code class="du mk ml mm mn b">Walk</code>前面添加<code class="du mk ml mm mn b">(d Donald)</code>的。这就把函数变成了<code class="du mk ml mm mn b">Donald</code>的方法。要使用这些方法，我们需要创建一个<code class="du mk ml mm mn b">Donald</code>的实例，并通过<strong class="ix hj">点操作符</strong>调用它们。</p><figure class="mg mh mi mj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/f818182e971824bab490e22d9c01b4d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ge92tPkvE_GRD5mPj3QmWA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">唐老鸭。由<a class="ae iu" href="https://unsplash.com/@kinli?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Kin Li </a>在Unsplash上拍摄的照片。</figcaption></figure><h2 id="fd7f" class="lr kp hi bd kq ls lt lu ku lv lw lx ky jg ly lz lc jk ma mb lg jo mc md lk me bi translated">🤔什么是方法签名？</h2><p id="d2c7" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">方法签名是方法的标识，就像人的手写签名一样。在Go中，方法签名由<strong class="ix hj">方法名</strong>、<strong class="ix hj">返回类型</strong>及其<strong class="ix hj">参数</strong>组成。</p><p id="a91e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，上面的方法<code class="du mk ml mm mn b">Quack</code>不接受任何参数并且<strong class="ix hj">不返回任何内容</strong>，其方法签名如下:</p><pre class="mg mh mi mj fd mo mn mp mq aw mr bi"><span id="8d1d" class="lr kp hi mn b fi ms mt l mu mv">Quack()</span></pre><p id="960a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">方法<code class="du mk ml mm mn b">Walk</code>有一个相似的签名，但方法名不同。</p><pre class="mg mh mi mj fd mo mn mp mq aw mr bi"><span id="27a9" class="lr kp hi mn b fi ms mt l mu mv">Walk()</span></pre><p id="70f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">值得注意的是，方法签名<strong class="ix hj">没有方法体</strong>。换句话说，它没有告诉我们任何关于方法底层实现的信息。</p><p id="8442" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们终于可以创建我们的第一个Go界面了！记住，一个接口仅仅是方法签名的集合。我们将用<code class="du mk ml mm mn b">Quack</code>和<code class="du mk ml mm mn b">Walk</code>的签名来命名我们的接口<code class="du mk ml mm mn b">Duck</code>。</p><pre class="mg mh mi mj fd mo mn mp mq aw mr bi"><span id="5653" class="lr kp hi mn b fi ms mt l mu mv">type Duck interface {<br/>    Quack()<br/>    Walk()<br/>}</span></pre><figure class="mg mh mi mj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/861ba33191620af8b432d6bd031d5a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*grL_AgF4P68m8khPvQJiMA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Josue Michel 在Unsplash上拍摄的照片。</figcaption></figure><p id="398c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很好，但是界面现在什么都不做。我们如何使用它？类型如何实现接口？</p><h2 id="7de3" class="lr kp hi bd kq ls lt lu ku lv lw lx ky jg ly lz lc jk ma mb lg jo mc md lk me bi translated">🤔如何实现一个接口？</h2><p id="c354" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">在Go中，如果一个数据类型的方法<strong class="ix hj">满足该接口的方法签名</strong>，那么这个数据类型就实现了一个接口。</p><p id="dc4f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">换句话说，当一个类型提供了一个接口中定义的方法的实现<strong class="ix hj"> </strong>以及相同的参数和返回类型时，它就实现了这个接口。</p><p id="8af6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，<code class="du mk ml mm mn b">Donald</code>结构实现了<code class="du mk ml mm mn b">Duck</code>接口，因为它有两个方法<code class="du mk ml mm mn b">Quack</code>和<code class="du mk ml mm mn b">Walk</code>，这两个方法不接受参数也不返回任何东西。</p><blockquote class="mz na nb"><p id="acd7" class="iv iw nc ix b iy iz ja jb jc jd je jf nd jh ji jj ne jl jm jn nf jp jq jr js hb bi translated">💻Go语言:Donald实现了Duck接口。</p><p id="219e" class="iv iw nc ix b iy iz ja jb jc jd je jf nd jh ji jj ne jl jm jn nf jp jq jr js hb bi translated">🧍人类语言:唐老鸭是一只鸭子！</p></blockquote><pre class="mg mh mi mj fd mo mn mp mq aw mr bi"><span id="f072" class="lr kp hi mn b fi ms mt l mu mv">type Duck interface {<br/>    Quack()<br/>    Walk()<br/>}</span><span id="0e4d" class="lr kp hi mn b fi mw mt l mu mv">// Donald implements the Duck interface<br/>type Donald struct {}</span><span id="5990" class="lr kp hi mn b fi mw mt l mu mv">func (d Donald) Quack() {<br/>    fmt.Println("I am Donald Duck!")<br/>}</span><span id="2e60" class="lr kp hi mn b fi mw mt l mu mv">func (d Donald) Walk() {<br/>    fmt.Println("I waddle")<br/>}</span></pre><p id="496b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住一个类型隐式地实现一个接口<strong class="ix hj">是很重要的。不需要额外的语法或关键字<strong class="ix hj"> </strong>。唯一的条件是该类型必须有接口的方法。</strong></p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="3edb" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">为什么要用Go接口？</h1><p id="573b" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">在上一节中，我解释了什么是Go接口以及使用它的必要语法。概括地说，我创建了一个结构<code class="du mk ml mm mn b">Donald</code>，它用两个方法<code class="du mk ml mm mn b">Quack</code>和<code class="du mk ml mm mn b">Walk</code>实现了<code class="du mk ml mm mn b">Duck</code>接口。</p><p id="e539" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了有效地使用Go接口，我们需要理解一个接口为什么以及如何在我们的程序中有用。本质上，Go接口允许我们实现所谓的<strong class="ix hj">鸭子打字</strong>。</p><blockquote class="mz na nb"><p id="d3bd" class="iv iw nc ix b iy iz ja jb jc jd je jf nd jh ji jj ne jl jm jn nf jp jq jr js hb bi translated">💡Duck typing通过<strong class="ix hj">它能做什么</strong>而不是它实际上是什么来定义一个对象或类型。</p></blockquote><p id="57a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像往常一样，这样的概念可以通过例子变得更清楚。让我们基于我最喜欢的漫威角色定义一个名为<code class="du mk ml mm mn b">Thor</code>的新结构！</p><pre class="mg mh mi mj fd mo mn mp mq aw mr bi"><span id="9630" class="lr kp hi mn b fi ms mt l mu mv">type Thor struct {}</span></pre><p id="6f6d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于那些不知道索尔是谁的人来说，他是漫威电影宇宙和北欧神话中的雷神。</p><figure class="mg mh mi mj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/75cd9058af232f4d0c249e7435df4af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cUDlNshweis9i1-wnqfxcA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">漫威的雷神。</figcaption></figure><p id="6466" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，他绝不是一只鸭子。不过多亏了Go interfaces，<strong class="ix hj">我们才能让他变成鸭子</strong>！我们所要做的就是通过给他<code class="du mk ml mm mn b">Quack</code>和<code class="du mk ml mm mn b">Walk</code>方法，让<code class="du mk ml mm mn b">Thor</code>实现<code class="du mk ml mm mn b">Duck</code>接口！</p><pre class="mg mh mi mj fd mo mn mp mq aw mr bi"><span id="cd6b" class="lr kp hi mn b fi ms mt l mu mv">// Thor implements the Duck interface<br/>type Thor struct {}</span><span id="2f0e" class="lr kp hi mn b fi mw mt l mu mv">func (t Thor) Quack() {<br/>    fmt.Println("I am the God of Thunder!")<br/>}</span><span id="6e6f" class="lr kp hi mn b fi mw mt l mu mv">func (t Thor) Walk() {<br/>    fmt.Println("I fly and shoot lightning")<br/>}</span></pre><p id="69c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为雷神现在可以嘎嘎叫，像鸭子一样走路，可以像鸭子一样被对待！这是duck typing背后的核心思想:一个对象是由它能做什么(<strong class="ix hj">它拥有的</strong>方法)而不是它是什么(<strong class="ix hj">它的类型</strong>)来定义的。</p><blockquote class="mz na nb"><p id="1b2d" class="iv iw nc ix b iy iz ja jb jc jd je jf nd jh ji jj ne jl jm jn nf jp jq jr js hb bi translated">🦆如果它走路像鸭子，叫起来像鸭子，那它一定是鸭子！</p></blockquote><p id="3820" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好吧…所以我可以让雷神变成一只有Go接口的鸭子。这对我写围棋程序有什么帮助？让我们假设你正在开发一个应用程序，它能让物体嘎嘎叫，像鸭子一样走路。</p><p id="4fbd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，像上一节一样，用方法<code class="du mk ml mm mn b">Quack</code>和<code class="du mk ml mm mn b">Walk</code>创建一个名为<code class="du mk ml mm mn b">Donald</code>的结构。然后，创建一个普通函数，它接受一个类型为<code class="du mk ml mm mn b">Donald</code>的参数，并调用这两个方法。</p><pre class="mg mh mi mj fd mo mn mp mq aw mr bi"><span id="9f8c" class="lr kp hi mn b fi ms mt l mu mv">func behaveLikeDonald(d Donald) {<br/>    d.Quack()<br/>    d.Walk()<br/>}</span></pre><p id="19dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">人们喜欢唐纳德，你的申请越来越受欢迎！有一天，你的用户希望雷神表现得像只鸭子。很简单，你重复你用<code class="du mk ml mm mn b">Donald</code>做的事情。</p><pre class="mg mh mi mj fd mo mn mp mq aw mr bi"><span id="5dd9" class="lr kp hi mn b fi ms mt l mu mv">func behaveLikeThor(t Thor) {<br/>    t.Quack()<br/>    t.Walk()<br/>}</span></pre><p id="95af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，您的应用程序变得更好了！越来越多的人开始要求不同的物体表现得像鸭子。突然，你意识到你的代码是不可伸缩的，因为你需要为每个对象创建一个新的函数！</p><figure class="mg mh mi mj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/b7d9c03c6e41066ebc41123aae706453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHZ9PFhL0kiEDCvqQVx7qw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">每个对象一个函数。</figcaption></figure><p id="457f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您可以只创建一个函数来处理任何同时具有<code class="du mk ml mm mn b">Quack</code>和<code class="du mk ml mm mn b">Walk</code>方法的对象，这不是很好吗？你猜对了，<em class="nc">去救援</em>！</p><p id="40d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Go中，接口在函数参数和返回值中可以被<strong class="ix hj">当作类型</strong>。在上面的例子中，<code class="du mk ml mm mn b">Donald</code>和<code class="du mk ml mm mn b">Thor</code>都是接口类型<code class="du mk ml mm mn b">Duck</code>，因为<strong class="ix hj">实现了接口</strong>(即拥有<code class="du mk ml mm mn b">Duck</code>的方法)。</p><p id="3bf2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样，您只需要一个接受接口类型为<code class="du mk ml mm mn b">Duck</code>的参数的函数。这使得您的应用程序可以随着与Duck相关的对象的数量而轻松扩展！</p><pre class="mg mh mi mj fd mo mn mp mq aw mr bi"><span id="a86c" class="lr kp hi mn b fi ms mt l mu mv">// Define function argument to be of type Duck<br/>func behaveLikeDuck (d Duck) {<br/>    d.Quack()<br/>    d.Walk()<br/>}</span></pre><p id="8ffa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你熟悉面向对象编程(OOP)，你可以说函数<code class="du mk ml mm mn b">behaveLikeDuck</code>实现了<a class="ae iu" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"/></a><strong class="ix hj">。</strong></p><figure class="mg mh mi mj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/f5aac72926398e3677c2296b435ca850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DxZT5_rpS_Hqe3seoi4WBw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">只有一个功能的n个对象。</figcaption></figure><p id="5e31" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总之，Go接口允许我们基于<strong class="ix hj">输入类型拥有的方法</strong>而不是其实际的具体类型来创建抽象。这允许我们设计灵活、可扩展和可伸缩的抽象！</p><p id="5c40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你仍然看不到Go接口的好处，现在还不要太担心。当你开始使用Go时，你很少需要设计自己的界面。</p><p id="e4d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">主要的要点是<strong class="ix hj">使用接口作为数据类型的想法</strong>，因为这是Go抽象的一种常见设计模式。永远记住下面这句话:</p><blockquote class="mz na nb"><p id="3211" class="iv iw nc ix b iy iz ja jb jc jd je jf nd jh ji jj ne jl jm jn nf jp jq jr js hb bi translated">接口类型关心的是一个对象能做什么，而不是它实际上是什么。换句话说，鸭子打字🦆。</p></blockquote></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="ad54" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">带接口值的引擎盖下</h1><p id="78a3" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">在上一节中，我给出了一个简单的例子，说明Go接口在设计强大的可重用抽象时是如何有用的。</p><p id="9da8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">概括地说，我创建了一个自定义结构<code class="du mk ml mm mn b">Donald</code>，它用两个方法<code class="du mk ml mm mn b">Quack</code>和<code class="du mk ml mm mn b">Walk</code>实现了一个<code class="du mk ml mm mn b">Duck</code>接口。还有一个函数<code class="du mk ml mm mn b">behaveLikeDuck</code>接受接口类型<code class="du mk ml mm mn b">Duck</code>的参数。</p><pre class="mg mh mi mj fd mo mn mp mq aw mr bi"><span id="377d" class="lr kp hi mn b fi ms mt l mu mv">func behaveLikeDuck (d Duck) {<br/>    d.Quack()<br/>    d.Walk()<br/>}</span></pre><p id="730e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们思考一下Go接口是如何工作的。具体来说，当我们调用函数<code class="du mk ml mm mn b">behaveLikeDuck</code>时会发生什么？</p><figure class="mg mh mi mj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/d824f3339cae0a3e7ae7702f39fad2d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xE0FboJMCtsLE3d1eM_P3g.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">嗯。马库斯·温克勒在Unsplash上拍摄的照片。</figcaption></figure><p id="caf6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们将一个变量传递给<code class="du mk ml mm mn b">behaveLikeDuck</code>时，Go在编译过程中执行<strong class="ix hj">静态类型检查</strong>，检查变量是否满足<code class="du mk ml mm mn b">Duck</code>接口。如果没有，编译就会失败。</p><p id="a23b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在运行时，Go执行<strong class="ix hj">类型转换</strong>，并在<code class="du mk ml mm mn b">behaveLikeDuck</code>内部创建一个<code class="du mk ml mm mn b">Duck</code>类型的局部变量<code class="du mk ml mm mn b">d</code>。这就产生了一个问题:当方法<code class="du mk ml mm mn b">Quack</code>和<code class="du mk ml mm mn b">Walk</code>被调用时，<em class="nc">怎么知道要执行</em>方法的哪个具体实现？</p><blockquote class="mz na nb"><p id="2386" class="iv iw nc ix b iy iz ja jb jc jd je jf nd jh ji jj ne jl jm jn nf jp jq jr js hb bi translated">❗:实现<code class="du mk ml mm mn b">Duck</code>的类型有很多种，每一种都有自己版本的<code class="du mk ml mm mn b">Quack</code>和<code class="du mk ml mm mn b">Walk</code>。</p></blockquote><p id="4e6c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">局部变量<code class="du mk ml mm mn b">d</code>是一个<strong class="ix hj">接口值</strong>。在最简单的意义上，你可以把一个接口值想象成一个包含两条信息的列表:接口的<strong class="ix hj">底层数据</strong>和<strong class="ix hj">具体</strong> <strong class="ix hj">类型。</strong></p><p id="718c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果我们提供一个类型为<code class="du mk ml mm mn b">Donald</code>的变量，那么<code class="du mk ml mm mn b">d</code>的底层数据指向<code class="du mk ml mm mn b">Donald</code>的实例，而具体类型是具有其方法实现的结构<code class="du mk ml mm mn b">Donald</code>。</p><figure class="mg mh mi mj fd ij er es paragraph-image"><div class="er es nk"><img src="../Images/219707c47c19e78f1fec59477b9d97a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*2atduvLoRaZD9tJ3MMR-LQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">接口值的简化表示</figcaption></figure><p id="547d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个接口值也公开了一个方法，让我们用它的底层具体类型执行<a class="ae iu" href="https://tour.golang.org/methods/15" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">类型断言</strong> </a>。我们现在不会深入讨论这个问题，因为这需要一篇单独的文章。</p><p id="dc73" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们调用接口值<code class="du mk ml mm mn b">d</code>上的方法时，Go <strong class="ix hj">在具体类型下寻找同名</strong>的方法并执行。从这个意义上说，Go足够动态，可以在运行时处理不同但相关的对象。</p><p id="47a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您必须记住的一个警告是，您可以在接口值上访问的方法仅仅是那些在接口中定义的方法。</p><p id="8049" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回到上面的例子，如果<code class="du mk ml mm mn b">Donald</code>有另一个叫做<code class="du mk ml mm mn b">Eat</code>的方法，你不能用接口值<code class="du mk ml mm mn b">d</code>调用它，因为它没有在<code class="du mk ml mm mn b">Duck</code>接口中定义。同样，如果你熟悉OOP，这与<strong class="ix hj">向上转换</strong>在Java等语言中的工作方式是一致的。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="d4f6" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">最后的想法</h1><p id="f659" class="pw-post-body-paragraph iv iw hi ix b iy lm ja jb jc ln je jf jg lo ji jj jk lp jm jn jo lq jq jr js hb bi translated">这就结束了对围棋初学者的围棋界面介绍！在本文中，我解释了什么是Go接口，为什么它们有用，Go接口的底层实现，以及duck类型。</p><p id="e4cf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于Go接口还有很多要讨论的，但是我将把它们留到我以后的文章中，因为这篇文章有点长。</p><p id="1fcc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读。和平✌️！</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="2572" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">参考</h1><ol class=""><li id="45c2" class="jt ju hi ix b iy lm jc ln jg nl jk nm jo nn js jy jz ka kb bi translated"><a class="ae iu" href="https://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go" rel="noopener ugc nofollow" target="_blank"> Jordan Orelli的《如何在Go中使用接口？</a></li><li id="cda7" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><a class="ae iu" href="https://research.swtch.com/interfaces" rel="noopener ugc nofollow" target="_blank"> Russ Cox的《Go数据结构:接口》</a></li></ol></div></div>    
</body>
</html>