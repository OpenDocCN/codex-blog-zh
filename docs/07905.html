<html>
<head>
<title>Using persistent data in a dockerized Django development environment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在dockerized Django开发环境中使用持久数据</h1>
<blockquote>原文：<a href="https://medium.com/codex/using-persistent-data-in-a-dockerized-django-development-environment-cec794db32a0?source=collection_archive---------11-----------------------#2022-07-04">https://medium.com/codex/using-persistent-data-in-a-dockerized-django-development-environment-cec794db32a0?source=collection_archive---------11-----------------------#2022-07-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="122d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Docker容器中运行Django，镜像您的代码库，获得一个干净的开发环境，实时反映代码变化。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/e2fee5731fcb6194caf1adf5f0ea8a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sD0DunTHs5mY939g"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae jt" href="https://unsplash.com/@carrier_lost?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊恩·泰勒</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="b820" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">发展环境</h1><p id="9746" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">拥有一个干净的开发环境是至关重要的，在这个环境中，您可以准确地指定正在使用的系统和包。它可以防止安装在主机上的包和用于您的项目的包之间的干扰。Docker容器提供了一个有限的、明确指定的和可复制的环境，主机上的文件更改不会影响容器。然而，在开发过程中，我们的代码库不断变化。为了反映这些变化，我们的容器需要不断地重新构建和运行。</p><h2 id="2148" class="kx jv hi bd jw ky kz la ka lb lc ld ke iq le lf ki iu lg lh km iy li lj kq lk bi translated">Djangos开发服务器</h2><p id="74a6" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Django运行自己的开发服务器，监控文件变化，并在必要时重启。由于与外界隔离，这些文件更改不会发生在传统的容器设置中。</p><h2 id="7548" class="kx jv hi bd jw ky kz la ka lb lc ld ke iq le lf ki iu lg lh km iy li lj kq lk bi translated">本地数据库设置</h2><p id="7ce5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">此外，使用像SQLite3 (Djangos默认)这样的本地数据库文件，每次容器停止(或重启)时，所有像迁移或数据库条目这样的更改都将被清除。迁移可以重新运行，尽管这是一项非常繁琐的任务。其他数据将完全丢失。</p><h2 id="d157" class="kx jv hi bd jw ky kz la ka lb lc ld ke iq le lf ki iu lg lh km iy li lj kq lk bi translated">将卷装入容器</h2><p id="f1ec" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">将项目文件夹和数据库作为一个卷安装到Docker容器中，可以对其进行读写访问。换句话说，现有数据(我们的项目文件和数据库)可以被容器访问和编辑，新数据也可以被永久保存。</p><h1 id="a400" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">设置环境</h1><h2 id="f3d8" class="kx jv hi bd jw ky kz la ka lb lc ld ke iq le lf ki iu lg lh km iy li lj kq lk bi translated">我们的项目结构</h2><p id="b47c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们希望挂载项目文件夹的全部内容，包括我们正在使用的数据库文件，用于本地开发。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="9cd9" class="kx jv hi lm b fi lq lr l ls lt">|-django_docker_setup<br/>|---django_docker_setup<br/>|---example_application<br/>|-----migrations<br/>|-manage.py<br/>|-requirements.txt<br/>|-Dockerfile<br/>|-Database-File</span></pre><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lu lv l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">我们项目的需求列表</figcaption></figure><h2 id="01de" class="kx jv hi bd jw ky kz la ka lb lc ld ke iq le lf ki iu lg lh km iy li lj kq lk bi translated">我们的文档</h2><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lu lv l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">运行Django应用程序的Dockerfile</figcaption></figure><h1 id="18bf" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">构建和运行我们的容器</h1><h2 id="d688" class="kx jv hi bd jw ky kz la ka lb lc ld ke iq le lf ki iu lg lh km iy li lj kq lk bi translated">装载卷</h2><p id="19ad" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><a class="ae jt" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank">挂载卷</a>是使Docker容器使用或生成的数据持久化的首选机制。</p><p id="033c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了将文件夹挂载到我们的容器中，我们使用了<code class="du lw lx ly lm b">docker run</code>上的<code class="du lw lx ly lm b">-v or --volume flag</code>,并指定了起始路径和目标路径:</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="e2b1" class="kx jv hi lm b fi lq lr l ls lt">docker run -v &lt;Path of folder to mount&gt;:&lt;Path to mount inside container&gt;</span></pre><h2 id="44ee" class="kx jv hi bd jw ky kz la ka lb lc ld ke iq le lf ki iu lg lh km iy li lj kq lk bi translated">发布端口</h2><p id="cf04" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">为了从容器外部访问我们的Django应用程序，我们需要向主机发布一个端口。在本例中，我们将之前公开的容器端口(8000)映射到主机的HTTP端口(80)。我们使用的格式如下，更多的可能性可以在<a class="ae jt" href="https://docs.docker.com/engine/reference/run/#expose-incoming-ports" rel="noopener ugc nofollow" target="_blank"> Docker文档</a>中找到。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="5cf5" class="kx jv hi lm b fi lq lr l ls lt">docker run -p hostPort:containerPort</span></pre><h2 id="9225" class="kx jv hi bd jw ky kz la ka lb lc ld ke iq le lf ki iu lg lh km iy li lj kq lk bi translated">完整命令:</h2><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="bc06" class="kx jv hi lm b fi lq lr l ls lt">docker build <!-- -->-t container-name .<br/>docker run -v<!-- --> $(pwd):/home/ -p 80:8000 container-name</span></pre><p id="725f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们的Dockerfile位于项目文件夹中，所以我们希望将该文件夹中的所有数据挂载到我们在Dockerfile中指定的工作目录中。</p><ul class=""><li id="c30f" class="lz ma hi ih b ii ij im in iq mb iu mc iy md jc me mf mg mh bi translated">打印当前工作目录的路径</li><li id="57bb" class="lz ma hi ih b ii mi im mj iq mk iu ml iy mm jc me mf mg mh bi translated"><code class="du lw lx ly lm b">/home/</code>是绝对路径，如我们的docker文件中所定义的</li></ul><h2 id="6a1a" class="kx jv hi bd jw ky kz la ka lb lc ld ke iq le lf ki iu lg lh km iy li lj kq lk bi translated">访问正在运行的容器</h2><p id="69af" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">此时，您的Django项目正在您的容器中运行。要访问容器，我们可以使用<code class="du lw lx ly lm b"><a class="ae jt" href="https://docs.docker.com/engine/reference/commandline/exec/" rel="noopener ugc nofollow" target="_blank">docker exec</a></code>。它在一个运行容器中运行一个命令，允许我们打开一个shell。</p><p id="ac4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要通过运行以下命令找到我们的容器id:</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="48c2" class="kx jv hi lm b fi lq lr l ls lt">docker ps</span></pre><p id="6481" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这给了我们这样的答案:</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="54db" class="kx jv hi lm b fi lq lr l ls lt">CONTAINER ID   IMAGE                        COMMAND                  CREATED         STATUS         PORTS                      NAMES</span><span id="6d35" class="kx jv hi lm b fi mn lr l ls lt">3fe54fa54c56   container-name   "/bin/sh -c 'python3…"   2 minutes ago   Up 2 minutes   0.0.0.0:80-&gt;8000/tcp       priceless_robinson</span></pre><p id="c687" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了容器id <code class="du lw lx ly lm b">3fe54fa54c56</code>,我们现在可以打开我们的外壳，运行我们的迁移或我们想要的任何东西:</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="d430" class="kx jv hi lm b fi lq lr l ls lt">docker exec -it 3fe54fa54c56 bash</span></pre><p id="1b6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在内部，我们现在可以以持续的方式进行或运行迁移:</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="f640" class="kx jv hi lm b fi lq lr l ls lt">dockeruser@3fe54fa54c56:/$ python3 manage.py migrate</span></pre><h2 id="8b18" class="kx jv hi bd jw ky kz la ka lb lc ld ke iq le lf ki iu lg lh km iy li lj kq lk bi translated">运行时更改文件</h2><p id="2e44" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">此外，运行时所做的代码更改将会实时反映在容器内部。Django应用程序会立即注册在容器外更改文件，然后开发服务器会重新启动。</p><h1 id="9262" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">摘要</h1><p id="cabd" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">通过这几个简单的步骤，您创建了一个不干扰您的主机设置的环境，同时保持了开发过程的顺利和简单。该环境被限制在您的主机系统之外，被明确指定且可重复。与此同时，容器外部的文件更改会立即反映到容器内部，而容器内部的更改(如迁移或数据库条目)会在当前运行的容器生命周期之后保持持久。</p></div></div>    
</body>
</html>