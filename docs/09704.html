<html>
<head>
<title>Hierarchical Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分层聚类</h1>
<blockquote>原文：<a href="https://medium.com/codex/hierarchical-clustering-c78e76fa33f4?source=collection_archive---------10-----------------------#2022-11-03">https://medium.com/codex/hierarchical-clustering-c78e76fa33f4?source=collection_archive---------10-----------------------#2022-11-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f398" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">与Kmeans不同，在层次聚类中，我们不需要在开始时定义聚类的数量。</h2></div><p id="95ec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">类型</strong></p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/b3fcf9bcea588a2dd40eaa45fddbd57f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/0*jZEsnUPGYZDp08Aw"/></div></figure><p id="e71e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">凝聚式层次聚类</strong></p><p id="1d20" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">凝聚层次聚类是最常见的层次聚类类型，用于根据相似性将对象分组。这是一种自下而上的方法，每个观察从自己的聚类开始，随着一个观察在层次结构中向上移动，聚类对被合并。</p><p id="eca4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设有4个数据点。我们将把这些点中的每一个分配给一个集群，因此在开始时将有4个集群。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kb"><img src="../Images/64bb1e1b00752dc48057e63395d7b7d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/0*k4jaG6SiZ5C4NkHB"/></div></figure><p id="9f87" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，在每次迭代中，我们合并最近的一对聚类，并重复这一步骤，直到只剩下一个聚类。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kc"><img src="../Images/7fc0b8d0fe0e01cbe4a4e599315f0901.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/0*lJJoC-DSqF8UyHNj"/></div></figure><p id="d212" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">分裂式层次聚类</strong></p><p id="6516" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分裂式层次聚类在解决现实世界的问题时并不常用。它的工作方式与聚集聚类相反。在这种情况下，我们从所有数据点作为一个单独的集群开始。在每次迭代中，我们分离不相似的最远的点或聚类，直到每个数据点被认为是一个单独的聚类。这里我们将单个聚类分成n个聚类，因此称为分裂聚类。</p><p id="3aa4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不管我们有10或1000个数据点。所有这些点在开始时将属于同一个集群:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kd"><img src="../Images/ea1ad15b8d8f5b79a68d51f47c171535.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/0*qSY9nNMvendMvpdY"/></div></figure><p id="471b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，在每次迭代中，我们分割聚类中最远的点，并重复这个过程，直到每个聚类只包含一个点:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kb"><img src="../Images/cd6f2838a5547d3b60dd74f9adb6fa1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/0*e_EqDjbCH0MNThwA"/></div></figure><p id="8559" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">层次聚类使用两个重要参数</strong></p><ol class=""><li id="c42b" class="ke kf hi iz b ja jb jd je jg kg jk kh jo ki js kj kk kl km bi translated">距离的度量(相似性)</li></ol><p id="cac4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">a.可以使用以下指标计算相似性</p><p id="2c9d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">b.汉娩距</p><p id="54c4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">c.曼哈顿距离(出租车或城市街区)</p><p id="0349" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">d.闵可夫斯基距离</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kn"><img src="../Images/e4bbd544370d428b1179334604afdb1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*iCQk4biug0SaYxCSGbwCFg.png"/></div></figure><p id="8728" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.链接标准</p><p id="daea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">选择距离度量后，需要确定距离的计算起点。链接标准指的是如何计算聚类之间的距离。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ko"><img src="../Images/a9e4272a29b476994bbad856745a7096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GYTI21QqwjS8C8yj"/></div></figure><p id="97d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">单联动</strong></p><p id="df47" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">两个聚类之间的距离是每个聚类中两点之间的最短距离。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ko"><img src="../Images/192384ded80a0789e54d6665ae0ac844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yD4eKBM-FZ7kQQ2U"/></div></figure><p id="6367" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">完成联动</strong></p><p id="4682" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">两个聚类之间的距离是每个聚类中两点之间的最长距离。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ko"><img src="../Images/67da911e203b107b0edd260f112f5ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vLMRZotRfNx8rNr-"/></div></figure><p id="7a49" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">平均联动</strong></p><p id="9322" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">聚类之间的距离是一个聚类中的每个点到另一个聚类中的每个点的平均距离。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ko"><img src="../Images/2cad9f862567c74963dd41c74391bb40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DZqSoyOR4yhuKbJv"/></div></figure><p id="7846" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">病房联动</strong></p><p id="2d1c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">聚类之间的距离是所有聚类内的平方差之和。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kp"><img src="../Images/c6a37cd63e97851b30628617d0e5e213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/0*ShSIsTae-M8uXNBT"/></div></figure><p id="eb20" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">算法工作流程:</strong></p><p id="138f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">凝聚的基本算法是简单明了的。</p><ul class=""><li id="a446" class="ke kf hi iz b ja jb jd je jg kg jk kh jo ki js kq kk kl km bi translated">计算邻近矩阵</li><li id="da31" class="ke kf hi iz b ja kr jd ks jg kt jk ku jo kv js kq kk kl km bi translated">让每个数据点成为一个集群</li><li id="12a9" class="ke kf hi iz b ja kr jd ks jg kt jk ku jo kv js kq kk kl km bi translated">重复:合并两个最近的聚类并更新邻近矩阵</li><li id="2328" class="ke kf hi iz b ja kr jd ks jg kt jk ku jo kv js kq kk kl km bi translated">直到只剩下一个集群</li></ul><p id="56f6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关键操作是计算两个聚类的接近度</p><p id="66b0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了更好地理解，让我们看一个凝聚层次聚类技术的图示。<strong class="iz hj"> </strong>假设我们有六个数据点{A，B，C，D，E，F}。</p><ul class=""><li id="2848" class="ke kf hi iz b ja jb jd je jg kg jk kh jo ki js kq kk kl km bi translated">步骤1:在初始步骤中，我们计算各个点的接近度，并将所有六个数据点视为独立的聚类，如下图所示。</li></ul><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kw"><img src="../Images/837a35616ede9592043d9940355ba598.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/0*HtwklVYaeYAd0Qld.png"/></div></figure><p id="6c13" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">凝聚层次聚类技术</p><ul class=""><li id="23a1" class="ke kf hi iz b ja jb jd je jg kg jk kh jo ki js kq kk kl km bi translated">步骤2:在步骤2中，相似的聚类被合并在一起并形成单个聚类。让我们考虑B、C和D、E是在第二步中合并的相似集群。现在，我们剩下四个集群，分别是A，BC，DE，f。</li><li id="4e91" class="ke kf hi iz b ja kr jd ks jg kt jk ku jo kv js kq kk kl km bi translated">步骤3:我们再次计算新聚类的接近度，并合并相似的聚类以形成新的聚类A、BC、DEF。</li><li id="182b" class="ke kf hi iz b ja kr jd ks jg kt jk ku jo kv js kq kk kl km bi translated">步骤4:计算新群的接近度。聚类DEF和BC是相似的，并且合并在一起以形成新的聚类。我们现在剩下两个星团A，BCDEF。</li><li id="e403" class="ke kf hi iz b ja kr jd ks jg kt jk ku jo kv js kq kk kl km bi translated">第5步:最后，所有的集群合并在一起，形成一个单一的集群。</li></ul><p id="b950" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">层次聚类技术可以用<strong class="iz hj">树状图来形象化。</strong></p><p id="77d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">树状图</strong>是一个<strong class="iz hj"> </strong>树形图，记录了合并或拆分的顺序。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kx"><img src="../Images/45647adade5f9a342cf7bf207ad4eac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6IqMTT6LCAEVLuUA.jpeg"/></div></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kx"><img src="../Images/8298f1c919cde137aaff69b8b6d8c64b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MBXGvagv6z_IjA8j.jpeg"/></div></div></figure></div></div>    
</body>
</html>