<html>
<head>
<title>Demonstrating exponential speedup with the Deutsch-Jozsa algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Deutsch-Jozsa算法演示指数加速</h1>
<blockquote>原文：<a href="https://medium.com/codex/demonstrating-exponential-speedup-with-the-deutsch-jozsa-algorithm-ae680df79039?source=collection_archive---------29-----------------------#2022-03-31">https://medium.com/codex/demonstrating-exponential-speedup-with-the-deutsch-jozsa-algorithm-ae680df79039?source=collection_archive---------29-----------------------#2022-03-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c37c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当一项新技术被大肆宣传时，人们都会好奇它能提供什么。随着量子计算越来越受到关注，你可能想知道它是否真的比我们今天拥有的计算机有好处。在这篇文章中，我将介绍Deutsch-Jozsa算法[1]，这是第一个被证明比最佳经典解决方案更快的量子算法。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="88a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设你有一个“黑盒”，它充当函数f:{0,1}ⁿ→{0,1}，也就是说，它以n位作为输入，输出1位，但你不知道这个函数是如何实现的，也不知道它的行为如何。您唯一知道的是，该函数只能有两种行为之一:该函数要么是常数，意味着它总是输出0或总是输出1，要么是平衡的，因此它对恰好一半的输入输出0，对另一半输入输出1。举个例子，假设我们有n=2，那么可能的输入是00，01，10，11。如果函数是常数，我们有:</p><ul class=""><li id="c9fb" class="jk jl hi ih b ii ij im in iq jm iu jn iy jo jc jp jq jr js bi translated">f(00)=f(01)=f(10)=f(11)=0或</li><li id="1541" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated">f(00)=f(01)=f(10)=f(11)=1</li></ul><p id="8f7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果函数是平衡的，我们有很多可能性，你可以在下面看到一些例子。</p><ul class=""><li id="7b71" class="jk jl hi ih b ii ij im in iq jm iu jn iy jo jc jp jq jr js bi translated">f(00)=f(01)=0且f(10)=f(11)=1或</li><li id="5c4b" class="jk jl hi ih b ii jt im ju iq jv iu jw iy jx jc jp jq jr js bi translated">f(00)=f(11)=0，f(01)=f(10)=1</li></ul><p id="bf6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Deutsch-Jozsa算法的目标是使用尽可能少的函数调用来确定函数是常数还是平衡的。要看量子算法如何优越，必须先看经典解。</p><h2 id="c0f3" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated"><strong class="ak">经典解:</strong></h2><p id="d8ed" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">经典解决方案的最佳情况是需要两次调用该函数。在这种情况下，第一个调用返回0，第二个调用返回1，反之亦然。这是真的，因为如果有两个不同的输出，那么功能必须平衡。</p><p id="5b2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，在最坏的情况下，我们需要对函数进行((2ⁿ÷2) +1)次调用。这是因为有可能前一半的调用将返回相同的值，所以如果下一个调用返回与前几个相同的值，那么f是常数，如果输出不同，那么f是平衡的。</p><h2 id="43c9" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated"><strong class="ak">量子解:</strong></h2><p id="3cb9" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">使用量子计算机来解决这个问题，我们可以通过一个简单的调用来解决它。因此很明显，即使n=1，量子解也更快，当我们增加输入的大小时，优势变得更大。那么，这怎么可能呢？</p><p id="1250" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一步是将函数f实现为一个量子预言，就像一个黑盒，这个预言将把输入|x⟩|y⟩映射到|x⟩|y ⊕ f(x)⟩.⊕符号表示模2加法，也称为异或。我们称之为oracle Uf。</p><p id="5cb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法的完整电路如下:</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ky"><img src="../Images/70c37bf2e4a2aebe7adbc77dd40bff99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l8-psWw0n7VfcCzG.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">Deutsch-Jozsa算法的量子电路。资料来源:qiskit.org</figcaption></figure><p id="d55e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以防你感到困惑，你看到的这个“⊗n”意味着这个动作发生在n个量子位中。这意味着有n个量子位被初始化为|0⟩，然后对它们应用n个哈达玛门。</p><p id="db58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解释正在发生的事情，在每一步中观察系统的状态将会很有趣。</p><ul class=""><li id="bee7" class="jk jl hi ih b ii ij im in iq jm iu jn iy jo jc jp jq jr js bi translated"><strong class="ih hj">第0步:</strong></li></ul><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lo"><img src="../Images/4a75fcbd9006b8dbe00806be06cf4f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/0*TsGzeyrMMX65cGl_"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">初态</figcaption></figure><ul class=""><li id="6507" class="jk jl hi ih b ii ij im in iq jm iu jn iy jo jc jp jq jr js bi translated"><strong class="ih hj">第一步(哈达玛节之后):</strong></li></ul><p id="658d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，可以很好地看到Hadamards对两个寄存器的影响，以及对整个系统的影响。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lp"><img src="../Images/09659f67d633088e88108af3224c0f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/0*qAq1jdTpnn5edlRG"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">Hadamard门应用于输入</figcaption></figure><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lq"><img src="../Images/e71c3c985fae5eec3d0862b178d94acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/0*ME9Suf9PbT94ji0v"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">阿达玛门应用于安西拉量子位</figcaption></figure><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lr"><img src="../Images/011ed2192c3f95a788c44913baf56155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SI-5jF9_b47Sa_Vo8iKFkQ.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">哈达玛门之后的结果状态</figcaption></figure><ul class=""><li id="8d85" class="jk jl hi ih b ii ij im in iq jm iu jn iy jo jc jp jq jr js bi translated"><strong class="ih hj">步骤2(Uf之后):</strong></li></ul><p id="19f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，在当前状态下，y = (|0⟩ -|1⟩).当应用U_f时，结果如下。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es ls"><img src="../Images/6cde0d1910c22ae6413020d7d2fc20ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/0*GBRxl1akhLCQ9NQi"/></div></figure><p id="385b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简化这种状态，请注意XOR的这些属性:</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lt"><img src="../Images/bd2dd7090ef64bedbb80af8ec3751e38.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/0*ietP707yFtK5L4aO"/></div></figure><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lu"><img src="../Images/92a5abf4f4dbc1f75792586819152198.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/0*xgW3ReBXk_-di8sQ"/></div></figure><p id="31a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这个，我们可以这样写:</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lv"><img src="../Images/b9886b39bccccac9becdcd6d5b309429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/0*IVh4pm3GO_QDUymO"/></div></figure><p id="9de3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使得有可能将这个术语重写为</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lw"><img src="../Images/a96acef7d69daf3b6d75d3403dd52437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/0*BH8o6Gb2TO_Iftcs"/></div></figure><p id="328f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导致国家</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lx"><img src="../Images/5ac174e5ea8bbb17855c3f2d6cc4a3c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/0*hAtky2WdOKZxC87q"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">U_f后的结果状态</figcaption></figure><ul class=""><li id="63ac" class="jk jl hi ih b ii ij im in iq jm iu jn iy jo jc jp jq jr js bi translated"><strong class="ih hj">步骤3(在最后一个哈达玛之后):</strong></li></ul><p id="0085" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们可以忽略第二个寄存器(ancilla量子位)，因为它不会被测量。这给我们留下了下面的状态。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es ly"><img src="../Images/51dcd9d8e820c17fbb6245031ee168ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/0*bCJVeH-rEUia4AFo"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">没有ancilla量子位的状态</figcaption></figure><p id="c8bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了理解下一步，我们可以把哈达玛门对一些state|x⟩的影响写成</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lz"><img src="../Images/802a207f4f3840cf68114353fa91258f.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/0*RoPHEcBkJpQjG9Hx"/></div></figure><p id="e3d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">x.y是位积，所以x.y=x₀y₀ ⊕ x₁y₁ ⊕ … ⊕xₙyₙ.也就是说，当哈达玛应用于to|ψ2⟩时，我们得到了我们的最终状态。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es ma"><img src="../Images/47e25dc56836228a13e3944380d0a0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/0*QzWmCeAjtUhe-1EB"/></div></figure><p id="f23e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，如果你想严格，那么最后一个操作的中间步骤是错误的，因为求和是|x⟩定义的一部分，哈达玛实际上也应用于它。但由于这不会影响结果，而且我相信这更容易理解所做的事情，所以我决定让它保持原样。</p><ul class=""><li id="18a9" class="jk jl hi ih b ii ij im in iq jm iu jn iy jo jc jp jq jr js bi translated"><strong class="ih hj">测量:</strong></li></ul><p id="eac9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是测量的时候了，这就是奇迹发生的地方。请注意，如果我们想要测量|00…0⟩状态，即|y⟩ = |00…0⟩，则此测量的概率由下式给出</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es mb"><img src="../Images/9b4798f6a496f6dff24f3b31417b7af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9duoMmFVkxa4isVOe54cA.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">注意:x.y=0，因为y的每一位都等于0。</figcaption></figure><p id="337a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，如你所见，如果我们测量一次结果，它等于|00…0⟩，那么我们肯定知道函数是常数，如果我们得到任何其他结果，那么函数是平衡的。因此，如前所述，我们使用了一次函数调用，而不是((2ⁿ÷2) +1)，这意味着该算法比经典算法要快得多。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="d99c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你已经知道了算法背后的理论，我们可以使用qiskit这样的平台来实现它，并在真正的量子计算机上进行尝试。我应该说下面的大部分代码都是基于qiskit文档[2]的，所以如果你想了解更多的信息，可以去看看。</p><h2 id="4a22" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated"><strong class="ak"> Qiskit实现:</strong></h2><p id="d916" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated"><strong class="ih hj">设置环境:</strong></p><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="206a" class="jy jz hi md b fi mh mi l mj mk">import numpy as np<br/>from qiskit import QuantumCircuit<br/>from qiskit.visualization import plot_histogram<br/>n=3 #size of the input</span><span id="1b23" class="jy jz hi md b fi ml mi l mj mk">from qiskit import IBMQ<br/>IBMQ.save_account("*token*")<br/>IBMQ.load_account()<br/>provider = IBMQ.get_provider("ibm-q")</span></pre><p id="547d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">创建Oracle: </strong></p><p id="d7bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以创建一个常数甲骨文或一个平衡。我将创建两个，只是为了让你知道他们看起来像什么。</p><ul class=""><li id="dfef" class="jk jl hi ih b ii ij im in iq jm iu jn iy jo jc jp jq jr js bi translated">常量Oracle:</li></ul><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="7c1d" class="jy jz hi md b fi mh mi l mj mk">const_oracle <strong class="md hj">=</strong> QuantumCircuit(n<strong class="md hj">+</strong>1)</span><span id="9523" class="jy jz hi md b fi ml mi l mj mk">output <strong class="md hj">=</strong> np<strong class="md hj">.</strong>random<strong class="md hj">.</strong>randint(2) #Randomly decides if f(x)=0 or f(x)=1<br/><strong class="md hj">if</strong> output <strong class="md hj">==</strong> 1:<br/>    const_oracle<strong class="md hj">.</strong>x(n)<br/>const_oracle<strong class="md hj">.</strong>draw()</span></pre><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es mm"><img src="../Images/78df2e9a6b4da2184d9dd20246018b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:168/format:webp/1*Wo3AVi6MUkQ1LfBzbdE4jg.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">常数oracle，其中f(x)=0</figcaption></figure><ul class=""><li id="00b9" class="jk jl hi ih b ii ij im in iq jm iu jn iy jo jc jp jq jr js bi translated">平衡的Oracle:</li></ul><p id="61ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">平衡预言是通过一些CNOT门实现的。此外，我们添加了一些非门，以改变控制量子位，使CNOT有一些影响。然而，NOT被应用了两次，所以控制量子位在Uf之后回到原始状态。</p><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="6f3a" class="jy jz hi md b fi mh mi l mj mk">balanced_oracle <strong class="md hj">=</strong> QuantumCircuit(n<strong class="md hj">+</strong>1)<br/>b_str <strong class="md hj">=</strong> "101" # This string simply determines the balance</span><span id="ace2" class="jy jz hi md b fi ml mi l mj mk"><em class="mn"># Place X-gates</em><br/><strong class="md hj">for</strong> qubit <strong class="md hj">in</strong> range(len(b_str)):<br/>    <strong class="md hj">if</strong> b_str[qubit] <strong class="md hj">==</strong> '1':<br/>        balanced_oracle<strong class="md hj">.</strong>x(qubit)</span><span id="7e4d" class="jy jz hi md b fi ml mi l mj mk"><em class="mn"># Use barrier as divider</em><br/>balanced_oracle<strong class="md hj">.</strong>barrier()</span><span id="400a" class="jy jz hi md b fi ml mi l mj mk"><em class="mn"># Controlled-NOT gates</em><br/><strong class="md hj">for</strong> qubit <strong class="md hj">in</strong> range(n):<br/>    balanced_oracle<strong class="md hj">.</strong>cx(qubit, n)</span><span id="3156" class="jy jz hi md b fi ml mi l mj mk">balanced_oracle<strong class="md hj">.</strong>barrier()</span><span id="1dac" class="jy jz hi md b fi ml mi l mj mk"><em class="mn"># Place X-gates to return qubits to original state</em><br/><strong class="md hj">for</strong> qubit <strong class="md hj">in</strong> range(len(b_str)):<br/>    <strong class="md hj">if</strong> b_str[qubit] <strong class="md hj">==</strong> '1':<br/>        balanced_oracle<strong class="md hj">.</strong>x(qubit)</span><span id="6e3d" class="jy jz hi md b fi ml mi l mj mk"><em class="mn"># Show oracle</em><br/>balanced_oracle<strong class="md hj">.</strong>draw()</span></pre><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es mo"><img src="../Images/636830c436973ecfbc59f14bae2ac396.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*l-CqIZ38ymf-RRIGw7MLWA.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">平衡Oracle</figcaption></figure><p id="ff44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">算法的其余部分:</strong></p><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="e612" class="jy jz hi md b fi mh mi l mj mk">dj_circuit <strong class="md hj">=</strong> QuantumCircuit(n<strong class="md hj">+</strong>1, n) </span><span id="53fc" class="jy jz hi md b fi ml mi l mj mk"><em class="mn"># Apply H-gates</em><br/><strong class="md hj">for</strong> qubit <strong class="md hj">in</strong> range(n):<br/>    dj_circuit<strong class="md hj">.</strong>h(qubit)</span><span id="2c69" class="jy jz hi md b fi ml mi l mj mk"><em class="mn"># Put ancilla qubit in state |-&gt;</em><br/>dj_circuit<strong class="md hj">.</strong>x(n)<br/>dj_circuit<strong class="md hj">.</strong>h(n)</span><span id="d8bb" class="jy jz hi md b fi ml mi l mj mk"><em class="mn"># Add oracle</em><br/>dj_circuit <strong class="md hj">+=</strong> balanced_oracle #You can change for constant oracle</span><span id="4c17" class="jy jz hi md b fi ml mi l mj mk"><em class="mn"># Repeat H-gates</em><br/><strong class="md hj">for</strong> qubit <strong class="md hj">in</strong> range(n):<br/>    dj_circuit<strong class="md hj">.</strong>h(qubit)<br/>dj_circuit<strong class="md hj">.</strong>barrier()</span><span id="5392" class="jy jz hi md b fi ml mi l mj mk"><em class="mn"># Measure</em><br/><strong class="md hj">for</strong> i <strong class="md hj">in</strong> range(n):<br/>    dj_circuit<strong class="md hj">.</strong>measure(i, i)</span><span id="7fd3" class="jy jz hi md b fi ml mi l mj mk"><em class="mn"># Display circuit</em><br/>dj_circuit<strong class="md hj">.</strong>draw()</span></pre><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es mp"><img src="../Images/25d2c245ea6bd83c3289a4e6c3ed94e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*_KYs252rKh4KSBWqD9H8uw.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">全Deutsch-Jozsa算法电路</figcaption></figure><p id="d9ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:电路是用n+1个量子位创建的，因为我们有一个安西拉量子位，初始化为|1⟩.另外，请注意，您可以使用+=运算将oracle附加到此电路，因此您在完整电路中看到的NOTs是Oracle的一部分，而不是外部电路的一部分。</p><p id="1c41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果:</strong></p><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="d16c" class="jy jz hi md b fi mh mi l mj mk">from qiskit import execute<br/>backend = provider.get_backend("ibmq_quito")<br/>job = execute(dj_circuit, backend=backend, shots=500)<br/>result = job.result()<br/>answer = result.get_counts()<br/>plot_histogram(answer)</span></pre><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es mq"><img src="../Images/cf3872a702e874afdfeed024660372f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*o0J3aZTxxU82QI8btqjXRQ.png"/></div></figure><p id="7b28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，仍然有很小的概率得到000的结果，但这是由于在真实的量子计算机上出现的一些噪声，比如执行算法的计算机。这意味着预期结果不是000，意味着函数是平衡的，这是正确的。如果您愿意，您可以切换oracles并检查结果是否仍然正确。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="88b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管这是超越经典算法的第一个算法，但它的好处并不真正有用，因为它解决的问题不是我们需要经常解决的。所以，尽管这证明了量子计算机可以胜过经典计算机，但还有其他算法也可以做到这一点，而且还可以解决有用和有趣的问题，如Grover的算法和Shor的算法。除了算法，其他领域也可以利用这项技术，比如机器学习和化学。</p><p id="c35f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">综上所述，我相信可以有把握地说量子计算机不仅仅是炒作，而且在不久的将来将会给我们带来真正的好处。</p><h2 id="dac6" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">参考资料:</h2><p id="c75f" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">[1]大卫·多伊奇和理查德·乔萨(1992)。“通过量子计算快速解决问题”。伦敦皇家学会会议录a . 439:553–558。<a class="ae mr" href="https://doi.org/10.1098%2Frspa.1992.0167" rel="noopener ugc nofollow" target="_blank">doi:10.1098/rspa . 1992.0167</a></p><p id="9ce6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[2] <a class="ae mr" href="https://qiskit.org/textbook/ch-algorithms/deutsch-jozsa.html" rel="noopener ugc nofollow" target="_blank"> Qiskit关于Deutsch-Jozsa算法的教材</a></p></div></div>    
</body>
</html>