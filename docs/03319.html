<html>
<head>
<title>Dive Deep into TiKV Transactions: The Life Story of a TiKV Prewrite Request</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入探究TiKV事务:TiKV预写请求的生活故事</h1>
<blockquote>原文：<a href="https://medium.com/codex/dive-deep-into-tikv-transactions-the-life-story-of-a-tikv-prewrite-request-242a764719cb?source=collection_archive---------24-----------------------#2021-08-27">https://medium.com/codex/dive-deep-into-tikv-transactions-the-life-story-of-a-tikv-prewrite-request-242a764719cb?source=collection_archive---------24-----------------------#2021-08-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/800c4675bf6e091a8c60872a089b21de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-WfgGIQ6ZA8qoUKK.png"/></div></div></figure><p id="2c97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">作者:</strong> <a class="ae jo" href="https://github.com/zhongzc" rel="noopener ugc nofollow" target="_blank">钟振池</a>(软件工程师实习生)</p><p id="824e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Transcreator: </strong> <a class="ae jo" href="https://github.com/CharLotteiu" rel="noopener ugc nofollow" target="_blank">夏洛特刘</a>；编辑:汤姆·万德</p><p id="89ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://tikv.org/" rel="noopener ugc nofollow" target="_blank"> TiKV </a>是一个分布式键值存储引擎，基于Google Spanner、F1和HBase的设计。然而，TiKV管理起来要简单得多，因为它不依赖于分布式文件系统。</p><p id="1fc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如在<a class="ae jo" href="https://pingcap.com/blog/2016-11-09-Deep-Dive-into-TiKV#transaction" rel="noopener ugc nofollow" target="_blank">深入探究TiKV </a>和<a class="ae jo" href="https://pingcap.com/blog/how-tikv-reads-and-writes#percolator" rel="noopener ugc nofollow" target="_blank">TiKV如何读写</a>中所介绍的，TiKV应用了受<a class="ae jo" href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36726.pdf" rel="noopener ugc nofollow" target="_blank"> Google Percolator </a>启发的两阶段提交(2PC)算法来支持分布式事务。这两个阶段是<code class="du jp jq jr js b">Prewrite</code>和<code class="du jp jq jr js b">Commit</code>。</p><p id="22f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我将探索预写阶段TiKV请求的执行工作流，并给出一个自顶向下的描述，说明如何在<a class="ae jo" href="https://docs.pingcap.com/tidb/stable/glossary#regionpeerraft-group" rel="noopener ugc nofollow" target="_blank">区域</a>领导者的多个模块中执行<a class="ae jo" href="https://docs.pingcap.com/tidb/stable/optimistic-transaction" rel="noopener ugc nofollow" target="_blank">乐观事务</a>的预写请求。这些信息将帮助您澄清TiKV请求的资源使用情况，并了解TiKV中相关的源代码。</p><h1 id="3ff0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">工作模型</h1><p id="3958" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">当TiKV初始化时，它会根据自己的配置创建不同类型的工作线程。一旦创建了这些工作线程，它们就在一个循环中不断地获取和执行任务。这些工作线程通常与关联的任务队列成对出现。因此，通过向不同的任务队列提交不同的任务，可以异步执行一些流程。下图简单说明了这种工作模式:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/853db95c957f7d6235121a1d4df11643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0MTDyqBcFXm0ZQ2b.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">TiKV工作线程的工作模型</figcaption></figure><h1 id="28b5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">gRPC请求阶段</h1><p id="b044" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">TiKV预写请求以出现在gRPC服务器线程上的来自网络的gRPC预写请求开始。下图显示了此阶段的工作流。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ffd3ec943ad2153ece62d190e05e88d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZOLs3hQfyfAKVko0.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">gRPC服务器线程工作流</figcaption></figure><p id="6fdd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">光看图可能不太容易理解，所以下面我将一步一步地具体描述gRPC线程是做什么的。每个步骤链接到相应源代码的编号:</p><ul class=""><li id="1d76" class="le lf hi is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/server/service/kv.rs#L1791" rel="noopener ugc nofollow" target="_blank"> 1 </a>:将预写的protobuf消息转换成事务层可以理解的<a class="ae jo" href="https://github.com/tikv/tikv/blob/5024ad08fc7101ba25f17c46b0264cd27d733bb1/src/storage/mod.rs#L70" rel="noopener ugc nofollow" target="_blank">突变</a>。突变表示一个键的写操作。</li><li id="166a" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/server/service/kv.rs#L1790" rel="noopener ugc nofollow" target="_blank"> 2 </a>:创建一个通道，并使用通道发送者构造一个gRPC通知回调。</li><li id="9e02" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">第<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/server/service/kv.rs#L150" rel="noopener ugc nofollow" target="_blank"> 3 </a>步:将通道接收方构造为gRPC响应任务，并提交给gRPC任务队列等待通知。</li><li id="9f68" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/storage/txn/scheduler.rs#L329" rel="noopener ugc nofollow" target="_blank"> 4 </a>:将gRPC通知回调和突变合并为一个事务任务。</li><li id="cbd1" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/storage/txn/scheduler.rs#L330" rel="noopener ugc nofollow" target="_blank"> 5 </a>:获取事务层的闩锁，并将gRPC通知回调存储在事务任务槽中。</li><li id="be1f" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/storage/txn/scheduler.rs#L333-L335" rel="noopener ugc nofollow" target="_blank"> 6 </a>:一旦事务层成功获得锁存，gRPC服务器线程继续执行带有唯一<code class="du jp jq jr js b">cid</code>的任务，该任务可用于索引gRPC通知回调。在预写请求的整个执行过程中，<code class="du jp jq jr js b">cid</code>是全局唯一的。</li><li id="e5af" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/storage/txn/scheduler.rs#L366-L404" rel="noopener ugc nofollow" target="_blank"> 7 </a>:为Raft层构造快照回调。这个回调由<code class="du jp jq jr js b">cid</code>、突变和事务调度器组成。</li><li id="f430" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤8: <a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/server/raftkv.rs#L421-L427" rel="noopener ugc nofollow" target="_blank">创建</a>Raft读索引请求，并且<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/worker/read.rs#L538" rel="noopener ugc nofollow" target="_blank">将</a>该请求与快照回调相结合以形成Raft命令。</li><li id="a18a" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/worker/read.rs#L377" rel="noopener ugc nofollow" target="_blank"> 9 </a>:发送Raft命令给它所属的对等体。</li></ul><p id="fb70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">gRPC线程已经完成了它的任务。故事的其余部分将在raftstore线程中继续。</p><h1 id="9c18" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">读取建议阶段</h1><p id="e01c" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">在介绍这个阶段之前，我想先说一下<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce1717/components/batch-system/Cargo.toml" rel="noopener ugc nofollow" target="_blank">批处理系统</a>。它是TiKV多筏实现的基石。</p><p id="bd5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在TiKV中，raftstore线程和apply线程是批处理系统的实例。这两个工作线程也以固定的循环模式运行，这符合上面提到的工作模型。</p><p id="c639" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">raftstore线程和apply线程在一个循环中经历三个阶段:收集消息阶段、处理消息阶段和处理I/O阶段。以下部分详细描述了这些阶段。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f6cfe7887b04caa56949920c0274405a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DX9MOaz3goWzXr41.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">批处理系统工作模式</figcaption></figure><p id="2179" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，让我们回到故事上来。</p><p id="01b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当Raft命令被发送到它所属的对等体时，该命令被存储在对等体的邮箱中。在收集消息阶段(上面圆圈的绿色部分)，raftstore线程收集邮箱中有消息的几个对等体，并在处理消息阶段(圆圈的紫色部分)一起处理它们。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0692b276b6188193750263dc56305f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OUsXDskt6DYg-stW.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">阅读建议阶段工作流程</figcaption></figure><p id="9a84" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个预写请求示例中，带有Raft读索引请求的Raft命令存储在对等方的邮箱中。在raftstore线程在步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/batch-system/src/batch.rs#L278" rel="noopener ugc nofollow" target="_blank"> 1 </a>收集对等体之后，raftstore线程进入处理消息阶段。</p><p id="f87d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是raftstore线程在处理消息阶段执行的相应步骤:</p><ul class=""><li id="21fa" class="le lf hi is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/fsm/store.rs#L802-L827" rel="noopener ugc nofollow" target="_blank"> 2 </a>:从对方邮箱中读取Raft命令。</li><li id="2f7b" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/fsm/peer.rs#L508" rel="noopener ugc nofollow" target="_blank"> 3 </a>:将Raft命令分成Raft读索引请求和快照回调。</li><li id="1f80" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/peer.rs#L2716-L2721" rel="noopener ugc nofollow" target="_blank"> 4 </a>:将Raft读索引请求交给raft-rs库，由<code class="du jp jq jr js b">step</code>函数处理。</li><li id="7dc1" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/raft-rs/blob/91a60ce417d55d4ca4d96b29963e3e3fa7f7d8d7/src/raft.rs#L1907-L1942" rel="noopener ugc nofollow" target="_blank">5</a>:raft-RS库准备好要发送的网络消息，并保存在消息缓冲区中。</li><li id="a233" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/peer.rs#L2737" rel="noopener ugc nofollow" target="_blank"> 6 </a>:将快照回调存储在对等体的挂起读取队列中。</li><li id="4945" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">第<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/batch-system/src/batch.rs#L295-L314" rel="noopener ugc nofollow" target="_blank"> 7 </a>步:返回到该阶段的开始，处理其他具有相同工作流的对等体。</li></ul><p id="9c61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在raftstore线程处理完所有对等体的消息后，它进入了单个循环的最后一个阶段:处理I/O阶段(圆圈的蓝色部分)。在这个阶段，在步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/server/raft_client.rs#L910-L932" rel="noopener ugc nofollow" target="_blank"> 8 </a>中，raftstore线程通过网络接口将存储在消息缓冲器中的网络消息发送到集群的其他TiKV节点。</p><p id="8fac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“读取建议”阶段到此结束。在预写请求取得进展之前，它必须等待其他TiKV节点做出响应。</p><h1 id="a0d6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">读取应用阶段</h1><p id="7fad" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">经过“长时间”的等待(对于计算机来说，几毫秒实际上是很长的时间)，发送网络消息的TiKV节点最终接收到来自其他追随者节点的响应，并将回复消息保存在对等方的邮箱中。现在，预写请求进入读取应用阶段。下图显示了此阶段的工作流程:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/500d285919c2db27927b27e4c3ed7ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MILhrcD03E7dtwRN.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">阅读应用阶段工作流</figcaption></figure><p id="6db7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">努力工作的raftstore线程注意到在这个对等体的邮箱中有一个消息等待处理，因此线程在这个阶段的行为如下:</p><ul class=""><li id="2db3" class="le lf hi is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/batch-system/src/batch.rs#L278" rel="noopener ugc nofollow" target="_blank"> 1 </a>:当循环回到收集消息阶段时，再次收集对等体。</li><li id="2cb0" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/fsm/store.rs#L802-L827" rel="noopener ugc nofollow" target="_blank"> 2 </a>:与上一阶段相同，线程从对方邮箱中读取回复消息。</li><li id="d879" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/fsm/peer.rs#L1230" rel="noopener ugc nofollow" target="_blank"> 3 </a>:将消息传递给raft-rs，由<code class="du jp jq jr js b">step</code>函数处理。</li><li id="8bfb" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/peer.rs#L2078-L2080" rel="noopener ugc nofollow" target="_blank"> 4 </a>:识别消息处理后可以应用哪些读操作，并收集操作。</li><li id="1dc9" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/peer.rs#L1975" rel="noopener ugc nofollow" target="_blank"> 5 </a>:调用快照回调，这些快照回调临时存储在对等体的挂起读取队列中。</li><li id="b934" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/worker/read.rs#L105-L110" rel="noopener ugc nofollow" target="_blank"> 6 </a>:构造KV引擎的快照并发送给快照回调。</li><li id="26ba" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/storage/txn/scheduler.rs#L559-L594" rel="noopener ugc nofollow" target="_blank"> 7 </a>:将快照回调拆分成由快照、<code class="du jp jq jr js b">cid</code>和突变组成的事务调度器和任务。然后，raftstore线程根据事务调度器记录的信息将任务发送给事务工作线程。</li></ul><p id="f54f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">读取应用阶段到此结束。接下来，轮到事务工作者了。</p><h1 id="131e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">写准备阶段</h1><p id="b0fa" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">在这个阶段，当调度工作器池中的事务工作器在步骤<a class="ae jo" href="https://github.com/tikv/yatp/blob/6bbea16a485583d7a6e32de335f6c6ec448df44a/src/pool/worker.rs#L44" rel="noopener ugc nofollow" target="_blank"> 1 </a>接收到由raftstore线程发送的任务时，该工作器在步骤<a class="ae jo" href="https://github.com/tikv/yatp/blob/6bbea16a485583d7a6e32de335f6c6ec448df44a/src/task/future.rs#L261" rel="noopener ugc nofollow" target="_blank"> 2 </a>通过将任务分割成KV快照、突变和<code class="du jp jq jr js b">cid</code>开始处理该任务。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b1967c096c2360284043fe266fd908f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2-XpjtAX4sp3XYyV.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">编写准备阶段工作流</figcaption></figure><p id="8611" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，事务层的主要逻辑开始发挥作用。它包括由事务工作线程执行的以下步骤:</p><ul class=""><li id="4f20" class="le lf hi is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/storage/txn/actions/prewrite.rs#L45-L86" rel="noopener ugc nofollow" target="_blank"> 3 </a>:通过快照读取KV引擎，并检查事务约束是否成立。</li><li id="4a99" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/storage/txn/actions/prewrite.rs#L88" rel="noopener ugc nofollow" target="_blank"> 4 </a>:检查通过后，为预写请求准备要写入的数据。</li><li id="bf31" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/server/raftkv.rs#L261-L263" rel="noopener ugc nofollow" target="_blank"> 5 </a>:将数据封装成一个普通的Raft请求。</li><li id="370c" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/storage/txn/scheduler.rs#L726-L745" rel="noopener ugc nofollow" target="_blank"> 6 </a>:用<code class="du jp jq jr js b">cid</code>准备一个新的写回调。</li><li id="cc5c" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/router.rs#L50-L55" rel="noopener ugc nofollow" target="_blank"> 7 </a>:将带有普通Raft请求的回调组装成Raft命令。</li><li id="b03e" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/router.rs#L53" rel="noopener ugc nofollow" target="_blank"> 8 </a>:向所属的对等体提出命令。</li></ul><p id="9d08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事务层逻辑到此结束。这个Raft命令包含写操作。如果命令运行成功，则预写请求成功。</p><h1 id="4004" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">写建议阶段</h1><p id="f40d" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">现在是raftstore线程提出写操作的时候了。下图显示了raftstore线程在这个阶段如何处理Raft命令。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b149a59aa48fbbf857e378e144c27576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DwqldJtUFkx_Fg7S.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">编写提议阶段工作流</figcaption></figure><p id="d78a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个阶段的前三个步骤与前面几节中的步骤相同。这里就不赘述了。让我们来完成剩下的步骤:</p><ul class=""><li id="f374" class="le lf hi is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/raft-rs/blob/91a60ce417d55d4ca4d96b29963e3e3fa7f7d8d7/src/raw_node.rs#L324-L333" rel="noopener ugc nofollow" target="_blank"> 4 </a> : raft-rs将net报文保存到报文缓冲区。</li><li id="a1cc" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/raft-rs/blob/91a60ce417d55d4ca4d96b29963e3e3fa7f7d8d7/src/raft.rs#L1895-L1904" rel="noopener ugc nofollow" target="_blank"> 5 </a> : raft-rs将raft日志附加到写批处理中。</li><li id="e2a4" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/peer.rs#L2307-L2320" rel="noopener ugc nofollow" target="_blank"> 6 </a>:对等体将写回调转移到一个提议，并将其存储在对等体的内部提议队列中。</li><li id="f1e5" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/batch-system/src/batch.rs#L295-L314" rel="noopener ugc nofollow" target="_blank">7</a>:raftstore线程返回处理邮箱中有消息的其他对等体。</li><li id="79a8" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/fsm/store.rs#L648-L666" rel="noopener ugc nofollow" target="_blank">8</a>:raftstore线程进入流程I/O阶段(圆圈的蓝色部分)，将暂时存储在写入批处理中的消息写入Raft引擎。</li><li id="46bd" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤Raft引擎返回消息被成功写入。</li><li id="138c" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/server/raft_client.rs#L910-L932" rel="noopener ugc nofollow" target="_blank">10</a>:raftstore线程向其他存储节点发送网络消息。</li></ul><p id="f952" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">写建议阶段已经结束。现在，随着Read Propose阶段的结束，leader节点必须等待来自其他TiKV节点的响应，然后才能进入下一个阶段。</p><h1 id="8b23" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">写提交阶段</h1><p id="7355" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">在另一个“长时间”等待之后，从节点响应领导节点，并将预写请求带入写提交阶段。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b2d5e4c0b17787d58d26c73e7983fa73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HuWmFndeG72oQi0n.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">写提交阶段工作流</figcaption></figure><ul class=""><li id="c0f2" class="le lf hi is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/fsm/store.rs#L802-L827" rel="noopener ugc nofollow" target="_blank"> 2 </a>:对等体接收来自其他TiKV节点的Raft附加响应。</li><li id="7e64" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/raft-rs/blob/91a60ce417d55d4ca4d96b29963e3e3fa7f7d8d7/src/raft.rs#L1534-L1626" rel="noopener ugc nofollow" target="_blank"> 3 </a>:步骤函数处理响应消息。</li><li id="55ff" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/peer_storage.rs#L749-L799" rel="noopener ugc nofollow" target="_blank"> 4 </a>、<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/peer_storage.rs#L749-L799" rel="noopener ugc nofollow" target="_blank"> 5 </a>和<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/peer_storage.rs#L749-L799" rel="noopener ugc nofollow" target="_blank">6</a>:raftstore线程从Raft引擎收集提交的Raft条目。</li><li id="165d" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/peer.rs#L1858-L1879" rel="noopener ugc nofollow" target="_blank">7</a>:raftstore线程从内部提议队列中收集与提交的Raft条目相关的提议。</li><li id="dbd6" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/peer.rs#L1880-L1886" rel="noopener ugc nofollow" target="_blank">8</a>:raftstore线程将Raft提交的条目和相关的提议组装到一个应用任务中。</li><li id="c627" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/peer.rs#L1887-L1888" rel="noopener ugc nofollow" target="_blank">9</a>:raftstore线程将任务发送给apply线程。</li></ul><p id="4acf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">随着写提交阶段的结束，raftstore线程完成了它的所有任务。接下来，接力棒被交给应用线程。</p><h1 id="7989" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">写应用阶段</h1><p id="1d6e" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">对于预写请求来说，这是最关键的阶段，在这个阶段，线程实际上向KV引擎写入数据。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c9edf2301a3232a2b57d61916d416336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lXcZaz-RknbTzw81.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">编写应用阶段工作流</figcaption></figure><p id="0d11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在步骤1和2中，应用线程接收到由raftstore线程发送的应用任务后，它在处理消息阶段(圆圈的紫色部分)继续执行以下步骤:</p><ul class=""><li id="1f63" class="le lf hi is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/fsm/apply.rs#L3067" rel="noopener ugc nofollow" target="_blank"> 3 </a>:从任务中读取提交的Raft条目。</li><li id="4db3" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/fsm/apply.rs#L1310-L1344" rel="noopener ugc nofollow" target="_blank"> 4 </a>:将条目转换成键值对，并将键值对存储到写批处理中。</li><li id="1a87" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/fsm/apply.rs#L1086" rel="noopener ugc nofollow" target="_blank"> 5 </a>:从任务中读取提议，并将它们存储为回调。</li></ul><p id="c50c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，在下一阶段(进程I/O)，应用线程采取以下步骤:</p><ul class=""><li id="6808" class="le lf hi is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/fsm/apply.rs#L464-L483" rel="noopener ugc nofollow" target="_blank"> 6 </a>:将写批处理中的键值对写入KV引擎。</li><li id="4c64" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤7:接收KV引擎返回的关于写操作是否成功的结果。</li><li id="d131" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/components/raftstore/src/store/fsm/apply.rs#L495-L497" rel="noopener ugc nofollow" target="_blank"> 8 </a>:调用所有回调。</li></ul><p id="53b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当调用回调时，事务调度器在步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/storage/txn/scheduler.rs#L727-L744" rel="noopener ugc nofollow" target="_blank"> 9 </a>将带有<code class="du jp jq jr js b">cid</code>的任务发送给事务工作器，将我们带到故事的最后部分。</p><h1 id="feda" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">回归阶段</h1><p id="4317" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">这是预写过程的最后阶段。TiKV向客户端返回预写请求的执行结果。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5ef2e14591c38115a816d96d72bb0ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BF7y7BpbjTm2odAf.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">退货阶段工作流程</figcaption></figure><p id="ce74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此阶段的工作流主要由事务工作者执行:</p><ul class=""><li id="aabe" class="le lf hi is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/storage/txn/scheduler.rs#L731-L739" rel="noopener ugc nofollow" target="_blank"> 1 </a>:事务工作器获取事务调度器发送的<code class="du jp jq jr js b">cid</code>。</li><li id="c6f9" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/storage/txn/scheduler.rs#L493" rel="noopener ugc nofollow" target="_blank"> 2 </a>:事务工作者使用<code class="du jp jq jr js b">cid</code>访问互斥的事务任务槽。</li><li id="9caa" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/storage/txn/scheduler.rs#L498" rel="noopener ugc nofollow" target="_blank"> 3 </a>:在gRPC请求阶段，事务工作者获取存储在事务任务槽中的gRPC通知回调。</li><li id="07e2" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤<a class="ae jo" href="https://github.com/tikv/tikv/blob/6708ce171792df02e1e90e1fe1e67e424d1586c8/src/storage/txn/scheduler.rs#L509" rel="noopener ugc nofollow" target="_blank"> 4 </a>:事务工作者向gRPC任务队列中等待的gRPC响应任务发送通知。</li><li id="b27e" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">步骤gRPC服务器线程用成功结果响应客户机。</li></ul><h1 id="cd9f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="9875" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">本文介绍了成功的预写请求的八个阶段，并重点介绍了每个阶段中的工作流程。希望这篇帖子可以帮助你理清TiKV请求的资源使用情况，让你对TiKV有更深入的了解。</p><p id="b4e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有关TiKV实施的更多细节，请参见<a class="ae jo" href="https://tikv.org/docs/3.0/concepts/overview/" rel="noopener ugc nofollow" target="_blank"> TiKV文档</a>和<a class="ae jo" href="https://tikv.org/deep-dive/introduction/" rel="noopener ugc nofollow" target="_blank">深入探讨</a>。如果您有任何问题或想法，欢迎加入<a class="ae jo" href="https://tikv.github.io/sig-transaction/" rel="noopener ugc nofollow" target="_blank"> TiKV交易SIG </a>与我们分享！</p></div><div class="ab cl ls lt gp lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hb hc hd he hf"><p id="c8dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lz">原载于2021年6月24日</em><a class="ae jo" href="https://en.pingcap.com/blog/tikv-prewrite-request-life-story" rel="noopener ugc nofollow" target="_blank"><em class="lz">www.pingcap.com</em></a>T22</p></div></div>    
</body>
</html>