<html>
<head>
<title>Things I’ve learned building a Drag &amp; Drop component with Svelte</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我学到了用Svelte构建拖放组件</h1>
<blockquote>原文：<a href="https://medium.com/codex/things-ive-learned-building-a-drag-drop-component-with-svelte-2ad9169f1aff?source=collection_archive---------5-----------------------#2021-08-09">https://medium.com/codex/things-ive-learned-building-a-drag-drop-component-with-svelte-2ad9169f1aff?source=collection_archive---------5-----------------------#2021-08-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="def9" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">我学到了用Svelte构建拖放组件</h1><p id="9671" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你好！我是<a class="ae kb" href="http://tubloo.com" rel="noopener ugc nofollow" target="_blank"> Tubloo </a>的一名像素推广员，我们正在那里建立一个在线视频制作商。在UI方面，我们一直在努力解决的一个问题是拖放组件。我们有一些独特的要求:</p><ul class=""><li id="4cab" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka kj kk kl km bi translated">允许一次拖动多个项目</li><li id="5674" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">支持垂直列表、水平列表以及二维网格</li><li id="2d48" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">虚拟化开箱即用，因为我们可能会在这些列表中获得数百个项目</li><li id="d22f" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">流畅和爽快(这是必须的，因为我们是一个视频应用程序！)</li><li id="7016" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">能够通过向列表边缘拖动来滚动列表</li><li id="9574" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">我们不需要拖放列表，因为在我们的应用程序中，每种类型的列表永远不会超过一个。</li></ul><p id="d207" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">不幸的是，我们找不到合适的组件，所以我们决定自己创建一个。毕竟，这能有多难呢？</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="9fc6" class="le ig hi la b fi lf lg l lh li">      ||||||||||||||||||||||||||<br/>    ||            +             ||<br/>  ||             +++              ||<br/>  ||              +               ||<br/>  ||            R.I.P             ||<br/>  ||         1990 - 20xx          ||<br/>  ||                              ||<br/>  ||   "How Difficult Could It    ||<br/>  ||        Possibly Be?"         ||<br/>  ||                              ||<br/>  ==================================</span></pre><p id="bbdf" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">经过多次试验，我们得出了这个结论:</p><figure class="kv kw kx ky fd lj"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="6ba9" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">该组件还没有准备好公开发布，但是我们已经在生产中部署了它，并对其进行了改进。一旦足够好，我们将开源组件。如果你感兴趣，请关注我的<a class="ae kb" href="https://twitter.com/DerekNguyen10" rel="noopener ugc nofollow" target="_blank">推特账号</a>。</p><p id="723d" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">在那之前，这是我学到的教训:</p><h1 id="cf5c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">1.本机拖动事件似乎不能很好地处理这种交互</h1><p id="d21f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我在这里措辞有点小心，因为不是原生API不好，很可能我只是…不好。我以前使用过这些事件进行文件上传&amp;它们非常棒。然而，这里有一些我在使用本地拖动事件时遇到的问题(例如，ondragstart、ondragend等)。)对于拖放交互:</p><ul class=""><li id="2a43" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka kj kk kl km bi translated">如果列表的容器没有“ondrag”处理程序，则“ondrag”和“ondragend”之间会有一个滞后，其中位置被重置为[0，0]，从而导致奇怪的动画。</li><li id="868e" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">Firefox不会将指针位置传递给ondrag处理程序，句号。</li><li id="11cd" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">有些情况下，即使没有拖动任何东西，我的主组件也想知道当前的指针位置(例如，在悬停时在列表项之间显示一个按钮<em class="lm">)。)</em></li></ul><p id="58f5" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">最后，我用<code class="du ln lo lp la b">onmousedown</code>和<code class="du ln lo lp la b">onmouseup</code>实现了一个自定义的拖动动作。我在窗口&amp;上附加了一个<code class="du ln lo lp la b">mousemove</code>处理程序来跟踪组件的全局状态。这样，指针的位置总是为组件所知。不可思议的是，这似乎不会在每次鼠标移动时触发重新渲染！</p><p id="675c" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">自定义事件的工作方式如下:</p><ol class=""><li id="8c8d" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka lq kk kl km bi translated">在mousedown时，立即将mouseup (A)事件附加到<em class="lm">文档</em></li><li id="c9e9" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka lq kk kl km bi translated">调用async <code class="du ln lo lp la b">dragUntil(x)</code>函数，当光标移动了至少x个像素时进行解析。</li><li id="374a" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka lq kk kl km bi translated">如果在承诺解决之前<em class="lm">触发了mouseup (A ),取消承诺&amp;移除自身。</em></li><li id="d9e9" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka lq kk kl km bi translated">如果承诺得到解决，则移除mouseup (A)并附加一个新的mouseup (B)作为<code class="du ln lo lp la b">ondragend</code>事件。</li><li id="6cbb" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka lq kk kl km bi translated">在mouseup (B)中，移除自身。</li></ol><p id="0d17" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">效果出奇的好！直到我们把它投入生产，并收到各种各样的'鬼'点击项目。当用户释放光标以完成拖动事件时，它还会在拖动的项目上注册一次单击，从而导致意外的UI更改。</p><p id="f225" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">再多的<code class="du ln lo lp la b">stopPropagation()</code>或<code class="du ln lo lp la b">capture: true</code>也无济于事。我都快气炸了(顺便说一句，我这么做是为了别的事)，直到我意识到这两个<code class="du ln lo lp la b">mouseup</code>事件都是附加在<em class="lm">文档</em>上的，而不是项目本身。因为光标可以移动到项目边界之外，所以项目的<code class="du ln lo lp la b">mouseup</code>事件不会被触发。</p><p id="7596" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">因此，解决方案是附加一个诱饵<code class="du ln lo lp la b">mouseup</code> / <code class="du ln lo lp la b">click</code>事件，在捕获阶段阻止传播。</p><ol class=""><li id="203a" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka lq kk kl km bi translated">在mousedown上，立即将mouseup (A)事件附加到<em class="lm">文档</em>上，并将带有 <code class="du ln lo lp la b"><strong class="jf hj">e.stopPropagation()</strong></code> <strong class="jf hj">的mouseup附加到<em class="lm">项目</em> </strong>上</li><li id="e85e" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka lq kk kl km bi translated">如果mouseup (A)事件在承诺解决之前<em class="lm">被触发，取消它，移除它自己<strong class="jf hj">和mouseup </strong>。</em></li><li id="d7ab" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka lq kk kl km bi translated">和以前一样</li><li id="69b8" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka lq kk kl km bi translated">在mouseup (B)中，移除自身<strong class="jf hj">和mouseup </strong>。</li></ol><p id="474a" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">但是，鬼咔嚓声还是发生了！结果是在mouseup (B)过程中，诱饵mouseup在幽灵点击之前被移除。最终修复该问题的方法是将mouseup的删除安排在事件队列的末尾:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="61fb" class="le ig hi la b fi lf lg l lh li">setTimeout(() =&gt; {<br/>	el.removeEventListener('mouseup', handleElementMouseUp, true)<br/>}, 0)</span></pre><h1 id="b2f0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">2.分离布局和拖动逻辑</h1><p id="8256" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如上所述，我们的拖动组件需要处理垂直列表、水平列表和2d网格。我们所有的列表目前都有统一的项目大小，但我们可能希望在未来改变这一点。对于支持所有这些用例的组件，拖动逻辑必须与布局无关(垂直、水平、网格)。</p><p id="af79" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我把所有的布局计算放进一个叫做“策略”的文件里。他们将回答基本的布局问题:</p><ul class=""><li id="cc10" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka kj kk kl km bi translated">知道了项目的高度和索引，它在列表中的[x，y]位置是什么？</li><li id="ad2f" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">知道一个条目在列表中的位置，它的索引是什么？但也有更有趣的:</li><li id="afc5" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">当拖动一个项目时&amp;光标在容器的一个边缘，知道光标的位置，容器应该向哪个方向滚动&amp;滚动多快？</li><li id="8caf" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">知道了列表容器的可见区域，可见项的索引是什么？</li></ul><p id="6e63" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">垂直“战略”可能看起来有点像这样:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="fe81" class="le ig hi la b fi lf lg l lh li">const place = ({ index, itemDimension }) =&gt; {<br/>	const itemHeight = itemDimension[1]<br/>	const y = itemHeight * index<br/>	return [0, y]<br/>}</span><span id="a940" class="le ig hi la b fi lr lg l lh li">const unplace = ({ cursorPosition, itemDimension }) =&gt; {<br/>	const y = cursorPosition[1]<br/>	const itemHeight = itemDimension[1]<br/>  return Math.round(y / itemHeight)<br/>}</span><span id="ba90" class="le ig hi la b fi lr lg l lh li">/* etc etc */</span></pre><p id="ea6a" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">到目前为止，这种结构工作得很好&amp;我认为当我们达到这一点时，为可变大小的列表传递类似位置缓存的东西不会太难。</p><h1 id="1609" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">3.设计一个灵活但又不太老套的API</h1><h1 id="0f51" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">尝试#1</h1><p id="9c4d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在我的第一次尝试中，我试图将我们现有的组件从React移植到Svelte，它使用了function props模式:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="62ea" class="le ig hi la b fi lf lg l lh li">&lt;Sorter data={data} {...otherProps}&gt;<br/>  {({ item, order, isDragging }) =&gt; &lt;MyListItem {...{ item, order, isDragging }} /&gt;}<br/>&lt;/Sorter&gt;</span></pre><p id="e277" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">在研究了两天两夜的文档后，我想到了这个(已经告诉我是哪种开发人员了，是吗？):</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="84ae" class="le ig hi la b fi lf lg l lh li">import Sorter from './Sorter.svelte'<br/>import MyListItem from './MyListItem.svelte'</span><span id="d8dd" class="le ig hi la b fi lr lg l lh li">&lt;Sorter {data} template={MyListItem} templateProps={{ foo: 'bar' }} /&gt;</span><span id="46e9" class="le ig hi la b fi lr lg l lh li">/* somewhere in Sorter.svelte */<br/>&lt;div class="wrapper"&gt;<br/>{#each data as item (item.id)}<br/>	&lt;svelte:component this={template} item={item} /&gt;<br/>{/each}<br/>&lt;/div&gt;</span></pre><p id="6eb3" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我盲目地试图复制一个反应习语&amp;没有意识到在苗条时，你会这样做:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="32ad" class="le ig hi la b fi lf lg l lh li">&lt;Sorter data={data} let:item let:isDragging&gt;<br/>	&lt;MyListItem {item} {isDragging}&gt;<br/>&lt;/Sorter&gt;</span><span id="8435" class="le ig hi la b fi lr lg l lh li">/* somewhere in Sorter.svelte */<br/>&lt;div class="wrapper"&gt;<br/>{#each data as item (item.id)}<br/>	&lt;slot {item} isDragging={draggingIds.has(item.id)} /&gt;<br/>{/each}<br/>&lt;/div&gt;</span></pre><p id="7efc" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">公平地说，对于过去的我来说，这种语法是不直观的&amp;来自React的语法有点令人费解，我甚至没有意识到当<code class="du ln lo lp la b">&lt;slot&gt;</code>在‘each’循环中时它还能工作🤯。在这里阅读揭露老虎机道具教程:<a class="ae kb" href="https://svelte.dev/tutorial/slot-props" rel="noopener ugc nofollow" target="_blank">https://svelte.dev/tutorial/slot-props</a></p><p id="bfc0" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我仍然不满意的一点是，用户需要告诉<code class="du ln lo lp la b">Sorter</code>id道具的名称，如果它不是字面上的“id”:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="ba1e" class="le ig hi la b fi lf lg l lh li">&lt;script&gt;<br/>	let data = [<br/>		{ aCustomIdFieldPleaseThankYou: "abcde1", value: "hi" }<br/>	]<br/>&lt;/script&gt;</span><span id="c161" class="le ig hi la b fi lr lg l lh li">&lt;Sorter data={data} idFieldName="aCustomIdFieldPleaseThankYou" &gt;&lt;/Sorter&gt;</span><span id="71aa" class="le ig hi la b fi lr lg l lh li">/* somewhere in Sorter.svelte */<br/>{#each data as item, i (item[idFieldName])}<br/>	{/* ... */}<br/>{/each}</span></pre><h1 id="7036" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">尝试#2</h1><p id="9076" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">然而，在主应用程序中，我们希望在项目列表的末尾放置一个按钮。作为一个思想家，我认为最好的方法是让用户自己实现循环&amp;让他们将一个“可拖动的”道具传递给底层组件。最大的灵活性！</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="cdb1" class="le ig hi la b fi lf lg l lh li">&lt;script&gt;<br/>	import { DragList, DragItem, DragIndicator } from 'svelte-sorter'<br/>	import MyListItem from './MyListItem.svelte'</span><span id="54e9" class="le ig hi la b fi lr lg l lh li">	let data = [/* ... */]<br/>&lt;/script&gt;</span><span id="99e3" class="le ig hi la b fi lr lg l lh li">&lt;DragList&gt;<br/>	&lt;DragIndicator /&gt;<br/>	{#each data as item, i (item.aCustomIdField)}<br/>		&lt;DragItem order={i}&gt;<br/>			&lt;MyListItem {item} /&gt;<br/>		&lt;/DragItem&gt;<br/>	{/each}<br/>	&lt;DragItem draggable={false}&gt;<br/>		&lt;button on:click={handleAddItem}&gt;Add&lt;/button&gt;<br/>	&lt;/DragItem&gt;<br/>&lt;/DragList&gt;</span></pre><p id="4fdd" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">这样，用户不必将<code class="du ln lo lp la b">data</code>、<code class="du ln lo lp la b">idFieldName</code>或<code class="du ln lo lp la b">selectedIds</code>传递到包装器组件中。在内部，事情也变得更加简单。每个个体<code class="du ln lo lp la b">&lt;DragItem&gt;</code>处理自己的定位，而不是持有一个巨大的状态对象。结果是，很容易将甜美的弹簧运动添加到单品中。我将在另一个要点中谈到这一点。</p><p id="b175" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">现在组件确实感觉更简单了，尽管有更多的样板代码…但这是一个很好的权衡，对吗？</p><p id="d732" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">对吗？</p><h1 id="cc05" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">尝试#3</h1><p id="adae" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一个大问题(见第5条)导致我重写了组件的一大部分。由于我不得不改变DOM结构，这让我重新考虑当前组件的API。</p><p id="1a28" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">这也是我意识到苗条有什么反应不的地方:<em class="lm">命名槽</em>！</p><p id="c8a4" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated"><em class="lm">成千上万身材苗条的开发人员面容姣好</em></p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="1426" class="le ig hi la b fi lf lg l lh li">&lt;Sorter&gt;<br/>  &lt;MyListItem slot="item" /&gt;<br/>  &lt;MyCustomIndicator slot="indicator"&gt;<br/>&lt;/Sorter&gt;</span></pre><p id="c3f0" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">以前的API非常灵活。然而，现在我们已经删除了滚动容器，这是不必要的。</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ls"><img src="../Images/66a525784ff6b7588afef516225a6343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eUAoJq5NcY_Rb9kg6Bq7Cg.png"/></div></div></figure><p id="7023" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">之前我提到我们需要一个添加按钮。好了，添加按钮现在可以存在于我们分类器组件之外:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="0319" class="le ig hi la b fi lf lg l lh li">&lt;Sorter<br/>  {data}<br/>  {selected}<br/>  idFieldName="customIdField"<br/>  let:item<br/>  let:isDragging<br/>  let:index<br/>&gt;<br/>  &lt;MyListItem slot="item"<br/>	  {item}<br/>	  {isDragging}<br/>	  {index}<br/>  /&gt;<br/>&lt;/Sorter&gt;<br/>&lt;button&gt;add&lt;/button&gt;</span></pre><p id="0be0" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我们又回到了传入自定义的<code class="du ln lo lp la b">idFieldName</code>，但至少现在我们达到了足够好的灵活性水平&amp;我们可以去掉所有的样板文件。</p><p id="3e8b" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">备注:我也尝试过苗条的动作，比如这样做:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="8a7d" class="le ig hi la b fi lf lg l lh li">&lt;div use:draggable={dragOptions}&gt;<br/>	{#each data as item, i (item.id)}<br/>		{/* ... */}<br/>	{/each}<br/>&lt;/div&gt;</span></pre><p id="8a0b" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">…但是我没有找到一种不通过DOM访问就能管理这些项目的方法，而且时间不允许我进一步探索这个问题。我确实想在将来再次参观它。</p><h1 id="fe74" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">2.虚拟化有一种错误的方式</h1><p id="d87b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">“虚拟化”就是只让<em class="lm">和</em>看到列表的可见部分。假设我们有一个1000项的列表，但是只有10项对用户可见，那么我们将只呈现这10项，而不是整个列表。</p><p id="4e3f" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">虚拟化是我添加到组件中的最后一项内容。我认为这相对容易，因为我们已经完全定位了列表中的所有内容&amp;列表项都有相同的大小。</p><p id="bc73" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">我需要做的是在呈现列表之前过滤掉所有不可见的组件。这只是检查一个项目的位置是否在被拖动的容器<em class="lm">或</em>内的问题，然后使用一个过滤循环代替th-</p><p id="5782" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">等等。当我开发这个特性时，用户仍然在处理循环。我不能在那里添加过滤器，因为它在我的分类器组件之外。</p><p id="e1a7" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">一个解决方案浮现在脑海中:导出一个用户可以用来过滤掉不可见项目的助手怎么样？</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="4611" class="le ig hi la b fi lf lg l lh li">import { Drag, DragItem, virtualizer } from 'svelte-sorter'</span><span id="a1fa" class="le ig hi la b fi lr lg l lh li">&lt;Drag&gt;<br/>	{#each virtualizer(data) as item, i (item.id)}<br/>		{/* ... */}<br/>	{/each}<br/>&lt;/Drag&gt;</span></pre><p id="b96f" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">但是我如何与这个函数通信呢？如果成功了，API现在就“更丑了”:在组件之上有了一个函数。</p><p id="aa41" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">为了找到解决方案，我将每一项打包成另一个组件:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="55fe" class="le ig hi la b fi lf lg l lh li">&lt;Drag&gt;<br/>	{#each data as item, i (item.id)}<br/>		&lt;DragVirtualizer&gt;<br/>			&lt;DragItem&gt;<br/>				&lt;MyListItem /&gt;<br/>			&lt;/DragItem&gt;<br/>		&lt;/DragVirtualizer&gt;<br/>	{/each}</span></pre><p id="4700" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated"><code class="du ln lo lp la b">DragVirtualizer</code>通过上下文订阅商店&amp;过滤掉不可见的项目:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="7edf" class="le ig hi la b fi lf lg l lh li">&lt;script&gt;<br/>	import { key } from './store'</span><span id="aec1" class="le ig hi la b fi lr lg l lh li">	export let id</span><span id="4954" class="le ig hi la b fi lr lg l lh li">	const { store } = getContext(key)<br/>&lt;/script&gt;</span><span id="156c" class="le ig hi la b fi lr lg l lh li">{#if $store.dragging.has(id) || $store.visibleIds.has(id)}<br/>	&lt;slot /&gt;<br/>{/if}</span></pre><p id="d197" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">你可以想象为什么这是一个坏主意:如果我有一个1000个订阅者的列表，那么每个卷轴上都有1000个订阅者。然而，它没有滞后，直到我用+500个项目进行测试，所以我妥协并推出了这个解决方案。</p><p id="c039" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">重写之后，我可以正确地实现这个特性**因为渲染循环现在又在排序器的组件控制之下了。赢了！</p><ul class=""><li id="a74a" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka kj kk kl km bi translated">:如果做错了，一切都会变得更容易和更困难**:我可以通过重用DOM节点来进一步优化这一点，但我还没有这样做</li></ul><h1 id="a897" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">5.在编写大部分代码之前，不断评估所有需求并创建一个环境</h1><p id="3f0c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在我着手虚拟化后不久，我们更新了UI，这样一个滚动列表就<em class="lm">嵌套在另一个滚动容器内</em>。这就是一切失控的地方:</p><ul class=""><li id="0a60" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka kj kk kl km bi translated">自动滚动失败，因为容器现在部分隐藏</li><li id="fd8d" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">当用户拖动一个项目时，它消失在空白中…因为偏移位置现在是错误的</li><li id="3069" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">虚拟化不再正常工作，因为它只考虑其父包装的维度</li></ul><p id="e598" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">以下是我做错的地方:</p><ul class=""><li id="542a" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka kj kk kl km bi translated">假设组件不在多层滚动列表下。</li><li id="13ef" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">仅计算直接滚动容器的滚动偏移量。在应用程序中，有多层滚动容器。</li></ul><p id="6f8d" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">这让我回到了绘图板。</p><ul class=""><li id="a071" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka kj kk kl km bi translated">需要计算真正的可见区域，而不仅仅是包装容器。</li><li id="0339" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">该组件不应是滚动容器。它应该只是具有最大宽度/高度的项目列表。</li><li id="95ac" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">自动滚动功能应该基于真正的可见区域，而不是包装容器。</li></ul><p id="d340" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">考虑到这些，我第n+1次重写了这个东西。</p><p id="5bcc" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">首先，我处理了可视区域。在下面的剪辑中，它被标记为带有红色边框的橙色:</p><figure class="kv kw kx ky fd lj"><div class="bz dy l di"><div class="lz ll l"/></div></figure><p id="6bb3" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">当视口剪辑组件时，可见区域会正确收缩。解决了这个问题，我现在可以准确地计算虚拟化的可见元素了(看到可见范围随着可见区域的缩小而缩小)。自动滚动区域现在也可以正确计算，所以拖动时总是可以滚动。</p><p id="b25b" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated">它在我们的应用程序中工作得足够好&amp;我期待着这个项目的开源。感谢您的关注！</p><h1 id="5f22" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">下一关</h1><p id="3c75" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">以下是我将要做的事情:</p><ul class=""><li id="d1b6" class="kc kd hi jf b jg ke jk kf jo kg js kh jw ki ka kj kk kl km bi translated">分组:将一个组件拖到另一个组件中以创建一个组</li><li id="c82b" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">处理不同的大小:即使每个列表项目都是统一的，我们也希望能够处理具有不同项目大小的列表。</li><li id="4c13" class="kc kd hi jf b jg kn jk ko jo kp js kq jw kr ka kj kk kl km bi translated">当然，还有修复所有未知的错误。</li></ul><p id="bbe3" class="pw-post-body-paragraph jd je hi jf b jg ke ji jj jk kf jm jn jo ks jq jr js kt ju jv jw ku jy jz ka hb bi translated"><strong class="jf hj">关于作者</strong>大家好，我是德里克。从图形设计背景进入编程，我正站在两者的交叉点:前端开发！我总是在网上寻找下一个很酷的东西。</p></div></div>    
</body>
</html>