<html>
<head>
<title>Building a JavaScript Single-Page Application with Rails API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Rails API构建JavaScript单页面应用程序</h1>
<blockquote>原文：<a href="https://medium.com/codex/building-a-javascript-single-page-application-with-rails-api-a8e5945128a9?source=collection_archive---------13-----------------------#2021-07-12">https://medium.com/codex/building-a-javascript-single-page-application-with-rails-api-a8e5945128a9?source=collection_archive---------13-----------------------#2021-07-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/70a356dd920fa256ea2aa65a64b809f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EnPCftiapw6C8mdTehXsZA.jpeg"/></div></div></figure><p id="b07a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是如何利用monorepo在后端使用Rails API构建JavaScript单页面应用程序的概述。在本例中，我主要关注我构建的一个名为SeeData Visualizer的小应用程序。</p><p id="2fa5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个应用程序的构建可以大致分为两个部分:Rails API和JavaScript客户端。</p><h1 id="61fe" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Rails API</h1><p id="1199" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">要创建monorepo，从整个项目的单个文件夹开始。按照根据文件夹和文件的内容来命名它们的惯例，我将示例应用程序的housing文件夹称为“seedata-visualizer”</p><p id="523a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在该文件夹中，使用以下命令从终端创建一个新的Rails API:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="d6f6" class="la jp hi kw b fi lb lc l ld le">terminal $ rails new project_name --api</span></pre><p id="0214" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Rails创建完API后，在项目中为前端使用的所有JavaScript、CSS和HTML创建一个名为“projectname_client”的新文件夹。由于我使用了monorepo，我试图保持命名非常清晰；我把API端叫做‘seedata _ API’，所以我把客户端叫做‘seedata _ client’在项目文件夹的最高层，所有应该可见的是这两个文件夹和自述文件。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/ed07a06058156971c810e0db8b12e29a.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*KUMpm8nHP2mDjQD1-cKwfQ.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">最高级别的应用程序文件树的屏幕截图，显示了API文件夹、客户端文件夹和自述文件。</figcaption></figure><h1 id="d607" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">连接到GitHub &amp;第一次提交</h1><p id="e9d9" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在进行任何其他更改之前，项目的结构应该被初始化为GitHub存储库，并链接到一个远程。我更喜欢这样做:在GitHub上初始化一个与我的项目同名的存储库，然后将它设置为我的项目的远程源。</p><p id="d03d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在GitHub上初始化一个新的存储库。使用不带空格的项目名称作为存储库名称。我避免勾选“初始化此存储库:”部分中的任何复选框，因为自述文件是一个很好的首次提交，我更喜欢以后添加许可证。这是个人喜好问题。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/8170f160332c9e88d85fd7e894b815ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2eYA4QhslPtQpzjvDi13CA.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">GitHub上新存储库表单的截图，显示了项目名称和我首选的初始化条件配置(公开，没有添加额外的内容)</figcaption></figure><p id="3a54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建存储库后，复制其链接。在终端中，访问新项目的API文件夹。Rails在创建API时会自动初始化GitHub存储库，如果不删除它，会导致提交整个项目的问题。一旦进入API文件夹，执行以下命令以删除GitHub repository Rails自动初始化:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3edd" class="la jp hi kw b fi lb lc l ld le">terminal $ rm -rf .git</span></pre><p id="dbbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦自动生成的git文件被删除，返回到终端中的父项目目录并初始化GitHub存储库:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="c76c" class="la jp hi kw b fi lb lc l ld le">terminal $ cd ..<br/>terminal $ git init</span></pre><p id="1e97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者，在本地初始化存储库时，可以添加一个分支名称。GitHub现在原生地将主分支称为“main”，但它过去使用“master”，因此一些编码人员更喜欢将他们的主分支称为master。要使用分支名称初始化本地存储库，请使用以下命令:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="2376" class="la jp hi kw b fi lb lc l ld le">terminal $ git init -b branch_name</span></pre><p id="39f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来是关键的一步:确保存储库中的某些内容已经被编辑过。为此，我通常使用自述文件。在主目录中，添加一个名为README.md的文件，并在该文件中键入一些文本。接下来，准备第一次提交，并通过粘贴GitHub存储库链接添加远程:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="183a" class="la jp hi kw b fi lb lc l ld le">terminal $ git add .<br/>terminal $ git commit -m 'initial commit'<br/>terminal $ git remote add origin &lt;your github repo link&gt;</span></pre><p id="6246" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后要做的事情是将提交推送到远程:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="d23b" class="la jp hi kw b fi lb lc l ld le">terminal $ git push</span></pre><p id="37a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果第一次推送成功，现在可以从最顶层的目录提交整个项目。如果试图从其中一个子目录提交，GitHub将显示错误消息，提交将失败。在编写示例应用程序的过程中，我在主文件夹中打开了一个终端窗口来进行提交。</p><h1 id="08e6" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">完成后端</h1><p id="348e" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">API已经设置好了，存储库也链接到了GitHub。现在应该在构建前端之前添加API中数据之间的任何关系。在示例项目中，一个可视化属于一个数据集，而一个数据集有许多可视化。</p><p id="b041" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行迁移并将任何种子数据添加到数据库:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="9f57" class="la jp hi kw b fi lb lc l ld le">terminal $ rails db:migrate<br/>terminal $ rails db:seed</span></pre><p id="0174" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成后端的最后一步是启用CORS，跨源资源共享。这使得可以从API服务器外部发出获取请求，这是正确运行JavaScript前端所必需的。首先，通过在Gemfile中取消注释来启用gem“rack-CORS ”( Rails自动包含它，但将其注释掉)。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="066c" class="la jp hi kw b fi lb lc l ld le"># Use Rack CORS for handling Cross-Origin Resource Sharing (CORS), making cross-origin AJAX possible</span><span id="ffeb" class="la jp hi kw b fi ll lc l ld le">gem 'rack-cors'</span></pre><p id="d2ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，在config文件夹内的application.rb文件中，将以下内容(或者取消注释，如果已经包含)粘贴到' class Application &lt; Rails::Application’ section of the file:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="70c0" class="la jp hi kw b fi lb lc l ld le">config.middleware.insert_before 0, <em class="lm">Rack</em>::Cors do<br/>  allow do<br/>    origins '*'<br/>    resource '*',<br/>      :headers =&gt; :any,<br/>      :methods =&gt; [:get, :post, :delete, :put, :patch, :options, :head],<br/>      :max_age =&gt; 0<br/>  end<br/>end</span></pre><p id="f8ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Nothing should be removed; this code should simply be added into the pre-existing class. This version of the code allows calls from any origin for any resource, so it is not a long-term solution for a hosted application. However, for a test project or practice, this configuration is fine.</p><h1 id="1389" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Writing the Client: File Structure</h1><p id="9766" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">The frontend of the application has a much smaller file tree than the backend. The bare minimum necessary files are index.html and index.js, but if using object-oriented JavaScript, it is recommended to create a source folder containing separate JavaScript files for each class and its AJAX calls.</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/605b54b42f8ded8258aa5375561bc526.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*5dwma5FYBseUfyzcrjtt3g.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">Example of the frontend file tree showing the source folder, index files, and CSS folder.</figcaption></figure><p id="c13f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">In order to include these files in the rendered application, they must be called in index.html. Script files (JavaScript in this case) can be called in the headers of the index file and then run with an event listener for DOM loading, or they can be called at the end of the index file, which will ensure that the DOM content loads before the script files are run. I prefer the latter approach.</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/011222bb40a9479738c48610a129ccc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*Wpufq4mYKteWZrJIs_0AFg.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">The bottom of the example application 标记中，显示为index.html调用的脚本。</figcaption></figure><p id="fb50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为index.js包含应用程序中JavaScript的全局上下文，所以它是最后加载的。对于更简单的应用程序，将它列在最后可以保持这个顺序。示例应用程序涉及到获取竞争条件，这些条件在外部解决，因此在这种情况下，defer属性被设置为保存index.js直到最后。</p><p id="a1f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于任何普通CSS样式，可以使用相对链接在标题中调用样式表。有些CSS库不采用这种技术，所以根据CSS的具体实现方式，头文件可能会也可能不会用于调用样式。</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/1e677d2aa3dc833b90d86b860e596d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*u90pRAvOjYxTYGdO0K6jGA.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">显示样式表相对链接的应用程序标题的屏幕截图。</figcaption></figure><h1 id="38da" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">客户端-服务器通信</h1><p id="9e65" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">用API后端和JavaScript前端设置应用程序的目的是利用fetch AJAX实用程序在服务器端和客户端之间进行通信。这些通信应该放在像“visualizationService.js”这样的文件中，这是以面向对象的JavaScript中它们的类命名的。这与主类文件“visualization.js”不同，后者保存与处理和放置DOM元素相关的行为。</p><p id="0a81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个基本的获取请求包括三个部分:<strong class="is hj">信息</strong>、<strong class="is hj">配置</strong>和<strong class="is hj">请求</strong>本身。在下面的例子中，常量<em class="lm">可视化</em>是一个包含要发送到服务器的信息的对象，<em class="lm"> configObj </em>是配置，请求本身是<em class="lm">获取</em>。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="23d9" class="la jp hi kw b fi lb lc l ld le">createVisualization(){<br/>  const visualization = {<br/>    name: document.getElementById('pass_name').value,<br/>    chart_type: document.getElementById('pass_type').value,<br/>    x_choice: parseInt(document.getElementById('x-data').value),<br/>    y_choice: parseInt(document.getElementById('y-data').value),<br/>    dataset_id: parseInt(document.getElementById('pass_dataset_id').value)<br/>   }</span><span id="916a" class="la jp hi kw b fi ll lc l ld le">  const configObj = {<br/>    method: "POST",<br/>    headers: {<br/>     'Content-Type': 'application/json'<br/>    },<br/>    body: JSON.stringify(visualization)<br/>  }</span><span id="57a1" class="la jp hi kw b fi ll lc l ld le">  fetch(`${<em class="lm">this</em>.endpoint}/visualizations`, configObj)<br/>  .then(<em class="lm">resp</em> =&gt; <em class="lm">resp</em>.json())<br/>  .then(<em class="lm">visualization</em> =&gt; {<br/>    const v = <strong class="kw hj">new</strong> Visualization(<em class="lm">visualization</em>)<br/>    v.addToDom()<br/>  })<br/>}</span></pre><p id="21cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一步是根据服务器中的数据向DOM添加元素，这些数据是使用fetch请求传递给前端的。这通常是分部分进行的，但是最简单的方法在前面的例子中已经说明了:对于从服务器返回的每一段数据，初始化一个正确类的新对象，然后将它添加到DOM中。在visualization类中，被调用的方法是constructor和addToDom():</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/e93f46880f0363443fecc7464bfc15f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*ctXQ_ElC9p0LZhlZH-kcEw.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">应用程序中可视化效果的实际构造函数。</figcaption></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="ae22" class="la jp hi kw b fi lb lc l ld le">addToDom(){<br/>  const renderTarget = <em class="lm">this</em>.element<br/>  <em class="lm">this</em>.renderVisualization(<em class="lm">this</em>.name, 0.35, renderTarget)<br/>}</span></pre><p id="a936" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的addToDom()函数是实际函数的简化版本，目的是展示过程的基本要素，而构造函数的截图是实际的构造函数。</p><h1 id="8db2" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">发布</h1><p id="b0ca" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">有了基本的API设置、服务器-客户机通信和可以向DOM发送数据的工作前端，选择是无穷无尽的。在我的例子中，我使用了一个名为d3.js的JavaScript库来呈现数据可视化，并弄清楚了如何接受用户上传的CSV文件来创建数据集。我编写的站点具有添加数据集、从新的或现有的数据创建可视化以及查看和删除可视化的功能。</p><p id="cbcd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用Rails后端提供了可靠而灵活的数据存储解决方案，而前端的JavaScript创建了快速且用户友好的体验。这种组合是快速构建功能性应用程序的理想选择。</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">可视化应用程序中seed的youtube演练</figcaption></figure></div></div>    
</body>
</html>