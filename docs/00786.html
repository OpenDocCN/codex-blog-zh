<html>
<head>
<title>Difference between GraphQL and REST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL和REST的区别</h1>
<blockquote>原文：<a href="https://medium.com/codex/difference-between-graphql-and-rest-e3b0ded30382?source=collection_archive---------11-----------------------#2021-03-18">https://medium.com/codex/difference-between-graphql-and-rest-e3b0ded30382?source=collection_archive---------11-----------------------#2021-03-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="40a1" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><p id="98ba" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">您是否曾经开发过REST APIs和端点，它们提供了超出要求的东西，最终降低了您的应用程序的速度。2012年，脸书的开发人员提出了一个解决方案，他们开发了一个开源应用程序GraphQL。它作为一种为API设计的查询语言。所以让我们直接开始吧。我们将确定API的一些属性，然后讨论GraphQL和REST如何处理它们。</p><h1 id="0aff" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">REST API</h1><p id="1a3e" class="pw-post-body-paragraph io ip hi iq b ir kk it iu iv kl ix iy iz km jb jc jd kn jf jg jh ko jj jk jl hb bi translated">在REST API中，您的代码被定向到特定的端点或URL。收到请求后，URL或端点控制向您发布的数据。您可以通过在URL中添加某些选项或参数来简化和组织返回给您的数据。</p><p id="8228" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">在标准API请求中，数据以JSON或JavaScript对象的形式返回，其中包含大量数据。所以它看起来像这样:</p><figure class="kq kr ks kt fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es kp"><img src="../Images/92431f6b14e0b04c1f40faf50206e62f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*5KPJZU6fTwZfRIg_QjcxXQ.png"/></div></div></figure><p id="3b37" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">然而，当前的REST API有两个主要挑战，描述如下:</p><ol class=""><li id="c8a8" class="lb lc hi iq b ir is iv iw iz ld jd le jh lf jl lg lh li lj bi translated">关于REST的第一个问题。这指的是提供超出要求的东西。本质上，并非所有交付的数据都对您的请求有用。</li><li id="286b" class="lb lc hi iq b ir lk iv ll iz lm jd ln jh lo jl lg lh li lj bi translated">第二个挑战是抓取。这是指不适合您的目的的绘图数据。这迫使您再次运行查询。</li></ol><h1 id="c149" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">GraphQL</h1><p id="2094" class="pw-post-body-paragraph io ip hi iq b ir kk it iu iv kl ix iy iz km jb jc jd kn jf jg jh ko jj jk jl hb bi translated">GraphQL的核心是一种从客户端应用程序查询数据库的语言。在后端，GraphQL向API指定如何将数据呈现给客户端。</p><p id="a010" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">GraphQL服务器为客户机提供了预定义的模式——可以从服务器请求的数据模型。换句话说，模式在定义如何访问数据时，充当了客户机和服务器之间的中间地带。看起来像这样:</p><figure class="kq kr ks kt fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lp"><img src="../Images/404898f26dad556d9d089414555b1646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZLJdyW2Ba4aH1KI1Ys7rCA.png"/></div></div></figure><p id="f85f" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">请注意，我们已经描述了可用数据的种类，但是这个描述并没有告诉您如何从客户端获取这些对象。这是REST和GraphQL的一个核心区别——特定资源的描述与检索它的方式无关。</p><p id="06e3" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">为了能够实际访问某本书或某个作者，我们需要在模式中创建一个查询类型:</p><figure class="kq kr ks kt fd ku er es paragraph-image"><div class="er es lq"><img src="../Images/cc0e3af95feb85b1de563d3a7f203e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*wSvxVTlqXgkEAzravnAUVA.png"/></div></figure><p id="e1a2" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">现在，我们可以发送一个类似于上面REST请求的请求，但是这次使用GraphQL:</p><figure class="kq kr ks kt fd ku er es paragraph-image"><div class="er es lr"><img src="../Images/0a01717380844ba1c141be6dac708c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*GB3SKIwRYbuGGsUHkZr9-A.png"/></div></figure><p id="c91f" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我们可以立即看到GraphQL与REST的一些不同之处，尽管两者都可以通过URL请求，并且都可以返回相同形状的JSON响应。</p><p id="c230" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">首先，我们可以看到带有GraphQL查询的URL指定了我们请求的资源以及我们关心的字段。此外，不是服务器作者为我们决定需要包含相关的作者资源，而是API的消费者决定。</p><p id="2dfc" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">但最重要的是，资源的身份，书籍和作者的概念，并不与获取它们的方式相联系。我们可以通过许多不同类型的查询，用不同的字段集检索同一本书。</p><h1 id="c5db" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">结论</h1><p id="97b5" class="pw-post-body-paragraph io ip hi iq b ir kk it iu iv kl ix iy iz km jb jc jd kn jf jg jh ko jj jk jl hb bi translated">GraphQL APIs可能是令人兴奋的新技术，但是在做出这样的架构决策之前理解权衡是很重要的。一些API，比如那些只有很少实体和跨实体关系的API，比如分析API，可能不适合GraphQL。而具有许多不同域对象的应用程序，如电子商务，其中有商品、用户、订单、支付等等，可能能够更多地利用GraphQL。</p></div></div>    
</body>
</html>