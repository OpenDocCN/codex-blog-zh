<html>
<head>
<title>Mediator Pattern: A Capable Underdog?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调解人模式:一个有能力的失败者？</h1>
<blockquote>原文：<a href="https://medium.com/codex/mediator-pattern-a-capable-underdog-7eb82944a935?source=collection_archive---------6-----------------------#2021-12-03">https://medium.com/codex/mediator-pattern-a-capable-underdog-7eb82944a935?source=collection_archive---------6-----------------------#2021-12-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/160d2738ae3e8b3e26cde00c491feba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NEzTLQNy6vDTuW7B6b48ew.jpeg"/></div></div></figure><p id="fec8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">啊，我的feed上又多了一个设计模式博客？我打赌你也是这么想的。但是让我向你保证，你至少会明白为什么我同时称它为有能力的人和失败者。</p><p id="84ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将在这里回答每个人在学习新模式时都会问的4个问题:<strong class="is hj">什么，为什么，什么时候和如何</strong>？</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="5abe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们开始吧:</p><h1 id="beb6" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">什么？</h1><p id="1312" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">首先也是最重要的，听到一个新的模式时产生的问题是为什么？<br/>当你已经有20多个众所周知的设计模式在项目的大部分时间里处于稳定状态时，为什么你还需要一些新的模式呢？</p><p id="2c26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了理解这一点，我们首先需要了解什么是中介模式？</p><p id="a89e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们按照维基百科的定义，它说:</p><blockquote class="ky kz la"><p id="049d" class="iq ir lb is b it iu iv iw ix iy iz ja lc jc jd je ld jg jh ji le jk jl jm jn hb bi translated">"中介模式定义了一个对象，它封装了一组对象如何交互."</p></blockquote><p id="f0f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">过头了吧。别担心。</p><p id="1934" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">顾名思义，调解人起着调解的中介作用。但是调解谁呢？你猜对了。课间休息。换句话说，它提供了一个统一的、单一的实体来在类之间进行通信。现在让我们把它变得简单一些，它在核心API动作和它们所通信的各自的业务逻辑之间起中介作用。所以，这是一种行为模式。</p><p id="f692" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你马上会问，当我们已经可以通过使用大量其他设计模式非常容易地在类之间进行通信时，为什么我们还需要一个中介，为了回答这个问题，让我们继续下一个主题。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="8598" class="jv jw hi bd jx jy lf ka kb kc lg ke kf kg lh ki kj kk li km kn ko lj kq kr ks bi translated">为什么？</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/de9884e4afc38d140db125017215bd6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*47yVS6oabVDepiv4"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">照片由<a class="ae lt" href="https://unsplash.com/@bdp028?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贝克特P </a>在<a class="ae lt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="d6cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设机场是您的应用程序，您需要管理空中交通。</p><p id="dccf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想象一下，如果地面上没有空中交通管制员，飞机需要通过与附近的几十架其他飞机进行交互来自行管理高度和速度，情况会怎样？</p><p id="e8dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这会造成混乱，不是吗？</p><p id="5c9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大多数传统的设计模式都是基于依赖关系的。假设有3个类依赖于3个不同的类来执行它们的业务逻辑。我们传统上所做的是解决它所消费的类的依赖性。这使得多对多的互动在某种程度上。这就造成了依赖关系的混乱。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/205b6a2ddbc9a952c296a5bd7c1d5604.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*uRzcER9AJHpNTheKDPSyKw.jpeg"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">传统的方式</figcaption></figure><p id="ed1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在想象你需要分离或者改变一些类的交互？</p><p id="6e4c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是调解人发挥作用的地方。</p><blockquote class="ky kz la"><p id="cba7" class="iq ir lb is b it iu iv iw ix iy iz ja lc jc jd je ld jg jh ji le jk jl jm jn hb bi translated">它的作用是，基本上处理交互。</p></blockquote><p id="3e93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这解决了几个问题:</p><ol class=""><li id="543f" class="lv lw hi is b it iu ix iy jb lx jf ly jj lz jn ma mb mc md bi translated">班级之间直接/紧密的交流。</li><li id="911a" class="lv lw hi is b it me ix mf jb mg jf mh jj mi jn ma mb mc md bi translated">处理复杂的依赖关系管理。</li><li id="8f68" class="lv lw hi is b it me ix mf jb mg jf mh jj mi jn ma mb mc md bi translated">允许我们轻松地修改类之间的任何交互。</li></ol><p id="dadb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在中介模式中，上面的场景看起来像这样:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/f7a0e063d9ba6e69f20204655385bf6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*8AfVfxkn0W0_NBBPtzlw4A.jpeg"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">调解人的方式</figcaption></figure><p id="7a30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很容易观察到，它不仅看起来干净，而且还提供了一个统一的界面来管理交互。</p><p id="168f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好了，现在我们知道了它是什么以及为什么要引入它，让我们检查一些用例，看看什么时候使用它，什么时候不使用它。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="104d" class="jv jw hi bd jx jy lf ka kb kc lg ke kf kg lh ki kj kk li km kn ko lj kq kr ks bi translated">什么时候？</h1><p id="60e8" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">简单来说，当你需要摆脱依赖纠缠时，我们可以使用一个中介模式。当你有这么多相互依赖的类时，管理依赖关系会让人头疼。</p><p id="71e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们需要轻松地改变类之间的交互行为时，当我们需要一个ATC类型的单一实体来管理交互时，当我们需要封装正在通信的对象以便只有一个实体知道类之间的依赖关系时，我们可以使用它。</p><p id="11ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，它并不完美。这是有代价的。</p><p id="d84d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与所有其他单一实体一样，它很容易失败。有太多依赖关系的复杂中介可能会成为单点故障。所以最好不要把它复杂化。</p><p id="3cbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们跳到如何使用它？</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="33c2" class="jv jw hi bd jx jy lf ka kb kc lg ke kf kg lh ki kj kk li km kn ko lj kq kr ks bi translated">怎么会？</h1><p id="2dda" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">别担心，我不会在这里粘贴整个解决方案。你可以在GitHub上查看这类项目的多个例子，比如这里的<a class="ae lt" href="https://github.com/evgomes/cqrs-mediatr-asp-net-core" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="1bec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是在基本环境中，您可以安装和配置MediatR Nuget包，创建与动作/工作流相关的模型和处理程序，然后通过向中介发送请求在动作中使用它。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="611d" class="jv jw hi bd jx jy lf ka kb kc lg ke kf kg lh ki kj kk li km kn ko lj kq kr ks bi translated">与CQRS的调解员</h1><p id="0e62" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">如果你从上面访问过GitHub repo，你会看到术语CQRS-调解人模式。CQRS和调解人经常互换使用，这是不正确的。</p><p id="b751" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">两者都有不同的用例以及需要解决的问题，但是将两者结合起来才是神奇之处。Nuget MediatR为这两种模式的使用提供了便利，这也是这些术语可以互换使用的原因之一。点击了解更多关于CQRS <a class="ae lt" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs" rel="noopener ugc nofollow" target="_blank">的信息。</a></p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h1 id="ac2a" class="jv jw hi bd jx jy lf ka kb kc lg ke kf kg lh ki kj kk li km kn ko lj kq kr ks bi translated">能干的落水狗？</h1><p id="20d6" class="pw-post-body-paragraph iq ir hi is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">到目前为止，我们知道它为什么有能力，但为什么它仍然是一个失败者？</p><p id="98f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不幸的是，这个问题没有确定的答案，但是以我的观点和观察，原因可能是许多现有的项目使用了广泛接受的设计模式，比如singleton和factory模式。但是很明显，中介模式的使用已经被接受，并且正在增长，特别是在整个行业的新解决方案中。</p><p id="fe48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">快乐学习！！！</p></div></div>    
</body>
</html>