<html>
<head>
<title>The Ultimate RxSwift Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">终极RxSwift指南</h1>
<blockquote>原文：<a href="https://medium.com/codex/understanding-rxswift-basics-in-the-simplest-way-6206c78f111d?source=collection_archive---------4-----------------------#2022-04-14">https://medium.com/codex/understanding-rxswift-basics-in-the-simplest-way-6206c78f111d?source=collection_archive---------4-----------------------#2022-04-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9b7e0ab77a72d43be2f187c592968ed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7UZ0IDBICT0BLllM1MEsg.png"/></div></div></figure><p id="bcb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看得见的..看得见的..可观察到的是，我们都从第一个词开始学习RxSwift，我相信至少90%的人结束他们的学习没有任何进展。没问题，我们都在同一条船上。在本文中，我将尽我最大的努力让大家以一种基本的方式理解RxSwift。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h2 id="e7c2" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">什么是可观察的？</h2><p id="e85d" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">可观测值只是Swift中序列的一种等价形式。让我帮助你想象一个可观察的。<br/>想一个<code class="du kv kw kx ky b">array</code>。使用数组，您可以做哪些事情？<br/>你可以做很多序列变换运算、计算运算以及很多其他的操作，对吗？此外，您还可以使用<code class="du kv kw kx ky b">map</code>、<code class="du kv kw kx ky b">filter</code>、<code class="du kv kw kx ky b">reduce</code>等高阶函数。所有这些优势在你的<code class="du kv kw kx ky b">Observable</code> <br/>中也是可行的。我们将一个字符串元素数组转换成一个整数数组，对吗？同样地，我们可以把一个可观察的转化成相当多的其他形式。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/3f764baf5f88dd3cda2655fa520485c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWJohQCQZsQxooNMKnvzvA.png"/></div></div></figure></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h2 id="8da8" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">等等，有区别的！！</h2><p id="2e62" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated"><code class="du kv kw kx ky b">array</code>和<code class="du kv kw kx ky b">Observable</code>之间有区别，那就是<code class="du kv kw kx ky b">time</code>。<br/>我将帮助您想象<code class="du kv kw kx ky b">time</code>在这里是一个怎样的不同因素。<br/>考虑一个有六个元素的数组。这六个元素都可以访问，并且可以同时访问。但是在<code class="du kv kw kx ky b">Observable</code>的情况下，每个元素都将与一个特殊的时间相关联，如下所示。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/37e834576e7c8bdeda6ad2e24c53da27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZBKV5IP2RmdN9ZME7K2A1g.png"/></div></div></figure><p id="6c37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，从上面的图像中，我们可以清楚地理解，两个元素仅在t0时间可用。30元素仅在t1时间可用。等等。<br/>希望你现在已经得到了差异因子。</p><blockquote class="lf lg lh"><p id="14d4" class="iq ir li is b it iu iv iw ix iy iz ja lj jc jd je lk jg jh ji ll jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">注</em> </strong> : <br/>可观察的整体思想是，你可以订阅它，你就可以得到那些事件。</p></blockquote></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h2 id="19fa" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">创建可观察对象</h2><p id="02c8" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">要创建一个可观察的对象，我们只需要使用可观察类称它为可观察的，并使用您想要观察的序列调用可观察类中的一个函数。我将展示一些可观察对象的例子，以及它是如何创建的，并熟悉可观察类中的一些常见函数。</p><p id="798c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kv kw kx ky b">Just</code></p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/f10805f34f1d44ef2d2e69856cbab0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SabYy7pmuxBouyk5FRUJbg.png"/></div></div></figure><p id="6ffe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一个将创建一个只有一个特定元素的可观察。</p><p id="bf2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kv kw kx ky b">Of</code></p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/c5ba6e900cd2d7782da9211e724760b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zAch8kXgD3CMDeCFoJuv4A.png"/></div></div></figure><p id="c7e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种可观察性允许您创建一个包含各种元素的可观察性。此外，它还意味着元素集的这些可观察函数在其中被指定。也就是说，如果您将<code class="du kv kw kx ky b">[1,2,3]</code>指定为一个数组，而不是一个不同的元素，那么可观测量会将其视为一个整数数组类型。</p><p id="1e97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kv kw kx ky b">from</code></p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/6d2fe22f35cb434259c8bbce53adf8bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmtneU6pqjNj77LEaD292Q.png"/></div></div></figure><p id="6020" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">默认情况下，这个可观察对象接受一个元素数组，但是可观察对象将对指定数组中的单个元素起作用。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h2 id="7706" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">由Observables发出的事件。</h2><p id="0456" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">在此之前，我们将再次回到数组的概念。我们将想象访问元素。正如我所说的，数组只不过是一系列元素。现在swift中的一个序列通常在<code class="du kv kw kx ky b">Iterator Protocol</code>上工作</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/ccd5c10d03fcefb1c7a358f280c1b8eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZTL9UqJ919pAM102l8Lwbw.png"/></div></div></figure><p id="d069" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上图来自苹果开发者文档。<code class="du kv kw kx ky b">IteratorProtocol</code>你可以清楚地看到Swift将<code class="du kv kw kx ky b">IteratorProtocol</code>分配给所有序列。所以封装开发者文档里写的关于IteratorProtocol的东西就是它只有一个功能，那就是<code class="du kv kw kx ky b">next()</code>。</p><p id="3b53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kv kw kx ky b"><strong class="is hj">Next<br/></strong></code>在<code class="du kv kw kx ky b">for-loop</code>中，<code class="du kv kw kx ky b">next()</code>函数在每次迭代中被调用，直到<code class="du kv kw kx ky b">next()</code>函数返回零。我为什么这么说是因为，在开始，我提到了<code class="du kv kw kx ky b">Observables</code>也就是<code class="du kv kw kx ky b">Sequences</code>。所以我们现在知道一个可观察对象可以访问名为<code class="du kv kw kx ky b">next()</code>的属性。我们还知道<code class="du kv kw kx ky b">Time</code>维度，也就是这里的微分，对吧？所以我们可以说，可观察的可以听<code class="du kv kw kx ky b">next()</code>事件。<br/>所以如果你有一个<code class="du kv kw kx ky b">Observable&lt;String&gt;</code>，那么每个<code class="du kv kw kx ky b">next</code>事件都会带有一个<code class="du kv kw kx ky b">String</code>。</p><p id="b2f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kv kw kx ky b"><strong class="is hj">onError</strong></code> <strong class="is hj"> <br/> </strong>至此我相信你应该对<code class="du kv kw kx ky b">next</code>有了一个清晰的认识。正如我之前说过的，Observables工作在迭代器和观察者模式上。考虑到<code class="du kv kw kx ky b">for-loop</code>我们总是可以在满足功能需求的情况下失败/中断/从<code class="du kv kw kx ky b">for-loop</code>返回。现在，同样的功能或用户错误警报也已经提供给了Observables，它还可以监听一个名为<code class="du kv kw kx ky b">onError</code>的特殊事件，告诉我们发生了错误。</p><p id="d6f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <br/> </strong>多与<code class="du kv kw kx ky b">onError</code>事件相同或相似。唯一的不同是，当它想要它的观察者知道它已经完成了这个过程时，它被可观察到的事物触发。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h2 id="e0f4" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">捐款</h2><p id="9f47" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">无论发出的是什么，我们都必须捕获发出的事件，因为这是RxSwift的全部目的。我们可以使用<code class="du kv kw kx ky b">subscribe(on: (Event&lt;T&gt;) -&gt; Void)</code>方法捕捉/监听来自<code class="du kv kw kx ky b">Observables</code>的事件。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/f71711f8c7d9f277b3afdbcbee200c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGw9k4ArreRWKjfkpnR7nw.png"/></div></div></figure><p id="14ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码产生了下面的o/p <br/> <code class="du kv kw kx ky b">Output: next(Hello)<br/> Output: completed</code></p><p id="1f2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述函数中的<code class="du kv kw kx ky b">event</code>为<code class="du kv kw kx ky b">enum</code>值，可以是我们之前提到的以下值之一:<code class="du kv kw kx ky b"><strong class="is hj">Next</strong></code> <strong class="is hj">、</strong> <code class="du kv kw kx ky b"><strong class="is hj">onError</strong></code> <strong class="is hj">、</strong> <code class="du kv kw kx ky b"><strong class="is hj">onCompleted</strong></code> <strong class="is hj"> </strong>等。<br/>如果您想订阅不同种类的活动，您可以使用<br/> <code class="du kv kw kx ky b"><strong class="is hj">func</strong> <strong class="is hj">subscribe</strong>(onNext: ((<strong class="is hj">T</strong>) <strong class="is hj">-&gt;</strong> <strong class="is hj">Void</strong>)?, onError: ((<strong class="is hj">Error</strong>) <strong class="is hj">-&gt;</strong> <strong class="is hj">Void</strong>)?, onCompleted: (() <strong class="is hj">-&gt;</strong> <strong class="is hj">Void</strong>)?, onDisposed: (() <strong class="is hj">-&gt;</strong> <strong class="is hj">Void</strong>)?) <strong class="is hj">-&gt;</strong> <strong class="is hj">Disposable</strong></code></p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h2 id="ea59" class="jv jw hi bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">把剩菜扔掉！</h2><p id="44c6" class="pw-post-body-paragraph iq ir hi is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">内存泄漏是一件非常痛苦的事情。使用观察者模式会增加两倍的内存泄漏风险。但是在RxSwift中，有一个简单的方法来处理内存泄漏，一个更软的方法是在使用结束后处理所有订户，这是通过调用订阅上的<code class="du kv kw kx ky b">dispose()</code>函数来完成的。因此通过调用<code class="du kv kw kx ky b">dispose()</code>函数，订阅将被立即处理掉。</p><p id="3358" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还有另一种简单的方法来实现这一点，那就是将它添加到一个<code class="du kv kw kx ky b">DisposeBag</code>中。通过在Disposebag中添加订阅，当父类被取消初始化时，订阅将被释放。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/ca93c3706d979e77ef033ebefe375649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSHsBUeQLzqDdGLi8WA6Xg.png"/></div></div></figure></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="d813" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这篇文章已经帮助你理解了RxSwift的核心概念，并且我期望你们所有人在你们的项目中尝试一次。</p></div></div>    
</body>
</html>