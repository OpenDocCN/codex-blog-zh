<html>
<head>
<title>Writing your own Operating System: Interrupts and Input</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写自己的操作系统:中断和输入</h1>
<blockquote>原文：<a href="https://medium.com/codex/writing-your-own-operating-system-interrupts-and-input-b6dfae970767?source=collection_archive---------2-----------------------#2021-08-20">https://medium.com/codex/writing-your-own-operating-system-interrupts-and-input-b6dfae970767?source=collection_archive---------2-----------------------#2021-08-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f212b6e3edc648cfbdba62cfd6d34b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dR2xNH0uBPrVuV4S5x9KFg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://www.freepik.com/vectors/banner" rel="noopener ugc nofollow" target="_blank">横幅</a>由katemangostar创建的矢量—【freepik.com T2】</figcaption></figure><p id="5776" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated"><span class="l ju jv jw bm jx jy jz ka kb di">在</span>我以前的一篇文章中，我解释了如何在控制台上显示文本以及如何将数据写入串口。如果你看起来很困惑，你可以回到第<a class="ae iu" href="https://hasinisama.medium.com/building-your-own-operating-system-drivers-8adfc889398b" rel="noopener">篇</a>来补上。</p><p id="4c82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以既然我们已经教会了我们的操作系统产生输出，如果它也知道如何读取输入，那就太好了。所以让我们从最常见的输入源开始；键盘。那么键盘是怎么工作的呢？你只要按一个按钮，瞧，它就印在屏幕上了！有这么简单吗？这就是我们将在本文中讨论的内容！</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/823e111b8eedac2bac654106c53f042b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jaDeqKecltea2B-CNtoJBQ.gif"/></div></div></figure><h2 id="d985" class="ki kj hi bd kk kl km kn ko kp kq kr ks jg kt ku kv jk kw kx ky jo kz la lb lc bi translated">什么是中断？</h2><p id="c6cc" class="pw-post-body-paragraph iv iw hi ix b iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">当硬件设备(如键盘、串口或定时器)向CPU发送输入时，就会发生中断。这是他们说“对不起，状态发生了变化，您可能需要检查一下这个”的方式。</p><p id="e61c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">中断也可能是由于程序错误而由CPU发出的，比如当一个程序将一个数除以零时。还有由<strong class="ix hj"> <em class="kc"> int </em> </strong>汇编代码指令引起的中断。我们称它们为<em class="kc">软件中断</em>，它们主要用于系统调用。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/afbf8a1710ae2b119906c9f7f2be8520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gys1OJrGhT-tnNmN5U-VMQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://www.freepik.com/vectors/people" rel="noopener ugc nofollow" target="_blank">人</a>由pch创建的向量。向量—<a class="ae iu" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank">freepik.com</a></figcaption></figure><h1 id="ccc4" class="lj kj hi bd kk lk ll lm ko ln lo lp ks lq lr ls kv lt lu lv ky lw lx ly lb lz bi translated">中断处理程序</h1><p id="9527" class="pw-post-body-paragraph iv iw hi ix b iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">但是我们如何解释这些中断呢？这些中断是通过<em class="kc">中断描述符表</em> (IDT)来处理的。总共有256个不同的中断，每个都从0-255编号。IDT描述了每个中断的处理程序。现在有三种处理程序:</p><ul class=""><li id="ff9d" class="ma mb hi ix b iy iz jc jd jg mc jk md jo me js mf mg mh mi bi translated"><strong class="ix hj">任务处理程序</strong> —特定于x86的英特尔版本</li><li id="f578" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="ix hj">中断处理程序</strong> —由硬件设备触发</li><li id="8bf9" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><strong class="ix hj">陷阱处理器</strong> —由用户程序触发</li></ul><p id="0a75" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将使用陷阱处理程序。</p><h1 id="d9c1" class="lj kj hi bd kk lk ll lm ko ln lo lp ks lq lr ls kv lt lu lv ky lw lx ly lb lz bi translated">在IDT中创建条目</h1><p id="4fe2" class="pw-post-body-paragraph iv iw hi ix b iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">正如我们在以前的文章中无数次做的那样，我们将使用另一个打包结构来定义IDT中的每个条目。</p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="ad27" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不要忘记为IDT本身创建另一个打包结构，就像我们为GDT创建的一样。</p><h1 id="431c" class="lj kj hi bd kk lk ll lm ko ln lo lp ks lq lr ls kv lt lu lv ky lw lx ly lb lz bi translated">处理中断</h1><p id="03bc" class="pw-post-body-paragraph iv iw hi ix b iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">但是当中断发生时，真正发生了什么呢？首先，CPU将把一些关于中断的信息推到堆栈上。然后它会在IDT中查找合适的中断处理程序并跳转到它。</p><p id="e418" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那时的堆栈看起来会像这样，</p><pre class="ke kf kg kh fd mq mr ms mt aw mu bi"><span id="7d47" class="ki kj hi mr b fi mv mw l mx my">    [esp + 12] eflags<br/>    [esp + 8]  cs<br/>    [esp + 4]  eip<br/>    [esp]      error code?</span></pre><p id="07a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kc">错误码末尾问号的原因？</em>不是所有的中断都会产生<em class="kc">错误代码</em>。就像问有没有错误一样。中断处理程序可以使用错误代码来获取更多关于发生了什么的信息。</p><p id="3ed9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里的中断<em class="kc">号</em>是<em class="kc">而不是</em>被推到堆栈上，因为我们可以通过检查哪个处理程序正在执行来知道哪个中断正在发生。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/ae32f0aab3d4458bb720cd04333fdc24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnecClgRdkMax7OPUBtFOw.png"/></div></div></figure><p id="4184" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，一旦中断处理程序完成，堆栈就使用<code class="du na nb nc mr b">iret</code>指令返回。</p><p id="6c15" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与机场海关一样，iret将检查返回的堆栈是否与中断发生前的堆栈相同。所以任何由中断处理程序压入堆栈的值都必须弹出。堆栈应该和以前一样。</p><p id="b77b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，C处理程序应该看起来像下面的代码。</p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="5b1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，棘手的部分是创建一个通用的中断处理程序。</p><h1 id="61ea" class="lj kj hi bd kk lk ll lm ko ln lo lp ks lq lr ls kv lt lu lv ky lw lx ly lb lz bi translated">通用中断处理程序</h1><p id="3416" class="pw-post-body-paragraph iv iw hi ix b iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">为什么制作一个能处理所有中断的通用中断处理程序很困难？这仅仅是因为CPU没有将中断号推入堆栈。为了解决这个问题，我们使用了NASM的宏功能。由于一些中断不会产生错误代码，所以值0将被用作它们的“错误代码”。</p><p id="5059" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我们需要一个<code class="du na nb nc mr b"><strong class="ix hj">common_interrupt_handler</strong></code>来完成以下工作:</p><ul class=""><li id="c922" class="ma mb hi ix b iy iz jc jd jg mc jk md jo me js mf mg mh mi bi translated">将寄存器压入堆栈。</li><li id="a6f1" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">调用C函数<code class="du na nb nc mr b">interrupt_handler</code>。</li><li id="efb6" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">从堆栈中弹出寄存器。</li><li id="ed9c" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated"><code class="du na nb nc mr b">esp</code>加8(因为之前推送的错误码和中断号)。</li><li id="b332" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">执行<code class="du na nb nc mr b">iret</code>返回中断代码。</li></ul><p id="35e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以你的代码应该是这样的，</p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h1 id="110f" class="lj kj hi bd kk lk ll lm ko ln lo lp ks lq lr ls kv lt lu lv ky lw lx ly lb lz bi translated">装载IDT</h1><p id="e1f1" class="pw-post-body-paragraph iv iw hi ix b iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">接下来，使用<code class="du na nb nc mr b">lidt</code>汇编代码指令加载IDT，该指令获取表中第一个元素的地址。</p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h1 id="9bbb" class="lj kj hi bd kk lk ll lm ko ln lo lp ks lq lr ls kv lt lu lv ky lw lx ly lb lz bi translated">可编程中断控制器(PIC)</h1><p id="a39c" class="pw-post-body-paragraph iv iw hi ix b iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">我们不能就这样开始使用硬件中断。为此，我们需要配置可编程中断控制器(PIC)。PIC使得将信号从硬件映射到中断成为可能。</p><p id="458a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是我们为什么需要配置它呢？PIC就不能完成任务吗？</p><p id="0a21" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">配置PIC有几个原因，</p><ul class=""><li id="4b75" class="ma mb hi ix b iy iz jc jd jg mc jk md jo me js mf mg mh mi bi translated">重新映射中断。默认情况下，PIC使用中断0-15作为硬件中断，这与CPU中断相冲突。因此，PIC中断必须重新映射到不同的时间间隔。</li><li id="f636" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">选择要接收的中断。你可能不想接收所有设备的中断，因为你没有处理这些中断的代码。</li><li id="b130" class="ma mb hi ix b iy mj jc mk jg ml jk mm jo mn js mf mg mh mi bi translated">为PIC设置正确的模式。</li></ul><p id="df06" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里两张图片链接在一起，以适应16个硬件中断。</p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="59a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个PIC中断都必须得到确认，这意味着必须向PIC发送一条消息，确认中断已被处理。如果不这样做，PIC将停止产生中断。通过向产生中断的PIC发送字节0x20来确认PIC中断。</p><p id="ac69" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，由于键盘中断是由PIC引发的，所以您必须在键盘中断处理程序的末尾调用<code class="du na nb nc mr b"><strong class="ix hj">pic_acknowledge</strong></code>。</p><h1 id="7076" class="lj kj hi bd kk lk ll lm ko ln lo lp ks lq lr ls kv lt lu lv ky lw lx ly lb lz bi translated">从键盘读取输入</h1><p id="d1b7" class="pw-post-body-paragraph iv iw hi ix b iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">接下来我们需要解决的是键盘输入本身。键盘不生成ASCII字符，它生成扫描代码。一个扫描码定义了一个按钮，当它被按下和释放时。可以从键盘上的数据I/O端口(地址为0x60)获得刚刚按下的按钮的扫描代码。</p><figure class="ke kf kg kh fd ij"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="26a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一部分是编写一个函数，将扫描代码翻译成相应的ASCII字符。此代码可能因键盘而异。</p><h1 id="c4dc" class="lj kj hi bd kk lk ll lm ko ln lo lp ks lq lr ls kv lt lu lv ky lw lx ly lb lz bi translated">输出输入</h1><p id="45f5" class="pw-post-body-paragraph iv iw hi ix b iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">现在只需调用<code class="du na nb nc mr b"><strong class="ix hj">serial_write()</strong></code> <strong class="ix hj"> </strong>函数，将从键盘读取的字符传递到串口写入即可。当你打字时，你在屏幕上看不到任何东西(因为我们不是在Bochs控制台上写，而是在串行端口上写)。</p><p id="ab1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你做了所有正确的事情，你会在你的<code class="du na nb nc mr b">com1.out</code>上看到这个。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/e21bb6ec6c88466aaa1856259cc61fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nVFTuSWcU8zqSQj2IjE3A.png"/></div></div></figure><p id="9da9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，如果我们在键盘上输入的任何内容都能在Bochs控制台上显示出来，那不是更好吗？</p><p id="2886" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们不能简单地使用<code class="du na nb nc mr b"><strong class="ix hj">fb_write()</strong></code> <strong class="ix hj"> </strong>功能，因为我们一次只写一个字符，需要相应地移动光标。</p><p id="6176" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，我添加了<code class="du na nb nc mr b"><strong class="ix hj">unsigned int BUFFER_COUNT</strong></code>来记录写在控制台上的字符数。并且增加了一个<code class="du na nb nc mr b"><strong class="ix hj">fb_clear()</strong></code> <strong class="ix hj"> </strong>功能，可以在退格键被按下时擦除一个字符。你可以简单地通过在一个字符上写字来“擦除”它。</p><pre class="ke kf kg kh fd mq mr ms mt aw mu bi"><span id="8e6f" class="ki kj hi mr b fi mv mw l mx my">fb_write_cell( i * 2, ' ', BLACK, BLACK);</span></pre></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><p id="1bb7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你阅读了这篇文章，你可以很容易地使用键盘在Bochs控制台上写东西，就像你看到的第一个gif一样。你现在可以尽情地写了。</p><figure class="ke kf kg kh fd ij er es paragraph-image"><div class="er es nl"><img src="../Images/0c94ecbedec2ce8e7f5deea674ded4d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*S-Fsaz-TvGzpiOgSyTkErg.gif"/></div></figure><p id="3f70" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是如果你有任何麻烦，不要担心。你可以从下面我的GitHub获得完整的代码。</p><div class="nm nn ez fb no np"><a href="https://github.com/HasiniSama/pocketOS/tree/interupt_and_inputs" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab dw"><div class="nr ab ns cl cj nt"><h2 class="bd hj fi z dy nu ea eb nv ed ef hh bi translated">GitHub -中断和输入端的HasiniSama/pocketOS</h2><div class="nw l"><h3 class="bd b fi z dy nu ea eb nv ed ef dx translated">中断驱动的单任务实模式x86操作系统。- GitHub - HasiniSama/pocketOS at…</h3></div><div class="nx l"><p class="bd b fp z dy nu ea eb nv ed ef dx translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od io np"/></div></div></a></div><p id="e6de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望在下一篇文章中也能看到你！</p><p id="dcdf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谢谢大家！</p><p id="bf4a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kc">参考文献:赫林，e .&amp;伦伯格，A. (2015)。</em> <a class="ae iu" href="https://littleosbook.github.io/#getting-to-c" rel="noopener ugc nofollow" target="_blank"> <em class="kc">关于OS开发的小书</em> </a></p><h2 id="3d25" class="ki kj hi bd kk kl km kn ko kp kq kr ks jg kt ku kv jk kw kx ky jo kz la lb lc bi translated">阅读以前的文章</h2><div class="nm nn ez fb no np"><a rel="noopener follow" target="_blank" href="/codex/writing-your-own-operating-system-segmentation-61351ecaa1bd"><div class="nq ab dw"><div class="nr ab ns cl cj nt"><h2 class="bd hj fi z dy nu ea eb nv ed ef hh bi translated">编写自己的操作系统:分段</h2><div class="nw l"><h3 class="bd b fi z dy nu ea eb nv ed ef dx translated">这是OS系列的第四篇文章。它解释了分段和全局描述符表。</h3></div><div class="nx l"><p class="bd b fp z dy nu ea eb nv ed ef dx translated">medium.com</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od io np"/></div></div></a></div><div class="nm nn ez fb no np"><a href="https://hasinisama.medium.com/building-your-own-operating-system-drivers-8adfc889398b" rel="noopener follow" target="_blank"><div class="nq ab dw"><div class="nr ab ns cl cj nt"><h2 class="bd hj fi z dy nu ea eb nv ed ef hh bi translated">构建您自己的操作系统:驱动程序</h2><div class="nw l"><h3 class="bd b fi z dy nu ea eb nv ed ef dx translated">这是OS系列的第三篇文章。它解释了如何在控制台上显示文本，以及如何将数据写入…</h3></div><div class="nx l"><p class="bd b fp z dy nu ea eb nv ed ef dx translated">hasinisama.medium.com</p></div></div><div class="ny l"><div class="of l oa ob oc ny od io np"/></div></div></a></div><div class="nm nn ez fb no np"><a href="https://hasinisama.medium.com/building-your-own-operating-system-2-e66425adb084" rel="noopener follow" target="_blank"><div class="nq ab dw"><div class="nr ab ns cl cj nt"><h2 class="bd hj fi z dy nu ea eb nv ed ef hh bi translated">构建自己的操作系统#2</h2><div class="nw l"><h3 class="bd b fi z dy nu ea eb nv ed ef dx translated">本文解释了如何使用C语言代替汇编代码作为OS开发的编程语言。</h3></div><div class="nx l"><p class="bd b fp z dy nu ea eb nv ed ef dx translated">hasinisama.medium.com</p></div></div><div class="ny l"><div class="og l oa ob oc ny od io np"/></div></div></a></div><div class="nm nn ez fb no np"><a href="https://hasinisama.medium.com/building-your-own-operating-system-980a4498104" rel="noopener follow" target="_blank"><div class="nq ab dw"><div class="nr ab ns cl cj nt"><h2 class="bd hj fi z dy nu ea eb nv ed ef hh bi translated">构建您自己的操作系统</h2><div class="nw l"><h3 class="bd b fi z dy nu ea eb nv ed ef dx translated">本文将描述如何实现可以和GRUB一起使用的最小的操作系统。</h3></div><div class="nx l"><p class="bd b fp z dy nu ea eb nv ed ef dx translated">hasinisama.medium.com</p></div></div><div class="ny l"><div class="oh l oa ob oc ny od io np"/></div></div></a></div></div></div>    
</body>
</html>