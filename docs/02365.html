<html>
<head>
<title>Create Standalone Linux Installer for your Python GUI Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Python GUI应用程序创建独立的Linux安装程序</h1>
<blockquote>原文：<a href="https://medium.com/codex/create-standalone-linux-installer-for-your-python-ai-application-5a31d99f9094?source=collection_archive---------3-----------------------#2021-07-15">https://medium.com/codex/create-standalone-linux-installer-for-your-python-ai-application-5a31d99f9094?source=collection_archive---------3-----------------------#2021-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b6c4d051957bda8f13aaba3226d881f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*esllsUtx1jqAR76b.jpg"/></div></div></figure><p id="cb78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有时你可能需要用python开发你的应用程序的图形用户界面，因为它提供了一种快速简单的方法来创建GUI应用程序。此外，创建python GUI提供了训练模型的机器学习(ML)推理的简单集成。因此，这节省了将ML模型投入生产的时间。</p><p id="63bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用python开发GUI应用程序有很多选择，Tkinter是开发桌面应用程序最流行的库之一。然而，将python应用程序分发给最终用户是很困难的，因为出于保护知识产权或Python开发和最终用户环境之间可能的冲突，我们不希望将我们的源代码与应用程序一起分发。</p><p id="ab7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设置python环境并不容易，尤其是对于非开发人员来说。设置Python环境的典型工作流如下所示。</p><ul class=""><li id="aea6" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">安装特定版本的Python</li><li id="068f" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">设置pip</li><li id="bd0f" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">设置虚拟环境</li><li id="ea24" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">设置应用程序源代码</li><li id="9fdf" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">安装依赖项</li></ul><p id="d376" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可能的选择是使用编译的字节码，但是生成<strong class="is hj">。pyc </strong>文件不能在不同版本的python之间移植，你仍然可以反编译<strong class="is hj"> pyc </strong>文件来进行逆向工程。使用像<a class="ae kc" href="http://www.pyinstaller.org/" rel="noopener ugc nofollow" target="_blank"> PyInstaller </a>和<a class="ae kc" href="https://wiki.python.org/moin/Pyarmor" rel="noopener ugc nofollow" target="_blank"> Pyarmor </a>这样的选项组合将在一定程度上帮助我们保护我们的代码。</p><h1 id="d25a" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">PyInstaller</h1><p id="2c69" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">提供了将python应用程序作为普通包安装程序分发的灵活性。它将Python应用程序及其所有依赖项打包到一个包中。用户可以运行打包的应用程序，而无需安装Python解释器或任何模块。PyInstaller检查您的Python代码并找出依赖项，然后根据操作系统将它们打包成合适的格式。请查看<a class="ae kc" href="https://pyinstaller.readthedocs.io/en/stable/usage.html" rel="noopener ugc nofollow" target="_blank">https://pyinstaller.readthedocs.io/en/stable/usage.html</a>了解PyInstaller命令行中可用选项的更多细节。</p><h1 id="5253" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">皮甲</h1><p id="d219" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">使用命令行工具帮助混淆python脚本。详细解释将在<a class="ae kc" href="https://wiki.python.org/moin/Pyarmor" rel="noopener ugc nofollow" target="_blank">https://wiki.python.org/moin/Pyarmor</a>中提供</p><h1 id="5225" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">制造自我</h1><p id="bf35" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">允许在Unix系统中创建自解压分发包。<a class="ae kc" href="https://makeself.io/" rel="noopener ugc nofollow" target="_blank"> Makeself </a>是一种创建自解压档案的简单方法。</p><h1 id="fd68" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">如何为Python应用程序创建分发包</h1><h2 id="3792" class="lg ke hi bd kf lh li lj kj lk ll lm kn jb ln lo kr jf lp lq kv jj lr ls kz lt bi translated">应用程序结构</h2><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="546e" class="lg ke hi lz b fi md me l mf mg">myapp<br/>  |<br/>  |-- __init__.py<br/>  |-- myapp.py<br/>  |-- anothermod.py<br/>  |--<!-- --> python files and other resources<br/> <!-- --> |__ <strong class="lz hj">dist<br/>  |     |myapp<br/>  |__ makeself_stage<br/>  |     |installer.sh<br/>  |__ build.sh</strong><br/>  | ..</span></pre><p id="8270" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用程序文件夹包含应用程序所需的所有必要的python文件和资源。作为最佳实践，包创建逻辑所需的所有脚本都被分离到<strong class="is hj"> build.sh </strong>文件中。以下是build.sh的分步内容</p><ul class=""><li id="5930" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">在bash脚本中声明Pyarmor路径。这可以作为一个参数传递给脚本。如果您的系统中安装了PyInstaller，Pyarmor会自动检测它。</li></ul><p id="c40e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mh mi mj lz b">PYARMOR</code> ="$HOME/。本地/bin/pyarmor "</p><ul class=""><li id="adc3" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">在这个预处理步骤中，您可以构建和准备您的依赖模块。这包括将二进制文件和库复制到适当的文件夹中</li><li id="b7ef" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">现在用pyarmor生成分发包。Pyarmor提供了“pack”选项，将混淆的脚本打包到包中。该选项使用pyinstaller创建软件包。此外，您可以使用选项“-e”将额外的选项传递给pyinstaller</li></ul><p id="b052" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mh mi mj lz b">${PYARMOR} pack --clean -e '--paths='path_to_search_imports:.' --hidden-import='PIL._tkinter_finder' --add-binary='path_to_lib.so:.' --exclude-module=modules_not_needed --add-data='./Config:Config' --add-data='./*.png:.'' <strong class="is hj">myapp.py</strong></code></p><p id="eb68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Pyarmor默认在/dist中创建捆绑包，您可以通过使用“-O或— output”选项传递输出路径来更改它</p><ul class=""><li id="bb59" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">最后一步是使用makeself从pyarmor from /dist文件夹创建的包文件夹中创建自解压归档文件</li></ul><ol class=""><li id="f90b" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn mk ju jv jw bi translated">设置makeself</li></ol><p id="c3a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">sudo apt-get安装makeself</p><p id="adb4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.在/dist文件夹中创建有效负载或归档文件，以便创建自解压运行文件</p><p id="f7bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mh mi mj lz b">cd dist</code></p><p id="ab01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mh mi mj lz b">tar -cvf myapp_1_0_0.tar -C myapp/ .</code></p><p id="eb94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.创建安装脚本</p><p id="43a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个安装脚本会将myapp_1_0_0.tar解压缩到目标的主目录中。根据不同的用例，可以修改这个脚本来满足需求。它可以是python脚本，但是为了简单起见，它被写成bash脚本。</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="1bca" class="lg ke hi lz b fi md me l mf mg"><strong class="lz hj">makeself_stage/installer.sh</strong></span><span id="5783" class="lg ke hi lz b fi ml me l mf mg">This script should contains following main function </span><span id="ad53" class="lg ke hi lz b fi ml me l mf mg">install_file <br/><br/>install_menu # to create short cut in system application menu<br/>create_desktop_shortcut # desktop shortcut<br/>create_uninstaller # finally uninstaller file in <!-- -->/usr/local/ directory</span><span id="f7f3" class="lg ke hi lz b fi ml me l mf mg">I am not writing all the logic for the creating menu shortcuts. Simple installation function should be like</span><span id="4542" class="lg ke hi lz b fi ml me l mf mg">function install_file() <br/>{ <br/>   echo "Extracting the application package"<br/>   if [ -d <!-- -->$HOME/myapp<!-- -->] <br/>   then<br/>     echo "Application already installed." <br/>     exit 1<br/>   else<br/>     mkdir <!-- -->$HOME/myapp<br/>   fi<br/>   <br/>   <strong class="lz hj">tar -xvf ./</strong><strong class="lz hj">myapp_1_0_0.tar</strong><strong class="lz hj">.tar -C </strong><strong class="lz hj">$HOME/myapp</strong><br/>}</span></pre><p id="a5a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.通过将归档文件复制到暂存目录来运行makeself</p><p id="4e8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">激光唱片..</p><p id="06a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mh mi mj lz b">cp dist/myapp_1_0_0.tar makeself_stage/</code></p><p id="a464" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mh mi mj lz b">makeself ./makeself_stage/ myapp_1_0_0.run "sample package" ./</code>安装人员<code class="du mh mi mj lz b">.sh</code></p><p id="0641" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">makeself的语法如下:</p><p id="da07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mh mi mj lz b">makeself [args] archive_dir file_name label startup_script [script_args]</code></p><ul class=""><li id="58e9" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><code class="du mh mi mj lz b">archive_dir</code>是包含要归档的文件的目录的名称</li><li id="d33d" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><code class="du mh mi mj lz b">file_name</code>是要创建的档案的名称</li><li id="26a1" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><code class="du mh mi mj lz b">label</code>是描述包的任意文本字符串。它将在提取文件时显示。</li><li id="99d7" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><code class="du mh mi mj lz b">startup_script</code>是从提取文件目录中<em class="mm">执行的命令。</em></li></ul><p id="3833" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个论点的细节将在<a class="ae kc" href="https://makeself.io/" rel="noopener ugc nofollow" target="_blank">https://makeself.io/</a>提供</p><h1 id="ec34" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="fe31" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">这种解决方案可能不适用于每个人，但尽量做到通用。它允许Python开发人员创建和分发一个像Linux中的C++程序一样的图形应用程序。这在windows中也可以实现，但是需要根据Windows环境调整脚本。你可能需要使用像<a class="ae kc" href="http://www.jrsoftware.org/isinfo.php" rel="noopener ugc nofollow" target="_blank"> Inno Setup </a>这样的软件，而不是makeself来为windows构建安装程序。通过将pycuda包与应用程序捆绑在一起，AI应用程序可以像这样轻松地分发。</p></div></div>    
</body>
</html>