# 击败英雄(模式)

> 原文：<https://medium.com/codex/never-meet-your-heroes-or-work-with-them-9d35e3d9ed30?source=collection_archive---------26----------------------->

![](img/f56cf8453338de71562d144326034bd3.png)

> 他们说你永远不会见到你的英雄。你钦佩并努力成为的人，并不总是你吹嘘的那样

在软件开发中，我有幸与一些非常聪明的人一起工作。史蒂夫·麦康奈尔称他们为“[10 倍开发人员](http://forums.construx.com/blogs/stevemcc/archive/2008/03/27/productivity-variations-among-software-developers-and-teams-the-origin-of-quot-10x-quot.aspx)”，他们编写代码的速度是“普通开发人员”的 10 倍。或者换句话说，“英雄”每当一个棘手的问题出现时，我们就派他们进去，就像施了魔法一样，他们征服了野兽，拯救了世界。

与英雄一起工作的一个指标是，一旦系统崩溃，团队就会转向英雄——他几乎构建了这个东西，并且自然拥有所有的知识。当需要做出重大决策时，讨论是在闭门造车的情况下进行的，甚至是由一个人(主人公)进行的，而学习结论背后的推理会让团队的其他成员受益。为什么？因为他们什么都知道，而且他们最清楚。
这就是为什么这实际上是一个反模式。

软件开发中英雄的问题？人们根本无法扩展。我们不能通过 API 调用异步访问他们的所有知识，反过来，工作变成了英雄的人质。但与此同时，这也使得这种模式很难打破，因为人们*希望*被依赖并感到有用。毫无疑问，知道自己是不可替代的是一种非常令人满足的感觉，所以可以理解为什么人们想要守护自己的知识并成为英雄。

我们非常重视确保我们不知道软件开发工具包的其他方面。虽然我不想暗示人=工具，但它确实提出了一个问题，即当谈到与人不可知论时，我们为什么放弃这个价值。当然，我们*可以*围绕不一定能做得最好的工具建立一个完整的堆栈。但是只要我们继续使用只做工作的工具，我们就不会给其他任何东西甚至是尝试的机会。同样适用于人。

在最坏的情况下，一个标准开始被设定。一个人做所有的工作，其他人只能是平庸的。团队开始失去对他们工作的所有权和责任，从而导致信心和动力的丧失。随着它的螺旋上升，英雄开始得到任何需要一些先前知识的工作，这需要一些先前的知识…你明白我在说什么。所有有趣的工作都归英雄所有。但这也会导致倦怠。当他们筋疲力尽时，他们开始犯错。这就引出了另一句古老的谚语——越大，摔得越重。

任何真正英雄的理想应该是变得过时，而不是不可替代。