<html>
<head>
<title>Containers Under The Hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引擎盖下的容器</h1>
<blockquote>原文：<a href="https://medium.com/codex/containers-under-the-hood-8d3ef4965fa8?source=collection_archive---------8-----------------------#2021-12-05">https://medium.com/codex/containers-under-the-hood-8d3ef4965fa8?source=collection_archive---------8-----------------------#2021-12-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9618" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了部署我们的应用程序，我们可以使用实际的物理机器，但是一个应用程序可能会干扰另一个应用程序，并可能会导致停机、资源匮乏、同一机器上运行的另一个微服务的安全问题。</p><p id="8b46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，我们可以为每个应用/微服务创建单独的虚拟机，并根据它们的需求分配资源。通过对我们共享的资源进行更多的控制，虚拟机为我们提供了许多好处，如果一个应用程序/微服务出现问题，它只会影响自身，从而保护其他应用程序的安全。虚拟机的所有这些功能都是以性能为代价的。在主机操作系统之上运行整个客户操作系统，只是为了运行我们的代码。虽然，在我们拥有非常高的计算能力的今天，这不会有太大的区别。，但是生成一个新的容器比生成一个新的虚拟机耗时更少，并且有助于减少部署时间</p><p id="c864" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果呢？我们可以减少所有这些性能开销，直接运行具有所有这些虚拟机功能的代码，并节省一些部署时间。这就是容器发挥作用的地方。</p><h1 id="9f79" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">什么是容器？</h1><p id="b01e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">从真正的意义上来说，容器只不过是Linux的一些特性的组合。这些是</p><ul class=""><li id="31fb" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">Linux监狱，又名<strong class="ih hj"> chroot </strong></li><li id="4f67" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">名称空间又名<strong class="ih hj">取消共享</strong></li><li id="b7cb" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">对照组又名<strong class="ih hj">c组</strong></li></ul><p id="13a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们逐一了解他们的目的:</p><h2 id="dc5c" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated"><a class="ae li" href="https://www.gnu.org/software/coreutils/manual/html_node/chroot-invocation.html#chroot-invocation" rel="noopener ugc nofollow" target="_blank"> chroot </a></h2><ul class=""><li id="8e3f" class="kg kh hi ih b ii kb im kc iq lj iu lk iy ll jc kl km kn ko bi translated">这是一个Linux命令，允许我们设置您创建的任何新进程的根目录。让我们创建一个名为“my-container”的新定制容器，并设置其根目录</li></ul><figure class="ln lo lp lq fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lm"><img src="../Images/fc6ef683aaaf220cb1facd8d05ea76e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mleIjyXM79ibbxIu6wfl4w.png"/></div></div></figure><p id="559e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的截图中，我创建了一个名为my-container的目录。现在我试图在my-container目录中设置新的根目录，并运行命令“bash ”,但是失败了。失败的原因是“bash”命令将试图在/bin目录中查找当前不存在的二进制文件。因此，为了成功运行这个命令，让我将bash二进制文件及其库文件手动复制到这个文件夹中。</p><figure class="ln lo lp lq fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es ly"><img src="../Images/4b9c9d9ed16e722112360007f1512e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zD1eCxV5q3T_7s-BHFXPHQ.png"/></div></div></figure><ul class=""><li id="1307" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">在上面的截图中，我已经将bash shell的所有二进制文件及其所有必需的依赖项复制到my-container目录中，并重新运行chroot命令。看到我们的容器被锁定在这个文件系统级别，不知道任何关于它的外部空间。整个容器安装在一个新的根目录下。如果您想隔离容器的文件系统，并且不想让它们查看每个文件，这对于容器来说是至关重要的。</li></ul><h2 id="9d6b" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated">命名空间</h2><ul class=""><li id="f71f" class="kg kh hi ih b ii kb im kc iq lj iu lk iy ll jc kl km kn ko bi translated">chroot 帮助我们隔离文件系统，但是我们的自定义my-container仍然存在一些问题。如果我们复制一些其他重要的二进制文件如ps来列出所有的进程，我们不仅可以看到运行在容器本身中的进程，还可以看到运行在父容器即主机上的所有进程，我们有能力通过使用“sudo kill-9&lt;PID&gt;命令发送<strong class="ih hj"> SIGKIll </strong>信号来破坏其他容器和重要进程。如果我复制ifconfig二进制文件，我们也可以看到主机的网络详细信息。我们需要这些重要的功能，但是希望不共享所有父级进程或同级进程的关键信息，这些信息来自运行在容器本身中的进程。这就是unshare命令发挥作用的地方。</li></ul><figure class="ln lo lp lq fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lz"><img src="../Images/b79c20dc3359a034a5e69b54d44b41ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vU8DvlcWcwit2M7A14E0w.png"/></div></div></figure><p id="26bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的截图中，我又创建了一个名为my-container-2的容器。在这两个容器中，我已经启动了一个tail命令后台进程，分别轮询容器1和容器2中的a.txt和b.txt文件。如果您使用ps命令检查两个容器中的进程，您将能够获得在单独的容器中运行的另一个进程的进程id，并且您将能够轻松地终止在不同容器上运行的进程。这就是我们想要解决的问题，可以使用unshare命令来解决。</p><p id="8bbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了取消主机上运行的所有进程的共享，我们可以使用<strong class="ih hj"> PID名称空间</strong>，子进程将拥有一组与其父进程不同的PID-进程映射。</p><pre class="ln lo lp lq fd ma mb mc md aw me bi"><span id="2454" class="ku je hi mb b fi mf mg l mh mi">unshare --pid chroot my-container-1<br/>unshare --pid chroot my-container-2</span></pre><p id="66fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有不同的命名空间来控制功能并设置许多其他内容的上限，如网络命名空间、挂载命名空间和用户命名空间。停止分享帮助主持人对我们的其他流程更加负责，因为<strong class="ih hj">“权力越大，责任越大。:)"</strong></p><p id="6375" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:使用非共享子进程看不到主机进程，但主机可以。</p><h2 id="0a73" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated">c组</h2><ul class=""><li id="6feb" class="kg kh hi ih b ii kb im kc iq lj iu lk iy ll jc kl km kn ko bi translated">好了，我们已经完成了文件系统隔离，并限制了一些非常重要和有用的命令。剩下的唯一事情就是控制一个单独的进程可以占用多少硬件资源，比如CPU、Ram、网络带宽。我们需要注意这最后一件事，因为一个糟糕的代码或饥饿的微服务可以通过消耗所有硬件资源来关闭所有容器。</li><li id="c270" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">在c-group来拯救我们之前，c-group是由谷歌发明的，并于2007年发布。下面我附上了两张截图，一张是我的主机mac的，一张是我的docker容器的。对于我的docker容器，我已经将docker进程的cpu使用率设置为只使用一个内核，内存使用率为1000MB。</li></ul><figure class="ln lo lp lq fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mj"><img src="../Images/525a19e589bd652e55f1951e3b6b7845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HVaqRM0hxSOgdVAzzq-GSQ.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated">具有8个内核和16GB Ram的主机(Mac)</figcaption></figure><figure class="ln lo lp lq fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mo"><img src="../Images/9e90a414e549eb74af0970bfddfd15b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s11tUXoIb-2Ue-2ALLU-aA.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx translated"><code class="du mp mq mr mb b">#create a controle group</code> Docker容器运行Ubuntu，具有1个内核和1000MB Ram</figcaption></figure><pre class="ln lo lp lq fd ma mb mc md aw me bi"><span id="f4dc" class="ku je hi mb b fi mf mg l mh mi">#create a control group named container-group<br/>cgcreate -g cpu,memory:/container-group</span><span id="b31c" class="ku je hi mb b fi ms mg l mh mi"># add our unshared env to our cgroup<br/>cgclassify -g cpu,memory &lt;container-PID&gt;</span><span id="31c9" class="ku je hi mb b fi ms mg l mh mi">#now we can use cgset command to set cpu and memory upper bound<br/>cgset -r cpu.cfs_period_us=100000 -r cpu.cfs_quota_us=$[ 100000 * $(getconf _NPROCESSORS_ONLN) ] container-group</span><span id="c0b9" class="ku je hi mb b fi ms mg l mh mi">cgset -r memory.limit_in_bytes=1000M container-group</span></pre><p id="4da4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，现在把docker想象成容器的这些关键功能的包装器，帮助我们轻松地自动化这些事情。</p><p id="023e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢你看了这么久。希望你喜欢这篇文章，如果是的话，请点击掌声按钮😜</p></div></div>    
</body>
</html>