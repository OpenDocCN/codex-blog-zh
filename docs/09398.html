<html>
<head>
<title>Scale Your Load Balancer Like Google</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像Google一样扩展您的负载平衡器</h1>
<blockquote>原文：<a href="https://medium.com/codex/load-balancers-how-do-you-scale-them-79a8cb2956cc?source=collection_archive---------7-----------------------#2022-10-18">https://medium.com/codex/load-balancers-how-do-you-scale-them-79a8cb2956cc?source=collection_archive---------7-----------------------#2022-10-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b828b797b61629de1710f13e48590075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wsQrKbKVRsos-ixEHBx57Q.jpeg"/></div></div></figure><h2 id="9078" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">什么是负载平衡器</h2><p id="931f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">当你第一次推出一个网站时，你几乎不用担心任何事情。您启动EC2实例或任何其他服务器，获取其公共IP地址，将该地址映射到您的域，就这样。你完了。但是，当流量开始增加，每秒钟收到数千个请求时，会发生什么呢？您的服务器将会因收到的请求而过载，最终崩溃。</p><p id="049c" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">那你会怎么做？这就是负载平衡器的用武之地。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/6a596760e4ff0acc23a6feacc394656c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PiV5hnSmJKv2NFlxRd0EuQ.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated"><a class="ae kx" href="https://www.nginx.com/resources/glossary/load-balancing/" rel="noopener ugc nofollow" target="_blank">https://www.nginx.com/resources/glossary/load-balancing/</a></figcaption></figure><p id="e532" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们在这里所做的是增加您拥有的服务器数量，以便可以毫无问题地处理增加的流量，并将它们连接到您的负载平衡器。然后，获取负载平衡器所在服务器的IP地址，并将其映射到您网站的域。请求现在到达负载平衡器，它将请求平均分配给应用服务器。</p><p id="8264" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">很好，现在您可以根据需要添加任意多的应用服务器，并为您的网站提供不断增长的流量。<br/>但是等一下，您的负载均衡器也是一个服务器，它必须对它可以处理的请求数量有一个上限，对吗？没错。</p><p id="967c" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在想想像google.com或Amazon.com这样的网站，它们每天服务于数千万个请求。你的硬件再好，也赶不上这个不断增长的数字。</p><p id="dfd6" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">那你是做什么的？很简单，你只需要增加更多的负载均衡器，在它们前面再加一层负载均衡器。与您在扩展应用服务器时所做的一样。就是这样，感谢阅读文章。</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="ky kz l"/></div></figure><p id="cc01" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">嗯，不完全是</strong>。这种方法的问题是，前端层将再次达到它所能服务的流量的上限。</p><p id="3760" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">这时，您需要开始考虑负载均衡器以外的问题，这也是我们将在本文中讨论的内容。</p><h1 id="3844" class="la ir hi bd is lb lc ld iw le lf lg ja lh li lj je lk ll lm ji ln lo lp jm lq bi translated">如何大规模实现负载平衡</h1><p id="ee1d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">这里我们将讨论几种不同的方法。根据您的使用情况和您所服务的流量，它们可能是有用的。</p><h2 id="4bc6" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">1.DNS循环赛</h2><p id="4b2c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">循环法<a class="ae kx" href="https://www.cloudflare.com/learning/dns/what-is-dns/" rel="noopener ugc nofollow" target="_blank"> DNS </a>是一种负载平衡技术，平衡由DNS服务器完成，而不是使用专用的负载平衡硬件。<br/>循环DNS可用于在多个负载平衡器之间平衡负载，其中DNS服务器每次轮流分发与不同LB对应的IP地址。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/c82baaa4c159f8deb7b99c70d8314668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNSSIcylgjRdkzlIj5qspg.png"/></div></div></figure><blockquote class="ls lt lu"><p id="a6b2" class="jo jp lv jq b jr kj jt ju jv kk jx jy lw kl ka kb lx km kd ke ly kn kg kh ki hb bi translated">我们在这里可以看到<strong class="jq hj"> Google </strong>和<strong class="jq hj"> Amazon </strong>使用DNS轮循来实现他们的前端负载平衡。</p></blockquote><p id="cd30" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">在上面的例子中，209.85.203.113 209 . 85 . 203 . 102……可能是不同负载均衡器的公共IP。</p><p id="97f1" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">DNS循环法的问题</strong></p><ol class=""><li id="bf09" class="lz ma hi jq b jr kj jv kk jb mb jf mc jj md ki me mf mg mh bi translated">由于DNS <a class="ae kx" href="https://www.cloudflare.com/learning/cdn/what-is-caching/" rel="noopener ugc nofollow" target="_blank">缓存</a>和<a class="ae kx" href="https://www.cloudflare.com/learning/serverless/glossary/client-side-vs-server-side/" rel="noopener ugc nofollow" target="_blank">客户端缓存</a>，循环法并不总是提供均匀分布的负载平衡。如果用户对特定网站的特别高流量<a class="ae kx" href="https://www.cloudflare.com/learning/dns/dns-server-types#recursive-resolver" rel="noopener ugc nofollow" target="_blank">递归解析器</a>进行DNS查询，该解析器将缓存该网站的IP，可能会向该IP发送大量流量。</li><li id="d68d" class="lz ma hi jq b jr mi jv mj jb mk jf ml jj mm ki me mf mg mh bi translated">另一个缺点是不能依靠循环法来保证站点的可靠性；如果其中一台服务器出现故障，DNS服务器仍将在循环轮换中保留该服务器的IP。因此，如果有六台服务器，其中一台离线，六分之一的用户将被拒绝服务。此外，循环DNS不考虑服务器负载、交易时间、地理距离和其他可以配置传统负载平衡的因素。</li></ol><h2 id="9723" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 2。基于地理位置的负载平衡</strong></h2><p id="dd77" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">让我们假设你的网站现在在世界各地都很有名，并且为欧洲、美洲和亚洲的用户提供流量服务。<br/>您的负载平衡器和应用服务器在印度。这产生了两个主要问题。<br/> 1。往返时间:-由于服务器位于印度，美国用户的请求必须穿越半个世界并返回。<br/> 2。特定于地区的信息:-作为一个产品所有者，你会希望向一个在中国而不是在美国的用户显示不同的网站。</p><p id="4196" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">这两个问题都有一个简单的解决方案。<a class="ae kx" href="https://en.wikipedia.org/wiki/GeoDNS" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">基于地理位置的DNS </strong> </a> <strong class="jq hj"> </strong>或<strong class="jq hj"/><a class="ae kx" href="https://jameshfisher.com/2017/02/08/how-does-geodns-work/" rel="noopener ugc nofollow" target="_blank">geodn</a>。这样，DNS现在将根据用户的位置为您的网站解析不同的IP地址。您可以将位于中国的用户重定向到离该位置最近的服务器，以确保最少的往返时间，并使服务器能够公开特定于该地理位置的内容。</p><p id="b6bf" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">但是话说回来，它对扩展负载平衡器有什么帮助呢？有了这个GeoDNS特性，您现在可以在不同的区域拥有不同的负载平衡器，并分别扩展每个堆栈。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/4ca68057338a8d942a592aae5c56b504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*sIgqWJrCqZ5yRRUPE8HAag.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">基于GeoDNS的负载均衡</figcaption></figure><p id="a172" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">在上面的例子中，对于同一个URL example.com，一个在法国的用户将总是得到一个192.0.0.2的IP地址，而一个在美国的用户得到192.0.0.1的IP地址。</p><blockquote class="ls lt lu"><p id="bb8e" class="jo jp lv jq b jr kj jt ju jv kk jx jy lw kl ka kb lx km kd ke ly kn kg kh ki hb bi translated"><strong class="jq hj">亚马逊(至少在内部)</strong>广泛使用<strong class="jq hj"> </strong>这种负载均衡。我做过的微服务几乎都用这个。</p></blockquote><p id="6f65" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">基于地理位置的负载平衡问题</strong></p><ol class=""><li id="a5ee" class="lz ma hi jq b jr kj jv kk jb mb jf mc jj md ki me mf mg mh bi translated">您几乎不可能遇到这个问题，但是使用这种方法，您仍然会受到负载平衡器在一个区域中所能提供的流量的限制。我们仍然面临着最初开始时的问题，但现在你将在区域一级而不是全球一级面临它。</li><li id="9a57" class="lz ma hi jq b jr mi jv mj jb mk jf ml jj mm ki me mf mg mh bi translated">并非所有DNS提供商都提供GeoDNS。亚马逊Route53为你提供了这种能力，而CloudFare没有。</li></ol><h2 id="b5ad" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">3.通过ECMP + BGP路由实现负载均衡</h2><p id="fa7a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">在我们试图了解如何扩展我们的负载平衡设备之前，让我们先了解一下ECMP和BGP协议。</p><p id="8dcb" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">等价多路径<br/> </strong>通常，我们认为IP地址指的是一台物理机器，而路由器指的是将数据包移动到距离该机器最近的下一个路由器。在最简单的情况下，总是有一个最佳的下一跳，路由器选择这一跳，并转发所有的数据包，直到到达目的地。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/ad4a7f8bcdf9ab2933c50beb2a266bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/0*OCgJ5RUNE2h9ydeA.png"/></div></figure><p id="2fd0" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">事实上，大多数网络要复杂得多。两台机器之间通常有多条路径可用，例如，当有多个ISP可用时，甚至当两台路由器通过多条物理电缆连接在一起以增加容量和提供冗余时。这就是<a class="ae kx" href="https://en.wikipedia.org/wiki/Equal-cost_multi-path_routing" rel="noopener ugc nofollow" target="_blank">等价多路径(ECMP)路由</a>发挥作用的地方——路由器不是选择单个最佳下一跳，它们有多个相同开销的跳，而是散列流量，以便在所有等价的可用路径上平衡连接。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/73892626e53bb9fdeac39be9e96ea7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/0*6zl0h5NPYYQy4lSd.png"/></div></figure><p id="afb0" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">ECMP是通过对每个数据包进行哈希运算来确定一条相对一致的可用路径来实现的。此处使用的哈希函数因设备而异，取决于源和目的IP地址以及TCP流量的源和目的端口。这意味着同一正在进行的TCP连接的多个数据包通常会经过相同的路径，这意味着即使路径具有不同的延迟，数据包也会以相同的顺序到达。值得注意的是，在这种情况下，路径可以在不中断连接的情况下改变，因为它们将总是在同一个目标服务器上结束，并且在这一点上，它们采用的路径基本上是不相关的。</p><p id="d659" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">边界网关协议<br/> </strong>坦率地说，BGP是一个非常庞大的话题，也是我们今天所知的互联网的构建模块之一。<a class="ae kx" href="https://en.wikipedia.org/wiki/Border_Gateway_Protocol" rel="noopener ugc nofollow" target="_blank">这个</a>是维基百科的定义。<br/>就本文而言，我们需要了解的是，您可以使用BGP来广播您的相邻路由。有了BGP，你还可以向互联网广播你离一个IP地址只有一跳之遥。</p><p id="e461" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">这个理论很好，但是我们该如何将它用于我们的目的呢？</p><blockquote class="ls lt lu"><p id="ff3e" class="jo jp lv jq b jr kj jt ju jv kk jx jy lw kl ka kb lx km kd ke ly kn kg kh ki hb bi translated">我将首先举一个简单的例子来理解这两种协议的优点。</p></blockquote><p id="173d" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">让我们假设我们已经保留了IP地址1.2.3.4。我们可以启动n台负载均衡器主机，然后这些主机将使用BGP协议向互联网广播它们距离IP 1.2.3.4只有1跳的距离。通过这种方式，使用BGP协议，我们基本上扩展了我们的负载平衡器堆栈。在任何时候，您都可以将更多的服务器添加到您的负载平衡设备中，广播该服务器距离您保留的IP地址只有1跳的距离，就这样。</p><p id="e80b" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">但是这种设置仍然有一个问题。您有n个负载平衡服务器，但是您如何知道它们之间的流量是平均分布的，或者至少是均匀分布的呢？考虑这样一种情况:所有流量仍然只被路由到一台服务器。这是ECMP的闪光点。<br/> 如上所述，如果路由器支持ECMP，它将确保流量在到达目的地的成本相同的节点之间平均分配。在我们的例子中，我们所有的n个负载平衡服务器都离1.2.3.4有1跳的距离，所以路由器将确保请求在每个服务器之间分配。</p><h2 id="ba4e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">3.1.L7 ECMP + BGP负载均衡</h2><p id="5e4e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">现在让我们从架构的角度来看看上面的例子是什么样子的。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/10af9e7ffdc20115ce140c57a0e71be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*yTCr1kGPBwmEmGncH10oLw.png"/></div><figcaption class="kt ku et er es kv kw bd b be z dx translated"><strong class="bd is"> L7 ECMP + BGP负载均衡</strong></figcaption></figure><p id="ac3a" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在，基于上面的配置，您可以水平扩展您的负载平衡器设备，并拥有无限的扩展能力。在任何时候，当你的负载均衡器过载时，你只需要再增加一个LB就可以了。<br/>但是这种解决方案有一个主要问题，即<strong class="jq hj"/><strong class="jq hj">路由器的无状态特性。</strong></p><p id="1d87" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">这种方法的问题</strong></p><p id="2a3d" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">如上所述，路由器不维护连接状态。为了选择与ECMP的下一跳，它们根据源和目的IP地址进行哈希运算。当路由器和负载平衡器之间的拓扑被扰乱时，就会出现问题。</p><p id="ab19" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">添加或删除负载平衡器时，目的地的可用路由数量会发生变化。路由器使用的哈希算法不一致，流在可用的负载平衡器之间重新洗牌，破坏了现有的连接。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/5cd7a03a8f36929282d954a4c11b8b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*CnA13Sp7IrEPcfmI4lKfQQ.png"/></div></figure><p id="c0bc" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">此外，每个路由器可以选择自己的路由，也可能有不同的缓存算法。当一个路由器变得不可用时，第二个路由器可能会以不同的方式路由相同的流。</p><p id="786e" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">如果您需要处理长时间的连接，如文件下载、视频流或网络套接字连接，这种解决方案肯定是行不通的。</p><blockquote class="ls lt lu"><p id="8079" class="jo jp lv jq b jr kj jt ju jv kk jx jy lw kl ka kb lx km kd ke ly kn kg kh ki hb bi translated">如果所有的路由器都使用一致的散列法，这些问题可以被最小化。在添加新的负载平衡器的情况下，一致的散列将确保连接的重新洗牌最小化，并且由于所有路由器使用相同的散列算法，即使添加或移除了路由器，分组也将被定向到相同的LB。</p></blockquote><h2 id="af11" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 3.2 L4-L7与ECMP + BGP分裂</strong></h2><p id="14bd" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">现在，在所有的方法和努力之后，我们仍然不能建立理想的解决方案。<br/>需要记住的一点是，上述方法的问题是路由器是无状态的，甚至是哑的。拓扑结构的任何变化都会导致所有连接的混乱。<br/>我们已经讨论了ECMP的一致性哈希如何解决这个问题，但是要确保所有路由器都以相同的方式设置是不可能的，除非您使用定制路由器预先加载整个网络。</p><p id="1ce0" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">因此，要解决上述问题，如果我们引入一个能够管理L7负载均衡器群和路由器之间的连接的层，我们应该会做得很好。</p><p id="8a2e" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">这就是L4-L7分裂出现的原因</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/aa82532440cdb6f6ef856d939259f622.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*kHUOmthPup-peqb6JNqCtQ.png"/></div></figure><p id="0164" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">有了另一层服务器来管理连接，我们可以完全控制通过L7 LB建立的连接，这是路由器所不具备的。</p><p id="978f" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">让我们看看如何使用L4负载平衡器解决上述问题。</p><p id="15cb" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">添加/删除L4 LB或路由器<br/> </strong>这些L4 LB完全在我们的控制之下，我们可以确保我们想要使用哪种算法来进行哈希运算。不管路由器或者甚至L4服务器是否被移除，所有运行的服务器将使用相同的散列算法，并且对于给定的源和目的地IP对，将分组定向到相同的L7 LB。</p><p id="5319" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">添加/删除L7负载平衡器<br/> </strong>即使我们启用了一致哈希，当您在最后一层添加或删除服务器时，哈希函数的输出也会发生变化，因为任何哈希都会考虑服务器的总数。<br/>那么，我们如何解决这个问题呢？这是L4层的亮点。<br/>现在您已经完全控制了这些服务器。通过保存一个连接表，可以确保已经建立的连接仍然路由到同一个LB。您可以使用<a class="ae kx" href="https://kubernetes.io/blog/2018/07/09/ipvs-based-in-cluster-load-balancing-deep-dive/" rel="noopener ugc nofollow" target="_blank"> IPVS </a>为您的L4负载平衡器提供负载平衡和连接管理。</p><blockquote class="ls lt lu"><p id="de4c" class="jo jp lv jq b jr kj jt ju jv kk jx jy lw kl ka kb lx km kd ke ly kn kg kh ki hb bi translated">谷歌创造了<a class="ae kx" href="https://research.google/pubs/pub44824/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">磁悬浮</strong></a>Github创造了<a class="ae kx" href="https://github.blog/2018-08-08-glb-director-open-source-load-balancer/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> GLB </strong> </a>它们使用相同的原理来实现它们的负载平衡解决方案。</p></blockquote><p id="f060" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">上述方法的问题</strong></p><ol class=""><li id="da28" class="lz ma hi jq b jr kj jv kk jb mb jf mc jj md ki me mf mg mh bi translated"><strong class="jq hj">复杂性</strong> :-除非绝对需要，否则您为什么会选择这种解决方案？有如此多的层次和如此复杂的设置，你最好使用AWS或Google cloud提供的LB。</li><li id="ba1e" class="lz ma hi jq b jr mi jv mj jb mk jf ml jj mm ki me mf mg mh bi translated"><strong class="jq hj">L4和L7 LB同时发生变化</strong> :-假设在两层都添加了新的服务器，我们现在有一个没有连接表的L4服务器，而随着L7主机数量的增加，哈希函数返回不同的输出。在这种情况下，来自新L4 LB的所有连接将被转发到不同的L7 LB。</li></ol></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><p id="de8e" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">这就是了。在本文中，我们讨论了扩展负载均衡器的4种方法，老实说，我们大多数人，包括我，都不需要这些方法。但是希望你比以前有更多的答案。</p><blockquote class="ls lt lu"><p id="4168" class="jo jp lv jq b jr kj jt ju jv kk jx jy lw kl ka kb lx km kd ke ly kn kg kh ki hb bi translated">此外，我希望对这些技术有更多的了解，并愿意致力于它们的实现。如果有人感兴趣，请联系:)</p></blockquote><p id="9036" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">如果你喜欢这篇文章，并希望我写更多，请跟我来。<br/>通过<a class="ae kx" href="https://www.linkedin.com/in/himanishmunjal/" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">Linkedin</strong></a><strong class="jq hj">联系我了解更多信息。</strong></p><h1 id="3074" class="la ir hi bd is lb lc ld iw le lf lg ja lh li lj je lk ll lm ji ln lo lp jm lq bi translated">参考</h1><p id="e6d0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated"><a class="ae kx" href="http://wtarreau.blogspot.com/2006/11/making-applications-scalable-with-load.html" rel="noopener ugc nofollow" target="_blank">http://wtarreau . blogspot . com/2006/11/making-applications-scalable-with-load . html</a><br/>T3】https://www . bizety . com/2017/01/17/Facebook-billion-user-load-balancing/<br/><a class="ae kx" href="https://github.blog/2018-08-08-glb-director-open-source-load-balancer/" rel="noopener ugc nofollow" target="_blank">https://github . blog/2018-08-08-GL b-director-open-source-load-balancer/</a><br/><a class="ae kx" href="https://vincent.bernat.ch/en/blog/2018-multi-tier-loadbalancer" rel="noopener ugc nofollow" target="_blank">https</a></p></div></div>    
</body>
</html>