<html>
<head>
<title>JAVA Virtual Machine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JAVA虚拟机</h1>
<blockquote>原文：<a href="https://medium.com/codex/java-virtual-machine-e3098cb18b7b?source=collection_archive---------20-----------------------#2022-06-16">https://medium.com/codex/java-virtual-machine-e3098cb18b7b?source=collection_archive---------20-----------------------#2022-06-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1c12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虚拟并不在现实中，所以它是一个对用户来说看起来真实的环境的模拟。</p><p id="8e83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虚拟机是提供与物理计算机相同功能的计算机体系结构。专用硬件、软件或两者的组合可用于它们的实现中。</p><p id="936f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java虚拟机是一种允许计算机运行Java应用程序以及其他已经编译成Java字节码的语言的虚拟机。</p><p id="10a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在虚拟机中，我们可以将其描述为两个部分；</p><p id="a82f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 1。SVM —基于系统的虚拟机</strong></p><p id="4b61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SVM包含真正的硬件，它创建了一个允许大量用户或实例同时运行的环境。因为有好几个环境，每一个都自成体系。</p><p id="df7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:VMWare，Xen。</p><p id="c50e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。AVM —基于应用的虚拟机</strong></p><p id="6cea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与SVM不同，这些虚拟机中没有物理硬件。相反，它有实际用途。该应用程序有助于创建一个允许其他应用程序运行的平台。这个平台接受一些输入，并把它们转换成各种输出或一种每个人都能理解的语言。基于方法的虚拟机是这一过程的结果。</p><p id="4c2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:- JVM，PVM</p><p id="9fc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个基于应用程序的虚拟机包括JVM。它是解释事情应该如何做的规范。</p><p id="0d84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们不能直接从互联网上获得这个JVM，因为它在现实世界中并不存在，但是它带有JAVA运行时环境(JRE ),我们可以很容易地从互联网上获得。当我们在计算机上安装JRE时，它会安装必要的代码来设置JVM。</p><p id="9b4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">平台独立性是JAVA的一个特性，然而平台依赖性是JRE的一个特性。</p><p id="9241" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们启动一个JAVA程序时，JVM读取类文件，并将它们转换成操作系统能够理解的语言。</p><p id="3911" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">创建JVM </strong></p><p id="a8d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们启动一个程序时，它会在计算机上创建一个JVM实例，当我们退出应用程序时，这个JVM实例就会死去。</p><p id="6a67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们同时执行两个或多个应用程序时，每个应用程序都有自己的Java虚拟机(JVM)。</p><p id="af13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦创建了JVM实例，它就创建一个非恶魔线程。每个Java应用程序中都有一个公共的静态main方法。这个先前构建的JVM实例继续使用这个主函数执行Java应用程序。我们现在有了一个能够创建非恶魔线程的恶魔线程。</p><p id="0b77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">销毁JVM实例的方法</strong></p><p id="ac14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果程序中没有非恶魔线程，这意味着我们已经杀死了所有产生的非恶魔线程。之后，JVM实例将自行到期。</p><p id="8fb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">调用系统退出机制。</p><p id="d140" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> JDK — Java开发套件</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/32ee7004cd95ffb7e2b7c4a321181d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/0*nepfdGEQI2gAVWxO"/></div></figure><p id="2513" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM是Java运行时环境(JRE)的一个组件。这个JVM中有三个关键组件。</p><ul class=""><li id="ee0e" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">类别载入器—载入</li><li id="547f" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">存储区—商店</li><li id="4b32" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">执行引擎—执行</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es jz"><img src="../Images/eabd12db4513754e83b8b7c13c88e122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dYJ-psf6NDHBi-Zx"/></div></div></figure><p id="bc51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记忆有5个主要部分:</p><p id="6dc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">方法区域——在JVM中加载时，这将加载类信息。</p><p id="3a97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">堆区域——在JVM中加载之后，这里是收集所有对象数据的地方..</p><p id="d62f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">堆栈—它维护方法信息以及线程中的局部变量。</p><p id="79f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PC寄存器—如果执行了非本机方法，这将保存有关线程中下一次执行的信息。</p><p id="bcec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本机方法区域—这允许将本机方法存储在线程中。</p><p id="1f22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> JVM数据类型</strong></p><p id="b99d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Java中的类型分为两类；</p><ul class=""><li id="0f1a" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">原始类型</li></ul><p id="0b4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Ex-:布尔型、字节型、字符型、短整型、长型、浮点型和双精度型</p><ul class=""><li id="72f8" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">参考类型</li></ul><p id="d3c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Ex-:类，指定对象和所有其他对象的类型。</p><p id="534b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">字号</strong></p><p id="d45f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在JVM中，字长为32位。JVM中只有几种原始数据类型:byte (8位)、short (16位)、int (32位)、long (64位)、float (32位)、double (64位)和char (32位)(16位)。</p><p id="5f78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">级装载机</strong></p><p id="c6e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类加载器负责在运行时将Java类动态加载到JVM中。它们也包含在JRE (Java运行时环境)中。结果，由于有了类装入器，JVM不需要知道底层文件或文件系统就可以运行Java程序。</p><p id="24b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">java初始化一个类有4种方法</p><p id="63a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用新关键字-为每个变量赋值。</p><p id="6f4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用现有对象的克隆方法—复制现有对象。</p><p id="ffd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用反射API (getInstance()方法)—完成设置后，变量将被赋予一个初始值。</p><p id="fddf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">IO。ObjectInputStream()并可以获取一个对象—为输入流中的非瞬态变量赋值。</p><p id="8e67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【java如何通过构造函数实例化父类</p><p id="8906" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编译这段代码时，JVM为每个构造函数生成一个init()函数。构造函数内部发生的事情决定(取决于)init()过程内部发生的事情。如果构造函数(子类)不包含任何内容，init方法有权调用父类(人类)的默认构造函数。</p><p id="ef9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">这个init函数可能包含三种不同类型的代码。</strong></p><ul class=""><li id="e1e4" class="jl jm hi ih b ii ij im in iq jn iu jo iy jp jc jq jr js jt bi translated">调用一些其他的构造函数init方法</li><li id="6990" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">初始化实例变量。</li><li id="7c96" class="jl jm hi ih b ii ju im jv iq jw iu jx iy jy jc jq jr js jt bi translated">具有特定实现的字节码</li></ul><p id="80ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> JVM参数/ JAVA类路径</strong></p><p id="fc41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JVM参数是在应用程序启动时传递给Java虚拟机的标志。在Linux或Mac机器上，它们可以通过whd.conf文件中的JAVA_OPTS设置来提供。</p><p id="9e2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">输出—打印/Application.java中的内容</strong></p><p id="f6bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们通过将Application.java放在“b”目录中，然后将Application.java放在“a”目录中来改变类路径，我们将得到期望的结果。</p><p id="d4ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论</strong></p><p id="ccec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果类路径中有两个相同的类，JVM会考虑第一个。类路径中的第一个类是JVM将要运行的类。当我们得到JVM参数时，这种情况就改变了；在这种情况下，JVM采用类路径上的最后一个类。</p></div></div>    
</body>
</html>