<html>
<head>
<title>Draw SVG shapes in Angular (Polygons).</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以角度(多边形)绘制SVG形状。</h1>
<blockquote>原文：<a href="https://medium.com/codex/draw-svg-shapes-in-angular-polygons-897bfb4614fc?source=collection_archive---------1-----------------------#2022-10-14">https://medium.com/codex/draw-svg-shapes-in-angular-polygons-897bfb4614fc?source=collection_archive---------1-----------------------#2022-10-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f10b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上一篇文章中，我解释了最低要求，这样我们就可以开始在web浏览器中使用Angular在SVG元素中绘制形状。本质上，我们有一个处理呈现逻辑的指令和一个处理表示逻辑的组件。</p><p id="7b03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将解释如何在SVG元素中绘制多边形并与之交互。</p><h1 id="ab0f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">绘制多边形</h1><p id="715b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">多边形是用来表示至少有三条边或三个点的图形的元素。如果您看一下代码，一个多边形元素看起来像这样:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="b775" class="kp je hi kl b fi kq kr l ks kt">&lt;polygon points="280,118 455,30 496,114 382,170"&gt;&lt;/polygon&gt;</span></pre><p id="ce6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果要画多边形，必须要有<strong class="ih hj"> <em class="ku">点</em> </strong>属性，无非就是一组用空格分割的坐标。但是我们在哪里可以找到这些坐标呢？这里有一个插图，让您能够描绘SVG元素的轴。</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kv"><img src="../Images/0ccc6bcc1156802dc79e5112522ed449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJXuIR6HztXSMB4-1SxuBA.png"/></div></div></figure><p id="3b4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们想要用鼠标交互来绘制多边形，所以可以想象在每次鼠标点击后都可以提取坐标。</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es ld"><img src="../Images/9157dbf834a96163a7554e04aa635bcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9lqGQ2uw0j4V6Mgh23H-lQ.gif"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">绘制多边形</figcaption></figure><p id="ebf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们开始编写指令内部的逻辑。我也将使用<a class="ae li" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank"> d3库</a>，它对创建具有多种属性的不同类型的形状有很好的支持。</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="2e0b" class="kp je hi kl b fi kq kr l ks kt">@Directive({<br/>  selector: '[appSvg]'<br/>})</span><span id="0d07" class="kp je hi kl b fi lj kr l ks kt">export class SvgDirective {</span><span id="3cd9" class="kp je hi kl b fi lj kr l ks kt">  private points: Array&lt;[number, number]&gt; = [];<br/>  private currentLine?: d3.Selection&lt;SVGLineElement, unknown, null, any&gt;;</span><span id="4675" class="kp je hi kl b fi lj kr l ks kt">  constructor(private elementRef: ElementRef, private renderer: Renderer2) { }</span><span id="df78" class="kp je hi kl b fi lj kr l ks kt">  @HostListener('mousedown', ['$event'])<br/>  onMouseDown(event: MouseEvent): void {<br/>		// Create the polygon only if we have three or more points <br/>    // and we are clicking on the rectangular helping shape<br/>    if ((event.target as HTMLElement).tagName === 'rect' &amp;&amp; this.points.length &gt;= 3) {<br/>      this.createPolygon();<br/>      this.clearHelperShapes();<br/>    } else {<br/>			// Otherwise, create another helping line or rectangular<br/>      this.addHelperShapes(event);<br/>    }<br/>  }</span><span id="5c30" class="kp je hi kl b fi lj kr l ks kt">  @HostListener('mousemove', ['$event'])<br/>  onMouseMove(event: MouseEvent): void {<br/>    let coordinates = this.getMousePosition(event);<br/>    if ((event.target as HTMLElement).tagName === 'rect' &amp;&amp; this.points.length &gt;= 3) {<br/>      this.renderer.setAttribute(event.target, 'stroke', '#0784fa');<br/>    } else {<br/>      let rect: SVGRectElement | null = document.querySelector('rect');<br/>      if (rect) {<br/>        this.renderer.setAttribute(rect, 'stroke', 'transparent');<br/>      }<br/>    }<br/>    // Move line by changing the coordinates<br/>    if (this.currentLine) {<br/>      this.currentLine.attr('x2', coordinates.x).attr('y2', coordinates.y)<br/>    }<br/>  }</span><span id="ffaa" class="kp je hi kl b fi lj kr l ks kt">  /**<br/>   * After each mouse click, we add a point into the array of polygon coordinates<br/>   * and insert the next helping line.<br/>   * @param event Mouse Event<br/>   */<br/>  private addHelperShapes(event: MouseEvent) {<br/>    let coordinates = this.getMousePosition(event);<br/>    this.points.push([coord.x, coord.y]);</span><span id="f3f2" class="kp je hi kl b fi lj kr l ks kt">    if (this.points.length == 1) {<br/>      d3.select(this.elementRef.nativeElement).append('rect')<br/>        .attr('x', coordinates.x - 5)<br/>        .attr('y', coordinates.y - 5)<br/>        .attr('width', '10')<br/>        .attr('height', '10')<br/>        .attr('fill', 'transparent')<br/>        .attr('class', 'help')<br/>    }</span><span id="12e9" class="kp je hi kl b fi lj kr l ks kt">    this.currentLine = d3.select(this.elementRef.nativeElement)<br/>      .insert('line', ':nth-child(1)')<br/>      .attr('x1', coordinates.x)<br/>      .attr('x2', coordinates.x)<br/>      .attr('y1', coordinates.y)<br/>      .attr('y2', coordinates.y)<br/>      .attr('stroke', '#0784fa')<br/>      .attr('class', 'help')<br/>  }</span><span id="ce3f" class="kp je hi kl b fi lj kr l ks kt">	/**<br/>   * Create a polygon shape<br/>   * @param event Mouse Event<br/>   */<br/>  private createPolygon() {<br/>    d3.select(this.elementRef.nativeElement)<br/>      .append("polygon")<br/>      .attr("points", this.points.join(' '))<br/>      .attr("fill", "lightgrey")<br/>      .attr("stroke", "black")<br/>      .attr('stroke-width', '0.2')<br/>  }</span><span id="f7da" class="kp je hi kl b fi lj kr l ks kt">	/**<br/>   * Get the mouse coordinates relative to the SVG element<br/>   * @param event Mouse Event<br/>   */<br/>  private getMousePosition(event: MouseEvent) {<br/>    return {<br/>      x: event.offsetX,<br/>      y: event.offsetY<br/>    }<br/>  }</span><span id="93b8" class="kp je hi kl b fi lj kr l ks kt">	/**<br/>   * Clear the helping lines and rectangular<br/>   * @param event Mouse Event<br/>   */<br/>  private clearHelperShapes() {<br/>    document.querySelectorAll('.help')<br/>    .forEach(element =&gt; {<br/>      element.remove();<br/>    });<br/>    this.points = [];<br/>  }<br/>}</span></pre><h1 id="c077" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">移动多边形</h1><p id="6be2" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">要移动多边形，你需要三样东西:</p><ul class=""><li id="7607" class="lk ll hi ih b ii ij im in iq lm iu ln iy lo jc lp lq lr ls bi translated">点的当前坐标。</li><li id="c838" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">元素引用。</li><li id="a728" class="lk ll hi ih b ii lt im lu iq lv iu lw iy lx jc lp lq lr ls bi translated">鼠标的当前坐标。</li></ul><p id="f8f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，为了达到预期的效果，您只需要在按下鼠标时移动多边形，因此我们有一个拖放行为。</p><figure class="kg kh ki kj fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es ld"><img src="../Images/e53cda6a5d384debd62def636588789d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6mLSeoU3bshX5oK34UJEbQ.gif"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">移动多边形</figcaption></figure><p id="c886" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们深入编码</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="9ef6" class="kp je hi kl b fi kq kr l ks kt">@Component({<br/>  selector: 'app-root',<br/>  template: `&lt;svg appSvg style="border: 1px solid black;" width="1000" height="700" &gt;<br/>  &lt;polygon points="477,175 579,281 407,318" fill="lightgrey" stroke="black" stroke-width="0.2"&gt;&lt;/polygon&gt;<br/>  &lt;/svg&gt;`,<br/>})</span><span id="9adb" class="kp je hi kl b fi lj kr l ks kt">@Directive({<br/>  selector: '[appSvg]'<br/>})</span><span id="682b" class="kp je hi kl b fi lj kr l ks kt">export class SvgDirective {</span><span id="2c35" class="kp je hi kl b fi lj kr l ks kt">  private draggingPoints: number[][] = [];<br/>  private draggingElement?: d3.Selection&lt;SVGPolygonElement, unknown, null, any&gt;;<br/>  private currentPoint: { x: number, y: number } = { x: 0, y: 0 };<br/>  private mousedown = false;<br/>  <br/>  constructor(private elementRef: ElementRef, private renderer: Renderer2) { }</span><span id="7c08" class="kp je hi kl b fi lj kr l ks kt">  @HostListener('mousedown', ['$event'])<br/>  onMouseDown(event: MouseEvent): void {<br/>    this.mousedown = true;<br/>    let coordinates = this.getMousePosition(event);<br/>    let target = (event.target as SVGPolygonElement);<br/>    if (target.tagName === 'polygon') {<br/>      this.currentPoint = coordinates;<br/>      this.draggingElement = d3.select(target);<br/>      this.draggingPoints = this.getPointsFromPolygon();<br/>    }<br/>  }</span><span id="9e04" class="kp je hi kl b fi lj kr l ks kt">  @HostListener('mousemove', ['$event'])<br/>  onMouseMove(event: MouseEvent): void {<br/>    let coordinates = this.getMousePosition(event);<br/>    if (!!this.draggingElement &amp;&amp; this.mousedown) {<br/>        document.body.style.cursor = 'move';<br/>        let x = coordinates.x - this.currentPoint.x;<br/>        let y = coordinates.y - this.currentPoint.y;<br/>        let h = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));<br/>        let angle = this.angleFromCoordinates(x, y);<br/>        var newPoints = this.polygonTranslate(this.draggingPoints, angle, h);<br/>        this.draggingElement.attr('points', newPoints.join(" "));<br/>    }<br/>  }</span><span id="535a" class="kp je hi kl b fi lj kr l ks kt">  @HostListener('mouseup', ['$event'])<br/>  onMouseUp(event: MouseEvent): void {<br/>    this.mousedown = false;<br/>    this.draggingElement = undefined;<br/>    this.renderer.setStyle(document.body, 'cursor', 'initial');<br/>  }<br/>  /**<br/>   * Get the angle from two coordinates<br/>   */<br/>  angleFromCoordinates(x: number, y: number) {<br/>    let rad = Math.atan2(y, x)<br/>    var pi = Math.PI<br/>    let angle = Math.round(rad * (180 / pi))</span><span id="2395" class="kp je hi kl b fi lj kr l ks kt">    if (angle &lt; 0) {<br/>      angle = angle + 360<br/>    }<br/>    return angle<br/>  }<br/>  /**<br/>   * Translate current polygon into a new one<br/>   * @param polygon An array of polygon coordinates<br/>   * @param angle The angle created by the polygon and the current mouse position<br/>   * @param distance The distance from the polygon to the mouse position<br/>   * @returns <br/>   */<br/>  polygonTranslate(polygon: number[][], angle: number, distance: number) {<br/>    let p = [];<br/>    for (let i = 0, l = polygon.length; i &lt; l; i++) {<br/>      const r = angle / 180 * Math.PI;<br/>      p[i] = [polygon[i][0] + distance * Math.cos(r), polygon[i][1] + distance * Math.sin(r)];<br/>    }<br/>    return p;<br/>  }<br/>  /**<br/>   * Extract the points of current polygon<br/>   * @param event Mouse events<br/>   */<br/>  getPointsFromPolygon(): number[][] {<br/>    let points: Array&lt;{x: number, y: number}&gt; = this.draggingElement?.property('points');<br/>    let pointsArray = []<br/>    for (let i = 0; i &lt; points.length; i++) {<br/>      pointsArray.push([points[i].x, points[i].y])<br/>    }<br/>    return pointsArray<br/>  }</span><span id="23c3" class="kp je hi kl b fi lj kr l ks kt">  private getMousePosition(event: MouseEvent) {<br/>    return {<br/>      x: event.offsetX,<br/>      y: event.offsetY<br/>    }<br/>  }<br/>}</span></pre><h1 id="8d92" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">后续步骤</h1><p id="9712" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我将解释SVG元素中更多的形状交互。敬请期待🙂</p><p id="03d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看已经完成的<a class="ae li" href="https://seats.better.network" rel="noopener ugc nofollow" target="_blank">项目</a>。</p><p id="aded" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢这篇文章，请在LinkedIn上关注我。</p></div></div>    
</body>
</html>