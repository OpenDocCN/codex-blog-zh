<html>
<head>
<title>Fuzzy query for CipherColumn | ShardingSphere 5.3.0 Deep Dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">cipher column | sharding sphere 5 . 3 . 0 Deep Dive的模糊查询</h1>
<blockquote>原文：<a href="https://medium.com/codex/fuzzy-query-for-ciphercolumn-shardingsphere-5-3-0-deep-dive-ad09faea67d3?source=collection_archive---------13-----------------------#2022-12-28">https://medium.com/codex/fuzzy-query-for-ciphercolumn-shardingsphere-5-3-0-deep-dive-ad09faea67d3?source=collection_archive---------13-----------------------#2022-12-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/848bfe1f61cbe437021d71b61567735c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJ7pAeZxni4FBLQkx0l7VA.png"/></div></div></figure><h1 id="db75" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">1.背景</h1><p id="1fe4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><a class="ae km" href="https://shardingsphere.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache ShardingSphere </a>支持数据加密。通过解析用户的SQL输入并根据用户的加密规则重写SQL，原始数据被加密，同时与密文数据一起存储在底层数据库中。</p><p id="0488" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">当用户查询数据时，只从数据库中取出密文数据，解密，最后将解密后的原始数据返回给用户。但是，由于加密算法对整个字符串进行加密，所以无法实现模糊查询。</p><p id="3a1a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">尽管如此，许多企业在数据加密后仍然需要模糊查询。<a class="ae km" rel="noopener" href="/faun/shardingsphere-5-3-0-is-released-new-features-and-improvements-bf4d1c43b09b?source=your_stories_page-------------------------------------">在5.3.0 </a>版本中，Apache ShardingSphere为用户提供了默认的模糊查询算法，支持加密字段的模糊查询。该算法还支持热插拔，可以由用户自定义，通过配置可以实现模糊查询。</p><h1 id="e64c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 2。加密场景下如何实现模糊查询？</strong></h1><h2 id="de18" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">2.1将数据加载到内存数据库(IMDB)</h2><p id="a9e9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">将所有数据加载到IMDB中进行解密；然后就像查询原始数据一样。这种方法可以实现模糊查询。如果数据量很小，这种方法将被证明是简单和划算的，而另一方面，如果数据量很大，这将是一场灾难。</p><h2 id="de3e" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">2.2实现与数据库程序一致的加密和解密功能</h2><p id="50b2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">第二种方法是修改模糊查询条件，利用数据库解密函数先解密数据，再实现模糊查询。这种方法的优点是实施和开发成本低，以及使用成本低。</p><p id="ebed" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">用户只需要稍微修改之前的模糊查询条件。但是密文和加密函数一起存储在数据库中，无法应对账户数据泄露的问题。</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="abf7" class="lp ir hi ll b be lq lr l ls lt">Native SQL: select * from user where name like "%xxx%" <br/>After implementing the decryption function: ѕеlесt * frоm uѕеr whеrе dесоdе(namе) lіkе "%ххх%"</span></pre><h2 id="f541" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">2.3数据屏蔽后存储</h2><p id="d816" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对密文实施数据屏蔽，然后将其存储在模糊查询列中。这种方法可能不够精确。</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="c9e5" class="lp ir hi ll b be lq lr l ls lt">For example, mobile number 13012345678 becomes 130****5678 after the masking algorithm is performed.</span></pre><h2 id="279c" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">2.4在令牌化和组合后执行加密存储</h2><p id="faf6" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">该方法对密文数据进行标记化和组合，然后通过将固定长度的字符分组并将一个字段拆分为多个字符来加密结果集。例如，我们以四个英文字符和两个中文字符作为查询条件:</p><p id="6de3" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><code class="du lu lv lw ll b">ningyu1</code>以4位字符为一组进行加密，所以第一组为<code class="du lu lv lw ll b">ning</code>，第二组为<code class="du lu lv lw ll b">ingy</code>，第三组为<code class="du lu lv lw ll b">ngyu</code>，第四组为<code class="du lu lv lw ll b">gyu1</code>，以此类推。所有字符都被加密并存储在模糊查询列中。如果您想要检索包含四个字符的所有数据，比如<code class="du lu lv lw ll b">ingy</code>，请加密这些字符并使用一个密钥<code class="du lu lv lw ll b">like"%partial%"</code>进行查询。</p><p id="1789" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">缺点:</strong></p><ol class=""><li id="3667" class="lx ly hi jq b jr kn jv ko jz lz kd ma kh mb kl mc md me mf bi translated">存储成本增加:自由分组会增加数据量，加密后数据长度会增加。</li><li id="5472" class="lx ly hi jq b jr mg jv mh jz mi kd mj kh mk kl mc md me mf bi translated">模糊查询中的长度限制:由于安全问题，自由分组的长度不能太短，否则很容易被<a class="ae km" href="https://www.techtarget.com/whatis/definition/rainbow-table" rel="noopener ugc nofollow" target="_blank">彩虹表</a>破解。就像我上面提到的例子，模糊查询字符的长度必须大于或等于4个字母/数字，或者2个汉字。</li></ol><h2 id="fd27" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">2.5单字符摘要算法(ShardingSphere <a class="ae km" rel="noopener" href="/faun/shardingsphere-5-3-0-is-released-new-features-and-improvements-bf4d1c43b09b?source=your_stories_page-------------------------------------">版本5.3.0 </a>中提供的默认模糊查询算法)</h2><p id="9b61" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">尽管上述方法都可行，但人们很自然会怀疑是否有更好的替代方法。在我们的社区中，我们发现单字符加密和存储可以平衡性能和查询，但无法满足安全性要求。</p><p id="e0c7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">那理想的解决方案是什么？受屏蔽算法和加密哈希函数的启发，我们发现可以使用数据丢失和单向函数。</p><p id="3d4d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">加密散列函数应该具有以下四个特征:</p><ol class=""><li id="8bff" class="lx ly hi jq b jr kn jv ko jz lz kd ma kh mb kl mc md me mf bi translated">对于任何给定的消息，计算哈希值应该很容易。</li><li id="36da" class="lx ly hi jq b jr mg jv mh jz mi kd mj kh mk kl mc md me mf bi translated">从已知的哈希值推断原始消息应该是困难的。</li><li id="bb19" class="lx ly hi jq b jr mg jv mh jz mi kd mj kh mk kl mc md me mf bi translated">在不改变散列值的情况下修改消息应该是不可行的。</li><li id="640d" class="lx ly hi jq b jr mg jv mh jz mi kd mj kh mk kl mc md me mf bi translated">两个不同的消息产生相同哈希值的可能性应该非常小。</li></ol><p id="cf3c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated"><strong class="jq hj">安全性:</strong>由于单向函数，无法推断原始消息。为了提高模糊查询的准确性，我们想对单个字符进行加密，但是会被彩虹表破解。</p><p id="4ed2" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">所以我们采取单向函数(保证加密后每个字符都一样)并增加碰撞频率(保证每个字符串都是1: N向后)，大大增强了安全性。</p><h1 id="e965" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">3.模糊查询算法</h1><p id="07ea" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Apache ShardingSphere通过使用下面的单字符摘要算法<code class="du lu lv lw ll b">org.apache.shardingsphere.encrypt.algorithm.like.CharDigestLikeEncryptAlgorithm</code>实现了一个通用的模糊查询算法。</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="77da" class="lp ir hi ll b be lq lr l ls lt">public final class CharDigestLikeEncryptAlgorithm implements LikeEncryptAlgorithm&lt;Object, String&gt; {<br/>  <br/>    private static final String DELTA = "delta";<br/>  <br/>    private static final String MASK = "mask";<br/>  <br/>    private static final String START = "start";<br/>  <br/>    private static final String DICT = "dict";<br/>  <br/>    private static final int DEFAULT_DELTA = 1;<br/>  <br/>    private static final int DEFAULT_MASK = 0b1111_0111_1101;<br/>  <br/>    private static final int DEFAULT_START = 0x4e00;<br/>  <br/>    private static final int MAX_NUMERIC_LETTER_CHAR = 255;<br/>  <br/>    @Getter<br/>    private Properties props;<br/>  <br/>    private int delta;<br/>  <br/>    private int mask;<br/>  <br/>    private int start;<br/>  <br/>    private Map&lt;Character, Integer&gt; charIndexes;<br/>  <br/>    @Override<br/>    public void init(final Properties props) {<br/>        this.props = props;<br/>        delta = createDelta(props);<br/>        mask = createMask(props);<br/>        start = createStart(props);<br/>        charIndexes = createCharIndexes(props);<br/>    }<br/>  <br/>    private int createDelta(final Properties props) {<br/>        if (props.containsKey(DELTA)) {<br/>            String delta = props.getProperty(DELTA);<br/>            try {<br/>                return Integer.parseInt(delta);<br/>            } catch (NumberFormatException ex) {<br/>                throw new EncryptAlgorithmInitializationException("CHAR_DIGEST_LIKE", "delta can only be a decimal number");<br/>            }<br/>        }<br/>        return DEFAULT_DELTA;<br/>    }<br/>  <br/>    private int createMask(final Properties props) {<br/>        if (props.containsKey(MASK)) {<br/>            String mask = props.getProperty(MASK);<br/>            try {<br/>                return Integer.parseInt(mask);<br/>            } catch (NumberFormatException ex) {<br/>                throw new EncryptAlgorithmInitializationException("CHAR_DIGEST_LIKE", "mask can only be a decimal number");<br/>            }<br/>        }<br/>        return DEFAULT_MASK;<br/>    }<br/>  <br/>    private int createStart(final Properties props) {<br/>        if (props.containsKey(START)) {<br/>            String start = props.getProperty(START);<br/>            try {<br/>                return Integer.parseInt(start);<br/>            } catch (NumberFormatException ex) {<br/>                throw new EncryptAlgorithmInitializationException("CHAR_DIGEST_LIKE", "start can only be a decimal number");<br/>            }<br/>        }<br/>        return DEFAULT_START;<br/>    }<br/>  <br/>    private Map&lt;Character, Integer&gt; createCharIndexes(final Properties props) {<br/>        String dictContent = props.containsKey(DICT) &amp;&amp; !Strings.isNullOrEmpty(props.getProperty(DICT)) ? props.getProperty(DICT) : initDefaultDict();<br/>        Map&lt;Character, Integer&gt; result = new HashMap&lt;&gt;(dictContent.length(), 1);<br/>        for (int index = 0; index &lt; dictContent.length(); index++) {<br/>            result.put(dictContent.charAt(index), index);<br/>        }<br/>        return result;<br/>    }<br/>  <br/>    @SneakyThrows<br/>    private String initDefaultDict() {<br/>        InputStream inputStream = CharDigestLikeEncryptAlgorithm.class.getClassLoader().getResourceAsStream("algorithm/like/common_chinese_character.dict");<br/>        LineProcessor&lt;String&gt; lineProcessor = new LineProcessor&lt;String&gt;() {<br/>  <br/>            private final StringBuilder builder = new StringBuilder();<br/>  <br/>            @Override<br/>            public boolean processLine(final String line) {<br/>                if (line.startsWith("#") || 0 == line.length()) {<br/>                    return true;<br/>                } else {<br/>                    builder.append(line);<br/>                    return false;<br/>                }<br/>            }<br/>  <br/>            @Override<br/>            public String getResult() {<br/>                return builder.toString();<br/>            }<br/>        };<br/>        return CharStreams.readLines(new InputStreamReader(inputStream, Charsets.UTF_8), lineProcessor);<br/>    }<br/>  <br/>    @Override<br/>    public String encrypt(final Object plainValue, final EncryptContext encryptContext) {<br/>        return null == plainValue ? null : digest(String.valueOf(plainValue));<br/>    }<br/>  <br/>    private String digest(final String plainValue) {<br/>        StringBuilder result = new StringBuilder(plainValue.length());<br/>        for (char each : plainValue.toCharArray()) {<br/>            char maskedChar = getMaskedChar(each);<br/>            if ('%' == maskedChar) {<br/>                result.append(each);<br/>            } else {<br/>                result.append(maskedChar);<br/>            }<br/>        }<br/>        return result.toString();<br/>    }<br/>  <br/>    private char getMaskedChar(final char originalChar) {<br/>        if ('%' == originalChar) {<br/>            return originalChar;<br/>        }<br/>        if (originalChar &lt;= MAX_NUMERIC_LETTER_CHAR) {<br/>            return (char) ((originalChar + delta) &amp; mask);<br/>        }<br/>        if (charIndexes.containsKey(originalChar)) {<br/>            return (char) (((charIndexes.get(originalChar) + delta) &amp; mask) + start);<br/>        }<br/>        return (char) (((originalChar + delta) &amp; mask) + start);<br/>    }<br/>  <br/>    @Override<br/>    public String getType() {<br/>        return "CHAR_DIGEST_LIKE";<br/>    }<br/>}</span></pre><ul class=""><li id="a490" class="lx ly hi jq b jr kn jv ko jz lz kd ma kh mb kl ml md me mf bi translated">定义二进制<code class="du lu lv lw ll b">mask</code>码以失去精度<code class="du lu lv lw ll b">0b1111_0111_1101</code>(掩码)。</li><li id="e577" class="lx ly hi jq b jr mg jv mh jz mi kd mj kh mk kl ml md me mf bi translated">像<code class="du lu lv lw ll b">map</code>字典一样保存顺序打乱的常用汉字。</li><li id="8e16" class="lx ly hi jq b jr mg jv mh jz mi kd mj kh mk kl ml md me mf bi translated">获取数字、英语和拉丁语的单个字符串<code class="du lu lv lw ll b">Unicode</code>。</li><li id="a72a" class="lx ly hi jq b jr mg jv mh jz mi kd mj kh mk kl ml md me mf bi translated">获取属于字典的汉字的<code class="du lu lv lw ll b">index</code>。</li><li id="9d24" class="lx ly hi jq b jr mg jv mh jz mi kd mj kh mk kl ml md me mf bi translated">其他字符获取单个字符串的<code class="du lu lv lw ll b">Unicode</code>。</li><li id="f941" class="lx ly hi jq b jr mg jv mh jz mi kd mj kh mk kl ml md me mf bi translated">将上述不同类型得到的数字加上<code class="du lu lv lw ll b">1 (delta)</code>，防止数据库中出现任何原文。</li><li id="9e96" class="lx ly hi jq b jr mg jv mh jz mi kd mj kh mk kl ml md me mf bi translated">然后将偏移量<code class="du lu lv lw ll b">Unicode</code>转换成二进制，用<code class="du lu lv lw ll b">mask</code>进行<code class="du lu lv lw ll b">AND</code>运算，进行2位数字丢失。</li><li id="77e0" class="lx ly hi jq b jr mg jv mh jz mi kd mj kh mk kl ml md me mf bi translated">失去精度后直接输出数字、英文、拉丁文。</li><li id="2c40" class="lx ly hi jq b jr mg jv mh jz mi kd mj kh mk kl ml md me mf bi translated">剩余的字符转换成十进制，并在失去精度后与通用字符<code class="du lu lv lw ll b">start</code>代码一起输出。</li></ul><h1 id="8bb2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 4。模糊算法开发进度</strong></h1><h2 id="7470" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">4.1第一版</h2><p id="ee61" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">只需使用常用字符的<code class="du lu lv lw ll b">Unicode</code>和<code class="du lu lv lw ll b">mask</code>代码进行<code class="du lu lv lw ll b">AND</code>操作。</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="7820" class="lp ir hi ll b be lq lr l ls lt">Mask: 0b11111111111001111101<br/>The original character: 0b1000101110101111讯<br/>After encryption: 0b1000101000101101設</span></pre><pre class="mm lk ll mn mo aw mp bi"><span id="80ab" class="ks ir hi ll b fi mq mr l ms lt">Assuming we know the key and encryption algorithm, the original string after a backward pass is:</span><span id="af4b" class="ks ir hi ll b fi mt mr l ms lt">1.0b1000101100101101 謭<br/>2.0b1000101100101111 謯<br/>3.0b1000101110101101 训<br/>4.0b1000101110101111 讯<br/>5.0b1000101010101101 読<br/>6.0b1000101010101111 誯<br/>7.0b1000101000101111 訯<br/>8.0b1000101000101101 設</span></pre><p id="6d7a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们发现基于丢失的位，每个字符串都可以反向导出<code class="du lu lv lw ll b">2^n</code>个汉字。当常用汉字的<code class="du lu lv lw ll b">Unicode</code>为十进制时，它们的间隔很大。注意，反推的汉字不是常用字，更有可能是反推的原字。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/9b1fbbb36a096d8d8f512f4dd48f41db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/0*O457wzfBCn7Vb88c"/></div></figure><h2 id="4da9" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">4.2第二版</h2><p id="be90" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">由于常用汉字<code class="du lu lv lw ll b">Unicode</code>的间隔是不规则的，我们计划将汉字<code class="du lu lv lw ll b">Unicode</code>的最后几位转换成十进制作为<code class="du lu lv lw ll b">index</code>来取一些常用汉字。这样，在算法已知的情况下，一次向后传递后就不会出现生僻字符，干扰物也不再容易消除。</p><p id="d044" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果我们把汉字的最后几位<code class="du lu lv lw ll b">Unicode</code>留下，就跟模糊查询的准确率和抗解密复杂度的关系有关了。准确率越高，解密难度越低。</p><p id="ce58" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们来看看在我们的算法下常见汉字的碰撞程度:</p><ol class=""><li id="3e8a" class="lx ly hi jq b jr kn jv ko jz lz kd ma kh mb kl mc md me mf bi translated">当<code class="du lu lv lw ll b">mask</code> =0b0011_1111_1111时:</li></ol><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/2dbc6767a391c18c87fcf685ebc15de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_lKpHMdESxObJ3Na"/></div></div></figure><p id="f9cd" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">2.当<code class="du lu lv lw ll b">mask</code> =0b0001_1111_1111时:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/c9841eceed325a0bef632e49f07c1dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/0*yPRvDJO3zB46fc0c"/></div></figure><p id="768d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">汉字尾数，留10位和9位。10位数的查询更准确，因为它的冲突要弱得多。然而，如果算法和密钥是已知的，则1:1字符的原始文本可以反向导出。</p><p id="fabb" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">9位数字的查询不太准确，因为9位数字的冲突相对更强，但1:1字符较少。我们发现，虽然不管留10位还是9位都改变碰撞，但由于汉字的Unicode不规则，分布很不平衡，整体碰撞概率无法控制。</p><h2 id="14b5" class="ks ir hi bd is kt ku kv iw kw kx ky ja jz kz la je kd lb lc ji kh ld le jm lf bi translated">4.3第三版</h2><p id="3e91" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">针对第二版中发现的分布不均的问题，我们把顺序打乱的常用字作为字典表。</p><ol class=""><li id="d88d" class="lx ly hi jq b jr kn jv ko jz lz kd ma kh mb kl mc md me mf bi translated">加密文本首先在乱序字典表中查找<code class="du lu lv lw ll b">index</code>。我们用<code class="du lu lv lw ll b">index</code>和下标来代替没有规则的<code class="du lu lv lw ll b">Unicode</code>。</li></ol><p id="0620" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">在不常用字符的情况下使用<code class="du lu lv lw ll b">Unicode</code>。(注意:要计算的代码尽量均匀分布。)</p><p id="228d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">2.下一步是用<code class="du lu lv lw ll b">mask</code>执行<code class="du lu lv lw ll b">AND</code>操作，并损失2位精度以增加冲突的频率。</p><p id="c4bc" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">我们来看看在我们的算法下常见汉字的碰撞程度:</p><ol class=""><li id="5118" class="lx ly hi jq b jr kn jv ko jz lz kd ma kh mb kl mc md me mf bi translated">当<code class="du lu lv lw ll b">mask</code> =0b1111_1011_1101时:</li></ol><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/ec80288fb55fa053a0900c733cda2f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/0*uZOanYeB7UtR89R3"/></div></figure><p id="fa83" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">2.当<code class="du lu lv lw ll b">mask</code> =0b0111_1011_1101时:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es my"><img src="../Images/9dc9e02d5d00c84efa017eb36f32bd4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/0*xpfbucQ7DeOSWimw"/></div></figure><p id="a1d9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">当<code class="du lu lv lw ll b">mask</code>剩下11位时，可以看到碰撞分布集中在1:4。当<code class="du lu lv lw ll b">mask</code>剩下10位时，数字变成1:8。这时候我们只需要调整精度损失的个数，就可以控制碰撞是1:2，1:4还是1:8。</p><p id="bca9" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">如果选择<code class="du lu lv lw ll b">mask</code>为1，算法和密钥已知，就会出现1:1的汉字，因为此时我们计算的是常用字符的碰撞度。如果我们在汉字的16位二进制之前加上缺失的4位，情况就变成了<code class="du lu lv lw ll b">2^5=32</code>种情况。</p><p id="fd00" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">由于我们对全文进行了加密，所以即使单个字符被反向推断，对整体安全性的影响也不大，不会造成海量数据泄露。同时，后向传递的前提是知道算法、key、<code class="du lu lv lw ll b">delta</code>和字典，所以从数据库中的数据是无法实现的。</p><h1 id="e43d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 5。如何使用模糊查询</strong></h1><p id="c331" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">模糊查询需要在加密配置中配置<code class="du lu lv lw ll b">encryptors</code>(加密算法配置)<code class="du lu lv lw ll b">likeQueryColumn</code>(模糊查询列名)<code class="du lu lv lw ll b">likeQueryEncryptorName</code>(模糊查询列的加密算法名)。</p><p id="893d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">请参考以下配置。添加自己的分片算法和数据源。</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="1faa" class="lp ir hi ll b be lq lr l ls lt">dataSources:<br/>  ds_0:<br/>    dataSourceClassName: com.zaxxer.hikari.HikariDataSource<br/>    driverClassName: com.mysql.jdbc.Driver<br/>    jdbcUrl: jdbc:mysql://127.0.0.1:3306/test?allowPublicKeyRetrieval=true<br/>    username: root<br/>    password: root<br/>    <br/>rules:<br/>- !ENCRYPT<br/>  encryptors:<br/>    like_encryptor:<br/>      type: CHAR_DIGEST_LIKE<br/>    aes_encryptor:<br/>      type: AES<br/>      props:<br/>        aes-key-value: 123456abc<br/>  tables:<br/>    user:<br/>      columns:<br/>        name:<br/>          cipherColumn: name<br/>          encryptorName: aes_encryptor<br/>          assistedQueryColumn: name_ext<br/>          assistedQueryEncryptorName: aes_encryptor<br/>          likeQueryColumn: name_like<br/>          likeQueryEncryptorName: like_encryptor<br/>        phone:<br/>          cipherColumn: phone<br/>          encryptorName: aes_encryptor<br/>          likeQueryColumn: phone_like<br/>          likeQueryEncryptorName: like_encryptor<br/>  queryWithCipherColumn: true<br/><br/><br/>props:<br/>  sql-show: true</span></pre><p id="ab4c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">插入</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="30d6" class="lp ir hi ll b be lq lr l ls lt">Logic SQL: insert into user ( id, name, phone, sex) values ( 1, '熊高祥', '13012345678', '男')<br/>Actual SQL: ds_0 ::: insert into user ( id, name, name_ext, name_like, phone, phone_like, sex) values (1, 'gyVPLyhIzDIZaWDwTl3n4g==', 'gyVPLyhIzDIZaWDwTl3n4g==', '佹堝偀', 'qEmE7xRzW0d7EotlOAt6ww==', '04101454589', '男')</span></pre><p id="cdf7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">更新</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="6390" class="lp ir hi ll b be lq lr l ls lt">Logic SQL: update user set name = '熊高祥123', sex = '男1' where sex ='男' and phone like '130%'<br/>Actual SQL: ds_0 ::: update user set name = 'K22HjufsPPy4rrf4PD046A==', name_ext = 'K22HjufsPPy4rrf4PD046A==', name_like = '佹堝偀014', sex = '男1' where sex ='男' and phone_like like '041%'</span></pre><p id="d618" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">挑选</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="e7a2" class="lp ir hi ll b be lq lr l ls lt">Logic SQL: select * from user where (id = 1 or phone = '13012345678') and name like '熊%'<br/>Actual SQL: ds_0 ::: select `user`.`id`, `user`.`name` AS `name`, `user`.`sex`, `user`.`phone` AS `phone`, `user`.`create_time` from user where (id = 1 or phone = 'qEmE7xRzW0d7EotlOAt6ww==') and name_like like '佹%'</span></pre><p id="0c6e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">选择:联邦表子查询</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="d804" class="lp ir hi ll b be lq lr l ls lt">Logic SQL: select * from user LEFT JOIN user_ext on user.id=user_ext.id where user.id in (select id from user where sex = '男' and name like '熊%')<br/>Actual SQL: ds_0 ::: select `user`.`id`, `user`.`name` AS `name`, `user`.`sex`, `user`.`phone` AS `phone`, `user`.`create_time`, `user_ext`.`id`, `user_ext`.`address` from user LEFT JOIN user_ext on user.id=user_ext.id where user.id in (select id from user where sex = '男' and name_like like '佹%')</span></pre><p id="d24c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">删除</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="10dc" class="lp ir hi ll b be lq lr l ls lt">Logic SQL: delete from user where sex = '男' and name like '熊%'<br/>Actual SQL: ds_0 ::: delete from user where sex = '男' and name_like like '佹%'</span></pre><p id="bd21" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">上面的例子演示了模糊查询列如何用不同的SQL语法重写SQL以支持模糊查询。</p><p id="7c30" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">这篇博文向您介绍了模糊查询的工作原理，并用具体的例子演示了如何使用它。我们希望通过这篇文章，您将对模糊查询有一个基本的了解。</p><h1 id="e7e1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">链接</h1><p id="a60a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">🔗<a class="ae km" href="https://shardingsphere.apache.org/document/current/en/downloads/" rel="noopener ugc nofollow" target="_blank">下载链接</a></p><p id="8d7d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">🔗<a class="ae km" href="https://shardingsphere.apache.org/" rel="noopener ugc nofollow" target="_blank">项目地址</a></p><p id="0055" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hb bi translated">🔗<a class="ae km" href="https://github.com/apache/shardingsphere-on-cloud" rel="noopener ugc nofollow" target="_blank">分割云上球体</a></p><h1 id="3cbe" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">作者</h1><p id="60dc" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">熊是的工程师，也是ShardingSphere的贡献者，负责数据加密和数据屏蔽</p></div></div>    
</body>
</html>