<html>
<head>
<title>The newer way to make Network Calls on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android上打网络电话的新方式</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-newer-way-to-make-network-calls-on-android-7162e2c37fe9?source=collection_archive---------1-----------------------#2022-05-09">https://medium.com/codex/the-newer-way-to-make-network-calls-on-android-7162e2c37fe9?source=collection_archive---------1-----------------------#2022-05-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3f40cc765060038d9be015bd3b5c829c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*x1jp1Ekrgvkt2-Qr.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">ktor-Android客户端</figcaption></figure><p id="268f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们使用诸如翻新和凌空技术的时间太长了，行业也非常有效地适应了这些技术。尽管如此，随着Kotlin在Android开发人员中的受欢迎程度的急剧增长，Kotlin中出现了一个新的网络调用API:<strong class="iw hj">Ktor-client</strong>。</p><p id="b11c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">JetBrains每天都在快速开发Kotlin。它是世界上最受欢迎的语言之一，占据了Android开发者的心。然而，他们并没有把它限制在那里。我们也可以用Kotlin创建一个后端服务器，它的API叫做<strong class="iw hj"> Ktor </strong>，而<strong class="iw hj"> Ktor-client </strong>是它的客户端版本。</p><h1 id="9c0d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">设置Ktor客户端</h1><p id="74a7" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">像往常一样，我们需要安装Ktor-client的依赖项。对于本教程，我们将使用以下依赖关系:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="86a7" class="le jt hi la b fi lf lg l lh li">def ktor_version = "1.6.8"<br/>implementation "io.ktor:ktor-client-core:$ktor_version"<br/>implementation "io.ktor:ktor-client-android:$ktor_version"<br/>implementation "io.ktor:ktor-client-serialization:$ktor_version"<br/>implementation "io.ktor:ktor-client-logging:$ktor_version"<br/>implementation "ch.qos.logback:logback-classic:1.2.9"</span></pre><p id="726a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Ktor-client提倡使用实现模块，因此我们只使用需要的模块，而不是Ktor中的所有模块。</p><h1 id="fab6" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建界面</h1><p id="093c" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">虽然使用<strong class="iw hj"> Ktor-client </strong>并不需要创建接口，但是使用这种设计模式是一个很好的实践。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="64cd" class="le jt hi la b fi lf lg l lh li">interface ApiService {<br/>  suspend fun getPost(id: String): Response&lt;PostDto&gt;</span><span id="18a9" class="le jt hi la b fi lj lg l lh li">  suspend fun createPost(post: Post): Response&lt;PostDto&gt;<br/>}</span></pre><p id="a853" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们现在可以在一个具体的类中实现这个接口。这是我们将进行实际网络调用的地方。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="7e6b" class="le jt hi la b fi lf lg l lh li">class ApiServiceImpl(<br/>  private val client: HttpClient<br/>) : ApiService {<br/>  override suspend fun getPost(id: String): Response&lt;PostDto&gt; {<br/>    return try {<br/>      val response = client.get&lt;PostDto&gt; {<br/>        url("$BASE_URL/posts/$id/?key=value")<br/>      }<br/>      return Response.Success(response)<br/>    } catch (e: RedirectResponseException) { // 3xx <br/>      Response.Error(e.response.status.description)<br/>    } catch (e: ClientRequestException) { // 4xx<br/>      Response.Error(e.response.status.description)<br/>    } catch (e: ServerResponseException) { // 5xx<br/>      Response.Error(e.response.status.description)<br/>    }<br/>  }</span><span id="a75a" class="le jt hi la b fi lj lg l lh li">  [...]<br/>}</span></pre><p id="78dd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Ktor-client是一个基于Kotlin的库，使用了它提供的所有特性。为了进行一个<code class="du lk ll lm la b">GET</code> HTTP调用，我们在<code class="du lk ll lm la b">client</code>对象上使用了<code class="du lk ll lm la b">suspend fun get()</code>函数。该函数会将传入的数据解析为泛型参数。构建器lambda函数有一个<code class="du lk ll lm la b">url()</code>方法，该方法接受带有路径参数和查询参数的<code class="du lk ll lm la b">String</code>URL——原始URL。</p><h1 id="1179" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建客户端对象</h1><p id="fea5" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">通常，我会鼓励你用依赖注入来做这件事，但是现在，我将在<code class="du lk ll lm la b">ApiService</code>接口中做一个<code class="du lk ll lm la b">companion object</code>。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="0b32" class="le jt hi la b fi lf lg l lh li">interface ApiService {<br/>  [...]</span><span id="c006" class="le jt hi la b fi lj lg l lh li">  companion object {<br/>    val client = HttpClient(Android) {<br/>      install(Logging) {<br/>        level = LogLevel.ALL<br/>      }            </span><span id="fb03" class="le jt hi la b fi lj lg l lh li">      install(JsonFeature) {                <br/>        serializer = KotlinxSerializer()<br/>      }<br/>    }<br/>  }<br/>}</span></pre><h1 id="330a" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">包装它</h1><p id="ecc7" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">现在，您可以结束所有工作，开始网络通话。假设您希望在用户点击按钮时获得帖子:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="9c18" class="le jt hi la b fi lf lg l lh li">btnGetPost.setOnClickListener { _ -&gt;<br/>  lifecycleScope.launch {<br/>    ApiService.client.use { <br/>      val service = ApiServiceImpl(it)<br/>  <br/>      when (val response = service.getPost("2")) {<br/>        is Response.Success -&gt; { /* do something */ }<br/>        is Response.Error -&gt; toast(response.message)<br/>      }<br/>    }<br/>  }<br/>}</span></pre><h1 id="bae0" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">提出发布请求</h1><p id="3bfa" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">这就像发出一个<code class="du lk ll lm la b">get</code>请求一样简单。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="8b95" class="le jt hi la b fi lf lg l lh li">override suspend fun createPost(post: Post): Response&lt;PostDto&gt; {<br/>  try {<br/>    val response = client.post&lt;PostDto&gt; {<br/>      url("$BASE_URL/posts")<br/>      contentType(ContentType.Application.Json)<br/>      setBody(post)<br/>    }<br/>   } catch ([...]) {<br/>     [ same as in the get function ]<br/>   }<br/>}</span></pre><p id="d625" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们使用<code class="du lk ll lm la b">post</code>方法代替<code class="du lk ll lm la b">get</code>。我们指定内容类型并传递请求体。</p><h1 id="8495" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">杂项笔记</h1><ol class=""><li id="f6ba" class="ln lo hi iw b ix kq jb kr jf lp jj lq jn lr jr ls lt lu lv bi translated">确保所有使用的<code class="du lk ll lm la b">data class</code>都标有注释<code class="du lk ll lm la b">@kotlinx.serialization.Serializable</code></li><li id="570f" class="ln lo hi iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated">上面代码中使用的<code class="du lk ll lm la b">Response</code>类如下:</li></ol><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="14a3" class="le jt hi la b fi lf lg l lh li">sealed class Response&lt;T&gt; {    <br/>  data class Success&lt;T&gt;(val data: T) : Response&lt;T&gt;()    <br/>  data class Error&lt;T&gt;(val message: String) : Response&lt;T&gt;()<br/>}</span></pre><p id="a849" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.不要忘记在AndroidManifest文件中添加<code class="du lk ll lm la b">INTERNET</code>权限。</p><h1 id="c057" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="1095" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated"><strong class="iw hj"> Ktor-client </strong>超级容易配置，超级容易使用。HTTP方法或部分URL没有注释。这是一个简单的网络请求调用，它返回我们需要处理的数据类对象。</p></div></div>    
</body>
</html>