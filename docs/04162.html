<html>
<head>
<title>Bit Manipulation in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的位操作</h1>
<blockquote>原文：<a href="https://medium.com/codex/bit-manipulation-in-javascript-117cd525e4d?source=collection_archive---------2-----------------------#2021-11-01">https://medium.com/codex/bit-manipulation-in-javascript-117cd525e4d?source=collection_archive---------2-----------------------#2021-11-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0406f2d551aac87ca42fc07c3c6f113a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRMPny9g9mP9ADSvaYzung.jpeg"/></div></div></figure><p id="a4a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">位操作是一种改变或处理由另一种数据类型(通常是整数)表示的实际数据位的技术。给定一个像7这样的整数，它所代表的位是用二进制写的——也就是说，从左到右是一系列1和0，代表加起来是整数的2的幂。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="abae" class="jx jy hi jt b fi jz ka l kb kc">7 = 4 + 2 + 1, which means<br/>7 = 2**2 + 2**1 + 2**0, so in binary, <br/>7 = 111</span></pre><p id="382e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">再举一个例子，甚至更大的数字也可以用二进制的比特来表示。二进制中的零表示不包括在总和中的2的幂，从右向左读取，从零幂开始。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="67e1" class="jx jy hi jt b fi jz ka l kb kc">645 = 2**9 + 2**7 + 2**2 + 2**0<br/>645 = 1010000101</span></pre><p id="10d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">二进制位编码可以存储的位数是有限的。毫无疑问，许多操作系统中32位到64位的变化是熟悉的——这指的是最大存储容量。很容易假设JavaScript可以用二进制编码的最大数是2的64次方(加上63次方，再加上62次方……)。但是，由于JavaScript在技术上在后台将所有数字表示为双精度浮点数，并且必须用一位来表示符号，因此可以安全编码的最大和最小数字是</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="dd50" class="jx jy hi jt b fi jz ka l kb kc">2**53 - 1, or the MAX_SAFE_INTEGER 9,007,199,254,740,991<br/>-(2**53 - 1) or the MIN_SAFE_INTEGER -9,007,199,254,740,991</span></pre><p id="3d7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这些数学信息，我们可以用比特操作来做什么呢？编码面试问题之外的一些常见用途包括压缩和加密，因为使用算法或密钥的逐位技术可用于将数据“推入”更小的帧中，或转换未加密数据的位，以便只有给定适当的密码才能识别它们。</p><h1 id="9d6f" class="kd jy hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">按位运算符</h1><p id="3cad" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">为了执行位操作，我们手头准备了一系列运算符。除了少数例外，这些对我来说都是全新的，直到最近，所以这个概述对每个人都有帮助。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="4bed" class="jx jy hi jt b fi jz ka l kb kc">~ NOT -&gt; flips every bit to its opposite (e.g., 1 -&gt; 0)<br/>&amp; AND -&gt; compares two equal-length bit patterns; returns one in positions where both patterns have ones, otherwise returns zero<br/>| OR -&gt; also compares two equal-length bit patterns; returns one if either pattern has a one in that position, otherwise zero<br/>^ XOR -&gt; also compares two equal-length patterns; only returns one in positions where the patterns are different<br/>&lt;&lt; LEFT SHIFT -&gt; shifts the pattern a certain number of bits (given after the operator) and adds zeroes to the end; equivalent to multiplying the starting number by 2**n, where n is the number to shift<br/>&gt;&gt; RIGHT SHIFT -&gt; shifts the pattern a certain number of bits to the right and appends one at the end; equivalent to dividing by 2**n, where n is the number to shift</span></pre><p id="c0dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些不是所有的位运算符；要了解更多信息，请查看此处的文档<a class="ae lf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="694e" class="kd jy hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">常见的位操作问题</h1><p id="2884" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">最常见的位操作问题可能是检查一个数是否是2的幂(在<a class="ae lf" href="https://leetcode.com/problems/power-of-two/" rel="noopener ugc nofollow" target="_blank"> Leetcode </a>上有一个现成的)。这个解决方案看起来很简单，但实际上一开始很难理解。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="3ca6" class="jx jy hi jt b fi jz ka l kb kc">const isPowerOfTwo = n =&gt; {<br/>  return (n &amp;&amp; !(n &amp; (n - 1)))<br/>}</span></pre><p id="2e70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是什么意思？我们知道我们正在返回一个布尔值。返回的前半部分检查n是否为真；也就是非零。这负责检查零是否是2的幂。第二部分利用我们的按位AND运算符来比较两个等长的位模式:n和n-1。让我们用一些例子更清楚地看看第二部分。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9ec7" class="jx jy hi jt b fi jz ka l kb kc">8 is a known power of 2<br/>8 passes the first test; it is truthy since it is not zero<br/>What about 8 &amp; 7? Let's look at them both as binary code<br/>8 = 1000 (2**3 + 0 + 0 + 0)<br/>7 = 0111 (0 + 2**2 + 2**1 + 2**0)<br/>So the operation 8 &amp; 7 results in 0000 (falsey)<br/>Therefore, doing !(8 &amp; 7) gives us a truthy value<br/>Our function returns true! 8 is a power of 2!</span></pre><p id="98b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">测试是这样进行的:所有2的幂在它们的二进制表示中只有一个1——它们是2的幂的地方。但是，从2的幂中减去1会得到一个包含多个1的数字，从而导致两种模式的按位AND运算符的结果总是返回false。因为我们检查这是否是假的，当我们的输入是2的幂时，我们得到一个真的布尔返回。</p><p id="c5c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个常见的位操作问题是计算一个数的二进制表示中1的个数。这也被称为Hamming weight，我觉得它非常有趣，因为它让人想起了县集市的画面，在那里，壮汉举起了一只巨大的蓝带猪，而不是锤子和铃铛。我跑题了。同样，可靠的Leetcode有一个准备好的<a class="ae lf" href="https://leetcode.com/problems/number-of-1-bits/" rel="noopener ugc nofollow" target="_blank">示例</a>。</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/04b7e965203e7fd6e519726d74820c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IkswI8W0GzIEpwyhds0Bog.jpeg"/></div></div></figure><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="e9c1" class="jx jy hi jt b fi jz ka l kb kc">const hammingWeight = n =&gt; { <br/>  let count = 0;<br/>  while(n){<br/>    n = n &amp; (n - 1)<br/>    count++<br/>  }<br/>  return count<br/>}</span></pre><p id="fd3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，一个看似简单的解决方案实际上很难理解。让我们再次用一些例子来分解它。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="4b3f" class="jx jy hi jt b fi jz ka l kb kc">Find the Hamming weight of 103<br/>First, we see our count is 0<br/>Then, while n -&gt; meaning whenever n is not zero<br/>Next, we are setting n to now equal n &amp; (n - 1) and then incrementing our count variable<br/>For 103, the binary representation is 2**6 + 2**5 + 2**2 + 2**1 + 2**0, or 1100111<br/>For 102, our initial n - 1, the binary would be 1100110<br/>So on first loop, n &amp; (n - 1) would be 1100110, and our counter iterates for the 1 that was in the 2**0 place</span><span id="ee81" class="jx jy hi jt b fi lh ka l kb kc">On the next loop:<br/>n = 1100110 (102)<br/>n - 1 = 1100101 (101)<br/>n = n &amp; (n - 1) = 1100100 (100) -&gt; counter is now up to 2</span><span id="07c1" class="jx jy hi jt b fi lh ka l kb kc">Next loop:<br/>n = 1100100 (100)<br/>n - 1 = 1100011 (99)<br/>n = n &amp; (n - 1) = 1100000 (96) -&gt; counter is now up to 3</span><span id="28f1" class="jx jy hi jt b fi lh ka l kb kc">Next loop:<br/>n = 1100000 (96)<br/>n - 1 = 1011111 (95)<br/>n = n &amp; (n - 1) = 1000000 (64) -&gt; counter is now up to 4</span><span id="8861" class="jx jy hi jt b fi lh ka l kb kc">Last loop: <br/>n = 1000000 (64)<br/>n - 1 = 0111111 (63)<br/>n = n &amp; (n - 1) = 0 -&gt; counter is now up to 5</span><span id="0fa4" class="jx jy hi jt b fi lh ka l kb kc">While loop stops because while(n) is no longer valid<br/>Counter is returned (5) -&gt; check for accuracy<br/>103 was 1100111 -&gt; 5 ones!</span></pre><p id="9c5d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法的关键在于，将一个数设置为该数的前一个值的按位AND运算符的结果，并且其递减量递增地“翻转”该数中每个位置右侧的所有位，直到该数为零，从而“移除”所有的1。只要这个过程被一个变量跟踪，1位的数目就可以被计数并返回。</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="c66e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这篇关于JavaScript中的位操作的简要介绍能够为编写某些算法提供新的信息和视角。我知道我仍然在努力掌握一些更高级的按位概念，所以一旦我更好地解决了这些问题，我可能不得不返回第二期。到目前为止，对我来说，关键是记住仔细绘制每一步，这样我就可以观察逐位运算创建的模式。在确定2的幂或计算1的位数的情况下，我试图重新创造我自己理解位运算的方式，以便其他人可以遵循这一思维过程。更多练习问题，请查看<a class="ae lf" href="https://leetcode.com/tag/bit-manipulation/" rel="noopener ugc nofollow" target="_blank"> Leetcode </a>上的位操作标签。编码快乐！</p></div></div>    
</body>
</html>