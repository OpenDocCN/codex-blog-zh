# 您不需要真正了解 HTML 来呈现表单

> 原文：<https://medium.com/codex/you-dont-really-need-to-know-html-to-render-forms-49ab5769aef0?source=collection_archive---------13----------------------->

尽管有各种各样的 HTML 控件和各种各样的使用模式来产生一个现代的用户界面，但我认为最稳定的是如何使用，最可预测的是它应该如何表现，最保守的元素是一个 [FORM](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement) 元素。

一旦看到 HTML 页面中的表单元素，您会期望:

*   有一个特定的数据上下文链接到此元素
*   表单定义了该数据上下文的边界，并且表单本身是该数据上下文的根，因此所有子 HTML 控件都相对于根工作
*   表单定义了对其拥有的数据的验证约束
*   表单在元素和数据模型之间引入了数据绑定功能，通常是双向数据绑定
*   如果表单不是只读的，则存在允许对更改的业务数据做出反应的操作，例如保存、取消、验证、发布到 API 等

![](img/5329b0633c7b18a1ccfbbc8f994cca03.png)

[瓦列里·塞索耶夫](https://unsplash.com/@valerysysoev?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

大多数客户端应用程序使用表单来管理客户端数据，并且大多数应用程序都有数据管理页面。所以每次我们添加一个新的管理页面时，我们都要重新实现这个表单应该具有的一些特征:数据绑定、验证、用户操作等。

是的，我们可以引入一些可重用的模块、帮助器、包装器、复杂的自定义控件和其他抽象来简化数据管理的实现，但一般来说，从一个页面到另一个页面的过程是相同的:创建表单、添加 HTML 原语或复杂的自定义控件、应用数据绑定和添加动作控件或提供对表单动作的反应(如提交)。

在现代世界中，大多数前端框架都简化了数据管理(例如 Angular ngModel 双向数据绑定指令)，但您需要为每个新页面从头开始:创建表单、添加 HTML 控件、实现/配置绑定、实现/配置验证等。

# 改变视角

如果我们可以改变我们的观点，不从 HTML 和呈现的角度，而是作为需要呈现给用户的领域上下文来检查表单构建过程，会怎么样呢？

让我们不要使用 HTML 规范语言，而是引入一些面向数据的 DSL 来描述数据应该如何呈现给最终用户。例如，假设我们想用下面的方案以只读模式(目前)表示一条单个用户信息:

```
User {
  id: string
  firstName: string
  lastName: string
  age: Number address: {
    main: string
  } permissions: {
    read: boolean
    write: boolean
  }
}
```

## 数据元素

为了描述我们的意图，我们需要尽可能少的属性:

*   *绑定*:从路由节点(用户)到我们要绑定的属性的路径(例如 *address.main* )
*   *type* :该字段的数据类型(通常是数据原语，如*字符串*、*数字*
*   *渲染器*:我们希望如何表示这段数据(例如，使用*文本框*)

示例:

```
{
  binding: address.main
  renderer: label
}
```

到目前为止一切顺利。我们知道我们的数据模型结构，我们可以只使用两个属性来描述我们的意图。

## 形状要素

下一步是将原子元描述符组合成一个表单组件。因此，我们需要具有更高级数据 API 的元素，能够与数据源交互并控制内部数据处理。为此，我们来介绍一下表单描述属性:

*   *名称*:唯一的表单名称，用于区分同一页面上的每个表单
*   *值*:直接来自我们可以指定的数据(如果我们使用一些本地数据)
*   *valueSource* :链接到远程数据以加载到表单中
*   *项*:原子数据元素表单列表包括

示例:

```
{
  name: userForm
  valueSource: https://some-external-source/resource/1 items:
  - binding: firstName
    renderer: label - binding: lastName
    renderer: label - binding: age
    renderer: textbox
    type: number - binding: address.main
    renderer: textbox
}
```

这个定义既易于阅读，又能根据我们的意图完全自我描述——我们希望从特定的 URL 加载数据，并将其绑定到一个包含 4 个数据元素的表单中，其中一些数据元素对于特定数据是只读的，一些数据元素允许更改输入数据。

仅此而已。如果我们没有一些复杂的依赖于表单的行为，只是想表示来自源的数据，并绑定它们以供进一步修改——我们已经充满了描述语言。

如果我们可以使用 HTML 不可知的面向数据的语言来描述我们的大多数管理表单，而无需每次构建新表单时都重新发明轮子，会怎么样？话太多了，我们来复习例子。

## 示例 1:表示用户个人信息

通过使用特定于用户界面的属性(label)来可视化前面的示例，使表单更加用户友好，并在输入控件之前呈现标签。此外，我们使用硬编码数据作为表单值(当数据来自内部源时的模拟示例)。

简单静态形式

结果，我们无需编写一行 HTML 代码就声明并呈现了用户表单页面——YAML 被转换成了用户表单最常见的表示形式。

将“年龄”定义为数字—表单解析器使用特定类型的输入来正确表示它。

## 示例 2:使用远程数据

在这个解决方案中，从远程服务(HTTP REST)访问数据并以只读模式可视化该数据的一部分是一项微不足道的任务——我们所需要的就是通过利用属性中的“valueSource”来定义传入数据的来源

远程数据

因为我们知道传入数据的结构，所以我们准备了一组原语来向最终用户表示这些数据。因此，当表单实例化时，数据从远程加载并合并到表单控件中，然后呈现给用户。

## 例 3:集合呢？

集合只是一个更复杂的表示，但仍然是可以通过路径访问的数据对象。由于集合中的每个元素都可以是一个对象——我们需要对特定集合项中包含的对象进行更详细的(父子)描述

带集合的表单

因为我们只需要表示每个集合元素的一部分数据，所以我们使用类似的元素描述:绑定到与新的根(语言)和标签相关的数据模型。

但是仅仅表示数据并没有太大用处。在下一章中，我将介绍更有趣的使用模式:对用户的改变做出反应，验证输入，与远程资源交互，执行一个动作，等等。