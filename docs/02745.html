<html>
<head>
<title>When to use Quarkus over Spring Boot? And how to get started? [2]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么时候在Spring Boot上空使用夸库？以及如何入门？[2]</h1>
<blockquote>原文：<a href="https://medium.com/codex/when-to-use-quarkus-over-spring-boot-and-how-to-get-started-2-d18484710e8?source=collection_archive---------4-----------------------#2021-08-03">https://medium.com/codex/when-to-use-quarkus-over-spring-boot-and-how-to-get-started-2-d18484710e8?source=collection_archive---------4-----------------------#2021-08-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/8abba36ba3b89f70ad25ded9c5eff13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gzFrSIJLSPhcA3yM"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">由<a class="ae hv" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Markus Spiske </a>在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><figure class="ev ex iw ix iy hk er es paragraph-image"><div class="er es iv"><img src="../Images/86add1a048c375e46808f8c0511ea76e.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*L-qENfh6p02TW8bx.png"/></div></figure><p id="dff2" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">如果您还没有阅读第一部分，请继续阅读，以更深入地了解何时使用，但是如果您只关心入门部分，那么这就是了。在本文中，我们将了解如何快速使用Quarkus应用程序，以及它有多简单。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><p id="fabd" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">出于本文的目的，我们将使用<strong class="jb hz"> Maven </strong>作为依赖性管理工具。如果你还没有安装<code class="du ke kf kg kh b">mvn</code>，你应该继续安装它。如果你在苹果电脑上，你就可以运行—</p><pre class="ki kj kk kl fd km kh kn ko aw kp bi"><span id="0b4d" class="kq kr hy kh b fi ks kt l ku kv">brew install maven</span></pre><p id="be57" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><code class="du ke kf kg kh b">mvn</code>提供了一种快速启动Quarkus项目的方法。你可以直接跑——</p><pre class="ki kj kk kl fd km kh kn ko aw kp bi"><span id="acb5" class="kq kr hy kh b fi ks kt l ku kv">mvn io.quarkus:quarkus-maven-plugin:2.0.3.Final:create \                                                                                      DprojectGroupId=com.YOUR_NAME \<br/>DprojectArtifactId=ARTIFACT_ID \<br/>DclassName="com.YOUR_NAME.ARTIFACT_ID.crud.HelloWorldResource" \<br/>-Dpath="/helloWorld"</span></pre><p id="d979" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">用您的名字或者您的组织的名字替换<code class="du ke kf kg kh b">YOUR_NAME</code>,用您的项目想要的工件ID替换<code class="du ke kf kg kh b">ARTIFACT_ID </code>。我会让我的组是<code class="du ke kf kg kh b">com.pradeepselva</code>，工件ID是<code class="du ke kf kg kh b">quarkus-demo</code>。</p><figure class="ki kj kk kl fd hk er es paragraph-image"><div class="er es kw"><img src="../Images/c438831ae259058a227314534a03ed1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*cY8zzxDPV_ewl8NatCOInA.png"/></div></figure><p id="164c" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这将在您的repo中创建一个名为<code class="du ke kf kg kh b">ARTIFACT_ID</code>的项目</p><p id="df84" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">您的项目目录应该如下所示。它附带了预配置的<strong class="jb hz"> Dockerfiles </strong>供您使用，<strong class="jb hz">预写的测试</strong>和一个简单的<strong class="jb hz">预写的HelloWorldResource </strong>，它公开了您的端口中的/helloWord端点:8080，该端点将返回<code class="du ke kf kg kh b">Hello RESTEasy</code>。(resteasy提供了使我们能够轻松创建REST APIs的功能)</p><p id="c021" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">要运行新启动的应用程序，只需停留在根目录下运行—</p><pre class="ki kj kk kl fd km kh kn ko aw kp bi"><span id="93f5" class="kq kr hy kh b fi ks kt l ku kv">./mvnw compile quarkus:dev</span></pre><p id="0755" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">一旦应用程序启动，测试<code class="du ke kf kg kh b">localhost:8080</code>上的<code class="du ke kf kg kh b">/helloWorld</code>端点。</p><figure class="ki kj kk kl fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kx"><img src="../Images/42fb499345266e825c11f9824a50d7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V066kN_6Nfoxssz4WquEBQ.png"/></div></div></figure><p id="3565" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">就是这样！引导你的第一个项目并运行它是如此简单。</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="6727" class="ky kr hy bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">更进一步</h1><p id="568f" class="pw-post-body-paragraph iz ja hy jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated">让我们更进一步，制作一个简单的API，它可以创建一个用户并查询所有保存的用户。出于本文的目的，我们将使用<strong class="jb hz"> PostgreSQL </strong>，但是也可以随意使用您选择的DB。</p><h2 id="1d6c" class="kq kr hy bd kz ma mb mc ld md me mf lh jk mg mh ll jo mi mj lp js mk ml lt mm bi translated">设置数据库</h2><ul class=""><li id="53f6" class="mn mo hy jb b jc lv jg lw jk mp jo mq js mr jw ms mt mu mv bi translated">因为这不是一个PostgreSQL教程，所以我们不要太深入它的设置。只需启动PostgreSQL并在<strong class="jb hz">端口:5432 </strong>上运行它，创建一个名为<code class="du ke kf kg kh b"><strong class="jb hz">quarkusdemo</strong></code>的数据库，我们就可以开始了</li><li id="2b9e" class="mn mo hy jb b jc mw jg mx jk my jo mz js na jw ms mt mu mv bi translated">在<code class="du ke kf kg kh b">quarkusdemo</code>中，用下面的模式创建一个名为<code class="du ke kf kg kh b">USER</code>的表</li></ul><pre class="ki kj kk kl fd km kh kn ko aw kp bi"><span id="71f9" class="kq kr hy kh b fi ks kt l ku kv">CREATE TABLE USER (<br/>  ID BIGSERIAL PRIMARY KEY, <br/>  NAME VARCHAR(64) NOT NULL, <br/>  EMAIL_ADDRESS VARCHAR(64) NOT NULL<br/>);</span></pre><figure class="ki kj kk kl fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nb"><img src="../Images/9411ec10e1b63856048ac6787c39cac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2oPFVvXTyD2507bmVt9pyA.png"/></div></div></figure><h2 id="3443" class="kq kr hy bd kz ma mb mc ld md me mf lh jk mg mh ll jo mi mj lp js mk ml lt mm bi translated">添加依赖关系</h2><p id="a2bd" class="pw-post-body-paragraph iz ja hy jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated">现在，我们需要添加一些包，以便使用您的数据库。对于一个<strong class="jb hz"> ORM </strong>来简化我们的SQL操作，我们将使用<code class="du ke kf kg kh b">quarkus-hibernate-orm-panache</code>，<strong class="jb hz">连接我们的PostgreSQL </strong>数据库，我们将使用<code class="du ke kf kg kh b">quarkus-jdbc-postgresql</code>来接受和<strong class="jb hz">产生JSON响应</strong>我们将<code class="du ke kf kg kh b">quarkus-resteasy-jackson</code>。将下面的依赖XML添加到根目录下的<code class="du ke kf kg kh b">pom.xml</code>文件中——</p><pre class="ki kj kk kl fd km kh kn ko aw kp bi"><span id="614e" class="kq kr hy kh b fi ks kt l ku kv">&lt;dependency&gt;<br/>  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>  &lt;artifactId&gt;quarkus-hibernate-orm-panache&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>  &lt;artifactId&gt;quarkus-jdbc-postgresql&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>  &lt;artifactId&gt;quarkus-resteasy-jackson&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="9f1a" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在<code class="du ke kf kg kh b">src/main/resources</code>内部。将此添加到您的<code class="du ke kf kg kh b">application.properties</code>以配置连接您的数据库。</p><pre class="ki kj kk kl fd km kh kn ko aw kp bi"><span id="7341" class="kq kr hy kh b fi ks kt l ku kv"><em class="nc">quarkus.datasource.db-kind </em>= postgresql<br/><em class="nc">quarkus.datasource.username </em>= postgres<br/><em class="nc">quarkus.datasource.password </em>= postgres<br/><em class="nc">quarkus.datasource.jdbc.url </em>= jdbc:postgresql://localhost:5432/quarkusdemo</span></pre><h2 id="6c2c" class="kq kr hy bd kz ma mb mc ld md me mf lh jk mg mh ll jo mi mj lp js mk ml lt mm bi translated">创建实体</h2><p id="2665" class="pw-post-body-paragraph iz ja hy jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated">首先，让我们为<code class="du ke kf kg kh b">USER</code>表创建一个实体</p><ul class=""><li id="60a9" class="mn mo hy jb b jc jd jg jh jk nd jo ne js nf jw ms mt mu mv bi translated">在与您的HelloWorldResource.java相同的目录中，创建一个名为<code class="du ke kf kg kh b">entity</code>的包，并在其中创建一个名为<code class="du ke kf kg kh b">Users.java</code>的java类，内容为</li></ul><pre class="ki kj kk kl fd km kh kn ko aw kp bi"><span id="54e3" class="kq kr hy kh b fi ks kt l ku kv"><em class="nc">// Replace with your package name and class name<br/>package </em>com.pradeepselva.quarkus.crud.entity;<br/><br/><em class="nc">import </em>io.quarkus.hibernate.orm.panache.PanacheEntityBase;<br/><br/><em class="nc">import </em>javax.persistence.*;<br/><br/>@Entity<br/>@Table(name = "USERS")<br/><em class="nc">public class </em>Users <em class="nc">extends </em>PanacheEntityBase {<br/>    @Id<br/>    @Column(name = "ID")<br/>    @GeneratedValue(strategy = GenerationType.<strong class="kh hz"><em class="nc">IDENTITY</em></strong>)<br/>    <em class="nc">private long </em>userId;<br/><br/>    @Column(name="NAME")<br/>    <em class="nc">private </em>String name;<br/><br/>    @Column(name = "EMAIL_ADDRESS")<br/>    <em class="nc">private </em>String emailAddress;<br/><br/>    <em class="nc">public long </em>getUserId() {<br/>        <em class="nc">return </em>userId;<br/>    }<br/><br/>    <em class="nc">public void </em>setUserId(<em class="nc">long </em>userId) {<br/>        <em class="nc">this</em>.userId = userId;<br/>    }<br/><br/>    <em class="nc">public </em>String getName() {<br/>        <em class="nc">return </em>name;<br/>    }<br/><br/>    <em class="nc">public void </em>setName(String name) {<br/>        <em class="nc">this</em>.name = name;<br/>    }<br/><br/>    <em class="nc">public </em>String getEmailAddress() {<br/>        <em class="nc">return </em>emailAddress;<br/>    }<br/><br/>    <em class="nc">public void </em>setEmailAddress(String emailAddress) {<br/>        <em class="nc">this</em>.emailAddress = emailAddress;<br/>    }<br/>}</span></pre><ul class=""><li id="2338" class="mn mo hy jb b jc jd jg jh jk nd jo ne js nf jw ms mt mu mv bi translated">我们将使用这个实体来处理对<code class="du ke kf kg kh b">USERS</code>表的操作。这个类将拥有我们的<strong class="jb hz"> ORM函数</strong>，因为它扩展了<strong class="jb hz"> PanacheEntityBase </strong>类。这里我们将表中的每一列定义为实体的一个类变量。我们声明long类型的ID，并将其生成策略设置为<code class="du ke kf kg kh b">IDENTITY</code>，这是我们的主键。本类中使用的装饰者(<code class="du ke kf kg kh b">Entity</code>、<code class="du ke kf kg kh b">Table</code>、<code class="du ke kf kg kh b">Column</code>、<code class="du ke kf kg kh b">Id</code>等)。)都很直接，完全按照他们说的去做。</li></ul><h2 id="870e" class="kq kr hy bd kz ma mb mc ld md me mf lh jk mg mh ll jo mi mj lp js mk ml lt mm bi translated">创建POST端点以将用户保存到数据库</h2><p id="7058" class="pw-post-body-paragraph iz ja hy jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated">现在把<code class="du ke kf kg kh b">HelloWorldResource</code>的类名改成<code class="du ke kf kg kh b">UsersResource</code>。让我们设置<code class="du ke kf kg kh b">UsersResource</code>的路径来处理端点<code class="du ke kf kg kh b">/api/users</code>。我们将从添加一个<strong class="jb hz"> POST </strong>方法到这个路径开始，添加保存用户的功能。</p><ul class=""><li id="6ae0" class="mn mo hy jb b jc jd jg jh jk nd jo ne js nf jw ms mt mu mv bi translated">为了创建一个post方法，<em class="nc">你猜对了，我们使用来自<code class="du ke kf kg kh b">javax.ws.rx</code>的</em> <code class="du ke kf kg kh b">POST</code>生成器。这个端点将<strong class="jb hz">接受用户的一个JSON </strong>对象(我们不会为这个演示处理任何复杂的验证)，也就是说，它从请求中消费一个JSON对象。我们将请求对象的媒体类型指定为JSON，这是在<code class="du ke kf kg kh b">Consumes</code>生成器中指定的。这个<strong class="jb hz">也产生一个JSON </strong>响应作为<code class="du ke kf kg kh b">Response</code>对象，这在<code class="du ke kf kg kh b">Produces</code>生成器中再次指定。由于这是一个保存数据的<strong class="jb hz">事务函数</strong>，我们指定使用<code class="du ke kf kg kh b">Transactional</code>生成器。挺直白的！</li></ul><pre class="ki kj kk kl fd km kh kn ko aw kp bi"><span id="861b" class="kq kr hy kh b fi ks kt l ku kv"><em class="nc">package </em>com.pradeepselva.quarkus.crud;<br/><br/><em class="nc">import </em>com.pradeepselva.quarkus.crud.entity.Users;<br/><br/><em class="nc">import </em>javax.transaction.Transactional;<br/><em class="nc">import </em>javax.ws.rs.Consumes;<br/><em class="nc">import </em>javax.ws.rs.POST;<br/><em class="nc">import </em>javax.ws.rs.Path;<br/><em class="nc">import </em>javax.ws.rs.Produces;<br/><em class="nc">import </em>javax.ws.rs.core.MediaType;<br/><em class="nc">import </em>javax.ws.rs.core.Response;<br/><br/>@Path("/api/users")<br/><em class="nc">public class </em>UsersResource {<br/>    @POST<br/>    @Transactional<br/>    @Consumes(MediaType.<strong class="kh hz"><em class="nc">APPLICATION_JSON</em></strong>)<br/>    @Produces(MediaType.<strong class="kh hz"><em class="nc">APPLICATION_JSON</em></strong>)<br/>    <em class="nc">public </em>Response createUser(Users user) {<br/>        Users.<em class="nc">persist</em>(user);<br/><br/>        <em class="nc">if</em>(user.isPersistent()) {<br/>            <em class="nc">return </em>Response.<em class="nc">ok</em>(user).build();<br/>        }<br/><br/>        <em class="nc">return </em>Response.<em class="nc">status</em>(Response.Status.<strong class="kh hz"><em class="nc">BAD_REQUEST</em></strong>).build();<br/>    }<br/>}</span></pre><figure class="ki kj kk kl fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ng"><img src="../Images/6597899b3b164721dd68c6e23ff89604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UEFx_8L9jQM1uJyeexMYmg.png"/></div></div></figure><p id="f8dd" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这正是我们上面讨论的。它<strong class="jb hz">"持久化"</strong>一个用户，如果它<strong class="jb hz">"持久化"</strong>，那么它返回用户对象作为<strong class="jb hz"> JSON响应</strong>，否则它发送<strong class="jb hz"> BAD_REQUEST </strong>的状态码作为响应。</p><p id="5460" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">您可以从根目录运行您的应用程序，使用—</p><pre class="ki kj kk kl fd km kh kn ko aw kp bi"><span id="b092" class="kq kr hy kh b fi ks kt l ku kv">./mvnw compile quarkus:dev</span></pre><p id="b6ab" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">左边的图片是第一次看到我们的API在运行！</p><h2 id="020f" class="kq kr hy bd kz ma mb mc ld md me mf lh jk mg mh ll jo mi mj lp js mk ml lt mm bi translated">创建一个GET端点来获取数据库中的所有用户</h2><p id="876e" class="pw-post-body-paragraph iz ja hy jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated">现在，你应该知道该怎么做了。现在我们将使用<code class="du ke kf kg kh b">GET</code>生成器在<code class="du ke kf kg kh b">/api/users</code>创建一个GET端点。这不会消耗任何东西，因为它是一个get请求，并且会产生一个JSON响应。现在你已经知道了如何让<strong class="jb hz">产生一个JSON </strong>响应。<code class="du ke kf kg kh b">Users</code>实体的<code class="du ke kf kg kh b">listAll()</code>函数返回<code class="du ke kf kg kh b">USERS</code>表中所有数据的<strong class="jb hz">可迭代</strong>。它基本上只是<code class="du ke kf kg kh b">SELECT * FROM USERS;</code>，但是有一个简单的函数将它转换成<code class="du ke kf kg kh b">Users</code>类型的Iterable。</p><pre class="ki kj kk kl fd km kh kn ko aw kp bi"><span id="4921" class="kq kr hy kh b fi ks kt l ku kv">@GET<br/>@Produces(MediaType.<strong class="kh hz"><em class="nc">APPLICATION_JSON</em></strong>)<br/><em class="nc">public </em>Response getAllUsers() {<br/>    <em class="nc">Iterable</em>&lt;Users&gt; allUsers = Users.<em class="nc">listAll</em>();<br/>    <em class="nc">return </em>Response.<em class="nc">ok</em>(allUsers).build();<br/>}</span></pre><figure class="ki kj kk kl fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nh"><img src="../Images/d87b14001098f55725f716064d491380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6JdUvoZghih55Jk3HTpazA.png"/></div></div></figure><p id="4c49" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这个函数应该是你的<code class="du ke kf kg kh b">UsersResource</code>类的一部分。它做的和它说的完全一样！</p><p id="aee1" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">同样，这是我们全新的GET请求！</p></div><div class="ab cl jx jy gp jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="hb hc hd he hf"><h1 id="3c37" class="ky kr hy bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">包扎</h1><p id="706f" class="pw-post-body-paragraph iz ja hy jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated">就像那样，我们已经配置了我们自己的PostgreSQL数据库以在我们的应用程序中使用，为方便起见设置了<strong class="jb hz"> ORM </strong>，并编写了API来保存<strong class="jb hz">用户数据和<strong class="jb hz">取回</strong>它们！</strong></p><p id="00dd" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">最棒的是，它几乎不需要任何时间，而且非常简单。这就是它的美妙之处。</p><p id="8f1d" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这只是夸夸其谈的一部分。从这里开始，您可以了解更多关于Quarkus提供的所有实用程序、Hibernate Panache ORM、使用实体管理器编写定制查询等等。旅程是漫长的，但是有一些很棒的文档可以支持你。</p><p id="452d" class="pw-post-body-paragraph iz ja hy jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">祝你在构思过程中愉快！</p></div></div>    
</body>
</html>