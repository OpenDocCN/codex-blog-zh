<html>
<head>
<title>Prefer lists to arrays in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中更喜欢列表而不是数组</h1>
<blockquote>原文：<a href="https://medium.com/codex/prefer-lists-to-arrays-in-scala-9df175e0884?source=collection_archive---------4-----------------------#2021-01-15">https://medium.com/codex/prefer-lists-to-arrays-in-scala-9df175e0884?source=collection_archive---------4-----------------------#2021-01-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="ecc9" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><figure class="ev ex ip iq ir is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es io"><img src="../Images/54f1c1c7cebc14572b77c4a2f5715e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UQXVOaKMQhiG4goX"/></div></div><figcaption class="iz ja et er es jb jc bd b be z dx translated"><a class="ae jd" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> freestocks </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="26db" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">Java提供了数组和列表。Scala也是如此。Java列表比数组有很多优势。在Scala中，列表比数组的优势甚至比Java更大。</p><p id="2a14" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">因为大多数学习Scala的人都是从Java的角度来学习的，所以我们将从回顾Java中声明和初始化数组的几种方式开始。</p><p id="b0cb" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这里有一种在Java中声明由五个特定整数组成的数组的方法:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="608b" class="kl km hi kh b fi kn ko l kp kq">int[] numbers = {43, -7, 8, 21, 58};</span></pre><p id="c71e" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">还有一些其他的方法，但是它们都涉及到“方括号”和“花括号”</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="d0bd" class="kl km hi kh b fi kn ko l kp kq">int[] numbers = new int[5];<br/>numbers[0] = 43;<br/>numbers[1] = -7; // etc.</span></pre><p id="5a67" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">Scala的语法有所不同，但是我想你会很快习惯的。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="dbbd" class="kl km hi kh b fi kn ko l kp kq">val numbers = Array(43, -7, 8, 21, 58)</span></pre><p id="035f" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">注意，那些是圆括号，不是“方括号”也不是“花括号”更有可能的是，在回到Java的过程中，你会忘记Java数组语法，而不得不在网上查找。我知道我有。</p><p id="7430" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在本地Scala REPL上，你可以得到关于类型推断的即时反馈。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="aa35" class="kl km hi kh b fi kn ko l kp kq">scala&gt; Array(43, -7, 8, 21, 58)<br/>res2: Array[Int] = Array(43, -7, 8, 21, 58)</span></pre><p id="29a1" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">上面显示的第一行Java代码和带有“<code class="du kr ks kt kh b">val</code>”的Scala代码都编译成了几乎相同的东西。如果您使用Java反汇编工具(<code class="du kr ks kt kh b">javap</code>和<code class="du kr ks kt kh b">-c</code>命令行选项)，您会看到很多不同之处，但是您也会看到很多连续的行是完全相同的。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="eb78" class="kl km hi kh b fi kn ko l kp kq">       0: iconst_5            // Push 5 (array size) on the stack<br/>       <strong class="kh hs">1: newarray      int</strong>   // New int array<br/>       3: dup                 // Duplicate top stack element<br/>       4: iconst_0            // Push 0 (first index) on the stack<br/>       <strong class="kh hs">5: bipush        43</strong>    // Push 43 (1st element) on the stack<br/>       7: iastore             // Store 43 at array index 0<br/>       8: dup<br/>       9: iconst_1            // Push 1 (second index) on the stack<br/>      <strong class="kh hs">10: bipush        -7</strong>    // Push -7 (2nd element) on the stack<br/>      12: iastore             // Store -7 at array index 1<br/>      13: dup<br/>      14: iconst_2            // Push 2 (third index) on the stack<br/>      // etc.</span></pre><p id="cb91" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">就JVM而言，Scala的<code class="du kr ks kt kh b">Array[Int]</code>和Java的<code class="du kr ks kt kh b">int[]</code>完全一样。</p><p id="bdcc" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">注意，在Scala中,“方括号”<code class="du kr ks kt kh b">[</code>和<code class="du kr ks kt kh b">]</code>不像在Java中那样用于数组。相反，它们的作用与Java中的“尖括号”<code class="du kr ks kt kh b">&lt;</code>和<code class="du kr ks kt kh b">&gt;</code>相同:为像<code class="du kr ks kt kh b">ArrayList&lt;E&gt;</code>这样的泛型类型括起类型参数。</p><p id="7954" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">本质上，您应该将Scala中的数组视为非常类似于Java开发工具包(JDK)中的泛型类型、Scala开发工具包(SDK)中的泛型类型、第三方库中的泛型类型以及您可能自己设计的泛型类型。</p><p id="765c" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这意味着，例如，如果你想在你的Scala程序中使用一个Java数组列表，你应该像这样声明它:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="64fe" class="kl km hi kh b fi kn ko l kp kq">    val reindeerNames = new util.ArrayList<strong class="kh hs">[</strong>String<strong class="kh hs">]</strong>()<br/>    reindeerNames add "Dasher"<br/>    reindeerNames add "Dancer"<br/>    reindeerNames add "Prancer" // etc.</span></pre><p id="4888" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">尽管在我看来，在Scala项目中使用任何<code class="du kr ks kt kh b">java.util</code>数据结构的唯一理由是为了Java的互操作性(例如，框架中的函数需要一个<code class="du kr ks kt kh b">ArrayList&lt;E&gt;</code>)。</p><p id="4fc6" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">该表扬的地方一定要表扬:当事先不知道元素的确切数量时，Java数组列表提供了比直接使用数组更重要的好处，比如自动调整后备数组的大小。</p><p id="b35b" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">尽管如此，最好在Scala程序中使用Scala集合。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="2267" class="kl km hi kh b fi kn ko l kp kq">val reindeerNames = List("Dasher", "Prancer", "Vixen", "Comet",<br/>                         "Cupid", "Donner", "Blitzen", "Rudolph")</span></pre><p id="b42f" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果相关类型<code class="du kr ks kt kh b">T</code>是<code class="du kr ks kt kh b">Comparable&lt;T&gt;</code>(Scala特性<code class="du kr ks kt kh b">Ordered[T]</code>扩展了Java的<code class="du kr ks kt kh b">Comparable[T]</code>)，那么对数组排序就很容易了。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="5df4" class="kl km hi kh b fi kn ko l kp kq">scala&gt; numbers.sorted<br/>res3: Array[Int] = Array(-7, 8, 21, 43, 58)</span></pre><p id="dd1d" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">不要指望用Java就能做到。在Scala中可以这样做的唯一原因是隐式转换为<code class="du kr ks kt kh b">ArrayOps[T]</code>。</p><p id="3550" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">但是要注意:数组是可变的数据结构，伴随而来的是所有的问题，包括并发性问题。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="66e6" class="kl km hi kh b fi kn ko l kp kq">scala&gt; numbers(0) = 74</span><span id="00a5" class="kl km hi kh b fi ku ko l kp kq">scala&gt; numbers<br/>res5: Array[Int] = Array(74, -7, 8, 21, 58)</span></pre><p id="709c" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在像<code class="du kr ks kt kh b">numbers</code>数组这样的玩具例子中，可变性根本不是问题。但是，在一个程序中，即使只有两个并发线程试图访问同一个数组，也可能会遇到瓶颈和竞争等问题。</p><p id="05cd" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">你们中的一些人可能对编写多线程程序不感兴趣。尽管如此，列表仍然比数组更好，因为心理模型:作为人类，我们倾向于考虑列表而不是数组。</p><p id="a8a4" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">例如，当你去购物时，你经常会有一个购物清单，但你可能从来没有过“购物清单”你的购物并不受限于任意数量的购物空间，而是受限于你能在这些商品上花多少钱，以及这些商品的价格。</p><p id="76a2" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">也许你想购买某个品牌的10个小配件，但你发现了一个交易，可以买两个小配件，送一个。所以，也许你接受了这笔交易，经常以这个价格购买15个小配件。</p><p id="11d6" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">因此，如果你用Java或Scala在网上购物车中实现购物车，你可能应该使用来自JDK的<code class="du kr ks kt kh b">java.util</code>包或SDK(来自<code class="du kr ks kt kh b">scala.collection.immutable</code>或<code class="du kr ks kt kh b">scala.collection.immutable</code>)的集合，而不是数组。</p><p id="2af2" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在某些情况下，比如在与Java框架交互操作时，您需要使用数组。但是由于<code class="du kr ks kt kh b">ArrayOps</code>中的<code class="du kr ks kt kh b">toList()</code>和<code class="du kr ks kt kh b">toSet()</code>函数，它们可以方便地转换成列表或集合。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="6c2e" class="kl km hi kh b fi kn ko l kp kq">scala&gt; numbers.toList<br/>res6: List[Int] = List(43, -7, 8, 21, 58)</span><span id="5c5d" class="kl km hi kh b fi ku ko l kp kq">scala&gt; numbers.toSet<br/>res7: scala.collection.immutable.Set[Int] = HashSet(-7, 21, 43, 8, 58)</span></pre><p id="a2f9" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这对于元素很少的玩具例子来说很好。当你需要一次处理成千上万个对象的时候呢？例如，假设您想要前一百万个素数的列表。</p><p id="a32c" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">一个简单的Java实现使用一个百万整数原语的数组，并且只进行最基本的优化(跳过所有大于2的偶数，只检查最大到<strong class="jg hs"> √ </strong> <em class="kv"> n </em>的潜在因子)，可以在不到三秒的时间内交付结果。</p><p id="c440" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">与使用不可变列表的Scala实现相比:这将花费很长时间，你可能会在几分钟后停止它，如果不是更早的话。只是在用<code class="du kr ks kt kh b">scala.collection.mutable.ArrayBuffer</code>替换了<code class="du kr ks kt kh b">List</code>之后，我才能够将运行时间降低到4秒以下。</p><p id="b456" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">但是…这个有一百万个素数的例子不太现实。你有多经常需要从几百万个整数中筛选出一百万个呢？可能不经常。</p><p id="5589" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">总的来说，Scala的数组主要用于与Java的互操作。在大多数情况下，更快的数组访问速度对于您不愿意使用C或C++之类的东西来说几乎没有任何优势。</p></div></div>    
</body>
</html>