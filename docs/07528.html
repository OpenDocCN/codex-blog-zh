<html>
<head>
<title>Shallow Cloning vs Deep Cloning | Objects | JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浅层克隆与深层克隆|对象| JavaScript</h1>
<blockquote>原文：<a href="https://medium.com/codex/shallow-cloning-vs-deep-cloning-objects-javascript-fc15280e5a6d?source=collection_archive---------19-----------------------#2022-06-17">https://medium.com/codex/shallow-cloning-vs-deep-cloning-objects-javascript-fc15280e5a6d?source=collection_archive---------19-----------------------#2022-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="bc80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对象是JavaScript的核心和灵魂。很多时候，我们出于很多原因想要在JavaScript中创建一个对象的副本/克隆。JavaScript中基本上有两种可能的克隆类型，今天我们将深入探讨它们。</p><h2 id="3cb1" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">1.浅层克隆</h2><p id="0413" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">让我们举一个简单的例子来理解浅层克隆</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kd"><img src="../Images/f86d6c6811e7bc7b01bc2515c785fd79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*F6F12mLddJE5L2CM4_XH2Q.png"/></div></figure><p id="e0d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上图中，你可以看到我创建了一个简单的person对象，名为<strong class="ih hj"> person1 </strong>，它有一些属性。在第51行，我创建了一个新对象(是吗？)称为<strong class="ih hj">人员2 </strong>并将其分配为人员1。之后，我只是更改person2的name属性。如果我控制台记录这两个对象，您认为输出会是什么？想一想！</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kl"><img src="../Images/fa5c48e2e9a8a2af27e8cacb5a5c5e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*Km-0-ZvtYv8DYPwFyp9NQw.png"/></div></figure><p id="50aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">令人惊讶的是，person1的name属性也被更改了。为什么会这样？因此，明确的答案是，person2实际上不是一个单独的对象，而只是对person1所指向的同一个对象的引用。这个创建对象克隆的过程被称为<strong class="ih hj">浅层克隆</strong>。</p><h2 id="0eb5" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">2.深度克隆</h2><p id="37ff" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">在我们深入探讨深度克隆之前，还有另一种类型的克隆叫做<strong class="ih hj">部分深度克隆</strong>。我给你举个例子来帮助你更好地理解。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es km"><img src="../Images/5c7f6118747ff947d025e507b1c14185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E0mZW2iX0hjKUOv2-_TEpg.png"/></div></div></figure><p id="61dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我刚刚向person对象添加了一个名为address的新属性，它是一个嵌套对象，我没有直接将person1分配给person2，而是使用<a class="ae kr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展运算符</a>将值赋予person2对象。</p><p id="c52b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第53和54行，我只是更新了person2对象的一些值。那么，当我控制台记录它们时，您认为这次的输出会是什么呢？</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ks"><img src="../Images/c77d355fbb827e91e4ca699cf07340a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J7d_mQobPkCI5xXyKJZ_4A.png"/></div></div></figure><p id="390e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所看到的，这一次，person1的名称并没有随着person2的名称的改变而改变，但是如果您已经注意到了，person1的嵌套对象(地址)的street属性也随着我们对person2的改变而改变，因此，实际上，spread操作符并没有对该对象进行精确的深度复制。这是对象的部分深层副本。类似地，在JavaScript中我们有<strong class="ih hj"> Object.assign() </strong>。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es kt"><img src="../Images/4e7dbb4017bbfdb2fe1c9af566e993a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*x0i_6mm-fx6eivueDDY2Yg.png"/></div></figure><p id="d572" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个场景中，我们也将得到相同的输出。因此，作为结论，我们可以说JavaScript中的spread操作符和Object.assign()对对象进行了部分深度克隆。还有另一种克隆对象的方法，那就是借助于<strong class="ih hj"> JSON.stringify() </strong>和<strong class="ih hj"> JSON.parse() </strong>但是它们的问题是，如果我们在一个对象中有一个函数和一些类型为object的属性，比如一个新的Date()，那么它不会被带到另一个对象，或者当它被带到另一个对象时，如果某个对象的属性在一个对象的字符串中发生了变化。下面是一个修改后的例子，修改后的代码与我们在本文中看到的一样。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ku"><img src="../Images/050adacb5b4a1fb8f2c3bf44e6799ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tbzp7G_LejBPlOM0nZTLWw.png"/></div></div></figure><p id="c6b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，person2对象没有calculateAge()，并且person2中的dateOfBirth属性被转换为字符串，这是我们不希望发生的。</p><p id="b483" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，为了在JavaScript中执行对象的完美深度克隆，我们将依赖一个名为lodash的第三方库，我们将通过npm安装它，因此请确保您的系统上安装了node。现在，我们在您的终端中运行以下命令:</p><blockquote class="kv kw kx"><p id="c880" class="if ig ky ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">npm i lodash</p></blockquote><p id="de98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将把lodash安装到您的项目中。要使用这个库，我们必须将这个库包含到我们的文件中，然后使用其中的方法来执行深度克隆。下面是我们的做法</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lc"><img src="../Images/b7cf98c99a14a176a8111687b411d070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yk3VCuAuyo9pSuvNHQxO0Q.png"/></div></div></figure><p id="7128" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，我使用了require('lodash ')并将其赋给了一个名为_lodash的常量，这样我就可以在文件中的任何地方使用它。现在，要创建person1对象的深层克隆，我们需要做的事情如下</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es ld"><img src="../Images/1122c3c611c4b9eef5018d54bac4464d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*Ptkz9s4E_RAP3NUPkD93OA.png"/></div></figure><p id="543d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，当我们控制台记录两个人对象时，我们将得到以下输出</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es le"><img src="../Images/2afebc8650ca432acbc31def709f9788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kblDx6fSZ8GU2kLHdQynTw.png"/></div></div></figure><p id="bc26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们已经成功地用JavaScript实现了该对象的100%深度克隆，而没有之前遇到的任何问题。</p><p id="d8e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总之，浅层拷贝只不过是由不同引用指向的相同对象，部分深层克隆是那些引用不同但不完全相同的对象，然后使用lodash我们可以得到该对象的完全深层克隆。希望你明白浅层克隆和深层克隆的区别。如果你有什么反馈或者你认为我错过了什么，请告诉我。谢了。快乐阅读。</p></div></div>    
</body>
</html>