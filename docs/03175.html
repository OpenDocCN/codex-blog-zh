<html>
<head>
<title>Clean Code — Objects and Data Structures (Summary)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干净的代码—对象和数据结构(摘要)</h1>
<blockquote>原文：<a href="https://medium.com/codex/clean-code-objects-and-data-structures-summary-1aa5d2058f84?source=collection_archive---------4-----------------------#2021-08-21">https://medium.com/codex/clean-code-objects-and-data-structures-summary-1aa5d2058f84?source=collection_archive---------4-----------------------#2021-08-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c501a136c528e585bb70b7fda80b2bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Se6reCDBQOAEKDGJ"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">克林特·王茂林在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="b252" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">数据抽象</h1><p id="f49b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">隐藏实现是关于抽象的。但是，它并没有简单地将变量私有，而是使用getters和setters来访问这些变量。相反，它公开了抽象接口，允许用户操作数据的<strong class="jv hj">本质</strong>，<strong class="jv hj">而不必知道其实现</strong>。例如:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/91b886453e2a2e9c05335d0ee94b64a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*S23j3oNdbAZFxlx6GjpqqQ.png"/></div></figure><p id="9b24" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">和</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/424786fc1b267c36cb3d660e5fb8ede6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*f-NEis03bpboFgpe9gT6mw.png"/></div></figure><p id="8c55" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">第一种使用具体术语来表示车辆的燃油油位，而第二种则使用百分比的抽象概念。上述第二种选择更可取。相反，我们希望用抽象的术语来表达我们的数据。这不仅可以通过使用接口和/或getters和setters来实现。</p><h1 id="8e15" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">数据/对象反对称</h1><p id="78bb" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">简单地说，对象和数据结构的区别是:</p><ul class=""><li id="44c6" class="lc ld hi jv b jw kw ka kx ke le ki lf km lg kq lh li lj lk bi translated"><strong class="jv hj">对象</strong>:将它们的数据隐藏在抽象之后，并公开对这些数据进行操作的函数。</li><li id="e05c" class="lc ld hi jv b jw ll ka lm ke ln ki lo km lp kq lh li lj lk bi translated"><strong class="jv hj">数据结构</strong>:暴露自己的数据，没有有意义的函数。</li></ul><p id="bf1b" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">例如，考虑程序形状示例。<code class="du lq lr ls lt b">Geometry</code>类操作三个形状类。形状类是没有任何行为的简单数据结构。所有的行为都在<code class="du lq lr ls lt b">Geometry</code>类中。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/c00caeaa2af23eb2f134fe3970e85908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ARPfrn8aDGEgceFIPPobaw.png"/></div></div></figure><p id="d311" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">观察如果我给<code class="du lq lr ls lt b">Geometry</code>添加<code class="du lq lr ls lt b">perimeter()</code>函数会发生什么。表单类不会受到影响。另一方面，如果我添加一个新的形状(一个新的数据结构)，我必须改变<code class="du lq lr ls lt b">Geometry</code>中的所有函数来处理它。</p><p id="ddbc" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">现在考虑面向对象的解决方案。这里的<code class="du lq lr ls lt b"> area()</code>方法是多态的。不需要<code class="du lq lr ls lt b">Geometry</code>类。因此，如果我添加一个新的形状，现有的功能都不会受到影响，但如果我添加一个新的功能，所有的形状都必须改变！</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/3459704d77b84698e6de638739ba18ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*89fJ_GvTWCYOj9VNiQpNEw.png"/></div></figure><p id="7b2f" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">对象和数据结构之间的基本二分法是:</p><blockquote class="lw lx ly"><p id="e9c9" class="jt ju lz jv b jw kw jy jz ka kx kc kd ma ky kg kh mb kz kk kl mc la ko kp kq hb bi translated">过程代码(使用数据结构的代码)使得在不改变现有数据结构的情况下添加新功能变得容易。另一方面，OO代码使得在不改变现有功能的情况下添加新类变得容易。</p></blockquote><p id="dbf9" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">补码</p><blockquote class="lw lx ly"><p id="47a2" class="jt ju lz jv b jw kw jy jz ka kx kc kd ma ky kg kh mb kz kk kl mc la ko kp kq hb bi translated">过程代码使得添加新的数据结构变得困难，因为所有的函数都必须改变。面向对象代码很难添加新的功能，因为所有的类都必须改变。</p></blockquote><p id="3190" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">关键是有些事情对于OO 来说<strong class="jv hj">难，对于程序</strong>来说<strong class="jv hj">容易，对于程序</strong>来说<strong class="jv hj">难的事情对于OO </strong>来说<strong class="jv hj">容易！</strong></p><p id="3bb3" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">当我们想要<strong class="jv hj">添加新的数据类型</strong>而不是新的函数时，<strong class="jv hj"> OO </strong>是最合适的。当我们想要<strong class="jv hj">添加新的函数</strong>而不是数据类型时，<strong class="jv hj">数据结构</strong>会更合适。</p><h1 id="bafa" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">德米特里定律</h1><p id="55ca" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">Demeter 的L <em class="lz"> aw表示一个模块不应该知道它所操作的<em class="lz">对象</em>的内部结构。这意味着对象不应该通过访问器公开其内部结构。</em></p><p id="a448" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">更准确地说，假设您有一个方法<code class="du lq lr ls lt b">f</code>和一个类<code class="du lq lr ls lt b">C</code>。Demeter法则说一个类<code class="du lq lr ls lt b">C</code>的方法<code class="du lq lr ls lt b">f</code>应该只调用这些方法:</p><ul class=""><li id="470e" class="lc ld hi jv b jw kw ka kx ke le ki lf km lg kq lh li lj lk bi translated"><code class="du lq lr ls lt b">C</code>(本身)</li><li id="538a" class="lc ld hi jv b jw ll ka lm ke ln ki lo km lp kq lh li lj lk bi translated">由<code class="du lq lr ls lt b">f</code>创建的对象</li><li id="cea2" class="lc ld hi jv b jw ll ka lm ke ln ki lo km lp kq lh li lj lk bi translated">作为参数传递给<code class="du lq lr ls lt b">f</code>的对象</li><li id="9d8b" class="lc ld hi jv b jw ll ka lm ke ln ki lo km lp kq lh li lj lk bi translated">保存在<code class="du lq lr ls lt b">C</code>的实例变量中的对象</li></ul><p id="1535" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">例如:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es md"><img src="../Images/98dcc7c141aa7c0f1cc7ba0c85e1eb4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*BhTqmYJyeKsdGzZXtkfCrw.png"/></div></figure><p id="dd71" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">该方法不应调用由任何允许的函数返回的对象上的方法。换句话说，和朋友说话，不要和陌生人说话。</p><h2 id="4b03" class="me iw hi bd ix mf mg mh jb mi mj mk jf ke ml mm jj ki mn mo jn km mp mq jr mr bi translated">火车失事</h2><p id="2d92" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">看看下面违反德米特里定律的代码</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/1b770846482ae85ed7eea88b7467d8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-QgSBKMDl1Bl_B7-WOb2Q.png"/></div></div></figure><p id="6284" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">它违反了Demeter定律，因为它对<code class="du lq lr ls lt b">getOptions()</code>的返回值调用<code class="du lq lr ls lt b">getScratchDir()</code>函数，然后对<code class="du lq lr ls lt b">getScratchDir()</code>的返回值调用<code class="du lq lr ls lt b">getAbsolutePath()</code>。这种代码通常被称为火车残骸，因为它看起来像一堆耦合的火车车厢。最佳解决方案是按如下方式将其拆分:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/37b7bacc1eae86a3db6cbc5abdd3bfcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*M5JadrceviGe8YeRZHSKkA.png"/></div></figure><p id="8455" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">这是否违反了Demeter取决于<code class="du lq lr ls lt b">ctxt</code>、<code class="du lq lr ls lt b">Options</code>和<code class="du lq lr ls lt b">ScratchDir </code>是对象还是数据结构。如果它们是<strong class="jv hj">对象</strong>，那么它们的内部结构应该是<strong class="jv hj">隐藏</strong>而不是暴露。另一方面，如果<code class="du lq lr ls lt b">ctxt</code>、<code class="du lq lr ls lt b">Options</code>和<code class="du lq lr ls lt b">ScratchDir </code>只是没有行为的<strong class="jv hj">数据结构</strong>，那么<strong class="jv hj">自然会暴露</strong>它们的内部结构，因此Demeter不适用。</p><h2 id="f2d1" class="me iw hi bd ix mf mg mh jb mi mj mk jf ke ml mm jj ki mn mo jn km mp mq jr mr bi translated">杂种</h2><p id="6f5e" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">混合结构是一半对象一半数据的结构。混合使得增加新的功能变得困难，但是也使得增加新的数据结构变得困难。<strong class="jv hj">避免</strong>制造它们。</p><h1 id="a7e2" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">数据传输对象</h1><p id="4f30" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">数据结构的典型形式是一个有公共变量而没有函数的类，它被称为数据传输对象或DTO。dto是非常有用的结构，尤其是在与数据库通信或解析来自套接字的消息时，等等。</p><p id="afca" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">更常见的叫做“豆”形。Beans拥有由getters和setters操作的私有变量。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/0f36f8df9aab0d4ff013a1b7463b88d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*piTCazYf2VYFAyTwrXEKlA.png"/></div></figure><h2 id="9212" class="me iw hi bd ix mf mg mh jb mi mj mk jf ke ml mm jj ki mn mo jn km mp mq jr mr bi translated">活动记录</h2><p id="4599" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">活动记录是具有公共(或被访问过的)变量的数据结构。但是它们通常有像<code class="du lq lr ls lt b">save </code>和<code class="du lq lr ls lt b">find</code>这样的导航方法。通常，这些活动记录是从数据库表或其他数据源直接翻译而来的。</p><p id="fb93" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated"><strong class="jv hj">不要把业务规则方法放入这些数据结构中，把它们当成对象。解决方案是将活动记录视为一个数据结构，并创建包含业务规则和隐藏其内部数据的单独对象。</strong></p><h1 id="9a8a" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论</h1><ul class=""><li id="3629" class="lc ld hi jv b jw jx ka kb ke mu ki mv km mw kq lh li lj lk bi translated"><strong class="jv hj">对象</strong>暴露行为，隐藏数据。这使得在不改变现有行为的情况下添加新类型的对象变得容易，但是使得向现有对象添加新行为变得困难。</li><li id="16cc" class="lc ld hi jv b jw ll ka lm ke ln ki lo km lp kq lh li lj lk bi translated"><strong class="jv hj">数据结构</strong>公开数据，没有显著的行为。这使得向现有数据结构添加新行为变得容易，但是向现有函数添加新数据结构变得困难。</li><li id="b88a" class="lc ld hi jv b jw ll ka lm ke ln ki lo km lp kq lh li lj lk bi translated">当我们希望灵活地添加新的<strong class="jv hj">数据类型</strong>时，我们更喜欢将<strong class="jv hj">对象</strong>用于系统的那个部分。</li><li id="7eec" class="lc ld hi jv b jw ll ka lm ke ln ki lo km lp kq lh li lj lk bi translated">当我们希望灵活地添加新的<strong class="jv hj">行为</strong>时，我们更喜欢将<strong class="jv hj">数据结构</strong>用于系统的那个部分。</li><li id="3781" class="lc ld hi jv b jw ll ka lm ke ln ki lo km lp kq lh li lj lk bi translated">优秀的软件开发人员不带偏见地理解这些问题，并为工作选择最佳方法。</li></ul></div><div class="ab cl mx my gp mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hb hc hd he hf"><p id="bfc7" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">这些都是我一直在努力学习的书的第6章总结，得到了书名为《干净的代码》的书的要点，作者是Robert C. Martin。</p><p id="9350" class="pw-post-body-paragraph jt ju hi jv b jw kw jy jz ka kx kc kd ke ky kg kh ki kz kk kl km la ko kp kq hb bi translated">请随时提供一些建议和反馈。谢了。</p><h1 id="4584" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">参考</h1><p id="ecd6" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">罗伯特·c·马丁的《干净的代码》</p></div></div>    
</body>
</html>