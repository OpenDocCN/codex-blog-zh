<html>
<head>
<title>Create Serverless Data Pipeline Using AWS CDK (Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS CDK (Python)创建无服务器数据管道</h1>
<blockquote>原文：<a href="https://medium.com/codex/create-serverless-data-pipeline-using-aws-cdk-python-ab2179488efd?source=collection_archive---------2-----------------------#2022-07-09">https://medium.com/codex/create-serverless-data-pipeline-using-aws-cdk-python-ab2179488efd?source=collection_archive---------2-----------------------#2022-07-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/91f768243de34273df1ddf987efd909c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVQ7a6i2NcMovhhKhiBcqA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">架构图</figcaption></figure><h1 id="faca" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">语境</h1><p id="ed4b" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">数据科学团队即将开始一项研究，他们需要一个基于AWS云的解决方案。这是我能提供给他们的:</p><p id="90bb" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated"><strong class="ju hj">主要流程(数据处理):</strong></p><ul class=""><li id="a87e" class="kv kw hi ju b jv kq jz kr kd kx kh ky kl kz kp la lb lc ld bi translated"><strong class="ju hj">设备</strong>上传<em class="le">。垫</em>文件与心电数据到S3桶(<strong class="ju hj"> Raw </strong>)</li><li id="4497" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp la lb lc ld bi translated">上传触发事件创建，该事件被发送到<strong class="ju hj"> SQS </strong>队列。</li><li id="26b7" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp la lb lc ld bi translated"><strong class="ju hj"> Lambda </strong>轮询SQS队列(事件映射调用)并开始处理事件。Lamba的运行时是一个Python Docker容器，因为库的大小超过了层的大小限制250 MB。如果过程中出现任何错误，您将在<strong class="ju hj"> Slack </strong>中收到通知。</li><li id="adfc" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp la lb lc ld bi translated">一旦完成，以拼花格式处理的数据被保存到S3桶中(<strong class="ju hj">已处理</strong>)。</li><li id="cae8" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp la lb lc ld bi translated">为了使数据科学家能够查询数据，<strong class="ju hj">胶合爬虫</strong>作业在<strong class="ju hj">数据目录</strong>中创建一个模式。然后，<strong class="ju hj"> Athena </strong>用于查询已处理的桶。</li></ul><p id="2437" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated"><strong class="ju hj">二次流程(CI/CD): </strong></p><p id="4747" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">当开发人员想要更改处理作业逻辑时，他应该准备好更改并提交给<strong class="ju hj"> CodeCommit </strong>库。其他一切都是自动化的，由CI/CD流程处理。</p><p id="4b0d" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">CodeBuild 服务将CDK代码转换成CloudFormation模板并部署到你的账户。换句话说，它自动创建所有基础结构组件。完成后，部署的资源组(堆栈)可在web UI上的<strong class="ju hj"> CloudFormation </strong>服务中获得。为了简化这两个步骤并为CI/CD流程提供自我更新，使用了<strong class="ju hj">代码管道</strong>抽象。您还会收到进度延迟通知。</p><h1 id="41e1" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">准备</h1><p id="4ef9" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">要为此项目准备您的本地环境，您应该遵循下面描述的步骤:</p><ol class=""><li id="9c83" class="kv kw hi ju b jv kq jz kr kd kx kh ky kl kz kp lk lb lc ld bi translated"><a class="ae ll" href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" rel="noopener ugc nofollow" target="_blank">安装AWS CLI </a>并设置凭证。</li><li id="09d5" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp lk lb lc ld bi translated"><a class="ae ll" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">安装NodeJS </a>以便能够使用CDK。</li><li id="3d5e" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp lk lb lc ld bi translated">使用命令<code class="du lm ln lo lp b">sudo npm install -g aws-cdk</code>安装CDK。</li><li id="6b57" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp lk lb lc ld bi translated">为您的项目创建一个新目录，并将您的当前工作目录更改为该目录。</li><li id="dcfe" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp lk lb lc ld bi translated">运行<code class="du lm ln lo lp b">cdk init --language python</code>启动CDK项目。</li><li id="c690" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp lk lb lc ld bi translated">使用CDK资源运行<code class="du lm ln lo lp b">cdk bootstrap</code>来引导AWS帐户。</li><li id="6e1c" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp lk lb lc ld bi translated"><a class="ae ll" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">安装Docker </a>在Lambda内部运行Docker容器。</li></ol><h1 id="4bcd" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">项目结构</h1><p id="028b" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">这是项目的最终外观。我将提供一步一步的指导，以便您最终理解其中的每个组件。</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="652f" class="ly iv hi lp b fi lz ma l mb mc">DataPipeline<br/>├──<!-- --> assets<br/>│<!-- -->   <!-- -->├──<!-- --> lambda<br/>│<!-- -->   <!-- -->│<!-- -->   <!-- -->├──<!-- --> dockerfile<br/>│<!-- -->   <!-- -->│<!-- -->   <!-- -->└──<!-- --> processing.py<br/>├── <!-- -->cdk.out<br/>│<!-- -->   <!-- -->└──<!-- --> ...<br/>├──<!-- --> stacks<br/>│<!-- -->   <!-- -->├──<!-- --> __init__.py<br/>│<!-- -->   <!-- -->├──<!-- --> data_pipeline_stack.py<br/>│<!-- -->   <!-- -->├── cicd_stack.py<br/>│<!-- -->   <!-- -->└── <!-- -->data_pipeline_stage.py<br/>├──<!-- --> app.py<!-- --> <br/>├──<!-- --> cdk.json<br/>└──<!-- --> requirements.txt</span></pre><p id="8a2b" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">我们的起点是<code class="du lm ln lo lp b">stacks</code>目录。它包含一个强制的空文件<code class="du lm ln lo lp b">__init__.py</code>来定义一个Python包。其他三个文件位于此处:</p><ul class=""><li id="4d70" class="kv kw hi ju b jv kq jz kr kd kx kh ky kl kz kp la lb lc ld bi translated"><code class="du lm ln lo lp b">data_pipeline_stack.py</code></li><li id="c919" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp la lb lc ld bi translated"><code class="du lm ln lo lp b">cicd_stack.py</code></li><li id="d225" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp la lb lc ld bi translated"><code class="du lm ln lo lp b">data_pipeline_stage.py</code></li></ul><p id="8df1" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">首先，我们打开<code class="du lm ln lo lp b">data_pipeline_stack.py</code>，导入进一步开发所需的所有库和构造。此外，我们需要定义一个具有父类<code class="du lm ln lo lp b">cdk.Stack</code>的类。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="e29f" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">之后，我们使用SQS <code class="du lm ln lo lp b"><a class="ae ll" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_sqs/Queue.html" rel="noopener ugc nofollow" target="_blank">Queue</a></code>构造来连接S3桶和Lambda。参数非常简单:堆栈元素id ( <code class="du lm ln lo lp b">‘raw_data_queue’</code>)、队列名称(<code class="du lm ln lo lp b">‘data_pipeline_queue’</code>)以及Lambda处理队列中的消息后该消息不可见的时间(<code class="du lm ln lo lp b">cdk.Duration.seconds(200)</code>)。请注意，可见性超时值取决于您的处理时间，如果处理需要30秒，最好将其设置为60秒。在本例中，我将它设置为200秒，因为处理需要大约100秒。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="e3d8" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">接下来，我们将使用<code class="du lm ln lo lp b"><a class="ae ll" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_s3/Bucket.html?highlight=add_event_notification#bucket" rel="noopener ugc nofollow" target="_blank">Bucket</a></code>构造为原始数据和已处理数据创建S3存储桶。记住，原始数据通常在上传后的头几天内被访问，我们可以添加<code class="du lm ln lo lp b">lifecycle_rules</code>在7天后将数据从S3标准传输到S3冰川，以降低存储成本。</p><p id="6368" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">此外，我们需要连接原始桶和SQS队列，以定义从桶中生成的事件的目的地。为此，我们使用带有两个参数的<code class="du lm ln lo lp b"><a class="ae ll" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_s3/Bucket.html?highlight=add_event_notification#aws_cdk.aws_s3.Bucket.add_event_notification" rel="noopener ugc nofollow" target="_blank">add_event_notification</a></code>方法:我们希望通知队列的事件(<code class="du lm ln lo lp b">_s3.EventType.OBJECT_CREATED</code>)和要通知的目标队列(<code class="du lm ln lo lp b">_s3n.SqsDestination(data_queue)</code>)。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><blockquote class="mf mg mh"><p id="7890" class="js jt le ju b jv kq jx jy jz kr kb kc mi ks kf kg mj kt kj kk mk ku kn ko kp hb bi translated">⚠️堆栈被销毁后，桶和里面的所有数据都将被删除。可以通过删除(设置为默认值)removal_policy和auto_delete_objects参数来更改此行为。</p></blockquote><p id="6d33" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">下一步是使用<code class="du lm ln lo lp b"><a class="ae ll" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.aws_lambda/DockerImageFunction.html" rel="noopener ugc nofollow" target="_blank">DockerImageFunction</a></code>构造创建Lambda。请参考下面的代码，看看我定义了什么参数。我认为它们是不言自明的，你已经熟悉了以前的例子，所以我相信这不会是一段艰难的时间。如有问题，请参考文档。</p><blockquote class="mf mg mh"><p id="7c14" class="js jt le ju b jv kq jx jy jz kr kb kc mi ks kf kg mj kt kj kk mk ku kn ko kp hb bi translated">⚠️:我唯一应该强调的是Lambda中的参数<code class="du lm ln lo lp b">timeout</code>的值——它应该总是小于队列中的参数<code class="du lm ln lo lp b">visibility_timeout</code>(<code class="du lm ln lo lp b">180</code>对<code class="du lm ln lo lp b">200</code>)。</p></blockquote><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="ded3" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">然后，我们附加一个策略来自动创建一个Lambda角色，这样它就可以使用<code class="du lm ln lo lp b">attach_inline_policy</code>方法处理来自S3的文件。您可以调整操作/资源参数，以授予Lambda对S3更细粒度的访问权限。</p><p id="5c84" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">现在我们转到<code class="du lm ln lo lp b">assets</code>目录。</p><p id="cdda" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">我们需要创建带有数据转换逻辑的<code class="du lm ln lo lp b">dockerfile</code>和<code class="du lm ln lo lp b">processing.py</code>，这非常简单。首先，我们解析来自SQS的事件以获得关于文件和桶的信息，然后解析<em class="le">。mat </em>将心电数据归档，清理后保存在<em class="le">中。拼花</em>格式到加工桶。此外，它还包括日志记录和松弛错误消息。最后，我们应该从队列中删除消息，这样文件就不会被再次处理。</p><p id="854a" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">对于你的管道，你可以改变处理逻辑，用你自己的Slack钩子替换<code class="du lm ln lo lp b">_url</code>。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="e3ad" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">让我们快速浏览一下Docker文件的逻辑:首先，我们从AWS ECR存储库中为Lambda汇集特殊的映像，然后安装所有Python库，将我们的<code class="du lm ln lo lp b">processing.py</code>脚本复制到容器中，并运行命令从脚本中启动处理程序函数。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><blockquote class="mf mg mh"><p id="fc01" class="js jt le ju b jv kq jx jy jz kr kb kc mi ks kf kg mj kt kj kk mk ku kn ko kp hb bi translated">⚠️:不要忘记将你在<code class="du lm ln lo lp b">processing.py</code>中使用的库添加到<code class="du lm ln lo lp b">dockerfile</code>中。</p></blockquote><p id="f01e" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">在此阶段，我们完成了数据管道堆栈的创建，可以进一步开始开发CI/CD堆栈。</p><h1 id="f72b" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">CI/CD堆栈</h1><p id="a3c5" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">对于CI/CD流程，我们将使用CodePipeline服务，这有助于我们简化部署流程。每次我们通过CodeCommit push更改数据管道或CI/CD堆栈时，CodePipeline都会自动重新部署这两个堆栈。简而言之，应用程序堆栈应添加到代码管道阶段，在该阶段添加到代码管道之后。之后，应用程序被合成为CI/CD堆栈，而不是应用程序堆栈。您可以在下面的代码管道结构后面找到文件和逻辑之间的连接的更详细的描述。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/fafb11d6aa0f845551b36826a70b1d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1LnqH5z_Ttyocy78qw28Dg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">创建代码管道堆栈的步骤</figcaption></figure><p id="1f1d" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">首先，我们需要打开<code class="du lm ln lo lp b">cicd_stack.py</code>，开始导入我们将使用的所有库和构造。稍后，我们将手动创建CodeCommit存储库，但是现在我们只需要引用它，所以我们可以将它作为源代码添加到CodePipeline中。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="b81d" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">我们使用<code class="du lm ln lo lp b"><a class="ae ll" href="https://docs.aws.amazon.com/cdk/api/v2/python/aws_cdk.pipelines/CodePipeline.html" rel="noopener ugc nofollow" target="_blank">CodePipeline</a></code>构造来创建CI/CD流程。我们使用参数<code class="du lm ln lo lp b">self_mutation</code>设置为<code class="du lm ln lo lp b">True</code>来允许管道自我更新，默认情况下它有<code class="du lm ln lo lp b">True</code>值。如果我们在应用程序堆栈中使用Docker，参数<code class="du lm ln lo lp b">docker_enables_for_synth</code>应该设置为<code class="du lm ln lo lp b">True</code>。之后，我们添加应用程序部署阶段，并启动管道构建来构建我们的管道。后者是将来设置时差通知的必要步骤。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="2cef" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">下一步是为CodePipeline配置Slack通知，以便开发人员可以监控部署。为此，我们使用<code class="du lm ln lo lp b"><a class="ae ll" href="https://docs.aws.amazon.com/cdk/api/v1/python/aws_cdk.aws_chatbot/SlackChannelConfiguration.html" rel="noopener ugc nofollow" target="_blank">SlackChannelConfiguration</a></code>构造。我们可以通过右键单击频道名称并复制URL的最后9个字符来获取<code class="du lm ln lo lp b">slack_channel_id</code>的值。要获得<code class="du lm ln lo lp b">slack_workspace_id</code>参数值，请使用<a class="ae ll" href="https://docs.aws.amazon.com/chatbot/latest/adminguide/getting-started.html" rel="noopener ugc nofollow" target="_blank"> AWS聊天机器人指南</a>。为了定义我们想要得到的通知类型，我们使用<code class="du lm ln lo lp b"><a class="ae ll" href="https://docs.aws.amazon.com/cdk/api/v1/python/aws_cdk.aws_codestarnotifications/NotificationRule.html" rel="noopener ugc nofollow" target="_blank">NotificationRule</a></code>construct。如果您想更精确地定义通知事件，请使用通知规则的<a class="ae ll" href="https://docs.aws.amazon.com/dtconsole/latest/userguide/concepts.html#events-ref-pipeline" rel="noopener ugc nofollow" target="_blank">事件。</a></p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><blockquote class="mf mg mh"><p id="3b12" class="js jt le ju b jv kq jx jy jz kr kb kc mi ks kf kg mj kt kj kk mk ku kn ko kp hb bi translated">具有<code class="du lm ln lo lp b"><a class="ae ll" href="https://docs.aws.amazon.com/cdk/api/v1/python/aws_cdk.pipelines/CodePipeline.html#aws_cdk.pipelines.CodePipeline.pipeline" rel="noopener ugc nofollow" target="_blank">.pipeline</a></code>属性的ℹ️我们指的是部署CDK应用的代码管道。只有在管道已经用<code class="du lm ln lo lp b"><a class="ae ll" href="https://docs.aws.amazon.com/cdk/api/v1/python/aws_cdk.pipelines/CodePipeline.html#aws_cdk.pipelines.CodePipeline.build_pipeline" rel="noopener ugc nofollow" target="_blank">build_pipeline()</a></code>方法建造后才可用。对于<code class="du lm ln lo lp b">source</code>的论点，我们应该传递的不是构造，而是管道对象。</p></blockquote><p id="322e" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">定义管道后，我们添加数据管道部署阶段。为了使我们项目更加清晰，我们在单独的文件中定义了数据管道部署的阶段。为此，我们使用<code class="du lm ln lo lp b"><a class="ae ll" href="https://docs.aws.amazon.com/cdk/api/v1/python/aws_cdk.core/Stage.html" rel="noopener ugc nofollow" target="_blank">cdk.Stage</a></code>父类。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="d5bb" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">对于那些使用<strong class="ju hj"> <em class="le"> </em> CDKv1 </strong>的人来说，额外的步骤是修改<code class="du lm ln lo lp b">cdk.json</code>配置文件，你应该将下面的表达式添加到上下文中。</p><pre class="lq lr ls lt fd lu lp lv lw aw lx bi"><span id="2366" class="ly iv hi lp b fi lz ma l mb mc">"context": {"@aws-cdk/core:newStyleStackSynthesis": true}</span></pre><p id="8ee2" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">至此，我们已经为数据管道堆栈创建了所有的构造和文件。剩下的唯一事情就是创建<code class="du lm ln lo lp b">app.py</code>和所有的最终步骤。我们导入从<code class="du lm ln lo lp b">cicd_stack.py</code>创建的所有构造，并为所有堆栈资源创建标签。</p><figure class="lq lr ls lt fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="a694" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">恭喜，我们已经完成了堆栈的创建。现在，我们终于可以创建名为<code class="du lm ln lo lp b">data_pipeline_repository</code>的CodeCommit存储库并向其中推送文件了。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/bb9d75f82231d62e2d6b87d3b12244fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Y-e0K9Yk_guTFI1H-jd1Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">代码提交存储库创建</figcaption></figure><p id="c55e" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">我们可以手动添加与在堆栈中创建的标签相同的标签，这样我们就可以在成本报告中看到为此任务创建的所有资源绑定在一起。</p><blockquote class="mf mg mh"><p id="13b5" class="js jt le ju b jv kq jx jy jz kr kb kc mi ks kf kg mj kt kj kk mk ku kn ko kp hb bi translated">⚠️在部署之前检查服务配额中的代码构建限制。</p></blockquote><p id="915a" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">恭喜，现在我们终于可以使用命令<code class="du lm ln lo lp b">cdk deploy</code>将堆栈部署到AWS，并享受所有资源是如何自动设置的。</p><h1 id="603a" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">雅典娜查询</h1><p id="fd2e" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">让我们从创建Glue Crawler开始，因为你需要在Glue控制台的数据目录部分点击Crawler。然后，您应该点击添加爬虫按钮，并检查所有步骤。我添加了与其他数据管道资源相同的标记，因此我可以一起跟踪它们。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/b730aef6f2f0e0c54091d4a9614a4d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5zBuwS5WRG5RcgaGBxmuw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">胶水爬虫创建</figcaption></figure><p id="e2e8" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">不要更改crawler源类型，添加S3数据存储并在包含路径中指定存储桶的路径。之后，创建新的或添加现有的角色，并指定运行它的频率。然后你应该创建数据库，在我的例子中我创建了<code class="du lm ln lo lp b">ecg_data</code>数据库。完成所有步骤并创建crawler后，运行它。</p><p id="329b" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">这就是我们用Athena查询<code class="du lm ln lo lp b">processed_ecg_data</code>表所需的全部内容。简单查询示例如下。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/33971033301c21849d7069a7903156ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nSKfFB7CONVXLTSedG5VA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">雅典娜查询</figcaption></figure><h1 id="05c6" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">帐户清理</h1><p id="6aad" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">如果您想删除开发过程中在您的帐户中创建的所有资源，您应该执行以下步骤:</p><ol class=""><li id="1d1e" class="kv kw hi ju b jv kq jz kr kd kx kh ky kl kz kp lk lb lc ld bi translated">运行以下命令删除所有栈资源:<br/> <code class="du lm ln lo lp b">cdk destroy CodePipelineStack/DataPipelineDeploy/DataPipelineStack CodePipelineStack</code></li><li id="14a8" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp lk lb lc ld bi translated">删除代码提交存储库</li><li id="b7a6" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp lk lb lc ld bi translated">为雅典和CDK创建的Clean ECR存储库和S3存储桶，因为它会产生成本。</li><li id="c877" class="kv kw hi ju b jv lf jz lg kd lh kh li kl lj kp lk lb lc ld bi translated">删除带表的粘合爬虫和数据库。</li></ol><blockquote class="mf mg mh"><p id="e8af" class="js jt le ju b jv kq jx jy jz kr kb kc mi ks kf kg mj kt kj kk mk ku kn ko kp hb bi translated">ℹ️命令<code class="du lm ln lo lp b">cdk destroy</code>只会破坏代码管道(CI/CD)栈和依赖它的栈。因为应用程序堆栈不依赖于代码管道堆栈，所以它们不会被销毁。我们需要分别销毁数据管道堆栈，有一个<a class="ae ll" href="https://github.com/aws/aws-cdk/issues/10190" rel="noopener ugc nofollow" target="_blank">讨论如何删除它们两个</a>。</p></blockquote><p id="1141" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">手动删除一些资源不太方便，需要与AWS开发人员进行几次讨论来解决这个问题。</p><h1 id="0362" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">结论</h1><p id="e8e0" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp hb bi translated">CDK为您提供基于AWS服务的应用开发工具包。一开始可能会很有挑战性，但你的努力最终会有回报的。您将能够通过一个命令来管理和传输您的应用程序。</p><p id="366e" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">CDK资源和完整代码可以在<a class="ae ll" href="https://github.com/ChildishGirl/serverless-data-pipeline" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到。</p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="738e" class="pw-post-body-paragraph js jt hi ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp hb bi translated">谢谢你一直读到最后。我真的希望它是有帮助的，如果你在评论中发现任何错误，请让我知道。</p></div></div>    
</body>
</html>