<html>
<head>
<title>Key Differences between C-Sharp and F-Sharp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">升C调和降F调的主要区别</h1>
<blockquote>原文：<a href="https://medium.com/codex/key-differences-between-c-sharp-and-f-sharp-73dd465cc296?source=collection_archive---------8-----------------------#2021-06-17">https://medium.com/codex/key-differences-between-c-sharp-and-f-sharp-73dd465cc296?source=collection_archive---------8-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ea0eb5490120e85902baf3145d437543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KgGNQ6vtSJaNSCDbiEQHbQ.png"/></div></div></figure><p id="990f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">C#和F#都有自己独特的方式。显然，当我们比较不同的编程语言时，这两种语言之间必然存在某些相似之处和不同之处。</p><p id="c53e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么这些区别是什么呢？C#和F#中有哪些可以做得更好的地方？在本帖中，我们有你所有问题的答案。请继续阅读。</p><p id="8f1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录</strong></p><ul class=""><li id="ec11" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">C#的得分高于F#？</li><li id="fcbc" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">其中F#得分超过C#？</li><li id="fbd8" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">两种语言代码的比较</li><li id="04c5" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">结论</li></ul><h1 id="5e16" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">C#的得分高于F#？</h1><h2 id="090e" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">任务运行时性能</h2><p id="d898" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">异步代码在C#中比在F#中运行得更快。这主要是因为编译器本身支持这些代码，并且它们生成优化的代码。一旦F#开始原生支持代码，这种差异就会缩小。尽管存在这种差异，但对于典型的业务线应用程序来说，这并不重要。</p><p id="d8f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">w可以提取到C#库中，并从F#中调用它，以获得真正的性能敏感代码。异步工作流通常在代码中使用，因为它比任务更容易使用。还因为它支持开箱即用的取消。</p><h2 id="80ec" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">与互动。网络图书馆</h2><p id="373b" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">因为大多数。NET库是用C#编写的，与F#相比，开发人员用C#工作变得更容易。</p><h2 id="172f" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">早期回报</h2><p id="c39b" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">在C#中，只需使用关键字<em class="lt"> return </em>就可以调用一个方法。这在F#中是不可能的。在深度嵌套的代码块中，这个特性非常有用。尽管return使得调用方法变得更容易，但是理解代码可能会变得困难。</p><h2 id="f037" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">协变/逆变</h2><p id="9731" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">C#支持Co/Contravariance，目前F#还不支持。这对于处理泛型的库代码尤其有益。</p><h2 id="1ad7" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">一般面向对象编程</h2><p id="f296" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">在C#中使用受保护的类更容易，因为它有一个在F#中没有的关键字叫做<em class="lt">受保护的</em>。此外，内部类类型、隐式接口和分部类的实现在C#中是可能的，而在F#中是不可能的。一般的面向对象编程在C#中更容易完成。</p><h2 id="a735" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">隐式铸造</h2><p id="e8b8" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">C#支持隐式转换，而F#不支持。F#不支持这两种类型，即向上转换或向下转换。因此，在C#中使用依赖隐式转换的库更容易。</p><h2 id="6a3f" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">源发生器</h2><p id="838a" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">源生成器不适用于F#。但是，有Myriad(一个代码生成器)。</p><h2 id="0379" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">文件排序</h2><p id="2a0d" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">在C#中，可以以任何方式对文件和命名空间进行排序。F#中有严格的顺序(从下到上)。因此，在C#中定义需要循环的模型更容易。</p><h2 id="3155" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">工具和集成开发环境支持</h2><p id="4bb5" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">与F#相比，C#提供了更好的工具和IDE支持。</p><p id="3df3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在所有ide中，C#的调试过程比F#更容易。在F#中，异步工作流尤其难以调试。</p><h2 id="de42" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">低级编程</h2><p id="f7d7" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">不安全代码和Invoke/P是属于C#的东西。C#也支持Span和pinned ref。这些在F#中都没有。</p><h2 id="ba8e" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">Winforms或WPF</h2><p id="48c9" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">C#特别开始为WPF或Winform客户端编码。这不是F#的重要领域。</p><h2 id="5c9e" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">实体框架</h2><p id="dfe2" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">在。NET世界中，实体框架是一个非常流行的框架。编码人员本能地想到不要在F#中使用这个框架，因为这个框架的设计是违反F#的。</p><h2 id="3532" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">异步主方法</h2><p id="4c10" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">在<em class="lt"> main </em> methodm中<em class="lt"> async </em>可用于C#的情况，而对于F# <em class="lt"> Async。<em class="lt">主</em>方法中使用同步运行</em>。</p><h1 id="943e" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">其中F#得分超过C#？</h1><h2 id="d890" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">默认不变性</h2><p id="1b1d" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">在F#中一切都是不可变的，除非你使用关键字<em class="lt"> mutable。</em>不变性有助于使并行化更容易，并防止缺陷。</p><p id="3a6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在F#中，管道便于从左上到右下编码，而不使用任何局部变量。因此更容易阅读代码。</p><h2 id="107e" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">一切都是一种表达</h2><p id="e148" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">随着表达式的使用，对代码的推理变得更加容易，对代码的调试也变得更加容易。F#中只有表达式，而C#中有表达式和语句。</p><h2 id="898a" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">类型推理</h2><p id="05ce" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">F#中的类型推断使得程序员输入较少的注释。重构也变得更加容易。</p><h2 id="60d1" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">受歧视的工会</h2><p id="ff72" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">F#中存在有区别的联合，这允许在使用类、记录、枚举和接口时以更好的方式对业务领域建模。更好的建模导致简单的代码和更少的缺陷。</p><h2 id="08f7" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">计算表达式</h2><p id="61b7" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">计算表达式以一种程序员友好的方式结合了各个方面，如异步、选项、结果、验证等。这在F#中是众所周知的。许多ce都在名为<em class="lt"> FsToolkit的库中提供。</em>将<em class="lt"> async </em>与任何东西结合起来，最终会变成臃肿的代码，难以阅读。</p><h2 id="17c6" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">模式匹配</h2><p id="212f" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">F#中的活动模式使得复杂的模式匹配更容易阅读。虽然C#最近在模式匹配方面有所改进，但F#比C#有一个更高的优势，即有一个活动的模式。</p><p id="fcc3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在F#中度量是已知的，而在C#中却不是。随着度量方法的使用，代码变得不容易出错并且更具表达性。</p><h2 id="d57d" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">更容易合并</h2><p id="7237" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">在C#中，许多合并冲突都是在方法声明的结尾引起的。在F#中不会出现这样的问题。</p><h2 id="3563" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">F#是更简单的语言</h2><p id="82f4" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">简单是使用F#的主要原因。F#中有71个关键字，而C#中有110个。在F#中只有一种方法来定义记录，而在C#中有4种方法。</p><p id="7423" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">C#没有自动语法布局工具。F#有Fantomas，可以帮助编写没有任何StyleCop-build-warnings的可读代码。</p><h2 id="e37e" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">部分应用和可组合性</h2><p id="9fbc" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">F#提供了部分应用程序，这在C#中是不方便的。这有助于创建更好的可组合设计。</p><h1 id="ccd8" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">两种语言代码的比较</h1><h2 id="532f" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">C#:平方和</h2><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/0af8e1dd3c0af6942d190efcb5230f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*bp35waX3MWBwh7Kt"/></div></figure><h2 id="c5c0" class="la kd hi bd ke lb lc ld ki le lf lg km jb lh li kq jf lj lk ku jj ll lm ky ln bi translated">F#:平方和</h2><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/74c84d5bf2b2e85011af1959875faf72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/0*VMlIP8nvpAOZ9DGc"/></div></figure><h1 id="98d8" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="70bf" class="pw-post-body-paragraph iq ir hi is b it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn hb bi translated">在本文中，我们看到了C#在某些方面比F#更好，反之亦然。两种语言各有利弊。因此，根据您正在构建的应用程序来选择语言是很重要的，这样就可以充分利用它们的特性来编写好的代码。最棒的是——这两种语言之间的互操作性非常惊人，允许您在应用程序中混合使用它们。</p></div><div class="ab cl ma mb gp mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hb hc hd he hf"><p id="3f7e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lt">原载于</em><a class="ae mh" href="https://www.partech.nl/nl/publicaties/2021/06/key-differences-between-c-sharp-and-f-sharp" rel="noopener ugc nofollow" target="_blank"><em class="lt">https://www . partech . nl</em></a><em class="lt">。</em></p></div></div>    
</body>
</html>