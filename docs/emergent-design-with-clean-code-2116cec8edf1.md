# 代码简洁的紧急设计

> 原文：<https://medium.com/codex/emergent-design-with-clean-code-2116cec8edf1?source=collection_archive---------12----------------------->

关于*干净代码*的一个伟大的事情是，随着你阅读这本书的进展，你所涵盖的概念变得更加抽象。在我看来，这种实践反映了一个人如何更好地掌握编程艺术本身。当你开始阅读*干净代码*时，你会学到一些概念，比如变量或函数的好名字，以及一个类的最佳行数。然而，当你继续读下去的时候，Bob 叔叔公司详细说明了你如何从你的代码中抽身出来，并确保它是设计良好的，你的一个同事可以在任何一天进入你的程序，并很容易理解你想要它做什么。

![](img/6a16cbf6b3ba8aa0167c6cbfee7d5f97.png)

同样，一旦你掌握了一门语言或框架的语法和基本特性，你就能够[到代码的抽象层](https://tomassetti.me/raising-the-level-of-abstraction-what-if-we-tried-to-do-that-bottom-up/)，专注于程序的整体设计和可维护性。我这里指的是[紧急设计](https://en.wikipedia.org/wiki/Emergent_Design#Emergent_design_in_agile_software_development)，敏捷软件开发中的一个概念，它敦促开发人员专注于构建应用程序的功能，并让系统的整体设计随着时间的推移而出现。在这篇博客中，我将回顾*干净代码*促进紧急设计的一般规则(按重要性排序)，以及如何构建可读性和可维护性更强的健壮程序。

## 规则 1:运行所有的测试

![](img/cb35b6ecf65cd4f7c6f6a0cd3dfe285e.png)

虽然我们在之前已经[讨论过测试，但它值得重复。为了使这一课简单，我将重复我在软件开发领域的导师们对我说的最常引用的一句话:](/geekculture/reading-clean-code-week-5-unit-tests-ccbfe31b6460?source=your_stories_page-------------------------------------)[未经测试的代码是破损的代码](https://maurits.vanrees.org/weblog/archive/2007/10/untested-code-is-broken-code)。正如 *Clean Code* 所说，一个未经测试的程序是一个不可验证的程序；也就是说，您不能检查您的代码是否始终如一地做您想要它做的事情。如果你不能检查一个系统做什么，你最好不要部署它。

虽然我可能听起来像一张破唱片，但对测试进行优先排序本质上迫使我们写更干净的代码。例如，如果一个程序的所有逻辑都存在于单个文件中，那么测试将会非常困难。为了编写这种逻辑的测试，你需要将你的函数分解到单独的文件中，默认情况下更紧密地遵循 [SRP](https://en.wikipedia.org/wiki/Single-responsibility_principle) ，最终使你的程序更小。此外，这种实践非常适合松散耦合和高内聚。因此，如果你从这篇博客文章中没有收集到任何其他信息，请收集以下信息:编写你的测试。

## 规则 2:重构

![](img/ebf3d131587d9e6cad35f9579a1361c4.png)

我们之前也提到过[重构](https://levelup.gitconnected.com/reading-c%CC%B6l%CC%B6e%CC%B6a%CC%B6n%CC%B6-c%CC%B6o%CC%B6d%CC%B6e%CC%B6-refactoring-week-4-a7abe6539eb3?source=your_stories_page-------------------------------------)，但是和测试一样，这是一个非常重要的主题，我们应该更深入地讨论它。简而言之，重构我们的代码对于好的设计是必不可少的。事实上，关于重构的规则排在关于测试的规则之后有一个很好的理由:如果我们有好的测试，我们可以确信我们的程序做了我们想要它做的事情，*即使我们改变它*。正如 Jeff Langr 在*干净代码*中所写的:

> 我们有这些测试的事实消除了对清理代码会破坏它的担心！

尽管这可能是一个令人生畏的命题，但是增量重构我们的代码是非常重要的。在重新审视我们的逻辑时，我们给自己一个机会来采用编程最佳实践、选择更好的名称、模块化我们的逻辑等等。随着测试和重构处于紧急设计的前沿，我们可以用最后三条规则来微调我们的代码。

## 规则 3:不要重复

![](img/89367a1fac4b5e9d36f8f2077796eb1a.png)

在这一点上，你可能会看到我用这篇文章总结了很多我之前的博文。虽然还有更多章节可以阅读，我也即将发表关于*干净代码*的博客文章，但这一章很好地概括了这本书，总结了许多你希望编写一个有凝聚力的软件时最重要的要点。

重复的代码会给系统带来不必要的复杂性，伴随着这种复杂性，您的程序也有更多失败的机会。通过消除这种重复，您的代码变得更加可重用。虽然有很多方法可以让你的代码保持清晰，但是 *Clean Code* 特别提到了来自极具影响力的 [*设计模式*](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_1?dchild=1&keywords=design+patterns&qid=1629484668&sr=8-1) 的[模板方法](https://refactoring.guru/design-patterns/template-method)，作为降低复杂性的一种方式。

## 规则 4:表现力

![](img/e2f1fc0054701f26528ac7dc365ee7d7.png)

我们都有过这种经历，试图破译不清楚的代码，煞费苦心地研究每一行，寻找出现的模式。通常，我们是最初编写难以理解的代码的程序员，这使得混乱的刺痛更加严重。正如 *Clean Code* 告诉我们的，“软件项目的大部分成本都在长期维护中。”因此，我们编写团队中每个人都能理解的软件是至关重要的。

以代码为媒介，有很多方法可以很好地表达我们自己。好的名字有助于我们编写有表现力的代码，小函数和分离关注点也是如此。此外，单元测试是使我们的代码更有表现力的另一种方式。当我们运行测试时，我们对代码的意图有了更好的理解。

## 规则 5:最小化类和方法

虽然遵循规则 3 和 4 很重要，但我们不想走得太远，创建数千个类和/或文件来完成我们的任务。在保持类和方法小的过程中，我们可能会制造太多的类和方法，这最终会增加代码的复杂性并降低我们的速度。事实上，编写干净的代码是一种平衡行为；在努力实现目标的过程中，你会不断地问自己这个方法是不是太大了？我的课太多了吗？这些测试很脆弱吗？

坦率地说，这种不确定性是编程的本质。对于大多数编码问题来说，没有固定的“正确答案”。编程是一种创造性的练习，一种永远不会完美的练习，但是在试图变得完美的过程中，我们每天都会变得更好一点。随着你技能的提高，没有“完美代码”的想法从极度恐惧到最终解脱。在尝试编写干净代码的过程中，你将作为一名程序员得到提高，你将推动你的同事提高，你将创造出令人惊叹的东西。有什么工作能比这更好呢？

在这一章的结尾，Langr 提到，虽然遵循这些规则很重要，但是没有任何指导方针可以胜过从经验中获得的专业知识。尽管如此，通过关注这些原则，各种水平的程序员都增加了他们编写干净代码的可能性，并在这样做的过程中，创建优雅的软件。

编码快乐！