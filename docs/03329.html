<html>
<head>
<title>Hunting for XSS with CodeQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用CodeQL寻找XSS</h1>
<blockquote>原文：<a href="https://medium.com/codex/hunting-for-xss-with-codeql-57f70763b938?source=collection_archive---------4-----------------------#2021-08-28">https://medium.com/codex/hunting-for-xss-with-codeql-57f70763b938?source=collection_archive---------4-----------------------#2021-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="97d3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是CodeQL</h1><p id="0143" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">几个月前，我通过滚动我的Twitter feed了解了CodeQL，从那以后我就爱上了它。顾名思义，CodeQL是一种查询语言。然而，您不是在数据库中查询实体记录，而是在代码库中查询感兴趣的模式。例如，假设您有以下示例NodeJS应用程序。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="kg kh l"/></div><figcaption class="ki kj et er es kk kl bd b be z dx translated">示例JavaScript应用程序</figcaption></figure><p id="1530" class="pw-post-body-paragraph jd je hi jf b jg km ji jj jk kn jm jn jo ko jq jr js kp ju jv jw kq jy jz ka hb bi translated">现在，假设您想知道在项目的哪些地方，名为<strong class="jf hj"> foo </strong>的属性被读取或写入。下面的codeQL查询将给出您正在寻找的结果。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="kg kh l"/></div><figcaption class="ki kj et er es kk kl bd b be z dx translated">示例查询</figcaption></figure><p id="d50d" class="pw-post-body-paragraph jd je hi jf b jg km ji jj jk kn jm jn jo ko jq jr js kp ju jv jw kq jy jz ka hb bi translated">设置codeQL环境并开始试用的步骤非常简单，可以在<a class="ae kr" href="https://codeql.github.com/docs/codeql-cli/getting-started-with-the-codeql-cli/" rel="noopener ugc nofollow" target="_blank">https://codeQL . github . com/docs/codeQL-CLI/getting-started-with-the-codeQL-CLI/</a>找到。一旦你有了合适的环境，我推荐你观看<a class="ae kr" href="https://securitylab.github.com/events/2020-05-07-codeql-workshop-javascript/" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj">用CodeQL </strong> </a>寻找JavaScript中的安全漏洞研讨会。这将通过实际操作让你对这门语言及其特性有一个基本的了解。</p><h1 id="88a3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">内置查询</h1><p id="d5be" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一旦你了解了基础知识，你将会了解到CodeQL已经有了很多内置的查询，可以用来寻找最常见类型的编码错误，包括<em class="ks"> XSS </em>。也就是说，开始使用codeQL寻找bug的一种方法是简单地对您克隆的开源代码库运行现有的查询。</p><p id="fe69" class="pw-post-body-paragraph jd je hi jf b jg km ji jj jk kn jm jn jo ko jq jr js kp ju jv jw kq jy jz ka hb bi translated">为了举例说明，您可以采取以下步骤，使用CodeQL找到我在<a class="ae kr" href="https://github.com/discourse/discourse/security/advisories/GHSA-v3v8-3m5w-pjp9" rel="noopener ugc nofollow" target="_blank"> Discourse </a>项目中发现的基于DOM的XSS漏洞。要复制这个发现，克隆话语存储库，签出提交<em class="ks">bb 2 c 48 b 0657 f 6182 b 852 ab 76 fc 190825d F5 d 2 b 7 f</em>，并从中创建一个codeQL数据库。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="kg kh l"/></div><figcaption class="ki kj et er es kk kl bd b be z dx translated">话语数据库创建</figcaption></figure><p id="d440" class="pw-post-body-paragraph jd je hi jf b jg km ji jj jk kn jm jn jo ko jq jr js kp ju jv jw kq jy jz ka hb bi translated">创建数据库后，可以使用<strong class="jf hj"><em class="ks">xssthroughdom . QL</em></strong>查询来寻找潜在的<em class="ks">基于Dom的XSS </em>漏洞。如果您设置了可视化代码+CodeQL集成，您应该会得到如下结果。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es kt"><img src="../Images/e1976c05642a81b4af70b37f4dd65f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yl7Fb0hcCHS3HMNbAaBc6w.png"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx translated"><strong class="bd ih"> <em class="la"> XssThroughDom.ql结果</em> </strong></figcaption></figure><p id="25af" class="pw-post-body-paragraph jd je hi jf b jg km ji jj jk kn jm jn jo ko jq jr js kp ju jv jw kq jy jz ka hb bi translated">结果将由路径组成。每条路径将一个<em class="ks">源</em>连接到一个<em class="ks">接收器</em>。换句话说，对潜在敏感的函数参数或属性赋值的一些输入。我不会深入讨论漏洞本身的细节，因为这超出了本文的范围。我只是用这个例子来证明人们可以通过简单地使用codeQL的内置查询来发现广泛使用的开源项目中的真实漏洞。</p><h1 id="ecf0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">LGTM</h1><p id="a132" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">根据GitHub，LGTM是:</p><blockquote class="lb lc ld"><p id="76b8" class="jd je ks jf b jg km ji jj jk kn jm jn le ko jq jr lf kp ju jv lg kq jy jz ka hb bi translated">一个代码分析平台，用于发现零日和防止关键漏洞</p></blockquote><p id="1e54" class="pw-post-body-paragraph jd je hi jf b jg km ji jj jk kn jm jn jo ko jq jr js kp ju jv jw kq jy jz ka hb bi translated">LGTM不仅允许你查询GitHub上托管的许多项目，而且它还使用CodeQL的官方查询不断评估它们。任何想看的人都可以得到结果。事实上，我在Discourse项目中发现的漏洞在LGTM也可以被任何有兴趣分析警报的人利用。</p><p id="571a" class="pw-post-body-paragraph jd je hi jf b jg km ji jj jk kn jm jn jo ko jq jr js kp ju jv jw kq jy jz ka hb bi translated">对于那些对该平台及其所能提供的感兴趣的人来说，一个很好的起点是分析故意易受攻击的web应用程序<a class="ae kr" href="https://lgtm.com/projects/g/bkimminich/juice-shop?mode=list&amp;severity=error" rel="noopener ugc nofollow" target="_blank"> <em class="ks">果汁店</em> </a> <em class="ks">的结果。</em></p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lh"><img src="../Images/c02ea4f5891433de6e0ad2a6293f3776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m-bsjTh_IT6Jv9mrpRIYEQ.png"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx translated">LGTM结果</figcaption></figure><h1 id="3975" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">更进一步</h1><p id="50dd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在发现话语漏洞后，我对CodeQL的潜力感到非常兴奋，并开始尝试构建我自己的易受攻击的代码，并针对它测试内置查询。玩了一会儿之后，我使用剪贴板API作为恶意的<em class="ks">源</em>构建了一些基于DOM的XSS测试用例。对于那些不熟悉剪贴板API及其安全含义的人，我建议阅读<a class="ae kr" href="https://research.securitum.com/the-curious-case-of-copy-paste/" rel="noopener ugc nofollow" target="_blank">复制和粘贴的奇怪案例</a>micha Bentkowski先生的一篇文章 ( <a class="ae kr" href="https://twitter.com/SecurityMB" rel="noopener ugc nofollow" target="_blank"> @SecurityMB </a>)。令我惊讶的是，没有一个内置查询能够检测到哪怕是最简单的基于剪贴板的XSS。然后，我决定构建自己的查询来寻找这种错误。最后，经过几个晚上的糟糕睡眠，我开始思考CodeQL的Javascript类型和类型跟踪谓词，然后<em class="ks">voilà</em>,<em class="ks">clipboard XSS . QL</em>查询诞生了。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="kg kh l"/></div><figcaption class="ki kj et er es kk kl bd b be z dx translated">剪贴板Xss.ql</figcaption></figure><p id="95db" class="pw-post-body-paragraph jd je hi jf b jg km ji jj jk kn jm jn jo ko jq jr js kp ju jv jw kq jy jz ka hb bi translated">完成后，我开始查询所有我最喜欢的开源项目，这些项目在LGTM都有。我能够在<a class="ae kr" href="https://hackerone.com/reports/1196958" rel="noopener ugc nofollow" target="_blank"> GitLab </a>和<a class="ae kr" href="https://github.com/github/paste-markdown/security/advisories/GHSA-gpfj-4j6g-c4w9" rel="noopener ugc nofollow" target="_blank"> Github的一个依赖项</a>中找到bug。目前都有可用的补丁。<br/>一旦我的查询得到了真实的结果，我决定尝试为CodeQL项目本身做点贡献。在撰写本文时，我的查询<a class="ae kr" href="https://github.com/github/securitylab/issues/422" rel="noopener ugc nofollow" target="_blank">仍在审核中</a>，但我相信它会被接受，并且最终剪贴板API源代码会被合并到标准的XSS查询中。</p><h1 id="c2b3" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">解决闭源网络应用</h1><p id="b706" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">CodeQL非常适合开源项目，尤其是已经在GitHub上的项目。但是用它来评估闭源web应用程序呢？<br/>我开发了一种手动方法，包括以下步骤:</p><ul class=""><li id="0cb5" class="li lj hi jf b jg km jk kn jo lk js ll jw lm ka ln lo lp lq bi translated">安装<a class="ae kr" href="https://chrome.google.com/webstore/detail/save-all-resources/abpdnfjocnmdomablahdcfnoggeeiedb" rel="noopener ugc nofollow" target="_blank"> <em class="ks">保存所有资源</em> </a> Chrome扩展(不涉及版税)</li><li id="cec8" class="li lj hi jf b jg lr jk ls jo lt js lu jw lv ka ln lo lp lq bi translated">启用扩展后，使用Chrome导航到web应用程序</li><li id="eec3" class="li lj hi jf b jg lr jk ls jo lt js lu jw lv ka ln lo lp lq bi translated">使用扩展下载页面的资源。确保选择下面突出显示的选项</li></ul><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lw"><img src="../Images/70d5905c5856076051898eb215b956fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77-8AuZkZ5lbxEy3kmNL9Q.png"/></div></div></figure><ul class=""><li id="0758" class="li lj hi jf b jg km jk kn jo lk js ll jw lm ka ln lo lp lq bi translated">将zip文件解压到您选择的目录中，并<a class="ae kr" href="https://codeql.github.com/docs/codeql-cli/creating-codeql-databases/" rel="noopener ugc nofollow" target="_blank">从中创建一个codeQL数据库</a></li><li id="0316" class="li lj hi jf b jg lr jk ls jo lt js lu jw lv ka ln lo lp lq bi translated">享受查询项目的乐趣</li></ul><h1 id="51db" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">未来的工作</h1><p id="df28" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我很想用CodeQL自动化我的评估闭源web应用的过程，并使它可扩展，但是我现在没有时间。我希望这篇文章能激励自动化僧侣们(例如，<a class="lx ly ge" href="https://medium.com/u/6dadd1681332?source=post_page-----57f70763b938--------------------------------" rel="noopener" target="_blank"> TomNomNom </a>，<a class="lx ly ge" href="https://medium.com/u/1dfc5adea2d4?source=post_page-----57f70763b938--------------------------------" rel="noopener" target="_blank"> Jason Haddix </a>)去实现它，并且当他们实现时记得告诉我；)</p></div></div>    
</body>
</html>