<html>
<head>
<title>What a Neural Network is?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是神经网络？</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-is-a-neural-network-6b6a552f8e19?source=collection_archive---------11-----------------------#2021-07-14">https://medium.com/codex/what-is-a-neural-network-6b6a552f8e19?source=collection_archive---------11-----------------------#2021-07-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="d099" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="7f04" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">大家好，今天我想解释什么是神经网络，主要原因是因为许多人听说过神经网络，但不知道什么是神经网络，它如何工作和他的目的。这是一个为那些对NN概念有疑问的人工智能领域的新手而写的故事。</p><p id="c3fe" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">神经网络是一种结构，它试图模拟神经元的生物结构及其目的，获取关于刺激的信息(在NN情况下获取数据)，通过其他神经元传递该信息，并对该刺激生成适当的答案。</p><p id="553d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">人类需要数据和经验来学习，神经网络如何学习？容易，神经网络也需要数据和经验来学习，但这个概念将在以后的培训部分解释。</p><h1 id="ae55" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">感知器。</h1><p id="a4ec" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在我们深入研究什么是神经网络以及它是如何工作的之前，我们应该知道感知器的概念。感知器是神经网络中的基本单元，我们可以将其与其他感知器结合来构建一个大的神经网络。NN与大脑结构有许多相似之处，我们知道，我们大脑的基本单位有一个叫神经元的基本单位，他的组合创造了一个生物神经网络。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/fb34247e92659d8313c67f60e485ea02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VH8N52icH2bun4wKbHTLNg.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">感知器</figcaption></figure><p id="65a0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">正如我们看到的，感知器有许多部分:</p><ul class=""><li id="75ec" class="kw kx hi jf b jg kb jk kc jo ky js kz jw la ka lb lc ld le bi translated">输入:向输出节点提供数据。</li><li id="22b1" class="kw kx hi jf b jg lf jk lg jo lh js li jw lj ka lb lc ld le bi translated">权重:决定了输入对最终结果的影响，如果输入的权重很高，那么他对最终结果的影响也会很大。最初，神经网络不知道权重的适当值，因此，默认情况下，权重是随机初始化的(我们可以修改这一点)。</li><li id="6b55" class="kw kx hi jf b jg lf jk lg jo lh js li jw lj ka lb lc ld le bi translated">输出:使用数学函数来确定最终结果。</li></ul><p id="7dbe" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">例如:假设我们想训练一个神经网络来确定一个人是否健康，而我们只有两个变量，性别和这个人是否从事任何运动(输入)。一旦我们有了这些值，我们就把它传递给输出节点，输出节点进行必要的计算以确定这个人是否健康。当我们向输出节点输入这两个变量时，权重应该被修改，因为性别不应该影响最终结果(在这种情况下)。</p><blockquote class="lk ll lm"><p id="91b4" class="jd je ln jf b jg kb ji jj jk kc jm jn lo kd jq jr lp ke ju jv lq kf jy jz ka hb bi translated">注意:权重的修改是通过一个名为“反向传播”的算法实现的。这是一个先进的概念，但我会在本文的训练神经网络部分尝试以简单的方式进行解释，但如果你想了解更多关于这种算法的信息，我建议你阅读一些关于深度学习的书籍，并观看一些关于这种算法的YouTube视频。</p></blockquote><h1 id="a204" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">神经网络。</h1><p id="e7d6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">既然知道了什么是percptron以及它是如何工作的，我们就可以知道什么是NN了。神经网络是一组完全相连的感知器，它们一起工作以实现一个共同的目标。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lr"><img src="../Images/e21cdb50384cddef54c9ba18f995533b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKvwi-CoYxgvo4mcUUf8TQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">神经网络。</figcaption></figure><p id="a609" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">正如我们所看到的，神经网络是它们之间完全连接的感知器，有三个主要部分。</p><ul class=""><li id="a5e8" class="kw kx hi jf b jg kb jk kc jo ky js kz jw la ka lb lc ld le bi translated">输入图层:我们从中获取输入的图层，我们的数据集中的每个要素都有一个输入。</li><li id="c62b" class="kw kx hi jf b jg lf jk lg jo lh js li jw lj ka lb lc ld le bi translated">隐藏层:其主要目的是将权重应用于输入，并将其传播到下一层，该层可能是其他隐藏层或输出层。关于神经网络应该包含的隐层数和节点数没有规则，我们应该根据我们的训练结果来修改它。</li></ul><blockquote class="lk ll lm"><p id="29ca" class="jd je ln jf b jg kb ji jj jk kc jm jn lo kd jq jr lp ke ju jv lq kf jy jz ka hb bi translated">注意:如果一个值足够高，那么这个值将被传播到下一层，否则，这个值将不会被传播。这可能导致“死”节点，这意味着对最终结果没有贡献的节点，因为他的值非常接近于零。如果我们有太多的死节点，神经网络就不会学习。</p></blockquote><ul class=""><li id="5846" class="kw kx hi jf b jg kb jk kc jo ky js kz jw la ka lb lc ld le bi translated">输出层:根据上一层的输出产生输出。如果我们面对二元分类问题，我们将有一个节点，但是在多类分类问题中，我们对每个类都有一个节点。例如:如果我们想确定一个人是否健康，我们有一个节点，但如果我们必须确定一个人是否患有某种疾病，我们将为每种疾病提供一个节点。</li></ul><h1 id="6bb5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">建立和训练神经网络。</h1><p id="344a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">恭喜你，你已经知道什么是神经网络和他的目的，但坏消息是你不知道如何建立它和如何训练它，但不要担心，我会尝试用一种简单的方式向你展示你如何做到这一点。这部分只是给对如何编写神经网络感兴趣的人看的，因此我假设你知道一些python编程的概念，也知道一些机器学习的概念。</p><p id="4a0f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">利用python中的一个库来构建神经网络最简单的方法，这个库就是tensorflow。要使用这个库，我们应该在开始之前做一些导入。</p><pre class="kh ki kj kk fd ls lt lu lv aw lw bi"><span id="52fb" class="lx ig hi lt b fi ly lz l ma mb">from tensorflow.keras.datasets import fashion_mnist<br/>from tensorflow.keras import layers, Sequential<br/>from tensorflow.keras.layers import Dense, Dropout<br/>from tensorflow import keras<br/>import tensorflow as tf</span></pre><p id="70dd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在下一个例子中，我们将使用fashion_mnist数据集来训练我们的模型，这是一个多类分类问题。数据集包含图像，我们将尝试预测服装的类型。</p><p id="1bfb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们需要四套不同的设备，一套用于训练，一套用于测试。x的集合包含“我们将提取特征”中的图像，y的测试包含标签(即服装名称)。</p><pre class="kh ki kj kk fd ls lt lu lv aw lw bi"><span id="367c" class="lx ig hi lt b fi ly lz l ma mb">(x_train, y_train), (x_test, y_test) = fashion_mnist.load_data()</span></pre><p id="6b62" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在我们有了数据，是时候开始构建神经网络了，第一步是创建一些将来会用到的变量。</p><pre class="kh ki kj kk fd ls lt lu lv aw lw bi"><span id="5d4c" class="lx ig hi lt b fi ly lz l ma mb">batch_size = 64<br/>num_classes = 10<br/>epochs = 300</span></pre><ul class=""><li id="634b" class="kw kx hi jf b jg kb jk kc jo ky js kz jw la ka lb lc ld le bi translated">batch_size:将在神经网络的每次迭代中使用的样本数。在第一次迭代中，我们将使用64个样本，在下一次迭代中，我们将使用其他64个样本(随机)。通常我们用2的幂。</li><li id="7d66" class="kw kx hi jf b jg lf jk lg jo lh js li jw lj ka lb lc ld le bi translated">num_classes:数据集中不同类的数量。</li><li id="093a" class="kw kx hi jf b jg lf jk lg jo lh js li jw lj ka lb lc ld le bi translated">次数:迭代的次数，或者同样的，在认为我们的神经网络训练良好之前，我们将通过神经网络多少次。这个值是一个超参数，我们应该根据我们的结果来调整历元的数量。</li></ul><blockquote class="lk ll lm"><p id="bba6" class="jd je ln jf b jg kb ji jj jk kc jm jn lo kd jq jr lp ke ju jv lq kf jy jz ka hb bi translated">注意:下一个代码是使NN正常工作所必需的，但是对他的功能的解释超出了这个故事的范围。</p></blockquote><pre class="kh ki kj kk fd ls lt lu lv aw lw bi"><span id="4c2c" class="lx ig hi lt b fi ly lz l ma mb"># One-hot encoding of y<br/>y_train = keras.utils.to_categorical(y_train, num_classes)<br/>y_test = keras.utils.to_categorical(y_test, num_classes)</span><span id="b9d2" class="lx ig hi lt b fi mc lz l ma mb"># One array<br/>x_train = x_train.reshape(60000, 784)<br/>x_test = x_test.reshape(10000, 784)<br/>x_train = x_train.astype('float32')<br/>x_test = x_test.astype('float32')</span></pre><p id="4048" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在是建立神经网络的时候了，为此我们将使用下一个代码:</p><pre class="kh ki kj kk fd ls lt lu lv aw lw bi"><span id="05ff" class="lx ig hi lt b fi ly lz l ma mb">#Building the model<br/>model = Sequential()<br/>model.add(Dense(128, activation='sigmoid', input_shape=(784,)))<br/>model.add(Dense(128, activation='sigmoid'))<br/>model.add(Dense(64, activation='sigmoid'))<br/>model.add(Dense(num_classes, activation='softmax'))<br/>model.summary()</span></pre><p id="3eb2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们正在利用一个序列模型，这意味着我们建立了一个多层的神经网络。</p><p id="c5e4" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">用方法。add(Dense())我们添加一个密集层，密集层是他的节点之间全连通的一个层，但是这个层包含了多少个节点呢？Dense()函数中的第一个数字决定了节点的数量。正如我们看到的，第一层包含一个名为“input_shape”的参数。这是包含输入层的节点数，因为我们正在构建隐藏层和输出层，但对于构建输入层，只需指定第一个隐藏层中的input_shape参数和他的大小(在我们的例子中为784)。参数“激活”允许我们选择数学公式来确定如何将权重的总和转换为输出。我们可以在每一层中使用不同的激活函数，或者根据我们的目的或问题的类型选择一个激活函数。</p><p id="0e2e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">您可以看到最后一层有变量“num_clases”作为节点数，这是因为这一层是输出层，您知道在这一层中，我们为每个要预测的类提供一个节点。这一层中的激活函数是不同的，因为“softmax”函数对于多类问题工作得很好。</p><p id="7061" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">现在是配置模型的时候了，我们将使用编译功能来完成。</p><pre class="kh ki kj kk fd ls lt lu lv aw lw bi"><span id="5a5e" class="lx ig hi lt b fi ly lz l ma mb">from tensorflow.keras.optimizers import SGD</span><span id="1814" class="lx ig hi lt b fi mc lz l ma mb">#Compile the model<br/>model.compile(loss='categorical_crossentropy',<br/>optimizer='sgd',<br/>metrics=['accuracy'])</span></pre><ul class=""><li id="84a7" class="kw kx hi jf b jg kb jk kc jo ky js kz jw la ka lb lc ld le bi translated">损失:该参数允许我们选择损失函数。损失函数计算实际值和预测值之间的差异(该值称为误差值)，并试图最小化该误差值以获得精确的模型。这个误差将沿着神经网络传播，当输出层生成结果时，我们将把它与期望的结果进行比较，然后神经网络为每个输出节点生成误差值。基于这些误差，神经网络将这些值传播到前一层，并根据这些误差修改权重以获得更好的结果，这就是反向传播的概念。在我们的例子中，我们使用了“分类交叉熵”函数，因为它是处理多类问题的最佳函数。</li><li id="c396" class="kw kx hi jf b jg lf jk lg jo lh js li jw lj ka lb lc ld le bi translated">优化器:确定修改权重的方式。</li><li id="6b05" class="kw kx hi jf b jg lf jk lg jo lh js li jw lj ka lb lc ld le bi translated">度量:我们评估模型性能的方式。</li></ul><p id="5a9d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">最后，是时候训练模型并观察结果了。我们将使用fit函数从NN训练开始。</p><pre class="kh ki kj kk fd ls lt lu lv aw lw bi"><span id="a68b" class="lx ig hi lt b fi ly lz l ma mb">history_sigmoid = model.fit(x_train, y_train, <br/>batch_size = batch_size, epochs=epochs, verbose=1, <br/>validation_split = 0.2)</span></pre><p id="eeee" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们使用训练集来训练带有他的标签(保存在y_train中)的模型。“verbose”参数用于显示我们的NN的训练进度,“validation_split”用于选择验证模型所需的百分比，在我们的示例中，我们使用x_train中的20%样本进行验证。命令输出将类似于以下内容:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es md"><img src="../Images/3f7a97434ac347346467e090b57612c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-54AUjew1vNdN5jcY_RQpw.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">安装输出。</figcaption></figure><p id="e390" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">正如我们所见，损耗逐步降低，精度不断提高。在训练结束时，精度应该接近1，损耗应该接近0。</p><h1 id="e8f1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">评估模型。</h1><p id="4c94" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">嗯，你知道如何训练神经网络，但你不知道网络是否工作良好，或者是否能以正确的方式预测结果。</p><p id="ce7a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">评估我们的神经网络性能的一个简单方法是使用混淆矩阵。这个矩阵向我们展示了多少预测是正确的，多少预测是错误的。</p><p id="5316" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">下面是执行此操作的代码:</p><pre class="kh ki kj kk fd ls lt lu lv aw lw bi"><span id="623b" class="lx ig hi lt b fi ly lz l ma mb">pred = model.predict(x_test) #Our predictions</span><span id="81c8" class="lx ig hi lt b fi mc lz l ma mb">from sklearn.metrics import confusion_matrix<br/>confusion_matrix(y_test.argmax(axis=1), pred.argmax(axis=1))</span></pre><p id="cd26" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">结果会是这样的:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es me"><img src="../Images/f873f276599c348a68fa6ea8d5acce01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*-IK8vtxi9YZRNzfyxi4UcQ.png"/></div></figure><p id="d017" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">根据要预测的类的数量，我们将有许多行和列。第一行属于第一个标签，第一列也属于第一个标签，依此类推。预测正确的值是对角线上的值，对角线外的值是预测错误的值。</p><h1 id="3a9c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="4c3b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这篇文章中，我试图以一种简单易懂的方式解释什么是神经网络以及它是如何工作的，这只是对这种算法的一个温和的介绍，如果你想了解更多关于这个人工智能的迷人领域，你应该开始阅读书籍，参加课程，阅读其他文章，写下你自己的结论，等等。我希望我已经帮助你多了解了一点神经网络。感谢您的阅读。</p></div></div>    
</body>
</html>