<html>
<head>
<title>Learning to love Tailwind</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学会爱上顺风</h1>
<blockquote>原文：<a href="https://medium.com/codex/learning-to-love-tailwind-85e36716c61b?source=collection_archive---------20-----------------------#2021-08-02">https://medium.com/codex/learning-to-love-tailwind-85e36716c61b?source=collection_archive---------20-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/06a4ce291cc6163c19ff73d628a667b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*LqWjA3RQ_D_56O_Ov0YZ_Q.jpeg"/></div></figure><div class=""/><p id="4be1" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">近年来，一些人称之为实用优先的CSS框架逐渐兴起:通过将单一用途的类直接组合到HTML中，对CSS采取原子方法。很容易理解为什么这种格式会流行起来:当您不需要编写自定义CSS时，您可以更快地构建布局，并且不需要每次进行更改时都重新构建文件。效用优先的框架也可以被配置成遵循一个严格的设计系统，当你构建一个遵循相同设计系统的设计时，这感觉很好——设计者经常使用一致的空间和宽度度量，所以你的CSS与他们的视觉保持一致感觉很好。</p><p id="b802" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一个流行的框架已经上升到主导地位，许多机构和软件公司利用它提供的快速原型制作能力。它被称为Tailwind，看起来它可能会成为未来前端开发领域的主要参与者。</p><h1 id="cb37" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">那么问题出在哪里？</h1><p id="7ecf" class="pw-post-body-paragraph im in hp io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">顺风CSS往往是开发人员之间的一个非常分裂的话题:有点像Marmite，你要么喜欢它，要么讨厌它。我认为这是一个奇耻大辱，因为大多数反对它的论点都可以通过改变心态来解决。重要的是要记住，就像生活中的任何事情一样，你应该总是为工作选择正确的工具。我不会坐着假装顺风解决一切:它只在正确的情况下有用。</p><p id="e1f2" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">问题是，Tailwind和其他实用优先的框架根本不像传统的CSS。如果你看看我们都非常熟悉的方法论，比如BEM，在风格的真理来源上有很大的不同。</p><h1 id="8c77" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">真相的新来源</h1><p id="8dc1" class="pw-post-body-paragraph im in hp io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">使用像BEM这样的方法，重点是在HTML、CSS和JavaScript之间保持关注点的分离。当谈到样式时，CSS通常被认为是事实的来源，而HTML应该只关注内容。这对于像Wordpress或静态HTML站点这样的单一站点来说非常有效，在这些站点中，您可能会编写重复出现的HTML。例如，这里有一个简单的<a class="ae ko" href="http://www.stubbornella.org/content/2010/06/25/the-media-object-saves-hundreds-of-lines-of-code/" rel="noopener ugc nofollow" target="_blank">媒体对象</a>结构:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="265c" class="ky jl hp ku b fi kz la l lb lc">&lt;div class="media-object"&gt;<br/>  &lt;div class="media-object__media"&gt;<br/>    &lt;img src="avatar.jpg" /&gt;<br/>  &lt;/div&gt;<br/>  &lt;div class="media-object__content"&gt;<br/>    Hello world! Here's some content.<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span><span id="9e74" class="ky jl hp ku b fi ld la l lb lc">$module: 'media-object';</span><span id="3c55" class="ky jl hp ku b fi ld la l lb lc">.#{$module} {<br/>  display: flex;<br/>  flex-direction: row;<br/>  <br/>  &amp;__media {<br/>    flex-basis: 48px;<br/>  }<br/>  <br/>  &amp;__content {<br/>    flex: 1 0 auto;<br/>  }<br/>}</span></pre><p id="62a1" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个对象的HTML可以无限复制和粘贴，就像构建一个基本的HTML页面一样。由于CSS存储在它的真实来源中，只要结构保持不变，如果我们重复HTML就没有太大关系。以这种方式复制和粘贴并不完美，也不总是感觉正确，但是通过这种方式工作，我们可以保持样式相当一致，即使它后来发生了变化。如果我们稍后通过添加填充来改变<code class="du le lf lg ku b">.media-object</code>，那么这个改变将会在使用这个类的任何地方被反映出来。当转向顺风时，这就是混乱的开始。</p><p id="6794" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">问题是，许多开发人员将转向Tailwind，并以与他们使用BEM完全相同的方式使用它:在任何需要的地方复制粘贴HTML结构。由于Tailwind使用类组合来创建样式，您的真实来源不再是CSS文件。HTML本身成为其外观的真实来源。下面是使用Tailwind的实用程序类构建的相同组件:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="7c32" class="ky jl hp ku b fi kz la l lb lc">&lt;div class="flex flex-row"&gt;<br/>  &lt;div class="w-7"&gt;<br/>    &lt;img src="avatar.jpg" /&gt;<br/>  &lt;/div&gt;<br/>  &lt;div class="flex-grow w-auto"&gt;<br/>    Hello world! Here's some content.<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="56d9" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">想象一下，我们把这个媒体对象复制粘贴到整个网站上；如果我们想在顶部元素中添加填充，我们必须遍历整个站点，手动将填充类添加到每个实例中。当然，您可以使用查找和替换工具来帮助，但是如果您不小心的话，这种技术可能会导致错误，并且随着站点的增长会变得难以管理。</p><p id="1a16" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这就是为什么如果你没有使用基于组件的框架，我不会推荐Tailwind。这就是为什么这么多人开始讨厌顺风:因为他们在工作中使用了错误的工具，而且这对他们不利。它只是不是为传统意义上的使用而设计的。</p><h1 id="8082" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">基于组件的体系结构</h1><p id="b2a6" class="pw-post-body-paragraph im in hp io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">Tailwind真正大放异彩的地方是在现代框架中:无论是React和Vue这样的JavaScript框架，还是Twig这样的模板系统，这种CSS方法在与基于组件的<em class="kn">架构相结合时都会蓬勃发展。</em></p><p id="698b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这样的系统中，风格的真实来源可以与网站的结构融合在一起。在这些系统中，鼓励开发人员构建可重用、可组合的组件。例如，下面是使用React构建的同一个媒体对象:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="3415" class="ky jl hp ku b fi kz la l lb lc">// MediaObject.js<br/>export default function MediaObject({ children, img}) {<br/>  return (<br/>    &lt;div class="flex flex-row"&gt;<br/>      &lt;div class="w-7"&gt;<br/>        &lt;img src={ img } /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div class="flex-grow w-auto"&gt;<br/>        { children }<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="17c8" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个文件<code class="du le lf lg ku b">MediaObject.js</code>现在是组件的外观和感觉的绝对真实来源:没有任何CSS文件被依赖，没有任何HTML需要被复制粘贴无数次。所有的东西都在这个文件里。</p><p id="b53b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如您所看到的，这个组件并不关心它包含的内容:媒体和文本内容都是在任何地方使用组件时传递下来的道具。下面是一个页面如何调用<code class="du le lf lg ku b">MediaObject</code>的例子:</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="a76f" class="ky jl hp ku b fi kz la l lb lc">&lt;MediaObject media="avatar.jpg"&gt;<br/>  &lt;h3&gt;Person Personson&lt;/h3&gt;<br/>  &lt;p&gt;Hello world!&lt;/p&gt;<br/>&lt;/MediaObject&gt;</span></pre><p id="b657" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">"但是修饰语呢？"，我听到你问。好吧，基于组件的框架也可以很容易地处理这个问题，并且在处理的时候做更酷的事情。</p><p id="0e12" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">例如，假设我们也有一个暗灰色背景的媒体对象的暗变体。不仅背景颜色需要改变，里面的文字颜色也需要改变，以与较暗的背景相协调。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="c1f0" class="ky jl hp ku b fi kz la l lb lc">export default function MediaObject({ children, img, modifiers }) {<br/>  const bgC = modifiers.isDarkBG ? 'bg-dark-grey' : 'bg-transparent';<br/>  const textC = modifiers.isDarkBG ? 'text-white' : 'text-dark-grey';<br/>  <br/>  return (<br/>    &lt;div class={`flex flex-row ${ bgC }`}&gt;<br/>      &lt;div class="w-7"&gt;<br/>        &lt;img src={ img }<br/>      &lt;/div&gt;<br/>      &lt;div class={`flex-grow w-auto ${ textC }`}&gt;<br/>        { children }<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="7359" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们可以使用普通的JavaScript来控制使用“modifiers”对象的感觉，这为我们提供了更强大的工具来构建条件样式。有太多的方法来使用它，一旦你习惯了这种工作方式，它就会变得非常自然和直观。您可以在组件本身内部定义条件，或者直接传递一串类名来进行额外的控制。</p><p id="a60a" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">建议在构建组件时利用抽象:您可以将不同级别的逻辑移动到同一个组件的不同文件中。React中最好的例子是<a class="ae ko" rel="noopener" href="/@yassimortensen/container-vs-presentational-components-in-react-8eea956e1cea">容器组件与表示组件。</a></p><h1 id="71f2" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">抽象业务逻辑以保持整洁</h1><p id="fa8f" class="pw-post-body-paragraph im in hp io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">通过将组件的视图(它看起来的样子)包装在存储业务逻辑(它工作的方式)的容器中，您可以将不同的关注点隔离到不同的文件中。我经常使用一个文件夹结构，其中文件夹名是组件名，有两个文件，<code class="du le lf lg ku b">index.js</code>和<code class="du le lf lg ku b">View.js</code>。<code class="du le lf lg ku b">index.js</code>是容器组件，而<code class="du le lf lg ku b">View.js</code>是表示组件。</p><figure class="kp kq kr ks fd hk er es paragraph-image"><div class="er es lh"><img src="../Images/4268f70c841c7c309edca31ecd712519.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/0*9QADvsO7-rGOq5K5"/></div></figure><p id="b446" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通过将我所有的表示逻辑保存在<code class="du le lf lg ku b">View.js</code>中，包括任何基于<code class="du le lf lg ku b">modifier</code>道具的条件样式，我可以确保任何与组件样式无关的逻辑都保存在容器组件<code class="du le lf lg ku b">index.js</code>中。这真的有助于保持整洁和理智，因为每样东西都有一个合理的去处。</p><pre class="kp kq kr ks fd kt ku kv kw aw kx bi"><span id="69e6" class="ky jl hp ku b fi kz la l lb lc">// View.js<br/>export default function MediaObjectView({ children, img, modifiers }) {<br/>  const bgC = modifiers.isDarkBG ? 'bg-dark-grey' : 'bg-transparent';<br/>  const textC = modifiers.isDarkBG ? 'text-white' : 'text-dark-grey';<br/>  <br/>  return (<br/>    &lt;div class={`flex flex-row ${ bgC }`}&gt;<br/>      &lt;div class="w-7"&gt;<br/>        &lt;img src={ img }<br/>      &lt;/div&gt;<br/>      &lt;div class={`flex-grow w-auto ${ textC }`}&gt;<br/>        { children }<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="890e" class="ky jl hp ku b fi ld la l lb lc">// index.js<br/>export default function MediaObject({ children, img, modifiers }) {<br/>  // any business logic can go here and be passed to MediaObjectView using props<br/>  <br/>  return &lt;MediaObjectView {...children, img, modifiers} /&gt;<br/>}</span></pre><p id="9086" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">理论上，你可以继续抽象组件，次数不限。通常建议坚持最大值为2，但我确信在某些情况下，进一步分离逻辑会有好处。</p><h1 id="3f58" class="jk jl hp bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">顺风适合我吗？</h1><p id="d800" class="pw-post-body-paragraph im in hp io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">嗯，也许吧。如果您正在构建静态HTML站点，可能不会。如果你正在用PHP构建Wordpress站点，你最好使用某种模板引擎来维护你的真实来源。但是，如果您正在使用React或Vue这样的现代JavaScript框架，我强烈建议您尝试一下:它非常不同，并且有自己的挑战，但是如果使用方法正确，它会非常有趣并且非常强大。只是不要期望能够使用你在BEM中学到的相同概念——这是一个完全不同的盒子。</p><p id="5f00" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在<a class="ae ko" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank">官方网站</a>上了解更多关于Tailwind的信息，<a class="ae ko" href="https://www.youtube.com/watch?v=J_7_mnFSLDg" rel="noopener ugc nofollow" target="_blank">观看这个精彩的演示</a>了解更多关于如何使用Tailwind代替传统CSS的细节。</p></div></div>    
</body>
</html>