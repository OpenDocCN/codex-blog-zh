<html>
<head>
<title>Data Structures &amp; Algorithms: How to Perform Minimum Queries in Constant Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构和算法:如何在恒定时间内执行最小查询</h1>
<blockquote>原文：<a href="https://medium.com/codex/data-structure-algorithms-how-to-perform-minimum-queries-in-constant-time-73e59cdca19a?source=collection_archive---------15-----------------------#2021-08-30">https://medium.com/codex/data-structure-algorithms-how-to-perform-minimum-queries-in-constant-time-73e59cdca19a?source=collection_archive---------15-----------------------#2021-08-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0e164d66035105f2dd5d7a19d9ef62fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VEX6rXH546hRPo0g"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">马里奥·卡尔沃在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2226" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇短文描述了稀疏表方法。它能够在给定阵列的子阵列上有效地执行许多最小查询(或最大查询)，即找到子阵列的最小值(或最大值)。</p><p id="c75c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们只有少量的查询要执行，我们可以采用一种简单的方法，遍历我们考虑的所有子数组。然而，如果我们有许多查询要做，这种方法将会非常慢。</p><p id="a7f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将从在线性时间内预处理输入数组开始。这个预处理步骤产生一个辅助数组，我们将使用它来计算任何子数组在常数时间内的最小值。</p><p id="f964" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将使用字母<em class="jt"> A </em>来表示输入数组，使用<em class="jt"> N </em>来表示它包含的元素数量。索引从1开始。</p><h1 id="ca78" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">预处理</h1><p id="75a7" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">预处理步骤计算长度为2的幂的每个子数组的最小值。</p><p id="9243" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用动态规划来计算θ(N log N)时间和空间中的预计算值。</p><p id="295d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将预先计算的结果存储在一个二维数组中，表示为<em class="jt"> SpTa </em>(用于稀疏表)。对于所有有意义的索引<em class="jt"> i </em>，<em class="jt"> j </em>，<em class="jt"> SpTa </em> (i，j)将对应于从索引<em class="jt"> i </em>开始并且正好包含2^j元素的子数组的最小值:<em class="jt"> A </em> [ <em class="jt"> i </em>..<em class="jt">我</em> + 2^j - 1】。<em class="jt"> i </em>可以是<em class="jt"> A </em>的任意一个指数(即在1和<em class="jt"> N </em>之间)并且<em class="jt"> j </em>必须满足2^j ≤ <em class="jt"> N </em>，所以<em class="jt"> j </em> ≤ log₂ <em class="jt"> N </em>。因此<em class="jt"> SpTa </em>的形状为<em class="jt"> N </em> × (⎣log₂ N⎦+ 1)。(“+ 1”是因为<em class="jt"> j </em>可以取值0。)</p><p id="84b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了填充这个数组，我们首先为<em class="jt"> A </em>的所有索引<em class="jt"> i </em>设置<em class="jt"> SpTa </em> (i，0)=<em class="jt">A</em>【I】。这是因为子阵<em class="jt">A</em><em class="jt">I</em>..<em class="jt"> i </em> + 2⁰ - 1】只包含<em class="jt"> A </em> [ <em class="jt"> i </em> ]，所以它的最小元素确实是<em class="jt"> A </em> [ <em class="jt"> i </em> ]。</p><p id="dcc0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最佳子结构来自简单的观察:两个子阵列的最小值之间的最小值是它们的并集的最小值。因此，<em class="jt">A</em><em class="jt">I</em>的最小值..<em class="jt"> i </em> + 2^j - 1】是<em class="jt"> m </em>和<em class="jt"> m' </em>之间的最小值，其中<em class="jt"> m </em>是<em class="jt"> A </em> [ <em class="jt"> i </em>的最小值..<em class="jt"> i </em> + 2^{j - 1} - 1]和<em class="jt"> m' </em>是<em class="jt">a</em>[<em class="jt">I</em>+2^{j-1]的最小值..<em class="jt">我</em> + 2^{ <em class="jt"> j </em> } - 1]:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/2f3c168cd31e1419c5829014fe177cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iGzMo01cH9gjukKGF68IEg.png"/></div></div></figure><p id="399c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代入先前计算并存储在<em class="jt"> SpTa </em>中的值，我们得到:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/8e03acd7443b2285119a9e4a2fb54802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UF2T_jAvEs_ghzlECi3AIA.png"/></div></div></figure><p id="60f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了实现上述方法，需要注意的是，<em class="jt"> SpTa </em> ( <em class="jt"> i </em>，<em class="jt"> j </em>)的计算依赖于<em class="jt"> i </em>较低，而<em class="jt"> j </em>较高的计算。因此，算法的外环对应于<em class="jt"> j </em>，内环对应于<em class="jt"> i </em>。</p><p id="5d61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面的伪代码定义了一个算法，该算法计算给定数组的稀疏表。</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/cf2ef0389a43f2e9ca5615622dc4f446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXEXiuevvEyFxjjxKj-1JQ.png"/></div></div></figure><p id="93f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述算法在θ(<em class="jt">N</em>log<em class="jt">N</em>)时间内运行。</p><h1 id="e81e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">计算子数组的最小值</h1><p id="ecb7" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">我们可以想到任何一个子数组<em class="jt"> A </em> [ <em class="jt"> i </em>..<em class="jt"> j </em>为两个子数组<em class="jt">U</em>:=<em class="jt">A</em>[<em class="jt">I</em>..<em class="jt"> i </em> + 2^ <em class="jt"> k </em> — 1】和<em class="jt">v</em>:= a[<em class="jt">j</em>—2^<em class="jt">k</em>+1..长度为2的幂的j。我们选择<em class="jt"> k </em>使得2^ <em class="jt"> k </em>是不超过<em class="jt"> A </em> [ <em class="jt"> i </em>长度的2的最大幂..<em class="jt"> j </em>:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/5816b6fd2e4f886b7a08472c4c5b049c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UqLiqkhpcKQSpOV4SpefUw.png"/></div></div></figure><p id="e4df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要证明一个[I]的所有值..j]属于两个子数组<em class="jt"> U </em>和<em class="jt"> V </em>中的一个。首先，我们观察到两个子数组具有相同的长度。假设有一个值<em class="jt"> A </em> [ <em class="jt"> p </em> ](其中<em class="jt">I</em>≤<em class="jt">p</em>≤<em class="jt">j</em>)不在<em class="jt"> U </em>或<em class="jt"> V </em>中。那么2 * 2^ <em class="jt"> k </em>严格小于a[I]的长度..j】。因此，存在一个大于2^k的2的幂，但仍不超过a[I]的长度..j】。</p><p id="176f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用这种方法，我们可以实现一个函数，该函数采用一个稀疏表和一个子数组的上下界，并在O(1)时间内返回该子数组的最小值:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/2a1453d6b7cc05e1b322cbd04a43ce4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HLYEPpidA3GEtvG2hF9YXw.png"/></div></div></figure><p id="908c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为2^k是不超过子阵列长度的2的最大幂。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="8cce" class="ju jv hi bd jw jx lk jz ka kb ll kd ke kf lm kh ki kj ln kl km kn lo kp kq kr bi translated">支持我</h1><p id="2f14" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">感谢阅读！我是数学和计算机科学的学生，写的文章涵盖了计算和编程的各个领域。如果你想在我发表新故事时收到邮件或者成为我的推荐会员，你可以点击这个链接来订阅:<a class="ae iu" rel="noopener" href="/subscribe/@alouizakarie">https://medium.com/subscribe/@alouizakarie</a>。</p></div></div>    
</body>
</html>