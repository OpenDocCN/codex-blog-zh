<html>
<head>
<title>Flutter Skill Of Interesting Animation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">趣味动画的飘动技巧</h1>
<blockquote>原文：<a href="https://medium.com/codex/flutter-skill-of-interesting-animation-d12325b3020d?source=collection_archive---------9-----------------------#2022-06-27">https://medium.com/codex/flutter-skill-of-interesting-animation-d12325b3020d?source=collection_archive---------9-----------------------#2022-06-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ec62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本章中，我们将分析颤振中的动画技巧。</p><p id="ac5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先我们来看下面的Gif。如果想达到以下动画切换效果，怎么考虑？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/4e3284f0ad0272a2b850aaa3dcc8ff9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/1*i8IuR4c0u-ThESPQd0YYoA.gif"/></div></figure><h1 id="aefa" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">动画</h1><p id="cf65" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">其实在颤振中实现类似的动画效果是很简单的。你甚至不需要定制布局。<br/>首先，我们需要使用<code class="du ko kp kq kr b">AnimatedPositioned</code>和<code class="du ko kp kq kr b">AnimatedContainer</code>:</p><ul class=""><li id="6acd" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated"><code class="du ko kp kq kr b">AnimatedPositioned</code>用于动画显示<code class="du ko kp kq kr b">Stack</code>中的位置</li><li id="665f" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><code class="du ko kp kq kr b">AnimatedContainer</code>用于制作尺寸变化的动画</li></ul><p id="c30b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们定义一个<code class="du ko kp kq kr b">PositionItem</code>，将<code class="du ko kp kq kr b">AnimatedPositioned</code>和<code class="du ko kp kq kr b">AnimatedContainer</code>嵌套在一起，并使用<code class="du ko kp kq kr b">PositionedItemData</code>来改变它们的位置和大小。</p><pre class="je jf jg jh fd lg kr lh li aw lj bi"><span id="9a03" class="lk jm hi kr b fi ll lm l ln lo">class PositionItem extends StatelessWidget {<br/>  final PositionedItemData data;<br/>  final Widget child;<br/><br/>  const PositionItem(this.data, {required this.child});<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return new AnimatedPositioned(<br/>      duration: Duration(seconds: 1),<br/>      curve: Curves.fastOutSlowIn,<br/>      child: new AnimatedContainer(<br/>        duration: Duration(seconds: 1),<br/>        curve: Curves.fastOutSlowIn,<br/>        width: data.width,<br/>        height: data.height,<br/>        child: child,<br/>      ),<br/>      left: data.left,<br/>      top: data.top,<br/>    );<br/>  }<br/>}<br/>class PositionedItemData {<br/>  final double left;<br/>  final double top;<br/>  final double width;<br/>  final double height;<br/><br/>  PositionedItemData({<br/>    required this.left,<br/>    required this.top,<br/>    required this.width,<br/>    required this.height,<br/>  });<br/>}</span></pre><p id="b413" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后我们只需要将<code class="du ko kp kq kr b">PositionItem</code>放在<code class="du ko kp kq kr b">Stack</code>下面，然后通过<code class="du ko kp kq kr b">LayoutBuilder</code>获取<code class="du ko kp kq kr b">parent</code>的大小，根据<code class="du ko kp kq kr b">PositionedItemData</code>调整<code class="du ko kp kq kr b">PositionItem</code>的位置和大小，就可以轻松实现初始的动画效果。</p><pre class="je jf jg jh fd lg kr lh li aw lj bi"><span id="d528" class="lk jm hi kr b fi ll lm l ln lo">child: LayoutBuilder(<br/>  builder: (_, con) {<br/>    var f = getIndexPosition(currentIndex % 3, con.biggest);<br/>    var s = getIndexPosition((currentIndex + 1) % 3, con.biggest);<br/>    var t = getIndexPosition((currentIndex + 2) % 3, con.biggest);<br/>    return Stack(<br/>      fit: StackFit.expand,<br/>      children: [<br/>        PositionItem(f,<br/>            child: InkWell(<br/>              onTap: () {<br/>                print("red");<br/>              },<br/>              child: Container(color: Colors.redAccent),<br/>            )),<br/>        PositionItem(s,<br/>            child: InkWell(<br/>              onTap: () {<br/>                print("green");<br/>              },<br/>              child: Container(color: Colors.greenAccent),<br/>            )),<br/>        PositionItem(t,<br/>            child: InkWell(<br/>              onTap: () {<br/>                print("yello");<br/>              },<br/>              child: Container(color: Colors.yellowAccent),<br/>            )),<br/>      ],<br/>    );<br/>  },<br/>),</span></pre><p id="4369" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如下图，您可以通过每次切换相应的索引来调整相应项目的大小和位置，从而触发<code class="du ko kp kq kr b">AnimatedPositioned</code>和<code class="du ko kp kq kr b">AnimatedContainer</code>产生动画效果，类似于初始动画的动画效果。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lp"><img src="../Images/8f23d13b43c1b1fc862a2feb59c65bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*IzcsG3n2WETSHS14ZBNdTw.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/84b0b0bac50ba75c45fa7df3d2f15a21.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/1*0FCByC8-FnkazK868P1KvA.gif"/></div></figure><blockquote class="lq lr ls"><p id="1b94" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated"><a class="ae lx" href="https://github.com/CarGuo/gsy_flutter_demo/blob/master/lib/widget/anim_switch_layout_demo_page.dart" rel="noopener ugc nofollow" target="_blank">https://github . com/CarGuo/gsy _ flutter _ demo/blob/master/lib/widget/anim _ switch _ layout _ demo _ page . dart</a></p></blockquote><p id="cdb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你对实现原理不感兴趣，这就是结局。你从上面学到了一点技巧:</p><blockquote class="lq lr ls"><p id="6669" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">改变<code class="du ko kp kq kr b"><strong class="ih hj">AnimatedPositioned</strong></code>和<strong class="ih hj"> </strong> <code class="du ko kp kq kr b"><strong class="ih hj">AnimatedContainer</strong></code>的任何参数，都可以使其产生动画效果。它们的参数与<code class="du ko kp kq kr b">Positioned</code>和<code class="du ko kp kq kr b">Container</code>完全相同，因此可以用来无缝替换<code class="du ko kp kq kr b">Positioned</code>和容器。只需要配置<code class="du ko kp kq kr b">duration</code>等附加参数即可。</p></blockquote><h1 id="b3d5" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">先进的</h1><p id="1e60" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated"><code class="du ko kp kq kr b">AnimatedPositioned</code>和<code class="du ko kp kq kr b">AnimatedContainer</code>是如何实现动画效果的？这里我们将介绍一个抽象的父类:<code class="du ko kp kq kr b">ImplicitlyAnimatedWidget</code>。</p><blockquote class="lq lr ls"><p id="c257" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">几乎所有以animated开头的小部件都继承自它。既然是用来做动画的，<code class="du ko kp kq kr b">ImplicitlyAnimatedWidget</code>一定是<code class="du ko kp kq kr b">StatefulWidget</code>。不出意外，它的实现逻辑主要在于<code class="du ko kp kq kr b">ImplicitlyAnimatedWidgetState</code>，我们后面会展开。</p></blockquote><p id="31cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们回顾一下在Flutter中使用动画的要求:</p><ul class=""><li id="c488" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated"><code class="du ko kp kq kr b">AnimationController</code>:用于控制动画的开始和暂停</li><li id="302a" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><code class="du ko kp kq kr b">TickerProvider</code>:用于创建<code class="du ko kp kq kr b">AnimationController</code>所需的Vsync参数。一般来说，<code class="du ko kp kq kr b">SingleTickerProviderStateMixin</code>是最常用的</li><li id="f83f" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><code class="du ko kp kq kr b">Animation</code>:用于处理动画的值，如<code class="du ko kp kq kr b">CurvedAnimation</code></li><li id="e2c4" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated">接收动画的对象:例如<code class="du ko kp kq kr b">FadeTransition</code></li></ul><p id="f805" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Flutter中的动画从ticker开始。当我们在状态下使用<code class="du ko kp kq kr b">with TickerProviderStateMixin</code>时，意味着我们有能力执行动画:</p><blockquote class="lq lr ls"><p id="223b" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">Flutter每画一帧，<code class="du ko kp kq kr b">Ticker</code>就会同步执行<code class="du ko kp kq kr b">AnimationController</code>中的<code class="du ko kp kq kr b">_tick</code>方法，然后执行<code class="du ko kp kq kr b">notifyListeners</code>改变<code class="du ko kp kq kr b">Animation</code>的值，从而触发状态的<code class="du ko kp kq kr b">setState</code>或者RenderObject的<code class="du ko kp kq kr b">markNeedsPaint</code>更新接口。</p></blockquote><p id="48be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，如下面的代码所示，而这部分代码是高度重复的。因此，对于这部分逻辑，官方提供了一个<strong class="ih hj"> </strong> <code class="du ko kp kq kr b">ImplicitlyAnimatedWidget</code>模板。</p><pre class="je jf jg jh fd lg kr lh li aw lj bi"><span id="bcbb" class="lk jm hi kr b fi ll lm l ln lo">class _AnimatedOpacityState extends State&lt;AnimatedOpacity&gt;<br/>    with TickerProviderStateMixin {<br/>  late final AnimationController _controller = AnimationController(<br/>    duration: const Duration(seconds: 2),<br/>    vsync: this,<br/>  )..repeat(reverse: true);<br/>  late final Animation&lt;double&gt; _animation = CurvedAnimation(<br/>    parent: _controller,<br/>    curve: Curves.easeIn,<br/>  );<br/><br/>  @override<br/>  void dispose() {<br/>    _controller.dispose();<br/>    super.dispose();<br/>  }<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return Container(<br/>      color: Colors.white,<br/>      child: FadeTransition(<br/>        opacity: _animation,<br/>        child: const Padding(padding: EdgeInsets.all(8), child: FlutterLogo()),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="1a1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如上面的淡入淡出动画，<code class="du ko kp kq kr b">ImplicitlyAnimatedWidgetState</code>只需要实现<code class="du ko kp kq kr b">forEachTween</code>方法和<code class="du ko kp kq kr b">didUpdateTweens</code>方法，而不需要实现<code class="du ko kp kq kr b">AnimationController</code>和<code class="du ko kp kq kr b">CurvedAnimation</code>。</p><pre class="je jf jg jh fd lg kr lh li aw lj bi"><span id="894c" class="lk jm hi kr b fi ll lm l ln lo">class _AnimatedOpacityState extends ImplicitlyAnimatedWidgetState&lt;AnimatedOpacity&gt; {<br/>  Tween&lt;double&gt;? _opacity;<br/>  late Animation&lt;double&gt; _opacityAnimation;<br/><br/>  @override<br/>  void forEachTween(TweenVisitor&lt;dynamic&gt; visitor) {<br/>    _opacity = visitor(_opacity, widget.opacity, (dynamic value) =&gt; Tween&lt;double&gt;(begin: value as double)) as Tween&lt;double&gt;?;<br/>  }<br/><br/>  @override<br/>  void didUpdateTweens() {<br/>    _opacityAnimation = animation.drive(_opacity!);<br/>  }<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return FadeTransition(<br/>      opacity: _opacityAnimation,<br/>      alwaysIncludeSemantics: widget.alwaysIncludeSemantics,<br/>      child: widget.child,<br/>    );<br/>  }<br/>}</span></pre><p id="d68b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">当</strong> <code class="du ko kp kq kr b"><strong class="ih hj">opacity</strong></code> <strong class="ih hj">改变时</strong> <code class="du ko kp kq kr b"><strong class="ih hj">ImplicitlyAnimatedWidgetState</strong></code> <strong class="ih hj">如何触发动画？</strong></p><p id="a1d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关键在于<code class="du ko kp kq kr b">forEachTween</code>的实施:</p><p id="5a7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<code class="du ko kp kq kr b">opacity</code>更新后，<code class="du ko kp kq kr b">forEachTween</code>将被调用。此时，内部<code class="du ko kp kq kr b">_shouldAnimateTween</code>确定值是否已经改变。如果目标值已经改变，基类中的<code class="du ko kp kq kr b">AnimationController.forward</code>将被执行开始动画。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es ly"><img src="../Images/97c79bd81d9c3bac45125b2ec47f264e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OyYpAkHOu2pCAAzL1f-W1g.png"/></div></div></figure><blockquote class="lq lr ls"><p id="4cdd" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">这里补充一个内容:<code class="du ko kp kq kr b">FadeTransition</code>会调用<code class="du ko kp kq kr b">_opacityAnimation</code>增加兼容性。当<code class="du ko kp kq kr b">AnimationController</code>开始执行动画时，会触发<code class="du ko kp kq kr b">_opacityAnimation</code>执行<code class="du ko kp kq kr b">markNeedsPaint</code>。如下图所示，<strong class="ih hj"> </strong> <code class="du ko kp kq kr b">markNeedsPaint</code>最终会触发<strong class="ih hj"> </strong> RenderObject的重绘。</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es md"><img src="../Images/3f7ae2a6e4d566123e526879985d52b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIzBiiqesNcjVKxSO97BrA.png"/></div></div></figure><p id="b121" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以在这里我们知道:通过继承<strong class="ih hj"> </strong> <code class="du ko kp kq kr b">ImplicitlyAnimatedWidget</code>和<strong class="ih hj"> </strong> <code class="du ko kp kq kr b">ImplicitlyAnimatedWidgetState</code>，可以更方便的实现一些动画效果。《快门》中很多默认的动画效果都是通过它实现的。</p><blockquote class="lq lr ls"><p id="ff1f" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">另外，在<code class="du ko kp kq kr b">ImplicitlyAnimatedWidget</code>模板中，除了<code class="du ko kp kq kr b">ImplicitlyAnimatedWidgetState</code>之外，官方还提供了另一个子类<code class="du ko kp kq kr b">AnimatedWidgetBaseState</code>。</p></blockquote><p id="a36e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，flutter中常用的动画控件都是通过<code class="du ko kp kq kr b">ImplicitlyAnimatedWidget</code>模板实现的，如下图所示，分别是flutter中常用动画控件继承的状态:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es me"><img src="../Images/3e3a4f0e04f338f0f9f51fd9dfcc3e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_TGVQ5KLet6oofJqBaDDGw.png"/></div></div></figure><p id="6a9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两种状态之间差异可以简单地理解为:</p><ul class=""><li id="13a7" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated"><code class="du ko kp kq kr b">ImplicitlyAnimatedWidgetState</code>主要配合各种<code class="du ko kp kq kr b">*Transition</code> Widget使用，比如<code class="du ko kp kq kr b">AnimatedOpacity</code>中的<code class="du ko kp kq kr b">FadeTransition</code>和<code class="du ko kp kq kr b">AnimatedScale</code>中的<code class="du ko kp kq kr b">ScaleTransition</code>，因为<strong class="ih hj"> </strong> <code class="du ko kp kq kr b">ImplicitlyAnimatedWidgetState</code>不使用<strong class="ih hj"> </strong> setState，而是通过触发RenderObject的<strong class="ih hj"> </strong> <code class="du ko kp kq kr b">markNeedsPaint</code>来更新界面</li><li id="90fc" class="ks kt hi ih b ii lb im lc iq ld iu le iy lf jc kx ky kz la bi translated"><code class="du ko kp kq kr b"><strong class="ih hj">AnimatedWidgetBaseState</strong></code>在原来的<strong class="ih hj"> </strong> <code class="du ko kp kq kr b"><strong class="ih hj">ImplicitlyAnimatedWidgetState</strong></code>的基础上增加了自动<strong class="ih hj"> </strong> <code class="du ko kp kq kr b"><strong class="ih hj">setState</strong></code>，这样它可以做一些更灵活的动画，比如我们前面用过的<code class="du ko kp kq kr b">AnimatedPositioned</code>和<code class="du ko kp kq kr b">AnimatedContainer</code></li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mf"><img src="../Images/ea7feb4f649eaed94dd800e34256b6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jWKZgSyj-jp2-01m8kGRg.png"/></div></div></figure><p id="d2cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其实，<code class="du ko kp kq kr b">AnimatedContainer</code>本身就是一个很有代表性的实现。如果你看看它的源代码，你会发现它的实现非常简单。你只需要实现<strong class="ih hj"> </strong> <code class="du ko kp kq kr b">forEachTween</code>中参数对应的<strong class="ih hj"> </strong> <code class="du ko kp kq kr b">Tween</code>实现即可。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mg"><img src="../Images/42b01d45d00c816e238e98126577f8bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GntkjxWluGoh9XOVFX7KYw.png"/></div></div></figure><p id="0114" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">比如我们前面改的<code class="du ko kp kq kr b">width</code>和<code class="du ko kp kq kr b">height</code>其实就是改了<code class="du ko kp kq kr b">Container</code>的<code class="du ko kp kq kr b">BoxConstraints</code>，所以对应的实现是<code class="du ko kp kq kr b">BoxConstraintsTween</code>。<strong class="ih hj"> </strong> <code class="du ko kp kq kr b">BoxConstraintsTween</code> <strong class="ih hj"> </strong>继承了<strong class="ih hj"> </strong> <code class="du ko kp kq kr b">Tween</code>，主要实现了<code class="du ko kp kq kr b">Tween</code>的<code class="du ko kp kq kr b">lerp</code>方法。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mh"><img src="../Images/ff66c55c2d2b49e9f5372ef38643b218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjfrkg82TOIetNlFYKfjsA.png"/></div></div></figure><p id="2338" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Flutter中，使用<code class="du ko kp kq kr b">lerp</code>方法实现插值:动画时在<code class="du ko kp kq kr b">beigin</code>和<code class="du ko kp kq kr b">end</code>之间进行<code class="du ko kp kq kr b">BoxConstraint</code>线性插值，其中t为动画时钟值下的变化值，例如:</p><blockquote class="lq lr ls"><p id="1156" class="if ig lt ih b ii ij ik il im in io ip lu ir is it lv iv iw ix lw iz ja jb jc hb bi translated">计算100x100到200x200的过程中需要的一些中间过程的大小。</p></blockquote><p id="2cb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如下面的代码所示，通过继承<code class="du ko kp kq kr b">AnimatedWidgetBaseState</code>，然后使用<code class="du ko kp kq kr b">ColorTween</code> <code class="du ko kp kq kr b">lerp</code>，可以快速实现下面文字的渐变效果。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mg"><img src="../Images/67b84d6aba90d2c899eb8ed1f62cbc3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aKkawydr5uhF2omd0nWe6A.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mi"><img src="../Images/25040f60d0a551a1ac5cdc5e09c1604b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lYmhCdwb52Zz8KJI_x4GmQ.gif"/></div></div></figure></div></div>    
</body>
</html>