<html>
<head>
<title>Android View Binding behind the scenes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android视图幕后绑定</h1>
<blockquote>原文：<a href="https://medium.com/codex/android-view-binding-behind-the-scenes-d2cfa3fe5914?source=collection_archive---------3-----------------------#2022-07-31">https://medium.com/codex/android-view-binding-behind-the-scenes-d2cfa3fe5914?source=collection_archive---------3-----------------------#2022-07-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cf0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“我喜欢在空闲时间写东西”，从来没有一个开发者这样说过。事实上，视图绑定极大地改善了布局文件和<em class="jh">活动/片段</em>之间的桥梁。但是我发现开发人员经常使用视图绑定，但是不知道幕后到底发生了什么。本文帮助您理解视图绑定是如何实现的，以便您可以充分利用它的特性。我们开始吧！</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es ji"><img src="../Images/21d396bcb078847262fb4e96a54cd0f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6_vaaTVf7qEfoCbyxVH9Q.png"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx translated">照片由<a class="ae jy" href="https://www.pexels.com/photo/binding-books-color-colorful-273034/" rel="noopener ugc nofollow" target="_blank"> pixabay </a>拍摄</figcaption></figure><h1 id="a17d" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">基本用法</h1><p id="9067" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">为了让我们熟悉一下，让我们看看一个示例布局，比较一下通过使用视图绑定和不使用视图绑定，我们将如何从一个<em class="jh">活动</em>中与它进行交互。</p><p id="c261" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的示例xml布局有一个<code class="du jd je jf jg b">TextView</code>和一个<code class="du jd je jf jg b">Button</code>组件。有一个小问题，<code class="du jd je jf jg b">Button</code>只存在于大屏幕中，所以我们将定义如下两种布局:</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es lc"><img src="../Images/b8c39724a37ddc434dff08e050c56f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*A1EaaRoQT4mu7LfhvLbnyg.png"/></div></figure><p id="eda5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">小型(简化)布局如下:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="c451" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而大的(简化的)布局将是:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="b343" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果不使用视图绑定，在<code class="du jd je jf jg b">TextView</code>中设置一条消息，在<code class="du jd je jf jg b">MainActivity</code>中设置一个<code class="du jd je jf jg b">Button</code>的监听器，如下所示:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="14bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在使用视图绑定时，我们可以这样做:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ld le l"/></div></figure><h1 id="135d" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">绑定类</h1><p id="9dfe" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">启用了<a class="ae jy" href="https://developer.android.com/topic/libraries/view-binding" rel="noopener ugc nofollow" target="_blank">视图绑定的模块中的任何布局</a>都有自己的绑定类，这是一个针对与Kotlin的互操作性而优化的Java类。简而言之，</p><blockquote class="lf lg lh"><p id="ffb1" class="if ig jh ih b ii ij ik il im in io ip li ir is it lj iv iw ix lk iz ja jb jc hb bi translated">binding类用于扩展布局，绑定其子视图，并以安全的方式将它们作为属性公开。</p></blockquote><p id="b044" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将剥离上例中为<code class="du jd je jf jg b">activity_main</code>生成的<code class="du jd je jf jg b">ActivityMainBinding</code>类，看看它是如何工作的。</p><h1 id="7bea" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">公开视图</h1><p id="6506" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">不管运行设备<code class="du jd je jf jg b">activity_main.xml</code>的屏幕宽度如何，我们都保证有一个<code class="du jd je jf jg b">ConstrainLayout</code>的<code class="du jd je jf jg b">TextView</code>子元素，所以我们的绑定类将这些视图公开为不可空的属性。然而，<code class="du jd je jf jg b">Button</code>组件只在设备有足够大的屏幕时才存在，所以在我们的Kotlin代码中，为了安全访问，它被公开为一个可空属性。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="fbd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，请注意，我们使用安全调用操作符仅在<code class="du jd je jf jg b">sampleButton</code>不为空的情况下设置点击监听器(即设备的屏幕足够大)。然而，通过直接使用<code class="du jd je jf jg b">findViewById</code>，我们将总是试图设置监听器，因此当在较小的屏幕设备上运行应用程序时会出现运行时错误，因为这些应用程序的<code class="du jd je jf jg b">activity_main</code>布局不包括<code class="du jd je jf jg b">Button</code>。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="df7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，</p><blockquote class="lf lg lh"><p id="fb7c" class="if ig jh ih b ii ij ik il im in io ip li ir is it lj iv iw ix lk iz ja jb jc hb bi translated">视图绑定为给定布局中存在的每个视图公开了一个正确类型的属性，这有助于我们避免在构建应用程序之前访问视图时出现错误。</p></blockquote><p id="e45b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除了有助于避免可空性问题，这种方法还有助于避免其他常见的错误，这些错误可能会因为将不正确的参数传递给<code class="du jd je jf jg b">findViewById</code>而发生。例如，构建过程会成功，但在以下情况下应用程序会在运行时崩溃:</p><ul class=""><li id="4d16" class="ll lm hi ih b ii ij im in iq ln iu lo iy lp jc lq lr ls lt bi translated">我们将一个不存在的id传递给<code class="du jd je jf jg b">findViewById</code>；</li><li id="6eee" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">我们将存在于另一个布局中但不在当前展开的布局中的id传递给<code class="du jd je jf jg b">findViewById</code>；</li><li id="dfae" class="ll lm hi ih b ii lu im lv iq lw iu lx iy ly jc lq lr ls lt bi translated">我们传递了一个有效的id，但是错误的数据类型给了<code class="du jd je jf jg b">findViewById</code>。</li></ul><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ld le l"/></div></figure><h1 id="3cee" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">扩大布局</h1><p id="6412" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">现在我们各退一步。我们知道如何使用<code class="du jd je jf jg b">binding</code>对象访问视图，但是我们首先是如何获得这个对象的呢？我们通过调用来自<code class="du jd je jf jg b">ActivityMainBinding</code>的<code class="du jd je jf jg b">inflate</code>静态方法并传递我们活动的<code class="du jd je jf jg b">layoutInflater</code>来创建它。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="a8e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">inflate</code>方法膨胀相应的布局并绑定视图。这是该类的一个关键部分，因为它检查每个子视图是否为空，并保证不应该为空的视图不会为空。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="14bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">太好了，我们已经膨胀了布局，但是我们还没有将膨胀的布局链接到我们的活动。注意，在上面的<code class="du jd je jf jg b">ActivityMainBinding</code>构造函数中，我们传递了一个展开的根视图的引用，可以通过公共的根属性访问它。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="e738" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着我们现在可以使用Kotlin的属性访问语法从活动中调用<code class="du jd je jf jg b">setContentView(binding.root)</code>。</p><p id="b393" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jh">现在快速声明:为了简单起见，上面的代码是对实际生成代码的简化。实际代码针对字节码性能进行了优化，但是逻辑保持不变。</em></p><h1 id="a146" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">布局内部的布局</h1><p id="eb76" class="pw-post-body-paragraph if ig hi ih b ii kx ik il im ky io ip iq kz is it iu la iw ix iy lb ja jb jc hb bi translated">到目前为止，我们知道视图绑定有助于减少任何xml布局中容易出错的代码和样板代码。最棒的是，它还灵活地支持布局内的布局，等等…</p><p id="ac2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，假设我们在<code class="du jd je jf jg b">inner.xml</code>中有任何xml布局。然后我们可以有另一个名为<code class="du jd je jf jg b">outer.xml</code>的xml布局，它包含了<code class="du jd je jf jg b">inner</code>:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="c190" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后<code class="du jd je jf jg b">OuterBinding</code>类会将一个<code class="du jd je jf jg b">InnerBinding</code>对象作为属性公开，你可以在两个布局中使用所有的视图绑定特性，以及任何其他递归包含的布局，以同样的方式。</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="939e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，请注意，这只是因为我们在包含的布局中添加了一个id。就像视图绑定需要一个id来为绑定类中的常规视图(<code class="du jd je jf jg b">TextView</code>、<code class="du jd je jf jg b">Button</code> …)生成属性一样，它也需要id来将任何包含的布局作为属性公开。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="cd33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！我希望这篇文章揭示了视图绑定是如何在幕后发挥其魔力的，以及它是如何在布局和视图组件之间提供一个更干净、更少出错的桥梁的。</p><p id="f408" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢的内容，不要忘记鼓掌，并关注更多！</p></div></div>    
</body>
</html>