<html>
<head>
<title>Path Handling Functions of R for Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中R的路径处理函数</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-i-wrote-a-python-package-to-imitate-rs-nice-and-neat-path-handling-functions-c6c45eccea9?source=collection_archive---------8-----------------------#2021-09-05">https://medium.com/codex/how-i-wrote-a-python-package-to-imitate-rs-nice-and-neat-path-handling-functions-c6c45eccea9?source=collection_archive---------8-----------------------#2021-09-05</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><div class=""><h2 id="28c5" class="pw-subtitle-paragraph ig hi hj bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dy translated">以类似R的方式统一Python的路径处理函数。</h2></div><figure class="iz ja jb jc fe jd es et paragraph-image"><div class="es et iy"><img src="../Images/d349ac6bc8d82d055c1c04911a1b6725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q01mix-c7ZNGOlcj.png"/></div><figcaption class="jg jh eu es et ji jj bd b be z dy translated">照片由<a class="ae jk" href="https://www.pexels.com/@birgit-held-392791?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Birgit从<a class="ae jk" href="https://www.pexels.com/photo/aerial-photo-of-building-1046125/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>举行</a></figcaption></figure><p id="b9eb" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated"><a class="ae jk" href="https://gwang-jin-kim.medium.com/useful-path-handling-functions-in-r-4459ba21e411" rel="noopener">base R中的路径处理函数</a>是内置的，干净而直观，而Python的路径处理函数<a class="ae jk" href="https://gwang-jin-kim.medium.com/useful-path-handling-functions-in-python-657296fd445a" rel="noopener">是跨三个不同的标准包(</a> <code class="dv kh ki kj kk b"><a class="ae jk" href="https://gwang-jin-kim.medium.com/useful-path-handling-functions-in-python-657296fd445a" rel="noopener">os</a></code> <a class="ae jk" href="https://gwang-jin-kim.medium.com/useful-path-handling-functions-in-python-657296fd445a" rel="noopener">、</a> <code class="dv kh ki kj kk b"><a class="ae jk" href="https://gwang-jin-kim.medium.com/useful-path-handling-functions-in-python-657296fd445a" rel="noopener">pathlib</a></code> <a class="ae jk" href="https://gwang-jin-kim.medium.com/useful-path-handling-functions-in-python-657296fd445a" rel="noopener">和</a> <code class="dv kh ki kj kk b"><a class="ae jk" href="https://gwang-jin-kim.medium.com/useful-path-handling-functions-in-python-657296fd445a" rel="noopener">shutils</a></code> <a class="ae jk" href="https://gwang-jin-kim.medium.com/useful-path-handling-functions-in-python-657296fd445a" rel="noopener"> ) </a>分布的、重复的、略有不同的。</p><p id="c8cb" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">把它们统一成一个Python包怎么样？</p><p id="b48b" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">我们姑且称这个套餐为<code class="dv kh ki kj kk b">rpath</code>。让我们一起创建一个包，同时在本文中浏览R和Python的路径处理命令。</p><h1 id="0cdd" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">使用诗歌设置包主干</h1><p id="b327" class="pw-post-body-paragraph jl jm hj jn b jo ld ik jq jr le in jt ju lf jw jx jy lg ka kb kc lh ke kf kg hc bi translated">诗歌使Python中的包创建和部署变得容易，提供了高度的可再现性。</p><p id="d21c" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">我们使用诗歌的安装脚本来安装诗歌:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="6c86" class="lm km hj kk b fj ln lo l lp lq">$ curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python3</span></pre><p id="c78d" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">重要提示:不要使用<code class="dv kh ki kj kk b">$ pip install poetry</code>。他们还在<code class="dv kh ki kj kk b">poetry</code>的网站上警告不要通过<code class="dv kh ki kj kk b">pip</code>安装。</p><p id="1024" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">通过以下方式检查安装是否正确:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="550f" class="lm km hj kk b fj ln lo l lp lq">$ poetry --version</span></pre><p id="63ab" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">现在让我们安装一个诗歌项目(包):</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="a5e1" class="lm km hj kk b fj ln lo l lp lq">$ poetry new rpath<br/>## Created package rpath in rpath</span></pre><p id="669d" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">让我们通过以下方式进入包的文件夹:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="c955" class="lm km hj kk b fj ln lo l lp lq">$ cd rpath</span></pre><p id="c9b8" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">用你选择的编辑器打开<code class="dv kh ki kj kk b">pyproject.toml</code>文件，比如gedit(在Ubuntu中)。<code class="dv kh ki kj kk b">.toml</code>文件是<code class="dv kh ki kj kk b">poetry</code>包的配置文件。请随意选择除gedit之外的任何其他编辑器:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="41f6" class="lm km hj kk b fj ln lo l lp lq">$ gedit pyproject.toml</span></pre><p id="7cc1" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">我们将文件写入/完成到:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="ff81" class="lm km hj kk b fj ln lo l lp lq">[tool.poetry]<br/>name = "rpath"<br/>version = "0.1.0"<br/>description = "R's path handling functions for Python"<br/>authors = ["Gwang-Jin Kim &lt;<a class="ae jk" href="mailto:gwang.jin.kim.phd@gmail.com" rel="noopener ugc nofollow" target="_blank">gwang.jin.kim.phd@gmail.com</a>&gt;"]</span><span id="6525" class="lm km hj kk b fj lr lo l lp lq">[tool.poetry.dependencies]<br/>python = "^3.9"</span><span id="82d0" class="lm km hj kk b fj lr lo l lp lq">[tool.poetry.dev-dependencies]<br/>pytest = "^5.2"</span><span id="f81f" class="lm km hj kk b fj lr lo l lp lq">[build-system]<br/>requires = ["poetry-core&gt;=1.0.0"]<br/>build-backend = "poetry.core.masonry.api"</span></pre><p id="5cf3" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">并保存更改。</p><p id="6c43" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">我们检查<code class="dv kh ki kj kk b">toml</code>文件的正确性:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="b572" class="lm km hj kk b fj ln lo l lp lq">$ poetry check<br/>## All set!</span></pre><p id="89da" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">然后，我们用我们最喜欢的编辑器创建并打开<code class="dv kh ki kj kk b">main.py</code>文件，并在那里编写我们的代码。</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="2996" class="lm km hj kk b fj ln lo l lp lq">$ YOUR_EDITOR rpath/main.py # in my case `gedit`</span></pre><p id="6047" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">并在那里写道:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="abe7" class="lm km hj kk b fj ln lo l lp lq">import os<br/>import pathlib<br/>import shutil</span></pre><p id="355d" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">现在我们已经准备好为这个包编写函数了。</p><h1 id="47ba" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">1.如何在R和Python中获取/设置当前目录</h1><p id="8dfd" class="pw-post-body-paragraph jl jm hj jn b jo ld ik jq jr le in jt ju lf jw jx jy lg ka kb kc lh ke kf kg hc bi translated">在R中，这将是:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="e151" class="lm km hj kk b fj ln lo l lp lq">getwd()<br/>setwd("/to/dir")</span></pre><p id="c6d4" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">在Python中，我们有:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="aa73" class="lm km hj kk b fj ln lo l lp lq"># get the current directory:<br/>os.path.abspath(os.getcwd())  <br/># os.path.abspath() helps to deal with Windows path peculiarities<br/>os.path.realpath('.')         # eliminates symbolic links<br/>                              # and replace them by the real path<br/>pathlib.Path.cwd()<br/>pathlib.Path(__file__).resolve() # resolve to absolute path</span><span id="bbd2" class="lm km hj kk b fj lr lo l lp lq"># set the current directory:<br/>os.chdir("/to/dir") <br/># no corresponding in pathlib or shutil</span></pre><p id="ab90" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">所以我们写成<code class="dv kh ki kj kk b">rpath/main.py</code>:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="dfff" class="lm km hj kk b fj ln lo l lp lq">def getwd():<br/>    return os.path.realpath(os.path.abspath(os.getcwd()))</span><span id="f279" class="lm km hj kk b fj lr lo l lp lq">def setwd(path):<br/>    return os.chdir(path)</span></pre><p id="29ae" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">我们可以用Python调用:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="d071" class="lm km hj kk b fj ln lo l lp lq">rpath.getwd()rpath.setwd(path)</span></pre><h1 id="2478" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">2.如何在R和Python中解析和访问路径名组件</h1><p id="62b4" class="pw-post-body-paragraph jl jm hj jn b jo ld ik jq jr le in jt ju lf jw jx jy lg ka kb kc lh ke kf kg hc bi translated">在R中，我们有:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="0103" class="lm km hj kk b fj ln lo l lp lq"># parent directory name<br/>dirname(path)# file name<br/>basename(path)# file extension      </span><span id="fc5e" class="lm km hj kk b fj lr lo l lp lq">## note, the following functions are not base R functions<br/>## you have to install the packages <br/>## preceding `::` <br/>## e.g. by `install.packages("tools") <br/>## or "rio" or "xfun"<br/>## e.g. 'csv' for files ending with '.csv'<br/>tools::file_ext(path) # or:<br/>rio::file_ext(path)   # or:<br/>xfun::file_ext(path)# split a path into its components  </span><span id="1376" class="lm km hj kk b fj lr lo l lp lq"># how to dissect path folder and file names<br/># "/a/b/c.txt" =&gt; c("a", "b", "c.txt")<br/>split_path &lt;- function(path) {<br/>  if (dirname(path) %in% c(".", path)) return(basename(path))<br/>  return(c(basename(path), split_path(dirname(path))))<br/>}<br/># from <a class="ae jk" href="https://stackoverflow.com/questions/29214932/split-a-file-path-into-folder-names-vector" rel="noopener ugc nofollow" target="_blank">here</a></span></pre><p id="93e3" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">在Python中:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="c01e" class="lm km hj kk b fj ln lo l lp lq"># parent directory:<br/>os.path.dirname(path)</span><span id="f3dd" class="lm km hj kk b fj lr lo l lp lq"># file name:<br/>os.path.basename(path)</span><span id="7255" class="lm km hj kk b fj lr lo l lp lq"># file extension:<br/>filename, file_extension = os.path.splitext(path)</span><span id="7ce9" class="lm km hj kk b fj lr lo l lp lq"># file extension:<br/>filename, file_extension = os.path.splitext(path)</span></pre><p id="31e6" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">所以我们可以理解它:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="0a2a" class="lm km hj kk b fj ln lo l lp lq">def dirname(path):<br/>    return os.path.dirname(path)def basename(path):<br/>    return os.path.basename(path)def file_ext(path):<br/>    return os.path.splitext(path)[1]</span></pre><h1 id="6387" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">3.如何在R和Python中连接路径组件</h1><p id="3d8f" class="pw-post-body-paragraph jl jm hj jn b jo ld ik jq jr le in jt ju lf jw jx jy lg ka kb kc lh ke kf kg hc bi translated">在R中，我们有:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="e23e" class="lm km hj kk b fj ln lo l lp lq">file.path("/a", "b", "file.txt") ## "/a/b/file.txt"</span></pre><p id="b169" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">在Python中，我们必须选择:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="b9f1" class="lm km hj kk b fj ln lo l lp lq">os.path.join("/dir", "dir", "file.txt")                                                <br/>pathlib.Path("/dir") / "dir" / "file.txt"                                             <br/>pathlib.PurePath("/dir", "dir", "file.txt")                                           <br/># make Path() objects to string using `str()` <br/># or their `.as_posix()` method<br/># they all create "/dir/dir/file.txt"</span></pre><p id="9c85" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">因此，要在Python中使用<code class="dv kh ki kj kk b">file.path()</code>，我们需要:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="4aab" class="lm km hj kk b fj ln lo l lp lq">def file_path(*args):<br/>    return os.path.join(*args)</span></pre><p id="5861" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">但是我也喜欢<code class="dv kh ki kj kk b">/</code>超载…</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="e1fe" class="lm km hj kk b fj ln lo l lp lq">Path = pathlib.Path</span></pre><p id="74c2" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">那么，我们就可以使用:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="775f" class="lm km hj kk b fj ln lo l lp lq">rpath.file_path("/a", "b", "c.txt") ## "/a/b/c.txt"</span></pre><p id="226d" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">而且:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="d216" class="lm km hj kk b fj ln lo l lp lq">str(rpath.Path("/a") / "b" / "c.txt") ## "/a/b/c.txt"</span></pre><h1 id="4f27" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">4.如何在R和Python中递归列出文件夹中的文件</h1><p id="88d7" class="pw-post-body-paragraph jl jm hj jn b jo ld ik jq jr le in jt ju lf jw jx jy lg ka kb kc lh ke kf kg hc bi translated">在R中，这将是:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="7eb2" class="lm km hj kk b fj ln lo l lp lq"># folders<br/>list.dirs(path = ".", full.names = TRUE, recursive = TRUE)</span><span id="defe" class="lm km hj kk b fj lr lo l lp lq"># files<br/>list.files("/to/dir", pattern="\\.csv", full.names=TRUE, recursive=TRUE) ## pattern is regex</span></pre><p id="c9ee" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">在Python中，我们有:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="b40b" class="lm km hj kk b fj ln lo l lp lq">pathlib.Path("/dir").glob("**/*.csv") <br/># recursivity through wildcards `**`!</span></pre><p id="0111" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">我们可以通过以下方式在Python中提供R函数:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="4d74" class="lm km hj kk b fj ln lo l lp lq">def list_dirs(path, pattern = "*", full_names=True, recursive=True):<br/>    pattern = "**" + os.sep + pattern if recursive else pattern<br/>    res = [p for p in pathlib.Path(path).glob(pattern) \<br/>                if os.path.isdir(p)]<br/>    if full_names:<br/>        return res<br/>    else:<br/>        return [basename(p) for p in res]</span><span id="55d0" class="lm km hj kk b fj lr lo l lp lq">def list_files(path, pattern="*", full_names = True, recursive=True):<br/>    pattern = "**" + os.sep + pattern if recursive else pattern<br/>    res = [p for p in pathlib.Path(path).glob(pattern) \<br/>                if os.path.isfile(p)]<br/>    if full_names:<br/>        return res<br/>    else:<br/>        return [basename(p) for p in res]</span><span id="052f" class="lm km hj kk b fj lr lo l lp lq">## `pattern` is here not regex pattern, but bash file path pattern of `glob`</span></pre><h1 id="3422" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">5.如何在R和Python中测试文件和文件夹的存在</h1><p id="6089" class="pw-post-body-paragraph jl jm hj jn b jo ld ik jq jr le in jt ju lf jw jx jy lg ka kb kc lh ke kf kg hc bi translated">在R中，这是通过以下方式解决的:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="0b37" class="lm km hj kk b fj ln lo l lp lq"># folders<br/>dir.exists("/to/dir")                # or file.exists("/to/dir")</span><span id="7c53" class="lm km hj kk b fj lr lo l lp lq"># files<br/>file.exists("/to/file.txt")</span></pre><p id="bb8f" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">在Python中，我们使用其中之一:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="429d" class="lm km hj kk b fj ln lo l lp lq"># for both:<br/>pathlib.Path("/to/dir/or/file.txt").exists()</span><span id="e163" class="lm km hj kk b fj lr lo l lp lq"># for folders<br/>pathlib.Path("to/dir").is_dir()<br/>os.path.isdir("to/dir")</span><span id="90f8" class="lm km hj kk b fj lr lo l lp lq"># for files<br/>pathlib.Path("to/file.txt").is_file()<br/>os.path.isfile("to/dir")</span><span id="078d" class="lm km hj kk b fj lr lo l lp lq"># there is also<br/>os.path.islink(path)</span></pre><p id="e7a1" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">所以我们可以总结为:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="ce55" class="lm km hj kk b fj ln lo l lp lq">def dir_exists(path):<br/>    return os.path.isdir(path)def file_exists(path):<br/>    return os.path.isfile(path)</span></pre><h1 id="f0a2" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">6.如何在R和Python中创建新的文件夹和文件</h1><p id="9486" class="pw-post-body-paragraph jl jm hj jn b jo ld ik jq jr le in jt ju lf jw jx jy lg ka kb kc lh ke kf kg hc bi translated">在R中，我们使用:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="3c56" class="lm km hj kk b fj ln lo l lp lq"># folders<br/>dir.create("/to/new/dir", recursive=TRUE)</span><span id="7a23" class="lm km hj kk b fj lr lo l lp lq"># files<br/>file.create("/to/file.txt")</span></pre><p id="3dcb" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">在Python中对应于:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="8174" class="lm km hj kk b fj ln lo l lp lq">pathlib.Path("/to/new/dir").mkdir(exist_ok=True, parents=True)<br/>os.makedirs("/to/new/dir", exist_ok=True)</span><span id="91b7" class="lm km hj kk b fj lr lo l lp lq"># create a file (touch)<br/>pathlib.Path("/to/new/file.txt").touch()</span></pre><p id="36c4" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">因此，我们用以下公式取代R的语法:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="6a19" class="lm km hj kk b fj ln lo l lp lq">def dir_create(path, recursive=True):<br/>    os.makedirs(path, exist_ok=True)<br/>    print(f"Created {path}")</span><span id="e548" class="lm km hj kk b fj lr lo l lp lq">def file_create(path):<br/>    pathlib.Path(path).touch()<br/>    print(f"Created {path}")</span></pre><h1 id="b553" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">7.如何在R和Python中(递归地)删除文件和文件夹</h1><p id="f54c" class="pw-post-body-paragraph jl jm hj jn b jo ld ik jq jr le in jt ju lf jw jx jy lg ka kb kc lh ke kf kg hc bi translated">在R中，我们通过<code class="dv kh ki kj kk b">unlink()</code>函数删除:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="565a" class="lm km hj kk b fj ln lo l lp lq"># folders<br/>unlink("/to/dir", recursive=TRUE)</span><span id="d1a3" class="lm km hj kk b fj lr lo l lp lq"># files<br/>unlink("/to/file.txt")</span></pre><p id="8fae" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">Python中的<code class="dv kh ki kj kk b">unlink()</code>也是这样:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="277a" class="lm km hj kk b fj ln lo l lp lq"># for both<br/>os.unlink("/to/dir/or/file.txt")<br/>pathlib.Path("/to/dir/or/file.txt").unlink()</span><span id="92e2" class="lm km hj kk b fj lr lo l lp lq"># rmdir (however, I never liked rmdir - it deletes only empty folders)<br/>os.rmdir(dir_path, missing_ok=True)</span></pre><p id="0c73" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">所以，这很简单:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="1254" class="lm km hj kk b fj ln lo l lp lq">def unlink(path):<br/>    os.unlink(path)</span></pre><h1 id="2818" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">8.如何在R和Python中复制包含内容和文件的文件夹</h1><p id="61f8" class="pw-post-body-paragraph jl jm hj jn b jo ld ik jq jr le in jt ju lf jw jx jy lg ka kb kc lh ke kf kg hc bi translated">在R中，我们可以:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="e4d4" class="lm km hj kk b fj ln lo l lp lq"># copy folder architecture recursively (not keeping original dates)<br/>dir.create('/to/dir', recursive=TRUE) # subsequently followed by:<br/>file.copy("/from/dir/or/file.txt", "/to/dir", recursive=TRUE, copy.date=FALSE)</span></pre><p id="9f04" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">在Python中，我们有:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="e757" class="lm km hj kk b fj ln lo l lp lq"># copy a folder recursively<br/>shutil.copytree(src="/from/dir", <em class="ls">dst="/to/dir"</em>, <br/>                <em class="ls">symlinks=False</em>, <br/>                <em class="ls">ignore=None</em>, <br/>                <em class="ls">copy_function=shutil.copy2</em>, <br/>                <em class="ls">ignore_dangling_symlinks=False</em>, <br/>                <em class="ls">dirs_exist_ok=False</em>)# copy a file<br/>shutil.copyfile("/from/file.txt", <br/>                "/to/file.txt",        # must be a complete file<br/>                follow_symlinks=True)            <br/>shutil.copy("/to/file.txt", "/new/dir/file.txt") <br/># only Python3.8+ # <br/># in &lt;Python3.8 put `str()` around Path() objects! or `.as_posix()`!</span></pre><p id="6d91" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">要实现R的<code class="dv kh ki kj kk b">file.copy()</code>，似乎有些棘手。</p><p id="6726" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">让我们实现一个简单的版本，涵盖最常见的情况。</p><p id="4c0a" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">因此，要么<code class="dv kh ki kj kk b">from</code>路径是一个目录——然后我们希望递归地将文件夹中的所有文件复制到新目录。因此，我们可以使用<code class="dv kh ki kj kk b">shutil.copytree()</code>。</p><p id="f154" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">如果<code class="dv kh ki kj kk b">from</code>路径是一个文件，我们使用<code class="dv kh ki kj kk b">shutil.copyfile()</code>。然而，我们可能希望允许现有的目录作为目标<code class="dv kh ki kj kk b">to</code>。我们可以使用上面写的<code class="dv kh ki kj kk b">dir_exist()</code>来检查。</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="aa3f" class="lm km hj kk b fj ln lo l lp lq">def file_copy(_from, _to):<br/>    if dir_exist(_from):<br/>        shutil.copytree(src=_from, dst=_to,<br/>                        <em class="ls">symlinks=False</em>, <br/>                        <em class="ls">ignore=None</em>, <br/>                        <em class="ls">copy_function=shutil.copy2</em>, <br/>                        <em class="ls">ignore_dangling_symlinks=False</em>, <br/>                        <em class="ls">dirs_exist_ok=False)</em><br/>    elif file_exist(_from):<br/>        if dir_exist(_to):<br/>            _to = file_path(_to, basename(_from))<br/>        shutil.copyfile(_from, _to,<br/>                        follow_symlinks=True)<br/>    else:<br/>        raise FileNotFoundError</span></pre><h1 id="fbea" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">9.如何在R和Python中移动和重命名文件夹和文件</h1><p id="cae1" class="pw-post-body-paragraph jl jm hj jn b jo ld ik jq jr le in jt ju lf jw jx jy lg ka kb kc lh ke kf kg hc bi translated">要承认，除了单个文件，R中没有真正的<code class="dv kh ki kj kk b">mv</code>等价物。</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="7769" class="lm km hj kk b fj ln lo l lp lq"># move a folder<br/>file.copy(from = "/from/dir", to = "/to/dir", <br/>          overwrite = recursive, <br/>          recursive = FALSE, <br/>          copy.mode = TRUE)<br/>unlink("/from/dir")<br/># so this is not actually a mv in the sense of unix commands,<br/># but a copy and delete recursively</span><span id="b78f" class="lm km hj kk b fj lr lo l lp lq"># files<br/># move a file<br/>file.rename("from", "to")<br/># or one could also copy first the file and then unlink() the original one.</span></pre><p id="eb50" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">在这一点上，Python有<code class="dv kh ki kj kk b">shutil.move()</code>，它相当于Unix系统的<code class="dv kh ki kj kk b">mv</code>:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="ac3f" class="lm km hj kk b fj ln lo l lp lq"># move a folder recursively<br/>shutil.move(<em class="ls">src="</em>/from/dir", <em class="ls">ds</em>t="/new/dir", <em class="ls">copy_function=shutil.copy2</em>)</span><span id="e202" class="lm km hj kk b fj lr lo l lp lq"># move files:<br/>os.rename("/to/file.txt", "/new/dir")<br/>pathlib.Path("/to/file.txt").rename("/new/dir/file.txt")<br/>shutil.move(src="/to/file.txt", dst="/new/dir")</span></pre><p id="e0dc" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">所以这可能是唯一的功能，我们更喜欢Python的<code class="dv kh ki kj kk b">move()</code>而不是R的<code class="dv kh ki kj kk b">file.rename()</code>。然而，我们将实现后者:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="af5c" class="lm km hj kk b fj ln lo l lp lq">def move(_from, _to, copy_function=shutil.copy2):<br/>    return shutil.move(src=_from, dst=_to,           <br/>                       copy_function=copy_function)def file_rename(_from, _to):<br/>    return shutil.move(src=_from, dst=_to)</span></pre><p id="cad6" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">最后，我们离开了:</p><h1 id="ed07" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">10.如何在R和Python中获取文件夹和文件的大小和创建时间</h1><p id="c4a3" class="pw-post-body-paragraph jl jm hj jn b jo ld ik jq jr le in jt ju lf jw jx jy lg ka kb kc lh ke kf kg hc bi translated">r对这个问题的解决方案是:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="f0aa" class="lm km hj kk b fj ln lo l lp lq">obj &lt;- file.info(path)<br/># watch available variables by<br/>str(obj)</span><span id="a002" class="lm km hj kk b fj lr lo l lp lq"># file size<br/>obj$size</span><span id="7daf" class="lm km hj kk b fj lr lo l lp lq"># is path a directory?<br/>obj$isdir</span><span id="f07c" class="lm km hj kk b fj lr lo l lp lq"># modification, creation, access time<br/>obj$mtime, obj$ctime, obj$atime</span></pre><p id="2493" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">为此，Python具有:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="b662" class="lm km hj kk b fj ln lo l lp lq">os.getsize(path)<br/>os.getatime(path)<br/>os.getctime(path)<br/>os.getmtime(path)</span><span id="5b90" class="lm km hj kk b fj lr lo l lp lq"># and one can use the setters too<br/>os.path.isdir(path)</span><span id="bd0b" class="lm km hj kk b fj lr lo l lp lq"># look for methods in<br/>dir(os)<br/>dir(os.path)<br/>dir(pathlib.Path)</span></pre><p id="72a7" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">为了模仿R的对象，我们可以在我们的Python包中为它编写一个类:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="068d" class="lm km hj kk b fj ln lo l lp lq">class FileInfo:<br/>    <br/>    def __init__(self, path):<br/>        self.path = path<br/>        self.size = os.getsize(path)<br/>        self.atime = os.getatime(path)<br/>        self.ctime = os.getctime(path)<br/>        self.mtime = os.getmtime(path)<br/>        self.isdir = os.path.isdir(path)</span><span id="47e6" class="lm km hj kk b fj lr lo l lp lq"># a more encompassing class would be:<br/>class FileInfo:<br/>    <br/>    def __init__(self, path):<br/>        self.path = path<br/>        self.exists = os.path.exists(path)<br/>        if self.exists:<br/>            self.size = os.getsize(path)<br/>            self.atime = os.getatime(path)           # last access<br/>            self.ctime = os.getctime(path)           # creation<br/>            self.mtime = os.getmtime(path)           # last modific.<br/>            self.isdir = os.path.isdir(path)         # is a dir<br/>            self.islink = os.path.islink(path)       # is a symlink<br/>            self.isfile = os.path.isfile(path) and not self.islink<br/>                                                 # is a regular file</span></pre><h1 id="24ab" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">使用诗歌构建和发布</h1><p id="42c6" class="pw-post-body-paragraph jl jm hj jn b jo ld ik jq jr le in jt ju lf jw jx jy lg ka kb kc lh ke kf kg hc bi translated">首先，我们必须导出函数名和类名，这样它们就可以从包中导出，因此可以从包外访问。</p><p id="8cb0" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">为此，我们打开文件夹中的<code class="dv kh ki kj kk b">~/rpath/rapth/__init__.py</code>文件，其中有<code class="dv kh ki kj kk b">main.py</code>文件。并在那里写入导入文件:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="4c85" class="lm km hj kk b fj ln lo l lp lq">__version__ = '0.1.0' # this line poetry wrote<br/>from .main import getwd, setwd, dirname, basename, file_ext  <br/>from .main import file_path, Path, list_dirs, list_files <br/>from .main import dir_exists, file_exists, dir_create, file_create<br/>from .main import unlink, file_copy, move, file_rename, FileInfo</span></pre><p id="705b" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">然后，我们必须构建并发布这个包:</p><pre class="iz ja jb jc fe li kk lj lk aw ll bi"><span id="cbb7" class="lm km hj kk b fj ln lo l lp lq">$ poetry build<br/>$ poetry publish <br/># asks for our username and password in PyPI<br/># so you should have an account there or register</span></pre><p id="3901" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">Cave:诗词对版本控制非常严格，所以每次要重新构建重新发布(为了更新包代码的改动)，都要在<code class="dv kh ki kj kk b">pyproject.toml</code>文件中增加版本号！(你可以给出版本号<code class="dv kh ki kj kk b">0.1.0-0</code>，如果你想避免版本号上升带来的膨胀，只升级<code class="dv kh ki kj kk b">—</code>后面的版本号)。</p><p id="5f90" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">一旦完成并删除了所有错误，我们就可以从这个星球上的任何地方进入终端:<code class="dv kh ki kj kk b">$ pip install rpath</code>，打开Python(或<code class="dv kh ki kj kk b">ipython</code>)，所有的路径处理功能都唾手可得！恭喜你！</p><p id="9a1d" class="pw-post-body-paragraph jl jm hj jn b jo jp ik jq jr js in jt ju jv jw jx jy jz ka kb kc kd ke kf kg hc bi translated">(完整代码列在<a class="ae jk" href="https://bitbucket.org/freiburgmls/rpath/src/master/" rel="noopener ugc nofollow" target="_blank">https://bitbucket.org/freiburgmls/rpath/src/master/</a>，我的bitbucket工作区)。</p></div></div>    
</body>
</html>