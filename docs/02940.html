<html>
<head>
<title>Scala 3 Macros without Pain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala 3宏没有痛苦</h1>
<blockquote>原文：<a href="https://medium.com/codex/scala-3-macros-without-pain-ce54d116880a?source=collection_archive---------3-----------------------#2021-08-12">https://medium.com/codex/scala-3-macros-without-pain-ce54d116880a?source=collection_archive---------3-----------------------#2021-08-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0475" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">带示例的Scala 3宏介绍</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8a10e319e76e8181318a6b571d99e29e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kIfk8KKiORwnuMoDmRqY2w.jpeg"/></div></div></figure><p id="55e8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Scala 3引入了一种处理<em class="kf">宏</em>的新方法，以及其他不错的新特性。<em class="kf">宏</em>将代码视为数据，它们允许分析其结构并在编译时生成新代码。</p><p id="bfa7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这篇文章中，我将介绍Scala 3 <em class="kf">宏</em>的一些额外特性，并展示一个可以在<em class="kf">宏</em>的帮助下解决的简单用例——如何使用外部SQL模式生成编译时检查的预准备语句。我经常参考这个项目，并根据它的代码描述一些特性，所以我鼓励<a class="ae kg" href="https://github.com/plewand/scala3-macros" rel="noopener ugc nofollow" target="_blank">下载</a>它，但这不是必不可少的。</p><p id="475d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">该员额的范围是:</p><ul class=""><li id="16ed" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp bi translated">一个简短的词汇表，用于快速介绍后面使用的一些术语</li><li id="54ac" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><em class="kf">内联</em>代码和<em class="kf">类型匹配</em>——简短描述</li><li id="434f" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><em class="kf">宏</em>理解概念和创建演示示例所需的基础知识</li><li id="6141" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">示例项目的描述</li><li id="ac92" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">我遇到的经历和提示</li><li id="5639" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">有用资源的链接</li></ul><p id="2eb4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我认为一个理论在理论上是好的，所以概念和例子一起介绍，看看它们如何在实践中应用。然而，在开始时，我将在一个小词汇表中介绍一些概念。这些定义并不精确，它们应该只是给出一些关于概念的直觉。</p><h1 id="b295" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">一点词汇表</h1><ul class=""><li id="4e41" class="kh ki hi jl b jm ln jp lo js lp jw lq ka lr ke km kn ko kp bi translated"><em class="kf">宏</em> —编译器执行的一段代码。在<em class="kf">宏</em>中，可以分析并生成代码。如果<em class="kf">宏</em>需要使用<code class="du ls lt lu lv b">T</code>类型的表达式，则需要将其转换为<code class="du ls lt lu lv b">Expr[T]</code>——适用于<em class="kf">宏</em>的表示。这个过程叫做<em class="kf">报价</em>。在<em class="kf">拼接</em>的过程中，在<em class="kf">宏</em>中创建的输出代码表示被转换回并嵌入到程序中。</li><li id="6481" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><em class="kf">抽象语法树</em> <em class="kf"> (AST) </em> —表示代码语法结构的树。在这篇文章中，作为一个AST，我经常把它的Scala 3实现理解为抽象语法树。</li><li id="e382" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><em class="kf">引用</em> —将代码转换为表示其<em class="kf">类型化抽象语法树</em>的结构的过程。对于类型<code class="du ls lt lu lv b">T</code> <em class="kf">的表达式<code class="du ls lt lu lv b">e</code>，引用</em> <code class="du ls lt lu lv b">’{e}</code>给出其类型<code class="du ls lt lu lv b">Expr[T]</code>的表示。对于类型<code class="du ls lt lu lv b">T</code> <em class="kf">来说，引用</em>是自动完成的，并产生<code class="du ls lt lu lv b">Type.of[T]</code>——一种可以在<em class="kf">宏</em>中使用的类型表示。</li><li id="81db" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><em class="kf">拼接</em>——一个引用的双重过程——它评估一个<em class="kf">类型的AST </em>作为<em class="kf">宏</em>中生成的<code class="du ls lt lu lv b">Expr[T]</code>嵌入到封闭代码中。如果<code class="du ls lt lu lv b">e</code>是<code class="du ls lt lu lv b">Expr[T]</code>类型，拼接<code class="du ls lt lu lv b">${e}</code>将插入该<em class="kf"> AST </em>代表的<code class="du ls lt lu lv b">T</code>类型的代码。</li><li id="cfe3" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><em class="kf">引用表达式</em>—类型为<code class="du ls lt lu lv b">T</code>的表达式表示为<code class="du ls lt lu lv b">Expr[T] </code>，可在<em class="kf">宏</em>中分析。它是一种高级表示，在视觉上类似于常规代码。它允许分析和构建代码，而无需深入了解其内部表示，如<em class="kf">类型化的AST </em>。</li><li id="1d58" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><code class="du ls lt lu lv b">Type[T]</code>、<code class="du ls lt lu lv b">Type.of[T]</code>—可在宏中分析的T类型的非擦除表示。如果我们有一个类型为<code class="du ls lt lu lv b">T</code>的表达式，<code class="du ls lt lu lv b">Type.of[T]</code>是由编译器提供的。</li><li id="462b" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><em class="kf">术语</em>—在<em class="kf">反射模块</em>中定义的<code class="du ls lt lu lv b">Expr[T]</code>的低级<em class="kf">型AST </em>表示。对于<code class="du ls lt lu lv b">T</code>类型的<code class="du ls lt lu lv b">e</code>来说<code class="du ls lt lu lv b">Expr[T]</code>是它的高级表示。其项可用<code class="du ls lt lu lv b">asTerm</code>法求得。从<code class="du ls lt lu lv b">Term</code>派生出代表代码结构的特定类型(如<code class="du ls lt lu lv b">New</code>术语调用<code class="du ls lt lu lv b">new</code>，<code class="du ls lt lu lv b">Block</code>用于代码块)。</li><li id="d767" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><em class="kf">反射API </em> —提供对<em class="kf">类型AST访问的低级API。</em>位于<em class="kf">反射模块</em>中。</li><li id="1537" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><em class="kf">级别一致性</em>——一种保持<em class="kf">宏</em>生成的代码一致的方法。例如，不可能在结果代码中直接嵌入在<em class="kf">宏</em>中定义的变量，只能嵌入表示变量的表达式。</li><li id="39a1" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><em class="kf">内联</em> —将代码放在使用的地方，而不是它的引用。</li><li id="f426" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><em class="kf"> TASTy (Typed AST)y </em> —一种保存代码信息的格式，包括<em class="kf"> AST </em>、源位置、文档。它由<em class="kf"> scalac </em>编译器在编译期间产生的文件中使用(更多信息<a class="ae kg" href="https://docs.scala-lang.org/scala3/guides/tasty-overview.html" rel="noopener ugc nofollow" target="_blank">在此</a>)。</li><li id="98e6" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><em class="kf">符号</em> —每个定义，比如变量、方法或类型，都有一个<em class="kf">符号</em>与之相连。<em class="kf">符号</em>给出了一些关于底层定义的信息。当您需要在<em class="kf">宏</em>中创建一个新方法或变量，或者使用<em class="kf">反射API </em>实用函数时，它们也很有用。</li></ul><h1 id="a70a" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">在一条直线上的</h1><p id="faf6" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">Scala 3中的<em class="kf">内联</em>保证了<em class="kf">内联代码</em>会在使用的地方被扩展。</p><ul class=""><li id="e1d0" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp bi translated">对于方法，它们的主体将被插入到调用的位置。</li><li id="8c21" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">对于表达式，它们将在编译时计算。</li><li id="9097" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">对于方法参数，它们将被插入到使用的地方(注意作为<em class="kf">内联</em>参数传递的方法和副作用)。</li></ul><p id="c710" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看下面的例子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="6cad" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">输出将是:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="4518" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">函数体<code class="du ls lt lu lv b">f</code>在调用的地方被<em class="kf">内联</em>。主体的第一行包含<code class="du ls lt lu lv b">summonInline</code> —在函数被<em class="kf">内联</em>后，获取给定的<em class="kf">的实用程序(在<a class="ae kg" href="https://docs.scala-lang.org/scala3/reference/contextual/derivation.html" rel="noopener ugc nofollow" target="_blank">类型类派生</a>期间有用)——在<em class="kf">内联</em>后，它看到在调用位置定义的给定</em>的<em class="kf">。它的参数被插入到用法的位置，所以副作用是累积的。</em></p><p id="ea7b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">函数<code class="du ls lt lu lv b">g</code>是一个常规函数，<code class="du ls lt lu lv b"> summonInline</code>发生在它被定义的对象中，所以它看到<em class="kf">给</em>的值为“定义”。它的参数是由值给出的，所以副作用发生在传递它的过程中。</p><p id="514d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">更多信息<a class="ae kg" href="https://docs.scala-lang.org/scala3/guides/macros/inline.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h1 id="7bda" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">匹配类型</h1><p id="635d" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">这是Scala 3的一个新特性，它允许根据类型的右边来减少类型。</p><p id="7f84" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在示例程序中，它用于根据预准备语句的类型生成函数调用的类型。列的定义由类表示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="4532" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">问题是如何获得参数列表的类型来分配具有列定义的值，即<code class="du ls lt lu lv b">(Col[Int](“a”), Col[String](“b”))</code> get <code class="du ls lt lu lv b">(Int, String)</code>的<br/>。我们能<em class="kf">匹配类型</em>很幸运:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><ol class=""><li id="9123" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke mb kn ko kp bi translated">在这种情况下,<code class="du ls lt lu lv b">Tuple</code>被用来表示论点。</li><li id="7aec" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">对于空元组，空元组作为停止条件返回。</li><li id="452b" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">如果类型<code class="du ls lt lu lv b">ColDef[b]</code>匹配为元组头，则在匹配中提取<code class="du ls lt lu lv b">b</code>并用作新元组类型的头。之后，元组的其余部分被递归匹配。</li></ol><p id="6480" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">更多信息<a class="ae kg" href="https://docs.scala-lang.org/scala3/reference/new-types/match-types.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h1 id="e4f2" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">宏指令</h1><p id="b98b" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">在这一节中，我将通过例子介绍Scala 3宏的一些基本概念。</p><h2 id="4f40" class="mc kw hi bd kx md me mf lb mg mh mi lf js mj mk lh jw ml mm lj ka mn mo ll mp bi translated">行情</h2><p id="e22f" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">一个<em class="kf">引用</em>将一个<code class="du ls lt lu lv b">T</code>类型的表达式转换成其<em class="kf">类型的抽象语法树</em>的高级表示为<code class="du ls lt lu lv b">Expr[T]</code>。此外，它将类型<code class="du ls lt lu lv b">T</code>转换为<code class="du ls lt lu lv b">Type[T]</code>——一种在<em class="kf">宏</em>中使用的类型表示。</p><p id="af3c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">例如下面的表达式将生成函数调用的<code class="du ls lt lu lv b">Expr[Unit]</code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h2 id="74b9" class="mc kw hi bd kx md me mf lb mg mh mi lf js mj mk lh jw ml mm lj ka mn mo ll mp bi translated">插接</h2><p id="34d7" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated"><em class="kf">拼接</em>是与<em class="kf">报价相反的操作。</em>它评估并嵌入一个<em class="kf"> AST </em>到代码中。该示例出现在项目的<code class="du ls lt lu lv b">SimpleMacro.scala</code>中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><ol class=""><li id="7231" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke mb kn ko kp bi translated">对于<code class="du ls lt lu lv b">Expr[String]</code>类型的<code class="du ls lt lu lv b">str</code>，拼接<code class="du ls lt lu lv b">$str</code>将评估<em class="kf"> AST </em>以将其转换回代码，因为需要对其调用<code class="du ls lt lu lv b">toUpperCase</code>函数(该操作作用于代码结构，此处不执行任何调用)</li><li id="701c" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">然后将生成的<code class="du ls lt lu lv b">expr</code>嵌入到结果代码中。</li></ol><h2 id="7696" class="mc kw hi bd kx md me mf lb mg mh mi lf js mj mk lh jw ml mm lj ka mn mo ll mp bi translated">宏观结构</h2><p id="a422" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">让我们来看看一个简单宏的结构——它是一个打印一个<em class="kf"> AST </em>的实用程序，以后如何以及为什么要使用它。在项目中可以在<code class="du ls lt lu lv b">LogAST.scala</code>文件中找到。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><ol class=""><li id="89d5" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke mb kn ko kp bi translated">该导入需要与<em class="kf">宏</em>系统交互。</li><li id="a9ad" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">每个宏都有相似的结构:它有一个<em class="kf">内联的</em>入口点，调用它的实现。入口点有一个常规签名，在本例中是一个类型为<code class="du ls lt lu lv b">T</code>的表达式。然后引用参数将其转换为<code class="du ls lt lu lv b">Expr[T]</code>。转换后的表达式被传递给实现。实现产生了<code class="du ls lt lu lv b">Expr[T]</code>，所以需要拼接得到所需的<code class="du ls lt lu lv b">T</code>类型的表达式。为此，宏被插入到<em class="kf">拼接</em>中。</li><li id="7458" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">该实现对<em class="kf">宏</em>入口点的提升参数起作用。编译器自动提供提升到<code class="du ls lt lu lv b">Type[T]</code>和<code class="du ls lt lu lv b">Quotes</code>的<code class="du ls lt lu lv b">T</code>类型。当类型<code class="du ls lt lu lv b">T</code>将在后面引用<em class="kf">和</em>时，在上下文中需要<code class="du ls lt lu lv b">Type[T]</code>。在这个<em class="kf">宏</em>中，它仅用于打印关于表达式类型的信息。</li><li id="dd92" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">它是一个依赖的导入(在作用域中需要一个<code class="du ls lt lu lv b">Quotes</code>实例),并且允许使用<em class="kf">术语</em>——一个处理<em class="kf"> AST </em>的低级机制。</li><li id="d48e" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">得到<code class="du ls lt lu lv b">Expr[T]</code>的一个<em class="kf">项</em>。<em class="kf">术语</em>提供了一种以低级方式分析和构建<em class="kf"> AST </em>的方法。代码的每个构造都有一些表示，可以用来获取信息或创建信息(例如<code class="du ls lt lu lv b">Apply</code>表示一个函数调用)。</li><li id="9786" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">显示关于类型的信息—它隐式地使用了<code class="du ls lt lu lv b">T:Type</code>。<code class="du ls lt lu lv b">Type.of[T]</code>由编译器自动提供。</li><li id="9f9b" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">使用ANSI颜色打印结果代码。Scala <em class="kf">宏</em>系统有一些打印机帮助调试，并以不同的方式呈现信息。</li><li id="034c" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">打印出<em class="kf"> AST </em>结构，它是如何在低层次上被构建的。</li><li id="4b4f" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">返回表达式本身。得益于此，宏<em class="kf">可以透明地使用。</em></li></ol><p id="9767" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">示例—打印对象构造(<code class="du ls lt lu lv b">LogASTTest.scala</code>):</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="d07c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">输出:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="8f50" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在生产线(1)上可以看到<em class="kf"> AST </em>。这些元素是出现在<code class="du ls lt lu lv b">Quotes.scala</code>中的<em class="kf">术语</em>。代码中的每一个构造都有它的表示。可以使用这些元素手动构建结果代码(尽管通常<em class="kf">引用</em> / <em class="kf">拼接</em>更容易)或者在<em class="kf">模式匹配</em>中使用这些类型(后面是一个例子)。</p><p id="4977" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">宏<em class="kf">的逻辑</em>在编译时执行——调用<code class="du ls lt lu lv b">sbt compile</code>查看。</p><p id="ba01" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="kf">宏</em>在使用处被扩展，因此需要定义为<em class="kf">内嵌</em>。此外，为了获得传递给宏的参数的代码结构信息，参数需要被<em class="kf">内联</em>。</p><h2 id="bb1c" class="mc kw hi bd kx md me mf lb mg mh mi lf js mj mk lh jw ml mm lj ka mn mo ll mp bi translated">反射API</h2><p id="b14b" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">使用<em class="kf">引用</em>和<em class="kf">拼接</em>并不能实现所有事情。Scala 3 <em class="kf">宏</em>通过<code class="du ls lt lu lv b">quotes.reflect</code>模块中的API提供了对低级别<em class="kf">类型AST </em>的访问。表达式、类型表示、符号等都有定义的类型。他们被组织在一个等级结构中。让我们来看一段摘录，完整的结构记录在<code class="du ls lt lu lv b">Quotes.scala</code>中:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="1324" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">父级中定义的每个操作在子级中也可用。对于一个<code class="du ls lt lu lv b">term</code>，使用<code class="du ls lt lu lv b">term.show(using Printer.TreeStructure)</code>可以看到这些元素。例如，让我们看看<code class="du ls lt lu lv b">Ident</code>是如何组织的。这种类型代表一个带有名称标识符:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="5f73" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">它的父节点是<code class="du ls lt lu lv b">Ref</code>——引用的表示。每种类型都有一个模块，该模块具有构造实例和<code class="du ls lt lu lv b">unapply</code>的方法——在这种情况下，可以提取<em class="kf">模式中与</em>匹配的名称。<code class="du ls lt lu lv b">IdentMethods </code>包含可以在实例上执行的操作。</p><h2 id="ec02" class="mc kw hi bd kx md me mf lb mg mh mi lf js mj mk lh jw ml mm lj ka mn mo ll mp bi translated">标志</h2><p id="b62e" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated"><em class="kf">符号</em>存在于各种定义背后，需要配合多个<em class="kf">反射API </em>函数。下面是一个例子——它将生成一个新函数，在运行时打印关于<em class="kf">符号</em>所有者的信息。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><ol class=""><li id="6fa6" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke mb kn ko kp bi translated"><code class="du ls lt lu lv b">Symbol</code>包含几个有用的方法，<code class="du ls lt lu lv b">spliceOwner</code>返回包含当前<em class="kf">拼接上下文</em>的定义的<em class="kf">符号</em>。在本例中是<em class="kf">宏</em>。每个<em class="kf">符号</em>都有一个方法<code class="du ls lt lu lv b">owner</code>来获取其父<em class="kf">符号</em>。</li><li id="1b26" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">要创建一个新功能，就必须创建它的主体。可以用<em class="kf">引用</em>和拼接来创建，也可以用<em class="kf">反射模块</em>中提供的<em class="kf">型AST </em>元素来创建。</li><li id="a7d4" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">一个新函数是用另一个<code class="du ls lt lu lv b">Symbol</code>方法创建的，这个方法的名字叫<code class="du ls lt lu lv b">newMethod</code>。它接受应该定义的所有者<em class="kf">符号</em>，名称和签名描述。同样，可以用其他的<code class="du ls lt lu lv b">Symbol</code>方法创建变量，也可以得到与类相关的<em class="kf">符号</em>。</li><li id="61d3" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated"><code class="du ls lt lu lv b">DefDef</code>代表<em class="kf"> AST中的功能定义。</em>它需要绑定到为新方法创建的<em class="kf">符号</em>。</li><li id="811c" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">定义必须嵌入到某个可以计算为表达式的<em class="kf">术语</em>中(<em class="kf">术语</em>有<code class="du ls lt lu lv b">isExpr</code>方法来检查它)。它的结构是通过用<code class="du ls lt lu lv b">logAST </code>助手打印空函数定义的<em class="kf"> AST </em>得到的。</li></ol><h1 id="8232" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">示例问题—安全的预准备语句</h1><p id="c7eb" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">在这一节中，我将展示一个示例问题，以及如何使用类型匹配支持的Scala 3 <em class="kf">宏</em>来解决这个问题。</p><p id="5255" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">假设我们必须解决以下限制/要求:</p><ul class=""><li id="918f" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp bi translated">数据库访问库在运行时检查查询中使用的数据，可能会传递不正确的数据类型。</li><li id="8bda" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">SQL模式保存在一个单独的文件中，以便于DB团队使用。</li><li id="ad04" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">代码在更改时应该与模式保持一致。</li><li id="dcf7" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">应该尽快检测出所有的模式不匹配。</li><li id="7731" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">可以用Scala 3甚至<em class="kf">宏</em>。</li></ul><p id="f7f6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们看看Scala 3的特性如何帮助解决这个问题:</p><ul class=""><li id="437c" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp bi translated">创建一个不安全语句的包装器，防止使用无效的数据类型— <em class="kf">类型匹配</em>。</li><li id="d293" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">一个知识来源——模式可以留在文件中。模式在编译时被读取，并根据它检查调用— <em class="kf">宏</em>。</li><li id="2d69" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">安全预准备语句在<em class="kf">宏</em>中生成，并用模式<em class="kf">宏</em>进行验证。</li><li id="8821" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">任何名称或类型不匹配都会在编译时报告— <em class="kf">宏展开</em>。</li></ul><h2 id="8780" class="mc kw hi bd kx md me mf lb mg mh mi lf js mj mk lh jw ml mm lj ka mn mo ll mp bi translated">(计划或理论的)纲要</h2><p id="d115" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">这个例子中的模式非常简单。它保存在<code class="du ls lt lu lv b">sql/schema.sql</code>文件中:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h2 id="9655" class="mc kw hi bd kx md me mf lb mg mh mi lf js mj mk lh jw ml mm lj ka mn mo ll mp bi translated">宏用法</h2><p id="f0fd" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">只需要从应用程序代码中调用它来生成一个安全的预准备语句:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><ol class=""><li id="44b9" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke mb kn ko kp bi translated">对带有参数的<em class="kf">宏</em>的调用:作为<em class="kf">字符串</em>的表名和作为<em class="kf">元组</em>的列定义(它是未包装的，所以看起来像一个常规调用)。注意，所有的参数都需要在编译时知道，因此<em class="kf">字符串</em>是常量。如果没有编译错误发生，这意味着给定的参数是有效的，并且与SQL模式一致。</li><li id="7d7a" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">调用生成的代码。类型已检查。</li></ol><h2 id="24e2" class="mc kw hi bd kx md me mf lb mg mh mi lf js mj mk lh jw ml mm lj ka mn mo ll mp bi translated">宏入口点</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><ol class=""><li id="cc15" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke mb kn ko kp bi translated">引入一个辅助函数是因为<em class="kf">内联的</em>入口点需要一次调用。</li><li id="e95b" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">由于<em class="kf">宏</em>有更多的逻辑，它被保存在一个<em class="kf">类</em>中。它的构造函数捕获参数中传递的<em class="kf">引号</em>。</li><li id="38a5" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated"><code class="du ls lt lu lv b">CallArgs[A]</code>用于构造与<em class="kf">类型匹配</em>的返回类型。</li><li id="31bb" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">为了简化处理，表名和列定义被分成两个参数。</li></ol><h2 id="d365" class="mc kw hi bd kx md me mf lb mg mh mi lf js mj mk lh jw ml mm lj ka mn mo ll mp bi translated">宏构造函数</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="efbe" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这里有趣的是一个<code class="du ls lt lu lv b">Quotes</code>实例(1)和依赖导入(2)，它们在<em class="kf">宏</em>的所有函数之间共享。</p><h2 id="7aab" class="mc kw hi bd kx md me mf lb mg mh mi lf js mj mk lh jw ml mm lj ka mn mo ll mp bi translated">主流</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><ol class=""><li id="113d" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke mb kn ko kp bi translated">这个函数是从入口点调用的(带有一个辅助函数)。注意，不需要<em class="kf">引号</em>，因为它在类的构造函数中是可见的。</li><li id="437b" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">可以获得传递给宏<em class="kf"/>“call”的值，但是它们必须在编译时可用。在这种情况下，表名被假定为常量<em class="kf">字符串</em>，因此我们可以访问它。如果表达式不能在编译时求值，函数<code class="du ls lt lu lv b">valueOrError</code>将报告一个编译错误。</li><li id="c09a" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated"><code class="du ls lt lu lv b">parseColumnInfo</code>是编译时执行的函数。它接受一个<em class="kf">术语</em>(一个<em class="kf"> AST </em>的非类型化表示，比<code class="du ls lt lu lv b">Expr</code>有更多的方法可以调用)作为参数。</li><li id="2447" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">如果解析成功，那么将解析的参数与从SQL脚本中读取的模式进行比较。</li><li id="d1cc" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">SQL命令构建为<code class="du ls lt lu lv b">String</code>。要在返回的代码中使用它，需要从它创建一个表达式。通过将它包含在<code class="du ls lt lu lv b">Expr(…)</code>中来完成。</li><li id="32cd" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">最后一部分是生成代码以创建预准备语句。注意一件重要的事情——<code class="du ls lt lu lv b">UsafeStatement($sql)</code>将生成的<code class="du ls lt lu lv b">Expr[String]</code>类型的<code class="du ls lt lu lv b">sql</code>嵌入到<em class="kf">宏</em>中，生成引用的代码。它将作为<em class="kf">字符串</em>嵌入到最终代码中。</li></ol><h2 id="5c7a" class="mc kw hi bd kx md me mf lb mg mh mi lf js mj mk lh jw ml mm lj ka mn mo ll mp bi translated">反射API —解析宏参数</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><ol class=""><li id="1094" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke mb kn ko kp bi translated">该函数接受转换为<code class="du ls lt lu lv b">Term</code>的<code class="du ls lt lu lv b">Expr</code>。</li><li id="15b9" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">该表达式与使用<em class="kf">反射API </em>提取<code class="du ls lt lu lv b">columnDefs</code>——传递给<em class="kf">宏</em>的参数相匹配。要匹配的结构是使用<code class="du ls lt lu lv b">logAST</code>助手获得的。打印代码的内部结构可以快速找到可以从中提取什么和如何提取，以及我们应该在<code class="du ls lt lu lv b">Quotes.scala</code>中搜索什么。</li><li id="f9b3" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">每个列定义<em class="kf">术语</em>在一个单独的函数中被解析。</li><li id="0738" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">如果<em class="kf">宏</em>遇到未知的代码结构，内置的报告实用程序会报告编译错误。</li></ol><h2 id="e0ba" class="mc kw hi bd kx md me mf lb mg mh mi lf js mj mk lh jw ml mm lj ka mn mo ll mp bi translated">引用模式—解析列定义</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><ol class=""><li id="d44a" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke mb kn ko kp bi translated">为了使用<em class="kf">引用的模式匹配</em>,<code class="du ls lt lu lv b">Term</code>被转换回<code class="du ls lt lu lv b">Expr</code>。如果不是<code class="du ls lt lu lv b">ColDef[_]</code>，则报告编译错误。</li><li id="53bd" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">如果<em class="kf">引用表达式</em>匹配，则检查该表达式是否与<em class="kf">案例</em>中给出的<em class="kf">引用表达式</em>等价。该模式可用于提取要在匹配用例中使用的表达式的类型和部分。在这种情况下，提取作为<em class="kf">宏</em>的参数给出的<code class="du ls lt lu lv b">ColDef </code>构造中使用的类型和表达式。换句话说，代码的结构用于在编译时生成一些逻辑，不执行运行时的<code class="du ls lt lu lv b">ColDef</code>构造。</li><li id="16e1" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">获得<code class="du ls lt lu lv b">TypeRepr</code>来构造列定义。<code class="du ls lt lu lv b">TypeRepr </code>允许获取关于类型的一些信息，比<code class="du ls lt lu lv b">Type[T]</code>更多。</li><li id="31b7" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">由于<code class="du ls lt lu lv b">ColDef</code>的构造函数参数是一个列名，并且需要在编译类型上可用<code class="du ls lt lu lv b">valueOrError</code>才能使用。如果在编译时无法计算该值，它将报告编译错误。</li><li id="0939" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">报告未知表达式的错误。</li></ol><h2 id="f8f3" class="mc kw hi bd kx md me mf lb mg mh mi lf js mj mk lh jw ml mm lj ka mn mo ll mp bi translated">报价类型模式匹配-列类型</h2><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lz ma l"/></div></figure><ol class=""><li id="7f09" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke mb kn ko kp bi translated"><code class="du ls lt lu lv b">Type[T]</code>可用于<em class="kf">模式匹配</em>，需要与<code class="du ls lt lu lv b">’[S]</code>匹配，其中<code class="du ls lt lu lv b">S</code>为显式类型或捕获。</li><li id="4e25" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke mb kn ko kp bi translated">小写值被捕获并可在案例中使用。</li></ol><h1 id="75bd" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">如何使用宏</h1><p id="4f5f" class="pw-post-body-paragraph jj jk hi jl b jm ln ij jo jp lo im jr js lw ju jv jw lx jy jz ka ly kc kd ke hb bi translated">这一节包含了对使用<em class="kf">宏</em>的方法的描述(很多是基于我在最后包含的博客)，一些技巧和我遇到的问题。</p><ul class=""><li id="52b6" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp bi translated">打印代码的<em class="kf">AST</em>(<code class="du ls lt lu lv b">logAST</code>helper)来查看应该生成或分析什么是使用<em class="kf">宏</em>代码的一种非常有用的方法。</li><li id="99f1" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">识别完<code class="du ls lt lu lv b">AST</code>的零件后，查看<code class="du ls lt lu lv b">Quotes.scala</code>中所需的元素。有些<em class="kf">术语</em>包含更多功能，有些则更少。还要检查<code class="du ls lt lu lv b">unapply</code>在<em class="kf">模式匹配</em>中可以提取什么。</li><li id="b0d3" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">有些表达式用匹配的<em class="kf">引号更方便匹配(例子中是单个参数)，有些使用<em class="kf">反射API </em>(例子中是参数提取)。</em></li><li id="f6c8" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">在<em class="kf">宏</em>类构造函数中使用公共<code class="du ls lt lu lv b">Quotes</code>实例是在方法间共享它的一种便捷方式。</li><li id="9cdb" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">在<em class="kf">反射模块</em>的<code class="du ls lt lu lv b">Quotes.scala</code>中，有几个实用函数可以帮助处理树，例如<code class="du ls lt lu lv b">TreeAccumulator</code>，</li><li id="b541" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><em class="kf">具有<em class="kf"> Metals </em>扩展的Visual Studio代码</em>在编写时比<em class="kf"> IntelliJ </em>插件工作得更好。</li></ul><h1 id="fb79" class="kv kw hi bd kx ky kz la lb lc ld le lf io lg ip lh ir li is lj iu lk iv ll lm bi translated">摘要</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/70188dd9fce3dc50970d7e64be069895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RavBi5MlVUg0CDOppXpvPw.jpeg"/></div></div></figure><p id="7a0e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">恭喜你，你到了帖子的末尾！感谢阅读或浏览，我希望你已经找到有用的东西。涵盖的主题只是介绍，还有很多可以尝试的。下面我列出了一些我认为有用的资源:</p><ul class=""><li id="3dde" class="kh ki hi jl b jm jn jp jq js kj jw kk ka kl ke km kn ko kp bi translated"><a class="ae kg" href="https://docs.scala-lang.org/scala3/reference/metaprogramming.html" rel="noopener ugc nofollow" target="_blank">元编程参考</a></li><li id="e18f" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><a class="ae kg" href="https://docs.scala-lang.org/scala3/guides/macros/macros.html" rel="noopener ugc nofollow" target="_blank"> Scala 3宏指南</a></li><li id="6618" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><a class="ae kg" href="https://scala-lang.org/api/3.x/scala/quoted/Quotes$reflectModule.html" rel="noopener ugc nofollow" target="_blank">报价文件</a></li><li id="1722" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated">非常好看的博客:<br/> 1。<a class="ae kg" href="https://blog.softwaremill.com/starting-with-scala-3-macros-a-short-tutorial-88e9d2b2584c" rel="noopener ugc nofollow" target="_blank">https://blog . software mill . com/starting-with-Scala-3-macros-a-short-tutorial-88e 9 D2 b 2584 c</a><br/>2 .<a class="ae kg" href="https://softwaremill.com/scala-3-macros-tips-and-tricks/" rel="noopener ugc nofollow" target="_blank">https://softwaremill.com/scala-3-macros-tips-and-tricks/</a>T29】3。<a class="ae kg" rel="noopener" href="/virtuslab/tasty-way-of-re-writing-macros-in-scala-3-3ce704a2c37c">https://medium . com/virtuslab/tasty-way-of-re-writing-macros-in-Scala-3-3c e 704 a2 c37c</a></li><li id="7098" class="kh ki hi jl b jm kq jp kr js ks jw kt ka ku ke km kn ko kp bi translated"><a class="ae kg" href="https://github.com/lampepfl/dotty-macro-examples" rel="noopener ugc nofollow" target="_blank">带有宏示例的储存库</a></li></ul><p id="2b3a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">项目的存储库可以在<a class="ae kg" href="https://github.com/plewand/scala3-macros" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>