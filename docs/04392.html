<html>
<head>
<title>Short-Circuiting in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的短路</h1>
<blockquote>原文：<a href="https://medium.com/codex/short-circuiting-in-javascript-cbe15b5bb2c?source=collection_archive---------7-----------------------#2021-11-27">https://medium.com/codex/short-circuiting-in-javascript-cbe15b5bb2c?source=collection_archive---------7-----------------------#2021-11-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fe548bc89054a049d88413e7f693ec80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VuqUH9S2si5ZXDGEPn84lQ.jpeg"/></div></div></figure><p id="744e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在JavaScript中，<strong class="is hj">短路是指表达式的部分求值，以避免不必要的计算</strong>。这篇博文描述了JavaScript中的短路操作符和赋值，以及如何使用它们。</p><h1 id="2120" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">短路运算符:&amp;&amp;、||、和？？</h1><p id="55d9" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">短路运算符仅在必要时计算表达式的右侧。</p><p id="e19b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">比如对于逻辑AND运算符<code class="du kr ks kt ku b">&amp;&amp;</code>，当左边的运算符为false时，右边的运算符不会改变结果。不管右边是真还是假，结果都是假的。因此JavaScript跳过右边的计算，使用左边的值。</p><p id="b68a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">JavaScript中有三种短路二元运算符:</p><ul class=""><li id="4707" class="kv kw hi is b it iu ix iy jb kx jf ky jj kz jn la lb lc ld bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">逻辑与</strong> </a> ( <code class="du kr ks kt ku b">A &amp;&amp; B</code> ): <code class="du kr ks kt ku b">B</code>只有在<code class="du kr ks kt ku b">A</code>为<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy" rel="noopener ugc nofollow" target="_blank">真值</a>时才被求值。</li><li id="ce23" class="kv kw hi is b it lf ix lg jb lh jf li jj lj jn la lb lc ld bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">逻辑或</strong> </a> ( <code class="du kr ks kt ku b">A || B</code> ): <code class="du kr ks kt ku b">B</code>只有在<code class="du kr ks kt ku b">A</code>为<a class="ae le" href="https://developer.mozilla.org/en-US/docsGlossary/Falsy" rel="noopener ugc nofollow" target="_blank"> falsy </a>时才求值。</li><li id="cc76" class="kv kw hi is b it lf ix lg jb lh jf li jj lj jn la lb lc ld bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">无效合并</strong> </a> ( <code class="du kr ks kt ku b">A ?? B</code> ): <code class="du kr ks kt ku b">B</code>只有在<code class="du kr ks kt ku b">A</code>为<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Glossary/Nullish" rel="noopener ugc nofollow" target="_blank">无效</a>时才被求值。</li></ul><p id="d9b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kr ks kt ku b">A</code>和<code class="du kr ks kt ku b">B</code>可以是任何表达式。它们的评估可能会调用包含复杂计算或有副作用的函数和getter调用。<br/>因为<code class="du kr ks kt ku b">A</code>和<code class="du kr ks kt ku b">B</code>可以返回任何值，所以这三个短路运算符计算并返回任何值，而不仅仅是布尔值。</p><p id="cdf4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着您可以使用短路操作符用于提供默认值 ( <code class="du kr ks kt ku b">||</code>和<code class="du kr ks kt ku b">??</code>)的<strong class="is hj">，用于检查空值(<code class="du kr ks kt ku b">&amp;&amp;</code>，在可选链接操作符<code class="du kr ks kt ku b">?.</code>可用之前)，以及用于React </strong>  ( <code class="du kr ks kt ku b">&amp;&amp;</code>)中的<a class="ae le" href="https://reactjs.org/docs/conditional-rendering.html#inline-if-with-logical--operator" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">条件渲染。</strong></a></p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="f50b" class="ls jp hi ku b fi lt lu l lv lw">// default values<br/>a = a || 123; // assigns 123 to a if a is falsy<br/>b = b ?? 123; // assigns 123 to b if b is nullish</span><span id="d3d1" class="ls jp hi ku b fi lx lu l lv lw">// optional chaining with &amp;&amp; ( .? is a modern alterative)<br/>if (obj.m != null &amp;&amp; obj.m() === '123') {<br/>   // ...<br/>}</span><span id="cd6b" class="ls jp hi ku b fi lx lu l lv lw">// React: conditional rendering<br/>return &lt;&gt;  <br/>  {user != null &amp;&amp;<br/>    &lt;div&gt;Welcome back, ${user.name}!&lt;/div&gt;<br/>  }<br/>&lt;&gt;;</span></pre><h1 id="0906" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">短路赋值:&amp;&amp;=，||=，和？？=</h1><p id="4519" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated"><strong class="is hj">用</strong><a class="ae le" href="https://h3manth.com/ES2021/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">es 2021</strong></a><strong class="is hj">可以在赋值表达式</strong> ( <code class="du kr ks kt ku b">&amp;&amp;=</code>、<code class="du kr ks kt ku b">||=</code>、<code class="du kr ks kt ku b">??=</code>)中使用短路运算符。仅当当前变量或属性值不触发短路时，才会执行短路赋值。这种行为有助于避免不必要的更新。</p><p id="007d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一个例子(<code class="du kr ks kt ku b">-Infinity</code>是<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy" rel="noopener ugc nofollow" target="_blank">真理性</a>):</p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="8618" class="ls jp hi ku b fi lt lu l lv lw">let a = 3;<br/>let b = 3;<br/>let c = 0;<br/>let d = 0;</span><span id="37e1" class="ls jp hi ku b fi lx lu l lv lw">a &amp;&amp;= -Infinity;<br/>b ||= -Infinity;<br/>c &amp;&amp;= -Infinity;<br/>d ||= -Infinity;</span><span id="854c" class="ls jp hi ku b fi lx lu l lv lw">console.log(a); // -Infinity<br/>console.log(b); // 3 (short-circuiting ||, because 3 is truthy)<br/>console.log(c); // 0 (short-circuiting &amp;&amp;, because 0 is falsy)<br/>console.log(d); // -Infinity</span></pre><h1 id="1d1f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">用短路运算符重构赋值</h1><p id="e476" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">短路赋值看起来非常类似于带有短路操作符表达式的常规赋值。有人可能会认为，它们可以在不改变行为的情况下进行如下重构:</p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="ff5a" class="ls jp hi ku b fi lt lu l lv lw">a = a &amp;&amp; x; /* becomes */ a &amp;&amp;= x;<br/>a = a || x; /* becomes */ a ||= x;<br/>a = a ?? x; /* becomes */ a ??= x;</span></pre><p id="a802" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，当我为<a class="ae le" href="https://p42.ai/" rel="noopener ugc nofollow" target="_blank"> P42 </a>中的<br/>’<a class="ae le" href="https://p42.ai/documentation/code-action/push-operator-into-assignment" rel="noopener ugc nofollow" target="_blank">将操作员推入任务</a>和<a class="ae le" href="https://p42.ai/documentation/code-action/pull-operator-out-of-assignment" rel="noopener ugc nofollow" target="_blank">将操作员拉出任务</a>重构开发安全评估时，我发现这些重构在某些情况下会导致行为变化。</p><p id="ff4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑下面的例子:</p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="e12c" class="ls jp hi ku b fi lt lu l lv lw">class C {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="5277" class="ls jp hi ku b fi lx lu l lv lw">  get x() {<br/>    return this._x;<br/>  }</span><span id="7aa5" class="ls jp hi ku b fi lx lu l lv lw">  set x(value) {<br/>    console.log(`set ${this.name}.x to ${value}`);<br/>    this._x = value;<br/>  }<br/>}</span><span id="9346" class="ls jp hi ku b fi lx lu l lv lw">// nullish coalescing operator<br/>const a = new C("a");<br/>a.x = a.x ?? 3;<br/>a.x = a.x ?? 4;<br/>console.log(a.x)</span><span id="569c" class="ls jp hi ku b fi lx lu l lv lw">// nullish assignment <br/>const b = new C("b");<br/>b.x ??= 3;<br/>b.x ??= 4;<br/>console.log(b.x)</span></pre><p id="0b64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">令人惊讶的是，将操作员移动到分配中会改变要执行的操作:</p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="f9a2" class="ls jp hi ku b fi lt lu l lv lw">// output for nullish coalescing operator<br/>"set a.x to 3"<br/>"set a.x to 3"<br/>3</span><span id="169e" class="ls jp hi ku b fi lx lu l lv lw">// output for nullish assignment <br/>"set b.x to 3"<br/>3</span></pre><p id="af45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然这些微小的差异在大多数时候并不重要，但出于两个原因，意识到这些差异是有好处的:</p><ul class=""><li id="cb22" class="kv kw hi is b it iu ix iy jb kx jf ky jj kz jn la lb lc ld bi translated">它们会在重构过程中导致崩溃，因为它们会改变现有的行为</li><li id="7129" class="kv kw hi is b it lf ix lg jb lh jf li jj lj jn la lb lc ld bi translated">它们有利于减少性能热点中的操作数量</li></ul><h1 id="94fe" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">摘要</h1><p id="e26b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">JavaScript中的短路操作符(<code class="du kr ks kt ku b">&amp;&amp;</code>、<code class="du kr ks kt ku b">||</code>、<code class="du kr ks kt ku b">??</code>)只在必要时才计算它们右边的表达式。它们的赋值等价物(<code class="du kr ks kt ku b">&amp;&amp;=</code>、<code class="du kr ks kt ku b">||=</code>、<code class="du kr ks kt ku b">??=</code>)仅在当前值将<br/>导致短路操作符右侧的执行时更新一个值。</p></div></div>    
</body>
</html>