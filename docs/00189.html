<html>
<head>
<title>Scaling Database With EclipseLink And Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用EclipseLink和Redis扩展数据库</h1>
<blockquote>原文：<a href="https://medium.com/codex/scaling-your-database-with-eclipselink-and-redis-d8a6c809a155?source=collection_archive---------3-----------------------#2021-01-03">https://medium.com/codex/scaling-your-database-with-eclipselink-and-redis-d8a6c809a155?source=collection_archive---------3-----------------------#2021-01-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="8503" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">概述</strong></h1><p id="85a9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj"> EclipseLink </strong>有两种类型的缓存:共享缓存(L2)维护从数据库读取的对象，隔离缓存(L1)保存事务生命周期中各种操作的对象。L2生命周期与特定的JVM相关联，并且跨越多个事务。默认情况下，不同JVM之间的缓存协调是关闭的。EclipseLink提供了一个分布式缓存协调特性，您可以启用它来确保分布式应用程序中的数据保持最新。L1和L2缓存都存储域对象。</p><p id="b23c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">“Redis</strong>是一个开源的(BSD许可的)、内存中的数据结构存储，用作数据库、缓存和消息代理。Redis提供数据结构，如字符串、哈希、列表、集合、带有范围查询的排序集合、位图、超级日志、地理空间索引和流。— <strong class="jf hj"> redis.io </strong></p><p id="a16c" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这篇文章是关于EclipseLink和Redis的，但是这个概念可以应用于任何ORM和分布式缓存库。</p><h1 id="5e1d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">挑战</strong></h1><p id="1d64" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">与Hibernate对L2与Redis集成的现成支持不同，EclipseLink没有像L2与分布式缓存集成那样的等效支持。</p><p id="32b1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">EclipseLink确实为CacheInterceptor类提供了几个API，从理论上讲，开发人员可以实现这些API来拦截EclipseLink缓存上的各种操作。不幸的是，这些API没有很好的文档记录，并且不容易实现，所以您还没有看到任何支持EclipseLink L2与Redis集成的开源库。</p><h1 id="6887" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">解决方案</strong></h1><p id="cd1f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">好消息是，有一种比通过CacheInterceptor接口更容易、更简单的方法来集成EclipseLink和Redis。这种方法使用缓存备用模式来读取数据，并将<em class="kg">数据库记录</em>存储为缓存条目。我们已经在Intuit for QuickBook Online Payroll的生产中使用这种方法来帮助扩展我们的数据库并提高应用程序性能。这是一个巨大的成功。</p><p id="b1f6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">缓存备用</strong></p><ol class=""><li id="aed6" class="kh ki hi jf b jg kb jk kc jo kj js kk jw kl ka km kn ko kp bi translated">当您的应用程序需要从数据库中读取数据时，它将首先检查Redis (L3)以查看数据是否可用</li><li id="ce88" class="kh ki hi jf b jg kq jk kr jo ks js kt jw ku ka km kn ko kp bi translated">如果数据可用(缓存命中)，则返回缓存的数据</li><li id="c5b7" class="kh ki hi jf b jg kq jk kr jo ks js kt jw ku ka km kn ko kp bi translated">如果数据不是(缓存未命中)，则向数据库查询数据。将填充缓存并将数据返回给调用者</li></ol><p id="2b50" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">数据库记录</strong></p><p id="6bdb" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">DatabaseRecord是EclipseLink中的一个对象，它将数据库行表示为字段值对。DatabaseRecord向一个或多个域对象提供数据。EclipseLink有从DatabaseRecord构建域对象的API。</p><p id="3a2e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">L2缓存使用域对象。使用DatabaseRecord作为缓存条目极大地简化了实现，因为我们不必担心维护域对象关系。主键可以与域类名一起使用来创建缓存的键。在概念层面上，DatabaseRecord类似于数据库表行。重要的一点是，这种方法缓存的是数据，而不是对象树。</p><p id="9b31" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">这里是概念性的读取流程</strong></p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/0158927ecc9892e5e833b7faeb404fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XVVfj_AtLHszS9AR-3lQ3A.jpeg"/></div></div></figure><p id="6dd7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于实现，我们使用AspectJ组合来挂钩EclipseLink生命周期，以拦截填充和失效缓存的读/写操作</p><h1 id="a9af" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">说够了，给我看看代码</strong></h1><p id="a7fc" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">【DatabaseRecordAspect.java<strong class="jf hj">:这个类将拦截EclipseLink使用的selectOneRow和selectAllRows方法来读取一个对象和一个对象集合</strong></p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="6d75" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">DatabaseRecordInterceptor.java</strong>:负责在结果转化为EclipseLink对象之前，拦截expressionquerymechanism . selectonerow()和expressionquerymechanism . selectall rows()来缓存DatabaseRecord。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="dade" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于缓存失效，您只需要向DescriptorEventAdapter注册您的失效器，并实现postUpdate()、postDelete()和postInsert()。当EclipseLink写入发生时，这些方法中的一个将被执行，您可以调用失效器来删除/更新Redis中的缓存条目。您应该异步填充缓存和使缓存失效，以避免阻塞应用程序。</p><p id="57b6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我们使用莴苣作为客户端库来与Redis和Kryo进行序列化对话</p><h1 id="5957" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">结论</strong></h1><p id="6161" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果缓存用于填充域对象的数据，那么将EclipseLink与Redis集成会容易得多。最初，我们试图缓存域对象，但是遇到了EclipseLink的几个问题。域对象维护与其他对象的关联。当您从Redis读回对象时，您必须重建对象树。当对象之间存在延迟加载关联时，这就变得复杂了。数据缓存很简单，缓存条目大小是一致的(即一个数据库行)。可预测的缓存条目大小有助于我们优化Redis缓存大小，并使序列化和反序列化更快。您不必对现有的代码做太多的修改就可以让它工作。在减少数据库负载和提供一致的性能方面，这对我们来说是一个真正的游戏规则改变者。</p></div></div>    
</body>
</html>