<html>
<head>
<title>Intro To Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker简介</h1>
<blockquote>原文：<a href="https://medium.com/codex/intro-to-docker-647dbb1aee14?source=collection_archive---------12-----------------------#2021-07-22">https://medium.com/codex/intro-to-docker-647dbb1aee14?source=collection_archive---------12-----------------------#2021-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1ba6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">抽象地学习系统设计是一项具有挑战性的任务，尤其是对于早期职业软件工程师。当然，对我来说，我很难理解微服务和负载平衡器等功能在生产中是什么样的，快速搜索行业实践导致了一个非常熟悉的困惑，这些困惑是由范围太大以至于我无法消化的工具引起的。幸运的是，一位从事软件工程的朋友向我推荐了Docker，这是一个非常容易使用的工具，即使对于像我这样的新手来说也是如此。这篇文章将提供Docker是什么的介绍性概述，并希望吸引您也花一些时间学习它！</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es jk"><img src="../Images/2b8b6b394c29deac5ac5db9397d0d0fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*MPiiW88TgBCs1wGUK6n-IA.png"/></div></figure><h1 id="1b93" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">Docker是什么，为什么？</strong></h1><p id="b274" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">Windows用户可能对虚拟机(VM)很熟悉，虚拟机是一种行为类似于计算机的文件系统，允许Windows用户运行只能在Linux或MacOS等其他操作系统上运行的程序。您还可以运行Windows虚拟机来保存同一操作系统的不同配置/版本。虚拟机打包了所有东西，包括代码、系统工具、库等——这被称为软件的“容器化”。每次运行虚拟机时，您都会运行整个客户操作系统和整个应用程序，如果您只想运行单个应用程序，这会占用过多的空间。</p><p id="22b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相比之下，Docker使用“容器”,这些容器在主机操作系统上作为独立的进程运行，但共享机器的内核。可以说容器共享相同的模板，但是在完全隔离的环境中运行。本质上，Docker抓住了虚拟机的效用，但效率更高，占用空间更少。Docker容器可以在任何计算机或任何基础设施以及任何云中运行。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kv"><img src="../Images/c1cf3b661c8f39f31eb9ec8f20e45733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TILFPrsgvGe0lMQJ"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">容器和虚拟机的比较</figcaption></figure><p id="f236" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个容器中操作系统的省略意味着Docker容器是难以置信的轻量级。您可以运行多个容器，而不会过度消耗内存和处理能力。因为Docker容器包装了所有必需的依赖项，所以它们总是以相同的方式运行，这在您的程序需要特定版本的依赖项时非常有利。换句话说，如果它能在你的电脑上工作，它也能在你朋友的电脑上工作。</p><p id="490c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有没有一个看起来可以用Docker执行的系统设计方案？微服务是可独立部署的小型模块化服务。与整体应用相比，微服务可以轻松地进行水平扩展，并允许团队处理和部署应用的不同部分，而无需重新启动或破坏整个应用。Docker容器非常适合微服务架构的执行，因为它们将应用程序分解到单独的容器中。此外，容器可以在Docker中轻松地相互通信，解决了构建微服务的主要障碍之一。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="b48d" class="js jt hi bd ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp bi translated"><strong class="ak">码头工人图像</strong></h1><p id="bb9c" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">现在，我们可以详细说明初始化一个工作Docker应用程序所需的特定组件。如果此时你还没有安装Docker，去Docker的网站<a class="ae lj" href="https://www.docker.com/products" rel="noopener ugc nofollow" target="_blank">下载适合你的操作系统的版本。</a></p><p id="25b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经谈到了Docker容器，现在我们将转向Docker图像。根据Docker docs，图像是“一个惰性的、不可变的文件，本质上是一个容器的快照。”它们是包含构建容器的指令的文件，类似于模板。容器又是映像的“克隆”或运行实例。</p><p id="10c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Docker有<a class="ae lj" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">一个名为DockerHub的库</a>(想想GitHub，不过是针对Docker图片的)包含了人们可以拉取和使用的常用图片(node、postgreSQL、mongoDB、NGINX)。例如，您可以使用命令<code class="du lk ll lm ln b">docker pull postgres</code>提取postgreSQL图像，如果您<code class="du lk ll lm ln b">docker run</code>了一个本地不存在的图像，Docker将自动检查DockerHub是否存在并提取该图像。</p><p id="aab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，你也可以建立自己的形象。图像是在DockerFile中构建的，docker file是一个文本文档，包含在命令行上运行的所有命令，用于构建图像。它实际上是连续运行命令。一个重要的注意事项是DockerFile必须与package.json文件存在于同一个文件路径中，以便访问相关的脚本来构建和启动您的应用程序。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div class="er es lo"><img src="../Images/ecb09ee6b8695b52810ffc499a13c098.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*LJzie_L5YfvvjZiUDllI8w.png"/></div><figcaption class="la lb et er es lc ld bd b be z dx translated">样本文档</figcaption></figure><p id="ecca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有许多不同的方式与Docker及其所有组件进行交互。这些工具中最强大的是Docker的命令行界面(CLI)。</p><blockquote class="lp lq lr"><p id="108f" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated">这里有一些使用Docker CLI的有用的Docker命令:</p><p id="c027" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker images</code>向您展示缓存在您机器上的图像</p><p id="8804" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker info</code>显示关于Docker安装的系统范围信息</p><p id="13c8" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker run &lt;image_name&gt;</code>运行指定的图像</p><p id="a8eb" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker build &lt;image_name&gt;</code>运行DockerFile中列出的命令，创建具有特定文件系统的映像</p><p id="4a43" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker pull &lt;image_name&gt;:&lt;version&gt;</code>从DockerHub中提取指定版本的特定图像</p><p id="4687" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker rmi &lt;image_name&gt;</code>从缓存中删除图像</p></blockquote></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="aa8d" class="js jt hi bd ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp bi translated"><strong class="ak">码头集装箱</strong></h1><p id="535d" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">Docker将容器定义为“应用程序层的抽象，将代码和依赖项打包在一起。”通常，容器占用几十兆字节，而虚拟机占用几十千兆字节。因为多个容器可以在同一台主机上运行，所以在需要运行多个应用程序但出于安全原因需要将它们隔离的情况下，它们非常有用。此外，这种容器化允许您轻松地旋转同一映像的多个实例，因此对于单个应用程序的水平扩展来说，这是一个很大的好处。</p><blockquote class="lp lq lr"><p id="9203" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated">容器的Docker CLI命令:</p><p id="5481" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker ps -a</code>显示所有正在运行或已退出的容器</p><p id="07bc" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker start &lt;container_name&gt;</code>运行指定的容器</p><p id="1ca5" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker stop &lt;container_name&gt;</code>停止指定的容器</p><p id="ee65" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker rm &lt;container_name&gt;</code>删除指定的容器</p><p id="a2b5" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker rm -f &lt;container_name&gt;</code>强制移除指定的容器</p></blockquote><p id="75c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在接下来的部分中，我们将讨论如何构造一个容器。但是首先，快速注意一下remove命令。Docker容器和图像即使在不使用的时候也会占用大量内存，因为Docker会缓存一些东西以加快运行时间。删除未标记的图像、停止的容器和其他被放弃的进程是一个很好的做法。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="5f20" class="js jt hi bd ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp bi translated"><strong class="ak"> Docker卷</strong></h1><p id="8e88" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">之前在讨论微服务的时候，我暗指了容器之间的通信。Docker通过卷来做到这一点。Docker卷是“自由浮动的文件系统”,它允许容器相互通信，在我们的主机上更改源代码，并持久存储数据。容器是无状态的，这意味着对源代码的任何更改都不会在刷新网页时反映出来。查看所做更改的唯一方法是完全重启容器，但这可能会导致您丢失存储在原始容器中的本地数据。与nodemon和数据库类似，卷可以解决这些问题。您还可以在容器之外创建和管理卷。同样，删除未使用的卷可以让您回收大量内存。</p><blockquote class="lp lq lr"><p id="722d" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated">有用的Docker音量命令:</p><p id="998c" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker volume ls</code>列出所有的卷</p><p id="d3df" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker volume rm &lt;volume_name&gt;</code>删除指定的体积</p><p id="ca73" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker volume prune</code>删除所有未使用的卷</p></blockquote></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="a244" class="js jt hi bd ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp bi translated"><strong class="ak"> Docker撰写</strong></h1><p id="e74f" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">最后，我们可以用一个叫做Docker Compose的便利工具把所有东西放在一起。Docker将compose定义为“定义和运行多容器Docker应用程序的工具。使用Compose，您可以使用YAML文件来配置应用程序的服务。然后，只需一个命令，您就可以从您的配置中创建和启动所有服务。”</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lw"><img src="../Images/84a1f7537f02afdf2993eed857cc1d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4UcwA_wH933Xq55n"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">Docker撰写文件示例</figcaption></figure><p id="01e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，运行合成文件将构建或获取1)必要的映像2)指定的容器和3)构建并保留应用程序使用的所有卷。如果我们查看示例代码，服务将Docker指向将构建相应容器的Docker文件(如果存在的话)。注意，这个容器有一个依赖项，一个postgreSQL映像。它还构建所有指定的卷。</p><blockquote class="lp lq lr"><p id="dee7" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated">重要的Docker编写命令:</p><p id="c4f2" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker compose up</code>启动并运行您的整个应用程序</p><p id="9613" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><code class="du lk ll lm ln b">docker compose down</code>停止并删除所有相关容器，同时删除连接到容器的网络(注意:不删除图像和卷)</p></blockquote></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="c099" class="js jt hi bd ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp bi translated"><strong class="ak">结论</strong></h1><p id="7400" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">可以想象，使用Docker对于新开发人员的入职以及响应性部署和伸缩来说是一个非常有用的工具。从文档中可以看出，“Docker非常适合高密度环境以及需要用更少的资源做更多事情的中小型部署。”当然，这只是对它的一些优点和基本组件的简要概述。但是我强烈推荐查看像<a class="ae lj" href="https://github.com/dylanlrrb/Please-Contain-Yourself" rel="noopener ugc nofollow" target="_blank">这种GitHub repo </a>这样的资源，其中有更多你可以练习的实例。</p><blockquote class="lp lq lr"><p id="b230" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated">其他有用的资源:</p><p id="e5bd" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><a class="ae lj" rel="noopener" href="/swlh/what-exactly-is-docker-1dd62e1fde38">Docker到底是什么？</a></p><p id="9d16" class="if ig ls ih b ii ij ik il im in io ip lt ir is it lu iv iw ix lv iz ja jb jc hb bi translated"><a class="ae lj" rel="noopener" href="/codingthesmartway-com-blog/docker-beginners-guide-part-1-images-containers-6f3507fffc98"> Docker —初学者指南</a></p></blockquote></div></div>    
</body>
</html>