<html>
<head>
<title>Making Your Own JavaScript Linter (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制作您自己的JavaScript Linter(第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/making-your-own-javascript-linter-part-2-288841612f4d?source=collection_archive---------6-----------------------#2021-01-14">https://medium.com/codex/making-your-own-javascript-linter-part-2-288841612f4d?source=collection_archive---------6-----------------------#2021-01-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="9ec9" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="https://medium.com/codex?source=logo-e10ad955760c---29038077e4c6" rel="noopener">法典</a></h2><div class=""/><div class=""><h2 id="38b5" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">综合教程</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/eb04230e02dd09cc44c7bfda796a96f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IdL9LprWycvN3fgnmO5T2g.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">奔跑的棉绒</figcaption></figure><p id="2573" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这是关于构建JavaScript linter的综合教程的第二部分。你可以在这里阅读<a class="ae ks" rel="noopener" href="/codex/making-your-own-javascript-linter-part-1-ee9f91dc49d8">第一部</a>。</p><p id="6f3f" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这里是GitHub 中dirtyrat的<a class="ae ks" href="https://github.com/JoanaBLate/dirtyrat" rel="noopener ugc nofollow" target="_blank">源代码。</a></p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="a0f5" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在教程的第一部分，我们学习了记号赋予器、扫描器和错误显示。这三个实体各有一个文件就足够了。而且每个文件里面的代码很容易理解，也不是很大。小菜一碟！</p><p id="5461" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">现在我们必须检查表示我们想要lint的源代码的令牌对象之间的关系。负责这项任务的linter部分被称为<em class="la">解析器</em>。解析器必须做的不仅仅是对照下一个邻居检查每个标记。我们刚刚到了事情变得棘手的地步！</p><p id="68be" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">有如此多的代码和多样的功能，我们不得不<strong class="jy hs">将解析器分成一堆模块</strong>。其中就有<em class="la"> parser.js </em>本身。我们会看着他们所有人。</p><h1 id="8599" class="lb lc hi bd ld le lf lg lh li lj lk ll ix lm iy ln ja lo jb lp jd lq je lr ls bi translated">陈述和表达</h1><p id="0035" class="pw-post-body-paragraph jw jx hi jy b jz lt is kb kc lu iv ke kf lv kh ki kj lw kl km kn lx kp kq kr hb bi translated">理论上，源代码有两种成分:语句和表达式。表达式是数据(值)或可以计算为数据的东西。一条语句是代码结构的一个元素，一般绑定一个关键字(<em class="la"> function </em>，<em class="la"> return </em>，<em class="la"> if </em>等)。).</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="694a" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这个定义语句x表达式有些武断和混乱，可能会因编程语言的不同而不同。我相信以下概念:</p><blockquote class="ma"><p id="3802" class="mb mc hi bd md me mf mg mh mi mj kr dx translated">计算机是一种遵循指令的机器。因此，任何源代码都是一组语句<strong class="ak"><em class="mk"/></strong><em class="mk">(显式或隐式)，这些语句可能包含表达式，这些表达式可能包含包含表达式的语句。以此类推，循环往复。</em></p></blockquote><p id="ee42" class="pw-post-body-paragraph jw jx hi jy b jz ml is kb kc mm iv ke kf mn kh ki kj mo kl km kn mp kp kq kr hb bi translated">语句和表达式(包括操作符)的概念是编写解析器的基础。</p><h1 id="5774" class="lb lc hi bd ld le lf lg lh li lj lk ll ix lm iy ln ja lo jb lp jd lq je lr ls bi translated">模块解析器</h1><p id="1416" class="pw-post-body-paragraph jw jx hi jy b jz lt is kb kc lu iv ke kf lv kh ki kj lw kl km kn lx kp kq kr hb bi translated">基本上，模块<em class="la">解析器</em>处理<strong class="jy hs">一级语句</strong> : <em class="la">“使用严格”</em>，全局变量和函数的导入和声明。对于全局变量初始化，它依赖于模块<em class="la">表达式</em>。在函数的情况下，它将几乎整个作业传递给模块<em class="la">函数</em>。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="5712" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这个解析器不接受函数之外的公共代码。它还调用模块<em class="la">寄存器</em>，专门用于控制名称。</p><h1 id="7409" class="lb lc hi bd ld le lf lg lh li lj lk ll ix lm iy ln ja lo jb lp jd lq je lr ls bi translated">解析函数头</h1><p id="8a79" class="pw-post-body-paragraph jw jx hi jy b jz lt is kb kc lu iv ke kf lv kh ki kj lw kl km kn lx kp kq kr hb bi translated">正如我们在上面看到的，解析几种一级语句很容易。解析一个函数有点复杂，因为我们需要能够处理循环内表达式内的函数，循环内的函数，if函数内的子句，whatever…</p><p id="bb36" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在JavaScript中，有三种以关键字<em class="la"> function </em>开头的函数:全局(第一级)函数、内部函数和匿名函数。由于它们仅在开始处不同(内部或非内部，匿名或非匿名)，解析器(模块<em class="la">函数</em>)可以在解析开始后对它们使用相同的代码。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h1 id="b184" class="lb lc hi bd ld le lf lg lh li lj lk ll ix lm iy ln ja lo jb lp jd lq je lr ls bi translated"><strong class="ak">解析功能体——路由器</strong></h1><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="88f4" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们必须将函数体理解为一系列语句。即使没有关键字(赋值或函数调用)。即使一行中所写的只是一个右花括号。想象一下这个符号说“当前块/范围到此结束”。</p><p id="8ff7" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">因此，我们的任务是编写一个循环，将每一行的第一个令牌路由到适当的函数来处理它。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="8b7e" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">类似上面例子的压缩源代码告诉我们，每行只写一条语句的原则(这对于解析一级语句来说很好)在这里不适用。</p><p id="d62a" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">路由器:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="f0f7" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们将更多地讨论路由器。</p><h1 id="40aa" class="lb lc hi bd ld le lf lg lh li lj lk ll ix lm iy ln ja lo jb lp jd lq je lr ls bi translated">解析函数体——处理程序(工人)</h1><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="3bf6" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">以上这三个函数足以帮助解释一些概念。我称他们为处理者或工作者，因为他们有效地工作，处理代币，吃代币；它们处理路由器(管理器)交付的工作。</p><p id="af87" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这三个函数开始吃第一个可用的令牌，它包含各自的关键字。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="8df2" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><em class="la"> eatElse </em>检查上下文是否允许<em class="la"> else </em>语句位于该位置(不久将有更多关于该主题的内容)。</p><p id="7730" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><em class="la">eaif</em>和<em class="la"> eatReturn </em>不需要检查上下文，因为任何可能的上下文(在函数体内部)对它们都是有效的，考虑到一些错误是在其他地方捕获的。例如:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="1503" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">无效令牌<em class="la">返回</em>在函数<em class="la">eaif</em>处被捕获为错误。并且棉绒在调用<em class="la"> eatReturn </em>之前退出。因此，<em class="la"> eatReturn </em>永远不用担心令牌<em class="la"> return </em>之前的令牌。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="4fc7" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">因为每个语句都有自己的规则，所以检查下一个标记的最佳位置是在“eat statement”函数内部。</p><p id="cd25" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在解析(吃和分析)其令牌后，<em class="la"> eatReturn </em>检查下一个令牌，而不吃(当没有错误时)，因为下一个令牌必须可用于路由器；它是负责解析块尾和行尾标记的函数。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="daed" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">解析完它的令牌后，<em class="la">eaif</em>和<em class="la"> eatElse </em>通知解析器一个新的块和一个新的分支被创建了(很快会有更多关于这个主题的内容)。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="def6" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">正如我们看到的模式是<strong class="jy hs">独立解析所有语句</strong>。这条规则只有一个例外:语句<em class="la"> catch </em>。这是唯一不应该被路由器捕获的语句。</p><p id="562e" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">现在，是什么使得<em class="la">捕捉</em>不同于<em class="la">中断</em>或<em class="la">否则</em>到了必须进行特殊解析的地步？简单回答。你可以有<em class="la">如果</em>没有<em class="la">其他</em>。您可以在不使<em class="la">中断</em>或<em class="la">继续</em>的情况下使<em class="la">用于</em>。但是如果你有<em class="la">试</em>你必须有<em class="la">赶</em>。<em class="la">最后</em>是可选的，所以它和其他语句一样。</p><p id="469d" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">每次dirtyrat关闭一个<em class="la"> try </em>块，它调用<em class="la"> forceEatCatch </em>。这就是为什么<em class="la"> catch </em>不应该被路由器捕获的原因:它被<em class="la"> forceEatCatch </em>捕获。</p><h1 id="b079" class="lb lc hi bd ld le lf lg lh li lj lk ll ix lm iy ln ja lo jb lp jd lq je lr ls bi translated">待续</h1><p id="c806" class="pw-post-body-paragraph jw jx hi jy b jz lt is kb kc lu iv ke kf lv kh ki kj lw kl km kn lx kp kq kr hb bi translated">你可以在这里阅读<a class="ae ks" rel="noopener" href="/codex/making-your-own-javascript-linter-part-3-da14e2aaf051">教程的第三部分</a>。</p></div></div>    
</body>
</html>