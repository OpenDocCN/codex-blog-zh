<html>
<head>
<title>Simulating Common, Censored, Outcome Variables as Dependent Variables in R [part 1]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模拟常见的，截尾，结果变量作为因变量在R[第一部分]</h1>
<blockquote>原文：<a href="https://medium.com/codex/simulating-common-censored-outcome-variables-as-dependent-variables-in-r-part-1-4ff2a2594c34?source=collection_archive---------20-----------------------#2021-08-12">https://medium.com/codex/simulating-common-censored-outcome-variables-as-dependent-variables-in-r-part-1-4ff2a2594c34?source=collection_archive---------20-----------------------#2021-08-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0b84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">【正在审核】</em></p><p id="ba91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按照我们在<a class="ae je" href="https://laure-17161.medium.com/simulating-common-non-censored-outcome-variables-as-dependent-variables-4bdea1efd211" rel="noopener">这里</a>所做的，在这篇短文中构成反应变量Y的，是标记感兴趣事件时间的单个时间或持续时间。它们通常被称为<em class="jd">到事件时间(tte) </em>。这些时间可以是几天、几周、几个月或几年，也可以是其他形式的时间。事件可能发生在研究者开始按计划进行试验研究之前，事件可能发生在研究期间，也可能发生在研究之后。并非所有患者/参与者都经历过或将经历感兴趣的事件。一个常见的场景是这样呈现的:登记的参与者经历了事件，事件发生的时间被记录下来，他们被停止跟踪，或者他们没有经历事件，他们选择停止被跟踪，或者研究者失去了对他们的跟踪，研究者不知道患者是否经历了事件，因此患者最后一次被看到的时间被记录为<em class="jd">审查时间</em>， 或者研究的结束时间以及为尚未经历该事件的患者记录的时间对应于研究结束时间，这些时间也被标记为<em class="jd">删截时间</em>。 所有这些时间都记录在响应变量y中。这种情况下的删失时间称为<em class="jd">右删失</em>。这篇短文中不感兴趣的其他可选场景是左删失和区间删失时间。</p><p id="542d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了模拟所述<em class="jd">右删失机制</em>的时间，我们为时间生成两个变量:<em class="jd"> tte变量T和右删失时间变量C，</em>假设T独立于C，给定一组协变量x。<em class="jd"/>然后我们认为Y中的观察值是T和C值之间的最小值。生存分析中需要的一个重要变量是指标二进制变量，tte的为<em class="jd"> 1，删失次数</em>为<em class="jd"> 0。感兴趣的事件通常是死亡，由此我们得到名称<em class="jd">生存时间</em>(你生存到死亡的时间)。另一个常见术语是<em class="jd">总存活时间(OS) </em>，当事件为<em class="jd">全因死亡</em>(患者可能死于交通事故，而感兴趣的事件为因观察到的健康状况而死亡)，以及<em class="jd">无进展存活时间(PFS) </em>，当感兴趣的事件包括<em class="jd">死亡和疾病进展。</em></em></p><p id="f11a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们模拟了适用于右删失数据的一般三类生存模型的生存时间:一类<em class="jd">参数模型(通常为指数、威布尔、瑞利、Gompertz、对数逻辑和对数正态模型)，包括加速失效时间(AFT)模型和cox比例(cox-PH)半参数模型。</em>我们将在<a class="ae je" href="https://laure-17161.medium.com/simulating-common-censored-outcome-variables-as-dependent-variables-in-r-part-2-c6c012417801" rel="noopener">的下一篇文章中介绍AFT模型的模拟策略。</a>生存建模有三个基本功能:</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/0fde9e3e97ad49506cbb66f182e4830c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*NcSlOsx5LQ95sNoI4nSSvQ.png"/></div></div></figure><p id="e5d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">风险函数h() </em>，它测量每个个体I在时间t经历感兴趣事件的<em class="jd">(瞬时)</em>风险。它取决于<em class="jd">基线</em> ( <em class="jd">，即在研究开始时测量的</em> ) <em class="jd">风险h0() </em>，以及潜在协变量的线性预测值。考虑到存活时间取决于这些变量，我们将使用来自<a class="ae je" href="https://laure-17161.medium.com/simulating-common-non-censored-outcome-variables-as-dependent-variables-4bdea1efd211" rel="noopener">另一篇关于模拟的文章</a>的相同线性预测值。然而，这组系数<em class="jd">β</em>，不包括参数模型的截距系数b0(我们在此限制中排除了AFT模型)。你可以在这里得到一些澄清。<em class="jd">累积风险函数Hi() </em>对风险函数<em class="jd">Hi()</em>t进行积分或求和，当后者分别为连续或离散时。<em class="jd">生存函数</em> <em class="jd"> Si() </em>测量个体I在<em class="jd">一段时间t </em>后经历感兴趣的事件的可能性，或者到时间t为止“<em class="jd">生存”</em>的概率。</p><p id="edf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参数模型和cox-PH模型本质上是基于这些函数(检查<a class="ae je" href="https://laure-17161.medium.com/applying-propensity-score-weighting-psw-technique-to-synthesize-evidence-from-two-individual-4c72ec9dac77" rel="noopener"> <em class="jd">这里</em> </a>它们是如何一一对应的)。最值得注意的一点是:</p><blockquote class="jr js jt"><p id="2e0a" class="if ig jd ih b ii ij ik il im in io ip ju ir is it jv iv iw ix jw iz ja jb jc hb bi translated">“危险函数可以相对于时间保持不变(对应于指数密度)；可以根据某个幂函数(对应于威布尔密度)作为时间的函数而增加；可以随时间线性增加<br/>(对应于瑞利密度)；或者可以随时间指数地增加(对应于Gompertz密度)。此外，<br/>根据时间的幂、线性或指数函数，可能存在危险交替减少<br/>或增加的时间间隔— <strong class="ih hj">丁和卡尔·E(2013)第5章。</strong></p></blockquote><p id="a889" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">针对基线测量的危险<em class="jd"> h0() </em>定义了许多函数；可能是一个<em class="jd">常数</em>一个<em class="jd">多项式</em>某个<em class="jd">对数</em>或者t 指数的某个<em class="jd">函数。与<em class="jd">指数、</em>冈珀茨</em>和<a class="ae je" href="https://laure-17161.medium.com/applying-propensity-score-weighting-psw-technique-to-synthesize-evidence-from-two-individual-4c72ec9dac77" rel="noopener"> <em class="jd">威布尔</em> </a>分布相关的常见危险有:</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jx"><img src="../Images/81015594995c308b5f7aa4d3ca0ce42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYv-jnTTrmKlCO5xmdIpCg.png"/></div></div></figure><p id="6306" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参数模型对基线风险进行了分布假设，由于一对一的关系，这相当于对存活时间进行了分布假设。cox-PH模型不需要基线危害或生存函数的特定分布，使模型灵活地适应参数模型可以适应的任何数据。根据风险函数的定义，我们得到等式<em class="jd">log[hi(t)/h0(t)]=β* Xi，</em>，由此<em class="jd">作出随时间恒定的对数风险比(lhr) </em>的假设(即线性预测器<em class="jd">β* Xi</em>被认为不依赖于t)，也称为比例风险(PH)假设<em class="jd">。</em>后者是半参数cox-PH建模框架下一个特别已知的假设。</p><h2 id="14ca" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">从标准参数生存分布模拟生存时间(假设比例风险)</h2><p id="d133" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">R包<em class="jd"> simsurv ( </em> <a class="ae je" href="https://www.jstatsoft.org/article/view/v097i03" rel="noopener ugc nofollow" target="_blank"> web文档</a>，<a class="ae je" href="https://www.youtube.com/watch?v=fJTYsncvpvI" rel="noopener ugc nofollow" target="_blank"> YouTube </a> <em class="jd">)为这一点提供了便利。</em></p><p id="a765" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">set . seed(10082021)</em></strong><em class="jd"><br/></em><strong class="ih hj"><em class="jd">b</em></strong><em class="jd">&lt;-runif(10，-0.05，...<br/></em><strong class="ih hj"><em class="jd">beta s</em></strong><em class="jd">&lt;-c(Xage = b[2]，Xbmi=b[3]，Xfemale=b[4]，XE“贝塔”是一个命名的向量。</em></p><p id="94f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用本文生成的相同协变量，存储在<em class="jd"> data2 </em>中，其中我们添加了一个由<em class="jd"> simsurv() </em> R函数所需的单独索引列:</p><p id="9870" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">data 2</em></strong><em class="jd">&lt;-data . frame(id = 1:1000，gender=factor(性别)，Xage=age，Xbmi=bmi，smoking . status = factor(smoking . status)，trtgps=factor(trtgps)，Xfemale=contrast.matrix[，2]，Xexsmoker=contrast.matrix[，3]，Xnonsmoker=contrast.matrix[，4]，XB=contrast.matrix[，5]，XC=contrast.matrix[，6]，XD=contrast</em></p><p id="9811" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">指数模型</strong></p><p id="ebae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">exp . surv dat</em></strong><em class="jd">&lt;-simsurv(dist = " exponential "，lambdas = 1.3，betas = betas，x = data2，seed=77) </em></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es ky"><img src="../Images/e2c1d55ae1a10f62b8eb88fa97918f48.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*ZKqQLclFc-p7PXl3qh-7Ug.png"/></div></figure><p id="a0aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">“exp . surv dat”</em>是一个3变量的数据帧。“状态”变量是一个1的向量，表示没有对<em class="jd">“事件时间”</em>进行审查。为了创建审查时间，可以假设任何大于或等于4的<em class="jd"> eventtime </em>都被认为是(正确的)审查。我们在带有组件<em class="jd"> maxt=4 </em>的<em class="jd"> simsurv() </em>函数中指定这一点，并得到以下结果。记得在<em class="jd"> simsurv </em>函数中设置种子，让我和你有相同的模拟存活时间。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es kz"><img src="../Images/0500cfe68fe33d2e796cf730e7570978.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*pdpWR5eSbXqT27plET1jEA.png"/></div></figure><p id="3385" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这个数据中没有太多的审查时间。删失率为28/1000*100 = 2.8%。审查时间是固定值，这并不常见。另一种创建右删截时间的方法，是生成两个指数型的<em class="jd">事件时间</em> T和C，分别用对象<strong class="ih hj"> <em class="jd"> exp1.survdat </em> </strong>和<strong class="ih hj"> <em class="jd"> exp2.survdat </em> </strong>表示。最终事件时间将是最小值<em class="jd"> min(Ti，Ci) </em>，如果Ti小于或等于Ci，则状态变量将为1，否则为0。我们分别改变<strong class="ih hj"> <em class="jd"> exp1.survdat </em> </strong>和<strong class="ih hj"> <em class="jd"> exp2.survdat </em> </strong>中的lambdas值(比如1.3和1)和种子(比如77和78)。假设我们已经生成了<strong class="ih hj"> <em class="jd"> exp1.survdat </em> </strong>和<strong class="ih hj"> <em class="jd"> exp2.survdat，</em> </strong>我们得到新的数据帧<strong class="ih hj"> <em class="jd"> exp.survdat </em> </strong>为</p><p id="b511" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">exp . surv dat</em></strong><em class="jd">&lt;-data . frame(id = exp 1 . surv dat $ id，T=exp1.survdat$eventtime，C=exp2.survdat$eventtime，event time = pmin(exp 1 . surv dat $ event time，exp2.survdat$eventtime)，status = as . numeric(exp 1 . surv dat $ event time&lt;= exp 2 . surv dat $ event</em></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es la"><img src="../Images/e61c3127185b8be5558c13edffc340ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*S_-pTMe4Hffrf-QmwUyibQ.png"/></div></div></figure><p id="da5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据帧的前5个值如下所示。这次被审查的价值观有不同的价值观。我们以同样的方式处理剩余的模型。</p><h2 id="b15c" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">gompertz模型</h2><p id="f04e" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">gomp 1 . surv dat</em></strong><em class="jd">&lt;-sim surv(dist = " gompertz "，lambdas = .03，gammas = .5，betas = betas，x = data2，seed = 77) </em></p><p id="1210" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">gomp 2 . surv dat</em></strong><em class="jd">&lt;-sim surv(dist = " gompertz "，lambdas = .01，gammas = .3，betas = betas，x = data2，seed = 78) </em></p><p id="276a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">得出的存活时间在数据帧<em class="jd"> gomp.survdat: </em>中</p><p id="7aec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">gomp . surv dat</em></strong><em class="jd">&lt;-data . frame(id = gomp 1 . surv dat＄id，T = gomp 1 . surv dat＄event time，C = gomp 2 . surv dat＄event time，event time = pmin(gomp 1 . surv dat＄event time，gomp 2 . surv dat＄event time)，status = as . numeric(gomp 1 . surv dat＄event time&lt;= gomp 2 . surv dat＄event time))【t1</em></p><h2 id="4a0f" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">威布尔模型</h2><p id="dc4c" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">Wei B1 . surv dat</em></strong><em class="jd">&lt;-simsurv(dist = " Weibull "，lambdas = .3，gammas = 1.5，betas = betas，x = data2，seed = 77) </em></p><p id="9174" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">weib 2 . surv dat</em></strong><em class="jd">&lt;-simsurv(dist = " Weibull "，lambdas = .1，gammas = 1.3，betas = betas，x = data2，seed = 78) </em></p><p id="3116" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">weib . surv dat</em></strong><em class="jd">&lt;-data . frame(id = Wei B1 . surv dat $ id，T=weib1.survdat$eventtime，C=weib2.survdat$eventtime，event time = pmin(Wei B1 . surv dat $ event time，weib2.survdat$eventtime)，status = as . numeric(Wei 1 . surv dat $ event time&lt;= Wei 2 . surv dat $ event time))【T33</em></p><p id="ed3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述<em class="jd">(正lambda和gamma低于gompertz，gamma为weibull&gt;1)</em>的模拟设置意味着Weibull和gompertz <em class="jd">(指数风险不变)</em>的基线风险都是单调(严格)增加的。然而，在现实中，h0(t)也可能减少。双组分混合模型放宽了基线风险单调性的假设，例如，双组分混合gompertz模型下的存活时间可通过以下方式生成:</p><p id="ec06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">2c gomp . surv dat</em></strong><em class="jd">&lt;-sim surv(dist = " gompertz "，lambdas = c(0.03，0.01)，gammas = c(.3，. 5)，betas = betas，mixture = TRUE，pmix = 0.5，x = data2，maxt = 9.00，seed=77) </em></p><h2 id="9769" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">根据标准参数生存分布模拟生存时间(假设非比例风险)</h2><p id="1566" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">这个假设意味着线性预测器<em class="jd">贝塔*Xi </em>依赖于t。<em class="jd"/>例如，<em class="jd">贝塔*Xi </em>可以是<em class="jd">贝塔*Xi =贝塔1*Xi +贝塔2*Xi*log(t)的形式。</em>我们接着定义两组系数<em class="jd">β1</em>和<em class="jd">β2</em>，它们具有相同的维数<em class="jd">，β1</em>是<em class="jd"> log(t)=0时的<em class="jd"> lhr </em>，β2</em>是log(t)中每单位变化的<em class="jd"> lhr </em>的变化。</p><p id="e59a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">set . seed(10082021)</em></strong><em class="jd"><br/></em><strong class="ih hj"><em class="jd">b</em></strong><em class="jd">&lt;-runif(10，-.05，<br/></em><strong class="ih hj"><em class="jd">beta 1</em></strong><em class="jd">&lt;-c(Xage = b[2]，Xbmi=b[3]，Xfemale=b[4]，Xexsmoker=b[5]，XB</em></p><p id="0a40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">B2</em></strong><em class="jd">&lt;-runif(10，-.01，. 05)<br/></em><strong class="ih hj"><em class="jd">beta 2</em></strong><em class="jd">&lt;-c(Xage = B2[2]，Xbmi=b2[3]，Xfemale=b2[4]，xex smoker =b2[6]，x非吸烟者= B2[6]，XB=b2[7]，XC=b2[8]，XD=b2[9]，XE=b2</em></p><p id="b23d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">存活时间最终通过以下代码获得:</p><p id="394f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">nonphgomp . surv dat</em><em class="jd">&lt;-simsurv(dist = " gompertz "，lambdas = 0.03，gammas = .5，betas = beta1，tde = beta2，x = data2，tdefunction = "log "，maxt = 4，seed=77) </em></strong></p><p id="7658" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一种情况是仅为治疗组定义β2:</p><p id="9971" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">beta 2</em></strong><em class="jd">&lt;-c(XB = B2[7]，XC=b2[8]，XD=b2[9]，XE=b2[10]) </em>，上面的代码还是会生成相应的生存时间。</p><h2 id="7759" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated">拟合模拟存活时间</h2><p id="218c" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">我们将<em class="jd"> gompertz-PH </em>和<em class="jd"> coxPH </em>模型分别拟合到<strong class="ih hj"> <em class="jd"> 2cgomp.survdat </em> </strong>和<strong class="ih hj"><em class="jd">nonphgomp . surv dat</em></strong><strong class="ih hj"><em class="jd"/></strong>并测试PH假设，考虑到存活时间和协变量<em class="jd">年龄、bmi、性别、吸烟状况</em>和<em class="jd">之间的潜在相关性我们需要<em class="jd"> R包生存</em>。我们使用包中的<em class="jd"> survreg() </em> R函数来拟合gompertz参数模型，然后使用同一个包中的cox.ph() R函数来拟合一个coxPH模型。响应变量在这些函数中被指定为<em class="jd"> Surv(事件时间，状态)。</em>遗憾的是，<em class="jd"> survreg() </em>只支持以下分布:<em class="jd">"极值"、" logistic "、"高斯"、"威布尔"、"指数"、"瑞利"、"对数高斯"、"对数正态"、"对数logistic "、" t "。</em>可能其他函数有，比如<em class="jd"> flexsurv R包</em>中的<em class="jd"> flexsurvreg() </em>函数<em class="jd"> </em>。然而，我们可以依靠<em class="jd"> coxph() </em>函数来拟合数据，正如我们前面提到的，我们不需要像在<em class="jd"> coxph() </em>中指定<em class="jd">dist = "</em>gompertz<em class="jd">"</em>这样的组件，就像在<em class="jd"> survreg()函数中需要的那样。</em>我们需要将<em class="jd"> data2、</em>中存储的所有协变量包含在<em class="jd"> 2cgomp.survdat </em>中，并为生存数据帧保留相同的名称<em class="jd"> 2cgomp.survdat </em>。</em></p><p id="e0d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">拟合双组分混合物数据</strong></p><p id="c811" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">2c gomp . Surv dat</em></strong><em class="jd">&lt;-data . frame(2c gomp . Surv dat，data 2)<br/></em><strong class="ih hj"><em class="jd">fitcph . mix gomp</em></strong><em class="jd">&lt;-Cox ph(Surv(event time，status)~ Xage+Xbmi+Xfemale+xex smoker+xn smoker+XB+XC+XD+XE，2c gom</em></p><p id="6eac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">拟合非PH值数据</strong></p><p id="612e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">nonphgomp . Surv dat</em></strong><em class="jd">&lt;-data . frame(nonphgomp . Surv dat，data 2)<br/></em><strong class="ih hj"><em class="jd">fitcph . nonphgomp</em></strong><em class="jd">&lt;-Cox ph(Surv(event time，status)~ Xage+Xbmi+Xfemale+Xexsmoker+xnosmoker+XB+XC</em></p><p id="40b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">比例风险假设的测试</strong></p><p id="7719" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于由R函数<em class="jd"> cox.zph() </em>定义的PH，我们使用<em class="jd">舍恩菲尔德测试</em>。零假设H0陈述<em class="jd">“危险成比例(或危险比随时间恒定)”</em>，替代Ha陈述<em class="jd">“危险不成比例(或危险比随时间不恒定)”。</em>下面是<em class="jd">Cox . zph(</em><strong class="ih hj"><em class="jd">fitcph . mix gomp</em></strong><em class="jd">)</em>和<em class="jd">Cox . zph(</em><strong class="ih hj"><em class="jd">fitcph . nonphgomp</em></strong><em class="jd">)的R输出。</em></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es lb"><img src="../Images/138343b50a013618cbfbd32b15bd3397.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*hNU7tYbafYjMyK4A0U7XPA.png"/></div></figure><p id="fff4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> cox.zph() </em>测试每个协变量，并提供模型的整体测试。使用<em class="jd"> cox.zph()[] </em>得到测试的每一个组件。<em class="jd"> </em>我们得到了我们所期望的结果，在非PH设置下模拟的存活时间的测试是显著的<em class="jd">(p值=1.4e-06) </em>，在PH设置下模拟的存活时间的测试是不显著的<em class="jd">(p值=0.084) </em>。我们可以进一步绘制<em class="jd"> cox.zph()[] </em>对于<em class="jd"> Xfemale和Xexsmoker </em>例如，从显著性检验<em class="jd">、</em>以及<em class="jd">在每幅图<em class="jd">、</em>上风险比随时间不变的0线</em>，来查看该线多久运行一次<em class="jd">围绕风险比随时间变化的95%置信带。</em></p><p id="5892" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">par(m flow = c(1，2))<br/>plot(</em><strong class="ih hj"><em class="jd">Cox . zph(fitcph . nonphgomp)【3】</em></strong><em class="jd">)<br/>abline(h = 0，col = 2)<br/>plot(</em><strong class="ih hj"><em class="jd">Cox . zph(fitcph . nonphgomp)【4】</em></strong><em class="jd">)<br/>abline(t</em></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lc"><img src="../Images/890388c6291c8a5e545814a78e6cef6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y878ovoC0Rf4cUEGK9PGTg.png"/></div></div></figure><p id="1848" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第一个图中，0线只是短暂地穿过范围，而在第二个图中，它几乎总是穿过范围，这证实了第一个图中的非恒定风险比<em class="jd">(p值&lt;. 05】</em>和第二个图中的恒定比<em class="jd">(p值&gt;. 05】</em>。</p><h2 id="5ec0" class="jy jz hi bd ka kb kc kd ke kf kg kh ki iq kj kk kl iu km kn ko iy kp kq kr ks bi translated"><strong class="ak">额外分析</strong></h2><p id="3d5a" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated"><strong class="ih hj">型号选择</strong></p><p id="ed2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们希望选择具有更好模型性能的协变量，我们使用<em class="jd"> step() </em> R函数进行<em class="jd">逐步模型选择</em>并结合<em class="jd"> anova() </em> R函数选择具有统计显著性的协变量。</p><p id="39f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">具体来说，函数<em class="jd"> anova()，ANOVA(step(fitcph . mix gomp))</em>产生了几个步骤的冗长输出。我们呈现最后一步。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es ld"><img src="../Images/fbd750337f7193e24876106ad8c9b089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*vG_NmB4zeIWPk09gIO7PjQ.png"/></div></figure><p id="6c73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们剩下4个显著的协变量:<em class="jd">年龄bmi </em> <em class="jd">治疗组C </em>和<em class="jd"/>我们用<em class="jd"> anova(step()) </em>对模型<em class="jd"> </em>重复相同的分析，简化为这4个变量(其中<em class="jd">datMixGomp = 2c gomp . surv dat</em>)。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es le"><img src="../Images/399db3acad2a40194e39428eaf18a734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*1RWnpSzW3Bo45fwMMwDR3g.png"/></div></figure><p id="a1fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一新的分析建议我们去掉d。因此，最终简化模型的汇总统计数据如下所示。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es lf"><img src="../Images/22239b52afe7c8d9ebc6fc204d147210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*LNdoYwFjeA5E3u34DU3GkA.png"/></div></figure><p id="2dc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，<strong class="ih hj"> <em class="jd"> fitcph.nonPHGomp </em> </strong>回归<strong class="ih hj"> <em class="jd"> </em> </strong>模型简化为<em class="jd">年龄bmi女和D. </em></p><p id="9b17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">测试线性假设</strong></p><p id="1703" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些协变量可能最适合其正交三次指数或对数版本。让我们从上面的简化模型中检查整体线性度。我们用下面的行代码来形象化这一点</p><p id="9fed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">par(m flow = c(1，2))</em></strong><em class="jd"><br/></em><strong class="ih hj"><em class="jd">plot</em></strong><em class="jd">(predict(reducedgomp . cphmodel)，Residual(reducedgomp . cphmodel，type="martingale)，xlab = "fitted values "，ylab = "martingale residuals "，main = "Residual plot "，las = 1)<br/></em><strong class="ih hj"><em class="jd">abline</em></strong></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lg"><img src="../Images/edcdd513bc235267571d617134f11cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akrITa7lB3uw1URXSlkABg.png"/></div></div></figure><p id="c6b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">怀疑存活时间(在PH设置下模拟)和第一张图中的协变量之间存在非共线性。第二张图看起来令人满意，这是根据在非ph环境下模拟的存活时间拟合的模型。</p><h1 id="8efd" class="lh jz hi bd ka li lj lk ke ll lm ln ki lo lp lq kl lr ls lt ko lu lv lw kr lx bi translated"><strong class="ak">推荐:</strong></h1><p id="46a4" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">当PH假设不满足时:对相关协变量进行分类或分层，或应用一些其他可能的有效转换，或拟合时间相关系数模型，或拟合AFT模型框架下的数据<a class="ae je" href="https://laure-17161.medium.com/simulating-common-censored-outcome-variables-as-dependent-variables-in-r-part-2-c6c012417801" rel="noopener">(见我们的下一篇文章)</a>。</p><p id="721e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当不满足线性假设时:识别非线性变量，包括二次三次项(即添加多项式项)，对变量进行分类/分层，应用一些对数变换或指数变换等。</p><h1 id="ac5a" class="lh jz hi bd ka li lj lk ke ll lm ln ki lo lp lq kl lr ls lt ko lu lv lw kr lx bi translated">参考</h1><p id="d513" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">1.<a class="ae je" href="https://www.academia.edu/20618730/Clinical_Trial_Data_Analysis_Using_R_by_Ding-Geng_Din_Chen_Karl_E._Peace" rel="noopener ugc nofollow" target="_blank"> <em class="jd">临床试验数据分析采用R </em> </a>由陈定庚(Din)和卡尔《2013年国际统计评论》</p></div></div>    
</body>
</html>