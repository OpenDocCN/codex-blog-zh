<html>
<head>
<title>Coroutines with Unity!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">统一的协程！</h1>
<blockquote>原文：<a href="https://medium.com/codex/coroutines-with-unity-b5a2b3fc3426?source=collection_archive---------13-----------------------#2021-04-02">https://medium.com/codex/coroutines-with-unity-b5a2b3fc3426?source=collection_archive---------13-----------------------#2021-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ih ii ij ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es ig"><img src="../Images/cb135ea157ea64f0b1290446ae645e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Y0WmcB3iWANxCIRFS-c7dg.gif"/></div></div></figure><p id="08c8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">任何用Unity编程的人都知道，迟早你会在更新函数中积累大量的代码。毕竟，<a class="ae jp" href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html" rel="noopener ugc nofollow" target="_blank"> Update </a>是一个名为every frame的函数，这使得它成为一个非常有用的编程工具！然而，有时我们需要比Update允许的更精确和定制。有时候，我们需要<strong class="it hj">协程</strong>。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h2 id="eba6" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr bi translated">什么是协程？</h2><p id="8db0" class="pw-post-body-paragraph ir is hi it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hb bi translated"><a class="ae jp" href="https://docs.unity3d.com/ScriptReference/Coroutine.html" rel="noopener ugc nofollow" target="_blank"> <strong class="it hj">协程</strong> </a>是间隔执行的函数。简单地说，你可以告诉一个函数暂停，等待一个条件或动作发生后再继续。这有助于您将其功能分解为一系列可以按顺序执行的步骤。</p><blockquote class="kx ky kz"><p id="7fa6" class="ir is la it b iu iv iw ix iy iz ja jb lb jd je jf lc jh ji jj ld jl jm jn jo hb bi translated">记住它们用法的一个好方法是想想单词<a class="ae jp" href="https://languages.oup.com/google-dictionary-en/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">例程</em> </a>以及它在现实世界中的含义——有规律地遵循的一系列动作。</p></blockquote><h2 id="7c6e" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr bi translated">句法</h2><p id="7e89" class="pw-post-body-paragraph ir is hi it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hb bi translated">函数的返回类型将是一个<strong class="it hj"> IEnumerator </strong>，这就是Unity如何将函数的执行划分到几个帧中。</p><figure class="lf lg lh li fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es le"><img src="../Images/69c4dfe0f08036a7ef779ca3ef1716eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m1WEIlgP9lKmUgS2ef4R3w.png"/></div></div></figure><p id="a7d4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">像任何常规函数一样，协程可以被赋予参数。变量将在整个协程中保持它们的值。</p><figure class="lf lg lh li fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es lj"><img src="../Images/69b7117a405823d53d27f9443b542935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jAk4h7U7GktftfSdrjQ4Og.png"/></div></div></figure><p id="9d7a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">协程有一个特殊的语句叫做<strong class="it hj"> <em class="la"> yield </em> </strong>，它返回函数的执行结果。这就是允许你暂停的原因。</p><p id="bcf2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">Yield通常伴随着<strong class="it hj"> WaitForSeconds </strong>，它允许你指定等待多长时间。</p><figure class="lf lg lh li fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es lk"><img src="../Images/52508c02315d57ff929dda2f4dbc03c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T0gej_ovGG1Ks6gMmGuqEw.png"/></div></div></figure><p id="e506" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">返回</strong>，作为一个标准特性，在该点终止执行，并将控制转移回调用进程。<strong class="it hj"> Yield </strong>表示该方法是一个<a class="ae jp" href="https://www.merriam-webster.com/dictionary/iterate" rel="noopener ugc nofollow" target="_blank">迭代器</a>，将在不止一帧上执行。当使用协程时，Unity知道从它停止的地方开始这个过程。</p><p id="47f9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">一个完成的协程必须总是从<strong class="it hj"> Start </strong>方法中被调用。</p><figure class="lf lg lh li fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es ll"><img src="../Images/a08e08ced74dbb74a4065494fa7d9f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gt0xmHTitq3uKTe1zUIDGg.png"/></div></div></figure></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><h2 id="0374" class="jx jy hi bd jz ka kb kc kd ke kf kg kh jc ki kj kk jg kl km kn jk ko kp kq kr bi translated">将协程与while循环结合起来——这是进行无限循环的正确方法</h2><p id="0377" class="pw-post-body-paragraph ir is hi it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hb bi translated">由于协程允许程序<em class="la">呼吸</em>，你可以有效地创建一个协程，它将永远运行<em class="la">而不会导致程序崩溃<em class="la"> g. </em></em></p><figure class="lf lg lh li fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es lm"><img src="../Images/0be9afa418f4d37e72f213503e58ae79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eCRSC7EY2kWgmAKnWVxzpg.png"/></div></div></figure><p id="451c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">然而，你可以得到更具体的。</p><p id="4af9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">一个协程可以在特定的条件下运行。这对于核心游戏循环非常有用，比如在玩家活着的时候让敌人产卵。</p><p id="ef03" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">代码示例:</strong></p><figure class="lf lg lh li fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es ln"><img src="../Images/70da00ccfaf22fc111436e0c7ed34421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MkyIdyZcbxz5HkWlttXOpA.png"/></div></div></figure><p id="6428" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在这个例子中，敌人会在屏幕限制内的随机位置出现。除非玩家死亡或者赢得游戏，否则<strong class="it hj">_停止产卵</strong>条件为假。这意味着这个例程将只运行<strong class="it hj">当</strong>玩家还活着或者游戏还在运行，否则它不会停止。</p><p id="b2d0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">什么样子:</strong></p><figure class="lf lg lh li fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es lo"><img src="../Images/2ec0432243db1f24dd5a2e41ea5abeb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Koy5nyWPJFpmaoHT4P5NuA.gif"/></div></div></figure><p id="ce81" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果你想知道为什么在对象中有一个处理父类的变换，这是一个在产生大量游戏对象时用来清理层次的技巧。我将在我的下一篇<a class="ae jp" href="https://dennisse-pd.medium.com/spawning-objects-without-clutter-in-unity-c23c2aa347ed" rel="noopener">文章</a>中讨论清理！</p></div></div>    
</body>
</html>