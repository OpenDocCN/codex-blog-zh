<html>
<head>
<title>Distributed Services using gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用gRPC的分布式服务</h1>
<blockquote>原文：<a href="https://medium.com/codex/distributed-services-using-grpc-100743363c6b?source=collection_archive---------0-----------------------#2021-01-24">https://medium.com/codex/distributed-services-using-grpc-100743363c6b?source=collection_archive---------0-----------------------#2021-01-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="249f" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">抄本</a></h2><div class=""/><div class=""><h2 id="f878" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">gRPC实用指南及其使用方法。NET和Python</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/46c53e32f36f661e14d5a3ad0490f3d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PBzJf-2pAD_RV1NB-1HK9A.png"/></div></div></figure><p id="1752" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">高效的通信通常是现代软件系统的主要驱动力之一，即使在微服务驱动的世界中也是如此。gRPC可以满足这些要求。在本文中，我们将研究gRPC的一些基础知识，并使用. NET实现第一个客户机和服务器应用程序。此外，一个基于Python的客户机演示了不同服务之间的高效通信是多么容易。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="149e" class="kv kw hi bd kx ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">gRPC是什么？</h1><p id="b156" class="pw-post-body-paragraph js jt hi ju b jv ln is jx jy lo iv ka kb lp kd ke kf lq kh ki kj lr kl km kn hb bi translated">gRPC是在分布式系统的不同端点之间进行通信的协议。它使用HTTP/2和协议缓冲区(protobuf)。像任何其他RPC系统一样，gRPC由一个服务器组成，它定义了客户机可以调用的方法和响应。然后，客户端实现特定的服务器存根，并可以使用提供的方法，如下图所示。NET和Python。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ls"><img src="../Images/5ab8d0f4c697219b6747e22cb74fd0c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqBz8GSSQpOQ_y-rtqhxRw.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">gRPC通信模式</figcaption></figure><p id="6b02" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">gRPC可以使用protobuf作为接口定义语言和传输消息的交换格式。它支持许多编程语言，如Android Java、C#、C++、Dart、Go、Java、Kotlin、Node.js、Objective-C、PHP、Python和Ruby。软件开发工具包(SDK)通常支持特定语言的实现。因此，基于gRPC，你可以快速实现用不同语言编写的分布式系统或微服务，这取决于开发人员偏好的编程语言。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="81e0" class="kv kw hi bd kx ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">协议缓冲区</h1><blockquote class="lx"><p id="0d48" class="ly lz hi bd ma mb mc md me mf mg kn dx translated">协议缓冲区是Google的语言中立、平台中立、可扩展的机制，用于序列化结构化数据。(【https://developers.google.com/protocol-buffers】T4)</p></blockquote><p id="6783" class="pw-post-body-paragraph js jt hi ju b jv mi is jx jy mj iv ka kb mk kd ke kf ml kh ki kj mm kl km kn hb bi translated">默认情况下，gRPC使用协议缓冲区(protobuf)进行数据交换和接口定义语言。Protocol buffers是一种用于序列化结构化数据的开源机制，由Google开发。在这一节中，我们将看看protobuf如何被用作数据交换格式和接口定义语言。让我们从一个简单的文件<code class="du mn mo mp mq b">foo.proto</code>开始，它定义了要序列化的数据的结构。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="ddb4" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在前面的例子中，您可以看到protobuf使用消息来结构化数据。它们中的每一个都包含一组名值对，称为字段。因此，您可以将protobuf中的消息看作是面向对象编程语言中的一种类或结构。</p><p id="e468" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在是时候用您喜欢和支持的编程语言将protobuf消息定义编译成相应的类型了。因此，protobuf编译器<code class="du mn mo mp mq b">protoc</code>可以在<a class="ae mh" href="https://github.com/protocolbuffers/protobuf/releases/" rel="noopener ugc nofollow" target="_blank"> GitHub发布页面</a>下载。</p><p id="6771" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">对于C#来说，下面的命令将生成可以通过协议缓冲API用来发送和接收消息的类。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="03e1" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在我们的示例中，生成的C#代码包括:</p><ul class=""><li id="2d09" class="mt mu hi ju b jv jw jy jz kb mv kf mw kj mx kn my mz na nb bi translated">包含关于protobuf消息的元数据的类<code class="du mn mo mp mq b">FooReflection</code></li><li id="b481" class="mt mu hi ju b jv nc jy nd kb ne kf nf kj ng kn my mz na nb bi translated">实现<code class="du mn mo mp mq b">IMessage&lt;Foo&gt;</code>并提供属性<code class="du mn mo mp mq b">Id</code>和<code class="du mn mo mp mq b">Description</code>的类<code class="du mn mo mp mq b">Foo</code>。</li></ul><p id="36ba" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">此外，类<code class="du mn mo mp mq b">Foo</code>提供了序列化和反序列化相关的方法。若要在C#中发送和接收消息，请使用以下示例中所示的方法。我们在这里使用内存流，但它也可以是任何其他流。请注意NuGet包<a class="ae mh" href="https://www.nuget.org/packages/Google.Protobuf/" rel="noopener ugc nofollow" target="_blank">谷歌。读写流需要Protobuf </a>。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="32fc" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">关于<code class="du mn mo mp mq b">protoc</code>如何生成C#代码的更多信息可以在这里找到:<a class="ae mh" href="https://developers.google.com/protocol-buffers/docs/reference/csharp-generated" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/protocol-buffers/docs/reference/cs harp-generated</a></p><p id="aee0" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">根据gRPC，protobuf也支持接口定义。<code class="du mn mo mp mq b">protoc</code>附带了一个额外的插件来生成客户端和服务器端代码。以下示例显示了gRPC接口定义的一个小样本。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="bb7a" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在前面的例子中，定义了gRPC服务<code class="du mn mo mp mq b">FooService</code>。这个服务提供了一元方法<code class="du mn mo mp mq b">GetFoo</code>。如您所见，请求和响应对象被定义为protobuf消息。同样<code class="du mn mo mp mq b">protoc</code>可用于以首选编程语言生成代码。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="42c9" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">对于C#来说，使用<a class="ae mh" href="https://www.nuget.org/packages/Grpc.Tools/" rel="noopener ugc nofollow" target="_blank"> Grpc是最好的方法。工具</a> NuGet包。在本文的后面，我们将研究C#工具集成。在gRPC接口定义和C#作为编程语言的情况下，产生的代码现在包括:</p><p id="4fed" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">总的来说:</p><ul class=""><li id="044e" class="mt mu hi ju b jv jw jy jz kb mv kf mw kj mx kn my mz na nb bi translated">保存关于protobuf请求和响应消息的元数据的类“FooReflection”。</li><li id="2ff9" class="mt mu hi ju b jv nc jy nd kb ne kf nf kj ng kn my mz na nb bi translated">实现<code class="du mn mo mp mq b">IMessage&lt;FooRequest&gt;</code>并为方法<code class="du mn mo mp mq b">GetFoo</code>的gRPC请求提供属性的类<code class="du mn mo mp mq b">FooRequest</code>。</li><li id="95b4" class="mt mu hi ju b jv nc jy nd kb ne kf nf kj ng kn my mz na nb bi translated">实现<code class="du mn mo mp mq b">IMessage&lt;FooResponse&gt;</code>并为方法<code class="du mn mo mp mq b">GetFoo</code>的gRPC响应提供字段的类<code class="du mn mo mp mq b">FooResponse</code>。</li></ul><p id="299d" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在服务器端代码生成的情况下:</p><ul class=""><li id="62a9" class="mt mu hi ju b jv jw jy jz kb mv kf mw kj mx kn my mz na nb bi translated">充当特定服务实现的基类的类<code class="du mn mo mp mq b">FooServiceBase</code>。</li></ul><p id="511f" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在客户端代码生成的情况下:</p><ul class=""><li id="3178" class="mt mu hi ju b jv jw jy jz kb mv kf mw kj mx kn my mz na nb bi translated">包含通过gRPC通道与服务器端部分交互的存根的类<code class="du mn mo mp mq b">FooServiceClient</code>。</li></ul></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="c83c" class="kv kw hi bd kx ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">沟通模式</h1><p id="0690" class="pw-post-body-paragraph js jt hi ju b jv ln is jx jy lo iv ka kb lp kd ke kf lq kh ki kj lr kl km kn hb bi translated">在前面的服务定义中，一元方法用于客户端和服务器之间的交互。但是gRPC客户机和服务器可以有更多的交互方式。</p><p id="a90a" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">一元RPC<br/>T5】一个客户端向服务器发送一个请求，得到一个响应</strong></p><pre class="jh ji jj jk fd nh mq ni nj aw nk bi"><span id="d5e7" class="nl kw hi mq b fi nm nn l no np">rpc GetFoo (FooRequest) returns (FooResponse);</span></pre><p id="7393" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">服务器流RPCs <br/> </strong>客户端向服务器发送请求，获取流以读取消息序列。在接口定义中，它是通过在响应前使用附加的stream关键字来声明的。</p><pre class="jh ji jj jk fd nh mq ni nj aw nk bi"><span id="506c" class="nl kw hi mq b fi nm nn l no np">rpc GetFoos(FooRequest) returns (stream FooResponse);</span></pre><p id="adb4" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">客户端流RPC<br/></strong>客户端编写一个消息序列，并发送给服务器。写完之后，客户端等待，直到服务器读取它们并返回响应。在接口定义中，它是通过在请求前使用附加的stream关键字来声明的。</p><pre class="jh ji jj jk fd nh mq ni nj aw nk bi"><span id="1061" class="nl kw hi mq b fi nm nn l no np">rpc SendFoos(stream FooRequest) returns (FooResponse);</span></pre><p id="cd13" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">双向流RPC<br/></strong>双方使用读和写流发送一系列消息。两个流都是独立的。在接口定义中，它是通过在请求和响应之前使用附加的stream关键字来声明的。</p><pre class="jh ji jj jk fd nh mq ni nj aw nk bi"><span id="1c9c" class="nl kw hi mq b fi nm nn l no np">rpc SendAndGetFoos(stream FooRequest) returns (stream FooResponse);</span></pre><p id="c207" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">gRPC中的连接可以由服务器、客户端终止，也可以由超时触发。客户端和服务器对呼叫状态进行独立的本地确定。因此，流调用可能在服务器上成功，但在客户端上由于超时而失败。如果取消，客户端或服务器所做的任何更改都不会自动回滚。连接立即终止。具体来说，关于连接和元数据处理的行为通常是特定于语言的。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="49fa" class="kv kw hi bd kx ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">C#中的第一个服务器和客户端应用程序</h1><p id="66e0" class="pw-post-body-paragraph js jt hi ju b jv ln is jx jy lo iv ka kb lp kd ke kf lq kh ki kj lr kl km kn hb bi translated">让我们从. NET中第一个完整的gRPC客户端和服务器开始。使用Visual Studio，很容易创建这两个应用程序。使用项目向导，你要搜索<code class="du mn mo mp mq b">gRPC</code>，按照助手的步骤操作，如下图所示。您可以选择启用Docker支持，但这不是本文的重点。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nq"><img src="../Images/8034003572f5c4174b44e2215749cd45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhNEU0rijQJU5qFxGgwf1w.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">使用Visual Studio 2019创建新的gRPC项目</figcaption></figure><p id="2c74" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">然后，Visual Studio创建一个gRPC服务器项目，我们就可以开始了。通过修改基于protobuf的接口定义并在生成的文件中实现定制的业务逻辑，我们可以完成gRPC服务器。但是幕后发生了什么呢？</p><p id="8a26" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">但是，Visual Studio创建了protobuf文件以及一个用于服务器实现的类。但是还有更多的事情发生。*。csproj-file使用标签显式引用我们的protobuf。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="8e51" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">该项告诉Visual Studio将该文件视为gRPC客户端和服务器生成的输入。属性<code class="du mn mo mp mq b">GrpcServices</code>指定Visual Studio应该生成哪些部分。</p><p id="f9c0" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">*csproj文件中第二个重要的引用是NuGet包<a class="ae mh" href="https://www.nuget.org/packages/Grpc.AspNetCore" rel="noopener ugc nofollow" target="_blank"> Grpc。AspNetCore </a>。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="7bbe" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">通过这个包<a class="ae mh" href="https://www.nuget.org/packages/Grpc.Tools/" rel="noopener ugc nofollow" target="_blank"> Grpc。工具</a>也将在我们的解决方案中提供。<code class="du mn mo mp mq b">Grpc.Tools</code>提供使用protoc编译器处理protobuf文件的支持。有了这个基本设置，链接的protobuf文件会在每次构建时编译，或者在由Run Custom Tool上下文菜单项触发时编译。</p><p id="618a" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">因为gRPC服务器应用程序是基于ASP.NET核心的，所以我们的项目包含一个<code class="du mn mo mp mq b">Startup.cs</code>。在这个文件中，可以使用<code class="du mn mo mp mq b">AddGrpc</code>和<code class="du mn mo mp mq b">MapGrpcService&lt;T&gt;</code>轻松激活gRPC支持，其中T是我们的gRPC服务实现。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="ea83" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">gRPC使用HTTP/2作为其传输协议。因此，Kestrel(ASP.NET核心中使用的web服务器)需要通过<code class="du mn mo mp mq b">appsettings.json</code>或<code class="du mn mo mp mq b">Program.cs</code>进行配置。以下示例建议所有端点使用HTTP/2作为传输协议。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="0aef" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">或者，您可以指定多个端点，每个端点都使用特定的配置。例如，当在一个项目中托管REST API和gRPC API，并且您希望REST API使用HTTP/1作为传输协议时，可以使用这种设置。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="106e" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">此外，gRPC端点应采用传输层安全性(TLS)来保护。在开发过程中，会自动生成受TLS保护的端点。通常，系统会提示您信任相应的证书，但是您可以使用命令<code class="du mn mo mp mq b">dotnet dev-certs https --trust</code>来触发该过程。在生产中，必须通过<code class="du mn mo mp mq b">appsettings.json</code>或<code class="du mn mo mp mq b">Program.cs</code>用您的特定证书参数配置TLS。通过属性<code class="du mn mo mp mq b">Certificate</code>可以将所有需要的参数提供给Kestrel。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="95e2" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在是时候构建我们的第一个客户端应用程序了。创建一个新的。NET核心控制台应用并安装NuGet包<a class="ae mh" href="https://www.nuget.org/packages/Google.Protobuf/" rel="noopener ugc nofollow" target="_blank"> Google。Protobuf </a>，<a class="ae mh" href="https://www.nuget.org/packages/Grpc.Net.Client/" rel="noopener ugc nofollow" target="_blank"> Grpc。Net客户端</a>和<a class="ae mh" href="https://www.nuget.org/packages/Grpc.Tools/" rel="noopener ugc nofollow" target="_blank"> Grpc。工具</a>。之后，只需添加一个链接到您已经用来创建服务器应用程序的protobuf文件。产生的*。csproj-file可以看起来像这个示例文件。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="bac1" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">请注意，<code class="du mn mo mp mq b">&lt;Protobuf/&gt;</code>标签的属性<code class="du mn mo mp mq b">GrpcServices</code>被设置为值<code class="du mn mo mp mq b">Client</code>。这建议协议编译器创建客户端存根而不是服务器相关部分。</p><p id="d210" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">所以让我们开始创建我们的客户端。首先，我们必须使用gRPC服务器应用程序的URI创建一个<code class="du mn mo mp mq b">GrpcChannel</code>。第二步，我们可以使用这个通道来设置我们的gRPC服务客户端。使用这个客户端，我们可以调用所有已定义的方法。以下示例显示了一元RPC调用。在中使用不支持TLS的gRPC客户端。NET Core 3.x，还需要一个额外的步骤。我们的应用上下文的开关<code class="du mn mo mp mq b">System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport</code>必须是<code class="du mn mo mp mq b">true</code>。应用程序使用。NET 5框架不需要额外的配置，但是要调用不安全的gRPC服务，他们必须使用2.32.0或更高版本。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="1b50" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">当使用ASP.NET核心应用程序时，gRPC客户端实现使用<code class="du mn mo mp mq b">HttpClientFactory</code>集成更加容易。因此，安装<a class="ae mh" href="https://www.nuget.org/packages/Grpc.Net.ClientFactory" rel="noopener ugc nofollow" target="_blank"> Grpc即可。Net.ClientFactory </a>启动时打包并注册gRPC服务:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="545b" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">gRPC客户端类型在ASP.NET核心依赖注入机制中注册为临时。因此，客户端可以很容易地在依赖注入创建的类型中被注入和消费，例如控制器。</p><p id="3781" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">当您开始使用C#构建第一个gRPC服务器和客户机时，您只需要知道这些。请参阅文章末尾的代码参考，以获得完整的工作示例。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="2ea8" class="kv kw hi bd kx ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">Python遇上了。网</h1><p id="da96" class="pw-post-body-paragraph js jt hi ju b jv ln is jx jy lo iv ka kb lp kd ke kf lq kh ki kj lr kl km kn hb bi translated">由于gRPC可以在许多编程语言中使用，所以它支持它们之间的通信。我们来考虑多个微服务。一个用C#开发，一个用Node.js，还有一个用Python。当然，它们都可以整合。在本节中，我们将重点讨论。NET和Python。(请注意，以下示例要求在各自的系统上安装Python和pip)</p><p id="0c33" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在开始编写Python客户端之前，我们必须安装gRPC相关的依赖项，并为protobuf文件生成Python存根。以下命令演示了所需的步骤:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="76bb" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这些步骤的结果包含两个文件:</p><ul class=""><li id="6658" class="mt mu hi ju b jv jw jy jz kb mv kf mw kj mx kn my mz na nb bi translated">包含生成的请求和响应类</li><li id="2176" class="mt mu hi ju b jv nc jy nd kb ne kf nf kj ng kn my mz na nb bi translated"><code class="du mn mo mp mq b">foo_pb2_grpc.py</code>包含生成的客户端和服务器类。</li></ul><p id="53fb" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">我们的gRPC服务器基于ASP.NET核心运行，并使用TLS进行安全通信，因此我们必须导出。NET开发证书优先。因此，您必须使用命令<code class="du mn mo mp mq b">certmgr</code>打开Windows证书管理器。在证书管理器中，导航到<code class="du mn mo mp mq b">Current user &gt; Personal &gt; Certificates</code>并导出将<code class="du mn mo mp mq b">ASP.NET Core HTTPS development certificate</code>设置为友好名称的证书。请使用以下导出选项<code class="du mn mo mp mq b">Without key, DER-coded X.509 (.cer)</code>。默认情况下，Python支持使用PEM格式的证书。所以最简单的方法就是把我们的证书转换成这种格式。这可以使用命令<code class="du mn mo mp mq b">openssl x509 -inform der -in localhost.cer -out localhost.pem</code>来完成。</p><p id="6451" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">最后，我们来看看使用Python实现gRPC客户机的例子。我们使用生成的gRPC存根和我们的证书来设置简单的测试客户端，如下面的代码片段所示:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="c50f" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在您可以使用<code class="du mn mo mp mq b">python client.py</code>运行Python应用程序。该脚本使用安全的通信通道调用我们基于ASP.NET核心的gRPC服务器，并将服务器响应打印到控制台。</p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="1f72" class="kv kw hi bd kx ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">包扎</h1><p id="477a" class="pw-post-body-paragraph js jt hi ju b jv ln is jx jy lo iv ka kb lp kd ke kf lq kh ki kj lr kl km kn hb bi translated">在本文中，我向您介绍了gRPC的基础知识，以及如何使用各种编程语言来使用它。基于此，您现在可以构建自己的服务，以非常高效的方式进行通信。英寸NET 5的gRPC堆栈有进一步的性能改进。因此，如果不使用gRPC，就没有理由构建服务间调用。</p><p id="175f" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在GitHub上，有一个完整的工作示例应用程序。它涵盖了客户机和服务器应用程序，以及用不同编程语言编写的不同服务之间的通信。(<a class="ae mh" href="https://github.com/fzankl/grpc-sample" rel="noopener ugc nofollow" target="_blank">示例如何使用gRPC。NET Core/ASP.NET Core和Python </a></p><p id="6eee" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">本文最初发表于:<a class="ae mh" href="https://www.fzankl.de/en/blog/distributed-services-using-grpc-in-dotnet-and-python" rel="noopener ugc nofollow" target="_blank">https://www . fzankl . de/en/blog/distributed-services-using-grpc-in-dot net-and-python</a></p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><h1 id="fe7f" class="kv kw hi bd kx ky kz la lb lc ld le lf ix lg iy lh ja li jb lj jd lk je ll lm bi translated">参考</h1><div class="nr ns ez fb nt nu"><a href="https://grpc.io/docs/" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab dw"><div class="nw ab nx cl cj ny"><h2 class="bd hs fi z dy nz ea eb oa ed ef hr bi translated">证明文件</h2><div class="ob l"><h3 class="bd b fi z dy nz ea eb oa ed ef dx translated">了解gRPC的主要概念，尝试快速入门，查找所有受支持语言的教程和参考资料，以及…</h3></div><div class="oc l"><p class="bd b fp z dy nz ea eb oa ed ef dx translated">grpc.io</p></div></div><div class="od l"><div class="oe l of og oh od oi jq nu"/></div></div></a></div><div class="nr ns ez fb nt nu"><a href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab dw"><div class="nw ab nx cl cj ny"><h2 class="bd hs fi z dy nz ea eb oa ed ef hr bi translated">语言指南|协议缓冲区| Google开发者</h2><div class="ob l"><h3 class="bd b fi z dy nz ea eb oa ed ef dx translated">本指南描述了如何使用协议缓冲区语言来构建您的协议缓冲区数据，包括。原型…</h3></div><div class="oc l"><p class="bd b fp z dy nz ea eb oa ed ef dx translated">developers.google.com</p></div></div><div class="od l"><div class="oj l of og oh od oi jq nu"/></div></div></a></div><div class="nr ns ez fb nt nu"><a href="https://developers.google.com/protocol-buffers/docs/reference/csharp-generated" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab dw"><div class="nw ab nx cl cj ny"><h2 class="bd hs fi z dy nz ea eb oa ed ef hr bi translated">C#生成的代码|协议缓冲区| Google开发者</h2><div class="ob l"><h3 class="bd b fi z dy nz ea eb oa ed ef dx translated">本页准确描述了协议缓冲编译器使用proto3为协议定义生成的C#代码</h3></div><div class="oc l"><p class="bd b fp z dy nz ea eb oa ed ef dx translated">developers.google.com</p></div></div><div class="od l"><div class="ok l of og oh od oi jq nu"/></div></div></a></div><div class="nr ns ez fb nt nu"><a href="https://docs.microsoft.com/de-de/aspnet/core/grpc/" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab dw"><div class="nw ab nx cl cj ny"><h2 class="bd hs fi z dy nz ea eb oa ed ef hr bi translated">gRPC中的一个。网络核心</h2><div class="ob l"><h3 class="bd b fi z dy nz ea eb oa ed ef dx translated">gRPC的主要好处是:gRPC是一个很好的发展中国家。</h3></div><div class="oc l"><p class="bd b fp z dy nz ea eb oa ed ef dx translated">docs.microsoft.com</p></div></div><div class="od l"><div class="ol l of og oh od oi jq nu"/></div></div></a></div><div class="nr ns ez fb nt nu"><a href="https://devblogs.microsoft.com/aspnet/grpc-performance-improvements-in-net-5/" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab dw"><div class="nw ab nx cl cj ny"><h2 class="bd hs fi z dy nz ea eb oa ed ef hr bi translated">中gRPC性能的改进。NET 5 | ASP.NET博客</h2><div class="ob l"><h3 class="bd b fi z dy nz ea eb oa ed ef dx translated">James gRPC是一个现代的开源远程过程调用框架。gRPC中有许多令人兴奋的特性:实时…</h3></div><div class="oc l"><p class="bd b fp z dy nz ea eb oa ed ef dx translated">devblogs.microsoft.com</p></div></div><div class="od l"><div class="om l of og oh od oi jq nu"/></div></div></a></div></div></div>    
</body>
</html>