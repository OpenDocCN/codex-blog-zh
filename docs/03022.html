<html>
<head>
<title>Understanding the ES6 Features of JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript的ES6特性</h1>
<blockquote>原文：<a href="https://medium.com/codex/understanding-the-es6-features-of-javascript-569bbd874fd1?source=collection_archive---------11-----------------------#2021-08-15">https://medium.com/codex/understanding-the-es6-features-of-javascript-569bbd874fd1?source=collection_archive---------11-----------------------#2021-08-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9f5d7cf3c1cce28c6bd6877d4e5c1687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ErMFSfh-eR-GSzIX"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像来源- <a class="ae iu" href="https://unsplash.com/s/photos/coding" rel="noopener ugc nofollow" target="_blank">去飞溅</a></figcaption></figure><p id="32db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ECMAScript 6缩写为ES6。ES6是ECMAScript的第六个版本，于2015年发布，被称为ECMAScript 2015。</p><p id="2633" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们看看ES6中包含了什么</p><h1 id="d180" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">箭头功能</strong></h1><p id="21dc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对于编写函数表达式，箭头函数提供了简化的语法。<br/>函数关键字、返回关键字和花括号不是必需的。</p><p id="edd1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑一个函数声明的例子:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d6ce" class="lf ju hi lb b fi lg lh l li lj">//function declaration</span><span id="7da3" class="lf ju hi lb b fi lk lh l li lj">function favouriteFood() {</span><span id="bdc3" class="lf ju hi lb b fi lk lh l li lj">return "I'm going to have pizza for lunch";</span><span id="0d06" class="lf ju hi lb b fi lk lh l li lj">}</span></pre><p id="3d42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用箭头功能:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="098a" class="lf ju hi lb b fi lg lh l li lj">const lunchMenu = pizza=&gt; `I'm going to eat a ${pizza} for lunch`;</span><span id="537f" class="lf ju hi lb b fi lk lh l li lj">console.log( lunchMenu("onion") );</span></pre><h1 id="c1e9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">模板文字</strong></h1><p id="4df8" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">带有嵌入表达式的字符串文字称为模板文字。多行字符串和字符串插值功能可以与它们一起使用。在ES2015规范的先前版本中，它们被称为“<strong class="ix hj">模板字符串</strong>”</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c482" class="lf ju hi lb b fi lg lh l li lj">let num1 = 2;</span><span id="c94f" class="lf ju hi lb b fi lk lh l li lj">let num2 = 3;</span><span id="dd94" class="lf ju hi lb b fi lk lh l li lj">const fullName = `${num1 + num2}`;<br/>console.log(fullName)</span></pre><h1 id="cac1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">解构对象</h1><p id="46bc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">使用对象析构，你可以从对象中提取属性，并将它们赋给JavaScript中的变量。对象析构还允许你在一条语句中提取许多属性，从嵌套对象中访问属性，如果属性不存在，设置一个默认值。</p><p id="dece" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们析构下面的对象:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c263" class="lf ju hi lb b fi lg lh l li lj">const employee = {</span><span id="d4d4" class="lf ju hi lb b fi lk lh l li lj">name: "Kim",</span><span id="51cb" class="lf ju hi lb b fi lk lh l li lj">age: 24,</span><span id="8145" class="lf ju hi lb b fi lk lh l li lj">department: {</span><span id="91ff" class="lf ju hi lb b fi lk lh l li lj">designation: "I am a software Dev "</span><span id="6cdb" class="lf ju hi lb b fi lk lh l li lj">}</span><span id="e901" class="lf ju hi lb b fi lk lh l li lj">}</span></pre><p id="fe72" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解构后:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6190" class="lf ju hi lb b fi lg lh l li lj">const employee = {</span><span id="3f04" class="lf ju hi lb b fi lk lh l li lj">name: "Kim",</span><span id="dfab" class="lf ju hi lb b fi lk lh l li lj">age: 24,</span><span id="9e5f" class="lf ju hi lb b fi lk lh l li lj">department: {</span><span id="2d3a" class="lf ju hi lb b fi lk lh l li lj">designation: "I am a software Dev "</span><span id="b593" class="lf ju hi lb b fi lk lh l li lj">}</span><span id="5415" class="lf ju hi lb b fi lk lh l li lj">}<br/>const { name, age, department: { designation} } = employee;</span><span id="739a" class="lf ju hi lb b fi lk lh l li lj">console.log(name);</span><span id="00a3" class="lf ju hi lb b fi lk lh l li lj">console.log(age);</span><span id="e074" class="lf ju hi lb b fi lk lh l li lj">console.log(designation);</span></pre><h1 id="de8d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">解构数组</h1><p id="725a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">可以从数组、对象和嵌套对象中获取数据，并使用析构赋值将数据赋给变量，析构赋值是一种JavaScript表达式，允许您将数组中的值或对象中的属性解包到不同的变量中。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b7d3" class="lf ju hi lb b fi lg lh l li lj">let [firstName, middleName, lastName] = ['Peter', 'John', 'Parkar'];</span><span id="3c05" class="lf ju hi lb b fi lk lh l li lj">console.log(lastName)// Parkar</span></pre><h1 id="0ef7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">对象文字</h1><p id="818c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在普通英语中，对象文字是用大括号括起来的逗号分隔的名称-值对列表。属性和函数可以用来表示这些值。</p><p id="59f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">具有一个属性和一个函数的对象文本片段如下所示。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3654" class="lf ju hi lb b fi lg lh l li lj">function studentAddress(address) {</span><span id="e33d" class="lf ju hi lb b fi lk lh l li lj">const {city, state} = address;</span><span id="0648" class="lf ju hi lb b fi lk lh l li lj">const newStudentAddress = {</span><span id="28e1" class="lf ju hi lb b fi lk lh l li lj">city,</span><span id="90a5" class="lf ju hi lb b fi lk lh l li lj">state,</span><span id="182a" class="lf ju hi lb b fi lk lh l li lj">country: 'India'</span><span id="a6cb" class="lf ju hi lb b fi lk lh l li lj">};</span><span id="1e5c" class="lf ju hi lb b fi lk lh l li lj">console.log(`${newStudentAddress.city}, ${newStudentAddress.state}, ${newStudentAddress.country}`)</span><span id="b70a" class="lf ju hi lb b fi lk lh l li lj">}</span><span id="fc03" class="lf ju hi lb b fi lk lh l li lj">studentAddress({city: 'Mumbai', state: 'Maharashtra'});</span></pre><h1 id="01a9" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">For of循环</h1><p id="901d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">for…of命令产生一个循环，该循环遍历可迭代对象，如内置字符串、数组、类似数组的对象(如参数或节点列表)、TypedArray、Map、Set和用户定义的可迭代对象。</p><p id="ce9a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们考虑下面的例子:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="821c" class="lf ju hi lb b fi lg lh l li lj">const students = [</span><span id="da16" class="lf ju hi lb b fi lk lh l li lj">{ name: "Kim", city: "Dubai" },</span><span id="9a09" class="lf ju hi lb b fi lk lh l li lj">{ name: "Peter", city: "Paris"},</span><span id="46bb" class="lf ju hi lb b fi lk lh l li lj">{ name: "Kelvin", city: "Amsterdam" }</span><span id="aa35" class="lf ju hi lb b fi lk lh l li lj">];</span><span id="165f" class="lf ju hi lb b fi lk lh l li lj">for( const student of students ) {</span><span id="f3a6" class="lf ju hi lb b fi lk lh l li lj">console.log( student.name + " lives in " + student.city );</span><span id="41af" class="lf ju hi lb b fi lk lh l li lj">}<br/>//Kim lives in Dubai <br/>//Peter lives in Paris<br/>//Kelvin lives in Amsterdam</span></pre><h1 id="ae3b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">扩展运算符</h1><p id="97b4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">spread操作符是JavaScript ES6操作符集中的新成员。它将一个iterable(例如，一个数组)扩展成单独的元素。为了制作JS对象的浅层副本，spread操作符被广泛使用。使用该运算符可以缩短并提高代码的可读性。</p><p id="6597" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设你要去商店买些杂货。所以你有一个购物清单数组，里面有你想买的所有东西。<br/>现在你在商场里，你有一个篮子，里面装着你清单上的所有商品，但你想再添加一些。<br/>向名为shoppingBasket的新数组中添加一些新产品，这将是shoppingList数组的副本。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="68e4" class="lf ju hi lb b fi lg lh l li lj">const shoppingList = ["bread", "milk", "butter"];</span><span id="120b" class="lf ju hi lb b fi lk lh l li lj">const shoppingBasket = [ ...shoppingList, "tofu", "pasta"];</span><span id="baa8" class="lf ju hi lb b fi lk lh l li lj">console.log(shoppingBasket);</span><span id="282e" class="lf ju hi lb b fi lk lh l li lj">//bread, milk, butter, tofu, pasta</span></pre><h1 id="f129" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Rest运算符</h1><p id="7d7b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们可以使用remainder参数语法将不定数量的参数指定为一个数组。使用rest参数可以调用带有任意数量参数的函数，而不管它是如何定义的。在ES2015或ES6中，添加了rest参数，提高了处理参数的能力。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="60db" class="lf ju hi lb b fi lg lh l li lj">function add(...nums) {</span><span id="eba6" class="lf ju hi lb b fi lk lh l li lj">console.log(nums);</span><span id="5f21" class="lf ju hi lb b fi lk lh l li lj">}</span><span id="9124" class="lf ju hi lb b fi lk lh l li lj">add(7, 8, 5, 4)</span><span id="d6f6" class="lf ju hi lb b fi lk lh l li lj">//[7, 8, 5, 4]</span></pre><h1 id="518d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">默认参数</h1><p id="244c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">当没有为函数参数提供值时，默认参数用于设置默认值(即未定义)。如果函数中没有提供参数，它的值将变得不确定。编译器使用我们在这种情况下指定的默认值。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="6e72" class="lf ju hi lb b fi lg lh l li lj">function foodShopping( food = "tomatoes") {</span><span id="d061" class="lf ju hi lb b fi lk lh l li lj">console.log(`I'm going to buy ${food} from the shop`);</span><span id="6371" class="lf ju hi lb b fi lk lh l li lj">}</span><span id="a211" class="lf ju hi lb b fi lk lh l li lj">foodShopping();</span></pre><h1 id="2b7f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">让和Const</h1><p id="c5c5" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">事实证明，const与let几乎相同。主要区别在于，一旦用const给变量赋值，就不能再给它重新赋值了。需要记住的是，用let声明的变量可以被重命名，而用const声明的变量则不能。</p><p id="d870" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看const的例子</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="0966" class="lf ju hi lb b fi lg lh l li lj">const originalPrice = 50;</span><span id="7054" class="lf ju hi lb b fi lk lh l li lj">const percentOff = 20;</span><span id="913e" class="lf ju hi lb b fi lk lh l li lj">const salePrice = originalPrice * (percentOff / 100);</span><span id="bafe" class="lf ju hi lb b fi lk lh l li lj">console.log(salePrice);</span></pre><p id="84bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看Let的例子</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5897" class="lf ju hi lb b fi lg lh l li lj">let x = 15;<br/>// Here x is 15<br/><br/>{<br/>let x = 2;<br/>// Here x is 2<br/>}</span></pre><h1 id="6a02" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">进出口</h1><p id="cd9b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">JavaScript ES6最重要的部分之一是导入和导出语句。它允许您将JavaScript类、方法、组件、常量和任何其他变量从一个JavaScript文件移动到另一个文件。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="9c4f" class="lf ju hi lb b fi lg lh l li lj">import { add } from './data.js';</span><span id="fab6" class="lf ju hi lb b fi lk lh l li lj">let result = add(6, 2);</span><span id="7bcb" class="lf ju hi lb b fi lk lh l li lj">console.log(result);<br/>//7</span></pre><h1 id="49c4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">尾随逗号</h1><p id="36b1" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">从一开始，JavaScript就支持数组文本中的尾部逗号，后来又将它们添加到对象文本、函数参数以及命名的导入和导出中。另一方面，JSON不允许尾随逗号。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="cb24" class="lf ju hi lb b fi lg lh l li lj">function add(param1,){</span><span id="612d" class="lf ju hi lb b fi lk lh l li lj">const example = {</span><span id="800d" class="lf ju hi lb b fi lk lh l li lj">name: 'Tom',</span><span id="aab8" class="lf ju hi lb b fi lk lh l li lj">};</span><span id="0d4e" class="lf ju hi lb b fi lk lh l li lj">console.log(example)</span><span id="4ceb" class="lf ju hi lb b fi lk lh l li lj">};</span><span id="a1d2" class="lf ju hi lb b fi lk lh l li lj">add(2);</span><span id="ffdb" class="lf ju hi lb b fi lk lh l li lj">//{name:"Tom"}</span></pre><h1 id="5644" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">承诺</h1><p id="5c94" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">JavaScript中的异步操作通过承诺来处理。当处理几个异步操作时，它们很容易管理，而回调会导致回调地狱和不可管理的代码。</p><p id="7bfe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们创建一个承诺，它返回一些用户数据，并在没有找到时抛出一个错误</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="ca10" class="lf ju hi lb b fi lg lh l li lj">const userData = new Promise((resolve, reject) =&gt; {</span><span id="586d" class="lf ju hi lb b fi lk lh l li lj">const error = false;</span><span id="0300" class="lf ju hi lb b fi lk lh l li lj">if(error) {</span><span id="5ec4" class="lf ju hi lb b fi lk lh l li lj">reject('No found');</span><span id="e158" class="lf ju hi lb b fi lk lh l li lj">} else {</span><span id="9606" class="lf ju hi lb b fi lk lh l li lj">resolve({</span><span id="7547" class="lf ju hi lb b fi lk lh l li lj">firstName: 'John',</span><span id="4b67" class="lf ju hi lb b fi lk lh l li lj">age: 32,</span><span id="7104" class="lf ju hi lb b fi lk lh l li lj">email: 'johncreta@gmail.com'</span><span id="c352" class="lf ju hi lb b fi lk lh l li lj">});</span><span id="f799" class="lf ju hi lb b fi lk lh l li lj">}</span><span id="7a15" class="lf ju hi lb b fi lk lh l li lj">});</span><span id="8398" class="lf ju hi lb b fi lk lh l li lj">userData</span><span id="8d15" class="lf ju hi lb b fi lk lh l li lj">.then((data) =&gt; console.log(data))</span><span id="a673" class="lf ju hi lb b fi lk lh l li lj">.catch((error) =&gt; console.log(error));</span></pre><h1 id="1be0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">取得</h1><p id="e6a6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Fetch API为您提供了一个JavaScript接口来访问和操作HTTP管道元素，如请求和响应。Fetch还为定义其他与HTTP相关的概念(如CORS和HTTP扩展)提供了一个逻辑位置。</p><p id="8e1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们考虑以下情况-</p><p id="5291" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">获取第一个注释值</strong>' https://jsonplaceholder . typicode . com/comments/1 '并记录其值。</p><p id="c5bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">使用</strong>‘https://jsonplaceholder . typicode . com/comments’发布新评论，并记录其值。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="d10a" class="lf ju hi lb b fi lg lh l li lj">fetch('https://jsonplaceholder.typicode.com/comments/1')</span><span id="c483" class="lf ju hi lb b fi lk lh l li lj">.then((response) =&gt; response.json())</span><span id="99a4" class="lf ju hi lb b fi lk lh l li lj">.then((data) =&gt; console.log(data))</span><span id="cb8b" class="lf ju hi lb b fi lk lh l li lj">fetch('https://jsonplaceholder.typicode.com/comments', {</span><span id="5d39" class="lf ju hi lb b fi lk lh l li lj">method: 'POST',</span><span id="8afe" class="lf ju hi lb b fi lk lh l li lj">body: JSON.stringify({</span><span id="7a10" class="lf ju hi lb b fi lk lh l li lj">name: 'Comment 109',</span><span id="c2ec" class="lf ju hi lb b fi lk lh l li lj">email: 'johnpeter@gmail.com',</span><span id="79f7" class="lf ju hi lb b fi lk lh l li lj">body: 'Hello Buddy',</span><span id="65ae" class="lf ju hi lb b fi lk lh l li lj">postId: 1</span><span id="6f14" class="lf ju hi lb b fi lk lh l li lj">})</span><span id="96e9" class="lf ju hi lb b fi lk lh l li lj">})</span><span id="54c6" class="lf ju hi lb b fi lk lh l li lj">.then((response) =&gt; response.json())</span><span id="a0f6" class="lf ju hi lb b fi lk lh l li lj">.then((data) =&gt; console.log(data))</span></pre><h1 id="1ca1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">异步和等待</h1><p id="69f7" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">开发Async/Await是为了使处理和编写链式承诺更加容易。异步函数返回一个承诺。如果函数返回一个错误，承诺将被拒绝。如果函数返回值，将解析承诺。</p><p id="c951" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我想在控制台上使用async和await打印一个来自Chuck Norris API的随机笑话:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f49b" class="lf ju hi lb b fi lg lh l li lj">const apiUrl = "https://api.chucknorris.io/jokes/random";</span><span id="9275" class="lf ju hi lb b fi lk lh l li lj">async function getJoke() {</span><span id="3abd" class="lf ju hi lb b fi lk lh l li lj">const response = await fetch(apiUrl);</span><span id="44b2" class="lf ju hi lb b fi lk lh l li lj">const data = await response.json();</span><span id="8e06" class="lf ju hi lb b fi lk lh l li lj">console.log(data.value);</span><span id="4d94" class="lf ju hi lb b fi lk lh l li lj">}</span><span id="e661" class="lf ju hi lb b fi lk lh l li lj">getJoke();</span></pre><p id="f112" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在这里了解更多关于ES6 <a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" rel="noopener ugc nofollow" target="_blank">的信息</a></p><p id="09e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你也可以在这里了解NodeJS集成<a class="ae iu" href="https://quickwork.co/apps/nodejs/integrations" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>