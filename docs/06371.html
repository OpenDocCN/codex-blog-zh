<html>
<head>
<title>Chapter 8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第八章</h1>
<blockquote>原文：<a href="https://medium.com/codex/chapter-8-71b28a3ec228?source=collection_archive---------24-----------------------#2022-04-20">https://medium.com/codex/chapter-8-71b28a3ec228?source=collection_archive---------24-----------------------#2022-04-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0607" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><strong class="ak">接口和抽象类</strong></h2></div><p id="5ab5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们应该通过使类抽象来防止类的形成(Animal anim = new Animal()；).在这种情况下，动物是指动物对象。</p><p id="17e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管编译器不允许我们构建抽象类的实例，但我们可以将它用作多态的声明引用类型。</p><p id="8744" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你不扩展一个抽象类，它就没有价值，没有用。在运行时，抽象类是你的抽象类的子类的实例。</p><p id="febe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们查看GUI组件时，它包含按钮、文本字段和滚动条等类，我们可以看到它有许多不同的类。当我们生成一个按钮时，我们不会创建该组件的一个实例并将其放在屏幕上。我们只是实例化组件的一个特定子类，而不是整个组件。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/4d22d8e4814cb4a2aa23f7c54430c14f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nqtkCg3MhqN_CNtq"/></div></div></figure><p id="f7cb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">行动中的多态性</strong></p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es kf"><img src="../Images/c76a0174e9fc939922deb0f56d8baaae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Urj34iJDhMMOtPcd"/></div></div></figure><p id="0176" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">-摘要- </strong></p><p id="3c4d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有主体但必须在另一个类中重写的方法称为抽象方法。只有抽象类才能有抽象方法。抽象类有可能同时获得抽象和非抽象方法。</p><p id="aa04" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用抽象方法时，必须在第一个实际的子类中实现它们。当子类实现抽象方法时，子类方法应该有一个主体和与抽象方法相同的返回类型。</p><p id="179a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们不能构建不同的抽象类型实例，但是我们可以声明一个数组对象来包含它。</p><p id="102a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Java中，每个类都是从类对象扩展而来的。对象由任何不显式扩展另一个类的类隐式扩展。</p><p id="e75b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为Java中的每个类都是object的子类，所以许多数组列表方法都利用了最终的多态类型对象。任何东西都可以被发送到这些数组列表函数中。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kg"><img src="../Images/d9a7e808515b5184f5df878132863127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/0*v9kXOeyfxWlABTMT"/></div></figure><p id="2dc0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对象出现在数组列表中，并作为类对象的一般实例运行。编译器不能暗示生成的对象与object的类型不同。</p><p id="e6ec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当一个对象被指定为object类型的变量引用时，不能将该对象赋给用实际对象类型声明的变量。因为任何类都通过了IS-A对象测试，所以我们可以将任何东西赋给引用类型对象。在Java中，每个对象都是object类型的一个实例。</p><p id="f32d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果引用变量的类包含方法，则只能调用对象上的方法。</p><p id="b8ed" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">多重继承</strong></p><p id="fedf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java编程语言中允许类型的多重继承，这意味着一个类可以实现多个接口。一个对象可以有许多类型，包括它自己的类的类型和它实现的所有接口的类型。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es kh"><img src="../Images/9b1361da48649e641bbaeb2a6dd22283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Td78cD2XEBOKzIou"/></div></div></figure><p id="3d57" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个叫做接口的解决方案给了这个死java的致命钻石。它克服了与多重继承相关的问题。接口中的所有方法都应该是抽象的，并且必须在具体的类中实现。所以JVM不会混淆在运行时应该使用两个继承版本中的哪一个。</p><p id="5168" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有的接口方法都应该是抽象的，每个具体的类都必须实现接口方法。</p><p id="11bb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当将一个类实现为多态类型时，可以留在那个类型中的对象必须来自同一个继承树，而不仅仅是任何一个继承树；它们必须来自多态类型的子类。然而，当接口被用作多态类型时，对象可以来自继承树中的任何地方。只要求对象来自实现接口的类。</p><p id="f3f2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">类、子类、抽象类、接口</strong></p><ul class=""><li id="be42" class="ki kj hi iz b ja jb jd je jg kk jk kl jo km js kn ko kp kq bi translated">创建一个不以任何方式扩展的类。如果一个新类没有通过IS-A测试。</li><li id="7589" class="ki kj hi iz b ja kr jd ks jg kt jk ku jo kv js kn ko kp kq bi translated">只有当你需要重写或添加新的行为到一个更具体的类版本时，才创建一个子类。</li><li id="ff16" class="ki kj hi iz b ja kr jd ks jg kt jk ku jo kv js kn ko kp kq bi translated">当你计划为一个子类集合构建一个模板，并且你至少有一些所有子类都可以使用的实现代码时，使用一个抽象类。当你想确保没有人能创建这种类型的对象时，就把这个类变成抽象的。</li><li id="aa32" class="ki kj hi iz b ja kr jd ks jg kt jk ku jo kv js kn ko kp kq bi translated">当你希望创建一个其他类可以完成的角色，而不管它们在继承树中的位置，使用一个接口。</li></ul><p id="a50f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.对象参数和/或返回类型可用于声明方法。</p><p id="2a86" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.不管实际的对象类型如何，只有当方法位于用作引用变量类型的类(或接口)中时，才能调用对象上的方法。因此，不管引用所引用的对象是什么类型，object类型的引用变量只能用于调用class Object中指定的方法。</p><p id="1cfb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.没有强制转换的类型引用变量，不能将对象赋给任何其他引用类型。强制转换可用于将一种类型的引用变量赋给子类型的引用变量，但如果堆上的对象不是与强制转换兼容的类型，则强制转换将在运行时失败。</p><p id="51d3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.例如:Van Van =(Van)Van . getobject(aVan)；</p><p id="b303" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.数组列表中的所有对象都属于Object类型(也就是说，除非使用强制转换，否则它们只能被对象引用变量引用)。<object>作为类型对象(意思是，它们只能被一个对象引用变量引用，除非你使用强制转换)。</object></p></div></div>    
</body>
</html>