<html>
<head>
<title>Enabling Client-Side Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">启用客户端搜索</h1>
<blockquote>原文：<a href="https://medium.com/codex/enabling-client-side-search-7f6cc7837f86?source=collection_archive---------11-----------------------#2022-02-04">https://medium.com/codex/enabling-client-side-search-7f6cc7837f86?source=collection_archive---------11-----------------------#2022-02-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="e9ee" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">免税品</h2><div class=""/><div class=""><h2 id="5d81" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated"><em class="jg">出自</em> <a class="ae jh" href="https://www.manning.com/books/hugo-in-action?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_jain_hugo_9_24_19" rel="noopener ugc nofollow" target="_blank"> <em class="jg">雨果在行动</em> </a> <em class="jg">出自阿提亚·贾恩</em></h2></div><p id="80d1" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">在本文中，我们将展示如何为Jamstack网站构建一个搜索小部件。</em></p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="36e3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在<a class="ae jh" href="https://www.manning.com/?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_jain_hugo_9_24_19" rel="noopener ugc nofollow" target="_blank">manning.com</a>结账时，将<strong class="jk hs"> fccjain </strong>输入折扣代码框，即可享受<a class="ae jh" href="https://www.manning.com/books/hugo-in-action?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_jain_hugo_9_24_19" rel="noopener ugc nofollow" target="_blank"> <em class="ke"> Hugo in Action </em> </a>的六折优惠。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="476c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">就像动态表单提交一样，在您输入时实时显示结果的搜索小部件需要JavaScript。既然我们已经为网站准备好了JS代码和基于JSON的伪API的框架结构，我们可以使用它们来提供客户端搜索。</p><h2 id="43af" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">客户端搜索的概念</strong></h2><p id="736d" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">在传统系统中，搜索是基于服务器的，客户端提供的关键字映射到搜索索引中的值，该索引为关键字提供最佳排名页面。客户端搜索的概念是，服务器向客户端提供这个索引(或者客户端动态构建它)，并且这个映射发生在客户端。</p><p id="152a" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">与基于服务器的搜索相比，客户端搜索有很多优势:</p><ul class=""><li id="be7a" class="ll lm hi jk b jl jm jo jp jr ln jv lo jz lp kd lq lr ls lt bi translated">搜索索引像Jamstack中的其他东西一样是静态的。它可以分布在CDN上，并提供CDN必须提供的所有缓存和性能优势。</li><li id="7da6" class="ll lm hi jk b jl lu jo lv jr lw jv lx jz ly kd lq lr ls lt bi translated">搜索索引被按需推送到客户端，甚至被预加载。因此，在向服务器发送击键时没有往返时间损失，并且搜索变得更快。</li><li id="ac3f" class="ll lm hi jk b jl lu jo lv jr lw jv lx jz ly kd lq lr ls lt bi translated">不需要额外的服务器来维护和保持与数据库的同步。用户的机器提供执行搜索所需的资源。</li><li id="71bf" class="ll lm hi jk b jl lu jo lv jr lw jv lx jz ly kd lq lr ls lt bi translated">即使用户在加载初始网页后离线，搜索也可以工作。</li></ul><p id="ecec" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">客户端搜索的最大限制是索引的大小。如果我们有一个大范围的索引，那么搜索索引的预加载可能会被证明是带宽密集型的，没有任何实际用途。我们可以拆分索引并按需分部分加载，但是扩展这种方法会回到由服务器维护整个索引的世界。</p><p id="bc0c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">对于大多数网站来说，从现代网络的角度来看，文本内容并不是非常庞大。2 MB的数据可以存储200万个字符。对于基于文本的搜索索引来说，这个数字是相当可观的，但对于网页来说，这并不是一个巨大的开销，因为我们在网站上经常会有这样大小的图像。虽然我们可以在Hugo中创建一个更加优化和健壮的搜索索引，但是Acme Corporation网站中的数据量非常小，我们通过JSON伪API提供所有数据。我们甚至可以将搜索索引的创建转移到JavaScript上。</p><h2 id="adc4" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">在标题中显示搜索框</strong></h2><p id="614d" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">搜索小部件由一个输入框和一个结果下拉列表组成，用于显示部分查询的结果。我们将把它添加到网站标题。</p><p id="c986" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单1。要添加到网站标题的搜索表单。(AcmeTheme/layouts/_ default/base of . html)</strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="140d" class="km kn hi me b fi mi mj l mk ml">&lt;header&gt;<br/>   ...<br/>   &lt;span id="search"&gt;                             ❶<br/>     &lt;input type="search" placeholder="Search"&gt;   ❷<br/>     &lt;div&gt;&lt;/div&gt;                                  ❸<br/>   &lt;/span&gt;<br/>   {{ partialCached "menu.html" ... }}<br/>   ...<br/> &lt;/header&gt;</span></pre><p id="dbd6" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❶ <strong class="jk hs">包装器div包含搜索表单和结果列表。</strong></p><p id="f501" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❷ <strong class="jk hs">网站的实际搜索表单。</strong></p><p id="63aa" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">搜索结果的❸ <strong class="jk hs">占位符。</strong></p><p id="04bf" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这就是所需要的一切。JavaScript将会自动激活这个搜索字段。</p><h2 id="5ddd" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">加载网站数据</strong></h2><p id="8e0d" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">为了填充JS中的搜索结果，我们需要从Pseudo API加载网站内容并创建一个搜索索引。我们可以使用JavasScript的fetch函数将网站数据提取到一个变量中。(<a class="ae jh" href="https://github.com/hugoinaction/hugoinaction/tree/chapter-10-resources/03" rel="noopener ugc nofollow" target="_blank">https://github . com/hugoin action/hugoin action/tree/chapter-10 resources/03</a>)。</p><p id="65ee" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单2。使用JavaScript中的window.fetch函数加载网站数据(AcmeTheme/assets/search . js)</strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="99bf" class="km kn hi me b fi mi mj l mk ml">export default {<br/>   async init() {<br/>     try {<br/>       const response = await window.fetch(          ❶<br/>         "/index.json");<br/>       if (!response.ok) {<br/>         this.removeSearch();                        ❷<br/>         return;<br/>       }<br/>       let data = await response.json();             ❸<br/>       / Just for now.<br/>       console.log(data);<br/>     } catch(e) {<br/>       this.removeSearch();<br/>     }<br/>   },<br/>  <br/>   removeSearch() {<br/>     document.querySelector("#search")?.remove();<br/>   }<br/> }</span></pre><p id="9793" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❶ <strong class="jk hs">使用fetch函数下载包含所有网站内容的索引文件。</strong></p><p id="7290" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❷ <strong class="jk hs">如果出现错误，移除搜索框。</strong></p><p id="57e1" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❸从JSON获取作为对象的响应数据。</p><p id="72cc" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果网站托管在GitHub Pages这样的子文件夹中，上面的代码会有一个问题，因为这些代码假设根<code class="du mm mn mo me b">/index.json</code>是代码的JSON版本所在的位置。我们将把<code class="du mm mn mo me b">site.BaseURL</code>作为另一个变量传递给<code class="du mm mn mo me b">defines</code>来解决这个问题。这个值需要用引号括起来才是有效的JavaScript(我们可以使用params代替defines，后者没有这个限制)。</p><p id="bc7c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单3。将BaseURL添加到定义参数(AcmeTheme/layouts/default/base of . html)</strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="c470" class="km kn hi me b fi mi mj l mk ml">{{ $defines := dict<br/>   "REMOVE_FORM_ON_SUBMISSION" (default "false" (<br/>     site.Param "RemoveFormOnSubmission"))<br/>   "BASE_URL" (print "\"" site.BaseURL "\"") }}     ❶</span></pre><p id="b508" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❶用引号括起来，使它成为一个有效的JavaScript字符串。</p><p id="17f4" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们还需要修复我们的JS代码。</p><p id="e583" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单4。添加BASE_URL以确保搜索总是从正确的端点开始(AcmeTheme/assets/search.js) </strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="f504" class="km kn hi me b fi mi mj l mk ml">const response = await window.fetch(<br/>   BASE_URL + "/index.json");</span></pre><p id="21ed" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们将从索引中调用搜索表单的init方法。即使函数是异步的，如果我们不需要等待它返回一个有效值，我们也可以不使用<code class="du mm mn mo me b">await</code>来调用它。</p><p id="540a" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单5。正在初始化搜索查询。(AcmeTheme/assets/index.js) </strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="0b50" class="km kn hi me b fi mi mj l mk ml">import Search from "./search"<br/>  <br/> function init() {<br/>   ...<br/>   Search.init();<br/> }</span></pre><p id="570c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">上面的代码应该在浏览器控制台中记录网站的全部内容。</p><p id="3559" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">代码检查点。在https://chapter-10-05.hugoinaction.com现场直播。</p><p id="ceaa" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">来源<a class="ae jh" href="https://github.com/hugoinaction/hugoinaction/tree/chapter-10-05" rel="noopener ugc nofollow" target="_blank">https://github . com/hugoin action/hugoin action/tree/chapter-10-05</a></p><h2 id="6166" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">导入搜索库</strong></h2><p id="9566" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">当网站上的数据很少时，我们可以使用正则表达式，在内容中循环查找结果。它可能会起作用，但是当我们需要像<em class="ke">模糊匹配</em>(允许使用部分术语和自动完成的结果)、搜索结果的适当加权评分这样的功能时，一个优秀的全文搜索库会很有帮助。JavaScript生态系统有许多现成的库，它们维护得非常好，并且易于使用。</p><p id="3e44" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">需要在机器上安装<em class="ke"> Node.js </em>(见<a class="ae jh" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank">https://nodejs.org</a>)来获取社区模块(我们可以使用任何版本)。一旦node.js可用，我们就可以使用<em class="ke"> npm </em>(节点包管理器)命令行。</p><p id="4e1c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在安装node.js依赖项之前，我们需要为我们的项目初始化node.js。我们的网站上有多个项目，Acme主题项目和Acme公司网站项目。由于搜索代码位于Acme Theme中并被共享，我们需要在Acme Theme项目中初始化node.js。</p><p id="e4d2" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为此，我们将运行<code class="du mm mn mo me b">npm init and answering a small questionnaire to get a `package.json</code>文件，该文件可以列出我们基于JavaScript的依赖项。</p><p id="0ce5" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单6。初始化为npm存储库(在AcmeTheme/) </strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="bda9" class="km kn hi me b fi mi mj l mk ml">npm init</span></pre><p id="0d24" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">接下来，我们需要搜索并下载一个node.js模块来帮助用户使用<code class="du mm mn mo me b">fuzzy search</code>。要使用<code class="du mm mn mo me b">npm</code>查找库，您可以使用<code class="du mm mn mo me b">npm search</code>命令。</p><p id="e76a" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单7。在npm上搜索模糊搜索库</strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="346c" class="km kn hi me b fi mi mj l mk ml">npm search fuzzy search</span></pre><p id="4df4" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">清单8。使用npm搜索模糊搜索的搜索结果。</p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="e6c6" class="km kn hi me b fi mi mj l mk ml">❯ npm search fuzzy search<br/> NAME        | DESCRIPTION           | AUTHOR          | DATE<br/> fuse.js         | Lightweight…         | =krisk          | 2021-01-05|<br/> fastest-levenshtein | Fastest Levenshtein… | =ka-weihe       | 2020-08-07|<br/> fuzzy-search | Simple fuzzy search | =wouter2203|2020-02-20|<br/> feathers-mongodb-fuzzy-se | hook which adds…     | =arve0  | 2020-09-13|<br/> arch                          |                      |         |           |<br/> minisearch                | Tiny but powerful…   | =lucaong |2021-06-25|<br/> mongoose-fuzzy-searching|Mongoose fuzzy…| =vspallas|2020-11-03|<br/> fuzzy-tools     | Functions for fuzzy… | =axules | 2021-04-18|<br/> fuzzy     | small, standalone…   | =mattyork       | 2016-10-01|<br/> leven-match     | Return all word…     | =eklem          | 2021-06-11|<br/> fuzzysearch  | Tiny and…   | =bevacqua       | 2015-03-06|<br/> mongoose-fuzzy  | Mongoose fuzzy…   | =pabloc  | 2020-07-28|<br/> scored-fuzzysearch | Tiny and… | =jhudson        | 2020-07-31|<br/> neofuzzy  | Quick fuzzy search…  | =jeanno    | 2020-11-26|<br/> fuzzy-search-mongoose | Fuzzy sarch | =piotreksl  | 2020-09-28|<br/> vue-fuse  | A Vue.js pluggin…    | =shayneosulli… | 2021-07-02|<br/> liblevenshtein | Various utilities…   | =dylon.edwards  | 2015-07-04|<br/> fuzzy-pop  | Simple fuzzy search… | =yoshokatana | 2015-05-05|<br/> fast-fuzzy | Fast and tiny…       | =ethanrutherf… | 2021-05-19|<br/> react-fuzzy-picker  | Search through a…    | =1egoman  | 2019-09-29|</span></pre><p id="9d22" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这里传递给<code class="du mm mn mo me b">npm</code>的根命令是search，我们正在搜索提供<code class="du mm mn mo me b">fuzzy search</code>的库。国家预防机制的最高结果是<code class="du mm mn mo me b">fuse.js</code>。在互联网上快速查看一下，我们发现<em class="ke"> `fuse.js` </em>是Apache许可的，相当小(&lt; 50kB)，没有其他依赖项，并且已经定期维护了近十年，定期发布，同时有许多下载和软件包依赖于它。</p><p id="faa6" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">要添加依赖项，我们可以使用<code class="du mm mn mo me b">npm install</code>命令。<code class="du mm mn mo me b">--save-dev</code>标志将开发依赖关系保存在package.json中，这样如果我们在新机器上进行<code class="du mm mn mo me b">npm install</code>操作，就可以使用它。开发依赖意味着它只在开发期间使用，在发布的网站中不需要。因为我们编译依赖项，所以在运行时不需要它们。</p><p id="33a5" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我会推荐使用fuse.js的6版。</p><p id="e100" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单9。添加fuse.js作为依赖项(在AcmeTheme/) </strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="b826" class="km kn hi me b fi mi mj l mk ml">npm install --save-dev <a class="ae jh" href="mailto:fuse.js@6" rel="noopener ugc nofollow" target="_blank">fuse.js@6</a></span></pre><p id="04db" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">该命令将生成一个名为<code class="du mm mn mo me b">package-lock.json</code>的文件和一个<code class="du mm mn mo me b">node_modules</code>文件夹。<code class="du mm mn mo me b">package-lock.json</code>相当于<code class="du mm mn mo me b">go.sum</code>，保存校验和以确保我们的依赖关系的完整性。<code class="du mm mn mo me b">node_modules</code>文件夹类似于<code class="du mm mn mo me b">_vendor</code>文件夹，它存储我们的依赖关系。npm不会为依赖项创建隐藏文件夹。</p><h2 id="3d35" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">更新我们的构建系统以支持npm </strong></h2><p id="7b7f" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">除非归档<code class="du mm mn mo me b">node_modules</code>文件夹对提交到源代码控制没有意义。把它挡在外面也不容易，因为我们需要在</p><p id="24a2" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">AcmeTheme模块获取其内容。在AcmeTheme模块中运行<code class="du mm mn mo me b">npm install</code>可能是不可能的，因为Hugo默认将模块放在一个隐藏的文件夹中。</p><p id="8111" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">因此，我们需要一种方法将<code class="du mm mn mo me b">fuse.js</code>依赖项暴露给顶级AcmeCorporationWebsite项目。为了执行这个任务，我们需要将AcmeTheme模块中的<code class="du mm mn mo me b">package.json</code>重命名为<code class="du mm mn mo me b">package.hugo.json</code>。如果Hugo模块中存在一个<code class="du mm mn mo me b">package.hugo.json</code>文件，Hugo知道这个模块依赖于npm，并且Hugo被允许将其依赖项复制到顶层项目。</p><p id="b351" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">要将我们的依赖项转移到顶级AcmeCorporationWebsite项目，我们可以运行以下命令:</p><p id="00e0" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单10。将所有模块包打包生成顶层package.json(在网站根文件夹/) </strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="5e64" class="km kn hi me b fi mi mj l mk ml">hugo mod npm pack</span></pre><p id="902e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">Hugo会将顶级的AcmeCorporation网站初始化为基于npm的项目，并创建package.hugo.json和package.json，现在我们在顶级的AcmeCorporation website项目运行<code class="du mm mn mo me b">npm install</code>得到那个文件夹中的node_modules和package-lock.json。AcmeTheme项目中的是多余的，我们可以删除。如果一个新的依赖项被添加到AcmeTheme项目中，我们需要将它添加到<code class="du mm mn mo me b">package.hugo.json</code>并再次运行<code class="du mm mn mo me b">hugo mod npm pack</code>命令。</p><p id="3d48" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">接下来，我们需要更新构建脚本来安装基于npm的依赖项。为此，我们需要在构建机器上安装<code class="du mm mn mo me b">npm install</code>命令。Netlify的构建机器预装了npm，而对于GitHub动作，我们需要增加一个步骤。注意<code class="du mm mn mo me b">npm i' is a shorthand to `npm install</code>。还有一个<code class="du mm mn mo me b">npm ci</code>命令，确保依赖项与package-lock.json匹配。但它不会删除已经安装的node_modules，这可能会导致构建时间更长。</p><p id="224e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">请注意，由于我们通过<code class="du mm mn mo me b">go.sum</code>获得了Hugo模块依赖关系的确切版本，Hugo模块基于npm的依赖关系不能跨版本更改。因此，只有当我们更改模块并在源代码控制中签入generate package.json时，我们才能运行<code class="du mm mn mo me b">hugo mod npm pack</code>。</p><h2 id="35f9" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated">更新网络寿命</h2><p id="1290" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">要更新Netlify中的build命令，我们可以转到<code class="du mm mn mo me b">Site settings &gt; Build &amp; deploy &gt; Continuous deployment &gt; Build command</code>来更新build命令。由于Netlify UI只接受一个用于构建命令的测试盒，我们可以使用<code class="du mm mn mo me b">&amp;&amp;</code>操作符来传输命令，并确保两个命令都成功。</p><p id="d229" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单11。构建命令来设置基于npm的依赖项并构建Hugo。</strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="c922" class="km kn hi me b fi mi mj l mk ml">npm i &amp;&amp; hugo --minify --baseURL $DEPLOY_PRIME_URL</span></pre><h2 id="dcad" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated">更新GitHub操作</h2><p id="d819" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">对于GitHub页面，我们需要在<code class="du mm mn mo me b">gh-pages.yml</code>中添加一组构建步骤来设置<code class="du mm mn mo me b">node.js</code>，然后运行‘NPM I’。</p><p id="7b61" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单12。更改GitHub操作以安装npm和基于npm的依赖项。(.github/workflows/。gh-pages.yml) </strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="6b2c" class="km kn hi me b fi mi mj l mk ml">jobs:<br/>   deploy:<br/>     steps:<br/>       ...<br/>       - name: Use Node.js<br/>         uses: actions/setup-node@v1<br/>         with:<br/>           node-version: '16.x'<br/>  <br/>       - name: Install NPM Dependencies<br/>         run: npm i</span></pre><p id="8f8b" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">有了这些更改，我们就可以在JavaScript代码中使用fuse.js搜索库了。</p><h2 id="ba6f" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">创建搜索索引</strong></h2><p id="7ddf" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">我们可以通过使用JavaScript中的<code class="du mm mn mo me b">import</code>语句导入<code class="du mm mn mo me b">fuse.js</code>。获取网站数据后，我们需要将其传递给<code class="du mm mn mo me b">fuse.js</code>来创建搜索索引。我们将制作一个加权搜索索引，其中标题权重为<code class="du mm mn mo me b">20</code>，标签得分为<code class="du mm mn mo me b">5</code>，而内容权重为1。这种评分允许给予标题中的单词比出现在网页内容中的单词高得多的值。</p><p id="1cb2" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们将索引存储为模块的局部变量。这样，模块中的所有方法都可以使用它。因为search不是一个类，我们只期望一个实例，所以模块的局部变量就像一个私有变量，在这个文件之外是不可访问的。</p><p id="ad11" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单13。导入fuse.js库以在基于JSON的内容中执行搜索。fuse.js提供了对模糊匹配、加权搜索的支持，以获得出色的搜索体验。在JavaScript中运行它可以使搜索响应更快。(AcmeTheme/assets/search.js) </strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="4ca7" class="km kn hi me b fi mi mj l mk ml">import Fuse from 'fuse.js'<br/>  <br/> let index = null;                          ❶                            <br/> export default {<br/>   init() {<br/>     ...<br/>  <br/>     let data = await response.json();      ❷<br/>     index= new Fuse(data, {<br/>       keys: [{                             ❸<br/>         name: 'title',<br/>         weight: 20<br/>       }, {<br/>         name: 'tag',<br/>         weight: 5<br/>       }, {<br/>         name: 'content'                    ❹<br/>       }]<br/>     });<br/>     / Just to test. Do not leave in code.<br/>     console.log(index.search('acme'));     ❺<br/>   }<br/> }</span></pre><p id="cf64" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❶ <strong class="jk hs">创建一个模块变量来存储所有函数中使用的索引。</strong></p><p id="714a" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❷ <strong class="jk hs">创建fuse.js索引。</strong></p><p id="be7f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❸ <code class="du mm mn mo me b">title</code> <strong class="jk hs">增加重量20。</strong></p><p id="12b3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❹ <strong class="jk hs">如未提供，重量按</strong>T6处理。</p><p id="f796" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❺ <strong class="jk hs">在开发过程中，留下一个测试查询会有所帮助。我们将搜索结果记录到浏览器的控制台。</strong></p><p id="2225" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">代码检查点。在https://chapter-10-06.hugoinaction.com的现场直播。源代码在<a class="ae jh" href="https://github.com/hugoinaction/hugoinaction/tree/chapter-10-06" rel="noopener ugc nofollow" target="_blank">https://github . com/hugoin action/hugoin action/tree/chapter-10-06</a></p><h2 id="ba3a" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">获取搜索输入并显示结果</strong></h2><p id="3c0f" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">搜索输入框和搜索方法准备就绪后，下一步是将两者链接在一起。我们需要做的第一件事是监听搜索框上的输入事件。只要用户在搜索框中输入一个字符，并在结果div中显示结果页面的标题，我们就会运行搜索查询。如果用户按下回车键，我们将导航到第一个搜索结果。我们也将限制搜索结果的数量到一个合理的数量。</p><p id="551f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们还需要在用户关注搜索框时显示搜索结果下拉列表，并在用户单击外部时移除它。更改后的完整文件在章节资源(</p><p id="a266" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><a class="ae jh" href="https://github.com/hugoinaction/hugoinaction/tree/chapter-10-resources/05" rel="noopener ugc nofollow" target="_blank">https://github . com/hugoin action/hugoin action/tree/chapter-10 resources/05</a></p><p id="28cb" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单14。通过下拉菜单显示搜索结果相对简单。我们使用输入事件来获取键盘和上下文菜单条目。(AcmeTheme/assets/search.js) </strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="cee8" class="km kn hi me b fi mi mj l mk ml">import Fuse from 'fuse.js'<br/>  <br/> let index = null;<br/> const MAX_SEARCH_RESULTS = 5;<br/>  <br/> export default {<br/>   init() {<br/>     ...<br/>     document.addEventListener("input", this.showResults);    ❶<br/>   }<br/>  <br/>   showResults(event) {<br/>     const searchBox = document.querySelector(<br/>       "#search input");<br/>     if (event.target !== searchBox) {<br/>       return;<br/>     }<br/>     const result = document.querySelector(<br/>       "#search div");<br/>     result.style.display = "block";<br/>     if (searchBox.value.length &gt; 0) {<br/>       const results = index.search(searchBox.value);<br/>       result.innerHTML = results                             ❷<br/>         .slice(0, MAX_SEARCH_RESULTS)                        ❸<br/>         .map(x =&gt; `&lt;a href="${<br/>           x.item.url}"&gt;<br/>           &lt;img src="${x.item.cover || ""}" width=<br/>           "40" height="40"&gt;<br/>           &lt;h3&gt;${x.item.title}&lt;/h3&gt;<br/>           &lt;span&gt;${x.item.content.substr(<br/>             0,40)}&lt;/span&gt;<br/>         &lt;/a&gt;`)                                               ❹<br/>         .join("");<br/>     } else {<br/>       result.innerHTML = '';<br/>     }<br/>   },<br/>   ...<br/> }</span></pre><p id="46a4" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❶ <strong class="jk hs">输入事件对文本框来说是最好的，因为它处理不常见的情况，比如通过鼠标和常规键盘按压进行复制粘贴。</strong></p><p id="de42" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❷<strong class="jk hs">innerhtml用来替换下拉列表的内容。注意，如果性能是个大问题，我们可以更新现有的DOM元素。</strong></p><p id="e126" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❸ <strong class="jk hs">将搜索结果的数量限制为MAX_SEARCH_RESULTS </strong></p><p id="60fb" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">❹ <strong class="jk hs">提供丰富的下拉体验，带有图像和伴随的文本。</strong></p><p id="c975" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">请注意，变量MAX_SEARCH_RESULTS可能来自Hugo配置，如define或param。</p><p id="eba6" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">随着这些变化，我们在网站中有了一个工作搜索框，帮助用户浏览整个内容。</p><figure class="lz ma mb mc fd mq er es paragraph-image"><div class="er es mp"><img src="../Images/e93425749c0dd3a0f0eb564e4092782e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/0*yRSqHvH5fpFzujpe.jpg"/></div><figcaption class="mt mu et er es mv mw bd b be z dx translated">图一。使用Acme Corporation网站中显示的下拉结果进行搜索。可以在基于Jamstack的网站中添加搜索，使用伪API获取所有内容，并使用JavaScript进行过滤。</figcaption></figure><p id="5eb7" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">代码检查点。住在</strong><a class="ae jh" href="https://chapter-10-07.hugoinaction.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jk hs">https://chapter-10-07.hugoinaction.com</strong></a><strong class="jk hs">。源代码位于</strong><a class="ae jh" href="https://github.com/hugoinaction/hugoinaction/tree/chapter-10-07" rel="noopener ugc nofollow" target="_blank"><strong class="jk hs">https://github . com/hugoin action/hugoin action/tree/chapter-10-07</strong></a></p><p id="8df9" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">带有npm变更的GitHub Pages存储库出现在<a class="ae jh" href="https://github.com/hugoinaction/GitHubPagesNpm" rel="noopener ugc nofollow" target="_blank">https://github.com/</a><a class="ae jh" href="https://github.com/hugoinaction/GitHubPagesNpm" rel="noopener ugc nofollow" target="_blank">hugoinaction/GitHubPagesNpm</a>上。</p><h2 id="678b" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">通过JavaScript使用Hugo模块</strong></h2><p id="9d3a" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">虽然npm使用起来很简单，但是我们可以继续使用Hugo模块来加载依赖项。Hugo模块允许依赖关系提供模板代码、捆绑内容和其他Hugo特有的数据以及JavaScript。Hugo模块中的assets文件夹充当node.js中的<code class="du mm mn mo me b">node_modules</code>文件夹。</p><p id="8b8e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们没有在搜索处理程序中添加任何键盘处理。我们将导入Hugo模块AcmeSearchSupport(</p><p id="4ade" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><a class="ae jh" href="https://github.com/hugoinaction/hugoinaction/tree/chapter-10-resources/06" rel="noopener ugc nofollow" target="_blank">https://github.com/hugoinaction/hugoinaction/tree/</a><a class="ae jh" href="https://github.com/hugoinaction/hugoinaction/tree/chapter-10-resources/06" rel="noopener ugc nofollow" target="_blank">第十章【资源】/06 </a>来执行这个任务。</p><p id="4b26" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们首先将它作为一个依赖项添加到AcmeTheme中。</p><p id="1310" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单15。将AcmeSearchSupport作为依赖项添加到AcmeTheme(AcmeTheme/config . YAML)</strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="9aa9" class="km kn hi me b fi mi mj l mk ml">module:<br/>   ...<br/>   imports:<br/>     ...<br/>     - path: github.com/hugoinaction/AcmeSearchSupport</span></pre><p id="4da9" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">接下来，我们加载这个模块我们的<code class="du mm mn mo me b">search.js</code>,并在初始化期间调用它。</p><p id="0af4" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单16。从Hugo模块加载js代码，由JS编译。构建(AcmeTheme/assets/search.js) </strong></p><pre class="lz ma mb mc fd md me mf mg aw mh bi"><span id="d66a" class="km kn hi me b fi mi mj l mk ml">import AcmeSearchSupport from "SearchSupport"<br/> ...<br/> export default {<br/>   async init() {<br/>   ...<br/>     try {<br/>       ...<br/>       AcmeSearchSupport();<br/>     } catch (e) {<br/>       this.removeSearch();<br/>     }<br/>   },<br/>   ...<br/> }</span></pre><p id="2b99" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">本文到此为止。如果你想了解这本书的更多信息，可以在曼宁的liveBook平台<a class="ae jh" href="https://livebook.manning.com/book/hugo-in-action?origin=product-look-inside&amp;utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_jain_hugo_9_24_19" rel="noopener ugc nofollow" target="_blank">这里</a>查看。</p></div></div>    
</body>
</html>