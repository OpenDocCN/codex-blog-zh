<html>
<head>
<title>The Importance Of Dependency Injection For Good Code Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入对良好代码结构的重要性</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-importance-of-dependency-injection-for-good-code-structure-7d5447f4055a?source=collection_archive---------5-----------------------#2021-10-17">https://medium.com/codex/the-importance-of-dependency-injection-for-good-code-structure-7d5447f4055a?source=collection_archive---------5-----------------------#2021-10-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="54f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">…以及何时不使用它！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a7674d1af7815286b9e977cb7f7dd2ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWi28HZHCAdfv02jHPwJcQ.jpeg"/></div></div></figure><p id="16ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一名大半辈子都在与大型代码库打交道的软件工程师，引入依赖注入彻底改变了我对良好代码结构的看法，并使我更容易将复杂的代码分解为更小且可维护的模块和服务类，而不必太担心分散在代码库中的实例化逻辑，因为它现在封装在DI逻辑中。</p><p id="b55e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我是通过一个名为鲍勃·李的谷歌工程师的一系列视频了解到这个概念的，他是<a class="ae jp" href="https://github.com/google/guice" rel="noopener ugc nofollow" target="_blank"> Guice框架</a>的作者，随后我阅读了由<a class="ae jp" href="https://www.amazon.com/s/ref=dp_byline_sr_ebooks_1?ie=UTF8&amp;field-author=Dhananjay+Prasanna&amp;text=Dhananjay+Prasanna&amp;sort=relevancerank&amp;search-alias=digital-text" rel="noopener ugc nofollow" target="_blank"> Dhananjay Prasanna </a>撰写的<a class="ae jp" href="https://www.amazon.com/Dependency-Injection-Design-patterns-Spring-ebook-dp-B0977ZS7P8/dp/B0977ZS7P8/ref=mt_other?_encoding=UTF8&amp;me=&amp;qid=1634485672" rel="noopener ugc nofollow" target="_blank">依赖注入书</a>(他也是谷歌Guice团队的成员)。</p><h1 id="2ac0" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">什么时候不用？</h1><p id="7eb7" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated"><a class="ae jp" href="https://www.amazon.com/Dependency-Injection-Design-patterns-Spring-ebook-dp-B0977ZS7P8/dp/B0977ZS7P8/ref=mt_other?_encoding=UTF8&amp;me=&amp;qid=1634485672" rel="noopener ugc nofollow" target="_blank">依赖注入书</a>将我的注意力吸引到视频系列遗漏或者可能没有明确说明的一个信息提示上；也就是说，<strong class="ih hj"> DI应该只用于您的服务类。</strong></p><p id="9750" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，<strong class="ih hj"> DI不是为了实例化你的实体类(例子包括ORM类、数据类、数据结构等)。</strong> DI用于实例化您的应用基础设施服务类。</p><p id="1200" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些服务类拥有使用<strong class="ih hj">new</strong>Entity实例化实体和数据类的方法是完全没问题的，但是不应该使用DI框架来实例化它们(换句话说，使用<strong class="ih hj"> new Entity() </strong>完全没问题)。</p><p id="ca2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你错过了上面的建议，那么DI将开始在你的代码中变得毫无意义，给你增加负担，并且永远不会让你体会到DI作为一个概念背后的真正好处。</p><p id="915f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">DI可能没有用的其他地方是在小型脚本或应用程序中。如果你有一个小的应用程序或者只是写一个小的脚本，DI可能不是你想要使用的。</p><p id="8c69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">依赖注入-快速解释</strong></p><p id="bd41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以尽可能简短的解释提供:</p><blockquote class="kt ku kv"><p id="b6ae" class="if ig kw ih b ii ij ik il im in io ip kx ir is it ky iv iw ix kz iz ja jb jc hb bi translated"><strong class="ih hj">依赖注入将实例化和连接服务类的责任转移到DI逻辑，而不是类实现。</strong></p></blockquote><p id="38e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，像<code class="du la lb lc ld b">CustomerInfoService</code>这样需要和数据库对话的服务类，不会创建一个<code class="du la lb lc ld b">new DatabaseService()</code>；相反，DI会将DatabaseService()的一个实例传递给<code class="du la lb lc ld b">CustomerInfoService</code>的构造函数。这由DI逻辑负责(无论是阿迪框架还是应用程序初始化时的简单DI代码)。</p><p id="66f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然在细胞微观层面上听起来微不足道，但这个简单的调整在应用程序代码结构的宏观层面上创造了巨大的好处。</p><p id="8316" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原因很简单，您现在可以很容易地用任何服务实现替换任何抽象服务，只需指示DI逻辑连接必要的服务实现。</p><p id="abaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于如何使用您的代码库，您的代码库可能处于以下三种状态之一:</p><p id="8c62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">代码基础类型I(从DI中受益最大):</strong>您的应用程序中已经有了服务类，您正在其他消费服务类中实例化您需要的服务，或者使用工厂方法实例化您的服务类并将它们连接在一起。在这种情况下，DI将立即使您受益，因为它将消除创建逻辑和工厂方法，并且所有实例化逻辑将作为DI框架(或逻辑)的责任的一部分完全转移。</p><p id="c861" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码基类型II(可能会受益):你有服务类，但是由于某种原因，它们在每个类中都使用了<code class="du la lb lc ld b">static</code>方法。这意味着您的服务类是不可实例化的，只是充当静态函数的名称空间。目前，您可以从任何地方调用任何函数(这并不好)。为了使您的代码库适应使用DI，您的代码库必须进行重组，删除静态函数修饰符，并修改每个类的构造函数，以传递它将消费的所需服务类。在与DI进一步合作之前，这是必需的。</p><p id="f838" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">代码库类型III(几乎没有任何好处)</strong>:在你的代码库中有一个叫做Utils.java的巨大类，在静态函数中有成千上万行代码，不断打破单一责任原则。在这种情况下，您可能需要修改代码结构的基础，并开始构建一个为每个服务定义边界的服务层。同样，您的团队可能会认为代码运行良好。在这种情况下，这里所需要的超出了本文所能提供的范围。</p><h1 id="c05f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">好处</h1><p id="a2a2" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">除了DI提供的常见好处(这些好处在网上很多地方都讨论过，包括:更好的可测试性、没有工厂方法层、增强的解耦、更少的锅炉板代码，因为现在所有的实例化代码都由DI组件处理)之外，我强烈感觉到以下好处被忽略了，甚至没有被提及:</p><p id="a424" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">好处#1:依赖注入作为一个简单的插件系统</strong></p><p id="b297" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在应用程序中使用DI作为一个简单的插件系统来启用和禁用特定的实现。定义可以做什么的接口可以为不同的行为插入不同的实现。</p><p id="dfcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">好处#2:将DI与配置标志结合起来为您的应用程序提供了强大的可扩展性</strong></p><p id="f478" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从可扩展性的角度来看，您的DI组件，结合用于启用不同环境设置的不同配置标志、实验性功能标志或可插拔组件，使阿迪成为非常强大的工具。示例:您可以拥有一个测试或生产的Enum环境，它将连接不同的服务实现来模拟测试环境中的真实生产端点。</p><p id="0e2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">好处#3:改变你的思维方式，将你的系统分解成小的服务类，这些服务类相互作用，组成模块，模块相互作用，组成你的应用程序。</strong></p><p id="753b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">综上所述，需要利用DI的优势来感知其背后的力量。另外，虽然你不需要阿迪库框架来启动。我建议使用一个，以便快速引导您了解它如何帮助构建您的服务层。</p><p id="0407" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于Java，有<a class="ae jp" href="https://github.com/google/guice" rel="noopener ugc nofollow" target="_blank"> Guice </a>和<a class="ae jp" href="https://github.com/google/dagger" rel="noopener ugc nofollow" target="_blank"> Dagger </a>。<br/>对于Python 3，<a class="ae jp" href="https://github.com/illuin-tech/opyoid" rel="noopener ugc nofollow" target="_blank"> Opyoid </a>看起来很有希望，并且变得更容易，因为Python 3现在允许类型声明提示。</p></div></div>    
</body>
</html>