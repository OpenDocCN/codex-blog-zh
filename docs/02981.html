<html>
<head>
<title>Writing your own Operating System: Segmentation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写自己的操作系统:分段</h1>
<blockquote>原文：<a href="https://medium.com/codex/writing-your-own-operating-system-segmentation-61351ecaa1bd?source=collection_archive---------12-----------------------#2021-08-13">https://medium.com/codex/writing-your-own-operating-system-segmentation-61351ecaa1bd?source=collection_archive---------12-----------------------#2021-08-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c429368f7fb0b25fcd5ff0b3aff3f6b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5TiBbmTkiWfjjabyVN8xJQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由pch.vector创建的<a class="ae iu" href="https://www.freepik.com/vectors/people'" rel="noopener ugc nofollow" target="_blank">人向量</a>——【freepik.com T2】</figcaption></figure><p id="d102" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi jt translated"><span class="l ju jv jw bm jx jy jz ka kb di"> T </span>本文是解释x86操作系统开发的系列文章的一部分。它可以作为一个独立的指南，但是如果你从<a class="ae iu" href="https://hasinisama.medium.com/building-your-own-operating-system-980a4498104" rel="noopener">开始</a>跟随这个系列，它会更有意义。如果你们都跟上了，我们可以继续下一步的操作系统开发。</p><p id="4fd1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，我们只在实模式下工作，这限制了我们1MB的内存。由于这远远不足以做任何有用的事情，我们需要跳转到保护模式，这将允许我们访问其余的内存。然而，在我们这样做之前，处理器至少需要设置两件事情:分段和中断。在本文中，我将讨论<strong class="ix hj">分段</strong>。</p><h1 id="e495" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">分割</strong></h1><p id="ad55" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">把整个记忆想象成一条面包。你把它切成片。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/33fda0c124987c0512bc9bc15144b3f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*iKVqXZNX2uQZHlwUeLae3A.gif"/></div></figure><p id="2f3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分段是一种组织记忆的方法。顾名思义，我们通过段来访问内存。如果记忆是一条面包，那么每一片都是一段。每个段都有一个基址和一个限制。</p><p id="5a33" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">48位逻辑地址用于寻址分段存储器中的一个字节。这48位定义了段和该段内的偏移。参见下图，了解48位逻辑地址如何转换为线性地址(将根据段的限制进行检查)。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/49534f4ef2df9f2c1a2b863088c6f1aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oefXI2G6mKP6I1rvlLy36g.png"/></div></div></figure><p id="bada" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了允许分段，您需要创建一个描述每个分段的表。在x86中，有两种类型的描述符表:全局描述符表(GDT)和本地描述符表(LDT)。ldt用于更复杂的分割模型。GDT是全球性的，为每个人所共享。</p><h1 id="58f3" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">全局描述符表(GDT)</h1><p id="2aca" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">需要澄清的是，严格来说，GDT并不是编写内核的<em class="ll">要求</em>，它只是编写有用的<em class="ll">内核的一个要求。</em></p><p id="588b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GDT为内存的某些部分定义了基本访问权限。这允许内核在进程试图违反这些约束时处理异常，并以某种方式终止该进程。大多数现代操作系统使用一种叫做“<strong class="ix hj">分页</strong>的内存模式来实现这一点。它更加通用，并且允许更高的灵活性。我将在另一篇文章中讨论分页。</p><p id="693d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们对分段和GDT有了一个基本的概念，让我们继续实际的编码。</p><h1 id="baea" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">访问内存</h1><p id="8aa3" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">首先，我们需要在内存中为GDT保留空间。为此，我们将编写名为<strong class="ix hj"> gdt_flush()的汇编代码函数。</strong></p><p id="5ae1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> gdt_flush() </strong>是一个函数，它使用我们包含一个限制的特殊指针，实际上告诉处理器新的gdt在哪里。</p><p id="6fec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GDT可以加载如下所示的组件代码:</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="989c" class="lr kd hi ln b fi ls lt l lu lv"><strong class="ln hj">lgdt</strong> [<strong class="ln hj">eax</strong>]</span></pre><p id="1eed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们需要重新加载新的段寄存器。</p><p id="a443" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">处理器有六个16位段寄存器:<code class="du lw lx ly ln b">cs</code>、<code class="du lw lx ly ln b">ss</code>、<code class="du lw lx ly ln b">ds</code>、<code class="du lw lx ly ln b">es</code>、<code class="du lw lx ly ln b">gs</code>和<code class="du lw lx ly ln b">fs</code>。<strong class="ix hj"> CS寄存器</strong>也被称为<strong class="ix hj">代码段</strong>。代码段告诉处理器它将在GDT的哪个偏移量中找到执行当前代码的访问权限。</p><p id="5788" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> DS寄存器</strong>也是同样的想法，但它不是用于代码，它是<strong class="ix hj">数据段</strong>并定义当前数据的访问权限。ES、FS和GS只是备用DS寄存器，对我们来说并不重要。</p><p id="0352" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于数据寄存器来说，加载段选择器寄存器很容易。您只需将正确的失调复制到寄存器中。0x10是GDT到数据段的偏移量。</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="92ed" class="lr kd hi ln b fi ls lt l lu lv"><strong class="ln hj">    mov</strong> <strong class="ln hj">ds</strong>, 0x10<br/>    <strong class="ln hj">mov</strong> <strong class="ln hj">ss</strong>, 0x10<br/>    <strong class="ln hj">mov</strong> <strong class="ln hj">es</strong>, 0x10<br/>    .<br/>    .<br/>    .</span></pre><p id="423c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，进行一次远跳转来重新加载我们的新代码段。0x08是代码段的偏移量。</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="74cf" class="lr kd hi ln b fi ls lt l lu lv"><strong class="ln hj">    jmp 0x08:.flush </strong>  <br/><strong class="ln hj">.flush: </strong>   <br/>    <strong class="ln hj">ret</strong></span></pre><h1 id="e5e4" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">配置GDT</h1><p id="13cd" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">我们需要一个结构来指定GDT的开始和大小。我们需要按照<strong class="ix hj"> lgdt </strong>指令要求的格式来写。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="3082" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GDT本身是一个64位长的条目列表。这些条目定义了允许区域在内存中的起始位置、该区域的限制以及与该条目相关联的访问权限。</p><p id="ecf3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于本教程，我们将创建一个只有3个条目的GDT。为什么是3？一开始，我们需要一个“虚拟”描述符，作为处理器内存保护特性的空段。我们需要一个代码段条目，最后，我们需要一个数据段寄存器条目。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/2b816d58a8e0c9b0f573f60fd2c12819.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*IF7NTVe2ADBnuV4GGS8jkg.jpeg"/></div></figure><p id="b2f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就像切面包时，第一片是没有用的。没有人需要所有的面包皮。处理器从不引用空描述符。某些仿真器，比如Bochs，会抱怨限制异常，如果你没有限制异常的话。有些使用这个描述符来存储指向GDT本身的指针(与LGDT指令一起使用)。</p><p id="bfb4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我们现在需要一个包含GDT条目值的结构。我们使用属性‘packed’告诉GCC不要改变结构中的任何对齐方式。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h1 id="15ee" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">装载GDT</h1><p id="446d" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">仅仅在内存中为GDT预留空间是不够的。我们需要将值写入每个GDT条目，设置GDT指针，然后我们需要调用gdt_flush()来执行更新。</p><p id="113d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随后是一个名为“gdt_set_gate()”的特殊函数，它使用易于使用的函数参数来完成所有转换，以将给定gdt条目中的每个字段设置为适当的值。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="0dc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于空描述符，我们可以只传递所有的空值。但是对于第二个和第三个条目，我们需要分配正确的值。基址是0，两者的限制都是4gb。</p><p id="20ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于两个条目，粒度= 0xCF，直到段限制的最高位是0xFFFFFFFF。注意，粒度位设置为1时，单个段描述符可以代表整个4gb地址空间。</p><p id="0230" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是对于代码段的访问权限= 0x9A特权0，对于数据段的访问权限= 0x92。</p><pre class="lg lh li lj fd lm ln lo lp aw lq bi"><span id="34e1" class="lr kd hi ln b fi ls lt l lu lv">gdt_set_gate(0, 0, 0, 0, 0);<br/>gdt_set_gate(1, 0, 0xFFFFFFFF, 0x9A, 0xCF);<br/>gdt_set_gate(2, 0, 0xFFFFFFFF, 0x92, 0xCF);</span></pre><h1 id="db84" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">初始化GDT</h1><p id="510c" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">我们需要初始化GDT。为此，我们需要添加另一个函数。我还添加了GDT指针的初始化，所以你可以更好地了解整个函数。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="f530" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们的GDT装载基础设施已经全部就绪。别忘了加上你的。o文件(<strong class="ix hj"> </strong>在我的代码<strong class="ix hj"> gdt.o </strong>和<strong class="ix hj"> memory_segments.o </strong>)到LD创建你的内核需要链接的文件列表中！</p><p id="cd48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在只需从kmain调用初始化函数。你完了！</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="1cd0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完成了吗？但是我怎么检查呢？您现在可能有点困惑，因为输出没有明显的变化。我们只是改变了操作系统中的内存调用结构。</p><p id="4132" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您可以像以前一样没有任何错误地运行您的操作系统，那么您已经成功地将分段配置到您的操作系统中。但是如果你有任何错误，不要担心。你可以从下面我的GitHub获得完整的代码。</p><div class="mj mk ez fb ml mm"><a href="https://github.com/HasiniSama/pocketOS/tree/integrate_segmentation" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">GitHub-HasiniSama/pocket OS at integrate _ segmentation</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">中断驱动的单任务实模式x86操作系统。- GitHub - HasiniSama/pocketOS at…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">github.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na io mm"/></div></div></a></div><p id="ad8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望在下一篇文章中也能看到你！</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/a5d3e8c6dfe7be2d75f0cab84fb5caa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/1*htDXml1B7MVCXH7KQF5ulQ.gif"/></div></figure><p id="3173" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">谢谢大家！</p><p id="b8b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ll">参考:赫林，e .&amp;伦伯格，A. (2015)。</em> <a class="ae iu" href="https://littleosbook.github.io/#getting-to-c" rel="noopener ugc nofollow" target="_blank"> <em class="ll">关于OS开发的小书</em> </a></p></div></div>    
</body>
</html>