<html>
<head>
<title>Improving Unit Testing with FluentAssertion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用FluentAssertion改进单元测试</h1>
<blockquote>原文：<a href="https://medium.com/codex/improving-unit-testing-with-fluentassertion-efde0a7e3475?source=collection_archive---------9-----------------------#2021-04-14">https://medium.com/codex/improving-unit-testing-with-fluentassertion-efde0a7e3475?source=collection_archive---------9-----------------------#2021-04-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ecc94d2cf7bb15e5565e1fde2f4ae23b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMBLYosulP4qc1_AB2jzAA.jpeg"/></div></div></figure><p id="7ae2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们重温一下基础知识。单元是程序中逻辑上独立的最小部分。在大多数编程语言中，一个函数被称为一个单元。单元测试是在程序中测试单元的过程。任何涉及到外部系统的测试，比如到数据库的连接，或者依赖于任何其他功能的测试，都不是单元测试。</p><p id="40e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">单元测试是任何开发项目中相当重要的一部分。它有助于在集成执行之前识别错误，为开发人员节省宝贵的时间。不幸的是，单元测试需要花费大量的时间，并且经常会导致糟糕的结果。</p><p id="44e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了防止这种情况发生，我们采用了波动分析法。在这篇文章中，让我们了解什么是流畅的断言，以及它如何帮助改进单元测试。</p><p id="5930" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录</strong></p><ul class=""><li id="2246" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">为什么要进行单元测试？</li><li id="c6b7" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">什么是FluentAssertions？</li><li id="e0ba" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">断言的范围</li><li id="7f2c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">常用断言</li><li id="57d0" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">用JSON断言</li><li id="d3d0" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">FluentAssertions的使用如何改进单元测试？</li><li id="8690" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">结论</li></ul><h1 id="26d6" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">为什么要进行单元测试？</h1><p id="08b4" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">软件测试的最后阶段通常是单元测试。这通常在软件部署之前完成。在这个阶段，测试每个逻辑上独立的代码片段，以检查这些代码片段是否给出了期望的结果。这些片段通常会有一个输出。单元测试通常在编码阶段完成，以使软件在部署前没有错误。</p><p id="a6fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是我们进行单元测试的一些原因-</p><ul class=""><li id="30a9" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">提高了代码的灵活性。</li><li id="9a3d" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">降低了重构代码即改变代码的风险。</li><li id="ba3c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">它通过暴露导致更好结果的边缘情况来提高代码的质量。</li><li id="1837" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">它有助于在执行集成测试之前识别代码中的错误，从而简化调试过程。</li><li id="ab12" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">代码的设计和结构得到了改进，因为程序员需要考虑一个方法需要完成什么。</li></ul><h1 id="3c8b" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是FluentAssertions？</h1><p id="aebf" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">FluentAssertions是一堆。NET扩展方法。它允许您指定测试驱动开发或行为驱动开发单元测试的预期结果。您可以使用以下语法来启用它-</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="29c5" class="lo kd hi lk b fi lp lq l lr ls">using FluentAssertions;</span></pre><p id="ec09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">FluentAssertions支持大多数单元测试框架。您所要做的就是将对所需测试框架程序集的引用添加到单元测试项目中。相应的程序集将由FluentAssertions自动找到，并用于引发特定于框架的异常。</p><p id="cafe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">FluentAssertions库为异常提供了更好的支持，增加了测试的可读性，同时使生成单元测试变得更加容易。</p><p id="990e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个简单断言的示例:</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/e777923d341294e02547d53465b8b327.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/0*JPx44opPKWbSLpy0"/></div></figure><p id="ee8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">“a”的值被初始化为10，再加上10就变成了20。因此，我们使用代码a.Should()对FluentAssertions进行了测试。Be(20)比Assert可读性更好。AreEqual(a，20)。</p><p id="ecff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">支持使用FluentAssertions进行单元测试的不同平台有</p><ul class=""><li id="0125" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">Xamarin.iOS 10.0</li><li id="11c5" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">。网络核心1.0</li><li id="4ae4" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">Xamarin。Mac 3.0</li><li id="9da6" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">。网络核心2.0</li><li id="9185" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">Xamarin。安卓7.0</li><li id="c33b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">单声道的</li><li id="6423" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">通用Windows平台</li><li id="8fc9" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">。Net框架4.5</li></ul><p id="cf47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">支持使用FluentAssertions进行单元测试的不同框架有</p><ul class=""><li id="d585" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">MSTest (Visual Studio 2010，Vis</li><li id="d350" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">姆布尼特</li><li id="bb5f" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">努尼特</li><li id="805a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">XUnit</li><li id="8f48" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">XUnit2</li><li id="1ef2" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">NSpec</li><li id="8f6b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">MSpec</li><li id="52ec" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">不负责任的人</li></ul><h1 id="bad5" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">断言的范围</h1><p id="c0d0" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">所有的断言都可以被批处理到一个AssertionScope中，这将使FluentAssertions在作用域的末尾为作用域内的所有失败抛出一个异常。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/7d838ca0e34934144ac5970b0f1cd9c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/0*V-rSHFPw5ruS7eBE"/></div></figure><h1 id="ef5b" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">常用断言</h1><p id="9a9b" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">以下是一些常用的断言:</p><h2 id="99e3" class="lo kd hi bd ke lv lw lx ki ly lz ma km jb mb mc kq jf md me ku jj mf mg ky mh bi translated">字符串(string theString =):</h2><ul class=""><li id="5f5b" class="jo jp hi is b it la ix lb jb mi jf mj jj mk jn jt ju jv jw bi translated">绳子。应该()。not be null()；</li><li id="b464" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">绳子。应该()。be null()；</li><li id="8c6d" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">绳子。应该()。BeEmpty()；</li><li id="b563" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">绳子。应该()。NotBeEmpty("不能为空")；</li><li id="eacb" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">绳子。应该()。Be("某串")；</li><li id="bc61" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">绳子。应该()。NotBe("某字符串")；</li><li id="8494" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">绳子。应该()。BeEquivalentTo("一些字符串")；</li><li id="7437" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">绳子。应该()。NotBeEquivalentTo("某个字符串")；</li></ul><h2 id="97d4" class="lo kd hi bd ke lv lw lx ki ly lz ma km jb mb mc kq jf md me ku jj mf mg ky mh bi translated">数值型(int a = 5；):</h2><ul class=""><li id="c029" class="jo jp hi is b it la ix lb jb mi jf mj jj mk jn jt ju jv jw bi translated">a.应该()。BeGreaterOrEqualTo(5)；</li><li id="1995" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">a.应该()。BeGreaterThan(4)；</li><li id="1ee8" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">a.应该()。贝莱索雷夸尔托(5)；</li><li id="51b9" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">a.应该()。be(5)；</li><li id="7787" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">a.应该()。NotBe(5)；</li></ul><p id="ae31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面给出了JSON中允许的断言列表:</p><ul class=""><li id="08cc" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">比奎瓦伦托</li><li id="6b14" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">ContainSingleElement()</li><li id="6e20" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">包含子树()</li><li id="f714" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">HaveCount()</li><li id="18ac" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">HaveElement()</li><li id="23c7" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">HaveValue()</li><li id="0344" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">MatchRegex()</li><li id="9125" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">NotBeEquivalentTo()</li><li id="b8cb" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">NotHaveValue()</li><li id="b0f4" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">NotMatchRegex()</li><li id="f300" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">NotHaveElement()</li></ul><p id="5038" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不要忘记使用FluentAssertions.Json，否则可能会出现误报。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/e024dd7681d068b01cec2f8fdbd40838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/0*eTjDAjkLuVVz5k3E"/></div></figure><h1 id="272d" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">FluentAssertions的使用如何改进单元测试？</h1><p id="6eb4" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">这里有一个例子，清楚地捕捉到了当FluentAssertion用于单元测试时，理解代码和以更简单的方式编写代码的区别。与普通的单元测试不同，FluentAssertions提供了以下好处，使程序员在执行单元测试时可以从中受益:</p><h2 id="c190" class="lo kd hi bd ke lv lw lx ki ly lz ma km jb mb mc kq jf md me ku jj mf mg ky mh bi translated">提高可读性</h2><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/2b7e8480a0e140e588d93ca803a0f647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/0*bkxXhN6qNx89thcI"/></div></figure><p id="3ee7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，我们可以看到相同的单元测试是使用Assert和FluentAssertions完成的。可以清楚地看到，与第一个单元测试相比，第二个单元测试更容易阅读。</p><h2 id="9ddb" class="lo kd hi bd ke lv lw lx ki ly lz ma km jb mb mc kq jf md me ku jj mf mg ky mh bi translated">测试失败的更清晰的解释</h2><p id="9f35" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated"><strong class="is hj">片段1 </strong></p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/2db122e7fd69d19e6faff891187e9ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/0*SuOgNNZg43WVN-8o"/></div></figure><p id="0cff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">片段二</strong></p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/fb613dc8f70d2b604cdf15119477e360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/0*MFP5t63s2uDefNcw"/></div></figure><p id="8730" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的两个片段中，我们可以看到使用Assert和FluentAssertions的区别。在第二个片段中，很容易理解测试失败的原因，这要归功于一条可读的消息。然而，在第一个问题中，我们没有得到明确的信息。</p><h1 id="4dfb" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="1de8" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">正如我们在这篇文章中看到的，使用FluentAssertions对你的单元测试活动有很大的帮助。它不仅提高了可读性，而且清楚地定义了测试用例的失败。这两个好处都有助于测试人员在代码中出现错误的情况下轻松地进行纠正。因此，在您的下一个单元测试项目中使用FluentAssertions来享受它的多重好处。</p></div><div class="ab cl mp mq gp mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hb hc hd he hf"><p id="f102" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mw">原载于</em><a class="ae mx" href="https://www.partech.nl/nl/publicaties/2021/04/improving-unit-testing-with-fluentassertion" rel="noopener ugc nofollow" target="_blank"><em class="mw">https://www . partech . nl</em></a><em class="mw">。</em></p></div></div>    
</body>
</html>