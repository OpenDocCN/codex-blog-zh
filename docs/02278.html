<html>
<head>
<title>Generating Combinations Efficiently with Asif’s Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Asif算法高效地生成组合</h1>
<blockquote>原文：<a href="https://medium.com/codex/generating-combinations-efficiently-with-asifs-algorithm-d453e803893?source=collection_archive---------3-----------------------#2021-07-11">https://medium.com/codex/generating-combinations-efficiently-with-asifs-algorithm-d453e803893?source=collection_archive---------3-----------------------#2021-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/8b2ca822b1d17eb0cd8ad5061d88bdbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*LdpYZaW7KDiW8upesEwRug.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">好吧，密码在哪里？</figcaption></figure><p id="09eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你好。我是赛义夫·侯赛因。如果您正在阅读这篇文章，那说明您想学习如何以编程的方式高效地生成给定数组的<em class="jo"> r </em>元素的组合。也许你已经做了一些关于如何从数组中生成组合的研究，并且被大量的算法淹没了，同时它们比看起来更难并且效率不高。今天我要向大家介绍一种新的组合生成算法，它既优雅又高效。</p><h1 id="9a3b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">为什么是这篇文章？</h1><p id="732c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在过去的几天里，我一直在研究如何编写一个高效优雅的代码来生成组合。弹出的第一个问题，“为什么？”。故事从一个月前开始，当时我正在解决谷歌的FooBar挑战，这是谷歌的一个秘密招聘挑战。我不擅长算法，当然也不知道如何生成组合。但我想出了一个名为“幸运三人组”的挑战，我必须生成组合。我遇到的第一个问题是，在发表这篇文章的时候，很难在互联网上了解组合。因为在大多数算法中，你必须使用树形数据结构来生成组合，并使用相同的方法来解决问题。所以我不得不做一些关于树数据结构的研究。我遇到第二个问题是这个方法有两个解决方案。简单的和高效的，难的。我不需要完整的组合生成器功能，因为我只需要处理3个元素。所以我选择了简单的方法。事情是这样的，简单的那个根本没有优化。我不得不使用Java而不是Python来避免超时错误。完成挑战后，我做了一些困难的研究。我不得不深入学习一下递归。但是那一次我发现这些算法不只是一团糟，而且也没有看起来那么有效。实现这些算法需要时间，并且可以在性能方面进行更多的优化。再说一遍，有很多算法可供你检验，我不想说得太具体。所以，我决定为什么我不做一个研究，并试图找出最优雅和最有效的一个！我就是这样开始的。</p><h1 id="8bfa" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">先决条件</h1><p id="6061" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">任何编程语言的基础知识都是期望的。与其他组合算法不同，Asif的算法不需要你深入了解递归。但是关于递归的最少知识是被期望的。</p><p id="d5bb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本页可能会对你的递归有所帮助:<a class="ae ks" href="https://www.tutorialspoint.com/data_structures_algorithms/recursion_basics.htm" rel="noopener ugc nofollow" target="_blank">https://www . tutorialspoint . com/data _ structures _ algorithms/recursion _ basics . htm</a></p><h1 id="5579" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">阿西夫算法</h1><p id="35ef" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">好了，我们到了主赛事现场！Asif的算法。</p><h2 id="4d7d" class="kt jq hi bd jr ku kv kw jv kx ky kz jz jb la lb kd jf lc ld kh jj le lf kl lg bi translated">主要依据</h2><ol class=""><li id="73d9" class="lh li hi is b it kn ix ko jb lj jf lk jj ll jn lm ln lo lp bi translated">首先弹出数组的第一个元素，并将其存储在任何变量中。</li><li id="7abd" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">递归地找出数组其余部分的组合两次(第一次是r - 1的组合，第二次是r的组合)并存储它。我们为什么要生成两次组合将在后面解释。</li><li id="0b9f" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">然后将我们弹出的第一个元素放在我们使用r - 1生成的所有组合的前面。</li><li id="cb83" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">你完了！但是不要忘记实现基本标准来打破递归。</li></ol><p id="31e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就这么简单。还在迷茫？放心吧！让我们深入了解一下。</p><p id="45b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们有一个数组[ 1，2，3，4 ]。从该数组中，我们必须生成3个元素的组合(r = 3)。我们把我们的组合函数叫做“<em class="jo">组合</em>”。根据算法，您弹出数组的第一个元素，并将其存储在一个变量中。做我们所拥有的，</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="80b7" class="kt jq hi ma b fi me mf l mg mh">head = 1, array = [ 2, 3, 4 ]</span></pre><p id="c539" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们用r - 1递归调用我们的组合函数。在我们的例子中，r是3，所以是2。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="8f0d" class="kt jq hi ma b fi me mf l mg mh">result = combination(array, 2)</span></pre><p id="ecf0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果应该是，</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="61cd" class="kt jq hi ma b fi me mf l mg mh">result = [ [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]</span></pre><p id="5449" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了！现在我们的下一步是推动第一个元素。我们将弹出的第一个元素存储在head变量中。我们把它加在我们生成的组合前面。添加后的结果将是，</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="0281" class="kt jq hi ma b fi me mf l mg mh">result = [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ] ]</span></pre><p id="155f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，这应该产生所有的组合。好的，坚持住！我们的数组长度是4，r是3。那么，4C3就是4对吗？那么我们应该有4个元素而不是3个元素。另一个在哪里？这就是第二代组合出现的原因。如果我们在r = 3的情况下再次递归调用组合函数，就可以找到丢失的元素。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="6711" class="kt jq hi ma b fi me mf l mg mh">results_again = combination(arr, 3)</span></pre><p id="f513" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这应该会导致，</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="5d12" class="kt jq hi ma b fi me mf l mg mh">results_again = [ [ 2, 3, 4 ] ]</span></pre><p id="ef12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">显然，如果数组长度等于r，那么将返回相同的数组作为结果。但是如果我们合计结果，我们得到，</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="f7de" class="kt jq hi ma b fi me mf l mg mh">final_result = result + result_again</span></pre><p id="5ea4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">结果是，</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="8274" class="kt jq hi ma b fi me mf l mg mh">final_result = [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ], [ 2, 3, 4 ] ]</span></pre><p id="7609" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">万岁！我们得到了所有可能的组合。如果你到这里还不明白，试着再读一遍内容，最重要的是记住这是一种递归方法，它有一个基本的标准或递归终止点。</p><h1 id="16bf" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">履行</h1><p id="d3a6" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">这里，我打算用JavaScript实现组合函数。你可以尝试在其他编程语言上实现它，比如C++、Java或Python。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="e082" class="kt jq hi ma b fi me mf l mg mh"><strong class="ma hj">function </strong>Combinations( arr, r ) {<br/>    // To avoid object referencing, cloning the array.<br/>    arr = arr &amp;&amp; arr.slice() || [];</span><span id="b806" class="kt jq hi ma b fi mi mf l mg mh">    <strong class="ma hj">var </strong>len = arr.length;</span><span id="046f" class="kt jq hi ma b fi mi mf l mg mh">    <strong class="ma hj">if</strong>( !len || r &gt; len || !r )     // Base criteria 1.<br/>        <strong class="ma hj">return </strong>[ [] ];<br/>    <strong class="ma hj">else if</strong>( r === len )            // Base criteria 2. <br/>        <strong class="ma hj">return </strong>[ arr ];</span><span id="a412" class="kt jq hi ma b fi mi mf l mg mh">    // Base criteria 3. If r === 1, return individual elements.<br/>    <strong class="ma hj">if</strong>( r === 1 ) <strong class="ma hj">return </strong>arr.reduce( ( x, v ) =&gt; {<br/>        x.push( [ v ] );</span><span id="69f3" class="kt jq hi ma b fi mi mf l mg mh">        <strong class="ma hj">return </strong>x;<br/>    }, [] );</span><span id="3efe" class="kt jq hi ma b fi mi mf l mg mh">    <strong class="ma hj">var </strong>head = arr.shift();         // Popping the first element.</span><span id="0440" class="kt jq hi ma b fi mi mf l mg mh">    <strong class="ma hj">return </strong>Combinations( arr, r - 1 ).map( x =&gt; {<br/>        // Pushing the first popped element at the front of all the generated combinations.<br/>        x.unshift( head );</span><span id="ae8d" class="kt jq hi ma b fi mi mf l mg mh">        <strong class="ma hj">return </strong>x;<br/>    } ).concat( Combinations( arr, r ) ); // The missing combinations.<br/>}</span><span id="62a2" class="kt jq hi ma b fi mi mf l mg mh">// Now do your stuff.</span><span id="1231" class="kt jq hi ma b fi mi mf l mg mh">console.log( Combinations( [ 1, 2, 3, 4, 5 ], 3 ) );</span></pre><h1 id="72de" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="53a8" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">这就结束了我关于以优雅而有效的方式生成组合的文章。希望对你有所帮助。是SD·阿西夫·侯赛因。注销。</p></div></div>    
</body>
</html>