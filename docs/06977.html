<html>
<head>
<title>Asking in Akka</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用阿卡语询问</h1>
<blockquote>原文：<a href="https://medium.com/codex/asking-in-akka-439fec603f64?source=collection_archive---------6-----------------------#2022-05-23">https://medium.com/codex/asking-in-akka-439fec603f64?source=collection_archive---------6-----------------------#2022-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="7f1f" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">文章</h2><div class=""/><div class=""><h2 id="f299" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated"><em class="jg">摘自</em> <a class="ae jh" href="https://www.manning.com/books/akka-in-action-second-edition?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_abraham2_akka_9_17_21" rel="noopener ugc nofollow" target="_blank"> <em class="jg">阿卡在行动，第二版</em> </a> <em class="jg">作者弗朗西斯科·洛佩兹-桑乔·亚伯拉罕</em></h2></div><p id="efd0" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">这篇文章简单介绍了Akka中“提问”的基本原理。</em></p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><p id="9b84" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">将<strong class="jk hs"> fccabraham2 </strong>输入<a class="ae jh" href="https://www.manning.com/?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_abraham2_akka_9_17_21" rel="noopener ugc nofollow" target="_blank">manning.com</a>结账处的折扣代码框，享受35%的折扣<a class="ae jh" href="https://www.manning.com/books/akka-in-action-second-edition?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_abraham2_akka_9_17_21" rel="noopener ugc nofollow" target="_blank"> <em class="ke"> Akka in Action，第二版</em> </a> <em class="ke"> </em>。</p></div><div class="ab cl kf kg gp kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hb hc hd he hf"><h2 id="aa4f" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">询问。或者期待回复。</strong></h2><p id="f02c" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">用Akka lingua语来说，询问就是发送信息并提供处理响应的方法。发送消息后会发生两件事。要么您得到一个指示消息已经被处理的响应，要么您没有。如果你没有，那么你需要决定你该怎么办——就像寄一封信一样，就像在美好的旧时光一样。如果你需要一个回应，但你没有得到，在你采取行动之前，你愿意等多久？</p><p id="3af3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">答案是用时间和两种可能的结果来表述的。在Akka中，当我们要求某样东西时，我们还必须提供我们愿意等多久，以及我们将要做什么，不管我们是否收到答复。这两件事都很容易设置。对于计时，我们使用类超时，对于事实，我们可以得到或得不到答案。这是对两个选项<code class="du ll lm ln lo b">Success</code>和<code class="du ll lm ln lo b">Failure</code>的模式匹配。这是抽象类<code class="du ll lm ln lo b">Try[T]</code>仅有的两个实例，其中<code class="du ll lm ln lo b">T</code>是我们期望得到的对象类型，如果答案及时返回，因此被认为是成功的。当我们查看管理器的新实现时，我们将立即看到一个示例，但是在此之前，我们可以先看一下图1，以便对它有所了解。</p><figure class="lq lr ls lt fd lu er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lp"><img src="../Images/fb94cef63ae86e123060ce00a9370edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BVeXC1e4FLuKJSsZ.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">图1经理询问员工的可能结果</figcaption></figure><p id="88e0" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在这里，我们描述了一个经理在某个时间范围内向一个工人请求一项任务，然后工人停止等待响应。根据应答是在超时之前还是之后出现，管理器处理成功或失败。</p><p id="cafb" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在我们深入实现之前，最后一个想法是记住，我们将看到这种询问的两种情况:一种更简单，作为问题发送的消息不包含任何内容；另一种更完整，我们发送的对象包含一些工人使用的信息。</p><p id="7d7f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在这两种情况下，我们将有相同的应用程序和一个监护人来传递经理获得的任务列表。在清单1中，我们可以看到程序开始时的初始输入。</p><p id="28de" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单1 ManagerWorkerApp和Guardian </strong></p><pre class="lq lr ls lt fd mf lo mg mh aw mi bi"><span id="bb1b" class="km kn hi lo b fi mj mk l ml mm">import akka.actor.typed.scaladsl.Behaviors<br/> import akka.actor.typed.{ ActorRef, ActorSystem, Behavior }<br/> import scala.concurrent.duration.SECONDS<br/> import akka.util.Timeout<br/> import scala.util.{ Failure, Success }<br/>  <br/> object ManangerWorkerApp extends App {<br/>  <br/>   val system: ActorSystem[Guardian.Command] =<br/>     ActorSystem(Guardian(), "example-ask-without-content")<br/>   system ! Guardian.Start(List("task-a", "task-b", "task-c", "task-d"))      #A<br/> }<br/>  <br/> object Guardian {<br/>  <br/>   sealed trait Command<br/>   case class Start(tasks: List[String]) extends Command<br/>  <br/>   def apply(): Behavior[Command] =<br/>     Behaviors.setup { context =&gt;<br/>       val manager: ActorRef[Manager.Command] =<br/>         context.spawn(Manager(), "manager-1")<br/>       Behaviors.receiveMessage {<br/>         case Start(tasks) =&gt;<br/>           manager ! Manager.Delegate(tasks)<br/>           Behaviors.same<br/>       }<br/>     }<br/> }</span></pre><p id="ff95" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A输入，任务列表</strong></p><p id="6208" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B向下传递输入</strong></p><p id="0f57" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">更简单的问题</strong></p><p id="fc9d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果我们运行前面清单1中的<code class="du ll lm ln lo b">App</code>，我们可以看到两种类型的结果。第一种类型在这里，如清单2所示。</p><p id="a7db" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单2响应及时返回时的输出</strong></p><pre class="lq lr ls lt fd mf lo mg mh aw mi bi"><span id="10b1" class="km kn hi lo b fi mj mk l ml mm">[Worker$] - My name is 'worker-task-c'. And I've done my task<br/> [Manager$] - task-c has been finished by worker-task-c</span></pre><p id="a3d3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这里可以补充的不多。在这种情况下，<code class="du ll lm ln lo b">Worker</code>及时完成了任务，<code class="du ll lm ln lo b">Manager</code>记录了这个事实。这是一只<code class="du ll lm ln lo b">Success</code>。</p><p id="73ca" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">另一方面，我们可以在清单3中看到另一种输出。</p><p id="d8f8" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单3响应没有及时返回时的输出</strong></p><pre class="lq lr ls lt fd mf lo mg mh aw mi bi"><span id="1dfc" class="km kn hi lo b fi mj mk l ml mm">[Manager$] - task 'task-a' has failed with [Ask timed out on [Actor[akka://example-ask-without-content/user/manager-1/worker-task-a#-450068248]] after [3000 ms]. Message of type [ask.simple.Worker$Do]. A typical reason for `AskTimeoutException` is that the recipient actor didn't send a reply.<br/> [Worker$] - My name is 'worker-task-a'. And I've done my task<br/> [DeadLetterActorRef] - Message [ask.simple.Worker$Done$] to Actor[akka://example-ask-without-content/deadLetters] was not delivered. [2] dead letters encountered. If this is not an expected behavior then Actor[akka://example-ask-without-content/deadLetters] may have terminated unexpectedly. This logging can be turned off or adjusted with configuration settings 'akka.log-dead-letters' and 'akka.log-dead-letters-during-shutdown'.</span></pre><p id="b114" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在最后一种情况下，发生了三件相关的事情。经理停止了等待答案，感觉回来了，报告说任务没有完成。另一方面，工人花费的时间比要求的要长，尽管经理放弃了等待，工人还是完成了任务。这就是我们看到第二条信息的原因。发生的第三件事涉及到两个新演员。当工作者完成它的任务时，它试图发送回一个回答，但是这个消息永远不会到达管理器。怎么会这样这是因为，当<code class="du ll lm ln lo b">ask</code> ing时，一个短暂的中间参与者被创建，用于处理沿着预定义的<code class="du ll lm ln lo b">Timeout</code>的等待。最终这会在管理器中产生一个<code class="du ll lm ln lo b">Success</code>或<code class="du ll lm ln lo b">Failure</code>消息。</p><p id="4245" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">乍一看，这个流程可能有点复杂；让我们从图2中得到一些帮助。回顾一下大局。</p><figure class="lq lr ls lt fd lu er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lp"><img src="../Images/f8dbdffae4974044767a8c3ed91b5963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5XjUgH1rNVCvPIkk.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">图二。短暂的中间参与者生命周期和超时后的职责</figcaption></figure><p id="5834" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">从一开始。当经理请求时，一个短暂的参与者负责将原始消息发送给工人，并将<code class="du ll lm ln lo b">Success</code>或<code class="du ll lm ln lo b">Failure</code>发送回经理。不管是这个还是那个，这个演员立刻就进入了<code class="du ll lm ln lo b">Behavior.stopped</code>。一旦这个actor被停止，它的引用就不再有效，当我们的<code class="du ll lm ln lo b">Worker</code>发回消息时，已经太晚了ActorSystem接管，确保这个消息被传递到死信。</p><p id="ebe5" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在，当事情变糟时，我们至少有一些信息，但这必须持保留态度；发送消息保证尽最大努力。</p><p id="b642" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果由于某种原因，工人出了问题，抛出异常，或者它运行的机架着火，经理就会得到一个<code class="du ll lm ln lo b">Timeout</code>。来自不存在的Worker的消息不会被创建，也不会被发送到deadLetters，因为默认情况下，Actor中的任何异常都由其创建者通过监督来处理。</p><p id="0fc3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在清单4中，我们看到了我们一直在谈论的管理器。它定义了<code class="du ll lm ln lo b">Timeout</code>以及<code class="du ll lm ln lo b">Success</code>和<code class="du ll lm ln lo b">Failure</code>的对策。</p><p id="5ca9" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单4经理询问</strong></p><pre class="lq lr ls lt fd mf lo mg mh aw mi bi"><span id="1a53" class="km kn hi lo b fi mj mk l ml mm">object Manager {<br/>  <br/>   sealed trait Command<br/>   final case class Delegate(tasks: List[String]) extends Command<br/>   final case class Report(description: String) extends Command<br/>  <br/>   def apply(): Behavior[Command] =<br/>     Behaviors.setup { context =&gt;<br/>       implicit val timeout: Timeout = Timeout(3, SECONDS)          #A<br/>  <br/>       Behaviors.receiveMessage { message =&gt;<br/>         message match {<br/>           case Delegate(tasks) =&gt;                                            #B<br/>             tasks.map { task =&gt;<br/>               val worker: ActorRef[Worker.Command] =<br/>                 context.spawn(Worker(), s"worker-$task")<br/>               context.ask(worker, Worker.Do) {                               #C<br/>                 case Success(Worker.Done) =&gt;                                 #D<br/>                   Report(s"$task has been finished by ${worker}") <br/>                 case Failure(ex) =&gt;                                          #D<br/>                   Report(s"task '$task' has failed with [${ex.getMessage()}")<br/>               }<br/>             }<br/>             Behaviors.same<br/>           case Report(description) =&gt;<br/>             context.log.info(description)<br/>             Behaviors.same<br/>         }<br/>       }<br/>     }<br/> }</span></pre><p id="b030" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">#一个超时含蓄地传递给了问</strong></p><p id="5a00" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B任务输入</strong></p><p id="ae28" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">问工人</p><p id="4002" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #D处理可能的结果</strong></p><p id="2fd7" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们在这里如何使用<code class="du ll lm ln lo b">ask</code>非常简单。经理正在将任务<code class="du ll lm ln lo b">Worker.Do</code>委派给我们正在询问的人，即<code class="du ll lm ln lo b">worker</code>，等待时间不会超过<code class="du ll lm ln lo b">timeout</code>。</p><p id="f7ae" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们可以在清单1中看到，在Worker本身中,<code class="du ll lm ln lo b">Worker.Do(replyTo: ActorRef[Worker.Response])</code>如何引用它需要重放给谁以及以什么条件重放。让我们看看清单5中的worker定义。</p><p id="129b" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单5工人回答</strong></p><pre class="lq lr ls lt fd mf lo mg mh aw mi bi"><span id="303a" class="km kn hi lo b fi mj mk l ml mm">object Worker {<br/>  <br/>   sealed trait Command<br/>   case class Do(replyTo: ActorRef[Worker.Response]) extends Command<br/>  <br/>   sealed trait Response<br/>   case object Done extends Response<br/>  <br/>   def apply(): Behavior[Command] =<br/>     Behaviors.receive { (context, message) =&gt;<br/>       message match {<br/>         case Do(replyTo) =&gt;<br/>           doing(scala.util.Random.between(2000, 4000))                       #A<br/>           context.log.info(<br/>             s"My name is '${context.self.path.name}'. And I've done my task")<br/>           replyTo ! Worker.Done                                                       #B<br/>           Behaviors.stopped<br/>       }<br/>     }<br/>  <br/>   def doing(duration: Int): Unit = {<br/>     val endTime = System.currentTimeMillis + duration<br/>     while (endTime &gt; System.currentTimeMillis) {}<br/>   }<br/> }</span></pre><p id="4e45" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A仿真委托任务</strong></p><p id="a1ab" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B回复经理</strong></p><p id="b057" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">首先，我们来关注一下<code class="du ll lm ln lo b">Worker.Do(replyTo: ActorRef[Worker.Response])</code>。你可能会问自己这个<code class="du ll lm ln lo b">replyTo</code>是如何出现在我们发送的信息中的。毕竟，当我们使用<code class="du ll lm ln lo b">context.ask(worker, Worker.Do)</code>时，这里没有提到<code class="du ll lm ln lo b">replyTo</code>。它是怎么结束的？</p><p id="55f8" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">要回答这个问题，我们必须在清单6中更深入地研究一下，<code class="du ll lm ln lo b">ask</code>本身的签名。</p><p id="cf8c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单6询问签名</strong></p><pre class="lq lr ls lt fd mf lo mg mh aw mi bi"><span id="4715" class="km kn hi lo b fi mj mk l ml mm">// Scala API impl<br/>   override def ask[Req, Res](target: RecipientRef[Req], createRequest: ActorRef[Res] =&gt; Req)( mapResponse: Try[Res] =&gt; T)(implicit responseTimeout: Timeout, classTag: ClassTag[Res]): Unit</span></pre><p id="cf6e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果这似乎有点令人生畏，这意味着我们需要走得更慢。如果我们一步一步来，这一点也不难。</p><p id="0348" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">当我们写<code class="du ll lm ln lo b">context.ask(worker, Worker.Do)</code>时，查看ask的签名<code class="du ll lm ln lo b">worker</code>对应于<code class="du ll lm ln lo b">target</code>参数。这里没什么神秘的，但是<code class="du ll lm ln lo b">Worker.Do</code>是不是<code class="du ll lm ln lo b">createRequest</code>可能不清楚。</p><p id="908e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们可能认为我们在那里传递了一个对象，但是签名<code class="du ll lm ln lo b">createRequest: ActorRef[Res] =&gt; Req</code>，告诉我们这是一个函数，而不是一个对象。接下来的问题是，我们如何从传递的这个<code class="du ll lm ln lo b">Worker.Do</code>对象中获取一个函数？如果您不熟悉Scala，这可能会让人感到困惑。Scala中的对象可以被视为函数，只要它们有一个apply方法，这里的<code class="du ll lm ln lo b">case class</code>是一个特殊的类，它提供了这个apply方法。在我们的例子中，感谢编译器，case类<code class="du ll lm ln lo b">Worker.Do(replyTo: ActorRef[Worker.Response])</code>产生了一个类似<code class="du ll lm ln lo b">def apply(replyTo: ActorRef[Worker.Response]): Worker.Do = new Worker.Do(replyTo)</code>的方法。</p><p id="9126" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">因为这个方法产生了，编译器现在理解了我们把<code class="du ll lm ln lo b">Worker.Do</code>放在<code class="du ll lm ln lo b">ask</code>方法中的意思。编译器推断我们引用的是我们的<code class="du ll lm ln lo b">case class</code>的<code class="du ll lm ln lo b">apply</code>函数，因为这是在<code class="du ll lm ln lo b">createRequest</code>的签名范围内唯一有意义的事情。就是这个——由于语法上的好处和编译器的聪明，我们将<code class="du ll lm ln lo b">Worker.Do.apply()</code>传递给那个方法。</p><p id="11db" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在来看一下<code class="du ll lm ln lo b">mapResponse</code>。根据它是否及时收到答案，我们代码中的<code class="du ll lm ln lo b">Success</code>或<code class="du ll lm ln lo b">Failure</code>被触发。我们已经讨论过这个问题，但现在让我们更仔细地看看。我们看到<code class="du ll lm ln lo b">mapResponse: Try[Res] =&gt; T</code>，内容如下:<code class="du ll lm ln lo b">mapResponse</code>是一个必须定义两个函数的函数——一个有输入<code class="du ll lm ln lo b">Success[Res]</code>和输出<code class="du ll lm ln lo b">T</code>，另一个有输入<code class="du ll lm ln lo b">Failure</code>和输出<code class="du ll lm ln lo b">T</code>。在我们的例子中，<code class="du ll lm ln lo b">Res</code>是<code class="du ll lm ln lo b">Worker.Done</code>，而<code class="du ll lm ln lo b">T</code>是<code class="du ll lm ln lo b">Manager.Command</code>。</p><p id="b206" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">最后，<code class="du ll lm ln lo b">implicit responseTimeout: Timeout</code>是我们等待响应的时间。它是一个隐式参数的事实意味着，如果在作用域中有一个隐式值，它就使用它，而不需要你显式地传递它。Scala中定义了许多作用域，但现在不会涉及这些。可以说，在我们的方法范围内，我们有一个隐含的“超时”。</p><p id="863c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">关于<code class="du ll lm ln lo b">classTag</code>，我们不会太在意。它的存在是出于历史原因和二进制兼容性。</p><p id="71a2" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这是你使用<code class="du ll lm ln lo b">ask</code>所需要知道的全部，但是还有一些其他的事情需要注意。当经理发送请求时会发生什么？运行时发生了什么？我们之前提到过，在提问的参与者和回答的参与者之间，有一个中间参与者。这个中间人演员就是我们的工人回复和来自<code class="du ll lm ln lo b">Worker.Do(replyTo: ActorRef[Worker.Response])</code>签名的那个。我们知道它的类型是<code class="du ll lm ln lo b">ActorRef[Worker.Response]</code>。当<code class="du ll lm ln lo b">Manager</code>请求<code class="du ll lm ln lo b">Worker</code>时，该类型的actor被创建，并被用作不带语法糖的方法的输入，<code class="du ll lm ln lo b">Worker.Do.apply(replyTo: ActorRef[Worker.Response])</code>。最后，这个<code class="du ll lm ln lo b">Worker.Do(intermediaryActor)</code>就是<code class="du ll lm ln lo b">Worker</code>接收到的。</p><h2 id="da44" class="km kn hi bd ko kp kq kr ks kt ku kv kw jr kx ky kz jv la lb lc jz ld le lf ho bi translated"><strong class="ak">询问有效载荷</strong></h2><p id="c16a" class="pw-post-body-paragraph ji jj hi jk b jl lg is jn jo lh iv jq jr li jt ju jv lj jx jy jz lk kb kc kd hb bi translated">有时我们对演员有所了解，我们需要在这个问题中包含一些信息。在前面的例子中，工作人员唯一知道的是向谁作出回应。让我们来看一个与前一个几乎相同的例子，除了当<code class="du ll lm ln lo b">ask</code>时，我们需要传递给工人一个包含一个<code class="du ll lm ln lo b">id</code>和一个<code class="du ll lm ln lo b">description</code>的<code class="du ll lm ln lo b">Task</code>。清单7给出了一个例子。</p><p id="d617" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单7任务对象作为有效载荷在询问时传递</strong></p><pre class="lq lr ls lt fd mf lo mg mh aw mi bi"><span id="cde5" class="km kn hi lo b fi mj mk l ml mm">final case class Task(taskId: String, taskDescription: String)<br/> sealed trait Command<br/> final case class Do(task: Task, replyTo: ActorRef[Worker.Response])<br/>       extends Command</span></pre><p id="ef10" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在这种情况下，当我们向<code class="du ll lm ln lo b">ask</code>提供<code class="du ll lm ln lo b">createRequest</code>参数时，我们将无法像以前那样依赖<code class="du ll lm ln lo b">Worker.Do.apply()</code>。记住<code class="du ll lm ln lo b">createRequest</code>期望一个只有一个参数的函数，但是现在，我们的<code class="du ll lm ln lo b">Worker.Do.apply</code>有两个参数，<code class="du ll lm ln lo b">task</code>和<code class="du ll lm ln lo b">replyTo</code>。框架在运行时为我们提供了中介<code class="du ll lm ln lo b">replyTo</code>，我们需要提供<code class="du ll lm ln lo b">task</code>。现在我们需要一个可以接受一个<code class="du ll lm ln lo b">Task</code>作为输入的方法，我们可以将它传递给Worker。这给了我们一个可以传递给<code class="du ll lm ln lo b">ask</code>的函数。在清单8中，我们有一个带有这种签名的函数。</p><p id="dc2a" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单8辅助方法创建签名询问函数</strong></p><pre class="lq lr ls lt fd mf lo mg mh aw mi bi"><span id="3d90" class="km kn hi lo b fi mj mk l ml mm">def auxCreateRequest (task: Worker.Task)(replyTo: ActorRef[Worker.Response]): Worker.Do = Worker.Do(task, replyTo)</span></pre><p id="77e9" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们看看清单9中的管理器，看看这是如何进行的。</p><p id="b2c3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单9使用auxCreateRequest的管理器</strong></p><pre class="lq lr ls lt fd mf lo mg mh aw mi bi"><span id="4300" class="km kn hi lo b fi mj mk l ml mm">object Manager {<br/>  <br/>   sealed trait Command<br/>   final case class Delegate(tasks: List[String]) extends Command<br/>   final case class Report(outline: String) extends Command<br/>  <br/>   def apply(): Behavior[Command] =<br/>     Behaviors.setup { context =&gt;<br/>       implicit val timeout: Timeout = Timeout(3, SECONDS)<br/>       def auxCreateRequest(task: Worker.Task)(                               #A<br/>           replyTo: ActorRef[Worker.Response]): Worker.Do =                   #A<br/>         Worker.Do(task, replyTo)                                             #A<br/>  <br/>       Behaviors.receiveMessage { message =&gt;<br/>         message match {<br/>           case Delegate(tasks) =&gt;<br/>             tasks.map { task =&gt;<br/>               val worker: ActorRef[Worker.Command] =<br/>                 context.spawn(Worker(), s"worker-$task")<br/>               context.ask(<br/>                 worker,<br/>                 auxCreateRequest(                                                     #B<br/>                   Worker.Task(System.currentTimeMillis().toString(), task))) {        #B<br/>                 case Success(Worker.Done(taskId)) =&gt;<br/>                   Report(s"$taskId has been finished by ${worker}")<br/>                 case Failure(ex) =&gt;<br/>                   Report(s"task has failed with [${ex.getMessage()}")<br/>               }<br/>             }<br/>             Behaviors.same<br/>           case Report(outline) =&gt;<br/>             context.log.info(outline)<br/>             Behaviors.same<br/>         }<br/>       }<br/>     }<br/> }</span></pre><p id="e3c2" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A辅助功能将任务传递给工人</strong></p><p id="fdc3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B任务功能的使用</strong></p><p id="7a9c" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果你不习惯函数式编程，可能很难直接理解这个<code class="du ll lm ln lo b">auxCreateRequest</code>如何产生<code class="du ll lm ln lo b">ask.createRequest</code>需要的签名。</p><p id="5ff5" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在我们的例子中，管理器从守护器中取出一个<code class="du ll lm ln lo b">Task</code>，姑且称之为<code class="du ll lm ln lo b">taskX</code>，并将其传递给我们的辅助方法。这产生了一个我们在清单10中看到的新函数。</p><p id="1135" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单10将‘taskX’传递给auxCreateRequest </strong>后的输出</p><pre class="lq lr ls lt fd mf lo mg mh aw mi bi"><span id="b535" class="km kn hi lo b fi mj mk l ml mm">def irrelevantName(rsp:ActorRef[Worker.Response]):Worker.Do =  Worker.Do(taskX,rsp)</span></pre><p id="6185" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这叫做currying，大多数函数式语言都提供了这种功能。我们可以把它看作是函数的部分应用，它的工作原理如下。当有一个类似于<code class="du ll lm ln lo b">multiplication(x: Int,y: Int) = x * y</code>的函数时，你可以通过<code class="du ll lm ln lo b">multipication(4)</code>来调用那个函数，这意味着你只传递了<code class="du ll lm ln lo b">x</code>，而不是<code class="du ll lm ln lo b">y</code>。这样做，你得到了一个新的函数<code class="du ll lm ln lo b">multiplication Curried(z: Int) = 4 * z</code>——现在你可以把它用作<code class="du ll lm ln lo b">multiplicationCurried(3) = 12</code>。</p><p id="1ad9" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在Scala中，我们需要明确地声明一个函数什么时候可以被定制。这是通过用括号将我们想要传递的输入变量分开来实现的。在这种情况下，我们会把它作为<code class="du ll lm ln lo b">def multipication(x: Int)(y: Int)</code>，我们把它作为<code class="du ll lm ln lo b">multiplication(4)_.</code></p><p id="b89d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">回到清单11中的转换<code class="du ll lm ln lo b">auxCreateRequest</code>，我们看到如何使用函数<code class="du ll lm ln lo b">createRequest</code>，只传递任务<code class="du ll lm ln lo b">taskX</code>和我们将得到的输出函数。</p><p id="3029" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单11只传递一个参数给auxCreateRequest </strong></p><pre class="lq lr ls lt fd mf lo mg mh aw mi bi"><span id="16f5" class="km kn hi lo b fi mj mk l ml mm">auxCreateRequest(taskX)(replyTo: ActorRef[Worker.Response])                  #A<br/>  <br/> def irrelevantName(rsp:ActorRef[Worker.Response]): Worker.Do =  auxCreateRequest(‘taskX`)(rsp:ActorRef[Worker.Response])              #B<br/>  <br/><strong class="lo hs"> #A currying with taskX<br/> #B output</strong></span></pre><p id="94ab" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在，<code class="du ll lm ln lo b">irrelevantName</code>函数是我们可以传递给<code class="du ll lm ln lo b">createRequest</code>的函数，而<code class="du ll lm ln lo b">taskX</code>包含在工人收到的消息中。如果一个人不习惯奉承，这就有点麻烦了，但是你可能经常需要这样做。了解ask的签名是一项有用的知识。</p><p id="c9b3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">本文到此为止。如果你想了解这本书的更多信息，可以在曼宁的liveBook平台上查看<a class="ae jh" href="https://livebook.manning.com/book/akka-in-action-second-edition?origin=product-look-inside&amp;utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_abraham2_akka_9_17_21" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>