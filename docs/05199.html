<html>
<head>
<title>Using the Spring Web Scopes, Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spring Web Scopes，第2部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/using-the-spring-web-scopes-part-2-59a3e952f641?source=collection_archive---------12-----------------------#2022-02-07">https://medium.com/codex/using-the-spring-web-scopes-part-2-59a3e952f641?source=collection_archive---------12-----------------------#2022-02-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="faae" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">文章</h2><div class=""/><div class=""><h2 id="733c" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated"><em class="jg">从</em> <a class="ae jh" href="https://www.manning.com/books/spring-start-here?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_spilca2_spring_9_22_20" rel="noopener ugc nofollow" target="_blank"> <em class="jg">春天从这里开始</em> </a> <em class="jg">由laurențiu·斯皮尔奇</em></h2></div><p id="011d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><em class="ke">本文涵盖</em></p><ul class=""><li id="7069" class="kf kg hi jk b jl jm jo jp jr kh jv ki jz kj kd kk kl km kn bi translated"><em class="ke">使用弹簧网示波器</em></li><li id="e419" class="kf kg hi jk b jl ko jo kp jr kq jv kr jz ks kd kk kl km kn bi translated"><em class="ke">为网络应用实现简单的登录功能</em></li><li id="c5a9" class="kf kg hi jk b jl ko jo kp jr kq jv kr jz ks kd kk kl km kn bi translated"><em class="ke">在网络应用程序中从一个页面重定向到另一个页面</em></li></ul></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="ca98" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在<a class="ae jh" href="https://www.manning.com/?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_spilca2_spring_9_22_20" rel="noopener ugc nofollow" target="_blank">manning.com</a>的结账处，将<strong class="jk hs"> fccspilca2 </strong>输入折扣代码框，即可享受40%的折扣。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="6eb4" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在这里查看第1部分<a class="ae jh" href="https://manningbooks.medium.com/using-the-spring-web-scopes-part-1-f05b8919e75b" rel="noopener"/>。</p><h2 id="4453" class="la lb hi bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt ho bi translated"><strong class="ak">在Spring web应用程序中使用会话范围</strong></h2><p id="7f54" class="pw-post-body-paragraph ji jj hi jk b jl lu is jn jo lv iv jq jr lw jt ju jv lx jx jy jz ly kb kc kd hb bi translated">在本节中，我们将讨论会话范围的beans。当你进入一个网络应用程序并登录后，你希望浏览该应用程序的页面，而该应用程序仍然记得你已经登录。会话范围的bean是由Spring管理的对象，Spring为它创建一个实例并将其链接到HTTP会话。一旦客户端向服务器发送请求，服务器会在整个会话期间为该请求在内存中保留一个位置。当为特定客户机创建HTTP会话时，Spring会创建一个会话范围bean的实例。只要HTTP会话仍然处于活动状态，该实例就可以在同一个客户机上重用。在整个HTTP会话中，存储在会话范围bean属性中的数据可用于所有客户机请求。这种存储数据的方法允许你存储用户在浏览你的应用页面时做了什么的信息。</p><figure class="ma mb mc md fd me er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es lz"><img src="../Images/13c7519f63c83db11f9418233a026e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jl5EmNdhoGdj7rGF.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">图8会话范围的bean用于在客户机的整个HTTP会话中保持上下文中的bean。Spring为客户机打开的每个HTTP会话创建一个会话范围bean的实例。对于在同一个HTTP会话中发送的所有请求，客户端访问同一个实例。每个用户都有自己的会话，并访问会话范围bean的不同实例。</figcaption></figure><p id="1321" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在花点时间比较图8和图2，图8展示了会话范围的bean，图2展示了请求范围的bean。图9也总结了这两种方法之间的比较。当您有一个请求范围的bean时，Spring为每个HTTP请求创建一个新的实例，但是当您有一个会话范围的bean时，Spring只为每个HTTP会话创建一个实例。会话范围的bean允许我们存储由同一客户机的多个请求共享的数据。</p><figure class="ma mb mc md fd me er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es mp"><img src="../Images/ac62e408e2dd7c7de56b8a9b09c342f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*904SbsOqa2yNp9xG.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">图9比较了请求作用域和会话作用域的bean，帮助您更容易地形象化这两个web bean作用域之间的差异。当您希望Spring为每个请求创建一个新实例时，您可以使用请求范围的beans。当您希望在客户机的整个HTTP会话中保留bean(以及它所包含的任何详细信息)时，可以使用会话范围的bean。</figcaption></figure><p id="6e87" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">可以使用会话范围的beans实现的功能的几个例子是</p><ul class=""><li id="698c" class="kf kg hi jk b jl jm jo jp jr kh jv ki jz kj kd kk kl km kn bi translated">登录-当经过身份验证的用户访问应用程序的不同部分并发送多个请求时，您需要保存他们的详细信息。</li><li id="a545" class="kf kg hi jk b jl ko jo kp jr kq jv kr jz ks kd kk kl km kn bi translated">在线购物车—用户访问应用程序的多个位置，搜索他们添加到购物车的产品。购物车会记住客户添加的所有产品。</li></ul><figure class="ma mb mc md fd me er es paragraph-image"><div class="er es mq"><img src="../Images/2ddca93142d66fe5f1de9901e979462b.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*xzzJv7CFO3efii1NIxueww.png"/></div></figure><p id="08b2" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">在本节中，我们将使用一个会话范围的bean来使我们的应用程序知道有用户登录，并在他们访问应用程序的不同页面时将他们识别为登录用户。通过这种方式，该示例向您传授了在使用生产应用程序时需要了解的所有相关细节。</p><p id="3052" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">让我们更改前面实现的应用程序，以显示只有登录用户才能访问的页面。一旦用户登录，应用程序会将他们重定向到该页面。该页面显示包含登录用户名的欢迎消息，并为用户提供通过单击页面上的链接注销的选项。</p><p id="d5e3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们需要采取以下步骤来实现这一变化(图10):</p><ol class=""><li id="b805" class="kf kg hi jk b jl jm jo jp jr kh jv ki jz kj kd mr kl km kn bi translated">创建一个会话范围的bean来保存登录用户的详细信息。</li><li id="c01f" class="kf kg hi jk b jl ko jo kp jr kq jv kr jz ks kd mr kl km kn bi translated">创建用户只能在登录后访问的页面。</li><li id="c1cd" class="kf kg hi jk b jl ko jo kp jr kq jv kr jz ks kd mr kl km kn bi translated">确保用户在没有首先登录的情况下不能访问在第1点创建的页面。</li><li id="00c8" class="kf kg hi jk b jl ko jo kp jr kq jv kr jz ks kd mr kl km kn bi translated">成功验证后，将用户从登录重定向到主页。</li></ol><figure class="ma mb mc md fd me er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es ms"><img src="../Images/526d94c0cbfff56e905c34272f9ad590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vDmjC3ch1HoZWH0N.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">图10我们使用一个会话bean来实现只有登录用户才能访问的应用程序部分。一旦用户通过身份验证，应用程序会将他们重定向到页面，他们只有通过身份验证后才能访问该页面。如果用户试图在身份验证之前访问该页面，应用程序会将他们重定向到登录表单。</figcaption></figure><p id="1bba" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">幸运的是，在Spring中，创建一个会话范围的bean就像在bean类中使用<code class="du mt mu mv mw b">@SessionScope</code>注释一样简单。让我们创建一个新的类，<code class="du mt mu mv mw b">LoggedUserManagementService,</code>,并使它的作用域如清单5所示。</p><p id="3abf" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单5。定义一个会话范围的bean来保存记录的用户详细信息</strong></p><pre class="ma mb mc md fd mx mw my mz aw na bi"><span id="60d7" class="la lb hi mw b fi nb nc l nd ne">@Service    #A<br/> @SessionScope    #B<br/> public class LoggedUserManagementService {<br/>  <br/>   private String username;<br/>  <br/>   // Omitted getters and setters<br/> }</span></pre><p id="bdae" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A我们添加了@Service原型注释来指示Spring在其上下文中将这个类作为bean来管理。</strong></p><p id="ca1e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们使用@SessionScope注释将bean的作用域改为session。</p><p id="e3e3" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">每次用户成功登录时，我们都将其名称存储在这个bean的username属性中。我们自动连接了<code class="du mt mu mv mw b">LoginProcessor</code>类中的<code class="du mt mu mv mw b">LoggedUserManagementService</code> bean，我们之前实现它是为了处理认证逻辑。</p><p id="2d14" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单6。使用</strong> <code class="du mt mu mv mw b"><strong class="jk hs">LoggedUserManagementService</strong></code>中的<strong class="jk hs"> bean登录逻辑</strong></p><pre class="ma mb mc md fd mx mw my mz aw na bi"><span id="7206" class="la lb hi mw b fi nb nc l nd ne">@Component<br/> @RequestScope<br/> public class LoginProcessor {<br/>  <br/>   private final LoggedUserManagementService loggedUserManagementService;<br/>  <br/>   private String username;<br/>   private String password;<br/>  <br/>   public LoginProcessor(    #A<br/>     LoggedUserManagementService loggedUserManagementService) {<br/>     this.loggedUserManagementService = loggedUserManagementService;<br/>   }<br/>  <br/>   public boolean login() {<br/>     String username = this.getUsername();<br/>     String password = this.getPassword();<br/>  <br/>     boolean loginResult = false;<br/>     if ("natalie".equals(username) &amp;&amp; "password".equals(password)) {<br/>       loginResult = true;<br/>       loggedUserManagementService.setUsername(username);    #B<br/>     }<br/>  <br/>     return loginResult;<br/>   }<br/>  <br/>   // Omitted getters and setters<br/> }</span></pre><p id="28df" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A我们自动连接LoggedUserManagementService bean</strong></p><p id="62b9" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B我们将用户名存储在LoggedUserManagementService bean上</strong></p><p id="f61f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">注意到<code class="du mt mu mv mw b">LoginProcessor</code> bean保持在请求范围内。我们仍然需要Spring为每个登录请求创建这个实例。在请求执行身份验证逻辑的过程中，我们只需要用户名和密码属性值。</p><p id="8461" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">因为<code class="du mt mu mv mw b">LoggedUserManagementService</code> bean是会话范围的，所以现在可以在整个HTTP会话中访问用户名值。您可以使用这个值来了解是否有人登录以及登录的人是谁。你不用担心多用户登录的情况；应用程序框架确保将每个HTTP请求链接到正确的会话。图11直观地描述了登录流程。</p><figure class="ma mb mc md fd me er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es ms"><img src="../Images/8c060a09e07a179a7d0041703b9663f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fq9MDc9tlA5gfXSD.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">图11示例中实现的登录流程。当用户提交他们的凭证时，登录过程开始。如果用户的凭证正确，用户名将存储在会话范围的bean中，应用程序将用户重定向到主页。如果凭据无效，应用程序会将用户重定向回登录页面，并显示登录失败的消息。</figcaption></figure><p id="e15e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在，我们创建一个新页面，并确保只有已经登录的用户才能访问它。我们为新页面定义了一个新的控制器(我们称之为<code class="du mt mu mv mw b">MainController)</code>。我们将定义一个动作，并将其映射到/main路径。为了确保用户只有登录后才能访问这个路径，我们检查了<code class="du mt mu mv mw b">LoggedUserManagementService</code> bean是否存储了任何用户名。如果它没有存储用户名，我们将用户重定向到登录页面。要将用户重定向到另一个页面，控制器操作需要返回字符串“redirect:”后跟操作要将用户重定向到的路径。图12直观地展示了主页背后的逻辑。</p><figure class="ma mb mc md fd me er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es lz"><img src="../Images/edb4529d35338eaca1d1acaceed0b2ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f7KYEC0Qf0g8SVr2.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">图12某人只有在通过身份验证后才能访问主页。当应用程序对用户进行身份验证时，它将用户名存储在会话范围的bean中。这样，应用程序就知道用户已经登录了。当有人访问主页，并且用户名不在会话范围的bean中时(他们没有进行身份验证)，应用程序会将他们重定向到登录页面。</figcaption></figure><p id="57d7" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">清单6展示了<code class="du mt mu mv mw b">MainController</code>类。</p><p id="053d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单6。</strong> <code class="du mt mu mv mw b"><strong class="jk hs">MainController</strong></code> <strong class="jk hs">类</strong></p><pre class="ma mb mc md fd mx mw my mz aw na bi"><span id="a652" class="la lb hi mw b fi nb nc l nd ne">@Controller<br/> public class MainController {<br/>  <br/>   private final LoggedUserManagementService loggedUserManagementService;<br/>  <br/>   public MainController(    #A<br/>     LoggedUserManagementService loggedUserManagementService) {<br/>     this.loggedUserManagementService = loggedUserManagementService;<br/>   }<br/>  <br/>   @GetMapping("/main")<br/>   public String home() {<br/>     String username =     #B<br/>       loggedUserManagementService.getUsername();<br/>  <br/>     if (username == null) {    #C<br/>       return "redirect:/";<br/>     }<br/>  <br/>     return "main.html";    #D<br/>   }<br/> }</span></pre><p id="4609" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A我们自动连接LoggedUserManagementService bean，以确定用户是否已经登录。</strong></p><p id="6abe" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B我们取用户名值，如果有人登录，这个值应该不同于null。</strong></p><p id="d82d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #C如果用户没有登录，我们会将用户重定向到登录页面。</strong></p><p id="641d" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #D如果用户登录，我们返回主页面的视图。</strong></p><p id="3d53" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">您需要在Spring Boot项目的resources/templates文件夹中添加定义视图的main.html。清单7显示了main.html页面的内容。</p><p id="9e18" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单7。main.html页面的内容</strong></p><pre class="ma mb mc md fd mx mw my mz aw na bi"><span id="da5f" class="la lb hi mw b fi nb nc l nd ne">&lt;!DOCTYPE html&gt;<br/> &lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;<br/> &lt;head&gt;<br/>     &lt;meta charset="UTF-8"&gt;<br/>     &lt;title&gt;Welcome&lt;/title&gt;<br/> &lt;/head&gt;<br/> &lt;body&gt;<br/>     &lt;h1&gt;Welcome&lt;/h1&gt;<br/> &lt;/body&gt;<br/> &lt;/html&gt;</span></pre><p id="5881" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">允许用户注销也很容易；您需要将<code class="du mt mu mv mw b">LoggedUserManagementService</code>会话bean中的用户名设置为null。让我们在页面上创建一个注销链接，并在欢迎消息中添加已登录的用户名。清单8显示了定义我们视图的main.html页面的变化。</p><p id="2f3e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单8。向main.html页面添加注销链接</strong></p><pre class="ma mb mc md fd mx mw my mz aw na bi"><span id="41a4" class="la lb hi mw b fi nb nc l nd ne">&lt;!DOCTYPE html&gt;<br/> &lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;<br/> &lt;head&gt;<br/>     &lt;meta charset="UTF-8"&gt;<br/>     &lt;title&gt;Login&lt;/title&gt;<br/> &lt;/head&gt;<br/> &lt;body&gt;<br/>     &lt;h1&gt;Welcome, &lt;span th:text="${username}"&gt;&lt;/span&gt;&lt;/h1&gt;    #A<br/>     &lt;a href="/main?logout"&gt;Log out&lt;/a&gt;    #B<br/> &lt;/body&gt;<br/> &lt;/html&gt;</span></pre><p id="0329" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A我们从控制器获取用户名，并在页面的欢迎消息中显示出来。</strong></p><p id="8ed4" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B我们在页面上添加一个链接，设置一个名为“logout”的HTTP请求参数。当控制器获得该参数时，它会从会话中删除用户名的值。</strong></p><p id="0484" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">这些main.html页面的变化也假设控制器中的一些变化，以完成功能。清单9展示了如何在控制器的动作中获取注销请求参数，并将用户名发送到页面上显示的视图。</p><p id="bbcf" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单9。基于注销请求参数</strong>注销用户</p><pre class="ma mb mc md fd mx mw my mz aw na bi"><span id="f75d" class="la lb hi mw b fi nb nc l nd ne">@Controller<br/> public class MainController {<br/>  <br/>   // Omitted code<br/>  <br/>   @GetMapping("/main")   <br/>   public String home(<br/>       @RequestParam(required = false) String logout,    #A<br/>       Model model    #B<br/>   ) {<br/>     if (logout != null) {    #C<br/>       loggedUserManagementService.setUsername(null);<br/>     }<br/>  <br/>     String username = loggedUserManagementService.getUsername();<br/>  <br/>     if (username == null) {<br/>       return "redirect:/";<br/>     }<br/>  <br/>     model.addAttribute("username" , username);    #D<br/>     return "main.html";<br/>   }<br/> }</span></pre><p id="171f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果存在的话，我们得到注销请求参数。</p><p id="4c79" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们添加一个模型参数来发送用户名到视图。</p><p id="7e9e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">如果logout参数存在，我们从LoggedUserManagementService bean中删除用户名。</p><p id="8015" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #D我们将用户名发送给视图。</strong></p><p id="7f39" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">为了完成该应用程序，我们希望更改<code class="du mt mu mv mw b">LoginController</code>以在用户通过身份验证后将他们重定向到主页面。为了达到这个结果，我们需要改变清单10所示的<code class="du mt mu mv mw b">LoginController</code>的动作。</p><p id="7d2f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单10。登录后将用户重定向到主页面</strong></p><pre class="ma mb mc md fd mx mw my mz aw na bi"><span id="ab68" class="la lb hi mw b fi nb nc l nd ne">@Controller<br/> public class LoginController {<br/>  <br/>   // Omitted code<br/>  <br/>   @PostMapping("/")<br/>   public String loginPost(<br/>       @RequestParam String username,<br/>       @RequestParam String password,<br/>       Model model<br/>   ) {<br/>     loginProcessor.setUsername(username);<br/>     loginProcessor.setPassword(password);<br/>     boolean loggedIn = loginProcessor.login();<br/>  <br/>     if (loggedIn) {   #A<br/>       return "redirect:/main";<br/>     }<br/>  <br/>     model.addAttribute("message", "Login failed!");<br/>     return "login.html";<br/>   }<br/> }</span></pre><p id="e6d9" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A当用户成功认证后，应用程序会将他们重定向到主页面。</strong></p><p id="fc17" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在，您可以启动应用程序并测试登录。当您提供正确的凭据时，应用程序会将您重定向到主页。点击“注销”链接，应用程序会将你重定向回登录页面。如果您试图在未进行身份验证的情况下访问主页，应用程序会重定向您进行登录。</p><figure class="ma mb mc md fd me er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es nf"><img src="../Images/93b44b45b8725c93683af800d6bd3a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BknmW4kr6-h3uTfi.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">图13这个视觉呈现了两个页面之间的流程。当用户登录时，应用程序会将他们重定向到主页面。用户可以点击注销链接，应用程序会将他们重定向回登录表单。</figcaption></figure><h2 id="e59c" class="la lb hi bd lc ld le lf lg lh li lj lk jr ll lm ln jv lo lp lq jz lr ls lt ho bi translated"><strong class="ak">在Spring web app中使用应用范围</strong></h2><p id="3f61" class="pw-post-body-paragraph ji jj hi jk b jl lu is jn jo lv iv jq jr lw jt ju jv lx jx jy jz ly kb kc kd hb bi translated">在本节中，我们讨论应用范围。我想提到它的存在，让你意识到它是如何工作的，并强调最好不要在生产应用程序中使用它。所有客户端请求共享一个应用程序范围的bean(图14)。</p><figure class="ma mb mc md fd me er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es ms"><img src="../Images/b3d5f8875c86507f42df1574bc626e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ts7BpbL0dCl5I0Ly.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">图14理解Spring web应用程序中的应用程序范围。来自所有客户端的所有HTTP请求共享应用程序范围的bean的实例。Spring上下文只提供了bean类型的一个实例，供任何需要的人使用。</figcaption></figure><p id="7497" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">应用程序范围接近于单例的工作方式。不同之处在于，在上下文中不能有更多相同类型的实例，并且在讨论web作用域(包括应用程序作用域)的生命周期时，我们总是使用HTTP请求作为参考点。对于单例bean和应用程序作用域bean，最好有不可变的属性，但是如果使属性不可变，可以直接使用单例bean。</p><p id="7490" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">通常，我建议开发人员避免使用应用程序范围的beans。通常，最好直接使用持久层，比如数据库，而不是在应用程序范围的bean中处理数据。</p><p id="b57e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">最好能看到一个例子来更好地理解这个案例。让我们修改一下本文中的应用程序，添加一个统计登录尝试次数的特性。</p><p id="b443" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">因为我们必须对所有用户的登录尝试进行计数，所以我们将把计数存储在应用程序范围的bean中。让我们创建一个<code class="du mt mu mv mw b">LoginCountService</code>应用程序范围的bean，它将计数存储在一个属性中。清单11显示了这个类的定义。</p><p id="017a" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单11。</strong> <code class="du mt mu mv mw b"><strong class="jk hs">LoginCountService</strong></code> <strong class="jk hs">类统计登录尝试次数</strong></p><pre class="ma mb mc md fd mx mw my mz aw na bi"><span id="b2ec" class="la lb hi mw b fi nb nc l nd ne">@Service<br/> @ApplicationScope    #A<br/> public class LoginCountService {<br/>  <br/>   private int count;<br/>  <br/>   public void increment() {<br/>     count++;<br/>   }<br/>  <br/>   public int getCount() {<br/>     return count;<br/>   }<br/> }</span></pre><p id="4034" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">@ApplicationScope注释将此bean的作用域更改为应用程序作用域。</p><p id="e5ee" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">然后，<code class="du mt mu mv mw b">LoginProcessor</code>可以自动连接这个bean，并为任何新的登录尝试调用<code class="du mt mu mv mw b">increment()</code>方法，如清单12所示。</p><p id="5c19" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单12。针对每个登录请求增加登录计数</strong></p><pre class="ma mb mc md fd mx mw my mz aw na bi"><span id="920b" class="la lb hi mw b fi nb nc l nd ne">@Component<br/> @RequestScope<br/> public class LoginProcessor {<br/>  <br/>   private final LoggedUserManagementService loggedUserManagementService;<br/>   private final LoginCountService loginCountService;<br/>  <br/>   private String username;<br/>   private String password;<br/>  <br/>   public LoginProcessor(    #A<br/>     LoggedUserManagementService loggedUserManagementService, <br/>     LoginCountService loginCountService) {<br/>     this.loggedUserManagementService = loggedUserManagementService;<br/>     this.loginCountService = loginCountService;<br/>   }<br/>  <br/>   public boolean login() {<br/>     loginCountService.increment();    #B<br/>    <br/>     String username = this.getUsername();<br/>     String password = this.getPassword();<br/>  <br/>     boolean loginResult = false;<br/>     if ("natalie".equals(username) &amp;&amp; "password".equals(password)) {<br/>       loginResult = true;<br/>       loggedUserManagementService.setUsername(username);<br/>     }<br/>  <br/>     return loginResult;<br/>   }<br/>  <br/>   // Omitted code<br/> }</span></pre><p id="ff8e" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A我们通过构造函数的参数注入LoginCountService bean】</strong></p><p id="1405" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">我们对每次登录尝试增加计数。</p><p id="0cf1" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">现在您需要做的最后一件事就是显示这个值。您可以在控制器的动作中使用一个<code class="du mt mu mv mw b">Model</code>参数来将计数值发送给视图。然后，您可以使用百里香叶在视图中显示该值。清单13展示了如何将值从控制器发送到视图。</p><p id="e8b4" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单13。从控制器发送计数值以显示在主页面上</strong></p><pre class="ma mb mc md fd mx mw my mz aw na bi"><span id="67bd" class="la lb hi mw b fi nb nc l nd ne">@Controller<br/> public class MainController {<br/>  <br/>   // Omitted code<br/>  <br/>   @GetMapping("/main")<br/>   public String home(<br/>       @RequestParam(required = false) String logout,<br/>       Model model<br/>   ) {<br/>     if (logout != null) {<br/>       loggedUserManagementService.setUsername(null);<br/>     }<br/>  <br/>     String username = loggedUserManagementService.getUsername();<br/>     int count = loginCountService.getCount();    #A<br/>  <br/>     if (username == null) {<br/>       return "redirect:/";<br/>     }<br/>  <br/>     model.addAttribute("username" , username);<br/>     model.addAttribute("loginCount", count);    #B<br/>  <br/>     return "main.html";<br/>   }<br/> }</span></pre><p id="5b6f" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A从应用程序作用域的bean中获取计数。</strong></p><p id="3241" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #B向视图发送计数值。</strong></p><p id="6516" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">清单14展示了如何在页面上显示计数值。</p><p id="dd99" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs">清单14。在主页面上显示计数值</strong></p><pre class="ma mb mc md fd mx mw my mz aw na bi"><span id="002c" class="la lb hi mw b fi nb nc l nd ne">&lt;!DOCTYPE html&gt;<br/> &lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;<br/> &lt;head&gt;<br/>     &lt;meta charset="UTF-8"&gt;<br/>     &lt;title&gt;Login&lt;/title&gt;<br/> &lt;/head&gt;<br/> &lt;body&gt;<br/>     &lt;h1&gt;Welcome, &lt;span th:text="${username}"&gt;&lt;/span&gt;!&lt;/h1&gt;<br/>     &lt;h2&gt;<br/>       Your login number is<br/>       &lt;span th:text="${loginCount}"&gt;&lt;/span&gt;    #A<br/>     &lt;/h2&gt;<br/>     &lt;a href="/main?logout"&gt;Log out&lt;/a&gt;<br/> &lt;/body&gt;<br/> &lt;/html&gt;</span></pre><p id="72eb" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated"><strong class="jk hs"> #A在页面上显示计数。</strong></p><p id="bd45" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">运行您的应用程序，您会在主页上发现登录尝试的总次数，如图15所示。</p><figure class="ma mb mc md fd me er es paragraph-image"><div class="er es ng"><img src="../Images/84959e2b2ee1c8ca2e08e22a906d4129.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/0*gN9nhjjfWLKAfTup.png"/></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">图15应用程序的结果是一个显示所有用户登录总数的网页。该主页显示登录尝试的总次数。</figcaption></figure><p id="bdca" class="pw-post-body-paragraph ji jj hi jk b jl jm is jn jo jp iv jq jr js jt ju jv jw jx jy jz ka kb kc kd hb bi translated">目前就这些。如果你想了解更多，请在曼宁的liveBook平台<a class="ae jh" href="https://livebook.manning.com/book/spring-start-here?origin=product-look-inside&amp;utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_spilca2_spring_9_22_20" rel="noopener ugc nofollow" target="_blank">点击</a>查看这本书。</p></div></div>    
</body>
</html>