<html>
<head>
<title>Scheduling tasks with WorkManager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用工作管理器计划任务</h1>
<blockquote>原文：<a href="https://medium.com/codex/scheduling-tasks-with-workmanager-13c4ad62704d?source=collection_archive---------2-----------------------#2021-05-08">https://medium.com/codex/scheduling-tasks-with-workmanager-13c4ad62704d?source=collection_archive---------2-----------------------#2021-05-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2ffa5fce1179104e019e75a01269a566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*48pMmY3lVb4UdrmB3U8ojA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@moritz_photography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">莫里茨·金德勒</a>在<a class="ae iu" href="https://unsplash.com/s/photos/clock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0e18" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一个简单的方法，通过拆分名称来描述WorkManager的特性。想象一下，你正在经营一家公司，你要负责同时处理大量的事情。在某些时候，你很难独自完成这一切。让我们称这些任务为<strong class="ix hj">工作</strong>。自然，你会把这些<strong class="ix hj">作品</strong>委托给你的下属或者你的员工。他们有能力在不打扰你的情况下管理它。他们可以和你一样高效地完成这些任务，同时减轻你肩上的负担。让我们称他们为"<strong class="ix hj">管理者</strong>"所以工作+经理=工作经理。</p><p id="6a24" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们重新思考一下Android世界中的相同场景。使用WorkManager API，您可以调度可推迟或异步的任务。WorkManager将确保这些任务将运行，即使您的应用程序已退出或处于后台。它是Android后台调度API的继承者，如FirebaseJobDispatcher、GcmNetworkManager和JobScheduler。你可以说工作管理器是一个结合了所有前辈力量的野兽。此外，它是向后兼容的(API级别14)，并意识到电池寿命。还有一个很酷的特性叫做“约束”我们将很快了解它。</p><h2 id="9d04" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">在后台</h2><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ko"><img src="../Images/3957b3b2597a251507786345a01d5656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NeyRYZFErHogkJPVHgw-eQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源:Android开发者</figcaption></figure><p id="7045" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您发送工作请求时，WorkManager会将其保存在本地数据库中。这就是即使应用程序退出或处于后台，它也能记住工作的方式。然后，它将检查您是否正在使用API级别23+,如果是，它将向JobScheduler发送工作请求。如果你的API等级在14-22之间，它会检查你的设备是否安装了Google play服务。如果是，那么将调用GcmNetworkManager。否则，自定义AlarmManager和BroadcastReceiver。</p><h2 id="96bf" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">我们要建造什么？</h2><p id="7358" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">我们将创建一个应用程序，将从网络下载图像，并在ImageView上显示它。通过使用这个例子，我们将了解工作管理器的特性。</p><h2 id="8cae" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">定义工作</h2><p id="cea4" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">我们已经决定从网络上下载一张图片，然后在ImageView上显示。就是我们所说的<code class="du ky kz la lb b">Work</code>。我们定义这项工作的类被称为<code class="du ky kz la lb b">Worker </code>类。</p><pre class="kp kq kr ks fd lc lb ld le aw lf bi"><span id="7f05" class="jt ju hi lb b fi lg lh l li lj">class ImageDownloadWorker(context: Context, params: WorkerParameters): CoroutineWorker(context, params) {<br/><br/>    override suspend fun doWork(): Result {<br/>        return try {<br/>            downloadImage()<br/>            Result.success(outputData)<br/>        }catch (e: Exception) {<br/>            Result.failure()<br/>        }<br/><br/>    }<br/>}</span></pre><p id="f91a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过简单地用一个<code class="du ky kz la lb b">Worker</code>类扩展任何一个类来创建一个<code class="du ky kz la lb b">Worker</code>类。它将覆盖一个名为<code class="du ky kz la lb b">doWork()</code>的方法，该方法将在WorkManager提供的后台线程上异步运行。你可能已经注意到我们正在扩展一个<code class="du ky kz la lb b">CoroutineWorker </code>而不是一个普通的<code class="du ky kz la lb b">Worker </code>类。如果你用的是Java，那么你可以用<code class="du ky kz la lb b">ListenableWorker </code>。原因是<code class="du ky kz la lb b">Worker</code>类在后台同步运行，而<code class="du ky kz la lb b">ListenableWorker </code>和<code class="du ky kz la lb b">CoroutineWorker </code>会异步运行。</p><p id="2e17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果将通知您您的工作是成功、失败还是需要重试。</p><h2 id="0c2c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">创建工作请求</h2><p id="f9d2" class="pw-post-body-paragraph iv iw hi ix b iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo kx jq jr js hb bi translated">既然我们已经定义了我们的<code class="du ky kz la lb b">Worker</code>类，我们必须使用WorkManager服务来调度我们的工作请求。有两种方法可以安排您的工作请求。您可以在一段时间间隔内定期运行您的请求，也可以安排它只运行一次。</p><blockquote class="lk ll lm"><p id="b75e" class="iv iw ln ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">创建一次性工作请求</p></blockquote><p id="b3fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建WorkManager类的新实例。</p><pre class="kp kq kr ks fd lc lb ld le aw lf bi"><span id="afbd" class="jt ju hi lb b fi lg lh l li lj">private val workManager by <em class="ln">lazy </em><strong class="lb hj">{<br/>    </strong>WorkManager.getInstance(<em class="ln">applicationContext</em>)<br/><strong class="lb hj">}</strong></span></pre><p id="64e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，创建您的工作请求</p><pre class="kp kq kr ks fd lc lb ld le aw lf bi"><span id="f55d" class="jt ju hi lb b fi lg lh l li lj"><br/>val constraints = Constraints.Builder()<br/>    .setRequiredNetworkType(NetworkType.<em class="ln">CONNECTED</em>)<br/>    .build()<br/><br/>val imageDownloadWorker = <em class="ln">OneTimeWorkRequestBuilder</em>&lt;ImageDownloadWorker&gt;()<br/>    .setConstraints(constraints)<br/>    .addTag(<em class="ln">UNIQUE_TAG</em>)<br/>    .build()<br/><br/>workManager.enqueueUniqueWork(<br/>    "oneTimeImageDownloader",<br/>    ExistingWorkPolicy.<em class="ln">KEEP</em>,<br/>    imageDownloadWorker<br/>)</span></pre><p id="94d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们仔细检查每一行代码，了解发生了什么。</p><pre class="kp kq kr ks fd lc lb ld le aw lf bi"><span id="e7f8" class="jt ju hi lb b fi lg lh l li lj">val constraints = Constraints.Builder()<br/>    .setRequiredNetworkType(NetworkType.<em class="ln">CONNECTED</em>)<br/>    .build()</span></pre><p id="4c3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">顾名思义，如果不满足某些条件，约束将限制工作管理器的操作。在这里，我确保工作管理器只有在互联网连接正常的情况下才会运行。这样，您可以设置一些其他约束，例如，</p><ul class=""><li id="8138" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated">设备电池状况良好</li><li id="2358" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">设备存储很好</li></ul><pre class="kp kq kr ks fd lc lb ld le aw lf bi"><span id="e823" class="jt ju hi lb b fi lg lh l li lj">val imageDownloadWorker = <em class="ln">OneTimeWorkRequestBuilder</em>&lt;ImageDownloadWorker&gt;()<br/>    .setConstraints(constraints)<br/>    .addTag(<em class="ln">UNIQUE_TAG</em>)<br/>    .build()</span></pre><p id="0408" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">创建一个OneTimeWorkRequestBuilder，并添加约束细节和一个唯一标记。我们可以使用这个标签来取消或观察我们的工作。</p><pre class="kp kq kr ks fd lc lb ld le aw lf bi"><span id="7b22" class="jt ju hi lb b fi lg lh l li lj">workManager.enqueueUniqueWork(<br/>    "oneTimeImageDownloader",<br/>    ExistingWorkPolicy.<em class="ln">KEEP</em>,<br/>    imageDownloadWorker<br/>)</span></pre><p id="27a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，将工作请求排队。</p><blockquote class="lk ll lm"><p id="015f" class="iv iw ln ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">创建定期工作请求</p></blockquote><p id="35b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有时候，我们的应用程序需要定期运行一些任务。比如，同步一天的活动，或者像WhatsApp一样备份数据。在这种情况下，可以使用PeriodicWorkRequest。</p><pre class="kp kq kr ks fd lc lb ld le aw lf bi"><span id="6c91" class="jt ju hi lb b fi lg lh l li lj">val builder = Data.Builder()<br/>builder.putString(<em class="ln">KEY_IMAGE_ID</em>, "1")<br/>val data = builder.build()<br/><br/>val constraints = Constraints.Builder()<br/>    .setRequiredNetworkType(NetworkType.<em class="ln">CONNECTED</em>)<br/>    .build()<br/><br/>val imageDownloadWorker = <em class="ln">PeriodicWorkRequestBuilder</em>&lt;ImageDownloadWorker&gt;(<br/>    15, TimeUnit.<em class="ln">MINUTES<br/></em>).setInputData(data)<br/>    .setConstraints(constraints)<br/>    .addTag(<em class="ln">UNIQUE_TAG</em>)<br/>    .build()<br/><br/>workManager.enqueueUniquePeriodicWork(<br/>    "periodicImageDownloader",<br/>    ExistingPeriodicWorkPolicy.<em class="ln">KEEP</em>,<br/>    imageDownloadWorker)</span></pre><p id="47db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">OneTimeWorkRequest和PeriodicWorkRequest之间的区别在于，我们有一个额外的参数来指定最小间隔。你可能会想，为什么它被称为最小间隔<strong class="ix hj">而不是重复间隔</strong>呢？原因是，由于我们之前设置的约束，时间间隔可能会延长。如果没有互联网连接，那么工作将不会运行，并且这个间隔可以被延长。此外，请记住最短时间长度为15分钟。</p><blockquote class="lk ll lm"><p id="4292" class="iv iw ln ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">添加输入和输出</p></blockquote><p id="2fb4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们使用了<code class="du ky kz la lb b">Data</code>对象。它们是键/值对的轻量级容器。它们帮助我们从<code class="du ky kz la lb b">WorkRequest</code>传入和传出数据。</p><pre class="kp kq kr ks fd lc lb ld le aw lf bi"><span id="d2ec" class="jt ju hi lb b fi lg lh l li lj">val builder = Data.Builder()<br/>builder.putString(<em class="ln">KEY_IMAGE_ID</em>, "1")<br/>val data = builder.build()</span></pre><ul class=""><li id="cff2" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated">创建数据构建器对象</li><li id="89fe" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">然后，使用putString方法将ImageId添加到构建器中。常量中的KEY_IMAGE_ID作为“键”,值为“1”。</li><li id="869e" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">在<code class="du ky kz la lb b">Data.Builder</code>对象上调用<code class="du ky kz la lb b">build</code>来创建你的<code class="du ky kz la lb b">data</code>对象并返回它。</li></ul><p id="0aa5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完全码</p><pre class="kp kq kr ks fd lc lb ld le aw lf bi"><span id="3340" class="jt ju hi lb b fi lg lh l li lj">val builder = Data.Builder()<br/>builder.putString(<em class="ln">KEY_IMAGE_ID</em>, "1")<br/>val data = builder.build()<br/><br/>val constraints = Constraints.Builder()<br/>    .setRequiredNetworkType(NetworkType.<em class="ln">CONNECTED</em>)<br/>    .build()<br/><br/>val imageDownloadWorker = <em class="ln">OneTimeWorkRequestBuilder</em>&lt;ImageDownloadWorker&gt;()<br/>    .setConstraints(constraints)<br/>    .setInputData(data)<br/>    .addTag(<em class="ln">UNIQUE_TAG</em>)<br/>    .build()<br/><br/>workManager.enqueueUniqueWork(<br/>    "oneTimeImageDownloader",<br/>    ExistingWorkPolicy.<em class="ln">KEEP</em>,<br/>    imageDownloadWorker<br/>)</span></pre><p id="0caf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，让我们在<code class="du ky kz la lb b">Worker </code>类中检索ImageId。</p><pre class="kp kq kr ks fd lc lb ld le aw lf bi"><span id="98b2" class="jt ju hi lb b fi lg lh l li lj">override suspend fun doWork(): Result {<br/>    return try {<br/>        val imageId = <em class="ln">inputData</em>.getString(<em class="ln">KEY_IMAGE_ID</em>)<br/>        val picture = downloadImage(imageId)<br/>        val outputData = <em class="ln">workDataOf</em>(<em class="ln">KEY_IMAGE_ID to </em>picture)<br/>        Result.success(outputData)<br/>    }catch (e: Exception) {<br/>        Log.e("doWorkException", e.printStackTrace().toString())<br/>        Result.failure()<br/>    }<br/><br/>}</span></pre><ul class=""><li id="4af2" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated">我们可以使用<code class="du ky kz la lb b">inputData</code>方法获取传递给<code class="du ky kz la lb b">Worker</code>类的imageId。因为我们使用了<code class="du ky kz la lb b">putString</code>方法传递数据，所以我们应该使用<code class="du ky kz la lb b">getString</code>来检索它。</li><li id="9657" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">同样，我们可以从<code class="du ky kz la lb b">WorkRequest</code>返回任何数据。这里，我们将从API返回imageUrl。创建一个新的数据对象，就像我们为输入所做的那样，使用相同的键“KEY_IMAGE_ID”并使用“picture”作为值。</li><li id="25ca" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">使用<code class="du ky kz la lb b">Result.success(outputData)</code>将<code class="du ky kz la lb b">outputData</code>返回到工作管理器</li></ul><p id="087d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完全码</p><pre class="kp kq kr ks fd lc lb ld le aw lf bi"><span id="ac65" class="jt ju hi lb b fi lg lh l li lj">class ImageDownloadWorker(context: Context, params: WorkerParameters) :<br/>    CoroutineWorker(context, params) {<br/><br/>    override suspend fun doWork(): Result {<br/>        return try {<br/>            val imageId = <em class="ln">inputData</em>.getString(<em class="ln">KEY_IMAGE_ID</em>)<br/>            val picture = downloadImage(imageId)<br/>            val outputData = <em class="ln">workDataOf</em>(<em class="ln">KEY_IMAGE_ID to </em>picture)<br/>            Result.success(outputData)<br/>        }catch (e: Exception) {<br/>            Log.e("doWorkException", e.printStackTrace().toString())<br/>            Result.failure()<br/>        }<br/><br/>    }<br/><br/>    private suspend fun downloadImage(imageId: String?): String? {<br/><br/>        val service = ServiceGenerator.createService(Service::class.<em class="ln">java</em>)<br/>        var imageUrl: String? = null<br/>        if (imageId != null) {<br/>            val response = service.getImage(imageId)<br/>            if (response.<em class="ln">isSuccessful</em>) {<br/>                response.body().<em class="ln">let {</em><strong class="lb hj"><br/></strong><br/>                    imageUrl = response.body()?.download_url<br/>                <strong class="lb hj">}<br/>            </strong>}<br/>        }<br/>        return imageUrl<br/>    }<br/>}</span></pre><blockquote class="lk ll lm"><p id="781a" class="iv iw ln ix b iy iz ja jb jc jd je jf lo jh ji jj lp jl jm jn lq jp jq jr js hb bi translated">观察工作进度</p></blockquote><p id="6cc1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以观察工作进度，并根据结果更新我们的UI。</p><pre class="kp kq kr ks fd lc lb ld le aw lf bi"><span id="f657" class="jt ju hi lb b fi lg lh l li lj">private fun observeWork(id: UUID) {<br/>    workManager.getWorkInfoByIdLiveData(id).observe(this, <strong class="lb hj">{ </strong>info <strong class="lb hj">-&gt;<br/>        </strong>if (info != null &amp;&amp; info.<em class="ln">state</em>.<em class="ln">isFinished</em>) {<br/>            val imageUrl = info.<em class="ln">outputData</em>.getString(<em class="ln">KEY_IMAGE_ID</em>)<br/>            Log.e("imageUrlSuccess", imageUrl.<em class="ln">toString</em>())<br/>            if (imageUrl != null) {<br/>                binding.button.<em class="ln">visibility </em>= View.<em class="ln">GONE<br/>                </em>binding.imageView.<em class="ln">visibility </em>= View.<em class="ln">VISIBLE<br/>                </em>setImage(imageUrl)<br/>            }<br/>        }<br/>    <strong class="lb hj">}</strong>)<br/>}</span></pre><p id="8b5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用工人id轻松观察工作，然后以<code class="du ky kz la lb b">LiveData</code>的形式获取信息。我们将能检查工作是否完成了。如果这样，我们可以尝试从Worker类中检索WorkRequest的输出。</p><p id="6a12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:如果您正在执行PeriodicWorkRequest，那么您不能检查状态是否为完成。原因是<strong class="ix hj">工作链</strong>在PeriodicWorkRequest中是不可能的。在工作链中，一个请求在成功后结束，然后转移到下一个工作者。由于工作链是不可能的，PeriodicWorkRequest将处于排队状态，等待下一次执行。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/3b1945d0ed6eb80b9c572c0e045306e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1I2eiUAN0gUNy6bdCVuZmQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源:Android开发者博客</figcaption></figure><p id="fbb4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你能够理解工作管理器的工作原理及其许多有用的特性。WorkManager还有许多其他特性我在本文中没有提到。如果你很好奇想了解更多，我建议你查看Android开发者的这个<a class="ae iu" href="https://developer.android.com/topic/libraries/architecture/workmanager?gclid=Cj0KCQjwytOEBhD5ARIsANnRjVjsZ0xqf65W5fh4H9FQwlm6YEj2mPwWj-F5XkDWAW93tjGoSzdy5a8aAvxREALw_wcB&amp;gclsrc=aw.ds" rel="noopener ugc nofollow" target="_blank">文档</a>。此外，您可以在我的GitHub <a class="ae iu" href="https://github.com/clint22/WorkManagerSample" rel="noopener ugc nofollow" target="_blank">资源库</a>中获得完整的代码。</p><p id="ae1d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望你和你的家人在疫情期间平安无事。让我们一起坚强，互相帮助。</p><p id="27be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">文章原贴<a class="ae iu" href="https://clintpauldev.com/workmanager-android/" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><p id="e3e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可能也想阅读我最近的文章</p><div class="mn mo ez fb mp mq"><a rel="noopener follow" target="_blank" href="/swlh/android-room-testing-made-easy-using-dagger-hilt-89d2d5d0e7f2"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hj fi z dy mv ea eb mw ed ef hh bi translated">使用匕首柄使Android房间测试变得容易</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">我一直想知道是否有一种方法可以确保我们的DAO函数在运行…</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">medium.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne io mq"/></div></div></a></div><div class="mn mo ez fb mp mq"><a rel="noopener follow" target="_blank" href="/swlh/how-to-create-a-simple-camera-app-using-android-camerax-library-7367778498e0"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hj fi z dy mv ea eb mw ed ef hh bi translated">如何使用Android CameraX库创建简单的相机应用程序</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">我只记得少数几个由Android团队开发的API像这个API一样轻松和先进…</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">medium.com</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne io mq"/></div></div></a></div><div class="mn mo ez fb mp mq"><a rel="noopener follow" target="_blank" href="/swlh/how-to-add-multiple-headers-to-grid-recyclerview-in-androidx-9dbd3460e06b"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hj fi z dy mv ea eb mw ed ef hh bi translated">如何在AndroidX中向Grid recyclerView添加多个头</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">这篇博文的封面图片不是巧合。我想和你分享我经历的情感创伤…</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">medium.com</p></div></div><div class="mz l"><div class="ng l nb nc nd mz ne io mq"/></div></div></a></div></div></div>    
</body>
</html>