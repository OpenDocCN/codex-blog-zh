<html>
<head>
<title>Currying in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿中的油彩</h1>
<blockquote>原文：<a href="https://medium.com/codex/currying-in-typescript-ca5226c85b85?source=collection_archive---------1-----------------------#2021-05-17">https://medium.com/codex/currying-in-typescript-ca5226c85b85?source=collection_archive---------1-----------------------#2021-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/72fe44e8b023c9c9158edbea7408a4e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUS9eFNEBepoJREByGSEWQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">安迪嘿的库里照片<a class="ae iu" href="https://unsplash.com/@eastcoastkitchen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> @eastcoastkitchen </a></figcaption></figure><h1 id="2332" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">什么是Currying？</h1><p id="7f26" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">Currying是一种编码技术，它将一个带有一定数量参数的函数转换成一个可链接的函数，允许它的参数分阶段提供。</p><p id="feef" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">例如，奉承<code class="du kw kx ky kz b">fn(1,2,3)</code>将允许它像<code class="du kw kx ky kz b">fn(1)(2)(3)</code>或<code class="du kw kx ky kz b">fn(1)(2,3)</code>等一样被调用。</p><p id="2ca8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">下面是一个currying函数的例子:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="1744" class="li iw hi kz b fi lj lk l ll lm">function curry(targetFn, …existingArgs) {<br/>  return function(…args) {<br/>    const totalArgs = […existingArgs, …args]<br/>    if(totalArgs.length &gt;= targetFn.length) {<br/>      return targetFn(…totalArgs)<br/>    }<br/>    return curry(targetFn, …totalArgs)<br/>  }<br/>}</span></pre><p id="9b28" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">注意目标函数的length属性的使用。因此，currying只能处理带有必需参数的函数。当然，这并不是说最后一次调用curried函数不能提供可选参数。</p><p id="4342" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这有许多用途，例如日志记录函数或构建器。但是它们的一个问题是，至少对于JavaScript来说，生成的curried函数可能会丢失参数信息。如下图所示:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/883a9e82a8bcd0b52723c198e963a166.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*anRngKkbbUfKpeXtvwMZ7Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">普通JS自动完成</figcaption></figure><p id="a17c" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">幸运的是，这是TypeScript可以帮助我们的。但是需要一些相当复杂的类型才能实现。</p><h1 id="7b43" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">场景</h1><p id="a882" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">对于我们的curried函数，在确定其规格时，我们需要考虑两个独立的运动部件:</p><ul class=""><li id="b2b1" class="lo lp hi jv b jw kr ka ks ke lq ki lr km ls kq lt lu lv lw bi translated">原始函数——它可以有任何参数和任何返回类型，但是我们需要知道它们</li><li id="c1ad" class="lo lp hi jv b jw lx ka ly ke lz ki ma km mb kq lt lu lv lw bi translated">先前提供的参数——这些参数可以是任意数量的原始函数参数,但只能按照它们被指定的顺序。</li></ul><p id="b0aa" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们可以使用上面的方法来确定简化函数的参数类型，即任意数量的原始函数<strong class="jv hj">剩余参数</strong></p><p id="f66f" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">然后，我们可以使用上面的所有内容来确定定制函数的<strong class="jv hj">参数和返回类型。</strong></p><ul class=""><li id="cfa4" class="lo lp hi jv b jw kr ka ks ke lq ki lr km ls kq lt lu lv lw bi translated">这些参数将是原始函数剩余的必需参数</li><li id="e646" class="lo lp hi jv b jw lx ka ly ke lz ki ma km mb kq lt lu lv lw bi translated">如果先前提供的参数+最新的参数大于或等于原始函数参数的长度，则返回类型将是原始函数的返回类型。</li><li id="6680" class="lo lp hi jv b jw lx ka ly ke lz ki ma km mb kq lt lu lv lw bi translated">否则，返回类型是另一个使用原始函数和所有当前提供的参数的派生函数</li></ul><p id="f70a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated"><strong class="jv hj">因此，我们需要定义3种主要类型。</strong></p><h1 id="22b4" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><strong class="ak">部分参数类型</strong></h1><p id="0409" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我们需要的第一种类型是给定一个函数，如果所有参数都被认为是可选的，则返回一个表示函数参数的元组。</p><p id="ca72" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这对于我们来说应该是一个容易创建的类型，因为我们几乎可以从TypeScript提供的现有实用程序类型中构建它。</p><ul class=""><li id="0ec2" class="lo lp hi jv b jw kr ka ks ke lq ki lr km ls kq lt lu lv lw bi translated"><code class="du kw kx ky kz b">Partial</code> —该类型接受所提供类型中的所有键，并使它们可选。</li><li id="a722" class="lo lp hi jv b jw lx ka ly ke lz ki ma km mb kq lt lu lv lw bi translated"><code class="du kw kx ky kz b">Parameters</code> —此类型提取表示给定函数参数的元组。</li></ul><p id="95f0" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">最终结果应该是这样的。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="b3ca" class="li iw hi kz b fi lj lk l ll lm">type PartialParameters&lt;<br/>  FN extends (…args: any[]) =&gt; any<br/>&gt; = Partial&lt;Parameters&lt;FN&gt;&gt;;</span></pre><p id="4c7b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">然而，在某些用例中，TypeScript有时不会将<code class="du kw kx ky kz b">Partial&lt;any[]&gt;</code>的结果视为数组类型，因此我们不能将它与rest参数一起使用。问题就谈到这里<a class="ae iu" href="https://github.com/microsoft/TypeScript/issues/29919." rel="noopener ugc nofollow" target="_blank">https://github.com/microsoft/TypeScript/issues/29919.</a></p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="3128" class="li iw hi kz b fi lj lk l ll lm">function foo&lt;<br/>  F extends (…args: any[]) =&gt; any<br/>&gt;(fn: F, …args: Partial&lt;Parameters&lt;F&gt;&gt;) { }<br/>// ERROR: A rest parameter must be of an array type.ts(2370)</span></pre><p id="ae46" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">因此，我们需要以一种将类型的输出保留为元组的方式来重复这个功能。</p><p id="81a4" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">为此，我们将使用一个实用程序类型，它的工作是遍历给定的元组以找到所有的组合，以及一个包装器类型，它将函数参数提供给这个实用程序类型。</p><p id="df95" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这是我们的实用程序类型，它使用递归和推理来一个接一个地检索元组中所有必需的项，并将它们作为可选值添加到输出类型中，最后将任何现有的可选值添加到输出类型中。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="df89" class="li iw hi kz b fi lj lk l ll lm">type PartialTuple&lt;<br/>  TUPLE extends any[],<br/>  EXTRACTED extends any[] = []<br/>&gt; =<br/>  // If the tuple provided has at least one required value<br/>  TUPLE extends [infer NEXT_PARAM, ...infer REMAINING] ?<br/>    // recurse back in to this type with one less item <br/>    // in the original tuple, and the latest extracted value<br/>    // added to the extracted list as optional<br/>    PartialTuple&lt;REMAINING, [...EXTRACTED, NEXT_PARAM?]&gt; :<br/>    // else if there are no more values, <br/>    // return an empty tuple so that too is a valid option<br/>    [...EXTRACTED, ...TUPLE]</span></pre><p id="9acb" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">在这个练习中，推理和递归将是我们最好的朋友。它们允许我们逐个查看所提供的元组的每个部分，直到我们检查完每个必需的参数。</p><p id="cb47" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在我们的<code class="du kw kx ky kz b">PartialParameters</code>类型可以使用这个实用程序类型来代替部分类型，结果是一样的，但是不会混淆TypeScript是否是数组类型。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="a375" class="li iw hi kz b fi lj lk l ll lm">type PartialParameters&lt;FN extends (…args: any[]) =&gt; any&gt; =<br/>  PartialTuple&lt;Parameters&lt;FN&gt;&gt;;</span><span id="b76d" class="li iw hi kz b fi mc lk l ll lm">// EXAMPLE</span><span id="a54a" class="li iw hi kz b fi mc lk l ll lm">type PartialParametersExample = PartialParameters&lt;<br/>  (a: boolean, b: string, c?: number) =&gt; any<br/>&gt;<br/>// type PartialParametersExample = [boolean?, string?, number?]</span></pre><h1 id="acad" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><strong class="ak">剩余参数类型</strong></h1><p id="d7f5" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">如前所述，我们需要考虑的另一种类型是用户仍然需要提供的必需参数的子集。因此，如果我们的curried函数的用户提供了3个参数，总共有5个必需的参数，那么该类型应该返回一个包含其余2个参数类型的元组。</p><p id="7098" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">不幸的是，我们不能只做<code class="du kw kx ky kz b">Array.slice</code>，也不能使用所提供参数的长度来提取给定数量的预期参数，但是我们可以用递归来分析元组类型的长度。方法如下:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="c73f" class="li iw hi kz b fi lj lk l ll lm">type RemainingParameters&lt;<br/>  PROVIDED extends any[],<br/>  EXPECTED extends any[]<br/>&gt; =<br/>  // if the expected array has any required items…<br/>  EXPECTED extends [infer E1, …infer EX] ?<br/>    // if the provided array has at least one required item,<br/>    // recurse with one item less in each array type<br/>    PROVIDED extends [infer P1, …infer PX] ?<br/>      RemainingParameters&lt;PX, EX&gt; :<br/>    // else the remaining args is unchanged<br/>    EXPECTED :<br/>  // else there are no more arguments<br/>  []</span></pre><p id="c424" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">本质上，这样做是从两个元组类型的前面删除必需的项，直到其中一个不再有任何必需的项。如果是空的<code class="du kw kx ky kz b">EXPECTED</code>元组，则返回一个空元组(不是预期的元组，因为它仍然包含可选值，并且我们永远不会达到拥有空元组的地步)。如果是<code class="du kw kx ky kz b">PROVIDED</code>元组，那么返回<code class="du kw kx ky kz b">EXPECTED</code>元组中剩余的内容。</p><p id="de8a" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">同样，这里有一些例子:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="85b2" class="li iw hi kz b fi lj lk l ll lm">type RemainingSimple = RemainingParameters&lt;<br/>  [1, 2],<br/>  [number, number, number]<br/>&gt;<br/>// type RemainingSimple = [number]</span><span id="0126" class="li iw hi kz b fi mc lk l ll lm">type RemainingOverflow = RemainingParameters&lt;<br/>  [1, 2, 3, 4],<br/>  [number]<br/>&gt;<br/>//type RemainingOverflow = []</span></pre><p id="d136" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">你们当中有眼力的可能已经注意到，这实际上并没有断言项的类型是相等的，所以一个字符串元组可以与一个数字元组进行比较，这种类型不会在意。幸运的是，我们不需要这样做，因为当我们使用这种类型时，我们的curried函数类型的其他部分已经断言了这种类型。</p><p id="558e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">但是，如果我们确实想确定类型是正确的，我们可以这样做。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="8cbd" class="li iw hi kz b fi lj lk l ll lm">type RemainingParameters&lt;<br/>  PROVIDED extends any[],<br/>  EXPECTED extends any[]<br/>&gt; =<br/>  // if the expected array has any required items…<br/>  EXPECTED extends [infer E1, …infer EX] ?<br/>    // if the provided array has at least one required item<br/>    PROVIDED extends [infer P1, …infer PX] ?<br/>      // if the type is correct, recurse with one item less<br/>      //in each array type<br/>      P1 extends E1 ? RemainingParameters&lt;PX, EX&gt; :<br/>      // else return this as invalid<br/>      never :<br/>    // else the remaining args is unchanged<br/>    EXPECTED :<br/>  // else there are no more arguments<br/>  []</span></pre><p id="e4e3" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果我们这样做，那么对于递归的每一级，如果提供的参数不是预期类型的有效扩展，类型<code class="du kw kx ky kz b">never</code>将被返回。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="a52f" class="li iw hi kz b fi lj lk l ll lm">// without the type validation<br/>type RemainingDifferentTypes = RemainingParameters&lt;<br/>  [1],<br/>  [string, string]<br/>&gt;<br/>// type RemainingDifferentTypes = [string]</span><span id="93a6" class="li iw hi kz b fi mc lk l ll lm">// with the type validation<br/>type RemainingDifferentTypes = RemainingParameters&lt;<br/>  [1],<br/>  [string, string]<br/>&gt;<br/>// type RemainingDifferentTypes = never</span></pre><h1 id="3ef8" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><strong class="ak">定制函数类型</strong></h1><p id="ccce" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">好的，这是我们必须做的最后一种类型…或者我应该说是最后两种类型，因为我们需要把逻辑分离出来。我们需要一个类型来定义实际的函数，另一个类型来定义它的返回值。</p><p id="2f37" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">让我们从主要的函数类型开始:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="30e1" class="li iw hi kz b fi lj lk l ll lm">type CurriedFunction&lt;<br/>  PROVIDED extends any[],<br/>  FN extends (…args: any[]) =&gt; any<br/>&gt; =<br/>  &lt;NEW_ARGS extends PartialTuple&lt;<br/>    RemainingParameters&lt;PROVIDED, Parameters&lt;FN&gt;&gt;<br/>  &gt;&gt;(…args: NEW_ARGS) =&gt;<br/>    CurriedFunctionOrReturnValue&lt;[…PROVIDED, …NEW_ARGS], FN&gt;</span></pre><p id="03b5" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这个类型有两个泛型参数，一个表示之前提供的所有参数，另一个表示curried函数的类型。</p><p id="af22" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们在这里也给返回的函数类型一个泛型参数，它是从我们之前提供的泛型类型和我们之前构建的类型构建的。将<code class="du kw kx ky kz b">PartialTuple</code>和<code class="du kw kx ky kz b">RemainingParameters</code>与前面的参数和函数参数结合起来，允许我们将返回类型参数指定为“任意数量的剩余函数参数”。</p><p id="76fc" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">使用<code class="du kw kx ky kz b">NEW_ARGS extends</code>捕获参数的类型允许TypeScript在调用函数时准确地看到提供了哪些参数，而不仅仅是知道它是任何有效的选项。因为我们确切地知道它们是什么，所以我们可以将它们与前面的参数组合起来，并将组合后的元组类型传递给我们接下来将构建的<code class="du kw kx ky kz b">CurriedFunctionOrReturnValue</code>类型。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="db87" class="li iw hi kz b fi lj lk l ll lm">type CurriedFunctionOrReturnValue&lt;<br/>  PROVIDED extends any[],<br/>  FN extends (…args: any[]) =&gt; any<br/>&gt; =<br/>  RemainingParameters&lt;PROVIDED, Parameters&lt;FN&gt;&gt;<br/>    extends [any, …any[]] ?<br/>    CurriedFunction&lt;PROVIDED, FN&gt; :<br/>    ReturnType&lt;FN&gt;</span></pre><p id="5617" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">这一个并不太复杂，它使用提供的参数泛型类型来与定制函数的预期参数进行比较。如果发现还剩下任何参数，返回类型就变成另一个<code class="du kw kx ky kz b">CurriedFunction</code>，这次是最新提供的参数。但是，如果已经指定了所有的参数，那么它的返回类型就变成了原来的curried函数的类型。</p><h1 id="d9b3" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated"><strong class="ak">将所有这些放在一起… </strong></h1><p id="c597" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">现在让我们将这些类型应用到我们的curry函数中:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="1b3d" class="li iw hi kz b fi lj lk l ll lm">function curry&lt;<br/>  FN extends (…args: any[]) =&gt; any,<br/>  STARTING_ARGS extends PartialParameters&lt;FN&gt;<br/>&gt;(targetFn: FN, …existingArgs: STARTING_ARGS):<br/>  CurriedFunction&lt;STARTING_ARGS, FN&gt;<br/>{<br/>  return function(…args) {<br/>    const totalArgs = [...existingArgs, ...args]<br/>    if(totalArgs.length &gt;= targetFn.length) {<br/>      return targetFn(...totalArgs)<br/>    }<br/>    return curry(targetFn, ...totalArgs as PartialParameters&lt;FN&gt;)<br/>  }<br/>}</span></pre><p id="437b" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">我们给了它两个泛型类型，第一个是第一个参数中提供的函数的类型，第二个是已经提供的参数的类型。</p><p id="7a63" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">与上面的泛型类型<code class="du kw kx ky kz b">NEW_ARGS</code>一样，我们将这两种类型都指定为泛型类型，这样我们就可以捕获关于它们的更详细的信息。</p><p id="ad6e" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">如果我们简单地放入<code class="du kw kx ky kz b">(targetFn: (...args: any[]) =&gt; any, ...existingArgs: PartialParameters&lt;FN&gt;)</code>，那么我们将不得不以最通用的格式使用这些类型。我们无法判断参数的类型或函数的返回类型，也无法准确判断前面提供了哪些参数。</p><p id="d7e1" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">通过将函数的返回类型指定为<code class="du kw kx ky kz b">CurriedFunction</code>，我们还向编译器提供了关于内部函数的返回类型和参数的信息，这使我们不必重复自己的工作。</p><p id="90f8" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">打字的唯一问题是我们必须将<code class="du kw kx ky kz b">totalArgs</code>转换成<code class="du kw kx ky kz b">PartialParameters&lt;FN&gt;</code>。我们知道这是对的，但编译器不知道。我们可以构建另一种类型来帮助编译器。但这不值得努力。</p><p id="d5fc" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">现在剩下的就是尝试一下了:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="31d6" class="li iw hi kz b fi lj lk l ll lm">function buildString(a: number, b: string, c: boolean): string {<br/>  return `The ${a.toString(36)} ${b} ${c ? "truth" : "lie"}!`<br/>}</span><span id="b8bf" class="li iw hi kz b fi mc lk l ll lm">const curried = curry(buildString)<br/>// const curried: CurriedFunction&lt;<br/>//   [],<br/>//   (a: number, b: string, c: boolean) =&gt; string<br/>// &gt;</span><span id="0a1e" class="li iw hi kz b fi mc lk l ll lm">const invalid = curried("not a number")<br/>// Argument of type 'string' is not assignable<br/>// to parameter of type 'number'.ts(2345)</span><span id="a445" class="li iw hi kz b fi mc lk l ll lm">const invalid2 = curried(123)({not: "a string"})<br/>// Argument of type '{ not: string; }' is not assignable<br/>// to parameter of type 'string'.ts(2345)</span><span id="45e1" class="li iw hi kz b fi mc lk l ll lm">const partway = curried(573566, "is a")<br/>const result = partway(false)<br/>// const result: string</span><span id="f972" class="li iw hi kz b fi mc lk l ll lm">console.log(result) <br/>// Yes, I really did make that outdated a reference</span></pre><p id="7fee" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">就这样了。感谢阅读！希望这对你有所帮助。有时，为了让TypeScript能够很好地工作，您必须跨越许多障碍，但是在以前没有验证的地方添加验证的能力非常有用。</p><p id="9282" class="pw-post-body-paragraph jt ju hi jv b jw kr jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kv ko kp kq hb bi translated">你会做什么不同的事吗？留言评论！这是我第一次写这样的指南，所以总是欢迎反馈。</p></div></div>    
</body>
</html>