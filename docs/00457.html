<html>
<head>
<title>Predicting Customer’s Next Purchase Using Predictive Modeling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用预测模型预测客户的下一次购买</h1>
<blockquote>原文：<a href="https://medium.com/codex/predicting-customers-next-purchase-b3dd1890924e?source=collection_archive---------0-----------------------#2021-02-07">https://medium.com/codex/predicting-customers-next-purchase-b3dd1890924e?source=collection_archive---------0-----------------------#2021-02-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4709" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">电子商务公司总是把GMV作为他们的北极星指标之一，但是GMV真的那么重要吗？</p><p id="8499" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，GMV很重要，因为它显示了平台上销售的商品的总销售额，但公司一直在大量使用这一指标，通过设定疯狂的内部GMV目标来与市场上的其他参与者竞争。在一家风险投资公司工作过之后，我看到很多初创公司的估值都是基于他们的GMV，GMV已经成为他们的主要衡量标准。</p><p id="0c77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能会问，目标定的高不好吗？竞争难道不会鼓励公司取得更多成就，从而帮助他们发挥最大潜力吗？是的，确实如此。然而，GMV在几个方面可能会误导人，并有可能将公司的目标和资源转移到不想要的方向，从而导致结果。</p><p id="5d61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，GMV不考虑取消、退货、返现和折扣。第二，如果只看GMV，企业将无法了解顾客重复购买的次数，以及每笔订单的平均价值。这些问题将导致另一个问题:该公司没有考虑到有多少钱实际进入其银行账户。</p><p id="7143" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">综上所述，本文将讨论我们如何发现客户购买行为的模式，并使用这些数据来预测客户下一次使用Python的购买行为。</p><h1 id="992a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">数据</strong></h1><p id="ca11" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">该数据集是关于英国的一家零售公司的，是从Kaggle获得的。</p><h1 id="4d79" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">1.度量探索</h1><p id="601f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在构建预测模型之前，我们要探索的指标有:</p><ol class=""><li id="666a" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">月收入和月增长率</li><li id="075e" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">活跃客户数量和每个客户的订单数量</li><li id="105b" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">每个订单的月平均收入</li><li id="c2e3" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">每月客户保持率</li></ol><p id="95cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过导入所有需要的库，让我们先看看我们的数据集是什么样子的。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="98b5" class="ld je hi kz b fi le lf l lg lh">import pandas as pd<br/>from datetime import datetime, timedelta<br/>%matplotlib inline<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>import seaborn as sns<br/>from __future__ import division</span><span id="6781" class="ld je hi kz b fi li lf l lg lh">import chart_studio.plotly as py<br/>import plotly.offline as pyoff<br/>import plotly.graph_objs as go</span><span id="c7c9" class="ld je hi kz b fi li lf l lg lh">pyoff.init_notebook_mode()</span><span id="25a5" class="ld je hi kz b fi li lf l lg lh">df = pd.read_csv(“OnlineRetail.csv”)<br/>df.head(14)</span></pre><p id="cf57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码产生了下面的表1.1。</p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lj"><img src="../Images/6566e344d16b9c16b6873d8f8e44713d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J06lzoclBm_F34uplkDOUw.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">表1.1</figcaption></figure><p id="a759" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上表中，我们获得了了解业务进展所需的所有重要信息，并利用我们拥有的组件构建了北极星方程式。</p><p id="6793" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们先来探究一下公司的月营收。</p><p id="e739" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将首先通过将“InvoiceDate”列转换为pandas的datetime格式来清理数据。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ced9" class="ld je hi kz b fi le lf l lg lh">df[‘InvoiceDate’] = pd.to_datetime(df[‘InvoiceDate’])</span><span id="71d1" class="ld je hi kz b fi li lf l lg lh">df[‘InvoiceYear’] = [d.date() for d in df[‘InvoiceDate’]]</span></pre><p id="a47e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，为了便于以后的分析和可视化，我们将从“InvoiceDate”列中创建一个仅包含月份和年份的新列。结果见表1.2。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="329e" class="ld je hi kz b fi le lf l lg lh">df[‘Month’]=df[‘InvoiceDate’].dt.strftime(‘%Y-%m’)</span><span id="b983" class="ld je hi kz b fi li lf l lg lh">df.head()</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lv"><img src="../Images/f643eaa4a63b8e76ec3c2b7ef80c142f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-LzwrrTHqTsnas09mLej_g.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">表1.2</figcaption></figure><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b8d9" class="ld je hi kz b fi le lf l lg lh">df[‘Revenue’] = df[‘UnitPrice’]*df[‘Quantity’]<br/>df_Revenue = df.groupby([‘Month’])[‘Revenue’].sum().reset_index()</span><span id="f7e7" class="ld je hi kz b fi li lf l lg lh">fig_revenue = px.line(df_Revenue, x =”Month”, y=”Revenue”, title=”Revenue By Month”,color_discrete_sequence=px.colors.qualitative.Pastel1)<br/>fig_revenue.show()</span></pre><p id="2d8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码让我们可以通过图表看到公司的收入——如下图所示。</p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lw"><img src="../Images/8ca222323d5a21d4153cfdd0ab5d20cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n3EmR_6ga82PavOWtqJzbw.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">图1.1</figcaption></figure><p id="b46d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该图清楚地告诉我们，从2011年8月开始，销售额一直在增长(从11月到2011年12月的销售额下降是由于数据不完整)。</p><h2 id="390d" class="ld je hi bd jf lx ly lz jj ma mb mc jn iq md me jr iu mf mg jv iy mh mi jz mj bi translated">1.1活跃客户</h2><p id="c35b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">为了了解企业的经营状况并在以后建立预测模型，我们需要了解公司的新客户和现有客户。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="e936" class="ld je hi kz b fi le lf l lg lh">df = df.query(“Country==’United Kingdom’”)</span><span id="94fe" class="ld je hi kz b fi li lf l lg lh">df_uk_active_cust = df.groupby(‘Month’)[‘CustomerID’].nunique().reset_index()</span><span id="1976" class="ld je hi kz b fi li lf l lg lh">fig_active_cust = px.bar(df_uk_active_cust, x=”Month”,y=”CustomerID”,color_discrete_sequence=px.colors.qualitative.Pastel1)<br/>fig_active_cust.show()</span></pre><p id="f453" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码块首先对dataframe进行排序，并且只显示在“Country”列中带有“United Kingdom”的行。然后，我们创建另一个数据框架，只显示活跃客户的数量，按月份分组——图1。</p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mk"><img src="../Images/549ce1dd7818962e58e9c99fc674b483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_86YYT_oJeqA2pEyye_Ncw.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">图1.2</figcaption></figure><h2 id="1486" class="ld je hi bd jf lx ly lz jj ma mb mc jn iq md me jr iu mf mg jv iy mh mi jz mj bi translated">1.2每份订单的数量和平均收入</h2><p id="ba58" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">上面的代码可以用来计算每月订单的数量和每个订单的平均收入。下图1.3显示了每月售出的数量，而图1.4显示了每份订单的平均收入。</p><p id="a68a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完整代码可以看<a class="ae ml" href="https://github.com/fistz24/ecommerce_analysis" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mm"><img src="../Images/4fcea888695f6d3c2666729df2296226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2sWxwCffZY-UXDPNs3g7qw.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">图1.3</figcaption></figure><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mn"><img src="../Images/b8df729f2d921c770ad3bdbe8811dfe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQJ_MWp0K45w_m3Jm7melA.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">图1.4</figcaption></figure><h2 id="40b0" class="ld je hi bd jf lx ly lz jj ma mb mc jn iq md me jr iu mf mg jv iy mh mi jz mj bi translated">1.3新客户</h2><p id="b2bc" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">每个公司都需要定义谁可以被视为新客户。在我们的例子中，我们将新客户定义为以前从未购买过产品的客户，并从月初开始购买。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c5cb" class="ld je hi kz b fi le lf l lg lh">cust_min_purchase = df.groupby(‘CustomerID’).InvoiceDate.min().reset_index()<br/>cust_min_purchase.columns =[‘CustomerID’,’MinPurchaseDate’]<br/>cust_min_purchase[‘MinPurchaseYearMonth’]=cust_min_purchase[‘MinPurchaseDate’].map(lambda date:100* date.year + date.month)</span><span id="005f" class="ld je hi kz b fi li lf l lg lh">df_uk = pd.merge(df, cust_min_purchase, on=’CustomerID’)</span><span id="7784" class="ld je hi kz b fi li lf l lg lh">df_uk[‘Year’]=df_uk[‘InvoiceDate_x’].dt.strftime(‘%Y-%m-%d’)</span><span id="132d" class="ld je hi kz b fi li lf l lg lh">df_uk[‘InvoiceYearMonth’]= df_uk[‘InvoiceDate’].map(lambda date:100* date.year + date.month)</span><span id="a601" class="ld je hi kz b fi li lf l lg lh">df_uk[‘UserType’] =’New’<br/>df_uk.loc[df_uk[‘InvoiceYearMonth’]&gt;df_uk[‘MinPurchaseYearMonth’],’UserType’]=’Existing’</span><span id="3592" class="ld je hi kz b fi li lf l lg lh">df_user_type_revenue = df_uk.groupby([‘InvoiceYearMonth’,’UserType’,’Month’])[‘Revenue’].sum().reset_index()</span><span id="ac36" class="ld je hi kz b fi li lf l lg lh">df_user_type_revenue</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div class="er es mo"><img src="../Images/442776ed8bd8dfc8b447c4090de67310.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*DpkjM9nmfiPo99xUQTi-ng.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">表1.3</figcaption></figure><p id="f837" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的代码中，我们得到了不同客户类别的收入数；新的和现有的。这将使我们对如何最大化营销预算和努力有一个更清晰的想法。</p><p id="c18c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使表格易于理解，让我们创建一个散点图。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="08db" class="ld je hi kz b fi le lf l lg lh">fig_user_type_revenue = px.scatter(df_user_type_revenue, x=”Month”,y=”Revenue”, color=”UserType”,color_discrete_sequence=px.colors.qualitative.Pastel1)<br/>fig_user_type_revenue.show()</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mp"><img src="../Images/673b7fac153e503a9a8d5ac4ac4ad138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JkLPQcbCuAXyTrlbhL9NfQ.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">图1.5</figcaption></figure><p id="0a6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的图5告诉我们，现有客户显示出积极的趋势，这间接转化为强大的客户群，尽管新客户呈下降趋势。</p><h2 id="31dc" class="ld je hi bd jf lx ly lz jj ma mb mc jn iq md me jr iu mf mg jv iy mh mi jz mj bi translated">1.4保留率</h2><p id="e84a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">df _ user _ purchase = df _ uk . group by([' CustomerID '，' Month'])['Revenue']。sum()。重置索引()</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="8efe" class="ld je hi kz b fi le lf l lg lh">#retention matrix<br/>df_retention = pd.crosstab(df_user_purchase[‘CustomerID’],df_user_purchase[‘Month’]).reset_index()<br/>df_retention.head()</span><span id="b121" class="ld je hi kz b fi li lf l lg lh">months = df_retention.columns[2:]<br/>retention_array=[]<br/>for i in range(len(months)-1):<br/> retention_data={}<br/> selected_month = months[i+1]<br/> prev_month= months[i]<br/> retention_data[‘Month’] = (selected_month)<br/> retention_data[‘TotalUserCount’] = df_retention[selected_month].sum()<br/> retention_data[‘RetainedUserCount’]= df_retention[(df_retention[selected_month]&gt;0)&amp; (df_retention[prev_month]&gt;0)][selected_month].sum()<br/> retention_array.append(retention_data)</span><span id="86be" class="ld je hi kz b fi li lf l lg lh">df_retention = pd.DataFrame(retention_array)<br/>df_retention[‘RetentionRate’] = df_retention[‘RetainedUserCount’]/df_retention[‘TotalUserCount’]</span><span id="2e5e" class="ld je hi kz b fi li lf l lg lh">fig_retained_user = px.line(df_retention, x=”Month”,y=”RetentionRate”,color_discrete_sequence=px.colors.qualitative.Pastel1)<br/>fig_retained_user.show()</span></pre><p id="854c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从6月到2011年8月，留存率呈指数增长，然后在2011年9月再次下降，如图1.6所示。</p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mq"><img src="../Images/57ebf0878fb29cc990ae8d4387998dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_hxHXpnjabskfplOXufRg.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">图1.6</figcaption></figure><h1 id="4851" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">2.客户细分</h1><p id="203b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在分析了电子商务公司的主要指标后，我们现在可以进行客户细分，以了解谁是最好的客户。</p><p id="55c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为什么我们需要客户细分？</p><p id="7244" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有客户都有不同的行为、特征和需求。因此，我们不能以同样的方式对待他们，如果我们以同样的方式对待他们，他们最终会找到其他选择。</p><p id="7e65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有几种客户细分方法，但我们将讨论最广泛使用的一种:RFM(最近，频率，货币)。我们将根据这三个细分市场划分客户:</p><ol class=""><li id="86b7" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">低价值:不太活跃的客户——很少购买和产生低收入的客户</li><li id="81e7" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">中等价值:那些频繁使用平台并产生中等收入的人</li><li id="053f" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">高价值:非常活跃的客户，他们消费非常频繁，比其他任何客户都多</li></ol><h2 id="4018" class="ld je hi bd jf lx ly lz jj ma mb mc jn iq md me jr iu mf mg jv iy mh mi jz mj bi translated">2.1最近</h2><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="358e" class="ld je hi kz b fi le lf l lg lh">To calculate recency, we’ll first sort the dataframe and find the most recent purchase date of each customer. </span><span id="5bdf" class="ld je hi kz b fi li lf l lg lh">df_user = pd.DataFrame(df[‘CustomerID’].unique())<br/>df_user.columns = [‘CustomerID’]</span><span id="3e09" class="ld je hi kz b fi li lf l lg lh">df_max_purchase= df_uk.groupby(‘CustomerID’).InvoiceDate.max().reset_index()<br/>df_max_purchase.columns=[‘CustomerID’,’MaxPurchaseDate’]</span><span id="4940" class="ld je hi kz b fi li lf l lg lh">df_max_purchase[‘Recency’] = (df_max_purchase[‘MaxPurchaseDate’].max() — df_max_purchase[‘MaxPurchaseDate’]).dt.days</span><span id="b0b9" class="ld je hi kz b fi li lf l lg lh">df_user = pd.merge(df_user, df_max_purchase[[‘CustomerID’,’Recency’]], on=’CustomerID’)</span><span id="74a7" class="ld je hi kz b fi li lf l lg lh">df_user.head()</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div class="er es mr"><img src="../Images/86050d929e3a7a1a5b6d087cf98b3dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*3lxZ4RJcVwRemHFS2ph_Fw.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">表2.1</figcaption></figure><p id="06f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码中包含的步骤有:</p><ol class=""><li id="74b8" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">创建一个df来保存customerID和细分分数</li><li id="1d2c" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">使用<strong class="ih hj"> max() </strong>函数获取每个客户的最大购买日期</li><li id="b48d" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">通过从df中的每一行减去<strong class="ih hj"> max() </strong>购买日期来计算最近日期，并使用<strong class="ih hj"> dt.days </strong>函数来获得天数</li></ol><p id="e59e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">表2.1显示了5行代码结果。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="454e" class="ld je hi kz b fi le lf l lg lh">fig_recency = px.histogram(df_user, x=”Recency”,color_discrete_sequence=px.colors.qualitative.Pastel1)<br/>fig_recency.show()</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es ms"><img src="../Images/fa61424cff1bc6b163e138925f6c1d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rBh5KxxWJ80w1M5T14tH5A.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">图2.1</figcaption></figure><p id="b42c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图2.1显示了最近的分布。</p><p id="a3e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了分配最近得分，我们将使用KMeans聚类。但是在此之前，与其他KMeans项目一样，我们需要知道我们需要多少个集群。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b6e6" class="ld je hi kz b fi le lf l lg lh">from sklearn.cluster import KMeans</span><span id="b49a" class="ld je hi kz b fi li lf l lg lh">sse ={}<br/>df_recency=df_user[[‘Recency’]]<br/>for k in range(1,10):<br/> kmeans=KMeans(n_clusters=k, max_iter=1000).fit(df_recency)<br/> df_recency[“clusters”] =kmeans.labels_<br/> sse[k] = kmeans.inertia_<br/> <br/>plt.figure()<br/>plt.plot(list(sse.keys()),list(sse.values()), color=”#FF7F50")<br/>plt.xlabel(“Number of Cluster”)<br/>plt.show()</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div class="er es mt"><img src="../Images/e7f82f067cc1669e895aca33c369e199.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*ZYmfclV5rxxzHCR-vB5W-A.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">图2.2</figcaption></figure><p id="fbfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从图2.2中，我们可以得出结论，3个集群就足够了，但我们将使用4个。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="01c3" class="ld je hi kz b fi le lf l lg lh">kmeans=KMeans(n_clusters=4)<br/>kmeans.fit(df_user[[‘Recency’]])<br/>df_user[‘RecencyCluster’] =kmeans.predict(df_user[[‘Recency’]])</span><span id="0753" class="ld je hi kz b fi li lf l lg lh">def cluster_order(cluster_name, target_name, df, ascending):<br/> new_cluster_field_name = ‘new_’ + cluster_name<br/> df_new = df.groupby(cluster_name)[target_name].mean().reset_index()<br/> df_new[‘index’] = df_new.index<br/> df_final = pd.merge(df, df_new[[cluster_name,’index’]],on=cluster_name)<br/> df_final = df_final.drop([cluster_name],axis=1)<br/> df_final = df_final.rename(columns={“index”:cluster_name})<br/> return df_final</span><span id="d6bb" class="ld je hi kz b fi li lf l lg lh">df_user = cluster_order(‘RecencyCluster’,’Recency’,df_user, False)</span><span id="c179" class="ld je hi kz b fi li lf l lg lh">df_user.groupby(‘RecencyCluster’)[‘Recency’].describe()</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div class="er es mu"><img src="../Images/f85dd8ead5e9ad4e4cb9f1a33c37d2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*xF9PltLzvJhNv0E9xgd-IA.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">表2.2</figcaption></figure><p id="6f70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先为最近建立了4个集群，并将其添加到现有的df中。然后我们定义一个函数，让我们对最近的聚类进行升序排序。</p><h2 id="e4cc" class="ld je hi bd jf lx ly lz jj ma mb mc jn iq md me jr iu mf mg jv iy mh mi jz mj bi translated">2.2频率</h2><p id="1e34" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">相同的原理将用于频率。我不会在本文中展示完整的代码，但是您可以在这里找到关于代码<a class="ae ml" href="https://github.com/fistz24/ecommerce_analysis" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="335a" class="ld je hi kz b fi le lf l lg lh">kmeans = KMeans(n_clusters=4)<br/>kmeans.fit(df_user[[‘Frequency’]])<br/>df_user[‘FrequencyCluster’]= kmeans.predict(df_user[[‘Frequency’]])</span><span id="5b13" class="ld je hi kz b fi li lf l lg lh">df_user = cluster_order(‘FrequencyCluster’,’Frequency’,df_user,True)</span><span id="cc32" class="ld je hi kz b fi li lf l lg lh">df_user.groupby(‘FrequencyCluster’)[‘Frequency’].describe()</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div class="er es mv"><img src="../Images/5ecd07de04dc9f7d6f6de64f554b635b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*HxIIfYquo7Puzn2gRGkQbA.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">表2.3</figcaption></figure><p id="99bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">高频意味着高价值客户。</p><h2 id="6183" class="ld je hi bd jf lx ly lz jj ma mb mc jn iq md me jr iu mf mg jv iy mh mi jz mj bi translated">2.3收入</h2><p id="963f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们将计算每个客户的总收入，并应用kmeans聚类对收入进行聚类。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="aafd" class="ld je hi kz b fi le lf l lg lh">df_uk[‘Revenue’]=df_uk[‘UnitPrice’] * df_uk[‘Quantity’]<br/>df_revenue=df_uk.groupby(‘CustomerID’).Revenue.sum().reset_index()</span><span id="24f6" class="ld je hi kz b fi li lf l lg lh">df_user = pd.merge(df_user, df_revenue, on=”CustomerID”)</span><span id="bfcb" class="ld je hi kz b fi li lf l lg lh">kmeans = KMeans(n_clusters=4)<br/>kmeans.fit(df_user[[‘Revenue’]])<br/>df_user[‘RevenueCluster’]=kmeans.predict(df_user[[‘Revenue’]])</span><span id="37b7" class="ld je hi kz b fi li lf l lg lh">df_user = cluster_order(‘RevenueCluster’,’Revenue’, df_user, True)</span><span id="713a" class="ld je hi kz b fi li lf l lg lh">df_user.groupby(‘RevenueCluster’)[‘Revenue’].describe()</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div class="er es mw"><img src="../Images/a2762ae6142f7c2708d00e434ce506b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*9AlWweTWurs8Ji-PXk1oZA.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">表2.4</figcaption></figure><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mx"><img src="../Images/9e1868756dbeb338d905eb61e6a5f2c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOL-0eU-gip650_8caozKA.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">表2.5</figcaption></figure><h2 id="a5ae" class="ld je hi bd jf lx ly lz jj ma mb mc jn iq md me jr iu mf mg jv iy mh mi jz mj bi translated">2.4总体得分</h2><p id="02b4" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们现在需要合并最近，频率和收入df，以获得总得分。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="ac57" class="ld je hi kz b fi le lf l lg lh">df_user[‘OverallScore’] = df_user[‘RecencyCluster’] + df_user[‘FrequencyCluster’] + df_user[‘RevenueCluster’]<br/>df_user.groupby(‘OverallScore’)[‘Recency’,’Frequency’,’Revenue’].mean().reset_index()</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div class="er es my"><img src="../Images/b57005ee576711848c7446ddafb3899f.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*K0kcDtdGoO7p_Q1H2dWUgg.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">表2.6</figcaption></figure><p id="a762" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的评分告诉我们，9分是我们最好的客户。但是如前所述，我们可以将它们分为3类。因此，我们将重新命名分数:</p><ol class=""><li id="ef5c" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">0–2:低值</li><li id="c075" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">3–6:中间值</li><li id="4ed9" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">7–9:高价值</li></ol><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="270e" class="ld je hi kz b fi le lf l lg lh">df_user[‘Segment’] = ‘Low-Value’<br/>df_user.loc[df_user[‘OverallScore’]&gt;2,’Segment’] = ‘Mid-Value’ df_user.loc[df_user[‘OverallScore’]&gt;6,’Segment’] = ‘High-Value’</span><span id="6f29" class="ld je hi kz b fi li lf l lg lh">df_user_graph = df_user.query(“Revenue &lt; 50000 and Frequency &lt; 2000”)</span><span id="0213" class="ld je hi kz b fi li lf l lg lh">fig_score= px.scatter(df_user_graph, x=”Frequency”, y=”Revenue”,color=”Segment”)<br/>fig_score.show()</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mz"><img src="../Images/2b225be465cb72eed124cc887f10544b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9l6_5LOH193Y3DisWUsKw.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">图2.3</figcaption></figure><p id="47ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图2.3显示了每个客户群的分布，如图所示，与其他两个客户群相比，中等价值客户购买最多，带来的收入也最多。</p><p id="c1f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在进入最后一步(但不是最后一步)，预测客户的下一次购买。</p><h1 id="3c8e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">3.预测客户的下一次购买</h1><h2 id="60f0" class="ld je hi bd jf lx ly lz jj ma mb mc jn iq md me jr iu mf mg jv iy mh mi jz mj bi translated">3.1数据争论</h2><p id="6f30" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">为了构建模型，我们将使用6个月的数据来预测未来3个月的客户行为。</p><p id="2e66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将首先创建一个新的数据帧，以免弄乱原始数据。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="77c9" class="ld je hi kz b fi le lf l lg lh">df_order_day= df_6m[[‘CustomerID’,’InvoiceDate’]]</span><span id="c162" class="ld je hi kz b fi li lf l lg lh">df_order_day = df_order_day.sort_values([‘CustomerID’,’InvoiceDate’])</span><span id="29d5" class="ld je hi kz b fi li lf l lg lh">df_order_day[‘InvoiceDay’] = df_6m[‘InvoiceDate’]</span><span id="cef9" class="ld je hi kz b fi li lf l lg lh">df_order_day = df_order_day.drop_duplicates(keep=’first’)</span><span id="e9b0" class="ld je hi kz b fi li lf l lg lh">df_order_day.head()</span></pre><p id="e40e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要找出每个CustomerID的最后3次购买，我们将使用<strong class="ih hj"> shift()来完成这项工作。</strong></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="d73f" class="ld je hi kz b fi le lf l lg lh">df_order_day[‘PrevInvoiceDate’] = df_order_day.groupby(‘CustomerID’)[‘InvoiceDay’].shift(1)<br/>df_order_day[‘D2InvoiceDate’] = df_order_day.groupby(‘CustomerID’)[‘InvoiceDay’].shift(2)<br/>df_order_day[‘D3InvoiceDate’] = df_order_day.groupby(‘CustomerID’)[‘InvoiceDay’].shift(3)</span><span id="0aab" class="ld je hi kz b fi li lf l lg lh">df_order_day[‘DayDiff’] = (df_order_day[‘InvoiceDay’]-df_order_day[‘PrevInvoiceDate’]).dt.days<br/>df_order_day[‘DayDiff2’] = (df_order_day[‘InvoiceDay’]-df_order_day[‘D2InvoiceDate’]).dt.days<br/>df_order_day[‘DayDiff3’] = (df_order_day[‘InvoiceDay’]-df_order_day[‘D3InvoiceDate’]).dt.days</span><span id="3688" class="ld je hi kz b fi li lf l lg lh">df_order_day.head()</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es na"><img src="../Images/3000f6894899c28f6e527196d471ae76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EjNjpWKoyH3pPscciJXVkg.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">表3.1</figcaption></figure><p id="558b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">表3.1显示了新数据帧df_order_day的前5行。正如所见，有些客户只购买了0-2次，这导致了大量的NaN值。这将在以后破坏我们的模型，所以我们将只保留购买超过3次的客户，使用下面的代码。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="a3d4" class="ld je hi kz b fi le lf l lg lh">df_order_day_last = df_order_day.drop_duplicates(subset=[‘CustomerID’],keep=’last’)</span><span id="7b13" class="ld je hi kz b fi li lf l lg lh">df_order_day_last = df_order_day_last.dropna()</span><span id="1df4" class="ld je hi kz b fi li lf l lg lh">df_order_day_last = pd.merge(df_order_day_last, df_day_diff, on=’CustomerID’)</span><span id="52cc" class="ld je hi kz b fi li lf l lg lh">df_user = pd.merge(df_user, df_order_day_last[[‘CustomerID’,’DayDiff’,’DayDiff2',’DayDiff3',’DayDiffMean’,’DayDiffStd’]],on=’CustomerID’)</span><span id="d015" class="ld je hi kz b fi li lf l lg lh">df_class =df_user.copy()<br/>df_class = pd.get_dummies(df_class)<br/>df_class.head()</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es nb"><img src="../Images/9f2a7eeb65d03b0be910603d4ab247e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LGlLRBAbv5EW3StMfm1_Vg.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">表3.2</figcaption></figure><h1 id="b420" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">4.构建模型</h1><p id="5c4d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在建立模型之前，让我们先来看看df的百分位数。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5ef8" class="ld je hi kz b fi le lf l lg lh">df_user.DateInterval.describe()</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div class="er es mr"><img src="../Images/0d675ca9d656ee1857a7a8579ad3997b.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*GnKSIILt7JkbwTYWMWjzPg.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">图1.1</figcaption></figure><h2 id="c259" class="ld je hi bd jf lx ly lz jj ma mb mc jn iq md me jr iu mf mg jv iy mh mi jz mj bi translated">4.1客户购买日课程</h2><p id="4ce0" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">为了有效地开展营销活动，我们需要锁定有可能再次购买的正确客户。为此，我们将客户分为三类:</p><ol class=""><li id="dfef" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">第0类:将在50天以上再次购买的客户</li><li id="a21c" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">第1类:将在21–49天内再次购买的客户</li><li id="7cf5" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">第2类:将在0-20天内再次购买的客户</li></ol><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="0670" class="ld je hi kz b fi le lf l lg lh">df_class[‘DateIntervalRange’]=2<br/>df_class.loc[df_class.DateInterval&gt;20, ‘DateIntervalRange’]=1<br/>df_class.loc[df_class.DateInterval&gt;50, ‘DateIntervalRange’]=0</span></pre><p id="f32a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码让我们得到了表3.3</p><figure class="ku kv kw kx fd lk er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es nc"><img src="../Images/2f7746fd0b6473e6ed0dea2f58735efc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PxOI0_Q-8KIz9xL7lK_IPA.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">表3.3</figcaption></figure><h2 id="37ab" class="ld je hi bd jf lx ly lz jj ma mb mc jn iq md me jr iu mf mg jv iy mh mi jz mj bi translated">4.2相关矩阵</h2><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="089f" class="ld je hi kz b fi le lf l lg lh">corr = df_class[df_class.columns].corr()<br/>plt.figure(figsize = (30,20))<br/>sns.heatmap(corr, annot=True, linewidth=0.2)</span></pre><figure class="ku kv kw kx fd lk er es paragraph-image"><div class="er es nd"><img src="../Images/06d18311061c6a6d2dd236263ef79643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*9YO12iKJzu8F4Aim2FtaUA.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx translated">图1.2</figcaption></figure><p id="fbc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该矩阵显示“总体得分”具有最高的正相关性，而新近性具有最低的(负)相关性。</p><h2 id="a9c9" class="ld je hi bd jf lx ly lz jj ma mb mc jn iq md me jr iu mf mg jv iy mh mi jz mj bi translated">4.3模型</h2><p id="d8d0" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们将使用多分类模型并调整超参数。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="817d" class="ld je hi kz b fi le lf l lg lh">df_class = df_class.drop(‘DateInterval’,axis=1)<br/>X,y = df_class.drop(‘DateIntervalRange’,axis=1),df_class.DateIntervalRange</span><span id="21c0" class="ld je hi kz b fi li lf l lg lh">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=40)</span><span id="98cd" class="ld je hi kz b fi li lf l lg lh">xgb_model = xgb.XGBClassifier().fit(X_train, y_train)</span><span id="e44e" class="ld je hi kz b fi li lf l lg lh">xgb_model.score(X_train, y_train)</span><span id="250b" class="ld je hi kz b fi li lf l lg lh">xgb_model.score(X_test[X_train.columns], y_test)</span></pre><p id="3904" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的训练集的精度是0.86，而我们的测试集的精度是0.52。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="d9b7" class="ld je hi kz b fi le lf l lg lh">param_test1 = {<br/> ‘max_depth’:range(3,10,2),<br/> ‘min_child_weight’:range(1,6,2)<br/>}<br/>gsearch1 = GridSearchCV(estimator = xgb.XGBClassifier(), <br/>param_grid = param_test1, scoring=’accuracy’,n_jobs=-1,cv=2)<br/>gsearch1.fit(X_train,y_train)<br/>gsearch1.best_params_, gsearch1.best_score_</span></pre><p id="7df1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将看看上面的准确性是否可以提高，根据上面的代码，max_dept和min_child_weight的最佳值分别是5和3。让我们测试一下它是否能提高我们模型的准确性。</p><figure class="ku kv kw kx fd lk er es paragraph-image"><div class="er es ne"><img src="../Images/69da70b608c8d1f8bde85678a82a6c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*53UcX9MntCDLPMSUF4Z4eg.png"/></div></figure><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="93d9" class="ld je hi kz b fi le lf l lg lh">xgb_model = xgb.XGBClassifier(max_depth=5, min_child_weight=3).fit(X_train, y_train)<br/>xgb_model.score(X_train, y_train)</span><span id="c819" class="ld je hi kz b fi li lf l lg lh">xgb_model.score(X_test[X_train.columns], y_test)</span></pre><p id="5bab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">新的参数确实改善了训练模型，但对测试模型没有影响，训练模型改善到0.9678，而测试模型保持在0.52。</p></div></div>    
</body>
</html>