<html>
<head>
<title>Kicking the Redux Habit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戒掉重复的习惯</h1>
<blockquote>原文：<a href="https://medium.com/codex/dumping-redux-wasnt-so-hard-578a0e0bf946?source=collection_archive---------14-----------------------#2021-08-08">https://medium.com/codex/dumping-redux-wasnt-so-hard-578a0e0bf946?source=collection_archive---------14-----------------------#2021-08-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5aebcac799ef43c5518f75dc380825c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zAL3rsYPeuvR5jTNzRWz9g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">经典冗余状态变化传播</figcaption></figure><p id="eef1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我喜欢Redux隔离的业务逻辑和可预测的变更传播模式，但是样板文件看起来像是纯粹的开销。Redux Toolkit有所帮助，但复杂性仍然存在。为什么在React应用中干净地管理状态会如此困难？</p><p id="f71e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">并没有。</p><p id="8d68" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">直觉上，所有这些间接的层次似乎都是不必要的，但是只有一种方法可以证明这一点——突然戒除法！最后，很容易用更简单的东西替换Redux。</p><h1 id="b838" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">两个箭头功能</h1><p id="42b5" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">绑定到状态和启动对状态的更改只需要两个箭头函数就可以实现:一个选择器和一个编辑器。我将使用经典的计数器应用程序作为说明。</p><p id="b5e9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">选择器看起来像这样…</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="ffc9" class="le jt hi la b fi lf lg l lh li">(state) =&gt; state.counter</span></pre><p id="6cf3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个编辑长这样…</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="3b90" class="le jt hi la b fi lf lg l lh li">(draft) =&gt; (draft.counter += 1)</span></pre><p id="419a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用这些函数，您可以使用一个简单的javascript对象绑定状态、触发和跟踪更改。</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="d9f1" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">一个最小的例子</h1><p id="620e" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">上面的编辑器和选择器函数来自一个示例Javascript <a class="ae ll" href="https://codesandbox.io/s/github/cefn/lauf/tree/main/apps/counter-js" rel="noopener ugc nofollow" target="_blank">计数器应用</a>(参见Typescript 中的等效<a class="ae ll" href="https://codesandbox.io/s/github/cefn/lauf/tree/main/apps/counter" rel="noopener ugc nofollow" target="_blank">版本)。</a></p><p id="45a5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在示例应用程序中，编辑器在业务逻辑模块中定义，并由ui事件调用。</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lm lk l"/></div></figure><p id="6e51" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">选择器嵌入在每个React组件中，因此很容易跟踪它订阅了应用程序状态的哪一部分…</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lm lk l"/></div></figure><p id="f2fd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在下面的沙盒中查看完整的行为及其来源。</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="ln lk l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">计数器应用程序沙箱</figcaption></figure><p id="7074" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这种彻底的简单性背离了Flux/Redux模型——在该模型中，我们会有一个动作类型、一个结构化的有效载荷定义、一个动作创建器、一个thunk创建器，其结果通过一个调度程序发送，以便(希望)与一个reducer和一些中间件中的相应行为保持一致。</p><p id="9016" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用一个最小的不可变存储，变更传播开始看起来像这样…</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/3a2ee2af60c411f7912be97723ddd52d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*qDUASiobd1YDnRYluvy6jg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">没有动作和Reducer样板文件的更改传播</figcaption></figure><h2 id="60b3" class="le jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">孤立的业务逻辑</h2><p id="2420" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">互联网上充斥着说“你可能不需要Redux”的文章，然后这些文章推荐依靠完全依赖于React原语并与render循环可怕地混合在一起的状态管理。您可能不需要Redux，但是有一些选项。</p><p id="9819" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">编辑器和状态应该独立定义，与React组件分开。这导致完全隔离的、可预测的和可测试的业务逻辑，并确保从React切换到React Native或Vue或Svelte或未来带来的任何事物的自由。</p><p id="7a7d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么，我们如何为不可变状态定义一个容器来连接我们的编辑器和选择器功能呢？</p><h2 id="73cc" class="le jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">快速捷径</h2><p id="3e51" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated"><a class="ae ll" href="https://codesandbox.io/s/github/cefn/lauf/tree/main/apps/counter-js" rel="noopener ugc nofollow" target="_blank">柜台演示</a>使用来自<a class="ae ll" href="https://www.npmjs.com/package/@lauf/store-react" rel="noopener ugc nofollow" target="_blank"> @lauf/store-react </a>的<a class="ae ll" href="https://cefn.com/lauf/api/interfaces/_lauf_store.store.html" rel="noopener ugc nofollow" target="_blank">商店对象</a>。我编写并测试了这个NPM模块来体现所提出的方法，但它只是您可以自己编写的几行代码。</p><p id="1414" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Store只保存一个Javascript对象作为状态，有一个<strong class="iw hj"> <em class="mc"> edit </em> </strong>方法接受编辑器函数来改变状态，并在编辑完成时通知订阅者。<a class="ae ll" href="https://github.com/cefn/lauf/blob/main/modules/store-react/src/index.ts" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj"><em class="mc">use selected</em></strong>React binding</a>只是一个挂钩，用于设置订阅，并过滤与选择器匹配的更改。</p><p id="3fe6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可以按照自己的意愿将存储传递给组件——它包装了一个变化的对象，但它自己的引用永远不会改变。在Counter应用程序中，商店是在父组件中创建的，并传递给props中的子组件。对于深度嵌套的组件，你可能应该使用<a class="ae ll" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React上下文API </a>来传递它。</p><h2 id="7355" class="le jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">具体来说:使用选择的反应钩子</h2><p id="bcb1" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">一个选择器函数被传递给<a class="ae ll" href="https://cefn.com/lauf/api/modules/_lauf_store_react.html#useselected" rel="noopener ugc nofollow" target="_blank"> useSelected钩子</a>来订阅一个遵循这个基本签名的React组件…</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="56e0" class="le jt hi la b fi lf lg l lh li"> const value = useSelected(store, selector)</span></pre><p id="9757" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这将在每次渲染时从存储中检索您选择的值。它还确保无论何时编辑后您选择的值不同，您的React组件都会被<em class="mc">重新渲染</em>(根据<a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" rel="noopener ugc nofollow" target="_blank"> Object.is </a>)。</p><h2 id="af0a" class="le jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">具体来说:商店编辑方法</h2><p id="b303" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在这个基本签名之后，一个编辑器函数被传递给商店的<a class="ae ll" href="https://cefn.com/lauf/api/interfaces/_lauf_store.store.html#edit" rel="noopener ugc nofollow" target="_blank">编辑方法</a></p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="ffde" class="le jt hi la b fi lf lg l lh li">store.edit(editor)</span></pre><p id="05eb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您的编辑器被传递一个状态树的副本来进行编辑。</p><p id="2869" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">就像Redux一样，从不修改原始状态树意味着当状态或状态的一个<a class="ae ll" href="https://cefn.com/lauf/api/modules/_lauf_store.html#selector" rel="noopener ugc nofollow" target="_blank">选择的</a>分支与之前的<strong class="iw hj"> <em class="mc">项</em> </strong>相同时，保证包含所有与之前相同的<strong class="iw hj"> <em class="mc">值</em> </strong>。致力于不变性允许您的业务逻辑、呈现器和记忆器使用“浅层相等检查”。他们可以有效地检查对项目的更改何时应该触发重新渲染或重新计算——只需在<code class="du md me mf la b">Object.is(prevItem,nextItem)===false</code>时。</p><p id="3ac5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了确保不变性，Lauf依赖Redux Toolkit 使用的<a class="ae ll" href="https://immerjs.github.io/immer/" rel="noopener ugc nofollow" target="_blank"> Immer </a>库<a class="ae ll" href="https://redux-toolkit.js.org/usage/immer-reducers" rel="noopener ugc nofollow" target="_blank">。你的编辑是通过一个Immer草案，而不是真正的状态。您可以使用普通的javascript赋值和操作在编辑器函数中操作草稿。当您的函数返回时，Immer编写一个新的不可变状态来与您所做的更改保持一致，重用任何未更改的部分。您可以在编辑器函数中使用常规的javascript语法和数据结构，而不用考虑不变性。</a></p><h2 id="7537" class="le jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">具体来说:变更传播</h2><p id="30bb" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">变化会自动传播。编辑完成后，只有编辑更改了选定值的组件才会触发渲染。</p><p id="1832" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">就是这样！</p><h1 id="d3f3" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">轮到你了</h1><p id="c873" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">请在评论中分享你的想法。我期待着找到这种方法的漏洞:)</p><p id="dbbb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我错过了什么来证明Redux和friends的所有额外层？</p><h1 id="0f02" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">跟进:一个复杂的例子</h1><p id="a42d" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">为了回答这种担心，即这只适用于简单的应用程序，如计数器，下面的Snake应用程序是一个更复杂的例子，它也使用<a class="ae ll" href="https://www.npmjs.com/package/@lauf/store-react" rel="noopener ugc nofollow" target="_blank"> @lauf/store-react </a>作为业务逻辑。</p><p id="1e90" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该应用将游戏状态与动画和输入事件相结合，<a class="ae ll" href="https://github.com/cefn/lauf/blob/main/apps/nextjs-snake/src/logic.ts" rel="noopener ugc nofollow" target="_blank">由多个并发脚本</a>控制。然后使用选择器将生成的动态状态绑定到React UI。</p><p id="b8da" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它使用箭头键来控制方向，但由于其业务逻辑完全隔离，游戏体验可以很容易地移植到触摸屏上基于拖动输入的界面或Javascript运行的任何其他地方。</p><h2 id="d9c1" class="le jt hi bd ju lp lq lr jy ls lt lu kc jf lv lw kg jj lx ly kk jn lz ma ko mb bi translated">详细来说:使用followSelector订阅</h2><p id="4917" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">因此，如果业务逻辑需要对变化的状态做出响应，那么Snake应用程序如何在没有反应的情况下工作呢？</p><p id="e14b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了在没有React <a class="ae ll" href="https://cefn.com/lauf/api/modules/_lauf_store_react.html#useselected" rel="noopener ugc nofollow" target="_blank"> useSelected </a>钩子的情况下监视状态变化，Snake应用程序使用了来自<a class="ae ll" href="https://www.npmjs.com/package/@lauf/store-follow" rel="noopener ugc nofollow" target="_blank"> @lauf/store-follow </a>的便利的<a class="ae ll" href="https://cefn.com/lauf/api/modules/_lauf_store_follow.html#followselector" rel="noopener ugc nofollow" target="_blank"> followSelector </a>方法，该方法没有React依赖项。在下面的摘录中<strong class="iw hj"> <em class="mc"> followSelector </em> </strong>在蛇的头部位置每次改变时调用一个回调。它检查它是否已经与水果碰撞…</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="lm lk l"/></div></figure><p id="4fe5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">点击Snake App播放或拖动分隔符查看源代码。</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="ln lk l"/></div></figure></div></div>    
</body>
</html>