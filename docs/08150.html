<html>
<head>
<title>East-West Communication in Kubernetes — How do services communicate within a cluster?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes中的东西方通信——集群中的服务如何通信？</h1>
<blockquote>原文：<a href="https://medium.com/codex/east-west-communication-in-kubernetes-how-do-services-communicate-within-a-cluster-310e9dc9dd53?source=collection_archive---------0-----------------------#2022-07-20">https://medium.com/codex/east-west-communication-in-kubernetes-how-do-services-communicate-within-a-cluster-310e9dc9dd53?source=collection_archive---------0-----------------------#2022-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f469" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">进一步了解支持服务到服务通信的3个本地k8s对象的动态特性——cluster IP服务、DNS和Kube代理。</h2></div><p id="dceb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我以前的文章“Kubernetes中的南北沟通”中，我写了客户机如何在集群中获得服务。进入集群后，我们现在可以看到后端服务如何在集群内相互通信。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/aabef536ad604209c6513d5ff4c5aa52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TQwtOtTXoae3GkR0UNbSQA.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">概观</figcaption></figure><h2 id="8aa7" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">传统的服务对服务通信</h2><p id="a941" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">在进入Kubernetes生态系统之前，快速浏览一下传统的服务到服务通信<strong class="iz hj"> — </strong>通信通过IP地址进行，因此为了让服务A调用服务B，一种方法是为服务B分配一个静态IP地址。现在，要么服务A已经知道这个IP地址(这在处理非常少量的服务时可能有效)，要么服务B用域名&amp;注册自己。服务A通过DNS查找获得服务B的联系地址。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lk"><img src="../Images/a4550c36023ca37c748e546b5f809ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IeJnII2Tqqg2nM_XZU9GTw.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">传统的服务对服务通信</figcaption></figure><h2 id="cec0" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">Kubernetes网络模型</h2><p id="6b77" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">现在，在Kubernetes集群中，我们有了控制平面，它构成了集群管理组件&amp;一组称为节点的工作机。这些节点托管pod，pod将后端微服务作为容器化服务运行。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ll"><img src="../Images/7c0779f2415df1abc79f7a421fc31997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VnCUxhg0GztFpR6qbf1fpw.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">按照Kubernetes网络模型在集群内部进行点对点通信。</figcaption></figure><p id="aafc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">按照Kubernetes网络模型——</p><ol class=""><li id="0a55" class="lm ln hi iz b ja jb jd je jg lo jk lp jo lq js lr ls lt lu bi translated">群集中的每个pod都有自己唯一的群集范围的IP地址</li><li id="2ebb" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">所有的豆荚都可以和集群内的每个豆荚通话，</li><li id="4be1" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">通信在没有NAT的情况下进行，这意味着目的地pod可以看到源pod的真实IP地址。Kubernetes认为容器网络或在其上运行的应用程序是可信的，不需要网络级别的身份验证。</li></ol><h2 id="822f" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">集群IP服务Pods上的持久抽象</h2><p id="bce2" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">由于群集中的每个pod都有自己的IP地址，因此一个pod与另一个pod对话应该很容易？不，因为pod是不稳定的，每次创建一个pod，它都会获得一个新的IP地址。因此客户服务必须以某种方式切换到下一个可用的pod，这是不希望的。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ma"><img src="../Images/4d479e52ecaca343b1ba49b28ea7b0bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d5m0Aea5xPr2d2DhtrG_YQ.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">Pod之间直接对话的问题在于另一个目的地Pod的短暂性&amp;其次是发现替代的Pod IP地址。</figcaption></figure><p id="e8f2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，Kubernetes可以在一组Pods之上创建一个层，为该组分配一个IP地址，并提供基本的负载平衡。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ma"><img src="../Images/cc9ee6765289302207d2d1c8c7100d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nl61fWAoVE6qcGjYRq5Msw.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">pod通过持久IP地址上的集群IP服务公开，客户端与服务对话，而不是直接与pod对话</figcaption></figure><p id="a79d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个抽象是由Kubernetes中一个名为<strong class="iz hj"> ClusterIP service </strong>的服务对象提供的。它在多个节点上生成，从而在集群中创建一个服务。它可以在任何端口上接收请求，并将其转发到pod上的任何端口。</p><p id="e2c0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，当应用程序服务A需要与服务B对话时，它调用服务B对象的ClusterIP服务，而不是运行该服务的单个pod。</p><p id="694a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ClusterIP使用Kubernetes中标签和选择器的标准模式来扫描符合选择标准的pod。豆荚是有标签的，服务有选择器来寻找标签。利用这一点，有可能进行基本的流量划分，其中新旧版本的微服务共存于同一个clusterIP服务之后。</p><h2 id="321f" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">CoreDNS —集群内的服务发现</h2><p id="467d" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">现在服务B已经获得了一个持久的IP地址，服务A仍然需要知道这个IP地址是什么，然后才能与服务B对话。</p><p id="b9d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kubernetes支持使用CoreDNS进行名称解析。服务A应该知道它需要与之对话的集群IP的名称(&amp; port)。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mb"><img src="../Images/3b5a85d5c8db021890ae234f06b17e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBv0GsuLnXUpdMQF3TvgMA.png"/></div></div></figure><ol class=""><li id="e72e" class="lm ln hi iz b ja jb jd je jg lo jk lp jo lq js lr ls lt lu bi translated">CoreDNS扫描集群，每当创建ClusterIP服务时，它的条目都会添加到DNS服务器中(如果进行了配置，它还会为每个pod添加一个条目，但它与服务到服务的通信无关)。</li><li id="ae71" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">接下来，CoreDNS将自己暴露为一个集群IP服务(默认情况下称为kube-dns ),并且这个服务被配置为pods中的名称服务器。</li><li id="b574" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">发起请求的Pod从DNS获取ClusterIP服务的IP地址，然后可以使用该IP地址和端口发起请求。</li></ol><p id="e8a9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<host name="">解析服务。<name of="" namespace="">。<type>。<root>。该类型可以是用于pod的pod(与服务到服务的通信无关)或用于服务的svc。</root></type></name></host></p><h2 id="4716" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">kube-proxy——cluster IP服务和backing Pods(目标网络地址转换)之间的链接</h2><p id="f845" class="pw-post-body-paragraph ix iy hi iz b ja lf ij jc jd lg im jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">到目前为止，从本文来看，似乎是ClusterIP服务将调用转发到后端pod。但实际上，它是由Kube-proxy完成的。</p><p id="b9aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kube-proxy在每个节点上运行，并监视服务和它们的后备Pods(实际上是端点对象)。</p><ol class=""><li id="e7f2" class="lm ln hi iz b ja jb jd je jg lo jk lp jo lq js lr ls lt lu bi translated">当一个节点上运行的pod向ClusterIP服务发出请求时，kube-proxy会拦截它。</li><li id="70a3" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">通过查看目标IP地址和端口，它可以识别目标群集IP服务。并且它将这个请求的目的地替换为一个端点的地址，在该端点上实际的Pods服务于该请求。</li></ol><h2 id="d525" class="kk kl hi bd km kn ko kp kq kr ks kt ku jg kv kw kx jk ky kz la jo lb lc ld le bi translated">它是如何真正协同工作的？</h2><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mc"><img src="../Images/7d7a02ece5e9e3d47020df049be1a03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O8QuR2jj39Frp7FsoDS40A.png"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">集群IP服务、核心DNS、客户端Pod、Kube代理、端点和目标服务Pod的交互</figcaption></figure><ol class=""><li id="efc0" class="lm ln hi iz b ja jb jd je jg lo jk lp jo lq js lr ls lt lu bi translated">目标的ClusterIP服务已在CoreDNS中注册</li><li id="39da" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">DNS解析:每个pod都有一个resolve.conf文件，其中包含核心DNS服务的IP地址，pod执行DNS查找。</li><li id="653b" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">Pod使用它从DNS收到的IP地址和它已经知道的端口调用clusterIP服务。</li><li id="4da5" class="lm ln hi iz b ja lv jd lw jg lx jk ly jo lz js lr ls lt lu bi translated">目的地地址转换:Kube-proxy将目的地IP地址更新为来自服务B的Pod可用的地址</li></ol><p id="3791" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">总结</strong></p><p id="3c73" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们看到了原生的Kubernetes对象，它们使得服务到服务的通信成为可能。虽然这些细节对应用层来说是隐藏的，但是了解vanilla Kubernetes中有什么是好的&amp;在Kubernetes之上构建的平台/产品适合去哪里。</p><p id="a0d2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的下一篇文章中，我将讨论服务网格，它提供了一个智能网络来简化服务到服务的通信。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="7ab6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望报道传达了它所承诺的内容。让我知道你的反馈。</p><p id="de7d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">我的相关文章</strong></p><p id="6cf3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">边车模式，流程外架构</strong> &amp; <strong class="iz hj">对多容器pod的需求</strong>—<a class="ae jt" rel="noopener" href="/codex/communication-inside-a-kubernetes-pod-why-do-we-need-multi-container-pods-3d8d0d64c2c9">https://medium . com/codex/communication-inside-a-kubernetes-pod-why-do-we-Need-multi-container-pods-3d 8d 0d 64 c 2 c 9</a></p><p id="74b4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">为什么我们需要Kubernetes的服务网络？—</strong><a class="ae jt" rel="noopener" href="/codex/east-west-service-to-service-communication-what-is-service-mesh-4e56f94bc89c">https://medium . com/codex/east-west-service-to-service-communication-what-is-service-mesh-4 e 56 f 94 BC 89 c</a></p><p id="2065" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">通过入口控制器暴露非HTTP端点&amp;新的网关API</strong><a class="ae jt" rel="noopener" href="/codex/north-south-communication-in-kubernetes-exposing-non-http-services-to-the-outside-world-4ebba4217443">https://medium . com/codex/north-south-communication-in-kubernetes-exposure-Non-HTTP-services-to-the-outside-world-4 ebba 4217443</a></p><p id="2601" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">Kubernetes中的南北沟通——客户端如何与集群内部的服务进行对话？</strong><a class="ae jt" rel="noopener" href="/better-programming/north-south-communication-in-kubernetes-how-does-a-client-talk-to-a-service-inside-a-cluster-8af8b27dbb9">https://medium . com/better-programming/north-south-communication-in-kubernetes-how-a-client-talk-to-a-service-inside-a-cluster-8 af8 b 27 dbb 9</a></p></div></div>    
</body>
</html>