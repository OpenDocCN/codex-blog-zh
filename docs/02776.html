<html>
<head>
<title>Using Python to Create an Innovative Trading Strategy and Achieve Better Results</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python创建创新的交易策略并取得更好的结果</h1>
<blockquote>原文：<a href="https://medium.com/codex/using-python-to-create-an-innovative-trading-strategy-and-achieve-better-results-702dcf4359ce?source=collection_archive---------1-----------------------#2021-08-05">https://medium.com/codex/using-python-to-create-an-innovative-trading-strategy-and-achieve-better-results-702dcf4359ce?source=collection_archive---------1-----------------------#2021-08-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9acc" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用Python结合多个指标创建非常规交易策略的实践指南</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/fcba8c3934093d22d8b5d3f4093e14f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Utn4e5P4YryUcaCwltYxzg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">安纳斯·阿尔尚蒂在<a class="ae jn" href="https://unsplash.com/@anasalshanti?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="04b6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">交易舞台上充斥着大量的人，他们的目标是从股市中发财。因此，要想在这个庞大的人群中脱颖而出，并在市场上保持强大的优势，创新非常规且未被普遍利用的新想法是必不可少的。例如，自从引入技术指标以来，几乎每个人都开始使用它们，但要取得成功，就必须创造性地使用它们，而不是采用传统的策略。这正是我们今天要做的。</p><p id="63b3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本文中，我们将使用Python来创建一个创新的交易策略，它结合了两个强大的指标，即随机振荡器和移动平均线收敛/发散(MACD)指标，最终目的是尽可能消除错误信号，实现更好的结果。事不宜迟，让我们进入文章吧！</p><p id="27d9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在继续之前，如果你想在没有任何代码的情况下回溯测试你的交易策略，有一个解决方案。这是<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">的后验区</a>。这是一个平台，可以免费对不同类型的可交易资产的任意数量的交易策略进行回溯测试，无需编码。点击这里的链接，你可以马上使用这个工具:<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">https://www.backtestzone.com/</a></p><h1 id="739f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">随机振荡器</h1><p id="5e2b" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">随机振荡器是一种基于动量的领先指标，广泛用于识别市场是处于超买还是超卖的状态。这就引出了我们的下一个问题。在令人担忧的市场中，什么是超买和超卖？当市场的趋势看起来非常看涨并且一定会盘整时，股票被认为是超买。类似地，当市场趋势似乎极度看跌并有反弹趋势时，股票到达超卖区域。</p><p id="124c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于其归一化功能，随机振荡器的值总是在0到100之间。一般超买和超卖水平分别被认为是70和30，但它可能因人而异。随机振荡器包括两个主要组件:</p><ul class=""><li id="6dfa" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated"><strong class="jq hj"> %K线:</strong>这条线是随机振荡器指标中最重要、最核心的组成部分。它也被称为快速随机指标。这条线的唯一目的是表达市场的当前状态(超买或超卖)。这条线的计算方法是从股票的收盘价中减去股票在指定时间段内达到的最低价格，然后将该差值除以从最高股票价格中减去股票在指定时间段内达到的最低价格所得的值。通过将上述步骤计算出的值乘以100，得到最终值。用最流行的设置14作为周期数来计算%K线的方法可以表示如下:</li></ul><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="6e65" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">%K = 100 * ((14 DAY CLOSING PRICE - 14 DAY LOWEST PRICE) - (14 DAY HIGHEST PRICE - 14 DAY LOWEST PRICE))</strong></span></pre><ul class=""><li id="4c5d" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated"><strong class="jq hj"> %D线:</strong>又称慢随机指标，无非是%K线在特定时期的移动平均线。它也被称为%K线的平滑版本，因为%D线的线图看起来比%K线更平滑。%D行的标准设置是周期数为3。</li></ul><p id="54e1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是计算随机振子分量的整个过程。现在，让我们分析一个图表，其中苹果的收盘价数据与随机振荡器一起绘制，随机振荡器分别以14和3作为%K线和% D线的回望期，以建立对该指标及其使用方式的牢固理解。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/d3d7c1fcf359d6cb78618429e379222c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRbfaRBRx5EOscr9S2KgOA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="53b0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该图细分为两个面板:上面板和下面板。上面的面板代表苹果收盘价的线图。下面的面板包括随机振荡器的组件。作为领先指标，随机振荡指标不能和收盘价一起绘制，因为指标值和收盘价变化很大。因此，它与收盘价(在我们的例子中低于收盘价)分开绘制。</p><p id="1da8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们之前讨论过的成分%K线和%D线分别用蓝色和橙色绘制。您还可以注意到%K和%D线上方和下方的两条额外的黑色虚线。它是被称为波段的随机振荡器的附加组件。这些波段用来突出超买和超卖的区域。如果%K线和%D线都在高波段上方交叉，那么股票被认为是超买。同样，当%K和%D线都穿过低波段时，股票被认为超卖。</p><h1 id="4638" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">MACD</h1><p id="6c0b" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在学习MACD之前，有必要知道指数移动平均线(EMA)是什么意思。EMA是一种移动平均线(MA ),它自动为最近的数据点分配较大的权重(除了重要性之外),而为遥远过去的数据点分配较小的权重。例如，一份试卷将由10%的一分问题、40%的三分问题和50%的长答案问题组成。从这个例子中，您可以观察到，我们根据重要性级别为试卷的每个部分分配了唯一的权重(长答案问题可能比一分问题更重要)。</p><p id="f5a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，MACD是一个趋势跟踪领先指标，通过减去两个指数移动平均线(一个周期较长，另一个周期较短)来计算。MACD指标有三个显著的组成部分。</p><ul class=""><li id="2d0e" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated"><strong class="jq hj"> MACD线:</strong>这条线是两个给定的指数均线之差。为了计算MACD线，需要计算一个周期较长的均线(慢速线)和一个周期较短的均线(快速线)。最快和最慢的长度分别是12，26。从快速均线中减去慢速均线可以得到最终的MACD线值。计算MACD线的公式可以表示如下:</li></ul><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="5a16" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">MACD LINE = FAST LENGTH EMA - SLOW LENGTH EMA</strong></span></pre><ul class=""><li id="0b73" class="lh li hi jq b jr js ju jv jx lj kb lk kf ll kj lm ln lo lp bi translated"><strong class="jq hj">信号线:</strong>这条线是MACD线本身在给定时间段内的指数移动平均线。计算信号线最流行的时期是9。由于我们平均了MACD线本身，信号线将比MACD线更平滑。</li><li id="7fe7" class="lh li hi jq b jr mb ju mc jx md kb me kf mf kj lm ln lo lp bi translated"><strong class="jq hj">直方图:</strong>顾名思义，是特意绘制出来揭示MACD线和信号线区别的直方图。这是用来识别趋势的一个很好的组件。计算直方图的公式可表示如下:</li></ul><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="4e46" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">HISTOGRAM = MACD LINE - SIGNAL LINE</strong></span></pre><p id="fc67" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">既然我们已经了解了MACD到底是什么。让我们分析一张MACD的图表来建立对指标的直觉。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/a48318b2a4a655b46077c664e016876c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VPisZboiq9jcBgKyPZDZTg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="180b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此图中有两个面板:顶部面板是苹果收盘价的图，底部面板是计算的MACD成分的一系列图。让我们拆开来看看每一个部件。</p><p id="7462" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">底部面板中第一个也是最明显的部分显然是计算直方图值的图。你可以注意到，每当市场显示负趋势时，该图就会变红，每当市场显示正趋势时，该图就会变绿。直方图的这个特性在识别市场趋势时变得非常方便。每当MACD线和信号线之间的差异很大时，直方图就扩展得更大，并且值得注意的是，直方图有时收缩，表示两个其他分量之间的差异相对较小。</p><p id="6712" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来的两个组件是MACD线和信号线。MACD线是灰色的线图，显示了苹果股价的慢速均线和快速均线之间的差异。同样，蓝色的线图是代表MACD线本身的均线的信号线。正如我们之前讨论的，信号线看起来更像是MACD线的平滑版本，因为它是通过平均MACD线本身的值计算出来的。</p><h1 id="f7a8" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">交易策略</h1><p id="3841" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">现在我们已经对随机振荡指标和MACD指标建立了一些基本的直觉。让我们讨论一下这篇文章中我们将要实施的交易策略。这个策略非常简单。</p><p id="a850" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果%K和%D线低于30，MACD和信号线小于-2，我们就做多(买入股票)。类似地，如果%K和%D线交叉超过70，并且MACD指标的两个分量都大于2，我们做空(卖出股票)。我们的交易策略可以表述如下:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="8fb0" class="lv kl hi lr b fi lw lx l ly lz">IF <strong class="lr hj">%K &lt; 30 </strong>AND <strong class="lr hj">%D &lt; 30 </strong>AND <strong class="lr hj">MACD.L &lt; -2 </strong>AND<strong class="lr hj"> SIGNAL.L &lt; -2</strong> ==&gt; <strong class="lr hj">BUY</strong><br/>IF <strong class="lr hj">%K &gt; 70 </strong>AND <strong class="lr hj">%D &gt; 70 </strong>AND <strong class="lr hj">MACD.L &gt; 2 </strong>AND<strong class="lr hj"> SIGNAL.L &gt; 2</strong> ==&gt; <strong class="lr hj">SELL</strong></span></pre><p id="cc84" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就是这样！我们的理论部分到此结束，让我们进入编程部分，我们将首先使用Python从头构建指标，构建讨论的交易策略，对苹果股票数据进行回溯测试，最后将结果与SPY ETF的结果进行比较。来做点编码吧！在继续之前，关于免责声明的一个注意事项:本文的唯一目的是教育人们，必须被视为一个信息，而不是投资建议等。</p><h1 id="afff" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">用Python实现</h1><p id="8a3f" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">编码部分分为以下几个步骤:</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="236b" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">1. Importing Packages<br/>2. Extracting Stock Data from Twelve Data<br/>3. Stochastic Oscillator Calculation<br/>4. MACD Calculation<br/>5. Creating the Trading Strategy<br/>6. Creating our Position<br/>7. Backtesting<br/>8. SPY ETF Comparison</strong></span></pre><p id="aa1b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h2 id="394f" class="lv kl hi bd km mg mh mi kq mj mk ml ku jx mm mn kw kb mo mp ky kf mq mr la ms bi translated">步骤1:导入包</h2><p id="d5c7" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="827b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="5c9b" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># IMPORTING PACKAGES<br/></strong><br/>import pandas as pd<br/>import numpy as np<br/>import requests<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)</span></pre><p id="3a56" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经将所有需要的包导入到python中。我们用十二数据的API端点来拉一下苹果的历史数据。</p><h2 id="b063" class="lv kl hi bd km mg mh mi kq mj mk ml ku jx mm mn kw kb mo mp ky kf mq mr la ms bi translated">步骤2:从12个数据中提取股票数据</h2><p id="9e41" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将使用由<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>提供的API端点提取苹果的历史股票数据。在此之前，请注意twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank"/>:十二数据公司是领先的市场数据提供商之一，拥有大量各种市场数据的API端点。它非常容易与十二数据提供的API进行交互，并且拥有有史以来最好的文档。此外，确保你有一个twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">的账户，只有这样，你才能访问你的API密匙(用API提取数据的重要元素)。</a></p><p id="f00a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="2aa0" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># EXTRACTING STOCK DATA<br/></strong><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>aapl = get_historical_data('AAPL', '2010-01-01')<br/>aapl.tail()</span></pre><p id="1067" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mt"><img src="../Images/df520b2ab3905b2b4b3ccc6bad3d55a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DvvwceenR4nYFbVl36LUug.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="fc74" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们做的第一件事是定义一个名为‘get _ historical _ data’的函数，该函数将股票的符号(‘symbol’)和历史数据的起始日期(‘start _ date’)作为参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们调用创建的函数从2010年开始提取苹果的历史数据，并将其存储到‘AAPL’变量中。</p><h2 id="89b9" class="lv kl hi bd km mg mh mi kq mj mk ml ku jx mm mn kw kb mo mp ky kf mq mr la ms bi translated">步骤3:随机振荡器计算</h2><p id="37c3" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将按照之前讨论过的方法和公式来计算随机振荡器的分量。</p><p id="aaf8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="c6ee" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># STOCHASTIC OSCILLATOR CALCULATION<br/></strong><br/>def get_stoch_osc(high, low, close, k_lookback, d_lookback):<br/>    lowest_low = low.rolling(k_lookback).min()<br/>    highest_high = high.rolling(k_lookback).max()<br/>    k_line = ((close - lowest_low) / (highest_high - lowest_low)) * 100<br/>    d_line = k_line.rolling(d_lookback).mean()<br/>    return k_line, d_line<br/><br/>aapl['%k'], aapl['%d'] = get_stoch_osc(aapl['high'], aapl['low'], aapl['close'], 14, 3)<br/>aapl.tail()</span></pre><p id="0f63" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/51bd82d9120cfb2c8c7417b126f5020a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V72XkYF6e1lEXXx6V8SV-g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="e7ac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们首先定义一个名为“get_stoch_osc”的函数，它分别将股票的高点(“高点”)、低点(“低点”)、收盘价数据(“收盘”)以及%K线(“K _回看”)和%D线(“D _回看”)的回看周期作为参数。在函数内部，我们首先使用Pandas软件包提供的“滚动”、“最小”和“最大”函数计算指定周期数的最低下限和最高上限数据点，并将这些值存储到“最低下限”和“最高上限”变量中。</p><p id="b353" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是%K线计算，我们将公式代入代码，并将读数存储到“k线”变量中，然后，我们计算%D线，这不过是获取指定周期数的%K线读数的SMA。最后，我们将返回值并调用函数来存储Apple的随机振荡器读数，分别以14和3作为%K和%D线的回望周期。</p><h2 id="f043" class="lv kl hi bd km mg mh mi kq mj mk ml ku jx mm mn kw kb mo mp ky kf mq mr la ms bi translated">第四步:MACD计算</h2><p id="9c64" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将从提取的苹果历史数据中计算MACD指标的所有组成部分。</p><p id="6866" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="a16b" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># MACD CALCULATION<br/></strong><br/>def get_macd(price, slow, fast, smooth):<br/>    exp1 = price.ewm(span = fast, adjust = False).mean()<br/>    exp2 = price.ewm(span = slow, adjust = False).mean()<br/>    macd = pd.DataFrame(exp1 - exp2).rename(columns = {'close':'macd'})<br/>    signal = pd.DataFrame(macd.ewm(span = smooth, adjust = False).mean()).rename(columns = {'macd':'signal'})<br/>    hist = pd.DataFrame(macd['macd'] - signal['signal']).rename(columns = {0:'hist'})<br/>    return macd, signal, hist<br/><br/>aapl['macd'] = get_macd(aapl['close'], 26, 12, 9)[0]<br/>aapl['macd_signal'] = get_macd(aapl['close'], 26, 12, 9)[1]<br/>aapl['macd_hist'] = get_macd(aapl['close'], 26, 12, 9)[2]<br/>aapl = aapl.dropna()<br/>aapl.tail()</span></pre><p id="7e5f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/160b6e189f2f63ff9f6a3872144957a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Se55p_C17DwsuDbDMi1RQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="ba30" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为“get_macd”的函数，它获取股票的价格(“prices”)、慢速均线的长度(“slow”)、快速均线的长度(“fast”)以及信号线的周期(“smooth”)。</p><p id="6c9e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在函数内部，我们首先使用Pandas提供的“ewm”函数计算快速和慢速长度ema，并将它们分别存储到“ema1”和“ema2”变量中。</p><p id="e0b6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我们通过从快速均线中减去慢速均线来计算macd线的值，并以熊猫数据帧的形式存储到“MACD”变量中。接下来，我们定义了一个名为“signal”的变量来存储信号线的值，该值是通过在指定的时间段内获取macd线值(“MACD”)的均线来计算的。</p><p id="0530" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，我们通过从信号线的值(“信号”)中减去macd线的值(“MACD”)来计算直方图值，并将它们存储到“hist”变量中。最后，我们返回所有计算出的值，并调用创建的函数来存储苹果的MACD组件。</p><h2 id="1c87" class="lv kl hi bd km mg mh mi kq mj mk ml ku jx mm mn kw kb mo mp ky kf mq mr la ms bi translated">步骤5:创建交易策略:</h2><p id="be5e" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将在python中实现所讨论的随机振荡器和移动平均线收敛/发散(MACD)组合交易策略。</p><p id="92a9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="5c62" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># TRADING STRATEGY<br/></strong><br/>def implement_stoch_macd_strategy(prices, k, d, macd, macd_signal):    <br/>    buy_price = []<br/>    sell_price = []<br/>    stoch_macd_signal = []<br/>    signal = 0<br/><br/>    for i in range(len(prices)):<br/>        if k[i] &lt; 30 and d[i] &lt; 30 and macd[i] &lt; -2 and macd_signal[i] &lt; -2:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                stoch_macd_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                stoch_macd_signal.append(0)<br/>                <br/>        elif k[i] &gt; 70 and d[i] &gt; 70 and macd[i] &gt; 2 and macd_signal[i] &gt; 2:<br/>            if signal != -1 and signal != 0:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                stoch_macd_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                stoch_macd_signal.append(0)<br/>        <br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            stoch_macd_signal.append(0)<br/>            <br/>    return buy_price, sell_price, stoch_macd_signal<br/>            <br/>buy_price, sell_price, stoch_macd_signal = implement_stoch_macd_strategy(aapl['close'], aapl['%k'], aapl['%d'], aapl['macd'], aapl['macd_signal'])</span></pre><p id="f931" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为‘bb _ stoch _ strategy’的函数，它将股票价格(‘prices’)、k线读数(‘K’)、D线读数(‘D’)、MACD线(‘MACD’)和信号线(‘MACD _ Signal’)作为参数。</p><p id="9e5d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在该函数中，我们创建了三个空列表(buy_price、sell_price和stoch_macd_signal ),在创建交易策略时，将在这些列表中追加值。</p><p id="07b5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之后，我们通过for循环实施交易策略。在for循环内部，我们传递某些条件，如果条件得到满足，相应的值将被追加到空列表中。如果购买股票的条件得到满足，买入价将被追加到“buy_price”列表中，信号值将被追加为1，表示购买股票。类似地，如果卖出股票的条件得到满足，卖价将被追加到“sell_price”列表中，信号值将被追加为-1，表示卖出股票。最后，我们返回附加了值的列表。然后，我们调用创建的函数并将值存储到各自的变量中。</p><h2 id="6190" class="lv kl hi bd km mg mh mi kq mj mk ml ku jx mm mn kw kb mo mp ky kf mq mr la ms bi translated">步骤6:创建我们的职位</h2><p id="1492" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将创建一个列表，如果我们持有股票，该列表将指示1；如果我们不拥有或持有股票，该列表将指示0。</p><p id="d20c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="74c7" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># POSITION<br/></strong><br/>position = []<br/>for i in range(len(stoch_macd_signal)):<br/>    if stoch_macd_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(aapl['close'])):<br/>    if stoch_macd_signal[i] == 1:<br/>        position[i] = 1<br/>    elif stoch_macd_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = aapl['close']<br/>k_line = aapl['%k']<br/>d_line = aapl['%d']<br/>macd_line = aapl['macd']<br/>signal_line = aapl['macd_signal']<br/>stoch_macd_signal = pd.DataFrame(stoch_macd_signal).rename(columns = {0:'stoch_macd_signal'}).set_index(aapl.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'stoch_macd_position'}).set_index(aapl.index)<br/><br/>frames = [close_price, k_line, d_line, macd_line, signal_line, stoch_macd_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy</span></pre><p id="b004" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/df1ea016160bdeefb77da1096f4e35f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HG-vGYTng_KWvt4w9eofjw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="7e7d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们创建一个名为‘position’的空列表。我们传递两个for循环，一个是为“位置”列表生成值，以匹配“信号”列表的长度。另一个for循环是我们用来生成实际位置值的循环。</p><p id="b0cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在第二个for循环中，我们对“signal”列表的值进行迭代，而“position”列表的值被附加到满足哪个条件上。如果我们持有股票，头寸的价值仍为1；如果我们卖出或不持有股票，头寸的价值仍为0。最后，我们正在进行一些数据操作，将所有创建的列表合并到一个数据帧中。</p><p id="533a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从显示的输出中，我们可以看到，在第一行中，我们在股票中的位置仍然是1(因为交易信号没有任何变化)，但是当交易信号代表买入信号(-1)时，我们的位置突然变成了0。我们的头寸将保持-1，直到交易信号发生一些变化。现在是时候实现一些回溯测试过程了！</p><h2 id="6d6e" class="lv kl hi bd km mg mh mi kq mj mk ml ku jx mm mn kw kb mo mp ky kf mq mr la ms bi translated">步骤7:回溯测试</h2><p id="c813" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在继续之前，有必要知道什么是回溯测试。回溯测试是查看我们的交易策略在给定股票数据上表现如何的过程。在我们的例子中，我们将对苹果股票数据实施随机振荡器和MACD组合交易策略的回溯测试过程。</p><p id="0a2b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="7728" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># BACKTESTING<br/></strong><br/>aapl_ret = pd.DataFrame(np.diff(aapl['close'])).rename(columns = {0:'returns'})<br/>stoch_macd_strategy_ret = []<br/><br/>for i in range(len(aapl_ret)):<br/>    try:<br/>        returns = aapl_ret['returns'][i] * strategy['stoch_macd_position'][i]<br/>        stoch_macd_strategy_ret.append(returns)<br/>    except:<br/>        pass<br/>    <br/>stoch_macd_strategy_ret_df = pd.DataFrame(stoch_macd_strategy_ret).rename(columns = {0:'stoch_macd_returns'})<br/><br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value / aapl['close'][0])<br/>stoch_macd_investment_ret = []<br/><br/>for i in range(len(stoch_macd_strategy_ret_df['stoch_macd_returns'])):<br/>    returns = number_of_stocks * stoch_macd_strategy_ret_df['stoch_macd_returns'][i]<br/>    stoch_macd_investment_ret.append(returns)<br/><br/>stoch_macd_investment_ret_df = pd.DataFrame(stoch_macd_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(stoch_macd_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret / investment_value) * 100)<br/>print(cl('Profit gained from the STOCH MACD strategy by investing $100k in AAPL : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the STOCH MACD strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre><p id="9c46" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="f45d" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">Profit gained from the STOCH MACD strategy by investing $100k in AAPL : 1189853.94</strong><br/><strong class="lr hj">Profit percentage of the STOCH MACD strategy : 1189%</strong></span></pre><p id="7dc0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们使用NumPy包提供的“diff”函数计算苹果股票的回报，并将其作为数据帧存储到“aapl_ret”变量中。接下来，我们传递一个for循环来迭代' aapl_ret '变量的值，以计算我们从交易策略中获得的回报，这些回报值被追加到' stoch_macd_strategy_ret '列表中。接下来，我们将“stoch_macd_strategy_ret”列表转换为数据帧，并将其存储到“stoch_macd_strategy_ret_df”变量中。</p><p id="52c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是回溯测试过程。我们将通过投资10万美元到我们的交易策略中来回测我们的策略。首先，我们将投资金额存储到“投资值”变量中。之后，我们正在计算使用投资金额可以购买的苹果股票数量。你可以注意到，我使用了Math软件包提供的“floor”函数，因为当投资金额除以苹果股票的收盘价时，它会输出一个十进制数。股票数量应该是整数，而不是小数。使用“底数”函数，我们可以去掉小数。请记住,“floor”函数比“round”函数要复杂得多。然后，我们传递一个for循环来查找投资回报，后面是一些数据操作任务。</p><p id="b727" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们打印了我们在交易策略中投入10万美元的总回报，显示我们在大约10年半的时间里获得了大约119万美元的利润，利润率为1189%。太好了！现在，让我们将我们的回报与SPY ETF(一种旨在跟踪标准普尔500股票市场指数的ETF)的回报进行比较。</p><h2 id="6c5e" class="lv kl hi bd km mg mh mi kq mj mk ml ku jx mm mn kw kb mo mp ky kf mq mr la ms bi translated">第八步:间谍ETF对比</h2><p id="f873" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">这一步是可选的，但强烈推荐，因为我们可以了解我们的交易策略相对于基准(间谍ETF)的表现如何。在这一步中，我们将使用我们创建的“get_historical_data”函数提取SPY ETF数据，并将我们从SPY ETF获得的回报与我们在Apple上的交易策略回报进行比较。</p><p id="f020" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可能已经注意到，在我所有的算法交易文章中，我没有将策略结果与标准普尔500市场指数本身进行比较，而是与SPY ETF进行比较，这是因为大多数股票数据提供商(如12 Data)不提供标准普尔500指数数据。所以，我别无选择，只能选择间谍ETF。如果你有幸得到标准普尔500市场指数数据，建议用它来做比较，而不是任何ETF。</p><p id="c196" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="5872" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj"># SPY ETF COMPARISON<br/></strong><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[0])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2010-01-01', 100000)<br/><br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('STOCH MACD Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre><p id="d6bb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="7112" class="lv kl hi lr b fi lw lx l ly lz"><strong class="lr hj">Benchmark profit by investing $100k : 287249.77</strong><br/><strong class="lr hj">Benchmark Profit percentage : 287%</strong><br/><strong class="lr hj">STOCH MACD Strategy profit is 902% higher than the Benchmark Profit</strong></span></pre><p id="37d6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>此步骤中使用的代码与前一个回溯测试步骤中使用的代码几乎相似，但我们不是投资苹果，而是通过不实施任何交易策略来投资SPY ETF。从输出可以看出，我们的交易策略跑赢了SPY ETF 902%。太棒了。</p><h1 id="8ce1" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后的想法！</h1><p id="bbeb" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">经过一个压倒性的过程，粉碎了理论和编码部分，我们已经成功地了解了什么是随机振荡器和移动平均线收敛/发散，结合这两个指标使用Python创建了一个交易策略，并超越了间谍ETF的表现。</p><p id="62e6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这篇文章只是对编程如何应用于金融，尤其是股票市场的一瞥。由此，我们可以说，为了在市场上保持强大的优势，掌握编程艺术和其他类似的技术概念是至关重要的。</p><p id="2344" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">主办:</strong> <a class="ae jn" href="https://eodhistoricaldata.com/r/?ref=DHY3H8NT" rel="noopener ugc nofollow" target="_blank"> EOD历史数据</a>是金融应用编程接口市场的领导者之一，提供各种各样的应用编程接口，从基本的每日市场数据到高度可定制的应用编程接口，如金融新闻应用编程接口和股票筛选应用编程接口。他们所有的API都是以一种本质上易于使用的方式设计的，因此初学者可以毫无障碍地使用它们。我个人使用过<a class="ae jn" href="https://eodhistoricaldata.com/r/?ref=DHY3H8NT" rel="noopener ugc nofollow" target="_blank"> EOD历史数据公司的</a>API，从我的经验来看，他们的API既适合专业人士也适合业余爱好者，用于辅助项目和构建企业级应用程序。</p><h2 id="1b2e" class="lv kl hi bd km mg mh mi kq mj mk ml ku jx mm mn kw kb mo mp ky kf mq mr la ms bi translated">完整代码:</h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="f440" class="lv kl hi lr b fi lw lx l ly lz"># IMPORTING PACKAGES<br/><br/>import pandas as pd<br/>import numpy as np<br/>import requests<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)<br/><br/># EXTRACTING STOCK DATA<br/><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>aapl = get_historical_data('AAPL', '2010-01-01')<br/>aapl.tail()<br/><br/># STOCHASTIC OSCILLATOR CALCULATION<br/><br/>def get_stoch_osc(high, low, close, k_lookback, d_lookback):<br/>    lowest_low = low.rolling(k_lookback).min()<br/>    highest_high = high.rolling(k_lookback).max()<br/>    k_line = ((close - lowest_low) / (highest_high - lowest_low)) * 100<br/>    d_line = k_line.rolling(d_lookback).mean()<br/>    return k_line, d_line<br/><br/>aapl['%k'], aapl['%d'] = get_stoch_osc(aapl['high'], aapl['low'], aapl['close'], 14, 3)<br/>aapl.tail()<br/><br/># STOCHASTIC OSCILLATOR PLOT<br/><br/>plot_data = aapl[aapl.index &gt;= '2020-01-01']<br/><br/>ax1 = plt.subplot2grid((14,1), (0,0), rowspan = 7, colspan = 1)<br/>ax2 = plt.subplot2grid((15,1), (9,0), rowspan = 6, colspan = 1)<br/>ax1.plot(plot_data['close'], linewidth = 2.5)<br/>ax1.set_title('AAPL STOCK PRICES')<br/>ax2.plot(plot_data['%k'], color = 'deepskyblue', linewidth = 1.5, label = '%K')<br/>ax2.plot(plot_data['%d'], color = 'orange', linewidth = 1.5, label = '%D')<br/>ax2.axhline(70, color = 'black', linewidth = 1, linestyle = '--')<br/>ax2.axhline(30, color = 'black', linewidth = 1, linestyle = '--')<br/>ax2.set_title(f'AAPL STOCH 14,3')<br/>ax2.legend(loc = 'right')<br/>plt.show()<br/><br/># MACD CALCULATION<br/><br/>def get_macd(price, slow, fast, smooth):<br/>    exp1 = price.ewm(span = fast, adjust = False).mean()<br/>    exp2 = price.ewm(span = slow, adjust = False).mean()<br/>    macd = pd.DataFrame(exp1 - exp2).rename(columns = {'close':'macd'})<br/>    signal = pd.DataFrame(macd.ewm(span = smooth, adjust = False).mean()).rename(columns = {'macd':'signal'})<br/>    hist = pd.DataFrame(macd['macd'] - signal['signal']).rename(columns = {0:'hist'})<br/>    return macd, signal, hist<br/><br/>aapl['macd'] = get_macd(aapl['close'], 26, 12, 9)[0]<br/>aapl['macd_signal'] = get_macd(aapl['close'], 26, 12, 9)[1]<br/>aapl['macd_hist'] = get_macd(aapl['close'], 26, 12, 9)[2]<br/>aapl = aapl.dropna()<br/>aapl.tail()<br/><br/># MACD PLOT<br/><br/>plot_data = aapl[aapl.index &gt;= '2020-01-01']<br/><br/>def plot_macd(prices, macd, signal, hist):<br/>    ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>    ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/><br/>    ax1.plot(prices, linewidth = 2.5)<br/>    ax1.set_title('AAPL STOCK PRICES')<br/>    ax2.plot(macd, color = 'grey', linewidth = 1.5, label = 'MACD')<br/>    ax2.plot(signal, color = 'skyblue', linewidth = 1.5, label = 'SIGNAL')<br/>    ax2.set_title('AAPL MACD 26,12,9')<br/><br/>    for i in range(len(prices)):<br/>        if str(hist[i])[0] == '-':<br/>            ax2.bar(prices.index[i], hist[i], color = '#ef5350')<br/>        else:<br/>            ax2.bar(prices.index[i], hist[i], color = '#26a69a')<br/><br/>    plt.legend(loc = 'lower right')<br/><br/>plot_macd(plot_data['close'], plot_data['macd'], plot_data['macd_signal'], plot_data['macd_hist'])<br/><br/># TRADING STRATEGY<br/><br/>def implement_stoch_macd_strategy(prices, k, d, macd, macd_signal):    <br/>    buy_price = []<br/>    sell_price = []<br/>    stoch_macd_signal = []<br/>    signal = 0<br/><br/>    for i in range(len(prices)):<br/>        if k[i] &lt; 30 and d[i] &lt; 30 and macd[i] &lt; -2 and macd_signal[i] &lt; -2:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                stoch_macd_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                stoch_macd_signal.append(0)<br/>                <br/>        elif k[i] &gt; 70 and d[i] &gt; 70 and macd[i] &gt; 2 and macd_signal[i] &gt; 2:<br/>            if signal != -1 and signal != 0:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                stoch_macd_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                stoch_macd_signal.append(0)<br/>        <br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            stoch_macd_signal.append(0)<br/>            <br/>    return buy_price, sell_price, stoch_macd_signal<br/>            <br/>buy_price, sell_price, stoch_macd_signal = implement_stoch_macd_strategy(aapl['close'], aapl['%k'], aapl['%d'], aapl['macd'], aapl['macd_signal'])<br/><br/># TRADING SIGNALS PLOT<br/><br/>plt.plot(aapl['close'])<br/>plt.plot(aapl.index, buy_price, marker = '^', markersize = 10, color = 'green')<br/>plt.plot(aapl.index, sell_price, marker = 'v', markersize = 10, color = 'r')<br/><br/># POSITION<br/><br/>position = []<br/>for i in range(len(stoch_macd_signal)):<br/>    if stoch_macd_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(aapl['close'])):<br/>    if stoch_macd_signal[i] == 1:<br/>        position[i] = 1<br/>    elif stoch_macd_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = aapl['close']<br/>k_line = aapl['%k']<br/>d_line = aapl['%d']<br/>macd_line = aapl['macd']<br/>signal_line = aapl['macd_signal']<br/>stoch_macd_signal = pd.DataFrame(stoch_macd_signal).rename(columns = {0:'stoch_macd_signal'}).set_index(aapl.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'stoch_macd_position'}).set_index(aapl.index)<br/><br/>frames = [close_price, k_line, d_line, macd_line, signal_line, stoch_macd_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy.head()<br/>strategy[-75:-70]<br/><br/># BACKTESTING<br/><br/>aapl_ret = pd.DataFrame(np.diff(aapl['close'])).rename(columns = {0:'returns'})<br/>stoch_macd_strategy_ret = []<br/><br/>for i in range(len(aapl_ret)):<br/>    try:<br/>        returns = aapl_ret['returns'][i] * strategy['stoch_macd_position'][i]<br/>        stoch_macd_strategy_ret.append(returns)<br/>    except:<br/>        pass<br/>    <br/>stoch_macd_strategy_ret_df = pd.DataFrame(stoch_macd_strategy_ret).rename(columns = {0:'stoch_macd_returns'})<br/><br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value / aapl['close'][0])<br/>stoch_macd_investment_ret = []<br/><br/>for i in range(len(stoch_macd_strategy_ret_df['stoch_macd_returns'])):<br/>    returns = number_of_stocks * stoch_macd_strategy_ret_df['stoch_macd_returns'][i]<br/>    stoch_macd_investment_ret.append(returns)<br/><br/>stoch_macd_investment_ret_df = pd.DataFrame(stoch_macd_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(stoch_macd_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret / investment_value) * 100)<br/>print(cl('Profit gained from the STOCH MACD strategy by investing $100k in AAPL : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the STOCH MACD strategy : {}%'.format(profit_percentage), attrs = ['bold']))<br/><br/># SPY ETF COMPARISON<br/><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[0])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2010-01-01', 100000)<br/><br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/><br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('STOCH MACD Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre></div></div>    
</body>
</html>