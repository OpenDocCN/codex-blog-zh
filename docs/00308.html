<html>
<head>
<title>Making Your Own JavaScript Linter (part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制作您自己的JavaScript Linter(第3部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/making-your-own-javascript-linter-part-3-da14e2aaf051?source=collection_archive---------5-----------------------#2021-01-15">https://medium.com/codex/making-your-own-javascript-linter-part-3-da14e2aaf051?source=collection_archive---------5-----------------------#2021-01-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="3bdd" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><div class=""><h2 id="1122" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">综合教程</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/8e887d4066966bde27cf70f1cfbc4118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4cPP0bVOzZdvx0gaEvmNbA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">奔跑的棉绒</figcaption></figure><p id="ab9a" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这是关于构建JavaScript linter的综合教程的第三部分。你可以在这里阅读<a class="ae ks" rel="noopener" href="/codex/making-your-own-javascript-linter-part-2-288841612f4d">第二部</a>。</p><p id="7cd5" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">这里是GitHub 中dirtyrat的<a class="ae ks" href="https://github.com/JoanaBLate/dirtyrat" rel="noopener ugc nofollow" target="_blank">源代码。</a></p><h1 id="0472" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">解析函数体—块</h1><p id="64dc" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">像<em class="lq"> if，else，for，while </em>这样的语句总是会创建一个代码块，也称为<em class="lq">作用域</em>。例如，当解析器发现语句<em class="lq"> break </em>时，它必须有办法知道这个语句是否在循环中。其他例子:当解析器发现一个右花括号时，它必须知道哪个块被关闭了。</p><p id="a8a2" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">通过两个全局变量和两个小函数来控制代码块。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="180c" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">如上面的代码所示，很容易知道语句<em class="lq"> break </em>何时有效。只是在时询问或<em class="lq">是否有任何开放的区块。</em></p><p id="5c38" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">现在，语句<em class="lq"> else </em>的检查必须不同:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="9673" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们通过检查<em class="lq"> lastClosedBlock == "if" </em>来验证<em class="lq"> else </em>语句。<em class="lq"> else </em>的性质是不进入<em class="lq"> if </em>块。其性质是在<em class="lq">之后如果</em>受阻。</p><h1 id="de3f" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">为什么我们需要JavaScript linter？</h1><p id="81da" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">浏览器、Deno (JavaScript)和NodeJs不会运行有任何语法错误的代码。但是他们不会在意调用一个不存在的函数的错误，直到执行试图调用这个函数的那一刻。也许运行时人员认为“这个名称还没有定义，但是让我们给它时间来定义它；毕竟我们运行的是动态语言！”。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="755f" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">借用编译编程语言中的术语，我们可以说在JavaScript中，语法错误是一个<em class="lq">编译时错误</em>。其他的都是运行时间错误。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="1eb3" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我个人的约定:“运行时”(不带空格)这个表述是指引擎，就像Chrome V8一样。而“运行时”(带空格)的表述是指代码运行的时刻。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="b1e0" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><em class="lq">编译时错误</em>是诚实的。你马上就会知道他们所有人。它们很容易修复。没有人会发布带有编译时错误的软件。嗯……现在我正在考虑这个规则的一个可能的例外。</p><p id="7f18" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated"><em class="lq">运行时错误</em>是隐蔽的。他们也被称为臭虫。有时它们发生在代码开始运行30分钟后。有时它们发生在非常罕见的鼠标移动、按键和其他动作的组合上。他们是程序员的地狱。</p></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="f2f8" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">JavaScript太宽容了。例如，这种语言允许在相同的范围内创建任意数量的同名函数。最新的函数是唯一会运行的函数，所有其他同名函数的存在只是为了误导您。或者，更糟糕的是，可能存在其中一些运行一段时间的情况(我不知道这是否可能)。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="7d93" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我不反对覆盖一个函数，只要它确实是必要的，并且以一种非常清晰的方式完成。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><p id="fd83" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">有人在<em class="lq"> if </em>语句的条件内写赋值吗？</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><blockquote class="ma"><p id="5d06" class="mb mc hi bd md me mf mg mh mi mj kr dx translated"><em class="mk">使用JavaScript linter的两个主要原因是1)将运行时错误转化为编译时错误，以及2)将JavaScript认为没问题的东西捕捉为错误。</em></p></blockquote></div><div class="ab cl lt lu gp lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hb hc hd he hf"><h1 id="aceb" class="kt ku hi bd kv kw ml ky kz la mm lc ld ix mn iy lf ja mo jb lh jd mp je lj lk bi translated">控制名称</h1><p id="9897" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">关于名字，一个好的短绒必须</p><ol class=""><li id="0b4d" class="mq mr hi jy b jz ka kc kd kf ms kj mt kn mu kr mv mw mx my bi translated">确保没有重复的声明，</li><li id="76f9" class="mq mr hi jy b jz mz kc na kf nb kj nc kn nd kr mv mw mx my bi translated">确保没有使用未定义的名称和</li><li id="071d" class="mq mr hi jy b jz mz kc na kf nb kj nc kn nd kr mv mw mx my bi translated">警告未使用的名称(未使用的本地名称通常是一个错别字和错误)。</li></ol><p id="a1a0" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">注意:dirtyrat知道这可能是林挺一个正在建设中的代码。因此，它不是将错误指向未使用的局部变量，而是产生强烈的警告。</p><p id="7ffd" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在逐个标记地解析标记时，每次声明或使用名称时，linter都会注册相应的标记。稍后，linter会尝试将消耗的名称(赋值、函数调用)与声明的名称进行匹配。</p><p id="4567" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">匹配必须在以后完成，因为函数在声明之前被调用是正常的。此外，对于导入和导出，有必要在开始匹配之前注册所有文件的所有名称。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="6e46" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">命名的黄金法则是:<strong class="jy hs">不同的东西必须有不同的名字</strong>。</p><p id="c6f7" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们不能只依赖一个简单的名称作为标识符，因为不同的元素只要在不同的范围内就可能有相同的名称。</p><p id="e050" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们必须在上面代码的标识符中包含范围:“x”、“f1”、“f1.x”、“f2”、“f2.if.x”和“f2.else.x”。</p><p id="4c7e" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">看起来不错，但不是所有情况下的解决方案:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="f293" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在上述情况下，标识符将是“f”、“f.if.x”和“f . if . x”；打破黄金法则！</p><p id="ec64" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">我们需要另一个标准来创建唯一标识符。依赖代码块是行不通的。</p><h1 id="7538" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">解析函数体—分支</h1><p id="96aa" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">解决方法是使用分支的概念。分支与块非常相似，但是更加详细。它们的存在只是为了帮助创建唯一的标识符。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="c7b2" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">让我们看看它是如何工作的:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="5bbb" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">太棒了。现在每个名字的全称以一种明确的方式注册了它的作用域。</p><p id="97ba" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">不同的东西有不同的名字。好的。问题是同一个东西(参数“a”)得到了不同的名称(“f.1.a”、“f.1.1.a”和“f.1.2.a”)。</p><p id="9907" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">别担心。我们稍后会处理这个问题。</p><h1 id="88c6" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">Rat —源代码文件对象</h1><p id="4c17" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">这是存储源代码文件数据的对象:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="a18e" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">源代码以右修剪行的形式存储。这解决了当我们从不同的环境(例如，Microsoft Windows或网页)导入文本时经常发生的不同的可能行尾问题(" \n" x "\r\n ")。</p><h1 id="de5f" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">真正的令牌对象</h1><p id="60e5" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">我们之前看到的令牌对象是一个极简的对象。这是真的:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="4ef5" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">有些字段仅对名称为<em class="lq">的令牌有效。</em></p><h1 id="737e" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">待续</h1><p id="54f5" class="pw-post-body-paragraph jw jx hi jy b jz ll is kb kc lm iv ke kf ln kh ki kj lo kl km kn lp kp kq kr hb bi translated">这里是<a class="ae ks" rel="noopener" href="/codex/making-your-own-javascript-linter-part-4-de4f106a9785">教程第四部分也是最后一部分</a>的链接。</p></div></div>    
</body>
</html>