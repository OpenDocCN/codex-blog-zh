# 使用 Redux Toolkit 的 createSlice 和 createAsyncThunk 处理异步状态变化的原因

> 原文：<https://medium.com/codex/reasoning-behind-using-redux-toolkits-createslice-and-createasyncthunk-to-handle-your-asynchronous-267e6a6514ca?source=collection_archive---------4----------------------->

![](img/37d7e2c429ec917cb56283df31828519.png)

[维克多](https://unsplash.com/@victor_g?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

我非常支持在发展决策背后进行合理的推理。这可能听起来很奇怪，但是很多时候我们在 web 开发中做一些事情，因为这是项目中已经在做的事情，是当前流行的做事方式。我想在本文中介绍的是下面列出的步骤:

*   识别 Redux 适用的情况
*   提供逐步实施
*   在我们进行的过程中，用所说的*合理推理*来支持实现

为了快速参考，我将使用这两个库中的片段作为我的前的[和](https://github.com/sinisa-nimcevic/basic-async-call-repository/tree/main)后的[。](https://github.com/sinisa-nimcevic/basic-async-call-repository/tree/ARTICLE/redux-create-slice-and-create-async-thunk)

# 第一章:设置

假设我想显示一个数据列表。和所有数据一样，它是通过异步 API 调用获取的。首先，我喜欢在两次快速呼吸(或者更多次)中构建这样的组件。

我想要一个“纯”的组件(不要和 [React 搞混了。PureComponent](https://reactjs.org/docs/react-api.html#reactpurecomponent) ，只显示作为 JSX 传入的道具。我这里说的纯，概念上类似于“纯函数”。纯函数是完全确定的函数，意味着它没有副作用。简单地说，它总是为完全相同的输入呈现完全相同的输出。除了条件渲染，这些“纯”组件没有逻辑，但即使在这里，我也要小心地处理。这给了我一个容易呈现的、纯粹的 UI 组件，例如，它不需要太多的努力就可以装配到故事书的故事中，并与团队的其他成员共享。作为参考，这是我所说的一个很好的例子:

到目前为止一切顺利。

组件的“肉”在父组件内部。父组件处理获取数据、显示加载指示器和可能捕获错误。为了实现功能组件在组件挂载上的功能，我们使用带有空依赖数组的`useEffect`钩子。我们收集在使用我们的`useState`钩子重新呈现后需要持久化的变量，并且我们有条件地呈现一个加载和/或错误消息。大致如下所示(为了使示例更简单，我省略了错误处理):

在这种方法中，有几件事情是可以的，如果我被要求在企业级项目的公关中审查这一点，有几件事情会让我感到毛骨悚然。

**好东西**。我们已经与 linter 和解，我们的异步函数在`useEffect`钩子中，同时保持回调函数名义上同步，依赖数组为空。我总是喜欢看到一个空的依赖数组，因为它更清楚地表明这种效应应该只发生在组件挂载和组件挂载上。此外，我们将不可预测的 API 调用包装在 try catch 块中，因此任何意外行为都在一个小的本地错误边界内。

**坏东西**。对我个人来说，冗长的`useEffect`是初学者 React 程序员的标志。首先，你非常直率地依赖一个副作用来正确地呈现你的组件。另一件事是，你让你的同事通读一段封装很差的代码——也许他们不在这里是因为与你的代码块有关的任何东西，但他们只是浪费了宝贵的时间来解释乍一看可能是任何东西的东西。**最重要的是——这也是我不会以这种特殊方式处理它的主要原因——为了在严格依赖于这个组件的单元测试中涵盖这种行为变得不可能了**。您必须模拟 API 调用，即使这样，您也必须为您的 html 引入测试 id，并验证它在文档中是否存在。哦，你也渲染和重新渲染一个组件中间测试，并希望`useEffect`挂钩工作。首先——它当然可以工作，你不应该测试第三方库，其次，你刚刚在单元测试中创建了一个黑盒测试。恭喜你，你的单元测试是一个集成测试，可能会加倍努力，因为这应该包含在端到端测试中。

# 第二章:清算

由于我们理所当然地对“简单”的方法不满意，我们该如何重构这段代码呢？简单地说，我将要提出的解决方案符合一个持续的项目，需要几个团队与各种类型和规模的程序员一起工作，持续数月。

随着 React hooks 的出现，对我来说，就代码的美学效果而言，Redux 已经成为一个更可行的解决方案。我不会详细介绍 redux 是如何工作的，而是直接开始实现它。跑步后

```
yarn add redux react-redux @reduxjs/toolkit
```

我们应该上路了。

您需要做的第一件事是在您想要操作的区域周围包裹一个 redux `Provider`组件。将它包装在顶层是安全的，因为 redux 的性能非常好，不会在全局存储改变时触发不必要的重新呈现(就像如果使用 React Context API 会发生的情况一样)。

存储对象由我们提供。利用`redux-toolkit`的一些优势创建的商店大致如下。

没什么特别的，我们使用`configureStore`函数来创建一个我们写的 reducers 的存储。为了让几个团队同时管理和操作顶级减速器，最佳做法是将它们分成几个部分。下面是用另一个叫做`createSlice`的工具包实用函数创建的一个非常基本的切片。

务必仔细阅读官方文件[中`createSlice`提供的所有信息](https://redux-toolkit.js.org/api/createslice)。我想在这里提到的是，虽然看起来你打破了做事的流动方式，直接改变了不可变的状态，但你实际上做的只是在引擎盖下使用`[immer](https://github.com/immerjs/immer)`，你的状态实际上保持不变。`createSlice`自动创建您可以在任何地方从您的代码调用的动作和特定模块的缩减器——一个易于管理的状态和缩减器逻辑“切片”,您可以使用它来封装每个业务关注的逻辑。

但是，我们还没有完成。我们仍然希望保持我们的组件更干净，并将异步逻辑移入我们的异步`thunks`。我们可以使用上面的逻辑，并在适当的时候在我们的组件内部调用它，但是仅仅这样，我们并没有从我们的可重用组件中完全抽象出实现。

我们实际上想做的是使用`createAsyncThunk`，尽管它有许多值得探索的选项，但一个非常简单的实现看起来像下面的代码:

所以现在我们有了异步数据获取所需的完整逻辑，它使用(希望)已经测试过的、值得信赖的 reducer 逻辑。说到[测试](https://redux.js.org/usage/writing-tests)，我将在另一篇文章中讨论这些，但是现在我们已经触及了`createAsyncThunk`和`createSlice`提供的东西的表面，以及我们一直以来的主要目标是什么。我们的逻辑是:

*   装入胶囊
*   可试验的
*   可靠的
*   有据可查

在我们的组件中使用它将如下所示:

向上滚动，将它与我们开始时的内容进行比较。事实上，我们用更少的污染组件的手绘代码实现了更多。`useSelector`钩子确保我们的组件状态保持最新，我们在组件内部所要做的就是调度我们的 thunk。

# 第三章:它的主旨

我喜欢这种方法的一点是，这最后一步可以由完全不熟悉整个 redux 流程的人来完成，切片逻辑被完全封装，因此不同的开发人员和不同的团队可以互不干涉，同时开发全球可用的功能。

我们得到的一个额外好处是，经过良好测试的 reducer 动作被封装的、易于测试的逻辑块(thunks)所使用，这些逻辑块又被可靠的方法在我们的组件内部调用。

我要说的是，这些 thunks 通常被分派到`onClick`或组件挂载上，这意味着我们几乎不必花时间在最终产品(组件)内部对它们进行单元测试，因为它们已经被 *a)* 自行测试过，并且 *b)* 由`useEffect`钩子或用户与浏览器的交互调用——这些都是我们可以完全信任的事情，因为脸书(React)和谷歌(Google)*的团队可能在发布他们的软件之前已经做了尽职调查。*

# 结论

我希望我已经为您提供了足够的精神食粮，并说服您探索 redux 工具包。这真的是一个了不起的包，它在将 redux 实现补充到 React 应用程序方面做得很好。我仅仅触及了`createSlice`和`createAsyncThunk`的皮毛，我还欠你一个关于如何准确地对它们进行单元测试的解释，但是我会把它留到下一次。此外，我已经忽略了一个真正强大的方法，我们可以利用`createAsyncThunk`提供的承诺生命周期行为，但同样，我希望在未来将其作为一个更高级的用例。

*如果你喜欢这篇文章或者只是想扩大你的社交网络，可以随时登陆* [*twitter*](https://twitter.com/SNimcevic) *或者*[*LinkedIn*](https://www.linkedin.com/in/sini%C5%A1a-nim%C4%8Devi%C4%87-5b438996/)*。*