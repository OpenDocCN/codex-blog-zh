<html>
<head>
<title>ETL Demystified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ETL去神秘化</h1>
<blockquote>原文：<a href="https://medium.com/codex/etl-demystified-409ed1168345?source=collection_archive---------9-----------------------#2022-02-25">https://medium.com/codex/etl-demystified-409ed1168345?source=collection_archive---------9-----------------------#2022-02-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="fb81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ETL用几句话解释了</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/70762cadd3f53782208fbf74fccee09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XAz-EHwTNfdiFvM8gTKmJg.png"/></div></div></figure><p id="a858" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我试图用简单的语言和一些Python代码来解释ETL过程。</p><h1 id="fd36" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">什么是ETL？</h1><p id="11ec" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在计算中，ETL代表提取、转换、加载。它是将数据从一个或多个源复制到目标系统的一般过程，目标系统以不同于源的方式或在不同于源的上下文中表示数据。</p><h1 id="b0c6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">ETL是如何工作的？</h1><h2 id="a339" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">在这里，我们将逐步了解ETL过程是如何工作的:</h2><h2 id="ba77" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">步骤1)提取</h2><p id="4bc3" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">数据从源系统中提取出来，并在提取过程中放置在临时区域中。如果需要任何转换，它们都在临时区域中执行，这样就不会损害源系统的性能。如果损坏的数据直接从源转移到数据仓库数据库，回滚将会很困难。在将提取的数据移入数据仓库之前，可以在临时区域对其进行验证。</p><p id="0a53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据仓库可以将具有不同硬件、数据库管理系统、操作系统和通信协议的系统结合起来。数据仓库必须将具有不同DBMS、硬件、操作系统和通信协议的系统结合起来。来源可能包括遗留程序，如大型机、定制应用程序、接触点设备(如ATM和呼叫交换机)、文本文件、电子表格、ERP、来自供应商和合作伙伴的数据等。</p><p id="b4f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在提取数据并物理加载它之前，需要一个逻辑数据映射。此数据图中显示了源数据和目标数据之间的联系。</p><h2 id="4337" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">三种数据提取方法:</h2><blockquote class="lg lh li"><p id="e83c" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated"><strong class="ih hj">部分提取</strong> —如果源系统在记录被修改时提醒您，这是获取数据的最简单方式。</p><p id="95e0" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated"><strong class="ih hj">部分提取(无更新通知)</strong> —并非所有系统都能在更新发生时发送通知；但是，它们可以指出已更改的记录，并提供这些记录的摘录。</p><p id="e264" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated"><strong class="ih hj">完整提取</strong> —某些系统根本无法确定哪些数据发生了变化。在这种情况下，从系统中获取数据的唯一方法是执行完全提取。这种方法要求手头有一份<br/>相同格式的先前摘录的备份，以便识别已经完成的更改。</p></blockquote><p id="9b16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论采用哪种方法，提取都不应该对源系统的性能或响应时间产生影响。这些是实时生产数据库。任何放缓或锁定都可能对公司的底线产生影响。</p><h2 id="86a3" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">步骤2)转型</h2><p id="7c78" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">从源服务器检索的数据是原始的，在其原始状态下不可用。因此，必须对其进行清理、映射和转换。实际上，这是ETL过程增加价值和转换数据以产生有意义的BI报告的关键步骤。</p><p id="62cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个关键的ETL概念，其中您将一组函数应用于提取的数据。<strong class="ih hj">直接移动</strong>或<strong class="ih hj">通过dat </strong> a是不需要任何转换的数据类型。</p><p id="e5e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在转换步骤中对数据执行定制操作。例如，假设客户想要数据库中不存在的销售收入总额。或者如果表中的名字和姓氏在不同的列中。在加载之前，可以将它们连接起来。</p><p id="1fb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是数据完整性问题的一些示例:</p><blockquote class="lg lh li"><p id="2150" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">同一个人的不同拼法，如Prashant，Parshant等。</p><p id="4cb5" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">一个公司名称有很多种表示方式，比如Google，Google Inc。</p><p id="624a" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">使用了各种名称，如克里弗兰和克利夫兰。</p><p id="bd5e" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">对于同一个客户，不同的应用程序可能会产生多个帐号。</p><p id="961c" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">一些需要数据的文件是空白的。</p></blockquote><h2 id="6521" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">步骤3)装载</h2><p id="b8ca" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">ETL过程的最后一步是将数据加载到目标数据仓库数据库中。在典型的数据仓库中，大量数据在相对较短的时间内被加载。因此，加载过程应该针对性能进行优化。</p><p id="948e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在发生加载故障时，应准备好恢复程序，以便操作可以从故障点重新开始，而不会损害数据完整性。数据仓库管理员必须根据服务器性能监控、继续和停止负载。</p><h2 id="a22a" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">装载类型:</h2><blockquote class="lg lh li"><p id="6939" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated"><strong class="ih hj">初始加载</strong> —填充所有的<br/>数据仓库表</p><p id="d7b9" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated"><strong class="ih hj">增量负载</strong> —根据需要定期实施持续的<br/>修改</p><p id="c08d" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated"><strong class="ih hj">完全刷新</strong> —清除一个或多个表格的内容<br/>并用新数据重新加载它们</p></blockquote><h2 id="69f5" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">负载验证</h2><blockquote class="lg lh li"><p id="ed1c" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">检查关键字段数据是否缺失或为空。</p><p id="77c4" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">应该测试基于目标表的建模视图。</p><p id="bdc4" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">检查组合值3和计算值。</p><p id="401a" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">维度和历史表中的数据检查。</p><p id="9bf3" class="if ig lj ih b ii ij ik il im in io ip lk ir is it ll iv iw ix lm iz ja jb jc hb bi translated">检查加载的事实和维度表上的BI报告。</p></blockquote><h1 id="9898" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用PythonScript设置ETL</h1><p id="e795" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">因此，您必须执行从几个数据库到一个数据仓库的基本提取转换加载(ETL ),以便为商业智能进行数据聚合。有几个可用的ETL包，您认为对于您的基本用例来说太多了。</p><p id="fe5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将向您展示如何从MySQL、SQL-server中提取数据。使用Python 3.6，转换数据并将其加载到SQL-server(数据仓库)中。</p><p id="829e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们必须为我们的项目创建一个目录:</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="c65e" class="ks jq hi lo b fi ls lt l lu lv">python_etl<br/>    |__main.py<br/>    |__db_credentials.py<br/>    |__variables.py<br/>    |__sql_queries.py<br/>    |__etl.py</span></pre><p id="f4fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">要使用Python设置ETL，您需要在项目目录中生成以下文件</strong>。</p><ul class=""><li id="5069" class="lw lx hi ih b ii ij im in iq ly iu lz iy ma jc mb mc md me bi translated"><strong class="ih hj"> db_credentials.py: </strong>应该拥有连接到所有数据库所需的所有信息。如数据库密码、端口号等。</li><li id="762d" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated"><strong class="ih hj"> sql_queries.py: </strong>所有提取和加载字符串格式数据的常用数据库查询都应该可用。</li><li id="acbf" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated"><strong class="ih hj"> etl.py: </strong>连接到数据库，通过执行所有必要的过程来执行所需的查询。</li><li id="394c" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated"><strong class="ih hj"> main.py: </strong>负责管理操作流程，按照指定的顺序执行必要的操作。</li></ul><p id="8fd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在sql_queries.py的这个部分中，这是我们将要存储所有sql查询的地方，这些查询用于从源数据库中提取并导入到我们的目标数据库(数据仓库)中</p><ul class=""><li id="c229" class="lw lx hi ih b ii ij im in iq ly iu lz iy ma jc mb mc md me bi translated">Python到MySQL的连接器:<a class="ae mk" href="https://dev.mysql.com/doc/connector-python/en/connector-python-introduction.html" rel="noopener ugc nofollow" target="_blank"> MySQL-connector-python </a></li><li id="2d85" class="lw lx hi ih b ii mf im mg iq mh iu mi iy mj jc mb mc md me bi translated">Python到Microsoft SQL Server的连接器:<a class="ae mk" href="https://github.com/mkleehammer/pyodbc/wiki" rel="noopener ugc nofollow" target="_blank"> pyodbc </a></li></ul><h1 id="d9ec" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">设置数据库身份证明和变量</h1><p id="e88f" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在variables.py中，创建一个变量来记录数据仓库数据库的名称。</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="120f" class="ks jq hi lo b fi ls lt l lu lv">datawarehouse_name = 'your_datawarehouse_name'</span></pre><p id="3dd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在db_credentials.py中配置所有源和目标数据库连接字符串和凭证，如下所示。将配置保存为一个列表，以便我们可以在以后需要时通过许多数据库迭代它。</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="5fc2" class="ks jq hi lo b fi ls lt l lu lv">from variables import datawarehouse_name<br/>datawarehouse_name = 'your_datawarehouse_name'<br/># sql-server (target db, datawarehouse)<br/>datawarehouse_db_config = {<br/>  'Trusted_Connection': 'yes',<br/>  'driver': '{SQL Server}',<br/>  'server': 'datawarehouse_sql_server',<br/>  'database': '{}'.format(datawarehouse_name),<br/>  'user': 'your_db_username',<br/>  'password': 'your_db_password',<br/>  'autocommit': True,<br/>}<br/># sql-server (source db)<br/>sqlserver_db_config = [<br/>  {<br/>    'Trusted_Connection': 'yes',<br/>    'driver': '{SQL Server}',<br/>    'server': 'your_sql_server',<br/>    'database': 'db1',<br/>    'user': 'your_db_username',<br/>    'password': 'your_db_password',<br/>    'autocommit': True,<br/>  }<br/>]<br/># mysql (source db)<br/>mysql_db_config = [<br/>  {<br/>    'user': 'your_user_1',<br/>    'password': 'your_password_1',<br/>    'host': 'db_connection_string_1',<br/>    'database': 'db_1',<br/>  },<br/>  {<br/>    'user': 'your_user_2',<br/>    'password': 'your_password_2',<br/>    'host': 'db_connection_string_2',<br/>    'database': 'db_2',<br/>  },<br/>]<br/># firebird (source db)<br/>fdb_db_config = [<br/>  {<br/>    'dsn': "/your/path/to/source.db",<br/>    'user': "your_username",<br/>    'password': "your_password",<br/>  }<br/>]</span></pre><h1 id="80a9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">SQL查询</h1><p id="f359" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在sql_queries.py的这个部分中，这是我们将要存储所有sql查询的地方，这些查询用于从源数据库中提取并导入到我们的目标数据库(数据仓库)中。</p><p id="83ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们必须为每个数据库实现不同的语法，因为我们正在与多个数据平台合作。我们可以通过基于数据库类型分离查询来做到这一点。</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="b5cd" class="ks jq hi lo b fi ls lt l lu lv"># example queries, will be different across different db platform<br/>firebird_extract = ('''<br/>  SELECT fbd_column_1, fbd_column_2, fbd_column_3<br/>  FROM fbd_table;<br/>''')<br/>firebird_insert = ('''<br/>  INSERT INTO table (column_1, column_2, column_3)<br/>  VALUES (?, ?, ?)  <br/>''')<br/>firebird_extract_2 = ('''<br/>  SELECT fbd_column_1, fbd_column_2, fbd_column_3<br/>  FROM fbd_table_2;<br/>''')<br/>firebird_insert_2 = ('''<br/>  INSERT INTO table_2 (column_1, column_2, column_3)<br/>  VALUES (?, ?, ?)  <br/>''')<br/>sqlserver_extract = ('''<br/>  SELECT sqlserver_column_1, sqlserver_column_2, sqlserver_column_3<br/>  FROM sqlserver_table<br/>''')<br/>sqlserver_insert = ('''<br/>  INSERT INTO table (column_1, column_2, column_3)<br/>  VALUES (?, ?, ?)  <br/>''')<br/>mysql_extract = ('''<br/>  SELECT mysql_column_1, mysql_column_2, mysql_column_3<br/>  FROM mysql_table<br/>''')<br/>mysql_insert = ('''<br/>  INSERT INTO table (column_1, column_2, column_3)<br/>  VALUES (?, ?, ?)  <br/>''')<br/># exporting queries<br/>class SqlQuery:<br/>  def __init__(self, extract_query, load_query):<br/>    self.extract_query = extract_query<br/>    self.load_query = load_query<br/># create instances for SqlQuery class<br/>fbd_query = SqlQuery(firebird_extract, firebird_insert)<br/>fbd_query_2 = SqlQuery(firebird_extract_2, firebird_insert_2)<br/>sqlserver_query = SqlQuery(sqlserver_extract, sqlserver_insert)<br/>mysql_query = SqlQuery(mysql_extract, mysql_insert)<br/># store as list for iteration<br/>fbd_queries = [fbdquery, fbd_query_2]<br/>sqlserver_queries = [sqlserver_query]<br/>mysql_queries = [mysql_query]</span></pre><h1 id="1365" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">提取转换负载</h1><p id="4929" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">要使用Python为上述数据源设置ETL，您需要以下模块:</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="51b9" class="ks jq hi lo b fi ls lt l lu lv"># python modules<br/> import mysql.connector<br/> import pyodbc<br/> import fdb<br/># variables<br/> from variables import datawarehouse_name</span></pre><p id="1ef3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用两种技术:etl()和etl_process()。</p><p id="e40c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">etl_process()是建立数据库源连接并基于数据库平台调用etl()方法的过程。</p><p id="da07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二种方法是etl()方法，它首先运行提取查询，然后将SQL数据存储在变量数据中，并将其插入到目标数据库中，这就是我们的数据仓库。数据转换可以通过改变类型元组的数据变量来完成。</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="f701" class="ks jq hi lo b fi ls lt l lu lv">def etl(query, source_cnx, target_cnx):<br/>  # extract data from source db<br/>  source_cursor = source_cnx.cursor()<br/>  source_cursor.execute(query.extract_query)<br/>  data = source_cursor.fetchall()<br/>  source_cursor.close()<br/>  # load data into warehouse db<br/>  if data:<br/>    target_cursor = target_cnx.cursor()<br/>    target_cursor.execute("USE {}".format(datawarehouse_name))<br/>    target_cursor.executemany(query.load_query, data)<br/>    print('data loaded to warehouse db')<br/>    target_cursor.close()<br/>  else:<br/>    print('data is empty')<br/>def etl_process(queries, target_cnx, source_db_config, db_platform):<br/>  # establish source db connection<br/>  if db_platform == 'mysql':<br/>    source_cnx = mysql.connector.connect(**source_db_config)<br/>  elif db_platform == 'sqlserver':<br/>    source_cnx = pyodbc.connect(**source_db_config)<br/>  elif db_platform == 'firebird':<br/>    source_cnx = fdb.connect(**source_db_config)<br/>  else:<br/>    return 'Error! unrecognised db platform'<br/>  # loop through sql queries<br/>  for query in queries:<br/>    etl(query, source_cnx, target_cnx)<br/>  # close the source db connection<br/>  source_cnx.close()</span></pre><h1 id="395f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">把所有东西放在一起</h1><p id="6611" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">现在，在下一步中，我们可以遍历main.py中的所有凭证，并对所有数据库执行etl。</p><p id="9945" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们必须导入所有必需的变量和方法:</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="9a7c" class="ks jq hi lo b fi ls lt l lu lv"># variables<br/>  from db_credentials import datawarehouse_db_config, <br/>  sqlserver_db_config, mysql_db_config, fbd_db_config<br/>  from sql_queries import fbd_queries, sqlserver_queries, mysql_queries<br/>  from variables import *<br/> # methods<br/>  from etl import etl_process</span></pre><p id="9f0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个文件中的代码负责遍历凭证，以便连接到数据库并使用Python操作执行必要的ETL。</p><pre class="je jf jg jh fd ln lo lp lq aw lr bi"><span id="7c00" class="ks jq hi lo b fi ls lt l lu lv">def main():<br/>  print('starting etl')<br/>  # establish connection for target database (sql-server)<br/>  target_cnx = pyodbc.connect(**datawarehouse_db_config)<br/>  # loop through credentials<br/>  # mysql<br/>  for config in mysql_db_config: <br/>    try:<br/>      print("loading db: " + config['database'])<br/>      etl_process(mysql_queries, target_cnx, config, 'mysql')<br/>    except Exception as error:<br/>      print("etl for {} has error".format(config['database']))<br/>      print('error message: {}'.format(error))<br/>      continue<br/>  # sql-server<br/>  for config in sqlserver_db_config: <br/>    try:<br/>      print("loading db: " + config['database'])<br/>      etl_process(sqlserver_queries, target_cnx, config, 'sqlserver')<br/>    except Exception as error:<br/>      print("etl for {} has error".format(config['database']))<br/>      print('error message: {}'.format(error))<br/>      continue<br/>  # firebird<br/>  for config in fbd_db_config: <br/>    try:<br/>      print("loading db: " + config['database'])<br/>      etl_process(fbd_queries, target_cnx, config, 'firebird')<br/>    except Exception as error:<br/>      print("etl for {} has error".format(config['database']))<br/>      print('error message: {}'.format(error))<br/>      continue<br/>  target_cnx.close()<br/>if __name__ == "__main__":<br/>  main()</span></pre><p id="9e6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在您的终端中，键入python main.py，您就已经使用纯python脚本创建了一个ETL。</p><h1 id="4788" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">最后的想法</h1><p id="c1ac" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我希望这篇文章对您有所帮助，让您对ETL有一个全新的认识，同时使您能够更好地理解它，并在今后更有效地使用它。如果能听到您关于您最喜欢的ETL工具以及您看到的占据数据仓库中心舞台的解决方案的消息，那将是非常好的。</p></div></div>    
</body>
</html>