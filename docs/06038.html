<html>
<head>
<title>Spring Boot Test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot试验</h1>
<blockquote>原文：<a href="https://medium.com/codex/spring-boot-test-42e67d2eae8c?source=collection_archive---------3-----------------------#2022-04-07">https://medium.com/codex/spring-boot-test-42e67d2eae8c?source=collection_archive---------3-----------------------#2022-04-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/cdecda4868eb129822f514d2def63ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*ZZ2T-YrHsPlX37hVhd-tFw.jpeg"/></div></figure><div class=""/><p id="43a0" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Spring Boot附带了一整套测试工具，如单元测试、集成测试、断言和模拟。est支持由两个模块提供:<code class="du jk jl jm jn b">spring-boot-test</code>包含核心项，<code class="du jk jl jm jn b">spring-boot-test-autoconfigure</code>支持测试的自动配置，但大多数开发人员使用的<code class="du jk jl jm jn b">spring-boot-starter-test</code>既有Spring Boot测试模块，也有JUnit Jupiter、AssertJ、Hamcrest和许多其他有用的库。</p><pre class="jo jp jq jr fd js jn jt ju aw jv bi"><span id="b537" class="jw jx hp jn b fi jy jz l ka kb">&lt;dependency&gt;     <br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     <br/>    &lt;artifactId&gt;<strong class="jn hq">spring-boot-starter-test</strong>&lt;/artifactId&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;     <br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;junit&lt;/groupId&gt;<br/>    &lt;artifactId&gt;junit&lt;/artifactId&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="75bf" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du jk jl jm jn b">spring-boot-starter-test</code>“Starter”(在<code class="du jk jl jm jn b">test</code> <code class="du jk jl jm jn b">scope</code>中)包含以下提供的库:</p><p id="6a6e" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kc" href="https://junit.org/junit5/" rel="noopener ugc nofollow" target="_blank"><strong class="io hq">JUnit 5</strong></a><strong class="io hq">:</strong>Java应用的单元测试库</p><p id="91b7" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kc" href="https://docs.spring.io/spring-framework/docs/5.3.17/reference/html/testing.html#integration-testing" rel="noopener ugc nofollow" target="_blank"> <strong class="io hq">春季测试</strong> </a> <strong class="io hq"> &amp; Spring Boot测试:</strong>对Spring Boot应用程序的实用程序和集成测试支持。</p><p id="bec8" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kc" href="https://assertj.github.io/doc/" rel="noopener ugc nofollow" target="_blank"><strong class="io hq">AssertJ</strong></a><strong class="io hq">:</strong>AssertJ提供了一组丰富的断言，真正有用的错误消息，提高了测试代码的可读性，并被设计成在您最喜欢的IDE中超级容易使用。</p><p id="e12b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kc" href="https://github.com/hamcrest/JavaHamcrest" rel="noopener ugc nofollow" target="_blank"><strong class="io hq">ham crest</strong></a><strong class="io hq">:</strong>ham crest是一个用于编写匹配器对象的框架，允许以声明方式定义“匹配”规则。(也称为约束或谓词)。</p><p id="6bd9" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kc" href="https://site.mockito.org/" rel="noopener ugc nofollow" target="_blank"><strong class="io hq">mock ITO</strong></a><strong class="io hq">:</strong>一个Java mocking框架，让你用干净&amp;简单的API编写漂亮的测试。Mockito测试可读性很强，并且会产生干净的验证错误。</p><p id="483f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kc" href="https://github.com/skyscreamer/JSONassert" rel="noopener ugc nofollow" target="_blank"><strong class="io hq">JSONassert</strong></a><strong class="io hq">:</strong>一个JSON的断言库，帮助编写JSON测试，就像你在比较一个字符串一样。在幕后，JSONassert将字符串转换成JSON对象，并将逻辑结构和数据与实际的JSON进行比较</p><p id="eafc" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kc" href="https://github.com/jayway/JsonPath" rel="noopener ugc nofollow" target="_blank"><strong class="io hq">JSON path</strong></a><strong class="io hq">:</strong>JSON path是一种针对JSON的查询语言，其特性类似于针对XML的<a class="ae kc" href="https://en.wikipedia.org/wiki/XPath" rel="noopener ugc nofollow" target="_blank"> XPath </a>。JSONPath用于从JSON文档中选择和提取子部分。</p><p id="2e43" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用这些工具，您可以准备一组自动化的功能测试。他们将帮助你测试、模拟和评估基于任何用例的不同场景。使用Spring Boot很容易实现两种常见的功能测试，包括单元测试和集成测试。</p><h1 id="94c4" class="kd jx hp bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">软件测试类型</h1><p id="9c6e" class="pw-post-body-paragraph im in hp io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">软件测试通常分为两大类:功能测试和非功能测试。</p><figure class="jo jp jq jr fd hk er es paragraph-image"><div class="er es hg"><img src="../Images/a378365e0d5198d2631fbe294e53adc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*bwkU0cnZBOjsnOiDiOMZXQ.png"/></div></figure><p id="9362" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">功能测试包括软件应用程序功能方面的测试，以确保您是否得到了想要的结果。另一方面，非功能性测试评估应用程序的其他方面，比如性能、可靠性、可用性、安全性等等，这可以在很大程度上提高我们软件的质量。在本文中，我们将关注两种主要的功能测试，其他的并不在本文的讨论范围之内。</p><h1 id="7ff6" class="kd jx hp bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">功能测试</h1><h2 id="9013" class="jw jx hp bd ke lf lg lh ki li lj lk km ix ll lm kq jb ln lo ku jf lp lq ky lr bi translated">单元测试</h2><p id="b65a" class="pw-post-body-paragraph im in hp io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">单元测试包括测试你的软件所使用的类、组件或模块的单个功能和方法。这很重要，因为我们可以在单元测试级别发现更多的缺陷。JUnit作为test starter的一部分，帮助我们在Spring Boot应用程序中进行单元测试。</p><p id="3de6" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">编写一个好的单元测试需要一些经验，但是随着时间的推移，你会有信心覆盖你正在测试的每一个单元的所有可能的情况，并且你会感谢你在前进中所花费的时间。</p><p id="8cc7" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有了<code class="du jk jl jm jn b">@SpringBootTest</code>作为注释，您已经可以开始编写您的第一个单元测试了。请记住，为了让spring boot和JUnit一起工作，我们需要使用<code class="du jk jl jm jn b">@ExtendWith(SpringExtension.class)</code>来代替<code class="du jk jl jm jn b">@RunWith</code>，但是由于<code class="du jk jl jm jn b">@SpringBootTest</code>它已经被处理了。</p><pre class="jo jp jq jr fd js jn jt ju aw jv bi"><span id="cb18" class="jw jx hp jn b fi jy jz l ka kb">@SpringBootTest<br/><strong class="jn hq">class </strong>SpringbootApplicationTests {<br/><br/>   @Autowire<br/>   StudentService <strong class="jn hq">studentService</strong>;<br/><br/>   @DisplayName(<strong class="jn hq">"Student service find by Id test"</strong>)<br/>   @Test<br/>   <strong class="jn hq">void </strong>testFindStudent_Successfull_returnStudent() {<br/>      <em class="ls">assertEquals</em>(<strong class="jn hq">"XX1"</strong>, <strong class="jn hq">studentService</strong>.findStudentById(<strong class="jn hq">"XX1"</strong>).getId());<br/>   }<br/><br/>}</span></pre><p id="efda" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这种方法的唯一问题是，为了有所有的注入和Spring Boot相关的布线，你将需要启动一个完整的Spring Boot应用程序，这将使测试过程缓慢。一个解决方案是使用其他注入方式，比如构造函数，这样你就不再需要<code class="du jk jl jm jn b">@SpringBootTest</code>了。</p><p id="7834" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">假设您有这样一个简单的服务:</p><pre class="jo jp jq jr fd js jn jt ju aw jv bi"><span id="5bf9" class="jw jx hp jn b fi jy jz l ka kb">@Service<br/><strong class="jn hq">public class </strong>StudentService {<br/><br/>    @Autowired<br/>    StudentRepository <strong class="jn hq">studentRepository</strong>;<br/><br/>    <strong class="jn hq">public </strong>Student findStudentById( String id ){<br/>        <strong class="jn hq">return studentRepository</strong>.findById(id).get();<br/>    }<br/><br/>}</span></pre><p id="1df4" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您使用JUnit5来避免运行整个spring boot应用程序，另一个解决方案是使用<code class="du jk jl jm jn b">@ExtendWith(MockiatoExtension.class)</code>，它将帮助您注入您想要测试的单元。</p><pre class="jo jp jq jr fd js jn jt ju aw jv bi"><span id="02a8" class="jw jx hp jn b fi jy jz l ka kb"><strong class="jn hq">@ExtendWith(MockitoExtension.class)</strong><br/><strong class="jn hq">class </strong>SpringbootApplicationTests {<br/><br/>   @InjectMocks<br/>   StudentService <strong class="jn hq">studentService</strong>;<br/><br/>   @Mock<br/>   StudentRepository <strong class="jn hq">studentRepository</strong>;<br/><br/>   @DisplayName(<strong class="jn hq">"Student service find by Id test"</strong>)<br/>   @Test<br/>   <strong class="jn hq">void </strong>testFindStudent_Successfull_returnStudent() {<br/>     // Mocking repository<br/>     <em class="ls">when</em>(<strong class="jn hq">studentRepository</strong>.findById(<strong class="jn hq">"XX1"</strong>))<br/>        .thenReturn(Optional.<em class="ls">of</em>(<strong class="jn hq">new </strong>Student(<strong class="jn hq">"XX1"</strong>,<strong class="jn hq">"John"</strong>,10L)));</span><span id="7358" class="jw jx hp jn b fi lt jz l ka kb">     // Asserting result<br/>     <em class="ls">assertEquals</em>(<strong class="jn hq">"XX1"</strong>, <strong class="jn hq">studentService</strong>.findStudentById(<strong class="jn hq">"XX1"</strong>).getId());<br/>   }<br/><br/>}</span></pre><p id="bf71" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这种情况下，<code class="du jk jl jm jn b">@InjectMock</code>将帮助你自动连接你需要测试的单元，而<code class="du jk jl jm jn b">@Mock</code>可以用来模拟单元内部的依赖关系。被模仿的对象将模仿真实的实现，以帮助我们的测试更加关注被测试的单元，而不是它们所具有的依赖性。最后，我们使用了<em class="ls"> assertEquals </em>来查看结果是否符合预期，如果符合，测试将会通过。</p><p id="6a47" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于JUnit 4，您可以使用这个<code class="du jk jl jm jn b">@RunWith(MockitoJUnitRunner.class)</code>注释。剩下的和JUnit 5差不多。</p><pre class="jo jp jq jr fd js jn jt ju aw jv bi"><span id="76bb" class="jw jx hp jn b fi jy jz l ka kb"><strong class="jn hq">@RunWith(MockitoJUnitRunner.class)</strong><br/><strong class="jn hq">class </strong>SpringbootApplicationTests {<br/>    ...<br/>}</span></pre><h2 id="9a66" class="jw jx hp bd ke lf lg lh ki li lj lk km ix ll lm kq jb ln lo ku jf lp lq ky lr bi translated">集成测试</h2><p id="3e86" class="pw-post-body-paragraph im in hp io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">另一方面，集成测试验证应用程序使用的不同模块或服务能够很好地协同工作。这些类型的测试运行起来更加昂贵，因为它们需要启动并运行应用程序的多个部分。</p><p id="1e13" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">假设我们的应用程序中有一个如下所示的控制器，我们希望通过调用该API来进行集成测试。这个测试可以涉及多个模块和类，我们将得到他们一起工作的结果。</p><pre class="jo jp jq jr fd js jn jt ju aw jv bi"><span id="1036" class="jw jx hp jn b fi jy jz l ka kb">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)<br/>public class <!-- -->SpringBootIntegrationTest<!-- -->{<br/><br/>    @LocalServerPort<br/>    private int port;<br/><br/>    @Autowired<br/>    private TestRestTemplate restTemplate;<br/><br/>    @Test<br/>    public <strong class="jn hq">void </strong>testGetStudentById_success_returnStudent() <br/>            <strong class="jn hq">throws </strong>Exception {<br/>        <!-- -->ResponseEntity&lt;Student&gt; response = <!-- -->this.restTemplate<br/>           .getForObject("http://localhost:" <br/>                + port <br/>                + "<strong class="jn hq">/student/find-by-id?id=XX1</strong>"<br/>		, <!-- -->Student<!-- -->.class);</span><span id="4b29" class="jw jx hp jn b fi lt jz l ka kb"><em class="ls">         assertEquals</em>(<strong class="jn hq">"XX1"</strong>, response.getBody().getId());<br/>    }<br/>}</span></pre><p id="afe6" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这个解决方案将运行一个完整的Spring boot应用程序，我们可以使用TestRestTemplate来检查API调用的结果。正如你所看到的，你只需要设置<code class="du jk jl jm jn b">@SpringBootTest</code>就可以开始了。拥有<code class="du jk jl jm jn b">webEnvironment</code>并不重要，只是有助于避免与任何其他运行环境应用的冲突。</p><p id="224c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">还有另一个解决方案有助于更快地运行测试。在这种方法中，我们根本不启动服务器，而是只测试它下面的一层，在这一层，Spring处理传入的HTTP请求，并将它交给您的控制器。要做到这一点，使用Spring的<code class="du jk jl jm jn b">MockMvc</code>,并通过使用测试用例上的<code class="du jk jl jm jn b">@AutoConfigureMockMvc</code>注释来请求注入。</p><pre class="jo jp jq jr fd js jn jt ju aw jv bi"><span id="b1e3" class="jw jx hp jn b fi jy jz l ka kb">@SpringBootTest<br/><strong class="jn hq">@AutoConfigureMockMvc</strong><br/><strong class="jn hq">public class </strong>SpringBootIntegrationTest {<br/><br/>    @Autowired<br/>    <strong class="jn hq">private MockMvc mockMvc;</strong><br/><br/>    @Test<br/>    <strong class="jn hq">public void </strong>testGetStudentById_success_returnStudent() <strong class="jn hq">throws </strong>Exception {<br/>        <strong class="jn hq">this</strong>.<strong class="jn hq">mockMvc<br/>            </strong>.perform(<em class="ls">get</em>(<strong class="jn hq">"/student/find-by-id?id=XX1"</strong>))<br/>            .andExpect(<em class="ls">status</em>().isOk());<br/>    }<br/><br/>}</span></pre><p id="886f" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这些是通过Spring Boot测试启动程序及其提供的工具创建单元测试和集成测试的基本样本。正如您所猜测的，有许多特性适合您的特定使用情形，您可以参考不同的参考资料来找到这些特性。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><p id="fd14" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">希望这篇文章对你有所帮助，请支持我，为这个故事鼓掌。如果你不知道事情是这样的:</p><figure class="jo jp jq jr fd hk er es paragraph-image"><div class="er es mb"><img src="../Images/d8ead00c53af87b68a953ecb2b581ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T6P5FYxSPXlU4md4.gif"/></div></figure><p id="c149" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">或者在这里给我买杯咖啡<a class="ae kc" href="https://www.buymeacoffee.com/fpashaee" rel="noopener ugc nofollow" target="_blank">！</a></p></div></div>    
</body>
</html>