<html>
<head>
<title>Managing Your Data Lifecycle with Time to Live Tables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用生存时间表管理数据生命周期</h1>
<blockquote>原文：<a href="https://medium.com/codex/managing-your-data-lifecycle-with-time-to-live-tables-e06dd3cc45ad?source=collection_archive---------10-----------------------#2021-07-26">https://medium.com/codex/managing-your-data-lifecycle-with-time-to-live-tables-e06dd3cc45ad?source=collection_archive---------10-----------------------#2021-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c283060f92a07ad2c198b794105b6785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PbMvsyTel0hH9UEh.jpg"/></div></div></figure><p id="50fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作者:<a class="ae jo" href="https://github.com/sunxiaoguang" rel="noopener ugc nofollow" target="_blank">孙晓光</a>(知乎软件架构师，TiKV项目维护人员)</p><p id="8c38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创世:<a class="ae jo" href="https://github.com/ran-huang" rel="noopener ugc nofollow" target="_blank">黄然</a>；编辑:汤姆·万德</p><p id="932b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您的组织与日俱增；你的数据也是。更多的数据带来了更多的商机，但也带来了更高的存储成本。你想要一个更好的方法来管理成本吗？我们希望我们的开源数据库TiDB也是如此。</p><p id="0d7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://docs.pingcap.com/tidb/stable" rel="noopener ugc nofollow" target="_blank"> TiDB </a>是一个为海量数据设计的分布式SQL数据库。我们的目标是以合理的成本支持大规模数据集。在TiDB Hackathon 2020 上，我们朝着那个方向迈出了一大步。<strong class="is hj">我们引入了一个特性，</strong> <a class="ae jo" href="https://github.com/tidb-hackathon/t4" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">生存时间(TTL)表</strong> </a> <strong class="is hj">，使TiDB能够根据数据的生命周期自动管理数据的生命周期。</strong> TiDB确保其资源的每一部分都被高价值的新鲜数据所消耗。</p><p id="6510" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，<strong class="is hj">我将详细描述TTL表以及我们如何在TiDB中实现它。</strong>此外，<strong class="is hj">我将分享一些如何在开源项目中使用TTL表的例子，包括dimension reports、Kubernetes long term events storage、MQTT for IoT等。</strong>时间不等人，我们开始吧。</p><h1 id="36c3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">什么是TTL表？</h1><p id="7659" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">TiDB社区已经做出了许多努力来限制TiDB存储成本。例如，我们探索了分层管理数据存储的方法，这允许数据库将冷数据存储在更便宜的存储介质上。我们还希望通过增加数据TiDB存储的价值来降低成本。<strong class="is hj">在很多情况下，特定数据集的价值与其生命周期密切相关。</strong>数据越旧，价值越低。为了帮助TiDB存储高价值数据，我们在TiDB中引入了TTL。</p><p id="e896" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">TTL，即生存时间，是一种限制系统中数据生命周期的机制。经过指定时间后，数据将被删除。它广泛用于缓存和存储系统，如Redis、RocksDB和MyRocks。</p><p id="3fda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在TiDB中，TTL被实现为TTL表。与上面的系统类似，<strong class="is hj">TiDB中的TTL表可以自动管理写入表中数据的生命周期，无需人工干预。</strong>数据到达生命周期的终点后，会自动过期，TiDB会回收被占用的资源。这种机制将用户从繁琐的生命周期管理中解放出来，并使用更少的资源快速删除数据。</p><h1 id="c071" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我们如何在TiDB中实现TTL表</h1><p id="5348" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">考虑到TiDB的内部机制和使用复杂度，我们为数据表增加了两个配置项:生存时间(<code class="du ks kt ku kv b">TTL</code>)和生存粒度(<code class="du ks kt ku kv b">TTL_GRANULARITY</code>)。有了这两个参数，TTL表可以管理您的数据生命周期。您可以为TTL表设置两种粒度:<code class="du ks kt ku kv b">row</code>和<code class="du ks kt ku kv b">partition</code>。</p><h2 id="a97e" class="kw jq hi bd jr kx ky kz jv la lb lc jz jb ld le kd jf lf lg kh jj lh li kl lj bi translated">行粒度TTL表</h2><p id="24cf" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">TiDB使用多版本并发控制(MVCC)来控制事务并发。当您更新一系列数据时，原始数据不会立即删除，而是与新数据保存在一起，并带有时间戳以区分版本。然后，一个周期性的<a class="ae jo" href="https://docs.pingcap.com/tidb/stable/garbage-collection-overview" rel="noopener ugc nofollow" target="_blank">垃圾收集</a> (GC)过程清除过时的数据。每当TiKV对行粒度TTL表进行GC时，它还会回收符合过期条件的数据行。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/6e430aa9ea3a78fc36cb240e804750f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GunG00LdPHXl4FCV.gif"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">行粒度TTL表</figcaption></figure><p id="d12b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当TiDB将GC任务分派给TiKV时，这些任务包括对应于TTL表及其TTL配置的键范围。基于TTL配置，TiKV计算TTL密钥范围内的数据生命周期。如果TiKV找到在MVCC有效但超过TTL的数据，TiKV会在GC过程中删除这些数据并释放存储空间。</p><p id="a8af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">值得注意的是，<strong class="is hj">目前大多数TiDB表都使用</strong> <a class="ae jo" href="https://docs.pingcap.com/tidb/stable/clustered-indexes" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">非聚集索引</strong> </a> <strong class="is hj">。</strong>如果主键索引或辅助索引与记录的删除进度不一致，则已经从表中删除的一组数据可能仍然在索引中可见。当使用任何索引时，这会导致查询失败。为了解决这个问题，我们将TTL表分成两个键范围:数据和索引。<code class="du ks kt ku kv b">The TTL for data = the TTL for index + the interval between the recent two rounds of GC</code>。这样，在至少一个GC周期内，所有数据的寿命都比索引长。</p><p id="df9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了在GC期间删除过期数据之外，压缩过程也是回收过期数据的好时机。因为我们在Hackathon上的时间有限，我们只为GC实现了TTL，但是我们计划进一步优化TTL的实现。</p><p id="56d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要在行粒度创建TTL表，请使用以下语句:</p><pre class="ll lm ln lo fd lt kv lu lv aw lw bi"><span id="fde9" class="kw jq hi kv b fi lx ly l lz ma">CREATE TABLE ttl_table {<br/>    id BIGINT PRIMARY KEY AUTO_RANDOM,<br/>    author VARCHAR(255),<br/>    post VARCHAR(255)<br/>} TTL='1h', TTL_GRANULARITY='ROW';</span></pre><p id="bcdd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还可以使用<code class="du ks kt ku kv b">ALTER TABLE</code>将现有的表切换到行粒度的TTL表。</p><h2 id="1148" class="kw jq hi bd jr kx ky kz jv la lb lc jz jb ld le kd jf lf lg kh jj lh li kl lj bi translated">分区粒度TTL表</h2><p id="8f23" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">删除大量数据会消耗很多资源，所以数据库通常采用定期GC或压缩来节约资源。您可能想知道为什么不使用<code class="du ks kt ku kv b">TRUNCATE</code>更有效地删除过期数据？为了解决这个问题，我们将TTL表实现为一个特殊的分区表，它对用户是不可见的。</p><p id="dfc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">若要创建分区粒度TTL表，请运行以下语句:</p><pre class="ll lm ln lo fd lt kv lu lv aw lw bi"><span id="e5a4" class="kw jq hi kv b fi lx ly l lz ma">CREATE TABLE ttl_table {<br/>    id BIGINT PRIMARY KEY AUTO_RANDOM,<br/>    author VARCHAR(255),<br/>    post VARCHAR(255)<br/>} TTL='1d', TTL_GRANULARITY='PARTITION';</span></pre><p id="2b8b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过使用滑动窗口在分区之间切换，我们可以按时间顺序将粗粒度数据分配给多个物理分区。循环创建一个新分区，同时最早的分区被截断和删除。最旧分区中的所有过期数据都会以较低的成本被快速删除。在这个特殊的删除操作中，RocksDB直接删除被删除逻辑数据的物理文件。然后，几乎零成本地释放存储空间。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/0dfc407e7f41c9de61920a6fbd2e3da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1rv8XsIewKp30Vml.gif"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">分区粒度TTL表</figcaption></figure><p id="8c54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前，TiDB不支持将普通表切换到分区表，也不支持将一个分区表切换到另一个分区表。因此，不能将现有的表更改为分区粒度的TTL表。</p><h1 id="3869" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">在哪里使用TiDB的TTL表</h1><p id="d4ba" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在你知道了TTL表是如何工作的，你能在哪里应用它？我们修改了一些开源项目，以便他们可以使用TiDB作为存储介质，并将他们的数据存储在TTL表中。在这些系统中，TiDB可以自动维护数据生命周期，而无需系统感知。</p><h2 id="f8ab" class="kw jq hi bd jr kx ky kz jv la lb lc jz jb ld le kd jf lf lg kh jj lh li kl lj bi translated">阿帕奇麒麟</h2><p id="cb87" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">维度报告广泛用于大数据场景，为决策提供高价值、及时的数据。Apache Kylin以多维在线分析处理(MOLAP)方式处理原始数据，以提供数据分析，如切片、切片、汇总和钻取。</p><p id="6828" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Apache Kylin中，报告中使用的维度和基数越多，数据量就越大。在许多情况下，数据量远远超过了一个独立数据库所能容纳的量。久而久之，用户不太可能对过时的数据进行实时分析。旧数据失去了与业务的相关性。通过有效地清理历史数据，可以减少不必要的资源消耗。</p><p id="17ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是TTL表的用武之地。<strong class="is hj">TTL表管理维度报告数据的生命周期，并且通过TiDB的索引查询功能，简化了Apache Kylin的实现。通过统一报告数据和元数据的管理，TiDB进一步降低了管理Apache Kylin的成本。</strong></p><h2 id="a05f" class="kw jq hi bd jr kx ky kz jv la lb lc jz jb ld le kd jf lf lg kh jj lh li kl lj bi translated">耶格追踪</h2><p id="d896" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><a class="ae jo" href="https://github.com/jaegertracing/jaeger" rel="noopener ugc nofollow" target="_blank"> Jaeger Tracing </a>是一个分布式追踪平台，支持OpenTracing标准，为OpenTelemetry提供实验支持。Jaeger可以使用Cassandra和Elasticsearch作为存储后端，还提供了一个gRPC插件，用于与其他存储系统集成。</p><p id="74e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们使用插件在TiDB上运行Jaeger。<strong class="is hj"> TiDB为Jaeger带来了TiKV的高吞吐量和可扩展性。它自动管理历史跟踪数据的生命周期，降低系统运营成本。</strong></p><h2 id="c640" class="kw jq hi bd jr kx ky kz jv la lb lc jz jb ld le kd jf lf lg kh jj lh li kl lj bi translated">Kubernetes事件</h2><p id="a709" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Kubernetes <code class="du ks kt ku kv b">event</code>对象记录集群中发生的所有事件。这些事件帮助您排除异常行为并审核群集操作。当Kubernetes集群很大并且变化频繁时，您可以选择将集群事件存储在一个单独的etcd集群中。但是，当Kubernetes频繁更新时，集群会生成大量事件。由于存储空间有限，etcd集群无法记录所有的Kubernetes事件，只能记录最近发生的事件。</p><p id="d053" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了解决这个问题，<strong class="is hj">您可以将Kubernetes事件存储在TiDB中，这样可以在更长的时间内存储更多的数据。</strong>此外，<strong class="is hj"> TiDB的二级索引使您能够快速灵活地查询存储的事件。</strong>在TTL表的帮助下，TiDB中存储的历史事件自动过期，节省了你的存储空间。</p><h2 id="dcf0" class="kw jq hi bd jr kx ky kz jv la lb lc jz jb ld le kd jf lf lg kh jj lh li kl lj bi translated">MQTT服务质量</h2><p id="d98e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">消息队列遥测传输(MQTT)是用于物联网(IoT)消息传递的轻量级发布/订阅协议。由于移动和物联网设备可能具有不稳定的网络连接，因此系统需要保存消息，以便即使客户端长时间离线，消息传递仍能达到服务质量(QoS)级别1或2。</p><p id="83ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">具有内置数据过期机制的存储后端非常适合需要可靠和及时交付的应用</strong>，例如突发新闻、黄色警报和天气预报。</p><p id="574a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在黑客马拉松期间，我们采用了一个流行的MQTT代理来支持MySQL作为后端存储。由于TiDB兼容MySQL，<strong class="is hj"> TiDB的TTL表可以根据用户设置的保留周期</strong>自动删除过期的数据。</p><h1 id="b105" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">摘要</h1><p id="e14e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在一个万物互联的时代，数据量正在快速增长。如何用更少的成本支持更多的数据是所有数据库管理系统都试图回答的问题。我们对这个问题的回答是TTL表。</p><p id="1786" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于TiDB来说，这个问题的核心是如何平衡TiDB的成本和它所承载的数据价值。数据越相关越新鲜，TiDB为你的企业创造的价值就越多。毕竟时间不等人，不如给更有价值的数据腾出空间。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="b432" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mi">原载于2021年6月10日</em><a class="ae jo" href="https://pingcap.com/blog/managing-you-data-lifecycle-with-time-to-live-tables" rel="noopener ugc nofollow" target="_blank"><em class="mi">【www.pingcap.com】</em></a><em class="mi"/></p></div></div>    
</body>
</html>