<html>
<head>
<title>Basic K-Means Clustering for Food Retail</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">食品零售的基本K-均值聚类</h1>
<blockquote>原文：<a href="https://medium.com/codex/basic-k-means-clustering-for-food-retail-b3ef12507238?source=collection_archive---------8-----------------------#2022-10-05">https://medium.com/codex/basic-k-means-clustering-for-food-retail-b3ef12507238?source=collection_archive---------8-----------------------#2022-10-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c500" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我们将对食品零售数据进行聚类，首先使用典型的K-means算法，然后使用平均价格指数</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/62ab495140f482250b8bcb76830b8a0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j-B4IaX2qVOaml3C"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jn" href="https://unsplash.com/@fikrirasyid?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">菲克里·拉西德</a>拍摄的照片</figcaption></figure><h1 id="efdc" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">第1部分:一般聚类</h1><p id="982a" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">聚类是一个非常好的工具，可以根据客户、商店或产品的相似程度进行分组。今天，我们将根据价格指数、产品数量和客户数量对商店进行分类</p><h2 id="b684" class="lc jp hi bd jq ld le lf ju lg lh li jy kp lj lk ka kt ll lm kc kx ln lo ke lp bi translated">关于K均值</h2><p id="a04a" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">K-means的工作原理很简单:</p><ol class=""><li id="c0ab" class="lq lr hi ki b kj ls km lt kp lu kt lv kx lw lb lx ly lz ma bi translated">它希望在您的数据集中找到预先确定的聚类。</li><li id="5cc2" class="lq lr hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">它通过寻找“聚类中心”来做到这一点，聚类中心是属于特定聚类的所有点的算术平均值</li><li id="35e3" class="lq lr hi ki b kj mb km mc kp md kt me kx mf lb lx ly lz ma bi translated">然后它会计算出一个特定的点离哪个聚类中心最近</li></ol><p id="d975" class="pw-post-body-paragraph kg kh hi ki b kj ls ij kl km lt im ko kp mg kr ks kt mh kv kw kx mi kz la lb hb bi translated">但是K-Means是如何如此快速地计算出这些聚类的呢？我听到你问了。K-Means不使用穷举搜索方法，而是使用一种叫做<em class="mj">期望最大化的酷技术，</em>一种更直观的方法。它的工作方式如下:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mk"><img src="../Images/22ec4cd2a905f6c251c160edd805aa71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wVFt68XH1AyksSFN.jpg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><em class="ml">鸣谢:</em><a class="ae jn" href="https://www.geeksforgeeks.org/ml-expectation-maximization-algorithm/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/ml-expectation-maximization-algorithm/</a>为了这张漂亮的流程图</figcaption></figure><h2 id="36d5" class="lc jp hi bd jq ld le lf ju lg lh li jy kp lj lk ka kt ll lm kc kx ln lo ke lp bi translated">准备数据</h2><p id="2dbb" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">让我们连接到我们的数据库，我的数据存储在Microsoft Server Management Studio上，因此我将在这里连接到它:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">如果您也来自MSSQL，请记得用您的详细信息更新此代码</figcaption></figure><p id="4741" class="pw-post-body-paragraph kg kh hi ki b kj ls ij kl km lt im ko kp mg kr ks kt mh kv kw kx mi kz la lb hb bi translated">现在，我将使用SQL查询创建数据集:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="3a03" class="pw-post-body-paragraph kg kh hi ki b kj ls ij kl km lt im ko kp mg kr ks kt mh kv kw kx mi kz la lb hb bi translated">请记住，我的数据集中有大约1000条记录，所以我可以使用' * '而不会浪费太多时间。如果你有更多的记录，使用<strong class="ki hj"><em class="mj"/></strong><code class="du mo mp mq mr b">SELECT element_1, element_2 … from database group by element_1, element_2</code><strong class="ki hj"><em class="mj"/></strong>会更有效</p><p id="2245" class="pw-post-body-paragraph kg kh hi ki b kj ls ij kl km lt im ko kp mg kr ks kt mh kv kw kx mi kz la lb hb bi translated">我们必须将数据标准化，使其标准差为1，均值为0。</p><blockquote class="ms mt mu"><p id="4c3f" class="kg kh mj ki b kj ls ij kl km lt im ko mv mg kr ks mw mh kv kw mx mi kz la lb hb bi translated"><strong class="ki hj"> <em class="hi">重要</em> </strong> <em class="hi">:使用</em> <code class="du mo mp mq mr b"><em class="hi">StandardScaler</em></code> <em class="hi">功能进行分类。当你处理负数时，它也是有用的。不过不要在回归中使用它，</em> <code class="du mo mp mq mr b"><em class="hi">Normalizer</em></code>会是你在那种情况下的首选武器。</p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="650f" class="pw-post-body-paragraph kg kh hi ki b kj ls ij kl km lt im ko kp mg kr ks kt mh kv kw kx mi kz la lb hb bi translated">缩放非常重要，因为它赋予数据的每个要素(基本上是数据集中的每个列)同等的重要性。如果没有它，范围最大的值将是最重要的。</p><h2 id="dfbe" class="lc jp hi bd jq ld le lf ju lg lh li jy kp lj lk ka kt ll lm kc kx ln lo ke lp bi translated">k-均值算法</h2><p id="0624" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">第一步是导入我们将需要的所有库，它们如下:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">执行预处理和K-means算法所需的库</figcaption></figure><h2 id="67c7" class="lc jp hi bd jq ld le lf ju lg lh li jy kp lj lk ka kt ll lm kc kx ln lo ke lp bi translated"><strong class="ak">最佳聚类数</strong></h2><p id="a26b" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">为了找出将我们的数据分成多少组，我们将使用“肘形曲线”。“肘”点是曲线变平的地方，这是我们需要的集群数量。</p><p id="df10" class="pw-post-body-paragraph kg kh hi ki b kj ls ij kl km lt im ko kp mg kr ks kt mh kv kw kx mi kz la lb hb bi translated">以下是肘形曲线的代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="43aa" class="pw-post-body-paragraph kg kh hi ki b kj ls ij kl km lt im ko kp mg kr ks kt mh kv kw kx mi kz la lb hb bi translated">我的肘部曲线看起来很奇怪——从视觉上看不清楚它在哪里变平</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es my"><img src="../Images/e55d9e7555683e5b2550c5bfb6b26c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*gQB-Zu7zr6YE7elvlND02A.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">我的肘部曲线——不清楚平台从哪里开始</figcaption></figure><p id="9709" class="pw-post-body-paragraph kg kh hi ki b kj ls ij kl km lt im ko kp mg kr ks kt mh kv kw kx mi kz la lb hb bi translated">我们需要一些方法来计算出这条曲线的拐点。“膝盖”图书馆来拯救我们了。该函数使用Kneedle算法计算出肘部:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="3e98" class="pw-post-body-paragraph kg kh hi ki b kj ls ij kl km lt im ko kp mg kr ks kt mh kv kw kx mi kz la lb hb bi translated">在我的例子中，输出是<strong class="ki hj"> 5个集群，</strong>这就是我们正在做的。</p><h2 id="f912" class="lc jp hi bd jq ld le lf ju lg lh li jy kp lj lk ka kt ll lm kc kx ln lo ke lp bi translated">执行K均值</h2><p id="1985" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">现在我们已经有了所有的细节，让我们执行实际的K-Means算法:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="3bbf" class="pw-post-body-paragraph kg kh hi ki b kj ls ij kl km lt im ko kp mg kr ks kt mh kv kw kx mi kz la lb hb bi translated">太好了！现在我们有了所有的分类标签，是时候将它们添加回我们的数据集了:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="bb4c" class="pw-post-body-paragraph kg kh hi ki b kj ls ij kl km lt im ko kp mg kr ks kt mh kv kw kx mi kz la lb hb bi translated">现在，您的数据集中应该有一个额外的“集群列”。你完了！</p><p id="b12c" class="pw-post-body-paragraph kg kh hi ki b kj ls ij kl km lt im ko kp mg kr ks kt mh kv kw kx mi kz la lb hb bi translated">下面是完整的代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mm mn l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">从头到尾的基本K-Means算法</figcaption></figure></div></div>    
</body>
</html>