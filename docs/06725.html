<html>
<head>
<title>Patch encrypted libraries in Meta’s apps for Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修补安卓版Meta应用中的加密库</h1>
<blockquote>原文：<a href="https://medium.com/codex/patch-encrypted-libraries-in-metas-apps-for-android-ad3dfd35db79?source=collection_archive---------7-----------------------#2022-05-10">https://medium.com/codex/patch-encrypted-libraries-in-metas-apps-for-android-ad3dfd35db79?source=collection_archive---------7-----------------------#2022-05-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/e8c507ecff5d4ccf04267d6fbedc5095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*8EvMBcWV4p1OPUXzrlDO6Q.png"/></div></figure><div class=""/><div class=""><h2 id="ffed" class="pw-subtitle-paragraph im ho hp bd b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd dx translated"><span class="l je jf jg bm jh ji jj jk jl di"> E </span>非根手机上Meta的<strong class="ak">工作场所</strong> app中SSL解钉的例子</h2></div><h1 id="19e8" class="jm jn hp bd jo jp jq jr js jt ju jv jw iv jx iw jy iy jz iz ka jb kb jc kc kd bi translated">介绍</h1><p id="8c02" class="pw-post-body-paragraph ke kf hp kg b kh ki iq kj kk kl it km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi la translated"><span class="l je jf jg bm jh ji jj jk jl di">我</span>参加了由<strong class="kg hq"> Meta </strong>在马德里举办的网络安全课程<a class="ae lb" href="https://bountyconedu2022.splashthat.com/" rel="noopener ugc nofollow" target="_blank"> BountyConEDU </a>，课程从4月29日持续到5月2日。在前两天，我们收到了一系列关于本地、移动和网络安全的密集研讨会，从中我们获得了关于成功漏洞搜寻的有用见解。最后一天是现场黑客会议，我们被要求找出Meta产品中的漏洞和错误。在这个练习中，我在一个名为“1 bit”的团队中工作。我们能够提交三份报告。在这篇文章中，我将谈谈我的看法。</p><h1 id="4f73" class="jm jn hp bd jo jp jq jr js jt ju jv jw iv jx iw jy iy jz iz ka jb kb jc kc kd bi translated">建议</h1><p id="0c4e" class="pw-post-body-paragraph ke kf hp kg b kh ki iq kj kk kl it km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">要给Android上的库打补丁，你通常必须找到目标库，打补丁，然后重新提交应用程序。在Meta的应用中，几乎所有的库都被压缩并加密在assets/libs文件夹中的一个名为<em class="lc">“libs . spo”</em>的<em class="lc">“super pack _ OB”</em>档案中。如果您想要修补其中的一个库，您必须首先解压缩“libs.xz”归档文件，然后恢复该过程。</p><p id="1e64" class="pw-post-body-paragraph ke kf hp kg b kh ld iq kj kk le it km kn lf kp kq kr lg kt ku kv lh kx ky kz hb bi translated">这个过程包含在<em class="lc">libsupercack-JNI . so</em>的函数<em class="lc"> "readNative" </em>中，但是由于更新可能会频繁发生，所以找到一种更通用的方法来绕过这个漫长的过程并直接修补目标库可能会很有用。<strong class="kg hq">这对许多其他android应用程序也很有用。</strong></p><h2 id="9fbe" class="li jn hp bd jo lj lk ll js lm ln lo jw kn lp lq jy kr lr ls ka kv lt lu kc lv bi translated">怎么会？</h2><p id="204d" class="pw-post-body-paragraph ke kf hp kg b kh ki iq kj kk kl it km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">我在Android Studio中用一个<a class="ae lb" href="https://github.com/michelerenzullo/Workplace_SSL_Unpinning/blob/b5753d39c5c4cbad6e08a0af82afca8b071842dd/dev/test_app/MyApplication/app/src/main/java/com/example/myapplication/random.java#L11" rel="noopener ugc nofollow" target="_blank"> Java函数</a>创建了一个测试应用程序，它让我们能够R+W访问我们的目标库，因此用RandomAccessFile在我们的偏移量处修补字节。然后我们对它进行反编译，并将我们的函数注入到一个活动中，例如登录活动。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="fb0a" class="jm jn hp bd jo jp md jr js jt me jv jw iv mf iw jy iy mg iz ka jb mh jc kc kd bi translated">技术部分</h1><p id="2702" class="pw-post-body-paragraph ke kf hp kg b kh ki iq kj kk kl it km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">输出apk的目标设备是非根电话，在这个过程中，我们假设我们没有根设备(或根仿真器)。使用的app是<a class="ae lb" href="https://www.apkmirror.com/apk/facebook-2/work/work-365-0-0-30-112-release/workplace-from-meta-365-0-0-30-112-8-android-apk-download/" rel="noopener ugc nofollow" target="_blank">Workplace 365 . 0 . 0 . 30 . 112 arm 64</a>，工具是<a class="ae lb" href="https://ibotpeaches.github.io/Apktool/" rel="noopener ugc nofollow" target="_blank"> apktool </a>、<a class="ae lb" href="https://github.com/NationalSecurityAgency/ghidra/releases" rel="noopener ugc nofollow" target="_blank"> Ghidra </a>、<a class="ae lb" href="https://developer.android.com/studio" rel="noopener ugc nofollow" target="_blank"> AndroidStudio </a>、<a class="ae lb" href="https://github.com/nelenkov/android-backup-extractor" rel="noopener ugc nofollow" target="_blank"> android backup extractor </a>、MT Manager 2.10.4(或NP Manager作为备选)adb、zipalign、apksigner和smali-2.5.2。在<a class="ae lb" href="https://github.com/michelerenzullo/Workplace_SSL_Unpinning" rel="noopener ugc nofollow" target="_blank">这个存储库</a>上有一些文章中用到的文件和工具。</p><p id="7fe7" class="pw-post-body-paragraph ke kf hp kg b kh ld iq kj kk le it km kn lf kp kq kr lg kt ku kv lh kx ky kz hb bi translated">让我们把手弄脏吧！</p><p id="2af7" class="pw-post-body-paragraph ke kf hp kg b kh ld iq kj kk le it km kn lf kp kq kr lg kt ku kv lh kx ky kz hb bi translated">要查看所有解压缩的库，我们必须安装应用程序并读取内存中的数据文件夹。在根手机上，我们可以访问路径<strong class="kg hq">/data/data/com . Facebook . work/</strong>，但在非根设备上，我们将通过编辑AndroidManifest.xml并执行adb备份来备份数据:</p><ul class=""><li id="6eea" class="mi mj hp kg b kh ld kk le kn mk kr ml kv mm kz mn mo mp mq bi translated">apktool将无法反编译Meta应用程序的AndroidManifest.xml(请参见此处记录的问题<a class="ae lb" href="https://github.com/iBotPeaches/Apktool/issues/1719" rel="noopener ugc nofollow" target="_blank"/>)我们仍然可以使用<strong class="kg hq"> MT管理器</strong>或<strong class="kg hq"> NP管理器编辑AndroidManifest。</strong>它们是强大的应用程序，允许你完全逆向工程任何安卓应用程序。我在用MT Manager编辑AndroidManifest设置<strong class="kg hq"> allowBackup="true" </strong>和<strong class="kg hq"> debuggable="true" </strong>(从Android 12+开始也需要)，然后签名安装。这里已经做了<a class="ae lb" href="https://github.com/michelerenzullo/Workplace_SSL_Unpinning/tree/main/dev/allowBackup" rel="noopener ugc nofollow" target="_blank"/>。</li></ul><figure class="mr ms mt mu fd hk"><div class="bz dy l di"><div class="mv mw l"/></div></figure><ul class=""><li id="f05d" class="mi mj hp kg b kh ld kk le kn mk kr ml kv mm kz mn mo mp mq bi translated">从亚洲开发银行运行</li></ul><pre class="mr ms mt mu fd mx my mz na aw nb bi"><span id="21f7" class="li jn hp my b fi nc nd l ne nf">adb backup com.facebook.work -f backup.ab</span></pre><ul class=""><li id="2abc" class="mi mj hp kg b kh ld kk le kn mk kr ml kv mm kz mn mo mp mq bi translated">现在我们用android backup extractor解密备份，并提取tar存档。在<strong class="kg hq">apps/com . Facebook . work/r</strong>中有设备内部存储器中的所有文件<strong class="kg hq">/data/data/com . Facebook . work/</strong></li></ul><pre class="mr ms mt mu fd mx my mz na aw nb bi"><span id="e2d1" class="li jn hp my b fi nc nd l ne nf">java -jar abe.jar unpack backup.ab backup.tar </span></pre></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="7ecc" class="jm jn hp bd jo jp md jr js jt me jv jw iv mf iw jy iy mg iz ka jb mh jc kc kd bi translated">逆向工程和修补本地库</h1><p id="77b4" class="pw-post-body-paragraph ke kf hp kg b kh ki iq kj kk kl it km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">Meta使用安卓NDK在Workplace编译了<a class="ae lb" href="https://github.com/facebookincubator/fizz" rel="noopener ugc nofollow" target="_blank"> Fizz库</a>，证书验证在<a class="ae lb" href="https://github.com/facebookincubator/fizz/blob/c40e4f45e4f4d02c837c82890e0e0725b9ee29d3/fizz/client/ClientProtocol.cpp#L1944" rel="noopener ugc nofollow" target="_blank">这条线上</a>实现。可以绕过<code class="du ng nh ni my b"><a class="ae lb" href="https://github.com/facebookincubator/fizz/blob/c40e4f45e4f4d02c837c82890e0e0725b9ee29d3/fizz/client/ClientProtocol.cpp#L1942" rel="noopener ugc nofollow" target="_blank">if (state.verifier())</a></code>检查来验证任何证书</p><figure class="mr ms mt mu fd hk er es paragraph-image"><div class="er es nj"><img src="../Images/cf75ac6bb2d0e0c30267e06be7c92c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*5brLTiRcDHDxtJ0hqp8Wiw.png"/></div></figure><p id="1897" class="pw-post-body-paragraph ke kf hp kg b kh ld iq kj kk le it km kn lf kp kq kr lg kt ku kv lh kx ky kz hb bi translated">要找到在新版本中修补的字节，必须反编译库并找到新的偏移量。</p><ul class=""><li id="3e11" class="mi mj hp kg b kh ld kk le kn mk kr ml kv mm kz mn mo mp mq bi translated">在<strong class="kg hq">libx plat _ fizz _ client _ protocol Android . so</strong>中使用Ghidra或IDA Pro搜索字符串“server choose unsupported SIG scheme:”以及下面几行要修补的检查，在这个版本中偏移量为<strong class="kg hq"> 0x1d9f0 </strong></li></ul><figure class="mr ms mt mu fd hk er es paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="er es nk"><img src="../Images/8e9f065c9e8d909eafe5c05f73cf1963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bHhB_T0hdpUNhOg7BerSRQ.png"/></div></div><figcaption class="np nq et er es nr ns bd b be z dx translated">偏移量0x1D9F0字节F7 00 00 B4</figcaption></figure><ul class=""><li id="2d83" class="mi mj hp kg b kh ld kk le kn mk kr ml kv mm kz mn mo mp mq bi translated">将指令<strong class="kg hq"> cbz </strong>变为无条件<strong class="kg hq"> b </strong>跳转，注意从<strong class="kg hq"> F7 00 00 B4 </strong>变为<strong class="kg hq"> 07 00 00 14 </strong>的字节</li></ul><figure class="mr ms mt mu fd hk er es paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="er es nt"><img src="../Images/d3637e6ca4680a09842354ab061fdc8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*82WnUk7VdfOp7iznKmFO1g.png"/></div></div></figure><blockquote class="nu nv nw"><p id="f2e1" class="ke kf lc kg b kh ld iq kj kk le it km nx lf kp kq ny lg kt ku nz lh kx ky kz hb bi translated">如果你有一个根设备，这篇文章将在这里结束，你只需要把补丁库推到你的设备中，替换原来的那个。</p></blockquote></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="c200" class="jm jn hp bd jo jp md jr js jt me jv jw iv mf iw jy iy mg iz ka jb mh jc kc kd bi translated">为非根设备生成修补的apk</h1><p id="cfc4" class="pw-post-body-paragraph ke kf hp kg b kh ki iq kj kk kl it km kn ko kp kq kr ks kt ku kv kw kx ky kz hb bi translated">要在非rooted手机上修补应用程序，需要访问存储在名为<strong class="kg hq">“libs . spo”的SUPERPACK_OB档案中的<strong class="kg hq">libx plat _ fizz _ client _ protocol Android . so</strong>。</strong></p><blockquote class="nu nv nw"><p id="f96e" class="ke kf lc kg b kh ld iq kj kk le it km nx lf kp kq ny lg kt ku nz lh kx ky kz hb bi translated">“<strong class="kg hq"> libs.spo </strong>文件只是众多<strong class="kg hq"> xz </strong>档案的容器。第一个是文件“<strong class="kg hq"> libs.xz </strong>”，可以看到幻字节“FD 37 7A 58 5A 00”而在每个xz存档的幻字节之前，有这样的22个字节:</p><p id="fff6" class="ke kf lc kg b kh ld iq kj kk le it km nx lf kp kq ny lg kt ku nz lh kx ky kz hb bi translated">？？？？00 00 00 00 00 00 00 00 00 00 00 4字节大小4字节压缩_大小？？？？</p><p id="5fac" class="ke kf lc kg b kh ld iq kj kk le it km nx lf kp kq ny lg kt ku nz lh kx ky kz hb bi translated">因此，您可以通过复制4个字节的compressed_size并添加到“FD 37…”的偏移量来计算档案的结尾，或者您可以在新的“FD 37 7A 58…”之前搜索页脚“59 5A”，您将获得“libs.xz”档案作为第一个条目，并且您可以提取包含所有压缩库的文件<strong class="kg hq">“libs”</strong>，但是<strong class="kg hq">它们被混淆了</strong>， 在某些情况下，如arm-v7a，您可以幸运地找到您想要修补的字节(如Instagram armv7a版本SSL unpinning中的<a class="ae lb" href="http://twitter.com/itsMoji" rel="noopener ugc nofollow" target="_blank"> @itsMoji </a>所做的，修补libliger.so)，因此您可以重新压缩它，更新新的压缩大小，并替换libs.spo内部。</p><p id="a07b" class="ke kf lc kg b kh ld iq kj kk le it km nx lf kp kq ny lg kt ku nz lh kx ky kz hb bi translated">但是armv64的混淆看起来更重或不同，你将无法找到要修补的字节。</p></blockquote><p id="4ebf" class="pw-post-body-paragraph ke kf hp kg b kh ld iq kj kk le it km kn lf kp kq kr lg kt ku kv lh kx ky kz hb bi translated">在过去，这只是一个brotli档案，但去年它被修改为一种新的加密格式。如果你想要帮助创建一个提取器/构建器，你可以看看这个库。</p><p id="6aed" class="pw-post-body-paragraph ke kf hp kg b kh ld iq kj kk le it km kn lf kp kq kr lg kt ku kv lh kx ky kz hb bi translated">最好找到一种通用的方法来绕过它，直接访问目标库。</p><ul class=""><li id="7824" class="mi mj hp kg b kh ld kk le kn mk kr ml kv mm kz mn mo mp mq bi translated">使用AndroidStudio我创建了一个简单的应用程序，带有一个函数<a class="ae lb" href="https://github.com/michelerenzullo/Workplace_SSL_Unpinning/blob/b5753d39c5c4cbad6e08a0af82afca8b071842dd/dev/test_app/MyApplication/app/src/main/java/com/example/myapplication/random.java#L11" rel="noopener ugc nofollow" target="_blank"> <strong class="kg hq"> patcher() </strong> </a>来设置对目标库的R+W访问，使用RandomAccessFile <strong class="kg hq"> </strong>查找之前在Ghidra中找到的偏移量(<strong class="kg hq"> 0x1d9f0) </strong>并覆盖新的字节<strong class="kg hq"> 07 00 00 14 </strong>。<a class="ae lb" href="https://github.com/michelerenzullo/Workplace_SSL_Unpinning/tree/main/dev/test_app/MyApplication" rel="noopener ugc nofollow" target="_blank">这个应用程序</a>位于为文章创建的存储库中。</li></ul><figure class="mr ms mt mu fd hk er es paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="er es oa"><img src="../Images/982f77e1a4ccd8709897fa2da5945138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQUsD6dQ4joMaNAnYF9SFQ.png"/></div></div></figure><ul class=""><li id="8845" class="mi mj hp kg b kh ld kk le kn mk kr ml kv mm kz mn mo mp mq bi translated">构建应用程序并用apktool反编译以查看dalvik字节码中的java函数</li></ul><pre class="mr ms mt mu fd mx my mz na aw nb bi"><span id="a2fd" class="li jn hp my b fi nc nd l ne nf">apktool d -r -o app-release app-release.apk</span></pre><p id="566a" class="pw-post-body-paragraph ke kf hp kg b kh ld iq kj kk le it km kn lf kp kq kr lg kt ku kv lh kx ky kz hb bi translated">在random.smali中这是刚刚编译的函数patcher()。</p><figure class="mr ms mt mu fd hk"><div class="bz dy l di"><div class="ob mw l"/></div></figure><p id="241f" class="pw-post-body-paragraph ke kf hp kg b kh ld iq kj kk le it km kn lf kp kq kr lg kt ku kv lh kx ky kz hb bi translated">在MainActivity.smali中，您可以看到对该函数的调用</p><pre class="mr ms mt mu fd mx my mz na aw nb bi"><span id="b6bf" class="li jn hp my b fi nc nd l ne nf">invoke-static {}, Lcom/example/myapplication/random;-&gt;patcher()V</span></pre></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="ea16" class="jm jn hp bd jo jp md jr js jt me jv jw iv mf iw jy iy mg iz ka jb mh jc kc kd bi translated">在工作场所履行我们的职能</h1><ul class=""><li id="5221" class="mi mj hp kg b kh ki kk kl kn oc kr od kv oe kz mn mo mp mq bi translated">用apktool(或MT管理器)反编译Workplace</li></ul><pre class="mr ms mt mu fd mx my mz na aw nb bi"><span id="eb73" class="li jn hp my b fi nc nd l ne nf">apktool d -r -o Workplace_365.0.0.30.112–367653625 Workplace_365.0.0.30.112–367653625.apk</span></pre><p id="c09b" class="pw-post-body-paragraph ke kf hp kg b kh ld iq kj kk le it km kn lf kp kq kr lg kt ku kv lh kx ky kz hb bi translated">登录活动可能是一个很好的目标，可以在我们登录/注销时而不是每次用户打开应用程序时实现修补库的功能。</p><p id="7d4e" class="pw-post-body-paragraph ke kf hp kg b kh ld iq kj kk le it km kn lf kp kq kr lg kt ku kv lh kx ky kz hb bi translated">在AndroidManifest中搜索“loginactivity”，一个结果是<strong class="kg hq">com . Facebook . work shared . auth . core . work loginactivity</strong></p><ul class=""><li id="b41a" class="mi mj hp kg b kh ld kk le kn mk kr ml kv mm kz mn mo mp mq bi translated">打开文件夹smali _ classes 8 \ com \ Facebook \ work shared \ auth \ core中的文件<strong class="kg hq">work loginactivity . smali</strong>，最后粘贴random.smali中的函数patcher()</li><li id="35cf" class="mi mj hp kg b kh of kk og kn oh kr oi kv oj kz mn mo mp mq bi translated">搜索<strong class="kg hq"> onStart() </strong>，及之后”。locals 3 "粘贴对我们的函数的调用，用com/Facebook/work shared/auth/core/work loginactivity编辑路径com/example/my application/random</li></ul><pre class="mr ms mt mu fd mx my mz na aw nb bi"><span id="418d" class="li jn hp my b fi nc nd l ne nf">.method public final onStart()V<br/>    .locals 3<br/><strong class="my hq">    invoke-static {}, Lcom/facebook/workshared/auth/core/WorkLoginActivity;-&gt;patcher()V</strong></span></pre><p id="7e78" class="pw-post-body-paragraph ke kf hp kg b kh ld iq kj kk le it km kn lf kp kq kr lg kt ku kv lh kx ky kz hb bi translated"><strong class="kg hq">编辑结束</strong></p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><ul class=""><li id="888f" class="mi mj hp kg b kh ld kk le kn mk kr ml kv mm kz mn mo mp mq bi translated">用smali-2.5.2.jar编译回源代码</li></ul><pre class="mr ms mt mu fd mx my mz na aw nb bi"><span id="b8ea" class="li jn hp my b fi nc nd l ne nf">java -Xmx3000m -jar smali-2.5.2.jar ass Workplace_365.0.0.30.112–367653625<em class="lc">\”smali folder where are located the files edited”</em> -o Workplace_365.0.0.30.112–367653625<em class="lc">\”classes number”</em>.dex</span><span id="e896" class="li jn hp my b fi ok nd l ne nf"><strong class="my hq">in this case it is classes8:</strong></span><span id="121f" class="li jn hp my b fi ok nd l ne nf">java -Xmx3000m -jar smali-2.5.2.jar ass Workplace_365.0.0.30.112–367653625\smali_classes8 -o Workplace_365.0.0.30.112–367653625\classes8.dex</span></pre><ul class=""><li id="008e" class="mi mj hp kg b kh ld kk le kn mk kr ml kv mm kz mn mo mp mq bi translated">为了签署我们的apk，如果您还没有使用Java keytool生成密钥库jks:</li></ul><pre class="mr ms mt mu fd mx my mz na aw nb bi"><span id="8902" class="li jn hp my b fi nc nd l ne nf">keytool -genkeypair -dname “CN=test, OU=Android, O=Google Inc.,L=Mountain View, ST=California, C=US” -keystore <em class="lc">"your testkey"</em>.jks -validity 9125 -keyalg RSA -keysize 2048 -storepass <em class="lc">"your keystore pass"</em> -alias <em class="lc">"your alias"</em></span></pre><ul class=""><li id="8d36" class="mi mj hp kg b kh ld kk le kn mk kr ml kv mm kz mn mo mp mq bi translated">更新Workplace apk zip存档，替换为新的classes dex文件(在Linux终端上使用cp和zip命令，在Windows上手动执行)，zipalign并用apksigner.jar对其签名:</li></ul><pre class="mr ms mt mu fd mx my mz na aw nb bi"><span id="578a" class="li jn hp my b fi nc nd l ne nf">cp Workplace_365.0.0.30.112–367653625.apk toalign_Workplace_365.0.0.30.112–367653625.apk &amp;&amp; zip toalign_Workplace_365.0.0.30.112–367653625.apk classes8.dex</span><span id="58be" class="li jn hp my b fi ok nd l ne nf">zipalign -p -f 4 toalign_Workplace_365.0.0.30.112–367653625.apk zipaligned_Workplace_365.0.0.30.112–367653625.apk &amp;&amp; rm toalign_Workplace_365.0.0.30.112–367653625.apk</span><span id="9174" class="li jn hp my b fi ok nd l ne nf">java -jar apksigner.jar sign --ks <em class="lc">“your testkey”</em>.jks --ks-pass pass:<em class="lc">”your keystore pass” </em>--in zipaligned_Workplace_365.0.0.30.112–367653625.apk --out signed_Workplace_365.0.0.30.112–367653625.apk</span></pre><blockquote class="nu nv nw"><p id="8779" class="ke kf lc kg b kh ld iq kj kk le it km nx lf kp kq ny lg kt ku nz lh kx ky kz hb bi translated">我使用一个脚本来快速完成前面的步骤，您可以在我的存储库“aut.bat”中找到它，您只需要替换应用程序的名称、您的密钥库和路径。当你只是编辑几个类的时候，它比apktool要好。您可以运行我的脚本，并将要编译的类作为参数“aut.bat classes2 classes3…”</p></blockquote><ul class=""><li id="d2d7" class="mi mj hp kg b kh ld kk le kn mk kr ml kv mm kz mn mo mp mq bi translated">卸载Workplace app并手动或通过安装apk</li></ul><pre class="mr ms mt mu fd mx my mz na aw nb bi"><span id="0a84" class="li jn hp my b fi nc nd l ne nf">adb install -r signed_Workplace_365.0.0.30.112–367653625.apk</span></pre><ul class=""><li id="2633" class="mi mj hp kg b kh ld kk le kn mk kr ml kv mm kz mn mo mp mq bi translated">登录或注销，在配置您的代理后，您现在应该可以在Burp中看到<code class="du ng nh ni my b">/graphql</code>呼叫</li></ul><figure class="mr ms mt mu fd hk er es paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="er es ol"><img src="../Images/0c953e343f7476d8d7d2014cbd66af8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUAShNTI3FibmsHZABRfNg.png"/></div></div></figure><blockquote class="nu nv nw"><p id="d917" class="ke kf lc kg b kh ld iq kj kk le it km nx lf kp kq ny lg kt ku nz lh kx ky kz hb bi translated">如果你重复备份的步骤，你会看到<strong class="kg hq">libx plat _ fizz _ client _ protocol Android . so</strong>已经被正确地修补了！</p></blockquote><p id="84b4" class="pw-post-body-paragraph ke kf hp kg b kh ld iq kj kk le it km kn lf kp kq kr lg kt ku kv lh kx ky kz hb bi translated">应用程序发出的请求和响应与网站上的不同，比较它们并找到有趣的错误是很有用的。狩猎愉快！</p></div></div>    
</body>
</html>