<html>
<head>
<title>The REST architecture — why you might have entirely missed it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">REST架构——为什么你会完全错过它</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-rest-architecture-why-you-might-have-entirely-missed-it-d45adf3ed981?source=collection_archive---------1-----------------------#2022-05-29">https://medium.com/codex/the-rest-architecture-why-you-might-have-entirely-missed-it-d45adf3ed981?source=collection_archive---------1-----------------------#2022-05-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ea1b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这是不对的。这一切必须马上停止。</h2></div><p id="8378" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇博客不应该是咆哮，而是从面对事实开始——很多后端开发人员完全忽略了核心的REST设计原则和最佳实践。</p><p id="5c57" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天我遇到了一些可怕的端点，比如<code class="du jt ju jv jw b">/getAllSubsections</code>和<code class="du jt ju jv jw b">/deleteContactOfUser</code>😱在Node.js项目中，这促使我写这篇博客，并触及设计REST APIs的基本原则。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es jx"><img src="../Images/f53b0a510a087e7a221acb5b97f0545b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MmSIoie2V5JYLlDCrTVAqg.png"/></div></div></figure><p id="1eea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们从陈述显而易见的事情开始。REST API是符合REST或<em class="kj">表述性状态转移</em>架构风格的设计原则的API。REST提供了高度的灵活性、可伸缩性和自由度，这就是它成为当今最常用的API架构的原因。</p><p id="634c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="kj">如果你不确定API是什么，也许可以读一下</em> <a class="ae kk" href="https://www.ibm.com/cloud/learn/api" rel="noopener ugc nofollow" target="_blank"> <em class="kj">这个</em> </a> <em class="kj">然后回到这里。</em></p><p id="2134" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">REST APIs可以用任何编程语言开发，不像SOAP或XML-RPC。唯一的要求是它们符合<strong class="iz hj">六个REST设计原则</strong>——也称为<strong class="iz hj">架构约束</strong>。</p><h1 id="0750" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">概念</h1><p id="1019" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">不过，在我们谈论这些原则之前，让我们缩短理论，尝试讨论一些概念，并通过一些现实生活中的例子来理解事情。</p><h2 id="db2f" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">资源</h2><blockquote class="lw lx ly"><p id="6bd5" class="ix iy kj iz b ja jb ij jc jd je im jf lz jh ji jj ma jl jm jn mb jp jq jr js hb bi translated">一个<strong class="iz hj">资源</strong>是一个<strong class="iz hj">对象</strong>，它具有一个类型、相关数据、与其他资源的关系以及一组对其进行操作的方法。</p></blockquote><p id="bd0b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常任何可以被命名的东西都可以被认为是资源。例如，考虑一下<a class="mc md ge" href="https://medium.com/u/504c7870fdb6?source=post_page-----d45adf3ed981--------------------------------" rel="noopener" target="_blank">媒体</a>上的资源。如果你看一下Medium的<a class="ae kk" href="https://github.com/Medium/medium-api-docs#3-resources" rel="noopener ugc nofollow" target="_blank"> API </a>，我们会看到以下4个资源—</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es me"><img src="../Images/1bf9600db25d877e76502c564da2220d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AfzAQEnaR_mee6El6Q91YA.png"/></div></div></figure><p id="bc5a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，在设计您的API时，您可以自由决定应该将什么作为资源进行分配。这个决定将影响你的API相应的复杂度和结构。</p><h2 id="f6e6" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">基于资源的URL</h2><p id="c6f5" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">在为你的API设计端点或URL时，我们需要确保它们是<strong class="iz hj">结构良好的</strong>并且是从我们上面定义的<strong class="iz hj">资源</strong>中派生出来的。</p><h2 id="a3e5" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">HTTP方法</h2><p id="b632" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">正如在资源定义中所讨论的，它与一组可以对其进行操作的方法相关联。最常见的HTTP动词有<code class="du jt ju jv jw b"><strong class="iz hj">GET</strong></code><strong class="iz hj"/><code class="du jt ju jv jw b"><strong class="iz hj">POST</strong></code><strong class="iz hj"/><code class="du jt ju jv jw b"><strong class="iz hj">PUT</strong></code><strong class="iz hj"/><code class="du jt ju jv jw b"><strong class="iz hj">PATCH</strong></code><strong class="iz hj"/>和<strong class="iz hj"> </strong> <code class="du jt ju jv jw b"><strong class="iz hj">DELETE</strong></code>。</p><h2 id="f8c5" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">一个重要的例子</h2><p id="6238" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">假设中型API端点如下所示。我们试图通过前4个端点进行的操作是<strong class="iz hj">创建</strong>、<strong class="iz hj">阅读</strong>、<strong class="iz hj">更新</strong>和<strong class="iz hj">删除</strong>博客。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es mf"><img src="../Images/3f04ff5b2e141eec833db0f13931c730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F01o3G18Qh_6RTa8ZFZWug.png"/></div></div></figure><p id="b051" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以上端点一塌糊涂，原因如下——</p><ol class=""><li id="f5af" class="mg mh hi iz b ja jb jd je jg mi jk mj jo mk js ml mm mn mo bi translated">URL的结构不是很好，它们包含的不仅仅是资源名(名词)。</li><li id="0512" class="mg mh hi iz b ja mp jd mq jg mr jk ms jo mt js ml mm mn mo bi translated">编写诸如/getAllSubsections这样的端点(正如我在介绍中提到的)是一场噩梦，因为子节<strong class="iz hj">不是定义良好的资源</strong>。</li><li id="35f0" class="mg mh hi iz b ja mp jd mq jg mr jk ms jo mt js ml mm mn mo bi translated">向URL添加动词会很快使管理变得不可能。我们现在有4个新的端点，而我们原本只有一个，也就是<code class="du jt ju jv jw b">/blogs</code>。随着我们开始处理其他资源，这个数字只会继续增加。</li><li id="30ed" class="mg mh hi iz b ja mp jd mq jg mr jk ms jo mt js ml mm mn mo bi translated">对于<strong class="iz hj">复杂或嵌套查询</strong>，比如获取所有用户出版物或在出版物下创建帖子，URL将会很大。想象一下我们需要3或4层嵌套的场景！</li></ol><p id="5017" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么我们在这里错过了什么？端点应该只包含<strong class="iz hj">资源</strong>(名词)并使用<strong class="iz hj"> HTTP方法</strong>进行操作！这是我们修复端点后的样子。你将在后面了解到这个约束被称为<strong class="iz hj">统一接口</strong>。另外，请注意，按照惯例，我们使用复数名词从资源中构造URL。所以我们使用<code class="du jt ju jv jw b">\blogs</code>而不是<code class="du jt ju jv jw b">\blog</code>。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es jx"><img src="../Images/00619c5f6ff46c899e68265772884696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1DebH_I1UUswVgsUV9l13A.png"/></div></div></figure><p id="4678" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于嵌套的情况，假设我们想要获得特定用户的所有发布，我们将使用类似于—</p><pre class="jy jz ka kb fd mu jw mv mw aw mx bi"><span id="6e15" class="li km hi jw b fi my mz l na nb">GET /users/{{userId}}/publications</span></pre><p id="905a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里的<code class="du jt ju jv jw b">userId</code>是特定用户的唯一标识符。您可以看到Medium确实使用了这个<a class="ae kk" href="https://github.com/Medium/medium-api-docs#32-publications" rel="noopener ugc nofollow" target="_blank">端点</a>用于相同的目的！</p><h2 id="b064" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">以JSON形式发送数据(通常)</h2><p id="eaa3" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">JSON是一种轻量级的数据交换格式。通常，当客户端和服务器交互时，任何交换的数据都应该是JSON格式的。此外，发送的数据必须遵循一些规范，如<strong class="iz hj"> JSend </strong>(最常见)、<strong class="iz hj"> JSON: API </strong>，或<strong class="iz hj"> OData JSON协议</strong>。</p><p id="3c9e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个基本的符合JSend的响应就是这么简单。这里可以阅读更多<a class="ae kk" href="https://github.com/omniti-labs/jsend" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="jy jz ka kb fd mu jw mv mw aw mx bi"><span id="2317" class="li km hi jw b fi my mz l na nb">{<br/>    status : "success",<br/>    data : {<br/>        "post" : { "id" : 1, "title" : "A blog post", "body" : "Some useful content" }<br/>     }<br/>}</span></pre><h2 id="15a6" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">无国籍</h2><p id="57a0" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">REST APIs必须是无状态的。所有状态在客户端处理<strong class="iz hj">。每个请求必须包含处理特定请求所需的所有<strong class="iz hj"> </strong>信息。<strong class="iz hj">服务器不需要记住以前的请求。</strong></strong></p><p id="ca77" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，让我们说你目前正在查看第6页上的所有博客。如果你想看第七页上的博客，那么下面的请求不允许</p><pre class="jy jz ka kb fd mu jw mv mw aw mx bi"><span id="dabd" class="li km hi jw b fi my mz l na nb">GET /blogs/nextPage  -- bad practice </span></pre><p id="3645" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">服务器是无状态的。这是因为需要将一些数据存储在服务器端，以跟踪上一次发送哪个页面来响应之前的请求。另一方面，请求我们指定页面</p><pre class="jy jz ka kb fd mu jw mv mw aw mx bi"><span id="6a09" class="li km hi jw b fi my mz l na nb">GET /blogs/page/6    -- good practice</span></pre><p id="b05f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">number(或id)不需要在服务器端处理任何状态，这被认为是一个好的实践。</p><p id="09b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种情况下可能出现的另一个问题是缓存。在服务器端使用缓存有助于更快地解决查询。<strong class="iz hj">然而，人们必须注意到，缓存并不意味着服务器正在存储应用状态</strong>。它只是复制以前请求的数据，并将其放入一个快速的内存中，以便将来请求时可以访问。</p><h1 id="6377" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">架构限制</h1><p id="f40e" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">因此，最后，让我们看看六个REST设计原则。你会注意到，我们已经讨论了这里的几个要点。</p><h2 id="cfb8" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">1.统一界面</h2><p id="053d" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">对同一资源的所有API请求看起来应该是一样的，不管请求来自哪里。REST API应该确保同一块数据，比如用户的姓名或电子邮件地址，只属于一个统一资源标识符(URI)。资源不应该太大，但是应该包含客户可能需要的每一条信息。</p><h2 id="feaf" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">2.客户端-服务器解耦</h2><p id="0d7e" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">在REST API设计中，客户端和服务器应用程序必须完全相互独立。客户端应用程序应该知道的唯一信息是所请求资源的URI；它不能以任何其他方式与服务器应用程序交互。类似地，服务器应用程序不应该修改客户机应用程序，而应该通过HTTP将它传递给请求的数据。</p><h2 id="f1a2" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">3.无国籍</h2><p id="6dff" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">REST APIs是无状态的，这意味着每个请求都需要包含处理它所需的所有信息。换句话说，REST APIs不需要任何服务器端会话。不允许服务器应用程序存储任何与客户端请求相关的数据。</p><h2 id="1cad" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">4.可缓存性</h2><p id="d69a" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">如果可能的话，资源应该可以在客户端或服务器端缓存。服务器响应还需要包含关于所交付的资源是否允许缓存的信息。目标是提高客户端的性能，同时增加服务器端的可伸缩性。</p><h2 id="d75b" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">5.分层系统架构</h2><p id="d683" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">在REST APIs中，调用和响应经过不同的层。根据经验，不要假设客户端和服务器应用程序直接相互连接。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div class="er es nc"><img src="../Images/a7dab46ced0a251cbf46deaf8f978bf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*ApKs9hWa1LdYjyb4-arziA.png"/></div></figure><p id="d717" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在通信回路中可能有许多不同的中介，每个中介都有特定的职责。一个好的设计确保各层是隔离的，除了它们下面的层之外，不要与其他层通信。</p><h2 id="fbe4" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">6.按需编码(可选)</h2><p id="3500" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">REST APIs通常发送静态资源，但是在某些情况下，响应也可以包含可执行代码(比如Java小程序)。在这些情况下，代码应该只按需运行。</p><h1 id="77d9" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">其他最佳实践</h1><p id="2cbe" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">我们已经在上面的段落中讨论了以下最佳实践——用JSON接受和响应、在端点路径中使用名词而不是动词、用复数名词命名集合、分层对象的嵌套资源以及缓存数据以提高性能。</p><p id="71cc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有其他几件事你可以处理。这些东西并不违反这些原则，但是对于一个好的API设计是必不可少的。</p><h2 id="7751" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">优雅地处理错误并返回标准错误代码</h2><p id="bddb" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">为了在错误发生时消除API用户的困惑，我们应该优雅地处理错误，并返回表明发生了哪种错误的HTTP响应代码。一些常见的错误HTTP状态码可以在<a class="ae kk" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="13ad" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">错误代码需要附带消息，以便维护人员有足够的信息来解决问题，但攻击者不能使用错误内容来进行我们的攻击，如窃取信息或关闭系统。</p><h2 id="d2dd" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">允许筛选、排序和分页</h2><p id="03a9" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">REST API背后的数据库可能会变得非常大。有时候，数据太多了，不应该一次全部返回，因为这样太慢了，或者会让我们的系统瘫痪。因此，我们需要过滤项目的方法。</p><p id="fe97" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还需要对数据进行分页的方法，以便一次只返回几个结果。我们不想因为试图一次获得所有请求的数据而占用资源太长时间。排序有助于根据需要提取有序数据。</p><h2 id="00ae" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">良好的安全实践</h2><p id="8004" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">客户端和服务器之间的大部分通信应该是私密的，因为我们经常发送和接收私密信息。因此，使用SSL/TLS来保证安全性是必须的。</p><p id="8d73" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将SSL证书加载到服务器上并不太困难，而且费用是免费的或者非常低。没有理由不让我们的REST APIs通过安全通道而不是开放通道进行通信。</p><h2 id="d50f" class="li km hi bd kn lj lk ll kr lm ln lo kv jg lp lq kx jk lr ls kz jo lt lu lb lv bi translated">版本化我们的API</h2><p id="29c8" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">我们应该有不同版本的API，如果我们对它们做任何改变，可能会破坏客户。可以像现在大多数应用程序一样，根据语义版本(例如，2.0.6表示主要版本2和第六个补丁)进行版本控制。你可以在这里阅读更多关于这个<a class="ae kk" href="https://semver.org" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="70bd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样，我们可以逐步淘汰旧的端点，而不是强迫每个人同时迁移到新的API。v1端点可以为不想改变的人保持活跃，而具有闪亮新特性的v2可以为那些准备升级的人服务。如果我们的API是公开的，这一点尤其重要。我们应该将它们版本化，这样我们就不会破坏使用我们API的第三方应用程序。</p><p id="7bfa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">版本化通常用<code class="du jt ju jv jw b">/v1/</code>、<code class="du jt ju jv jw b">/v2/</code>等完成。添加在API路径的开头。</p><h1 id="d240" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">结论(TL；博士)</h1><p id="7342" class="pw-post-body-paragraph ix iy hi iz b ja ld ij jc jd le im jf jg lf ji jj jk lg jm jn jo lh jq jr js hb bi translated">那么准备好像专业人士一样设计REST APIs了吗？🙃</p><p id="cee8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们在接下来的三段中快速总结一下整篇文章。</p><figure class="jy jz ka kb fd kc er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es jx"><img src="../Images/61daee391d5ac643c3232297be538c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YS7yziC3MeVflTg_OgwSzw.png"/></div></div></figure><p id="2f00" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">设计高质量REST APIs最重要的一点是遵循web标准和约定来保持一致性。JSON、SSL/TLS和HTTP状态码都是现代web的标准构件。</p><p id="1254" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">性能也是一个重要的考虑因素。我们可以通过不一次返回太多数据来增加它。此外，我们可以使用缓存，这样我们就不必一直查询数据。</p><p id="f69b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">端点的路径应该一致。我们使用名词只是因为HTTP方法指出了我们想要采取的行动。嵌套资源的路径应该在父资源的路径之后。他们应该告诉我们正在获取或操作什么，而不需要阅读额外的文档来理解它在做什么。</p><p id="edb5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你读了这篇文章，发现它很有用，你可能也会喜欢—</p><div class="nd ne ez fb nf ng"><a rel="noopener follow" target="_blank" href="/codex/facts-about-node-js-you-might-have-missed-772267878d30"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hj fi z dy nl ea eb nm ed ef hh bi translated">你可能错过的关于节点JS的事实</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">节点JS不是一个框架和更多…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">medium.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu kh ng"/></div></div></a></div></div><div class="ab cl nv nw gp nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="hb hc hd he hf"><p id="4b92" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您有任何问题或建议，请随时联系我。您可以在这些社交媒体平台上关注我— <a class="ae kk" href="https://www.linkedin.com/in/ab-satyaprakash/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae kk" href="https://www.youtube.com/channel/UCJ6D0HS8c9Il-eX5lGbAyGg" rel="noopener ugc nofollow" target="_blank"> YouTube </a>、<a class="ae kk" href="https://twitter.com/AbSatyaprakash" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae kk" href="https://www.instagram.com/absatyaprakash/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>了解更多更新内容！</p><p id="ad0a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">一如既往！黑客快乐！😇</strong></p></div><div class="ab cl nv nw gp nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="hb hc hd he hf"><p id="542e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae kk" href="https://absatyaprakash01.medium.com/subscribe" rel="noopener">加入我的电子邮件列表，获得更多精彩的教程和编程博客</a> ❤️</p></div></div>    
</body>
</html>