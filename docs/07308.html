<html>
<head>
<title>Garbage Collection Algorithms in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的垃圾收集算法</h1>
<blockquote>原文：<a href="https://medium.com/codex/garbage-collection-algorithms-in-java-c2cb6b1c8d9a?source=collection_archive---------10-----------------------#2022-06-09">https://medium.com/codex/garbage-collection-algorithms-in-java-c2cb6b1c8d9a?source=collection_archive---------10-----------------------#2022-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cba8d518970ecd3f4125b7c8d201ff49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L9thnpDbtWiGmqJF"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">肯尼·埃利亚松在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="82e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java是一种在堆中收集垃圾的语言。操作系统正在堆中为JVM进程分配内存。JVM将堆分成几代。两代是永和老一代。年轻一代存储新对象，老一代存储旧对象。当对象变老时，对象从年轻一代移动到老一代。当老一代不再有足够的空间来存储对象时，垃圾收集器就会移除旧对象。</p><p id="1688" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">垃圾收集是一种高效的内存管理机制。移除堆中不需要的和未使用的对象，为新对象腾出内存空间。</p><p id="2fce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">许多垃圾收集算法是通过基于时间的内存分配矩阵来实现的。这些算法用收益和行为相互比较。下面是许多算法的特点。</p><p id="f738" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">减少回收内存的时间</p><p id="73ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">减少浪费的内存</p><p id="d784" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">减少内存以执行收集</p><p id="f557" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">减少收集过程中的暂停时间</p><h2 id="3b51" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">标记和扫描算法</h2><p id="064b" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">垃圾收集算法中的基本算法。在这个过程中的某个时刻，算法会停止工作，因为内存已满。当程序停止时，算法清理空间。</p><p id="0547" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个过程从标记开始。对象有一个标记位，用于标识标记期间访问的对象。校验位可以是0或1。收集器遍历所有根，更新标记位。</p><p id="ac2c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后扫描步骤开始。它在内存中穿行，只保留未标记的对象。</p><h2 id="091f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">G1垃圾收集器算法</h2><p id="95fa" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">G1垃圾收集算法在具有多处理器机器的大内存上工作。该算法优于并行生成扫描算法，因为它具有更好的性能。这个算法可以在JDK 4和更高版本中找到。</p><p id="705e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">G1收集器将堆分成大小相等的区域。它执行垃圾收集，并在整个过程中使用并发全局标记阶段来标记对象。当标记结束时，大部分空白区域被识别。G1收集器首先扫描那些确定的区域。由于这个原因，该算法也被称为“垃圾优先”。</p><h2 id="8e04" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">垃圾收集器</h2><p id="ee52" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">Z垃圾收集器是一个实验级算法，包含在Java 11版本中。该算法是为Linux设计的，在JDK 14之后，它将在windows和Mac OS中可用。</p><p id="b489" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">许多新引入的功能。它在更短的时间内并发工作，具有更好的性能。</p><p id="455c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该算法在内存空间已满时工作。该算法通过引用链找到应用程序可以访问的对象，释放不能访问的引用。该算法监视堆中行为对象的状态。监控是为了发现应用程序可以通过引用访问对象。垃圾回收器正在移除无法作为引用访问的。</p><h2 id="f64b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">比较</h2><p id="4e5b" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">作为一个优势，标记和扫描算法是一个循环工作的永无止境的过程，而且，在算法的执行时间之间没有开销。该算法的缺点是程序运行时算法运行多次。</p><p id="06a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">G1垃圾收集算法非常有效，并且适用于多处理器机器。此外，该算法在暂停时间目标的方式上是有效的。该算法不适用于严格的吞吐量操作。它与应用程序和垃圾收集同时共享资源。资源共享影响性能。</p><p id="783b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Z垃圾收集器算法在不中断不超过10ms的情况下执行并发执行。在堆划分的区域中，该算法可以调整大小。该算法使用动态内存分配来指向替代区域以释放堆。此外，它还提供多重映射服务，即虚拟内存中有一个地址指向同一个物理内存。这些是算法用来释放空间的更有效的方法。缺点是开发者不能控制算法的运行时间开销。对于需要大量内存空间的大规模应用来说，这是一个问题。</p><p id="4720" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">标记和清扫算法是应用程序中最常用的垃圾收集器。Z垃圾收集器在释放空间方面更有效，但它仍处于实验阶段。G1垃圾收集器更适合大内存和多处理系统。</p><h2 id="27b8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">参考</h2><p id="3296" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">[1]“JVM垃圾收集器”，baeldung.com<a class="ae iu" href="https://www.baeldung.com/jvm-garbage-collectors" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/jvm-garbage-collectors</a>(访问时间:2022年6月9日)。</p><p id="c930" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[2]“在Java中选择最佳垃圾收集算法以获得更好的性能”，LinkedIn。<a class="ae iu" href="https://www.linkedin.com/pulse/choosing-best-garbage-collection-algorithm-better-java-prasad/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/pulse/chopping-best-garbage-collection-algorithm-better-Java-Prasad/</a>(访问时间:2022年6月9日)。</p><p id="766b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[3]拜尔斯·里克。"垃圾收集算法。"</p></div></div>    
</body>
</html>