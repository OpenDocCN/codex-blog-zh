<html>
<head>
<title>Most Useful Apache Geode Statistics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最有用的Apache Geode统计数据</h1>
<blockquote>原文：<a href="https://medium.com/codex/most-useful-apache-geode-statistics-ebb85b37db2d?source=collection_archive---------5-----------------------#2021-06-24">https://medium.com/codex/most-useful-apache-geode-statistics-ebb85b37db2d?source=collection_archive---------5-----------------------#2021-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9b2a63fd3b2035a13d0499c0d19d091e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*itM1jpLlcrE2wOb-V22iGw.png"/></div></div></figure><h1 id="2a97" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="60ba" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Apache Geode在分布式系统的每个成员中生成各种统计数据，包括以下统计数据:</p><ul class=""><li id="42da" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated">操作系统</li><li id="dcea" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">Java虚拟机(JVM)</li><li id="55ca" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">JVM堆内存</li><li id="31c6" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">JVM垃圾收集</li><li id="5fe9" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">对等请求</li><li id="3d86" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">客户端到服务器的请求</li><li id="9b46" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated">缓存性能</li></ul><p id="f174" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">如果<em class="lf">启用统计采样的</em>属性设置为真，则统计数据会定期写入由<em class="lf">统计存档文件</em>属性配置的存档文件中。查看文件的主要方式是使用<a class="ae lg" href="https://gemtalksystems.com/products/vsd/" rel="noopener ugc nofollow" target="_blank">可视化统计显示</a> (vsd)工具。参见文档<a class="ae lg" href="https://gemfire.docs.pivotal.io/910/geode/managing/troubleshooting/producing_troubleshooting_artifacts.html" rel="noopener ugc nofollow" target="_blank">此处</a>了解生成统计文件的更多细节。有关vsd的更多详细信息，请参见文档<a class="ae lg" href="https://gemfire.docs.pivotal.io/910/gemfire/tools_modules/vsd/chapter_overview.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="88f9" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">其中一些统计数据有助于解决大多数问题；有些比较晦涩，只适用于狭窄的情况。</p><p id="5840" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hb bi translated">本文描述了对问题进行故障排除时最有用的统计信息，在某些情况下，还描述了统计信息之间的关系。</p><h1 id="53d6" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">最有用的统计数据</h1><p id="f184" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">所有的统计数据都被分成不同的类别。下面列出了最有用的类别。以下各节描述了每个类别中最重要的统计信息。</p><ul class=""><li id="2a7a" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><a class="ae lg" href="#af5f" rel="noopener ugc nofollow">VMStats</a>—JVM的统计信息</li><li id="67c1" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><a class="ae lg" href="#4cd1" rel="noopener ugc nofollow">VMMemoryPoolStats</a>—JVM堆内存的统计信息</li><li id="1b50" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><a class="ae lg" href="#160c" rel="noopener ugc nofollow">VMGCStats</a>—JVM垃圾收集的统计数据</li><li id="26e8" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><a class="ae lg" href="#5aa1" rel="noopener ugc nofollow"> StatSamplerStats </a> —统计数据采样器本身的统计数据</li><li id="d488" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><a class="ae lg" href="#9440" rel="noopener ugc nofollow"> ResourceManagerStats </a> —堆监控的统计数据</li><li id="505c" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><a class="ae lg" href="#acb8" rel="noopener ugc nofollow">分区区域统计</a> —分区区域的统计</li><li id="c9d8" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><a class="ae lg" href="#c94f" rel="noopener ugc nofollow"> LinuxSystemStats </a> —操作系统的统计数据</li><li id="a9ba" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><a class="ae lg" href="#d6ef" rel="noopener ugc nofollow"> DistributionStats </a> —对等请求的统计数据</li><li id="5d45" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><a class="ae lg" href="#f548" rel="noopener ugc nofollow"> CacheServerStats </a> —客户端对服务器请求的统计</li><li id="b10c" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><a class="ae lg" href="#33bc" rel="noopener ugc nofollow"> CachePerfStats </a> —缓存性能统计</li></ul><h2 id="af5f" class="lh ir hi bd is li lj lk iw ll lm ln ja jz lo lp je kd lq lr ji kh ls lt jm lu bi translated">VMStats</h2><p id="6e3f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj"> VMStats </strong>实例将与JVM进程相关的所有统计信息组合在一起，包括:</p><ul class=""><li id="c6a6" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><strong class="jq hj"> fdsOpen / fdLimit </strong> —指示从<code class="du lv lw lx ly b">ManagementFactory.getOperatingSystemMXBean()</code>提供的<code class="du lv lw lx ly b">UnixOperatingSystemMXBean</code>中检索的JVM中文件描述符(FD)的当前和最大数量。如果打开的文件系统数量达到限制，则会出现“<em class="lf">太多打开文件</em>”的<code class="du lv lw lx ly b">IOException</code>。</li><li id="3dce" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> processCpuTime </strong> —表示从<code class="du lv lw lx ly b">ManagementFactory.getOperatingSystemMXBean()</code>的<code class="du lv lw lx ly b">UnixOperatingSystemMXBean</code>中获取的JVM CPU的处理时间。这个统计显示了JVM占了主机CPU总量的多少(参见<a class="ae lg" href="#c94f" rel="noopener ugc nofollow"> LinuxSystemStats </a>)。</li><li id="59d2" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj">线程</strong> —表示从<code class="du lv lw lx ly b">ManagementFactory.getThreadMXBean()</code>提供的<code class="du lv lw lx ly b">ThreadMXBean</code>中检索到的JVM中的线程数</li></ul><h2 id="4cd1" class="lh ir hi bd is li lj lk iw ll lm ln ja jz lo lp je kd lq lr ji kh ls lt jm lu bi translated">VMMemoryPoolStats</h2><p id="8fde" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">一个<strong class="jq hj"> VMMemoryPoolStats </strong>实例将所有与java堆内存空间相关的统计数据组合在一起。例子包括<em class="lf"> CMS老根</em>、<em class="lf"> Par伊甸园</em>、<em class="lf"> G1伊甸园</em>和<em class="lf"> G1老根</em>。为由<code class="du lv lw lx ly b">ManagementFactory.getMemoryPoolMXBeans()</code>提供的每个<code class="du lv lw lx ly b">MemoryPoolMXBeans</code>创建一个。</p><ul class=""><li id="743d" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><strong class="jq hj">currentusememory</strong>—表示JVM的当前堆使用情况</li><li id="e5bb" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> currentMaxMemory </strong> —表示JVM的最大堆使用率</li></ul><h2 id="160c" class="lh ir hi bd is li lj lk iw ll lm ln ja jz lo lp je kd lq lr ji kh ls lt jm lu bi translated">VMGCStats</h2><p id="16b2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">一个<strong class="jq hj"> VMGCStats </strong>实例将所有与java垃圾收集器相关的统计信息组合在一起。例子包括<em class="lf"> ConcurrentMarkSweep </em>、<em class="lf"> ParNew </em>、<em class="lf"> G1老一代</em>和<em class="lf"> G1年轻一代</em>。为<code class="du lv lw lx ly b">ManagementFactory.getGarbageCollectorMXBeans()</code>提供的每个<code class="du lv lw lx ly b">GarbageCollectorMXBeans</code>创建一个。</p><ul class=""><li id="5712" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><strong class="jq hj">收集</strong> —表示垃圾收集的次数</li><li id="024f" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> collectionTime </strong> —以纳秒为单位表示垃圾收集时间。此统计数据中的峰值可能会导致成员与分布式系统断开连接，并且可能需要对已配置的堆或区域配置进行垃圾收集调优或调整(例如，添加或更改堆LRU回收)。</li></ul><h2 id="5aa1" class="lh ir hi bd is li lj lk iw ll lm ln ja jz lo lp je kd lq lr ji kh ls lt jm lu bi translated">StatSamplerStats</h2><p id="b2b9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj"> StatSamplerStats </strong>实例将所有与统计抽样相关的统计数据组合在一起。</p><ul class=""><li id="0560" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><strong class="jq hj"> delayDuration </strong> —表示统计采样器线程采集的样本之间的延迟。<a class="ae lg" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/internal/statistics/HostStatSampler.java" rel="noopener ugc nofollow" target="_blank">主机统计采样器的</a>统计线程根据<em class="lf">统计采样率</em>属性定期对统计数据进行采样。如果statThread在应该采样的时候没有采样，<strong class="jq hj"> delayDuration </strong>将显示一个尖峰。这通常表明存在资源问题(例如GC或CPU)，有助于缩小调查的时间范围。</li><li id="3f5f" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj">JVM暂停</strong> —表示JVM暂停的次数。当统计样本之间的延迟大于三秒钟时，此统计值将递增。这个时间可以通过<a class="ae lg" href="https://github.com/apache/geode/blob/2271b7f2b7c5ff8adc1b066894a3b714975cbe0d/geode-core/src/main/java/org/apache/geode/internal/statistics/HostStatSampler.java#L66" rel="noopener ugc nofollow" target="_blank">gemfire . statsamplerdelaythreshold</a>Java系统属性进行配置。</li></ul><h2 id="9440" class="lh ir hi bd is li lj lk iw ll lm ln ja jz lo lp je kd lq lr ji kh ls lt jm lu bi translated">资源管理器统计</h2><p id="d853" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj"> ResourceManagerStats </strong>实例将所有与堆使用情况监控相关的统计信息组合在一起。</p><ul class=""><li id="ba17" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><strong class="jq hj"> heapCriticalEvents </strong> —表示堆使用率超过临界堆百分比的次数。临界堆百分比是成员不再接受缓存操作的百分比。它是通过resource manager<em class="lf">critical-heap-percentage</em>属性配置的。</li><li id="8637" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> evictionStartEvents </strong> —指示堆使用率超过驱逐堆百分比的次数。回收堆百分比是用堆LRU回收定义的区域开始回收的百分比。它是通过resource manager<em class="lf">eviction-heap-percentage</em>属性配置的。</li></ul><h2 id="acb8" class="lh ir hi bd is li lj lk iw ll lm ln ja jz lo lp je kd lq lr ji kh ls lt jm lu bi translated">分区区域状态</h2><p id="39ec" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">一个<strong class="jq hj"> PartitionedRegionStats </strong>实例将与一个分区区域相关的所有统计信息组合在一起。</p><ul class=""><li id="7eba" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><strong class="jq hj">桶计数</strong> —表示成员中定义的桶数</li><li id="bb58" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> primaryBucketCount </strong> —表示成员中定义的主存储桶的数量</li><li id="4a16" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> dataStoreBytesInUse </strong> —表示包括主存储桶和次存储桶在内的所有存储桶的条目字节数</li><li id="fbe6" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> dataStoreEntryCount </strong> —表示所有<strong class="jq hj"> </strong>存储桶中的条目数，包括主存储桶和次存储桶</li></ul><h2 id="c94f" class="lh ir hi bd is li lj lk iw ll lm ln ja jz lo lp je kd lq lr ji kh ls lt jm lu bi translated">Linux系统状态</h2><p id="097d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj"> linuxSystemStats </strong>实例将所有与Linux系统性能相关的统计数据组合在一起。</p><ul class=""><li id="ea7f" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><strong class="jq hj"> cachedMemory </strong> —表示从<em class="lf"> /proc/meminfo </em>中获取的RAM中缓存的内存量</li><li id="f6e9" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> cpuActive </strong> —表示从<em class="lf"> /proc/stat </em>中检索到的活动CPU百分比</li><li id="e3ee" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj">空闲内存</strong> —表示从<em class="lf"> /proc/meminfo </em>中检索的主机上可用的空闲内存量。这个统计信息有助于确定可用内存量对于JVM堆和本机线程是否足够。</li><li id="9c22" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> loadAverage1 </strong>，<strong class="jq hj"> loadAverage5 </strong>，<strong class="jq hj"> loadAverage15 </strong> —表示从<em class="lf"> /proc/loadavg </em>中检索到的正在运行和等待的进程数。这些统计数据有助于确定系统上的负载对于CPU的数量来说是否过高。</li><li id="5c82" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj">物理内存</strong> —表示从<em class="lf"> /proc/meminfo </em>中检索到的主机上的物理内存量</li><li id="ea02" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> recvBytes </strong> —表示从<em class="lf"> /proc/net/dev </em>中检索到的通过网络从其他成员接收的字节数</li><li id="ba05" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> recvDrops </strong> —表示从<em class="lf"> /proc/net/dev </em>中检索到的已接收的丢弃字节数。此统计信息的非零值表示可能存在网络问题。</li><li id="1403" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> xmitBytes </strong> —表示从<em class="lf"> /proc/net/dev </em>中检索到的通过网络传输给其他成员的字节数</li><li id="3caa" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> xmitDrops </strong> —表示从<em class="lf"> /proc/net/dev </em>中检索到的传输字节数。此统计信息的非零值表示可能存在网络问题。</li></ul><h2 id="d6ef" class="lh ir hi bd is li lj lk iw ll lm ln ja jz lo lp je kd lq lr ji kh ls lt jm lu bi translated">分布统计</h2><p id="8ddb" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj"> DistributionStats </strong>实例对所有与对等通信和处理相关的统计数据进行分组。</p><ul class=""><li id="6d53" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><strong class="jq hj">节点</strong> —表示分布式系统的成员数量</li><li id="b1eb" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj">functionExecutionThreads</strong>/<strong class="jq hj">functionExecutionQueueSize</strong>—指示在所有线程都在使用时，用于处理函数执行请求的名为<a class="ae lg" href="https://github.com/apache/geode/blob/2271b7f2b7c5ff8adc1b066894a3b714975cbe0d/geode-core/src/main/java/org/apache/geode/distributed/internal/ClusterOperationExecutors.java#L149" rel="noopener ugc nofollow" target="_blank"> functionExecutionPool </a>的ExecutorService中的线程数以及超额请求队列。<strong class="jq hj"> functionExecutionThreads </strong>统计对应于<code class="du lv lw lx ly b">Function Execution Processor</code>线程的数量(默认最大值是处理器*16和100的最大值)。如果<strong class="jq hj">functionExecutionQueueSize</strong>始终大于零，那么可以通过设置<a class="ae lg" href="https://github.com/apache/geode/blob/2271b7f2b7c5ff8adc1b066894a3b714975cbe0d/geode-core/src/main/java/org/apache/geode/distributed/internal/OperationExecutors.java#L31" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> DistributionManager来增加functionExecutionPool的最大线程数。MAX_FE_THREADS </em> </a> java系统属性。关于何时以及如何使用函数执行线程的更多信息，请参见我的<a class="ae lg" rel="noopener" href="/swlh/threads-used-in-apache-geode-function-execution-9dd707cf227c">文章</a>。</li><li id="1844" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj">highporitythreads</strong>/<strong class="jq hj">highporityqueuesize</strong>—表示ExecutorService中用于处理高优先级消息(例如<a class="ae lg" href="https://github.com/apache/geode/blob/8333d606fce4737da1e5dc846efa53f3ab035cd3/geode-core/src/main/java/org/apache/geode/internal/cache/CreateRegionProcessor.java#L311" rel="noopener ugc nofollow" target="_blank"> CreateRegionMessage </a>、<a class="ae lg" href="https://github.com/apache/geode/blob/8333d606fce4737da1e5dc846efa53f3ab035cd3/geode-core/src/main/java/org/apache/geode/internal/cache/InitialImageOperation.java#L1522" rel="noopener ugc nofollow" target="_blank"> RequestImageMessage </a>)的名为<a class="ae lg" href="https://github.com/apache/geode/blob/2271b7f2b7c5ff8adc1b066894a3b714975cbe0d/geode-core/src/main/java/org/apache/geode/distributed/internal/ClusterOperationExecutors.java#L127" rel="noopener ugc nofollow" target="_blank">highporitypool</a>的线程数量，以及当所有线程都在使用中时的超额请求队列。<strong class="jq hj">highporitythreads</strong>统计对应于<code class="du lv lw lx ly b">Pooled High Priority Message Processor</code>线程的数量(默认最大值为1000)。如果<strong class="jq hj">highporityqueuesize</strong>始终大于零，那么可以通过设置<a class="ae lg" href="https://github.com/apache/geode/blob/2271b7f2b7c5ff8adc1b066894a3b714975cbe0d/geode-core/src/main/java/org/apache/geode/distributed/internal/OperationExecutors.java#L28" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> DistributionManager来增加highPriorityPool的最大线程数。MAX_THREADS </em> </a> java系统属性。</li><li id="f341" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj">partitionedRegionThreads</strong>/<strong class="jq hj">partitionedRegionQueueSize</strong>—指示在所有线程都在使用时，用于处理分区区域消息(例如<a class="ae lg" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/PutMessage.java" rel="noopener ugc nofollow" target="_blank"> PutMessage </a>、<a class="ae lg" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/internal/cache/partitioned/DestroyMessage.java" rel="noopener ugc nofollow" target="_blank"> DestroyMessage </a>)和超额请求队列的名为<a class="ae lg" href="https://github.com/apache/geode/blob/2271b7f2b7c5ff8adc1b066894a3b714975cbe0d/geode-core/src/main/java/org/apache/geode/distributed/internal/ClusterOperationExecutors.java#L146" rel="noopener ugc nofollow" target="_blank"> partitionedRegionPool </a>的ExecutorService中的线程数。<strong class="jq hj">partitionedRegionThreads</strong>统计信息对应于<code class="du lv lw lx ly b">PartitionedRegion Message Processor</code>线程的数量(默认最大值是处理器*32和200的最大值)。如果<strong class="jq hj">partitionedRegionQueueSize</strong>始终大于零，那么可以通过设置<a class="ae lg" href="https://github.com/apache/geode/blob/2271b7f2b7c5ff8adc1b066894a3b714975cbe0d/geode-core/src/main/java/org/apache/geode/distributed/internal/ClusterOperationExecutors.java#L70" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> DistributionManager来增加partitionedRegionPool的最大线程数。MAX_PR_THREADS </em> </a> java系统属性。</li><li id="1de3" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj">processing threads</strong>/<strong class="jq hj">overflowQueueSize</strong>—表示ExecutorService中用于处理正常消息(例如<a class="ae lg" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/internal/cache/TXCommitMessage.java" rel="noopener ugc nofollow" target="_blank"> TXCommitMessage </a>、<a class="ae lg" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/management/internal/ManagerStartupMessage.java" rel="noopener ugc nofollow" target="_blank"> ManagerStartupMessage </a>)的线程数量，以及当所有线程都在使用中时的超额请求队列。<strong class="jq hj"> processingThreads </strong>统计对应于<code class="du lv lw lx ly b">Pooled Message Processor</code>线程的数量(默认最大值为1000)。如果<strong class="jq hj"> overflowQueueSize </strong>始终大于零，那么可以通过设置<a class="ae lg" href="https://github.com/apache/geode/blob/2271b7f2b7c5ff8adc1b066894a3b714975cbe0d/geode-core/src/main/java/org/apache/geode/distributed/internal/OperationExecutors.java#L28" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> DistributionManager来增加线程池的最大线程数。MAX_THREADS </em> </a> java系统属性。</li><li id="b0f5" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> sendersTO </strong> —表示到其他成员的传出线程拥有的(TO)连接数。只有在<em class="lf"> conserve-sockets </em>属性设置为false时，才会设置此统计信息。在这种情况下，当在一个成员中处理请求的线程需要向另一个成员发送消息时，它将创建并使用到该成员的专用连接。一个例子是当处理客户端put请求的<code class="du lv lw lx ly b">ServerConnection</code>线程需要将值复制到次要成员时。这将导致远程成员创建一个专用的<code class="du lv lw lx ly b">P2P message reader</code>线程来处理该消息以及来自本地成员和线程的任何未来消息。这将增加本地成员中的<strong class="jq hj">发送者到</strong>统计和远程成员中的<strong class="jq hj">接收者到</strong>统计。</li><li id="3bb8" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> receiversTO </strong> —指示来自远程成员的传入线程拥有的(TO)连接数。相应的<strong class="jq hj"> sendersTO </strong>将在远程成员中递增。该统计对应于<code class="du lv lw lx ly b">P2P message reader</code>线程的数量，并且仅在<em class="lf">保存套接字</em>属性设置为false时才会被设置。</li><li id="042e" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> senderTimeouts </strong> —表示对于<em class="lf">套接字租用时间</em>属性(默认值为60000毫秒)<em class="lf"> </em>处于空闲状态并且已经关闭的传出线程拥有(TO)连接的数量。当线程拥有的连接关闭时，其对应的远程<code class="du lv lw lx ly b">P2P message reader</code>线程也将关闭。本地<strong class="jq hj">发送器到</strong>和远程<strong class="jq hj">接收器到</strong>的统计将被递减。此外，本地<strong class="jq hj"> senderTimeouts </strong>将递增。成员之间的线程拥有的连接是按需创建的，创建成本可能很高(尤其是使用SSL)。一旦它们被建立，只要建立它们的线程存在，它们就应该被维护。增加<em class="lf">套接字租用时间</em>(最大值为600000毫秒)或将其设置为零来禁用它，将有助于确保连接不会过早关闭。</li><li id="e5fb" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> replyTimeouts </strong> —表示一个成员中的线程等待来自另一个成员的回复至少<em class="lf"> ack-wait-threshold </em>秒(默认值=15)的次数。即使超时已经发生，线程也将继续等待，直到收到回复或者远程成员离开分布式系统。该统计信息对应于日志中的一条<code class="du lv lw lx ly b">15 second warning</code>消息。</li><li id="fc79" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> replyWaitsInProgress </strong> —表示一个成员中等待远程成员回复的线程数。零以上的统计数据表明线程被永久阻塞。</li><li id="2b8e" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj">接收到的可疑消息</strong> —表示当某个成员意外离开或出现网络问题而无法联系到特定成员时，从其他成员处接收到的可疑消息的数量</li><li id="c608" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj">可疑消息</strong> —表示当某个成员意外离开或出现网络问题导致无法联系特定成员时，发送给其他成员的可疑消息的数量</li></ul><h2 id="f548" class="lh ir hi bd is li lj lk iw ll lm ln ja jz lo lp je kd lq lr ji kh ls lt jm lu bi translated">CacheServerStats</h2><p id="2be8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj"> CacheServerStats </strong>实例将所有与客户端到服务器的通信和处理相关的统计数据分组。</p><ul class=""><li id="00fe" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><strong class="jq hj">当前客户端</strong> —表示当前连接到此服务器的唯一客户端的数量。对于长期客户端，这个统计数据应该相对平坦。</li><li id="87d7" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj">当前客户端连接</strong> —表示客户端连接到该服务器的总数。此统计信息表明执行缓存操作的客户端线程的数量。</li><li id="4475" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj">closeConnectionRequests</strong>—表示来自客户端的关闭连接请求的数量。对于长期客户端，该统计信息是空闲客户端连接超时和关闭频率的指示器。这个统计也和<strong class="jq hj">发送者到</strong>和<strong class="jq hj">接收者到</strong>有关系。本统计中的流失也意味着那些统计中的流失。在这种情况下，Churn意味着从客户端到服务器以及从服务器到其成员的套接字连接被关闭和重新打开。由于创建套接字连接的成本可能很高(尤其是对于SSL)，所以这个统计值应该尽可能接近零。如果此统计数据中有大量变动，则应该增加或禁用客户端池<em class="lf">空闲超时</em>属性。默认的<em class="lf">空闲超时</em>是五秒，这通常太低了。</li><li id="82d8" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj">connections time out</strong>—此统计信息指示服务器根据池<em class="lf">读取超时</em>属性确定的客户端上超时的连接数。尽管统计数据增加了，但是处理客户端请求的<code class="du lv lw lx ly b">ServerConnection</code>线程继续处理该请求。这个统计值应该尽可能接近零。如果不是，那么应该增加客户端池<em class="lf">读取超时</em>属性。</li><li id="7973" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> threadQueueSize </strong> —该统计数据显示等待<code class="du lv lw lx ly b">ServerConnection</code>线程处理的客户端请求的数量。仅当cache server<em class="lf">max-threads</em>属性设置为大于零时才适用。这个属性导致一个名为<a class="ae lg" href="https://github.com/apache/geode/blob/8333d606fce4737da1e5dc846efa53f3ab035cd3/geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/AcceptorImpl.java#L128" rel="noopener ugc nofollow" target="_blank">池</a>的ExecutorService被创建。如果<strong class="jq hj"> threadQueueSize </strong>一直大于零，那么<em class="lf"> max-threads </em>属性应该增加。</li></ul><h2 id="33bc" class="lh ir hi bd is li lj lk iw ll lm ln ja jz lo lp je kd lq lr ji kh ls lt jm lu bi translated">CachePerfStats</h2><p id="9946" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj"> CachePerfStats </strong>实例对所有与缓存使用相关的统计数据进行分组。</p><ul class=""><li id="34e0" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><strong class="jq hj">cacheListenerCallsInProgress</strong>—表示正在进行的CacheListener回调的数量。该统计值在零以上，表示CacheListener永久阻塞。</li><li id="f718" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj">cacheWriterCallsInProgress</strong>—表示正在进行的CacheWriter回调的数量。零以上的统计数据表明CacheWriter永久停滞。</li><li id="51f6" class="km kn hi jq b jr kx jv ky jz kz kd la kh lb kl kt ku kv kw bi translated"><strong class="jq hj"> loadsInProgress </strong> —表示正在进行的CacheLoader回调的数量。零以上的统计数据表明CacheLoader被永久阻塞。</li></ul><h1 id="658b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="eab9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">本文展示了在解决问题时使用的一些更有用的统计数据。</p></div></div>    
</body>
</html>