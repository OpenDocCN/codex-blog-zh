<html>
<head>
<title>Key Principles of Software Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件架构的关键原则</h1>
<blockquote>原文：<a href="https://medium.com/codex/key-principles-of-software-architecture-3a500f177f93?source=collection_archive---------1-----------------------#2021-01-24">https://medium.com/codex/key-principles-of-software-architecture-3a500f177f93?source=collection_archive---------1-----------------------#2021-01-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="720e" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><div class=""><h2 id="e041" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">让我们也解码什么是建筑，建筑师做什么</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es jg"><img src="../Images/c966f36bccccc8e18ce90d1165abce00.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*GOPsyS6kgeXa3Ceh"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">皮沙贝</figcaption></figure><p id="3b05" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">很长一段时间，我一直想知道什么是软件“架构”。如果架构是那些表示系统组件、层、交互和数据流的漂亮图表，那么什么是“高层次设计”。我花了很长时间才找到或意识到答案。</p><p id="5f10" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">形式上，建筑有很多定义。然而，常见的术语是构建模块、基本结构、设计蓝图等等。这明确反映了它对产品的重要性。</p><p id="28cb" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">我逐渐意识到，架构是对产品来说非常重要的东西，如果我们在生命周期的早期做出这些决定，它可以使产品变得优雅、稳定、抽象、易于扩展和发展。然而,“多早”是有上下文关系的，在此之后的任何时间做出改变都是昂贵的。</p><h1 id="1702" class="ko kp hi bd kq kr ks kt ku kv kw kx ky ix kz iy la ja lb jb lc jd ld je le lf bi translated">什么是软件架构</h1><blockquote class="lg"><p id="9cc7" class="lh li hi bd lj lk ll lm ln lo lp kn dx translated"><em class="lq">任何对应用程序来说重要的东西，最好尽早识别和定义，以及对所有这些工件的共同理解都可以被称为软件架构</em></p></blockquote><h1 id="d9bd" class="ko kp hi bd kq kr ks kt ku kv kw kx ky ix lr iy la ja ls jb lc jd lt je le lf bi translated">谁是软件架构师</h1><p id="987a" class="pw-post-body-paragraph js jt hi ju b jv lu is jx jy lv iv ka kb lw kd ke kf lx kh ki kj ly kl km kn hb bi translated">(我更喜欢将软件架构作为日常开发的一部分，而不是一个独立的部门)，</p><blockquote class="lg"><p id="f1f4" class="lh li hi bd lj lk ll lm ln lo lp kn dx translated"><em class="lq">认识到以上几点，并把全部心思放在识别什么对应用程序是重要的，在早期阶段优雅地构建这些元素，并确保这成为整个团队的共识。</em></p></blockquote><p id="8e7b" class="pw-post-body-paragraph js jt hi ju b jv lz is jx jy ma iv ka kb mb kd ke kf mc kh ki kj md kl km kn hb bi translated">注意上面的“共识”字样。这是该角色最重要的部分，即带来对整个技术和产品愿景一致性的共同理解。最好是围绕它建立一个易于叙述的故事，每个人都可以在日常工作中容易地记住和谈论。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="3917" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">现在，我们理解了建筑和建筑师。故事的下一部分是关于如何确保我们有好的架构。这给我们带来了软件架构的一些关键原则。我们在网上有许多记录良好的丰富资源，因此，我们将不赘述，而是用一些经验总结一下。</p><h1 id="abb7" class="ko kp hi bd kq kr ks kt ku kv kw kx ky ix kz iy la ja lb jb lc jd ld je le lf bi translated">软件架构的关键原则</h1><h1 id="48b0" class="ko kp hi bd kq kr ks kt ku kv kw kx ky ix kz iy la ja lb jb lc jd ld je le lf bi translated">减少返工，降低风险</h1><p id="25d3" class="pw-post-body-paragraph js jt hi ju b jv lu is jx jy lv iv ka kb lw kd ke kf lx kh ki kj ly kl km kn hb bi translated">首要的是如何减少返工。我们无法控制业务需求的变化，相反，新的需求对业务有益。然而，我们可以控制改变的数量，我们需要在一个应用程序中作出任何新的要求。神奇的原理是坚实的。然而，让我们打破僵局，用简单的术语来谈一谈，</p><p id="05f8" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">不要重复(干):</strong>是的，不要再写那些你可以从现有实现中使用的代码。这就是持续重构的习惯“大有帮助”的地方。需要一些你已经在另一个模块中编写的实现，把它拿出来，使它通用，以便在所有地方使用。识别、重构并使其通用化以便重用。</p><p id="6308" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">每当我们编写重复的代码时，我们都需要维护更多的代码，需要在多个地方为相同的需求进行更改，需要对系统进行更多的测试，由于多个地方的更改，可能会有更多的bug。</p><p id="86db" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">单一责任:</strong>如果我需要挑选一个关键原则，我会投赞成票。这就是“单一责任原则”对于保持代码可读性、可维护性以及长期工作的重要性。</p><p id="d836" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">确保任何代码单元都属于一个特定的职责。经验法则:它应该总是被改变以服务于一个特定的意图。通过这样做，我们带来的最大影响是让读者和开发者明白我们的意图。如果代码可以清楚地表达自己的意图，那么应用程序代码就可以像故事书一样被阅读。现在，谁不喜欢整天看故事而不是谜题呢？这是重要的原则之一，如果认真遵循，可以使代码长期可维护，从而延长整个应用程序的寿命。我们需要花更少的精力来培训新的开发人员，或者解决任何问题或扩展功能。</p><p id="93c7" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">它还大大降低了总拥有成本。</p><p id="99e0" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><em class="ml">代码单元:应用程序、模块、类、函数——它们都是各自上下文中的代码单元，区别在于“用户”。</em></p><p id="a37e" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">开放关闭原则:</strong>实现应该对扩展开放，对变更关闭。现在，这可能是一个令人困惑的说法。让我们从实现的角度来简化它。</p><p id="2960" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">使用接口来定义行为。接口有助于通过另一个类实现随时在应用程序中添加新的行为。这意味着如果我们简单地为同一个接口添加一个新的实现，并为用户/调用者(DI)注入它，那么调用者或接口的用户不需要改变任何东西。我们不需要对调用代码进行任何更改。我们只是通过增加一种实现风格来扩展行为。本质上，我们增强了系统行为，而没有对现有的实现进行更改，只是简单地扩展了现有的行为，添加了新的风格。</p><p id="ddb1" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">好处是巨大的。它有助于避免对现有代码的修改，这种修改通常会增加测试成本和潜在的错误。它改进了接口背后的关注点的抽象，而不是当调用者需要知道使用多个类来实现多种风格时。</p><p id="19ef" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><em class="ml">示例:</em>咖啡机使用咖啡机(接口)制作咖啡。我们有一台浓缩咖啡机(EspressoCoffeeMachine)，咖啡机就用这个。在未来，如果我们想要添加更多的机器，例如制作卡布奇诺，我们可以在系统中添加另一台机器(CappuccinoCoffeeMachine实现CoffeeMachine)，并根据上下文将这台新机器注入CoffeeMaker。最终结果是，我们添加了新的行为，而没有改变咖啡机，咖啡机或EspressoCoffeeMachine中的任何代码。但是我们刚刚添加了一个新的实现。</p><h1 id="e7fb" class="ko kp hi bd kq kr ks kt ku kv kw kx ky ix kz iy la ja lb jb lc jd ld je le lf bi translated">为改变而设计</h1><blockquote class="lg"><p id="69d5" class="lh li hi bd lj lk ll lm ln lo lp kn dx translated"><em class="lq">变化是唯一的真理！</em></p></blockquote><p id="5485" class="pw-post-body-paragraph js jt hi ju b jv lz is jx jy ma iv ka kb mb kd ke kf mc kh ki kj md kl km kn hb bi translated">管理好它的唯一方法就是接受它并为它做好计划。但是我们能计划好每一个变化吗？不，这实际上是不可能的，因为变化意味着一些我们以前没有意识到的新事物。这可能是规模或技术方面的一些新要求、缺陷或挑战。因此，管理变化的唯一方法是使我们的系统开放并适应变化。设计和编写应用程序代码，使其可以随时扩展以引入新的行为，而不会干扰现有的实现或增加大量的更改成本。</p><p id="d76c" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">神奇之处在于很好地遵循了架构原则，混合了解耦、分层、单一职责、关注点分离、开放-关闭等等。耦合度较低的体系结构是管理变更的关键，在这种体系结构中，各个组件、服务和层可以在不影响其他集成组件的情况下进行更改。</p><p id="907a" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">这不就是微服务如此受欢迎的原因吗...任何不是为改变而开发的系统最终都会增加TCO的大量成本。</p><p id="355e" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">最小原则(知识、惊讶、努力):</strong></p><p id="2278" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">最少知识原则表明，不应该要求用户理解服务(或组件)的内部。它应该只需要学习如何使用服务。有效使用服务不需要内部知识。如果这个原则没有得到遵守，并且服务行为可以通过了解内部情况来改变，那么通过引入紧耦合、意外和意外失败的下一个原则，将服务的内部复杂性传播到调用系统组件。</p><p id="55a4" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">惊奇原则表明，应用程序的实现不应该让读者感到惊奇，应该让任何了解系统领域的人都容易理解。这意味着在实现层面上的许多事情，例如:为变量/函数/类/包/模块和所有的东西有正确的命名约定，保持实现在逻辑上应该在的地方，不要横切关注点，以及在任何地方应用最少知识的原则。这是保持应用程序可维护性和长期保持低开发成本的一个重要原则。</p><p id="78c7" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">省力原则建议每个人自然地沿着尽可能不费力的路径前进。这意味着人类倾向于使用现有的知识，如果它是容易获得的并且被适当地定义，希望减少努力。而如果将现有的辛辛苦苦得来的知识投入使用，难道不会让未来的工作或系统更加有效吗？</p><p id="f079" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">在实现层面，这意味着以一种对开发人员来说显而易见的方式定义架构，遵循一种模式并实现最佳结果。例如:约定胜于配置，在系统中定义样板框架，抽象实现已经就位。一旦我们为web应用程序设计设计了一个系统，只需定义元数据，并将逻辑和视图类放在一个特定的包中，开发人员就可以轻松地创建应用程序页面。它大大降低了总成本，同时减少了错误，保持了设计的整洁。</p><h1 id="845e" class="ko kp hi bd kq kr ks kt ku kv kw kx ky ix kz iy la ja lb jb lc jd ld je le lf bi translated">降低总拥有成本</h1><p id="666d" class="pw-post-body-paragraph js jt hi ju b jv lu is jx jy lv iv ka kb lw kd ke kf lx kh ki kj ly kl km kn hb bi translated">降低总拥有成本是一个好的架构师的另一个责任，也是好的架构的一个重要属性。</p><p id="ed66" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">如果遵循以上定义的所有好的原则(以及更多),它会自动降低现在的总拥有成本，并在未来降低更多。代码越是解耦、易于扩展、易于理解和维护，就越有助于降低TCO。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="a26e" class="ko kp hi bd kq kr mm kt ku kv mn kx ky ix mo iy la ja mp jb lc jd mq je le lf bi translated">不断进化</h1><p id="0b2d" class="pw-post-body-paragraph js jt hi ju b jv lu is jx jy lv iv ka kb lw kd ke kf lx kh ki kj ly kl km kn hb bi translated">总结一下，如果我们正确遵循上述原则，它将帮助我们定义一个不断发展的体系结构，这个体系结构对变化和增量改进是开放的。这使得重构和不断向架构添加新特性变得容易。</p><blockquote class="lg"><p id="0694" class="lh li hi bd lj lk ll lm ln lo lp kn dx translated"><em class="lq">如果变化是软件生命的唯一真理，那么只有一个不断发展的架构才能存活下来</em></p></blockquote></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="03d4" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><a class="ae mr" href="https://martinfowler.com/tags/evolutionary%20design.html" rel="noopener ugc nofollow" target="_blank">这里的</a>是我的虚拟远程专家马丁·福勒提供的关于架构和设计发展的一个很好的资源:)</p><p id="9c2a" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated">网上有很多关于伟大建筑的极好的资源。然而，最终以上几点总结了基础，然后我们可以添加更多的扩展。更多的，寻找坚实的原则和最少的原则。</p><p id="6add" class="pw-post-body-paragraph js jt hi ju b jv jw is jx jy jz iv ka kb kc kd ke kf kg kh ki kj kk kl km kn hb bi translated"><strong class="ju hs">对于系统设计的演变，在这里阅读其中的</strong> <a class="ae mr" href="https://matrixexplorer.medium.com/evolution-of-system-design-from-micro-functions-to-micro-services-53cdf8e276ac" rel="noopener"> <strong class="ju hs">学习历程</strong> </a> <strong class="ju hs">。</strong></p></div></div>    
</body>
</html>