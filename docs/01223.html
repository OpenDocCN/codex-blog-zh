<html>
<head>
<title>Reverse Engineering Bare Metal Kernel Images with QEMU- Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用QEMU对裸机内核映像进行逆向工程——第1部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/reverse-engineering-bare-metal-low-level-kernel-images-with-qemu-getting-started-c705b7b14d35?source=collection_archive---------5-----------------------#2021-04-12">https://medium.com/codex/reverse-engineering-bare-metal-low-level-kernel-images-with-qemu-getting-started-c705b7b14d35?source=collection_archive---------5-----------------------#2021-04-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/7f9214a2e91cf1787aba6018760392c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/0*gJmtgSBb4Lf5Hc8s.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">来自<a class="ae iq" href="https://olayiwolaayinde.medium.com/why-learn-embedded-systems-87bbf5aafd04" rel="noopener">https://olayiwolaayinde . medium . com/why-learn-embedded-systems-87 bbf 5a AFD 04</a></figcaption></figure><p id="7d00" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">本教程是裸机逆向工程系列的一部分</strong></p><p id="bc10" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">自从我拆开了几部Android手机后，我对嵌入式系统的好奇心开始增长。虽然我不是嵌入式系统，但我知道手机最终会取代电脑；因此，我想更多地了解他们。那时我开始学习ARM，并发现它们和嵌入式设备有许多相似之处。在那之后，我开始了比赛:我开始学习关于嵌入式设备的一切知识。</p><p id="ddbc" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">什么是嵌入式系统？— </strong>嵌入式系统是一种尽可能高效、经济地服务于单一目的的设备。最常见的例子是物联网设备(如相机)。通常这需要软件只运行需要的东西；因此，需要嵌入式操作系统(例如嵌入式Linux)。</p><p id="58fa" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我决定探索的第一套嵌入式系统是Raspberry Pis，因为我已经有了一些使用它们的经验(专门针对基于hackathon的项目，而不是逆向工程或二进制开发)。它也是一个非常完善的系统，这使得学习它的某些方面是如何工作的更加容易(包括软件和硬件)。最后，它使得为它寻找开发工具变得更加容易，包括模拟器，这样我就可以随时随地进行我的项目。</p><p id="4211" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">你也不一定要从覆盆子馅饼开始...还有其他像Beaglebone设备，路由器，相机，等等。然而，对于本教程，我将主要关注树莓Pi 0。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="19e9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在进一步阅读之前，你应该知道一些基本的事情:</p><ul class=""><li id="4730" class="jw jx hi it b iu iv iy iz jc jy jg jz jk ka jo kb kc kd ke bi translated">串行通信:这是通常用于调试输入和输出的信号。通常，这需要将电缆连接到引脚上；然而，使用QEMU，我们可以将它模拟为stdin/stdout。</li><li id="e011" class="jw jx hi it b iu kf iy kg jc kh jg ki jk kj jo kb kc kd ke bi translated">引脚:这是嵌入式系统发送信号的方式(串行、JTAG等)。</li><li id="ca7e" class="jw jx hi it b iu kf iy kg jc kh jg ki jk kj jo kb kc kd ke bi translated">工具链:这是我们编译代码的方式。我们将经常进行交叉编译(因为我们在本教程中假设我们没有任何ARM硬件)。你可能听到的工具链是<strong class="it hj"> eabi、gnueabi和gnueabi-hf </strong>。对于本教程，我们将只考虑<strong class="it hj"> eabi </strong>，因为它是裸机工具链(例如，没有操作系统)。有关gnueabi和gnueabi-hf的更多信息，请点击此处。</li></ul><p id="24ff" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">首先，我们需要某种Linux平台。为此，我使用了Ubuntu 20.04，但是你可以选择任何你想要的与我下面列出的软件兼容的发行版。在您的发行版中，我们需要安装以下软件:</p><ul class=""><li id="9b99" class="jw jx hi it b iu iv iy iz jc jy jg jz jk ka jo kb kc kd ke bi translated">GDB多元建筑— <code class="du kk kl km kn b"><strong class="it hj">sudo apt install gcc-multiarch</strong></code></li><li id="af9c" class="jw jx hi it b iu kf iy kg jc kh jg ki jk kj jo kb kc kd ke bi translated">qemu(我在这个演示中用的是5.2)——【https://www.qemu.org/download/#source】<strong class="it hj"/></li><li id="765e" class="jw jx hi it b iu kf iy kg jc kh jg ki jk kj jo kb kc kd ke bi translated">一个逆向工程工具(我推荐<strong class="it hj"> Ghidra </strong>，不过这是个人喜好)</li><li id="0ebb" class="jw jx hi it b iu kf iy kg jc kh jg ki jk kj jo kb kc kd ke bi translated">可选项:gcc-arm-none-eabi — <code class="du kk kl km kn b"><strong class="it hj">sudo apt install arm-none-eabi-gcc</strong></code></li></ul><p id="d708" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">为此，我们将与qemu-system-arm合作(它也是qemu-system-aarch64的一部分)。它有许多不同的设备已经默认支持和其他你可以做的。关于使用qemu-system-arm，有一些重要的事情需要注意。首先，您将需要指定如何读取输出和写入输入(特别是对于串行)。因为我们没有使用实际的硬件，所以我们不能使用引脚作为与设备交互的方式。例如，假设我们想要模拟一个名为<strong class="it hj"> kernel.img </strong>的内核，我们需要运行以下命令来运行它:</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="0b97" class="kw kx hi kn b fi ky kz l la lb"><strong class="kn hj">- qemu-system-aarch64 -M raspi0 -kernel kernel.img -serial null -serial stdio</strong></span></pre><p id="47f0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果我们想做同样的事情，但我们可以连接到GDB，我们可以运行以下命令:</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="ef23" class="kw kx hi kn b fi ky kz l la lb"><strong class="kn hj">- qemu-system-arm -M raspi0 -kernel kernel.img -serial null -serial stdio -S -gdb tcp::4269 -boot c</strong></span></pre><p id="4e2b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这个命令具体做的是打开一个我们可以通过gdb-multiarch连接的gdb服务器，并以这种方式与之交互。为了连接到它，我们运行以下命令。</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="2fed" class="kw kx hi kn b fi ky kz l la lb"><strong class="kn hj">- gdb-multiarch<br/>- add-symbol-file kernel.elf &lt;addr&gt; — Run this command if you have an elf file for your kernel, otherwise, it is optional. <br/>- target remote localhost:&lt;port&gt;</strong></span></pre><p id="354c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我强烈建议将它作为gdb脚本文件。这样，你也可以让gdb更容易管理。这里有一些关于GDB脚本的不错的教程:</p><p id="cd0b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><a class="ae iq" href="https://www.adacore.com/gems/gem-119-gdb-scripting-part-1" rel="noopener ugc nofollow" target="_blank">https://www.adacore.com/gems/gem-119-gdb-scripting-part-1</a>T12<a class="ae iq" href="https://www.adacore.com/gems/gem-120-gdb-scripting-part-2" rel="noopener ugc nofollow" target="_blank">https://www.adacore.com/gems/gem-120-gdb-scripting-part-2</a></p><p id="7151" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">您也可以使用GEF进行调试；但是，您需要运行以下命令:</p><pre class="ko kp kq kr fd ks kn kt ku aw kv bi"><span id="e117" class="kw kx hi kn b fi ky kz l la lb"><strong class="kn hj">gdb-gef-multiarch (or however you bring it up on the console)<br/>set architecture arm <br/>add-symbol-file kernel.elf &lt;addr&gt;<br/>gef-remote -q localhost:&lt;port&gt;</strong></span></pre></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="a5b2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在我们有了执行代码的环境，有几种方法可以评估内核。除了GDB，我们还需要一个反汇编/反编译程序，比如二进制忍者或者Ghidra。这将有助于我们对内核进行逆向工程，尤其是准系统程序。准系统软件是指软件直接在没有操作系统功能的硬件上运行。这有时甚至没有像<strong class="it hj"> stdio.h或stdlib.h </strong>这样的标准库。因此，我们将没有符号，除非我们有一个ELF文件。即使这样，如果使用标准库，反编译程序和反汇编程序也有可能无法识别它们。</p><p id="2e84" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">最后，学习如何阅读ARM汇编代码至关重要。大多数嵌入式系统使用ARM架构；然而，有些人仍然使用MIPS，在极少数情况下，使用Power PC。您想要熟悉的一些术语:</p><ul class=""><li id="fd27" class="jw jx hi it b iu iv iy iz jc jy jg jz jk ka jo kb kc kd ke bi translated">呼叫约定</li><li id="861f" class="jw jx hi it b iu kf iy kg jc kh jg ki jk kj jo kb kc kd ke bi translated">序言</li><li id="e931" class="jw jx hi it b iu kf iy kg jc kh jg ki jk kj jo kb kc kd ke bi translated">尾声</li><li id="d6c2" class="jw jx hi it b iu kf iy kg jc kh jg ki jk kj jo kb kc kd ke bi translated">登记</li><li id="afd7" class="jw jx hi it b iu kf iy kg jc kh jg ki jk kj jo kb kc kd ke bi translated">记忆</li></ul><p id="c63e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在继续学习之前，你应该做的一个很棒的教程是Azeria。它有七个部分，你将能够开始学习如何逆转和利用基于ARM的代码。<strong class="it hj">经历这一切！</strong>链接:【https://azeria-labs.com/writing-arm-assembly-part-1/】T4</p><p id="142d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">您可能需要考虑的其他一些事情:</p><ul class=""><li id="d5a3" class="jw jx hi it b iu iv iy iz jc jy jg jz jk ka jo kb kc kd ke bi translated">开始学习一些<strong class="it hj"> Python </strong>，你会经常用它来开发和逆向工程脚本(这会让你的生活变得简单很多)。</li><li id="2507" class="jw jx hi it b iu kf iy kg jc kh jg ki jk kj jo kb kc kd ke bi translated">获取<strong class="it hj"> pwntools </strong>，这将帮助你开发，它支持arm和aarch 64—<a class="ae iq" href="https://docs.pwntools.com/en/latest/" rel="noopener ugc nofollow" target="_blank">https://docs.pwntools.com/en/latest/</a></li><li id="c3f3" class="jw jx hi it b iu kf iy kg jc kh jg ki jk kj jo kb kc kd ke bi translated">获取<strong class="it hj"> angr </strong>:这将帮助你发现漏洞，并对重复性任务进行逆向工程——https://docs.angr.io/<a class="ae iq" href="https://docs.angr.io/" rel="noopener ugc nofollow" target="_blank"/></li></ul><p id="6151" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在你已经准备好了！你现在应该做的是尝试解决CTF挑战，或者对你感兴趣的内核进行逆向工程。稍后，我将回顾一些你可能已经错过的重要概念(我是通过艰难的方式学到的)。</p></div></div>    
</body>
</html>