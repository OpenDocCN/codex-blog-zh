<html>
<head>
<title>Predicting Students Decision To Go Into University</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测学生上大学的决定</h1>
<blockquote>原文：<a href="https://medium.com/codex/educational-data-mining-predicting-students-decision-to-go-to-go-into-university-6ee807f33f1c?source=collection_archive---------0-----------------------#2020-07-16">https://medium.com/codex/educational-data-mining-predicting-students-decision-to-go-to-go-into-university-6ee807f33f1c?source=collection_archive---------0-----------------------#2020-07-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="84e7" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="ceb2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">教育数据挖掘是用机器学习算法分析学生数据，以推断信息来进一步帮助学生接受教育。这是一个具有巨大潜在利益的领域，多年来已经引起了研究人员和一些教育机构的极大兴趣。</p><h1 id="db73" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">目标</h1><p id="f3bd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">机器学习对教育数据的一个非常常见的应用是预测学生的成绩(我将在另一篇文章中介绍这一点)。不过，在这个项目中，我们的目标明确如下:</p><ul class=""><li id="4051" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">预测学生通过进入大学深造的最终决定。</li></ul><p id="b58d" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo km jq jr js kn ju jv jw ko jy jz ka hb bi translated">有了这些信息，学校管理者就有可能了解对每组学生采取的正确方法。要么通过向学生解释高等教育的重要性来鼓励他们，要么向他们展示可行的选择以及如何追求这些选择。</p><h1 id="7875" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">数据集</strong></h1><p id="c3e1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了创建我们的分类模型，我们需要为我们的算法提供数据。我们需要找到这些数据，在这个项目中，我们将利用一个公开的葡萄牙学校数据集。用这个网址可以找到:<a class="ae kp" href="https://github.com/Emmanuel96/Higher_edu_dec_prediction/blob/master/Dataset/student.csv" rel="noopener ugc nofollow" target="_blank">https://github . com/Emmanuel 96/Higher _ edu _ dec _预测/blob/master/Dataset/student . CSV</a></p><p id="1817" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo km jq jr js kn ju jv jw ko jy jz ka hb bi translated">下图解释了数据集中存在的要素。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es kq"><img src="../Images/024a03f2f77f265126b2b021849912f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*gOyw-sQosoB6LzFkvRK8ig.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">数据集功能简要说明</figcaption></figure><h1 id="68b5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">履行</h1><p id="f0b0" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了实现前面解释的目标，我们将使用三种不同的分类算法(多层感知器分类器、K-最近邻和Adaboost集成)根据学生的决定对他们进行分类</p><p id="b319" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo km jq jr js kn ju jv jw ko jy jz ka hb bi translated">一旦我们的环境设置好了，我们首先导入我们的Panda库，如下所示:</p><pre class="kr ks kt ku fd lc ld le lf aw lg bi"><span id="cf89" class="lh ig hi ld b fi li lj l lk ll">import pandas as pd<br/>import numpy as np<br/>import seaborn as sns</span></pre><p id="63d0" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo km jq jr js kn ju jv jw ko jy jz ka hb bi translated">请注意，如果您还没有安装这些库，您必须安装pip或conda。</p><p id="618a" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo km jq jr js kn ju jv jw ko jy jz ka hb bi translated">接下来，我们导入必要的scikit-learn库:</p><pre class="kr ks kt ku fd lc ld le lf aw lg bi"><span id="2191" class="lh ig hi ld b fi li lj l lk ll"><strong class="ld hj"># sklearn imports</strong><br/>from sklearn.metrics import mean_squared_error<br/>from sklearn.metrics import r2_score<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.preprocessing import LabelEncoder<br/>from sklearn import metrics</span><span id="e790" class="lh ig hi ld b fi lm lj l lk ll"><strong class="ld hj"># classifiers</strong><br/>from sklearn.neural_network import MLPClassifier<br/>from sklearn.ensemble import AdaBoostClassifier<br/>from sklearn.neighbors import KNeighborsClassifier</span></pre><h1 id="2b84" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">分类</h1><p id="3c81" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">机器学习算法大多属于监督或无监督学习的范畴。分类是一种监督学习，我们用来将一组数据分为两个或更多个类别。</p><p id="54ec" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo km jq jr js kn ju jv jw ko jy jz ka hb bi translated">在我们的例子中，为了实现这一点，首先，我们读取csv文件，从中创建一个数据帧，并删除空值，如下所示:</p><pre class="kr ks kt ku fd lc ld le lf aw lg bi"><span id="b5c5" class="lh ig hi ld b fi li lj l lk ll">data = pd.read_csv(<br/>    r'C:/Users/Emmanuel/Documents/projects/Python/Students Data Analysis/Dataset/student.csv')<br/>student_data = pd.DataFrame(data)</span><span id="ada3" class="lh ig hi ld b fi lm lj l lk ll"><strong class="ld hj"># drop all null data</strong><br/>student_data.dropna(inplace=True)</span></pre><h2 id="8657" class="lh ig hi bd ih ln lo lp il lq lr ls ip jo lt lu it js lv lw ix jw lx ly jb lz bi translated">处理分类值</h2><p id="7895" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">分类算法不适用于分类值，我们需要将它们转换为二进制值。在这种情况下，我们使用Pandas dummy_data函数和我们的自定义函数，如下所示:</p><pre class="kr ks kt ku fd lc ld le lf aw lg bi"><span id="0ee2" class="lh ig hi ld b fi li lj l lk ll"><strong class="ld hj"># function to convert categorical data to binary data</strong><br/>def handle_cat_data(cat_feats, data):<br/>    for f in cat_feats:<br/>        to_add = pd.get_dummies(data[f], prefix=f, drop_first=True)<br/>        merged_list = data.join(<br/>            to_add, how='left', lsuffix='_left', rsuffix='_right')<br/>        data = merged_list</span><span id="24e5" class="lh ig hi ld b fi lm lj l lk ll">    <strong class="ld hj"># then drop the categorical features</strong><br/>    data.drop(cat_feats, axis=1, inplace=True)</span><span id="1d24" class="lh ig hi ld b fi lm lj l lk ll">    return data</span><span id="9327" class="lh ig hi ld b fi lm lj l lk ll"><strong class="ld hj"># drop all null data</strong><br/>student_data.dropna(inplace=True)</span><span id="9720" class="lh ig hi ld b fi lm lj l lk ll"><strong class="ld hj"># array of categorical values</strong><br/>cat_data = ['school', 'sex', 'address', 'famsize', 'Mjob', 'Fjob', 'reason', 'guardian', 'schoolsup', 'activities', 'nursery', 'fatherd', 'Pstatus', 'higher', 'internet', 'romantic', 'famrel',<br/>            'freetime', 'goout', 'Dalc', 'Walc', 'health', 'Medu', 'famsup']</span><span id="594b" class="lh ig hi ld b fi lm lj l lk ll">student_data = handle_cat_data(cat_data, student_data)</span></pre><h2 id="55e2" class="lh ig hi bd ih ln lo lp il lq lr ls ip jo lt lu it js lv lw ix jw lx ly jb lz bi translated">拆分数据集以测试和训练数据</h2><p id="7e9a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们不能将相同的数据用于训练和测试目的，因为我们的模型已经熟悉了训练数据集，因此为了测试其准确性和稳健性，我们需要一个我们的模型不熟悉的测试数据集。</p><p id="cf87" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo km jq jr js kn ju jv jw ko jy jz ka hb bi translated">我们不能将整个数据集直接用于训练和测试，因此我们使用train_test_split方法将其分成80%用于训练，20%用于测试。我们选择较高的列作为目标列，并保留其他列，除了用于训练模型的目标列。我们通过下面的代码片段实现了这一点:</p><pre class="kr ks kt ku fd lc ld le lf aw lg bi"><span id="9efe" class="lh ig hi ld b fi li lj l lk ll"><strong class="ld hj"># divide data into training and testing data</strong><br/>X_train, X_test, y_train, y_test = train_test_split(student_data.drop(<br/>'failures', axis=1), student_data.failures, test_size=0.25, stratify=student_data.failures)</span><span id="bad6" class="lh ig hi ld b fi lm lj l lk ll"><strong class="ld hj"># classifier names for run model function</strong><br/>classifier_names = ["K Nearest Neighbour",<br/>"Neural Networks", "Adaboost Classifier"]</span><span id="09a0" class="lh ig hi ld b fi lm lj l lk ll"><strong class="ld hj"># classifiers</strong><br/>classifiers = [<br/>KNeighborsClassifier(),<br/>MLPClassifier(),<br/>AdaBoostClassifier(),<br/>]</span></pre><p id="389c" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo km jq jr js kn ju jv jw ko jy jz ka hb bi translated">最后，我们通过调用run_models函数来运行我们的模型，如下所示:</p><pre class="kr ks kt ku fd lc ld le lf aw lg bi"><span id="07a6" class="lh ig hi ld b fi li lj l lk ll"><strong class="ld hj"># run classification model</strong><br/>run_models(classifier_names, classifiers, X_train, X_test, y_train, y_test)</span></pre><h1 id="7ecf" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结果和模型评估</h1><p id="f0f3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">下表显示了所用不同算法的精度。这些值可能与您根据不同因素(即您的机器)获得的值略有不同。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es ma"><img src="../Images/0b89b39b66902d441c027affea5807b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dY7B1LkAdlfjeJk-t3fFAA.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">分类模型的准确性</figcaption></figure><p id="96f2" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo km jq jr js kn ju jv jw ko jy jz ka hb bi translated">为了评估一个模型，我们可以使用不同的因素，但是在这种情况下，我们选择精度和训练模型所花费的时间(以秒为单位)。</p><p id="bc27" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo km jq jr js kn ju jv jw ko jy jz ka hb bi translated">MLP是一个神经网络分类器；它通常需要一个大型数据集，并且可能非常复杂。这里我们使用了一个简单的版本，默认200次迭代和5层。不出所料，因为它的复杂性，它花了最长的时间。我预计精度会很高，但如果微调，它会给出更好的精度。</p><p id="a58e" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo km jq jr js kn ju jv jw ko jy jz ka hb bi translated">这里使用的最后一个分类算法是Adaboost。它是一种集成分类器，即两种或多种分类算法的组合。在大多数情况下，他们给出更好的结果，但不是在我们这里的情况。在这种情况下，它有点达不到KNN分类器。我也对超参数微调很有信心，我们会有更好的准确性</p><p id="56da" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo km jq jr js kn ju jv jw ko jy jz ka hb bi translated">我们可以很容易地看到，K个最近的邻居给出了最好的准确度；这是非常有趣的，因为它是这里使用的相对最简单的算法，给出了82.76%的准确度，同时也花费了最短的运行时间。</p><h1 id="3a65" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">未来工作:</strong></h1><p id="7f43" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">尽管我们需要用更大的数据集来测试我们的模型，但我们目前可以用它来预测学生的决定。为了使它更加稳健，我们需要微调超参数，看看这对精度有什么影响。</p><p id="7999" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo km jq jr js kn ju jv jw ko jy jz ka hb bi translated">感谢您阅读我的文章，如果您有任何问题或意见，请随时联系我。</p></div></div>    
</body>
</html>