<html>
<head>
<title>Use MySQL Window Functions to Get More out of Your Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MySQL窗口函数从数据中获取更多信息</h1>
<blockquote>原文：<a href="https://medium.com/codex/use-mysql-window-functions-to-get-more-out-of-your-data-3a5ed5fe28a1?source=collection_archive---------7-----------------------#2021-06-23">https://medium.com/codex/use-mysql-window-functions-to-get-more-out-of-your-data-3a5ed5fe28a1?source=collection_archive---------7-----------------------#2021-06-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="44dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">MySQL在其8.0版中引入了窗口函数。定位行组而不折叠它们。在本文中，我们将探索MySQL提供的最通用的窗口函数的示例实现。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/4235f4ac8fb179f23f539ed1df68bb94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rgt89xDa1hyg_AMT.png"/></div></div></figure><h1 id="c2c0" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">MySQL中的窗口函数</h1><p id="a70e" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">窗口函数是MySQL提供的一个高级特性，用于提高查询的执行性能。这些函数作用于与目标行相关的一组行，称为窗口框架。与GROUP BY子句不同，窗口函数不会将行折叠成一行，而是保留每一行的详细信息。这种新的数据查询方法在数据分析和商业智能中具有不可估量的价值。</p><h2 id="087e" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">窗口函数与聚合函数</h2><p id="ed0d" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated"><a class="ae lg" href="https://www.google.com/url?q=https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html&amp;sa=D&amp;source=editors&amp;ust=1623869458162000&amp;usg=AOvVaw3cHLTrgN1uakADEA4Yq_5U" rel="noopener ugc nofollow" target="_blank">聚合函数</a>用于从一组行中返回一个标量值。MySQL中一些著名的聚合函数有SUM、MIN、MAX、AVG和COUNT。我们可以将这些函数与GROUP BY子句结合使用来获得一个聚合值。</p><p id="8d46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，<a class="ae lg" href="https://www.google.com/url?q=https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html&amp;sa=D&amp;source=editors&amp;ust=1623869458163000&amp;usg=AOvVaw0C0BeSMOFscGODl42LAljl" rel="noopener ugc nofollow" target="_blank">窗口函数</a>为每个目标行返回一个相应的值。这些目标行或窗口函数在其上操作的一组行被称为窗口框架。窗口函数使用OVER子句定义窗口框架。通过使用OVER子句而不是GROUP BY，窗口函数可以将聚合函数作为其SQL语句的一部分。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lh"><img src="../Images/063099eeb677f6485b7272a0bccb1c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uv81DiX-VWuBpAFRKmKtVA.png"/></div></div></figure><h2 id="3008" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">最流行的MySQL窗口函数有哪些？</h2><p id="baa0" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">以下是MySQL提供的专用窗口函数:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es li"><img src="../Images/08127c32c888b3f44b01a8a2a0c363d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-BACC-qka7ZDhIZj9GpVAQ.png"/></div></div></figure><p id="bc32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请参考官方MySQL <a class="ae lg" href="https://www.google.com/url?q=https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html%23function_ntile&amp;sa=D&amp;source=editors&amp;ust=1623869458180000&amp;usg=AOvVaw0gABErYYi-TYJXmbYkpMrX" rel="noopener ugc nofollow" target="_blank">文档</a>以获得关于上述每个功能的深入信息。</p><h2 id="a251" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">MySQL中的窗口函数用例示例</h2><p id="49de" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">现在让我们来看看如何利用上面提到的一些窗口函数。</p><h2 id="899b" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">创建示例MySQL数据库表</h2><p id="14fe" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">我将使用最新的MySQL服务器实例和Arctype作为SQL客户端。下面是我们的示例数据库的结构:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lj"><img src="../Images/62cad44398c8dcb37967a9bc5bfd4a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CGZ0sfVy2j1GCFuf.jpg"/></div></div></figure><p id="998d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用以下SQL脚本通过Arctype客户端创建表结构:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="50ea" class="ks jq hi ll b fi lp lq l lr ls">CREATE TABLE departments (<br/>	dep_id INT (10) AUTO_INCREMENT PRIMARY KEY,<br/>	dep_name VARCHAR (30) NOT NULL,<br/>	dep_desc VARCHAR (150) NULL<br/>);<br/><br/>CREATE TABLE employees (<br/>	emp_id INT (10) AUTO_INCREMENT PRIMARY KEY,<br/>	first_name VARCHAR (20) NOT NULL,<br/>	last_name VARCHAR (25) NOT NULL,<br/>	email VARCHAR (100) NOT NULL,<br/>	phone VARCHAR (20) DEFAULT NULL,<br/>	salary DECIMAL (8, 2) NOT NULL,<br/>	dep_id INT (10) NOT NULL,<br/>	FOREIGN KEY (dep_id) REFERENCES <br/>		departments (dep_id) <br/>			ON DELETE CASCADE<br/>			ON UPDATE CASCADE<br/>);<br/><br/>CREATE TABLE evaluations (<br/>    eval_id INT (10) AUTO_INCREMENT PRIMARY KEY,<br/>    emp_id INT (10) NOT NULL,<br/>    eval_date DATETIME NOT NULL,<br/>    eval_name VARCHAR (30) NOT NULL,<br/>    notes TEXT DEFAULT NULL,<br/>    marks DECIMAL (4,2) NOT NULL,<br/>    FOREIGN KEY (emp_id) REFERENCES employees (emp_id)<br/>);<br/><br/>CREATE TABLE overtime (<br/>    otime_id INT (10) AUTO_INCREMENT PRIMARY KEY,<br/>    emp_id INT (10) NOT NULL,<br/>    otime_date DATETIME NOT NULL,<br/>    no_of_hours DECIMAL (4,2) NOT NULL,<br/>    FOREIGN KEY (emp_id) REFERENCES employees (emp_id)<br/>);</span></pre><p id="8dbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建表之后，我们可以使用适当的关系将一些示例数据插入到每个表中。现在，让我们回到窗口函数。</p><h2 id="f6a2" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">用ROW_NUMBER()对结果进行排序和分页</h2><p id="de70" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在我们的示例数据库中，employee表是根据emp_id排列的。但是，如果我们需要为每一行分配一个单独的序列号，那么我们可以使用ROW_NUMBER()窗口函数。</p><p id="f815" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的示例中，我们使用ROW_NUMBER()函数，同时根据薪金金额对每一行进行排序。</p><p id="0976" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果只使用GROUP BY子句进行查询，我们将得到以下结果。</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="21a7" class="ks jq hi ll b fi lp lq l lr ls">SELECT * FROM employees ORDER BY salary DESC;</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="ab fe cl lt"><img src="../Images/a735ec7c5f47f1574aa8b4329ad8273d.png" data-original-src="https://miro.medium.com/v2/0*VmDkeHHYpLUhTQx5"/></div></figure><p id="d9d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，在使用ROW_NUMBER()函数关联单个行号之后，已经为每一行分配了一个序列号:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="6d39" class="ks jq hi ll b fi lp lq l lr ls">SELECT <br/>  ROW_NUMBER() OVER( ORDER BY salary DESC) `row_num`,<br/>  first_name,<br/>  last_name,<br/>  salary<br/>FROM<br/>  employees;</span></pre><p id="d266" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="ab fe cl lt"><img src="../Images/3fb89b1a06780fb3fae2bafb1bf327fd.png" data-original-src="https://miro.medium.com/v2/0*wJ4qPG1KHh7UMMl1"/></div></figure><p id="6c82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ROW_NUMBER函数的另一个用途是分页。例如，假设我们需要以分页格式显示雇员的详细信息，每页只包含五条记录。这可以通过ROW_NUMBER函数和WHERE子句指向所需的记录集来实现:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="2458" class="ks jq hi ll b fi lp lq l lr ls">WITH page_result AS (<br/>	SELECT<br/>		ROW_NUMBER() OVER( <br/>			ORDER BY salary DESC<br/>		) `row_num`,<br/>		first_name,<br/>		last_name,<br/>		salary<br/>	FROM<br/>		employees<br/>)<br/>SELECT * FROM page_result WHERE `row_num` BETWEEN 6 AND 10</span></pre><p id="7010" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="ab fe cl lt"><img src="../Images/d603bd7dcbd385f006c1fffcf138a5a1.png" data-original-src="https://miro.medium.com/v2/0*HG73Sm4jwuRAds9_"/></div></figure><h2 id="b350" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">在MySQL窗口函数中使用PARTITION BY</h2><p id="6f96" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">使用PARTITION BY子句使我们能够根据部门对雇员进行划分。以下查询可用于获取按部门划分的员工的工资等级。</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="53b9" class="ks jq hi ll b fi lp lq l lr ls">SELECT<br/>	dep_name,<br/>	ROW_NUMBER() OVER (<br/>		PARTITION BY dep_name <br/>        ORDER BY salary DESC<br/>	) `row_num`,<br/>	first_name,<br/>	last_name,<br/>	salary,<br/>	email<br/>FROM <br/>	employees AS emp<br/>	INNER JOIN departments AS dep<br/>		ON dep.dep_id = emp.dep_id</span></pre><p id="9184" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="ab fe cl lt"><img src="../Images/1b7b98da190cf8028306e6210f3b7b0f.png" data-original-src="https://miro.medium.com/v2/0*7Dw0N8ltEIZUEsst"/></div></figure><p id="5aa7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以进一步扩展这个查询，通过提取row_num等于1的行来获得每个部门中工资最高的雇员。(因为我们已经按每个部门对员工进行了分区，所以ROW_NUMBER为每个分区开始一个新的序列)</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="f35d" class="ks jq hi ll b fi lp lq l lr ls">SELECT<br/>	ROW_NUMBER() OVER (<br/>		ORDER BY dep_name DESC<br/>	) `row_num`, <br/>	dep_name, <br/>	first_name,<br/>	last_name,<br/>	salary,<br/>	email<br/>FROM<br/>(<br/>	SELECT<br/>	dep_name,<br/>	ROW_NUMBER() OVER (<br/>		PARTITION BY dep_name <br/>        ORDER BY salary DESC<br/>	) `row_num`,<br/>	first_name,<br/>	last_name,<br/>	salary,<br/>	email<br/>	FROM <br/>		employees AS emp<br/>		INNER JOIN departments AS dep<br/>			ON dep.dep_id = emp.dep_id<br/>) AS highest_paid<br/>WHERE<br/>	`row_num` = 1</span></pre><p id="c5bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="ab fe cl lt"><img src="../Images/62aec4d2fb75cc2ac8cf8196d1fc3983.png" data-original-src="https://miro.medium.com/v2/0*dya2Le4y2DzXoSdw"/></div></figure><h2 id="8338" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">使用LAG()比较行值</h2><p id="a67d" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">LAG函数使用户能够使用指定的偏移量访问前面的行。当我们需要将前面行的值与当前行的值进行比较时，这种函数非常有用。在我们的数据集中，我们有一个名为evaluations的表，其中包括每年的员工评估。使用LAG，我们可以识别每个员工的绩效，并确定他们是否有所改进。</p><p id="0699" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们针对“evaluations”表编写一个查询，以确定LAG函数的基本输出。在该查询中，我们将按emp_id(雇员id)对雇员进行分区，并按eval_date(评估日期)对该分区进行排序。</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="2e63" class="ks jq hi ll b fi lp lq l lr ls">SELECT <br/>	emp_id,<br/>	DATE(eval_date) AS `date`,<br/>	eval_name,<br/>	marks,<br/>	LAG(marks) OVER (<br/>		PARTITION BY emp_id ORDER BY eval_date<br/>	) AS previous<br/>FROM<br/>	evaluations;</span></pre><p id="484a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="ab fe cl lt"><img src="../Images/f2523bf0777a32423f4cf7283b66206c.png" data-original-src="https://miro.medium.com/v2/0*e_d6bHYVs6Q-leIF"/></div></figure><p id="9f36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的结果集中，我们可以看到LAG函数为“marks”列返回相应的前一个值。然后，我们需要进一步细化该数据集，以获得一个数字百分比来确定员工的年度绩效。</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="f0cd" class="ks jq hi ll b fi lp lq l lr ls">WITH emp_evaluations AS (<br/>	SELECT <br/>		emp_id,<br/>		YEAR(eval_date) AS `year`,<br/>		eval_name,<br/>		marks,<br/>		LAG(marks,1,0) OVER (<br/>        	PARTITION BY emp_id <br/>            ORDER BY eval_date<br/>        ) AS previous<br/>	FROM<br/>		evaluations<br/>)<br/>SELECT<br/>	emp_id,<br/>	`year`,<br/>	eval_name,<br/>	marks,<br/>	previous,<br/>	IF (previous = 0, '0%',<br/>		CONCAT(ROUND((marks - previous)*100/previous, 2), '%')<br/>	) AS difference<br/>FROM<br/>	emp_evaluations;</span></pre><p id="69c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的查询中，我们定义了一个公共表表达式(CTE)来获取名为emp_evaluations的初始LAG查询的结果。与最初的查询有一些不同。</p><p id="3493" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个是这里我们只从eval_date日期时间字段中提取年份值，另一个是我们在LAG函数中定义了一个偏移量和一个默认值(1为偏移量，0为默认值)。当没有前面的行时，例如每个分区的开头，将填充该默认值。</p><p id="822f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们查询emp_evaluations结果集，计算每行的“marks”和“previous”列之间的差异。</p><p id="78a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们定义了一个IF条件来识别空的先前值(previous = 0)，并将它们显示为无差异(0%)或计算差异。如果没有这个IF条件，每个分区的第一行将显示为空值。该查询将提供以下格式化的输出结果。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="ab fe cl lt"><img src="../Images/e30ee3dd801f8258cd28958d3a7fa44c.png" data-original-src="https://miro.medium.com/v2/0*YnvWThnncXLh_Aqx"/></div></figure><h2 id="3de9" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">使用DENSE_RANK()为行分配等级</h2><p id="2fb7" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">DENSE_RANK函数可用于为分区中的行分配等级，并且没有任何间隙。如果目标列在多行中具有相同的值，DENSE_RANK将为这些行中的每一行分配相同的等级。</p><p id="d863" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上一节中，我们确定了员工的年度绩效。现在让我们假设我们正在向每个部门中进步最快的员工提供奖金。在这种情况下，我们可以使用DENSE_RANK为员工的绩效差异分配一个等级。</p><p id="b295" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们修改LAG function部分中的查询，从结果数据集创建一个视图。因为我们只需要在这里查询(选择)数据，所以MySQL视图将是一个理想的解决方案。我们修改了emp_evaluations中的SELECT语句，通过联接evaluations、employees和departments表来包含相关的部门、名字和姓氏。</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="9454" class="ks jq hi ll b fi lp lq l lr ls">CREATE VIEW emp_eval_view AS<br/>	WITH emp_evaluations AS (<br/>		SELECT <br/>			eval.emp_id AS `empid`,<br/>			YEAR(eval.eval_date) AS `eval_year`,<br/>			eval.eval_name AS `evaluation`,<br/>			eval.marks AS `mark`,<br/>			LAG(eval.marks,1,0) OVER (<br/>				PARTITION BY eval.emp_id <br/>                ORDER BY eval.eval_date<br/>			) AS `previous`,<br/>			dep.dep_name AS `department`,<br/>			emp.first_name AS `first_name`,<br/>			emp.last_name AS `last_name`<br/>		FROM<br/>			evaluations AS eval<br/>			INNER JOIN employees AS emp ON emp.emp_id = eval.emp_id<br/>			INNER JOIN departments AS dep ON dep.dep_id = emp.dep_id<br/>	)<br/>	SELECT<br/>		empid,<br/>		first_name,<br/>		last_name,<br/>		department,<br/>		`eval_year`,<br/>		evaluation,<br/>		mark,<br/>		previous,<br/>		IF (previous = 0, '0%',<br/>			CONCAT(ROUND((mark - previous)*100/previous, 2), '%')<br/>		) AS difference<br/>	FROM<br/>		emp_evaluations;</span></pre><p id="080b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="ab fe cl lt"><img src="../Images/e3950154a43632760079bd0a23fc6cd5.png" data-original-src="https://miro.medium.com/v2/0*PyKVscIMKWgkOo60"/></div></figure><p id="4dc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后使用这个视图(emp_eval_view ),我们使用DENSE_RANK函数为按部门划分的每一行分配一个等级，并按差异降序排序。此外，我们只选择与指定年份相关的记录(` eval_year` = 2020)。</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="49b5" class="ks jq hi ll b fi lp lq l lr ls">SELECT<br/>	empid,<br/>	first_name,<br/>	last_name,<br/>	department,<br/>	`eval_year`,<br/>	evaluation,<br/>	difference AS 'improvement',<br/>	DENSE_RANK() OVER (<br/>		PARTITION BY Department<br/>		ORDER BY Difference DESC<br/>	) AS performance_rank<br/>FROM <br/>	emp_eval_view <br/>WHERE <br/>	`eval_year` = 2020</span></pre><p id="ca61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="ab fe cl lt"><img src="../Images/dca1ed653a582585f72117c19d952e4d.png" data-original-src="https://miro.medium.com/v2/0*408p17tgjHSP16os"/></div></figure><p id="030e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们可以过滤上面的结果集，通过使用WHERE子句获得第一个排名记录(performance_rank = 1)来确定每个部门中绩效最高的个人，如下所示。</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="c7cd" class="ks jq hi ll b fi lp lq l lr ls">SELECT *<br/>FROM (<br/>	SELECT<br/>		empid,<br/>		first_name,<br/>		last_name,<br/>		department,<br/>		`eval_year`,<br/>		evaluation,<br/>		difference AS 'improvement',<br/>		DENSE_RANK() OVER (<br/>			PARTITION BY Department<br/>			ORDER BY Difference DESC<br/>		) AS performance_rank<br/>	FROM <br/>		emp_eval_view <br/>	WHERE <br/>		`eval_year` = 2020<br/>) AS yearly_performance_data<br/>WHERE <br/>	performance_rank = 1</span></pre><p id="7048" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结果:</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="ab fe cl lt"><img src="../Images/366aa2a1b3c17dec132d948e4019043c.png" data-original-src="https://miro.medium.com/v2/0*Ws2LY4Kc23NqZvdu"/></div></figure><p id="a163" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的结果集中我们可以看到，企业可以使用这个DENSE_RANK函数来识别表现最佳或表现不佳的员工和部门。这些指标对于商业智能过程至关重要，所有的功劳都归于MySQL Windows函数。</p><h2 id="9622" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">使用FIRST_VALUE和LAST_VALUE()从分区中获取第一个和最后一个值</h2><p id="a21a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">FIRST_VALUE函数使用户能够从有序分区中获得第一个值，而LAST_VALUE则获得相反的结果集的最后一个值。这些函数可用于我们的数据集，以确定每个部门中加班最少和最多的员工。</p><p id="452f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> FIRST_VALUE() </strong> <br/>我们可以使用FIRST_VALUE函数来获得各个部门中加班最少的员工。</p><p id="e36b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的SQL语句中，我们定义了一个公共表表达式，使用SUM聚合函数计算每个雇员每月的加班时间。然后使用FIRST_VALUE窗口函数，我们将获得特定部门中加班最少的员工的串联详细信息(名和姓以及加班值)。这种分区是通过PARTITION BY语句完成的。</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="4b0d" class="ks jq hi ll b fi lp lq l lr ls">WITH overtime_details AS (<br/>	SELECT<br/>		MONTHNAME(otime.otime_date) AS `month`,<br/>		dep.dep_name AS `dep_name`,<br/>		emp.emp_id AS `emp_id`,<br/>		emp.first_name AS `first_name`,<br/>		emp.last_name AS `last_name`,<br/>		SUM(otime.no_of_hours) AS `overtime`<br/>	FROM<br/>		overtime AS otime<br/>		INNER JOIN employees AS emp ON emp.emp_id = otime.emp_id<br/>		INNER JOIN departments AS dep ON dep.dep_id = emp.dep_id<br/>	GROUP BY `month`, emp.emp_id<br/>	ORDER BY `month`, emp.emp_id ASC<br/>)<br/>SELECT<br/>	dep_name,<br/>	emp_id,<br/>	first_name,<br/>	last_name,<br/>	`month`,<br/>	overtime,<br/>	FIRST_VALUE (CONCAT(first_name,' ',last_name,' - ',overtime)) OVER (<br/>			PARTITION BY dep_name<br/>			ORDER BY overtime<br/>		) least_overtime<br/>FROM <br/>	overtime_details;</span></pre><p id="a881" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将提供如下所示的结果集，指出一段时间内做得最少的员工。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="ab fe cl lt"><img src="../Images/5f2c86271a5d6e42b09f02870b2cb0df.png" data-original-src="https://miro.medium.com/v2/0*peLouivyzm1PP5ez"/></div></figure><p id="54f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> LAST_VALUE() </strong> <br/>我们可以使用LAST_VALUE窗口函数来获取各部门中加班最多的员工。语法和逻辑与FIRST_VALUE SQL语句相同，但增加了一个“frame子句”,用于定义需要应用LAST_VALUE函数的当前分区的子集。</p><p id="f7b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用的是:</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="5f4f" class="ks jq hi ll b fi lp lq l lr ls">RANGE BETWEEN <br/>	UNBOUNDED PRECEDING AND <br/>	UNBOUNDED FOLLOWING</span></pre><p id="33c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为框架子句。这实际上是通知数据库引擎，该帧从结果集的第一行开始，到最后一行结束。(在我们的查询中，这适用于每个分区)</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="f365" class="ks jq hi ll b fi lp lq l lr ls">WITH overtime_details AS (<br/>	SELECT<br/>		MONTHNAME(otime.otime_date) AS `month`,<br/>		dep.dep_name AS `dep_name`,<br/>		emp.emp_id AS `emp_id`,<br/>		emp.first_name AS `first_name`,<br/>		emp.last_name AS `last_name`,<br/>		SUM(otime.no_of_hours) AS `overtime`<br/>	FROM<br/>		overtime AS otime<br/>		INNER JOIN employees AS emp ON emp.emp_id = otime.emp_id<br/>		INNER JOIN departments AS dep ON dep.dep_id = emp.dep_id<br/>	GROUP BY `month`, emp.emp_id<br/>	ORDER BY `month`, emp.emp_id ASC<br/>)<br/>SELECT<br/>	dep_name,<br/>	emp_id,<br/>	first_name,<br/>	last_name,<br/>	`month`,<br/>	overtime,<br/>	LAST_VALUE (CONCAT(first_name,' ',last_name,' - ',overtime)) OVER (<br/>			PARTITION BY dep_name<br/>			ORDER BY overtime<br/>			RANGE BETWEEN<br/>				UNBOUNDED PRECEDING AND<br/>				UNBOUNDED FOLLOWING<br/>		) most_overtime<br/>FROM <br/>	overtime_details;</span></pre><p id="78ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将为我们提供每个部门加班最多的员工的详细信息。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="ab fe cl lt"><img src="../Images/7952d2800b3021b5085723b4c9edd70b.png" data-original-src="https://miro.medium.com/v2/0*_oXCmev9bTMAv0IG"/></div></figure><h2 id="6f5f" class="ks jq hi bd jr kt ku kv jv kw kx ky jz iq kz la kd iu lb lc kh iy ld le kl lf bi translated">结论</h2><p id="bf36" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">MySQL中的窗口函数是对已经非常优秀的数据库的一个很好的补充。在本文中，我们主要通过一些实际例子讲述了如何使用窗口函数。下一步是进一步挖掘MySQL窗口函数，并将它们与所有其他可用的MySQL功能相结合，以满足任何业务需求。</p></div></div>    
</body>
</html>