# Scala 3 宏没有痛苦

> 原文：<https://medium.com/codex/scala-3-macros-without-pain-ce54d116880a?source=collection_archive---------3----------------------->

## 带示例的 Scala 3 宏介绍

![](img/8a10e319e76e8181318a6b571d99e29e.png)

Scala 3 引入了一种处理*宏*的新方法，以及其他不错的新特性。*宏*将代码视为数据，它们允许分析其结构并在编译时生成新代码。

在这篇文章中，我将介绍 Scala 3 *宏*的一些额外特性，并展示一个可以在*宏*的帮助下解决的简单用例——如何使用外部 SQL 模式生成编译时检查的预准备语句。我经常参考这个项目，并根据它的代码描述一些特性，所以我鼓励[下载](https://github.com/plewand/scala3-macros)它，但这不是必不可少的。

该员额的范围是:

*   一个简短的词汇表，用于快速介绍后面使用的一些术语
*   *内联*代码和*类型匹配*——简短描述
*   *宏*理解概念和创建演示示例所需的基础知识
*   示例项目的描述
*   我遇到的经历和提示
*   有用资源的链接

我认为一个理论在理论上是好的，所以概念和例子一起介绍，看看它们如何在实践中应用。然而，在开始时，我将在一个小词汇表中介绍一些概念。这些定义并不精确，它们应该只是给出一些关于概念的直觉。

# 一点词汇表

*   *宏* —编译器执行的一段代码。在*宏*中，可以分析并生成代码。如果*宏*需要使用`T`类型的表达式，则需要将其转换为`Expr[T]`——适用于*宏*的表示。这个过程叫做*报价*。在*拼接*的过程中，在*宏*中创建的输出代码表示被转换回并嵌入到程序中。
*   *抽象语法树* *(AST)* —表示代码语法结构的树。在这篇文章中，作为一个 AST，我经常把它的 Scala 3 实现理解为抽象语法树。
*   *引用* —将代码转换为表示其*类型化抽象语法树*的结构的过程。对于类型`T` *的表达式`e`，引用* `’{e}`给出其类型`Expr[T]`的表示。对于类型`T` *来说，引用*是自动完成的，并产生`Type.of[T]`——一种可以在*宏*中使用的类型表示。
*   *拼接*——一个引用的双重过程——它评估一个*类型的 AST* 作为*宏*中生成的`Expr[T]`嵌入到封闭代码中。如果`e`是`Expr[T]`类型，拼接`${e}`将插入该 *AST* 代表的`T`类型的代码。
*   *引用表达式*—类型为`T`的表达式表示为`Expr[T]` ，可在*宏*中分析。它是一种高级表示，在视觉上类似于常规代码。它允许分析和构建代码，而无需深入了解其内部表示，如*类型化的 AST* 。
*   `Type[T]`、`Type.of[T]`—可在宏中分析的 T 类型的非擦除表示。如果我们有一个类型为`T`的表达式，`Type.of[T]`是由编译器提供的。
*   *术语*—在*反射模块*中定义的`Expr[T]`的低级*型 AST* 表示。对于`T`类型的`e`来说`Expr[T]`是它的高级表示。其项可用`asTerm`法求得。从`Term`派生出代表代码结构的特定类型(如`New`术语调用`new`，`Block`用于代码块)。
*   *反射 API* —提供对*类型 AST 访问的低级 API。*位于*反射模块*中。
*   *级别一致性*——一种保持*宏*生成的代码一致的方法。例如，不可能在结果代码中直接嵌入在*宏*中定义的变量，只能嵌入表示变量的表达式。
*   *内联* —将代码放在使用的地方，而不是它的引用。
*   *TASTy (Typed AST)y* —一种保存代码信息的格式，包括 *AST* 、源位置、文档。它由 *scalac* 编译器在编译期间产生的文件中使用(更多信息[在此](https://docs.scala-lang.org/scala3/guides/tasty-overview.html))。
*   *符号* —每个定义，比如变量、方法或类型，都有一个*符号*与之相连。*符号*给出了一些关于底层定义的信息。当您需要在*宏*中创建一个新方法或变量，或者使用*反射 API* 实用函数时，它们也很有用。

# 在一条直线上的

Scala 3 中的*内联*保证了*内联代码*会在使用的地方被扩展。

*   对于方法，它们的主体将被插入到调用的位置。
*   对于表达式，它们将在编译时计算。
*   对于方法参数，它们将被插入到使用的地方(注意作为*内联*参数传递的方法和副作用)。

让我们看看下面的例子:

输出将是:

函数体`f`在调用的地方被*内联*。主体的第一行包含`summonInline` —在函数被*内联*后，获取给定的*的实用程序(在[类型类派生](https://docs.scala-lang.org/scala3/reference/contextual/derivation.html)期间有用)——在*内联*后，它看到在调用位置定义的给定*的*。它的参数被插入到用法的位置，所以副作用是累积的。*

函数`g`是一个常规函数， `summonInline`发生在它被定义的对象中，所以它看到*给*的值为“定义”。它的参数是由值给出的，所以副作用发生在传递它的过程中。

更多信息[此处](https://docs.scala-lang.org/scala3/guides/macros/inline.html)。

# 匹配类型

这是 Scala 3 的一个新特性，它允许根据类型的右边来减少类型。

在示例程序中，它用于根据预准备语句的类型生成函数调用的类型。列的定义由类表示:

问题是如何获得参数列表的类型来分配具有列定义的值，即`(Col[Int](“a”), Col[String](“b”))` get `(Int, String)`的
。我们能*匹配类型*很幸运:

1.  在这种情况下,`Tuple`被用来表示论点。
2.  对于空元组，空元组作为停止条件返回。
3.  如果类型`ColDef[b]`匹配为元组头，则在匹配中提取`b`并用作新元组类型的头。之后，元组的其余部分被递归匹配。

更多信息[此处](https://docs.scala-lang.org/scala3/reference/new-types/match-types.html)。

# 宏指令

在这一节中，我将通过例子介绍 Scala 3 宏的一些基本概念。

## 行情

一个*引用*将一个`T`类型的表达式转换成其*类型的抽象语法树*的高级表示为`Expr[T]`。此外，它将类型`T`转换为`Type[T]`——一种在*宏*中使用的类型表示。

例如下面的表达式将生成函数调用的`Expr[Unit]`。

## 插接

*拼接*是与*报价相反的操作。*它评估并嵌入一个 *AST* 到代码中。该示例出现在项目的`SimpleMacro.scala`中。

1.  对于`Expr[String]`类型的`str`，拼接`$str`将评估 *AST* 以将其转换回代码，因为需要对其调用`toUpperCase`函数(该操作作用于代码结构，此处不执行任何调用)
2.  然后将生成的`expr`嵌入到结果代码中。

## 宏观结构

让我们来看看一个简单宏的结构——它是一个打印一个 *AST* 的实用程序，以后如何以及为什么要使用它。在项目中可以在`LogAST.scala`文件中找到。

1.  该导入需要与*宏*系统交互。
2.  每个宏都有相似的结构:它有一个*内联的*入口点，调用它的实现。入口点有一个常规签名，在本例中是一个类型为`T`的表达式。然后引用参数将其转换为`Expr[T]`。转换后的表达式被传递给实现。实现产生了`Expr[T]`，所以需要拼接得到所需的`T`类型的表达式。为此，宏被插入到*拼接*中。
3.  该实现对*宏*入口点的提升参数起作用。编译器自动提供提升到`Type[T]`和`Quotes`的`T`类型。当类型`T`将在后面引用*和*时，在上下文中需要`Type[T]`。在这个*宏*中，它仅用于打印关于表达式类型的信息。
4.  它是一个依赖的导入(在作用域中需要一个`Quotes`实例),并且允许使用*术语*——一个处理 *AST* 的低级机制。
5.  得到`Expr[T]`的一个*项*。*术语*提供了一种以低级方式分析和构建 *AST* 的方法。代码的每个构造都有一些表示，可以用来获取信息或创建信息(例如`Apply`表示一个函数调用)。
6.  显示关于类型的信息—它隐式地使用了`T:Type`。`Type.of[T]`由编译器自动提供。
7.  使用 ANSI 颜色打印结果代码。Scala *宏*系统有一些打印机帮助调试，并以不同的方式呈现信息。
8.  打印出 *AST* 结构，它是如何在低层次上被构建的。
9.  返回表达式本身。得益于此，宏*可以透明地使用。*

示例—打印对象构造(`LogASTTest.scala`):

输出:

在生产线(1)上可以看到 *AST* 。这些元素是出现在`Quotes.scala`中的*术语*。代码中的每一个构造都有它的表示。可以使用这些元素手动构建结果代码(尽管通常*引用* / *拼接*更容易)或者在*模式匹配*中使用这些类型(后面是一个例子)。

宏*的逻辑*在编译时执行——调用`sbt compile`查看。

*宏*在使用处被扩展，因此需要定义为*内嵌*。此外，为了获得传递给宏的参数的代码结构信息，参数需要被*内联*。

## 反射 API

使用*引用*和*拼接*并不能实现所有事情。Scala 3 *宏*通过`quotes.reflect`模块中的 API 提供了对低级别*类型 AST* 的访问。表达式、类型表示、符号等都有定义的类型。他们被组织在一个等级结构中。让我们来看一段摘录，完整的结构记录在`Quotes.scala`中:

父级中定义的每个操作在子级中也可用。对于一个`term`，使用`term.show(using Printer.TreeStructure)`可以看到这些元素。例如，让我们看看`Ident`是如何组织的。这种类型代表一个带有名称标识符:

它的父节点是`Ref`——引用的表示。每种类型都有一个模块，该模块具有构造实例和`unapply`的方法——在这种情况下，可以提取*模式中与*匹配的名称。`IdentMethods` 包含可以在实例上执行的操作。

## 标志

*符号*存在于各种定义背后，需要配合多个*反射 API* 函数。下面是一个例子——它将生成一个新函数，在运行时打印关于*符号*所有者的信息。

1.  `Symbol`包含几个有用的方法，`spliceOwner`返回包含当前*拼接上下文*的定义的*符号*。在本例中是*宏*。每个*符号*都有一个方法`owner`来获取其父*符号*。
2.  要创建一个新功能，就必须创建它的主体。可以用*引用*和拼接来创建，也可以用*反射模块*中提供的*型 AST* 元素来创建。
3.  一个新函数是用另一个`Symbol`方法创建的，这个方法的名字叫`newMethod`。它接受应该定义的所有者*符号*，名称和签名描述。同样，可以用其他的`Symbol`方法创建变量，也可以得到与类相关的*符号*。
4.  `DefDef`代表 *AST 中的功能定义。*它需要绑定到为新方法创建的*符号*。
5.  定义必须嵌入到某个可以计算为表达式的*术语*中(*术语*有`isExpr`方法来检查它)。它的结构是通过用`logAST` 助手打印空函数定义的 *AST* 得到的。

# 示例问题—安全的预准备语句

在这一节中，我将展示一个示例问题，以及如何使用类型匹配支持的 Scala 3 *宏*来解决这个问题。

假设我们必须解决以下限制/要求:

*   数据库访问库在运行时检查查询中使用的数据，可能会传递不正确的数据类型。
*   SQL 模式保存在一个单独的文件中，以便于 DB 团队使用。
*   代码在更改时应该与模式保持一致。
*   应该尽快检测出所有的模式不匹配。
*   可以用 Scala 3 甚至*宏*。

让我们看看 Scala 3 的特性如何帮助解决这个问题:

*   创建一个不安全语句的包装器，防止使用无效的数据类型— *类型匹配*。
*   一个知识来源——模式可以留在文件中。模式在编译时被读取，并根据它检查调用— *宏*。
*   安全预准备语句在*宏*中生成，并用模式*宏*进行验证。
*   任何名称或类型不匹配都会在编译时报告— *宏展开*。

## (计划或理论的)纲要

这个例子中的模式非常简单。它保存在`sql/schema.sql`文件中:

## 宏用法

只需要从应用程序代码中调用它来生成一个安全的预准备语句:

1.  对带有参数的*宏*的调用:作为*字符串*的表名和作为*元组*的列定义(它是未包装的，所以看起来像一个常规调用)。注意，所有的参数都需要在编译时知道，因此*字符串*是常量。如果没有编译错误发生，这意味着给定的参数是有效的，并且与 SQL 模式一致。
2.  调用生成的代码。类型已检查。

## 宏入口点

1.  引入一个辅助函数是因为*内联的*入口点需要一次调用。
2.  由于*宏*有更多的逻辑，它被保存在一个*类*中。它的构造函数捕获参数中传递的*引号*。
3.  `CallArgs[A]`用于构造与*类型匹配*的返回类型。
4.  为了简化处理，表名和列定义被分成两个参数。

## 宏构造函数

这里有趣的是一个`Quotes`实例(1)和依赖导入(2)，它们在*宏*的所有函数之间共享。

## 主流

1.  这个函数是从入口点调用的(带有一个辅助函数)。注意，不需要*引号*，因为它在类的构造函数中是可见的。
2.  可以获得传递给宏*“call”的值，但是它们必须在编译时可用。在这种情况下，表名被假定为常量*字符串*，因此我们可以访问它。如果表达式不能在编译时求值，函数`valueOrError`将报告一个编译错误。*
3.  *`parseColumnInfo`是编译时执行的函数。它接受一个*术语*(一个 *AST* 的非类型化表示，比`Expr`有更多的方法可以调用)作为参数。*
4.  *如果解析成功，那么将解析的参数与从 SQL 脚本中读取的模式进行比较。*
5.  *SQL 命令构建为`String`。要在返回的代码中使用它，需要从它创建一个表达式。通过将它包含在`Expr(…)`中来完成。*
6.  *最后一部分是生成代码以创建预准备语句。注意一件重要的事情——`UsafeStatement($sql)`将生成的`Expr[String]`类型的`sql`嵌入到*宏*中，生成引用的代码。它将作为*字符串*嵌入到最终代码中。*

## *反射 API —解析宏参数*

1.  *该函数接受转换为`Term`的`Expr`。*
2.  *该表达式与使用*反射 API* 提取`columnDefs`——传递给*宏*的参数相匹配。要匹配的结构是使用`logAST`助手获得的。打印代码的内部结构可以快速找到可以从中提取什么和如何提取，以及我们应该在`Quotes.scala`中搜索什么。*
3.  *每个列定义*术语*在一个单独的函数中被解析。*
4.  *如果*宏*遇到未知的代码结构，内置的报告实用程序会报告编译错误。*

## *引用模式—解析列定义*

1.  *为了使用*引用的模式匹配*,`Term`被转换回`Expr`。如果不是`ColDef[_]`，则报告编译错误。*
2.  *如果*引用表达式*匹配，则检查该表达式是否与*案例*中给出的*引用表达式*等价。该模式可用于提取要在匹配用例中使用的表达式的类型和部分。在这种情况下，提取作为*宏*的参数给出的`ColDef` 构造中使用的类型和表达式。换句话说，代码的结构用于在编译时生成一些逻辑，不执行运行时的`ColDef`构造。*
3.  *获得`TypeRepr`来构造列定义。`TypeRepr` 允许获取关于类型的一些信息，比`Type[T]`更多。*
4.  *由于`ColDef`的构造函数参数是一个列名，并且需要在编译类型上可用`valueOrError`才能使用。如果在编译时无法计算该值，它将报告编译错误。*
5.  *报告未知表达式的错误。*

## *报价类型模式匹配-列类型*

1.  *`Type[T]`可用于*模式匹配*，需要与`’[S]`匹配，其中`S`为显式类型或捕获。*
2.  *小写值被捕获并可在案例中使用。*

# *如何使用宏*

*这一节包含了对使用*宏*的方法的描述(很多是基于我在最后包含的博客)，一些技巧和我遇到的问题。*

*   *打印代码的*AST*(`logAST`helper)来查看应该生成或分析什么是使用*宏*代码的一种非常有用的方法。*
*   *识别完`AST`的零件后，查看`Quotes.scala`中所需的元素。有些*术语*包含更多功能，有些则更少。还要检查`unapply`在*模式匹配*中可以提取什么。*
*   *有些表达式用匹配的*引号更方便匹配(例子中是单个参数)，有些使用*反射 API* (例子中是参数提取)。**
*   *在*宏*类构造函数中使用公共`Quotes`实例是在方法间共享它的一种便捷方式。*
*   *在*反射模块*的`Quotes.scala`中，有几个实用函数可以帮助处理树，例如`TreeAccumulator`，*
*   **具有 *Metals* 扩展的 Visual Studio 代码*在编写时比 *IntelliJ* 插件工作得更好。*

# *摘要*

*![](img/70188dd9fce3dc50970d7e64be069895.png)*

*恭喜你，你到了帖子的末尾！感谢阅读或浏览，我希望你已经找到有用的东西。涵盖的主题只是介绍，还有很多可以尝试的。下面我列出了一些我认为有用的资源:*

*   *[元编程参考](https://docs.scala-lang.org/scala3/reference/metaprogramming.html)*
*   *[Scala 3 宏指南](https://docs.scala-lang.org/scala3/guides/macros/macros.html)*
*   *[报价文件](https://scala-lang.org/api/3.x/scala/quoted/Quotes$reflectModule.html)*
*   *非常好看的博客:
    1。[https://blog . software mill . com/starting-with-Scala-3-macros-a-short-tutorial-88e 9 D2 b 2584 c](https://blog.softwaremill.com/starting-with-scala-3-macros-a-short-tutorial-88e9d2b2584c)
    2 .[https://softwaremill.com/scala-3-macros-tips-and-tricks/](https://softwaremill.com/scala-3-macros-tips-and-tricks/)3。[https://medium . com/virtuslab/tasty-way-of-re-writing-macros-in-Scala-3-3c e 704 a2 c37c](/virtuslab/tasty-way-of-re-writing-macros-in-scala-3-3ce704a2c37c)*
*   *[带有宏示例的储存库](https://github.com/lampepfl/dotty-macro-examples)*

*项目的存储库可以在 [GitHub](https://github.com/plewand/scala3-macros) 上获得。*