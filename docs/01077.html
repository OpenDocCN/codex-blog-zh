<html>
<head>
<title>Unity Development — Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity开发—协同程序</h1>
<blockquote>原文：<a href="https://medium.com/codex/unity-development-coroutines-adae74fcd857?source=collection_archive---------20-----------------------#2021-04-02">https://medium.com/codex/unity-development-coroutines-adae74fcd857?source=collection_archive---------20-----------------------#2021-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/727a63b7238a0298fcfc7d6f623b11b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*y_OJlBJH28-pqqznLAl4Rg.gif"/></div></div></figure><p id="f040" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经看到了如何使用变量，移动对象，碰撞和触发器如何与unity甚至协同程序一起工作。</p><p id="a7a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们把所有的知识放在一起，做一个简单的自动门系统。</p><p id="507a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们继续下一步之前，让我们简要地看一下协程。</p><p id="a06f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">T3】协程:T5】</strong></p><p id="5dc7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可以把它们想象成一个特殊的函数，让你暂停/延长代码块的执行。任何例行工作或任何您希望随时间执行的事情，这时您将使用协程。例如，日夜循环，它总是发生，所以它可以被假设为一个例行工作或一个秘密游戏，其中一个敌人发现了你，现在他暂停了他正在做的一切，并移动到他最后一次看到你的地方，在这里，停止他正在做的任何事情(可能是巡逻)的行为可以使用协程来完成。因此，您可以假设，无论何时，当您需要在一段时间内做一些事情，或者当您做一些需要中断的事情或中断流程的事件时，使用协程都是一个安全的选择。</p></div><div class="ab cl jq jr gp js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hb hc hd he hf"><p id="36c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来制作一个自动门系统，当玩家靠近门时，门会自动打开，进入门后会自动关闭。</p><p id="cada" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，开门和关门的动作可以看作是一个例程，所以我们可以使用协程来实现它。</p><p id="1cb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从运动开始，</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jx"><img src="../Images/d7df18631477d8c365c032dfb06afb86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uXEEb_PxmMTrMIvwKm10Q.png"/></div></div></figure><p id="0769" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中，<strong class="is hj"> UserInput() </strong>返回我们的输入的规范化向量3。Clamp用于创建玩家边界。</p><p id="e4fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">移动完成后，让我们继续创建一个触发区，玩家一接触它就触发一个事件。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/d6c4d1a05ee87454454fb89c3e034965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjo3BkfYniAczZiEJa3iiQ.png"/></div></div></figure><p id="912f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，跳跳虎是一个空的游戏对象，它包含一个带有触发器的盒子碰撞器，以及一个触发我们的<strong class="is hj">协程</strong>的行为脚本。</p><p id="2592" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成后，让我们检查碰撞，这可以通过，</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/27e0eb06fc988ee314aa03d84e2e717a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08GnXOVTdKmienHD1Zm0-A.png"/></div></div></figure><p id="d44c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，当我们进入触发区域时，调用<strong class="is hj"> OnTriggerEnter() </strong>，当我们退出该区域时，调用<strong class="is hj"> OnTriggerExit() </strong>。<strong class="is hj">“其他”</strong>存储与我们的游戏物体发生碰撞的物体的碰撞体。<strong class="is hj"> GetComponent() </strong>用于获取<strong class="is hj">触发事件(脚本)</strong>中的<strong class="is hj"> DoorClose() </strong>。</p><p id="7d30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们来看看使这成为可能的协程，</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ke"><img src="../Images/c1145ccebd19160b72db2148de959866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zApYMVrsfk0Y81NB9kULQg.png"/></div></div></figure><p id="ffaf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的想法是，在触发我们的事件打开/关闭门时。我们将收缩/扩展门，因此当我们减少或增加对象的局部比例时，使用<strong class="is hj"> while循环</strong>。但是，如果这是一个正常的方法，整个过程将在一个单一的框架中完成，这不是我们想要的。因此，我们使用协程，协程允许我们使用<strong class="is hj"> yield return </strong>语句，其中null表示我们作为while循环在继续之前一直等到帧的末尾。这给了我们一种渐进和一致的开门/关门的感觉。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kf"><img src="../Images/9df71fe06c4d76d436d862b2b2401f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7G8S8pv3fZIVxr0winos1g.png"/></div></div></figure><p id="e7de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> StartCoroutine() </strong>是自明的。</p><p id="25d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以查看我以前的<a class="ae jo" href="https://sidthakur3519.medium.com" rel="noopener">文章</a>来了解更多关于主题的细节。</p><p id="af5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一个小技巧，使单面缩放对象…</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e9c85ecbf0a465415fa9a7f41d2c9190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_XsQfKoxL_6ZxDt211H8jA.gif"/></div></div><figcaption class="kg kh et er es ki kj bd b be z dx translated">当我们沿着一个轴缩放一个对象时，通常会发生这种情况</figcaption></figure><p id="98e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，这可以通过创建一个空对象，重置其<strong class="is hj">变换</strong>，然后用我们想要的对象作为父对象，并将其设置到我们想要的位置来实现，例如，如果我们希望沿x轴正方向缩放对象，我们可以将变换设置为0.5，如果我们希望沿负方向缩放，我们可以通过将其变换设置为-0.5来实现。(0.5，因为我们的立方体对象的比例为1)。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/605f10efdf3d569f265cecd6c21572a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2UKzOfrLYWuf5e1tJZsdgw.gif"/></div></div></figure><p id="5ac8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更多即将推出！！！！！！</p></div></div>    
</body>
</html>