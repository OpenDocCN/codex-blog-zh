# 软件架构的关键原则

> 原文：<https://medium.com/codex/key-principles-of-software-architecture-3a500f177f93?source=collection_archive---------1----------------------->

## [法典](http://medium.com/codex)

## 让我们也解码什么是建筑，建筑师做什么

![](img/c966f36bccccc8e18ce90d1165abce00.png)

皮沙贝

很长一段时间，我一直想知道什么是软件“架构”。如果架构是那些表示系统组件、层、交互和数据流的漂亮图表，那么什么是“高层次设计”。我花了很长时间才找到或意识到答案。

形式上，建筑有很多定义。然而，常见的术语是构建模块、基本结构、设计蓝图等等。这明确反映了它对产品的重要性。

我逐渐意识到，架构是对产品来说非常重要的东西，如果我们在生命周期的早期做出这些决定，它可以使产品变得优雅、稳定、抽象、易于扩展和发展。然而,“多早”是有上下文关系的，在此之后的任何时间做出改变都是昂贵的。

# 什么是软件架构

> *任何对应用程序来说重要的东西，最好尽早识别和定义，以及对所有这些工件的共同理解都可以被称为软件架构*

# 谁是软件架构师

(我更喜欢将软件架构作为日常开发的一部分，而不是一个独立的部门)，

> *认识到以上几点，并把全部心思放在识别什么对应用程序是重要的，在早期阶段优雅地构建这些元素，并确保这成为整个团队的共识。*

注意上面的“共识”字样。这是该角色最重要的部分，即带来对整个技术和产品愿景一致性的共同理解。最好是围绕它建立一个易于叙述的故事，每个人都可以在日常工作中容易地记住和谈论。

现在，我们理解了建筑和建筑师。故事的下一部分是关于如何确保我们有好的架构。这给我们带来了软件架构的一些关键原则。我们在网上有许多记录良好的丰富资源，因此，我们将不赘述，而是用一些经验总结一下。

# 软件架构的关键原则

# 减少返工，降低风险

首要的是如何减少返工。我们无法控制业务需求的变化，相反，新的需求对业务有益。然而，我们可以控制改变的数量，我们需要在一个应用程序中作出任何新的要求。神奇的原理是坚实的。然而，让我们打破僵局，用简单的术语来谈一谈，

**不要重复(干):**是的，不要再写那些你可以从现有实现中使用的代码。这就是持续重构的习惯“大有帮助”的地方。需要一些你已经在另一个模块中编写的实现，把它拿出来，使它通用，以便在所有地方使用。识别、重构并使其通用化以便重用。

每当我们编写重复的代码时，我们都需要维护更多的代码，需要在多个地方为相同的需求进行更改，需要对系统进行更多的测试，由于多个地方的更改，可能会有更多的 bug。

**单一责任:**如果我需要挑选一个关键原则，我会投赞成票。这就是“单一责任原则”对于保持代码可读性、可维护性以及长期工作的重要性。

确保任何代码单元都属于一个特定的职责。经验法则:它应该总是被改变以服务于一个特定的意图。通过这样做，我们带来的最大影响是让读者和开发者明白我们的意图。如果代码可以清楚地表达自己的意图，那么应用程序代码就可以像故事书一样被阅读。现在，谁不喜欢整天看故事而不是谜题呢？这是重要的原则之一，如果认真遵循，可以使代码长期可维护，从而延长整个应用程序的寿命。我们需要花更少的精力来培训新的开发人员，或者解决任何问题或扩展功能。

它还大大降低了总拥有成本。

*代码单元:应用程序、模块、类、函数——它们都是各自上下文中的代码单元，区别在于“用户”。*

**开放关闭原则:**实现应该对扩展开放，对变更关闭。现在，这可能是一个令人困惑的说法。让我们从实现的角度来简化它。

使用接口来定义行为。接口有助于通过另一个类实现随时在应用程序中添加新的行为。这意味着如果我们简单地为同一个接口添加一个新的实现，并为用户/调用者(DI)注入它，那么调用者或接口的用户不需要改变任何东西。我们不需要对调用代码进行任何更改。我们只是通过增加一种实现风格来扩展行为。本质上，我们增强了系统行为，而没有对现有的实现进行更改，只是简单地扩展了现有的行为，添加了新的风格。

好处是巨大的。它有助于避免对现有代码的修改，这种修改通常会增加测试成本和潜在的错误。它改进了接口背后的关注点的抽象，而不是当调用者需要知道使用多个类来实现多种风格时。

*示例:*咖啡机使用咖啡机(接口)制作咖啡。我们有一台浓缩咖啡机(EspressoCoffeeMachine)，咖啡机就用这个。在未来，如果我们想要添加更多的机器，例如制作卡布奇诺，我们可以在系统中添加另一台机器(CappuccinoCoffeeMachine 实现 CoffeeMachine)，并根据上下文将这台新机器注入 CoffeeMaker。最终结果是，我们添加了新的行为，而没有改变咖啡机，咖啡机或 EspressoCoffeeMachine 中的任何代码。但是我们刚刚添加了一个新的实现。

# 为改变而设计

> *变化是唯一的真理！*

管理好它的唯一方法就是接受它并为它做好计划。但是我们能计划好每一个变化吗？不，这实际上是不可能的，因为变化意味着一些我们以前没有意识到的新事物。这可能是规模或技术方面的一些新要求、缺陷或挑战。因此，管理变化的唯一方法是使我们的系统开放并适应变化。设计和编写应用程序代码，使其可以随时扩展以引入新的行为，而不会干扰现有的实现或增加大量的更改成本。

神奇之处在于很好地遵循了架构原则，混合了解耦、分层、单一职责、关注点分离、开放-关闭等等。耦合度较低的体系结构是管理变更的关键，在这种体系结构中，各个组件、服务和层可以在不影响其他集成组件的情况下进行更改。

这不就是微服务如此受欢迎的原因吗...任何不是为改变而开发的系统最终都会增加 TCO 的大量成本。

**最小原则(知识、惊讶、努力):**

最少知识原则表明，不应该要求用户理解服务(或组件)的内部。它应该只需要学习如何使用服务。有效使用服务不需要内部知识。如果这个原则没有得到遵守，并且服务行为可以通过了解内部情况来改变，那么通过引入紧耦合、意外和意外失败的下一个原则，将服务的内部复杂性传播到调用系统组件。

惊奇原则表明，应用程序的实现不应该让读者感到惊奇，应该让任何了解系统领域的人都容易理解。这意味着在实现层面上的许多事情，例如:为变量/函数/类/包/模块和所有的东西有正确的命名约定，保持实现在逻辑上应该在的地方，不要横切关注点，以及在任何地方应用最少知识的原则。这是保持应用程序可维护性和长期保持低开发成本的一个重要原则。

省力原则建议每个人自然地沿着尽可能不费力的路径前进。这意味着人类倾向于使用现有的知识，如果它是容易获得的并且被适当地定义，希望减少努力。而如果将现有的辛辛苦苦得来的知识投入使用，难道不会让未来的工作或系统更加有效吗？

在实现层面，这意味着以一种对开发人员来说显而易见的方式定义架构，遵循一种模式并实现最佳结果。例如:约定胜于配置，在系统中定义样板框架，抽象实现已经就位。一旦我们为 web 应用程序设计设计了一个系统，只需定义元数据，并将逻辑和视图类放在一个特定的包中，开发人员就可以轻松地创建应用程序页面。它大大降低了总成本，同时减少了错误，保持了设计的整洁。

# 降低总拥有成本

降低总拥有成本是一个好的架构师的另一个责任，也是好的架构的一个重要属性。

如果遵循以上定义的所有好的原则(以及更多),它会自动降低现在的总拥有成本，并在未来降低更多。代码越是解耦、易于扩展、易于理解和维护，就越有助于降低 TCO。

# 不断进化

总结一下，如果我们正确遵循上述原则，它将帮助我们定义一个不断发展的体系结构，这个体系结构对变化和增量改进是开放的。这使得重构和不断向架构添加新特性变得容易。

> *如果变化是软件生命的唯一真理，那么只有一个不断发展的架构才能存活下来*

[这里的](https://martinfowler.com/tags/evolutionary%20design.html)是我的虚拟远程专家马丁·福勒提供的关于架构和设计发展的一个很好的资源:)

网上有很多关于伟大建筑的极好的资源。然而，最终以上几点总结了基础，然后我们可以添加更多的扩展。更多的，寻找坚实的原则和最少的原则。

**对于系统设计的演变，在这里阅读其中的** [**学习历程**](https://matrixexplorer.medium.com/evolution-of-system-design-from-micro-functions-to-micro-services-53cdf8e276ac) **。**