<html>
<head>
<title>First Missing Positive Number in an Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数组中第一个缺失的正数</h1>
<blockquote>原文：<a href="https://medium.com/codex/first-missing-positive-number-in-an-array-d06505aafbe4?source=collection_archive---------9-----------------------#2021-04-02">https://medium.com/codex/first-missing-positive-number-in-an-array-d06505aafbe4?source=collection_archive---------9-----------------------#2021-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/3c8eec7bfb23c79546ffa2c843ae5c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*PweC_ngLKLm6g67ReptR8g.png"/></div></figure><p id="e0fa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最近在一次技术面试中，我被要求解决以下问题:</p><p id="dd2a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">编写一个函数，查找不在给定的非负非重复整数数组中的最小非负整数</p><p id="1b87" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我认为这是一个非常好的问题，因为起初它似乎非常简单，但随着你深入研究，几乎肯定会有许多方法来改进你最初提出的解决方案。让我们现在就开始吧。</p><h1 id="cb5e" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">蛮力</h1><p id="2e42" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">当我做这类问题时(特别是在面试环境中，当面试你的人在看你写代码时，有一个时间因素)，我喜欢从屏幕上的一些东西开始，然后得到一个答案。</p><p id="406c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">做到这一点的最好方法是想出强力解决方案，然后在你有了一个工作函数后对其进行优化，并且可以更深入地研究逻辑。</p><p id="072d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我们的例子中，最简单的强力解决方案是嵌套循环。外部循环将从0开始向上计数(因为0是最小的非负整数),并一直向上计数，直到找到我们要寻找的数字。</p><p id="0215" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">内部循环将扫描整个数组，寻找外部循环给出的数字。如果找到那个号码，它将继续，如果没有，我们有我们的号码，它将返回它。</p><p id="7cb0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们把它付诸实践:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="d30e" class="kw jl hi ks b fi kx ky l kz la">const smallest = function(nums){<br/>  for (let i = 0; i&lt;Infinity; i++){<br/>    if (!nums.includes(i)) return i<br/>  }<br/>  return nums.length<br/>}</span></pre><p id="318c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">简单有效。这将遍历所有的数字，直到无穷远，直到我们找到一个不在数组中的数字。的。includes()方法为我们处理内部循环。</p><p id="960d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们的空间复杂度是很大的O(1)，但是我们的时间复杂度不是最好的O(N)</p><h1 id="cb21" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">整理</h1><p id="0d03" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我的下一个直觉是，如果我们对数组进行排序，理论上我们可以大大减少运行时间，因为我们最多只需要遍历数组一次，只是检查整数的顺序是否正确。在最坏的情况下，我们一直到达数组的末尾，没有发现一个缺口，并且我们知道下一个最小的数就是数组的长度(例如，在[0，1，2，3]的数组中，没有出现的最小数是4，这也是数组的长度)。</p><p id="d957" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">其代码如下:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="6c88" class="kw jl hi ks b fi kx ky l kz la">const smallest = function(nums){<br/>  nums = nums.sort()<br/>  <br/>  if (nums[0] !== 0) return 0<br/>  <br/>  for(let i = 0; i&lt; nums.length; i++){<br/>     if (nums[i+1] - nums[i] !== 1){<br/>       return nums[i] + 1<br/>     }<br/>   }<br/>  return nums.length<br/>}</span></pre><p id="e90b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的For循环现在只对数组的每个元素运行一次，所以它是O(N)。然而，自从我们的。sort()方法以O(N log N)时间复杂度运行，与我们的线性循环相比，它实际上是更大的因素。所以我们的时间复杂度O(N log N + N)降低到(O N log N)。</p><p id="ab01" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好吧，我们越来越接近了，但我们可以做得更好。</p><h1 id="2c49" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">哈希表</h1><p id="6072" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我的下一个直觉是使用散列表。使用哈希表以增加内存来换取速度，这通常是我们要做的一个权衡。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="cebb" class="kw jl hi ks b fi kx ky l kz la">const smallest = function(nums){</span><span id="ca21" class="kw jl hi ks b fi lb ky l kz la">  hash = {}</span><span id="53f9" class="kw jl hi ks b fi lb ky l kz la">  nums.forEach(num =&gt; {<br/>    hash[num] = true<br/>  })</span><span id="4ddb" class="kw jl hi ks b fi lb ky l kz la">for (let i =0; i&lt;nums.length+1; i++){<br/>    if (!hash[i]) return i <br/>  }</span><span id="5c4c" class="kw jl hi ks b fi lb ky l kz la">  return nums.length<br/>}</span></pre><p id="bc40" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你会在这里看到一个模式，如果我们遍历所有代码，这意味着不在数组中的最小数是数组的长度，这意味着数组包含了从0到其大小的所有数。</p><p id="f953" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的第一个循环遍历数组，为数组中的每个数字创建一个键值对，并将其存储在hash中。</p><p id="cbf6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，我们的第二个循环从0开始迭代，直到数组的长度，检查每个数字在hash中是否有对应的键。如果没有，我们就打破循环，返回号码。</p><p id="a277" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有两个循环，但是因为它们没有嵌套，所以将它们的运行时间相加，而不是相乘，这样我们得到的时间复杂度为O(N + N)或O(2N ),我们可以将其简化为O(N ),称之为线性。然而，我们的空间复杂度现在是O(N ),而不是常数，因为我们使用的是散列。</p><p id="147f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是我在面试中所能得到的，但是我的面试官给了我两个主要的线索，并告诉我继续寻找解决方案。这两条线索是:</p><ol class=""><li id="77f3" class="lc ld hi io b ip iq it iu ix le jb lf jf lg jj lh li lj lk bi translated">记住输入是唯一的和非负的</li><li id="e67f" class="lc ld hi io b ip ll it lm ix ln jb lo jf lp jj lh li lj lk bi translated">当从0到size的每个数字都存在时，数组中迭代次数的最坏情况发生，因此最大迭代次数为N</li></ol><h1 id="641e" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">线性时间和常数空间解</h1><p id="298f" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">绞尽脑汁了几个小时，最后一步一步走了，我终于想到了解决办法。</p><p id="b77f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由于这些数字都是正数(或零)，我们可以利用这一事实，创建一种“就地检查表”，能够在线性时间内跟踪数字，而无需创建新的数组。</p><p id="70a8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们可以通过使用每个数字的值，在相应的索引处“划掉”该数字来实现这一点。这是什么意思？我来解释一下:</p><p id="542c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们使用数组[3，1，5，2，0]作为例子。</p><p id="9043" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当我们到达数组[0]时，值是3。我们现在知道3出现了。我们可以将数组修改为“划掉”3，并通过转到数组[3]并将那里的数字改为负数来标记它的存在。</p><p id="94a7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的数组现在是[3，1，5，-2，0]</p><p id="5237" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将继续这个模式，直到到达数组的末尾。在我们的例子中，最终的数组看起来像[-3，-1，-5，-2，0]</p><p id="365e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们可以循环，看看哪些数字不是负的。如果它们都是，我们将知道所有的数字都存在，但如果不是，我们遇到的第一个数字的索引将是我们要寻找的数字。</p><p id="d884" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在你可能已经注意到了我们例子中的一个问题。我们寻找的答案是4，因为这是最小的非负数。但是在我们的数组[4]中，vale既不是负数也不是正数。它是零。因此，我们必须在代码中编写一个特例来处理这种情况。</p><p id="e3a1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面来看看:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="6093" class="kw jl hi ks b fi kx ky l kz la">cosnt smallest = function(nums) {<br/>  let len = nums.length<br/>    for (let i=0; i&lt;len; i++){<br/>      let idx = Math.abs(nums[i])<br/>    if (nums[idx] === undefined){<br/>      nums[idx] = 1<br/>    }<br/>    if (nums[idx] === 0){<br/>      nums[0] *= -1<br/>      nums[idx] = -1<br/>    } else {<br/>      nums[idx] *= -1<br/>    }<br/>  }<br/>  <br/>  for (let i=0; i&lt;nums.length; i++){<br/>    if (nums[i] &gt; 0 ) return i<br/>  }<br/>  return nums.length<br/>};</span></pre><p id="e4e1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我们在这里处理一些边缘案件。第一个是我提到的数组中有一个0。我们不能像其他数字一样乘以-1，因为它仍然是零。我们也不能将if语句调整为if nums[i] &gt; 0返回I，因为在某些情况下，0的索引可能已经被计算，也可能没有被计算。我们无从得知。</p><p id="b70d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们必须发挥创造力，如果我们得到一个值为0的数，那么转到索引0，乘以-1，然后把0变成负1。这样，我们就不会在得到0之前把它变成负数，从而破坏了在索引0处“划掉”数字的能力。</p><p id="3cf4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">此外，您将看到我们在数组的开头创建了一个变量“len”。这是因为有时如果数组中有更大的数，我们函数的设置方式是，当num[idx]未定义时，我们将它存储为1。例如，如果我们的数组是[1，2，50，3]。当我们到达值为50的索引3时，我们知道索引50并不存在，因此我们先将array[50]设置为1，然后将其设为负值，在数组中对其进行计数。因为这会导致我们的数组增长，如果我们在for循环中使用nums.length，我们将会比我们想要的运行更多次，并且会迭代一堆空格。将len设置为等于原始数组长度可以解决这个问题。</p><p id="ec47" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，在我们的else条件中，我们需要考虑这样的情况:我们已经将0更改为-1，但是它还没有被我们的for循环访问。如果发生这种情况，我们可能会意外地将索引1处的数字改回正数，而它已经变成负数了。</p><p id="681b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这段代码通过在将数字改为负数之前确保它是正数来解决这个问题:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="a4df" class="kw jl hi ks b fi kx ky l kz la">} else {<br/>  if (nums[idx] &gt; 0){<br/>    nums[idx] *= -1<br/>  }<br/>}</span></pre><p id="741d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们的最终代码如下所示:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="bd33" class="kw jl hi ks b fi kx ky l kz la">cosnt smallest = function(nums) {<br/>  let len = nums.length<br/>    for (let i=0; i&lt;len; i++){<br/>      let idx = Math.abs(nums[i])<br/>    if (nums[idx] === undefined){<br/>      nums[idx] = 1<br/>    }<br/>    if (nums[idx] === 0){<br/>      nums[0] *= -1<br/>      nums[idx] = -1<br/>    } else {<br/>      if (nums[idx] &gt; 0){<br/>        nums[idx] *= -1<br/>      }<br/>    }<br/>  }<br/>  <br/>  for (let i=0; i&lt;nums.length; i++){<br/>    if (nums[i] &gt; 0 ) return i<br/>  }<br/>  return nums.length<br/>};</span></pre><p id="9dda" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">今天就到这里。请随意尝试自己的解决方案，看看您是否能找到任何边缘案例。</p></div></div>    
</body>
</html>