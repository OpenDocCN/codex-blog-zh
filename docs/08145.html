<html>
<head>
<title>Data Structures and How To Build It From Scratch (Hash Table) #2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构以及如何从头开始构建它(哈希表)#2</h1>
<blockquote>原文：<a href="https://medium.com/codex/data-structures-and-how-to-build-it-from-scratch-hash-table-2-95158a7883fc?source=collection_archive---------22-----------------------#2022-07-19">https://medium.com/codex/data-structures-and-how-to-build-it-from-scratch-hash-table-2-95158a7883fc?source=collection_archive---------22-----------------------#2022-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="46c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">哈希表</strong>是一种数据结构，可以用来将键映射到它们的特定值，它也被称为<strong class="ih hj">哈希表。</strong>哈希表高效地执行键值对的插入和删除操作，并在哈希表中搜索键值。顺便说一下，JavaScript提供了内置函数来制作哈希表。它们被称为Map()和Set()。</p><blockquote class="jd je jf"><p id="cd8b" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><em class="hi">琐事:集合是需要由唯一值组成的集合数据集，当我们将键映射到值</em>时，映射是当你有成对的关联数据时</p></blockquote><p id="aa33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JavaScript中的哈希表有两个组成部分，对象和哈希函数。</p><p id="c8d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">- Object包含存储数据的哈希表，它保存哈希表的所有“键-值”对。</p><p id="661c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">-哈希函数是为哈希表定义的，用于确定给定键值对的“索引”。</p><p id="45fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们要创建一个名为HashTable的类，它包含四个方法:hash()、set()、get()和keys()。</p><p id="cb69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们必须创建一个类及其构造函数。我们需要创建一个名为data的属性来确定我们将要创建的散列映射的大小。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jk"><img src="../Images/c330eefa0eb3f663e9049b9a7edc4ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DL89r47Rsl0AaVjalJhoHg.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">类哈希表及其构造函数。</figcaption></figure><p id="3ffe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们会做一个叫_hash()的方法。这个方法基本上返回一个随机整数(比如给定的参数是“grapes”，构造函数的大小是50，就返回23)。我们需要这个方法作为其他方法的地址(我们稍后会看到)。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ka"><img src="../Images/c3286386ff188efdaf90df9305905136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPxjBiQ5RUHzb3gJF1w6cQ.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">_哈希方法</figcaption></figure><p id="fabb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们将创建一个名为set()的方法，将数据插入到一个散列表中，并将键和值作为参数。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es kb"><img src="../Images/229efffd1f762539d86bc01aa7a2d7a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xesy3MWthRrIu9Jy6MSQ2Q.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">永久变形测定法</figcaption></figure><p id="20ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要创建一个地址，并使用_hash()方法来确定值本身。那么如果this.data[address]为空，我们将分配一个空数组。然后我们将[键，值]推送到this . data[地址]。最后，我们必须返回this.data。</p><p id="329c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来我们要做一个叫get()的方法，这个方法，如果基于给定键的数据存在，它会返回一个基于那个键的值，否则会返回undefined。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es kc"><img src="../Images/e9952ff15f20bffc9544d2efbd6bf926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1vTsP2b_fwfx7LJZXSST7A.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">获取方法</figcaption></figure><p id="822a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和往常一样，我们必须将地址确定为_hash方法的返回。我们必须创建一个名为currentBucket的变量作为this.data[address]变量。我们要确保currentBucket不为null，如果为null，就作为undefined返回。</p><p id="9274" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了更好地理解循环内部的情况，我们必须查看currentBucket值。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jk"><img src="../Images/6ef2e3fc8be3675e68eaa954e703af35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOTx1sjYVSQg-fMEtendSQ.png"/></div></div></figure><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es kd"><img src="../Images/a9a040423ede7ede0f508114eb22628a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XnspByUaGHl_rZfmZgdDmA.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">console . log(current bucket)</figcaption></figure><p id="246d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在循环内部，如果currentBucket[i][0]或<strong class="ih hj"> grapes </strong>是===给定的params key，我们将返回currentBucket [i][1]或<strong class="ih hj"> 3 </strong>。为什么我们需要这样做？因为即使密钥不同，地址也有可能相同。</p><p id="0032" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一个方法是keys()。keys()将返回this.data中的所有键</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ke"><img src="../Images/dd1835a324a9e650fac29a9e8ad1f303.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ntn1YzYvXuAFRBGS79LTyA.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">keys方法</figcaption></figure><p id="e961" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将一个变量作为临时数组，然后我们循环this.data.length，如果this.data[i]不为空，我们将把this.data中的每个键都推送到keyArray。</p><p id="2435" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，就这样了。我们刚刚用class做了自己的哈希表。这是哈希表类的完整代码。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es kf"><img src="../Images/1d0b51095f15f85e6ec57b7aee22ef8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QCBCdz7zMYwR7ITu6ch-jw.png"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">哈希表的完整代码</figcaption></figure><p id="ec99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae kg" href="https://singgihaji.medium.com/data-structures-and-how-to-build-it-from-scratch-linked-list-3-c7f609950a60" rel="noopener">数据结构和如何从头构建(链表)上见#3！</a></p></div></div>    
</body>
</html>