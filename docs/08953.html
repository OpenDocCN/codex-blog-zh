<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/codex/adding-authentication-to-full-stack-mern-web-application-4974543c3e66?source=collection_archive---------5-----------------------#2022-09-14">https://medium.com/codex/adding-authentication-to-full-stack-mern-web-application-4974543c3e66?source=collection_archive---------5-----------------------#2022-09-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/2d53f59bd5f4330cda750e08ecd4b3e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JHFbF6I52AD_Zn6j5CLF1Q.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">向全栈MERN web应用程序添加身份验证</figcaption></figure><p id="0c21" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">本文是“让我们构建和部署一个全栈MERN web应用程序”的第2部分。在那篇教程中，我们创建了一个名为<strong class="hy iv">生产力跟踪器</strong>的应用程序，它允许你记录你的日常活动。然而，我们的应用程序有一个问题。你能想出来吗👀？你的提示就在这篇文章的标题里。在本教程中，让我们看看这个问题以及如何解决它。</p><h2 id="ae3c" class="iw ix hx bd iy iz ja jb jc jd je jf jg ih jh ji jj il jk jl jm ip jn jo jp jq bi translated">我们开始吧</h2><p id="1c62" class="pw-post-body-paragraph hv hw hx hy b hz jr ib ic id js if ig ih jt ij ik il ju in io ip jv ir is it hb bi translated">⚠️ <em class="jw"> </em> <strong class="hy iv">警告:</strong> <em class="jw">本教程使用的认证是不安全的。我不建议在真实项目中使用这种认证方式。</em></p><h2 id="cc2c" class="iw ix hx bd iy iz ja jb jc jd je jf jg ih jh ji jj il jk jl jm ip jn jo jp jq bi translated">问题是</h2><p id="d3f0" class="pw-post-body-paragraph hv hw hx hy b hz jr ib ic id js if ig ih jt ij ik il ju in io ip jv ir is it hb bi translated">由于您的应用程序目前在线可用，任何人都可以使用它并向您的数据库添加活动。这不太好，是吗？在这里，身份验证介入以挽救局面。若要防止未经授权访问您的应用程序，请添加身份验证。</p><figure class="jy jz ka kb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jx"><img src="../Images/33aca294a678f2c92ae4a394c1c618f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_ZwmfaSTScNZi9_f.png"/></div></div></figure><h2 id="ac97" class="iw ix hx bd iy iz ja jb jc jd je jf jg ih jh ji jj il jk jl jm ip jn jo jp jq bi translated">添加身份验证</h2><p id="3dd0" class="pw-post-body-paragraph hv hw hx hy b hz jr ib ic id js if ig ih jt ij ik il ju in io ip jv ir is it hb bi translated">我们必须分别开发前端和后端身份验证，因为我们将两者分开了。同样，为了简单起见，我们将在不使用任何库的情况下构建基本身份验证。</p><h2 id="3c7e" class="iw ix hx bd iy iz ja jb jc jd je jf jg ih jh ji jj il jk jl jm ip jn jo jp jq bi translated">后端认证</h2><p id="f1cf" class="pw-post-body-paragraph hv hw hx hy b hz jr ib ic id js if ig ih jt ij ik il ju in io ip jv ir is it hb bi translated">我们需要实现后端认证并授权一些路由。</p><h2 id="3bcb" class="iw ix hx bd iy iz ja jb jc jd je jf jg ih jh ji jj il jk jl jm ip jn jo jp jq bi translated">身份验证与授权</h2><p id="c601" class="pw-post-body-paragraph hv hw hx hy b hz jr ib ic id js if ig ih jt ij ik il ju in io ip jv ir is it hb bi translated">这两个词可能会让你感到困惑。<strong class="hy iv">认证</strong>是允许有凭证的人访问我们的应用程序，而<strong class="hy iv">授权</strong>是授权的人访问资源。</p><figure class="jy jz ka kb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jx"><img src="../Images/80f67b1dc086d2be4df2b285295e5066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QxHQ3PFlmKn_E7MD.png"/></div></div></figure><p id="49e7" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">在我们的场景中，授权授予对资源的访问权，比如创建活动和获取活动，而身份验证则需要登录到应用程序。</p><h2 id="d695" class="iw ix hx bd iy iz ja jb jc jd je jf jg ih jh ji jj il jk jl jm ip jn jo jp jq bi translated">JWT简介</h2><blockquote class="kc kd ke"><p id="82f0" class="hv hw jw hy b hz ia ib ic id ie if ig kf ii ij ik kg im in io kh iq ir is it hb bi translated">JSON Web Token (JWT)是一种简洁的、URL安全的方式，用于表示要在双方之间传输的声明。JWT中的声明被编码为JSON对象，该对象被用作JSON Web签名(JWS)结构的有效载荷，或者被用作JSON Web加密(JWE)结构的明文，从而能够对声明进行数字签名或使用消息认证码(MAC)进行完整性保护和/或加密。</p></blockquote><p id="548a" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">简单来说，JWT用于验证用户是否有权限执行某个操作。</p><p id="793c" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">让我们用JWT实现<strong class="hy iv">登录认证</strong>。</p><p id="cff1" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">因为你是唯一使用你的应用程序的人，所以你不需要注册功能，你可以将<code class="du ki kj kk kl b">EMAIL</code>和<code class="du ki kj kk kl b">PASSWORD</code>存储在<code class="du ki kj kk kl b">.env</code>文件中。</p><ul class=""><li id="83ae" class="km kn hx hy b hz ia id ie ih ko il kp ip kq it kr ks kt ku bi translated">打开<code class="du ki kj kk kl b">.env</code>文件，添加这三个变量。</li></ul><pre class="jy jz ka kb fd kv kl kw kx aw ky bi"><span id="0d95" class="iw ix hx kl b fi kz la l lb lc">TOKEN_KEY=somesecrettoken<br/>EMAIL=youremail<br/>PASSWORD=yourpassword</span></pre><p id="93d4" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">这里的<em class="jw"/><code class="du ki kj kk kl b"><em class="jw">TOKEN_KEY</em></code><em class="jw">可以是任意随机的字符串。它被JWT使用。</em></p><ul class=""><li id="d8ae" class="km kn hx hy b hz ia id ie ih ko il kp ip kq it kr ks kt ku bi translated">打开一个终端，安装<code class="du ki kj kk kl b">jsonwebtoken</code>包。</li></ul><pre class="jy jz ka kb fd kv kl kw kx aw ky bi"><span id="7dd9" class="iw ix hx kl b fi kz la l lb lc">npm i jsonwebtoken</span></pre><ul class=""><li id="1bee" class="km kn hx hy b hz ia id ie ih ko il kp ip kq it kr ks kt ku bi translated">打开<code class="du ki kj kk kl b">controllers</code>文件夹，创建<code class="du ki kj kk kl b">auth.controller.js</code>文件。复制并粘贴下面的代码。</li></ul><pre class="jy jz ka kb fd kv kl kw kx aw ky bi"><span id="29c8" class="iw ix hx kl b fi kz la l lb lc">const jwt = require("jsonwebtoken");<br/><br/>require("dotenv").config();<br/><br/>const EMAIL = process.env.EMAIL;<br/>const PASSWORD = process.env.PASSWORD;<br/><br/>/* If the email and password are correct, then return a token. */<br/>const login = (req, res) =&gt; {<br/>  /* Destructuring the email and password from the request body. */<br/>  const { email, password } = req.body;<br/><br/>  if (email === EMAIL &amp;&amp; password === PASSWORD) {<br/>    /* Creating a token. */<br/>    const token = jwt.sign({ email }, process.env.TOKEN_KEY, {<br/>      expiresIn: "2h",<br/>    });<br/>    return res.status(200).json({<br/>      statusCode: 200,<br/>      msg: "Login successful",<br/>      token,<br/>    });<br/>  }<br/>  return res.status(401).json({<br/>    statusCode: 401,<br/>    msg: "Invalid Credentials",<br/>  });<br/>};<br/><br/>module.exports = {<br/>  login,<br/>};</span></pre><p id="5969" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">上面的代码检查邮件地址和密码是否匹配，如果匹配，就生成一个令牌并发送到前端，实现前端认证。</p><ul class=""><li id="075e" class="km kn hx hy b hz ia id ie ih ko il kp ip kq it kr ks kt ku bi translated">打开<code class="du ki kj kk kl b">routes</code>文件夹创建<code class="du ki kj kk kl b">auth.routes.js</code>并注册一条新路线登录。</li></ul><pre class="jy jz ka kb fd kv kl kw kx aw ky bi"><span id="8886" class="iw ix hx kl b fi kz la l lb lc">const express = require("express");<br/><br/>const { login } = require("../controllers/auth.controller");<br/><br/>const router = express.Router();<br/><br/>router.post("/login", login);<br/><br/>module.exports = router;</span></pre><ul class=""><li id="b312" class="km kn hx hy b hz ia id ie ih ko il kp ip kq it kr ks kt ku bi translated">最后，在<code class="du ki kj kk kl b">server.js</code>中，使用注册的路线。</li></ul><pre class="jy jz ka kb fd kv kl kw kx aw ky bi"><span id="bf12" class="iw ix hx kl b fi kz la l lb lc">...<br/>const AuthRouter = require("./routes/auth.route");<br/>...<br/><br/>...<br/>app.use("/api/auth", AuthRouter);<br/>...</span></pre><p id="119b" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">我们成功地实现了认证。现在只有经过认证的人才能访问我们的应用程序。但是经过认证的人仍然可以访问我们的资源和添加活动，因为我们没有授权这些路线。</p><p id="f0ba" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">让我们创建一个中间件来授权这些路由。</p><pre class="jy jz ka kb fd kv kl kw kx aw ky bi"><span id="9d76" class="iw ix hx kl b fi kz la l lb lc">GET /api/activities<br/><br/>POST /api/activity</span></pre><ul class=""><li id="8e6c" class="km kn hx hy b hz ia id ie ih ko il kp ip kq it kr ks kt ku bi translated">在项目根目录中，创建一个名为<code class="du ki kj kk kl b">middleware</code>的文件夹，并在该文件夹中创建<code class="du ki kj kk kl b">auth.js</code>文件。复制并粘贴下面的代码。</li></ul><pre class="jy jz ka kb fd kv kl kw kx aw ky bi"><span id="af3a" class="iw ix hx kl b fi kz la l lb lc">const jwt = require("jsonwebtoken");<br/><br/>require("dotenv").config();<br/><br/>/* It checks if the token is valid and if it is, it decodes it and attaches the decoded token to the request object */<br/>const verifyToken = (req, res, next) =&gt; {<br/>  const token = String(req.headers.authorization)<br/>    .replace(/^bearer|^jwt/i, "")<br/>    .replace(/^\s+|\s+$/gi, "");<br/><br/>  try {<br/>    if (!token) {<br/>      return res.status(403).json({<br/>        statusCode: 403,<br/>        msg: "A token is required for authentication",<br/>      });<br/>    }<br/>    /* Verifying the token. */<br/>    const decoded = jwt.verify(token, process.env.TOKEN_KEY);<br/>    req.userData = decoded;<br/>  } catch (err) {<br/>    return res.status(401).json({<br/>      statusCode: 401,<br/>      msg: "Invalid Token",<br/>    });<br/>  }<br/>  return next();<br/>};<br/><br/>module.exports = verifyToken;</span></pre><p id="8017" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">我们创建了一个名为<code class="du ki kj kk kl b">verifyToken()</code>的中间件函数来验证前端通过头发送的令牌。如果验证成功，则用户可以访问上述路线。</p><ul class=""><li id="db79" class="km kn hx hy b hz ia id ie ih ko il kp ip kq it kr ks kt ku bi translated">现在打开<code class="du ki kj kk kl b">activity.route.js</code>，这样修改代码。</li></ul><pre class="jy jz ka kb fd kv kl kw kx aw ky bi"><span id="6338" class="iw ix hx kl b fi kz la l lb lc">...<br/>router.get("/activities", auth, getActivities);<br/><br/>router.post("/activity", auth, addActivity);<br/>...</span></pre><p id="f377" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">就是这样！后端认证已完成🎉。</p><h2 id="30a9" class="iw ix hx bd iy iz ja jb jc jd je jf jg ih jh ji jj il jk jl jm ip jn jo jp jq bi translated">前端认证</h2><p id="ad0d" class="pw-post-body-paragraph hv hw hx hy b hz jr ib ic id js if ig ih jt ij ik il ju in io ip jv ir is it hb bi translated">是时候实现前端认证了。</p><ul class=""><li id="cbad" class="km kn hx hy b hz ia id ie ih ko il kp ip kq it kr ks kt ku bi translated">首先，让我们创建一个登录页面。</li><li id="7f06" class="km kn hx hy b hz ld id le ih lf il lg ip lh it kr ks kt ku bi translated">在<code class="du ki kj kk kl b">src</code>文件夹中创建<code class="du ki kj kk kl b">Login.jsx</code>和<code class="du ki kj kk kl b">Login.css</code>文件。将下面的代码复制粘贴到<code class="du ki kj kk kl b">Login.jsx</code>文件中，并在<code class="du ki kj kk kl b">Login.css</code>中使用<a class="ae iu" href="https://github.com/itsrakeshhq/productivity-app/blob/main/client/src/Login.css" rel="noopener ugc nofollow" target="_blank">这个</a>。</li></ul><pre class="jy jz ka kb fd kv kl kw kx aw ky bi"><span id="3dd9" class="iw ix hx kl b fi kz la l lb lc">import React from "react";<br/><br/>import "./Login.css";<br/><br/>const Login = () =&gt; {<br/>  /* When the user submits the form, prevent the default action, grab the email and password from the form, send a POST request to the backend with the email and password, and if the response is successful, store the token in local storage and reload the page. */<br/>  const handleSubmit = async (event) =&gt; {<br/>    event.preventDefault();<br/>    const { email, password } = event.target;<br/><br/>    const response = await fetch(<br/>      `${process.env.REACT_APP_BACKEND_URL}/auth/login`,<br/>      {<br/>        method: "POST",<br/>        headers: {<br/>          "Content-Type": "application/json",<br/>        },<br/>        body: JSON.stringify({<br/>          email: email.value,<br/>          password: password.value,<br/>        }),<br/>      }<br/>    );<br/><br/>    const data = await response.json();<br/>    localStorage.setItem("token", data.token);<br/>    window.location.reload();<br/>  };<br/><br/>  return (<br/>    &lt;div className="login"&gt;<br/>      &lt;h1&gt;Login&lt;/h1&gt;<br/>      &lt;form onSubmit={handleSubmit}&gt;<br/>        &lt;span&gt;<br/>          &lt;label htmlFor="email"&gt;Email:&lt;/label&gt;<br/>          &lt;input type="email" id="email" name="email" /&gt;<br/>        &lt;/span&gt;<br/>        &lt;span&gt;<br/>          &lt;label htmlFor="password"&gt;Password:&lt;/label&gt;<br/>          &lt;input type="password" id="password" name="password" /&gt;<br/>        &lt;/span&gt;<br/>        &lt;button type="submit"&gt;Login&lt;/button&gt;<br/>      &lt;/form&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>export default Login;</span></pre><p id="41f4" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">这将呈现登录页面。</p><figure class="jy jz ka kb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es jx"><img src="../Images/dcdb8b1e4c435d6c98096dde0c36f514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jj_Sir4uj_oMFiQd.png"/></div></div></figure><p id="44ad" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated"><code class="du ki kj kk kl b">handleSubmit()</code>从表单中获取电子邮件和密码，发出<code class="du ki kj kk kl b">POST</code>请求，并发送电子邮件和密码值进行验证。之后，服务器验证并发回一个我们可以用来访问资源的令牌。</p><p id="bd1b" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">这里我们使用<code class="du ki kj kk kl b"><a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank">localStorage</a></code>将值永久保存在浏览器中，这样我们就不会在关闭应用程序或浏览器后被注销。</p><ul class=""><li id="9d72" class="km kn hx hy b hz ia id ie ih ko il kp ip kq it kr ks kt ku bi translated">打开<code class="du ki kj kk kl b">index.js</code>文件并添加这个逻辑。如果<code class="du ki kj kk kl b">localStorage</code>中有令牌则渲染<code class="du ki kj kk kl b">App.jsx</code>否则渲染<code class="du ki kj kk kl b">Login.jsx</code>。</li></ul><pre class="jy jz ka kb fd kv kl kw kx aw ky bi"><span id="5878" class="iw ix hx kl b fi kz la l lb lc">...<br/>const token = localStorage?.getItem("token");<br/><br/>root.render(<br/>    &lt;React.StrictMode&gt;<br/>    {token ? &lt;App /&gt; : &lt;Login /&gt;}<br/>    &lt;/React.StrictMode&gt;<br/>);<br/>...</span></pre><ul class=""><li id="0aa7" class="km kn hx hy b hz ia id ie ih ko il kp ip kq it kr ks kt ku bi translated">现在在<code class="du ki kj kk kl b">App.jsx</code>文件中，我们需要通过头部发送<code class="du ki kj kk kl b">token</code>，这样后端将验证它并提供对路由的访问。</li></ul><pre class="jy jz ka kb fd kv kl kw kx aw ky bi"><span id="0087" class="iw ix hx kl b fi kz la l lb lc">...<br/>useEffect(() =&gt; {<br/>    const fetchData = async () =&gt; {<br/>      const result = await fetch(<br/>        `${process.env.REACT_APP_BACKEND_URL}/activities`,<br/>        {<br/>          headers: {<br/>            Authorization: `Bearer ${token}`, // &lt;----------- HERE<br/>          },<br/>        }<br/>      );<br/>      const data = await result.json();<br/>      setActivities(data);<br/>    };<br/>    fetchData();<br/>}, [token]);<br/>...<br/><br/>...<br/>const addActivity = async (event) =&gt; {<br/>    event.preventDefault();<br/><br/>    const newActivity = {<br/>      name: event.target.activity.value,<br/>      time: event.target.time.value,<br/>    };<br/><br/>    await fetch(`${process.env.REACT_APP_BACKEND_URL}/activity`, {<br/>      method: "POST",<br/>      headers: {<br/>        "Content-Type": "application/json",<br/>        Authorization: `Bearer ${token}`, // &lt;---------- HERE<br/>      },<br/>      body: JSON.stringify(newActivity),<br/>    });<br/><br/>    event.target.activity.value = "";<br/>    event.target.time.value = "";<br/>    window.location.reload();<br/>};<br/>...</span></pre><p id="811f" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">搞定✅。我们实现了前端和后端认证。现在只有您可以访问您的应用程序🥳(只要您不共享您的凭据👀).</p><p id="d4e8" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">源代码:<a class="ae iu" href="https://github.com/itsrakeshhq/productivity-app" rel="noopener ugc nofollow" target="_blank">生产力应用</a></p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="a31e" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">在下一篇文章中，我们将学习如何为前端和后端编写测试😍。</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="7781" class="pw-post-body-paragraph hv hw hx hy b hz ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it hb bi translated">关注更多💯。</p></div></div>    
</body>
</html>