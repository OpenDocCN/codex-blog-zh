<html>
<head>
<title>LeetCode 238. Product of Array Except Self — Python Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 238。除自身之外的数组乘积— Python解决方案</h1>
<blockquote>原文：<a href="https://medium.com/codex/leetcode-238-product-of-array-except-self-python-solution-2ec1a6f855ae?source=collection_archive---------8-----------------------#2022-06-20">https://medium.com/codex/leetcode-238-product-of-array-except-self-python-solution-2ec1a6f855ae?source=collection_archive---------8-----------------------#2022-06-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e1b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">盲75 —编程和技术面试问题—解释系列</p><h2 id="691f" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">问题是:</h2><p id="9cad" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">给定一个整数数组<strong class="ih hj"> <em class="kd"> nums </em> </strong>，返回一个数组答案使得<strong class="ih hj"> <em class="kd">答案【I】</em></strong>等于<strong class="ih hj"> <em class="kd"> nums </em> </strong>除<strong class="ih hj"><em class="kd">nums【I】</em></strong>之外的所有元素的乘积。</p><h2 id="ca23" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">制约因素:</h2><ul class=""><li id="7d78" class="ke kf hi ih b ii jy im jz iq kg iu kh iy ki jc kj kk kl km bi translated"><strong class="ih hj"> <em class="kd"> nums </em> </strong>的任何前缀或后缀的乘积保证适合32位整数。</li><li id="7b00" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">你必须写一个运行时间为O(n)的算法</li><li id="e30f" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">不能使用除法运算。</li></ul><h2 id="a753" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">示例:</h2><p id="8f0a" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">例1: </p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="1771" class="jd je hi kx b fi lb lc l ld le"><strong class="kx hj">Input:</strong> <strong class="kx hj"><em class="kd">nums </em></strong>= [1,2,3,4]<br/><strong class="kx hj">Output:</strong> [24,12,8,6]</span></pre><p id="4ec2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例2: </strong></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="98d1" class="jd je hi kx b fi lb lc l ld le"><strong class="kx hj">Input:</strong> <strong class="kx hj"><em class="kd">nums </em></strong>= [-1,1,0,-3,3]<br/><strong class="kx hj">Output:</strong> [0,0,9,0,0]</span></pre><figure class="ks kt ku kv fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lf"><img src="../Images/0bfcca4cda05d6ee17791f82997c722b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qxWAaDj_XObO-NqE.png"/></div></div></figure><h2 id="871a" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">解释是:</h2><p id="ad08" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">这个问题是动态规划的一个很好的例子。更明显的方法当然是更长的方法。这种方式就是从左到右遍历<strong class="ih hj"> <em class="kd"> nums </em> </strong>数组并设置<strong class="ih hj"> <em class="kd">答案【I】</em></strong>到<strong class="ih hj"> <em class="kd">答案【I-1】</em></strong>乘以<strong class="ih hj"><em class="kd">nums【I-1】</em></strong>然后从右到左乘以<strong class="ih hj"> <em class="kd">答案【I】</em></strong>乘<strong class="ih hj"> <em class="kd"> nums之所以<strong class="ih hj"> <em class="kd">答案【I】</em></strong>从来不乘以<strong class="ih hj"> <em class="kd"> nums </em> </strong>或者答案at <strong class="ih hj"> <em class="kd"> i </em> </strong>，而是<strong class="ih hj"> <em class="kd"> i +/- 1 </em> </strong>是因为这样会乘以<strong class="ih hj"> <em class="kd">答案【I】</em></strong>本身，这是我们不做的约束之一。这种解决方案称为两遍，时间复杂度为O(2 * n)，非常接近最佳时间复杂度，但这可以在一遍中完成，时间复杂度为O(n)。</em></strong></p><p id="4afc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">O(n)的解决方案是只遍历数组一次，但是跟踪数组的左右乘积，并将这些乘积乘以<strong class="ih hj"> <em class="kd">答案【I】</em></strong>。</p><h2 id="8e7b" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">双通解— O(2 * n)</h2><p id="ac97" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">首先，创建一个保存<strong class="ih hj"> <em class="kd"> nums </em> </strong>长度的变量，这样可以节省时间，而不是每次都调用<strong class="ih hj"> <em class="kd"> len(nums) </em> </strong>，如果长度经常被使用，这是一个好习惯。然后是极限情况，如果数组的长度为零或者数组没有内存，那么就返回数组本身，因为什么都不会改变。然后初始化<strong class="ih hj"> <em class="kd"> ans </em> </strong>数组，该数组保存所有的1，而不是0，因为当应用乘法时，它永远不会改变。这是第一遍将要完成的地方，如前所述，将<strong class="ih hj"> <em class="kd"> ans[i] </em> </strong>设置为<strong class="ih hj"> <em class="kd"> nums </em> </strong>中的前一个数字乘以ans中的前一个数字。一旦完成，初始化一个右变量为1以保存正确的乘积，否则索引0处的数字将保存错误的值。它不会乘以索引1处的值。然后在for循环内部将<strong class="ih hj"><em class="kd">ans【I】</em></strong>乘以右乘积<strong class="ih hj">，然后将右乘积</strong>乘以<strong class="ih hj"><em class="kd">nums【I】</em></strong>处的值。经过这一过程后，阵列就完成了，可以返回。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c64d" class="jd je hi kx b fi lb lc l ld le">class Solution:<br/>  def productExceptSelf(self, nums: List[int]) -&gt; List[int]:<br/>    len_n = len(nums)<br/> <br/>    if len_n == 0 or nums is None:<br/>      return nums<br/> <br/>    ans = [1] * len_n <br/> <br/>    for i in range(1, len_n):<br/>      ans[i] = nums[i — 1] * ans[i — 1]</span><span id="f230" class="jd je hi kx b fi ln lc l ld le">    right = 1<br/>    <br/>    for i in range(len_n — 1, -1, -1):<br/>      ans[i] *= right<br/>      right *= nums[i]<br/>    <br/>    return ans</span></pre><figure class="ks kt ku kv fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lo"><img src="../Images/26db7b2de870eae1417b4d26a8721445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H_NUln0Hjo_lwBaH.png"/></div></div></figure><h2 id="2065" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">一步解——O(n)</h2><p id="aafc" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">对于一次通过的解决方案，您将左右乘积都声明为1，并像以前一样初始化<strong class="ih hj"> <em class="kd"> len_n </em> </strong>变量。同样，如果<strong class="ih hj"> <em class="kd"> nums </em> </strong>中没有元素，则返回<strong class="ih hj"> <em class="kd"> nums </em> </strong>。然后用1初始化<strong class="ih hj"> <em class="kd"> ans </em> </strong>数组，现在我们迭代<strong class="ih hj"> <em class="kd"> nums </em> </strong>数组。for循环内部的前两行和后两行可以交换，先左后右更有意义。对于左侧，将<strong class="ih hj"><em class="kd">ans【I】</em></strong>乘以左侧乘积，然后更新左侧乘积。与前面的解决方案一样，在for循环中使用了左右乘积之后，您必须更新它们，以确保<strong class="ih hj"><em class="kd">【ans】</em></strong>没有乘以<strong class="ih hj"><em class="kd">nums【I】</em></strong>。然后通过乘以<strong class="ih hj"><em class="kd">nums【I】</em></strong>来更新左边的乘积。那么对于正确的产品，你先更新<strong class="ih hj"><em class="kd">ans【len _ n-I-1】</em></strong>，减一是因为<strong class="ih hj"><em class="kd">ans【len _ n】</em></strong>会出界。然后将右积乘以<strong class="ih hj"><em class="kd">nums【len _ n-I-1】</em></strong>。在for循环结束时，你可以返回<strong class="ih hj"> <em class="kd"> ans </em> </strong>数组。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="8233" class="jd je hi kx b fi lb lc l ld le">class Solution:<br/>  def productExceptSelf(self, nums: List[int]) -&gt; List[int]:<br/>    l, r = 1, 1<br/>    len_n = len(nums)<br/>    <br/>    if len_n == 0 or nums is None:<br/>      return nums</span><span id="10d5" class="jd je hi kx b fi ln lc l ld le">    ans = [1] * len_n<br/>    <br/>    for i in range(0, len_n):<br/>      ans[i] *= l<br/>      l *= nums[i]<br/>      ans[len_n — i — 1] *= r<br/>      r *= nums[len_n — i — 1]<br/> <br/>    return ans</span></pre><figure class="ks kt ku kv fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lp"><img src="../Images/9dd3755fee0ad6a0d04d932989260ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XMjdlGIuOPbvSozE.png"/></div></div></figure><h1 id="8487" class="lq je hi bd jf lr ls lt jj lu lv lw jn lx ly lz jq ma mb mc jt md me mf jw mg bi translated">信息:</h1><p id="85a0" class="pw-post-body-paragraph if ig hi ih b ii jy ik il im jz io ip iq ka is it iu kb iw ix iy kc ja jb jc hb bi translated">网址:<a class="ae mh" href="http://www.nkwade.dev/" rel="noopener ugc nofollow" target="_blank">nkwade . dev</a><br/>LinkedIn:<a class="ae mh" href="http://www.linkedin.com/in/nkwade/" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/nkwade</a><br/>GitHub:<a class="ae mh" href="http://www.github.com/nkwade" rel="noopener ugc nofollow" target="_blank">github.com/nkwade</a><br/>邮箱:<a class="ae mh" href="mailto:nicholas@nkwade.dev" rel="noopener ugc nofollow" target="_blank"> nicholas@nkwade.dev </a></p></div></div>    
</body>
</html>