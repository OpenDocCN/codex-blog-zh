<html>
<head>
<title>MultiThread processing pipeline with ordered output in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中具有有序输出的多线程处理流水线</h1>
<blockquote>原文：<a href="https://medium.com/codex/multithread-processing-pipeline-with-ordered-output-in-java-843643af4aae?source=collection_archive---------1-----------------------#2021-11-14">https://medium.com/codex/multithread-processing-pipeline-with-ordered-output-in-java-843643af4aae?source=collection_archive---------1-----------------------#2021-11-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6887" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我面临一个挑战:给定一个音频流作为输入，我怎样才能接近实时地处理它？如果这个过程包括几个阶段呢？我用Java开发了一个简单的解决方案，这里描述了我选择的理由..好好享受吧！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/3b8d836965a2ddb37484b055c548f39f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MtXoxMRdN4oVA0g1"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">由<a class="ae ju" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae ju" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="f06f" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">问题是</h1><p id="d79c" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">在软件工程的所有问题中，我们必须开始问:我们的用例是什么，我们想要完成什么？</p><h1 id="41dd" class="kc kd hi bd ke kf lf kh ki kj lg kl km kn lh kp kq kr li kt ku kv lj kx ky kz bi translated">要求</h1><p id="752b" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我们的系统是生产者/消费者模式的一个例子，其中音频源(生产者)将数据注入我们的系统(消费者)。</p><p id="624d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们做一些假设，这些假设在大多数情况下可能是有意义的。他们将帮助我们定义需求。</p><h2 id="b4ef" class="lk kd hi bd ke ll lm ln ki lo lp lq km iq lr ls kq iu lt lu ku iy lv lw ky lx bi translated">音频源</h2><p id="e831" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">音源以固定的时间间隔产生<strong class="ih hj">原始数据</strong>(即字节数组)。让我们假设音频被分成固定大小的<strong class="ih hj">帧</strong>，并且每个帧包含一个<strong class="ih hj">序列号</strong>。如果不是这种情况，我们总是可以用一些逻辑来装饰音频源，以将数据分成帧。</p><p id="559e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个要求是我们的系统是线性的。每一帧的输出取决于它自己，而不是之前或之后的帧(我们将看到这如何影响我们的设计)。</p><p id="cf40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">来自数据源的最后要求是隐含的，并且是多媒体信号的特征:在处理之后，音频源的帧必须保持相同的顺序(<strong class="ih hj">顺序保持</strong>)。将最后两个需求放在一起，我们不关心如何处理每个帧，只要在输出中，处理后的帧保持它们在输入中的相同顺序。</p><p id="114e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下面的代码片段中，您可以看到我定义的框架的API(一些方法将在接下来的部分中更有意义)。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h2 id="3611" class="lk kd hi bd ke ll lm ln ki lo lp lq km iq lr ls kq iu lt lu ku iy lv lw ky lx bi translated">发动机</h2><p id="80a9" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">通常，在音频处理流程中有两个、三个或更多步骤(<strong class="ih hj">滤波器</strong>)，例如，增强音频、压缩音频等。为简单起见，假设我们只有两个步骤(同样的推理可以应用于更多步骤)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ma"><img src="../Images/e5915afc1ac9d7a38444d03887b14d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCLBZeeoYhx-UcbfS33aCw.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">两步音频处理引擎</figcaption></figure><p id="6c41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">发动机的最后一个要求是<strong class="ih hj">会自动停止</strong>。对于我们讨论的目标来说，这不是强制性的，但是这样做很好，并且会使实现更有趣。</p><h2 id="e8f1" class="lk kd hi bd ke ll lm ln ki lo lp lq km iq lr ls kq iu lt lu ku iy lv lw ky lx bi translated">概括一下</h2><p id="e145" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">以下是我们的要求:</p><ul class=""><li id="0c4d" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mg mh mi mj bi translated">数据流应分割成<strong class="ih hj">编号的帧。</strong></li><li id="c1a6" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">系统应为<strong class="ih hj">线性。</strong></li><li id="3ed1" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">系统应自动关闭。</li><li id="6fa0" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">输出中过滤后的音频信号应包含按序列号排序的帧<strong class="ih hj">。</strong></li></ul><h1 id="e07e" class="kc kd hi bd ke kf lf kh ki kj lg kl km kn lh kp kq kr li kt ku kv lj kx ky kz bi translated">建筑</h1><p id="8072" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">在这里，我将描述系统的三种可选架构，从最简单的(和性能较差的)到最复杂的(和最快的)。</p><h2 id="a457" class="lk kd hi bd ke ll lm ln ki lo lp lq km iq lr ls kq iu lt lu ku iy lv lw ky lx bi translated">串行处理</h2><p id="8de9" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">下图显示了可能是最简单的实现:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mp"><img src="../Images/9158a4d340b4e80f328f82b7f6e41dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*s_mW4MSq_JvvaOhs8DA5YQ.gif"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">引擎的串行实现</figcaption></figure><p id="669c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">发动机由两个过滤器组成；在应用第二个过滤器之前，我们将第一个过滤器应用于所有帧(想象两个循环，一个接一个)。这种解决方案最容易实现，但也需要更多时间来处理我们的音频源。</p><p id="1037" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们分别称<em class="jd"> t1 </em>和<em class="jd"> t2 </em>为第一和第二滤波器处理一帧的平均时间，那么由<em class="jd"> n </em>帧组成的信号的总处理时间将为:<em class="jd"> n*(t1 + t2) </em></p><h2 id="d967" class="lk kd hi bd ke ll lm ln ki lo lp lq km iq lr ls kq iu lt lu ku iy lv lw ky lx bi translated">并行处理</h2><p id="24f0" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">由于我们的系统是线性的，我们可以通过在两个独立的线程中运行过滤器来提高它的性能。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mp"><img src="../Images/bd2072ad63d8c5d4b794b46222ea1303.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YX-anBl-JqKlnCOLODofzg.gif"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">引擎的并行实现</figcaption></figure><p id="5061" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，当第二滤波器正在处理帧<em class="jd"> i </em>时，第一滤波器正在处理帧<em class="jd"> i+1 </em>。同时，帧<em class="jd"> i+2 </em>被放入队列中，一旦空闲就由第一滤波器获取，等等。</p><p id="8f2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过这样做，我们减少了处理整个音频流所需的时间。使用与前面相同的符号，总处理时间将是:<em class="jd"> n*max(t1，t2) + min(t1，T2)。</em>如果两个加工时间相似，并且<em class="jd"> n </em>是一个很大的数字，那么这大概等于<em class="jd">串行加工时间</em>的一半。</p><h2 id="52e2" class="lk kd hi bd ke ll lm ln ki lo lp lq km iq lr ls kq iu lt lu ku iy lv lw ky lx bi translated">并行处理—多线程</h2><p id="9d84" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">让我们来点刺激的吧！如今，我们的大部分硬件(笔记本电脑、智能手机等..)有<strong class="ih hj">多CPU核心</strong>；我们可以利用这一点，在多个线程中运行同一个过滤器。在前面的例子中，我们可以分别在两个和三个并行线程中运行这两个过滤器。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mq"><img src="../Images/696659207206d44705fe1e26649791d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*46E7UK772e1DVkY4PUz82g.gif"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">引擎的并行多线程实现</figcaption></figure><p id="3556" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了计算处理时间，让我们使用与前面相同的符号，加上<em class="jd"> f1 </em>和<em class="jd"> f2 </em>作为我们分别运行第一个和第二个过滤器的线程数。处理时间变成:<em class="jd"> n*(t1/f1 + t2/f2) </em></p><p id="7489" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<em class="jd"> f1 </em>和<em class="jd"> f2 </em>都至少为2，并且如果<em class="jd"> t1 </em>与<em class="jd"> t2 </em>相似，对于<em class="jd"> n </em>的较大值，我们可以将加工时间至少再减少一半<em class="jd">，</em>这意味着串行加工时间的四分之一<em class="jd">(我将这个和前面的计算留给您作为作业)。</em></p><h2 id="b9c0" class="lk kd hi bd ke ll lm ln ki lo lp lq km iq lr ls kq iu lt lu ku iy lv lw ky lx bi translated">选择的建筑</h2><p id="d543" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我们将使用最后一种架构，<strong class="ih hj">并行多线程</strong>，它是性能最好的。</p><p id="f1a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">发动机由几个<strong class="ih hj">层</strong>组成；每一层对应于音频处理的一个步骤，并且以一个<strong class="ih hj">滤波器</strong>和该滤波器将运行的<strong class="ih hj">线程数量</strong>为特征。在每层的输入和输出都有一个<strong class="ih hj">队列</strong>。</p><h1 id="d7c5" class="kc kd hi bd ke kf lf kh ki kj lg kl km kn lh kp kq kr li kt ku kv lj kx ky kz bi translated">队列及其API</h1><p id="0006" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">到目前为止，我们已经讨论了其中的两个要求:音频源被分成编号为<strong class="ih hj">的帧</strong>和系统的<strong class="ih hj">线性度</strong>。这使我们能够分析少量架构，并决定使用具有并行和多线程过滤器的引擎。</p><p id="2d72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺少的是分析其他两个需求的结果:</p><ul class=""><li id="46d9" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mg mh mi mj bi translated">输出中滤波后的音频信号应包含正确排序的帧<strong class="ih hj">；</strong></li><li id="3034" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">系统应<strong class="ih hj">自动关闭。</strong></li></ul><p id="8575" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个需求驱动我们选择我们使用的队列类型。</p><h2 id="1938" class="lk kd hi bd ke ll lm ln ki lo lp lq km iq lr ls kq iu lt lu ku iy lv lw ky lx bi translated">多线程队列</h2><p id="2778" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">处理多线程时，最好的入手点是java中的<a class="ae ju" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">Java . util . concurrent</strong></a>包。在那里您可以找到<a class="ae ju" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/PriorityBlockingQueue.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">PriorityBlockingQueue</strong></a>类，它之所以有趣，有两个原因:</p><ul class=""><li id="3e95" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mg mh mi mj bi translated">它实现了<a class="ae ju" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">阻塞队列</strong> </a>接口。这意味着每一次插入或提取都用一个<a class="ae ju" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Lock.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">锁</strong> </a>来管理，以防止出现竞争情况。此外，还有一个<a class="ae ju" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Condition.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">条件</strong> </a>与锁相关联；当一个线程要提取一个元素时，如果队列为空，那么它会一直等待，直到队列中插入一个新元素；</li><li id="6dd5" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">您可以通过实现一个<strong class="ih hj">比较器</strong>来配置它，以便通过一些自定义逻辑对其元素进行排序。在我们的例子中，我们可以根据帧的序列号对它们进行排序；这样，当队列中插入多个帧时，它们将被自动排序。</li></ul><p id="c8c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然使用<strong class="ih hj"> PriorityBlockingQueue </strong>可以解决<strong class="ih hj">竞争条件</strong>和<strong class="ih hj">帧排序</strong>，但它无法帮助我们实现自动关闭所需的层、队列和输出之间的<strong class="ih hj">同步</strong>。</p><p id="65c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我是这样解决这个问题的。</p><h1 id="b968" class="kc kd hi bd ke kf lf kh ki kj lg kl km kn lh kp kq kr li kt ku kv lj kx ky kz bi translated">自动关机(我称之为“滚动最后一帧”技术)</h1><p id="5728" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">自动关机的逻辑基于几条规则:</p><ul class=""><li id="3672" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mg mh mi mj bi translated">当源或任何其他滤波器<strong class="ih hj">完成</strong>其处理时，它将发出特定帧，姑且称之为<strong class="ih hj">最后一帧</strong>。该帧的<strong class="ih hj">序列号</strong>将被设置为无穷大(<code class="du mr ms mt mu b"><strong class="ih hj">Long.MAX_VALUE</strong></code> <strong class="ih hj"> </strong>)，因此它将被自动插入队列的最后一个。最后一帧将包含一个名为<strong class="ih hj"> layerSize </strong>的计数器，最初设置为发射器层的大小。在我们的示例中，源的大小为1，第一层的大小为2，第二层的大小为3。</li><li id="1a52" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">当最后一帧<strong class="ih hj">进入</strong>队列时，该队列将检查是否已经存在最后一帧(最终由不同线程的前一个过滤器发出)。如果是，它将<strong class="ih hj">减少</strong>最后一帧的层大小。</li><li id="fd67" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">当从队列中<strong class="ih hj">请求</strong>一帧时，如果第一帧是数据帧，则提取该帧；如果是最后一帧，那么它的引用<strong class="ih hj">将被返回，但是最后一帧将保留在队列中，可供其他线程使用。</strong></li><li id="ef5a" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">当最后一帧被下一层中的过滤器<strong class="ih hj">取为</strong>时，如果<strong class="ih hj"> </strong>最后一帧的<strong class="ih hj">层大小</strong>等于1，则该过滤器将停止其处理，并因此将最后一帧发送到下一队列。如果最后一帧包含一个大于1的<strong class="ih hj"> layerSize </strong>，它将被忽略。</li></ul><p id="1d88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了<strong class="ih hj">在滚动最后一帧</strong>时自动关闭。最后一帧将在系统中传播(滚动)。只要任何过滤器接收到layerSize等于1的最后一帧，它就会关闭(用灰色表示)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mq"><img src="../Images/5db2ba293560708f4230b4e045c9f237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AqWAVIOgmeUm-JRJDoKOIw.gif"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">使用滚动最后帧技术自动关闭引擎</figcaption></figure><p id="7449" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个逻辑必须在两个地方实现:队列和过滤器。</p><h2 id="a945" class="lk kd hi bd ke ll lm ln ki lo lp lq km iq lr ls kq iu lt lu ku iy lv lw ky lx bi translated">过滤器</h2><p id="fea4" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">这个片段显示了过滤器的逻辑。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="5796" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从队列中提取出一个帧(我将条件作为谓词传递，因为我想将队列的实现与帧的内部逻辑分离)。如果该帧是一个<strong class="ih hj">数据帧</strong>(不是最后一帧)，它将被处理并插入<strong class="ih hj">输出队列</strong>。否则，过滤器检查该帧是否是前一层的最后一个(即<strong class="ih hj"> layerSize </strong>是否等于1)。如果是，过滤器将<strong class="ih hj">向输出队列发送</strong>最后一帧，并将其自身设置为<strong class="ih hj">无效</strong>；否则，过滤器将<strong class="ih hj">忽略</strong>帧。</p><h2 id="1fe3" class="lk kd hi bd ke ll lm ln ki lo lp lq km iq lr ls kq iu lt lu ku iy lv lw ky lx bi translated">长队</h2><p id="bc3e" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">逻辑的另一部分在队列中实现。我扩展了PriorityBlockingQueue的逻辑，实现了我所谓的<strong class="ih hj">ConditionalPriorityBlockingQueueImpl</strong>(我知道，我本可以找到一个更好的名字)。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="89c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">提取</strong>帧的方法相对简单:队列获取第一帧(让我们记住它们是按序列号排序的)。队列应用<strong class="ih hj">谓词</strong>，用于检查是否提取帧，作为参数传递给帧。根据谓词的结果，帧被<strong class="ih hj">提取</strong>并且<strong class="ih hj">队列被更新</strong>，或者只是<strong class="ih hj">返回</strong>作为参考。</p><p id="66a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">插入</strong>最后一帧的方法稍微复杂一点。在这里，我再次将队列的逻辑从帧中分离出来。首先，队列检查队列中是否已经有最后一帧。如果是，调用上面的<code class="du mr ms mt mu b"><strong class="ih hj">editFunction</strong></code>(减少<strong class="ih hj">层大小</strong>)。如果没有，它将<strong class="ih hj">创建</strong>一个新的帧(静态构造函数<code class="du mr ms mt mu b"><strong class="ih hj">elementCreatorMethod</strong></code>不在此讨论范围内)并将<strong class="ih hj">插入到队列中。</strong></p><h2 id="badf" class="lk kd hi bd ke ll lm ln ki lo lp lq km iq lr ls kq iu lt lu ku iy lv lw ky lx bi translated">多线程引擎</h2><p id="9bbe" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">由于引擎自动关闭，它的API变得非常简单。此外，每个过滤器都包含其输入和输出队列作为属性，因此我可以将引擎设计为这些过滤器的简单包装器，并将其构造委托给工厂，这也不在范围之内。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h1 id="4672" class="kc kd hi bd ke kf lf kh ki kj lg kl km kn lh kp kq kr li kt ku kv lj kx ky kz bi translated">测试</h1><p id="ad41" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">为了测试引擎，我使用了之前描述的配置:1个源，第一层中的2个线程，第二层中的3个线程，1个串行写入器。<br/>为了这个测试，每一层<strong class="ih hj">中的<strong class="ih hj">过滤器</strong>将</strong>输入帧复制到输出，<strong class="ih hj">在控制台中打印一个日志</strong>并有一个<strong class="ih hj">随机延迟</strong>来模拟一个真实的情况场景，其中我们无法预测每一帧的准确处理时间。</p><p id="f16c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">写入器</strong>实现了与过滤器类似的逻辑，唯一的区别是它将有一个<strong class="ih hj">内部计数器</strong>来知道它必须等待哪个帧并从队列中提取，以保持输出中所需的顺序。它的<code class="du mr ms mt mu b"><strong class="ih hj">getFrameList</strong></code>方法在返回处理过的帧之前会一直等到处理完成。</p><p id="c697" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是我写的单元测试，用来验证数据源发出10帧时系统的行为。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="3ef3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是输出日志。如您所见，帧在两层中的处理顺序并不总是相同，但它们会按顺序到达输出。</p><pre class="jf jg jh ji fd mv mu mw mx aw my bi"><span id="1636" class="lk kd hi mu b fi mz na l nb nc">Frame 1 processed in layer 1</span><span id="f76f" class="lk kd hi mu b fi nd na l nb nc">Frame 2 processed in layer 1</span><span id="dc4f" class="lk kd hi mu b fi nd na l nb nc">Frame 0 processed in layer 2</span><span id="85b0" class="lk kd hi mu b fi nd na l nb nc">Frame 3 processed in layer 1</span><span id="0a80" class="lk kd hi mu b fi nd na l nb nc">Frame 2 processed in layer 2</span><span id="7b1e" class="lk kd hi mu b fi nd na l nb nc">Frame 4 processed in layer 1</span><span id="56ed" class="lk kd hi mu b fi nd na l nb nc">Frame 1 processed in layer 2</span><span id="9350" class="lk kd hi mu b fi nd na l nb nc">Frame 5 processed in layer 1</span><span id="1a93" class="lk kd hi mu b fi nd na l nb nc">Frame 3 processed in layer 2</span><span id="9334" class="lk kd hi mu b fi nd na l nb nc">Writing frame 0</span><span id="a162" class="lk kd hi mu b fi nd na l nb nc">Writing frame 1</span><span id="97c6" class="lk kd hi mu b fi nd na l nb nc">Writing frame 2</span><span id="e675" class="lk kd hi mu b fi nd na l nb nc">Frame 4 processed in layer 2</span><span id="ef28" class="lk kd hi mu b fi nd na l nb nc">Frame 6 processed in layer 1</span><span id="250f" class="lk kd hi mu b fi nd na l nb nc">Writing frame 3</span><span id="1de8" class="lk kd hi mu b fi nd na l nb nc">Frame 7 processed in layer 1</span><span id="990b" class="lk kd hi mu b fi nd na l nb nc">Writing frame 4</span><span id="0935" class="lk kd hi mu b fi nd na l nb nc">Frame 5 processed in layer 2</span><span id="37f3" class="lk kd hi mu b fi nd na l nb nc">Frame 8 processed in layer 1</span><span id="fd70" class="lk kd hi mu b fi nd na l nb nc">Frame 6 processed in layer 2</span><span id="b888" class="lk kd hi mu b fi nd na l nb nc">Writing frame 5</span><span id="a9a0" class="lk kd hi mu b fi nd na l nb nc">Frame 9 processed in layer 1</span><span id="6df2" class="lk kd hi mu b fi nd na l nb nc">Frame 7 processed in layer 2</span><span id="68a6" class="lk kd hi mu b fi nd na l nb nc">Frame 8 processed in layer 2</span><span id="c884" class="lk kd hi mu b fi nd na l nb nc">Writing frame 6</span><span id="6d92" class="lk kd hi mu b fi nd na l nb nc">Writing frame 7</span><span id="b8f5" class="lk kd hi mu b fi nd na l nb nc">Frame 9 processed in layer 2</span><span id="41c4" class="lk kd hi mu b fi nd na l nb nc">Writing frame 8</span><span id="9d04" class="lk kd hi mu b fi nd na l nb nc">Writing frame 9</span></pre></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="f341" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="3a34" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我在这里描述了我对一个常见问题的解决方案:如何实现一个多线程并行数据处理引擎，记住被处理数据的最终顺序；所有这些都用一个简单的Java实现(不使用任何消息代理或事件驱动架构)。我在代码片段中展示了我认为最有趣的代码部分，并省略了其他部分，如工厂或框架的实现细节。</p><p id="9da4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我的解决方案中，我更关注<strong class="ih hj">抽象</strong>(例如，使用<strong class="ih hj">泛型</strong>或<strong class="ih hj">谓词</strong>和<strong class="ih hj">函数</strong>作为参数)，这使得代码更加可重用，但牺牲了可读性。</p><p id="b5bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个<strong class="ih hj">选择</strong>将是一个更耦合但更简单的实现，可能会有一些代码重复，但可读性更好，同时推迟了泛化的需要。这也是一个有效的选择。</p><p id="f3e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">一如既往，看情况</em>！这取决于情况，取决于我们的用例，取决于我们目前对<em class="jd">的了解，如果/如何/何时</em>我们的系统会在未来发展，当然，还取决于你的个人品味和审美感！</p></div></div>    
</body>
</html>