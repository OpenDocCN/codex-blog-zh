<html>
<head>
<title>Flog: a functional logger for Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">flog:Scala的一个函数式日志记录器</h1>
<blockquote>原文：<a href="https://medium.com/codex/flog-a-functional-logger-for-scala-986d4039562f?source=collection_archive---------4-----------------------#2021-05-12">https://medium.com/codex/flog-a-functional-logger-for-scala-986d4039562f?source=collection_archive---------4-----------------------#2021-05-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8c4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">不幸的是，记录可能是一件好事，也可能是一件坏事。对于生产系统，日志记录是一门独立的学科。但是，在代码开发中，它似乎并没有得到足够的使用。它应该是如此简单，以至于当试图理解为什么代码不能像预期的那样工作时，它是第一个，而不是最后一个手段。这一点在函数式编程语言中尤为明显。那是因为测井是以<em class="jm">语句</em>为导向，而不是以<em class="jm">表达式</em>为导向。即使您不想麻烦日志记录，而是使用<em class="jm"> println </em>，您仍将不得不与您的代码搏斗，因为<em class="jm"> println </em>产生<em class="jm">单元</em>，即它是面向语句的。</p><figure class="jo jp jq jr fd js er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es jn"><img src="../Images/216c16ae2f70e56570004e88eaa62e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iT45x1w_apoudzCiPhQ_2Q.jpeg"/></div></div></figure><p id="6755" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是为什么我开发了<strong class="ih hj"> Flog </strong>，一个Scala (2)的函数式日志记录器。真的很好用。假设你想定义一个类型为<em class="jm"> X </em>的<strong class="ih hj"> val </strong> <em class="jm"> x </em>作为某个表达式(<em class="jm"> expr </em>)，你写:</p><pre class="jo jp jq jr fd jz ka kb kc aw kd bi"><span id="a94a" class="ke kf hi ka b fi kg kh l ki kj">val x: X = expr</span></pre><p id="7abf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是现在您决定想要知道<em class="jm"> expr </em>的实际值是多少。只需添加一个<em class="jm">消息</em>(日志消息，一个<em class="jm">字符串</em>)和操作符！！如下所示:</p><pre class="jo jp jq jr fd jz ka kb kc aw kd bi"><span id="1c65" class="ke kf hi ka b fi kg kh l ki kj">val flog = <!-- -->Flog[MyClass]<br/>import flog._</span><span id="c396" class="ke kf hi ka b fi kk kh l ki kj">// other code</span><span id="63a8" class="ke kf hi ka b fi kk kh l ki kj">val x: X = msg !! expr</span></pre><p id="c7ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样！基本上你要做的就是这些。一个<em class="jm"> expr </em>的表示将被附加到日志中，否则，程序的行为将与之前完全一样。但是，如果您不想在日志中再次看到该值，该怎么办呢？只需更换！！运算符by |！并且程序将同样运行，但是此时没有日志记录(哦，顺便说一下，<em class="jm"> msg </em>不会被求值)。</p><p id="dccc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">的！！如果使用标准记录器，操作员对应于<em class="jm">信息</em>。也可以用！？对于<em class="jm">调试</em>或者！？？对于<em class="jm">跟踪</em>。</p><p id="c046" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，你可以通过简单地将<em class="jm"> Flog() </em>替换为<em class="jm"> Flog </em>()，来去除<em class="jm"> Flog </em>在模块中的所有用法。<em class="jm">禁用</em>。最终，当您确定再也不想记录这个表达式时，您只需删除<em class="jm"> msg |！</em>共构。</p><p id="2ad4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，<em class="jm"> Flog </em>使用的实际日志记录实用程序是<em class="jm">org . slf4j . logger factory . get logger</em>用于<em class="jm"> Flog </em>类本身。对于严肃的使用，你会想要为你自己的类使用一个记录器。您可以通过将<em class="jm"> flog </em>实例化为:</p><pre class="jo jp jq jr fd jz ka kb kc aw kd bi"><span id="318d" class="ke kf hi ka b fi kg kh l ki kj">val flog: Flog = Flog[MyClass]</span></pre><p id="f9d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，您可能也想知道记录器如何知道如何表示类型<em class="jm"> X </em>的实例。如果<em class="jm"> X </em>是某种复合但熟悉的类型，如<em class="jm"> Iterable[Int]、Future[Double]、</em>或<em class="jm"> Option[String] </em>(还有许多其他受支持的容器)，那么记录器将只做合理的事情，而不需要您做任何额外的工作。但是如果<em class="jm"> X </em>是自己代码中定义的类型呢？是<strong class="ih hj">案例类</strong>(还是其他<em class="jm">产品</em>)？然后使用适当数量的参数简单地调用<em class="jm"> loggableN </em>方法:</p><pre class="jo jp jq jr fd jz ka kb kc aw kd bi"><span id="e832" class="ke kf hi ka b fi kg kh l ki kj">case class Complex(real: Double, imag: Double)<br/>implicit val complexLoggable: Loggable[Complex] = new Loggables {}.loggable2(Complex)<br/>"test complex" !! <em class="jm">Complex</em>(1, 0)</span></pre><p id="584f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果你自己开发的类不是产品呢？那么你有两个选择。快速和肮脏的版本，你用！|操作员。这将把<em class="jm"> toString </em>应用于该值并使用它。更好的方法是在<em class="jm"> X </em>的伴生对象中创建一个<em class="jm"> Loggable[X] </em>的隐式值，如果您要记录诸如<em class="jm"> Try[X] </em>或<em class="jm"> List[X] </em>之类类型的值，这也是必需的。这很容易做到，在<em class="jm">自述文件</em>中有描述。</p><p id="f5f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在https://github.com/rchillyard/Flog找到这个日志库。您可以使用下面的<em class="jm"> sbt </em>指令将flog包含在您的项目中:</p><p id="08e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">library dependencies+= " com . phasmidsoftware " % " flog _ 2.13 " % " 1 . 0 . 8 "</p><p id="498c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编辑2021/9/10，添加<em class="jm"> sbt </em>依赖信息。</p></div></div>    
</body>
</html>