<html>
<head>
<title>Sealed classes and traits in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中的密封类和特征</h1>
<blockquote>原文：<a href="https://medium.com/codex/sealed-classes-and-traits-in-scala-62e6076053c6?source=collection_archive---------3-----------------------#2021-09-16">https://medium.com/codex/sealed-classes-and-traits-in-scala-62e6076053c6?source=collection_archive---------3-----------------------#2021-09-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e50c8636e2c6bb1da0eb3ca441a26cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hO7F5sYzOYfZ0T0_"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@amyannaasher?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾米·阿什</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="cafb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">昨天，9月14日，是Java 17的正式发布日，这是几年来第一个长期支持(LTS)版本(之前的LTS版本是三年前发布的Java 11)。</p><p id="b617" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java 17的新特性之一是增加了密封类和接口。这对那些只使用Java编程的人来说很陌生，但对那些也使用Scala编程的人来说并不奇怪。</p><p id="187a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" rel="noopener" href="/codex/the-future-of-java-is-to-absorb-scala-features-965ceaf7c8e4">我上周写了</a>Java的未来是吸收Scala特性。当然，不是每一个特性，只是那些被认为是有益的，并且可以在不破坏向后兼容性的情况下引入Java的特性。</p><p id="ed84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Scala中的密封类和密封特征被认为是Java值得拥有的。在“<code class="du jt ju jv jw b">class</code>”或“<code class="du jt ju jv jw b">interface</code>”之前添加<code class="du jt ju jv jw b">sealed</code>修饰符不会破坏现有的程序，因为如果它们是早期Java版本的有效程序，它们在上下文中就不会有这个词。</p><p id="ee3d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅仅因为Scala程序员对Java的这个新特性并不感到惊讶，并不一定意味着他们知道它是如何工作的，或者他们已经在自己的Scala程序中使用了这个特性。</p><p id="d7e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我将概述Scala中密封类和特征的基础知识。我还会给出几个具体的例子，希望能给你一些关于如何在自己的Scala程序中使用密封类和特征的想法。</p><p id="6454" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Java和Scala中，一个类都可以被标记为final(当然Java接口成为final是没有意义的)。如果它不是最终的，一个非私有类可以被同一个包中的任何其他类扩展，或者被模块中的任何类扩展，或者如果它是公共的，被“世界”扩展。</p><p id="90b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，在某些情况下，您可能希望允许一个类被扩展，但是只在某些非常特殊的条件下。</p><p id="fe2c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于Match-Case语句中的模式匹配，访问修饰符，即使Scala能够比Java更精确地指定访问范围，也可能不如您所希望的那样细粒度。</p><p id="d6b1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，假设您想要根据继承的下一个较低级别的子类匹配一个<code class="du jt ju jv jw b">java.net.URLConnection</code>对象(不考虑运行时类)。</p><p id="ce3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该对象可能是一个<code class="du jt ju jv jw b">HttpURLConnection</code>或一个<code class="du jt ju jv jw b">JarURLConnection</code>。这些可能是Java开发工具包中唯一的“主要”类型，但不能保证它们是特定系统配置中的唯一类型。</p><p id="89f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以你必须为一个意外的主要类型提供一个默认的案例，比如<code class="du jt ju jv jw b">FtpURLConnection</code>，或者容忍一个非穷举的匹配警告，以及运行时可能出现的<code class="du jt ju jv jw b">MatchError</code>。</p><p id="5eca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用Scala创建的类层次结构也是如此。但是在Scala中，你总是有第三种选择:密封类。</p><p id="ede5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，在Java 17(或更早的Java 15，如果您启用了预览功能)，您也可以在Java中使用该选项。</p><p id="391b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">密封类意味着它只能由您指定的类(或特征，而不是接口)来扩展。试图用未指定的类扩展密封类会导致编译错误。</p><p id="7cf6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Scala中，您可以通过将子类或子目录放在同一个源文件中来指定，稍后您将在示例中看到。</p><p id="fb53" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Java中，看起来你必须写一个许可条款(例如，“<code class="du jt ju jv jw b">sealed class Shape permits Circle, Triangle, Square,</code>”等等)。)，我猜它们一定在单独的源文件中。</p><p id="b7ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不认为<code class="du jt ju jv jw b">Shape</code>类是密封类的好用例。也许棋子是一个更好的用例，因为棋子的数量比二维图形的数量要少得多。</p><p id="e9af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所知，国际象棋是两个人的游戏。每个玩家得到十六个棋子:一个国王，一个王后，两个象，两个骑士和两个车，以及八个棋子。不同的部分可以由具有公共超类的不同类的实例来表示。</p><p id="b72d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们密封了那个公共超类，那么编译器知道这些是那个超类存在的唯一子类。</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="d81f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了密封的<code class="du jt ju jv jw b">Piece</code>类，编译器现在知道一个<code class="du jt ju jv jw b">Piece</code>实例只能是一个<code class="du jt ju jv jw b">King</code>、<code class="du jt ju jv jw b">Queen</code>、<code class="du jt ju jv jw b">Bishop</code>、<code class="du jt ju jv jw b">Knight</code>、<code class="du jt ju jv jw b">Rook</code>或<code class="du jt ju jv jw b">Pawn</code>。如果我们想要更多的片段，比如大主教和大法官，我们只需要将它们添加到源文件中。</p><p id="b9b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意<code class="du jt ju jv jw b">Pawn</code>是抽象的。但也许所有这些都需要是抽象的。请随意使用这个例子。</p><p id="44bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能会觉得Scala中的密封类就像Java中的枚举类型(或“枚举”)。有时它们被用于这个目的。例如，我们可以，</p><pre class="jx jy jz ka fd kd jw ke kf aw kg bi"><span id="d01e" class="kh ki hi jw b fi kj kk l kl km">sealed class DayOfTheWeek</span><span id="94c8" class="kh ki hi jw b fi kn kk l kl km">object SUNDAY</span><span id="abef" class="kh ki hi jw b fi kn kk l kl km">object MONDAY</span><span id="cee0" class="kh ki hi jw b fi kn kk l kl km">object TUESDAY</span><span id="a3cd" class="kh ki hi jw b fi kn kk l kl km">// etc.</span></pre><p id="35a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住，就Java虚拟机(JVM)而言，没有枚举类型或“枚举”这样的东西，只有扩展了<code class="du jt ju jv jw b">Enum&lt;E&gt;</code>的最终类<code class="du jt ju jv jw b">E</code>。</p><p id="3a46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这给了我尝试编写一个扩展<code class="du jt ju jv jw b">java.lang.Enum[E]</code>的密封Scala类的想法。这是一个充满问题的兔子洞。密封的类和特征并不是Java枚举类型的答案。</p><p id="c1d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">据我所知，密封抽象类和密封特征之间的区别与非密封抽象类和非密封特征之间的区别是一样的。</p><p id="4181" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，这意味着一个类只能扩展一个密封类的一个子类，但是一个类可以实现一个密封特征的多个子树。</p><p id="8114" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑这个例子:</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="5a6e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么我们可能会有这样的情况:</p><pre class="jx jy jz ka fd kd jw ke kf aw kg bi"><span id="1ade" class="kh ki hi jw b fi kj kk l kl km">class Knight extends Piece<strong class="jw hj"> with CanJumpOver with SomeOtherTrait</strong> {</span><span id="5d7f" class="kh ki hi jw b fi kn kk l kl km">  override val notation: String = "N"</span><span id="a1af" class="kh ki hi jw b fi kn kk l kl km">  <strong class="jw hj">override val minimumMoveDistance: Int = 3</strong></span><span id="dae0" class="kh ki hi jw b fi kn kk l kl km"><strong class="jw hj">  override val maximumMoveDistance: Int = 3</strong></span><span id="5913" class="kh ki hi jw b fi kn kk l kl km">}</span></pre><p id="8688" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我这样设置，<code class="du jt ju jv jw b">Knight</code>可以直接扩展<code class="du jt ju jv jw b">Piece</code>，但不能直接实现<code class="du jt ju jv jw b">Movable</code>。也许这是这个特定用例的正确设计。</p><p id="cded" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不知道是否有办法在运行时绕过密封，但我知道本地的Scala REPL不允许这样做。</p><pre class="jx jy jz ka fd kd jw ke kf aw kg bi"><span id="6652" class="kh ki hi jw b fi kj kk l kl km">scala&gt; class Archbishop extends chess.pieces.<strong class="jw hj">Piece</strong> with chess.pieces.CanJumpOver<br/>                                             <strong class="jw hj">^</strong><br/>       <strong class="jw hj">error: illegal inheritance from sealed class Piece</strong></span><span id="2287" class="kh ki hi jw b fi kn kk l kl km">scala&gt; class Chancellor extends chess.pieces.<strong class="jw hj">Movable</strong><br/>                                             <strong class="jw hj">^<br/>       error: illegal inheritance from sealed trait Movable</strong></span></pre><p id="4136" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我还没有看到Scala编译器如何编译密封的类和特征，也没有看到它们如何出现在JVM中。很可能已经超越了基础。</p><p id="bbd8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简而言之，Scala中密封类和特征的基本思想是，它们使您能够在一个层次上限制继承层次，而不限制它在直接子类或子类型之下的任何层次上。</p><p id="bd66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是Scala中密封类和特征的基础。我希望这篇介绍能给你一些如何在自己的Scala项目中使用它们的想法。</p></div></div>    
</body>
</html>