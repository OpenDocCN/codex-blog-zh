<html>
<head>
<title>High Performance Random Numbers: A Mersenne twister alternative</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高性能随机数:梅森扭结器的替代方案</h1>
<blockquote>原文：<a href="https://medium.com/codex/high-performance-random-numbers-a-mersenne-twister-alternative-cf827d89897a?source=collection_archive---------1-----------------------#2021-04-24">https://medium.com/codex/high-performance-random-numbers-a-mersenne-twister-alternative-cf827d89897a?source=collection_archive---------1-----------------------#2021-04-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a5ae3261f95838b1c38fc70e2c07ca08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xgUpqN2cfBPPVu62"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">埃菲社在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="aded" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">随机数及其生成对于几乎所有产品级软件都至关重要。它们大量用于游戏、人工智能、功能测试等等。然而，尽管在如此广泛的应用中普遍存在，但生成它们的算法和方法在过去的25年中并没有太大的变化。典型地，伪随机数发生器(PRNG)被分为两类，一类是加密的，另一类是非加密的，并且作为随机性和速度之间的平衡。用于非加密用例的主要一个被称为<a class="ae iu" href="https://en.wikipedia.org/wiki/Mersenne_Twister" rel="noopener ugc nofollow" target="_blank">梅森扭转器</a>。</p><p id="5009" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Mersenne twister最初是由松本诚和西村拓治在1997年开发的。它主要基于使用<a class="ae iu" href="https://en.wikipedia.org/wiki/Mersenne_prime" rel="noopener ugc nofollow" target="_blank">梅森素数</a>作为周期的概念。Mersenne twister在各种流行的编程语言以及许多商业应用程序中被用作PRNG。它依赖于一个相当大的国家，并提供充足的性能。这个可以改进吗？PRNG有可能以最小的随机性和内存使用牺牲来击败梅森图吗？</p><p id="77c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我将尝试通过使用不同的算法生成随机数来回答这个问题。这种替代算法的独特属性称为FY5Z，它可以使用SIMD内在指令进行完全优化。我们将评估与Mersenne twister相比的性能和随机性效率。</p><h1 id="0c73" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">FY5Z:前进洗牌机</h1><p id="7173" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">SIMD指令，如x86机器上广泛使用的SSE2集，提供了一次对128位数据执行向量运算的能力。在整数的情况下，这意味着每个向量中同时有两个64位整数或四个32位整数。在大多数处理器上，诸如加法或减法之类的基本操作通常每条指令不到一个时钟周期。然而，使用最简单的操作不足以达到高效或可容忍的随机性水平。为了速度而牺牲任何实质上的随机分布，完全违背了PRNG的目的。因此，需要一些更有影响力的操作。</p><p id="1d4b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">SIMD指令集，如SSE2，提供了称为混洗的特殊操作，在常规汇编中没有直接的等价操作。在高级别上，混洗是根据掩码或控制整数改变数据顺序的操作。把这想象成<em class="kw">并行交换</em>。对于SSE2集合，仅在<a class="ae iu" href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=SSE2&amp;text=shuffle" rel="noopener ugc nofollow" target="_blank"> 16或32位整数</a>上支持混洗。这两种类型的操作，加法和洗牌，可以用来创建一个有效的大国家与一个较小的周期。这是通过将shuffle的子状态“携带”到某个更大的状态来实现的，比如一个整数数组。四个32位整数的单次混洗可以如下所示:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/bda8613a0952a753367c42f8194ac689.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*IVv98KEtBAky6I7iptJCZw.png"/></div></figure><p id="2f07" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用八位控制掩码混洗每组四个整数，使得掩码的每两位代表一个槽，在操作之后，索引槽中的整数应该被放置。例如，如果掩码中的第一个两位整数是3，这意味着128位向量中的第一个32位整数移动到结果向量中的最后一个槽。</p><p id="b5af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设有一个32位整数的向量。为了混洗所有的整数，需要每四个整数混洗一次，直到我们混洗了<code class="du lc ld le lf b">n</code>个整数。然而，目标是产生伪随机数，而不仅仅是洗牌。需要一些其他操作来增加随机数发生器中所谓的<em class="kw">周期</em>，即一个数重复之前的世代数。对于这种情况，将使用将混洗的整数添加到另一个向量，该向量跨代保持其状态。这确保了会有很大可变性和传播。</p><p id="3f04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">两个操作可以组合成一个称为前向洗牌的东西，这是一个由跨越一个更大的状态向量的所有洗牌操作的总和形成的向量。这样的操作可以被认为如下:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es lg"><img src="../Images/8e5b36a83d955835a20ad689d460d2a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*XiBOvcSZmfLu7eurzCgFuQ.png"/></div></figure><h1 id="d150" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">测试:性能</h1><p id="98bc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">击败Mersenne twister的第一个测试是性能问题。可以编写一个PRNG来更快地生成伪随机数吗？该测试在四核i7英特尔Haswell处理器上并排比较了Mersenne Twister和Fy5z的实施。对于Fy5z的实现，前向混洗的顺序被线性测试，其中向量状态的每个部分被顺序混洗和求和，以及分组密码版本，其中混洗的顺序是混沌顺序。为了增加熵和随机性，在添加到混洗整数的值上使用了额外的掩码。使得不是将混洗的整数加回先前的向量，而是将它们加到掩码，然后存储在状态向量中。Fy5z的实现如下:</p><figure class="ky kz la lb fd ij"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="c8b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个实现将会和Mersenne twister的标准C实现进行测试，可以在这里找到<a class="ae iu" href="https://github.com/ESultanik/mtwister" rel="noopener ugc nofollow" target="_blank"/>。在50次产生1000万个随机数的试验中，以微秒计的平均结果是:</p><pre class="ky kz la lb fd lj lf lk ll aw lm bi"><span id="78e3" class="ln ju hi lf b fi lo lp l lq lr">Running: 'Mersenne Twister' took 109224 u/s<br/>Running: 'fy5z' took 62958 u/s<br/>Running: 'fy5z_block' took 67703 u/s</span></pre><p id="69cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">幸运的是，Fy5z的实现确实优于Mersenne Twister。为什么会这样？首先，MT是在每个整数的基础上操作的，它是一个标量算法。其中这种新的正向洗牌是以并行的向量方式进行的。鉴于此，这并不试图使用AVX和更近期的SIMD指令，有很少或没有风险被低于时钟在CPU的水平。在这里，“块”变体的执行速度似乎比非块变体要慢一些。这可能有多种原因，但最主要的是，以标量方式(非矢量化)索引一个<code class="du lc ld le lf b">static</code>数组所增加的开销会降低性能。</p><p id="0eb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了速度，PRNG的一个非常重要的属性是它的随机程度。不检查随机数生成器的随机程度，就不能盲目地庆祝速度的提高。</p><h1 id="d61a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">测试:随机性</h1><p id="cd89" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们可以用多种方式测试PRNG实现的随机性。最生动和详细的方式，虽然是一个图形和绘图测试。对于这个测试，两个PRNGs都将生成一些等效的随机二维坐标。这些坐标将用于在橙色“画布”上绘制黑点。目的是描绘出每个生成器的输出是什么样子，以及每个生成的输出的分布和排列。</p><p id="1ad5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，可以使用一个<a class="ae iu" href="https://github.com/jweinst1/png-maker/blob/master/CMakeLists.txt" rel="noopener ugc nofollow" target="_blank"> cmake项目和一个简单的C程序</a>，该程序使用了为处理和编辑可移植网络图形(PNG)图像而开发的原始库<code class="du lc ld le lf b">libpng</code>，可以用来“绘制”生成的随机数。下面你看到的图像是png图像，颜色深度为1位，调色板为2色。这意味着每个像素由一位表示，允许高压缩率。第一个结果是Fy5z的:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/3025085262320e3e923826e0465f4772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4GMyXymPMU69I56CA0YzVg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Fy5z PRNG</figcaption></figure><p id="7c7d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，梅森图的结果是:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/482f697a9d81cd4dd8fe1a0c5125b7b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qp1Wab6JiPSp9-9Io3oVyA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">梅森龙卷风PRNG</figcaption></figure><p id="a8f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如人们所看到的，这两者之间有显著的区别。虽然Fy5z版本仍然实现了伪随机分布，但它具有稀疏可见的线，并且当与Mersenne Twister图像相比时，坐标重叠。另一方面，梅森龙卷风几乎没有明显的模式，看起来更加随机。</p><p id="57a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为什么会这样呢？一种可能性是周期。Fy5z的周期比Mersenne Twister短，导致在相同数量的世代中可能会发生更多的碰撞。总的来说，这些测试表明PRNGs的更快实现确实是可能的。然而，这样做可能会导致随机性下降，因此需要更多的尽职调查来创建在最大性能和随机性方面表现出色的PRNGs。</p></div></div>    
</body>
</html>