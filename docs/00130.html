<html>
<head>
<title>Seven cool Fibonacci functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">七个很酷的斐波那契函数</h1>
<blockquote>原文：<a href="https://medium.com/codex/some-cool-fibonacci-functions-in-a-few-different-languages-69db36e7bc1a?source=collection_archive---------0-----------------------#2020-10-24">https://medium.com/codex/some-cool-fibonacci-functions-in-a-few-different-languages-69db36e7bc1a?source=collection_archive---------0-----------------------#2020-10-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/db1dbf5a5d40142e7a317cb406fd75d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ky6OmSABzeTebPQ6"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@luddelorentz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢德·洛伦兹</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2e9b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每当我学习一门新语言时，我首先要写的就是一些简单的斐波那契数列函数，一个是递归的，一个是迭代的，还有一个是生成斐波那契数列直到n的函数。这三个问题通常揭示了不同语言之间的哲学差异，或者展示了在一种语言中处理一个问题的不同方法。以下是我发现的一些最酷的斐波那契函数。</p><h1 id="1a80" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">传统递归</h1><p id="ecc2" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这是Python中标准的递归斐波那契函数。我们以前都见过。这很无聊，而且慢得令人难以置信。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="26a9" class="lf ju hi lb b fi lg lh l li lj">def fib(n):<br/>    if (n &lt; 2):<br/>        return 1<br/>    return fib(n - 1) + fib(n - 2)</span></pre><p id="b424" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管在Haskell中使用模式匹配看起来很优雅:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="b53a" class="lf ju hi lb b fi lg lh l li lj">fib 0 = 1<br/>fib 1 = 1<br/>fib n = (fib (n - 1)) + (fib (n - 2))selection-clipboard: primary</span></pre><h1 id="84d5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">传统迭代</h1><p id="be6e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">相比之下，迭代版本当然快得令人难以置信。不过还是很无聊。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="1bb0" class="lf ju hi lb b fi lg lh l li lj">def fib(n):<br/>    a, b = 1, 1<br/>    for i in range(n):<br/>        a, b = b, a + b<br/>    return b</span></pre><h1 id="46d7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">比奈公式</h1><p id="4fe4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">比奈公式是第n个斐波那契数列的公式:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/e185a268549afe6e7b5859f05429008b.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/0*zaOIKejfjLmnMeYz.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">信用:解决问题的艺术</figcaption></figure><p id="04b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是到目前为止的第一个单句程序，但是它很蹩脚:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="5217" class="lf ju hi lb b fi lg lh l li lj">def fib(n): <br/>    return int((((1+5**0.5)/2)**n - ((1-5**0.5)/2)**n)/5**0.5)</span></pre><h1 id="95a0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">哈斯克尔·齐威思</h1><p id="702f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">有趣的事情从这里开始:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="19ef" class="lf ju hi lb b fi lg lh l li lj">fibs = 1 : 1 : zipWith (+) fibs (tail fibs)</span></pre><p id="014f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这创建了一个延迟生成的无限斐波那契数列。使用它，我们可以通过索引或切片无限列表来访问第n个斐波那契数。对于那些不熟悉Haskell的人来说，这可能看起来很神奇，但是我会试着解释一下，但不会试图从总体上解释Haskell。</p><p id="28bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本质上，对于前两个元素之后的每个元素，我们将列表添加到自身，但将它偏移一:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="c46f" class="lf ju hi lb b fi lg lh l li lj">[1, 1] -- starting list</span><span id="2fd0" class="lf ju hi lb b fi ll lh l li lj">-- Add the offset list to the non offset list</span><span id="b6c6" class="lf ju hi lb b fi ll lh l li lj">  [1, 1]<br/>+ [1]</span><span id="384b" class="lf ju hi lb b fi ll lh l li lj">-- resulting in:<br/>[1, 1, 2]</span><span id="8605" class="lf ju hi lb b fi ll lh l li lj">-- and then again;<br/>  [1, 1, 2]<br/>+ [1, 2]</span><span id="7765" class="lf ju hi lb b fi ll lh l li lj">-- resulting in:<br/>[1, 1, 2, 3]</span></pre><h1 id="b54f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">递归Python Oneliner</h1><p id="056f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这是一个极其愚蠢的实现，但是当我被要求在不使用Binet公式的情况下用Python写一个斐波那契数列单行程序时，我想到了这个实现。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4e47" class="lf ju hi lb b fi lg lh l li lj">def fibs(n): [fib(x) for x in range(n) for fib in [lambda x: 1 if x &lt; 2 else fib(n - 1) + fib(n - 2)]]</span></pre><p id="baba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本质上，这个函数使用一个元素列表理解来内联创建一个斐波那契函数。它甚至比标准的递归函数都慢，但这是一个有趣的技巧。</p><h1 id="2c30" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">。折叠()一行</h1><p id="8baf" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">下一个是标准迭代版本的一个非常酷的版本，它可以在任何语言中使用<code class="du lm ln lo lb b">.fold()</code>方法和匿名函数。这是它在Rust中的样子:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="f36d" class="lf ju hi lb b fi lg lh l li lj">fn fib(n: usize) -&gt; usize {<br/>    (0..n).fold((0, 0), |(a, b), _| (b, a + b)).1<br/>}</span></pre><p id="0a1b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你熟悉<code class="du lm ln lo lb b">.fold()</code>和更高级的函数，这很容易理解，在Rust中，它和标准迭代函数一样快。</p><h1 id="2736" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">无限生成器</h1><p id="ef7d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Haskell的zipWith Fibonacci函数之所以简洁，部分原因是它生成了一个无限的Fibonacci数列表，以后可以对其进行索引或切片。虽然懒惰是Haskell的核心部分，但在使用生成器或懒惰迭代器的语言中也可以做到这一点。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="206c" class="lf ju hi lb b fi lg lh l li lj">def fibs():<br/>    a, b = 1, 1<br/>    while True:<br/>        yield b<br/>        a, b = b, a + b</span></pre></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><p id="24d0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯，这是我最后一个了，但我肯定还有很多我错过了。尤其是，我对任何简洁的Lisp解决方案感兴趣。如果你有任何酷的东西，请在下面分享！</p></div></div>    
</body>
</html>