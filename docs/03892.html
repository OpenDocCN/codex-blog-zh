<html>
<head>
<title>Easy Implementation of Dummy Coding/One-Hot Coding in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R语言中伪编码/一键编码的简单实现</h1>
<blockquote>原文：<a href="https://medium.com/codex/easy-implementation-of-dummy-coding-one-hot-coding-in-r-42c0486f8996?source=collection_archive---------3-----------------------#2021-10-05">https://medium.com/codex/easy-implementation-of-dummy-coding-one-hot-coding-in-r-42c0486f8996?source=collection_archive---------3-----------------------#2021-10-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/667c76287ec96d85b52f34966d03b1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*D03XWCJijo8DoUQKDSyJ5A.jpeg"/></div></figure><p id="62f0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本文总结了一些简单的方法，可以快速地将分类变量一起转换为0-1值，其他变量保留在数据帧中以供下一步分析。</p><p id="12db" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们不使用繁琐的ifelse或case_when函数。</p><p id="10de" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我将构建一个常规任务:在一个数据框架中，我们有一个ID变量，一个数值变量，N1，两个分类变量，C1和C2，我们想把它们编码为虚拟变量，还有一个分类变量，C3，我们保持不变。</p><p id="6172" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们首先创建一些数据。函数set.seed用于保证每次运行代码时都可以复制结果。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="d2a1" class="jt ju hi jp b fi jv jw l jx jy">set.seed(451)<br/>df=data.frame(<br/>id=1:8,<br/>N1=round(runif(8,14,20),2),<br/>C1=sample(c("E","F","G","H"),8,replace=T),<br/>C2=sample(c("Ideal","Good","Average"),8,replace=T),<br/>C3=sample(c("Group 1","Group 2"),8,replace=T),stringsAsFactors = T) </span></pre><p id="caf3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我创建了一个有5个变量和8行的数据帧。见下文。如果对set.seed()使用451，那么应该创建和我一样的数据帧。</p><figure class="jk jl jm jn fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/f9b2886715e07c0d049d873d1a59dc82.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*XON6eCCpAspq2Dr2f6AC9g.png"/></div></figure><p id="6206" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如开始所述，我们只需要伪编码C1和C2。C1有4个不同的级别(E、F、G和H)，C2有3个不同的级别(好、理想和一般):4+3=7。如果我们不考虑满级，我们将创建7个假人，每个一级。</p><p id="cb63" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是，如果我们想保持一个完整的秩，并避免所谓的“伪陷阱”，我们将有一个截距(或常数，即一列1)和5个伪，或6个没有截距的伪。我让读者去弄清楚什么是虚拟陷阱。</p><p id="5365" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面我提供三种方法。每个都只是使用管道的一行代码。你可以复制我的代码，做一些小的改动来完成你的工作。</p><p id="910a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，我使用pivot_wider函数来完成虚拟编码。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="53ce" class="jt ju hi jp b fi jv jw l jx jy">library(tidyverse)<br/>df1=df %&gt;% mutate(value1=1,value2=1) %&gt;% pivot_wider(names_from =C1,values_from=value1,<strong class="jp hj">values_fill = 0</strong>) %&gt;%  pivot_wider(names_from = C2,values_from=value2,values_fill = 0);df1</span></pre><p id="6bf3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">诀窍是创建两个1的常量列(称为value1和value2)，并通过pivot_wider两次将数据转换为宽形。每次我们使用<strong class="io hj"> values_fill = 0 </strong>用零填充NAs。我们现在只为C1和C2完成了彻底的虚拟转换。总共创建了7个虚拟变量。</p><p id="6a23" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了获得满秩变换，我们可以移除7个虚拟对象中的一个，或者添加一个截距并从两个因子中的每一个移除一个虚拟对象。由这两个虚拟变量代表的因子水平被选择作为参考。在下面，我选择<strong class="io hj">虚拟E和理想</strong>作为参考，并在添加截距时相应地删除它们。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="27e5" class="jt ju hi jp b fi jv jw l jx jy">df2=df1 %&gt;% mutate(intercept=1) %&gt;% <strong class="jp hj">select(-c(E,Ideal)</strong>);df2</span></pre><p id="a2fd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有时人们想跟踪那些新的假人(他们最初来自哪个栏目，C1还是C2？).他们想给那些假名字加上前缀或附录，比如“C1”。e”或“好的C2”我的方法是在改变C1和C2的价值观之前先改变它们。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="e641" class="jt ju hi jp b fi jv jw l jx jy">df1=df %&gt;% mutate(value1=1,value2=1,<strong class="jp hj">C1=str_c("C1_",C1),C2=paste0(C2,".C2")</strong>) %&gt;% pivot_wider(names_from =C1,values_from=value1,values_fill = 0) %&gt;%  pivot_wider(names_from = C2,values_from=value2,values_fill = 0);df1</span></pre><p id="b5a1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">无论是<strong class="io hj"> paste0还是strc_c </strong>都可以系统地改变C1和C2的值(如上图所示)。如果你找到更好的方法，请告诉我。</p><p id="cd4e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">pivot_wider的对立面pivot_longer可以轻松地将一组虚拟变量转换回分类变量。你可以从我之前的文章中找到答案。</p><p id="f788" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另一种方法是在caret包中使用dummyVar。语法dummyVar有点奇怪，因为它需要两步才能得到我们需要的数据帧。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="5891" class="jt ju hi jp b fi jv jw l jx jy">library(caret)<br/>df1=dummyVars( ~.-C3, data = df,sep = "_")<br/>data.frame(predict(df1, newdata = df))<br/>df1$C3=df$C3;df1</span></pre><p id="690e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用管道，</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="6a25" class="jt ju hi jp b fi jv jw l jx jy">df1=df %&gt;% dummyVars(~.<strong class="jp hj">-C3</strong>,data=., <strong class="jp hj">sep="_"</strong>) %&gt;% predict(,newdata=df) %&gt;% as.data.frame()%&gt;%mutate(C3=df$C3)</span></pre><p id="70aa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">dummyVars像pivot_wider一样给你7个虚拟变量。dummyVars的优点是它可以自动保留原来的列名(C1和C2)作为前缀，并相应地将它们添加到那些虚拟变量的名称中。</p><p id="83b0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">dummiesVars的问题是，它将数据框架中的每个分类变量转换为dummy，除非我们将C3排除在转换之外(通过在公式中添加<strong class="io hj"> -C3 </strong>)。因此，C3从新数据帧中移除，我们必须通过mutate函数手动将其添加回来。</p><p id="a443" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">公式也有猫腻:“~。——C3“，”~C1+。——C3“，”~C2+。——C3“，”~C1+C2+。-C3”和“~C1+C2+N1+id-C3”都给出了相同的结果，但是列的顺序不同。公式中的点表示包括数据框架中的所有变量。</p><p id="ba3e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用dummyVars时如何获得满秩变换？dummyVars有一个选项<strong class="io hj"> fullRank=T </strong>来实现这个目标。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="d972" class="jt ju hi jp b fi jv jw l jx jy">df1=df %&gt;% dummyVars(~.-C3,data=., sep="_",<strong class="jp hj">fullRank=T</strong>) %&gt;% predict(,newdata=df) %&gt;% as.data.frame()%&gt;%mutate(intercept=1,C3=df$C3)</span></pre><p id="824e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">总共制作了5个假人。然后，我们需要通过mutate向数据帧添加一个截距。</p><p id="8bb4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">相反，如果我们不想要截距，但仍然喜欢满秩转换，我们可以修改dummyVars函数中上述代码的公式参数。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="87cf" class="jt ju hi jp b fi jv jw l jx jy">df1=df %&gt;% dummyVars(~.-C3<strong class="jp hj">-1</strong>,data=., sep="_",fullRank=T) %&gt;% predict(,newdata=df) %&gt;% as.data.frame()%&gt;%mutate(C3=df$C3)</span></pre><p id="34b2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">公式中的“<strong class="io hj"> -1 </strong>”告诉R在变换过程中不考虑截距。结果，创建了6个假人。</p><p id="b913" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后一种方法是使用model.matrix。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="3ea2" class="jt ju hi jp b fi jv jw l jx jy">df1=as.data.frame(model.matrix(~C1+.-C3,df));df1<br/></span></pre><p id="0fa5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们不想拦截，你可以</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="9c4e" class="jt ju hi jp b fi jv jw l jx jy">as.data.frame(model.matrix(~C1+.-1-C3,df))</span></pre><p id="ef25" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">model.matrix的优点是转换总是满秩的(要么用一个截距创建5个虚拟对象，要么不用截距创建6个虚拟对象)。缺点是您不能定制那些新创建的虚拟变量的名称，并且您仍然会丢失您不想在输出中转换为虚拟变量的分类变量。此外，model.matrix的输出仍然需要转换回dataframe。</p><p id="c4c3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用管道，我们有</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="55ce" class="jt ju hi jp b fi jv jw l jx jy">df1=df %&gt;% model.matrix(~.-C3,.) %&gt;% as.data.frame()%&gt;%mutate(C3=df$C3)</span></pre><p id="0375" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">model.matrix中的第二个点(~。-C3。)来指示管道中的数据参数。</p><p id="84f6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">总而言之，这三种方法各有利弊。但是它们比其他情况下要方便得多。如果我们准备线性回归或glm，我们将使用model.matrix，而不用担心满秩或虚拟陷阱。在其他情况下，dummyVars可以一次快速处理包含许多分类变量的数据集(例如产品特性)，如果您只想对选定数量的分类变量进行伪编码，pivot_wider允许进行定制。</p></div></div>    
</body>
</html>