<html>
<head>
<title>Pro Tips For Designing Robust React Components Part II: Bundle Size</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计鲁棒React组件的专业技巧第二部分:线束尺寸</h1>
<blockquote>原文：<a href="https://medium.com/codex/pro-tips-for-designing-robust-react-components-part-ii-bundle-size-5c65556ae5a1?source=collection_archive---------23-----------------------#2021-08-09">https://medium.com/codex/pro-tips-for-designing-robust-react-components-part-ii-bundle-size-5c65556ae5a1?source=collection_archive---------23-----------------------#2021-08-09</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><figure class="ew ey ih ii ij ik es et paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="es et ig"><img src="../Images/eba415dc14df71822dc35c1ab7b7fa23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mf5BI9KzAyYr539mcdDlrA.jpeg"/></div></div><figcaption class="ir is eu es et it iu bd b be z dy translated">photo by<em class="iv">@ bobbin io 2112 via</em><a class="ae iw" href="https://www.twenty20.com/photos/36eb7b62-ed97-4f1a-8713-39163704ebbc/?utm_t20_channel=bl" rel="noopener ugc nofollow" target="_blank"><em class="iv">第220期</em> </a></figcaption></figure><p id="a48a" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">几周前，我分享了一些提高React应用程序性能的技巧。让我们看看如何改进另一个指标——捆绑包大小。</p><div class="jv jw fa fc jx jy"><a rel="noopener follow" target="_blank" href="/codex/pro-tips-for-designing-robust-react-components-c3eaf9cd7ae4"><div class="jz ab dx"><div class="ka ab kb cl cj kc"><h2 class="bd hk fj z dz kd eb ec ke ee eg hi bi translated">设计坚固React组件的专业技巧</h2><div class="kf l"><h3 class="bd b fj z dz kd eb ec ke ee eg dy translated">“如何让我的React应用程序更具响应性和可维护性？”</h3></div><div class="kg l"><p class="bd b fq z dz kd eb ec ke ee eg dy translated">medium.com</p></div></div><div class="kh l"><div class="ki l kj kk kl kh km ip jy"/></div></div></a></div><h1 id="0812" class="kn ko hj bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">为什么包的大小很重要？</h1><p id="41f2" class="pw-post-body-paragraph ix iy hj iz b ja ll jc jd je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju hc bi translated">因为当用户打开你的页面时，这会影响你的应用程序加载的速度。这是至关重要的，因为许多用户可能会通过不可靠的3G或无线连接进行连接，速度很慢，因此小的捆绑包大小是必不可少的，这样用户就不会离开你的网站。如果网页加载时间超过3秒，用户往往会离开网站。2秒的阈值是“危险区域”,大多数用户期望应用程序在这段时间内完全加载，如果没有，他们就会开始不耐烦。</p><p id="b869" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">当然，React应用程序加载与页面加载是不对称的——通常，您可以加载大量HTML和CSS，比React.js捆绑文件快得多。然而，加载时间仍然很重要，即使你有稍微长一点的时间来渲染应用程序。因此，虽然用户会原谅你花10秒来渲染应用程序，但60秒、45秒，甚至可能30秒就不能这么说了。</p><p id="6892" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">没有人期望你在2秒内完成一个React应用程序，但是如果你能做到，那么你的团队应该举办一个披萨和啤酒庆祝会。对于其他人，这里有一些缩小包大小的技巧。</p><h1 id="5d35" class="kn ko hj bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">把你的包裹分成小份</h1><p id="6b70" class="pw-post-body-paragraph ix iy hj iz b ja ll jc jd je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju hc bi translated">这是一项非常强大的技术，可以让应用程序加载更快，因为现在Webpack可以按需加载一堆更小的包，而不是一个大的包。因此，你可以将你的应用程序的仪表盘打包成一个可以立即加载的包，并延迟加载代表其他辅助页面的包。我想这就是脸书、Instagram和其他人用来保持他们的主要网站的加载时间可控的方法——这些网站是用React编写的。</p><p id="c162" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">从Webpack 4开始，拆分包是一个可用的特性。现在制作的应用程序可能不是使用Webpack 3或更低版本构建的，所以不必担心升级到稍微不兼容的版本。</p><h2 id="3c6f" class="lq ko hj bd kp lr ls lt kt lu lv lw kx ji lx ly lb jm lz ma lf jq mb mc lj md bi translated">代码分割是如何工作的？</h2><p id="cdb1" class="pw-post-body-paragraph ix iy hj iz b ja ll jc jd je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju hc bi translated">Webpack文档给了我们3种实现代码拆分的方法。第一个使用入口点，入口点使用Webpack配置中的<code class="dv me mf mg mh b">entry</code>配置行。这基本上意味着您想要分离的每个组件树在Webpack配置中引用的特定文件中都有一些祖先组件。整个树被捆绑成一个束。</p><p id="9ae7" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">这就是如何使用<code class="dv me mf mg mh b">entry</code>来定义Webpack需要制作的不同包:</p><figure class="mi mj mk ml fe ik"><div class="bz dz l di"><div class="mm mn l"/></div></figure><p id="707e" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">您必须为所有的包包含<code class="dv me mf mg mh b">dependOn: 'shared'</code>，然后列出您作为依赖项导入的任何外部库以及多个组件树使用的每个组件的文件名。否则，共享依赖项在两个包中都是重复的，违背了代码分割的目的。本例中的lodash依赖项将在每个没有共享依赖项的已创建包中占用超过500KB的空间。</p><p id="44f5" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">当然，将所有共享组件放在一个文件中通常是不可行的。无论您在<code class="dv me mf mg mh b">dependOn:</code>中写了什么，该指令都会在<code class="dv me mf mg mh b">entry</code>对象的正下方有一个键，比如本例中的<code class="dv me mf mg mh b">shared</code>，如果一个包有多个依赖项，那么它就是一个字符串数组。为不同的包创建多个<code class="dv me mf mg mh b">dependOn</code>名称允许您定义多个共享入口点，这些入口点的路径反映了您的React应用程序的结构。</p><h1 id="1415" class="kn ko hj bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">将内容的长列表重构为单独的XHR调用</h1><p id="084f" class="pw-post-body-paragraph ix iy hj iz b ja ll jc jd je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju hc bi translated">如果您的React应用程序中有任何长的文本字符串数组，这些可能会降低加载时间。尝试创建一个API端点来提供这些数据，然后在运行时使用<code class="dv me mf mg mh b">node-fetch</code>来检索这些数据，在请求完成时使用进度指示器作为占位符。您可以在加载额外的包之前使用代码分割来获取内容，这减少了用户与应用程序交互之前的呈现时间。</p><p id="cd94" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated"><a class="ae iw" href="https://github.com/bvaughn/react-window" rel="noopener ugc nofollow" target="_blank"> react-window </a>模块被设计成获取长的内容列表。然而，它还有一个额外的性能优化。它不是获取整个列表，而是只获取适合视窗的数量，然后发出一个DOM更新。如果出于某种原因，您的列表及其所有属性有几兆大，这将非常有用。有时候会这样。</p><p id="6832" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">此外，您可以设置您的API端点来预取请求，这将使服务器在您准备发出实际的API调用时缓存响应。在某些情况下，这可以加快获取长内容列表的时间。</p><h1 id="e6b9" class="kn ko hj bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">使用摇树</h1><p id="7519" class="pw-post-body-paragraph ix iy hj iz b ja ll jc jd je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju hc bi translated">树抖动是从捆绑包中消除死代码的过程。要做到这一点，您必须只从模块中导入您需要的函数(也就是说，不要全部导入)，并且您必须将<code class="dv me mf mg mh b">"sideEffects": false</code>放在package.json中与<code class="dv me mf mg mh b">name</code>属性相同的级别上。您也可以将其添加到Webpack配置文件中的<code class="dv me mf mg mh b">rules</code>属性对象下。</p><p id="31ca" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">副作用是任何模块，当导入时，除了从模块导入项目之外，还运行一些后台函数。Webpack希望确保从包中移除未使用的函数不会意外地阻止重要代码的运行。如果有这样的模块，您应该将它们的文件名作为字符串数组包含在<code class="dv me mf mg mh b">sideEffects</code>属性中，Webpack会将它们保存在包中。</p><p id="23a0" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">注意，要做到这一点，你必须在你的文件中使用<a class="ae iw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank"> ES2015导入语法</a>。</p><h1 id="6759" class="kn ko hj bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">使用服务人员</h1><p id="026e" class="pw-post-body-paragraph ix iy hj iz b ja ll jc jd je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju hc bi translated">适用于各种web apps，不反应app<em class="mo">本身</em>。</p><p id="8844" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">服务工作者是页面在后台部署的Javascript文件。它通过缓存“安装”事件侦听器中指定的所有文件来“安装”该文件。然后，它通过发送一个<code class="dv me mf mg mh b">window.postMessage()</code>调用与页面通信，其数据随后被网页上的“消息”事件监听器截获。</p><p id="e8bd" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">但是，服务人员如何知道与哪个页面进行通信呢？原来<code class="dv me mf mg mh b">postMessage()</code>还带有一个origin参数，告诉浏览器应该将消息广播到哪些页面。因此浏览器窗口中具有相同原点的选项卡都将接收到该消息。</p><p id="9c49" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">所以服务人员不会真的进行一对一的信息传递，除非只有一个匹配的页面。可以把它想象成一个发布-订阅通道，所有相同来源的打开页面都将从消息中获得数据。请记住，源是由主机名或域名、端口号和协议(HTTP或HTTPS)组成的元组。</p><p id="fd73" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">服务人员可以通过缓存安装时指定的文件，然后在“消息”有效负载中返回这些文件来打开页面，从而提高应用程序的性能。这些文件有效地缓存在浏览器中，因此应用程序可以使用这种方法来读取CSS文件、字体和HTML中定义的其他依赖项，如<code class="dv me mf mg mh b">&lt;script&gt;</code>标记。它不适合缓存包(使用Webpack服务器代替)，也没有指定来源，你在你的应用程序中创建了安全漏洞。</p><p id="687d" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">Google Developers 在他们的文档中有一些很棒的服务工作者事件的代码样本。他们还有一个<a class="ae iw" href="https://developers.google.com/web/ilt/pwa/introduction-to-service-worker" rel="noopener ugc nofollow" target="_blank">老教程</a>，解释服务人员如何工作。</p></div><div class="ab cl mp mq gq mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hc hd he hf hg"><p id="fc0c" class="pw-post-body-paragraph ix iy hj iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hc bi translated">我希望这篇文章对你寻求让你的应用反应更快有所帮助。如果你有任何其他的表演想法，请在下面的评论中告诉我。</p></div></div>    
</body>
</html>