<html>
<head>
<title>Why structs are better than protocols for dependency inversion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么结构比协议更适合依赖倒置</h1>
<blockquote>原文：<a href="https://medium.com/codex/why-structs-are-better-than-protocols-for-dependency-inversion-55f1ec3ef777?source=collection_archive---------0-----------------------#2022-09-19">https://medium.com/codex/why-structs-are-better-than-protocols-for-dependency-inversion-55f1ec3ef777?source=collection_archive---------0-----------------------#2022-09-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/b1fb27cfa0397a044f87abacdb2b233e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ofTWt4K4-J3fMpOnnLV9LQ.jpeg"/></div></div></figure><div class=""/><p id="e02c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们想到Swift中的依赖性反转时，通常首先想到的是协议。众所周知的模式是创建一个协议来定义一些必需的行为，并创建一个具体的实现来执行该职责。</p><p id="85fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这在测试我们的代码时变得非常有价值，因为我们可以用依赖关系来代替模拟版本，这些版本可以用期望的响应来启动，并查询预期的结果。</p><p id="66c4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然这种模式在大多数情况下已经足够了，但结构通常可以提供协议无法提供的优势。</p><h1 id="377c" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">协议失败的地方…</h1><h2 id="0685" class="km jp ht bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated"><strong class="ak">名称-间距</strong></h2><p id="30e9" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">协议的一个主要缺点是它们不能嵌套其他类型。想象以下片段:</p><figure class="lf lg lh li fd hk"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="e506" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们试图为我们的<code class="du ll lm ln lo b">House</code>定义一个协议，我们也需要为<code class="du ll lm ln lo b">Inhabitant</code>定义一个协议，就像这样:</p><figure class="lf lg lh li fd hk"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="0491" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">烦人的是，<code class="du ll lm ln lo b">Inhabiting</code>协议不能嵌套在<code class="du ll lm ln lo b">Housing</code>里面，所以污染了全局命名空间。随着时间的推移，这可能会导致冲突和兑现，尤其是在大型代码库中。</p><h2 id="00e2" class="km jp ht bd jq kn ko kp ju kq kr ks jy jb kt ku kc jf kv kw kg jj kx ky kk kz bi translated"><strong class="ak">异质阵列</strong></h2><p id="a35b" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">假设我们的消费类型需要一系列的房子。通过下面的代码片段，我们遇到了臭名昭著的<code class="du ll lm ln lo b">Protocol ‘Housing’ can only be used as a generic constraint because it has Self or associated type requirements</code>错误。</p><figure class="lf lg lh li fd hk"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="a1a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们有两个选择。第一个是使<code class="du ll lm ln lo b">Street</code>通用，就像这样:</p><figure class="lf lg lh li fd hk"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="ebd5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，这里的问题是，现在我们被束缚在一种特定类型的住房上。在我们的街道上，我们可能有多种类型的房子，如平房和大厦，所以这可能不总是我们想要的。</p><p id="7768" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一个解决方案是以类似于<code class="du ll lm ln lo b">AnyHashable</code>或<code class="du ll lm ln lo b">AnyPublisher</code>的方式创建一个类型擦除包装器。这里我们可以创建删除类型的<code class="du ll lm ln lo b">AnyHousing</code>，就像这样:</p><figure class="lf lg lh li fd hk"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="d135" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是哦不！在这里，我们可以看到，我们已经将自己与每栋房子的一种特定类型的居民联系起来了！为了完全实现类型擦除，我们还需要一个<code class="du ll lm ln lo b">AnyInhabiting</code>类型。最终结果如下:</p><figure class="lf lg lh li fd hk"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="618a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这相当冗长，如果我们仔细观察，<code class="du ll lm ln lo b">AnyInhabiting</code>和<code class="du ll lm ln lo b">AnyHousing</code>的实现与我们开始时的<code class="du ll lm ln lo b">Inhabitant</code>和<code class="du ll lm ln lo b">House</code>非常相似！</p><h1 id="f705" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用结构的技巧…</h1><p id="ec9e" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们如何使用结构来执行与协议相同的功能的答案是保持它们的简单性！我们可以以这样一种方式编写结构，它只保存消费类型所需的数据和功能。我们可以编写一个适配器来将任何对象映射到我们的结构，而不是遵循一个协议。</p><p id="9531" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设跟随<code class="du ll lm ln lo b">ViewModel</code>。它允许我们在初始化时定义文本和<code class="du ll lm ln lo b">buttonTapped</code>功能。</p><figure class="lf lg lh li fd hk"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="58b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们现在可以在一个扩展中添加一个便利的初始化器来映射我们需要调用的服务。</p><figure class="lf lg lh li fd hk"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="93d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当测试我们的UI层时，不需要创建一个对象并遵循一个协议。我们可以简单地在初始化时提供测试功能和文本。</p><h1 id="f45e" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="acad" class="pw-post-body-paragraph iq ir ht is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们现在已经看到了协议的替代方案，它执行相同的功能，保持相同级别的可测试性，并简化冗长的样板代码。似乎好得难以置信，对吗？</p><p id="2ef0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我看到的一个警告是，需要对初始结构应用一些规则，使其保持为纯数据对象(Kotlin风格的数据类在这里是理想的)。</p><p id="4915" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我发现在大多数情况下，与协议相比，这种模式更简洁，也不那么冗长，所以我在日常工作中继续使用它</p><p id="f0ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了完整起见，<a class="ae lp" href="https://gist.github.com/oconnelltoby/af160f5efe7b00c5d33887be280d2855" rel="noopener ugc nofollow" target="_blank">这里有一个要点</a>，它以同样的方式延续了众议院的例子！</p></div></div>    
</body>
</html>