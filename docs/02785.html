<html>
<head>
<title>SQL unit testing with Redgate and tSQLt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redgate和tSQLt进行SQL单元测试</h1>
<blockquote>原文：<a href="https://medium.com/codex/sql-unit-testing-with-redgate-and-tsqlt-329917829f42?source=collection_archive---------10-----------------------#2021-08-05">https://medium.com/codex/sql-unit-testing-with-redgate-and-tsqlt-329917829f42?source=collection_archive---------10-----------------------#2021-08-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/09ea09c83f15d35da5ac669744702be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFyq7oP7-kyaXCjsyYV-8g.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">来自<a class="ae hv" href="https://openclipart.org/detail/227338/beaker-vaso-de-precipitado-bequer-becher" rel="noopener ugc nofollow" target="_blank">的阿历克斯·戈加</a>的剪贴画</figcaption></figure><div class=""/><p id="0463" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我和我的团队处理一个令人毛骨悚然的逻辑时，我们经常发现为相关代码编写单元测试很有用。这有助于我们定义和记录我们的期望，减轻手动测试的负担，并让我们安心，新的代码更改不会破坏我们目前所拥有的。直到最近，我还用C#、JavaScript、Java和Delphi做过单元测试，但从未用SQL做过。</p><p id="b916" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Redgate是一家提供各种产品的公司，这些产品使数据库的各方面工作变得更加容易。他们的产品之一，<a class="ae hv" href="https://www.red-gate.com/products/sql-development/sql-test/" rel="noopener ugc nofollow" target="_blank"> SQL Test </a>，允许开发者用T-SQL做单元测试。它基于开源的tSQLt框架，也是我们在SQL Server中对存储过程进行单元测试时所使用的。</p><h1 id="1824" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">设置</h1><h2 id="7abf" class="kr ju hy bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">正在安装SQL测试</h2><p id="1041" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">我们将SQL Test作为<a class="ae hv" href="https://www.red-gate.com/products/sql-development/sql-toolbelt/" rel="noopener ugc nofollow" target="_blank"> SQL Toolbelt </a>的一部分安装，尽管看起来它也可以作为一个独立的产品使用。你可以开始28天的免费试用，但要知道Redgate并不便宜。</p><h2 id="4a83" class="kr ju hy bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">安装tSQLt框架</h2><p id="4921" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">要将tSQLt安装到数据库上，请启动SQL Server Management Studio (SSMS ),然后单击SQL Toolbelt中的SQL Test按钮。如果您还没有任何正在测试的数据库，这将显示一个空列表。单击“添加数据库…”按钮，提示您选择一个数据库。选择一个数据库，然后单击“添加数据库”。这将显示以下对话:</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es lk"><img src="../Images/7d161d9dc98238c85498e3b103ce07cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*1edL2s-mDt7e1dzBrDA1rQ.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">安装tSQLt框架</figcaption></figure><p id="76f3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先注意SQL Test警告它将对数据库进行的更改。不幸的是，这些变化是安装框架所必需的。我建议使用数据库的开发副本，这样就不会影响到其他环境。</p><p id="fdb7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其次，注意您可以选择添加<a class="ae hv" href="https://github.com/red-gate/SQLCop/" rel="noopener ugc nofollow" target="_blank"> SQL Cop </a>静态分析测试。这是一组预制的测试，根据一组标准检查您的数据库，例如，所有的表都有主键，所有出现的<code class="du lp lq lr ls b">VARCHAR</code>类型都有指定的大小。这些测试被添加到它们自己的模式中，即<code class="du lp lq lr ls b">SQLCop</code>。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es lt"><img src="../Images/e21cba72eb1cc8cda95f3b39ef1cac72.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*4ZVTTlz_leCuo29MBdi3gg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">SQL Cop测试运行的示例</figcaption></figure><p id="0836" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果我在数据库上运行SQL Cop测试，那么“没有任何数据的表”测试就会失败。单击失败的测试会在右边的窗格中显示测试输出，在我的例子中会写出空表的名称:</p><pre class="ll lm ln lo fd lu ls lv lw aw lx bi"><span id="09d7" class="kr ju hy ls b fi ly lz l ma mb">Test Procedure: [SonicTheHedgehog].[SQLCop].[test Tables without any data] on STEPHENB-LT02<br/>[SQLCop].[test Tables without any data] failed: (Failure)<br/>Empty tables in your database:</span><span id="d1cc" class="kr ju hy ls b fi mc lz l ma mb">[sth].[Character]<br/>[sth].[GameCharacters]<br/>[sth].[Zone]</span></pre><p id="14b6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不管您是否安装了SQL Cop，您都会看到在模式<code class="du lp lq lr ls b">tSQLt</code>下创建的对象。这些对象将由测试框架隐式使用，或者由您在编写单元测试时显式使用。</p><h1 id="2856" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">创建单元测试</h1><p id="d18d" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">单击“New test…”按钮(带有大加号图标的按钮)会弹出下面的窗口，提示您输入测试名称和测试类。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es md"><img src="../Images/472eb264bf11f3836a1e2fdc50231531.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*3f2rDZHxtG5nIJUdSWJPpw.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">创建新测试</figcaption></figure><p id="7762" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">测试名称将用作测试所基于的存储过程的名称(前缀为单词“test”和一个空格)。test类将确定底层模式的名称，并用于在UI中对测试进行分组。</p><p id="f96c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦您创建了一个新的测试，您就会看到一个SQL脚本，它改变了您新创建的测试过程。该模板遵循流行的<a class="ae hv" href="https://automationpanda.com/2020/07/07/arrange-act-assert-a-pattern-for-writing-good-tests/" rel="noopener ugc nofollow" target="_blank">Arrange–Act–Assert</a>模式(尽管术语“组装”被用来代替“排列”)。</p><ol class=""><li id="ee4d" class="me mf hy ix b iy iz jc jd jg mg jk mh jo mi js mj mk ml mm bi translated"><strong class="ix hz">安排/组装:</strong>为你正在测试的代码设置先决条件。这可能包括伪造一个表格(更多内容见下文)和插入一些数据。</li><li id="032a" class="me mf hy ix b iy mn jc mo jg mp jk mq jo mr js mj mk ml mm bi translated"><strong class="ix hz"> Act: </strong>运行被测代码。这可能是执行存储过程或调用函数。</li><li id="c81a" class="me mf hy ix b iy mn jc mo jg mp jk mq jo mr js mj mk ml mm bi translated"><strong class="ix hz">断言:</strong>检查运行代码的实际结果，并将它们与预期结果进行比较。为此，tSQLt提供了许多断言函数。</li></ol><p id="5ad6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种结构促使你仔细考虑测试的前提条件、主题和后置条件。从现在开始，对测试进行更改意味着对这个存储过程进行修改。</p><h2 id="5b37" class="kr ju hy bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">可重新运行的测试</h2><p id="2213" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">SQL Test在执行后自动回滚的事务中运行每个单元测试。这意味着测试可以重复运行并且行为一致，但也意味着您的测试代码不会对您的数据进行持久的更改。</p><h2 id="edc9" class="kr ju hy bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">伪造数据库对象</h2><p id="55fb" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">编写单元测试的一个常见挑战是隔离依赖关系。我们希望我们的测试代码关注被测试的功能。我们还希望我们的测试是健壮的，也就是说，我们不希望它们因为系统的无关部分的改变而失败。</p><p id="6e28" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在像Java和C#这样的编程语言中，这个问题通常通过模仿或存根接口来解决。tSQLt框架提供了帮助“伪造”表或函数的实用程序。</p><p id="ecca" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae hv" href="https://tsqlt.org/user-guide/isolating-dependencies/faketable/" rel="noopener ugc nofollow" target="_blank"> FakeTable </a>的情况下，给定的表被替换为一个空表，该空表是原始表的逐列副本。然而，这个副本没有复制任何约束，这意味着在设置前提条件时，您不必担心关系数据。例如，下表存储了出现在每个刺猬索尼克游戏中的<a class="ae hv" href="https://sonic.fandom.com/wiki/Zone" rel="noopener ugc nofollow" target="_blank">区域</a>:</p><pre class="ll lm ln lo fd lu ls lv lw aw lx bi"><span id="dcda" class="kr ju hy ls b fi ly lz l ma mb">CREATE TABLE sth.GameZone<br/>(<br/>  Id INT NOT NULL,<br/>  ZoneName VARCHAR(50) NOT NULL,<br/>  Acts INT NOT NULL DEFAULT 2,<br/>  GameId INT NOT NULL,<br/>  PRIMARY KEY (Id),<br/>  FOREIGN KEY (GameId) REFERENCES sth.Game (Id)<br/>)</span></pre><p id="79ba" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于<code class="du lp lq lr ls b">sth.Game</code>的外键，在我们可以将行插入到<code class="du lp lq lr ls b">sth.GameZone</code>之前，我们首先需要将相关数据插入到<code class="du lp lq lr ls b">sth.GameZone</code>表中。在正常情况下，这是一件好事，但在这里，它只会增加我们的测试代码。因此，我们称它为FakeTable:</p><pre class="ll lm ln lo fd lu ls lv lw aw lx bi"><span id="788a" class="kr ju hy ls b fi ly lz l ma mb">EXEC tSQLt.FakeTable @TableName = 'sth.GameZone'</span></pre><p id="c832" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在内部，这将重命名原始表，并在测试期间在其位置创建一个假表。现在我们可以插入到<code class="du lp lq lr ls b">sth.GameZone</code>中，而不用担心外键或任何其他约束——我们所关心的是它如何影响被测代码。</p><p id="30c8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有关更多信息，请参见tSQLt文档中的<a class="ae hv" href="https://tsqlt.org/user-guide/isolating-dependencies/" rel="noopener ugc nofollow" target="_blank">隔离依赖关系</a>部分。</p><h2 id="7741" class="kr ju hy bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">坚持期望</h2><p id="5557" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">tSQLt框架为断言代码的预期结果提供了几个助手过程。这些包括比较两个标量值的简单断言，例如<code class="du lp lq lr ls b">AssertEquals</code>和<code class="du lp lq lr ls b">AssertLike</code>。不出所料，只要不满足条件，这些过程就会使您的测试失败。</p><p id="71da" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有一些表格级别的断言也非常有用——在这些断言中，我们发现<code class="du lp lq lr ls b">AssertEqualsTable</code>特别强大。该过程比较每个表中的所有行，允许您非常精确地指定数据的“之前”和“之后”状态。当表内容不同时，测试生成如下输出:</p><pre class="ll lm ln lo fd lu ls lv lw aw lx bi"><span id="37ee" class="kr ju hy ls b fi ly lz l ma mb">|_m_|Id|Name                |Released               |PlatformId|<br/>+---+--+--------------------+-----------------------+----------+<br/>|&lt;  |3 |Sonic &amp; Knuckles    |1994-10-18 00:00:00.000|1         |<br/>|=  |1 |Sonic the Hedgehog  |1991-06-23 00:00:00.000|1         |<br/>|=  |2 |Sonic the Hedgehog 2|1992-11-21 00:00:00.000|1         |<br/>|&gt;  |3 |Sonic the Hedgehog 3|1994-05-27 00:00:00.000|1         |</span></pre><p id="e3ea" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，这个文本表使用了比较表中的列和值，并添加了<code class="du lp lq lr ls b">_m_</code>列。这里，<code class="du lp lq lr ls b">=</code>(等于)用于标记完全匹配的行。<code class="du lp lq lr ls b">&lt;</code>(小于)符号表示出现在预期表中但不在实际表中的行，而<code class="du lp lq lr ls b">&gt;</code>(大于)表示相反的情况。</p><p id="a822" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的例子中，缺少“Sonic &amp; Knuckles”行，因为它包含在预期的结果集中，但在实际的表中却没有。另一方面,“刺猬索尼克3”的行是意外的，因为它出现在实际的表中，尽管不存在于预期的表中。</p><p id="9ec6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于使用<code class="du lp lq lr ls b">AssertEqualsTable</code>的更多信息，参见<a class="ae hv" href="https://tsqlt.org/user-guide/assertions/assertequalstable/" rel="noopener ugc nofollow" target="_blank">本页</a>。</p><h2 id="d423" class="kr ju hy bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">奖励:断言错误</h2><p id="5aee" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">我想测试在某些情况下我的过程会抛出一个异常(即它调用了<code class="du lp lq lr ls b">RAISERROR</code>)。我并不清楚如何使用<a class="ae hv" href="https://tsqlt.org/user-guide/expectations/expectexception/" rel="noopener ugc nofollow" target="_blank"> ExpectException </a>，因为任何异常都会自动使我的测试失败，不管它是否是预期的。</p><p id="35ca" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我发现解决方案是在一个<code class="du lp lq lr ls b">try…catch</code>块中调用我的过程和断言，例如</p><pre class="ll lm ln lo fd lu ls lv lw aw lx bi"><span id="0288" class="kr ju hy ls b fi ly lz l ma mb">CREATE PROCEDURE MyTests.[test ExpectException]<br/>AS<br/>BEGIN<br/>  BEGIN TRY<br/>    -- Call the proc that raises the error<br/>    EXEC endTheWorld<br/><br/>    -- Tell tSQLt to expect the exception<br/>    EXEC tSQLt.ExpectException @ExpectedMessage = 'The apocalypse is here', @ExpectedSeverity = NULL, @ExpectedState = NULL;<br/>  END TRY<br/>  BEGIN CATCH<br/>    -- No need to do anything here<br/>  END CATCH<br/>END;</span></pre><h1 id="9102" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">简单的例子</h1><p id="e938" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">继续我之前的刺猬索尼克的例子，让我们假设我的数据库具有如下所示的模式:</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ms"><img src="../Images/fa5c2cd12cd72794d52f9625687793be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgB92eCqVntS-C1vQ3rTeQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">刺猬索尼克示例数据库的模式</figcaption></figure><p id="b3b6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我有一个存储过程<code class="du lp lq lr ls b">FixZoneName</code>，它会在区域名称的末尾添加单词“Zone ”(如果它还不存在的话)。下面是单元测试的一个示例:</p><figure class="ll lm ln lo fd hk"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="2a46" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该测试执行以下操作:</p><ol class=""><li id="d3fe" class="me mf hy ix b iy iz jc jd jg mg jk mh jo mi js mj mk ml mm bi translated">伪造<code class="du lp lq lr ls b">GameZone</code>表，这样我们就不必处理对<code class="du lp lq lr ls b">Game</code>和<code class="du lp lq lr ls b">Platform</code>表的依赖。</li><li id="59e2" class="me mf hy ix b iy mn jc mo jg mp jk mq jo mr js mj mk ml mm bi translated">将测试数据插入假<code class="du lp lq lr ls b">GameZone</code>表。</li><li id="f800" class="me mf hy ix b iy mn jc mo jg mp jk mq jo mr js mj mk ml mm bi translated">执行被测程序，即<code class="du lp lq lr ls b">FixZoneName</code>。</li><li id="bec1" class="me mf hy ix b iy mn jc mo jg mp jk mq jo mr js mj mk ml mm bi translated">查询<code class="du lp lq lr ls b">GameZone</code>的内容，并使用<code class="du lp lq lr ls b">AssertEqualsString</code>确认记录按预期更新。</li></ol><p id="1101" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这有点简单，但是它演示了一个测试的基本结构。</p><h1 id="342b" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">代码覆盖率</h1><p id="1f19" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">当您在SQL Test中运行测试时，您会发现除了测试输出之外，它还提供了一个关于代码覆盖率的报告，例如</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es mv"><img src="../Images/0f6e2c9d6df4cf3e0a677cbd9bf35b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*r0OFtDxleWK0ZV8bJcWMdg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">SQL测试中的代码覆盖率</figcaption></figure><p id="cbb2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个报告的一个漂亮的特性是过程名是可点击的。这样做可以向下滚动到该过程的代码，其中SQL Test突出显示了测试所覆盖的语句。</p><figure class="ll lm ln lo fd hk er es paragraph-image"><div class="er es mw"><img src="../Images/0bd83e81d759a8830bf790debefb469a.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*ZnVJNSKu1RWuZVgGNAgTBA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">FixZoneName中包含的语句</figcaption></figure><h1 id="1510" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">解决纷争</h1><p id="f3ae" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">我发现在某些数据库上，我的测试无法运行。相反，它们在<code class="du lp lq lr ls b">System.Data.SqlClient.SqlException</code>上失败，并显示如下错误消息:</p><pre class="ll lm ln lo fd lu ls lv lw aw lx bi"><span id="11d1" class="kr ju hy ls b fi ly lz l ma mb">Cannot access CLR. Assembly might be in an invalid state. Try running EXEC tSQLt.EnableExternalAccess @enable = 0; or reinstalling tSQLt.</span></pre><p id="e155" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的例子中，这条消息建议的SQL命令不起作用。然而，我在这篇<a class="ae hv" href="https://www.red-gate.com/simple-talk/databases/sql-server/tools-sql-server/ten-things-i-wish-id-known-when-i-started-using-tsqlt-and-sql-test/" rel="noopener ugc nofollow" target="_blank">有用的文章</a>中找到了一个补救方法。除了给出一些方便的技巧之外，作者还建议通过将数据库所有者改为<code class="du lp lq lr ls b">sa</code>来解决这个问题。</p><pre class="ll lm ln lo fd lu ls lv lw aw lx bi"><span id="0ce8" class="kr ju hy ls b fi ly lz l ma mb">ALTER AUTHORIZATION ON DATABASE::tSQLt_Example TO sa</span></pre><h1 id="9da1" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">版本化您的测试</h1><p id="26d5" class="pw-post-body-paragraph iv iw hy ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">由于单元测试构成了数据库模式的一部分，如果您使用SQL源代码控制(SOC)或SQL变更自动化(SCA)，您的测试将被自动覆盖。测试模式和过程的处理方式与数据库中的任何其他对象相同。</p><p id="d011" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在没有模式版本控制系统的情况下，另一个选择是为每个测试保存创建脚本。这可能对一个小项目有用，但是如果您的数据库很大/很复杂，您可能会发现这种方法很快就变得很麻烦。但是，如果您想尝试这种方法，请注意创建tSQLt测试模式与创建普通模式是不同的，例如</p><pre class="ll lm ln lo fd lu ls lv lw aw lx bi"><span id="3d51" class="kr ju hy ls b fi ly lz l ma mb">EXEC tSQLt.NewTestClass 'UnitTests';</span></pre><p id="cff6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是因为tSQLt需要将模式标记为测试类。感谢我的同事<a class="ae hv" href="https://www.linkedin.com/in/teshvier-mathura-810aa1170/" rel="noopener ugc nofollow" target="_blank">特什维尔</a>帮助揭开了这个秘密。</p></div><div class="ab cl mx my gp mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hb hc hd he hf"><p id="9290" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文介绍了使用Redgate和tSQLt框架进行SQL单元测试的基础知识。单元测试是一种非常有用的技术，看到我们能够在数据库层面上直接应用这种技术是令人兴奋的。</p><h2 id="2e9a" class="kr ju hy bd jv ks kt ku jz kv kw kx kd jg ky kz kh jk la lb kl jo lc ld kp le bi translated">用于本文</h2><ul class=""><li id="81da" class="me mf hy ix b iy lf jc lg jg ne jk nf jo ng js nh mk ml mm bi translated">SQL Server Management Studio 18 . 9 . 1</li><li id="b78d" class="me mf hy ix b iy mn jc mo jg mp jk mq jo mr js nh mk ml mm bi translated">SQL Server 15.0.2000.5 (2019)</li><li id="136c" class="me mf hy ix b iy mn jc mo jg mp jk mq jo mr js nh mk ml mm bi translated">SQL测试</li></ul></div></div>    
</body>
</html>