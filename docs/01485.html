<html>
<head>
<title>Styling CodeMirror v6 with Material UI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用材质UI设计CodeMirror v6的样式</h1>
<blockquote>原文：<a href="https://medium.com/codex/styling-codemirror-v6-with-material-ui-f3a7a3f765b1?source=collection_archive---------3-----------------------#2021-05-05">https://medium.com/codex/styling-codemirror-v6-with-material-ui-f3a7a3f765b1?source=collection_archive---------3-----------------------#2021-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0279" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">创造统一的风格和调色板</h2></div><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="jc jd l"/></div></figure><p id="20da" class="pw-post-body-paragraph je jf hi jg b jh ji ij jj jk jl im jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在上一篇文章中，我用react组件包装了CodeMirror v6。然而，当它应该看起来像一个代码编辑器时，它看起来仍然像一个普通的<code class="du kb kc kd ke b">&lt;textarea&gt;</code>。</p><p id="8fcd" class="pw-post-body-paragraph je jf hi jg b jh ji ij jj jk jl im jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">CodeMirror的<a class="ae ka" href="https://github.com/codemirror/basic-setup/blob/main/src/basic-setup.ts" rel="noopener ugc nofollow" target="_blank">基础设置</a>有杂货店价值的扩展，可以开始使用成熟的代码编辑器。我有一个更简单的目标，所以我挑选了两个我认为适用于我的用例的扩展:</p><ul class=""><li id="ef30" class="kf kg hi jg b jh ji jk jl jn kh jr ki jv kj jz kk kl km kn bi translated">@codemirror/highlight</li><li id="9358" class="kf kg hi jg b jh ko jk kp jn kq jr kr jv ks jz kk kl km kn bi translated">@codemirror/matchbrackets</li></ul><p id="967e" class="pw-post-body-paragraph je jf hi jg b jh ji ij jj jk jl im jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">CodeMirror本身与代码语法无关，需要一组规则来标记代码段。幸运的是，<code class="du kb kc kd ke b"><a class="ae ka" href="https://github.com/codemirror/lang-javascript#user-content-javascript" rel="noopener ugc nofollow" target="_blank">@codemirror/lang-javascrip</a>t</code>扩展包含了标记JavaScript/JSX和TypeScript/TSX的规则。</p><pre class="ix iy iz ja fd kt ke ku kv aw kw bi"><span id="b50f" class="kx ky hi ke b fi kz la l lb lc">npm i \<br/>@codemirror/highlight \<br/>@codemirror/matchbrackets \<br/>@codemirror/lang-javascript</span></pre><p id="3756" class="pw-post-body-paragraph je jf hi jg b jh ji ij jj jk jl im jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">我创建了一个新文件<code class="du kb kc kd ke b">~/components/editor/extensions.ts</code>并导入相关的扩展名。大多数扩展将是函数调用的返回值。有些，像<code class="du kb kc kd ke b">defaultHighlightStyle.fallback</code>，会是值。</p><pre class="ix iy iz ja fd kt ke ku kv aw kw bi"><span id="5004" class="kx ky hi ke b fi kz la l lb lc"><em class="ld">import </em>{ <em class="ld">javascript </em>} <em class="ld">from </em>"@codemirror/lang-javascript";<br/><em class="ld">import </em>{ defaultHighlightStyle } <em class="ld">from </em>"@codemirror/highlight";<br/><em class="ld">import </em>{ <em class="ld">bracketMatching </em>} <em class="ld">from </em>"@codemirror/matchbrackets";<br/><br/><em class="ld">export const </em>extensions = [<br/>  <em class="ld">bracketMatching</em>(),<br/>  defaultHighlightStyle.fallback,<br/>  <em class="ld">javascript</em>(),<br/>];</span></pre><p id="fd83" class="pw-post-body-paragraph je jf hi jg b jh ji ij jj jk jl im jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">然后可以用扩展更新<code class="du kb kc kd ke b">~/components/editor/index.ts</code>中的<code class="du kb kc kd ke b">EditorState.create</code>配置对象。</p><pre class="ix iy iz ja fd kt ke ku kv aw kw bi"><span id="3ffd" class="kx ky hi ke b fi kz la l lb lc"><em class="ld">import </em>{ extensions } <em class="ld">from </em>"./extensions";</span><span id="86ba" class="kx ky hi ke b fi le la l lb lc">/* ... */</span><span id="2635" class="kx ky hi ke b fi le la l lb lc"><em class="ld">const </em>state = EditorState.<em class="ld">create</em>({<br/>  doc: "console.log('hello there')",<br/>  extensions,<br/>});</span><span id="70b1" class="kx ky hi ke b fi le la l lb lc">/* ... */</span></pre><p id="4a98" class="pw-post-body-paragraph je jf hi jg b jh ji ij jj jk jl im jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">回到网站，曾经枯燥的文本框现在看起来像一个代码编辑器。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lf"><img src="../Images/67041e20735e424c2bdb0614089edc00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y4218fyPOZZX2qFSv44_uA.png"/></div></div></figure><h1 id="5872" class="lm ky hi bd ln lo lp lq lr ls lt lu lv io lw ip lx ir ly is lz iu ma iv mb mc bi translated">链接到材质用户界面</h1><p id="c805" class="pw-post-body-paragraph je jf hi jg b jh md ij jj jk me im jm jn mf jp jq jr mg jt ju jv mh jx jy jz hb bi translated">站点和代码编辑器有一个统一的调色板似乎是一个合理的要求。<a class="ae ka" href="https://next.material-ui.com/customization/default-theme/#main-content" rel="noopener ugc nofollow" target="_blank">材质UI的主题有很多颜色，我可以从</a>中挑选。</p><p id="13a9" class="pw-post-body-paragraph je jf hi jg b jh ji ij jj jk jl im jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><a class="ae ka" href="https://codemirror.net/6/examples/styling/#highlighting" rel="noopener ugc nofollow" target="_blank"> CodeMirror 6有一个修改高亮样式的简单方法。</a></p><pre class="ix iy iz ja fd kt ke ku kv aw kw bi"><span id="f080" class="kx ky hi ke b fi kz la l lb lc">import {tags, HighlightStyle} from "@codemirror/highlight"<br/><br/>const myHighlightStyle = HighlightStyle.define([<br/>  {tag: tags.keyword, color: "#fc6"},<br/>  {tag: tags.comment, color: "#f5d", fontStyle: "italic"}<br/>])</span></pre><p id="9042" class="pw-post-body-paragraph je jf hi jg b jh ji ij jj jk jl im jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在<code class="du kb kc kd ke b">@codemirror/lang-javascript</code>中，我可以看到哪些标签在使用。通过一些正则表达式的魔法，我能够将标签重新排列成一个<code class="du kb kc kd ke b">Map</code>。虽然很乏味，但我需要给每个标签映射一种颜色。</p><pre class="ix iy iz ja fd kt ke ku kv aw kw bi"><span id="0492" class="kx ky hi ke b fi kz la l lb lc">/* Note: In this case using a `Map` was not the best choice */</span><span id="5d44" class="kx ky hi ke b fi le la l lb lc">const tagColorMap = new Map&lt;Tag, Omit&lt;TagStyle, "tag"&gt;&gt;([<br/>  [tags.angleBracket, { color: theme.palette.primary.light }],<br/>  /* ... */<br/>])</span></pre><p id="3a22" class="pw-post-body-paragraph je jf hi jg b jh ji ij jj jk jl im jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">回想起来，我会选择更好的组织方式。也许，将键作为样式对象，值作为与该样式匹配的标签的<code class="du kb kc kd ke b">Array</code>。</p><p id="6700" class="pw-post-body-paragraph je jf hi jg b jh ji ij jj jk jl im jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">我需要将<code class="du kb kc kd ke b">tagColorMap</code>转换成<code class="du kb kc kd ke b">HighlightStyle.define</code>需要的<code class="du kb kc kd ke b">TagStyle</code>对象的数组。</p><pre class="ix iy iz ja fd kt ke ku kv aw kw bi"><span id="b8a0" class="kx ky hi ke b fi kz la l lb lc">const specs = Array.from(tagColorMap.entries()).map(([tag, style]) =&gt; ({<br/>  tag,<br/>  ...style,<br/>}))</span><span id="6dec" class="kx ky hi ke b fi le la l lb lc"><em class="ld">export const </em>highlightStyle = HighlightStyle.<em class="ld">define</em>(specs)</span></pre><p id="add5" class="pw-post-body-paragraph je jf hi jg b jh ji ij jj jk jl im jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在<code class="du kb kc kd ke b">~/components/editor/extensions.ts</code>中，我将导入<code class="du kb kc kd ke b">highlightStyle</code>并将其添加到导出的扩展中。</p><pre class="ix iy iz ja fd kt ke ku kv aw kw bi"><span id="a861" class="kx ky hi ke b fi kz la l lb lc"><em class="ld">import </em>{ highlightStyle } <em class="ld">from </em>"./highlight-style";</span><span id="f396" class="kx ky hi ke b fi le la l lb lc">/* ... */</span><span id="7165" class="kx ky hi ke b fi le la l lb lc"><em class="ld">export const </em>extensions = [<br/>  highlightStyle,<br/>  /* ... */<br/>];</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mi"><img src="../Images/9689b492700efcd3395fa25bfa92dad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnHkWMi6pGe-wtzkPIdeiQ.png"/></div></div></figure><h1 id="6103" class="lm ky hi bd ln lo lp lq lr ls lt lu lv io lw ip lx ir ly is lz iu ma iv mb mc bi translated">换行和装订线编号</h1><p id="b931" class="pw-post-body-paragraph je jf hi jg b jh md ij jj jk me im jm jn mf jp jq jr mg jt ju jv mh jx jy jz hb bi translated">我注意到长长的队伍将输出框推离了屏幕。为了启用换行，需要将<code class="du kb kc kd ke b">EditorView.linewrapping</code>添加到<code class="du kb kc kd ke b">extensions</code>中。</p><p id="6dd8" class="pw-post-body-paragraph je jf hi jg b jh ji ij jj jk jl im jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">本来觉得阴沟编号会不好看，后来改了主意。所需要的就是<code class="du kb kc kd ke b">@codemirror/gutter</code>库。</p><pre class="ix iy iz ja fd kt ke ku kv aw kw bi"><span id="feaa" class="kx ky hi ke b fi kz la l lb lc">// ~/components/editor/extensions.ts</span><span id="7541" class="kx ky hi ke b fi le la l lb lc"><em class="ld">import </em>{ EditorView } <em class="ld">from </em>"@codemirror/view";<br/><em class="ld">import </em>{ <em class="ld">lineNumbers </em>} <em class="ld">from </em>"@codemirror/gutter";</span><span id="098e" class="kx ky hi ke b fi le la l lb lc"><em class="ld">/* ... */</em></span><span id="ce93" class="kx ky hi ke b fi le la l lb lc"><em class="ld">export const </em>extensions = [<br/>  EditorView.<em class="ld">lineWrapping</em><br/>  <em class="ld">lineNumbers</em>(),<br/>  <em class="ld">/* ... */<br/></em>];</span></pre><h1 id="7c74" class="lm ky hi bd ln lo lp lq lr ls lt lu lv io lw ip lx ir ly is lz iu ma iv mb mc bi translated">打开黑暗模式</h1><p id="623c" class="pw-post-body-paragraph je jf hi jg b jh md ij jj jk me im jm jn mf jp jq jr mg jt ju jv mh jx jy jz hb bi translated">使用<code class="du kb kc kd ke b">EditorView.theme</code>并将第二个对象设置为<code class="du kb kc kd ke b">{ dark: true }</code>，将启用与深色主题的兼容性。最明显的是，装订线编号和光标变亮了。</p><pre class="ix iy iz ja fd kt ke ku kv aw kw bi"><span id="13cd" class="kx ky hi ke b fi kz la l lb lc">// ~/components/editor/extensions.ts</span><span id="a9c4" class="kx ky hi ke b fi le la l lb lc"><em class="ld">/* ... */</em></span><span id="7632" class="kx ky hi ke b fi le la l lb lc"><em class="ld">export const </em>extensions = [<br/>  EditorView.<em class="ld">theme({}, { dark: true });<br/>  /* ... */<br/></em>];</span></pre><p id="7f01" class="pw-post-body-paragraph je jf hi jg b jh ji ij jj jk jl im jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">经过所有的更改后，代码编辑器看起来是这样的:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mj"><img src="../Images/88f2e711688ffd3147f8c8eacdacd00b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZv3jWdCxypV9KNYaiXWhQ.png"/></div></div></figure><h1 id="1ce7" class="lm ky hi bd ln lo lp lq lr ls lt lu lv io lw ip lx ir ly is lz iu ma iv mb mc bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="f48a" class="pw-post-body-paragraph je jf hi jg b jh md ij jj jk me im jm jn mf jp jq jr mg jt ju jv mh jx jy jz hb bi translated">使用CodeMirror扩展和Material UI的主题对象向CodeMirror v6添加了自定义样式。</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="edd1" class="pw-post-body-paragraph je jf hi jg b jh ji ij jj jk jl im jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><em class="ld">最初来自:</em></p><div class="mr ms ez fb mt mu"><a href="https://www.bayanbennett.com/posts/styling-codemirror-v6-with-material-ui-devlog-005" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">使用材质UI设计CodeMirror v6的样式| DevLog 005</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">在上一篇文章中，我用react组件包装了CodeMirror v6。然而，它仍然看起来像一个平原时，它应该…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">www.bayanbennett.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni lk mu"/></div></div></a></div></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es nj"><img src="../Images/8e5119be1bb692e6343b8d27ba1cd821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KpyP5OY09RD7196_o3dNBw.png"/></div></div><figcaption class="nk nl et er es nm nn bd b be z dx translated">这只是为了缩略图</figcaption></figure></div></div>    
</body>
</html>