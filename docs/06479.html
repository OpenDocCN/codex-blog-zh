<html>
<head>
<title>Implementing a Clean Architecture Application in Scala — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Scala中实现一个干净的架构应用——第1部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/implementing-a-clean-architecture-application-in-scala-part-1-1442f0438b03?source=collection_archive---------9-----------------------#2022-04-26">https://medium.com/codex/implementing-a-clean-architecture-application-in-scala-part-1-1442f0438b03?source=collection_archive---------9-----------------------#2022-04-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="57cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Clean Architecture是由Robert c . Martin(Bob大叔)提出的一套指南，我将在本文中使用这些指南实现一个应用程序。虽然Clean Architecture只是一套指南，任何项目都可能有它的版本，但重要的原则是在工程师团队中实现一个版本，并在所有项目中坚持它。这个示意图是我们干净的建筑风格。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/c055d8f3ee9ead0066dcc1456ed8ffcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*VvEDFkd5-7crH_PHzw34Mg.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">我们干净的建筑</figcaption></figure><p id="5fe0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经在我之前的文章“Scala中干净的架构”中描述了我们的风格这个教程完全基于我以前的帖子，所以请阅读它，并确保您熟悉该项目的结构。</p><div class="jq jr ez fb js jt"><a rel="noopener follow" target="_blank" href="/codex/clean-architecture-in-scala-41d1ab05a618"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hj fi z dy jy ea eb jz ed ef hh bi translated">Scala中干净的架构</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">首先，什么是干净的架构？罗伯特·c·马丁(鲍勃大叔)声称虽然系统架构…</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">medium.com</p></div></div><div class="kc l"><div class="kd l ke kf kg kc kh jj jt"/></div></div></a></div><p id="3f17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在我的<a class="ae jp" href="https://github.com/SaeidDadkhah/clean-arch-example" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上实现了一个类似Medium的小应用程序！这个实现不是一个性能实现，它的唯一用途是描述这里提供的概念。</p><div class="jq jr ez fb js jt"><a href="https://github.com/SaeidDadkhah/clean-arch-example" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hj fi z dy jy ea eb jz ed ef hh bi translated">GitHub-SaeidDadkhah/Clean-arch-example:Scala中干净架构的实现</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">Scala中干净架构的实现。我们将使用Clean架构实现一个简单的博客应用程序…</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">github.com</p></div></div><div class="kc l"><div class="ki l ke kf kg kc kh jj jt"/></div></div></a></div></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><h1 id="f67b" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">企业层-域</h1><p id="4db1" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi lt translated">一个实现总是应该从企业层开始。该层的完整实现在<code class="du mc md me mf b">./02_domain</code>目录下的<code class="du mc md me mf b">02_domain</code>项目中提供。<code class="du mc md me mf b">com.github.saeiddadkhah.domain</code>包里面有两个包。<code class="du mc md me mf b">auth</code>包包含<code class="du mc md me mf b">User</code>和<code class="du mc md me mf b">Session</code>类，<code class="du mc md me mf b">blog</code>包包含<code class="du mc md me mf b">Post</code>、<code class="du mc md me mf b">Paragraph</code>、<code class="du mc md me mf b">Clap</code>和<code class="du mc md me mf b">Comment</code>类。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mg"><img src="../Images/e1df7e8df3a05b3203f511fbfbbebbcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:310/format:webp/1*mMSNeMSuzZFHtlAVe_LINg.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><code class="du mc md me mf b">domain</code>包的结构</figcaption></figure><p id="8a72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个包的结构的最佳实践之一是将所有的类放在一个特殊的包中；比如<code class="du mc md me mf b">User</code>类。虽然认证和授权不是<code class="du mc md me mf b">User</code>类的唯一用法，但是我们将这个类放在<code class="du mc md me mf b">auth</code>包中。让我们实现实体。最简单的实体只有一些参数，例如<code class="du mc md me mf b">Clap</code>和<code class="du mc md me mf b">Session</code>类。实体的参数只能是原语、基本的Java或Scala类和实体。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">仅建模数据的简单类</figcaption></figure><p id="c9ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些实体可能有一组简单的功能和验证，例如<code class="du mc md me mf b">Post</code>、<code class="du mc md me mf b">Clap</code>和<code class="du mc md me mf b">User</code>类。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">一个功能简单的类</figcaption></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">带有验证的类</figcaption></figure><p id="5ba6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一些实体可能有不同的类型，每个类型有其特殊的数据和功能，例如<code class="du mc md me mf b">Paragraph</code>类。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">不同类型的类</figcaption></figure><p id="0123" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我实现了这三种类型以保持教程的简单性，然而，根据不同的用例，你可以使用其中的每一种类型，甚至将它们结合起来，例如，你可能有一个带有属性、方法、验证的抽象类和几个子类。</p><h1 id="f228" class="kq kr hi bd ks kt mj kv kw kx mk kz la lb ml ld le lf mm lh li lj mn ll lm ln bi translated">应用层-合同</h1><p id="ad64" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi lt translated">构建应用层从设置合同开始。<code class="du mc md me mf b">03_contract</code>项目是<code class="du mc md me mf b">02_domain</code>项目和应用层合同的副本。下面是这部分项目的结构。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mo"><img src="../Images/b19e1dffe61698c3fc52304efd4593e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*DNy47HiyYdbmyNG-YebWEg.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">应用层的合同结构</figcaption></figure><p id="4a49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mc md me mf b">callback</code>和<code class="du mc md me mf b">service</code>包内的包结构与<code class="du mc md me mf b">domain</code>内的包结构完全相同，为一个类定义的回调和服务与该类在同一个包内。以下代码片段是发布服务的完整定义。<code class="du mc md me mf b">Request</code>类在服务的伴随对象中定义，指定服务的输入，<code class="du mc md me mf b">PublishPostService</code>扩展了<code class="du mc md me mf b">Service</code>，指定了<code class="du mc md me mf b">Request</code>和<code class="du mc md me mf b">Response</code>的类型。根据<code class="du mc md me mf b">Service</code>的定义，这个<em class="mp">抽象</em>类的任何实例<strong class="ih hj">只有一个名为<code class="du mc md me mf b">call</code>的</strong>方法，带有一个<code class="du mc md me mf b">Request</code>参数和一个隐式<code class="du mc md me mf b">scala.concurrent.ExecutionContext</code>参数，并将返回一个<code class="du mc md me mf b">Future[Post]</code>的实例。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">服务的定义</figcaption></figure><p id="0866" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与服务不同，回调不扩展任何其他类，并且可能有几个方法。回调中定义的方法通常是简单的CRUD(创建、读取、更新和删除)操作。回调和服务之间的另一个区别是，我们可以在一个实体上定义几个服务，但是对于一个实体只有一个回调——例如，这里我们有<code class="du mc md me mf b">AuthorizeService</code>、<code class="du mc md me mf b">SignInService</code>、<code class="du mc md me mf b">SignOutService</code>和<code class="du mc md me mf b">SignUpService</code>，对于<code class="du mc md me mf b">Session</code>类只有<code class="du mc md me mf b">SessionCallback</code>。这里是<code class="du mc md me mf b">PostCallback</code>的定义。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">回调的定义</figcaption></figure><p id="fc6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您不应该确切知道回调应该包含哪些方法。您可以在实现用例时添加方法。定义<code class="du mc md me mf b">get</code>方法的最佳实践之一是将响应包装在<code class="du mc md me mf b">Option</code>类中，以明确指定没有符合所提供标准的数据的情况。另一种做法是为期望返回元素列表的方法考虑<code class="du mc md me mf b">limit</code>和<code class="du mc md me mf b">offset</code>参数。</p></div><div class="ab cl kj kk gp kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hb hc hd he hf"><p id="03a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请继续关注实现应用程序其余部分的下一篇文章。请随意查看<a class="ae jp" href="https://saeiddadkhah.medium.com/clean-architecture-in-scala-41d1ab05a618" rel="noopener">以前的帖子</a>和<a class="ae jp" href="https://github.com/SaeidDadkhah/clean-arch-example" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>以及未解决的问题。我希望你喜欢这个教程。谢谢你。</p></div></div>    
</body>
</html>