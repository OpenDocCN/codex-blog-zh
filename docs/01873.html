<html>
<head>
<title>What is Hexagonal Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是六边形建筑</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-is-hexagonal-architecture-e7cf80b69539?source=collection_archive---------3-----------------------#2021-06-10">https://medium.com/codex/what-is-hexagonal-architecture-e7cf80b69539?source=collection_archive---------3-----------------------#2021-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1eb9b5ed6097361515c464f060851927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGYas2ojEFZ7ntABhU1FfQ.jpeg"/></div></div></figure><p id="c0f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">大多数软件应用程序都是使用六边形架构模型设计的。在这样的模型中，您将输出和输入放在设计的边缘。中央逻辑或应用程序的核心逻辑独立于任何外部干预。</p><p id="0afe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">边缘的输出和输入意味着它们的处理程序的交换是在不改变核心代码的情况下完成的。使用六边形架构的主要吸引力在于它使得代码测试更加容易。</p><p id="2c20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">测试变得更加稳定，因为能够换成赝品。六边形建筑明显不同于分层建筑。在分层架构中，为了支持测试，您可以使用依赖注入和其他技术。UI也可以在六边形模型中交换。</p><p id="665b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些是创造六边形建筑的核心原因。在本帖中，我们将详细了解什么是六边形架构，它有什么好处。</p><p id="b6fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录</strong></p><ol class=""><li id="19e1" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">什么是六边形建筑？</li><li id="ec25" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">六边形架构的优势</li><li id="3334" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">六角形建筑的缺点</li><li id="0542" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">六边形建筑的层次</li><li id="09da" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">结论</li></ol><h1 id="8345" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是六边形建筑？</h1><p id="a31e" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">阿利斯泰尔·考克伯恩在2005年提出了六边形架构。六边形架构是一种架构模式，有助于解决传统架构(以数据库为中心的架构)中与应用程序维护相关的问题。六角形架构(也称为端口和适配器模式)背后的核心概念是应用程序是系统的中心。端口将到达或离开应用程序的输入和输出与外部技术、交付机制和工具隔离开来。</p><p id="3153" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了更好地理解这个概念，让我们快速查看下图。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div class="er es lf"><img src="../Images/6595dd96efc33b32a81cfa1f0b08fb21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/0*GOYufPvhUQzkpu75"/></div></figure><p id="74a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如图所示，有两个六边形，一个在另一个里面。内六角描绘了应用程序的核心、应用程序逻辑和业务。适配层位于核心和外部六边形之间。六边形的每一边代表一个端口。</p><p id="9964" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正因为六边形有六条边，并不意味着六边形结构中只能有六个端口。六边形只是用来用简单的语言表示整个概念。考克伯恩选择了一个六边形的平边，而不是一个圆，来具体表示港口的位置。</p><h1 id="13c9" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">六边形架构的优势</h1><ul class=""><li id="dee0" class="jo jp hi is b it la ix lb jb lk jf ll jj lm jn ln ju jv jw bi translated"><strong class="is hj">即插即用:</strong>这种架构为我们提供了在开发过程中根据需求添加和移除适配器的能力。例如，我们可以在不改变逻辑的情况下将GraphQL适配器与REST适配器互换</li><li id="0dff" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated"><strong class="is hj">可测试性:</strong>我们可以毫不费力地为每个组件编写测试用例，因为它解耦了所有的层。</li><li id="0233" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated">适应性/增强:我们总是可以添加一种新的方式来轻松地与应用程序交互。</li><li id="b877" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated"><strong class="is hj">可持续性</strong>:维护变得更加容易，因为所有的第三方库都可以保存在基础设施层。</li><li id="bac0" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated"><strong class="is hj">数据库独立:</strong>我们可以很容易地切换数据库提供商，因为数据库与数据访问是分离的。</li><li id="be34" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated"><strong class="is hj">干净的代码:</strong> UI很容易实现，因为业务逻辑远离了React、Angular或Blazor等表示层。</li><li id="b089" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated">组织良好:新开发人员将很容易上手，并对项目有更好的理解，因为它组织良好。</li></ul><h1 id="2d9a" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">六角形建筑的缺点</h1><ul class=""><li id="c605" class="jo jp hi is b it la ix lb jb lk jf ll jj lm jn ln ju jv jw bi translated">领域层变得很重，因为这一层实现了大量的逻辑。</li><li id="64a7" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated">随着我们用多层抽象来构建应用程序，复杂程度将会急剧增加。</li><li id="872b" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated">拥有许多间接层和隔离层通常会增加构建和维护应用程序的成本。这个成本超过了抽象的好处。</li><li id="1c14" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated">大多数web应用程序永远不需要切换数据库和框架。它们只能通过浏览器使用。创建有可能替换任何实现的应用程序是一个崇高的目标。然而，大多数应用程序不需要这种级别的适应性。因此，构建如此理想的应用程序是浪费时间。</li></ul><h1 id="7280" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">六边形建筑的层次</h1><ul class=""><li id="6ddb" class="jo jp hi is b it la ix lb jb lk jf ll jj lm jn ln ju jv jw bi translated"><strong class="is hj">领域API层:</strong>这一层是中心层，不依赖任何其他层。因为主适配器和辅助适配器应该能够实现该契约，所以它是域层交互(端口)的契约。这也被称为依赖性反转原理域层(DIP)。</li><li id="f78c" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated"><strong class="is hj">领域层(业务层):</strong>这些层保持干净，没有任何其他依赖。他们有商业逻辑。</li><li id="c437" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated"><strong class="is hj"> Rest适配器层:</strong>Rest适配器层也叫左端口适配器。主适配器是实现restful服务的层，如GET、POST、PUT、DELETE等。</li><li id="c53a" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn ln ju jv jw bi translated"><strong class="is hj">持久性适配器层:</strong>这是Rest适配器，也称为右端口适配器或辅助适配器。这是实现实体框架核心的层，它以前实现了一个存储库设计模式。DbSet是存储库，DbContext是工作单元(UOW)。引导/表示层:-这是项目的最后一层。一切从这里开始。</li></ul><h1 id="474c" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="52b3" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">六边形架构是构建web应用程序的流行方法之一。何时何地使用这种架构完全取决于项目的类型。将应用程序分成不同的责任层是好的，但是过早地使用抽象将导致徒劳的结果。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="bf6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lv">原载于</em><a class="ae lw" href="https://www.partech.nl/nl/publicaties/2021/06/what-is-hexagonal-architecture" rel="noopener ugc nofollow" target="_blank"><em class="lv">https://www . partech . nl</em></a><em class="lv">。</em></p></div></div>    
</body>
</html>