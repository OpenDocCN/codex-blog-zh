<html>
<head>
<title>Building a REST API with Node.js, MySQL, and Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js、MySQL和Express构建REST API</h1>
<blockquote>原文：<a href="https://medium.com/codex/building-a-rest-api-with-node-js-mysql-and-express-d55c090d171e?source=collection_archive---------0-----------------------#2021-12-22">https://medium.com/codex/building-a-rest-api-with-node-js-mysql-and-express-d55c090d171e?source=collection_archive---------0-----------------------#2021-12-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0d2065362b4585c6e3f96a25a2a21813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rgPDXGgOfT-z8BRl_AneWg.jpeg"/></div></div></figure><p id="8828" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Node.js通常与MongoDB等NoSQL数据库结合使用，尽管它也可以很好地与MySQL、PostgreSQL等关系数据库配合使用。MySQL已经存在了几十年，是广泛使用的关系数据库管理系统(RDBMS)之一。世界上最开放源代码的数据库是小型和大型应用程序的理想RDBMS。</p><p id="fd93" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本教程将通过创建一个简单的数据库来添加、更新和删除todos，探索如何用Express和MySQL构建REST API。您可以通过克隆这个项目的<a class="ae jo" href="https://github.com/icode247/Serverside-rendering-FastAPI" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>来跟进。我们开始吧！</p><h2 id="a541" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">先决条件</h2><p id="a56c" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">本教程是一个实践演示。在开始之前，请确保您准备好了以下内容:</p><ol class=""><li id="525e" class="kp kq hi is b it iu ix iy jb kr jf ks jj kt jn ku kv kw kx bi translated"><a class="ae jo" href="https://docs.arctype.com/connect/mysql" rel="noopener ugc nofollow" target="_blank"> MySQL </a>服务器安装在你的电脑上。</li><li id="ed74" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><a class="ae jo" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">你电脑上安装的Node.js </a>。</li></ol><p id="a68b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有的演示都将使用Ubuntu 20.04和Node 14 LTS。它也适用于其他操作系统和其他版本的Linux。</p><h1 id="f6c8" class="ld jq hi bd jr le lf lg jv lh li lj jz lk ll lm kc ln lo lp kf lq lr ls ki lt bi translated">什么是休息？</h1><p id="fdaa" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">REST(表述性状态转移)是一种软件架构风格，开发人员建立这种风格是为了帮助创建和开发万维网的架构。REST规定了一组标准，这些标准是关于互联网规模的分布式超媒体系统(如Web)的体系结构应该如何运行的。这是应用程序、服务器和网站传递数据和服务的各种方式之一。它通常为处理数据和服务的开发人员如何通过API表示元素提供规则。其他程序可以适当地请求和接收API提供的数据和服务。</p><h1 id="c6de" class="ld jq hi bd jr le lf lg jv lh li lj jz lk ll lm kc ln lo lp kf lq lr ls ki lt bi translated">为什么要用REST？</h1><p id="7938" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">REST有几个独特的特征，使其成为软件工程师广泛采用的顶级软件架构风格之一。</p><ol class=""><li id="c877" class="kp kq hi is b it iu ix iy jb kr jf ks jj kt jn ku kv kw kx bi translated"><strong class="is hj">它是轻量级的</strong>:REST API使用HTTP标准。因此，您可以使用XML、JSON、HTML和其他数据格式。因此，REST APIs快速、轻量，是开发移动应用程序、物联网设备和其他应用程序的绝佳选择。</li><li id="67ef" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">它是独立的:</strong>REST API中客户端和服务器的分离使得它是独立的。REST协议将数据存储和用户界面从服务器中分离出来，使得开发人员可以轻松地协作构建项目。</li><li id="c54f" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">可扩展且灵活</strong>:由于客户端和服务器端的分离，REST API的使用是可扩展且灵活的，允许开发人员集成REST API，而无需任何额外的工作。</li><li id="cb85" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">它是无状态的</strong>:调用是独立进行REST的，这些调用的每一个都包含了完成请求的所有数据。</li><li id="6eab" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">它有一个统一的接口</strong>，允许应用程序独立发展，而无需将应用程序的服务或模型和动作紧密耦合到API层本身。</li><li id="7355" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">这是一个分层架构系统</strong>，它构建了一个层次结构，有助于创建一个更具可伸缩性和模块化的应用程序。</li></ol><h1 id="4efd" class="ld jq hi bd jr le lf lg jv lh li lj jz lk ll lm kc ln lo lp kf lq lr ls ki lt bi translated">MySQL数据库概述</h1><p id="5efb" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">MySQL 是一个开源的关系数据库管理系统(RDBMS)。它是PHP使用的最流行的数据库系统。MySQL是一种完全托管的数据库服务，用于部署云原生应用。集成的高性能查询加速器HeatWave将MySQL性能提升了5400倍。</p><p id="cb6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">MySQL由Oracle Corporation开发、发布和支持，具有以下特性。</p><ul class=""><li id="286d" class="kp kq hi is b it iu ix iy jb kr jf ks jj kt jn lu kv kw kx bi translated">MySQL数据库中的数据存在于由列和行组成的表中。</li><li id="e6e8" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn lu kv kw kx bi translated">MySQL是一个运行在服务器上的数据库系统。</li><li id="04d9" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn lu kv kw kx bi translated">MySQL是小型和大型应用程序的理想选择。</li><li id="b8ae" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn lu kv kw kx bi translated">MySQL是一个非常快速、可靠且易于使用的数据库系统。它使用标准的SQL。</li><li id="088b" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn lu kv kw kx bi translated">MySQL可以在多种平台上编译。</li></ul><h1 id="f6ea" class="ld jq hi bd jr le lf lg jv lh li lj jz lk ll lm kc ln lo lp kf lq lr ls ki lt bi translated">创建Node.js应用程序</h1><p id="3165" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">既然我们已经探索了REST是什么，并且对MySQL数据库有了一个快速的概述，那么让我们开始创建我们的RESTFul应用程序。首先，我们需要用下面的命令为我们的项目创建一个文件夹:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="4b21" class="jp jq hi ma b fi me mf l mg mh">mkdir rest-with-mysql &amp;&amp; cd rest-with-mysql</span></pre><p id="9107" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的命令将创建一个<em class="mi"> rest-with-MySQL </em>文件夹，并将目录更改为该文件夹。接下来，我们将使用下面的命令初始化一个新的node.js项目:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="949e" class="jp jq hi ma b fi me mf l mg mh">npm init -y</span></pre><p id="2ced" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的命令将初始化一个新的Node.js项目，跳过所有关于项目细节的提示。该命令还将在我们项目的根目录中创建一个package.json文件，该文件将记录关于我们项目的所有重要元数据。您可以通过删除命令中的标志来决定根据提示输入项目详细信息。</p><p id="c1a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将安装项目所需的依赖项。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="9f20" class="jp jq hi ma b fi me mf l mg mh">npm install express MySQL cors</span></pre><p id="289e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的命令需要一点时间来完成，但是我们会在最后安装<a class="ae jo" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank"> Express </a>、MySQL和<a class="ae jo" href="https://www.npmjs.com/package/cors" rel="noopener ugc nofollow" target="_blank"> Cors </a>。最后，让我们看看我们的项目结构。在本教程结束时，我们的项目结构将如下所示:</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/599c3c2f8bbee60124ae5638be550075.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/0*eADleNOQD1NEjGD9.png"/></div></figure><h1 id="ff1a" class="ld jq hi bd jr le lf lg jv lh li lj jz lk ll lm kc ln lo lp kf lq lr ls ki lt bi translated">设置Express服务器</h1><p id="9658" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">现在我们已经安装了我们的依赖项，让我们通过首先设置我们的express服务器来让它们工作。</p><p id="1da3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个<em class="mi"> app.js </em>文件，并将下面的代码片段添加到其中。我们将导入以下内容:</p><ul class=""><li id="7dc4" class="kp kq hi is b it iu ix iy jb kr jf ks jj kt jn lu kv kw kx bi translated"><strong class="is hj"> Express: </strong>创建我们的服务器。</li><li id="98d5" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn lu kv kw kx bi translated"><strong class="is hj"> Cors: </strong>允许并重定向请求资源。</li><li id="d9a9" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn lu kv kw kx bi translated"><strong class="is hj">路由器:</strong>这是我们的API路由将在后面的章节中定义的地方。</li><li id="cdf1" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn lu kv kw kx bi translated">AppError和errorHandler: 这些是我们的全局错误处理函数。我们稍后将创建它们。</li></ul><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="a224" class="jp jq hi ma b fi me mf l mg mh">const express = require("express");<br/>const cors = require("cors");<br/>const router = require("./routes");<br/>const AppError = require("./utils/appError");<br/>const errorHandler = require("./utils/errorHandler");<br/>….</span></pre><p id="8344" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们从express创建一个<strong class="is hj">应用</strong>实例，使用我们应用中的<strong class="is hj"> express.json() </strong>中间件来解析URL编码的主体。最后，我们让API路由器中间件监听对指定URL的传入请求。</p><p id="bc7b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们检查端点中丢失的URL，如果它们被访问，就向用户抛出一个<a class="ae jo" href="https://www.ionos.com/digitalguide/websites/website-creation/what-does-the-404-not-found-error-mean/" rel="noopener ugc nofollow" target="_blank"> 404 </a>错误。全局错误处理程序将处理这个问题(我们将在后续部分中创建它)。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="3d5c" class="jp jq hi ma b fi me mf l mg mh">app.use(api, router);<br/><br/>app.all("*", (req, res, next) =&gt; {<br/> next(new AppError(`The URL ${req.originalUrl} does not exists`, 404));<br/>});<br/>app.use(errorHandler);<br/>...</span></pre><p id="44dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们将配置我们的应用程序来监听端口<strong class="is hj"> 3000。</strong></p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="f5d4" class="jp jq hi ma b fi me mf l mg mh">const PORT = 3000;<br/>app.listen(PORT, () =&gt; {<br/> console.log(`server running on port ${PORT}`);<br/>});<br/><br/>module.exports = app;<!-- -->Choosing port 3000 for our listening port.</span></pre><h1 id="0880" class="ld jq hi bd jr le lf lg jv lh li lj jz lk ll lm kc ln lo lp kf lq lr ls ki lt bi translated">设置并连接到MySQL</h1><p id="8705" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">现在，我们已经设置好了Express服务器。让我们继续设置我们的MySQL数据库。首先，我们将使用下面的命令打开我们的MySQL shell:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="37fb" class="jp jq hi ma b fi me mf l mg mh">//On Windows<br/>MySQL<br/><br/>//Ubuntu<br/>mysql -u root -p</span></pre><p id="05af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述命令将提示您输入root密码。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/9a898cfa6da2e3231b1c0994e59bf5cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rb0oDDTXQqrZR_GO.png"/></div></div></figure><p id="486b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">输入密码，然后按Enter键继续。如果一切顺利，您应该会在您的终端上看到与下面的屏幕截图类似的输出。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/e8ad57f823b54403fadbd8d7a1eae015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oGhTYyVGDKVVGWhN.png"/></div></div></figure><p id="1a7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，在MySQL shell上执行下面的SQL语句，创建我们的<strong class="is hj"> todos </strong>数据库。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="11cb" class="jp jq hi ma b fi me mf l mg mh">CREATE DATABASE todos</span></pre><p id="048c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，执行下面的命令来创建我们的<strong class="is hj"> todolist </strong>表。该表将有一个<strong class="is hj"> id </strong>、<strong class="is hj">名称、状态、创建日期</strong>字段。该id字段将成为我们的表的主键。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="5524" class="jp jq hi ma b fi me mf l mg mh">CREATE TABLE todolist(id int NOT NULL AUTO_INCREMENT,<br/>name varchar(50) NOT NULL, <br/>status varchar(50), <br/>date_created DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, <br/>PRIMARY KEY (id));</span></pre><p id="84b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，在我们的项目根目录下创建<strong class="is hj"> <em class="mi">服务</em> </strong>文件夹。在<strong class="is hj">服务</strong>文件夹中，创建一个<strong class="is hj"> db.js </strong>文件，并将以下代码片段添加到其中。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="0ce6" class="jp jq hi ma b fi me mf l mg mh">const mysql = require('mysql');<br/>const conn = mysql.createConnection({<br/> host: "localhost",<br/> user: "root",<br/> password: "1234",<br/> database: "todos",<br/>});<br/><br/>conn.connect();<br/><br/>module.exports = conn;</span></pre><p id="1492" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码将使用MySQL <strong class="is hj"> createConnection </strong>方法连接到我们的MySQL数据库。createConnection方法将<strong class="is hj">主机</strong>、<strong class="is hj">用户名</strong>、<strong class="is hj">密码</strong>和<strong class="is hj">数据库</strong>名称作为必需的参数。</p><h1 id="38e8" class="ld jq hi bd jr le lf lg jv lh li lj jz lk ll lm kc ln lo lp kf lq lr ls ki lt bi translated">创建应用程序控制器</h1><p id="fb83" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">我们已经成功连接了我们的MySQL数据库。让我们继续为我们的应用程序创建路由。</p><p id="00ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的项目根目录下，创建一个<strong class="is hj"> <em class="mi">控制器</em> </strong>文件夹，然后在<strong class="is hj"> <em class="mi">控制器</em> </strong>文件夹下创建一个<strong class="is hj"> index.js </strong>文件。</p><p id="da9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们将导入全局错误处理程序和MySQL数据库连接。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="90e7" class="jp jq hi ma b fi me mf l mg mh">const AppError = require("../utils/appError");<br/>const conn = require("../services/db");</span></pre><p id="9291" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将创建我们的<strong class="is hj"> getAllTodos </strong>处理程序来获取数据库中的所有Todos。这个处理程序将使用MySQL查询方法，该方法将一个SQL查询和一个回调函数作为参数。如果在操作过程中出现错误，我们将使用<strong class="is hj"> AppError </strong>类将错误返回给用户。然后，当操作成功运行时，我们用一个<strong class="is hj"> 200状态</strong>代码将数据返回给用户。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="0161" class="jp jq hi ma b fi me mf l mg mh">exports.getAllTodos = (req, res, next) =&gt; {<br/> conn.query("SELECT * FROM todolist", function (err, data, fields) {<br/>   if(err) return next(new AppError(err))<br/>   res.status(200).json({<br/>     status: "success",<br/>     length: data?.length,<br/>     data: data,<br/>   });<br/> });<br/>};</span></pre><p id="4db6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将创建我们的<strong class="is hj"> createTodo </strong>处理程序来将新的Todo添加到我们的数据库中。然后我们检查客户端是否发送了一个空表单，并返回一个<strong class="is hj"> 404错误</strong>消息。</p><p id="fdbf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们从请求体中获取todo名称，并将创建的每个todo的状态默认设置为<strong class="is hj"> pending </strong>。使用query mysql方法，我们创建一个插入查询，将todo添加到我们的数据库中。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="1036" class="jp jq hi ma b fi me mf l mg mh">exports.createTodo = (req, res, next) =&gt; {<br/> if (!req.body) return next(new AppError("No form data found", 404));<br/> const values = [req.body.name, "pending"];<br/> conn.query(<br/>   "INSERT INTO todolist (name, status) VALUES(?)",<br/>   [values],<br/>   function (err, data, fields) {<br/>     if (err) return next(new AppError(err, 500));<br/>     res.status(201).json({<br/>       status: "success",<br/>       message: "todo created!",<br/>     });<br/>   }<br/> );<br/>};</span></pre><p id="cb07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们创建一个<strong class="is hj"> getTodo </strong>处理程序来通过id获取我们的Todo。首先，我们将检查请求参数中是否指定了id，如果没有找到，则向客户端返回一个错误。</p><p id="b615" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将执行一条SQL语句来获取其id在请求参数上的todo，并将其返回给客户端。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="e44a" class="jp jq hi ma b fi me mf l mg mh">exports.getTodo = (req, res, next) =&gt; {<br/> if (!req.params.id) {<br/>   return next(new AppError("No todo id found", 404));<br/> }<br/> conn.query(<br/>   "SELECT * FROM todolist WHERE id = ?",<br/>   [req.params.id],<br/>   function (err, data, fields) {<br/>     if (err) return next(new AppError(err, 500));<br/>     res.status(200).json({<br/>       status: "success",<br/>       length: data?.length,<br/>       data: data,<br/>     });<br/>   }<br/> );<br/>};</span></pre><p id="868c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将创建我们的<strong class="is hj"> updateTodo </strong>处理程序来更新我们的Todo，这次将修改其<strong class="is hj"> id </strong>在要完成的请求参数中的todo。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="6306" class="jp jq hi ma b fi me mf l mg mh">exports.updateTodo = (req, res, next) =&gt; {<br/> if (!req.params.id) {<br/>   return next(new AppError("No todo id found", 404));<br/> }<br/> conn.query(<br/>   "UPDATE todolist SET status='completed' WHERE id=?",<br/>   [req.params.id],<br/>   function (err, data, fields) {<br/>     if (err) return next(new AppError(err, 500));<br/>     res.status(201).json({<br/>       status: "success",<br/>       message: "todo updated!",<br/>     });<br/>   }<br/> );<br/>};</span></pre><p id="bcf9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们将创建一个<strong class="is hj"> deleteTodo </strong>处理程序来从我们的数据库中删除一个Todo。我们将执行一个delete语句来删除一个todo，它的<strong class="is hj"> id </strong>是请求参数。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="d9f0" class="jp jq hi ma b fi me mf l mg mh">exports.deleteTodo = (req, res, next) =&gt; {<br/> if (!req.params.id) {<br/>   return next(new AppError("No todo id found", 404));<br/> }<br/> conn.query(<br/>   "DELETE FROM todolist WHERE id=?",<br/>   [req.params.id],<br/>   function (err, fields) {<br/>     if (err) return next(new AppError(err, 500));<br/>     res.status(201).json({<br/>       status: "success",<br/>       message: "todo deleted!",<br/>     });<br/>   }<br/> );<br/>}</span></pre><h1 id="ae66" class="ld jq hi bd jr le lf lg jv lh li lj jz lk ll lm kc ln lo lp kf lq lr ls ki lt bi translated">创建全局错误处理程序</h1><p id="0ffe" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">现在，让我们快速创建我们的全局错误处理程序。首先，在我们的项目根目录中创建一个<strong class="is hj"> utils </strong>文件夹。然后，创建一个<strong class="is hj"> appError.js </strong>和<strong class="is hj"> errorHandler.js </strong>文件。将下面的代码片段添加到<strong class="is hj"> appError.js </strong>文件中。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="6f13" class="jp jq hi ma b fi me mf l mg mh">class AppError extends Error {<br/> constructor(msg, statusCode) {<br/>   super(msg);<br/><br/>   this.statusCode = statusCode;<br/>   this.error = `${statusCode}`.startsWith('4') ? 'fail' : 'error';<br/>   this.isOperational = true;<br/><br/>   Error.captureStackTrace(this, this.constructor);<br/> }<br/>}<br/>module.exports = AppError;</span></pre><p id="0efa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码创建了一个<strong class="is hj"> AppError </strong>类，它扩展了内置的<strong class="is hj"> Error </strong>类。然后我们将把错误<strong class="is hj">消息</strong>和<strong class="is hj">状态</strong>传递给错误类构造函数。然后，我们将从状态代码开始检查应用程序中发生了什么类型的错误，并将该错误添加到错误堆栈跟踪中。</p><p id="6c95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，打开<strong class="is hj"> errorHandler.js </strong>文件并添加下面的代码片段:</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="cd56" class="jp jq hi ma b fi me mf l mg mh">module.exports = (err, req, res, next) =&gt; {<br/> err.statusCode = err.statusCode || 500;<br/> err.status = err.status || "error";<br/> res.status(err.statusCode).json({<br/>   status: err.status,<br/>   message: err.message,<br/> });<br/>};</span></pre><p id="9670" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码将检查我们的应用程序中可能存在的错误，并将相应的错误和状态代码发送给客户端，而不会破坏我们的应用程序。</p><h1 id="49aa" class="ld jq hi bd jr le lf lg jv lh li lj jz lk ll lm kc ln lo lp kf lq lr ls ki lt bi translated">创建应用程序路由</h1><p id="410e" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">在我们的项目根目录中，创建一个<strong class="is hj"> <em class="mi"> routes </em> </strong>文件夹，然后创建一个<strong class="is hj"> index.js </strong>文件，并将下面的代码片段添加到其中。</p><pre class="lv lw lx ly fd lz ma mb mc aw md bi"><span id="3f28" class="jp jq hi ma b fi me mf l mg mh">const express = require("express");<br/>const controllers = require("../controllers");<br/>const router = express.Router();<br/><br/>router.route("/").get(controllers.getAllTodos).post(controllers.createTodo);<br/>router<br/> .route("/:id")<br/> .get(controllers.getTodo)<br/> .put(controllers.updateTodo)<br/> .delete(controllers.deleteTodo);<br/>module.exports = router;</span></pre><p id="3d04" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码从express router类创建了一个<strong class="is hj"> router </strong>对象。然后，我们在应用程序中创建以下路线。</p><ul class=""><li id="7106" class="kp kq hi is b it iu ix iy jb kr jf ks jj kt jn lu kv kw kx bi translated">获取路线:获取我们数据库中的所有todos。</li><li id="7bc5" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn lu kv kw kx bi translated">发布路线:向我们的数据库添加新的待办事项</li><li id="7368" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn lu kv kw kx bi translated">获取路由:通过id获取todo</li><li id="fb98" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn lu kv kw kx bi translated">Put Route:按id更新todo</li><li id="644f" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn lu kv kw kx bi translated">删除路线:按id删除待办事项。</li></ul><p id="2c76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们导出路由器对象。</p><h1 id="815c" class="ld jq hi bd jr le lf lg jv lh li lj jz lk ll lm kc ln lo lp kf lq lr ls ki lt bi translated">使用Arctype查看数据</h1><p id="c70e" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">现在我们已经创建了所有的路线。现在，让我们连接到Arctype以可视化数据库中的数据。为此，我们需要从官网下载<a class="ae jo" href="https://arctype.com/" rel="noopener ugc nofollow" target="_blank"> Arctype </a>。下载并安装Arctype，然后将数据库连接到它。当您启动Arctype时，单击MySQL创建一个连接— <a class="ae jo" href="https://docs.arctype.com/connect/mysql" rel="noopener ugc nofollow" target="_blank">如果您需要帮助，请遵循本指南</a>。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/a29c0c1edec78861656ff676934a36ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cKKNzoqRefOlJqJM.png"/></div></div></figure><p id="27cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们将添加我们的连接凭证，并按下<strong class="is hj">保存</strong>按钮。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/f63e0292b01e745a0485086d58b02a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jiJJY6al6MIYCl0i.png"/></div></div></figure><p id="fa83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经成功连接到我们的数据库。您应该会在Arctype仪表盘的右侧看到我们的数据库表。点击<strong class="is hj"> todolist </strong>表，对Arctype上的数据库进行一些查询。</p><p id="ab25" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以通过点击<strong class="is hj">插入行</strong>选项卡向数据库添加新记录。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/5bc73240b550a58a96eb6e323803fbda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bst2UocrReMF4zrG.png"/></div></div></figure><p id="dde2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还可以<strong class="is hj">编辑</strong>并使用Arctype查询我们的数据库表…等等。</p><h1 id="5cc5" class="ld jq hi bd jr le lf lg jv lh li lj jz lk ll lm kc ln lo lp kf lq lr ls ki lt bi translated">结论</h1><p id="83c7" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">现在您已经了解了如何使用Express框架构建REST API安装Express Node.js包，创建MySQL数据库，并创建一个简单的待办事项应用程序。这就够了！</p><p id="103d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或许你可以在这里了解更多关于如何使用MySQL和Node.js <a class="ae jo" href="https://arctype.com/mysql/drivers/node-mysql" rel="noopener ugc nofollow" target="_blank">的信息。如果您有任何问题，请随时联系Twitter。</a></p></div></div>    
</body>
</html>