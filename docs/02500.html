<html>
<head>
<title>From Rails to Node: A Beginner’s Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Rails到Node:初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/codex/from-rails-to-node-a-beginners-guide-d8c5a7ef395c?source=collection_archive---------8-----------------------#2021-07-23">https://medium.com/codex/from-rails-to-node-a-beginners-guide-d8c5a7ef395c?source=collection_archive---------8-----------------------#2021-07-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d326c1f0ddf1487138014787e2e0c4ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U8WUAWtlyejtVSQ_"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@amyhirschi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾米·赫希</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="c1b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有什么感觉比从计算机科学学位或软件工程训练营毕业更令人沮丧的了，当你调出第一批工作清单，发现其中许多都不是你在课程中学到的特定技术。唉。但是，学习新技能的无限机会是科技世界最令人兴奋的方面，你对引入新工具和新概念越开放，你在潜在雇主面前就越有市场。</p><p id="05a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为一个建立在用户友好语言之上的用户友好框架，Ruby on Rails是开发人员训练营和类似组织中的一个流行选择，作为一个后端环境来教授新的软件工程师。为什么不呢？它得到了很好的支持，易于理解，并且适用于PostgreSQL等关系数据库。但是正如我们所说的——学习新工具是技术领域的游戏名称，所以本文将作为初学者指南，将Rails知识转移到另一个流行的后端环境中:</p><p id="9aa5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Node.js。</p><h1 id="c4b2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Node.js是什么？</h1><p id="bb02" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Node是一个后端运行时环境，旨在允许开发人员在浏览器之外编写和运行JavaScript代码。那是什么意思？基本上，它让我们能够使用JS为动态web应用程序构建服务器，就像我们习惯使用Ruby和Rails一样。这样做的好处是显而易见的:它允许我们在前端和后端统一我们的代码库。它也让我们写更多的JavaScript，这从来不是一件坏事！在我们开始之前，如果您还没有安装Node，请确保先安装它。让我们深入研究，从基础知识开始。</p><h1 id="985c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">入门指南</h1><p id="a1ed" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们将开始构建一个新的项目目录，并在其中运行<code class="du kw kx ky kz b">npm init</code>来生成我们的<code class="du kw kx ky kz b">package.json</code>。我们要做的第一件事是将下面一行添加到该文件中:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="117d" class="li ju hi kz b fi lj lk l ll lm">"type": "module"</span></pre><p id="ad7a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">直到最近，诸如<code class="du kw kx ky kz b">import</code>的ES6特性还不被Node支持。在<code class="du kw kx ky kz b">package.json</code>中包含这一行将会为我们打开这个可爱的功能。</p><p id="f040" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，为了弥补这里的知识缺口，本指南将介绍Node本身之外的几项附加技术，这些技术将允许我们建立一个类似于我们习惯使用Rails的环境。我们将在MERN堆栈(MongoDB、Express、React、Node)的上下文中工作，必要时会涉及到它，但不是本文的重点。现在让我们快速浏览一下其中的一些工具。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="706b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 1。Express.js </strong></p><p id="7c2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kw kx ky kz b">npm i express</code></p><p id="c793" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Express是一个流行的极简节点框架，非常适合构建RESTful APIs。</p><p id="2308" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 2。猫鼬</strong></p><p id="e472" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kw kx ky kz b">npm i mongoose</code></p><p id="ff14" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Mongoose是MongoDB的建模工具，它允许我们轻松地建立数据库连接、编写对象模型模式、查询数据库等等。由于本指南旨在作为Node而非Mongo的初级读本，所以我们在这里不会涉及实际的数据库设置。然而，参考资料中会链接一个非常有用的Youtube系列，它涵盖了从开始到结束的整个栈MERN开发周期，包括MongoDB初始化。</p><p id="bd97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 3。nodemon </strong></p><p id="dfea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kw kx ky kz b">npm i nodemon</code></p><p id="6d1b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">nodemon是Node的替代包装器。它会主动观察代码中的变化，并自动重启服务器以反映这些变化，而不是让您自己手动执行该任务。一旦安装了nodemon，确保将行<code class="du kw kx ky kz b">“start”: “nodemon index.js”</code>添加到<code class="du kw kx ky kz b">package.json</code>文件中的<code class="du kw kx ky kz b">scripts</code>对象中。这将允许你运行<code class="du kw kx ky kz b">npm start</code>来启动你的后端。</p><p id="16b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 4。cors </strong></p><p id="9e1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kw kx ky kz b">npm i cors</code></p><p id="b95d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">cors是一个Express节点中间件包(稍后将详细介绍),支持各种CORS功能。</p><p id="de22" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> 5。dotenv </strong></p><p id="4d82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kw kx ky kz b">npm i dotenv</code></p><p id="d107" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个简单的节点包，允许我们创建并利用一个<code class="du kw kx ky kz b">.env</code>文件来隐藏敏感信息，如数据库凭证、API密钥等。在推送到GitHub之前，确保您的<code class="du kw kx ky kz b">.env</code>文件包含在您的<code class="du kw kx ky kz b">.gitignore</code>中！</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="09d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好的，太好了！有了这些工具，我们只需要在项目中再创建几个条目就可以了。让我们在我们的根目录下做三个目录，它们的名字可能听起来很熟悉:<code class="du kw kx ky kz b">controllers</code> <code class="du kw kx ky kz b">models</code>和<code class="du kw kx ky kz b">routes</code>。之后，我们将创建一个<code class="du kw kx ky kz b">index.js</code>文件并在我们的编辑器中打开它。这是我们设置服务器的地方！</p><h1 id="acb3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">服务器初始化</h1><p id="01db" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如前所述，我们的<code class="du kw kx ky kz b">index.js</code>文件将是我们建立服务器的地方。在这里，我们将导入几个刚刚安装的包，并编写一些样板代码来启动和运行。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/4171aa10258c177f55ca9c800a5580b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bXqpz1ayX9YTlEmGyPP4Ug.png"/></div></div></figure><p id="c5a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看我们在这里做什么。首先，像往常一样，我们将导入服务器初始化所需的包。稍后，我们也将在这里导入我们的路由文件。在第6行，我们将配置<code class="du kw kx ky kz b">dotenv</code>——在我们可以使用它之前需要一个动作。在第8行，我们将使用Express创建一个服务器实例，然后在第10行和第11行，我们将告诉它同时使用<code class="du kw kx ky kz b">cors</code>和<code class="du kw kx ky kz b">json</code>中间件。之后，一旦您将MongoDB连接URL以及端口信息放在了<code class="du kw kx ky kz b">.env</code>文件中，并为它们指定了名称，您就可以在这里通过将它们指定给变量来访问它们，如第13行和第14行所示。接下来，在第16行，我们将使用mongoose的<code class="du kw kx ky kz b">connect</code>方法，将DB URL和options对象作为参数传递，来建立到数据库的连接。我们将字符串化一个<code class="du kw kx ky kz b">.then</code>,其中我们传入一个回调函数，该函数调用我们的<code class="du kw kx ky kz b">app</code>实例上的<code class="du kw kx ky kz b">listen</code>,传入端口和<code class="du kw kx ky kz b">console.log</code>消息作为参数。之后，我们将捕获并记录任何错误。最后，在第20行，我们将通过在我们的<code class="du kw kx ky kz b">app</code>实例上调用<code class="du kw kx ky kz b">use</code>来设置一个初始路由，传入一个路径字符串，然后传入一个带有状态代码和json响应的回调函数。稍后，我们将回到这里，扩大这条路线，以及添加更多。但在此之前，我们需要实际建造这些路线。</p><h1 id="f5ba" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">路线</h1><p id="7401" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">啊，路由。这听起来很熟悉！虽然这不会像我们习惯的Rails那样编写(很明显)，但同样的概念仍然适用:我们将指定一个HTTP方法、一个请求可以从前端发送到的路由，以及一个处理该请求所发生的事情的控制器动作。让我们为即将建立的<code class="du kw kx ky kz b">Note</code>模型写一些CRUD路径。以下是我们习惯在Rails中看到的内容:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="7144" class="li ju hi kz b fi lj lk l ll lm">get "/notes", to: "notes#index"<br/>post "/notes", to: "notes#create"<br/>patch "/notes/:id", to: "notes#update"<br/>delete "/notes/:id", to: "notes#destroy"</span></pre><p id="ef5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，让我们看一下我们将如何使用Express处理这些相同的路线。在我们的<code class="du kw kx ky kz b">routes</code>目录中，我们将创建一个名为<code class="du kw kx ky kz b">notes_routes.js</code>的文件，并编写以下代码:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/e8eff0fad7d7941ed40a5ccccc75416e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hvOPn3d1Q2_PwNbax7l2PA.png"/></div></div></figure><p id="f7e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们将从一个控制器文件导入Express和四个动作函数，我们还没有制作。接下来，我们将在第6行创建一个Express路由器的实例。之后，我们将调用我们希望在该实例上路由的每个HTTP方法，首先传入可以发出请求的路径，然后传入控制器的action函数。最后，我们将导出路由器。就是这样！完成后，让我们回到我们的<code class="du kw kx ky kz b">index.js</code>并向我们的服务器提供路由。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/655cd98d303ec5b394c904db29a7a823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgbRFPSyHpgUEpI4uben_Q.png"/></div></div></figure><p id="4597" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">只需从<code class="du kw kx ky kz b">notes_routes.js</code>导入路由器，将路径作为字符串传入<code class="du kw kx ky kz b">app.use</code>的第一个参数，然后将路由器作为第二个参数传入。通过传入<code class="du kw kx ky kz b">“/notes”</code>作为<code class="du kw kx ky kz b">index.js</code>中的路径，以及我们在路由文件中设置的附加子路径，我们将能够获取的完整端点看起来类似于<code class="du kw kx ky kz b">http://localhost:5000/notes/</code>以获取所有注释并发布新注释，以及<code class="du kw kx ky kz b">http://localhost:5000/notes/id</code>以编辑特定注释并删除特定注释。我们还将在第24行创建另一个通配符路由，以便在用户碰巧遇到一个不存在的端点时返回一个错误。</p><p id="75c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">酷——现在我们已经设置好了路由，让我们构建一个控制器，这样当用户点击端点时，就会发生一些事情。</p><h1 id="4bc4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">控制器</h1><p id="5cb7" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">因此，在这一点上，我们已经知道了基于我们已经建立的路线，我们的控制器将需要哪四个动作:<code class="du kw kx ky kz b">getNotes</code>、<code class="du kw kx ky kz b">createNote</code>、<code class="du kw kx ky kz b">updateNote</code>和<code class="du kw kx ky kz b">deleteNote</code>。让我们再来看看我们是如何习惯于在Rails中处理这些动作的:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="6b32" class="li ju hi kz b fi lj lk l ll lm">def index<br/>   @notes = Note.all<br/>   render json: @notes<br/>end</span><span id="3114" class="li ju hi kz b fi lw lk l ll lm">def create<br/>   @note = Note.create(note_params)<br/>   render json: @note<br/>end</span><span id="5c49" class="li ju hi kz b fi lw lk l ll lm">def update<br/>   @note = Note.find(params[:id])<br/>   @note.update(note_params)<br/>   render json: @note<br/>end</span><span id="273d" class="li ju hi kz b fi lw lk l ll lm">def destroy<br/>   @note = Note.find(params[:id])<br/>   @note.destroy<br/>end</span></pre><p id="0581" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们将使用Mongoose在Node中处理这些相同的操作。在<code class="du kw kx ky kz b">controllers</code>内部，让我们创建一个名为<code class="du kw kx ky kz b">notes_controller.js</code>的文件并编写一些代码:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/3f3b996185b90762f37e574b5b8f8fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQDBvquTuiUGdgVT1Qdoqg.png"/></div></div></figure><p id="375d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总的想法是，每个动作将由一个异步函数组成，该函数接收请求和响应对象作为参数。请求对象是客户端在获取中设置的内容，响应是服务器返回的内容。在每个动作中，我们将使用各种Mongoose模型查询方法来查找正确的数据。在顶部，我们正在导入猫鼬，以及我们尚未创建的<code class="du kw kx ky kz b">Note</code>模型。接下来，我们将看看我们的每个行动。</p><p id="9b01" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du kw kx ky kz b">getNotes</code>中，我们运行一个try/catch块，在这里我们调用我们的<code class="du kw kx ky kz b">Note</code>模型上的<code class="du kw kx ky kz b">.find()</code>查询方法。<code class="du kw kx ky kz b">.find()</code>是由Mongoose提供的一个查询，如果没有参数传入，它将返回模型的所有实例的数组。它——以及我们将调用的其他查询中间件——是一个异步函数，这意味着我们需要在它前面去掉<code class="du kw kx ky kz b">await</code>关键字，以确保它在我们进入下一步之前完成执行。一旦完成，我们只需将响应的状态设置为200表示“OK ”,然后将注释数组呈现为JSON。如果代码块捕捉到一个错误，我们转而呈现错误消息的JSON。</p><p id="982d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kw kx ky kz b">createNotes</code>首先创建一个新的<code class="du kw kx ky kz b">Note</code>实例，将请求对象的主体作为数据传入。然后，我们运行另一个try/catch块，如果该块成功，它会将新的注释保存到我们的数据库中，并在JSON中将它作为响应返回，否则会显示一条错误消息。</p><p id="28c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，<code class="du kw kx ky kz b">updateNote</code>从请求对象参数中获取特定注释的ID，并将其别名化为<code class="du kw kx ky kz b">_id</code>，以更接近MongoDB的ID格式。然后，我们检查以确保它是一个有效的MongoDB ID，方法是将它传递给Mongoose的ObjectID类型上的一个<code class="du kw kx ky kz b">isValid()</code>调用。如果解析为false，我们将返回404错误。否则，我们在我们的<code class="du kw kx ky kz b">Note</code>模型上调用<code class="du kw kx ky kz b">findByIdAndUpdate()</code>，首先传入ID，然后传入请求体，最后传入一个options对象，其键<code class="du kw kx ky kz b">new</code>设置为<code class="du kw kx ky kz b">true</code>。一旦完成，我们将用200状态以及更新后的注释的JSON进行响应。</p><p id="b8f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，<code class="du kw kx ky kz b">deleteNote</code>将以类似的方式开始——首先从参数中获取ID，然后检查其有效性。一旦解决了这个问题，我们就调用<code class="du kw kx ky kz b">Note</code>模型上的<code class="du kw kx ky kz b">findByIdAndDelete()</code>,并传入这个ID。然后我们将呈现一个JSON响应，表示一个成功的请求。</p><p id="9e80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很好，快到了！我们将讨论的最后一件事是为我们的<code class="du kw kx ky kz b">Note</code>创建一个模型，它将把一切联系在一起。</p><h1 id="e2c6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">模型</h1><p id="ea24" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Rails中的模型、迁移和模式往往是框架工作中较为繁琐的部分。您很早就被锁定在模型设计中，对模式的任何更改都需要回滚和创建新的迁移，有时会导致错误和不必要的麻烦。使用节点和非关系数据库(如MongoDB)的一个主要优势是，您不需要从一开始就将自己束缚在任何特定的蓝图上，因此对设计进行更改要容易得多。Mongoose进一步简化了这个过程，它提供了简单易用的模式，可以在不进行任何迁移的情况下动态更新。不过，在此之前，让我们先最后看一眼Rails，看看我们是如何做到这一点的。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="b8ab" class="li ju hi kz b fi lj lk l ll lm">def change<br/>   create_table :notes do |t|<br/>      t.string :title    <br/>      t.string :content    <br/>      t.string :date    <br/>      t.string :color    <br/>      t.boolean :pinned    <br/>   end<br/>end</span></pre><p id="638b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，如果我们想要更新或删除这个模型中的任何列，我们显然必须为每个更改运行额外的迁移。使用Mongoose，我们可以创建我们的模式并直接编辑它，无需迁移。让我们在<code class="du kw kx ky kz b">models</code>中创建一个名为<code class="du kw kx ky kz b">note_model.js</code>的文件:</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/e437acbe32e8651c4332e02f4ca29768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*la29BevG83QGRerF7zMbBw.png"/></div></div></figure><p id="7b4f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这么简单。我们可以在任何需要对<code class="du kw kx ky kz b">Note</code>模型进行修改的时候到这里来修改这个模式，之后创建的任何新的note实例都会反映这些修改。</p><p id="d1e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在你知道了！我们已经使用Express和Mongoose成功地设置了一个节点后端来路由来自客户端的CRUD请求。</p><h1 id="9b7c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">零碎的东西</h1><p id="1bc2" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们在这里介绍的只是冰山一角Node还可以提供更多功能。我们几乎没有提到中间件，它可以为你的应用程序增加全新层次的功能。除此之外，我们在本指南中只描述了最基本的单一模型场景。笔记需要用户拥有怎么办？<em class="lz">活动记录！！</em>我听到你在后面喊。考虑到Node和Express最常与非关系数据库一起使用，对象所有权是一个完全不同的问题，我们不在这里讨论。如果您对真正深入环境感兴趣，我强烈推荐查看下面链接的节点文档和指南。编码快乐！</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><blockquote class="ma mb mc"><p id="0c56" class="iv iw lz ix b iy iz ja jb jc jd je jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated">参考</p><p id="5dcb" class="iv iw lz ix b iy iz ja jb jc jd je jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated"><a class="ae iu" href="https://nodejs.org/en/docs/" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> Node.js文档</em> </a></p><p id="2346" class="iv iw lz ix b iy iz ja jb jc jd je jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated"><a class="ae iu" href="https://mongoosejs.com/docs/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">獴文档</em> </a></p><p id="e35b" class="iv iw lz ix b iy iz ja jb jc jd je jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated"><a class="ae iu" href="https://www.youtube.com/watch?v=ngc9gnGgUdA&amp;list=PL6QREj8te1P7VSwhrMf3D3Xt4V6_SRkhu&amp;t=0s&amp;ab_channel=JavaScriptMastery" rel="noopener ugc nofollow" target="_blank"> <em class="hi"> JavaScript Mastery的完整栈MERN开发系列</em> </a> <em class="hi"> ||一个非常详细和有用的视频指南，从后端到前端开始使用Node、MongoDB和完整的MERN栈。强烈推荐。</em></p><p id="3944" class="iv iw lz ix b iy iz ja jb jc jd je jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated"><a class="ae iu" rel="noopener" href="/@brandon.lau86/one-to-many-relationships-with-mongodb-and-mongoose-in-node-express-d5c9d23d93c2"><em class="hi">Node/Express中与MongoDB和Mongoose的一对多关系</em> </a> <em class="hi"> ||学习Node和MongoDB应用程序中对象关系的良好起点。</em></p><p id="9e98" class="iv iw lz ix b iy iz ja jb jc jd je jf md jh ji jj me jl jm jn mf jp jq jr js hb bi translated"><a class="ae iu" href="https://www.npmjs.com/package/express-mongoose-generator" rel="noopener ugc nofollow" target="_blank"><em class="hi">Express-mongose-generator</em></a><em class="hi">| |一个NPM包，为Express/mongose应用程序提供样板生成器，很像Rails生成器。注意:这个包使用ES6 </em> <code class="du kw kx ky kz b"><em class="hi">require</em></code> <em class="hi">之前的语法。</em></p></blockquote></div></div>    
</body>
</html>