<html>
<head>
<title>Reactive Extensions in .NET Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应式延伸。网络核心</h1>
<blockquote>原文：<a href="https://medium.com/codex/reactive-extensions-in-net-core-597b594675bb?source=collection_archive---------2-----------------------#2021-05-17">https://medium.com/codex/reactive-extensions-in-net-core-597b594675bb?source=collection_archive---------2-----------------------#2021-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/312b6359d85b3681762199575c19d2d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Xz2wm1S7vBFiPWF9EBUCQ.jpeg"/></div></div></figure><p id="9b00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个快速变化的世界，事物更新很快。考虑显示股票价格、体育赛事直播比分的网站，甚至是一个视频流网站。在所有这些情况下，数据每秒都会更新。</p><p id="dd2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是你注意到什么了吗？UI中的数据不断发生变化，用户可以实时看到变化。它在后台悄无声息地发生，也不需要刷新或重新加载页面。</p><p id="c645" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是通过异步方法实现的，在异步方法中，需要等待和侦听响应数据。同时，控件被返回给用户以浏览页面。这种编程方法被称为反应式编程。并且在各种编程语言中实现反应式编程的实践是使用可用于相应编程语言的反应式扩展来完成的。</p><p id="e9d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇博客中，我们将探讨反应式扩展，以及如何在运行的C#编程语言中实现它们。网芯。</p><p id="9075" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">目录</strong></p><ol class=""><li id="21da" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">反应式编程和扩展简介</li><li id="d096" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">反应式扩展的实际实现</li><li id="0fa9" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated">结论</li></ol><h1 id="8fd4" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">反应式编程和扩展简介</h1><p id="14e0" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">反应式编程就是开发事件驱动的异步应用程序，这些应用程序可以在系统之间传递数据。这是通过创建数据流来实现的，数据流负责传递事件、消息、呼叫和故障。</p><p id="eebe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用一个例子来解释这一点。考虑两个系统——服务A和b。它们相互通信。现在，A向B发送请求，控制调用返回服务A代码(异步方法)。现在，在这两个服务之间已经建立了一个数据流(想象一条流动的水管)，并且请求的数据已经被一个接一个地发送到请求服务。该流将一直打开，直到发送完所有数据。一旦出现故障，它就会关闭。此外，它还处理对时间敏感的变量。这意味着变量的值随着其从属变量的变化而变化。</p><p id="00eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了在不同的编程语言中实现反应式编程，反应式扩展可以作为外部包以多种形式提供。因此，用户不必担心如何构建实现反应式编程的代码。相反，他们可以专注于如何最好地利用反应式编程，并从中受益。</p><h1 id="fd1e" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">反应式扩展的实际实现</h1><p id="9a05" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">在这一节中，让我们用C#代码创建一个简单的可观察实现。在这种情况下，可观察代码在控制台窗口中打印某些数据，但同时它允许用户在同一个控制台窗口中键入某些输入。</p><h2 id="1f15" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">第一步</h2><p id="fb5c" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">创建一个基于. Net Core的控制台应用程序，并为其提供一个有效的名称。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/2a90bf7c2ae65824dce7934626d62225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c-zPpt79IWnM0hMj"/></div></div></figure><h2 id="e95c" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">第二步</h2><p id="2ff4" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">创建解决方案后，文件夹结构如下所示。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/db1541b6a21e29b7caae8d5d2e1f07a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/0*Vp1TysjRcsnhtHRG"/></div></figure><p id="9261" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">program.cs文件如下所示。这是将被修改以实现我们的更改的文件。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/3f30234bbd3f3c3e6ce92aa7699853fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/0*Q74mwvsuSw82OWhl"/></div></figure><h2 id="bfaf" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">第三步</h2><p id="f420" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">右键单击项目并转到管理NuGet包。搜索反应并安装系统。反应性NuGet包。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/99e0c2f887b13244091c124d92e4e913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kMKkIS78kg02c5_p"/></div></div></figure><h2 id="f96a" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">第四步</h2><p id="234c" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">转到program.cs文件并包含using System。标题部分中的Reactive.Linq。</p><h2 id="c0e2" class="lf kd hi bd ke lg lh li ki lj lk ll km jb lm ln kq jf lo lp ku jj lq lr ky ls bi translated">第五步</h2><p id="2ac0" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">下面是需要包含在程序类中的代码。这反过来将用于实现所需的目标。</p><pre class="lu lv lw lx fd mb mc md me aw mf bi"><span id="d816" class="lf kd hi mc b fi mg mh l mi mj">class Program { ​ static void Main(string[] args) ​ { ​ Console.WriteLine("Hello! This is from PARTECH."); ​ IObservable&lt;string&gt; observable = Observable.Generate(0, iterator =&gt; (iterator &lt; 11), iterator =&gt; iterator + 1, iterator =&gt; new string('*', iterator), ​ iterator =&gt; TimeSpan.FromSeconds(iterator)); ​ using (observable.Subscribe(Console.WriteLine)) ​ { ​ Console.WriteLine("Operation Started."); ​ Console.WriteLine("Press any key to exit!!!"); ​ ​ Console.ReadLine(); ​ } ​ Console.WriteLine("Operation Ended."); ​ } }</span></pre><p id="9008" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，可观察的。生成方法来自包系统。反应包。生成方法有6个重载。我们消费接受的方法</p><ul class=""><li id="9f95" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn mk ju jv jw bi translated">循环变量的初始状态，</li><li id="a823" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn mk ju jv jw bi translated">可观察对象必须执行到的循环</li><li id="cbe2" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn mk ju jv jw bi translated">每次迭代要添加的值</li><li id="c21d" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn mk ju jv jw bi translated">每次迭代要做的操作，</li><li id="f189" class="jo jp hi is b it jx ix jy jb jz jf ka jj kb jn mk ju jv jw bi translated">可观察对象必须被执行的周期(基本上是一个调度程序)。</li></ul><figure class="lu lv lw lx fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/4fc84fcb9b74c8cd903cee1dd379bafc.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/0*7hSaiutj0ApVL43s"/></div></figure><p id="1ef6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，在上面的代码中，我们将循环的初始值设为0。代码将循环10次，每循环一次就加1。在代码中，我们将按照这样的模式添加星号——第一个循环有一个星号，第二个循环有两个星号，依此类推，直到最后一个循环有10个星号。</p><p id="d814" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">星号将出现在当前正在执行的迭代次数的间隔之后。例如，第一个星号会在一秒钟后出现，第二个星号会在两秒钟后出现，依此类推。</p><figure class="lu lv lw lx fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/2fbc6a4aa7485b9f6359304d985d8bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/0*cpQrHKOs7S5kjsTV"/></div></figure><p id="a3e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，它也为用户提供了键入任何输入数据的控件。用户不需要等到该过程完成。</p><p id="789f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，observables已经被实现，我们已经体验了它在代码中是如何工作的。除了可观察性，反应库还提供了更多。它提供了Subjects和Observer，这对于异步通信和刷新系统间的数据流也很方便。</p><h1 id="1b8d" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="5e3d" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">反应性延伸部易于消耗。Net中，它使应用程序响应更快，因为它的异步性质。开发人员使用扩展实现异步和时变数据更新变得更加容易。</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="3e52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mu">原载于</em><a class="ae mv" href="https://www.partech.nl/nl/publicaties/2021/05/reactive-extensions" rel="noopener ugc nofollow" target="_blank"><em class="mu">https://www . partech . nl</em></a><em class="mu">。</em></p></div></div>    
</body>
</html>