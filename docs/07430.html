<html>
<head>
<title>Deep Dive into Data structures using Javascript — Queue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Javascript深入研究数据结构—队列</h1>
<blockquote>原文：<a href="https://medium.com/codex/deep-dive-into-data-structures-using-javascript-queue-6976f5801bba?source=collection_archive---------19-----------------------#2022-06-14">https://medium.com/codex/deep-dive-into-data-structures-using-javascript-queue-6976f5801bba?source=collection_archive---------19-----------------------#2022-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f2b4691c4e88d99c545e263712bee649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iN-UtCecOI60mWBW.jpg"/></div></div></figure><h1 id="027d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">什么是队列？</h1><p id="8022" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">队列是一种线性数据结构，它以类似于数组的顺序存储其元素。当添加或删除元素时，它遵循一个叫做<strong class="jq hj"> FIFO </strong>的特定顺序——这是<strong class="jq hj">先进先出</strong>的缩写。</p><p id="701e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">理解/记忆队列如何使用<strong class="jq hj"> FIFO </strong>的一个简单方法是想象一个字面上的队列，换句话说，一群人在排队等候。每个新人从列表的末尾开始(排队)，第一个进入等待队列的人是第一个从队列中出来的人。所有的人遵循同样的顺序，直到没有人留下。</p><p id="cd69" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">Queue不是Javascript中的内置数据结构，但是实现一个定制的队列非常简单。</p><h1 id="19aa" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">队列剖析</h1><figure class="kr ks kt ku fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/99da3ed4e7dc49c03a127cd14a1e0ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OhfrdT8NHR9eIrVd.jpg"/></div></div></figure><p id="0d6c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">队列数据结构具有非常基本和直接的结构，它与<a class="ae kv" href="https://www.sahinarslan.tech/posts/deep-dive-into-data-structures-using-javascript-stack/" rel="noopener ugc nofollow" target="_blank">堆栈数据结构</a>非常相似——我们使用一些方法按顺序存储和管理元素。每当我们想要添加(入队)一个项目时，我们像堆栈一样添加到列表的末尾，但是当我们删除(出列)一个项目时，我们总是在列表的最开始工作，以遵循FIFO(先进先出)操作顺序。类似地，使用peek方法，我们可以快速检索队列中第一个插入的元素。队列和栈的主要区别在于我们在列表中的什么地方移除:对于队列，我们总是从开始移除，而对于栈，移除总是在最后。</p><h1 id="3ed2" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">何时使用队列</h1><p id="4ce8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们先来快速浏览一下队列中常见操作的<a class="ae kv" href="https://www.sahinarslan.tech/posts/comprehensive-big-o-notation-guide-in-plain-english-using-javascript" rel="noopener ugc nofollow" target="_blank">大O </a>:</p><figure class="kr ks kt ku fd ij er es paragraph-image"><div class="er es kw"><img src="../Images/3cb447f455513a9672c568bc3fcdbada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/0*JPEZ-G4NFCBwZpXZ.jpg"/></div></figure><p id="55de" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">当您特别希望实施FIFO(先进先出)访问规则时，队列非常有用。一个很好的例子就是任何类型的等待队伍，在那里你想要按照“先来先服务”的顺序进行操作。它可以是任何东西，从销售库存有限的产品(因此，如果只剩下一个产品，排队的第一个顾客可以得到产品)到预订约会或酒店房间。</p><p id="49d3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">与Stack类似，Queue也只有很少的方法(enqueue、dequeue和peek)。这使得能够使用FIFO(先进先出)规则来强制执行对数据的受限访问，并且很少的处理方法也会使代码更容易理解和使用。</p><p id="3636" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">您还可以有一个可选的查找/迭代器方法——但是如果您需要经常使用它，您可能会重新考虑使用数组。因为队列的主要用途不是频繁迭代，所以从概念的角度来看，它不太合适。</p><p id="1ef5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现实世界中的许多编程语言和应用程序都使用队列。一些例子是:</p><p id="4bc2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">-在<strong class="jq hj"> CPU任务调度</strong>中使用—这是一种机制，用于确定在另一个进程暂停时将使用CPU资源的进程。</p><p id="31e4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">-用于打印机-每个打印请求进入一个队列，队列中的第一个请求被执行，而其他请求被搁置。</p><ul class=""><li id="c1a2" class="kx ky hi jq b jr km jv kn jz kz kd la kh lb kl lc ld le lf bi translated">也用于BFS(广度优先搜索/遍历),用于高级数据结构，如树和图，二叉树中的级别顺序搜索，解决问题的概念，如在迷宫/矩阵中寻找最短路径和检测回文。</li></ul><h1 id="3af1" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Javascript中的队列实现</h1><p id="59f2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">可以使用<a class="ae kv" href="https://www.sahinarslan.tech/posts/deep-dive-into-data-structures-using-javascript-arrays" rel="noopener ugc nofollow" target="_blank">数组</a>或<a class="ae kv" href="https://www.sahinarslan.tech/posts/deep-dive-into-data-structures-using-javascript-linked-list" rel="noopener ugc nofollow" target="_blank">链表</a>来实现队列。链表是一个更好的选择，因为它有更好的性能和适当的时间复杂度匹配。因为我们从列表的开始处进行移除——这个动作在链表中花费了常数时间O(1)(出列的时间复杂度应该是O(1))，而由于索引移位，它在数组中花费了线性时间O(n)。每当从数组中删除一个元素时(只要它不是列表中的最后一个元素)，由于列表中的大小变化，所有后面的元素都会移动以匹配正确的索引号。</p><p id="cf15" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">另一方面，与链表版本相比，数组版本实现起来更简单，当您处理少量项目时，它也能很好地工作。因此，您也可以根据使用情形选择阵列版本，只要您确定不需要扩展您要处理的项目数量。如果您不确定，请使用链表版本——因为一旦扩展出现，性能差异将会非常大。</p><p id="7cf6" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我将在下面分享这两个实现。对于这两者，我们将使用ES6类来构建这个数据结构。以下是实现中的方法列表:</p><ul class=""><li id="e54e" class="kx ky hi jq b jr km jv kn jz kz kd la kh lb kl lc ld le lf bi translated"><code class="du lg lh li lj b">enqueue(value)</code> - <em class="lk">添加到队列末尾。</em></li><li id="3881" class="kx ky hi jq b jr ll jv lm jz ln kd lo kh lp kl lc ld le lf bi translated"><code class="du lg lh li lj b">dequeue()</code> - <em class="lk">从队列的开始处移除</em></li><li id="cba0" class="kx ky hi jq b jr ll jv lm jz ln kd lo kh lp kl lc ld le lf bi translated"><code class="du lg lh li lj b">peek()</code> - <em class="lk">检索队列中的第一个元素</em></li><li id="175d" class="kx ky hi jq b jr ll jv lm jz ln kd lo kh lp kl lc ld le lf bi translated"><code class="du lg lh li lj b">isEmpty()</code> - <em class="lk">检查队列是否为空的帮助器方法</em></li><li id="be93" class="kx ky hi jq b jr ll jv lm jz ln kd lo kh lp kl lc ld le lf bi translated"><code class="du lg lh li lj b">length()</code> - <em class="lk">查看队列长度的可选方法</em></li><li id="8c24" class="kx ky hi jq b jr ll jv lm jz ln kd lo kh lp kl lc ld le lf bi translated"><code class="du lg lh li lj b">clear()</code> - <em class="lk">清除队列的可选方法</em></li><li id="0d2c" class="kx ky hi jq b jr ll jv lm jz ln kd lo kh lp kl lc ld le lf bi translated"><code class="du lg lh li lj b">toArray()</code> - <em class="lk">可选方法以数组形式返回队列元素</em></li></ul><p id="dafa" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我希望这篇文章能帮助你理解什么是队列以及它是如何工作的！我鼓励您在自己喜欢的代码编辑器中尝试下面的实现。感谢阅读！</p><h1 id="6e44" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">使用链表的队列实现:</h1><pre class="kr ks kt ku fd lq lj lr ls aw lt bi"><span id="9cc3" class="lu ir hi lj b fi lv lw l lx ly">// Minimal Linked List implementation with: append, deleteHead and toArray (optional) methods.<br/>// To match the time complexity of O(1) on both add (enqueue) &amp; removal (dequeue) of Queue, we will be using both ends of the Linked List. Therefore we maintain both head and tail pointers.<br/><br/>class LinkedListMinimal {<br/>  constructor(value) {<br/>    this.head = null<br/>    this.tail = null<br/>    this.length = 0<br/>  }<br/>  <br/>  // add to the end of the list<br/>  append(value) {<br/>    // Initialize a newNode with value recieved and next as null.<br/>    const newNode = {<br/>      value: value,<br/>      next: null<br/>    }<br/>    <br/>    // Let's check if Linked List is empty or not first.<br/>    if (!this.head) {<br/>      // If there is no head (no elements) it is empty. In that case make the newNode as head<br/>      // since it is the only node at this point and there is no tail either,<br/>      // tail will also have the same value (both head and tail will point to same place in memory from now on):<br/>      this.head = newNode<br/>      this.tail = newNode<br/>    } else {<br/>      // If Linked List is not empty, Attach new node to the end of linked list:<br/>      this.tail.next = newNode      <br/>      this.tail = newNode<br/>    }<br/><br/>    this.length++<br/>  }<br/>  <br/>  deleteHead() {<br/>    if (!this.head) return<br/><br/>    const headVal = this.head.value<br/><br/>    // if one element left<br/>    if (this.length === 1) {<br/>      this.head = null<br/>      this.tail = null<br/>      this.length--<br/>      return headVal<br/>    }<br/><br/>    // define newHead as this.head.next<br/>    const newHead = this.head.next<br/>    // now change the head pointer to newHead<br/>    this.head = newHead<br/>    this.length--<br/>    return headVal<br/>  }<br/>  <br/>  // toArray - loop through nested objects, then return the values in an array<br/>  toArray() {<br/>    const array = []<br/>    // Initialize a currentNode variable pointing to this.head - which will be the starting point for traversal.<br/>    let currentNode = this.head<br/><br/>    // fill the array until we reach the end of list:<br/>    while (currentNode !== null) {<br/>      array.push(currentNode.value)<br/>      currentNode = currentNode.next<br/>    }<br/>    return array<br/>  }<br/>}<br/><br/>class Queue {<br/>  constructor() {<br/>    this.items = new LinkedListMinimal()<br/>  }<br/>  <br/>  // add to the end of Queue<br/>  enqueue(value) {<br/>    this.items.append(value)<br/>  }<br/>  <br/>  // remove from the beginning of Queue<br/>  dequeue() {<br/>    if (this.isEmpty()) {<br/>      return null<br/>    }<br/>    <br/>    const dequeuedItem = this.items.deleteHead()<br/>    if (!dequeuedItem) return<br/>    return dequeuedItem<br/>  }<br/>  <br/>  // retrive first element in the Queue<br/>  peek() {<br/>    if (this.isEmpty()) return null<br/>    return this.items.head.value<br/>  }<br/>  <br/>  // helper method to check if Queue is empty<br/>  isEmpty() {<br/>    return this.items.length === 0<br/>  }<br/>  <br/>  // optional method to check the length of Queue<br/>  length() {<br/>    return this.items.length<br/>  }<br/>  <br/>  // optional method to clear the Queue<br/>  clear() {<br/>    this.items = new LinkedListMinimal()<br/>  }<br/>  <br/>  // optional method returns Queue elements as an Array<br/>  toArray() {<br/>    return this.items.toArray()<br/>  }<br/>}</span></pre><h1 id="888d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">使用数组的队列实现:</h1><pre class="kr ks kt ku fd lq lj lr ls aw lt bi"><span id="e021" class="lu ir hi lj b fi lv lw l lx ly">class Queue {<br/>  constructor() {<br/>    this.items = []<br/>  }<br/>  <br/>  // add to the end of Queue<br/>  enqueue(item) {<br/>    this.items.push(item)<br/>  }<br/>  <br/>  // remove from the beginning of Queue<br/>  dequeue() {<br/>    if (this.isEmpty()) return<br/>    // This costs Linear Time O(n) instead of O(1) due to array shift:<br/>    const dequeuedItem = this.items.shift()<br/>    return dequeuedItem<br/>  }<br/>  <br/>  // retrive first element in the Queue<br/>  peek() {<br/>    if (this.isEmpty()) return<br/>    return this.items[0]<br/>  }<br/>  <br/>  // helper method to check if Queue is empty<br/>  isEmpty() {<br/>    return this.items.length === 0<br/>  }<br/>  <br/>  // optional method to check the length of Queue<br/>  length() {<br/>    return this.items.length<br/>  }<br/>  <br/>  // optional method to clear the Queue<br/>  clear() {<br/>    this.items = []<br/>  }<br/>  <br/>  // optional method returns Queue elements as an Array<br/>  toArray() {<br/>    return this.items<br/>  }<br/>}</span></pre></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="1570" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="lk">原发表于</em><a class="ae kv" href="https://www.sahinarslan.tech/posts/deep-dive-into-data-structures-using-javascript-queue" rel="noopener ugc nofollow" target="_blank"><em class="lk">https://www . sahinarslan . tech</em></a><em class="lk">。</em></p></div></div>    
</body>
</html>