<html>
<head>
<title>A Replication of “DeepBugs: A Learning Approach to Name-based Bug Detection”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">复制“深度Bug:基于名称的Bug检测的学习方法”</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-partial-replication-of-deepbugs-a-learning-approach-to-name-based-bug-detection-1e35421a69e?source=collection_archive---------11-----------------------#2021-07-19">https://medium.com/codex/a-partial-replication-of-deepbugs-a-learning-approach-to-name-based-bug-detection-1e35421a69e?source=collection_archive---------11-----------------------#2021-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/972e4fc17b4e061f1c9955a5db1ea8ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BQ8ift7_eMg2Lpm2"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">艾莉娜·格鲁布尼亚克在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="ea10" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是发表在ESEC/FSE 2021 [0]的artifact track上的研究论文“<em class="jt">‘深度Bug:基于名称的Bug检测的学习方法’</em>”的摘要。这篇论文源于我在普渡大学的课程<em class="jt"> ECE 595:高级软件工程</em>中的一个课程项目。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="fbd9" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">原始文件</h1><p id="310c" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">2018年，Pradel &amp; Sen发表了一篇名为<em class="jt"> DeepBugs </em>的论文，描述了一种软件缺陷检测工具[1]。</p><p id="5290" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Pradel &amp; Sen的目标是当软件工程师以错误的顺序使用变量时出现的软件缺陷。例如，如果有一个函数<em class="jt">calcCylinderVolume(int radius，int height) </em>被意外调用为<em class="jt">calcCylinderVolume(some height，some radius)</em>那么计算出来的体积就会不正确。</p><p id="3cac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类型检查不能解决这个问题，因为参数具有相同的类型。然而，如果您能够对嵌入在变量名中的语义进行推理，您<em class="jt">就能够</em>发现这样的缺陷——例如，名为“someHeight”的变量可能存储高度信息，而名为“someRadius”的变量存储半径信息。</p><p id="5554" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Pradel &amp; Sen假设<em class="jt">工程师通常为具有相似目的的变量使用相似的变量名</em>。(参见“最佳实践”建议[2]和“自然性假设”[3，4])。基于这一假设，对于这些交换参数的bug，他们提出了以下检测算法:</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es le"><img src="../Images/87fac04012107762ea361f35591687e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*USnItJgizYYRpBc5htpmUg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">DeepBugs将源代码转换成抽象语法树(ASTs)，然后通过Word2Vec转换成语义编码向量。神经网络确定含义是否与使用上下文相匹配。这里有个开发者用<strong class="bd kd"> setDims(y，x) </strong>为<strong class="bd kd"> setDims(width，height) </strong>写了一个函数调用。Deep-Bugs了解到<strong class="bd kd"> x </strong>和<strong class="bd kd"> width </strong>语义相似，y和height也是如此，因此它预测参数被交换。</figcaption></figure><ul class=""><li id="ea45" class="lj lk hi ix b iy iz jc jd jg ll jk lm jo ln js lo lp lq lr bi translated">使用程序的AST识别函数调用。</li><li id="439b" class="lj lk hi ix b iy ls jc lt jg lu jk lv jo lw js lo lp lq lr bi translated">提取用于每个函数调用的变量的名称。</li><li id="e968" class="lj lk hi ix b iy ls jc lt jg lu jk lv jo lw js lo lp lq lr bi translated">通过训练Word2Vec模型[5]对“<em class="jt">相似变量名</em>的概念进行数值建模，与被调用的函数的名称上下文化(例如，“someHeight”和“someRadius”在调用函数“calcCylinderVolume”的上下文中的含义)。Word2Vec模型学习通常作为第一个参数、第二个参数等等传递的变量名。</li><li id="a4f7" class="lj lk hi ix b iy ls jc lt jg lu jk lv jo lw js lo lp lq lr bi translated">使用这个Word2Vec模型来识别某些变量名“不寻常”的用法，如由训练的Word2Vec模型计算的向量所定义的。</li></ul><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/27bcd42325aef792c34c4c271cd37633.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*H06q9u2amCqxt4RgCoW93g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">在计算出Word2Vec向量后，DeepBugs算法使用一个小型神经网络作为基于名称的bug的分类器。</figcaption></figure><p id="3ff1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些不寻常的用法可以解释为(1)糟糕的变量名的例子，或者(2)缺陷。当存在多个参数时，使用异常，并且如果参数被交换，使用将变得<em class="jt">正常</em>，那么我们可能会看到一个交换参数缺陷。</p><p id="90b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我估计大多数软件工程师自己都犯过这个错误。我当然有！</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="9e8d" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">分身术</h1><p id="3d62" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">Pradel &amp; Sen的结果令人信服。然而，科学方法的一部分是<em class="jt">对外复制</em>的发现。我的团队已经开始这样做了。特别是，我们想看看我们是否可以使用相同的数据，但一个独立的实现，并获得相同的结果。</p><h2 id="ed1d" class="ly kc hi bd kd lz ma mb kh mc md me kl jg mf mg kp jk mh mi kt jo mj mk kx ml bi translated">共享依赖项</h2><p id="1f3e" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">我们确实在实现中共享了一些依赖:</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/7c25b18a23c018878c382a7bde179173.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*SWf4t6NWwL5DI1CTRuRI1A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">相同的数据集，一些共享组件，没有共享代码。</figcaption></figure><p id="1989" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Pradel &amp; Sen已经完成了决定使用何种神经网络架构的所有艰难工作。因此，我们的实现任务并不太复杂——让管道匹配才是最难的部分。</p><h2 id="72b1" class="ly kc hi bd kd lz ma mb kh mc md me kl jg mf mg kp jk mh mi kt jo mj mk kx ml bi translated">笔误</h2><p id="8a1d" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">我们误读了他们的论文，使用了200个令牌的Word2Vec窗口大小，而不是20个令牌。哎呀。</p><h2 id="77a2" class="ly kc hi bd kd lz ma mb kh mc md me kl jg mf mg kp jk mh mi kt jo mj mk kx ml bi translated">但是，稳定的结果！</h2><p id="6b76" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">即使有这种数量级的错别字，他们的方法也是稳定的。</p><figure class="lf lg lh li fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/336a0e6b8ac20cd6478b2cbbbcc1eff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*N-N9BZGk0xaDRyqxFsS0vQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">在来自150k JavaScript数据集的交换参数案例中，我们的DeepBugs复制成功地获得了与原作者的工作相似的性能。</figcaption></figure><h2 id="afc4" class="ly kc hi bd kd lz ma mb kh mc md me kl jg mf mg kp jk mh mi kt jo mj mk kx ml bi translated">部分复制</h2><p id="2cd7" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">我们将我们的工作描述为<em class="jt">部分</em>复制，因为Pradel &amp; Sen评估了他们在几种类型缺陷上的方法——我们只看了交换参数的那种。但是，我们仍然使用<em class="jt">复制</em>这个词，因为我们独立地获得了相同的主要结果。</p><h2 id="e9be" class="ly kc hi bd kd lz ma mb kh mc md me kl jg mf mg kp jk mh mi kt jo mj mk kx ml bi translated">反射</h2><p id="5dd4" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">Pradel &amp; Sen在记录他们的工作方面做得非常好，足够仔细，以至于第三方——我的团队——可以复制它。他们漏掉的一件事是他们的RNG种子。有可能是更改的种子导致了轻微的性能差异，但是我怀疑我们的Word2Vec窗口大小错误才是真正的原因。</p><p id="3b97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总的来说，我认为这是一个很好的研究生课程项目。该团队接触了软件工程工具中的一些最先进的技术，应用了他们在其他课程中学到的ML知识，完成了一次成功的科学复制，并发布了一个经过同行评审的工件。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="e63c" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">更多信息</h1><ol class=""><li id="fcfa" class="lj lk hi ix b iy kz jc la jg mo jk mp jo mq js mr lp lq lr bi translated">此处神器可用<a class="ae iu" href="https://doi.org/10.5281/zenodo.5110820" rel="noopener ugc nofollow" target="_blank">，包括源代码和</a><a class="ae iu" href="https://github.com/PurdueDualityLab/deepbugs-jr/blob/develop/paper/Deepbugs_Replication_Paper_Abstract.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>。</li></ol><h1 id="7533" class="kb kc hi bd kd ke ms kg kh ki mt kk kl km mu ko kp kq mv ks kt ku mw kw kx ky bi translated">参考</h1><p id="57c0" class="pw-post-body-paragraph iv iw hi ix b iy kz ja jb jc la je jf jg lb ji jj jk lc jm jn jo ld jq jr js hb bi translated">[0] ACM定义:<a class="ae iu" href="https://www.acm.org/publications/policies/artifact-review-and-badging-current" rel="noopener ugc nofollow" target="_blank">https://www . ACM . org/publications/policies/artifact-review-and-badging-current</a></p><p id="b3ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[1] Pradel &amp; Sen，2018年。<a class="ae iu" href="https://dl.acm.org/doi/abs/10.1145/3276517" rel="noopener ugc nofollow" target="_blank"> <em class="jt"> Deepbugs:一种基于名字的bug检测学习方法</em> </a>。</p><p id="ce20" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[2]马丁，2009年。<a class="ae iu" href="https://www.oreilly.com/library/view/clean-code-a/9780136083238/" rel="noopener ugc nofollow" target="_blank"> <em class="jt">干净的代码:敏捷软件工艺手册</em> </a>。</p><p id="d6fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[3]欣德尔等人，2016年。<a class="ae iu" href="https://dl.acm.org/doi/pdf/10.1145/2902362" rel="noopener ugc nofollow" target="_blank"> <em class="jt">关于软件的自然性</em> </a>。</p><p id="a3e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[4]阿拉马尼斯等人，2018年。<a class="ae iu" href="https://dl.acm.org/doi/pdf/10.1145/3212695" rel="noopener ugc nofollow" target="_blank"> <em class="jt">针对大代码和自然度的机器学习综述</em> </a>。</p><p id="f3c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[5] Mikolov等人，2013年。<a class="ae iu" href="http://arxiv.org/abs/1301.3781" rel="noopener ugc nofollow" target="_blank"><em class="jt"/></a><em class="jt">向量空间中单词表征的高效估计。</em></p></div></div>    
</body>
</html>