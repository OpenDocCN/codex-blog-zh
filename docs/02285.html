<html>
<head>
<title>How to start a new relationship with Scala after breaking up with Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Java分手后如何与Scala开始新的关系</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-start-a-new-relationship-with-scala-after-breaking-up-with-java-72d993017cc3?source=collection_archive---------10-----------------------#2021-07-11">https://medium.com/codex/how-to-start-a-new-relationship-with-scala-after-breaking-up-with-java-72d993017cc3?source=collection_archive---------10-----------------------#2021-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/03cf7e493b6511b55a0fcab361d4a7c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w6CgYhMCIol2MZym"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><p id="7f82" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在从事Java工作10多年后，我最近开始在新岗位上从事Scala工作。这个转变一点也不容易。</p><p id="2c0a" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这就是为什么，这个想法让我想到我应该分享我的学习，这样其他人就可以从中受益，而不会遇到我所面临的问题。</p><p id="8a83" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">事实上，很多时候我们需要做一些项目，这些项目的技术与我们的专业知识有一点点不同。java开发人员经常需要从事一些Scala项目，这似乎很常见，可能是在公司内部，也可能是在换工作的时候。由于Scala是在Java之上创建的，所以很容易(几乎)切换。但是如果我们注意到，从面向对象编程到函数式编程有一个全新的编程范式转变。在这篇文章中，我将讨论Scala的棘手之处，或者我会说是函数式编程。</p><h1 id="5f21" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">基本差异</h1><p id="25a8" class="pw-post-body-paragraph jc jd hi je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hb bi translated">在深入研究这门语言的复杂性之前，我们应该了解两者之间的基本区别。根据定义:</p><p id="1dfb" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="je hj">函数式编程</strong>是一种一切围绕函数的编程技术。这意味着，对于要执行的任何类型的任务，我们将只创建函数。</p><p id="def2" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">另一方面，<strong class="je hj">面向对象编程</strong>范式是完全基于对象的，在那里运行任何任务，你都会创建一个对象。</p><p id="85f1" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">函数式编程(FP)原则:</p><p id="b87d" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">♀<strong class="je hj">纯函数</strong>是函数式编程的精髓。这些函数的输出将保持不变，即使你调用它们无数次。换句话说，外态对纯函数没有影响，或者你可以说不会有副作用。例如:函数<code class="du ld le lf lg b">getSum(a , b)</code>将返回输入的总和，即<code class="du ld le lf lg b">a+b</code>，并且将始终产生与输出相同的总和。</p><p id="6cb7" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">不变性是FP提供的另一大优势。由于这与纯函数直接相关，所以我们总是会创建不可变的对象。与默认创建可变对象的OOP相比，它提高了应用程序的性能。</p><p id="0f46" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">并行性在FP中很容易实现，因为每个表达式都是引用透明的。例如，如果x，y和&amp; &amp;是引用透明的，那么x &amp; &amp; y将会执行，不管执行多少次，对它们都没有(副作用),因此这将使它们并行化变得很容易。</p><p id="6dae" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">让我们来谈谈Scala新手在学习时需要记住的一些要点:</p><h1 id="547c" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">一切都是表达</h1><p id="4b0c" class="pw-post-body-paragraph jc jd hi je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hb bi translated">在Scala中，一切都是表达式，不像Java，在Java中你有一个不会返回任何东西的代码块。比如:Java中的“if else”块只是一个块，不会返回任何东西。</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="6f89" class="lp kb hi lg b fi lq lr l ls lt">if(isThisReallyTrue) // Please do something</span><span id="f7a4" class="lp kb hi lg b fi lu lr l ls lt">else //don’t do anything</span></pre><p id="024e" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">但在Scala中,“if else”块本身就是一个表达式，将返回某种值。例如:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="0ba5" class="lp kb hi lg b fi lq lr l ls lt">if(matchRegex) str = “abc”</span><span id="3812" class="lp kb hi lg b fi lu lr l ls lt">else str = “”</span></pre><p id="4ca9" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在上面的例子中，你可以将结果存储到一个val中并使用它。</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="851c" class="lp kb hi lg b fi lq lr l ls lt">val x: String = if(matchRegex) str = “abc” else str = “”</span></pre><h1 id="ec34" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">Scala中的纯函数</h1><p id="6896" class="pw-post-body-paragraph jc jd hi je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hb bi translated">让我们看看如何在Scala中定义纯函数:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="cf07" class="lp kb hi lg b fi lq lr l ls lt">def toUpper(str:String) :String = str.toUpperCase()</span></pre><p id="0ae2" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">上面的方法会将小写字符串转换成大写。因此，无论你调用这个函数多少次，输出都不会修改字符串。</p><p id="99b9" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="je hj">引用透明性</strong>是一个表达式，如果它可以被它的值替换并且不改变它的行为。这是纯函数的一个重要性质，因为函数<code class="du ld le lf lg b">f</code>只有在<code class="du ld le lf lg b">f(x)</code>的表达式对于x的每个值都是参照透明的情况下才是纯的。</p><p id="0672" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">就拿这个表达式来说:<code class="du ld le lf lg b">arg + (4–2)</code>是指称透明的，因为它可以用<code class="du ld le lf lg b">arg + 2</code>来代替。</p><p id="04e8" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这在性能方面起着重要的作用，因为表达式是在编译时计算的，在运行时可以节省几个周期。</p><h1 id="0b52" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">Scala如何实现不变性</h1><p id="449e" class="pw-post-body-paragraph jc jd hi je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hb bi translated">Scala更喜欢不可变的代码，这可能会迫使程序员思考以不可变的方式编写代码。默认情况下，Scala中的集合是不可变的。用Scala的函数式编程写的一句名言:</p><blockquote class="lv lw lx"><p id="25eb" class="jc jd ly je b jf jg jh ji jj jk jl jm lz jo jp jq ma js jt ju mb jw jx jy jz hb bi translated">首选val、不可变对象和没有副作用的方法。先伸手去拿。当你有特定的需要和理由时，使用变量、可变对象和有副作用的方法。</p></blockquote><p id="6977" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">让我们来谈谈Java，如果你需要让你的变量不可变，那么你需要让它成为最终变量。一个java方法会这样写:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="f4ab" class="lp kb hi lg b fi lq lr l ls lt">public void doSomething(Person person) { // TODO something}</span></pre><p id="b75b" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">现在，您可以将Person作为最终结果，如下所示:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="1ede" class="lp kb hi lg b fi lq lr l ls lt">public void doSomething(final Person person)</span></pre><p id="db04" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">但是在Scala中，如果你只是传递参数，默认情况下它是val，相当于final。在Scala中，你可以这样定义方法:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="7cd9" class="lp kb hi lg b fi lq lr l ls lt">def doSomething(person: Person) : Unit = // TODO something</span></pre><p id="a492" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">默认情况下，这个person对象是有值。</p><p id="ed64" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">让我们来谈谈集合以及如何在Scala中操作它。</p><p id="a81f" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">默认情况下，Scala的集合类如<code class="du ld le lf lg b">Set, Map, List, Seq</code>是不可变的，而在Java中它们是可变的。创建any集合类的新实例时，不能直接修改它。</p><p id="d86e" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">有一个常见的场景，几乎每个人都在他们的项目中使用它来动态更新定制对象的列表。</p><p id="86cc" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">例如，创建一个<code class="du ld le lf lg b">List&lt;Person&gt; objects</code></p><p id="13da" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在Java中，我们会这样做:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="c05a" class="lp kb hi lg b fi lq lr l ls lt">List&lt;Person&gt; personList = new ArrayList&lt;&gt;();</span><span id="fb51" class="lp kb hi lg b fi lu lr l ls lt">for(x: someOtherCollectionObject){<br/>  Person p = new Person();<br/>   p.setName(x.name);<br/>   personList.add(p);</span><span id="421e" class="lp kb hi lg b fi lu lr l ls lt">}</span></pre><p id="a9d1" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">但是你不能在Scala中使用相同的语法，因为它是一个不可变的列表。虽然，您也可以显式地创建可变列表并实现上面的语法(以Scala的方式)，但是您会发现可变包的使用在项目中是禁用的，并且是非常不鼓励的。</p><p id="d812" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这可以通过功能图来解决。现在，Scala中的每个集合都有三个基本方法:<code class="du ld le lf lg b">map, flatmap, filter</code>这是极其有用的。</p><p id="bd71" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">因此，新的语法将是:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="3c43" class="lp kb hi lg b fi lq lr l ls lt">Val personList: List&lt;Person&gt; = someOtherCollectionObject.map( ele =&gt; {<br/>  Person( name = obj.name)<br/>})</span></pre><p id="b5c8" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">从上面的例子中你可以看到，在Scala中，for(或while)循环的使用是必须的，也是不鼓励的。Scala(函数式编程)将为不同的用例提供不同的方法，这有助于消除像(索引越界等)这样的<a class="ae iu" href="https://en.wikipedia.org/wiki/Off-by-one_error" rel="noopener ugc nofollow" target="_blank">差一个的错误</a>。</p><h1 id="c55e" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">Scala中的并发性</h1><p id="39fb" class="pw-post-body-paragraph jc jd hi je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hb bi translated">Scala为并发性提供了极好的支持。上面提到的两点(纯度、不变性)是实现健壮并发的关键。让我们看看如何:</p><p id="917b" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">由于集合的不变性，在多个线程之间共享数据是不可能的，程序员不必担心并发问题。</p><p id="9833" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">不像在java中，如果你需要解决这个问题，你需要付出很多努力来实现它(线程同步，线程安全收集)。</p><p id="56b7" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="je hj">期货</strong>就像在后台做任何任务一样。一个简单的未来可以这样写:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="fdaf" class="lp kb hi lg b fi lq lr l ls lt">val future = Future (println(“Print first future”))</span></pre><p id="e55d" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">现在这个未来将被立即解决，这不会使它变得纯粹，因为它有副作用。因此，为了使它更纯粹，我们可以使用一个名为Cats的库，它提供了一个名为IO Monad的具体工具，该工具将使这种未来懒惰得到评估，并且根据需要，您可以解决它。所以，用木卫一来概括:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="96af" class="lp kb hi lg b fi lq lr l ls lt">for {<br/>_ &lt;- IO.fromFuture(IO(<br/>    Future(println(“Print first future”)))<br/>} yield{}</span></pre><p id="caf6" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">Scala中还有其他选项可以实现并发。但是讨论超出了本文的范围。</p></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h2 id="e67e" class="lp kb hi bd kc mc md me kg mf mg mh kk jn mi mj ko jr mk ml ks jv mm mn kw mo bi translated">结论</h2><p id="108c" class="pw-post-body-paragraph jc jd hi je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hb bi translated">总之，我提到的这些提示只是冰山一角，在海洋深处还有更多值得挖掘的地方。但是以上几点在你的日常开发中使用频率非常高。Scala必须提供更强大的特性，比如模式匹配、自然的代码编写方式(+，-可以是有效的函数名)、更面向数学的风格等等。</p><p id="30f6" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><strong class="je hj">免责声明</strong>:作为一个Scala新手，我已经尽我所知写了这些指针。请随时分享您的专家建议和意见。</p><p id="0381" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">如果你喜欢这篇文章，请为它鼓掌。随着我在Scala上的进一步工作，这将激励我分享更多的经验。</p></div></div>    
</body>
</html>