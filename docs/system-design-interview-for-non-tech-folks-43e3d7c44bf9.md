# 系统设计面试问题介绍

> 原文：<https://medium.com/codex/system-design-interview-for-non-tech-folks-43e3d7c44bf9?source=collection_archive---------10----------------------->

## 能够从高层次看到全局是在科技行业任何职位取得成功所需的技能。

系统设计问题旨在测试你解决问题的能力。让我们解决不同领域的问题，从垃圾邮件、存储、延迟到设计整个系统。

# 问题 1—垃圾邮件检测

人们正在跨网站复制内容。让我们假设我们是谷歌搜索网页垃圾团队的一员。我们如何**检测重复网站**？我们将试图确定哪一个是原件，哪一个是复制品。

1.**对内容应用哈希函数( *#* )** :后续内容相似的页面是重复的。

**风险:**谷歌可能会错误地将重复页面索引到原始页面之前。

2.内容以**最散列的入站链接**为原创。

**风险:**不良行为者可以通过夸大入站链接的数量来欺骗系统。

3.**给页面嵌入唯一 ID:**后面没有唯一 ID 但内容相同的页面是重复的。

**风险:**这将需要网站管理员的额外工作。因此，我们可能无法获得 100%的合规性。

4.**比较相似网页的时间戳:**假设较早的那个是原始的。

**风险:**网络管理员可以伪造早期时间戳。

5.因素**域名信誉**。众所周知，抄袭原创内容的域名会受到处罚。

**风险:**这可能需要手动干预，既慢又费钱。

考虑到利弊，我们可以应用以下解决方案:**具有唯一 ID 的散列函数。**

# **问题 2 —减少 Gmail 的邮件存储容量**

Gmail 至少有 4 种不同的方式可以节省存储空间。让我们描述每一个，并讨论每一个的利弊。

**1。压缩**

应用压缩算法或在压缩前连接邮件。

缺点:这会使邮件访问速度变慢。

缓解:有选择地/聪明地选择要压缩的邮件。

**2。删除**

自动删除邮件。

反对意见:自动删除邮件有悖于 Gmails 营销。

**缓解:**一定天数后自动删除邮件或使用 AI 智能确定可能永远不需要的邮件。

**3。单项存储**

保留多封邮件中包含的电子邮件、图像和附件的单一副本。

**4。客户端存储**

在客户端机器上存储一些邮件(类似 WhatsApp)。

缺点:用户无法在不同的机器上访问所有的邮件。

**缓解:**有选择地/聪明地选择邮件存储在客户机本地。

**5。场外存储**

我们可以将一些邮件存储在异地存储设备上，这要便宜得多。

缺点:这会降低邮件的访问速度。

**缓解:**有选择地/聪明地选择邮件存放在异地。

我们还可以根据 Gmail 用户/客户的类型及其使用案例/问题来确定存储缩减策略。

# **问题 3—解决服务器瓶颈**

如果您有一个应用程序运行在存储客户保险信息的服务器上，并且您的同事想要访问和更新这些文档。尽管如此，他们抱怨等待时间长和网络中断。

![](img/6d5bac80d07c9bf9ed5cfbcc1a776dca.png)

**响应时间慢的原因:**

*   **网络:**网络延迟可能是由数据中心或最终用户位置的网络连接缓慢或过载造成的。缓慢的互联网主干也可能是网络延迟的原因。
*   **服务器:**服务器延迟是由缓慢的处理器和低效的服务器硬件架构造成的。
*   **存储:**存储延迟是由性能缓慢的存储设备造成的。固态硬盘和内存解决方案可提供更高的性能。
*   **数据库:**当应用程序频繁访问数据库时，会出现数据库(DB)延迟。数据库延迟在存储二进制数据时尤其具有挑战性，因为数据库是用来存储关系数据的。
*   **应用程序延迟:**如果出现以下情况，应用程序会非常慢:
*   他们使用次优的数据结构和糟糕的算法。
*   它们运行在没有针对最新硬件进行优化的操作系统上。
*   如果出现死锁情况。

假设 IT 团队已经排除了网络、服务器、存储和应用程序延迟。他们已经将其隔离到数据库延迟。

**怎么解决？**

1.为我们的应用程序使用不同的后端。许多公司现在使用 MongoDB 等 NoSQL 解决方案来存储非关系数据。

2.将我们的二进制数据迁移到存储在文件系统或 SAN/NAS 存储上的文档中。这最大限度地减少了数据库行程和数据库延迟。

3.利用内存中的分布式缓存。这将通过针对读取操作优化的缓存系统来减轻数据库流量。

# 问题 4—设计一个博客应用程序

最后，让我们设计一个博客网站的数据模型和关键功能。

![](img/391156f95fde75798c8a58df1ff10883.png)

**数据模型**

**博文数据模型:**

*   *博文编号*
*   *博客作者的电子邮件*
*   *标题*
*   *内容*
*   *日期*

**评论数据模型:**

*   *评论号*
*   *评论作者的邮箱*
*   *标题*
*   *内容*
*   *日期*

**功能**

*   *GetAllPosts()*
*   *ShowAllPosts()*
*   *GetSinglePost()*
*   *GetComments()*
*   *ShowSinglePost()*
*   *AddComment()*
*   *AddNewPost()*

让我们走一遍所有这些是如何结合在一起的，也就是说，走一遍用户输入与程序每个部分的交互:

*   用户访问博客主页。这调用了 *GetAllPosts()* ，它按时间倒序获取最后 10 篇博文。
*   检索到数据后， *ShowAllPosts()* 将信息放在适当的视图中，包括呈现在用户浏览器中的 HTML。
*   用户可以点击查看特定的博客文章。这将调用 *GetSinglePost()* 和一个子例程 *GetComments()* ，该子例程从数据库中检索特定的博客文章和评论。
*   一旦检索到数据， *ShowSinglePost()* 就会将信息放到适当的视图中。
*   如果用户决定添加评论，它调用 *AddComment()* ，在适当的认证之后，将作者的评论保存到数据库中。
*   如果用户决定添加一个新的博客，它调用 *AddNewPost()* ，在适当的认证之后，将作者的博客保存到数据库中。