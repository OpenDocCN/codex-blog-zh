<html>
<head>
<title>Git: what is it anyway?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">吉特:这到底是什么？</h1>
<blockquote>原文：<a href="https://medium.com/codex/git-what-is-it-anyway-7fe34d40ae0e?source=collection_archive---------7-----------------------#2021-03-05">https://medium.com/codex/git-what-is-it-anyway-7fe34d40ae0e?source=collection_archive---------7-----------------------#2021-03-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="50af" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><div class=""><h2 id="a4d1" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">git内部是如何工作的，为什么这么棒？</h2></div><p id="99c3" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们喜欢GIT。我们爱GIT。因为它每天能拯救我们的生命和时间几十次，让我们快乐:)</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/3921bf2c312182828f0320b0ee621543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YgKRI2EIDeZIlqdD"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">照片由<a class="ae ks" href="https://unsplash.com/@yancymin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yancy Min </a>在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="779b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们一直在<strong class="ji hs"> git pull </strong> ing和<strong class="ji hs"> git push </strong> ing，以及<strong class="ji hs"> merg </strong> ing和<strong class="ji hs"> commit </strong> ting，等等……但是，等等！它实际上是如何工作的？</p><h1 id="f49e" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">git的核心是什么？</h1><p id="3dd5" class="pw-post-body-paragraph jg jh hi ji b jj ll is jl jm lm iv jo jp ln jr js jt lo jv jw jx lp jz ka kb hb bi translated">嗯，GIT只是一个持久的hashmap:你给他一个对象，他给你一个对应于那个对象的hash。就是这样。很简单，对吧？</p><pre class="kd ke kf kg fd lq lr ls lt aw lu bi"><span id="502b" class="lv ku hi lr b fi lw lx l ly lz">$ echo "something" | git hash-object --stdin<br/>deba01fc8d98200761c46eb139f11ac244cf6eb5</span></pre><p id="e3f7" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">GIT一直在这样做:它读取内容，存储内容，并基于内容生成散列<strong class="ji hs">。</strong></p><p id="c72f" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这意味着<strong class="ji hs">相同的生成哈希==相同的内容</strong>。这是<em class="ma">非常非常重要的</em>，因为git不喜欢重复，而<em class="ma">从不</em>多次存储具有相同内容(和相同散列)的对象。</p><p id="6085" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">好吧，但是这些<em class="ma">物体</em>到底是什么？</p><p id="b28f" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">对象是一段内容:它可以是文件的内容，也可以是目录结构。对象是git可以存储的任何东西。</p><p id="90dd" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">让我们尝试将字符串“something”存储到GIT中。</p><pre class="kd ke kf kg fd lq lr ls lt aw lu bi"><span id="3ea3" class="lv ku hi lr b fi lw lx l ly lz">$ echo "something" | git hash-object --stdin -w<br/>fatal: Not a git repository (or any of the parent directories): .git</span></pre><p id="7024" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">一个错误…太好了！</p><p id="e3d7" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">git抱怨这个文件夹“不是一个GIT存储库”。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es mb"><img src="../Images/22ed6f63d92da0e7af75e00731f9cb0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ed8qASJnG_qkKYTIINYVAg.jpeg"/></div></figure><h1 id="9b78" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">什么是git存储库？</h1><p id="ae39" class="pw-post-body-paragraph jg jh hi ji b jj ll is jl jm lm iv jo jp ln jr js jt lo jv jw jx lp jz ka kb hb bi translated">嗯，GIT存储内容，所以，从某种角度来说，GIT是一个文件系统。和其他文件系统一样，它也需要初始化。</p><pre class="kd ke kf kg fd lq lr ls lt aw lu bi"><span id="5a44" class="lv ku hi lr b fi lw lx l ly lz">$ git init<br/>Initialized empty Git repository</span></pre><p id="de4b" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">与其他文件系统不同，GIT使用文件来存储对象，这不是磁盘上的底层结构，但非常相似。</p><p id="acd7" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">现在我们已经初始化了GIT存储库，我们准备好存储对象了:</p><pre class="kd ke kf kg fd lq lr ls lt aw lu bi"><span id="08b6" class="lv ku hi lr b fi lw lx l ly lz">$ echo "something" | git hash-object --stdin -w<br/>deba01fc8d98200761c46eb139f11ac244cf6eb5</span></pre><p id="b1e5" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">已存储。万岁！</p><p id="cde7" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">现在我们需要一种方法来检索那个对象。这很简单:</p><pre class="kd ke kf kg fd lq lr ls lt aw lu bi"><span id="0517" class="lv ku hi lr b fi lw lx l ly lz">$ git cat-file -p deba01f<br/>something</span></pre><p id="a880" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">git cat-file是一个强大的文件。与标志<code class="du mc md me lr b">-p</code>一起使用，它打印对象并退出，但是我们可以使用标志<code class="du mc md me lr b">-t</code>向它询问对象的类型。在这种情况下，它会回答说该对象属于类型<code class="du mc md me lr b">blob</code>，一个二进制大对象，一个用户内容。</p><p id="0751" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">是的，是的，你是对的:以这种方式存储和检索对象是非常不舒服的，而且我们没有对任何东西进行版本控制。我们需要更简单的东西…</p><p id="150e" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">哦，我有主意了！让我们把文件转换成对象！</p><p id="4268" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">太好了！我们还可以存储文件夹和所有的文件树！让我们开始吧。</p><pre class="kd ke kf kg fd lq lr ls lt aw lu bi"><span id="86be" class="lv ku hi lr b fi lw lx l ly lz">$ echo "something" &gt; README</span></pre><p id="ed85" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">好了，我已经创建了一个文件，现在呢？让我们问一下GIT(使用<strong class="ji hs"> git状态</strong>)</p><pre class="kd ke kf kg fd lq lr ls lt aw lu bi"><span id="4917" class="lv ku hi lr b fi lw lx l ly lz">$ git status<br/>On branch master</span><span id="ff00" class="lv ku hi lr b fi mf lx l ly lz">Initial commit</span><span id="d3fa" class="lv ku hi lr b fi mf lx l ly lz">Untracked files:<br/>  (use "git add &lt;file&gt;..." to include in what will be committed)</span><span id="ef83" class="lv ku hi lr b fi mf lx l ly lz">    README</span><span id="beba" class="lv ku hi lr b fi mf lx l ly lz">nothing added to commit but untracked files present (use "git add" to track)</span></pre><p id="10fe" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">哇哦。嘿，等等。那是什么？什么是提交？一根树枝？我们在说什么？</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es mg"><img src="../Images/0ad366e71566aee6b0900e00bfe9e041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*-bE0eswzlP21-uuuky2X5g.jpeg"/></div></figure><h1 id="38df" class="kt ku hi bd kv kw kx ky kz la lb lc ld ix le iy lf ja lg jb lh jd li je lj lk bi translated">承诺</h1><p id="e4c4" class="pw-post-body-paragraph jg jh hi ji b jj ll is jl jm lm iv jo jp ln jr js jt lo jv jw jx lp jz ka kb hb bi translated">我们稍后会谈到分支；对于提交是什么，我可以告诉你，这是创建提交时文件和文件夹所处状态的快照。</p><p id="0059" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">因此，我们这里需要的是创建一个提交。</p><p id="8ec1" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">Git使用两个阶段的过程来创建提交:在第一个阶段中，它将文件的快照创建到他的“暂存区”中，在第二个阶段中，它将这些快照存储到一个提交对象中。</p><p id="e4ac" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">做起来比说起来容易:让我们将自述文件添加到临时区域</p><pre class="kd ke kf kg fd lq lr ls lt aw lu bi"><span id="92b9" class="lv ku hi lr b fi lw lx l ly lz">$ git add README<br/>$ git status<br/>On branch master</span><span id="0d67" class="lv ku hi lr b fi mf lx l ly lz">Initial commit</span><span id="1315" class="lv ku hi lr b fi mf lx l ly lz">Changes to be committed:<br/>  (use "git rm --cached &lt;file&gt;..." to unstage)</span><span id="b6cd" class="lv ku hi lr b fi mf lx l ly lz">new file: README</span></pre><p id="b841" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">好，补充！<code class="du mc md me lr b">git status</code>显示文件已经被添加到stage中(“Changes to commit”听起来不错，对吧？)</p><p id="badb" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">让我们保存这些更改:</p><pre class="kd ke kf kg fd lq lr ls lt aw lu bi"><span id="4744" class="lv ku hi lr b fi lw lx l ly lz">$ git commit -m "Added README"<br/>[master (root-commit) aeb27a2] Added README<br/>1 file changed, 1 insertion(+)<br/>create mode 100644 README</span></pre><p id="0dd5" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">干得好！我们已经创建了第一个提交！但是…你能看到吗？<code class="du mc md me lr b">aeb27a2</code>似乎是一个对象哈希。</p><p id="d606" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">让我们看看里面有什么！</p><pre class="kd ke kf kg fd lq lr ls lt aw lu bi"><span id="4494" class="lv ku hi lr b fi lw lx l ly lz">$ git cat-file -p aeb27a2<br/>tree a8986e4af597c38dd3bb1ec08bea46cb123a929e<br/>author Alessandro Chitolina &lt;alekitto@gmail.com&gt; 1614506381 +0100<br/>committer Alessandro Chitolina &lt;alekitto@gmail.com&gt; 1614506381 +0100</span><span id="8064" class="lv ku hi lr b fi mf lx l ly lz">Added README</span></pre><p id="7f6c" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">“添加自述文件”是我几分钟前刚刚写的，但其他信息呢？</p><p id="05a8" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">“作者”和“提交者”看起来很简单:那就是我。并且该数字必须是创建提交时的时间戳。</p><p id="86d5" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">但是“树”呢？似乎是一个物体…好吧，让我们检查一下！</p><pre class="kd ke kf kg fd lq lr ls lt aw lu bi"><span id="3f4f" class="lv ku hi lr b fi lw lx l ly lz">$ git cat-file -p a8986e4af597c38dd3bb1ec08bea46cb123a929e<br/>100644 blob deba01fc8d98200761c46eb139f11ac244cf6eb5 README</span></pre><p id="70bd" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">惊喜惊喜！树是GIT上的“文件夹”表示。只有一个名为“README”的文件，存储为对象<code class="du mc md me lr b">deba01fc8d98200761c46eb139f11ac244cf6eb5</code>(我以前听过这个数字，对吧？)，拥有权限<code class="du mc md me lr b">100644</code>(或者只是<code class="du mc md me lr b">0644</code>)和类型<code class="du mc md me lr b">blob</code>(“二进制大对象”的首字母缩写，所以它是一个具有<em class="ma">真实</em>内容的文件)。</p><p id="85ec" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">现在，我们可以通过新的提交来创建和添加更多的文件(或文件夹)，或者修改现有的文件，但是即使在这种情况下，这个<code class="du mc md me lr b">commit</code>对象也将保持不变，并且将总是包含具有相同文件表示的相同树对象指针，这将确保不会及时丢失任何数据。</p><p id="8ec4" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">第一部分结束。在第二部分，我将和你谈谈分支，远程和一些有用的git命令。</p><p id="efa8" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">感谢阅读。<br/>答</p></div></div>    
</body>
</html>