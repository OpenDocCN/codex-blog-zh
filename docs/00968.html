<html>
<head>
<title>Flutter Navigator 2.0 for Authentication and Bootstrapping — Part 4: Bootstrapping</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于认证和引导的Flutter Navigator 2.0第4部分:引导</h1>
<blockquote>原文：<a href="https://medium.com/codex/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-4-bootstrapping-6ff60c845331?source=collection_archive---------1-----------------------#2021-03-28">https://medium.com/codex/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-4-bootstrapping-6ff60c845331?source=collection_archive---------1-----------------------#2021-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="b0d0" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><figure class="ev ex ip iq ir is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es io"><img src="../Images/d5a2fb85b560a96da6e83db9c9e5ad21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ze9Ubp_OgPxB6IxX0-AR1Q.png"/></div></div></figure><ul class=""><li id="2708" class="iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated"><a class="ae jr" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-1-introduction-d7b6dfdd0849" rel="noopener">第一部分:简介</a></li><li id="485c" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated"><a class="ae jr" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-2-user-interaction-5dc043e7e44a" rel="noopener">第二部分:用户互动</a></li><li id="3187" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated"><a class="ae jr" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-3-authentication-93dbcb5f0f0a" rel="noopener">第三部分:认证</a></li><li id="4e03" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated"><strong class="jb hs">第4部分:引导</strong></li><li id="29b0" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated"><a class="ae jr" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-5-web-eeb4835804df" rel="noopener">第五部分:网络</a></li></ul><p id="d2a9" class="pw-post-body-paragraph jx jy hi jb b jc jd jz ka je jf kb kc jg kd ke kf ji kg kh ki jk kj kk kl jm hb bi translated">在本系列的第三部分<a class="ae jr" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-3-authentication-93dbcb5f0f0a" rel="noopener">中，我们探索了带有认证用例的Navigator 2.0 API。在本文中，我们处理<strong class="jb hs">引导过程</strong>并相应地构建导航栈。</a></p><figure class="kn ko kp kq fd is er es paragraph-image"><div class="er es km"><img src="../Images/48443e2415c014c99c3fa8865d3fee8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*0y-F5tBoVHLPY_iEWNrmRQ.jpeg"/></div></figure><p id="2c11" class="pw-post-body-paragraph jx jy hi jb b jc jd jz ka je jf kb kc jg kd ke kf ji kg kh ki jk kj kk kl jm hb bi translated">让我们从阐明我所说的自举是什么意思开始。据<a class="ae jr" href="https://techterms.com/definition/bootstrap" rel="noopener ugc nofollow" target="_blank"><em class="kr"/></a><em class="kr"/>网站:</p><blockquote class="ks kt ku"><p id="2253" class="jx jy kr jb b jc jd jz ka je jf kb kc kv kd ke kf kw kg kh ki kx kj kk kl jm hb bi translated">…自举是启动计算机时发生的启动过程…虽然自举通常与系统<a class="ae jr" href="https://techterms.com/definition/bootsequence" rel="noopener ugc nofollow" target="_blank">引导序列</a>相关联，但它也可以由单个应用程序使用。例如，一个程序在打开时可能会自动运行一系列命令。这些命令可以处理用户设置、检查更新和加载动态库...它们被认为是引导进程，因为它们在程序启动时自动运行。</p></blockquote><p id="8ec0" class="pw-post-body-paragraph jx jy hi jb b jc jd jz ka je jf kb kc jg kd ke kf ji kg kh ki jk kj kk kl jm hb bi translated">在许多应用中，当应用启动时，首先检查认证状态。如果用户登录，应用程序通过从本地和远程数据源获取用户数据来做好准备。通常，闪屏会一直显示给用户，直到应用程序准备好。在本文中，我们将重点放在从应用程序启动开始的屏幕导航，直到应用程序显示带有用户特定数据的主屏幕。</p><figure class="kn ko kp kq fd is er es paragraph-image"><div class="er es ky"><img src="../Images/d9c79cf18465b06679fe62f6e9da91e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/1*a23m0ms36t7IijmVYLei-w.gif"/></div></figure><h2 id="3fd2" class="kz la hi bd lb lc ld le lf lg lh li lj jg lk ll lm ji ln lo lp jk lq lr ls ho bi translated">颜色仓库</h2><p id="9a29" class="pw-post-body-paragraph jx jy hi jb b jc lt jz ka je lu kb kc jg lv ke kf ji lw kh ki jk lx kk kl jm hb bi translated">在前面的示例中，颜色列表是从Flutter的<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/material/Colors-class.html" rel="noopener ugc nofollow" target="_blank">Colors</a></code>类中直接访问的。在这个示例中，我们在引导过程中异步访问来自<code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/data/colors_repository.dart" rel="noopener ugc nofollow" target="_blank">ColorsRepository</a></code>类的颜色。<code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/data/colors_repository.dart#L22" rel="noopener ugc nofollow" target="_blank">fetchColors()</a></code>方法从<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/material/Colors-class.html" rel="noopener ugc nofollow" target="_blank">Colors</a></code>类返回相同的颜色列表，延迟3秒。</p><p id="de8b" class="pw-post-body-paragraph jx jy hi jb b jc jd jz ka je jf kb kc jg kd ke kf ji kg kh ki jk kj kk kl jm hb bi translated">通常，存储库模式用于抽象数据访问。因此，我们不应该在这里实现数据访问逻辑。然而，在我们的例子中，我们在存储库类中实现了数据访问逻辑，以便用更少的代码进行简单的解释，并且更加关注实际的主题。</p><figure class="kn ko kp kq fd is"><div class="bz dy l di"><div class="mc md l"/></div></figure><h2 id="b8e5" class="kz la hi bd lb lc ld le lf lg lh li lj jg lk ll lm ji ln lo lp jk lq lr ls ho bi translated">该应用程序</h2><p id="6021" class="pw-post-body-paragraph jx jy hi jb b jc lt jz ka je lu kb kc jg lv ke kf ji lw kh ki jk lx kk kl jm hb bi translated">当应用程序启动时，<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件被实例化，并位于应用程序小部件树的顶部，与前面的示例一样。在这个示例中，我们使用<a class="ae jr" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank"> <em class="kr">提供者状态管理模式</em> </a>，通过<code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/viewmodels/colors_view_model.dart" rel="noopener ugc nofollow" target="_blank">ColorsViewModel</a></code>和<code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/viewmodels/auth_view_model.dart" rel="noopener ugc nofollow" target="_blank">AutViewModel</a></code>类将<code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/data/colors_repository.dart" rel="noopener ugc nofollow" target="_blank">ColorsRepository</a></code>和<code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/data/auth_repository.dart" rel="noopener ugc nofollow" target="_blank">AuthRepository</a></code>一起注入到app中。</p><figure class="kn ko kp kq fd is"><div class="bz dy l di"><div class="mc md l"/></div></figure><h2 id="5b57" class="kz la hi bd lb lc ld le lf lg lh li lj jg lk ll lm ji ln lo lp jk lq lr ls ho bi translated">路由器授权</h2><p id="2a82" class="pw-post-body-paragraph jx jy hi jb b jc lt jz ka je lu kb kc jg lv ke kf ji lw kh ki jk lx kk kl jm hb bi translated">颜色状态列表与<code class="du ly lz ma mb b">_loggedIn</code>、<code class="du ly lz ma mb b">_selectedColorCode</code>和<code class="du ly lz ma mb b">_selectedShape</code>状态一起保存在<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>类的<code class="du ly lz ma mb b">_colors</code>属性中。</p><figure class="kn ko kp kq fd is"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="01b9" class="pw-post-body-paragraph jx jy hi jb b jc jd jz ka je jf kb kc jg kd ke kf ji kg kh ki jk kj kk kl jm hb bi translated">让我们看看初始化<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>类时会发生什么:</p><ul class=""><li id="56a9" class="iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated"><code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>向<code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/data/auth_repository.dart" rel="noopener ugc nofollow" target="_blank">AuthRepository</a></code>询问认证状态，并等待直到接收到结果。</li><li id="74bc" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated">同时，<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小工具调用<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>的<code class="du ly lz ma mb b">build</code>方法，<code class="du ly lz ma mb b">SplashScreen</code>获取<em class="kr">检查登录状态</em>显示给用户，如前文所述。</li><li id="998d" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated">当收到认证状态时，<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>通知<code class="du ly lz ma mb b">_loggedIn</code>的setter方法内的<code class="du ly lz ma mb b">Router</code>小部件。</li><li id="c3ea" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated"><code class="du ly lz ma mb b">Router</code>小部件要求<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>相应地构建导航栈。</li></ul><p id="88d9" class="pw-post-body-paragraph jx jy hi jb b jc jd jz ka je jf kb kc jg kd ke kf ji kg kh ki jk kj kk kl jm hb bi translated"><em class="kr">如果用户已经登录</em></p><ul class=""><li id="28e9" class="iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">从<code class="du ly lz ma mb b">RouterDelegate</code>和<code class="du ly lz ma mb b">SplashScreen</code>的<code class="du ly lz ma mb b">build</code>方法返回带有<code class="du ly lz ma mb b">_splashStack</code>的导航器小部件，用于<em class="kr">获取颜色</em>显示给用户。</li></ul><figure class="kn ko kp kq fd is"><div class="bz dy l di"><div class="mc md l"/></div></figure><ul class=""><li id="dd32" class="iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated"><code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>从<code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/data/colors_repository.dart#L22" rel="noopener ugc nofollow" target="_blank">ColorsRepository</a></code>类中请求颜色。它调用<code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/data/colors_repository.dart#L22" rel="noopener ugc nofollow" target="_blank">ColorsRepository.fetchColors()</a></code>方法，并等待，直到它收到颜色。</li><li id="3ced" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated">当获取颜色列表时，<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>设置<code class="du ly lz ma mb b">colors</code>状态，并通知其setter方法中的<code class="du ly lz ma mb b">Router</code>小部件。</li><li id="9ec5" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated"><code class="du ly lz ma mb b">Router</code>小部件要求<code class="du ly lz ma mb b">RouterDelegate</code>构建<code class="du ly lz ma mb b">_loggedInStack</code>导航栈。</li></ul><figure class="kn ko kp kq fd is"><div class="bz dy l di"><div class="mc md l"/></div></figure><figure class="kn ko kp kq fd is er es paragraph-image"><div class="er es ky"><img src="../Images/f76e306f8dd08f4f21e175e9e4b0f32b.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/1*zCH2_F8Z5HO5ImhH4eAnRQ.gif"/></div></figure><p id="8e8e" class="pw-post-body-paragraph jx jy hi jb b jc jd jz ka je jf kb kc jg kd ke kf ji kg kh ki jk kj kk kl jm hb bi translated"><em class="kr">如果用户没有登录</em></p><ul class=""><li id="ef40" class="iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">从<code class="du ly lz ma mb b">build</code>方法返回带有<code class="du ly lz ma mb b">_loggedOutStack</code>的导航器小部件，并向用户显示<code class="du ly lz ma mb b">LoginScreen</code>。</li><li id="405b" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated">当在<code class="du ly lz ma mb b">LoginScreen</code>内部调用<code class="du ly lz ma mb b">onLogin</code>回调时，<code class="du ly lz ma mb b">loggedIn</code>状态被设置为真，并通知<code class="du ly lz ma mb b">Router</code>小工具。</li><li id="6bf1" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated">从<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>的<code class="du ly lz ma mb b">build</code>方法返回带有<code class="du ly lz ma mb b">_splashStack</code>的导航器小部件，并且<em class="kr">获取颜色</em>显示给用户。</li><li id="76e4" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated"><code class="du ly lz ma mb b">ColorsRepository.fetchColors()</code>方法被调用。</li><li id="a353" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated">当获取颜色列表时，<code class="du ly lz ma mb b">RouterDelegate</code>设置<code class="du ly lz ma mb b">colors</code>状态，并在其setter方法中通知<code class="du ly lz ma mb b">Router</code>小部件。</li><li id="91d3" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated"><code class="du ly lz ma mb b">Router</code>小部件要求<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>构建<code class="du ly lz ma mb b">_loggedInStack</code>导航栈。</li></ul><figure class="kn ko kp kq fd is"><div class="bz dy l di"><div class="mc md l"/></div></figure><figure class="kn ko kp kq fd is er es paragraph-image"><div class="er es ky"><img src="../Images/3ff0a2765c909ea5c95388049f0d04a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/1*BUSH2n1vlxRVGvkkvRWvOg.gif"/></div></figure><p id="f3e1" class="pw-post-body-paragraph jx jy hi jb b jc jd jz ka je jf kb kc jg kd ke kf ji kg kh ki jk kj kk kl jm hb bi translated">与之前的示例应用程序不同的是，<code class="du ly lz ma mb b">_splashStack</code>还考虑了<code class="du ly lz ma mb b">_colors</code>状态。如果还没有获取<code class="du ly lz ma mb b">_colors</code>并且用户已经登录，应用程序应该显示<code class="du ly lz ma mb b">SplashScreen</code>，因为它正在等待来自<code class="du ly lz ma mb b">ColorsRepository</code>的颜色。<code class="du ly lz ma mb b">_loggedInStack</code>和<code class="du ly lz ma mb b">_loggedOutStack</code>与第二个样品完全相同。</p><figure class="kn ko kp kq fd is"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="0bae" class="pw-post-body-paragraph jx jy hi jb b jc jd jz ka je jf kb kc jg kd ke kf ji kg kh ki jk kj kk kl jm hb bi translated">在这个示例应用程序中，我们将颜色列表与用户相关联。因此，当用户注销时，我们通过将<code class="du ly lz ma mb b">_colors</code>、<code class="du ly lz ma mb b">_selectedColorCode</code>和<code class="du ly lz ma mb b">_selectedShape</code>状态设置为<code class="du ly lz ma mb b">null</code>来清除状态。我们还应该调用<code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/data/colors_repository.dart#L30" rel="noopener ugc nofollow" target="_blank">ColorsRepository.clearColors()</a></code>方法来清除与用户相关的数据。</p><h2 id="7e33" class="kz la hi bd lb lc ld le lf lg lh li lj jg lk ll lm ji ln lo lp jk lq lr ls ho bi translated">颜色视图模型</h2><p id="f82c" class="pw-post-body-paragraph jx jy hi jb b jc lt jz ka je lu kb kc jg lv ke kf ji lw kh ki jk lx kk kl jm hb bi translated"><code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/viewmodels/colors_view_model.dart" rel="noopener ugc nofollow" target="_blank">ColorsViewModel</a></code>和<code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/viewmodels/auth_view_model.dart" rel="noopener ugc nofollow" target="_blank">AuthViewModel</a></code>类扩展了<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html" rel="noopener ugc nofollow" target="_blank">ChangeNotifier</a></code> mixin，它们使用<a class="ae jr" href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/simple" rel="noopener ugc nofollow" target="_blank">提供者状态管理库</a>被注入到应用程序树小部件中。<code class="du ly lz ma mb b">ViewModel</code>类用于表示数据获取过程的状态。对于许多开发人员来说，使用提供者模式的状态管理是否完全是MVVM(模型-视图-视图模型)是有争议的。我不打算解释我在这方面的观点，以便将重点更多地放在导航主题上。</p><p id="ecee" class="pw-post-body-paragraph jx jy hi jb b jc jd jz ka je jf kb kc jg kd ke kf ji kg kh ki jk kj kk kl jm hb bi translated">子部件访问视图模型中的<code class="du ly lz ma mb b">loggingIn</code>、<code class="du ly lz ma mb b">loggingOut</code>、<code class="du ly lz ma mb b">fetchingColors</code>和<code class="du ly lz ma mb b">clearingColors</code>状态，以判断操作是否已经开始、正在进行和完成。</p><figure class="kn ko kp kq fd is"><div class="bz dy l di"><div class="mc md l"/></div></figure><figure class="kn ko kp kq fd is"><div class="bz dy l di"><div class="mc md l"/></div></figure><h2 id="6814" class="kz la hi bd lb lc ld le lf lg lh li lj jg lk ll lm ji ln lo lp jk lq lr ls ho bi translated">注销工厂</h2><p id="9daa" class="pw-post-body-paragraph jx jy hi jb b jc lt jz ka je lu kb kc jg lv ke kf ji lw kh ki jk lx kk kl jm hb bi translated">按下<code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/002-03-mobile-only-with-auth-and-bootstrap/widgets/logout_fab_03.dart" rel="noopener ugc nofollow" target="_blank">LogoutFab</a></code>小工具时:</p><ul class=""><li id="2c25" class="iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated"><code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/viewmodels/auth_view_model.dart#L35" rel="noopener ugc nofollow" target="_blank">AuthViewModel.logout</a></code>被称为。该方法将<code class="du ly lz ma mb b">AuthViewModel</code>中的<code class="du ly lz ma mb b">logingOut</code>状态设置为<code class="du ly lz ma mb b">true</code>，并调用<code class="du ly lz ma mb b">notifyListeners</code>，这将导致<code class="du ly lz ma mb b">LogoutFab</code>的重建。</li><li id="70c6" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated"><code class="du ly lz ma mb b">LogoutFab</code>小工具显示一个带有<code class="du ly lz ma mb b">CircularProgresIndicator</code>的浮动动作按钮(fab)</li><li id="1ebf" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated">当<code class="du ly lz ma mb b">logout</code>过程完成后，<code class="du ly lz ma mb b">AuthViewModel</code>内的<code class="du ly lz ma mb b">logingOut</code>状态被置为<code class="du ly lz ma mb b">false</code>，并通知<code class="du ly lz ma mb b">LogoutFab</code> widget。</li><li id="3494" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated">这一次，<code class="du ly lz ma mb b">LogoutFab</code>小部件的重建将不会被注意到，因为随后的<code class="du ly lz ma mb b">colorsViewModel.clearColors()</code>调用会将<code class="du ly lz ma mb b">clearingColors</code>状态设置为<code class="du ly lz ma mb b">true</code>，这将导致另一次重建。</li><li id="c61d" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated"><code class="du ly lz ma mb b"><a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/002-navigator-2/002-03-mobile-only-with-auth-and-bootstrap/widgets/logout_fab_03.dart" rel="noopener ugc nofollow" target="_blank">LogoutFab</a></code>将被重建，带有<code class="du ly lz ma mb b">CircularProgresIndicator</code>的FAB再次显示。</li><li id="5649" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated">当<code class="du ly lz ma mb b">clearColors()</code>过程完成后，<code class="du ly lz ma mb b">AuthViewModel</code>内的<code class="du ly lz ma mb b">clearingColors</code>状态被设置为<code class="du ly lz ma mb b">false</code>并通知<code class="du ly lz ma mb b">LogoutFab</code>小程序。</li><li id="7384" class="iz ja hi jb b jc js je jt jg ju ji jv jk jw jm jn jo jp jq bi translated">同样，重建将不会被注意到，因为随后的<code class="du ly lz ma mb b">onLogout</code>调用将导致在<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>内重建导航历史，结果，<code class="du ly lz ma mb b">LoginScreen</code>将被显示。</li></ul><figure class="kn ko kp kq fd is"><div class="bz dy l di"><div class="mc md l"/></div></figure><h2 id="39fc" class="kz la hi bd lb lc ld le lf lg lh li lj jg lk ll lm ji ln lo lp jk lq lr ls ho bi translated">主屏幕、彩色屏幕、形状屏幕</h2><p id="a831" class="pw-post-body-paragraph jx jy hi jb b jc lt jz ka je lu kb kc jg lv ke kf ji lw kh ki jk lx kk kl jm hb bi translated">我们希望<code class="du ly lz ma mb b">HomeScreen</code>、<code class="du ly lz ma mb b">ColorScreen</code>和<code class="du ly lz ma mb b">ShapeScreen</code>具有相同的逻辑，以便每当按下<code class="du ly lz ma mb b">LogoutFab</code>时，用户都会收到文本通知，告知<code class="du ly lz ma mb b">logout</code>正在清除颜色列表。</p><figure class="kn ko kp kq fd is"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="6ba0" class="pw-post-body-paragraph jx jy hi jb b jc jd jz ka je jf kb kc jg kd ke kf ji kg kh ki jk kj kk kl jm hb bi translated">这些小部件内部的状态管理非常简单。如果<code class="du ly lz ma mb b">AUthViewModel.logingOut</code>或<code class="du ly lz ma mb b">ColorsViewModel.clearingColors</code>为真，我们显示<code class="du ly lz ma mb b">InProgressMessage</code>，它是一个定制的小部件，向用户显示操作名称和屏幕名称。</p><figure class="kn ko kp kq fd is er es paragraph-image"><div class="er es ky"><img src="../Images/d21d8adfe6bf000bd3ba94585c8e871a.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/1*9PHUWQDJaEL5g1JkYfYsHw.gif"/></div></figure><h1 id="f546" class="me la hi bd lb mf mg mh lf mi mj mk lj ml mm mn lm mo mp mq lp mr ms mt ls mu bi translated"><strong class="ak">免责声明</strong></h1><p id="5cc5" class="pw-post-body-paragraph jx jy hi jb b jc lt jz ka je lu kb kc jg lv ke kf ji lw kh ki jk lx kk kl jm hb bi translated">请注意，在这个示例应用程序中，用于确定当前应用程序状态的所有属性都单独存储在<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>类中，以便于演示和解释。不建议这样做，因为在应用程序开发过程中，这些属性的数量会随着时间的推移而增加，如果将它们都存储起来，会造成过度的破坏。我们需要用一个<em class="kr">干净的</em>T10】架构来应用最佳实践。例如，我们不需要在<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>中存储<code class="du ly lz ma mb b">colors</code>列表。事实上，我们不应该将存储库类注入到<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>中，因为<code class="du ly lz ma mb b"><a class="ae jr" href="https://api.flutter.dev/flutter/widgets/RouterDelegate-class.html" rel="noopener ugc nofollow" target="_blank">RouterDelegate</a></code>类不需要知道找出应用程序状态需要哪些存储库。相反，我们可以使用依赖注入库来注入与存储库交互的用例类。尽管干净的体系结构超出了本系列文章的范围，但是如果读者不熟悉这个主题，我强烈建议进一步阅读。</p><h1 id="09af" class="me la hi bd lb mf mg mh lf mi mj mk lj ml mm mn lm mo mp mq lp mr ms mt ls mu bi translated">结论</h1><p id="e733" class="pw-post-body-paragraph jx jy hi jb b jc lt jz ka je lu kb kc jg lv ke kf ji lw kh ki jk lx kk kl jm hb bi translated">在本文中，我们学习了如何构建导航堆栈来响应由引导导致的应用程序状态变化。你可以在<a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/tree/develop/002-navigator2" rel="noopener ugc nofollow" target="_blank"> Github页面</a>找到源代码。该项目包括多个<code class="du ly lz ma mb b">main.dart</code>文件。运行这个示例应用程序最简单的方法是右键单击<code class="du ly lz ma mb b">main_002_03.dart</code>文件并选择<code class="du ly lz ma mb b">Run 'main_002_03.dart'</code>。</p><p id="1393" class="pw-post-body-paragraph jx jy hi jb b jc jd jz ka je jf kb kc jg kd ke kf ji kg kh ki jk kj kk kl jm hb bi translated">到目前为止，我们在移动应用程序中使用Navigator 2.0 API。所有这些示例也适用于Web应用程序，但是用户体验会很差，因为Web浏览器的地址栏不会随着导航栈的更新而更新。<a class="ae jr" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-5-web-eeb4835804df" rel="noopener">在下一篇文章</a>中，我们将学习如何解析和恢复Web URL链接并相应地导航。</p><p id="b363" class="pw-post-body-paragraph jx jy hi jb b jc jd jz ka je jf kb kc jg kd ke kf ji kg kh ki jk kj kk kl jm hb bi translated">特别感谢Jon Imanol Durán 审阅了本系列的所有文章，并给了我有用的反馈。如果你喜欢这篇文章，请按下鼓掌按钮，启动<a class="ae jr" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow" rel="noopener ugc nofollow" target="_blank"> Github库</a>。</p></div></div>    
</body>
</html>