# 我最喜欢的坚实原则

> 原文：<https://medium.com/codex/my-favorite-solid-principle-eff0a321d8fb?source=collection_archive---------17----------------------->

![](img/f8938f0f573e0ab9f85ac733183d611c.png)

在 [Unsplash](https://unsplash.com/s/photos/strong?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上由 [Ameer Basheer](https://unsplash.com/@24ameer?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄的照片

几年前，在一次技术面试中，有人问我以下问题:“你最喜欢的坚实原则是什么？”我认为这是一个奇怪的问题，因为所有这些原则对我来说都是同等重要的，而且是牢固的。如果你漏了一个，你就不会再有实体了，而更像是卖了或者旧了。

几年后，我意识到事实上这一原则在不同的场合以不同的形式出现。坚持这一原则帮助我创建了具有可伸缩数据模型的模块化软件系统，并编写了易于推理的代码。这一原则超越了面向对象编程，并作为一等公民接受了不变性。如果你现在还猜不出来:我说的是开/闭原理。

> 对扩展开放，但对修改关闭

这短短的一句话里凝聚了很多程序员的智慧。“修改关闭”基本上是告诉我们编写一旦发布就不可改变的代码。将区块链上的智能合约视为一种极端情况，在这种情况下，不可能修改已发布的代码。在那里你不能仅仅重命名一个字段或者删除一个已存在的字段，代码是关闭的。但是您可以通过添加新的智能契约来扩展它，这些新的智能契约可以与现有的智能契约一起工作，并扩展它们的功能。如果拥有智能合约和永久网络存储的去中心化对等系统的趋势继续下去，程序员将被迫改变他们对代码的想法。

但是，即使在今天，对于我们的大型企业软件系统、嵌入式系统和移动应用程序来说，有远见地编写代码也是明智的。我们应该能够在不触及现有功能的情况下向代码库添加新功能。这将大大降低回归错误的风险和整体代码的复杂性。

如果我们把代码想象成一组独立的 Dag(有向无环图),那么实现开放/封闭原则就更容易了。每次添加新功能时，我们都会向图中添加新节点或创建新图，而不是更改旧节点。当然，我们需要务实的改变，特别是，如果有一个错误，我们将不得不更新现有的代码。但是，在设计我们的代码时，考虑的是附加的变化而不是修改，我们的软件系统将自动变得更加模块化。

创建好的扩展点并不容易。根据我的经验，做得太多或太少的代码会阻止我们扩展功能。显然，如果代码做得太多，那么将代码用于其他用例就变得很困难，在这些用例中只需要某一部分功能。我们被迫拆分代码，添加参数并进行其他修改。另一种选择是代码复制，虽然这听起来不对，但在某些情况下，这可能是更好的选择。另一方面，如果代码做得太少，就几乎不可能以有意义的方式使用它。尽管我们没有修改现有的代码，但是我们确实创建了一个巨大的依赖图，其中有一个单点故障。

当然，有时现有代码不再支持业务案例。但与此同时，对于任何重要的项目，以一种不需要几年后完全重写的方式设计我们的代码是有益的。相反，我们应该努力构建高质量的、不可变的代码，我们可以在未来的岁月中扩展和构建这些代码。