<html>
<head>
<title>Basic SQL statements you need to know (GROUP BY/HAVING/INNER JOIN)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您需要了解的基本SQL语句(GROUP BY/HAVING/INNER JOIN)</h1>
<blockquote>原文：<a href="https://medium.com/codex/basic-sql-statements-you-need-to-know-group-by-having-inner-join-6081d270de58?source=collection_archive---------8-----------------------#2022-06-24">https://medium.com/codex/basic-sql-statements-you-need-to-know-group-by-having-inner-join-6081d270de58?source=collection_archive---------8-----------------------#2022-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="f39a" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">介绍</p></blockquote><p id="9ae5" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在<a class="ae jk" rel="noopener" href="/@24littledino/basic-sql-statements-you-need-to-know-select-distinct-order-by-limit-where-26b703df8aa1">上一篇文章</a>中，我们讨论了非常基本的SQL语句。在本文中，我们将关注稍微复杂一点的— <code class="du jl jm jn jo b">GROUP BY</code>、<code class="du jl jm jn jo b">HAVING</code>和<code class="du jl jm jn jo b">INNER JOIN</code>，然而它们非常强大。</p><blockquote class="if ig ih"><p id="7e11" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><em class="hi"> SQL语句</em></p></blockquote><p id="c587" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在下面的演示中，我们将使用同一个表作为示例。这个表叫做<strong class="il hj">客户</strong>，记录了客户的信息。它有4个特征——<code class="du jl jm jn jo b">ID</code><strong class="il hj"/><code class="du jl jm jn jo b">Name</code><strong class="il hj"/><code class="du jl jm jn jo b">City</code><strong class="il hj"/><code class="du jl jm jn jo b">Age</code>，这个表中有6个客户。此外，<strong class="il hj">主键是</strong> <code class="du jl jm jn jo b"><strong class="il hj">ID</strong></code>，因为您只能使用<code class="du jl jm jn jo b">ID</code>来唯一地标识每一行。</p><p id="497f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如果你对关系数据库不熟悉，去看看我的<a class="ae jk" rel="noopener" href="/@24littledino/basic-sql-statements-you-need-to-know-select-distinct-order-by-limit-where-26b703df8aa1">上一篇文章</a>！</p><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jp"><img src="../Images/8019b5dcd204e7e6c465790ce47b49a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6uXewYDX6jUH6VBTZkw5cw.jpeg"/></div></div></figure><p id="304a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj"> 1。分组依据</strong></p><p id="91ee" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">第一个用于将具有相同值<strong class="il hj">的行分组为汇总行</strong>，您可以决定<strong class="il hj">想要哪种类型的汇总</strong>(即<code class="du jl jm jn jo b">MAX</code> / <code class="du jl jm jn jo b">MIN</code> / <code class="du jl jm jn jo b">AVG</code> / <code class="du jl jm jn jo b">SUM</code> / <code class="du jl jm jn jo b">COUNT</code>)。</p><p id="f2f6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">比方说，我们想知道每个城市客户的平均年龄。我们如何对客户进行分组？</p><p id="f6f6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">是的，<strong class="il hj">按城市</strong>。然后，我们可以使用<code class="du jl jm jn jo b">AVG</code>函数得到每个城市的平均年龄。更具体地说，查询类似于<code class="du jl jm jn jo b">SELECT City, <strong class="il hj">AVG(Age)</strong> FROM customers <strong class="il hj">GROUP BY City</strong>;</code>，它返回—</p><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kb"><img src="../Images/c8cbb61d1104786ca7865f96c1e4372b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IkFA0w491J5IY1i2fKJENQ.jpeg"/></div></div></figure><p id="b990" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如果我们现在想知道<strong class="il hj">每个城市的客户总数</strong>该怎么办？</p><p id="be9b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们将功能更改为<code class="du jl jm jn jo b">COUNT</code>。需要注意的一点是<code class="du jl jm jn jo b">COUNT(*)</code>将<strong class="il hj">包括重复值和空值</strong>，它只是计算行数。如果您想计算<strong class="il hj">唯一</strong>行的数量，您有两个选项。</p><ul class=""><li id="8edb" class="kc kd hi il b im in iq ir jh ke ji kf jj kg jg kh ki kj kk bi translated">在列名前添加<code class="du jl jm jn jo b"><strong class="il hj">DISTINCT</strong></code>关键字。它将删除重复项(参见<a class="ae jk" rel="noopener" href="/codex/basic-sql-statements-you-need-to-know-select-distinct-order-by-limit-where-26b703df8aa1">如何使用</a><code class="du jl jm jn jo b"><a class="ae jk" rel="noopener" href="/codex/basic-sql-statements-you-need-to-know-select-distinct-order-by-limit-where-26b703df8aa1">DISTINCT</a></code>)——<code class="du jl jm jn jo b">SELECT City, COUNT(<strong class="il hj">DISTINCT</strong> Name) Customers FROM customers GROUP BY City;</code>。</li><li id="0467" class="kc kd hi il b im kl iq km jh kn ji ko jj kp jg kh ki kj kk bi translated">统计<strong class="il hj">主键</strong>中的行数。正如我们在之前讨论过的<a class="ae jk" rel="noopener" href="/codex/basic-sql-statements-you-need-to-know-select-distinct-order-by-limit-where-26b703df8aa1">，主键是用来唯一标识行的。其中不会有任何重复的值，所以我们可以使用该属性来查找唯一行的数量— <code class="du jl jm jn jo b">SELECT City, COUNT(<strong class="il hj">ID</strong>) Customers FROM customers GROUP BY City;</code>。</a></li></ul><p id="e8cf" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这两种方法产生相同的结果，即使<code class="du jl jm jn jo b">Name</code>不是主键。</p><p id="4b5f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">⚡第二个列名是<code class="du jl jm jn jo b">Customers</code>，因为我们<strong class="il hj">重命名</strong>该列，方法是在原始列名后给新名称分配一个空格。</p><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kq"><img src="../Images/b3df5d054223f235284aa19a592a31be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6yavaQk1Kh9D4vOyBWUUWg.jpeg"/></div></div></figure><p id="e268" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这就是我们使用<code class="du jl jm jn jo b">GROUP BY</code>的方式！下一个问题是，如果我们想找到至少有两个顾客的城市怎么办？</p><p id="fc2f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">你可能会想到<code class="du jl jm jn jo b">WHERE</code>子句(见<a class="ae jk" rel="noopener" href="/codex/basic-sql-statements-you-need-to-know-select-distinct-order-by-limit-where-26b703df8aa1">如何使用</a> <code class="du jl jm jn jo b"><a class="ae jk" rel="noopener" href="/codex/basic-sql-statements-you-need-to-know-select-distinct-order-by-limit-where-26b703df8aa1">WHERE</a></code>)。不幸的是，<code class="du jl jm jn jo b">WHERE</code> <strong class="il hj">不能和</strong>一起使用聚集函数，比如<code class="du jl jm jn jo b">COUNT</code>、<code class="du jl jm jn jo b">SUM</code>、<code class="du jl jm jn jo b">AVG</code>。因此，我们需要另一个条款— <code class="du jl jm jn jo b">HAVING</code>。</p><p id="0998" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj"> 2。拥有</strong></p><p id="214b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">简单地说，<code class="du jl jm jn jo b">HAVING</code>的行为与<code class="du jl jm jn jo b">WHERE</code>完全相同，除了它是为聚合函数设计的。如果我们想找到至少有两个客户的城市，我们只需写下返回</p><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kr"><img src="../Images/2d25982586ca1183a6567559fbf5a9a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9KIs9Gq5K6YeaqBbS5IULg.jpeg"/></div></div></figure><p id="9c3c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如果你检查前面的结果，你会发现巴黎确实是唯一一个至少有两个顾客的城市。类似地，如果你想找到哪个城市的客户平均年龄高于30岁，你就写T0。</p><p id="a1ab" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj"> 3。内部连接</strong></p><p id="45ea" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">知道如何从一个表中提取信息是有用且关键的，但是很多时候我们想要合并来自多个表的信息。特别是，<code class="du jl jm jn jo b">INNER JOIN</code>允许我们选择在<strong class="il hj"> 2表</strong>中具有<strong class="il hj">匹配值</strong>的记录。</p><p id="e3a3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">语法是这样的<code class="du jl jm jn jo b">SELECT * FROM table1 <strong class="il hj">INNER JOIN </strong>table2 <strong class="il hj">ON</strong> table1.column1 = table2.column2</code>。您可能会注意到，<code class="du jl jm jn jo b">ON</code>用于选择您想要匹配的列。例如，数据库中有两个表。一个存储客户的<strong class="il hj">个人信息</strong>，另一个存储客户的<strong class="il hj">订单信息</strong>。我们可能希望匹配两个表，以查看特定年龄范围的客户<strong class="il hj">的<strong class="il hj">订单偏好</strong>，因此我们需要连接两个表。我们应该选择哪一列？</strong></p><p id="b234" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我知道我没有给你两张表的详细信息，但是我们会使用<strong class="il hj">客户id</strong>。ID是合适的，因为它可以用来唯一地标识每个客户。假设我们使用<strong class="il hj">名称</strong>作为匹配属性。几乎可以肯定的是，一定有不止一个同名的客户，我们如何确切地知道谁订购了哪些产品？是芝加哥的约翰还是伦敦的约翰？</p><p id="a7bb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">让我们做一个有趣的实验。假设我们在<code class="du jl jm jn jo b">Name</code>属性— <code class="du jl jm jn jo b">SELECT * FROM customers c1 <strong class="il hj">INNER JOIN </strong>customers c2 <strong class="il hj">ON</strong> c1.Name = c2.Name</code>上将客户表与其自身进行内部连接。是的，我们可以这么做(我知道这看起来有点疯狂)。结果会是怎样的？</p><p id="bc4f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">理想情况下，每个顾客都应该与自己相匹配。然而，事实并非如此，结果实际上是—</p><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ks"><img src="../Images/d431eac69a73caf1bd55cfdfb78f25ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sWnkIhcq9pPprPZiLCdFeA.jpeg"/></div></div></figure><p id="3104" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">大多数客户如我们所料被合并，但是约翰出现了4次。为什么会这样？</p><p id="85d3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">是的，你是对的，我们没有使用主键(<code class="du jl jm jn jo b">ID</code>)来合并表。因此，芝加哥的约翰不得不与自己和伦敦的约翰合并。同样的事情也发生在另一个约翰身上。伦敦的约翰不得不与自己和芝加哥的约翰合并。现在你看到问题了。我们更喜欢使用<strong class="il hj">主键</strong>作为匹配属性来避免这个问题(即匹配的客户实际上是不同的人)。</p><p id="f16c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">但是，如果您坚持，我们仍然可以使用<code class="du jl jm jn jo b">Name</code>来合并2个表，只是我们需要一个额外的列— <code class="du jl jm jn jo b">City</code>。因为我们的桌子很小，你可以看到唯一的问题是有两个约翰住在不同的城市。如果我们同时使用<code class="du jl jm jn jo b">Name</code>和<code class="du jl jm jn jo b">City</code>来合并表格，他们将被视为不同的人。换句话说，我们使用<strong class="il hj">多列条件</strong>。查询是这样的— <code class="du jl jm jn jo b">SELECT * FROM customers c1 INNER JOIN customers c2 ON c1.Name = c2.Name AND <strong class="il hj">c1.City = c2.City</strong>;</code>，它返回—</p><figure class="jq jr js jt fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es kt"><img src="../Images/f42779060b8e86e459c1dd96cb733a66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dqn_HZ4zIVffnEA5C4rstg.png"/></div></div></figure><p id="c701" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">问题已解决！芝加哥的约翰只配自己，伦敦的约翰也配自己。然而，我们的数据库很小，我们可以手动找到问题。如果我们的数据库足够大，我们应该找到两个住在同一个城市的同名同岁的人。在这种情况下，我们仍然需要<code class="du jl jm jn jo b">ID</code>来合并表(这实际上是最好的选择)。</p><p id="0baf" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">有时候你也许可以使用<code class="du jl jm jn jo b">INNER JOIN</code>而不会产生任何错误，但是<strong class="il hj">结果是有问题的或者没有反映现实</strong>。基于不正确信息检索的分析会有偏差，基于有偏差分析的决策会有后果。因此，我们要尽可能地小心，这里有一些可以帮助我们减少错误的注意事项。</p><ul class=""><li id="ac47" class="kc kd hi il b im in iq ir jh ke ji kf jj kg jg kh ki kj kk bi translated"><strong class="il hj">通过重命名表格和指定表格名称来避免歧义</strong></li></ul><p id="ff58" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">从上面的查询中，您可能会注意到我将第一个<code class="du jl jm jn jo b">customers</code>表重命名为<code class="du jl jm jn jo b">c1</code>，将第二个<code class="du jl jm jn jo b">customers</code>表重命名为<code class="du jl jm jn jo b">c2</code>。然后，当我引用一个列时，我是针对表的，即<code class="du jl jm jn jo b">c1.Name</code>(从第一个<code class="du jl jm jn jo b">customers</code>开始的<code class="du jl jm jn jo b">Name</code>列)、<code class="du jl jm jn jo b">c2.Name</code>(从第二个<code class="du jl jm jn jo b">customers</code>开始的<code class="du jl jm jn jo b">Name</code>列)。<strong class="il hj">在这种情况下，重命名是强制性的</strong>，因为两个表的名称完全相同。此外，<strong class="il hj">由于<code class="du jl jm jn jo b">Name</code>列出现在两个表中，所以在这里</strong>表名的说明也是强制性的。如果我们不指定我们指的是哪个<code class="du jl jm jn jo b">Name</code>，SQL将会被混淆并返回错误。</p><p id="ab21" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">但是，如果您有不同的表名和不同的列名，<strong class="il hj">重命名和指定都不是强制性的</strong>。说到这里，为了方便起见，我们倾向于将表重命名为<strong class="il hj">一个更短的名称</strong>(指定时不需要键入完整的名称)。为了清晰和调试，我们还在列<strong class="il hj">前指定了表名(当您知道列来自哪里时，调试会更容易)。因此，重命名和指定绝对是需要保持的好习惯。</strong></p><ul class=""><li id="fc8e" class="kc kd hi il b im in iq ir jh ke ji kf jj kg jg kh ki kj kk bi translated"><strong class="il hj">无匹配值—返回空表</strong></li></ul><p id="d352" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">当列中没有匹配值时，SQL只返回一个空表。这通常是查询失败的标志。您可能使用了错误的表，引用了错误的列，或者数据库本身有问题。</p><ul class=""><li id="7867" class="kc kd hi il b im in iq ir jh ke ji kf jj kg jg kh ki kj kk bi translated"><strong class="il hj">检查表分区的结果</strong></li></ul><p id="2028" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">现实世界中的一个表可能有数万行(甚至更多)。考虑到数据量，很难判断连接结果是否正确。我经常做的是首先对表进行分区，然后在小表上验证连接结果。例如，我们可以从每个表中随机抽取20行，对它们进行内部连接，并检查结果是否符合预期。然后，我们重复验证过程几次，因为这些行是随机选择的。我们可能会遇到这样的情况，查询只适用于部分数据(例如，验证数据集中没有选择不同城市的约翰)，而不是整个数据集。</p><ul class=""><li id="e1a3" class="kc kd hi il b im in iq ir jh ke ji kf jj kg jg kh ki kj kk bi translated"><strong class="il hj">选择我们需要的列</strong></li></ul><p id="4421" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如您所见，即使两个表中的列具有完全相同的名称和匹配的值，它们也会显示出来。我们应该选择我们需要的列<strong class="il hj">以避免冗余</strong>。例如，我们在<code class="du jl jm jn jo b">Name</code>和<code class="du jl jm jn jo b">City</code>属性上连接两个表<code class="du jl jm jn jo b">c1</code>、<code class="du jl jm jn jo b">c2</code>，那么这两列中的结果值在两个表中是相同的(这实质上就是连接的含义)。因此，我们可以选择<code class="du jl jm jn jo b">c1.Name, c1.City</code>或<code class="du jl jm jn jo b">c2.Name, c2.City</code>。结果表将比原始表更整洁(显示相同的属性两次)。</p><ul class=""><li id="cc69" class="kc kd hi il b im in iq ir jh ke ji kf jj kg jg kh ki kj kk bi translated"><strong class="il hj">连接两个以上的表</strong></li></ul><p id="34e3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">其实我们可以加入<strong class="il hj">多个表</strong>！例如，我们在数据库中有3个表。第一个存储客户的<strong class="il hj">个人信息</strong>；第二个存储客户的<strong class="il hj">订单信息</strong>；最后一个存储产品的<strong class="il hj">细节。我们可能想要匹配3个表来查看特定年龄范围</strong>的客户<strong class="il hj">的<strong class="il hj">产品偏好</strong>，因此我们需要<strong class="il hj">匹配3个表</strong>。举例来说，匹配第一个和第二个表是不够的，因为第二个表不包含产品细节；匹配第二个和第三个表是不够的，因为第二个表不包含客户详细信息(即年龄)。匹配第一个和第三个表是不可行的，因为没有共同的属性。</strong></p><p id="15ae" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">你可能想知道为什么我们不把所有的数据存储在一个表中。实际上，这样做可能会导致<strong class="il hj">冗余和异常</strong>，所以我们需要规范化表格(不过这是另一天的主题)。这里的关键点是我们可以连接任意多的表，语法类似于<code class="du jl jm jn jo b">SELECT * FROM table1 <strong class="il hj">INNER JOIN </strong>(table2 <strong class="il hj">INNER JOIN</strong> table3 <strong class="il hj">ON</strong> table2.column1 = table3.column2) <strong class="il hj">ON</strong> table1.column1 = table2.column2;</code>。</p><p id="264a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">恭喜你，你已经走了这么远！在<a class="ae jk" rel="noopener" href="/codex/basic-sql-statements-you-need-to-know-select-distinct-order-by-limit-where-26b703df8aa1">上一篇</a>和本文中，我们经历了<code class="du jl jm jn jo b">SELECT</code>、<code class="du jl jm jn jo b">ORDER BY</code>、<code class="du jl jm jn jo b">LIMIT</code>、<code class="du jl jm jn jo b">DISTINCT</code>、<code class="du jl jm jn jo b">WHERE</code>、<code class="du jl jm jn jo b">GROUP BY</code>、<code class="du jl jm jn jo b">HAVING</code>、<code class="du jl jm jn jo b">INNER JOIN</code>，这些关键词/从句应该足够你从数据库中提取信息了。然而，熟能生巧。你可以在网上找到大量的SQL练习，去练习吧，这样你就可以流利地组合从句了。祝你好运！</p><p id="8e6b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">💛如果你喜欢这篇文章，一定要关注我！这真的鼓励了我，激励我继续分享。非常感谢。</p><blockquote class="if ig ih"><p id="4f2d" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">参考</p></blockquote><ol class=""><li id="d249" class="kc kd hi il b im in iq ir jh ke ji kf jj kg jg ku ki kj kk bi translated"><a class="ae jk" href="https://www.w3schools.com/sql/sql_groupby.asp" rel="noopener ugc nofollow" target="_blank">https://www.w3schools.com/sql/sql_groupby.asp</a></li><li id="ff0c" class="kc kd hi il b im kl iq km jh kn ji ko jj kp jg ku ki kj kk bi translated"><a class="ae jk" href="https://www.w3schools.com/sql/sql_having.asp" rel="noopener ugc nofollow" target="_blank">https://www.w3schools.com/sql/sql_having.asp</a></li><li id="0b0d" class="kc kd hi il b im kl iq km jh kn ji ko jj kp jg ku ki kj kk bi translated"><a class="ae jk" href="https://www.w3schools.com/sql/sql_join_inner.asp" rel="noopener ugc nofollow" target="_blank">https://www.w3schools.com/sql/sql_join_inner.asp</a></li></ol></div></div>    
</body>
</html>