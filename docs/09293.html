<html>
<head>
<title>How does Dependency Injection work in Angular?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular中的依赖注入是如何工作的？</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-dependency-injection-works-in-angular-1773110a60a4?source=collection_archive---------8-----------------------#2022-10-10">https://medium.com/codex/how-dependency-injection-works-in-angular-1773110a60a4?source=collection_archive---------8-----------------------#2022-10-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="60e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的编码之旅中的某个时刻，我们都使用过依赖注入，而不考虑技术栈。但是用它的理由是什么呢？</p><p id="1911" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下，每当我们需要访问一个类时，就实例化它！可怕，是的！我们使用DI来避免类之间的硬依赖。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0335091e6aac90821aff92106b69762d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FDTJmdVQW30xF640En88lA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">在组件的构造函数中注入MessageService实例</figcaption></figure><p id="ceff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">依赖注入确保组件不会自己创建服务类的实例，而是将<em class="jt">实例化过程</em>委托给<strong class="ih hj"><em class="jt"/></strong>注入器，后者负责创建相应类的实例并将其注入构造器。</p><h2 id="07a5" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">注入器如何解析依赖关系？</h2><p id="da7b" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">注射器基本上有一个<em class="jt">注册表</em>，所有的实例都在这里被创建<em class="jt">(通常当我们在类之前使用</em><strong class="ih hj"><em class="jt">@ Injectable</em></strong><em class="jt">注释)</em>并存储。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ku"><img src="../Images/a7655abedc6ba0c4ac2c085c5555426e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bVZH35k5dzLNxmuo6o6mCQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">使用<strong class="bd jw">提供的<strong class="bd jw"> @Injectable </strong> decorator的</strong>属性来确保这个服务类可以在任何需要的地方作为依赖项注入。</figcaption></figure><p id="d19a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当组件<em class="jt">(上例中的</em><strong class="ih hj"><em class="jt">Component _ A</em></strong><em class="jt">)</em>被执行时，它会解析对现有实例的依赖，而不是创建一个新实例。在编译期间，如果在<em class="jt"> @NgModule </em>的<em class="jt"> providers数组</em>中没有提到该类，或者该类没有使用<em class="jt"> @Injectable </em> decorator的providedIn属性进行配置，就会发生这种情况；它将抛出一个错误，指出它无法解析依赖关系。</p><p id="4cb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就引出了一个问题,“根”是干什么的？对吗？</p><p id="6dfe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，让我们了解注入器层次结构和解析规则:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kv"><img src="../Images/24368618232a50c2227af0c17cf1a09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KII5jx_qV1vN_dUddrgTTw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">解决依赖关系的注入层次结构</figcaption></figure><p id="7027" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们在图中看到的，有两种层次结构:元素注入器层次结构和模块注入器层次结构。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kw"><img src="../Images/9e583240718e0c4d9194eb6561c53c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sSl9spHALURoj2wR_eu3EA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">组件有自己的提供者数组来解决依赖关系</figcaption></figure><p id="5bba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先说元素注入器层次！适用于用<strong class="ih hj"><em class="jt">@指令</em> </strong>和<strong class="ih hj"><em class="jt">@组件</em></strong>decorator声明的类。在这种情况下，依赖关系是在元素注入器树本身中<strong class="ih hj">解析的，即在ComponentA本身中。</strong></p><p id="1eee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jt">但是，如果有</em> <strong class="ih hj"> <em class="jt">没有提供者数组</em> </strong> <em class="jt">里面提到的组件呢？</em></p><p id="291d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们从上面的注入树图中看到的，如果它不能解析组件内部的依赖关系，那么它会请求元素注入树<em class="jt">(本例中是根组件)</em>中的父组件来解析它。如果providers数组中提供了该类，它将解析依赖关系并返回到<em class="jt">组件</em>。</p><p id="ca99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jt">但是如果根组件也没有providers数组呢？</em></p><p id="2e8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它返回到请求解析依赖关系的<em class="jt">组件A </em>，因为它在元素注入器树中没有被解析，结果是搜索在其中声明了<em class="jt">组件A </em>的模块。</p><p id="b535" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在来看<strong class="ih hj">模块的作用<em class="jt">注射器树</em>注射器树</strong>。</p><p id="ed91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于<strong class="ih hj"> <em class="jt">子模块</em> </strong>是惰性加载的，并且在其作用域中声明了<em class="jt"> ComponentA </em>，因此它被委托负责解析依赖关系。如果Angular能在<em class="jt">子模块</em>中找到依赖项的提供者，它会在<em class="jt">组件</em>中注入依赖项。但是如果没有找到，它会进一步将解析委托给<strong class="ih hj"> <em class="jt">根模块注入器</em> </strong>。然后同样的过程发生，如果没有找到提供者，它被进一步委托给<strong class="ih hj"> <em class="jt">平台模块注入器</em> </strong>，然后最后是<strong class="ih hj"> <em class="jt">空注入器</em> </strong>，最终<strong class="ih hj"> <em class="jt">在Angular试图解决依赖关系时抛出错误</em> </strong>。</p><p id="8009" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简化了吧？</p><p id="8811" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文灵感来自Youtube上的<a class="ae kx" href="https://www.youtube.com/c/DecodedFrontend" rel="noopener ugc nofollow" target="_blank">解码前端</a>频道。</p><p id="ef31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我真的很想让你对这篇文章鼓掌。不要委托给下一位读者，好吗？无红利</p></div></div>    
</body>
</html>