# 更新的 EDA 参考架构

> 原文：<https://medium.com/codex/updated-eda-reference-architecture-b1d08a43fc87?source=collection_archive---------6----------------------->

在过去的三年里，我花时间为客户设计事件驱动的解决方案，并围绕事件驱动架构开发最佳实践。从我最近的项目中，我不得不更新 EDA 参考架构，并真正将消息传递作为一种服务而不是事件主干来讨论… **EDA 不是 Kafka** ！:远不止如此，让我们来看看原因。

![](img/7d5dc0ebb86a322de238ee9e4cd96c8c.png)

我与架构师的一个常见讨论是围绕“消息传递与事件”，或者“排队与发布/订阅”，这很快导致产品比较 Kafka 与 MQ。

一些 IT 架构师希望使用完整的 Kafka，或者一些有偏见的营销活动声称“‘队列’是一种陈旧的东西，你不再需要它们了”或者“有了 Kafka，你可以在一个平台上解决你所有的消息传递需求”。这是错误的，过于简单化，不同的语义导致不同的工具。

很明显，我们必须仔细检查嗡嗡声，并总是回到“适合目的”的讨论并分析所需的需求:当开发数字业务应用程序时，我们多年来都知道“消息是开发可伸缩、有弹性、有弹性的解决方案的关键”。这是反应宣言的核心。

**一些背景**

几年前，消息传递专家定义了[事件与消息传递](https://ibm-cloud-architecture.github.io/refarch-eda/concepts/events-versus-messages/#messaging-versus-event-streaming)的分类:即使今天提出的大多数论点仍然适用，但重要的是要注意应用程序正在交换一个字节数组，表示组件之间共享的消息。20 多年来,“事件”在不同的编程语言或框架中被认为是支持异步通信的一种方式。今天，事件代表了业务实体的事实，并且是不可变的。

真正重要的是考虑以下要求:

*   向另一个应用程序发送一个**异步请求，期望它发送一个**响应**回来，在一个更大的流程或业务逻辑中执行一个动作。**
*   发送**异步**消息向全世界广播其数据变化。这些代表了关于其数据的事实，在领域驱动的设计中，这些事实是**事件**。

在这两种情况下，消息都保存在中间件产品中，供其他应用程序使用。请求/响应模型带来了一些需求，如一次性交付、事务性、一致性、无重复和使用前的弹性。第二种方法可能至少使用一次交付，支持多个消费者的伸缩，并接受最终的数据一致性。在中间件产品级别，需要做出一些设计决策来支持每一个需求，这就是为什么今天 IT 架构师应该考虑不同的产品来满足业务应用程序的需求:

*   **点对点通信**用队列保存消息。队列中的消息一旦被使用就会被删除:这对于支持请求/响应通信来说是完美的。
*   **发布/订阅通信**用主题来保存消息。有一个时间解耦，Kafka 添加到传统 JMS 基于主题的中间件中的是这样一个事实，即消息可以在一个附加日志中保存很长一段时间，并且一旦它们被所有订阅者使用，就不会被中间件删除，而是被管理员配置删除。不再有“所有订户”的概念。消费者在他们想要的时候消费，从最后读取的消息或者从任何特定的偏移开始。

使用 append log，应用程序可以进行数据流处理，不断地使用消息，处理消息，并向不同的主题发布新消息。这些新功能为动态数据提供了新的实时处理。有了历史附加日志，任何消费者都可以通过按时间顺序读取链接到这些实体的业务事件来构建自己的业务实体视图:这对于审计或从失败中重建它们的状态，或者理解事物是如何构建的或如何到达它们的当前状态是非常强大的。

架构师需要确定一组关键需求来解决:

*   近乎实时地了解由现有应用程序创建的新数据，以获得更好的业务洞察力，并向最终用户/客户提出新的业务机会。这意味着采用数据流和智能查询解决方案。
*   与现有的事务系统集成，并继续进行事务处理，同时采用分布式系统的最终一致性特征。(云原生无服务器或微服务是分布式系统)
*   转向无服务器和微服务之间的异步通信，因此它们变得更具响应性、弹性和可伸缩性(“反应式应用”的特征)。
*   松散耦合，但仍然理解 API 契约。API 是同步的(RES，SOAP)还是异步的(队列和主题)。
*   获得数据治理的清晰可见性，编目应用程序能够持续评估哪些应用程序安全地访问什么，以及做什么。

在 [Gartner 的 EDA 成熟度模型](https://www.gartner.com/en/documents/3942102/maturity-model-for-event-driven-architecture)中，我们看到了企业从“偶然的”EDA 模型发展到“高级的或普遍的”EDA 模型(EDA 是业务组合的一部分)需要遵循的演变过程，并且满足上面列出的要求正在成为帮助企业进入“高级”阶段的关键。

**EDA 参考架构**

我们的 [EDA 参考架构](https://ibm-cloud-architecture.github.io/refarch-eda/introduction/reference-architecture/#event-driven-architecture)是两年多前定义的，随着时间的推移，新的需求不断出现，我们总是需要重新审视它。让我们描述图 1 的组件:

![](img/566876f4957c888c6be335b1392e1586.png)

在**队列侧**(左上角)，我们需要现代微服务或功能即服务，以及传统应用程序，能够向队列中写入数据或从队列中读取数据。这必须是编码异步请求/响应通信的方法。我认为[命令查询责任分离](https://ibm-cloud-architecture.github.io/refarch-eda/patterns/cqrs/)和 [Saga](https://ibm-cloud-architecture.github.io/refarch-eda/patterns/saga/)) 模式是现代微服务解决方案中非常重要的设计模式，但是这些模式需要用队列、队列和主题的混合来实现，而不仅仅是 Kafka 主题。

队列产品，如 IBM MQ，支持 XA 事务，这是任何现代架构都要保持的一个关键特性:我们希望在同一事务中发布消息的同时写入数据库。此外，大型机仍然是任何混合云架构中的优秀公民。与分布式系统相比，它们支持事务处理，并且在大多数情况下总拥有成本更低。但是我不会在本文中详述 TCO。大多数大型机都与 IBM MQ 集成在一起，以支持异步请求/响应通信，在 EDA 中，我们希望获得这些消息的可见性，以供其他人作为事件使用。因此，将数据复制到队列中，然后从队列注入到 Kafka 主题是很有意义的。这是 MQ 和 Kafka 之间的箭头，Kafka 连接器框架用于支持这种注入。IBM MQ 还支持透明的“流队列”,以便将消息从现有队列发送到其他队列，从而可以插入 Kafka 连接器。

在 **Reactive cloud-native app** 端，开发者需要采用领域驱动的设计来更好地识别要在微服务中开发的有界上下文、聚合、事件和命令。命令大多数时候是在 OpenAPI 契约中定义的动词。实体和集合将用于定义服务将管理什么，以及公开的 API 的模式是什么。

为了反应，这些微服务是消息驱动，且必须与消息中间件集成。这是《反应宣言》中介绍的反应系统的著名人物:

![](img/ecd8c42f2b79a62ecc440ace3e7f1ea7.png)

在 DDD，事件是不变的事实，因此发现的事件是队列和主题中消息的良好候选。正如本文开头所看到的，通信的语义将有助于决定我们是需要队列还是主题，或者两者都需要。[事件采购](https://ibm-cloud-architecture.github.io/refarch-eda/patterns/event-sourcing/)是另一种可能影响此类决策的模式。

为了保持契约测试和契约管理的最佳实践，AsyncAPI 规范帮助开发人员定义消息的模式结构，以便在组件之间异步交换。它使用绑定结构来定义向哪个中间件发送消息。

例如，OpenAPI 可以自顶向下开发，也可以通过在 Java 应用程序中使用 microprofile OpenApi 自底向上开发。当采用 API 管理时，这个 OpenApi 定义也被部署在 **API 网关**中，以控制每个云原生应用的流量和安全访问。RESTful 端点之间的 HTTP 通信将进入 API 网关。现在，当通过队列或主题进行通信时，使用 AsyncAPI 定义，并且可以在**事件网关**中控制，事件网关充当消息代理和消费者之间的中间代理。我们才刚刚开始采用这种技术，但它将有助于流量监控和应用治理。

如果 OpenAPIs 正在以 JSON 模式的形式为 REST 端点定义 API 数据模式，那么**模式注册中心**正在添加模式管理和版本控制，以便基于 Kafka 的应用程序可以获得它们的数据契约。这是异步契约定义的第一部分，AsyncAPI 正在向它添加更多的规范，但是模式注册中心还没有与 API 管理完全集成。

[Apicurio](https://www.apicur.io/) 是一个开源项目，支持 API 和模式注册。

云原生开发者需要考虑[微概要反应消息](https://download.eclipse.org/microprofile/microprofile-reactive-messaging-1.0/microprofile-reactive-messaging-spec.pdf)、[事件](https://knative.dev/docs/eventing/)，或者任何角色框架，如【https://github.com/IBM/kar】IBM KAR(T4)来支持他们服务的实现。

下图展示了这种服务的潜在结构:在一个或多个 JAXRS 资源类中使用 [microprofile OpenAPI](https://github.com/eclipse/microprofile-open-api) 注释定义 API。这些 API 可以在一个 API 管理产品中作为 IBM API Connect 进行管理。

![](img/7301ec1bfc554581662c73973534b218.png)

应用程序结构的其余部分反映了洋葱架构的 DDD 方法。业务逻辑在它自己的层中，有 DDD 集合、无处不在的语言、服务、业务规则等等

存储库层支持将这些聚合持久化到外部面向文档或基于 SQL 的数据库中。

由于大多数新的微服务都是消息驱动的，我们正在添加一个可能使用队列或主题的消息层。在 Java 中，微概要反应式消息传递可用于定义不同的发布通道，如队列、主题或两者兼有。

根据定义消息或事件结构的 JSON 或 Avro 模式，开发人员可以构建 AsyncAPI 规范，该规范也可以由 API 产品管理。我将在另一篇博客中介绍使用持续集成和部署到 Kubernetes 平台的这类应用程序的一些代码模板。

任何云原生应用程序的最后一部分是将长期运行的有状态应用程序迁移到微服务，这些应用程序过去是在业务流程管理平台中开发的:这种整体产品套件的重组和现代化是基于微服务甚至无服务器架构的。需要长时间运行的、以人为中心的工作流的业务应用程序将运行在消息代理之上，在流程的中间步骤使用业务事件或产生这样的事件。这些都是 EDA 和现代数字企业非常重要的元素。

在图 1 的左侧，我们可以看到不同的数据源:这些数据需要注入到事件主干中，这样数据就可以对任何消费者可见。

不同的解决方案可用于注入此类数据，而**变更数据捕获**技术应被视为将非绿色领域应用程序引入现代分布式和以事件为中心的世界的解决方案。

在图 1 的右侧，有一个非常重要的元素需要考虑:云数据湖:这是大数据处理、人工智能模型构建和所有特色工程发生的地方。这是一个高度可扩展的环境，支持大量结构化或非结构化数据。

像 Kafka 这样的事件主干被用作这些现代数据湖的数据注入，但也支持对数据流的近实时分析。

事件驱动架构的成熟采用与流分析、人工智能和 API 市场相集成，以帮助业务团队实现新的领先解决方案。其中包括持续情报、情境决策、全球生态系统运营和事件衍生洞察的货币化。

架构图的下一行显示了这样的能力:在大数据平台上开发的 AI 模型和预测评分可以用于近实时地对事件通知进行评分。可以使用不同的技术，我们使用 Apache Flink 或 Apache Spark 来支持这些分析。也可以使用 Kafka Stream，但是它与 Kafka 有很强的耦合性，因此应用清晰的关注点分离原则，考虑将 Flink 作为更好的替代方案是很有趣的，因为开发人员通过使用 Flink 获得的技能可以用于其他平台，也可以用于静态数据。

最后，还有一些新的应用程序可以集成到这个架构中，目标是支持复杂的事件处理语义。Apache Flink 有一个 [CEP 引擎](https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/libs/cep/)，它处理事件排序模式，从事件模式中派生出新的合成事件，或者可能触发 BPM 或基于规则的系统中的业务操作。

Flink 是一个非常好的平台，可以独立于 Kafka 支持您的数据流、SQL 和 CEP。

我想我涵盖了这种新的 EDA 参考架构的所有元素。更多即将推出…