<html>
<head>
<title>Advanced Machine Learning Techniques for Predicting Maize Crop Yield using Sentinel-2 Satellite Imagery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Sentinel-2卫星图像预测玉米作物产量的先进机器学习技术</h1>
<blockquote>原文：<a href="https://medium.com/codex/advanced-deep-learning-techniques-for-predicting-maize-crop-yield-using-sentinel-2-satellite-1b63ac8b0789?source=collection_archive---------2-----------------------#2021-03-06">https://medium.com/codex/advanced-deep-learning-techniques-for-predicting-maize-crop-yield-using-sentinel-2-satellite-1b63ac8b0789?source=collection_archive---------2-----------------------#2021-03-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b9921541a429d9b17cc4607d11903345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kvdQ8lz5hgm8fO9iAz70uQ.jpeg"/></div></div></figure><h1 id="2eff" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">简介</strong></h1><p id="dfd3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">对田间作物变异性的预测可以帮助农民在不同情况下做出正确的决策。当前在<strong class="jq hj">遥感</strong>和<strong class="jq hj">高分辨率、高频率和免费的Sentinel-2图像</strong>方面的进步改善了精准农业在更广泛农民中的实施。</p><p id="5ecf" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这个故事的目的是创建一个模型，能够估计东非<strong class="jq hj">田地的玉米产量。给定一个时间序列</strong> <a class="ae kr" href="https://scihub.copernicus.eu/dhus/#/home" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">【哨兵2】图像</strong> </a>和<strong class="jq hj">气候变量</strong>。该模型将能够评估<strong class="jq hj">玉米<em class="ks">玉蜀黍</em>粮食产量</strong> <strong class="jq hj">每英亩吨的空间变异性。<br/> </strong>本故事使用的数据来自<strong class="jq hj"> </strong> <a class="ae kr" href="https://zindi.africa/competitions/cgiar-crop-yield-prediction-challenge/data" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">津迪</strong> </a> <strong class="jq hj">。</strong></p><h2 id="855d" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak">这个故事研究了植被指数(VIs)和先进的深度学习技术在预测玉米作物产量中的应用。</strong></h2></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="0da7" class="iq ir hi bd is it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn bi translated"><strong class="ak">为什么是哨兵？</strong></h1><p id="5b38" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Sentinel-2数据为区域和全球农业监测创造了新的机会，因为它能够以10-20米的空间分辨率在12个光谱带中观察地球，覆盖全球，重访频率为5天，并与当前和历史上的Landsat任务兼容。监测土壤性质和作物状况，以及绘制耕作活动图，有助于研究人员和农民评估土地使用情况，预测收成，监测季节变化，并协助实施可持续发展政策。随着可用的卫星数据源越来越多，其中许多可以免费使用，潜力是巨大的<strong class="jq hj">(</strong><a class="ae kr" href="https://www.sentinel-hub.com/explore/industries-and-showcases/agriculture/" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj"><em class="ks">Sentinel-hub，2021</em></strong></a><strong class="jq hj"><em class="ks">)</em>。</strong></p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/272630164867bfb1c9ec99a8efee8a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jblJ2kCS9Nkt8WmZ1GO5jw.png"/></div></div></figure><h1 id="3fef" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">玉米作物产量预测的重要Sentinel-2波段</strong></h1><p id="b3a8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在每个模型被训练并用于预测之后，计算用于预测的所有特征的特征重要性。发现对模型准确性贡献更大的重要sentinel-2波段主要是红边波段，尤其是<strong class="jq hj">红边3(波段7) </strong>。此外，<strong class="jq hj">短波红外(波段10) </strong>也被称为<strong class="jq hj">卷云</strong>和<strong class="jq hj">近红外窄波段(波段8A) </strong>对预测模型有益。</p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><figure class="lu lv lw lx fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/d66fff77a9fa10ece996cc843d2e0d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*-883q9A18AVWB2OnwbDHyA.jpeg"/></div></figure><h1 id="c951" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> <em class="lz">玉米作物产量预测的重要植被指标</em> </strong></h1><p id="2cc1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我使用了我在自定义脚本 的<a class="ae kr" href="https://custom-scripts.sentinel-hub.com/custom-scripts/sentinel-2/indexdb/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> Sentinel hub库中发现的各种光谱植被指数(VI)。然而，在40个不同的VI中，我发现25个仅在预测玉米作物产量方面有意义。</strong></a></p><p id="89cf" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">下表1 </strong>列出了用于估算作物产量的候选VI。这些植被指数的重要性在最近的研究中得到了确认，这些研究侧重于基于卫星的作物生产和产量估计。然而，我的综述表明，与作物产量有密切关系的植被指数通常包括红边波长，或者被设计成对冠层叶绿素含量敏感。注意到这一点，我决定在Zindi CGIAR作物产量预测挑战赛<strong class="jq hj">的<strong class="jq hj"> </strong>获胜者编写的脚本</strong>  <strong class="jq hj"> </strong>中使用<a class="ae kr" href="https://github.com/Az-Ks/CGIAR_Solution_Code_To_Get_4th_Place/blob/main/CGIAR_SOLUTION_4th_Place.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">函数。</strong>该函数从Sentinel-2图像的三个红边波段得出重要特征。<strong class="jq hj">(注意:该函数存在于下面的代码中。)</strong></a></p><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/bb389cd15dacd1b8c230b362e560391b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYUCoR3XM4yD5gNGVS7ltA.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx translated">表1:预测玉米作物产量的重要植被指数</figcaption></figure></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/d855329f0ed93bcd0bfbecd96456505e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2YVZNi8Ft5c5S4VnmF0vQ.jpeg"/></div></div></figure><h1 id="3a9a" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">气候变量的重要性</strong></h1><p id="9731" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在提供的数据集中，气候变量来自<a class="ae kr" href="http://www.climatologylab.org/terraclimate.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> Terraclimate </strong> </a>。<strong class="jq hj"> TerraClimate </strong>是1958-2019年全球陆地表面每月气候和气候水平衡的数据集。<strong class="jq hj">地形气候</strong>数据具有月时间分辨率和大约4千米(1/24度)的空间分辨率。</p><p id="d172" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">地形气候变量是<strong class="jq hj">最高温度、最低温度、水汽压、降水累积、向下地表短波辐射、风速、参考蒸散量(ASCE Penman-Montieth)、径流量、实际蒸散量、气候水分亏缺、土壤水分、雪水当量、帕尔默干旱严重指数、水汽压亏缺。</strong></p><p id="fe25" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">除了<strong class="jq hj"> SWE(雪水当量)之外，用于预测的地形气候变量由上面列出的变量组成。</strong></p><p id="8a69" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">注:</strong>在所有用于预测的特征中，气候变量被证明更为重要。<strong class="jq hj">如何？…影响模型准确性的前七(7)个重要特征是气候变量。</strong></p><h2 id="35ba" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak"> <em class="lz">这是利用5 Xgboost算法<strong class="ak"> <em class="lz">内置的</em> </strong>特性重要性实现的。</em>T15】</strong></h2><figure class="lu lv lw lx fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/31ecf9c4bb76cb8c004eca18a0334d24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*bgoykxrz890HgcJFmW5w_g.png"/></div><figcaption class="mb mc et er es md me bd b be z dx translated">表2:前七(7)个重要气候变量</figcaption></figure></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/aed0684ed8eb301500617a39bebc5b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ldvh5hjzHbcX75LCPAEzg.jpeg"/></div></div></figure><h1 id="d339" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">重要的土壤相关特征</strong></h1><p id="5029" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">竞赛土壤数据来自<a class="ae kr" href="https://www.isric.org/explore/soilgrids/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> ISRIC世界土壤信息</strong> </a>。土壤网格数据的每个资产都是一幅包含6个波段的图像，每个波段对应一个深度(0–5厘米、5–15厘米、15–30厘米、30–60厘米、60–100厘米、100–200厘米)。然而，比赛的土壤数据只有5至15厘米深的条带。</p><p id="dbd5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">有助于作物产量模型准确性的前四个重要土壤相关特征是<strong class="jq hj">pH7时的阳离子交换容量(cec_mean或cec)、淤泥(淤泥_mean)、总氮(氮_mean)和有机碳密度(ocd_mean)。</strong></p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="00e1" class="iq ir hi bd is it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn bi translated">建模</h1><h2 id="1681" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak">导入库</strong></h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="8d24" class="kt ir hi mj b fi mn mo l mp mq">import os<br/>import random<br/>import sklearn<br/>import numpy as np<br/>import pandas as pd<br/>import seaborn as sns<br/>import lightgbm as lgb<br/>from lightgbm import LGBMRegressor<br/>from matplotlib import pyplot as plt<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import mean_squared_log_error<br/>pd.set_option(‘display.max_columns’, None)<br/>import math as Math<br/>from sklearn.metrics import log_loss<br/>from sklearn.model_selection import KFold<br/>RANDOM_STATE = 42</span></pre><h2 id="12a1" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak">减少内存使用的功能</strong></h2><p id="1582" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><em class="ks">注意:该函数通过将每一列的数据类型转换为最少的数据类型来减少内存使用，例如，将浮点64转换为浮点16。这是因为较高的数据类型比较低的数据类型(如float16)消耗更多的内存。</em></p><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="e43c" class="kt ir hi mj b fi mn mo l mp mq">def reduce_mem_usage(df, verbose=True):<br/>    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']<br/>    start_mem = df.memory_usage().sum() / 1024**2    <br/>    for col in df.columns:<br/>        col_type = df[col].dtypes<br/>        if col_type in numerics:<br/>            c_min = df[col].min()<br/>            c_max = df[col].max()<br/>            if str(col_type)[:3] == 'int':<br/>                if c_min &gt; np.iinfo(np.int8).min and c_max &lt; np.iinfo(np.int8).max:<br/>                    df[col] = df[col].astype(np.int8)<br/>                elif c_min &gt; np.iinfo(np.int16).min and c_max &lt; np.iinfo(np.int16).max:<br/>                    df[col] = df[col].astype(np.int16)<br/>                elif c_min &gt; np.iinfo(np.int32).min and c_max &lt; np.iinfo(np.int32).max:<br/>                    df[col] = df[col].astype(np.int32)<br/>                elif c_min &gt; np.iinfo(np.int64).min and c_max &lt; np.iinfo(np.int64).max:<br/>                    df[col] = df[col].astype(np.int64)  <br/>            else:<br/>                if c_min &gt; np.finfo(np.float16).min and c_max &lt; np.finfo(np.float16).max:<br/>                    df[col] = df[col].astype(np.float16)<br/>                elif c_min &gt; np.finfo(np.float32).min and c_max &lt; np.finfo(np.float32).max:<br/>                    df[col] = df[col].astype(np.float32)<br/>                else:<br/>                    df[col] = df[col].astype(np.float64)    <br/>    end_mem = df.memory_usage().sum() / 1024**2<br/>    if verbose: print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (start_mem - end_mem) / start_mem))<br/>    return df</span></pre><h2 id="15bd" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak">加载数据集</strong></h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="2e34" class="kt ir hi mj b fi mn mo l mp mq">#Path to Data Folder<br/>link = 'C:/Crop Yield Prediction/'</span><span id="608f" class="kt ir hi mj b fi mr mo l mp mq">#Training dataframe<br/>train_df = pd.read_csv(link + 'Train.csv')</span><span id="8909" class="kt ir hi mj b fi mr mo l mp mq">#years for the test fields<br/>test_field_ids_years_df = pd.read_csv(link + 'test_field_ids_with_year.csv') </span><span id="2a36" class="kt ir hi mj b fi mr mo l mp mq">#additional soil and climate information<br/>add_info_df = pd.read_csv(link + 'fields_w_additional_info.csv') </span><span id="0d20" class="kt ir hi mj b fi mr mo l mp mq">#Sample Submission File<br/>ss = pd.read_csv(link + 'SampleSubmission.csv')</span></pre><h2 id="34f5" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak">查看卫星图像</strong></h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="3a73" class="kt ir hi mj b fi mn mo l mp mq">train_folder =  'C:/Crop Yield Prediction/image_arrays_train/image_arrays_train/'</span><span id="ca9c" class="kt ir hi mj b fi mr mo l mp mq">fid = train_df['Field_ID'].sample().values[0]</span><span id="e10d" class="kt ir hi mj b fi mr mo l mp mq">fn =  train_folder + fid + '.npy' <br/>              <br/>print(f'Loading {fn} as an array')</span><span id="c7f6" class="kt ir hi mj b fi mr mo l mp mq">#Loading the data with numpy<br/>arr = np.load(fn)</span><span id="ad3e" class="kt ir hi mj b fi mr mo l mp mq">#360 bands, images 40 or 41px a side<br/>print('Array shape:', arr.shape)</span><span id="2c09" class="kt ir hi mj b fi mr mo l mp mq">#Combine three bands for viewing<br/>rgb_jan = np.stack([arr[4], arr[3], arr[2]], axis=-1)</span><span id="7a18" class="kt ir hi mj b fi mr mo l mp mq">#Scale band values to (0, 1) for easy image display<br/>rgb_jan = rgb_jan / np.max(rgb_jan)</span><span id="dbcc" class="kt ir hi mj b fi mr mo l mp mq">#View with matplotlib<br/>plt.imshow(rgb_jan)</span></pre><figure class="lu lv lw lx fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/3b7e4280f3079aa4d0b76ae374f53701.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*KgnmrXDh9CikONtPh8i-lQ.png"/></div></figure><h2 id="3dc7" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak">查看12个月的伪彩色图像</strong></h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="50c7" class="kt ir hi mj b fi mn mo l mp mq">fig, axs = plt.subplots(3, 4, figsize=(12, 8), facecolor='w', edgecolor='k')<br/>fig.subplots_adjust(hspace = .5, wspace=.001)<br/>axs = axs.ravel()<br/>for i  in range(12):<br/>  #False colour (band 8, 4 and 3)<br/>  rgb = np.stack([arr[i*30 +8], arr[i*30 + 4], arr[i*30 + 3]], axis=-1)<br/>  #Scaling consistently<br/>  rgb = rgb / 4000 <br/>  axs[i].imshow(rgb.clip(0, 1))<br/>  axs[i].set_title(str(i+1))</span></pre><figure class="lu lv lw lx fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/0c05e6a27e83c492d7ffe481f064ba35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*stnxYMBLWaRZ625IgrJdMQ.png"/></div></figure><h2 id="a17f" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak">查看图像波段名称</strong></h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="6cc6" class="kt ir hi mj b fi mn mo l mp mq">band_names = [l.strip() for l in open(link + 'bandnames.txt', 'r').readlines()]<br/>print(band_names)</span></pre><figure class="lu lv lw lx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/7251e9afd5d5fc3e8949be7682222981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfk-xULtBq53RB-hIG8aTA.png"/></div></div></figure></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="0455" class="iq ir hi bd is it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn bi translated"><strong class="ak">特征工程提示</strong></h1><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="1a89" class="kt ir hi mj b fi mn mo l mp mq"><strong class="mj hj">1. Specify Bands of Interest and Average Center Points<br/>2. Average Climate Values Over 4 Years By Each Month in Maize Season in kenya for some Climate Variables<br/>3. Generate Statistics for vegetation indices covering a whole sentinel-2 imagery<br/>4. Use of Significant Vegetation Indices<br/>5. Generate Statistics from Vegetation Indices (Max, Min, Median)<br/>6. Generate Median Features From Red Bands <br/></strong></span></pre><p id="490e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj"> <em class="ks">注</em> </strong> <em class="ks">:下面的Python函数是特征工程函数。</em></p><h2 id="d6c8" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak">指定感兴趣的波段和平均中心点</strong></h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="8fc7" class="kt ir hi mj b fi mn mo l mp mq"># Center Point 20<br/>def process_im_20(fid, folder='C:/Crop Yield Prediction/image_arrays_train/image_arrays_train/'):<br/>    <br/>  fn = f'{folder}/{fid}.npy'<br/>  arr = np.load(fn)<br/>  bands_of_interest = ['S2_B12', 'S2_B11', 'S2_B10', 'S2_B9', 'S2_B8', 'S2_B8A', 'S2_B7', 'S2_B6', 'S2_B5',<br/>                       'S2_B4', 'S2_B3', 'S2_B2', 'S2_B1', 'CLIM_pr', 'CLIM_soil', 'CLIM_aet', 'CLIM_def', <br/>                       'CLIM_pdsi', 'CLIM_pet', 'CLIM_ro', 'CLIM_srad', 'CLIM_swe', 'CLIM_tmmn', 'CLIM_tmmx', <br/>                       'CLIM_vap', 'CLIM_vpd', 'CLIM_vs']<br/>  values = {}<br/>  for month in range(2, 9):<br/>    bns = [str(month) + '_' + b for b in bands_of_interest] <br/>    idxs = np.where(np.isin(band_names, bns)) # Index of these bands<br/>    vs = arr[idxs, 20, 20] # Sample the im at the center point<br/>    for bn, v in zip(bns, vs[0]):<br/>      values[bn] = v<br/>  return values</span><span id="fd10" class="kt ir hi mj b fi mr mo l mp mq"># Center point_30_10<br/>def process_im_30_10(fid, folder='C:/Crop Yield Prediction/image_arrays_train/image_arrays_train/'):<br/>    <br/>  fn = f'{folder}/{fid}.npy'<br/>  arr = np.load(fn)<br/>  bands_of_interest = ['S2_B12', 'S2_B11', 'S2_B10', 'S2_B9', 'S2_B8', 'S2_B8A', 'S2_B7', 'S2_B6', 'S2_B5',<br/>                       'S2_B4', 'S2_B3', 'S2_B2', 'S2_B1', 'CLIM_pr', 'CLIM_soil', 'CLIM_aet', 'CLIM_def', <br/>                       'CLIM_pdsi', 'CLIM_pet', 'CLIM_ro', 'CLIM_srad', 'CLIM_swe', 'CLIM_tmmn', 'CLIM_tmmx', <br/>                       'CLIM_vap', 'CLIM_vpd', 'CLIM_vs']<br/>  values = {}<br/>  for month in range(2, 9):<br/>    bns = [str(month) + '_' + b for b in bands_of_interest] # Bands of interest for this month <br/>    idxs = np.where(np.isin(band_names, bns)) # Index of these bands<br/>    vs = arr[idxs, 30, 10] # Sample the im at the center point<br/>    for bn, v in zip(bns, vs[0]):<br/>      values[bn] = v<br/>  return values</span><span id="3fd1" class="kt ir hi mj b fi mr mo l mp mq"># Center point_10_30<br/>def process_im_10_30(fid, folder='C:/Crop Yield Prediction/image_arrays_train/image_arrays_train/'):<br/>    <br/>  fn = f'{folder}/{fid}.npy'<br/>  arr = np.load(fn)<br/>  bands_of_interest = ['S2_B12', 'S2_B11', 'S2_B10', 'S2_B9', 'S2_B8', 'S2_B8A', 'S2_B7', 'S2_B6', 'S2_B5',<br/>                       'S2_B4', 'S2_B3', 'S2_B2', 'S2_B1', 'CLIM_pr', 'CLIM_soil', 'CLIM_aet', 'CLIM_def', <br/>                       'CLIM_pdsi', 'CLIM_pet', 'CLIM_ro', 'CLIM_srad', 'CLIM_swe', 'CLIM_tmmn', 'CLIM_tmmx', <br/>                       'CLIM_vap', 'CLIM_vpd', 'CLIM_vs']<br/>  values = {}<br/>  for month in range(2, 9):<br/>    bns = [str(month) + '_' + b for b in bands_of_interest] # Bands of interest for this month <br/>    idxs = np.where(np.isin(band_names, bns)) # Index of these bands<br/>    vs = arr[idxs, 10, 30] # Sample the im at the center point<br/>    for bn, v in zip(bns, vs[0]):<br/>      values[bn] = v<br/>  return values</span></pre><h2 id="fe7d" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak">肯尼亚四年来每个玉米季节月份的平均气候变量</strong></h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="dd9d" class="kt ir hi mj b fi mn mo l mp mq">def average_variables(add_info_df, special_cols) : <br/> <br/> additional_ = pd.DataFrame()<br/> climat = [‘pr’,’tmmn’,’tmmx’]</span><span id="af32" class="kt ir hi mj b fi mr mo l mp mq">for month in range(2, 9): <br/> for climat_ in climat :<br/> features_ = []<br/> for year in [2016,2017,2018,2019] :<br/> features_.append(‘climate_’+str(year) + ‘_’ + str(month) + f’_{climat_}’ )<br/> additional_[f’Average_for_4_Years_Variables{month-1}_{climat_}’] = add_info_df[features_].mean(axis=1)<br/> <br/> # Soil Columns<br/> for col in special_cols : <br/> additional_[col] = add_info_df[col]<br/> return additional_</span></pre><h2 id="9b91" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak">覆盖整个sentinel-2影像的植被指数统计</strong></h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="a0be" class="kt ir hi mj b fi mn mo l mp mq"># SAVI<br/>def get_SAVI_data(fid, folder=None) :<br/>  fn = f'{folder}/{fid}.npy'<br/>  arr = np.load(fn)<br/>  bands_of_interest = ['S2_B4', 'S2_B8']<br/>  L = 0.725<br/>  values = {}<br/>  <br/>  for month in range(12): <br/>    bns = [str(month) + '_' + b for b in bands_of_interest] <br/>    idxs = np.where(np.isin(band_names, bns)) <br/>    B08 = arr[idxs][1].astype(int)<br/>    B04 = arr[idxs][0].astype(int)<br/>    <br/>    SAVI_arr = (B08 - B04) / (B08 + B04 + L) * (1.0 + L)<br/>    values['SAVI_Max_'+str(month)] = SAVI_arr.max()<br/>  <br/>  return values</span><span id="bdc7" class="kt ir hi mj b fi mr mo l mp mq"># EVI<br/>def get_EVI_data(fid, folder=None) :<br/>  fn = f'{folder}/{fid}.npy'<br/>  arr = np.load(fn)<br/>  bands_of_interest = ['S2_B4', 'S2_B8','S2_B2']<br/>  values = {}<br/>  <br/>  for month in range(12): <br/>    bns = [str(month) + '_' + b for b in bands_of_interest] <br/>    idxs = np.where(np.isin(band_names, bns)) <br/>    B08 = arr[idxs][1].astype(int)<br/>    B04 = arr[idxs][0].astype(int)<br/>    B02 = arr[idxs][2].astype(int)<br/>    <br/>    EVI_arr = 2.5 * (B08 - B04) / ((B08 + 6.0 * B04 - 7.5 * B02) + 1.0)<br/>    values['EVI_Median_'+str(month)] = np.median(EVI_arr)<br/>  <br/>  for month in range(12):<br/>    bns = [str(month) + '_' + b for b in bands_of_interest] <br/>    idxs = np.where(np.isin(band_names, bns)) <br/>    B08 = arr[idxs][1].astype(int)<br/>    B04 = arr[idxs][0].astype(int)<br/>    B02 = arr[idxs][2].astype(int)<br/>    <br/>    EVI_arr = 2.5 * (B08 - B04) / ((B08 + 6.0 * B04 - 7.5 * B02) + 1.0)<br/>    values['EVI_Max_'+str(month)] = EVI_arr.max()<br/>  <br/>  return values</span><span id="b92b" class="kt ir hi mj b fi mr mo l mp mq"># NDVI<br/>def get_NDVI_data(fid, folder=None) :<br/>  fn = f'{folder}/{fid}.npy'<br/>  arr = np.load(fn)<br/>  bands_of_interest = ['S2_B4', 'S2_B8']<br/>  values = {}<br/>  <br/>  for month in range(12): <br/>    bns = [str(month) + '_' + b for b in bands_of_interest] <br/>    idxs = np.where(np.isin(band_names, bns)) <br/>    <br/>    NDVI_arr = (arr[idxs][1].astype(int)-arr[idxs][0].astype(int)) / (arr[idxs][1].astype(int)+arr[idxs][0].astype(int))<br/>    values['NDVI_Median_'+str(month)] = np.median(NDVI_arr)<br/>  <br/>  for month in range(12): <br/>    bns = [str(month) + '_' + b for b in bands_of_interest] <br/>    idxs = np.where(np.isin(band_names, bns)) <br/>    <br/>    NDVI_arr = (arr[idxs][1].astype(int)-arr[idxs][0].astype(int)) / (arr[idxs][1].astype(int)+arr[idxs][0].astype(int))<br/>    values['NDVI_Min_'+str(month)] = NDVI_arr.min()<br/>    values['NDVI_Max_'+str(month)] = NDVI_arr.max()<br/> <br/>  return values</span><span id="c5a6" class="kt ir hi mj b fi mr mo l mp mq"># NDWI<br/>def get_NDWI_data(fid, folder=None) :<br/>  fn = f'{folder}/{fid}.npy'<br/>  arr = np.load(fn)<br/>  bands_of_interest = ['S2_B8', 'S2_B3']<br/>  values = {}<br/>  <br/>  for month in range(12): <br/>    bns = [str(month) + '_' + b for b in bands_of_interest] <br/>    idxs = np.where(np.isin(band_names, bns)) <br/>    <br/>    NDVI_arr = (arr[idxs][1].astype(int)-arr[idxs][0].astype(int)) / (arr[idxs][1].astype(int)+arr[idxs][0].astype(int))<br/>    values['NDWI_Median_'+str(month)] = np.median(NDVI_arr)<br/>  <br/>  for month in range(12): <br/>    bns = [str(month) + '_' + b for b in bands_of_interest] <br/>    idxs = np.where(np.isin(band_names, bns)) <br/>    <br/>    NDVI_arr = (arr[idxs][1].astype(int)-arr[idxs][0].astype(int)) / (arr[idxs][1].astype(int)+arr[idxs][0].astype(int))<br/>    values['NDWI_Min_'+str(month)] = NDVI_arr.min()<br/>    values['NDWI_Max_'+str(month)] = NDVI_arr.max()<br/> <br/>  return values</span><span id="e8c4" class="kt ir hi mj b fi mr mo l mp mq"># NDMI<br/>def get_NDMI_data(fid, folder=None) :<br/>  fn = f'{folder}/{fid}.npy'<br/>  arr = np.load(fn)<br/>  bands_of_interest = ['S2_B11', 'S2_B8']<br/>  values = {}<br/>  <br/>  for month in range(12): <br/>    bns = [str(month) + '_' + b for b in bands_of_interest] <br/>    idxs = np.where(np.isin(band_names, bns)) <br/>    <br/>    NDVI_arr = (arr[idxs][1].astype(int)-arr[idxs][0].astype(int)) / (arr[idxs][1].astype(int)+arr[idxs][0].astype(int))<br/>    values['NDMI_Median_'+str(month)] = np.median(NDVI_arr)<br/>  <br/>  for month in range(12): <br/>    bns = [str(month) + '_' + b for b in bands_of_interest] <br/>    idxs = np.where(np.isin(band_names, bns)) <br/>    <br/>    NDVI_arr = (arr[idxs][1].astype(int)-arr[idxs][0].astype(int)) / (arr[idxs][1].astype(int)+arr[idxs][0].astype(int))<br/>    values['NDMI_Min_'+str(month)] = NDVI_arr.min()<br/>    values['NDMI_Max_'+str(month)] = NDVI_arr.max()<br/> <br/>  return values</span></pre><h2 id="85f3" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak">植被指数</strong></h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="5dc9" class="kt ir hi mj b fi mn mo l mp mq">def vegetation_indices(train_sampled):<br/>    <br/>    # NDVI = NIR-Red/NIR+Red = Band8-Band4/Band8+Band4<br/>    for i in range(2, 10):<br/>        train_sampled['NDVI_Month_' + str(i)] = (train_sampled[str(i) + '_S2_B8'] - train_sampled[str(i) + '_S2_B4'])/(train_sampled[str(i) + '_S2_B8'] + train_sampled[str(i) + '_S2_B4'])</span><span id="0dfa" class="kt ir hi mj b fi mr mo l mp mq">    # SAVI = ((NIR - RED)/ (NIR + RED + L))*(1 + L)<br/>    for i in range(2, 10):<br/>        train_sampled['SAVI_Month_' + str(i)] = ((train_sampled[str(i) + '_S2_B8']<br/>                                                  - train_sampled[str(i) + '_S2_B4']) / (train_sampled[str(i) + '_S2_B8']<br/>                                                 + train_sampled[str(i) + '_S2_B4'] + 1)) * (1 + 1)</span><span id="975a" class="kt ir hi mj b fi mr mo l mp mq">    # ARVI = (NIR – (2 * Red) + Blue) / (NIR + (2 * Red) + Blue)<br/>    for i in range(2, 10):<br/>        train_sampled['ARVI_Month_' + str(i)] = (train_sampled[str(i) + '_S2_B8']<br/>                                                 -(2*train_sampled[str(i) + '_S2_B4']) <br/>                                                 + train_sampled[str(i) + '_S2_B2']) / (train_sampled[str(i) + '_S2_B8']<br/>                                                 +(2*train_sampled[str(i) + '_S2_B4']) <br/>                                                 + train_sampled[str(i) + '_S2_B2'])</span><span id="5e61" class="kt ir hi mj b fi mr mo l mp mq">    # GCI = (NIR) / (Green) – 1<br/>    for i in range(2, 10):<br/>        train_sampled['GCI_Month_' + str(i)] = (train_sampled[str(i) + '_S2_B8'])/(train_sampled[str(i) + '_S2_B3'])-1</span><span id="ed0d" class="kt ir hi mj b fi mr mo l mp mq">    # NDWI = (NIR-SWIR)/(NIR+SWIR)<br/>    for i in range(2, 10):<br/>        train_sampled['NDWI_Month_' + str(i)] = (train_sampled[str(i) + '_S2_B3']<br/>                                                    - train_sampled[str(i) + '_S2_B8'])/(train_sampled[str(i) + '_S2_B3']<br/>                                                                                         + train_sampled[str(i) + '_S2_B8'])</span><span id="1ca3" class="kt ir hi mj b fi mr mo l mp mq">    # RVI = (NIR/RED)<br/>    for i in range(2, 10):<br/>         train_sampled['RVI_Month_' + str(i)] = (train_sampled[str(i) + '_S2_B8']) / (train_sampled[str(i) + '_S2_B4'])</span><span id="585e" class="kt ir hi mj b fi mr mo l mp mq">    # OSAVI ((1.0 + 0.16) * (B08 - B04) / (B08 + B04 + 0.16))<br/>    for i in range(2, 10):<br/>         train_sampled['OSAVI_Month_' + str(i)] = ((1 + 0.16) * (train_sampled[str(i) + '_S2_B8'] - train_sampled[str(i) + '_S2_B4'])/<br/>                                                  (train_sampled[str(i) + '_S2_B8'] + train_sampled[str(i) + '_S2_B4'] + 0.16))</span><span id="feec" class="kt ir hi mj b fi mr mo l mp mq">    # SLAVI = B08 / (B04 + B12)<br/>    for i in range(2, 10):<br/>         train_sampled['SLAVI_Month_' + str(i)] =  ((train_sampled[str(i) + '_S2_B8'])/ (train_sampled[str(i) + '_S2_B4'] +  train_sampled[str(i) + '_S2_B12']))</span><span id="d2e1" class="kt ir hi mj b fi mr mo l mp mq">    # NPCRI (b4-b2)/(b4 + b2)<br/>    for i in range(2, 10):<br/>         train_sampled['NPCRI_Month_' + str(i)] =  ((train_sampled[str(i) + '_S2_B4'] - train_sampled[str(i) + '_S2_B2'])/(train_sampled[str(i) + '_S2_B4'] + train_sampled[str(i) + '_S2_B2']))</span><span id="f26b" class="kt ir hi mj b fi mr mo l mp mq">    # Soil Composition Index = (B11 - B08) / (B11 + B08)<br/>    for i in range(2, 10):<br/>         train_sampled['SCI_Month_' + str(i)] =  ((train_sampled[str(i) + '_S2_B11'] - train_sampled[str(i) + '_S2_B8']) / (train_sampled[str(i) + '_S2_B11'] + train_sampled[str(i) + '_S2_B8']))</span><span id="4164" class="kt ir hi mj b fi mr mo l mp mq"># SARVI (1.0 + L) * (B08 - (Rr - y * (RB - Rr))) / (B08 + -(Rr - y * (RB - Rr)) + L)     # y = 0.735; Rr = 0.740; L = 0.487; RB = 0.560;<br/>    for i in range(2, 10):<br/>         train_sampled['SARVI_Month_' + str(i)] =  (1.0 + 0.487) * (train_sampled[str(i) + '_S2_B8']- (0.740 - 0.735 * (0.560 - 0.740)))/  (train_sampled[str(i) + '_S2_B8'] + - (0.740 - 0.735 * (0.560 - 0.740)) + 0.487)</span><span id="b277" class="kt ir hi mj b fi mr mo l mp mq">    # ndmi = (b8 - b11) / (b8 + b11)<br/>    for i in range(2, 10):<br/>        train_sampled['NDMI_Month_' + str(i)] = (train_sampled[str(i) + '_S2_B8'] - train_sampled[str(i) + '_S2_B11'])/ (train_sampled[str(i) + '_S2_B8'] + train_sampled[str(i) + '_S2_B11'])<br/>        <br/>    # EVI_2 = 2.5 (NIR - RED)/(NIR + C2 * Blue + l)<br/>    for i in range(2, 9):<br/>        train_sampled['EVI_2_Month_' + str(i)] = 2.5* ((train_sampled[str(i) + '_S2_B8'] <br/>                                                      - train_sampled[str(i) + '_S2_B4'])/((train_sampled[str(i) + '_S2_B8']) + (2.4 * train_sampled[str(i) + '_S2_B4'])+1))<br/>        <br/>    return train_sampled</span></pre><h2 id="1dc1" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak">植被指数统计</strong></h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="f398" class="kt ir hi mj b fi mn mo l mp mq">def vegetation_index_statistics(train_sampled, spectral_indices = None):<br/>    for i in spectral_indices:<br/>        train_sampled[f'{i}_min'] = train_sampled.filter(regex = f'^{i}').min(axis = 1)<br/>        train_sampled[f'{i}_max'] = train_sampled.filter(regex = f'^{i}').max(axis = 1)<br/>        train_sampled[f'{i}_avg'] = train_sampled.filter(regex = f'^{i}').mean(axis = 1)<br/>        train_sampled[f'{i}_median'] = train_sampled.filter(regex = f'^{i}').median(axis = 1)<br/>    return train_sampled</span></pre><h2 id="1d44" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak">红色条带的中值特征</strong></h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="8dc0" class="kt ir hi mj b fi mn mo l mp mq">def get_features_from_Bands(fid, folder='C:/Crop Yield Prediction/image_arrays_train/image_arrays_train', bands=None, Band_Names=None) :<br/>    <br/>  fn = f'{folder}/{fid}.npy'<br/>  arr = np.load(fn)<br/>  <br/>  final_values = {}<br/>  for bands_idx in range(len(bands)) : <br/>    bands_of_interest = bands[bands_idx]<br/>    Name = Band_Names[bands_idx]<br/>    values = {}<br/>    for month in range(12):<br/>      bns = [str(month) + '_' + b for b in bands_of_interest] <br/>      idxs = np.where(np.isin(band_names, bns)) <br/>      Relation_arr = arr[idxs][1].astype(int) / arr[idxs][0].astype(int) <br/>      <br/>      values[f'BANDS_FEATURES_Median_{Name}_'+str(month)] = np.median(Relation_arr)<br/>    <br/>    final_values.update(values)<br/>  return final_values</span></pre></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="b888" class="iq ir hi bd is it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn bi translated">处理和准备—数据和特征</h1><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="8e39" class="kt ir hi mj b fi mn mo l mp mq">1 Apply the<strong class="mj hj"> Specify</strong> <strong class="mj hj">Bands of Interest and Average Center Points </strong>functions<br/>2 Apply the <strong class="mj hj">Reduce Memory Usage </strong>function<br/>3 Apply the <strong class="mj hj">Average Climate Values Over 4 Years </strong>function<br/>4 Apply the<strong class="mj hj"> Statistics for indices covering a whole sentinel-2 imagery </strong>function<br/>5 Apply the <strong class="mj hj">Vegetation indices </strong>function<br/>6 Apply the <strong class="mj hj">Statistic from Vegetation Indices </strong>function<br/>7 Apply the <strong class="mj hj">Median Features from Red Band</strong> function</span></pre><h2 id="ddcb" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated">应用<strong class="ak">指定</strong> <strong class="ak">感兴趣波段和平均中心点</strong>功能</h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="b598" class="kt ir hi mj b fi mn mo l mp mq"># Specify Bands of Interest and Center Point<br/>train_sampled_10 = pd.DataFrame([process_im_10_30(fid) for fid in train_df['Field_ID'].values])<br/>train_sampled_20 = pd.DataFrame([process_im_20(fid) for fid in train_df['Field_ID'].values])<br/>train_sampled_30 = pd.DataFrame([process_im_30_10(fid) for fid in train_df['Field_ID'].values])</span><span id="0b87" class="kt ir hi mj b fi mr mo l mp mq"># divide the three dataframes by each other<br/>train_sampled = 0<br/>train_sampled = (train_sampled_10 + train_sampled_20 + train_sampled_30)/ 3</span></pre><h2 id="a3bd" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated">应用<strong class="ak">减少内存使用</strong>功能</h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="8d74" class="kt ir hi mj b fi mn mo l mp mq">train_sampled = reduce_mem_usage(train_sampled)</span></pre><h2 id="1148" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated">应用<strong class="ak">4年平均气候值</strong>功能</h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="c93f" class="kt ir hi mj b fi mn mo l mp mq"># Average some specific Climate Variables for Additional Data<br/>special_cols = add_info_df.columns[:12] # define columns needed for averaging<br/>averaging_df = average_variables(add_info_df, special_cols)</span><span id="cf1b" class="kt ir hi mj b fi mr mo l mp mq">train_sampled['Yield'] = train_df['Yield'].values # Add in the field ID and yield<br/>train_sampled['Field_ID'] = train_df['Field_ID'].values<br/>train_sampled = pd.merge(train_sampled,averaging_df,on='Field_ID',how='left') # merge together with train_sampled using "field_id"</span></pre><h2 id="4197" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated">对覆盖整个sentinel-2图像的指数应用<strong class="ak">统计</strong>功能</h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="5b7a" class="kt ir hi mj b fi mn mo l mp mq">train_EVI = pd.DataFrame([get_EVI_data(train_df['Field_ID'].values[fid_idx], folder = 'C:/Crop Yield Prediction/image_arrays_train/image_arrays_train/') for fid_idx in tqdm(range(len(train_df['Field_ID'].values))) ])<br/>train_EVI['Field_ID'] = train_df['Field_ID'].values</span><span id="66bb" class="kt ir hi mj b fi mr mo l mp mq">train_SAVI = pd.DataFrame([get_SAVI_data(train_df['Field_ID'].values[fid_idx], folder = 'C:/Crop Yield Prediction/image_arrays_train/image_arrays_train/') for fid_idx in tqdm(range(len(train_df['Field_ID'].values))) ])<br/>train_SAVI['Field_ID'] = train_df['Field_ID'].values</span><span id="2b4f" class="kt ir hi mj b fi mr mo l mp mq">train_NDVI = pd.DataFrame([get_NDVI_data(train_df['Field_ID'].values[fid_idx], folder = 'C:/Crop Yield Prediction/image_arrays_train/image_arrays_train/') for fid_idx in tqdm(range(len(train_df['Field_ID'].values))) ])<br/>train_NDVI['Field_ID'] = train_df['Field_ID'].values</span><span id="f7df" class="kt ir hi mj b fi mr mo l mp mq">train_NDWI = pd.DataFrame([get_NDWI_data(train_df['Field_ID'].values[fid_idx], folder = 'C:/Crop Yield Prediction/image_arrays_train/image_arrays_train/') for fid_idx in tqdm(range(len(train_df['Field_ID'].values))) ])<br/>train_NDWI['Field_ID'] = train_df['Field_ID'].values</span><span id="b526" class="kt ir hi mj b fi mr mo l mp mq">train_NDMI = pd.DataFrame([get_NDMI_data(train_df['Field_ID'].values[fid_idx], folder = 'C:/Crop Yield Prediction/image_arrays_train/image_arrays_train/') for fid_idx in tqdm(range(len(train_df['Field_ID'].values))) ])<br/>train_NDMI['Field_ID'] = train_df['Field_ID'].values</span><span id="fd44" class="kt ir hi mj b fi mr mo l mp mq">train_sampled = pd.merge(train_sampled,train_EVI,on='Field_ID',how='left') # merge train_f together with train_sampled using "field_id"<br/>train_sampled = pd.merge(train_sampled,train_SAVI,on='Field_ID',how='left') # merge train_f together with train_sampled using "field_id"<br/>train_sampled = pd.merge(train_sampled,train_NDVI,on='Field_ID',how='left') # merge train_f together with train_sampled using "field_id"<br/>train_sampled = pd.merge(train_sampled,train_NDWI,on='Field_ID',how='left') # merge train_f together with train_sampled using "field_id"<br/>train_sampled = pd.merge(train_sampled,train_NDMI,on='Field_ID',how='left') # merge train_f together with train_sampled using "field_id"</span></pre><h2 id="ec50" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated">应用<strong class="ak">植被指数</strong>功能</h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="9fa6" class="kt ir hi mj b fi mn mo l mp mq">train_sampled = vegetation_indices(train_sampled)</span></pre><h2 id="8c26" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated">应用<strong class="ak">植被指数统计</strong>功能</h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="e0f3" class="kt ir hi mj b fi mn mo l mp mq">indices = ['NDVI', 'SARVI', 'SAVI', 'GCI', 'SCI', 'ARVI', 'SLAVI', 'RVI','OSAVI', 'NPCRI', 'NDMI', 'NDWI', 'EVI_2']</span><span id="4ce4" class="kt ir hi mj b fi mr mo l mp mq">train_sampled = vegetation_index_statistics(train_sampled, spectral_indices= indices)</span></pre><h2 id="7388" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated">应用红带功能中的<strong class="ak">中值特征</strong>和<strong class="ak"/></h2><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="fb90" class="kt ir hi mj b fi mn mo l mp mq">bands = [ [‘S2_B7’,’S2_B5'] ,[‘S2_B7’,’S2_B6']] <br/>names = [‘FEATURES_B7_B5’,’FEATURES_B7_B6'] <br/>train_f = pd.DataFrame([get_features_from_Bands(train_df[‘Field_ID’].values[fid_idx],bands=bands,Band_Names=names)<br/> for fid_idx in tqdm(range(len(train_df[‘Field_ID’].values))) ])<br/>train_f[‘Field_ID’] = train_df[‘Field_ID’].values # add the field_id to the tain_f dataframe<br/>train_sampled = pd.merge(train_sampled,train_f,on=’Field_ID’,how=’left’) # merge train_f together with train_sampled using “field_id”</span></pre><p id="5c98" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">注:</strong> <em class="ks">由于对数据进行数学运算，可能会出现缺失值。要发现数据中是否存在缺失值，请检查缺失值。</em></p><p id="4a92" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj">发现缺失值— </strong>如果存在缺失值，用每列中最常出现的缺失值填充。</p><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="df40" class="kt ir hi mj b fi mn mo l mp mq">def missing_zero_values_table(df):<br/>        zero_val = (df == 0.00).astype(int).sum(axis=0)<br/>        mis_val = df.isnull().sum()<br/>        mis_val_percent = 100 * df.isnull().sum() / len(df)<br/>        mz_table = pd.concat([zero_val, mis_val, mis_val_percent], axis=1)<br/>        mz_table = mz_table.rename(<br/>        columns = {0 : 'Zero Values', 1 : 'Missing Values', 2 : '% of Total Values'})<br/>        mz_table['Total Zero Missing Values'] = mz_table['Zero Values'] + mz_table['Missing Values']<br/>        mz_table['% Total Zero Missing Values'] = 100 * mz_table['Total Zero Missing Values'] / len(df)<br/>        mz_table['Data Type'] = df.dtypes<br/>        mz_table = mz_table[<br/>            mz_table.iloc[:,1] != 0].sort_values(<br/>        '% of Total Values', ascending=False).round(1)<br/>        print ("Your selected dataframe has " + str(df.shape[1]) + " columns and " + str(df.shape[0]) + " Rows.\n"      <br/>            "There are " + str(mz_table.shape[0]) +<br/>              " columns that have missing values.")<br/>#         mz_table.to_excel('D:/sampledata/missing_and_zero_values.xlsx', freeze_panes=(1,0), index = False)<br/>        return mz_table</span><span id="6d56" class="kt ir hi mj b fi mr mo l mp mq">missing_zero_values_table(train_sampled)</span><span id="6341" class="kt ir hi mj b fi mr mo l mp mq"># Fill with the most occurent value in each column<br/>train_sampled = train_sampled.fillna(train_sampled.mode().iloc[0])</span></pre></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="f334" class="iq ir hi bd is it lo iv iw ix lp iz ja jb lq jd je jf lr jh ji jj ls jl jm jn bi translated"><strong class="ak"> <em class="lz">培训和测试—交叉验证</em> </strong></h1><h2 id="f5b6" class="kt ir hi bd is ku kv kw iw kx ky kz ja jz la lb je kd lc ld ji kh le lf jm lg bi translated"><strong class="ak"> <em class="lz">实现了XGBoost算法。</em> </strong></h2><h1 id="e4a6" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">为什么是XGBoost？</strong></h1><ol class=""><li id="0c73" class="mv mw hi jq b jr js jv jw jz mx kd my kh mz kl na nb nc nd bi translated"><em class="ks">执行速度。</em></li><li id="9071" class="mv mw hi jq b jr ne jv nf jz ng kd nh kh ni kl na nb nc nd bi translated"><em class="ks">车型性能</em></li></ol><blockquote class="nj nk nl"><p id="2e0f" class="jo jp ks jq b jr km jt ju jv kn jx jy nm ko kb kc nn kp kf kg no kq kj kk kl hb bi translated">XGBoost是一种算法，最近一直主导着应用机器学习和针对<a class="ae kr" href="https://www.quora.com/What-is-structured-data-in-the-context-of-machine-learning" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj"/></a>结构化或表格化数据的<a class="ae kr" href="https://www.kaggle.com/competitions" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj"/></a>。XGBoost是梯度提升决策树的实现，旨在提高速度和性能。</p></blockquote><ul class=""><li id="c89d" class="mv mw hi jq b jr km jv kn jz np kd nq kh nr kl ns nb nc nd bi translated">当讨论执行速度时，XGBoost很快。与梯度增强的其他实现相比，速度非常快。</li><li id="05ba" class="mv mw hi jq b jr ne jv nf jz ng kd nh kh ni kl ns nb nc nd bi translated">XGBoost在分类和回归预测建模问题上主导结构化或表格化数据集。证据是，它是Kaggle竞争数据科学平台上竞赛获胜者的首选算法。</li></ul><pre class="lu lv lw lx fd mi mj mk ml aw mm bi"><span id="3f80" class="kt ir hi mj b fi mn mo l mp mq">from sklearn.model_selection import KFold<br/>import xgboost as xgb<br/>from sklearn.metrics import mean_squared_error</span><span id="b49f" class="kt ir hi mj b fi mr mo l mp mq">X, y  = train_sampled.drop(['Field_ID'],axis=1), train_df['Yield']</span><span id="4972" class="kt ir hi mj b fi mr mo l mp mq">kf = KFold(n_splits =5,shuffle=True,random_state=160)<br/>feats = pd.DataFrame({'features': X.columns}) <br/>gbm_predictions = []<br/>cv_score_ = 0<br/>oof_preds = np.zeros((train_df.shape[0],))</span><span id="93d0" class="kt ir hi mj b fi mr mo l mp mq">for i,(tr_index,test_index) in enumerate(kf.split(X,y)):<br/>    print()<br/>    print(f'######### FOLD {i+1} / {kf.n_splits} ')</span><span id="649b" class="kt ir hi mj b fi mr mo l mp mq">X_train,y_train = X.iloc[tr_index,:],y[tr_index]<br/>    X_test,y_test = X.iloc[test_index,:],y[test_index]<br/>    <br/>    gbm = xgb.XGBRegressor(eval_metric = 'rmse',n_estimators = 2000,learning_rate = 0.001,seed=162,random_state = 162,colsample_bytree=0.65)</span><span id="4d86" class="kt ir hi mj b fi mr mo l mp mq">gbm.fit(X_train,y_train,eval_set = [(X_test, y_test)],early_stopping_rounds = 200,verbose=100)</span><span id="1f0e" class="kt ir hi mj b fi mr mo l mp mq">cv_score_ += mean_squared_error(y_test, gbm.predict(X_test), squared=False) / kf.n_splits<br/>    oof_preds[test_index] = gbm.predict(X_test)</span><span id="ce53" class="kt ir hi mj b fi mr mo l mp mq">preds = gbm.predict(test_sampled[X_train.columns])<br/>    gbm_predictions.append(preds)</span><span id="9e94" class="kt ir hi mj b fi mr mo l mp mq">feats[f'Fold {i}'] = gbm.feature_importances_</span><span id="8746" class="kt ir hi mj b fi mr mo l mp mq">feats['Importances'] = feats.mean(axis=1)<br/>print( ' CV RMSE : ',cv_score_)<br/>preds_xgb = np.average(gbm_predictions, axis=0)<br/>print(preds_xgb.shape)</span></pre><blockquote class="nj nk nl"><p id="90a0" class="jo jp ks jq b jr km jt ju jv kn jx jy nm ko kb kc nn kp kf kg no kq kj kk kl hb bi translated"><strong class="jq hj">注:</strong> <em class="hi">其他梯度提升决策树如</em><a class="ae kr" href="https://lightgbm.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj"><em class="hi">light GBM</em></strong></a><em class="hi">都可以实现。然而，为了进一步提高作物产量预测模型的准确性，需要做更多的技巧来生成更重要的特征，并且模型超参数调整也将增加模型的预测能力。</em></p></blockquote><p id="1e20" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">非常感谢 <a class="ae kr" href="https://zindi.africa/competitions" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> <em class="ks">津迪</em> </strong> </a> <em class="ks">以及津迪CGIAR作物产量预测挑战赛的获胜者。</em></p><p id="8839" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hj"> <em class="ks">好好关注我，了解更多关于深度学习在GIS中的应用的更新故事。</em>T13】</strong></p><blockquote class="nj nk nl"><p id="140f" class="jo jp ks jq b jr km jt ju jv kn jx jy nm ko kb kc nn kp kf kg no kq kj kk kl hb bi translated"><strong class="jq hj">参考文献</strong></p></blockquote><div class="nt nu ez fb nv nw"><a href="https://www.frontiersin.org/articles/10.3389/fenvs.2020.00085/full" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab dw"><div class="ny ab nz cl cj oa"><h2 class="bd hj fi z dy ob ea eb oc ed ef hh bi translated">Sentinel-2在小农农林景观中作物产量估算的潜力…</h2><div class="od l"><h3 class="bd b fi z dy ob ea eb oc ed ef dx translated">非洲国家缺乏实地范围的作物生产统计数据，这限制了对产量的潜在研究…</h3></div><div class="oe l"><p class="bd b fp z dy ob ea eb oc ed ef dx translated">www.frontiersin.org</p></div></div><div class="of l"><div class="og l oh oi oj of ok io nw"/></div></div></a></div><p id="491d" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><a class="ae kr" href="https://github.com/Az-Ks/CGIAR_Solution_Code_To_Get_4th_Place/blob/main/CGIAR_SOLUTION_4th_Place.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> <em class="ks">第四名为辛迪加农作物产量预测挑战赛</em> </strong> </a> <strong class="jq hj"> <em class="ks">。</em>T25】</strong></p></div></div>    
</body>
</html>