<html>
<head>
<title>Periodic Tasks— Celery beat and MongoDB dynamic schedulers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">周期性任务— Celery beat和MongoDB动态调度程序</h1>
<blockquote>原文：<a href="https://medium.com/codex/periodic-tasks-celery-beat-and-mongodb-dynamic-schedulers-24cdf396dcc?source=collection_archive---------2-----------------------#2021-07-06">https://medium.com/codex/periodic-tasks-celery-beat-and-mongodb-dynamic-schedulers-24cdf396dcc?source=collection_archive---------2-----------------------#2021-07-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/59a32d960de867c85ffa3f1b48889a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dPfnTVgq-rGvEZ7wRfnZTA.png"/></div></div></figure><p id="acac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于大多数项目，将有一个场景来卸载长时间运行或CPU密集型任务。此外，还需要实现一些批处理或周期性任务。</p><p id="e476" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这种需求，有助于实时处理数据的分布式任务队列系统是合适的。</p><p id="4ba0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在python世界<a class="ae jo" href="https://docs.celeryproject.org/en/stable/index.html" rel="noopener ugc nofollow" target="_blank">芹菜分布式任务队列</a>提供了这样的解决方案</p><blockquote class="jp jq jr"><p id="ec1a" class="iq ir js is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated">“Celery是一个简单、灵活、可靠的分布式系统，可以处理大量的消息，同时为运营部门提供维护这样一个系统所需的工具。</p><p id="3320" class="iq ir js is b it iu iv iw ix iy iz ja jt jc jd je ju jg jh ji jv jk jl jm jn hb bi translated">它是一个任务队列，侧重于实时处理，同时也支持任务调度。"</p></blockquote><p id="fe6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">芹菜工程生产者，经纪人和消费者模式。生产者创建任务并将其推给代理，然后消费者(工作者)将任务出队并执行它。</p><p id="f57b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jw jx jy jz b">pip install celery</code></p><pre class="ka kb kc kd fd ke jz kf kg aw kh bi"><span id="f0e0" class="ki kj hi jz b fi kk kl l km kn">#create the file <!-- -->tasks.py</span><span id="0c07" class="ki kj hi jz b fi ko kl l km kn">from celery import Celery</span><span id="8f34" class="ki kj hi jz b fi ko kl l km kn">//using rabbitmq as the message broker<br/>app = Celery('name',broker='amqp://guest@localhost')</span><span id="66f0" class="ki kj hi jz b fi ko kl l km kn">@app.task<br/>def hello():<br/>  return 'hello world'</span></pre><p id="bc6c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">**来自<a class="ae jo" href="https://docs.celeryproject.org/en/stable/getting-started/introduction.html#get-started" rel="noopener ugc nofollow" target="_blank">https://docs . celery project . org/en/stable/getting-started/introduction . html # get-started</a>的示例代码</p><p id="ed29" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以运行芹菜工人如下</p><p id="bfe2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jw jx jy jz b">celery -A tasks worker --loglevel=DEBUG</code></p><p id="d18b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们对芹菜如何执行任务有了一点了解，让我们进入我们的博客主题，讨论芹菜的任务调度器<strong class="is hj">击败</strong></p><p id="56b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Celery通过<a class="ae jo" href="https://docs.celeryproject.org/en/stable/reference/celery.beat.html#module-celery.beat" rel="noopener ugc nofollow" target="_blank"> Celery Beat </a>支持任务调度，支持基于特定周期(时间间隔或crontab调度)的任务执行。</p><p id="7562" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">定期任务可以通过“beat_schedule”选项添加到现有的celery应用程序配置中</p><pre class="ka kb kc kd fd ke jz kf kg aw kh bi"><span id="2c17" class="ki kj hi jz b fi kk kl l km kn">app = Celery('name',broker='amqp://guest@localhost')<br/>app.conf.beat_schedule = {<br/>  'call-every-30-seconds': {<br/>    'task': 'tasks.hello',<br/>    'schedule': 30.0 #time-interval type<br/>   }<br/>}</span></pre><p id="3ebf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">芹菜节拍可以使用下面的命令运行。<strong class="is hj">启动节拍服务</strong>前，确保芹菜工也在运行。</p><p id="2ac6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jw jx jy jz b">celery -A tasks beat --loglevel=DEBUG</code></p><p id="8be0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在执行上面的命令之后，您可以在celery beat的日志中看到，它每30秒对任务进行一次排队，在celery worker的日志中，您可以看到worker在相同的时间段内执行任务。</p><p id="0c83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">celery beat使用默认调度器<em class="js">celery . beat . persistent scheduler</em>，它使用shelve数据库文件来存储调度条目及其状态。</p><p id="c67a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种默认设置的问题是，很难动态地管理任务，例如添加或修改与任务相关的执行配置。</p><p id="24a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果,<strong class="is hj">可以将</strong>这些日程相关信息存储在数据库中，并且<strong class="is hj">可以动态添加或修改</strong>日程相关信息。</p><p id="f966" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是的，这可以通过使用定制的调度程序来实现，如<a class="ae jo" href="https://github.com/zmap/celerybeat-mongo" rel="noopener ugc nofollow" target="_blank"> celerybeat-mongo </a>，它使用mongodb作为数据库来存储和管理调度及其状态信息。现在让我们详细看看如何实现它。</p><p id="9db9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jw jx jy jz b">pip install celerybeat-mongo mongoengine</code></p><p id="b0ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用mongoengine操作celerybeat-mongo的模型来创建和修改时间表。为此，我们将使用来自celerybeat-mongo的PeriodicTasks类。</p><p id="500d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们创建一个定制类并导入所需的模块。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="kp kq l"/></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">只完成了基本的创建和更新操作，但是可以扩展这个类来进行自定义验证和实现</figcaption></figure><p id="3460" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">默认情况下，这将创建/修改名为“schedules”的集合中的文档。如他们的<a class="ae jo" href="https://github.com/zmap/celerybeat-mongo#settings" rel="noopener ugc nofollow" target="_blank">设置文档</a>中所述，当它与芹菜应用程序集成时，这个收集选项可以改变。</p><p id="738d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用一些样本数据集调用如下定义的自定义类。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="89e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们有了一些类，它们在celerybeat-mongo lib的PeriodicTask模型上执行crud操作。让我们开始与celery应用程序集成配置，例如为celery beat提供自定义集合，以同步和拾取由我们的“CustomPeriodicTaskManage”类管理的日程。</p><pre class="ka kb kc kd fd ke jz kf kg aw kh bi"><span id="bbc8" class="ki kj hi jz b fi kk kl l km kn">config = {<br/>    "mongodb_scheduler_db": "my_project",<br/>    "mongodb_scheduler_url": "mongodb://localhost:27017",<br/>    "mongodb_scheduler_collection": "custom_schedule_collection" <br/>}<br/>app = Celery('name',broker='amqp://guest@localhost')<br/>app.conf.beat_schedule = {<br/>  'call-every-30-seconds': {<br/>    'task': 'tasks.hello',<br/>    'schedule': 30.0 #time-interval type<br/>   }<br/>}<br/>app.conf.update(**config)</span></pre><p id="66e1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们使用下面的命令运行芹菜工和beat</p><pre class="ka kb kc kd fd ke jz kf kg aw kh bi"><span id="9e24" class="ki kj hi jz b fi kk kl l km kn">celery -A tasks worker --loglevel=DEBUG<br/>celery -A tasks beat -S celerybeatmongo.schedulers.MongoScheduler --loglevel=DEBUG</span></pre><p id="c468" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在celery beat服务的日志中，您可以看到它将后端指向上面定义的mongodb配置。还显示了它根据计划选择任务并对任务进行排队。</p><p id="73e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Celery worker服务日志显示它将任务出队并执行它。</p><p id="e848" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您可以使用“CustomPeriodicTaskManage”类更新时间表，并看到celery beat动态地选择更改并运行它，而无需重新启动服务。</p><p id="7d6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太好了，现在我们可以通过将时间表存储在数据库中来管理它。我们还可以动态地更改时间表(interval或crontab ),允许celery beat服务拾取更改并执行它，而无需重新启动服务。</p><p id="f308" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这篇文章是有用的，并解决了与数据库后端运行芹菜节拍的要求。</p></div></div>    
</body>
</html>