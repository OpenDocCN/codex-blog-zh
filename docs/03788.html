<html>
<head>
<title>Genetic Algorithm &amp; Spatio-Temporal Networks: Optimization of Campus Shuttle Bus Schedule Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遗传算法与时空网络:校园班车时刻表优化(二)</h1>
<blockquote>原文：<a href="https://medium.com/codex/genetic-algorithm-spatio-temporal-networks-optimization-of-campus-shuttle-bus-schedule-part-2-255a25daf53e?source=collection_archive---------3-----------------------#2021-09-26">https://medium.com/codex/genetic-algorithm-spatio-temporal-networks-optimization-of-campus-shuttle-bus-schedule-part-2-255a25daf53e?source=collection_archive---------3-----------------------#2021-09-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7c03" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">第2部分:基线问题的遗传算法(带Python代码)</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a888cb675c17aa237605d3896eef05fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYGGtDHOEuShei5SWNLMjg.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><blockquote class="jn jo jp"><p id="bf96" class="jq jr js jt b ju jv ij jw jx jy im jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">代码可以在这个<a class="ae kn" href="https://github.com/AlisonYao/DURF-Bus-Schedule-Optimization" rel="noopener ugc nofollow" target="_blank"> GitHub Repo </a>中找到。</p></blockquote><p id="cdb8" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">在<a class="ae kn" rel="noopener" href="/codex/genetic-algorithm-spatio-temporal-networks-optimization-of-campus-shuttle-bus-schedule-part-1-e0dc3bcdb30c">的上一篇博客</a>中，我介绍了用于问题公式化的<strong class="jt hj">时空网络</strong>，它几乎涵盖了这个项目的所有理论部分。这里，我们将继续讨论最后一点理论，然后是实现。更具体地说，这篇文章将向您展示如何使用Python编写基线问题的遗传算法解决方案(要查看什么是基线问题，请查看此处的<a class="ae kn" rel="noopener" href="/codex/genetic-algorithm-spatio-temporal-networks-optimization-of-campus-shuttle-bus-schedule-part-1-e0dc3bcdb30c"/>)。</p><h1 id="be89" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">为什么是遗传算法？</h1><p id="5cc4" class="pw-post-body-paragraph jq jr hi jt b ju lj ij jw jx lk im jz ko ll kc kd kp lm kg kh kq ln kk kl km hb bi translated">我选择了<a class="ae kn" href="https://towardsdatascience.com/introduction-to-genetic-algorithms-including-example-code-e396e98d8bf3" rel="noopener" target="_blank">遗传算法</a>来解决这个优化问题，因为它有独特的优势:</p><h2 id="9b4b" class="lo ks hi bd kt lp lq lr kx ls lt lu lb ko lv lw ld kp lx ly lf kq lz ma lh mb bi translated"><strong class="ak"> 1。遗传算法需要较少的计算能力</strong></h2><p id="427c" class="pw-post-body-paragraph jq jr hi jt b ju lj ij jw jx lk im jz ko ll kc kd kp lm kg kh kq ln kk kl km hb bi translated">由于只有枚举了总线的路径才能确定总线的开销，因此我们首先尝试了列生成的方法。列生成枚举解集中所有可能的路径，并使用强力搜索来寻找最优解。逐一检查干草，直到我们找到针，这就像大海捞针一样。但是，仅基准案例就已经总共有2 ** 34 = 17，179，869，184条路径，而我的计算机没有存储所有这些信息的硬件容量。我们只能看到干草堆中随机的一部分，不知道针是否真的在这一部分，所以列生成在计算上变得不可行。因此，我求助于遗传算法，一种启发式算法。它从一个随机的次优解开始，然后随着时间的推移进化到更接近最优解的更好的解。</p><h2 id="08f5" class="lo ks hi bd kt lp lq lr kx ls lt lu lb ko lv lw ld kp lx ly lf kq lz ma lh mb bi translated"><strong class="ak"> 2。遗传算法不受黑盒公式的影响</strong></h2><p id="621a" class="pw-post-body-paragraph jq jr hi jt b ju lj ij jw jx lk im jz ko ll kc kd kp lm kg kh kq ln kk kl km hb bi translated">在理想情况下，优化问题有一个明确的目标函数，我可以用𝑓(𝑥).的形式来表达然而，在我们的例子中，用一种显式的形式来表述问题是非常复杂的，而且有些不必要。主要原因是没有封闭形式的函数规定了营业时间和价格之间的关系。因此，我将目标表述为一个黑盒，这意味着我不试图编写一个明确的目标函数。同样，也不需要明确表达我们的约束。因此，我们的问题表述如下。</p><p id="51ad" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">我们的<strong class="jt hj">目标</strong>是将NYU至上海班车车队的总成本降至最低。根据不同版本的网络结构，约束条件很容易发生变化。所有<strong class="jt hj">约束</strong>的并集包括:</p><ol class=""><li id="1987" class="mc md hi jt b ju jv jx jy ko me kp mf kq mg km mh mi mj mk bi translated"><strong class="jt hj">需求约束</strong>:班车车队需要尽可能满足学生的需求，并留有少量余量。一个例子是，每辆公交车容纳50名学生，容差为3。即使3个学生在等着出行，公交车也不会开。容忍度取决于学校对学生要求的重视程度。</li><li id="1415" class="mc md hi jt b ju ml jx mm ko mn kp mo kq mp km mh mi mj mk bi translated"><strong class="jt hj">高峰时段约束</strong>:在早上和下午的高峰时段，任何一辆公交车都不能在30分钟的间隔内行驶。</li><li id="3de2" class="mc md hi jt b ju ml jx mm ko mn kp mo kq mp km mh mi mj mk bi translated"><strong class="jt hj">最大工作时间限制</strong>:每辆公交车只能由一名公交车司机驾驶，且不能连续工作超过4小时。</li></ol><p id="5d42" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">尽管有优势，我确实需要指出<em class="js">遗传算法并不能保证最优</em>。遗传算法可能会陷入次优解。尽管如此，如果基线问题的计算要求已经很高，而扩展问题只会变得更糟，那么相比之下，GA是我们的最佳策略。</p><h1 id="1501" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">基线问题的Python实现</h1><p id="0f58" class="pw-post-body-paragraph jq jr hi jt b ju lj ij jw jx lk im jz ko ll kc kd kp lm kg kh kq ln kk kl km hb bi translated">在我们深入Python代码之前，我们需要理解GA的每一步是如何适应基线问题的。我强烈建议你在前进之前学习GA 的<a class="ae kn" href="https://towardsdatascience.com/introduction-to-genetic-algorithms-including-example-code-e396e98d8bf3" rel="noopener" target="_blank">基础知识。</a></p><p id="d3e9" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">对于基线问题，解决方案中的一个路径看起来像011001010001011111000010111110001011。它有34个0或1的基因，因为总共有34个区间。0表示在间隔期间公共汽车仍在等待，并且不运载任何学生；1代表一辆从JQ到AB或者从AB到JQ的公共汽车。请注意，基因为1不一定代表公交车载有学生。为了满足下一个时段开始时的巨大需求，公共汽车可能会空载前往JQ。一个解决方案有几条总线，所以一个解决方案将几个路径染色体连接在一起。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/bf6def9b5450a110460d61f78b3fcda8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d5JXXfMeCK47OrEGCwg7Jg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="262f" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">在产生解染色体之后，可以根据适应度函数计算适应度分数。适应度函数有两个组成部分，总成本和惩罚成本。对于第一个组成部分，虽然每辆公交车的价格需要与班车公司协商，但价格一般取决于从公交车运营开始到结束的持续时间。<strong class="jt hj">请注意，只要司机开始一天的工作并且没有打卡下班，所有标有0的间隔仍然要付费，即使公交车停在一个地方。</strong>因此，我使用了下面的数学公式:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mr"><img src="../Images/01aff944c915ec5d5f2b448e7d111392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bvi-3XJ3LjIqggfntjB8mg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="d8df" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">其中x为公交车的运行时长(单位:小时)。这个公式在很多方面是违反直觉的，但我们只是把它作为一个案例。比如路径染色体01100101000101111100001011110001011运营33个区间，也就是16.5个小时，那么这趟公交的成本就是20 * 16.5 = 330元。那么，总成本就是每辆公交车的成本之和。适应性分数的第二个组成部分是违反约束的惩罚。根据您所考虑的基本函数的版本，您可能会有一个仅强制需求约束的惩罚，或两个约束，或需求约束、高峰时间约束和最大工作时间约束的所有三个惩罚。每次学生没有上车，或司机在高峰时间的一个间隔内完成一次旅行，或司机连续工作超过4小时，都会在健康得分上增加不同金额的小额罚款。</p><p id="8fec" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">具体来说，下面是如何检测违反约束的情况。首先，对于需求约束，染色体路径需要被编码成大小为4 * 34的数组，该数组指定每个0和1的含义。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/5957cb1b1c032d7cbe8d2d275d93c532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mI7DURPBARgSRvGBnrU2LA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="d2cc" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">在这个例子中，左边的第一个1对应于右边的第一列，其中唯一的1表示公共汽车从JQ开往AB。同理，其余意思相同。帮助我们计算总线总容量的是数组的第二行和第三行。然后，我们可以将所有JQ到AB的公共汽车和AB到JQ的公共汽车加起来，然后乘以公共汽车的载客量，与需求进行比较。第二，对于高峰时间的限制，我们需要从7:30到8:30和从17:30到18:30检查每个染色体的连续1。10、01和00在高峰时间有效，但11点无效。第三，对于最大工作时间约束，我们需要跟踪一行中1的数量。在高峰时间的情况下，高峰时间的0也可能意味着公共汽车正在运行，所以我们也需要考虑这种特殊情况。如果工作持续时间超过4小时，则会导致惩罚。</p><h2 id="bb7e" class="lo ks hi bd kt lp lq lr kx ls lt lu lb ko lv lw ld kp lx ly lf kq lz ma lh mb bi translated">Python代码</h2><p id="37b2" class="pw-post-body-paragraph jq jr hi jt b ju lj ij jw jx lk im jz ko ll kc kd kp lm kg kh kq ln kk kl km hb bi translated">现在我们终于可以得到Python代码了。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="f050" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">我偏离典型GA实现的一个地方是<code class="du mv mw mx my b">mutation</code>函数。我测试了遗传算法中变异步骤的两个实现。第一种是传统的实现方式，其中给定一个概率mutation_prob，每个基因都可能发生突变。不能保证一条染色体是否会发生突变，也不能保证一条染色体会在多少个地方发生突变。第二个是从一个解染色体中随机挑选一个基因来静音。突变是确定的，而且只能有一个突变。我尝试了第二个实现，试图更快地收敛算法。测试结果表明，第二种方法在许多方面确实优于传统方法。此外，第二种实现更快，因为它不需要遍历每个基因并确定它是否会发生突变。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mz"><img src="../Images/7f0969b5ce7027d01bf72ccfee0cb3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wuHvMA_-LypHloNnK45u5w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="a869" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">比较测试1&amp;2和3&amp;4，给定固定的evoluation _ depth，变异版本2具有更少的约束违反和更低的最终成本。比较测试1和3和5，变异版本1似乎即使在产生20，000代之后也没有很好地收敛。它的性能在早期达到稳定，与测试4相比远不令人满意。因此，自行设计的变异函数实现比常规方法执行得更好。无论如何调整参数mutation_prob，这种优势都会持续存在。</p><blockquote class="jn jo jp"><p id="7fb6" class="jq jr js jt b ju jv ij jw jx jy im jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">因此，我建议将mutationType设置为‘New’，并将mutation_num保持为1。</p></blockquote><p id="7ace" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">Python代码的结果应该如下所示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es na"><img src="../Images/c20fc15a84df81160f72dd3426bef526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-BjwioxS3IoZ0bacKIYAA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="2610" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">在我的测试中，最好的结果给了我一个新的优化时间表来解决基线问题:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nb"><img src="../Images/fb58793ed6a84040e1eccee022bd4ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ogMiUkMYRWGf1AVAa_6dog.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure></div><div class="ab cl nc nd gp ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hb hc hd he hf"><p id="9592" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">谢谢你阅读我的博客！希望对你有帮助。</p><p id="c604" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">我的Github:<a class="ae kn" href="https://github.com/AlisonYao" rel="noopener ugc nofollow" target="_blank">https://github.com/AlisonYao</a></p><p id="148b" class="pw-post-body-paragraph jq jr hi jt b ju jv ij jw jx jy im jz ko kb kc kd kp kf kg kh kq kj kk kl km hb bi translated">我的卡格尔:<a class="ae kn" href="https://www.kaggle.com/alisonyao" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/alisonyao</a></p></div></div>    
</body>
</html>