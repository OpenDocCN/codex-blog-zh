<html>
<head>
<title>Transmitting Deltas Between Different Apache Geode Distributed Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在不同的Apache Geode分布式系统之间传输增量</h1>
<blockquote>原文：<a href="https://medium.com/codex/transmitting-deltas-between-different-apache-geode-distributed-systems-e46a3eae931?source=collection_archive---------13-----------------------#2021-03-23">https://medium.com/codex/transmitting-deltas-between-different-apache-geode-distributed-systems-e46a3eae931?source=collection_archive---------13-----------------------#2021-03-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="6902" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><h1 id="5aa2" class="io ip hi bd iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl bi translated">介绍</h1><p id="2d95" class="pw-post-body-paragraph jm jn hi jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Apache Geode提供了一个<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/Delta.java" rel="noopener ugc nofollow" target="_blank"> Delta </a>接口，当对一个对象进行更改时，该接口有助于序列化两个JVM之间的对象更改，而不是整个对象。对于大型对象，这提供了一种优化，它受以下各项支持:</p><ul class=""><li id="a39f" class="kl km hi jo b jp kn jt ko jx kp kb kq kf kr kj ks kt ku kv bi translated">客户端到服务器</li><li id="bfcc" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">同一分布式系统中的服务器对服务器</li><li id="30c7" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">服务器到客户端</li></ul><p id="d73e" class="pw-post-body-paragraph jm jn hi jo b jp kn jr js jt ko jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj hb bi translated">不支持将增量从一个<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/distributed/DistributedSystem.java" rel="noopener ugc nofollow" target="_blank">分布式系统</a>中的服务器发送到另一个(例如两个WAN站点)中的服务器。目前，在分布式系统之间发送的每个事件都包含整个对象。通常，对象以字节数组的形式存储在区域中。对于增量来说，情况并非如此。相反，增量被表示为完全反序列化的对象。当接收到对增量的改变时，它被应用于内存中的对象。再加上不支持在分布式系统之间发送增量，这意味着每次在发送分布式系统中更新时，整个对象都被序列化，而在接收分布式系统中被反序列化。由于增量主要用于可以变得非常大的对象(如会话)，这可能是低效的。</p><p id="0a4d" class="pw-post-body-paragraph jm jn hi jo b jp kn jr js jt ko jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj hb bi translated">本文描述了一种在分布式系统之间发送增量字节而不是发送整个对象字节的方法。</p><h1 id="c5c5" class="io ip hi bd iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl bi translated">体系结构</h1><p id="a432" class="pw-post-body-paragraph jm jn hi jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于此实现，每个事件在发送分布式系统中的客户端和接收分布式系统中的服务器之间的路径如下:</p><ul class=""><li id="aee2" class="kl km hi jo b jp kn jt ko jx kp kb kq kf kr kj ks kt ku kv bi translated">客户端对数据区域执行put操作</li><li id="9f09" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">根据操作是创建还是更新，对象的完整字节或增量字节从客户端发送到服务器</li><li id="c513" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">服务器中数据区的<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/cache/CacheWriter.java" rel="noopener ugc nofollow" target="_blank"> CacheWriter </a>设置<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/cache/wan/GatewaySender.java" rel="noopener ugc nofollow" target="_blank"> GatewaySender </a>队列键</li><li id="c18b" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">服务器中数据区域上的<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/cache/CacheListener.java" rel="noopener ugc nofollow" target="_blank"> CacheListener </a>在包含适当字节(增量或完整)的代理区域上创建一个<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/cache/EntryEvent.java" rel="noopener ugc nofollow" target="_blank"> EntryEvent </a>，并将该事件分发给连接到代理区域的GatewaySender</li><li id="dc13" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">连接到代理区域的GatewaySender将事件发送到接收分布式系统中的服务器</li><li id="f987" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">接收分布式系统上的服务器中的<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/cache/wan/GatewayReceiver.java" rel="noopener ugc nofollow" target="_blank">网关接收器</a>接收该事件</li><li id="b511" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">代理区域中的CacheWriter将适当的字节(增量或完整)放入数据区域</li></ul><p id="df13" class="pw-post-body-paragraph jm jn hi jo b jp kn jr js jt ko jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj hb bi translated">注意:这些步骤中的GatewaySender和GatewayReceiver实际上包含几个不同的对象。</p><p id="09b3" class="pw-post-body-paragraph jm jn hi jo b jp kn jr js jt ko jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj hb bi translated">为简单起见，下图显示了此实现的体系结构，每个分布式系统中有一台服务器:</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es le"><img src="../Images/90e7462aee0361fcc31e297d8564bfd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IAw-8ZTafYCDM-I6GeTD1A.png"/></div></div></figure><h1 id="9019" class="io ip hi bd iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl bi translated">区域配置</h1><p id="7eec" class="pw-post-body-paragraph jm jn hi jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上述体系结构的区域配置在xml中如下所示:</p><h2 id="127b" class="lq ip hi bd iq lr ls lt iu lu lv lw iy jx lx ly jc kb lz ma jg kf mb mc jk ho bi translated">数据区域</h2><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="md me l"/></div></figure><h2 id="6fc8" class="lq ip hi bd iq lr ls lt iu lu lv lw iy jx lx ly jc kb lz ma jg kf mb mc jk ho bi translated">代理区域</h2><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="md me l"/></div></figure><h1 id="cfb3" class="io ip hi bd iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl bi translated">警告</h1><p id="73ec" class="pw-post-body-paragraph jm jn hi jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这种实现有一些注意事项:</p><ul class=""><li id="a7c3" class="kl km hi jo b jp kn jt ko jx kp kb kq kf kr kj ks kt ku kv bi translated">接收分布式系统必须拥有完整的对象才能应用增量字节，因此两个分布式系统必须从相同的状态开始(要么都为空，要么一个是另一个的副本)。</li><li id="ad7d" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">接收分布式系统代理区域存储每个键的最新字节。</li><li id="1898" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">无法为代理区域启用驱逐。如果它被启用并且条目被收回，则从发送分布式系统接收的销毁事件将被忽略。</li></ul><h1 id="732a" class="io ip hi bd iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl bi translated">履行</h1><p id="ed5e" class="pw-post-body-paragraph jm jn hi jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">本文中描述的所有源代码以及示例用法都可以在<a class="ae kk" href="https://github.com/boglesby/send-delta-between-wan-sites" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="4ed8" class="pw-post-body-paragraph jm jn hi jo b jp kn jr js jt ko jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj hb bi translated">该实现由以下三个<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/cache/CacheCallback.java" rel="noopener ugc nofollow" target="_blank"> CacheCallback </a>类组成:</p><ul class=""><li id="3d81" class="kl km hi jo b jp kn jt ko jx kp kb kq kf kr kj ks kt ku kv bi translated">附加到数据区的<strong class="jo hs">GatewaySenderDeltaCacheWriter</strong></li><li id="b8b5" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">附加到数据区的<strong class="jo hs">GatewaySenderDeltaCacheListener</strong></li><li id="4a33" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">附加到代理区域的<strong class="jo hs">gatewaysenderproxycache writer</strong></li></ul><h2 id="5934" class="lq ip hi bd iq lr ls lt iu lu lv lw iy jx lx ly jc kb lz ma jg kf mb mc jk ho bi translated">GatewaySenderDeltaCacheWriter</h2><p id="c3fc" class="pw-post-body-paragraph jm jn hi jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jo hs">gatewaysenderdeltachewriter</strong>处理方法:</p><ul class=""><li id="41a0" class="kl km hi jo b jp kn jt ko jx kp kb kq kf kr kj ks kt ku kv bi translated">初始化事件中的尾键</li><li id="216e" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">将尾键设置为事件的回调参数</li></ul><p id="b669" class="pw-post-body-paragraph jm jn hi jo b jp kn jr js jt ko jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj hb bi translated">尾键是GatewaySender队列中的键。在正常的GatewaySender启用区域中，尾键由主BucketRegion的<a class="ae kk" href="https://github.com/apache/geode/blob/23c373e2e47d9ab9951fc2b2e19a94e29d756a15/geode-core/src/main/java/org/apache/geode/internal/cache/BucketRegion.java#L578" rel="noopener ugc nofollow" target="_blank"> handleWANEvent </a>方法初始化。然后，它被复制到冗余服务器。由于本例中的数据区域未启用GatewaySender，因此不会发生这种情况。一旦尾键在事件中初始化，它就被设置到回调参数中。这样做是因为尾密钥仅在启用GatewaySender的区域中的服务器之间复制。在未启用GatewaySender的区域中，它会被忽略。</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="06b6" class="pw-post-body-paragraph jm jn hi jo b jp kn jr js jt ko jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj hb bi translated"><strong class="jo hs">gatewaysenderdeltachewriter</strong>setTailKey方法调用BucketRegion的handleWANEvent方法来设置尾键。</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="md me l"/></div></figure><h2 id="1466" class="lq ip hi bd iq lr ls lt iu lu lv lw iy jx lx ly jc kb lz ma jg kf mb mc jk ho bi translated">GatewaySenderDeltaCacheListener</h2><p id="4d6e" class="pw-post-body-paragraph jm jn hi jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jo hs">GatewaySenderDeltaCacheListener</strong>流程方法:</p><ul class=""><li id="18c4" class="kl km hi jo b jp kn jt ko jx kp kb kq kf kr kj ks kt ku kv bi translated">获取协同定位的代理区域</li><li id="c017" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">使用代理区域和输入EntryEvent创建EntryEvent</li><li id="d1c6" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">检索代理区域的网关发送方</li><li id="f0ad" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">将入口事件分发到每个网关发送方</li></ul><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="6ab3" class="pw-post-body-paragraph jm jn hi jo b jp kn jr js jt ko jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj hb bi translated">GatewaySenderDeltaCacheListenercreateProxyEntryEvent方法在代理区域上创建EntryEvent。</p><p id="a3ce" class="pw-post-body-paragraph jm jn hi jo b jp kn jr js jt ko jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj hb bi translated">EntryEvent包含:</p><ul class=""><li id="251c" class="kl km hi jo b jp kn jt ko jx kp kb kq kf kr kj ks kt ku kv bi translated"><a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/cache/Operation.java" rel="noopener ugc nofollow" target="_blank">操作</a>(创建、更新、销毁)</li><li id="f4a7" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">代理区域</li><li id="3c28" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">钥匙</li><li id="6cf8" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">创建(完整对象)或更新(增量)时的值字节</li><li id="ad14" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">一个布尔回调参数，表示字节是增量还是满的</li><li id="3f01" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">由<strong class="jo hs">GatewaySenderDeltaCacheWriter</strong>生成的尾密钥</li><li id="69eb" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">发起<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/distributed/DistributedMember.java" rel="noopener ugc nofollow" target="_blank">分发成员</a></li><li id="f80c" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">始发<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/internal/cache/EventID.java" rel="noopener ugc nofollow" target="_blank">事件ID </a></li><li id="6326" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">发起方<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/ClientProxyMembershipID.java" rel="noopener ugc nofollow" target="_blank">ClientProxyMembershipID</a></li><li id="6a81" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">始发<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/internal/cache/versions/VersionTag.java" rel="noopener ugc nofollow" target="_blank">版本标签</a></li></ul><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="e1f5" class="pw-post-body-paragraph jm jn hi jo b jp kn jr js jt ko jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj hb bi translated"><strong class="jo hs">GatewaySenderDeltaCacheListener</strong>deliverToGatewaySenderQueues方法检索代理区域的GatewaySenders并将事件分发给每个代理区域。</p><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="md me l"/></div></figure><h2 id="51d4" class="lq ip hi bd iq lr ls lt iu lu lv lw iy jx lx ly jc kb lz ma jg kf mb mc jk ho bi translated">GatewaySenderProxyCacheWriter</h2><p id="8e4e" class="pw-post-body-paragraph jm jn hi jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jo hs">gatewaysenderproxycache writer</strong>的处理方法:</p><ul class=""><li id="0416" class="kl km hi jo b jp kn jt ko jx kp kb kq kf kr kj ks kt ku kv bi translated">获取协同定位的数据区域</li><li id="4c74" class="kl km hi jo b jp kw jt kx jx ky kb kz kf la kj ks kt ku kv bi translated">根据EntryEvent的操作和布尔回调参数调用local region<a class="ae kk" href="https://github.com/apache/geode/blob/23c373e2e47d9ab9951fc2b2e19a94e29d756a15/geode-core/src/main/java/org/apache/geode/internal/cache/LocalRegion.java#L5181" rel="noopener ugc nofollow" target="_blank">basicBridgePut</a>或<a class="ae kk" href="https://github.com/apache/geode/blob/23c373e2e47d9ab9951fc2b2e19a94e29d756a15/geode-core/src/main/java/org/apache/geode/internal/cache/LocalRegion.java#L5435" rel="noopener ugc nofollow" target="_blank"> basicBridgeDestroy </a>方法。使用输入EntryEvent中的完整字节或增量字节调用basicBridgePut方法。</li></ul><figure class="lf lg lh li fd lj"><div class="bz dy l di"><div class="md me l"/></div></figure><h1 id="a20f" class="io ip hi bd iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl bi translated">将来的</h1><p id="dbe3" class="pw-post-body-paragraph jm jn hi jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventImpl.java" rel="noopener ugc nofollow" target="_blank">gatewaysendereventempl</a>表示在两个分布式系统之间发送的事件。需要修改它，以便能够在发送分布式系统中存储增量字节，并且应该修改<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/internal/cache/tier/sockets/command/GatewayReceiverCommand.java" rel="noopener ugc nofollow" target="_blank"> GatewayReceiverCommand </a>，以便能够在接收分布式系统中应用这些增量字节。</p><p id="9d69" class="pw-post-body-paragraph jm jn hi jo b jp kn jr js jt ko jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj hb bi translated">此外，发送分布式系统当前不知道接收分布式系统中对象的状态。这必须改变，以便在接收分布式系统没有完整对象的情况下，发送分布式系统知道何时必须发送完整字节而不是增量字节。</p><p id="ace2" class="pw-post-body-paragraph jm jn hi jo b jp kn jr js jt ko jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj hb bi translated">一种可能的方法是修改<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySenderEventProcessor.java" rel="noopener ugc nofollow" target="_blank">AbstractGatewaySenderEventProcessor</a>。AbstractGatewaySenderEventProcessor创建GatewaySenderEventImpls，构建这些mpls的批处理，并使它们被发送到接收分布式系统。可以修改它来跟踪接收分布式系统中的哪些对象需要完整的对象字节而不是增量字节。这可以通过跟踪与接收分布式系统建立连接的时间以及最后一次为每个条目发送完整对象字节的时间来完成。如果进入时间在连接时间之前，则整个字节将被重新发送；否则将发送增量字节。从发送分布式系统的角度来看，如果无法与接收分布式系统中的任何服务器建立连接，那么该系统就会关闭。当它重新启动时(当发送分布式系统可以连接到它时)，它可能是一个全新的分布式系统。发送的分布式系统对此一无所知，因此必须发送完整的字节。</p><p id="21c8" class="pw-post-body-paragraph jm jn hi jo b jp kn jr js jt ko jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj hb bi translated">另一个潜在的方法是修改<a class="ae kk" href="https://github.com/apache/geode/blob/0abd7667b324da3a88fa341675b68f08118c83cb/geode-wan/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventRemoteDispatcher.java#L581" rel="noopener ugc nofollow" target="_blank"> GatewayAck </a>和<a class="ae kk" href="https://github.com/apache/geode/blob/develop/geode-wan/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventRemoteDispatcher.java" rel="noopener ugc nofollow" target="_blank">gatewaysendereventremotedatcher</a>。GatewayAck是接收分布式系统为每批GatewaySenderEventImpls返回的确认。gateway sendereventremotedatcher处理网关确认。GatewayAck当前包含在接收分布式系统上处理批处理时发生的异常的集合以及其他字段。可以修改集合，使其包含远程分布式系统中不存在的每个条目的InvalidDeltaException。对于每一个，可以修改发送分布式系统中的gatewaysendereventmorthedispatcher，以创建一个具有完整字节的GatewaySenderEventImpl并对其进行排队。</p></div></div>    
</body>
</html>