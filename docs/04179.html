<html>
<head>
<title>How to make a video call app with iOS CallKit and Sendbird Calls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用iOS CallKit和Sendbird Calls制作视频通话应用程序</h1>
<blockquote>原文：<a href="https://medium.com/codex/make-a-video-call-app-with-ios-callkit-and-sendbird-calls-95b86ddbc908?source=collection_archive---------0-----------------------#2021-11-04">https://medium.com/codex/make-a-video-call-app-with-ios-callkit-and-sendbird-calls-95b86ddbc908?source=collection_archive---------0-----------------------#2021-11-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/386b77b725ba0519b4e7dbcf8801d282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/0*4lQc1vXvS05dleVw.png"/></div></figure><div class=""/><p id="ffd7" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">作者:李在成<br/>工程师| <a class="ae jk" href="https://www.sendbird.com" rel="noopener ugc nofollow" target="_blank">仙鸟</a></p><p id="135a" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jl">如果您正在寻找关于Swift、Kotlin、reactor、颤振等的教程，请访问我们的</em> <a class="ae jk" href="https://sendbird.com/developer/tutorials" rel="noopener ugc nofollow" target="_blank"> <em class="jl">开发者门户网站</em> </a> <strong class="io hq"> <em class="jl">。</em> </strong></p><ul class=""><li id="57b4" class="jm jn hp io b ip iq it iu ix jo jb jp jf jq jj jr js jt ju bi translated">如需完整的iOS视频聊天应用，请查看我们在GitHub上的<a class="ae jk" href="https://github.com/sendbird/quickstart-calls-directcall-ios" rel="noopener ugc nofollow" target="_blank">示例应用</a>。</li><li id="c1b2" class="jm jn hp io b ip jv it jw ix jx jb jy jf jz jj jr js jt ju bi translated">查看我们的iOS视频聊天<a class="ae jk" href="https://sendbird.com/docs/calls/v1/ios/quickstart/make-first-call#2-make-1-to-1-call-3-step-7-add-capabilities-to-your-app" rel="noopener ugc nofollow" target="_blank">文档</a>。</li></ul><h1 id="2d67" class="ka kb hp bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><p id="1e76" class="pw-post-body-paragraph im in hp io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">本教程将指导您使用Sendbird Calls框架和苹果的CallKit框架开发VoIP应用程序。您将从开发一个简单的项目开始，该项目允许您使用CallKit拨打本地电话。</p><p id="8c5d" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">每个部分都提供了文件的完整代码。您可以将代码复制并粘贴到适当的文件中。提供的代码可能不是唯一的实现。您可以通过仔细阅读以下步骤来定制它们，以满足您的需求。这些步骤将帮助您更好地了解CallKit。</p><h1 id="9570" class="ka kb hp bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第一步。创建Sendbird帐户</h1><p id="742d" class="pw-post-body-paragraph im in hp io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">1.注册一个免费的<a class="ae jk" href="https://dashboard.sendbird.com/auth/signup" rel="noopener ugc nofollow" target="_blank"> Sendbird账户</a>。</p><p id="f676" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.使用您的电子邮件id创建一个帐户，或单击“继续使用谷歌”。</p><p id="7ce7" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.通过输入“组织名称”和“电话号码”来设置您的组织。</p><p id="2091" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">4.在最靠近您所在地区的地方创建一个新的“聊天+通话”应用程序。</p><ul class=""><li id="484c" class="jm jn hp io b ip iq it iu ix jo jb jp jf jq jj jr js jt ju bi translated">在屏幕的左侧，您应该会看到一个“来电”菜单，进入“工作室”并创建一个新的“电话亭”用户。</li></ul><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ld"><img src="../Images/5be8d1a66fe5b2f0726e29b68c52cfa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1rXUAKMe5jtCwguG.gif"/></div></div></figure><h1 id="1414" class="ka kb hp bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第2步:配置呼叫套件</h1><h2 id="e550" class="lm kb hp bd kc ln lo lp kg lq lr ls kk ix lt lu ko jb lv lw ks jf lx ly kw lz bi translated">步骤2.1</h2><p id="e615" class="pw-post-body-paragraph im in hp io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">要开发VoIP应用服务，您需要该应用的VoIP证书。转到苹果开发者页面并登录。</p><h2 id="24a7" class="lm kb hp bd kc ln lo lp kg lq lr ls kk ix lt lu ko jb lv lw ks jf lx ly kw lz bi translated">步骤2.2</h2><p id="e905" class="pw-post-body-paragraph im in hp io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">转到证书，标识符和配置文件&gt;证书&gt;创建新证书。您将在“服务”部分找到VoIP服务证书。创建VoIP服务证书。</p><h2 id="3ec3" class="lm kb hp bd kc ln lo lp kg lq lr ls kk ix lt lu ko jb lv lw ks jf lx ly kw lz bi translated">步骤2.3</h2><p id="c70b" class="pw-post-body-paragraph im in hp io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">转到目标&gt;签名和功能。添加背景模式并启用IP语音。这将创建一个. rights文件和允许您使用VoIP服务的适当权限。如果不启用IP语音，将出现呼叫工具包错误代码1。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ma"><img src="../Images/41360c81d13c8a8d90a0b19b95363b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7bkzj1ApJILyPAa6.png"/></div></div></figure><h1 id="0022" class="ka kb hp bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第3步:设计呼叫工具包用户界面</h1><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ld"><img src="../Images/b137a4cd54504cf441aace9517d888f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UNpsHj6kpKxRaF3H.png"/></div></div></figure><h2 id="0e0a" class="lm kb hp bd kc ln lo lp kg lq lr ls kk ix lt lu ko jb lv lw ks jf lx ly kw lz bi translated">步骤3.1</h2><p id="9ec7" class="pw-post-body-paragraph im in hp io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">要为CallKit配置本地化信息，请创建一个名为<strong class="io hq">cxproviderconfiguration . extension . swift</strong>的文件。</p><p id="cc78" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">cxp provider</strong></p><blockquote class="mb mc md"><p id="dd48" class="im in jl io b ip iq ir is it iu iv iw me iy iz ja mf jc jd je mg jg jh ji jj hb bi translated"><strong class="io hq"> <em class="hp"> CXProvider </em> </strong> <em class="hp">是表示电话服务提供商的对象。</em><strong class="io hq"><em class="hp">CX provider</em></strong><em class="hp">用</em><strong class="io hq"><em class="hp">CX provider configuration</em></strong><em class="hp">初始化。VoIP应用程序应该只为每个应用程序创建一个</em><strong class="io hq"><em class="hp">CX provider</em></strong><em class="hp">实例，并全局使用。更多信息请参见</em> <a class="ae jk" href="https://developer.apple.com/documentation/callkit/cxprovider" rel="noopener ugc nofollow" target="_blank"> <strong class="io hq"> <em class="hp">苹果开发者文档— CXProvider。</em> </strong> </a></p></blockquote><p id="d7d0" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">每个提供者可以指定一个符合<strong class="io hq"> CXProviderDelegate </strong>协议的对象来响应事件，例如开始呼叫、保持呼叫或激活提供者的音频会话。</p><h2 id="cba9" class="lm kb hp bd kc ln lo lp kg lq lr ls kk ix lt lu ko jb lv lw ks jf lx ly kw lz bi translated">第3.2步</h2><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="0db7" class="lm kb hp mi b fi mm mn l mo mp">extension CXProviderConfiguration {<br/>    static var custom: CXProviderConfiguration {<br/>    // 1<br/>    let configuration = CXProviderConfiguration(localizedName: "Homing Pigeon")</span><span id="81a3" class="lm kb hp mi b fi mq mn l mo mp">    // 2<br/>    // Native call log shows video icon if it was video call.<br/>    configuration.supportsVideo = true</span><span id="4d5f" class="lm kb hp mi b fi mq mn l mo mp">    // Support generic type to handle *User ID*<br/>    configuration.supportedHandleTypes = [.generic]</span><span id="0954" class="lm kb hp mi b fi mq mn l mo mp">    // Icon image forwarding to app in CallKit View<br/>    if let iconImage = UIImage(named: "App Icon") {<br/>        configuration.iconTemplateImageData = iconImage.pngData()<br/>    }<br/>    return configuration<br/>    }<br/>}</span></pre><p id="dcc6" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq">CXProviderConfiguration</strong>对象控制传入和传出呼叫的本地呼叫UI，包括提供商的本地化名称、传入呼叫要播放的铃声以及呼叫期间要显示的图标。有关更多信息，请参见<a class="ae jk" href="https://developer.apple.com/documentation/callkit/cxproviderconfiguration" rel="noopener ugc nofollow" target="_blank"> <strong class="io hq">苹果开发者文档— CXProviderConfiguration。</strong> </a></p><ol class=""><li id="b359" class="jm jn hp io b ip iq it iu ix jo jb jp jf jq jj mr js jt ju bi translated">用本地化名称初始化<strong class="io hq">CXProviderConfiguration</strong>对象。当您的用户通过CallKit收到呼叫时，此名称将出现在呼叫视图中。使用适当的命名，例如您的应用服务名称，作为本地化名称。在这种情况下，我们使用“信鸽”</li><li id="4a23" class="jm jn hp io b ip jv it jw ix jx jb jy jf jz jj mr js jt ju bi translated">配置用户界面及其功能。在这一步中，设置<strong class="io hq"> supportsVideo </strong>、<strong class="io hq"> supportedHandleTypes </strong>和<strong class="io hq"> iconTemplateImageData </strong>。如果您想进一步定制CallKit，请参见下表。也可以参考<a class="ae jk" href="https://developer.apple.com/documentation/callkit/cxproviderconfiguration" rel="noopener ugc nofollow" target="_blank"> <strong class="io hq">苹果开发者文档— CXProviderConfiguration。</strong>T49】</a></li></ol><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ms"><img src="../Images/1a5346860bf90c53f2cb14b8699cede7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0Vb5hcE5b8PhTbCd0n_Zg.png"/></div></div></figure><h2 id="809b" class="lm kb hp bd kc ln lo lp kg lq lr ls kk ix lt lu ko jb lv lw ks jf lx ly kw lz bi translated">支持视频</h2><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="7e17" class="lm kb hp mi b fi mm mn l mo mp">configuration.supportsVideo = true</span></pre><p id="3c57" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是一个布尔值，它指示呼叫除了音频之外是否还支持视频功能。默认设置为<strong class="io hq">假</strong>。苹果文档:<a class="ae jk" href="https://developer.apple.com/documentation/callkit/cxproviderconfiguration/1779574-supportsvideo" rel="noopener ugc nofollow" target="_blank"><strong class="io hq">supports video</strong></a>。</p><p id="b426" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您的服务提供视频通话，请将<strong class="io hq">支持视频</strong>设置为<strong class="io hq">真</strong>。如果您的服务不提供视频通话，请跳过此设置。</p><h2 id="abf5" class="lm kb hp bd kc ln lo lp kg lq lr ls kk ix lt lu ko jb lv lw ks jf lx ly kw lz bi translated">支持的HandleTypes</h2><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="9a62" class="lm kb hp mi b fi mm mn l mo mp">configuration.supportedHandleTypes = [.generic]</span></pre><p id="0713" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是您想要处理的呼叫提供者的类型。参见CXHandle.HandleType。</p><p id="92da" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hq"> CXHandle </strong>指的是在每次通话中如何识别你的用户。三种可能的句柄类型是:<strong class="io hq">。电话号码</strong>，<strong class="io hq">。电子邮件</strong>和<strong class="io hq">。通用</strong>。根据您提供的服务和管理用户的方式，您可以选择不同的选项。如果通过电话号码或电子邮件地址识别用户，选择<strong class="io hq">。电话号码</strong>或<strong class="io hq">。电子邮件</strong>。但是，如果它是基于某个随机的<strong class="io hq"> UUID </strong>值或其他未指定的值，则使用<strong class="io hq">。通用</strong>。<strong class="io hq">。泛型</strong>，它是一个未指定的<strong class="io hq">字符串</strong>值，可以更灵活地使用。</p><h2 id="9a60" class="lm kb hp bd kc ln lo lp kg lq lr ls kk ix lt lu ko jb lv lw ks jf lx ly kw lz bi translated">iconTemplateImageData</h2><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="30f7" class="lm kb hp mi b fi mm mn l mo mp">if let iconImage = UIImage(named: "App Icon") {<br/>    configuration.iconTemplateImageData = iconImage.pngData()<br/>}</span></pre><p id="29a5" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是为提供者显示的图标图像的PNG数据。</p><p id="4837" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">图标图像应该是边长为40磅的正方形图像。图像的alpha通道用于创建白色图像蒙版，该蒙版在系统的原生调用UI中用于按钮，该按钮将用户从该系统UI带到第三方应用。</p><p id="689b" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">参见<a class="ae jk" href="https://developer.apple.com/documentation/callkit/cxproviderconfiguration/2274376-icontemplateimagedata" rel="noopener ugc nofollow" target="_blank">T21。 </a></p><p id="09f8" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">设置<strong class="io hq">。iconTemplateImageData </strong>到图标图像，该图标图像将显示在CallKit屏幕上本地化名称的旁边。分配<strong class="io hq">。pngData() </strong>到你的应用图标。</p><h1 id="0bc5" class="ka kb hp bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第四步。请求呼叫套件操作</h1><figure class="le lf lg lh fd hk er es paragraph-image"><div class="er es mt"><img src="../Images/bf927a80c181572e8b05846ddfd46c22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/0*MaZyLCDgfpGFCmjs.png"/></div></figure><p id="f03d" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">CallKit提供许多与呼叫相关的功能，如拨号、结束、静音、保持等。这些特性中的每一个都应该由名为<strong class="io hq"> CXCallAction </strong>的适当的CallKit动作来执行。这些动作是从一个<strong class="io hq"> CXCallController </strong>对象中调用的，该对象使用<strong class="io hq"> CXTransaction </strong>对象来执行每个<strong class="io hq"> CXCallAction </strong>。为了控制CallKit，您必须创建相应的<strong class="io hq"> CXCallActions </strong>，并通过使用<strong class="io hq"> CXTransaction </strong>请求一个事务来执行它们。</p><p id="ef18" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">向CallKit发送请求有三个步骤:</p><ol class=""><li id="a3d2" class="jm jn hp io b ip iq it iu ix jo jb jp jf jq jj mr js jt ju bi translated">创建<strong class="io hq">cxcalaction</strong>对象</li><li id="98e3" class="jm jn hp io b ip jv it jw ix jx jb jy jf jz jj mr js jt ju bi translated">创建<strong class="io hq"> CXTransaction </strong>对象</li><li id="320e" class="jm jn hp io b ip jv it jw ix jx jb jy jf jz jj mr js jt ju bi translated">通过<strong class="io hq"> CXCallController </strong>请求<strong class="io hq"> CXTransaction </strong>对象</li></ol><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es ms"><img src="../Images/75f46527caffa3d59ac80e150626ed56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oZEL4V03YhcEsTJWv5jNdg.png"/></div></div></figure><h2 id="ada8" class="lm kb hp bd kc ln lo lp kg lq lr ls kk ix lt lu ko jb lv lw ks jf lx ly kw lz bi translated">第4.1步。交易</h2><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="6878" class="lm kb hp mi b fi mm mn l mo mp">// Allow to request for actions<br/>let callController = CXCallController()</span><span id="6e58" class="lm kb hp mi b fi mq mn l mo mp">// Request transaction<br/>private func requestTransaction(with action: CXCallAction, completionHandler: (NSError? -&gt; Void)?) {<br/>    let transaction = CXTransaction(action: action)<br/>    callController.request(transaction) { error in<br/>        completionHandler?(error as NSError?)<br/>    }<br/>}</span></pre><p id="5da0" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">添加<strong class="io hq"> CXCallController </strong>属性和另一个名为<strong class="io hq">的方法request transaction(with:completion handler:)</strong>。该方法使用<strong class="io hq"> CXCallAction </strong>创建<strong class="io hq"> CXTransaction </strong>，并通过<strong class="io hq"> callController </strong>请求事务。在创建一个<strong class="io hq"> CXCallAction </strong>对象后，您总是需要调用这个方法。</p><h1 id="d6c8" class="ka kb hp bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第4.2步。呼叫操作</h1><h2 id="48e3" class="lm kb hp bd kc ln lo lp kg lq lr ls kk ix lt lu ko jb lv lw ks jf lx ly kw lz bi translated">开始呼叫操作</h2><p id="2c25" class="pw-post-body-paragraph im in hp io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">下面实现了<strong class="io hq"> CXStartCallAction </strong>的一个方法。这个动作代表了通话的开始。如果动作请求成功，将调用相应的<strong class="io hq">cxproviderdelegate . provider(_:perform:)</strong>事件。</p><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="dcca" class="lm kb hp mi b fi mm mn l mo mp">func startCall(with uuid: UUID, calleeID: String, hasVideo: Bool, completionHandler: ((NSError?) -&gt; Void)? = nil) {<br/>    // 1<br/>    let handle = CXHandle(type: .generic, value: calleeID)    <br/>    let startCallAction = CXStartCallAction(call: uuid, handle: handle)<br/>    <br/>    // 2<br/>    startCallAction.isVideo = hasVideo<br/>    <br/>    // 3<br/>    self.requestTransaction(with: startCallAction, completionHandler: completionHandler)<br/>}</span></pre><ol class=""><li id="0668" class="jm jn hp io b ip iq it iu ix jo jb jp jf jq jj mr js jt ju bi translated">您必须创建一个与调用相关联的<strong class="io hq"> CXHandle </strong>对象，该对象将用于标识调用所涉及的用户。该对象将与UUID一起包含在<strong class="io hq"> CXStartCallAction </strong>中。</li><li id="00c8" class="jm jn hp io b ip jv it jw ix jx jb jy jf jz jj mr js jt ju bi translated">如果通话有视频，设置<strong class="io hq">。isVideo </strong>到<strong class="io hq"> true </strong>。</li></ol><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="8a2b" class="lm kb hp mi b fi mm mn l mo mp">startCallAction.isVideo = hasVideo</span></pre><p id="920a" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.如步骤1所述，在创建一个<strong class="io hq"> CXStartCallAction </strong>对象后，不要忘记调用<strong class="io hq">request transaction(with:completion handler:)</strong>方法。</p><h2 id="97ce" class="lm kb hp bd kc ln lo lp kg lq lr ls kk ix lt lu ko jb lv lw ks jf lx ly kw lz bi translated">结束通话操作</h2><p id="7a52" class="pw-post-body-paragraph im in hp io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">下面实现了<strong class="io hq"> CXEndCallAction </strong>的另一种方法。此动作表示通话已结束。如果动作请求成功，将调用相应的<strong class="io hq">cxproviderdelegate . provider(_:perform:)</strong>事件。<strong class="io hq"> CXEndCallAction </strong>只需要调用的<strong class="io hq"> UUID </strong>。用<strong class="io hq"> UUID </strong>创建一个<strong class="io hq"> CXEndCallAction </strong>对象。</p><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="6707" class="lm kb hp mi b fi mm mn l mo mp">func endCall(with uuid: UUID, completionHandler: ((NSError?) -&gt; Void)? = nil) {<br/>    let endCallAction = CXEndCallAction(call: uuid)<br/>    self.requestTransaction(with: endCallAction, completionHandler: completionHandler)<br/>}</span></pre><h2 id="9ac6" class="lm kb hp bd kc ln lo lp kg lq lr ls kk ix lt lu ko jb lv lw ks jf lx ly kw lz bi translated">其他呼叫操作</h2><p id="b113" class="pw-post-body-paragraph im in hp io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">其他<strong class="io hq"> CXCallActions </strong>可以和<strong class="io hq"> CXStartCallAction </strong>和<strong class="io hq"> CXEndCallAction </strong>一样实现。以下是其他通话操作的列表:</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mu"><img src="../Images/d653657d38566718d887e238f6432362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHMfhmsD-1ggmFyBOOiveA.png"/></div></div></figure><h1 id="4dc3" class="ka kb hp bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第五步。管理通话</h1><p id="6501" class="pw-post-body-paragraph im in hp io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">要轻松管理<strong class="io hq"> CXCallController </strong>和通话id，您可能需要创建一个通话管理器，它必须可以从任何地方访问。呼叫管理器将存储和管理正在进行的呼叫的<strong class="io hq"> UUID </strong>以处理呼叫事件。</p><blockquote class="mb mc md"><p id="362d" class="im in jl io b ip iq ir is it iu iv iw me iy iz ja mf jc jd je mg jg jh ji jj hb bi translated"><strong class="io hq"> <em class="hp">注意</em> </strong> <em class="hp"> <br/>您还可以使用</em><strong class="io hq"><em class="hp">cxcallcontroller . call observer . calls</em></strong><em class="hp">属性来管理活动呼叫(包括结束的呼叫)列表并观察呼叫变化。每个调用都是一个</em><strong class="io hq"><em class="hp">CXCall</em></strong><em class="hp">对象，代表CallKit中的一个调用。通过勾选</em><strong class="io hq"><em class="hp"/></strong><em class="hp">属性，可以处理正在进行的通话。</em></p><p id="e512" class="im in jl io b ip iq ir is it iu iv iw me iy iz ja mf jc jd je mg jg jh ji jj hb bi translated"><em class="hp">有关更多信息，请参见</em> <a class="ae jk" href="https://developer.apple.com/documentation/callkit/cxcallobserver" rel="noopener ugc nofollow" target="_blank"> <strong class="io hq"> <em class="hp">苹果开发者文档— CallObserver </em> </strong> </a> <em class="hp">和</em> <a class="ae jk" href="https://developer.apple.com/documentation/callkit/cxcall" rel="noopener ugc nofollow" target="_blank"> <strong class="io hq"> <em class="hp">苹果开发者文档— CXCall </em> </strong> </a></p></blockquote><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="925a" class="lm kb hp mi b fi mm mn l mo mp">import CallKit<br/><br/>class CallManager {<br/>    // 1<br/>    static let shared = CallManager()<br/><br/>    let callController = CXCallController()<br/><br/>    // 2<br/>    private(set) var callIDs: [UUID] = []<br/><br/>    // MARK: Call Management<br/>    func containsCall(uuid: UUID) -&gt; Bool {<br/>        return CallManager.shared.callIDs.contains(where: { $0 == uuid })<br/>    }<br/><br/>    func addCall(uuid: UUID) {<br/>        self.callIDs.append(uuid)<br/>    }<br/><br/>    func removeCall(uuid: UUID) {<br/>        self.callIDs.removeAll { $0 == uuid }<br/>    }<br/><br/>    func removeAllCalls() {<br/>        self.callIDs.removeAll()<br/>    }<br/>}</span></pre><p id="3ca7" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">创建一个名为<strong class="io hq"> CallManager </strong>的新类。然后，添加一个共享的静态实例，以便从任何地方访问它(您可以选择使用除singleton之外的其他模式)。</p><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="dd68" class="lm kb hp mi b fi mm mn l mo mp">static let shared = CallManager() // singleton</span></pre><p id="896e" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你想知道更多关于这个模式的信息，请看<a class="ae jk" href="https://developer.apple.com/documentation/swift/cocoa_design_patterns/managing_a_shared_resource_using_a_singleton" rel="noopener ugc nofollow" target="_blank"> <strong class="io hq">使用单例管理共享资源。</strong> </a></p><p id="98fa" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">添加类型为<strong class="io hq">【UUID】</strong>的<strong class="io hq"> callIDs </strong>属性，并添加管理callIDs的方法:<strong class="io hq"> addCall(uuid:) </strong>，<strong class="io hq"> removeCall(uuid:) </strong>和<strong class="io hq"> removeAllCalls() </strong></p><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="3bbe" class="lm kb hp mi b fi mm mn l mo mp">private(set) var callIDs: [UUID] = []</span><span id="306d" class="lm kb hp mi b fi mq mn l mo mp">func containsCall(uuid: UUID) -&gt; Bool { ... }</span><span id="248e" class="lm kb hp mi b fi mq mn l mo mp">func addCall(uuid: UUID) { ... }</span><span id="6323" class="lm kb hp mi b fi mq mn l mo mp">func removeCall(uuid: UUID) { ... }</span><span id="67a7" class="lm kb hp mi b fi mq mn l mo mp">func removeAllCalls() { ... }</span></pre><h1 id="6ee8" class="ka kb hp bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第六步。处理呼叫工具包事件</h1><p id="9151" class="pw-post-body-paragraph im in hp io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">要报告新的来电或响应新的CallKit操作，您必须使用在第2节中创建的<strong class="io hq">CX provider configuration</strong>创建一个<strong class="io hq"> CXProvider </strong>对象。您还可以通过<strong class="io hq">cxprovidereddelegate</strong>处理该调用的CallKit事件。</p><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="72f0" class="lm kb hp mi b fi mm mn l mo mp">// ProviderDelegate.swift<br/>class ProviderDelegate: NSObject {</span><span id="95fa" class="lm kb hp mi b fi mq mn l mo mp">    // 2<br/>    private let provider: CXProvider</span><span id="984f" class="lm kb hp mi b fi mq mn l mo mp">    override init() {<br/>        provider = CXProvider(configuration: CXProviderConfiguration.custom)</span><span id="84db" class="lm kb hp mi b fi mq mn l mo mp">        super.init()</span><span id="5845" class="lm kb hp mi b fi mq mn l mo mp">        // If the queue is `nil`, delegate will run on the main thread.<br/>        provider.setDelegate(self, queue: nil)<br/>    }</span><span id="5ba1" class="lm kb hp mi b fi mq mn l mo mp">    // 3<br/>    func reportIncomingCall(uuid: UUID, callerID: String, hasVideo: Bool, completionHandler: ((NSError?) -&gt; Void)? = nil) {</span><span id="399c" class="lm kb hp mi b fi mq mn l mo mp">        // Update call based on DirectCall object<br/>        let update = CXCallUpdate()</span><span id="294c" class="lm kb hp mi b fi mq mn l mo mp">        // 4. Informations for iPhone local call log<br/>        let callerID = call.caller?.userId ?? "Unknown"<br/>        update.remoteHandle = CXHandle(type: .generic, value: callerID)<br/>        update.localizedCallerName = callerID<br/>        update.hasVideo = hasVideo</span><span id="c4e9" class="lm kb hp mi b fi mq mn l mo mp">        // 5. Report new incoming call and add it to `callManager.calls`<br/>        provider.reportNewIncomingCall(with: uuid, update: update) { error in<br/>            guard error == nil else {<br/>                completionHandler?(error as NSError?)<br/>                return<br/>            }</span><span id="6193" class="lm kb hp mi b fi mq mn l mo mp">            // Add call to call manager<br/>            CallManager.shared.addCall(uuid: uuid)<br/>        }<br/>    }</span><span id="b079" class="lm kb hp mi b fi mq mn l mo mp">    // 6<br/>    func connectedCall(uuid: UUID, startedAt: Int64) {<br/>        let connectedAt = Date(timeIntervalSince1970: Double(startedAt)/1000)<br/>        self.provider.reportOutgoingCall(with: uuid, connectedAt: connectedAt)<br/>    }</span><span id="6c7a" class="lm kb hp mi b fi mq mn l mo mp">    // 7<br/>    func endCall(uuid: UUID, endedAt: Date, reason: CXCallEndedReason) {<br/>        self.provider.reportCall(with: uuid, endedAt: endedAt, reason: reason)<br/>    }<br/>}</span><span id="783a" class="lm kb hp mi b fi mq mn l mo mp">// 1<br/>extension ProviderDelegate: CXProviderDelegate {<br/>    func providerDidReset(_ provider: CXProvider) { }<br/>}</span></pre><ol class=""><li id="da5c" class="jm jn hp io b ip iq it iu ix jo jb jp jf jq jj mr js jt ju bi translated">导入<strong class="io hq"> CallKit </strong>并创建一个<strong class="io hq"> ProviderDelegate </strong>类，与<strong class="io hq">n object</strong>和<strong class="io hq"> CXProviderDelegate </strong>保持一致。</li><li id="795a" class="jm jn hp io b ip jv it jw ix jx jb jy jf jz jj mr js jt ju bi translated">添加两个属性:<strong class="io hq"> callManager </strong>和<strong class="io hq"> provider </strong>。<strong class="io hq">呼叫管理器</strong>是您在第3节中创建的<strong class="io hq">呼叫管理器</strong>类。提供程序报告CallKit的操作。当您初始化一个提供者时，使用您已经在第2节中创建的<strong class="io hq">cxproviderconfiguration . custom</strong>。</li></ol><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="444e" class="lm kb hp mi b fi mm mn l mo mp">private let provider: CXProvider<br/><br/>override init() {<br/>    provider = CXProvider(configuration: CXProviderConfiguration.custom)<br/><br/>    super.init()<br/><br/>    // If the queue is `nil`, delegate will run on the main thread.<br/>    provider.setDelegate(self, queue: nil)<br/>}</span></pre><ol class=""><li id="9253" class="jm jn hp io b ip iq it iu ix jo jb jp jf jq jj mr js jt ju bi translated">要报告一个新的来电，您需要创建一个<strong class="io hq"> CXCallUpdate </strong>实例，其中包含来电的相关信息，以及用于标识参与通话的用户的<strong class="io hq"> CXHandle </strong>。</li><li id="60e6" class="jm jn hp io b ip jv it jw ix jx jb jy jf jz jj mr js jt ju bi translated">为了让你的调用更加丰富，你可以定制<strong class="io hq"> CXHandle </strong>和<strong class="io hq"> CXCallUpdate </strong>实例。如果呼叫有视频，请将has video设置为true。上层iPhone通话记录基于<strong class="io hq"> CXHandle </strong>对象。</li><li id="0e53" class="jm jn hp io b ip jv it jw ix jx jb jy jf jz jj mr js jt ju bi translated">在报告一个新的来电后，您必须使用之前添加的<strong class="io hq"> addCall(uuid:) </strong>方法将其添加到<strong class="io hq"> CallManager.shared.calls </strong>中。</li><li id="7e2d" class="jm jn hp io b ip jv it jw ix jx jb jy jf jz jj mr js jt ju bi translated">CallKit通过侦听适当的CallKit事件来跟踪呼叫的接通时间和结束时间。要告诉CallKit呼叫已连接，请调用<strong class="io hq">reportOutgoingCall(with:connected at:)</strong>。这将启动通话持续时间，并通知iPhone应用程序的通话日志中显示的通话起点。</li><li id="53a2" class="jm jn hp io b ip jv it jw ix jx jb jy jf jz jj mr js jt ju bi translated">要告诉CallKit呼叫结束，调用<strong class="io hq">report call(with:ended at:reason:)</strong>。这将通知呼叫的端点，该端点也将显示在iPhone应用程序的呼叫日志中。</li></ol><h1 id="a4d9" class="ka kb hp bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第六步。处理CXCallAction事件</h1><h2 id="8120" class="lm kb hp bd kc ln lo lp kg lq lr ls kk ix lt lu ko jb lv lw ks jf lx ly kw lz bi translated">与CallKit UI的交互</h2><p id="abe8" class="pw-post-body-paragraph im in hp io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">当提供者执行<strong class="io hq"> CXCallActions </strong>时，可以调用相应的<strong class="io hq"> CXProviderDelegate </strong>方法。为了正确响应用户的操作，您必须在方法中实现适当的Sendbird调用操作。</p><blockquote class="mb mc md"><p id="6a89" class="im in jl io b ip iq ir is it iu iv iw me iy iz ja mf jc jd je mg jg jh ji jj hb bi translated"><strong class="io hq"> <em class="hp">重要</em> </strong> <em class="hp">:在方法结束之前，不要忘记执行</em><strong class="io hq"><em class="hp">action . full()</em></strong><em class="hp">。</em></p><p id="3003" class="im in jl io b ip iq ir is it iu iv iw me iy iz ja mf jc jd je mg jg jh ji jj hb bi translated"><strong class="io hq"> <em class="hp">重要</em> </strong> <em class="hp">:要访问</em><strong class="io hq"><em class="hp">【UUID】</em></strong><em class="hp">的调用，必须使用</em><strong class="io hq"><em class="hp">action . calluuid</em></strong><em class="hp">属性，而不是</em><strong class="io hq"><em class="hp">action . uuid</em></strong><em class="hp">。</em></p></blockquote><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es mv"><img src="../Images/391617447cd59054a8525da7eb45a462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*anV47QZttOHkzea_5Aw4UA.png"/></div></div></figure><p id="e4c7" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有关<strong class="io hq"> CXProviderDelegate </strong>方法的更多信息，请参考<a class="ae jk" href="https://developer.apple.com/documentation/callkit/cxproviderdelegate" rel="noopener ugc nofollow" target="_blank"> <strong class="io hq">苹果开发者文档— CXProviderDelegate </strong> </a>。</p><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="f7bf" class="lm kb hp mi b fi mm mn l mo mp">// ProviderDelegate.swift<br/>extension ProviderDelegate: CXProviderDelegate {<br/>    func providerDidReset(_ provider: CXProvider) {<br/>        // Stop audio<br/>        // End all calls because they are no longer valid<br/>        // Remove all calls from the app's list of call</span><span id="2999" class="lm kb hp mi b fi mq mn l mo mp">        CallManager.shared.removeAllCalls()<br/>    }</span><span id="f5e9" class="lm kb hp mi b fi mq mn l mo mp">    func provider(_ provider: CXProvider, perform action: CXStartCallAction) {<br/>        // Get call object<br/>        // Configure audio session<br/>        // Add call to  `callManger.callIDs`.<br/>        // Report connection started</span><span id="5785" class="lm kb hp mi b fi mq mn l mo mp">        action.fulfill()<br/>    }</span><span id="1162" class="lm kb hp mi b fi mq mn l mo mp">    func provider(_ provider: CXProvider, perform action: CXAnswerCallAction) {<br/>        // Configure audio session<br/>        // Accept call<br/>        // Notify incoming call accepted</span><span id="b442" class="lm kb hp mi b fi mq mn l mo mp">        action.fulfill()<br/>    }</span><span id="eb89" class="lm kb hp mi b fi mq mn l mo mp">    func provider(_ provider: CXProvider, perform action: CXEndCallAction) {<br/>        // Mute the call<br/>        // End the call</span><span id="af78" class="lm kb hp mi b fi mq mn l mo mp">        action.fulfill()</span><span id="39f3" class="lm kb hp mi b fi mq mn l mo mp">        // Remove the ended call from `callManager.callIDs`.<br/>        CallManager.shared.removeCall(uuid: action.callUUID)<br/>    }</span><span id="f806" class="lm kb hp mi b fi mq mn l mo mp">    func provider(_ provider: CXProvider, perform action: CXSetHeldCallAction) {<br/>        // update holding state.<br/>        // Mute the call when it's on hold.<br/>        // Stop the video when it's a video call.</span><span id="944b" class="lm kb hp mi b fi mq mn l mo mp">        action.fulfill()<br/>    }</span><span id="2510" class="lm kb hp mi b fi mq mn l mo mp">    func provider(_ provider: CXProvider, perform action: CXSetMutedCallAction) {<br/>        // stop / start audio</span><span id="fffb" class="lm kb hp mi b fi mq mn l mo mp">        action.fulfill()<br/>    }</span><span id="b5f1" class="lm kb hp mi b fi mq mn l mo mp">    func provider(_ provider: CXProvider, didActivate audioSession: AVAudioSession) {<br/>        // Start audio<br/>    }</span><span id="d85f" class="lm kb hp mi b fi mq mn l mo mp">    func provider(_ provider: CXProvider, didDeactivate audioSession: AVAudioSession) {<br/>        // Restart any non-call related audio now that the app's audio session has been<br/>        // de-activated after having its priority restored to normal.<br/>    }<br/>}</span></pre><h1 id="292a" class="ka kb hp bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第七步。与用户界面的交互</h1><p id="fab2" class="pw-post-body-paragraph im in hp io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">您可以使用CallKit的默认视图开始和结束呼叫。接下来，让我们尝试使用带有CallKit的自定义UI。为了清楚起见，本教程跳过创建相关的故事板文件和<strong class="io hq"> ViewController </strong>文件。相反，假设有一个文本字段用于输入远程用户的ID，一个按钮用于发出呼叫，另一个按钮用于接收呼入，最后一个按钮用于结束呼叫。</p><pre class="le lf lg lh fd mh mi mj mk aw ml bi"><span id="6dbe" class="lm kb hp mi b fi mm mn l mo mp">// ViewController.swift<br/>import UIKit<br/><br/>class ViewController: UIViewController {<br/>    let providerDelegate = ProviderDelegate()<br/><br/>    // UUID of ongoing call<br/>    var callID: UUID?<br/><br/>    // 1<br/>    @IBAction func didTapOutgoingCall() {<br/>        guard let calleeID = userIDTextField.text?.trimmingCharacters(in: .whitespaces) else { return }<br/>        guard !calleeID.isEmpty else { return }<br/>        let uuid = UUID()<br/>        self.callID = uuid<br/><br/>        CallManager.shared.startCall(with: uuid, calleeID: calleeID, hasVideo: false) { error in<br/>            // ...<br/>        }<br/>    }<br/><br/>    // 2<br/>    @IBAction func didTapEnd() {<br/>        guard let callID = self.callID else { return }<br/>        CallManager.shared.endCall(with: callID) { error in<br/>            guard error == nil else { return }<br/>        }<br/>        self.callID = nil<br/>    }<br/><br/>    // 3<br/>    @IBAction func didTapIncomingCall() {<br/>        guard let callerID = userIDTextField.text?.trimmingCharacters(in: .whitespaces) else { return }<br/>        guard !callerID.isEmpty else { return }<br/>        let uuid = UUID()<br/>        self.callID = uuid<br/><br/>        providerDelegate.reportIncomingCall(uuid: uuid, callerID: callerID, hasVideo: false) { error in<br/>            // ...<br/>        }<br/>    }<br/>}</span></pre><ol class=""><li id="7430" class="jm jn hp io b ip iq it iu ix jo jb jp jf jq jj mr js jt ju bi translated">发出呼叫:因为用户正在发起呼叫，所以您必须为该呼叫创建一个请求。该操作需要被叫方的<strong class="io hq">用户ID </strong>和呼叫的唯一<strong class="io hq"> UUID </strong>。</li><li id="7098" class="jm jn hp io b ip jv it jw ix jx jb jy jf jz jj mr js jt ju bi translated">实现结束按钮的动作:该动作将根据<strong class="io hq"> callID </strong>结束通话。</li><li id="ea32" class="jm jn hp io b ip jv it jw ix jx jb jy jf jz jj mr js jt ju bi translated">接听音频来电:要做到这一点，你必须模拟一个音频来电。因为CallKit不知道来电，所以您必须向CallKit报告来电。此操作需要呼叫者的用户ID和呼叫的唯一UUID。目前，因为来电是在本地进行的，所以您将使用随机生成的<strong class="io hq"> UUID() </strong>而不是真实来电者的<strong class="io hq"> UUID </strong>。如果要测试视频来电，将<strong class="io hq"> hasVideo </strong>参数的值指定为<strong class="io hq"> true </strong>。</li></ol><h1 id="cae2" class="ka kb hp bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="13b4" class="pw-post-body-paragraph im in hp io b ip ky ir is it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">本教程介绍了使用基于WebRTC和Apple CallKit框架构建的Sendbird Calls框架开发VoIP应用程序。您正在构建具有语音和视频通话功能的迷人应用。iOS调用app搭建快乐！</p></div></div>    
</body>
</html>