<html>
<head>
<title>Build A Telegram Translation Bot With Easegress</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Easegress构建一个电报翻译机器人</h1>
<blockquote>原文：<a href="https://medium.com/codex/build-a-telegram-translation-bot-with-easegress-194bc48cbd6e?source=collection_archive---------14-----------------------#2022-08-29">https://medium.com/codex/build-a-telegram-translation-bot-with-easegress-194bc48cbd6e?source=collection_archive---------14-----------------------#2022-08-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="bb91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Easegress是<a class="ae jd" href="https://megaease.com" rel="noopener ugc nofollow" target="_blank"> MegaEase </a>开发的下一代开源(</strong> <a class="ae jd" href="https://github.com/megaease/easegress" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Github </strong> </a> <strong class="ih hj">)基于流量的网关</strong> <strong class="ih hj">产品</strong>。它完全基于云原生技术构建，避免了传统反向代理在高可用性、流量协调、监控、服务发现等方面的缺点。</p><p id="006a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我们发布了Easegress v2.0，对流量编排进行了另一次重大增强，允许用户通过编排多个API来实现一个超级API，而无需编写任何代码。本文将通过构建一个电报翻译机器人来演示这一特性。这个机器人可以自动将收到的信息翻译成中文、日文和英文，除了文本信息，它还支持翻译语音和照片信息。</p><p id="5566" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有一个3分钟的演示和介绍视频。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="a352" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果想试试，可以在电报组中添加</strong> <code class="du jl jm jn jo b"><strong class="ih hj">@EaseTranslate</strong></code> <strong class="ih hj"> bot，授予其管理员权限。</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jp"><img src="../Images/fd86b75a31a5f19caef6e1a6c980a169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XRUhGtS7YHEK9j_mkDz-kQ.png"/></div></div></figure><h1 id="8bf4" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">1.先决条件</h1><p id="6297" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">由于bot需要接收电报消息通知和调用第三方API，我们必须提前准备以下内容:</p><ul class=""><li id="ad27" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">根据本文档安装最新版本的Easegress，并确保外部应用程序可以访问至少一个端口80、88、443或8443上的Easegress实例。</li><li id="83dc" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">按照<a class="ae jd" href="https://core.telegram.org/bots#3-how-do-i-create-a-bot" rel="noopener ugc nofollow" target="_blank">这个文档</a>创建一个电报机器人，设置它的名字(本文使用的是EaseTranslateBot)，记下它的令牌，<a class="ae jd" href="https://core.telegram.org/bots/api#setwebhook" rel="noopener ugc nofollow" target="_blank">设置一个Webhook </a>指向上一步安装的Easegress实例。我们的机器人将通过这个Webhook接收新消息的通知。</li><li id="c6fe" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">AWS访问密钥ID和访问密钥Secret，并确保您可以使用这个访问密钥来使用AWS转换API。</li><li id="73ad" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">Google Cloud的令牌，并确保您可以使用Google Cloud的语音识别API和OCR(图像注释)API来使用这个令牌。</li></ul><p id="b9a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用其他供应商的翻译、语音识别或OCR APIs，但是这需要您相应地修改后面部分中的示例。</p><h1 id="16f9" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">2.它是如何工作的</h1><p id="d620" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">下图显示了这个机器人的工作流程。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ln"><img src="../Images/25700fc05f1b73586556bcaf4edbbc0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pa2cm0CMbjYRFm7dR0gKWQ.png"/></div></div></figure><p id="ec26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当通过webhook从电报服务器收到新消息的通知时，机器人首先检查消息类型，并相应地执行以下操作:</p><ul class=""><li id="de8d" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated"><strong class="ih hj">短信:</strong>直接提取短信文本；</li><li id="3421" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><strong class="ih hj">语音消息:</strong>在这种情况下，消息体只包含语音文件的ID，所以我们需要调用Telegram的API将ID转换成文件地址，然后下载文件并将其内容发送到Google的语音识别服务，将其转换成文本；</li><li id="1949" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><strong class="ih hj">图片消息:</strong>基本上，这种情况与语音消息相同，但是文件内容被发送到Google的图像注释服务。</li></ul><p id="c0d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经过上述处理后，所有三种类型的消息都被转换成文本，然后可以调用AWS翻译服务将它们翻译成目标语言，本例中使用的目标语言是中文、日文和英文。</p><h1 id="6d93" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">3.管道</h1><p id="b27a" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">首先，让我们检查一下Pipeline编排的整体流程:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo jk l"/></div></figure><p id="7989" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们已经解释了机器人背后的基本思想，从上面的流程可以很容易地看到整个过程。但是，因为最终的响应需要组合多个API的执行结果，所以我们需要使用多个名称空间来存储这些API的参数和执行结果，即发送的请求和返回的响应。</p><p id="3f62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且，为了达到更好的效果，我们还在管道上定义了一些数据:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo jk l"/></div></figure><p id="3458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中<strong class="ih hj"> zh </strong>、<strong class="ih hj"> ja </strong>和<strong class="ih hj"> en </strong>为中文、日文和英文的语言代码，<strong class="ih hj"> text </strong>为语言名称和对应的标志，<strong class="ih hj"> fallback </strong>为翻译失败时的替换文本，如下图所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lp"><img src="../Images/9c4ba872a50be2a69103c1ecda155814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9BDgZo2VcOzpa-hwYIbyfw.png"/></div></div></figure><h1 id="6ae2" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">4.过滤器</h1><p id="0bf1" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在Easegress中，过滤器是处理流量的组件，具体来说，在本例中，管道负责编排流量，而检测消息类型和调用第三方API则由过滤器完成。</p><h1 id="4fb8" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">4.1后端代理</h1><p id="0c11" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">所有的外部API请求都是通过代理过滤器发送的，这个例子使用了四个外部服务，所以有四个代理过滤器，由于它们的配置非常简单，我就不多做介绍了。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo jk l"/></div></figure><h1 id="e96a" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">4.2检测消息类型</h1><p id="6ab4" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">这是通过ResultBuilder筛选器完成的，配置如下:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo jk l"/></div></figure><p id="a50e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它的模板字段是按照<a class="ae jd" href="https://pkg.go.dev/text/template" rel="noopener ugc nofollow" target="_blank"> Go text/template package </a>的要求编写的模板，运行时生成一个字符串，ResultBuilder返回给Pipeline作为它的执行结果，Pipeline可以基于这个执行结果进行跳转。换句话说，ResultBuilder和Pipeline一起工作来实现类似于编程语言的开关情况功能。</p><p id="7d82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Telegram中的一条消息可能来自一个用户组，也可能来自一个通道，表示消息体的字段不同，所以模板先确定这一点，但两种情况下，消息体的格式都是一样的。</p><p id="433a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jl jm jn jo b"><strong class="ih hj">DEFAULT</strong></code>是请求所属的名称空间，其中<code class="du jl jm jn jo b"><strong class="ih hj">.requests.DEFAULT</strong></code>是Telegram通过webhook随消息发送的HTTP请求。通过检查消息正文中文本、语音和照片字段的有效性，我们可以知道消息的类型。</p><p id="9ed4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目前ResultBuilder的结果只能是<code class="du jl jm jn jo b"><strong class="ih hj">result0</strong></code> — <code class="du jl jm jn jo b"><strong class="ih hj">result9</strong></code>，所以我们对短信使用<code class="du jl jm jn jo b"><strong class="ih hj">result0</strong></code>，对语音消息使用<code class="du jl jm jn jo b"><strong class="ih hj">result1</strong></code>，对图片消息使用<code class="du jl jm jn jo b"><strong class="ih hj">result2</strong></code>。稍后我们将增强这个过滤器，使结果更具可读性。</p><h1 id="e94e" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">4.3读取文件内容</h1><p id="2458" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">语音和照片消息都需要首先将消息中的文件ID转换为文件路径，然后读取文件以获取其内容，这是使用以下过滤器完成的:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo jk l"/></div></figure><p id="7a2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，将文件ID转换为路径的步骤对于照片来说比对于语音来说要复杂一些。这是因为，对于同一张原始照片，Telegram可能会生成多个大小不同的缩略图，并将所有缩略图与原始照片一起发送，而最后一张才是原始照片。</p><h1 id="e0a2" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">4.4语音识别和OCR</h1><p id="a60c" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">这两个过滤器有点复杂，但是它们都只是根据第三方服务的请求创建相应的HTTP请求。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo jk l"/></div></figure><h1 id="a9f0" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">4.5文本提取</h1><p id="331e" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">对于三种不同的消息类型，我们都使用过滤器来提取文本。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo jk l"/></div></figure><p id="b59c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能已经注意到，我们在文本消息中使用了一个<strong class="ih hj"> exclude </strong>字段，这是为了在翻译结果中排除原文，而对于语音或照片消息，识别的文本内容可能会不准确，因此要保留识别的文本供用户参考。</p><h1 id="29d3" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">4.6翻译</h1><p id="368f" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">由于AWS要求对所有请求进行签名，因此在通过RequestBuilder创建请求之后，使用RequestAdaptor来完成签名。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo jk l"/></div></figure><h1 id="50a4" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">4.7将翻译结果构建到回复消息中</h1><p id="38f0" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">这是本文中最复杂的过滤器，但一般来说，它只是按照Telegram的要求，组织我们之前获得的信息。特别是，<code class="du jl jm jn jo b"><strong class="ih hj">$.data.PIPELINE</strong></code>引用了我们在管道上定义的数据。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo jk l"/></div></figure><h1 id="8d24" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">4.8回应</h1><p id="021f" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">Telegram要求我们对每个请求返回一个响应。因为我们不需要通过这个响应来回复消息，所以我们可以简单地将状态代码设置为200。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo jk l"/></div></figure><h1 id="ae7a" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">5.部署</h1><p id="41d2" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">一旦我们准备好了配置文件(可以在这里下载<a class="ae jd" href="https://github.com/megaease/easegress/tree/main/example/translation-bot" rel="noopener ugc nofollow" target="_blank">，我们就可以通过下面的命令将这个管道部署到Easegress(假设文件名是<code class="du jl jm jn jo b">translate-pipeline.yaml</code>)。</a></p><p id="c019" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> $ egctl对象create-f translate-pipeline . YAML</strong></p><p id="a79a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们还需要创建一个HTTPServer，并让它将通过webhook发送的telegram的消息通知转发到上面的管道，注意，这个管道的外部访问地址必须是我们前面创建的Telegram webhook的地址。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lo jk l"/></div></figure><p id="f9a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已。只有yaml文件，没有编码工作。</p></div></div>    
</body>
</html>