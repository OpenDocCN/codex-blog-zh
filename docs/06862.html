<html>
<head>
<title>Aspect Object Programing with Spring boot Example (Part Tow)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Spring boot实例进行特征对象编程(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/aspect-object-programing-with-spring-boot-example-a2d0bf8f1578?source=collection_archive---------4-----------------------#2022-05-17">https://medium.com/codex/aspect-object-programing-with-spring-boot-example-a2d0bf8f1578?source=collection_archive---------4-----------------------#2022-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/96de354da76f85e96e338de3355e921f.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*nDcQyOdZHVEcowvqBOa1vQ.png"/></div></div></figure><h2 id="dc7f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">简介:</h2><p id="66a1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">在上一篇文章中，我们讨论了方面，如果你读了上一篇文章，你应该知道方面核心概念和方面的spring boot概念。在本文中，我将在spring boot项目中使用java编写方面代码。</p><blockquote class="kj kk kl"><p id="6467" class="jo jp km jq b jr kn jt ju jv ko jx jy kp kq ka kb kr ks kd ke kt ku kg kh ki hb bi translated">github项目链接<a class="ae kv" href="https://github.com/abdalrhmanAlkraien/Aspect-example" rel="noopener ugc nofollow" target="_blank">https://github.com/abdalrhmanAlkraien/Aspect-example</a></p></blockquote><h2 id="8437" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">外观配置:</h2><p id="8c3d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">要在任何spring-boot应用程序中应用方面编程，您需要进行方面配置。在当前步骤中，我们需要转到两个位置:对于第一个位置，我们需要更新pom.xml文件并放置方面依赖关系。</p><p id="c2ac" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">我们可以使用spring中提供的方面依赖，但是在本文中，我将使用AspectJ依赖。</p><p id="b809" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><code class="du kw kx ky kz b"><strong class="jq hj">Pom.xml</strong></code> <strong class="jq hj">文件:</strong></p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="5837" class="iq ir hi kz b fi li lj l lk ll">&lt;!-- enable aspect --&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;<br/>    &lt;version&gt;5.3.18&lt;/version&gt;<br/>&lt;/dependency&gt;<br/><br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;<br/>    &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;<br/>    &lt;version&gt;1.9.9.1&lt;/version&gt;<br/>&lt;/dependency&gt;<br/><br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;<br/>    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;<br/>    &lt;version&gt;1.9.9.1&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="d1f5" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">现在我将创建一个名为<code class="du kw kx ky kz b"><strong class="jq hj">AspectConfig.java</strong></code> <strong class="jq hj"> </strong>的java文件，然后添加<code class="du kw kx ky kz b">@EnableAspectJAutoProxy</code>。从上一篇文章中，你可以知道为什么我在使用<strong class="jq hj"> Aspect时需要启用代理。</strong></p><p id="3152" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><code class="du kw kx ky kz b">AspectConfig.java</code>文件</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="97ca" class="iq ir hi kz b fi li lj l lk ll">@EnableAspectJAutoProxy(exposeProxy = true)<br/>public class AspectConfig {<br/>}</span></pre><p id="5e97" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><a class="ae kv" href="http://localhost:8080/swagger-ui.html" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/swagger-ui . html</a></p><p id="1ca4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">现在我有了一个控制器包和服务包，我将在其中编写业务逻辑。</p><h2 id="43f0" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">业务逻辑:</h2><p id="64e3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">在这一节中，我们只需要定义一些Api来为方面采取一些行动。</p><p id="2305" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><strong class="jq hj">controller.TaskController.java</strong></p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="e1c6" class="iq ir hi kz b fi li lj l lk ll">@RestController<br/>@RequestMapping("/api/tasks")<br/>public class TaskController {<br/><br/>    private final TaskService taskService;<br/>    public TaskController(TaskServiceImp taskService){<br/>        this.taskService=taskService;<br/>    }<br/><br/>    @GetMapping<br/>    @ApiOperation(value = "Get all tasks")<br/>    public void getTask(){<br/>        taskService.getTask();<br/>    }<br/><br/>    @PostMapping<br/>    @ApiOperation(value = "save new task")<br/>    public String saveTask(){<br/>        return taskService.saveTask();<br/>    }<br/><br/>    @GetMapping("/{id}")<br/>    @ApiOperation(value = "get one task by id")<br/>    public String getTaskById(@ApiParam(value = "1",required = true, example = "123") @PathVariable("id") Long id){<br/>        return taskService.getTaskById(id);<br/>    }<br/><br/>    @PutMapping<br/>    @ApiOperation(value = "update any task")<br/>    public String updateTask(){<br/>        return taskService.updateTask();<br/>    }<br/><br/>    @DeleteMapping("/{id}")<br/>    @ApiOperation(value = "delete task by id")<br/>    public String deleteTaskById(@ApiParam(value = "1",required = true, example = "123") @PathVariable("id") Long id){<br/>        return taskService.deleteTaskById(id);<br/>    }<br/>}</span></pre><p id="fc1c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><strong class="jq hj">service.TaskService.java</strong></p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="f4e9" class="iq ir hi kz b fi li lj l lk ll">public interface TaskService {<br/><br/>    String getTask();<br/>    String saveTask();<br/>    String getTaskById(Long id);<br/>    String updateTask();<br/>    String deleteTaskById(Long id);<br/><br/>}</span></pre><p id="7663" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><strong class="jq hj">service.Impl.TaskServiceImpl.Java</strong></p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="e1dc" class="iq ir hi kz b fi li lj l lk ll">@Service<br/>public class TaskServiceImp implements TaskService {<br/><br/>    public  TaskServiceImp(){<br/><br/>    }<br/><br/>    @Override<br/>    public String getTask() {<br/>        return "execute getTask";<br/>    }<br/><br/>    @Override<br/>    public String saveTask() {<br/>        return "execute saveTask";<br/><br/>    }<br/><br/>    @Override<br/>    @Loggable<br/>    public String getTaskById(Long id) throws Exception {<br/>        if(id&lt;1){<br/>            throw new Exception("the id less than 1");<br/>        }<br/>        return "execute getTaskById ".concat(id.toString());<br/>    }<br/><br/>    @Override<br/>    public String updateTask() {<br/>        return "execute updateTask";<br/><br/>    }<br/><br/>    @Override<br/>    @Loggable<br/>    public String deleteTaskById(Long id) throws Exception {<br/>        if(id&lt;1){<br/>            throw new Exception("the id less than 1");<br/>        }<br/>        return "execute deleteTaskById ".concat(id.toString());<br/>    }<br/><br/>}</span></pre><blockquote class="kj kk kl"><p id="5f6b" class="jo jp km jq b jr kn jt ju jv ko jx jy kp kq ka kb kr ks kd ke kt ku kg kh ki hb bi translated">现在所有的服务和Api都完成了。</p></blockquote><h2 id="c200" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">方面任务:</h2><p id="fbd9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">在这个会话中，我将创建一个方面类来定义我们的切入点和建议，以记录所有执行的API和日志异常。</p><p id="00d4" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><strong class="jq hj">什么方面会做？</strong></p><p id="6932" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><strong class="jq hj">方面会记录不同的事情:</strong></p><ul class=""><li id="c84f" class="lm ln hi jq b jr kn jv ko jb lo jf lp jj lq ki lr ls lt lu bi translated">当进入API方法时，我们需要日志信息。</li><li id="2c4f" class="lm ln hi jq b jr lv jv lw jb lx jf ly jj lz ki lr ls lt lu bi translated">当退出API时，我们需要日志信息。</li><li id="e2ed" class="lm ln hi jq b jr lv jv lw jb lx jf ly jj lz ki lr ls lt lu bi translated">我们需要使用名为<strong class="jq hj">loggeable</strong>的注释记录服务方法返回值的信息。</li><li id="0ce7" class="lm ln hi jq b jr lv jv lw jb lx jf ly jj lz ki lr ls lt lu bi translated">我们需要项目中发生的异常的日志信息。</li></ul><p id="4865" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><code class="du kw kx ky kz b"><strong class="jq hj">aspect.AspectTask.java</strong></code> <strong class="jq hj">文件:</strong></p><p id="090e" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">在当前会话中，我将分解解释每个方法，完成后，我将把所有的类方法放在一个块中。</p><p id="5bf1" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">第一步，我定义了一些变量作为切入点，如下所示。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="a04e" class="iq ir hi kz b fi li lj l lk ll">private final String apiPointcut="execution(* com.example.logger.springlogger.controller.*.*(..))";</span><span id="33b3" class="iq ir hi kz b fi ma lj l lk ll">private final String exceptionPointcut ="execution(* com.example.logger.springlogger.*.*.*(..))";</span></pre><p id="d8d5" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">实际上，我们可以用这种方式来定义点切割，或者用本文中的其他方法来定义点切割。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="ecb5" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><strong class="jq hj">作为方法的切入点</strong></p><p id="b7de" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">我们可以使用<code class="du kw kx ky kz b">@Pointcut</code>来定义你的切入点，但是这样，你必须使用一个方法来定义它。比如下面的代码。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="3dae" class="iq ir hi kz b fi li lj l lk ll">@Pointcut(apiPointcut)<br/>public void APIPointCut(){}</span></pre><p id="4b6a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">现在我们有了切入点，但是我们需要使用建议来处理这个切入点。</p><p id="d7b6" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><strong class="jq hj">方面的建议</strong></p><p id="ccc8" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">当使用方面时，必须使用advice，因为当特定事件发生时，我们需要记录任何事情。</p><p id="cf58" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">要使用任何建议，我们需要为建议设置切入点。我们可以使用这种方式<code class="du kw kx ky kz b">@Advice(Pointcut)</code>在任何通知中定义切入点。</p><blockquote class="kj kk kl"><p id="a8e5" class="jo jp km jq b jr kn jt ju jv ko jx jy kp kq ka kb kr ks kd ke kt ku kg kh ki hb bi translated">你可以看到这个链接来了解Aspect中的建议类型。</p></blockquote><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="25d5" class="iq ir hi kz b fi li lj l lk ll">@Before("APIPointCut()")<br/>public void logEnteringAPI(JoinPoint joinPoint){<br/>    <em class="km">log</em>.info("The API method will executing {}",joinPoint.getSignature().getName());<br/>    if(joinPoint.getArgs().length&gt;0){<br/>        Object[] args=joinPoint.getArgs();<br/>        <em class="km">log</em>.info("the Api argument is ".concat(args[0].toString()));<br/>    }<br/>}</span></pre><p id="717f" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><code class="du kw kx ky kz b">JoinPoint</code> : Joinpoint是对原始方法的引用，我们可以从<code class="du kw kx ky kz b">JoinPoint</code>接口知道这个方法的方法名和参数。</p><p id="57cc" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">上面的建议<code class="du kw kx ky kz b">logEnteringAPI(JoinPoint joinPoint)</code>会在调用<code class="du kw kx ky kz b">pointCut</code>里面的方法之前执行，然后会执行里面的实现，之后会执行原来的方法，并带着愉快的场景前进。</p><p id="edcb" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">我使用了来自连接点的<code class="du kw kx ky kz b">Args</code>对象实例，用于记录原始方法中的参数。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="cc8c" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">现在我们需要为退出API方法时的日志编写实现。</p><p id="7931" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">我们将使用同一个名为<code class="du kw kx ky kz b">APIPointCut()</code>方法的切入点，因为我们需要同一个包中的日志。我们用它和<code class="du kw kx ky kz b">@Before</code>建议。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="03ed" class="iq ir hi kz b fi li lj l lk ll">@After("APIPointCut()")<br/>public void logExitingAPI(JoinPoint joinPoint){<br/>    <em class="km">log</em>.info("The API method finished execute {}",joinPoint.getSignature().getName());<br/>}</span></pre><p id="b8c7" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">用上面的建议调用<code class="du kw kx ky kz b">Pointcut</code>里面的方法后会被执行。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="17fb" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">我为日志特定的方法创建了一个新的注释，叫做<code class="du kw kx ky kz b">Loggable</code></p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="f252" class="iq ir hi kz b fi li lj l lk ll">public @interface Loggable {<br/>}</span></pre><p id="4f04" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">我在上面的<code class="du kw kx ky kz b">TaskServiceImp </code>中使用了两个方法，分别叫做<code class="du kw kx ky kz b">getTaskById</code>和<code class="du kw kx ky kz b">deleteTaskById</code></p><p id="f695" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">比如下面的代码片段:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="5d47" class="iq ir hi kz b fi li lj l lk ll">@Override<br/>@Loggable<br/>public String getTaskById(Long id)</span></pre><p id="00f0" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">和</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="afd3" class="iq ir hi kz b fi li lj l lk ll">@Override<br/>@Loggable<br/>public String deleteTaskById(Long id)</span></pre><p id="2050" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">并且advice方法必须有一个新的切入点来指向注释。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="d009" class="iq ir hi kz b fi li lj l lk ll">@AfterReturning(value = "@annotation(com.example.logger.springlogger.aspect.TaskServiceAspect.Loggable)"<br/>,returning = "returnValue")<br/>public void logEachReturningValue(JoinPoint joinPoint<br/>,Object returnValue){</span><span id="b203" class="iq ir hi kz b fi ma lj l lk ll">    <em class="km">log</em>.info("the value from method:"<br/>.concat(joinPoint.getSignature().getName())<br/>.concat(returnValue.toString()));</span><span id="e2da" class="iq ir hi kz b fi ma lj l lk ll">}</span></pre><p id="323d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">上面代码中用于处理任何方法的项目里面都有<code class="du kw kx ky kz b"><a class="ae kv" href="http://twitter.com/Loggable" rel="noopener ugc nofollow" target="_blank">@Loggable</a></code>。并将记录返回值。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="c79d" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">现在我们需要任何异常的日志，以及哪个方法有这个异常。</p><p id="a0d8" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">我们使用变量作为<code class="du kw kx ky kz b">Pointcut</code>，在这个例子中称为<code class="du kw kx ky kz b">exceptionPointcut</code>，并将使用带有<code class="du kw kx ky kz b">AfterThrowing</code>通知的变量来捕捉项目中的任何异常。</p><p id="ac45" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><code class="du kw kx ky kz b">exceptionPointcut</code>将扫描项目中的所有方法，你可以从下面一行代码中看到它的价值。</p><p id="fa1a" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><code class="du kw kx ky kz b">exceptionPointcut= ”execution(* com.example.logger.springlogger.*.*.*(..))”</code></p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="d049" class="iq ir hi kz b fi li lj l lk ll">@AfterThrowing(value = exceptionPointcut ,throwing = "exception")<br/>public void logsExceptionsFromAnyLocations(JoinPoint joinPoint,Throwable exception) throws Throwable {<br/>    <em class="km">log</em>.error("We have error in this method {}",joinPoint.getSignature().getName());<br/>    <em class="km">log</em>.error("The exception message: ".concat(exception.getMessage()));<br/>}</span></pre><p id="3dbc" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated">上述建议将在应用程序中抛出任何异常时执行，并将记录该异常的方法名称和异常消息。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="cfdc" class="pw-post-body-paragraph jo jp hi jq b jr kn jt ju jv ko jx jy jb kq ka kb jf ks kd ke jj ku kg kh ki hb bi translated"><code class="du kw kx ky kz b"><strong class="jq hj">aspect.AspcetTask.java</strong></code> <strong class="jq hj">文件:</strong></p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="f59c" class="iq ir hi kz b fi li lj l lk ll">@Aspect<br/>@Log4j2<br/>@Component<br/>public class TaskServiceAspect {<br/><br/>    private final String apiPointcut="execution(* com.example.logger.springlogger.controller.*.*(..))";<br/>    private final String exceptionPointcut ="execution(* com.example.logger.springlogger.*.*.*(..))";<br/><br/>    @Pointcut(apiPointcut)<br/>    public void APIPointCut(){}<br/><br/><br/>    @Before("APIPointCut()")<br/>    public void logEnteringAPI(JoinPoint joinPoint){<br/>        <em class="km">log</em>.info("The API method will executing {}",joinPoint.getSignature().getName());<br/>        if(joinPoint.getArgs().length&gt;0){<br/>            Object[] args=joinPoint.getArgs();<br/>            <em class="km">log</em>.info("the Api argument is ".concat(args[0].toString()));<br/>        }<br/>    }<br/><br/>    @After("APIPointCut()")<br/>    public void logExitingAPI(JoinPoint joinPoint){<br/>        <em class="km">log</em>.info("The API method finished execute {}",joinPoint.getSignature().getName());<br/>    }<br/><br/>    @AfterThrowing(value = exceptionPointcut ,throwing = "exception")<br/>    public void logsExceptionsFromAnyLocations(JoinPoint joinPoint,Throwable exception) throws Throwable {<br/>        <em class="km">log</em>.error("We have error in this method {}",joinPoint.getSignature().getName());<br/>        <em class="km">log</em>.error("The exception message: ".concat(exception.getMessage()));<br/>    }<br/><br/>    @AfterReturning(value = "@annotation(com.example.logger.springlogger.aspect.TaskServiceAspect.Loggable)",returning = "returnValue")<br/>    public void logEachReturningValue(JoinPoint joinPoint,Object returnValue){<br/>        <em class="km">log</em>.info("the value from method: ".concat(joinPoint.getSignature().getName()).concat(returnValue.toString()));<br/>    }<br/><br/>    public @interface Loggable {<br/>    }<br/>}</span></pre><h2 id="e7ee" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">运行应用程序后记录日志</h2><p id="0a51" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">运行应用程序并调用任何API后，您可以看到类似这样的内容。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/b49fc66e051f542a270b9d3448daad02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Zk35_9QjZ43kvIwvAN2dw.png"/></div></div></figure><h1 id="f173" class="mj ir hi bd is mk ml mm iw mn mo mp ja mq mr ms je mt mu mv ji mw mx my jm mz bi translated">结论</h1><p id="6f84" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">从这篇文章中，我们学习并练习了如何在spring boot中使用aspect，以及如何在aspect中使用我们自己的注释。如果我们被前一篇文章弄糊涂了，我想这篇文章会让你清醒地思考这个问题。你可以使用这个<a class="ae kv" href="https://github.com/abdalrhmanAlkraien/Aspect-example" rel="noopener ugc nofollow" target="_blank">链接</a>来访问GitHub上的这个项目，你可以看到它来学习、克隆和实践它。</p></div></div>    
</body>
</html>