<html>
<head>
<title>Concurrency in Dart — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dart中的并发性—第二部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/concurrency-in-dart-part-ii-e67ec0f110c4?source=collection_archive---------12-----------------------#2022-03-30">https://medium.com/codex/concurrency-in-dart-part-ii-e67ec0f110c4?source=collection_archive---------12-----------------------#2022-03-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f814" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">dart中的异步、未来、等待和完成。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/8c15e9799ae56e4af88d76c2ee7047f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G5KvDKNESwTYrbALGN_K2Q.png"/></div></div></figure><h1 id="67a5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">将来的</h1><p id="03d8" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Dart有一个Future类型，它是一个稍后返回某个特定类型的值的承诺。</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="749f" class="kx jq hi kt b fi ky kz l la lb">Future&lt;int&gt; countTheStars();</span></pre><p id="c321" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Future本身是通用的，可以提供任何类型。如果你调用这个函数，那么它会立即返回一个<em class="lc">Future&lt;int&gt;T1】。这个未来可以被倾听或等待。在后台，它将调用ISRO/美国宇航局的HTTP APIs(如果这些可用的话)，并返回几个星或错误(由于一些问题)。假设你在听未来，因此结果会传递给你。</em></p><p id="1e5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦数星机从美国宇航局/ISRO返回，它就会来到Dart并告诉它把它放回<strong class="ih hj">事件队列</strong>。正如我们所知，<strong class="ih hj">事件循环</strong>处理事件队列中的任务，最终，一旦从事件队列中挑选出结果，将会通知将来收听结果的人。</p><p id="6cf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">未来可以是这些状态中的任何一种</strong></p><ol class=""><li id="a4fd" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated">未完成。</li><li id="6006" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">用一个值完成。</li><li id="2316" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">已完成，但有错误。</li></ol><p id="cdff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="ba72" class="kx jq hi kt b fi ky kz l la lb">final myFuture = Future&lt;int&gt;.delayed(<br/>  Duration(milliseconds:1),<br/>  () =&gt; 42,<br/>);</span></pre><p id="3036" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Future.delayed </strong>是一个返回未来值的函数。它接受一个<strong class="ih hj"> Duration </strong>对象和一个返回值的函数(基于未来类型，这里是int)。Dart在duration对象提到的持续时间之后运行这个函数。</p><h1 id="892a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">从未来中获取价值</h1><p id="66ad" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">如果你试着打印我的未来，你会得到这个结果:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="bdb0" class="kx jq hi kt b fi ky kz l la lb">print(myFuture)<br/><strong class="kt hj">Result:<br/></strong>Instance of 'Future&lt;int&gt;'</span></pre><h2 id="d9b9" class="kx jq hi bd jr lr ls lt jv lu lv lw jz iq lx ly kd iu lz ma kh iy mb mc kl md bi translated">通过回调获得结果</h2><p id="934e" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">有三个回调:<strong class="ih hj">然后是</strong>、<strong class="ih hj"> catchError </strong>和<strong class="ih hj"> whenComplete </strong>。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="mg mh et er es mi mj bd b be z dx translated"><a class="ae mk" href="https://dartpad.dartlang.org/?id=0846789ef19a19ca6037ab52046e0010" rel="noopener ugc nofollow" target="_blank">https://dartpad.dartlang.org/?id = 0846789 ef 19 a 19 ca 6037 ab 52046 e 0010</a></figcaption></figure><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="65fc" class="kx jq hi kt b fi ky kz l la lb"><strong class="kt hj">Output</strong><br/>After the future<br/>32<br/>Future completed</span></pre><p id="10d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你读了最后一篇<a class="ae mk" href="https://tarunengineer.medium.com/concurrency-in-dart-part-i-d20bf5fcb250" rel="noopener">文章</a>，你就会知道为什么这是打印声明的顺序。print()是同步函数，<strong class="ih hj"> Future.delayed </strong>是异步函数。</p><blockquote class="ml mm mn"><p id="53b8" class="if ig lc ih b ii ij ik il im in io ip mo ir is it mp iv iw ix mq iz ja jb jc hb bi translated">这里要注意的有趣的事情是，即使持续时间是0毫秒，未来的代码也将被推到事件队列中，同步代码将首先运行。</p></blockquote><h2 id="5558" class="kx jq hi bd jr lr ls lt jv lu lv lw jz iq lx ly kd iu lz ma kh iy mb mc kl md bi translated">用async-await获取结果</h2><p id="cbc4" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">回调很容易理解，但是很难阅读和实现。我相信我们的大脑顺序思考会更好。同样，如果你嵌套它们，那就更困难了。只要在谷歌搜索一下<strong class="ih hj">回拨地狱</strong>你就会得到答案。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div><figcaption class="mg mh et er es mi mj bd b be z dx translated"><a class="ae mk" href="https://dartpad.dartlang.org/?id=9d3966358ddc76e8b8c5379b1ba6f242" rel="noopener ugc nofollow" target="_blank">https://dartpad.dartlang.org/?id = 9d 3966358 DDC 76 E8 b 8c 5379 B1 ba 6 f 242</a></figcaption></figure><p id="1c64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">wait</strong>在then &amp; catchError之上充当语法糖。在这里，整个异步功能被视为未来的<strong class="ih hj"/>。任何使用await的函数必须是一个<strong class="ih hj">异步</strong>函数。当您正在等待的被调用的future函数完成时，它会告诉dart将它放回事件队列，然后像前面一样被选取。每次等待调用时都会发生这种情况。使用try-catch，您可以看到如何捕捉错误以及了解未来何时完成。</p><p id="ebb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，由于await使流在逻辑上同步，因此“在未来之后”仅在未来完成之后打印。</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="6fc2" class="kx jq hi kt b fi ky kz l la lb"><strong class="kt hj">Output</strong><br/>32<br/>future is complete<br/>after the future</span></pre><h1 id="8994" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">完成者</h1><p id="717b" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">好了，现在你明白了未来和异步等待。现在，您正在为rest APIs使用一个HTTP库，它完全基于回调(非未来的dart API ),并且您希望向您的消费者呈现一个Dart facade。在这种情况下，<strong class="ih hj">完成者</strong>前来救援。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="f3a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第4行中，我们创建了一个<strong class="ih hj">完成符</strong>，它在完成时返回一个字符串。Completer有一个future属性，它有一个Future类型，你通常可以使用上面讨论的不同方法从中获取一个值。如果你看到getHttpData接收两个匿名函数:onComplete和onError。在这些匿名函数中，我们可以使用我们的完成器实例来完成它，未来的侦听器将根据HTTP库的结果接收值或错误。</p><p id="a2bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">进一步阅读:</strong></p><ol class=""><li id="554f" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated"><a class="ae mk" href="https://tarunengineer.medium.com/concurrency-in-dart-part-i-d20bf5fcb250" rel="noopener"><em class="lc">Dart中的并发:Part — I. </em> </a></li><li id="029b" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated"><a class="ae mk" href="https://tarunengineer.medium.com/concurrency-in-dart-part-iii-2086329d82a2" rel="noopener"><em class="lc">Dart中的并发:第三部。</em>T19】</a></li></ol></div></div>    
</body>
</html>