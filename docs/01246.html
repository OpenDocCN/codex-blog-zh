<html>
<head>
<title>Should I use X-buffers to Serialize Data?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我应该使用X-buffers来序列化数据吗？</h1>
<blockquote>原文：<a href="https://medium.com/codex/should-i-use-x-buffers-to-serialize-data-1cb405e0e98a?source=collection_archive---------15-----------------------#2021-04-13">https://medium.com/codex/should-i-use-x-buffers-to-serialize-data-1cb405e0e98a?source=collection_archive---------15-----------------------#2021-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="735b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">x缓冲区？你什么意思？，easy，<strong class="ak"> Flat- </strong> buffers和<strong class="ak"> Protocol- </strong> buffers(这不是官方的，只是我决定将这两个术语分组的一种方式)</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/84c953476e76d1f1dcf6db70f33cfec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fvU7nASBzVKdypFL"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">由<a class="ae jn" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯文·Ku</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3b7b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">每当一项新技术或框架涌现时，人们通常会认为它在各方面都比以前的好，因为它更新，但是，理解它旨在解决什么问题以及它是否在所有情况下都足够好是很重要的，这就是为什么我决定写这篇文章，以便了解X-Buffers是否真的比JSON更好。</p><p id="2bf9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了确定使用X-Buffers是否是一个好主意，我将通过不同的场景进行Golang基准测试。这是用于进行比较的模式(完整模式<a class="ae jn" href="https://github.com/cperez08/xbuffer-bench/tree/main/model" rel="noopener ugc nofollow" target="_blank">这里是</a>)。</p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="3446" class="kp kq hi kl b fi kr ks l kt ku">type <strong class="kl hj">Customer</strong> struct {<br/>  <strong class="kl hj">FirstName</strong>   string               <br/>  <strong class="kl hj">LastName</strong>    string               <br/>  <strong class="kl hj">Age</strong>         uint32               <br/>  <strong class="kl hj">Balance</strong>     float64              <br/>  <strong class="kl hj">Debt</strong>        float64              <br/>  <strong class="kl hj">Preferences</strong> *Preferences         <br/>  <strong class="kl hj">Friends</strong>     []*Customer          <br/>  <strong class="kl hj">Addresses</strong>   map[string]*Location <br/>}</span></pre><p id="1def" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您不熟悉协议缓冲区或FlatBuffer，在进一步阅读之前，您可以查看一下这些资源。</p><ul class=""><li id="2fdc" class="kv kw hi jq b jr js ju jv jx kx kb ky kf kz kj la lb lc ld bi translated"><a class="ae jn" href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener ugc nofollow" target="_blank">协议缓冲IDL指南</a>和<a class="ae jn" href="https://www.youtube.com/watch?v=72mPlAfHIjs" rel="noopener ugc nofollow" target="_blank">协议缓冲简介</a></li><li id="be1a" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated"><a class="ae jn" href="https://google.github.io/flatbuffers/" rel="noopener ugc nofollow" target="_blank">平面缓冲器介绍</a>和<a class="ae jn" href="https://google.github.io/flatbuffers/flatbuffers_benchmarks.html" rel="noopener ugc nofollow" target="_blank">平面缓冲器基准测试</a></li></ul><h1 id="4ec8" class="lj kq hi bd lk ll lm ln lo lp lq lr ls io lt ip lu ir lv is lw iu lx iv ly lz bi translated"><strong class="ak">实验</strong></h1><p id="714a" class="pw-post-body-paragraph jo jp hi jq b jr ma ij jt ju mb im jw jx mc jz ka kb md kd ke kf me kh ki kj hb bi translated">现在，让我们进行一些基准测试，为此，我将使用3种不同的复杂性级别，以便我们可以看到每种序列化格式在不同压力级别下的表现:</p><ul class=""><li id="c29c" class="kv kw hi jq b jr js ju jv jx kx kb ky kf kz kj la lb lc ld bi translated"><strong class="jq hj">第1级</strong>，客户对象有1个地址。</li><li id="215c" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated"><strong class="jq hj">级别2 </strong>，客户对象有10个地址，10个朋友，每个朋友包含10个地址。</li><li id="a005" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated"><strong class="jq hj">三级</strong>，客户对象有100个地址，200个好友，每个好友包含100个地址。</li></ul><p id="4209" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="mf">所有测试均在CPU为英特尔酷睿i5–6267 u CPU、2.90GHz、Golang 1.16.2的机器上运行，</em>结果可能因其他语言或机器而异。</p><h2 id="0665" class="kp kq hi bd lk mg mh mi lo mj mk ml ls jx mm mn lu kb mo mp lw kf mq mr ly ms bi translated">1级封送指标</h2><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="3e90" class="kp kq hi kl b fi kr ks l kt ku">JSON   354464  3442 ns/op  1075 B/op  14 allocs/op<br/>Proto  467773  2188 ns/op  1088 B/op  15 allocs/op<br/>FBS    697542  1690 ns/op  1304 B/op  10 allocs/op</span><span id="b72b" class="kp kq hi kl b fi mt ks l kt ku"><strong class="kl hj">Size in bytes</strong><br/>JSON:371, Proto:143, Fbs:296</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/4cc21b26123b10b00a4f0c74f6b5c517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptDzyeIfr5K1Lz__2VIZzg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">一级元帅</figcaption></figure><p id="8f8c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我不得不承认，第一次运行这些测试时，我不得不重新考虑所有的实现，因为以前我有一个误解，认为FlatBuffer在所有意义上都比JSON和协议缓冲格式好得多，但正如您所看到的，对于我们最简单的场景，情况并非如此。</p><h2 id="5b3b" class="kp kq hi bd lk mg mh mi lo mj mk ml ls jx mm mn lu kb mo mp lw kf mq mr ly ms bi translated">第2级封送指标</h2><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="95a2" class="kp kq hi kl b fi kr ks l kt ku">JSON    6504   177418 ns/op  52443 B/op  619 allocs/op<br/>Proto   9921   128793 ns/op  43157 B/op  717 allocs/op<br/>FBS     10000  116492 ns/op  62473 B/op  326 allocs/op</span><span id="c796" class="kp kq hi kl b fi mt ks l kt ku"><strong class="kl hj">Size in KB</strong><br/>JSON:17, Proto:8.9, Fbs:13</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/fe5a07f781631184d1550759541faae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQ0-m-YJSfkKOne7nSmy8A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">二级元帅</figcaption></figure><p id="c4c5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这种情况下，JSON在任何情况下都不再是赢家，Protocol Buffer缩短了使用FlatBuffer的时间，作为结论，Protocol Buffer看起来是我们在这种情况下的最佳选择，现在让我们将这种行为与更极端的情况进行对比。</p><h2 id="2e2d" class="kp kq hi bd lk mg mh mi lo mj mk ml ls jx mm mn lu kb mo mp lw kf mq mr ly ms bi translated">第3级封送指标</h2><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="17d6" class="kp kq hi kl b fi kr ks l kt ku">JSON    39  29045645 ns/op  9810394 B/op  84209 allocs/op<br/>Proto   55  21001219 ns/op  6334196 B/op  103901 allocs/op<br/>FBS     78  13158922 ns/op  8333920 B/op  42052 allocs/op</span><span id="7372" class="kp kq hi kl b fi mt ks l kt ku"><strong class="kl hj">Size in MB</strong><br/>JSON:2.5, Proto:1.2, Fbs:2.0</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/665a7491cc2da0b9c5d1799830844720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tcs2FtgJsLPr7IkaLMwtpA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">三级元帅</figcaption></figure><p id="4e22" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">记得这一次我使用了100个地址，200个朋友，每个朋友有100个地址，这是一个不常见的用例，但也是可能的，我曾经在一个项目中遇到过这么大的对象。</p><p id="f81b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于这种极端情况，最糟糕的是JSON格式，FlatBuffer现在甚至比上次的Proto Buffer还要快，关于大小的趋势与其他测试一致。</p><h2 id="a874" class="kp kq hi bd lk mg mh mi lo mj mk ml ls jx mm mn lu kb mo mp lw kf mq mr ly ms bi translated">1级解组统计</h2><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="ba08" class="kp kq hi kl b fi kr ks l kt ku">JSON    134371     10778 ns/op  1000 B/op  26 allocs/op<br/>Proto   728599     1592 ns/op   733 B/op   13 allocs/op<br/>FBS     510885903  2.365 ns/op  0 B/op     0 allocs/op</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/ea79ee462ae6c073f2706d2973bb77b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9eF10ePwHyVKuylbz1sArA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">解组级别1</figcaption></figure><p id="b9a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">是的，图片是正确的，FlatBuffer没有尝试将二进制数据解析到对象中的分配，时间几乎为0 (2 ns)，在协议缓冲区的情况下，它需要0.7 KB和JSON 1 KB的内存分配，关于协议缓冲区花费的时间大约为0.001 ms和JSON 0.01 ms，让我们看看接下来会发生什么。</p><h2 id="f093" class="kp kq hi bd lk mg mh mi lo mj mk ml ls jx mm mn lu kb mo mp lw kf mq mr ly ms bi translated">第2级解组统计</h2><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="c0bb" class="kp kq hi kl b fi kr ks l kt ku">JSON     2886       353497 ns/op  32025 B/op  1000 allocs/op<br/>Proto    13471      91999 ns/op   31446 B/op  705 allocs/op<br/>FBS      444298354  2.490 ns/op   0 B/op      0 allocs/op</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mx"><img src="../Images/67dc502a2fc27d6992d702112b8cb489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E56w8xHF5vEfTpZGXXDlFw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">解组级别2</figcaption></figure><p id="ab23" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">FlatBuffer不受对象大小和复杂性的影响，并保持以前的度量，另一方面，协议Buffer和JSON在内存分配方面彼此接近，协议Buffer为31 KB，JSON为32 KB，但是，在花费的时间方面，协议Buffer为0.09 ms，而JSON为0.3 ms</p><h2 id="6ffe" class="kp kq hi bd lk mg mh mi lo mj mk ml ls jx mm mn lu kb mo mp lw kf mq mr ly ms bi translated">第3级解组统计</h2><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="9851" class="kp kq hi kl b fi kr ks l kt ku">JSON    22         50498996 ns/op   5849893 B/op  148547 allocs/op<br/>Proto   78         14708673 ns/op   4989886 B/op  105029 allocs/op<br/>FBS     527564692  2.248 ns/op      0 B/op        0 allocs/op</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es my"><img src="../Images/0138f1f882f53a0c5dc26c950585f900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tSF-mCs-p3xNA_XdWpwolQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">解组级别3</figcaption></figure><p id="f33e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">FlatBuffer再次保持了速度，协议缓冲区占用了大约4.9 MB的内存分配，而JSON占用了5.8 MB的内存分配(每次操作)，就花费的时间而言，协议缓冲区花费了14 ms，而JSON花费了50 ms解析对象，这是一个非常重要的区别。</p><p id="9bcd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是为什么Flatbuffer在解组对象时性能如此之好呢？公平地说，您需要知道，Flat Buffer甚至不会解组字节，它在封送处理过程中所做的是通过偏移量和vtables来容纳字节，以便能够在以后访问数据，因此，它不是重新构建整个对象，而是准备字节数组，并根据需要根据数据类型和/或长度来查找字段(示例<a class="ae jn" href="https://github.com/cperez08/xbuffer-bench/blob/main/allocation/fbs.go#L45" rel="noopener ugc nofollow" target="_blank">此处为</a>)。</p><p id="1818" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你对上面显示的平坦缓冲区结果非常满意，请等一下，首先你需要知道使用它的缺点是什么，这些是我遇到的一些缺点:</p><ul class=""><li id="974a" class="kv kw hi jq b jr js ju jv jx kx kb ky kf kz kj la lb lc ld bi translated">调试二进制消息是非常困难的，你不能只记录有效载荷或使用中间体(防火墙、代理、发布/订阅等)来分析有效载荷并基于此做出决定，这也适用于协议缓冲区。</li><li id="6e3a" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated">实现是乏味的，正如你在这里看到的<a class="ae jn" href="https://github.com/cperez08/xbuffer-bench/blob/main/allocation/fbs.go#L63" rel="noopener ugc nofollow" target="_blank"/>，构建FlatBuffer对象比协议缓冲和JSON需要更多的小心和步骤。</li><li id="6c2f" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated">一些语言中缺少一些功能，例如，二分搜索法(地图)还不能用于Golang或Rust。</li></ul><p id="769e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">在结束之前，让我分享一些最后的想法:</strong></p><ul class=""><li id="5282" class="kv kw hi jq b jr js ju jv jx kx kb ky kf kz kj la lb lc ld bi translated">关注内存分配之所以重要，是因为内存管理。在Golang中，负责这项工作的是垃圾收集器(GC ),它负责释放我们的程序不再使用的内存，简而言之，当堆内存超过4MB或在过去2分钟内没有启动时，就会触发GC(默认),因此，如果您的GC需要一直努力清理内存，这将消耗您运行程序所需的CPU。</li><li id="fda9" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated">如果读完这篇文章后，你认为使用JSON是一个坏主意，让我告诉你相反的情况，对于常规场景，这是我的第一选择，它被广泛支持，易于调试，正如你所看到的，在正常情况下这种差异并不过分。</li><li id="f403" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated">根据之前的回答，您可能想知道什么时候是使用X-Buffers的好机会，我个人会使用X-Buffers进行服务对服务的通信、缓存存储，当业务需要非常低的延迟时，如在游戏中，或者当您在非常有限的环境(网络、磁盘、内存)下工作时，如物联网。</li></ul><p id="6c53" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">奖励:</strong></p><ol class=""><li id="8215" class="kv kw hi jq b jr js ju jv jx kx kb ky kf kz kj mz lb lc ld bi translated">Golang proto buf项目的一个分支叫做GoGo proto buf，它承诺减少分配的字节数，让我们使用gogofaster方法来看看一些统计数据:</li></ol><p id="dc05" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">马萨林</strong></p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="34b0" class="kp kq hi kl b fi kr ks l kt ku">GogoProto<strong class="kl hj">L1</strong>  1244660   944.4 ns/op     627 B/op      9 allocs/op<br/>GogoProto<strong class="kl hj">L2</strong>  17931     67348 ns/op     31112 B/op    433 allocs/op<br/>GogoProto<strong class="kl hj">L3</strong>  104       11383685 ns/op  4968503 B/op  62899 allocs/op</span></pre><p id="6d02" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与标准协议缓冲区实现相比，GoGo Protobuf的实现确实有所改进:</p><ul class=""><li id="cc51" class="kv kw hi jq b jr js ju jv jx kx kb ky kf kz kj la lb lc ld bi translated">级别1:字节分配减少44%，速度提高56%</li><li id="e022" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated">级别2:字节分配减少27%，速度提高47%</li><li id="267b" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated">级别3:字节分配减少22%，速度提高47%</li><li id="30ff" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated">在所有情况下，大小都完全相同</li><li id="0ddb" class="kv kw hi jq b jr le ju lf jx lg kb lh kf li kj la lb lc ld bi translated">Gogo Protobuf的统计是包括FlatBuffer和JSON在内的所有场景中最好的。</li></ul><p id="af1d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">解组</strong></p><pre class="iy iz ja jb fd kk kl km kn aw ko bi"><span id="b1f6" class="kp kq hi kl b fi kr ks l kt ku">GogoProto<strong class="kl hj">L1</strong>   1863813  628.5 ns/op     528 B/op      11 allocs/op<br/>GogoProto<strong class="kl hj">L2</strong>   34784    34081 ns/op     22206 B/op    465 allocs/op<br/>GogoProto<strong class="kl hj">L3</strong>   193      5784670 ns/op   3625775 B/op  64031 allocs/op</span></pre><p id="793c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">级别1:字节分配减少31%，速度提高40%</p><p id="8bb2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">级别2:字节分配减少29%，速度提高66%</p><p id="1e4a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">级别3:字节分配减少25%,速度提高59%</p><p id="1bd2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 2。</strong>您还可以将平面缓冲区与gRPC结合使用，并利用HTTP2获得更好的性能，<a class="ae jn" href="https://grpc.io/blog/grpc-flatbuffers/" rel="noopener ugc nofollow" target="_blank">查看此处</a>了解更多信息，<a class="ae jn" href="https://github.com/google/flatbuffers/blob/master/grpc/tests/go_test.go" rel="noopener ugc nofollow" target="_blank">查看此处</a>查看示例</p></div></div>    
</body>
</html>