<html>
<head>
<title>Make your Flutter Apps pixel-perfect right away</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">立即让您的Flutter应用程序达到像素级完美</h1>
<blockquote>原文：<a href="https://medium.com/codex/flutter-pixel-perfect-9660c4b2f129?source=collection_archive---------3-----------------------#2021-08-02">https://medium.com/codex/flutter-pixel-perfect-9660c4b2f129?source=collection_archive---------3-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0967c14870152b82ab56044ed7ed8d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*USN9NATvpHcRmunmqokCLA.png"/></div></div></figure><p id="03b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Flutter中构建标准UI既简单又快速。使用来自Flutter团队和社区的许多小部件集合，您可以用用户友好和直观的语言在两个平台上构建一个简单的UI。</p><p id="cb82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Flutter中，您可以嵌套任意深度的小部件，而不用担心性能，并且在Flutter中推荐嵌套小部件。事实上，如果你有一个很大的部件，那么很有可能你可以或者需要把它分割成更小的部件。</p><p id="9290" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">构建一个好的应用程序是困难的，但是构建一个像素级完美的应用程序要困难100倍，尤其是如果你有一个没有适当代码约定的大团队。在某种程度上，您将拥有一个很大的小部件集合，其中包含许多默认值、可选值和配置。</p><p id="b137" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你有一个不担心所有UI细节的客户，你确实需要进一步阅读。如果你的客户或老板注重细节，你需要一些额外的时间来检查所有的UI细节。不言而喻，当你的客户说尺寸不对，但你真的无法分辨时，这是多么令人困惑。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/55d44e70b94cb823b77fa5c30914ffa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*pm09NWupJcLGgvlQoV4h-w.png"/></div></figure><p id="e13d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我给你展示一下通常会搞砸的事情的可能性，这导致了一个修复Flutter中1像素问题的任务。</p><p id="77fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最简单的例子是，假设您需要创建一张左右边距为12px的卡片，您最终编写了下面的代码。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/71b8dad889883736f77793486c64dca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r8yq8-eKwLBclP-6YRmLIg.png"/></div></div></figure><p id="53a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也许你会认为，因为容器有8px的边距，所以你只需要添加4px的填充，就可以使第57行的Card小部件有12px，但是在屏幕上，它不是12px，而是16px。卡片小部件中容器的默认边距有四个额外像素。</p><p id="7a36" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这只是你可以从Flutter中使用的大量小部件中的一个例子，以及你的团队创建的定制小部件。理想情况下，小部件不能有填充或空白。你创建的窗口小部件也不应该有任何大小，所有的大小都应该由父窗口小部件控制，但是错误或异常总是在项目中发生。因此，让我们来讨论如何让你的生活更轻松。</p><h1 id="616f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">下一步是什么</h1><p id="afec" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">为了确保你的UI逐像素显示，你可以使用这个棒极了的<a class="ae kx" href="https://pub.dev/packages/pixel_perfect" rel="noopener ugc nofollow" target="_blank">Flutter Pixel Perfect Package</a>在你的应用程序上放置叠加图片。类似于chrome中的<a class="ae kx" href="https://chrome.google.com/webstore/detail/perfectpixel-by-welldonec/dkaagdgjmgdmbnecmcefdhjekcoceebi?hl=en" rel="noopener ugc nofollow" target="_blank"> PerfectPixel </a>。</p><p id="4597" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">问题是每次你想在UI上检查像素是否完美时，把设计团队的每张图片都放在assets文件夹中很麻烦，所以最实用的检查尺寸的方法是用尺子。如果你是Mac用户，也许你知道<a class="ae kx" href="https://xscopeapp.com" rel="noopener ugc nofollow" target="_blank"> xScope </a>应用程序或<a class="ae kx" href="https://red-lines-tools.web.app" rel="noopener ugc nofollow" target="_blank"> Redline </a>工具，它们具有在整个屏幕上逐像素绘制覆盖网格的功能。</p><p id="02ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Flutter中，在现有应用的基础上绘制网格非常简单。如果你使用MaterialApp作为你的主要小部件，那么你只需要在builder函数中画出标尺。</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="d5eb" class="ld jv hi kz b fi le lf l lg lh"><strong class="kz hj">class</strong> <strong class="kz hj">MyApp</strong> <strong class="kz hj">extends</strong> <strong class="kz hj">StatelessWidget</strong> {<br/>  <strong class="kz hj">@override</strong><br/>  Widget build(BuildContext context) {<br/>    <strong class="kz hj">return</strong> MaterialApp(<br/>      builder: (context, widget) {<br/>        <strong class="kz hj">return</strong> Text('Im always here on top of all your screen');<br/>      },<br/>      home: MyHomePage(),<br/>    );<br/>  }<br/>}</span></pre><p id="5284" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一个问题是如何在你的应用程序上画一个8px的正方形来填满整个屏幕？</p><p id="b17c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简单的方法是使用SizedBox<strong class="is hj">T5(</strong>height:8，width: 8)，用SizedBo填充整个屏幕。然而，如果你这样做了，你也会在你的应用程序上绘制很多SizedBox部件。或者，您可以使用<a class="ae kx" href="https://api.flutter.dev/flutter/rendering/CustomPainter-class.html" rel="noopener ugc nofollow" target="_blank"> CustomPainter </a>手动绘制。你只需要知道设备的宽度和高度，然后用drawRect为整个屏幕画一个8px的正方形方框。</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="6377" class="ld jv hi kz b fi le lf l lg lh">class <strong class="kz hj">GridPainter </strong>extends <strong class="kz hj">CustomPainter </strong>{<br/>  <strong class="kz hj">double </strong>deviceWidth;<br/>  <strong class="kz hj">double </strong>deviceHeight;<br/><br/>  <strong class="kz hj">GridPainter<em class="li">(</em></strong>this.deviceWidth, this.deviceHeight<strong class="kz hj"><em class="li">)</em></strong>;<br/><br/>  @override<br/>  void paint<strong class="kz hj"><em class="li">(</em>Canvas </strong>canvas, <strong class="kz hj">Size </strong>size<strong class="kz hj"><em class="li">) {<br/>    </em></strong>var paint = Paint()<br/>      ..strokeWidth = 1<br/>      ..style = <strong class="kz hj">PaintingStyle</strong>.stroke<br/>      ..strokeCap = <strong class="kz hj">StrokeCap</strong>.round;<br/><br/>    for <strong class="kz hj"><em class="li">(</em></strong>var i = -<strong class="kz hj"><em class="li">(</em></strong>deviceHeight / 2<strong class="kz hj"><em class="li">)</em></strong>; i <strong class="kz hj"><em class="li">&lt; </em></strong>deviceHeight; i += 8<strong class="kz hj"><em class="li">) {<br/>      </em></strong>for <strong class="kz hj"><em class="li">(</em></strong>var j = -<strong class="kz hj"><em class="li">(</em></strong>deviceWidth / 2<strong class="kz hj"><em class="li">)</em></strong>; j <strong class="kz hj"><em class="li">&lt; </em></strong>deviceWidth; j += 8<strong class="kz hj"><em class="li">) {<br/>        </em></strong>canvas.drawRect<strong class="kz hj"><em class="li">(<br/>            </em></strong>Offset<strong class="kz hj"><em class="li">(</em></strong>j.toDouble(), i.toDouble()<strong class="kz hj"><em class="li">) </em></strong>&amp; Size<strong class="kz hj"><em class="li">(</em></strong>8, 8<strong class="kz hj"><em class="li">)</em></strong>,<br/>            paint<strong class="kz hj"><em class="li">)</em></strong>;<br/>      <strong class="kz hj"><em class="li">}<br/>    }<br/>  }<br/><br/>  </em></strong>@override<br/>  <strong class="kz hj">bool </strong>shouldRepaint<strong class="kz hj"><em class="li">(</em>CustomPainter </strong>oldDelegate<strong class="kz hj"><em class="li">) {<br/>    </em></strong>return false;<br/>  <strong class="kz hj"><em class="li">}<br/></em></strong>}</span></pre><p id="586e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，在您需要在MaterialApp小部件上的builder函数中返回的小部件中使用GridPainter。</p><pre class="jp jq jr js fd ky kz la lb aw lc bi"><span id="b9e3" class="ld jv hi kz b fi le lf l lg lh">@override<br/><strong class="kz hj">Widget </strong>build<strong class="kz hj"><em class="li">(</em>BuildContext </strong>context<strong class="kz hj"><em class="li">) {<br/>  </em></strong>var width = <strong class="kz hj">MediaQuery</strong>.<em class="li">of</em><strong class="kz hj"><em class="li">(</em></strong>context<strong class="kz hj"><em class="li">)</em></strong>.size.width;<br/>  var height = <strong class="kz hj">MediaQuery</strong>.<em class="li">of</em><strong class="kz hj"><em class="li">(</em></strong>context<strong class="kz hj"><em class="li">)</em></strong>.size.height;<br/>  return Stack<strong class="kz hj"><em class="li">(<br/>    </em></strong>children: <strong class="kz hj"><em class="li">[<br/>      </em></strong>widget.child,<br/>        Center<strong class="kz hj"><em class="li">(<br/>          </em></strong>child: IgnorePointer<strong class="kz hj"><em class="li">(<br/>            </em></strong>child: CustomPaint<strong class="kz hj"><em class="li">(<br/>              </em></strong>painter: GridPainter<strong class="kz hj"><em class="li">(</em></strong>width, height<strong class="kz hj"><em class="li">)</em></strong>,<br/>            <strong class="kz hj"><em class="li">)</em></strong>,<br/>          <strong class="kz hj"><em class="li">)</em></strong>,<br/>        <strong class="kz hj"><em class="li">)</em></strong>,<br/>    <strong class="kz hj"><em class="li">]</em></strong>,<br/>  <strong class="kz hj"><em class="li">)</em></strong>;<br/><strong class="kz hj"><em class="li">}</em></strong></span></pre><p id="c508" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，你只需要考虑如何隐藏或显示网格的自己的实现，你可以对代码进行注释，并在需要显示标尺时启用它。现在，您可以在应用程序中快速验证微件的大小。</p><p id="87f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">双击演示页面标题上方的黑色<strong class="is hj">“</strong>图标，亲自尝试一下。</p><figure class="jp jq jr js fd ij"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="6bc3" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">现在怎么办？</h1><p id="4626" class="pw-post-body-paragraph iq ir hi is b it ks iv iw ix kt iz ja jb ku jd je jf kv jh ji jj kw jl jm jn hb bi translated">如果需要快捷方式，可以查看这个包。</p><div class="ll lm ez fb ln lo"><a href="https://pub.dev/packages/on_screen_ruler" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hj fi z dy lt ea eb lu ed ef hh bi translated">on_screen_ruler |颤振包</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">在你的应用程序上画一个8px的正方形，如果你的客户有鹰眼，你会需要这个。1.去拿…</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">公共开发</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc io lo"/></div></div></a></div><p id="b6b3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果您的老板或客户抱怨并告诉您有一个像素没有对齐，您可以展示标尺并讨论比一个像素没有对齐更重要的问题，但不要忘记如果您的客户或您的测试人员知道这一点，他们也可以很容易地发现对齐错误。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/ead20d3aa93c331476428ad400d6fb87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PJj-3R8kBnpikNJi9j5nRw.png"/></div></div></figure></div></div>    
</body>
</html>