<html>
<head>
<title>What I was doing wrong — Spring autowiring and feature flagging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我做错了什么——Spring自动布线和特性标记</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-i-was-doing-wrong-spring-autowiring-and-feature-flagging-12bb979a08f6?source=collection_archive---------1-----------------------#2021-09-22">https://medium.com/codex/what-i-was-doing-wrong-spring-autowiring-and-feature-flagging-12bb979a08f6?source=collection_archive---------1-----------------------#2021-09-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="f607" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">我个人的一系列发现，设计问题，浪费时间的活动，不适用的模式，以及我在团队定期回顾中分享的其他问题。</p></blockquote><p id="6be4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">Spring framework允许快速启动工作应用程序，以至于任何对其特性的误用或过度使用都被速度的好处所抵消。使用Spring创建一个基本的“用户CRUD REST API服务”有多快？春季工作坊系列之一的<a class="ae jk" href="https://twitter.com/jekaborisov" rel="noopener ugc nofollow" target="_blank"> @jekaborisov </a>证明大约2 <strong class="il hj">分钟</strong>就够了。难以置信的快。我们可以想象PoC的设计速度有多快。企业听到这个时机是多么兴奋。</p><p id="cb7f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">使用PoC作为长期解决方案的核心时开始出现的问题。在支持和发展阶段，这里出现了另一种情绪—业务部门非常困惑，为什么支持现有应用程序可能需要比初始PoC更多的时间。</p><h1 id="04aa" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">自动布线</strong></h1><p id="18f0" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it jh kl iw ix ji km ja jb jj kn je jf jg hb bi translated">Spring提供了一个优秀的DI框架。组件(或者任何其他原型)注释足以标记一个特定的类来自动注入。您只需要将它自动连接到应用程序任何模块的任何组件中。后面所有的魔术都是免费的。</p><p id="6eae" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">Spring支持3种类型的自动布线:</p><ul class=""><li id="d0e4" class="ko kp hi il b im in iq ir jh kq ji kr jj ks jg kt ku kv kw bi translated">按字段</li><li id="6e8b" class="ko kp hi il b im kx iq ky jh kz ji la jj lb jg kt ku kv kw bi translated">按设定者</li><li id="f578" class="ko kp hi il b im kx iq ky jh kz ji la jj lb jg kt ku kv kw bi translated">由构造者</li></ul><p id="8ffd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如果没有严格的理由使用前两种类型，就不要使用。让它成为一个定期的代码检查练习来发现和修复。你的TDD实践会感谢你选择了“构造器注入”。此外，龙目岛还会和你握手。为什么？</p><p id="f0a1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">第一个原因:</strong>您可以使用原始的junit-mockito测试类型来测试您的特性，而根本不需要Sring注入。使用Mockito " <em class="ik"> @InjectMocks </em>"注释可以很容易地复制构造函数注入，因此您的测试启动时间将不包括Spring初始化开销。这比依赖弹簧的测试快一百倍。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="a4d4" class="ll jm hi lh b fi lm ln l lo lp">@RunWith(MockitoJUnitRunner.class)<br/>public class SomeProviderTest {<br/><br/>    @InjectMocks<br/>    private SomeProvider provider;<br/><br/>    @Spy<br/>    private SomeService service;<br/><br/><br/>    @Test<br/>    public void testSomeMethod() {<br/>       ...<br/>    }</span></pre><p id="7329" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">只需将这个测试类示例与一些常见的Spring测试类进行比较。</p><p id="6ce0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">第二个原因:</strong> Lombok和"<em class="ik">@ RequiredArgsConstructor</em>"注释允许你声明真正优雅简单的类，例如</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="81e5" class="ll jm hi lh b fi lm ln l lo lp">@Component<br/>@RequiredArgsConstructor<br/>public class SomeProvider {<br/>    private final SomeService someService;<br/>    private final AnotherService anotherService;<br/>}</span></pre><p id="b751" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">Lombok将为final字段生成一个构造函数，Spring尊重构造函数注入，因为整个类被标记为Component。简单就是力量。</p><h1 id="c518" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">特征标记</strong></h1><p id="2ea0" class="pw-post-body-paragraph ii ij hi il b im kj io ip iq kk is it jh kl iw ix ji km ja jb jj kn je jf jg hb bi translated">敏感话题。有争议的话题。许多明智的人认为，将特性标志作为打开/关闭特定特性的永久选项是一种反模式。Allen Holub和Martin Fowler坚持只有当特性处于开发或采用状态时才临时使用特性标志。</p><figure class="lc ld le lf fd lr er es paragraph-image"><div class="er es lq"><img src="../Images/badd32c214b65a04d9325579ae46a5dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*TEh4pl--1afyYe00F_nnTg.png"/></div></figure><p id="f1c4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">完全同意标志的交集增加了支持所有组合的复杂性。</p><p id="1e23" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">但是，在一些商业案例中，功能标志的使用因其优势而变得合理:</p><ul class=""><li id="8dd3" class="ko kp hi il b im in iq ir jh kq ji kr jj ks jg kt ku kv kw bi translated"><em class="ik">管理独立的子系统</em> —例如，由于检测到性能下降，禁用某些特定资源的修改API</li><li id="61cb" class="ko kp hi il b im kx iq ky jh kz ji la jj lb jg kt ku kv kw bi translated"><em class="ik">扩展安全管理</em> —例如在维护期间或发现安全漏洞时禁用用户注册模块</li><li id="8b1c" class="ko kp hi il b im kx iq ky jh kz ji la jj lb jg kt ku kv kw bi translated"><em class="ik">多租户配置</em> —仅针对特定客户开启/关闭特定功能，允许其他客户使用</li><li id="3b1d" class="ko kp hi il b im kx iq ky jh kz ji la jj lb jg kt ku kv kw bi translated"><em class="ik">模块化架构</em> —构建和部署特定的架构单元，作为核心应用模块的子集</li></ul><p id="b07a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如果您需要构建您的应用程序来支持其中的一些业务标准，那么最好选择模块化架构，每个模块都有单独的配置(这使您能够灵活地单独管理每个模块，甚至在运行时使用特定的管理工具，如<a class="ae jk" href="https://launchdarkly.com/" rel="noopener ugc nofollow" target="_blank">launch darky</a>)。</p><p id="fdd8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">因此，我建议在这个架构中完全避免使用Spring“组件”(和其他原型)注释。为什么？因为使用模块化体系结构在全局范围内注册beans不是好的做法。通过使用“组件”注释，您的应用程序变得更加整体化，这里的特性标志只对打开/关闭行为有很小的意义，但对管理服务没有意义。</p><figure class="lc ld le lf fd lr er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lu"><img src="../Images/25288c1f927d8362c3b4e62a1212c437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SWzNc2s0WDLEqHSgPvZPcg.png"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx translated">模块化与整体式架构</figcaption></figure><p id="1360" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">每个特性的"<em class="ik"> @Configuration </em>"类允许为特定行为创建所需工作人员的单独上下文。因此，切换配置类是打开/关闭与此功能相关的一切的一个示例。因此，应用程序变得更加模块化和易于配置。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="c669" class="ll jm hi lh b fi lm ln l lo lp">@Configuration<br/>@ConditionalOnProperty(value = "feature.enabled")<br/>@EnableConfigurationProperties(FeatureConfig.class)<br/>public class FeatureConfiguration {<br/><em class="ik"><br/>    </em>@Value("${feature.info}")<br/>    private String info;<br/><br/>    @Bean<br/>    public FeatureService featureService(RequiredDependency dep) {<br/>        return new FeatureService(dep);<br/>    }<br/><br/>    @Bean<br/>    public FeatureProvider featureProvider(FeatureService service) {<br/>        return new FeatureProvider(service);<br/>    }<br/>}</span></pre><p id="4c43" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">一旦激活此功能，将创建所有必需的bean，否则应用程序全局上下文将不会被独立的未使用的bean污染。</p><h1 id="d762" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">结论</h1><ul class=""><li id="7aaf" class="ko kp hi il b im kj iq kk jh md ji me jj mf jg kt ku kv kw bi translated">为了尊重TDD的全部功能——在Spring中只使用构造函数注入，这允许保持测试类简单并且独立于Spring上下文</li><li id="9a03" class="ko kp hi il b im kx iq ky jh kz ji la jj lb jg kt ku kv kw bi translated">使用“配置”作为bean初始化的来源——这使得应用程序更加模块化，并允许保留一个位置来配置(激活/停用)特定模块，而不是将服务分布在整个应用程序中并单独管理它们。</li></ul></div></div>    
</body>
</html>