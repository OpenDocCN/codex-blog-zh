<html>
<head>
<title>Streaming with JPAstreamer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JPAstreamer进行流式处理</h1>
<blockquote>原文：<a href="https://medium.com/codex/streaming-with-jpastreamer-b7116609138?source=collection_archive---------3-----------------------#2021-07-25">https://medium.com/codex/streaming-with-jpastreamer-b7116609138?source=collection_archive---------3-----------------------#2021-07-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="462c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><em class="ix">一个开源的轻量级库，以Java流的形式即时处理数据</em></h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/44b72fe25b704aa26ce748f66e4ee427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lr73diuPiymZ_9wVcw6UAQ.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">JPA流光</figcaption></figure><h2 id="db6b" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">概观</h2><p id="84d6" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated"><a class="ae lf" href="https://en.wikibooks.org/wiki/Java_Persistence/What_is_JPA%3F" rel="noopener ugc nofollow" target="_blank"><strong class="ko hj">JPA</strong></a>(Java Persistence API)规范让您定义哪些对象应该被持久化，以及这些对象应该如何在您的Java应用程序中持久化。JPA被认为是Java行业中对象到关系映射(ORM)的标准行业方法。</p><p id="505b" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">我们经常会遇到这样的情况，我们确实喜欢坚持使用一种语言。需要从Java转换到Hibernate查询语言(HQL)或Java持久性查询语言(JPQL)，这是一个繁琐的过程，因为每种语言的语法都不同，而且有些不直观。在这种情况下，我更喜欢Hibernate Java Persistence API(JPA ),它为我消除了其他不便。</p><p id="83c7" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated"><em class="ll">如果你想了解Java流，你可以访问我以前的博客</em> <a class="ae lf" href="https://praveeng-nair.medium.com/java-with-streams-c58994a400e4" rel="noopener"> <strong class="ko hj"> <em class="ll">这里</em> </strong> </a> <em class="ll">。</em> <br/>现在已经可以在JPA的更高版本中获得流，我们可以在其上进行聚合操作，这是完全正确的，但是这些流不能使用流来表达实际的数据库查询，并且性能可能很差。</p><p id="db9e" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">JPAstreamer  库提供了另一个开源解决方案，它是一个轻量级的库，可以用Java流表达JPA查询。在这篇博客中，我们将介绍如何将这个库与<strong class="ko hj"> Spring Boot </strong>和<strong class="ko hj"> Spring Data JPA </strong>集成在一起。这个想法听起来很棒，同时也让我很兴奋，因为library会基于您的Java流创建一个SQL查询。</p><p id="7835" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">下图显示了Java流的SQL等价运算符，它以非常简单的方式解释了这个概念。你可以在这里阅读更多操作符<a class="ae lf" href="https://speedment.github.io/jpa-streamer/jpa-streamer/1.0.1/fetching-data/sql-equivalents.html" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lm"><img src="../Images/d6754cd50194372aeb44e194ec8d18e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bTern9nt46xTS7z3FIgsFQ.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">Java流的SQL等价物</figcaption></figure><h2 id="3487" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">创建Spring Boot应用程序</h2><p id="1199" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">我创建了一个简单的Spring Boot应用程序，它运行嵌入式H2数据库，并通过REST API公开端点。它还使用Spring Data JPA与数据库进行交互。因此，一旦应用程序从<a class="ae lf" href="https://start.sping.io" rel="noopener ugc nofollow" target="_blank">https://start . spring . io</a>引导，我们需要在pom文件中包含以下两个依赖项。第一个添加了<code class="du ln lo lp lq b">JPAstreamer</code>，而第二个将它与Spring Boot整合。</p><pre class="iz ja jb jc fd lr lq ls lt aw lu bi"><span id="3939" class="jo jp hi lq b fi lv lw l lx ly">&lt;dependency&gt;   <br/>&lt;groupId&gt;com.speedment.jpastreamer&lt;/groupId&gt;   &lt;artifactId&gt;jpastreamer-core&lt;/artifactId&gt;   <br/>&lt;version&gt;1.0.2&lt;/version&gt; <br/>&lt;/dependency&gt; </span><span id="43ce" class="jo jp hi lq b fi lz lw l lx ly">&lt;dependency&gt;   &lt;groupId&gt;com.speedment.jpastreamer.integration.spring&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-jpastreamer-autoconfigure&lt;/artifactId&gt;   &lt;version&gt;1.0.2&lt;/version&gt; <br/>&lt;/dependency&gt;</span></pre><h2 id="9e24" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">JPA的实体模型</h2><p id="d6a1" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">让我们看一下我们的示例实体。下面是<code class="du ln lo lp lq b">Author</code>类。每个作者可以有一本或多本相关的书。</p><pre class="iz ja jb jc fd lr lq ls lt aw lu bi"><span id="08f1" class="jo jp hi lq b fi lv lw l lx ly">@Data<br/>@Entity(name = "author")<br/>@JsonInclude(JsonInclude.Include.<em class="ll">NON_NULL</em>)<br/>public class Author {<br/><br/>    @Id<br/>    @GeneratedValue<br/>    private Long id;<br/><br/>    private String firstName;<br/><br/>    @Column(unique = true)<br/>    private String lastName;<br/><br/>    @OneToMany<br/>    private List&lt;Book&gt; books;<br/><br/>}</span></pre><p id="380a" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">下面是<code class="du ln lo lp lq b">Book</code>实体。</p><pre class="iz ja jb jc fd lr lq ls lt aw lu bi"><span id="7c6d" class="jo jp hi lq b fi lv lw l lx ly">@Data<br/>@NoArgsConstructor<br/>@Entity(name = "book")<br/>@JsonInclude(JsonInclude.Include.<em class="ll">NON_NULL</em>)<br/>public class Book {<br/>    @Id<br/>    @GeneratedValue<br/>    private Long id;<br/><br/>    @Column(unique = true)<br/>    private String title;<br/><br/>    @ManyToOne(fetch = FetchType.<em class="ll">EAGER</em>)<br/>    @JoinColumn(name = "author_id")<br/>    private Author author;<br/><br/>    public Book(Long id, String title) {<br/>        this.id = id;<br/>        this.title = title;<br/>    }<br/>}</span></pre><h2 id="f6f4" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">JPAstreamer依赖注入</h2><p id="eb95" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">现在我们可以将JPAstreamer注入到我们的控制器中，并做一个简单的操作。</p><pre class="iz ja jb jc fd lr lq ls lt aw lu bi"><span id="afe1" class="jo jp hi lq b fi lv lw l lx ly">private final JPAStreamer jpaStreamer;<br/><br/>public BookController(JPAStreamer jpaStreamer) {<br/>    this.jpaStreamer = jpaStreamer;<br/>}</span></pre><p id="32f8" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">让我们对<code class="du ln lo lp lq b">Book</code>实体执行一个<em class="ll"> findAll </em>操作，根据<code class="du ln lo lp lq b">id</code>字段对其进行降序排序，然后将所有流收集到列表中。简而言之，看起来几乎与标准Java流相似，不是吗？</p><pre class="iz ja jb jc fd lr lq ls lt aw lu bi"><span id="5078" class="jo jp hi lq b fi lv lw l lx ly">@GetMapping("/books")<br/>public ResponseEntity&lt;?&gt; findAllBooks() {<br/>    return ResponseEntity.<em class="ll">ok</em>(<br/>            jpaStreamer.stream(Book.class)<br/>            .sorted(Book$.<em class="ll">id</em>.reversed())<br/>            .collect(Collectors.<em class="ll">toList</em>()));<br/>}</span></pre><p id="fb75" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">现在，我们可以在启动应用程序后调用端点。</p><pre class="iz ja jb jc fd lr lq ls lt aw lu bi"><span id="aba5" class="jo jp hi lq b fi lv lw l lx ly">$ curl <a class="ae lf" href="http://localhost:8080/api/books" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/books</a></span><span id="2af1" class="jo jp hi lq b fi lz lw l lx ly">[{"id":<strong class="lq hj">5</strong>,"title":"Harry Potter and the half blood Prince","author":{"id":1,"firstName":"Joanne","lastName":"Rowling","books":[]}},{"id":<strong class="lq hj">4</strong>,"title":"Harry Potter and Sorcerers stone","author":{"id":1,"firstName":"Joanne","lastName":"Rowling","books":[]}},{"id":<strong class="lq hj">3</strong>,"title":"Harry Potter and Chamber of Secrets","author":{"id":1,"firstName":"Joanne","lastName":"Rowling","books":[]}},{"id":<strong class="lq hj">2</strong>,"title":"The Cuckcoos Calling","author":{"id":1,"firstName":"Joanne","lastName":"Rowling","books":[]}},{"id":<strong class="lq hj">1</strong>,"title":"The Casual Vacancy","author":{"id":1,"firstName":"Joanne","lastName":"Rowling","books":[]}}]</span></pre><p id="a2e8" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">如果您看到应用程序日志，这些API操作会执行SQL查询。</p><pre class="iz ja jb jc fd lr lq ls lt aw lu bi"><span id="6ef7" class="jo jp hi lq b fi lv lw l lx ly">Hibernate: <br/>    select<br/>        book0_.id as id1_2_,<br/>        book0_.author_id as author_i3_2_,<br/>        book0_.title as title2_2_ <br/>    from<br/>        book book0_ <br/>    order by<br/>        book0_.id desc<br/>Hibernate: <br/>    select<br/>        author0_.id as id1_0_0_,<br/>        author0_.first_name as first_na2_0_0_,<br/>        author0_.last_name as last_nam3_0_0_ <br/>    from<br/>        author author0_ <br/>    where<br/>        author0_.id=?<br/>Hibernate: <br/>    select<br/>        books0_.author_id as author_i1_1_0_,<br/>        books0_.books_id as books_id2_1_0_,<br/>        book1_.id as id1_2_1_,<br/>        book1_.author_id as author_i3_2_1_,<br/>        book1_.title as title2_2_1_,<br/>        author2_.id as id1_0_2_,<br/>        author2_.first_name as first_na2_0_2_,<br/>        author2_.last_name as last_nam3_0_2_ <br/>    from<br/>        author_books books0_ <br/>    inner join<br/>        book book1_ <br/>            on books0_.books_id=book1_.id <br/>    left outer join<br/>        author author2_ <br/>            on book1_.author_id=author2_.id <br/>    where<br/>        books0_.author_id=?</span></pre><h2 id="4cd4" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">流配置</h2><p id="8463" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">大多数情况下，您只需要选定的字段，而不是全部，这也有助于提高查询的性能，因为我们只对某些字段感兴趣。我们可以通过在<code class="du ln lo lp lq b">JPAstreamer.</code> <br/>上使用<code class="du ln lo lp lq b">StreamConfiguration</code>来实现这一点。让我们借助另一个例子来看看这一点。</p><pre class="iz ja jb jc fd lr lq ls lt aw lu bi"><span id="63fe" class="jo jp hi lq b fi lv lw l lx ly">@GetMapping("/books/sc/{title}")<br/>public ResponseEntity&lt;?&gt; findBookByTitleUsingStreamConfig(@PathVariable String title) {</span><span id="59e1" class="jo jp hi lq b fi lz lw l lx ly">    StreamConfiguration&lt;Book&gt; sc = StreamConfiguration<br/>            .<em class="ll">of</em>(Book.class)<br/>            .selecting(Projection.<em class="ll">select</em>(Book$.<em class="ll">id</em>, Book$.<em class="ll">title</em>));<br/>    return ResponseEntity.<em class="ll">ok</em>(<br/>            jpaStreamer.stream(sc)<br/>            .filter(Book$.<em class="ll">title</em>.contains(title))<br/>            .collect(Collectors.<em class="ll">toList</em>()));<br/>}</span></pre><p id="7382" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">上面的投影只选择了id和title。如果我们到达API端点，我们只能看到响应中返回的特定字段。StreamConfiguration还有助于解决其他性能问题，如<a class="ae lf" href="https://vladmihalcea.com/n-plus-1-query-problem/" rel="noopener ugc nofollow" target="_blank"> N+1问题</a>。</p><pre class="iz ja jb jc fd lr lq ls lt aw lu bi"><span id="2344" class="jo jp hi lq b fi lv lw l lx ly">$ curl <a class="ae lf" href="http://localhost:8080/api/books/sc/Potter" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/books/sc/Potter</a><br/>[{"id":3,"title":"Harry Potter and Chamber of Secrets"},{"id":4,"title":"Harry Potter and Sorcerers stone"},{"id":5,"title":"Harry Potter and the half blood Prince"}]</span></pre><h2 id="93cf" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">摘要</h2><p id="d386" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated"><code class="du ln lo lp lq b">Stream</code>是一个接口，<code class="du ln lo lp lq b">JPAstreamer</code>可以根据所使用的管道和其他因素从<code class="du ln lo lp lq b">Stream</code>的各种不同实现中进行选择。上述流通过JPA呈现给数据库查询。</p><p id="e82d" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">因此，我们已经看到，使用开源库<code class="du ln lo lp lq b">JPAstreamer</code>和Hibernate(或任何JPA提供者)在JPA上进行流式处理，将类型安全的、有表现力的数据库查询组合成标准的Java流是多么容易和出色。这样做，您将能够继续使用JPA，同时保持代码库的整洁和可维护性。</p><p id="c4b2" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">我看到的唯一问题是，它会进行一些分析，并将某些数据发送回<a class="ae lf" href="https://speedment.com/" rel="noopener ugc nofollow" target="_blank"> Speedment的</a>服务器。如果您希望禁用此<a class="ae lf" href="https://github.com/speedment/jpa-streamer/blob/master/DISCLAIMER.md" rel="noopener ugc nofollow" target="_blank">功能</a>，您需要联系他们的团队。我对此有点担心，但话说回来，这个想法真的很好。</p><p id="c7db" class="pw-post-body-paragraph km kn hi ko b kp lg ij kr ks lh im ku jz li kw kx kd lj kz la kh lk lc ld le hb bi translated">你可以在这里找到源代码<a class="ae lf" href="https://github.com/PraveenGNair/spring-data-jpastreamer" rel="noopener ugc nofollow" target="_blank"><strong class="ko hj"/></a>。快乐学习！！</p><h2 id="e332" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">参考</h2><div class="ma mb ez fb mc md"><a href="https://github.com/speedment/jpa-streamer" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">GitHub-speedment/jpa-streamer:JPAstreamer是一个轻量级库，用于将JPA查询表示为…</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">选择film0_。film_id为film_id1_1_，film0_。描述如描述2 _ 1 _ film 0 _所述。languag11_1_…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">github.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr ji md"/></div></div></a></div><div class="ma mb ez fb mc md"><a href="https://blogs.oracle.com/javamagazine/jpastreamer-expressing-hibernatejpa-queries-with-java-streams" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">JPAstreamer:用Java流表达Hibernate/JPA查询</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">2021年1月29日下载这篇文章的PDF如果你能保持Hibernate/JPA，同时坚持使用Java会怎么样…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">blogs.oracle.com</p></div></div><div class="mm l"><div class="ms l mo mp mq mm mr ji md"/></div></div></a></div></div></div>    
</body>
</html>