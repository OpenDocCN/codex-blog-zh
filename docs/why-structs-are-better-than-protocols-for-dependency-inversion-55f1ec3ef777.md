# 为什么结构比协议更适合依赖倒置

> 原文：<https://medium.com/codex/why-structs-are-better-than-protocols-for-dependency-inversion-55f1ec3ef777?source=collection_archive---------0----------------------->

![](img/b1fb27cfa0397a044f87abacdb2b233e.png)

当我们想到 Swift 中的依赖性反转时，通常首先想到的是协议。众所周知的模式是创建一个协议来定义一些必需的行为，并创建一个具体的实现来执行该职责。

这在测试我们的代码时变得非常有价值，因为我们可以用依赖关系来代替模拟版本，这些版本可以用期望的响应来启动，并查询预期的结果。

虽然这种模式在大多数情况下已经足够了，但结构通常可以提供协议无法提供的优势。

# 协议失败的地方…

## **名称-间距**

协议的一个主要缺点是它们不能嵌套其他类型。想象以下片段:

如果我们试图为我们的`House`定义一个协议，我们也需要为`Inhabitant`定义一个协议，就像这样:

烦人的是，`Inhabiting`协议不能嵌套在`Housing`里面，所以污染了全局命名空间。随着时间的推移，这可能会导致冲突和兑现，尤其是在大型代码库中。

## **异质阵列**

假设我们的消费类型需要一系列的房子。通过下面的代码片段，我们遇到了臭名昭著的`Protocol ‘Housing’ can only be used as a generic constraint because it has Self or associated type requirements`错误。

这里我们有两个选择。第一个是使`Street`通用，就像这样:

然而，这里的问题是，现在我们被束缚在一种特定类型的住房上。在我们的街道上，我们可能有多种类型的房子，如平房和大厦，所以这可能不总是我们想要的。

另一个解决方案是以类似于`AnyHashable`或`AnyPublisher`的方式创建一个类型擦除包装器。这里我们可以创建删除类型的`AnyHousing`，就像这样:

但是哦不！在这里，我们可以看到，我们已经将自己与每栋房子的一种特定类型的居民联系起来了！为了完全实现类型擦除，我们还需要一个`AnyInhabiting`类型。最终结果如下:

这相当冗长，如果我们仔细观察，`AnyInhabiting`和`AnyHousing`的实现与我们开始时的`Inhabitant`和`House`非常相似！

# 使用结构的技巧…

我们如何使用结构来执行与协议相同的功能的答案是保持它们的简单性！我们可以以这样一种方式编写结构，它只保存消费类型所需的数据和功能。我们可以编写一个适配器来将任何对象映射到我们的结构，而不是遵循一个协议。

假设跟随`ViewModel`。它允许我们在初始化时定义文本和`buttonTapped`功能。

我们现在可以在一个扩展中添加一个便利的初始化器来映射我们需要调用的服务。

当测试我们的 UI 层时，不需要创建一个对象并遵循一个协议。我们可以简单地在初始化时提供测试功能和文本。

# 结论

我们现在已经看到了协议的替代方案，它执行相同的功能，保持相同级别的可测试性，并简化冗长的样板代码。似乎好得难以置信，对吗？

我看到的一个警告是，需要对初始结构应用一些规则，使其保持为纯数据对象(Kotlin 风格的数据类在这里是理想的)。

我发现在大多数情况下，与协议相比，这种模式更简洁，也不那么冗长，所以我在日常工作中继续使用它

为了完整起见，[这里有一个要点](https://gist.github.com/oconnelltoby/af160f5efe7b00c5d33887be280d2855)，它以同样的方式延续了众议院的例子！