<html>
<head>
<title>ASP.NET Core Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ASP.NET核心依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/codex/asp-net-core-dependency-injection-8c3feae161b9?source=collection_archive---------5-----------------------#2021-08-21">https://medium.com/codex/asp-net-core-dependency-injection-8c3feae161b9?source=collection_archive---------5-----------------------#2021-08-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="e57d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是依赖注入？</h1><p id="3eb5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">简而言之，依赖注入(DI)或控制反转(IoC)是一种软件架构设计模式，它有助于管理类型(类)定义之外的依赖关系。该类型不再创建或管理其依赖项，而只是声明并使用它来提供其预期的功能。依赖项的初始化由应用框架完成，并在运行时通过<em class="kb">构造函数注入</em>或<em class="kb">属性注入</em>或<em class="kb">方法注入</em>注入到类型中。</p><p id="1e6f" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">那么，什么是<em class="kb">依赖呢？</em>考虑下面的C#代码片段:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/1b4e7e0775c81ea6cee6ec7f38d38c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*2hMMiTmtpcOz1Y1CIn_E9g.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">EmailNotifier的紧密耦合</figcaption></figure><p id="ceca" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这里，类型<em class="kb"> EmailNotifier </em>对类型<em class="kb"> GmailClient </em>有明确的<em class="kb">依赖关系，因为<em class="kb"> GmailClient </em>的初始化与<em class="kb"> EmailNotifier </em>的初始化紧密耦合。明天，如果出于任何原因，决定放弃Gmail而使用Outlook，那么我们必须改变实施方案。除此之外，如果我们以后再次从Outlook转到Gmail，我们还必须手动修改代码。显然，这不是我们想要和需要的解决方案——依赖注入。</em></p><p id="2dd7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">依赖注入是一个非常强大的概念，它有助于创建具有清晰的<strong class="jf hj">关注分离</strong>、<strong class="jf hj">解耦</strong>、<strong class="jf hj">高维护性</strong>并且更容易<strong class="jf hj">模仿</strong>进行单元测试的软件系统。</p><p id="16ac" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在本文中，我们将从以下几个方面来探讨DI。净5(。NET Core 5)及其内置的DI系统，支持<em class="kb">构造器注入</em>技术<em class="kb">。</em></p><p id="b8af" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在继续深入之前，让我们按照哎呀的原则绕一小段路:</p><p id="8d68" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">如果一个类继承&amp;实现一个接口，那么该类的对象可以被一个与接口类型相同的变量引用。</em></p><p id="1777" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">以上陈述是控制功能的依赖注入/反转的核心。让我们看看这是什么意思。考虑一下，我们有一个定义为:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es kt"><img src="../Images/5dc59a5c1855da7c7692e0584d8b7191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DbXYS7d99XjI-h2CpbLvRA.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">IEmailClient接口定义</figcaption></figure><p id="2de6" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，让我们在<em class="kb"> GmailClient: </em>中继承并实现这个接口类型</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ky"><img src="../Images/3aa7a7128a475ec298746fe9e8181c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IIIpEBWbExI3hVO6nzp80w.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">用GmailClient类实现IEmailClient</figcaption></figure><p id="cecd" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这样，我们现在可以通过以下方式初始化一个<em class="kb"> GmailClient </em>:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kz"><img src="../Images/a51a17fb573ac5be8ca3ec35957d08c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*wfryEds0yVNaQTag3zRldg.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">通过接口类型变量引用GmailClient</figcaption></figure><p id="fe0a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">记住这个原则，我们现在将修改原来的<em class="kb"> EmailNotifier </em>类，以声明它对<em class="kb"> GmailClient </em>的依赖关系，作为<em class="kb"> </em> <strong class="jf hj"> <em class="kb">构造函数参数</em> </strong> <em class="kb"> : </em></p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es la"><img src="../Images/4ade6851382c2751db79bb98d1f66a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*2ya51mB0zK_-kyVNRfhU7Q.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">构造函数依赖注入</figcaption></figure><p id="57c7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb">随着这一变化，</em>类型<em class="kb"> EmailNotifier </em>不再负责其电子邮件客户端的初始化，这将由框架处理。我们现在来看看如何指导ASP.NET核心去做这件事。</p><p id="4741" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在ASP.NET核心中，所有依赖项都必须在<em class="kb"> StartUp </em>类的<em class="kb"> ConfigureServices </em>方法中注册。有三种方法可以在中注册依赖项。网络核心:</p><p id="3a38" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj"> <em class="kb"> Singleton </em> </strong>:通过这种类型的依赖关系注册，我们指示运行时使用另一个已定义类型的单个(且仅一次)已创建实例来服务特定类型的所有依赖关系解析请求。</p><p id="ee79" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj"> <em class="kb">瞬态</em> : </strong>通过这种类型的依赖关系注册，我们指示运行时使用新创建的另一个已定义类型的实例来服务特定类型的所有依赖关系解析请求。</p><p id="c419" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><strong class="jf hj"> <em class="kb">作用域</em> : </strong>通过这种类型的依赖关系注册，我们指示运行时为特定类型的所有依赖关系解析请求提供相同作用域内另一个已定义类型的新创建实例(相同的HTTP请求)。</p><p id="0bc9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">让我们通过一个项目来理解这些意味着什么。</p><p id="5db9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">以下是ASP.NET核心MVC项目结构:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lb"><img src="../Images/e3449994c4815f5b198c8107dfd5f24e.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*PCe-HqK_vdaF5lz9Nrg1VQ.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">MVC核心项目结构</figcaption></figure><p id="7056" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">这里，<em class="kb"> ITime.cs </em>是一种接口类型，定义为:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">ITime.cs接口定义</figcaption></figure><p id="a4b7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><em class="kb"> ITimeSingleton.cs </em>、<em class="kb"> ITimeTransient.cs </em>、<em class="kb"> ITimeScoped.cs </em>都是从接口<em class="kb"> ITime.cs </em>继承而来的接口类型。这里显示了<em class="kb"> ITimeSingleton </em>的定义，但是三个接口定义基本相同:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">ITimeSingleton.cs接口定义</figcaption></figure><p id="d011" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，我们有三个类，它们分别继承和实现这三个接口。这些类分别是<em class="kb">timesingletonservice . cs</em>、<em class="kb">timetransientservice . cs</em>、<em class="kb"> TimeScopedService.cs </em>。这里显示了<em class="kb">timesingletonservice . cs</em>的定义，但是三个类的定义基本相同:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">TimeSingleton.cs定义</figcaption></figure><p id="7f81" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">想法是记录这三个类被运行时调用的确切时刻，然后在调用方法<em class="kb"> GetTime </em>时返回日期时间值。</p><p id="6b64" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">现在，让我们注册三种类型的依赖项，看看效果。首先，在<em class="kb"> StartUp.cs </em>中，找到<em class="kb"> ConfigureServices </em>方法，并在里面添加以下几行代码:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">ASP。网络核心服务注册</figcaption></figure><p id="86c7" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在这里，我们指示ASP.NET核心:</p><ol class=""><li id="05ab" class="le lf hi jf b jg kc jk kd jo lg js lh jw li ka lj lk ll lm bi translated">每当类型为<em class="kb"> ITimeSingleton </em>的依赖关系解析请求被发送到DI系统/ IoC容器/运行时，第一次创建<em class="kb"> TimeSingletonService </em> <strong class="jf hj">的实例</strong>。对于下列依赖项解析请求，请使用同一个实例，不要创建新的实例。</li><li id="dd1c" class="le lf hi jf b jg ln jk lo jo lp js lq jw lr ka lj lk ll lm bi translated">每当类型为<em class="kb"> ITimeTransient </em>的依赖关系解析请求被发送到DI系统/ IoC容器/运行时时，创建一个<em class="kb"> TimeTransientService </em> <strong class="jf hj">的实例。</strong></li><li id="e72e" class="le lf hi jf b jg ln jk lo jo lp js lq jw lr ka lj lk ll lm bi translated">每当<strong class="jf hj"> </strong>类型ITimeScoped的依赖关系解析请求被发送到作用域 (HTTP请求)内的DI系统/ IoC容器/运行时<strong class="jf hj">时，第一次创建<em class="kb"> TimeScopedService </em> <strong class="jf hj">的实例，并为同一作用域内的所有后续请求共享相同的实例。对于新的作用域，创建另一个实例。</strong></strong></li></ol><p id="d81e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们现在将验证上述陈述。</p><p id="47c9" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">MVC应用程序有一个控制器<em class="kb"> (DemoController.cs) </em>，它在它的<em class="kb">参数化构造器</em>中声明了所有的<em class="kb">三个</em>接口类型依赖，并在索引动作中调用了如下的<em class="kb"> GetTime </em>方法:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">DemoController.cs定义</figcaption></figure><p id="1eda" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">按照MVC惯例，控制器调用名为<em class="kb"> Index.cshtml </em>的视图，该视图除了从控制器接收数据之外，还通过Razor的<em class="kb"> @inject </em>指令声明所有三种接口类型的依赖关系，并调用<em class="kb"> GetTime </em>方法，如下所示:</p><figure class="ki kj kk kl fd km"><div class="bz dy l di"><div class="lc ld l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">Index.cshtml视图</figcaption></figure><p id="7d2c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">当应用程序运行且首次达到演示控制器的索引动作时，输出为:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ls"><img src="../Images/93426a87470443e2b65183522a9ebdc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VBtH87qMzIm3-QJawm79iA.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">首次输出</figcaption></figure><p id="248d" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">刷新此页面时，输出为:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lt"><img src="../Images/e4b902940a02669edf2c8132d9869b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHVmSgPycHWaxEPcYoyurw.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">第二输出</figcaption></figure><h1 id="9950" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">说明</h1><p id="9af3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">由于<strong class="jf hj"> <em class="kb"> singleton </em> </strong>注册，类型<em class="kb">timesingletonservice . cs</em>只被初始化一次，因此它的<em class="kb"> GetTime </em>方法在应用程序的整个生命周期中只被调用一次。这个相同的实例在所有后续的依赖关系解析请求之间共享。因此，尽管多次刷新页面，但<em class="kb">单件服务初始化日期时间</em>列的时间戳从不改变。</p><p id="6e41" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">由于服务<em class="kb"> TimeTransientService.cs </em>被注册为<strong class="jf hj"> <em class="kb">瞬态</em> </strong>服务，每当页面被刷新时，路由系统就开始初始化DemoController，并且通过检查其声明的构造函数依赖性，每次都继续初始化<em class="kb"> TimeTransientService.cs </em>。除此之外，当控件到达视图时，由于视图的依赖性，相同的类被再次初始化。因此，我们看到<em class="kb">瞬态服务初始化日期时间</em>列的时间戳每次都在改变。</p><p id="af35" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">对于作为<strong class="jf hj"><em class="kb"/></strong>服务注册的timescopedservice . cs，每当页面被刷新时，路由系统就开始初始化DemoController，并通过检查其声明的构造函数依赖性，每次都继续初始化<em class="kb"> TimeScopedService.cs </em>。但是，当控件到达视图时，因为它在相同的HTTP范围内，所以相同的类不会再次初始化，时间戳值是共享的。因此，尽管我们看到时间戳值在每次页面刷新时都发生了变化，但是列<em class="kb">作用域服务初始化日期时间</em>的两行值是相同的。</p><p id="2f94" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi lu translated">这篇文章解释了依赖注入的概念，并介绍了在ASP.NET内核中注册依赖的三种方式。</p><h1 id="dc01" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考</h1><p id="03f5" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><em class="kb">源代码可在:</em>获得</p><p id="6e7a" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated"><a class="ae md" href="https://github.com/Shahnawaz-QI/aspdotnetcore-dependency-injection" rel="noopener ugc nofollow" target="_blank">Shahnawaz-QI/aspdotnetcore-Dependency-Injection:ASP.NET核心依赖注入演示(github.com)</a></p><p id="0c7c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">其他参考:</p><ol class=""><li id="642d" class="le lf hi jf b jg kc jk kd jo lg js lh jw li ka lj lk ll lm bi translated"><a class="ae md" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/?view=aspnetcore-5.0" rel="noopener ugc nofollow" target="_blank">ASP.NET核心的基本面</a></li><li id="d705" class="le lf hi jf b jg ln jk lo jo lp js lq jw lr ka lj lk ll lm bi translated"><em class="kb">Pro ASP.NET Core 3:使用MVC、Blazor和Razor Pages开发云就绪的Web应用</em></li><li id="fdb9" class="le lf hi jf b jg ln jk lo jo lp js lq jw lr ka lj lk ll lm bi translated"><a class="ae md" href="https://www.youtube.com/playlist?list=PL6n9fhu94yhVkdrusLaQsfERmL_Jh4XmU" rel="noopener ugc nofollow" target="_blank">ASP.NET初学者核心教程</a></li></ol></div></div>    
</body>
</html>