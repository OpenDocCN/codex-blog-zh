<html>
<head>
<title>State management in React upgraded: xstate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React升级后的状态管理:xstate</h1>
<blockquote>原文：<a href="https://medium.com/codex/state-management-in-react-upgraded-xstate-58840a8962d9?source=collection_archive---------10-----------------------#2021-08-28">https://medium.com/codex/state-management-in-react-upgraded-xstate-58840a8962d9?source=collection_archive---------10-----------------------#2021-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e64e4fbd70fd1525d6a24c4da5445c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mPDP3eVXF38AxNpn"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">卢卡·乔纳斯在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="0fbb" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">简介(React中的有限状态机概念)</h1><p id="2556" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi kr translated">inite状态机的概念已经存在了很长时间，与React没有什么特别的关系。我不会在维基百科上全部介绍你，但主要思想是，你有一个有限的状态集，你的应用程序可以在任何一个时间点处于一个状态，并且只能处于一个状态。提供了一定的输入，有限状态机转换到它的另一个状态。现在，这种经过提炼的计算机科学听起来很像国家管理，有一个不变的单一真理来源，你肯定听说过很多。</p><p id="6b53" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated"><code class="du lf lg lh li b"><a class="ae iu" href="https://github.com/statelyai/xstate" rel="noopener ugc nofollow" target="_blank">xstate</a></code>库所做的是，它为你提供了一套自己的工具来创建有限状态机(FSM)来管理你的javascript应用程序状态。就其本身而言，<code class="du lf lg lh li b">xstate</code>并不偏向于任何一个流行的库/框架——它只是一个概念的javascript实现，并且目前作为一个包提供给<a class="ae iu" href="https://github.com/statelyai/xstate/tree/main/packages/xstate-react" rel="noopener ugc nofollow" target="_blank"> React </a>、<a class="ae iu" href="https://github.com/statelyai/xstate/tree/main/packages/xstate-vue" rel="noopener ugc nofollow" target="_blank"> Vue </a>和<a class="ae iu" href="https://github.com/statelyai/xstate/tree/main/packages/xstate-svelte" rel="noopener ugc nofollow" target="_blank"> Svelte </a>。</p><p id="3913" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">我最关心的是在组件之间共享状态机。现在，在组件之间共享状态机的最好方法是使用React内置的<code class="du lf lg lh li b">useContext</code>钩子。</p><p id="4e61" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">如果你对<code class="du lf lg lh li b">xstate</code>有些熟悉，或者喜欢按自己的步调进行，请随意查看我曾经尝试过的<a class="ae iu" href="https://github.com/sinisa-nimcevic/basic-async-call-repository/tree/ARTICLE/first-xstate" rel="noopener ugc nofollow" target="_blank"> github库</a>。它对状态机和<code class="du lf lg lh li b">useContext</code>的实现进行了测试，这两者<strong class="jv hj">不</strong>包含在下面的内容中。</p><h1 id="3bf9" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">实施</h1><p id="7bec" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">我个人喜欢切换到FSM管理状态的原因是易于实现。附件A —这是您的状态机依赖关系的权重:</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/d0d2320292b5cf07ce42102ac7737156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*74wUY4OKRdGExx65Z5mrrw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">关键xstate导入的网络开销</figcaption></figure><p id="2f84" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">一旦你像一个真正的计算机科学家一样在一张纸上设计好了你的状态机，你就可以开始在<code class="du lf lg lh li b">xstate</code>中编写你的第一个有限状态机了。顺便说一下，要想知道如何在纸上画出状态机并给你的朋友留下深刻印象，看看<a class="ae iu" href="https://xstate.js.org/viz/" rel="noopener ugc nofollow" target="_blank">这个</a>方便的工具，你可以用它来分析你实现的状态机。但稍后会详细介绍。</p><p id="20c6" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">这是用<code class="du lf lg lh li b">xstate</code>写的FSM的基础。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/dd55d44956d4a0157054f1c05afffe3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*AcdVPsiT5CmcyaP68cUzqw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">用<code class="du lf lg lh li b">xstate</code>写的FSM的基础</figcaption></figure><p id="907a" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">这个特殊的FSM处理获取一组数据，你会看到它已经</p><ul class=""><li id="021e" class="lp lq hi jv b jw la ka lb ke lr ki ls km lt kq lu lv lw lx bi translated">一个人类可读的<code class="du lf lg lh li b">id</code>，</li><li id="a385" class="lp lq hi jv b jw ly ka lz ke ma ki mb km mc kq lu lv lw lx bi translated">我们马上设定<code class="du lf lg lh li b">initial</code>状态，</li><li id="01e4" class="lp lq hi jv b jw ly ka lz ke ma ki mb km mc kq lu lv lw lx bi translated">它有所谓的<code class="du lf lg lh li b">context</code>(这是你可以在<code class="du lf lg lh li b">states</code>部分操作的)，</li><li id="4f7e" class="lp lq hi jv b jw ly ka lz ke ma ki mb km mc kq lu lv lw lx bi translated">还有一部分详细描述了您的状态机的<code class="du lf lg lh li b">states</code>。</li></ul><p id="bd0c" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">这就是全部了。<code class="du lf lg lh li b">states</code>部分完全在您的控制之下——本例中提供的状态名称完全由您来命名——没有类似框架的约束。此外，在这些类型的状态管理API中没有如此常见的难看的switch case语句。一切都整齐地打包在一个配置对象中。</p><p id="900c" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">我们看到初始状态被设置为<code class="du lf lg lh li b">idle</code>。为了从一种状态转换到另一种状态，我们使用(是的，你已经猜到了)转换。这就是过渡的实现方式。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="f381" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated"><code class="du lf lg lh li b">FETCH</code>和<code class="du lf lg lh li b">loading</code>都是您之前选择的任意名称。多酷啊。因此，如果状态是<code class="du lf lg lh li b">idle</code>，如果机器接收到一个<code class="du lf lg lh li b">FETCH</code>命令，它将转换到称为<code class="du lf lg lh li b">loading</code>的状态。对于在您的<code class="du lf lg lh li b">states</code>中定义的每个状态，您可以有任意数量的<code class="du lf lg lh li b">on</code>对象，每个对象由您打算发送到您的FSM的命令命名，并且每个对象通向下一个预期状态。</p><p id="b60c" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">现在，当处理异步代码时，也就是我们例子中的<code class="du lf lg lh li b">loading</code>状态，事情变得稍微复杂了一些。</p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="73f9" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated"><code class="du lf lg lh li b">loading</code>状态在<code class="du lf lg lh li b">invoke</code>属性下有一个调用配置。简化和删减的注释如下所示。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/2b34b73c6c076a0a58414d29b033bcd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*2HBVx0GXhGFVRMcUV8ETKw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">在一个<code class="du lf lg lh li b">xstate</code>状态配置中处理异步状态。</figcaption></figure><p id="c3bd" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">调用分解如下所示:</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/3ae44833d1d64be1452e6397f9d3d5a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*blgXPbYR4iC5b_ALxAziAQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">带有源代码和内置挂钩的调用配置。</figcaption></figure><p id="99fb" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">我希望我已经清楚地注释了代码的这一部分，并且折叠的、简化的配置截图应该突出了配置异步数据调用的关键要素。</p><p id="7a2f" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">一旦您的状态机准备好了，就将其导入到您的组件中，并使用一个<code class="du lf lg lh li b">useMachine</code>钩子:</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/4a6b166dea566458f4a704f3ec6f21ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*6E9QWfYXfLp-fYVk7pXCXw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">useMachine挂钩的用例示例。</figcaption></figure><p id="8927" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">这或多或少是FSM的要点，包括一些稍微高级的特性来适应异步代码。</p><h1 id="1393" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">但是它是如何扩展的呢？</h1><p id="d9a9" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">随着你的应用程序变得越来越复杂，我们面临着所谓的“状态和转换爆炸”。值得庆幸的是，因为FSM作为一个概念在40年代就已经存在，所以这个问题已经解决了。1987年，一个叫大卫·哈雷尔的家伙建立了状态图。这在David Kourdish在CSSConf BP 2019 的<a class="ae iu" href="https://www.youtube.com/watch?v=0cqeGeC98MA" rel="noopener ugc nofollow" target="_blank">演讲中有详细介绍——我将尝试解释的内容就在那里(只是由<code class="du lf lg lh li b">xstate</code>库的作者本人更雄辩地提出)，所以我恳求你，如果你已经走了这么远，并且有大约40分钟的空闲时间，请务必查看一下。</a></p><figure class="lk ll lm ln fd ij"><div class="bz dy l di"><div class="mi me l"/></div></figure><p id="4e23" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">因此，为了保持简短，状态图<em class="mj">在概念上</em>提供:</p><ul class=""><li id="cbb3" class="lp lq hi jv b jw la ka lb ke lr ki ls km lt kq lu lv lw lx bi translated"><strong class="jv hj">动作</strong> ( <code class="du lf lg lh li b">xstate</code>对<code class="du lf lg lh li b">entry</code>和<code class="du lf lg lh li b">exit</code>事件有钩状配置，转场是顺便动作等)</li><li id="645a" class="lp lq hi jv b jw ly ka lz ke ma ki mb km mc kq lu lv lw lx bi translated"><strong class="jv hj">守卫</strong>(可以实现条件转换)</li><li id="77b8" class="lp lq hi jv b jw ly ka lz ke ma ki mb km mc kq lu lv lw lx bi translated"><strong class="jv hj">层级</strong>(可以有嵌套状态)</li><li id="92b7" class="lp lq hi jv b jw ly ka lz ke ma ki mb km mc kq lu lv lw lx bi translated"><strong class="jv hj">正交性</strong>(可以有平行状态)</li><li id="c799" class="lp lq hi jv b jw ly ka lz ke ma ki mb km mc kq lu lv lw lx bi translated">历史(你可以转换回记忆中的状态)</li></ul><p id="fa5d" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">如果你计划将<code class="du lf lg lh li b">xstate</code>添加到你的项目中，确保你记住这一点，并在<a class="ae iu" href="https://github.com/statelyai/xstate" rel="noopener ugc nofollow" target="_blank">官方文件</a>中找到更多信息。</p><h1 id="c02d" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论</h1><p id="927c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">在您的应用程序中使用FSM和状态图的主要优势是能够<a class="ae iu" href="https://xstate.js.org/viz" rel="noopener ugc nofollow" target="_blank">可视化</a>您的软件建模过程，创建易于推理(和测试)的精确逻辑图，出色的测试覆盖率，自动生成的代码，最重要的是，通过所有这些，适应后期的突破性需求变化。</p><p id="c31a" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">可能会阻碍你的是学习曲线，以及这种思考软件的方式需要提前计划的事实(但是说实话，没有提前计划，不会有很多好的项目发生)。此外，有一个警告——并不是所有的都可以用状态图来建模。</p><p id="5ec1" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated">至于我自己，我完全接受这个想法，并期待下次有机会时使用<code class="du lf lg lh li b">xstate</code>。我也希望我已经把你推到了正确的<em class="mj">方向上</em>，并且前端开发社区将开始更多地意识到使用类似于这里所描述的技术的软件建模。这篇文章只是触及了皮毛。</p><p id="cbd5" class="pw-post-body-paragraph jt ju hi jv b jw la jy jz ka lb kc kd ke lc kg kh ki ld kk kl km le ko kp kq hb bi translated"><em class="mj">如果你认为你对xstate有一些见解，而我可能遗漏了或误解了，我鼓励你联系我——这个主题很广泛，可以用无数种方式来处理。如果你想拓展你的人际网络，你也可以在推特上找到我。</em></p></div></div>    
</body>
</html>