<html>
<head>
<title>AES: How the Most Advanced Encryption Actually Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AES:最先进的加密技术实际上是如何工作的</h1>
<blockquote>原文：<a href="https://medium.com/codex/aes-how-the-most-advanced-encryption-actually-works-b6341c44edb9?source=collection_archive---------2-----------------------#2021-07-13">https://medium.com/codex/aes-how-the-most-advanced-encryption-actually-works-b6341c44edb9?source=collection_archive---------2-----------------------#2021-07-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/82f1d0e73a72cb16b7d03952ff00d0c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0tm9NZW_Q2--zb3SR6JIjA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源:<a class="ae iu" href="https://www.venafi.com/blog/what-are-best-use-cases-symmetric-vs-asymmetric-encryption" rel="noopener ugc nofollow" target="_blank">https://www . vena fi . com/blog/what-is-best-use-cases-symmetric-vs-asymmetric-encryption</a></figcaption></figure><p id="6e50" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">政府、军队、银行和企业都依赖它。它负责保护您的大部分(如果不是全部)个人和财务数据。它有专门的CPU指令。这是美国国家安全局唯一批准的加密算法。</p><p id="c8e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们当然在谈论高级加密标准(AES)，这是迄今为止开发的最普通、最安全的对称加密算法。</p><p id="317d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将是我们目前写的最长的一篇文章😊。我们将深入研究这个算法是如何工作的。现代密码算法绝不是微不足道的；他们使用高等数学中的概念来实现高级别的安全性。但我们不指望你成为数学家。</p><p id="3e34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然有许多关于AES的文章，但大多数文章要么太专业，要么遗漏了重要信息。通过这篇文章，我们希望在全面性和可访问性之间达到完美的平衡。然而，我们必须承认，这篇文章需要一定程度的数学知识，因为这里引入了数学概念。</p><p id="03cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">必须说明的是，你不应该试图在一个生产应用中自己实现AES，或者冒一个<a class="ae iu" href="https://en.wikipedia.org/wiki/Side-channel_attack" rel="noopener ugc nofollow" target="_blank">侧信道攻击</a>的风险。使用许多免费的<a class="ae iu" href="https://en.wikipedia.org/wiki/Comparison_of_cryptography_libraries" rel="noopener ugc nofollow" target="_blank">密码库</a>，它们提供你需要的任何算法的测试实现。</p><h1 id="30bb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">基础知识</h1><p id="0e6d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">首先，简要回顾一下什么是AES。</p><p id="7e84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">AES并不是算法本身的名字，而是国家标准与技术研究所(NIST)授予他们认为是加密事实标准的算法的称号。该算法的实际名称是<em class="kw"> Rijndael </em>，它是由NIST在一系列算法中选择的，以取代以前的标准，即DES(数据加密标准)。Rijndael于2001年获得NIST批准，并于2002年被美国政府采用。它仍然是美国政府和世界各地机构使用的标准密码。</p><p id="9332" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">AES是一种<em class="kw">对称密码</em>，也就是说使用单个密钥来加密<em class="kw">和</em>解密相同的数据。AES可以使用以下密钥大小执行:<strong class="ix hj"> 128位、196位和256位</strong>。通常，增加密钥大小也会提高安全级别。Rijndael适用于任何32位倍数的密钥大小，但NIST选择了平衡性能和安全性的特定大小(和其他参数)。</p><p id="20d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也是一种<em class="kw">分组密码</em>，意思是数据在加密前被分成块。AES将明文分成16字节(128位)的块。</p><h1 id="3b38" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">算法概述</h1><p id="c02f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">AES的要点是:我们将每个明文块排列成一个4x4的矩阵，并对其重复执行一组操作。我们称每次迭代为<em class="kw">轮</em>，根据密钥长度(这是NIST选择的另一个参数)，我们执行<strong class="ix hj"> 10、12或14轮</strong>:</p><ul class=""><li id="15e0" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js lc ld le lf bi translated">128位密钥10轮</li><li id="15d9" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">196位密钥12轮</li><li id="48ab" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">256位密钥14轮</li></ul><p id="8a48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于每一轮，我们使用<em class="kw"> Rijndael密钥表</em>从主密钥生成一个<em class="kw">轮密钥</em>。</p><p id="2c7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将定义4x4矩阵的四种运算:</p><ul class=""><li id="7a3b" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js lc ld le lf bi translated">子字节()</li><li id="e29e" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">shiftRows()</li><li id="e6e3" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">混合列()</li><li id="4f52" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">addRoundKey()</li></ul><p id="f257" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不是每一轮操作都是一样的；对于第一轮，我们只添加了round键，对于最后一轮，我们省略了mixColumns()步骤。因此，AES算法的伪代码可能如下所示:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="bc81" class="lu ju hi lq b fi lv lw l lx ly">function AESencrypt(plaintext, key) {<br/>  <br/>  blocks := divideIntoBlocks(plaintext);<br/>  roundKeys = getRoundKeys(key)</span><span id="d213" class="lu ju hi lq b fi lz lw l lx ly">  for (block in blocks) {</span><span id="a01e" class="lu ju hi lq b fi lz lw l lx ly">    //first round<br/>    addRoundKey(roundKeys[0], block);</span><span id="4550" class="lu ju hi lq b fi lz lw l lx ly">    //intermediate rounds<br/>    for (8, 10 or 12 rounds) {<br/>      subBytes(block);<br/>      shiftRows(block);<br/>      mixColumns(block);<br/>      addRoundKey(roundKeys[..], block);<br/>    }</span><span id="cef3" class="lu ju hi lq b fi lz lw l lx ly">    //last round<br/>    subBytes(block);<br/>    shiftRows(block);<br/>    addRoundKey(roundKeys[numRounds - 1], block);</span><span id="c4ac" class="lu ju hi lq b fi lz lw l lx ly">  }</span><span id="cc2e" class="lu ju hi lq b fi lz lw l lx ly">  ciphertext := reassemble(blocks);<br/>  return ciphertext;</span><span id="4e40" class="lu ju hi lq b fi lz lw l lx ly">}</span></pre><h1 id="db96" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">数学背景</h1><p id="b7c5" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这一节可能显得相当深奥。我们告诉过你我们会详细解释AES，我们没有说谎。幸运的是，我们认为只有高中水平的数学和基本编程经验才能理解本节中的概念。不要让华丽的词藻把你搞糊涂了！</p><p id="2f0e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们引入抽象代数中的一个概念，叫做<em class="kw">伽罗瓦域</em>或<em class="kw">有限域</em>。一个<em class="kw">字段</em>是一个集合(意味着一个对象的集合),其操作作用于该集合，其行为类似于加、减、乘、除。换句话说，这些运算满足许多性质，这些性质也适用于有理数上的加法/减法/乘法/除法。实际上，具有这四种运算的有理数和实数都有资格作为一个域。<em class="kw">有限</em>限定符仅仅意味着集合有有限数量的元素。</p><p id="3838" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们不会深入研究字段的具体定义。就把它想象成一组加减乘除被重新定义的数字。</p><p id="bac2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">AES使用特定的伽罗瓦域，我们称之为<em class="kw"> Rijndael的有限域</em>，来执行许多基本运算。特别是用了不可约多项式<em class="kw">x</em>⁸+<em class="kw">x</em>⁴+<em class="kw">x</em>+<em class="kw">x</em>+1的GF(2⁸。你过一会儿就会明白这意味着什么。</p><p id="3d44" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">伽罗瓦域GF( <em class="kw"> pⁿ </em>)，其中<em class="kw"> p </em>是素数<em class="kw"> n </em>是正整数，表示具有<em class="kw"> pⁿ </em>元素<em class="kw">的域。</em>例如，字段GF(8)(或GF(2))包含从0到7的所有整数。伽罗瓦域的一个重要性质是域GF( <em class="kw"> pⁿ </em>)的元素<strong class="ix hj">都是小于n次的非负系数多项式，求值点为p </strong> <em class="kw">。p </em>称为该字段的<em class="kw">特征</em>。</p><p id="cc5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们再来看看GF(8)，或者GF(2)。GF(2)包含{0，1，2，3，4，5，6，7}，可以等价地表示为{0，1，2，2 + 1，2，2 + 1，2 + 2，2 + 2，2 + 1}，或者{0，1，<em class="kw"> x </em>，<em class="kw"> x </em> + 1，<em class="kw"> x </em>，<em class="kw"> x </em> + 1，<em class="kw"> x </em> + <em class="kw"> x </em></p><p id="ecd6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了这个符号，我们现在可以解释加/减/乘/除如何与伽罗瓦域一起工作。</p><h2 id="7d64" class="lu ju hi bd jv ma mb mc jz md me mf kd jg mg mh kh jk mi mj kl jo mk ml kp mm bi translated"><strong class="ak">加法/减法</strong></h2><p id="a463" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">假设我们要添加GF的元素<em class="kw"> a </em>和<em class="kw">b</em>(<em class="kw">pⁿ</em>)。先把它们转换成多项式形式，也就是写成<em class="kw"> p </em>的幂和。然后我们将多项式相加在一起，但有一个警告:对于<em class="kw"> a(p) </em>中的每个系数<em class="kw"> a_k </em>、<em class="kw"> b(p) </em>中的每个系数<em class="kw"> b_k </em>，得到的系数<em class="kw"> c_k </em>等于<em class="kw">a _ k</em>+<em class="kw">b _ k</em>mod<em class="kw">p</em>。做减法，公式是<em class="kw">c _ k</em>=<em class="kw">a _ k</em>—<em class="kw">b _ k</em>mod<em class="kw">p</em>。</p><p id="376e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于Medium不支持数学表达式，我们深表歉意。这是乳胶中的配方:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/7bacdc6fcd5126b9ae543b49789b9121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*b32ra3kUxYZx0PAk-fBF0g.png"/></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/a40f8008027fc4fdfdc0bef9cd71b4ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*-XPMYNDqSAghS8q8jizwpA.png"/></div></figure><p id="bbb5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“mod”当然代表模，在大多数编程语言中写为“%”。让我们看一个例子:</p><p id="824e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GF(3⁴的74+26)=(2 * 3+2 * 3+2 * 1)+(2 * 3+2 * 3+2 * 1)</p><p id="70e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">=(2 * 3+4 * 3+2 * 3+4 * 1)=(2 * 3+3+6+1)=<strong class="ix hj">70</strong></p><p id="a2d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，由于系数上的模运算，4 * 3变成了3，4 * 1变成了1。</p><p id="06bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Rijndael字段GF(2⁸)以及所有具有特征2的字段都有一个共同的属性，这使得它们非常适合于计算机:<strong class="ix hj">加法和减法相当于按位异或(XOR/⊕)运算。这是可行的，因为多项式中的每一项都代表一位。</strong>这里有另一个例子来证明这一事实:</p><p id="2379" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GF(2⁴的15+12)=(2+2+2+1)+(2+2)</p><p id="b758" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">=(2 * 2+2 * 2+2+1)=(2+1)=<strong class="ix hj">3</strong></p><p id="f1f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">15⊕12 = 0b 1111⊕0b 1100 = 0b 0011 =<strong class="ix hj">3</strong></p><p id="8ae0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">伽罗瓦域中的加法通常被称为“无进位加法”我们独立地将每组数字以模<em class="kw"> p </em>相加。注意，在上面的例子中，第一组数字加起来是2 mod 2 = 0，而第二组数字加起来是7 mod 2 = 3。</p><h2 id="5302" class="lu ju hi bd jv ma mb mc jz md me mf kd jg mg mh kh jk mi mj kl jo mk ml kp mm bi translated"><strong class="ak">乘法</strong></h2><p id="7dee" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了将GF( <em class="kw"> pⁿ </em>)中的两个多项式<em class="kw"> a(p) </em>和<em class="kw"> b(p) </em>相乘，我们需要选择第三个多项式<em class="kw"> m(p) </em>，该多项式<em class="kw">不能被</em>分解，并且次数至少为<em class="kw"> n </em>。我们称m(p)为不可约多项式。</p><p id="bf1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了将 GF( <em class="kw"> pⁿ </em>)中的<em class="kw"> a(p) </em>和<em class="kw"> b(p)相乘，我们执行以下步骤:</em></p><ul class=""><li id="c9c2" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js lc ld le lf bi translated">像正常一样将<em class="kw"> a(p) </em>和<em class="kw"> b(p) </em>相乘</li><li id="29c0" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">减少生成的多项式的系数模p。</li><li id="1ae6" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">减少整个多项式mod <em class="kw"> m(p)。这就是为什么我们的最终答案不到pⁿ.</em></li></ul><p id="da06" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一步可以使用多项式长除法来执行。<strong class="ix hj">不过，这可不是普通的师<em class="kw">。我们在这个过程中执行的每一个算术运算都必须是有限域的版本。在GF(2⁸的例子中，每次我们执行“减法”时，我们实际上执行的是“异或”运算。将多项式表示为二进制字符串将有助于这一步。</em></strong></p><p id="780e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们在GF(2⁸表演193 * 56)并用<em class="kw">m(p)</em>=<em class="kw">x</em>⁸+<em class="kw">x</em>⁴+<em class="kw">x</em>+<em class="kw">x</em>+1(Rijndael的场):</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/bd112a094204bbb54cd3a67618b3c790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rc1od0FZUReYTN0q6MJAow.png"/></div></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/c300bb343cc02731aae54931cb6985f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QdgLMbTc2cpGQEC3UXjZfw.png"/></div></div></figure><p id="b823" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果有限域的乘法看起来很复杂，不用担心！利用Rijndael的场，乘法算法可以大大优化，超出上述内容。下面是一个伪代码实现:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="738b" class="lu ju hi lq b fi lv lw l lx ly">function gmul(a : byte, b : byte) {</span><span id="9cf4" class="lu ju hi lq b fi lz lw l lx ly">  p : byte = 0x00;<br/>  <br/>  for (8 rounds) {</span><span id="4333" class="lu ju hi lq b fi lz lw l lx ly">    //if low bit of b is set<br/>    if ((b &amp; 1) != 0) {<br/>      p = p ⊕ a;<br/>    }<br/>    <br/>    //true if the high bit of a is set<br/>    h : bool = (a &amp; 0x80) != 0;</span><span id="cb7e" class="lu ju hi lq b fi lz lw l lx ly">    a = a &lt;&lt; 1; //shift left<br/>    <br/>    if (h) {<br/>      a = a ⊕ 0x1B; //value of the polynomial m(p) (0x11B) with the high bit removed<br/>    }</span><span id="f97d" class="lu ju hi lq b fi lz lw l lx ly">    b = b &gt;&gt; 1; //right shift</span><span id="01ba" class="lu ju hi lq b fi lz lw l lx ly">   return p;</span><span id="a206" class="lu ju hi lq b fi lz lw l lx ly">  }  <br/>}</span></pre><h2 id="a589" class="lu ju hi bd jv ma mb mc jz md me mf kd jg mg mh kh jk mi mj kl jo mk ml kp mm bi translated">乘法逆/除法</h2><p id="b4dc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">多项式a(p)的乘法逆是多项式b(p)，使得a(p) * b(p) mod m(p) = 1。通过应用上述算法的逆运算，可以找到乘法逆运算。除法就是将第一个操作数乘以第二个操作数的倒数。</p><h2 id="7012" class="lu ju hi bd jv ma mb mc jz md me mf kd jg mg mh kh jk mi mj kl jo mk ml kp mm bi translated"><strong class="ak">有什么意义？</strong></h2><p id="f18c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">AES为什么借用有限域理论的概念？主要原因是性能。请记住，GF(2⁸中的“加法”与“异或”运算相同。还要考虑没有必要担心上溢/下溢，因为操作的输入和输出被限制在数字0–255。</p><p id="037d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">乘法没有看起来那么复杂。为了客观地看待问题，考虑计算机如何在最底层执行正常的乘法:通过重复的位移和加法(当然，我们没有特殊的电路来执行GF(2⁸算法)。最后，2和3相乘非常容易优化。这在以后会变得很重要。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="f2e9" class="lu ju hi lq b fi lv lw l lx ly">//multiply by 2 in GF(2^8)<br/>function gmul2(a : byte) {</span><span id="0f0f" class="lu ju hi lq b fi lz lw l lx ly">  h : byte = a &amp; 0x80; //high bit</span><span id="291b" class="lu ju hi lq b fi lz lw l lx ly">  b : byte = a &lt;&lt; 1;</span><span id="29da" class="lu ju hi lq b fi lz lw l lx ly">  if (h == 0x80) b = b ⊕ 0x1b;</span><span id="389b" class="lu ju hi lq b fi lz lw l lx ly">  return b; </span><span id="3125" class="lu ju hi lq b fi lz lw l lx ly">}</span><span id="2e58" class="lu ju hi lq b fi lz lw l lx ly">//multiply by 3 in GF(2^8)<br/>function gmul3(a : byte) {</span><span id="a245" class="lu ju hi lq b fi lz lw l lx ly">  return a ⊕ gmul2(a);</span><span id="fc08" class="lu ju hi lq b fi lz lw l lx ly">}</span></pre><h1 id="87e0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">密钥扩展</h1><p id="d21e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">背景介绍完了！现在是时候研究AES实际上做什么的本质了。</p><p id="7eb8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在进行任何加密之前，必须为每一轮生成单独的128位密钥。Rijndael使用特定的算法来生成轮密钥。</p><p id="9641" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Rijndael密钥计划执行许多操作:</p><p id="cf3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> rotate(): </strong>将一个32位(4字节)字向左旋转8位。举个例子:rotate(0xab157c9e) = 0x157c9eab。</p><p id="85ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> rcon(): </strong>在Rijndael的有限域中对2取幂(重复相乘)到指定值。这个操作可以用下面的伪代码来描述。然而，我们将只需要使用最多11个rcon()值，因此一个查找表就足够了。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="739b" class="lu ju hi lq b fi lv lw l lx ly">function rcon(value : unsigned int) {</span><span id="4873" class="lu ju hi lq b fi lz lw l lx ly">  c : byte = 1;<br/>  <br/>  if (value == 0) return 0;<br/>  while (value != 1) {<br/>    c = gmul(c, 2);<br/>    value--;<br/>  }</span><span id="67ab" class="lu ju hi lq b fi lz lw l lx ly">  return c;</span><span id="5ebc" class="lu ju hi lq b fi lz lw l lx ly">}</span></pre><p id="4294" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还没有解释幂运算如何适用于有限域。简而言之，它与普通数学非常相似。如果好奇的读者想了解更多，我们鼓励他们自己做研究。</p><p id="0b5d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">sbox():</strong>Rijndael字段中的另一个操作，通常用下面的查找表实现:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/813149bcbb6f88f2f8ec005fa71adb1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jS3HSAr5mIotBFA0EXgW1A.png"/></div></div></figure><p id="81c3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数学上，sbox()是一个两部分操作。首先，我们取输入的乘法逆运算。结果表示为一个八元素向量(每位一个)，并经过以下转换:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/8c59864415deca3b68252624e077a672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-l0Y4dkfLh-KEpUlNuoy_Q.png"/></div></div></figure><p id="9d54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">整个过程是用Rijndael的有限域算法进行的。例如，在最后，字节0b11000110没有被相加，而是与矩阵向量乘积进行了“异或”运算。这种转换更简洁地表示为一系列xor和左位旋转，如下所示:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/5b7bec62c6b679483436c77ca7426d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hn53zg152FwaSqwu6ECvyQ.png"/></div></div></figure><p id="2242" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">sbox()操作在整体上极大地提高了AES的安全性。它对<strong class="ix hj">线性密码分析</strong>有抵抗力，因为它很难用线性变换来近似。它还能抵抗<strong class="ix hj">差分密码分析</strong>，因为在输入如何变化和输出如何变化之间似乎没有相关性。最后，sbox()的特殊之处在于没有<strong class="ix hj">固定点</strong>，即不存在输入等于输出的情况。</p><p id="33c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">密钥扩展算法主要作用于32位字，而不是字节。以后我们将<strong class="ix hj">子字()</strong>定义为sbox()在一个字的每个字节上的应用。</p><h2 id="3bb0" class="lu ju hi bd jv ma mb mc jz md me mf kd jg mg mh kh jk mi mj kl jo mk ml kp mm bi translated">密钥扩展算法</h2><p id="4fc8" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">真正的密钥生成算法。在了解这些步骤之前，让我们先定义一些常数:</p><ul class=""><li id="7e69" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js lc ld le lf bi translated">让K[0]到K[N-1]代表原始密钥的32位字。</li><li id="b036" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">设N等于32位字中原始密钥的长度<strong class="ix hj">(128、192或256位密钥分别为4、6或8)。</strong></li><li id="c9db" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">设R等于轮数<strong class="ix hj">(128、192或256位密钥分别为10、12或15)。</strong></li><li id="6c06" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated">设W[0]到W[4R-1]代表包含所有轮密钥的32位字。我们称之为扩展键。</li></ul><p id="71bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">密钥扩展算法遍历所有32位字W[0]到W[4R-1]。当我们想要一个特定的轮密钥时，我们组合对应于该轮的扩展密钥的四个字(128位)。例如，第3轮密钥由W[8]到W[11]组成。</p><p id="f2d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">算法是这样的:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="45d7" class="lu ju hi lq b fi lv lw l lx ly">for (i from 0 to 4R - 1) {</span><span id="2ef9" class="lu ju hi lq b fi lz lw l lx ly">  //The first words (W[0] thru W[N-1]) are equal to the words of the original key.<br/>  //For a 128-bit key, this means that the first round key is equal to the original key.<br/>  if (0 &lt; i &lt; N) W[i] = K[i];</span><span id="c8b7" class="lu ju hi lq b fi lz lw l lx ly">  //Perform operations on the last word of each N-length cycle before XOR-ing.<br/>  else if (i &gt;= N and i == 0 mod N)<br/>    W[i] = W[i-N] <strong class="lq hj">⊕ </strong>subWord(rotate(W[i-1])) <strong class="lq hj">⊕ </strong>rcon(i/N);</span><span id="512f" class="lu ju hi lq b fi lz lw l lx ly">  //For a 256-bit key length only.<br/>  else if (i &gt;= N and N == 8 and i == 4 mod N)<br/>    W[i] = W[i-N] <strong class="lq hj">⊕ </strong>subWord(W[i-1])<strong class="lq hj">;</strong></span><span id="1dbe" class="lu ju hi lq b fi lz lw l lx ly">  //Typical case<br/>  else W[i] = W[i-N] <strong class="lq hj">⊕ </strong>W[i-1];</span><span id="c60e" class="lu ju hi lq b fi lz lw l lx ly">}</span></pre><p id="bf0e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该算法的要点是这样的:通常，每个单词是前一个单词与其后N个位置的单词进行异或运算。但是每n个字，在异或发生之前，我们对后面n个位置的字执行各种GF(2⁸运算。</p><h1 id="d161" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">AES回合，循序渐进</h1><p id="8d00" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">在本节中，我们将带您完成整个AES回合。记住第一轮只包含addRoundKey()步骤。我们将检查每一步，所以想象第一轮已经过去，我们现在在第二轮。</p><p id="7512" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们想要加密以下消息:</p><blockquote class="mu mv mw"><p id="df34" class="iv iw kw ix b iy iz ja jb jc jd je jf mx jh ji jj my jl jm jn mz jp jq jr js hb bi translated">那只敏捷的棕色狐狸跳过了那只懒狗</p></blockquote><p id="8014" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将只看第一个块是如何加密的，包含“快速布朗”。重新排列成4x4矩阵后，该块看起来像这样:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es na"><img src="../Images/b3426f9a5b459ae563fdda38c4619631.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*Vun6MZNz5WVwvFY6JyflXQ.png"/></div></figure><p id="1fee" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里又是十六进制的:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/89443bff3fd6d77d1a8650fba9052ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*uVKDa77gjVgsfdaZNpxxzg.png"/></div></figure><h2 id="2d0f" class="lu ju hi bd jv ma mb mc jz md me mf kd jg mg mh kh jk mi mj kl jo mk ml kp mm bi translated">子字节()</h2><p id="6f6e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这是AES回合的第一步。我们对矩阵中的每个字节执行sbox()操作(详情参见“密钥扩展”部分)。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nc"><img src="../Images/84e2a062346d7ac91ce4273df7fe76b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RmhHKWYNXTdJbP4N0gZrAg.png"/></div></div></figure><h2 id="445a" class="lu ju hi bd jv ma mb mc jz md me mf kd jg mg mh kh jk mi mj kl jo mk ml kp mm bi translated">shiftRows()</h2><p id="e1fc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对于这一步，我们将每一行向左旋转一定数量的与行号对应的空格。第一行移动0个空格，第二行移动1个空格，依此类推。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/d5953762d45965ed390660a46941361a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XCto0rabgzk8CjtfubHGbQ.png"/></div></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/7936ea1c89956b9b3f32a46741a231e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S1K2igpNY813n4gV643ixw.png"/></div></div></figure><h2 id="1a96" class="lu ju hi bd jv ma mb mc jz md me mf kd jg mg mh kh jk mi mj kl jo mk ml kp mm bi translated">混合列()</h2><p id="24a8" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在，我们使用GF(2⁸算法(gmul()和XOR，而不是普通的加法和乘法)将每列乘以下面的矩阵:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/304a4b8ff0f7c5b9edb13278b4dd0520.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*E0POvJgWhIcwAM7IonSyyg.png"/></div></figure><p id="fe3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">整个转换如下所示:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/03b75515fbc5c01ec772098f265b8693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*WxfxSc5kHtxlwrJnvOkVhA.png"/></div></figure><p id="4800" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，这种转换涉及许多乘以2和乘以3的操作。这就是“数学背景”一节末尾提到的优化发挥作用的地方。</p><p id="a8c5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的示例中，对每一列应用转换如下所示:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/61e9262c4f745738ebc293a443f2df0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sCWXX9VppD-b6g6GrwcsvA.png"/></div></div></figure><p id="fc10" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">shiftRows()和mixColumns()步骤都将<strong class="ix hj">扩散</strong>添加到密码中，因为它们允许明文中的微小变化影响整个密文。</p><h2 id="5562" class="lu ju hi bd jv ma mb mc jz md me mf kd jg mg mh kh jk mi mj kl jo mk ml kp mm bi translated">addRoundKey()</h2><p id="6967" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">这是最简单的一步。我们将块中的每个字节与轮密钥中相应的字节进行异或运算。我们假设这一轮的轮密钥是:</p><blockquote class="mu mv mw"><p id="3c16" class="iv iw kw ix b iy iz ja jb jc jd je jf mx jh ji jj my jl jm jn mz jp jq jr js hb bi translated">abcdefghijklmnop</p></blockquote><p id="b843" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在十六进制中，这是:</p><blockquote class="mu mv mw"><p id="6cdf" class="iv iw kw ix b iy iz ja jb jc jd je jf mx jh ji jj my jl jm jn mz jp jq jr js hb bi translated">61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70</p></blockquote><p id="0e1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请记住，这是一个非常不现实的场景。与加密密钥一样，轮密钥应该是伪随机的。</p><p id="606d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的示例中，addRoundKey()的结果如下所示:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/3d966f7acb3d171389cd9f1ce1674e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fXQ5360UIv3GAbiYCeJYvw.png"/></div></div></figure><p id="d533" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">转换回ASCII，单个AES回合的结果如下所示:</p><blockquote class="mu mv mw"><p id="b4e2" class="iv iw kw ix b iy iz ja jb jc jd je jf mx jh ji jj my jl jm jn mz jp jq jr js hb bi translated">1sfò%èm P</p></blockquote><p id="10d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见，原始消息已经被荒谬地打乱了。把这个放大14倍，确保密钥是随机的，你就有了一个即使是最好的计算机也无法破解的安全级别。</p><h1 id="505d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">[通信]解密</h1><p id="a366" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">所以我们有了加密信息。如何逆转AES漫长而复杂的过程？AES的一大优点是<em class="kw">每一个动作都有它的反面。</em></p><p id="eec4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解密是这样工作的:我们使用相同的过程生成轮密钥。然后，我们使用各种运算的逆运算在<em class="kw">逆</em>中执行加密算法。</p><p id="d05d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">addKeys()步骤是它自己的逆步骤。将字符串<em class="kw"> A </em>与字符串<em class="kw"> B </em>进行两次异或运算，结果是<em class="kw"> A </em>。我们只需要记住使用最终的加密轮密钥作为第一个解密轮密钥，倒数第二个作为第二个，以此类推。</p><p id="32f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于mixColums()步骤，我们将上述矩阵的<em class="kw">逆</em>应用于所有列。转换如下所示:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/34b2bff0f9bbb9b171dc52adfca988b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zUUllEswFhKSgt4AAO3JBA.png"/></div></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/ac0023f8e7aeb7f557ee5fd5dac0126a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OLYNV1RDKelE9ekkJ01o0Q.png"/></div></div></figure><p id="4cb0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于shiftRows()步骤，我们简单地以相反的方向旋转行。或者可选地，在相同方向上将每一行旋转不同数量的空间。如果一个字节在第二行，它将在加密期间向左旋转1个空格，在解密期间向右旋转1个空格/向左旋转3个空格。</p><p id="5848" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，对于subBytes()步骤，我们应用sbox()操作的<em class="kw">逆</em>。记住，我们通常使用sbox()的查找表。我们还可以使用一个查找表来求逆，如下所示:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nl"><img src="../Images/8b0eea083dd72647b7a3bf0bf9814836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4LV9AzaTnkE9Rk44BlXfA.png"/></div></div></figure><p id="dfe2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一件事:我们需要记住，不是所有的回合都是一样的。因为我们在第一轮加密中只执行addRoundKey()，所以我们在最后一轮解密中也执行同样的操作。因为我们在最后一轮加密中省略了mixColumns()，所以我们必须在第一轮解密中这样做。</p><p id="7171" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">整个解密过程的伪代码如下所示:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="dc32" class="lu ju hi lq b fi lv lw l lx ly">function AESdecrypt(ciphertext, key) {<br/>  <br/>  blocks := divideIntoBlocks(ciphertext);<br/>  roundKeys = getRoundKeys(key)</span><span id="2c91" class="lu ju hi lq b fi lz lw l lx ly">  for (block in blocks) {</span><span id="6e2b" class="lu ju hi lq b fi lz lw l lx ly">    //first round<br/>    addRoundKey(roundKeys[numRounds - 1], block);<br/>    shiftRowsInv(block);<br/>    subBytesInv(block);</span><span id="b4f3" class="lu ju hi lq b fi lz lw l lx ly">    //intermediate rounds<br/>    for (8, 10 or 12 rounds) {<br/>      addRoundKey(roundKeys[..], block);<br/>      mixColumnsInv(block);<br/>      shiftRowsInv(block);<br/>      subBytesInv(block);<br/>    }</span><span id="f000" class="lu ju hi lq b fi lz lw l lx ly">    //last round<br/>    addRoundKey(roundKeys[0], block);</span><span id="556b" class="lu ju hi lq b fi lz lw l lx ly">}</span><span id="b28e" class="lu ju hi lq b fi lz lw l lx ly">  plaintext := reassemble(blocks);<br/>  return plaintext;</span><span id="6e47" class="lu ju hi lq b fi lz lw l lx ly">}</span></pre><h1 id="7472" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">安全屋</h1><p id="2da5" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们完了！我们已经解释了基本上所有的事情。有了这些知识，你应该能够自己实现AES，尽管我们强烈反对这样做。</p><p id="9768" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们安全屋相信网络安全是每个人的，所以我们很高兴以一种容易理解的方式展示这样的信息。网络安全行业忽视了小企业，我们想表明立场。</p><p id="ed6d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你觉得你读到的内容很有价值，可以考虑去https://safehouse.dev/<a class="ae iu" href="https://safehouse.dev/" rel="noopener ugc nofollow" target="_blank">看看我们。</a></p></div></div>    
</body>
</html>