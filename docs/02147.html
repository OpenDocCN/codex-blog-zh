<html>
<head>
<title>Functional Data Structures and pattern matching in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中的函数数据结构和模式匹配</h1>
<blockquote>原文：<a href="https://medium.com/codex/functional-data-structures-and-pattern-matching-in-scala-7a379092e1e4?source=collection_archive---------9-----------------------#2021-07-03">https://medium.com/codex/functional-data-structures-and-pattern-matching-in-scala-7a379092e1e4?source=collection_archive---------9-----------------------#2021-07-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="97c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数式编程范式是一种没有任何可变状态的代码编写方式。因此，这提出了一个问题，我们如何定义数据结构以及如何使用它们，这里我们将讨论什么是<em class="jd">功能数据结构</em>以及我们将如何定义和使用它们，并且还将研究<em class="jd">模式匹配</em>和<em class="jd">高阶函数</em>的相关概念。</p><p id="8583" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">定义功能数据结构</strong></p><p id="536a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数式数据结构是对纯函数进行操作的东西，这意味着像<em class="jd"> 1 + 2 </em>将给出<em class="jd"> 3 </em>留下<em class="jd"> 1和2 </em>未修改的两个列表a和b在它们的连接上将给出<em class="jd"> (a++b) </em>将给出完全不同的列表，留下a和b未修改，这不涉及大量的数据复制吗，让我们以链表为例来检查一下。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="4f1e" class="jn jo hi jj b fi jp jq l jr js">//List type parameterised with type A<br/><strong class="jj hj">sealed</strong> <strong class="jj hj">trait</strong> <strong class="jj hj">List</strong>[<strong class="jj hj">+A</strong>]<br/>//A list constructor representing an empty list<br/><strong class="jj hj">case</strong> <strong class="jj hj">object</strong> <strong class="jj hj">Nil</strong> <strong class="jj hj">extends</strong> <strong class="jj hj">List</strong>[<strong class="jj hj">Nothing</strong>]<br/>//A list type representing an non empty list<br/><strong class="jj hj">case</strong> <strong class="jj hj">class</strong> <strong class="jj hj">Cons</strong>[<strong class="jj hj">+A</strong>](head<strong class="jj hj">:A</strong>,tail<strong class="jj hj">:List</strong>[<strong class="jj hj">A</strong>]) <strong class="jj hj">extends</strong> <strong class="jj hj">List</strong>[<strong class="jj hj">A</strong>]</span></pre><p id="da32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看Scala中的链表实现，我们创建了一个trait，Scala中的trait类似于一个接口的trait，它可以选择性地包含方法实现。sealed关键字表示trait的实现必须在文件本身中。之后，我们为列表创建了两个构造函数，对象Nil表示一个空列表，Cons表示一个非空列表的构造函数。</p><p id="81d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我们为列表类型使用了类型为<strong class="ih hj"> A </strong>的通用参数。这表明我们的列表可以是Int、Double、String等类型。</p><figure class="je jf jg jh fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jt"><img src="../Images/f687c3307d842b1fa03a7988e4a0f633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HPoQwXDMLbuIc8pnWGPsmw.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">内存列表</figcaption></figure><blockquote class="kf kg kh"><p id="a617" class="if ig jd ih b ii ij ik il im in io ip ki ir is it kj iv iw ix kk iz ja jb jc hb bi translated">列表中使用的<strong class="ih hj"> [+A] </strong>在Scala中称为协方差，即假设狗是动物的子类型，那么List[dog]就是List[Animal]的子类型。在这里，我们将Nil扩展为List[Nothing],这将适合我们所有的情况，因此Nothing是all类型的子类型，这将适合我们的需要，因此Nil可以是String、Double、Int等的空列表</p></blockquote><p id="11bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，在一个列表上定义的sum和product之类的操作将如下所示。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="84ec" class="jn jo hi jj b fi jp jq l jr js">/*<br/>  * Function to calculate sum of elements in a list*/<br/>  <strong class="jj hj">def</strong> sum(lis<strong class="jj hj">:List</strong>[<strong class="jj hj">Int</strong>])<strong class="jj hj">:Int</strong>=lis <strong class="jj hj">match</strong> {<br/>    <strong class="jj hj">case</strong> <strong class="jj hj">Nil</strong> <strong class="jj hj">=&gt;</strong> <strong class="jj hj">0</strong><br/>    <strong class="jj hj">case</strong> <strong class="jj hj">Cons</strong>(x,xs)<strong class="jj hj">=&gt;</strong>x+sum(xs)<br/>  }</span><span id="505e" class="jn jo hi jj b fi kl jq l jr js">  /*<br/>  * Function to calculate product of elements in a list*/<br/>  <strong class="jj hj">def</strong> prod(lis<strong class="jj hj">:</strong> <strong class="jj hj">List</strong>[<strong class="jj hj">Int</strong>])<strong class="jj hj">:Int</strong>=lis <strong class="jj hj">match</strong> {<br/>    <strong class="jj hj">case</strong> <strong class="jj hj">Nil=&gt;1</strong><br/>    <strong class="jj hj">case</strong> <strong class="jj hj">Cons</strong>(<strong class="jj hj">0</strong>,<strong class="jj hj">_</strong>)<strong class="jj hj">=&gt;0</strong><br/>    <strong class="jj hj">case</strong> <strong class="jj hj">Cons</strong>(x,xs)<strong class="jj hj">=&gt;</strong>x*prod(xs)<br/>  }</span></pre><p id="ff5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了找到一个链表的元素的和，我们检查了两种情况，我们可以在稍后查看这个匹配操作，这里我们比较列表，如果列表是一个空列表，那么和将是零，否则我们计算列表头和剩余部分的和。</p><p id="1389" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，如果列表为空，则计算乘积。如果到达列表的末尾，则返回乘积1，如果任何元素为0，则返回0，另一种情况是递归计算乘积。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="1aa8" class="jn jo hi jj b fi jp jq l jr js"><strong class="jj hj">object</strong> <strong class="jj hj">List</strong> {<br/> <strong class="jj hj">def</strong> main(args<strong class="jj hj">:</strong> <strong class="jj hj">Array</strong>[<strong class="jj hj">String</strong>])<strong class="jj hj">:</strong> <strong class="jj hj">Unit</strong> = {<br/>   <strong class="jj hj">val</strong> x<strong class="jj hj">:List</strong>[<strong class="jj hj">Int</strong>]<strong class="jj hj">=Cons</strong>(<strong class="jj hj">1</strong>,<strong class="jj hj">Cons</strong>(<strong class="jj hj">2</strong>,<strong class="jj hj">Nil</strong>))<br/>   println(sum(x))<br/>   //sum is 3 <br/>   println(prod(x))<br/>   //product is 2<br/>}</span></pre><p id="0c7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Scala中的模式匹配</strong></p><p id="089c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们仔细看看模式匹配部分看起来有点像switch case表达式。我们在这里做的是用关键字<strong class="ih hj"> match </strong>匹配一个int类型的列表。</p><p id="617a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd"> lis匹配</em> </strong></p><p id="4ea1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">花括号中提供了不同的匹配情况</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="2cbe" class="jn jo hi jj b fi jp jq l jr js">{<strong class="jj hj">case</strong> ex1<strong class="jj hj">=&gt;</strong> do_something<br/> <strong class="jj hj">case</strong> ex2<strong class="jj hj">=&gt;</strong> do_something<br/>}</span></pre><p id="ca9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们以列表加法为例，检查模式匹配是如何工作的。我们正在根据某些情况检查我们的列表，如果我们的列表是一个空列表，总和将为零，这将与第一种情况相匹配。下一个条件如下。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="41ed" class="jn jo hi jj b fi jp jq l jr js"><strong class="jj hj">case</strong> <strong class="jj hj">Cons</strong>(x,xs)<strong class="jj hj">=&gt;</strong>x+sum(xs)</span></pre><p id="8b0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该条件表示非空列表，对于非空列表，递归地计算总和，即总和将是其头部的总和，在这种情况下是递归地添加到sum函数的整数，直到达到列表末尾的停止条件。当达到停止条件时，将返回零，所有递归函数将被解析，并且将返回和。</p><p id="e089" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看一些模式匹配的例子。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="64d1" class="jn jo hi jj b fi jp jq l jr js"><strong class="jj hj">val</strong> k<strong class="jj hj">=Array</strong>(<strong class="jj hj">1</strong>,<strong class="jj hj">2</strong>,<strong class="jj hj">3</strong>)<br/>  <strong class="jj hj">Array</strong>(<strong class="jj hj">1</strong>,<strong class="jj hj">Nil</strong>) <strong class="jj hj">match</strong> {<br/>    <strong class="jj hj">case</strong> <strong class="jj hj">_</strong> <strong class="jj hj">=&gt;</strong> println(<strong class="jj hj">23</strong>)<br/>  }<br/>  //prints 23    <br/>  <strong class="jj hj">Cons</strong>(<strong class="jj hj">1</strong>,<strong class="jj hj">Cons</strong>(<strong class="jj hj">2</strong>,<strong class="jj hj">Nil</strong>)) <strong class="jj hj">match</strong> {<br/>    <strong class="jj hj">case</strong> <strong class="jj hj">Cons</strong>(h,<strong class="jj hj">_</strong>)<strong class="jj hj">=&gt;</strong>println(h)<br/>  }<br/>  //1<br/>  <strong class="jj hj">Cons</strong>(<strong class="jj hj">1</strong>,<strong class="jj hj">Cons</strong>(<strong class="jj hj">2</strong>,<strong class="jj hj">Nil</strong>)) <strong class="jj hj">match</strong> {<br/>    <strong class="jj hj">case</strong> <strong class="jj hj">Cons</strong>(<strong class="jj hj">_</strong>,h)<strong class="jj hj">=&gt;</strong>println(h)<br/>  }<br/>  //Cons(2,Nil)    <br/>}</span></pre><ul class=""><li id="2e88" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">第一个case将打印23，因为我们使用了_ and _ is来忽略结果，这意味着它不会检查任何东西，它将简单地执行case。</li><li id="3fce" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">第二种情况将匹配一个非空列表，并将打印列表的头。在这种情况下，它将是1。</li><li id="399b" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">第三个条件将打印列表中不包括头部的部分。</li></ul><figure class="je jf jg jh fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es la"><img src="../Images/6b8ff573438427616fd5502410466570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*KnewHYWVZAiHxdjJ80AoOg.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">列表匹配示例</figcaption></figure><p id="8458" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">函数数据结构中的数据共享</strong></p><p id="6d7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当数据结构变得不可变时，将会出现一个问题，即如何向其中添加元素或从其中删除元素。如果我们向列表<strong class="ih hj"> xs </strong>中添加一个新元素，这将导致一个新列表的创建，但实际上我们不需要将所有元素复制到列表中，我们可以重用列表xs。这个过程被称为<strong class="ih hj">数据共享</strong>。</p><p id="85d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">高阶函数和传递匿名函数</strong></p><p id="b08f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在函数式编程中，我们可以把函数当作值来处理，这样这些函数就可以存储在数据结构中，传递给函数等等。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="f4b6" class="jn jo hi jj b fi jp jq l jr js"><strong class="jj hj">def</strong> findFirst[<strong class="jj hj">T</strong>](as<strong class="jj hj">:</strong> <strong class="jj hj">List</strong>[<strong class="jj hj">T</strong>], f<strong class="jj hj">:</strong> <strong class="jj hj">T</strong> =&gt; <strong class="jj hj">Boolean</strong>)<strong class="jj hj">:</strong> <strong class="jj hj">Int</strong> = {<br/>    <strong class="jj hj">@annotation</strong>.tailrec<br/>    <strong class="jj hj">def</strong> loop(n<strong class="jj hj">:</strong> <strong class="jj hj">Int</strong>)<strong class="jj hj">:</strong> <strong class="jj hj">Int</strong> =<br/>      <strong class="jj hj">if</strong> (n &gt;= as.length) -<strong class="jj hj">1</strong><br/>      <strong class="jj hj">else</strong> <strong class="jj hj">if</strong> (f(as(n))) n<br/>      <strong class="jj hj">else</strong> loop(n + <strong class="jj hj">1</strong>)<br/><br/>    loop(<strong class="jj hj">0</strong>)<br/>  }</span></pre><p id="85b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个用于查找数组中第一个出现的元素的函数，这个函数将另一个函数<strong class="ih hj"> f </strong>作为参数，用于检查数组元素是否是我们要查找的元素，如果是，这个函数将返回它的位置。否则它将返回-1。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="4cb3" class="jn jo hi jj b fi jp jq l jr js"><strong class="jj hj">val</strong> arr2 <strong class="jj hj">=</strong> <strong class="jj hj">List</strong>("apple", "orange", "grapes")<br/>findFirst(arr2, (x<strong class="jj hj">:</strong> <strong class="jj hj">String</strong>) <strong class="jj hj">=&gt;</strong> x == "grapes"))</span></pre><p id="6bdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个将匿名函数传递给另一个函数的例子，这个函数将接受一个字符串类型的值，并检查字符串是否为“grapes ”(如果为真)。该函数将返回元素的位置。</p></div></div>    
</body>
</html>