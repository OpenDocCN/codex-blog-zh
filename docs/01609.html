<html>
<head>
<title>Why You Should Always Avoid Static Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你应该总是避免静态函数</h1>
<blockquote>原文：<a href="https://medium.com/codex/why-you-should-always-avoid-static-function-29828212ba7b?source=collection_archive---------11-----------------------#2021-05-16">https://medium.com/codex/why-you-should-always-avoid-static-function-29828212ba7b?source=collection_archive---------11-----------------------#2021-05-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6bb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">写一个静态函数总是很诱人的。我们可以从任何地方直接调用它们，而不必注入/初始化/准备它们的包装类。但是我们不应该这样做。事实上，它们甚至不应该存在于任何编程语言中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/bc40f767cdbaa6674f3c5c24d2090b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CEJnbRflM0KSN7JIQy-UA.jpeg"/></div></div></figure><h1 id="4fe7" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">1.它们是不可测试的</h1><p id="8577" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">假设我们在类测试中有这个方法:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="343c" class="kx jq hi kt b fi ky kz l la lb">public void doSomething() {<br/>  var a = 1;<br/>  var b = 2;<br/>  var c = MyClass.myStaticFunction(a, b);<br/>  return a + b + c;<br/>}</span></pre><p id="9bce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们的<em class="lc"> myStaticFunction </em>调用数据库，执行一些验证，并用一些数据库结果对<em class="lc"> a </em>和<em class="lc"> b </em>进行难看的计算。但是我们想写一个单元测试来确保<em class="lc"> doSomething() </em>总是返回:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="8228" class="kx jq hi kt b fi ky kz l la lb">a + b + c</span></pre><p id="3a14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要初始化一个到数据库的真实连接，确保这个数据库填充了正确的数据，并在我们的单元测试中配置所有这些，只是为了确保… a + b + c</p><p id="c26a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更好的选择是:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="b3e9" class="kx jq hi kt b fi ky kz l la lb"><br/>public void doSomething(MyClass myClass) {<br/> var a = 1;<br/> var b = 2;<br/> var c = myClass.myFunction(a, b);<br/> return a + b + c;<br/>}</span></pre><p id="a86b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么我们可以像这样简单地编写我们的测试:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="c435" class="kx jq hi kt b fi ky kz l la lb">@Test<br/>public void testDoSomething() {<br/>  MyClass myClass = mock(myClass.class);<br/>  doReturn(3).when(myClass).myFunction(1, 2);<br/>  assertThat(myDoSomethingClass.doSomething(myClass)).isEqualTo(6);<br/>}</span></pre><p id="5dcc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用一个像<a class="ae ld" href="https://site.mockito.org/" rel="noopener ugc nofollow" target="_blank"> mockito </a>这样的模拟框架来统一验证<em class="lc">做什么和</em>只做什么。</p><h1 id="d5f6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">2.他们像瘟疫一样复制你的参数</h1><p id="234d" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">如果一个人希望总是将相同的参数无用地传递给自己的函数，他会喜欢静态函数:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="1cd6" class="kx jq hi kt b fi ky kz l la lb">public void doSomeOtherThing(Database database, SqlUser sqlUser, SqlWhatever whatever) {<br/>  var a = SqlDb.staticFunction(database, sqlUser, whatever, 't');<br/>  var b = SqlDb.staticFunction(database, sqlUser, whatever, 'z');<br/>  var c = SqlDb.staticFunction(database, sqlUser, whatever, 'f');<br/>  var d = SqlDb.staticFunction(database, sqlUser, whatever, 'g');<br/>}</span></pre><p id="8d50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你不像我一样喜欢它们，我们可以用上面的观点写同样的函数:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="8618" class="kx jq hi kt b fi ky kz l la lb">public void doSomeOtherThing(MyDb myDb) {<br/>  var a = myDb.function('t');<br/>  var b = myDb.function('z');<br/>  var c = myDb.function('f');<br/>  var d = myDb.function('g');<br/>}</span></pre><p id="3ca8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过在前面的某个地方只初始化MyDb一次:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="4f8a" class="kx jq hi kt b fi ky kz l la lb">myDb = new MySqlDb(database, metadata, whatever);</span></pre><h1 id="9212" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">3.他们不肯让步</h1><p id="9237" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">假设有一种非常奇怪的情况，客户或我们的老板想要从SQL数据库转移到像Mongo这样的文档数据库(或者想要支持他们两个，wild wild ),而我们仍然有我们丑陋的静态函数:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="a99a" class="kx jq hi kt b fi ky kz l la lb">public void doSomeOtherThing(Database database, SqlUser sqlUser, SqlWhatever whatever) {<br/>  var a = SqlDb.staticFunction(database, sqlUser, whatever, 't');<br/>  var b = SqlDb.staticFunction(database, sqlUser, whatever, 'z');<br/>  var c = SqlDb.staticFunction(database, sqlUser, whatever, 'f');<br/>  var d = SqlDb.staticFunction(database, sqlUser, whatever, 'g');<br/>}</span></pre><p id="1b89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哦不！我们不认为除了<em class="lc"> sqlUser </em>或类似<em class="lc"> SqlWhatever </em>的其他用户类型之外还会有其他用户类型。</p><p id="72cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们使用像2这样的非静态函数。如果不重复我们的参数，我们可以得到完全相同的代码，尽管:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="6939" class="kx jq hi kt b fi ky kz l la lb">public void doSomeOtherThing(MyDb myDb) {<br/>  var a = myDb.function('t');<br/>  var b = myDb.function('z');<br/>  var c = myDb.function('f');<br/>  var d = myDb.function('g');<br/>}</span></pre><p id="fd8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用先前在某处初始化的不同数据库:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="8a20" class="kx jq hi kt b fi ky kz l la lb">myDb = new MyMongoDb(database, metadata, whatever);</span></pre><h1 id="9a39" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">更好的选择</h1><p id="01c0" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">假设我们的语言禁止使用静态函数，我们可以编写类似这样的代码来复制它的用法:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="f478" class="kx jq hi kt b fi ky kz l la lb">public class MyOtherClass {<br/>  public void doSomething() {<br/>    var a = 1;<br/>    var b = 2;<br/>    var c = new MyClass().myFunction(a, b);<br/>    return a + b + c;<br/>  }<br/>}</span></pre><p id="6d23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个丑:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="48e8" class="kx jq hi kt b fi ky kz l la lb">new MyClass().myFunction(a, b);</span></pre><p id="4fd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后可以用三种方式重构:<br/> 1。我们可以让<em class="lc"> myFunction </em>只是<em class="lc"> MyOtherClass </em>的一个方法；</p><p id="d2dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.如果<em class="lc"> new MyClass()。myFunction </em>在其他地方被使用，我们可以传递依赖关系来清楚地表达它，就像我们之前做的那样:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="8831" class="kx jq hi kt b fi ky kz l la lb">public void doSomething(MyClass myClass) {<br/> var a = 1;<br/> var b = 2;<br/> var c = myClass.myFunction(a, b);<br/> return a + b + c;<br/>}</span></pre><p id="f4d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.或者，如果<em class="lc"> myClass.myFunction </em>在同一个基类的子类中被调用，我们可以直接将<em class="lc"> myClass.myFunction </em>向上移动到基类中(或者提取到一个新的基类中，如果该函数定义了一个真正的公共行为)。</p><h1 id="ae69" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="677a" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">你应该总是避免静态函数，但是有时你仍然需要它们。在Java中，没有参数化的构造函数，你不能写两个相同类型的构造函数重载:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="21d0" class="kx jq hi kt b fi ky kz l la lb">public class Test {<br/>  public Test(String myFirstProperty) {<br/>    this.myFirstProperty = myFirstProperty;<br/>  }<br/>  public Test(String mySecondProperty) {<br/>    this.mySecondProperty = mySecondProperty;<br/>  }</span></pre><p id="7fa3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没有像Python中那样的命名参数的概念。但是您可以使用静态工厂函数来解决这个问题:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="0c58" class="kx jq hi kt b fi ky kz l la lb">public static Test ofMyFirstProperty(String myFirstProperty) {<br/>  Test test = new Test();<br/>  test.myFirstProperty = myFirstProperty;<br/>  return test;<br/>}</span></pre><p id="1275" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者使用一个构建器(它在背后使用一个静态函数)。除了这个和主入口点之外，我看不到任何其他合法的用法…</p></div></div>    
</body>
</html>