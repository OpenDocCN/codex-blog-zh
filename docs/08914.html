<html>
<head>
<title>Implement Kafka Topics Joiner With Golang 🔥</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Golang实现Kafka主题Joiner🔥</h1>
<blockquote>原文：<a href="https://medium.com/codex/implement-kafka-topics-joiner-with-golang-f8a9c046fcbe?source=collection_archive---------1-----------------------#2022-09-12">https://medium.com/codex/implement-kafka-topics-joiner-with-golang-f8a9c046fcbe?source=collection_archive---------1-----------------------#2022-09-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="02fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你好。今天，我们将在Go中构建一个Kafka生产者和消费者。泛型，Golang的一个新特性，将对我们有利。当在同一上下文中处理多种类型时，泛型非常有用。</p><h1 id="23dc" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">工具</h1><p id="a3f5" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">让我们评估一下我们的需求； ✨</p><ul class=""><li id="89b7" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated"><em class="kp">码头工人</em></li><li id="9c32" class="kg kh hi ih b ii kq im kr iq ks iu kt iy ku jc kl km kn ko bi translated"><em class="kp"> Golang 1.18或更新版本</em></li></ul><p id="6024" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以设置我们的文件夹层次结构，如下所示:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="98ca" class="le je hi la b fi lf lg l lh li">- producer<br/>  - producer.go<br/>  - main.go<br/>  - types.go<br/>- consumer<br/>  - main.go<br/>  - types.go<br/>  - connection.go<br/>main.go<br/>.gitignore<br/>config.yaml<br/>docker-compose.yaml</span></pre><p id="6548" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将建立的系统如下:<a class="ae lj" href="https://emojipedia.org/person-lifting-weights/" rel="noopener ugc nofollow" target="_blank">🏋️ </a></p><figure class="kv kw kx ky fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lk"><img src="../Images/4776446c8bca75ba958ceac4fb5f2efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*exBcB8vSysqTtpAfEf-9kw.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">golang-Kafka-生产者和消费者-加入-主题</figcaption></figure><h1 id="39e1" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">归档</h1><p id="45f3" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated"><code class="du lw lx ly la b">docker-compose</code>文件应该是这样的。对于这个项目，我们将Kowl、Zookeeper和Kafka添加到<code class="du lw lx ly la b">docker-compose</code>文件中。</p><figure class="kv kw kx ky fd ll"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="ddef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在需要用一些Kowl配置更新<code class="du lw lx ly la b">config.yaml</code>文件；</p><figure class="kv kw kx ky fd ll"><div class="bz dy l di"><div class="lz ma l"/></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">用于kowl的配置文件</figcaption></figure><p id="6f3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行Docker，在你喜欢的任何终端进入你的项目文件夹；</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="d539" class="le je hi la b fi lf lg l lh li">docker compose up -d</span></pre><p id="95b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几次重启后，一旦卡夫卡准备好了，Kowl就可以在<code class="du lw lx ly la b">localhost:8080</code>访问仪表盘。</p><figure class="kv kw kx ky fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mb"><img src="../Images/7c83530da21460f4910111dfb97765e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sUkqcH37jl9IabqtQF1ddw.png"/></div></div></figure><h1 id="9adc" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">编码</h1><p id="b248" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">好的。我们可以开始编码了。首先，有两个戈朗卡夫卡图书馆。<code class="du lw lx ly la b">segmentio/kafka-go</code>和<code class="du lw lx ly la b">confluent-kafka-go</code></p><p id="e850" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你必须安装C编译器，因为合流使用CGO。SegmentIO不使用CGO；而是可以直接使用Golang。在本文中，我将演示如何使用这两个库。</p><p id="6b48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在主分支中找到合流生产者，我在另一个分支中添加了SegmentIO生产者；</p><div class="mc md ez fb me mf"><a href="https://github.com/muhammedikinci/go-generics-with-kafka" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">GitHub-muhammedikinci/go-generics-with-Kafka</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">github.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt lq mf"/></div></div></a></div><div class="mc md ez fb me mf"><a href="https://github.com/muhammedikinci/go-generics-with-kafka/tree/segmentio-producer" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">GitHub-muhammedikinci/go-generics-with-Kafka at segment io-producer</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">github.com</p></div></div><div class="mo l"><div class="mu l mq mr ms mo mt lq mf"/></div></div></a></div><h2 id="471f" class="le je hi bd jf mv mw mx jj my mz na jn iq nb nc jr iu nd ne jv iy nf ng jz nh bi translated">生产者</h2><p id="b90f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">导航到producer文件夹后，在终端中输入以下命令；</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="6c34" class="le je hi la b fi lf lg l lh li">cd producer<br/>go mod init producer<br/>get get github.com/segmentio/kafka-go</span></pre><p id="b269" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在产品、类别和形象之间建立联系。<code class="du lw lx ly la b">types.go</code>文件如下所示:</p><figure class="kv kw kx ky fd ll"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="dab8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建我们的主题和数据。我们在连接卡夫卡，创造我们需要的主题；</p><figure class="kv kw kx ky fd ll"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="96e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以创建生产者对象并在<code class="du lw lx ly la b">main.go</code>文件中使用它。生产者向我们的话题推送消息。</p><figure class="kv kw kx ky fd ll"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="ceb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们运行生产者时；</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="e9b6" class="le je hi la b fi lf lg l lh li">go run .</span></pre><p id="dde6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">卡夫卡中的结果一定是这样的:</p><figure class="kv kw kx ky fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ni"><img src="../Images/753567bf14eb5f2391abf663c1f07403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jRfeRnhwzc7sM7vKqLDp6g.png"/></div></div></figure><p id="562b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将开始为消费者编码。我们将从我们创建的主题中接收消息，然后我们将尝试通过将它们与它们的键相关联来加入消息。我还想直观地展示我们正在做的事情。</p><figure class="kv kw kx ky fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es nj"><img src="../Images/0c1f2fdf8c7899450da4927d7dadf60a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-cZ_EN7kBUpSnt8SIKLdRQ.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">go-Kafka-join-tutorial-example-d B- structure</figcaption></figure><p id="b762" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有产品、图片和类别表。在我们的数据库结构中；一个产品可以有多张照片。但是，一个产品只能有一个类别。</p><h2 id="2a18" class="le je hi bd jf mv mw mx jj my mz na jn iq nb nc jr iu nd ne jv iy nf ng jz nh bi translated">消费者</h2><p id="ee0a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">让我们开始创造消费者吧！</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="4f5d" class="le je hi la b fi lf lg l lh li">cd consumer<br/>go mod init consumer<br/>get get github.com/segmentio/kafka-go</span></pre><p id="4789" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在消费者中，我们有相同的<code class="du lw lx ly la b">types.go</code>文件。可以从制作方复制&amp;粘贴过来。</p><p id="78b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在<code class="du lw lx ly la b">connection.go</code>文件中用如下的泛型创建了一个消费者结构</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="08c4" class="le je hi la b fi lf lg l lh li">type Consumer[T comparable] struct {<br/>  reader *kafka.Reader<br/>  dialer *kafka.Dialer<br/>  topic  string<br/>}</span></pre><p id="b94f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我为消费者放置了名为CreateConnection的接收器函数。这个函数连接到Kafka并返回给我们reader对象。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="e9ed" class="le je hi la b fi lf lg l lh li">func (c *Consumer[T]) CreateConnection() {<br/>  c.reader = kafka.NewReader(kafka.ReaderConfig{<br/>    Brokers:   []string{"localhost:9092"},<br/>    Topic:     c.topic,<br/>    Partition: 0,<br/>    MinBytes:  10e3, // 10KB<br/>    MaxBytes:  10e6, // 10MB<br/>    MaxWait:   time.Millisecond * 10,<br/>    Dialer:    c.dialer,<br/>  })<br/>  c.reader.SetOffset(0)<br/>}</span></pre><p id="4cdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我创建了另一个名为Read的接收函数。这个函数有两个参数:</p><ul class=""><li id="6453" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">模型—我们的桌子</li><li id="4b0a" class="kg kh hi ih b ii kq im kr iq ks iu kt iy ku jc kl km kn ko bi translated">回调—我们将另一个表进程传递到这里，用于合并表</li></ul><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="2dc8" class="le je hi la b fi lf lg l lh li">func (c *Consumer[T]) Read(model T, callback func(T, error)) {<br/>  for {<br/>    ctx, _ := context.WithTimeout(context.Background(), time.Millisecond*80)<br/>    message, err := c.reader.ReadMessage(ctx)</span><span id="bf80" class="le je hi la b fi nk lg l lh li"><br/>    if err != nil {<br/>      callback(model, err)<br/>      return<br/>    }</span><span id="dc32" class="le je hi la b fi nk lg l lh li">    err = json.Unmarshal(message.Value, &amp;model)<br/>    if err != nil {<br/>      callback(model, err)<br/>      continue<br/>    }<br/>    callback(model, nil)<br/>  }<br/>}</span></pre><p id="e5bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在寻找新的信息，直到卡夫卡的语境结束。当没有收到任何消息时，上下文将在80毫秒后被终止。</p><p id="6a86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在打开<code class="du lw lx ly la b">main.go</code>文件，创造消费者连接。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="9675" class="le je hi la b fi lf lg l lh li">dialer := &amp;kafka.Dialer{<br/>  Timeout:   10 * time.Second,<br/>  DualStack: true,<br/>}</span><span id="52e6" class="le je hi la b fi nk lg l lh li">productConsumer := Consumer[Product]{<br/>  dialer: dialer,<br/>  topic:  "producer-product-table-testing",<br/>}<br/>productConsumer.CreateConnection()</span><span id="a467" class="le je hi la b fi nk lg l lh li">imageConsumer := Consumer[Image]{<br/>  dialer: dialer,<br/>  topic:  "producer-image-table-testing",<br/>}<br/>imageConsumer.CreateConnection()</span><span id="b2e4" class="le je hi la b fi nk lg l lh li">categoryConsumer := Consumer[Category]{<br/>  dialer: dialer,<br/>  topic:  "producer-category-table-testing",<br/>}<br/>categoryConsumer.CreateConnection()</span></pre><p id="6f35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们开始在这里合并我们的表。我开始阅读卡夫卡的作品；</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="a8d6" class="le je hi la b fi lf lg l lh li">productConsumer.Read(Product{}, func(product Product, err error) {<br/>  collectedProduct := CollectedProduct{<br/>    ID:            product.ID,<br/>    Name:          product.Name,<br/>    Price:         product.Price,<br/>    OriginalPrice: product.OriginalPrice,<br/>    Images:        []string{},<br/>  }</span></pre><p id="aaef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第一个参数中，我说我想获得产品型号和回调参数，read函数向我们发送产品数据和错误(如果是)</p><p id="0cd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在回调函数中，这一次我开始读取图像，也开始加入。我们把来自卡夫卡的图像放入产品对象中</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="b981" class="le je hi la b fi lf lg l lh li">imageConsumer.Read(Image{}, func(image Image, err error) {<br/>  if product.ID == image.ProductID {<br/>    collectedProduct.Images = append(<br/>      collectedProduct.Images, image.URL,<br/>    )<br/>  }<br/>})</span></pre><p id="cad1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的主文件最后看起来如下</p><figure class="kv kw kx ky fd ll"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h2 id="f75a" class="le je hi bd jf mv mw mx jj my mz na jn iq nb nc jr iu nd ne jv iy nf ng jz nh bi translated">结果</h2><p id="bc1f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">如果我们运行消费者，结果将是这样的:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="3b64" class="le je hi la b fi lf lg l lh li">{0 product1 23 34  [<a class="ae lj" href="http://google.com/image1.jpg" rel="noopener ugc nofollow" target="_blank">http://google.com/image1.jpg</a> <a class="ae lj" href="http://google.com/image2.jpg" rel="noopener ugc nofollow" target="_blank">http://google.com/image2.jpg</a>]}<br/>{2 product2 23 34 Category1 [<a class="ae lj" href="http://google.com/image4.jpg" rel="noopener ugc nofollow" target="_blank">http://google.com/image4.jpg</a>]}<br/>{3 product3 23 34 Category3 [<a class="ae lj" href="http://google.com/image5.jpg" rel="noopener ugc nofollow" target="_blank">http://google.com/image5.jpg</a> <a class="ae lj" href="http://google.com/image6.jpg" rel="noopener ugc nofollow" target="_blank">http://google.com/image6.jpg</a> <a class="ae lj" href="http://google.com/image6.jpg" rel="noopener ugc nofollow" target="_blank">http://google.com/image6.jpg</a>]}<br/>{4 product4 23 34 Category1 []}<br/>{5 product5 23 34 Category2 []}<br/>{5 product5 23 34 Category2 []}</span></pre><p id="72e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，我们在每个循环中将图片和分类主题的偏移量设置为0。这意味着每个产品循环图像和类别主题都要从头开始。如果不希望这样，可以为旧的传递消息创建一个缓存机制。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="e34b" class="le je hi la b fi lf lg l lh li">imageConsumer.reader.SetOffset(0)<br/>categoryConsumer.reader.SetOffset(0)</span></pre><p id="d384" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不知道这种方式有多高效。在本文中，我只关注创建一个主题加入者系统。如果你想要更多的工具和效率，最好的选择是Kafka和Java</p><p id="b5e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！👋</p></div></div>    
</body>
</html>