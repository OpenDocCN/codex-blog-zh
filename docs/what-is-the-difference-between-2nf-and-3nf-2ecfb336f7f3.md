# 2NF 和 3NF 有什么区别？

> 原文：<https://medium.com/codex/what-is-the-difference-between-2nf-and-3nf-2ecfb336f7f3?source=collection_archive---------9----------------------->

![](img/33da646d394bf4d463630635b2d145be.png)

# 介绍

数据库中的规范化是组织数据以减少冗余的过程。主要思想是将一个较大的表分割成较小的表，并通过一个关系将它们连接起来。

但是，像你我这样的最终用户为什么要关心数据规范化呢？

要回答这个问题，我们首先需要了解如果我们的数据没有被规范化会发生什么。

# 为什么数据库规范化很重要？

让我们假设一家公司存储了它所有的数据，比如员工的详细信息、个人信息等等。，在单个表中。开发人员、数据库管理员(DBA)等最终用户可以访问这些数据。但是当多个最终用户同时与数据库交互时会发生什么呢？

例如，假设一名 DBA 正在更新数据库，在此过程中，一名开发人员在完全不知情的情况下对数据库执行了另一项操作。这些用户现在对数据库有了完全不同的看法。

当多个用户同时与数据库交互时，这种数据不匹配可以被称为异常。

这就是数据规范化介入的地方。它有助于避免数据不一致，并提供一种更有组织的方式来存储您的数据。因此，无论您是数据库管理员还是最终用户，您都需要了解您的数据是如何存储的，以及这对公司意味着什么。

既然我们对没有数据规范化会发生什么有了一个清晰的概念，那么让我们来看看可用于数据库管理(DBMS)的各种范式。

# 范式

## 第一范式(1NF)

如果一个关系不包含任何多值或复合属性，则称其为第一范式(1NF)。换句话说，表中的每个属性都必须保存一个原子值；否则，它违背了第一范式的规则。

让我们看一个例子:

![](img/8ed02d0648d91bfcd6659fbc544969cb.png)

表中的最后一列“租借的电影”包含几个值。该表的 1NF 版本如下所示:

![](img/b6c3c674153b979fdc31f710bffe864c.png)

现在您可能想知道，如果上述转换使现有行数加倍，数据规范化如何减少冗余？

这是因为我们采用了一个简单的场景，其中我们只考虑了一个表。在下一节中，我们将讨论第二范式，它对于数据规范化如何减少总体冗余更有意义。

## 第二范式(2NF)

如果满足以下条件，则关系为第二范式(2NF ):

1.  它是第一范式(1NF ),
2.  它没有部分依赖性

如果可以从候选关键字的真子集确定非关键字属性，则称该关系具有**部分依赖**。

让我们看一个例子来更好地理解这一点

![](img/ffc24f77d3cf3e98544cdc85a7913761.png)

上表遵循 1NF，因为每个属性保存一个值。但是，“教师年龄”是一个非键属性(因为它不能用作标识符——两个人可以有相同的年龄)，它依赖于“教师 ID”，后者是候选键的真子集。因此，此表呈现部分依赖关系，不遵循第二范式。

adobe 表格的 2NF 转换如下所示:

**表 1:**

![](img/6bef9b5ce0fb483587731a6b7f2c4173.png)

**表二:**

![](img/b63ca04528481b7cbff3c5342b3f1b52.png)

现在，我们不再需要在每次添加新课程时存储教师年龄。当您处理大量行时，这种分解减少了总体冗余。

让我们看看链中的下一个范式。

## 第三范式(3NF)

如果符合以下条件，则关系为第三范式(3NF)

1.  它在 2NF 中，
2.  对于所有非关键属性**，它没有**传递依赖**。**

如果 A->B and B-> C 是两个函数依赖，那么 A->C 是传递依赖。如果一个表有这样的间接依赖，那么它就不符合第三范式。

或者，如果这些条件之一为真，则具有函数依赖关系 A->B 的关系在 3NF 中

1.  a 是超级键
2.  B 是主要属性，即 B 是候选关键字的一部分

考虑下面的表格-

![](img/ed02cb1d3c9023294f8324ee50ed352f.png)

**主键:**员工 ID
**非键属性:**员工姓名、员工州、员工国家、员工邮政编码

1.  “员工邮政编码”依赖于“员工 ID”
2.  “雇员州”和“雇员国家”依赖于“雇员邮政编码”。'

因此，根据传递依赖的定义，“雇员州”和“雇员国家”依赖于“雇员 ID”因此，该表不在 3NF 中。我们需要把表分成两部分，最终的转换看起来像这样-

**表 1:**

![](img/76bcc5020fe261d908bc93ed4ad47574.png)

**表 2:**

![](img/d14bc4f1f7b95a7467732294d210ec2c.png)

# 第二范式(2NF)和第三范式(3NF)的区别

对三种范式的概述告诉我们一件事是肯定的——每一种范式都比前一种范式更严格。例如，在 2NF 中，非主属性不依赖于主(或键)属性，但是一个非主属性可以依赖于另一个非主属性。3NF 消除了这种可能性，因为非主属性只依赖于关系的超级键。

此外，2NF 处理部分依赖，而 3NF 专注于避免传递依赖。使用 2NF，我们看到重复组从表中删除了，而 3NF 完全减少了冗余。因此，3NF 是一种更强的规范化形式。

2NF 和 3NF 之间的直接比较有些误导，因为这不是苹果对苹果的比较。3NF 是 2NF 的更复杂的情况，因此，比较这些范式是不公平的。规范化的选择取决于您的数据和最终目标。如果你的目标是减少主要的冗余数据，选择 2NF。但是，如果您希望确保引用完整性，3NF 是更好的选择。