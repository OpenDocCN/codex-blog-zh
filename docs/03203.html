<html>
<head>
<title>Everything you need to know about Binary Search Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于二分搜索法树你需要知道的一切</h1>
<blockquote>原文：<a href="https://medium.com/codex/everything-you-need-to-know-about-binary-search-trees-e53760ff1f1c?source=collection_archive---------16-----------------------#2021-08-22">https://medium.com/codex/everything-you-need-to-know-about-binary-search-trees-e53760ff1f1c?source=collection_archive---------16-----------------------#2021-08-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4260" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">定义、操作以及如何从头开始实现它们。</h2></div><p id="0205" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">二分搜索法树(简称BST)是一种基本的数据结构。它们能够存储和组织可订购的价值。它们有大量的应用，可以用来实现像动态集合、字典和优先级队列这样的数据结构。</p><p id="6731" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章展示了我们如何定义和实现二分搜索法树及其操作。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/f43651c58ff5ee595c09684eee56db5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8B7yyCC9n3DXjTf1"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated"><a class="ae kj" href="https://unsplash.com/@whale?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马修·史密斯</a>在<a class="ae kj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="146f" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">定义和术语</h1><p id="2a4c" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">设(<em class="lo"> X </em>，≤)为全序集。</p><p id="880e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们从使用两个公理归纳定义二叉查找树的节点的概念开始:</p><p id="7178" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> (1) </strong>存在一个空节点，记为<code class="du lp lq lr ls b">Null</code>；</p><p id="2ad2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> (2) </strong>一个四元组<em class="lo"> N </em> = ( <em class="lo"> P </em>，<em class="lo"> x </em>，<em class="lo"> L </em>，<em class="lo"> R </em>)这样:</p><ul class=""><li id="e1b3" class="lt lu hi iz b ja jb jd je jg lv jk lw jo lx js ly lz ma mb bi translated"><em class="lo"> x </em>属于<em class="lo"> X </em>，</li><li id="c023" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated"><em class="lo"> P </em>、<em class="lo"> L </em>和<em class="lo"> R </em>为节点，</li><li id="d77b" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated">二进制搜索树属性得到满足(我们稍后会谈到它)</li></ul><p id="3e7e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">是一个节点。<em class="lo"> x </em>称为节点的键，<em class="lo"> P </em>称为父节点，<em class="lo"> L </em>为左子节点，<em class="lo"> R </em>为右子节点。</p><p id="9e22" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可能还想在每个节点中存储一个辅助值，但这不会改变我们实现操作的方式。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="1bd0" class="mh ks hi bd kt mi mj mk kx ml mm mn lb jg mo mp ld jk mq mr lf jo ms mt lh mu bi translated">树叶、树木、深度、高度和祖先</h2><p id="71f0" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">如果左孩子和右孩子都是空的，那么<em class="lo"> T </em>称为<strong class="iz hj">叶</strong>。如果父节点为空，则称为根节点。</p><p id="cade" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> A二叉查找树</strong> <em class="lo"> B </em>可以为空，或者由根节点<em class="lo"> R </em>来表征。我们说<em class="lo"> R </em>属于<em class="lo"> B </em>并且一个节点属于<em class="lo"> B </em>正好当它的父节点属于时。如果<em class="lo"> N </em>是一个节点，我们就把根节点为<em class="lo"> N </em>的树简称为<em class="lo"> N </em>。在本文的其余部分，我们将假设键在树中是惟一的。</p><p id="adcd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">树中节点的深度是它到根的距离。形式上，根的深度是0，如果一个节点(<em class="lo"> p </em>，<em class="lo"> v </em>，<em class="lo"> L </em>，<em class="lo"> R </em>)有深度<em class="lo"> x </em>，<em class="lo"> L </em>和<em class="lo"> R </em>有深度(<em class="lo"> x </em> + 1)。</p><p id="9bab" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将一棵树的<strong class="iz hj">高度</strong>定义为其最深叶子的深度，即所有叶子深度的最大值。</p><p id="6b94" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们说节点<em class="lo"> N </em>是节点<em class="lo"> M </em>的祖先如果<em class="lo"> N </em> = <em class="lo"> M </em>或<em class="lo"> N </em>是M的祖先的父节点如果<em class="lo"> N </em>是<em class="lo"> M </em>和<em class="lo"> N </em>的祖先我们说<em class="lo"> N </em>是<em class="lo"> M </em>的适当祖先</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="fcb2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这允许将树的类型定义为有区别的联合:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mv"><img src="../Images/cc746050c9c36ec819663467a46a2811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBrTUrnEXsh_3HXiPEGi6w.png"/></div></div></figure><h2 id="f4b8" class="mh ks hi bd kt mi mj mk kx ml mm mn lb jg mo mp ld jk mq mr lf jo ms mt lh mu bi translated">二分搜索法的财产</h2><p id="cbee" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">二进制搜索属性允许根据键的顺序来组织节点。给定一个非空节点(<em class="lo"> P </em>，<em class="lo"> x </em>，<em class="lo"> L </em>，<em class="lo"> R </em>)，说明对于树<em class="lo"> L </em>中的所有节点ℓ和树<em class="lo">r</em>中的所有节点<em class="lo"> R </em>，Key(ℓ) ≤ <em class="lo"> x </em>和<em class="lo"> x </em> ≤ Key( <em class="lo"> r 【T42</em></p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="b7e9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，下图显示了一个二叉查找树。它的根有4个键。它的叶子有调1，5和11。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mw"><img src="../Images/0195320c2cdf2597138a427566f01835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bI6W0iRSU321EUfL4St-tg.png"/></div></div></figure><p id="2cdf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是下面的二叉树不是二叉查找树:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mx"><img src="../Images/a1f028e79c5cbb756829da869176dcdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aWaEotlosqwbgawg7PtYQ.png"/></div></div></figure><p id="9ee9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是因为根的右子树包含一个key -1的节点，它小于根的键。</p><h1 id="30c1" class="kr ks hi bd kt ku my kw kx ky mz la lb io na ip ld ir nb is lf iu nc iv lh li bi translated">操作</h1><p id="06a8" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">二分搜索法采油树支持以下作业:</p><ul class=""><li id="2f9f" class="lt lu hi iz b ja jb jd je jg lv jk lw jo lx js ly lz ma mb bi translated"><em class="lo">行走，</em></li><li id="8958" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated"><em class="lo">插入，</em></li><li id="4b8e" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated"><em class="lo">搜索，</em></li><li id="7370" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated">正在搜索，</li><li id="c112" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated"><em class="lo">最小查询</em>和<em class="lo">最大查询</em>，</li><li id="e5f4" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated"><em class="lo">删除。</em></li></ul><h2 id="c7ab" class="mh ks hi bd kt mi mj mk kx ml mm mn lb jg mo mp ld jk mq mr lf jo ms mt lh mu bi translated">步行</h2><p id="28bb" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated"><em class="lo">走</em>或<em class="lo">遍历</em>一棵树意味着以某种顺序访问所有节点，并将它们传递给某个函数。</p><p id="6a45" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">行走算法有三种:按序、前序、后序。按序遍历访问一个节点(<em class="lo"> P </em>，<em class="lo"> x </em>，<em class="lo"> L </em>，<em class="lo"> R </em>)，方法是按序递归遍历它的左子树<em class="lo"> L </em>，然后打印(或做任何你想做的事情)键<em class="lo"> x </em>，最后按序递归遍历<em class="lo"> R </em>。它的实现如下:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mv"><img src="../Images/f466febca2063e59611ae840d0d3d4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WLRmT4b5bN9URaVbVgtspw.png"/></div></div></figure><ul class=""><li id="95f5" class="lt lu hi iz b ja jb jd je jg lv jk lw jo lx js ly lz ma mb bi translated">有序遍历按排序顺序打印二叉查找树的所有节点。它相对于树中的节点数在θ(N)时间内运行。</li><li id="3f39" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated"><code class="du lp lq lr ls b">walk_in_order</code>可以使用连续函数进行尾递归。</li><li id="23f3" class="lt lu hi iz b ja mc jd md jg me jk mf jo mg js ly lz ma mb bi translated">类似地，前序和后序遍历分别在遍历子树之前和之后打印当前键。</li></ul><h2 id="3742" class="mh ks hi bd kt mi mj mk kx ml mm mn lb jg mo mp ld jk mq mr lf jo ms mt lh mu bi translated">插入</h2><p id="ab65" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated"><em class="lo">将关键字</em>v插入BST包括以产生新二叉查找树的方式插入带有关键字<em class="lo"> v </em>的节点。</p><p id="1252" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们用来执行这个操作的过程创建了一个新的带有关键字<em class="lo"> v </em>的叶子N。为了找到N的父节点，我们从根到叶子访问树，选择适当的分支来维护二叉搜索树的属性。当我们找到一片叶子(我们称之为<em class="lo"> M </em>)时，<em class="lo"> M </em>成为<em class="lo"> N </em>的父节点。如果<em class="lo"> v </em> ≤ Key( <em class="lo"> M </em>)(或Key(<em class="lo">M</em>)&lt;<em class="lo">v</em>)，我们将<em class="lo"> M </em>的左子(或右子)设置为<em class="lo"> N. </em></p><p id="2df3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一个递归实现:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es nd"><img src="../Images/56fd09bf9746bd92a79b1d95040956cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16oLmgt6ilaPUMqYZ20rtQ.png"/></div></div></figure><p id="75ba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">子例程<code class="du lp lq lr ls b">findParent</code>递归调用自己，直到它到达一个空节点。这意味着前一个节点是一个叶子，而不仅仅是一个叶子:新节点的未来父节点。</p><p id="f6fd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦我们获得了父类，我们只需要执行一些处理。我们创建了树叶<em class="lo"> N </em>并且我们决定它是它的父节点的左子节点还是右子节点。</p><p id="7ea7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使前面的函数迭代并不难:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mv"><img src="../Images/1825cf63532de396caeb4353e3f40084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_5CfKrCYIeraFo1MvQCQ6g.png"/></div></div></figure><p id="29e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相对于树的高度，插入运行时间为θ(<em class="lo">H</em>)次。</p><h2 id="e81d" class="mh ks hi bd kt mi mj mk kx ml mm mn lb jg mo mp ld jk mq mr lf jo ms mt lh mu bi translated">搜索</h2><p id="f163" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">二分搜索法树允许我们根据树的高度在线性时间内搜索给定关键字的节点，如下面的伪代码所示。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mv"><img src="../Images/3e99e3d90ddd05fcdec0ecdd852f4897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1vEelDgt5QZWTToyVHKGAw.png"/></div></div></figure><p id="0754" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实现非常简单。我们检查当前节点是否包含目标键(在这种情况下，我们返回<code class="du lp lq lr ls b">true</code>)，如果目标键比当前节点的键小，则递归调用左边的子树，如果目标键比当前节点的键大，则递归调用右边的子树。如果我们在终止之前到达一个空节点，那么目标键不属于BST。</p><p id="7c7d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样的想法可以迭代实现:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mv"><img src="../Images/2c644bf789c0b112e8faebc22fc3a4e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMM-Qx0Hp-rx_7fNU1fAew.png"/></div></div></figure><h2 id="1a24" class="mh ks hi bd kt mi mj mk kx ml mm mn lb jg mo mp ld jk mq mr lf jo ms mt lh mu bi translated">最小和最大查询</h2><p id="658f" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">查找树中的最小(或最大)键类似于搜索。我们需要知道的就是走向最左边(或最右边)的子树，直到我们到达一个空节点。</p><p id="11ec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们实现<code class="du lp lq lr ls b">find-min</code>如下:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mv"><img src="../Images/4599227846d1c2ae4b5c164e1bee83e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JF0hjfH_9_M-xlHYv_BnHA.png"/></div></div></figure><p id="9450" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lp lq lr ls b">find-max</code>类似。</p><h2 id="6547" class="mh ks hi bd kt mi mj mk kx ml mm mn lb jg mo mp ld jk mq mr lf jo ms mt lh mu bi translated">查找节点的后继节点</h2><p id="a476" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">给定一棵树<em class="lo"> R </em>中的一个节点<em class="lo"> N </em> = ( <em class="lo"> p </em>，<em class="lo"> v </em>，<em class="lo"> L </em>，<em class="lo"> R </em>)，我们将<em class="lo"> R </em>中<em class="lo"> N </em>的后继节点定义为那些key严格大于<em class="lo"> v </em>的节点中key最小的节点。这样的节点不一定存在。</p><p id="52c2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果<em class="lo"> R </em>非空，那么<em class="lo"> N </em>的后继者是<em class="lo">R</em>的最小值</p><p id="81ac" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果<em class="lo"> R </em>为空，<em class="lo"> N </em>可能还有后继:它是其最近的右祖先，即左子树包含<em class="lo"> N </em>的最近祖先。</p><p id="85ca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，下面画的树中5的后继者是6: 4是5的右祖先，因为5在它的右子树中，所以我们向上移动到6，它是5的左祖先。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es ne"><img src="../Images/fb48471e725904ee6f600a5b7f793996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSwh2sXQCOJh8NRqVWrklA.png"/></div></div></figure><p id="3431" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更正式地说:</p><blockquote class="nf ng nh"><p id="bb65" class="ix iy lo iz b ja jb ij jc jd je im jf ni jh ji jj nj jl jm jn nk jp jq jr js hb bi translated">如果N有一个非空的右孩子，那么N的后继者是N的右孩子的最小值。</p><p id="5c1b" class="ix iy lo iz b ja jb ij jc jd je im jf ni jh ji jj nj jl jm jn nk jp jq jr js hb bi translated">如果N的右子代为空，那么N有后继当且仅当它有右祖先(在这种情况下，N的后继是它最近的右祖先)。</p><p id="fd87" class="ix iy lo iz b ja jb ij jc jd je im jf ni jh ji jj nj jl jm jn nk jp jq jr js hb bi translated"><strong class="iz hj">证明大纲:</strong></p><p id="4ffe" class="ix iy lo iz b ja jb ij jc jd je im jf ni jh ji jj nj jl jm jn nk jp jq jr js hb bi translated">如果R是非空的，设m是R的最小值。如果N是其父节点的左节点，那么根据二叉搜索树的性质，m小于N的所有祖先，因此它一定是N的后继节点。如果N是其父节点的右节点，那么每个祖先都小于它，所以m是后继节点。</p><p id="8b51" class="ix iy lo iz b ja jb ij jc jd je im jf ni jh ji jj nj jl jm jn nk jp jq jr js hb bi translated">现在假设R为空。设m表示N的最近的右祖先，如果它存在的话。那么根据右祖先的定义和BST属性，m大于N。如果m在其父的左子树中，那么没有m的祖先比它小。因为m是N的*最近*的右祖先，所以不是m的祖先的N的任何合适的祖先是N的左祖先，因此小于它。这足以证明m是n的后继。</p><p id="3cf8" class="ix iy lo iz b ja jb ij jc jd je im jf ni jh ji jj nj jl jm jn nk jp jq jr js hb bi translated">最后，假设R为空，N没有右祖先。R的所有子代都小于它(通过BST属性)。所有祖先都是左祖先，因此也小于N。这证明N没有后继者。</p></blockquote><p id="4311" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这允许我们编写以下实现:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mv"><img src="../Images/0cce3cabbb809a089eb86b94590e413e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Twrpnx4xCfuVRNJ_7ADMoQ.png"/></div></div></figure><p id="83b1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果<code class="du lp lq lr ls b">tree</code>没有后继者，则返回<code class="du lp lq lr ls b">NULL</code>。</p><p id="b7f1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行时间为O( <em class="lo"> H </em>)，最坏情况下为θ(<em class="lo">H</em>)。</p><h2 id="06b2" class="mh ks hi bd kt mi mj mk kx ml mm mn lb jg mo mp ld jk mq mr lf jo ms mt lh mu bi translated">删除节点</h2><p id="d21d" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">我们讨论的最后一个操作比前几个更棘手。给定一个二叉查找树<em class="lo"> R </em>和一个节点<em class="lo"> N </em>，目标是生成一个新的二叉查找树<em class="lo">R’</em>，它包含除<em class="lo"> N </em>之外的<em class="lo"> R </em>的所有节点。</p><h2 id="556f" class="mh ks hi bd kt mi mj mk kx ml mm mn lb jg mo mp ld jk mq mr lf jo ms mt lh mu bi translated">重新移植</h2><p id="5c16" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">我们做的第一件事是声明一个过程<code class="du lp lq lr ls b">repot</code>，用一个节点替换另一个节点。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mv"><img src="../Images/7c839af4c3aded48a484a37ca9b9706e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYocGPTgdI5kJ8cG5lRMiw.png"/></div></div></figure><p id="b714" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第2行到第6行要求<code class="du lp lq lr ls b">next</code>的父母忘记他们的孩子(我们将在适当的时候给<code class="du lp lq lr ls b">next</code>提供新的父母)。</p><p id="9653" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果<code class="du lp lq lr ls b">previous</code>没有父节点(即<code class="du lp lq lr ls b">tree</code>的根节点)，那么我们只需将<code class="du lp lq lr ls b">next</code>赋值给<code class="du lp lq lr ls b">tree</code>。</p><p id="44d6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">否则，<code class="du lp lq lr ls b">previous</code>的父节点将成为<code class="du lp lq lr ls b">next</code>的父节点(第12行)，我们将<code class="du lp lq lr ls b">next</code>分配给<code class="du lp lq lr ls b">previous</code>的适当子节点(第13到17行)。</p><h2 id="0db7" class="mh ks hi bd kt mi mj mk kx ml mm mn lb jg mo mp ld jk mq mr lf jo ms mt lh mu bi translated">删除</h2><p id="339a" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">如果<em class="lo"> N </em>的两个子节点中至少有一个为空，那么我们调用<code class="du lp lq lr ls b">repot N C</code>，其中<em class="lo"> C </em>是<em class="lo"> N </em>的左子节点，如果它的右子节点为空，则它的右子节点为空。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mv"><img src="../Images/5a17f1ca421af5cb414038c6db9f005d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gr9vHLwCNLqfz7wT_b-Ihg.png"/></div></div></figure><p id="f05b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑下面的例子，我们想要删除节点<em class="lo"> y </em>。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es nl"><img src="../Images/348d45ee4284f16ed52f564adc83f883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UwK-QmZhuN1Fp_Th5Vz1zw.png"/></div></div></figure><p id="7ee6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">满足<code class="du lp lq lr ls b">delete</code>(第2行)的第一个条件。当我们调用<code class="du lp lq lr ls b">repot y NULL</code>时，条件行13满足，那么<em class="lo"> y </em>的父代的左子代，即<em class="lo"> x </em>。右，变为空。然后我们可以从记忆中抹去<em class="lo"> y </em>。更新后的树如下所示:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es nm"><img src="../Images/8dae3fae174ed07b10952fdbbd945fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J2SYbuPWLwkWPk0fRMAz8A.png"/></div></div></figure><p id="4992" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设现在N有两个非空的孩子。在这种情况下，我们将节点<em class="lo"> N </em>替换为它的后继节点。例如，假设下图表示输入树，我们想要删除带有键17的节点。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es nn"><img src="../Images/578d45274205549d97b043386f0a3f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PlEgh2So8AzqBR-wXnAgZA.png"/></div></div></figure><p id="8633" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">目标是用它的后继者20代替17。</p><p id="a1e0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一步是使用函数<code class="du lp lq lr ls b">repot</code>连接20到23的右子树。这给出了以下临时树:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es no"><img src="../Images/fad8a7380f62345e52851324a55cb9f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*be08IOlHEbbaSW8MrR5gBg.png"/></div></div></figure><p id="c299" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们将17的右子树连接到20:我们设置了<code class="du lp lq lr ls b">20.Right &lt;- 17.Right</code>和<code class="du lp lq lr ls b">20.Right.Parent &lt;- 20</code>。</p><p id="41d9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">20现在有了合适的右子树。我们需要设置它的左子树和它的父树。为此，我们调用<code class="du lp lq lr ls b">repot 17 20</code>，然后将17的左子树连接到20: <code class="du lp lq lr ls b">20.Left &lt;- 17.Left</code>和<code class="du lp lq lr ls b">20.Left.Parent &lt;- 20</code>。</p><p id="06c2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，如果我们想要删除的节点<em class="lo"> N </em>的后继节点<em class="lo"> S </em>是它的右子节点，那么我们只需要将<em class="lo"> S </em>重新移植到<em class="lo"> N </em>中。</p><p id="556e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是最终的实现:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mv"><img src="../Images/b9a4fc860e620507f3fd58ca0df2862e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lS2mPW4NaR_EIPQinfyXWw.png"/></div></div></figure><h1 id="b445" class="kr ks hi bd kt ku my kw kx ky mz la lb io na ip ld ir nb is lf iu nc iv lh li bi translated">结论:高度上的一句话</h1><p id="bf52" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">我们讨论的大多数操作的运行时复杂性与树的高度成正比。具有<em class="lo"> n </em>个节点的树的高度渐近地在log <em class="lo"> n </em>和<em class="lo"> n </em>之间。如果我们按照排序的顺序插入节点，我们会得到一个一元树:节点的高度是θ(<em class="lo">n</em>)，所以使用树而不是列表没有任何好处。假设现在您有一组<em class="lo"> n </em>键，并通过以随机顺序插入所有键来构建BST。恰好树的期望高度是最优的:O(log_2 (n))。还存在自平衡二分搜索法树，当我们插入和删除节点时，它保持它们的高度最小。红黑树是自平衡二分搜索法树的一个例子。它们将是未来文章的主题。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="8cce" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">支持我！</h1><p id="3a91" class="pw-post-body-paragraph ix iy hi iz b ja lj ij jc jd lk im jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">如果您觉得这篇文章很有帮助，请考虑关注我，帮助我达到继续加入中型合作伙伴计划所需的100名关注者的门槛。这是免费的，真的很有帮助。</p><p id="81d0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也可以使用我的推荐链接订阅Medium: <a class="ae kj" rel="noopener" href="/plans?subscribeToUserId=b705ec524bd3&amp;source=entity_driven_subscription-b705ec524bd3------------------------------------">成为会员</a>。你可以访问Medium上所有会员专用的文章，你的会员费将直接支持我。</p><p id="4c3b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">🐙</p></div></div>    
</body>
</html>