<html>
<head>
<title>Two Resampling Approaches to Assess a Model: Cross-validation and Bootstrap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">评估模型的两种重采样方法:交叉验证和自举</h1>
<blockquote>原文：<a href="https://medium.com/codex/two-resampling-approaches-to-assess-a-model-cross-validation-and-bootstrap-794916d37212?source=collection_archive---------2-----------------------#2021-06-26">https://medium.com/codex/two-resampling-approaches-to-assess-a-model-cross-validation-and-bootstrap-794916d37212?source=collection_archive---------2-----------------------#2021-06-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c2b4" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">它们是如何工作的以及R中的例子</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ab3eb38e2caff043c96f5756dc35dca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oQGmUEMAvwlBz8Jl"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">凯利·西克玛在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8a82" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了评估模型的性能，您可以收集更多的观察值，并根据新数据测试您的模型。但是根据项目的不同，获得新的观察结果可能是昂贵的或者是不可能的。在这种情况下，您可以对已有的数据集使用重采样。两种最常用的重采样方法是交叉验证和自举。</p><h1 id="675f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak">交叉验证</strong></h1><p id="3487" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">通过交叉验证，您可以通过估计测试误差来执行<strong class="jq hj"> <em class="lh">模型评估</em> </strong>，或者通过基于每个模型的测试误差选择灵活性级别来执行<strong class="jq hj"> <em class="lh">模型选择</em> </strong>。CV的基本思想是</p><blockquote class="li"><p id="c832" class="lj lk hi bd ll lm ln lo lp lq lr kj dx translated">1.将数据集分成训练集和验证集</p><p id="70be" class="lj lk hi bd ll lm ln lo lp lq lr kj dx translated">2.使用训练集来拟合模型</p><p id="f56b" class="lj lk hi bd ll lm ln lo lp lq lr kj dx translated">3.使用验证集评估模型的性能</p></blockquote><p id="c228" class="pw-post-body-paragraph jo jp hi jq b jr ls ij jt ju lt im jw jx lu jz ka kb lv kd ke kf lw kh ki kj hb bi translated">基于这一思想，验证集方法、留一法CV和k倍CV在细节上有所不同。</p><h2 id="a377" class="lx kl hi bd km ly lz ma kq mb mc md ku jx me mf kw kb mg mh ky kf mi mj la mk bi translated"><strong class="ak">验证设置方法</strong></h2><p id="2582" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">为了从一个数据集中得到一个训练集和验证集，它随机地将一个数据集分成两部分——通常50:50用于训练和验证，但是这个比例是可以调整的。对于评估指标，您可以对定量变量使用均方误差(MSE ),或者对定性变量使用大量错误分类的观察值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ml"><img src="../Images/917d1c031e7d5904288a543d0a3a6ea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUtzvZ_QGVmHCe_EpXpFyg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">验证集方法的工作原理</figcaption></figure><p id="38eb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如您所见，实现验证集方法是小菜一碟。然而，这是有代价的。因为训练和验证集中的内容是随机确定的，所以测试错误可能会因每个集中包含哪些观察值而有很大差异。因此，测试误差的验证估计变化很大。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mm"><img src="../Images/72cd3ede2040b05ccb5c4e1c1593c38c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c2jBL9VVjaaoXTl6vIDrBg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">显示高度变化的验证估计值的一维图。该数据集由Manish Kumar收集，该模型根据汽车在高速公路上的mpg预测汽车价格(1000美元)。</figcaption></figure><p id="27aa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">验证集方法的另一个限制来自其训练集的大小。当给定的数据集很小时，统计方法往往表现不佳。由于验证集方法只使用全部观察值的一半，它可能会高估测试错误率。留一法简历就是解决这些问题的。</p><h2 id="23af" class="lx kl hi bd km ly lz ma kq mb mc md ku jx me mf kw kb mg mh ky kf mi mj la mk bi translated"><strong class="ak">留一交叉验证(LOOCV) </strong></h2><p id="54b4" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">与验证集方法不同，LOOCV使用单个观察值作为验证集，并将所有剩余的- <em class="lh">即n-1 - </em>作为训练集。然后，通过选择不同的值作为验证集，重复n次拟合和评估。所以在迭代结束时，它有n个测试错误。这些的平均值成为LOOCV估计值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mn"><img src="../Images/a472eefc7b893368828d98128a224afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l3pKEE8RkDq5OLIu7LvJeg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">LOOCV是如何工作的</figcaption></figure><p id="4d67" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与验证集方法相比，LOOCV使用几乎所有的观察值来拟合模型，并重复拟合。因此，不太可能高估测试错误率。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mo"><img src="../Images/b02a6cf6eaa0a24fcebf1c79722a552f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZMQfXL-6eTa69lXFKAjTQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">10次重复loocv，表明loocv估计值是无偏的</figcaption></figure><p id="59cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，因为它执行n次拟合过程，所以实现起来可能很昂贵。所以k倍CV给出了一个验证集的变化来改进。</p><h2 id="7f66" class="lx kl hi bd km ly lz ma kq mb mc md ku jx me mf kw kb mg mh ky kf mi mj la mk bi translated"><strong class="ak"> K倍交叉验证</strong></h2><p id="ed45" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">使用k倍CV，首先选择k的值。然后，将一个数据集分成k个集合。类似于LOOCV，第一组成为验证组，其余的成为训练组。在拟合和评估模型之后，您移动到第二组并重复该过程。与LOOCV不同，k倍CV重复k次，k个测试误差估计值的平均值成为k倍CV估计值。所以在某种程度上，当k=n时，LOOCV是k倍CV的一个特例</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mn"><img src="../Images/85c082eaba25cb020677f4d18fceeb7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vObAy1PRUm6ULk_nxxcBcg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">k-fold CV如何工作</figcaption></figure><p id="cdfc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与LOOCV相比，k-fold CV的一个明显优势是，k-fold CV在计算上更好，因为它执行的迭代次数更少。另一个优势在于偏差-方差的权衡。因为LOOCV的训练集包括几乎整个数据集，LOOCV给出了一个无偏的估计。也就是说，LOOCV估计很可能等于给定数据集的真实测试误差。与LOOCV相比，k-fold CV对训练集使用更少的观察值。因此，与LOOCV相比，k倍具有较少的相关训练集和较高的有偏估计。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mp"><img src="../Images/4450cf970da1c55d543dbec2ed75fecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8rOktpyBoUGvAa-9IQCFBQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">10重复k倍cv，表明k倍估计值比100倍cv估计值偏多一点</figcaption></figure><p id="d9cf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，当我们评估一个模型时，偏见并不是唯一的考虑因素。我们还应该通过评估方差来考虑一个模型如何在一个全新的数据集上执行。由于LOOCV的所有训练集与整个数据集几乎相同，因此它们彼此高度重叠。这导致产生高度相关的输出。并且因为LOOCV估计是基于这些输出计算的，所以LOOCV估计往往具有高方差。</p><p id="de83" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与LOOCV的训练集相比，k-fold CV的训练集重叠较少。因此，输出的相关性较低，k倍CV估计值的方差低于LOOCV估计值。根据经验，k=5和k=10既不会出现极高的偏差，也不会出现方差。</p><h2 id="1329" class="lx kl hi bd km ly lz ma kq mb mc md ku jx me mf kw kb mg mh ky kf mi mj la mk bi translated"><strong class="ak">交叉验证模式选择</strong></h2><p id="5e2f" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">上面的所有代码示例都使用交叉验证方法来评估模型。然而，正如我在开始时提到的，您也可以使用交叉验证来选择模型的灵活性级别。您只需要存储交叉验证估计值，以便以后进行比较。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mq"><img src="../Images/f792eb6d371aa71376da9d9a715c0329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*rFmaM9C9PFsYG9Xw0sYr4A.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">显示交叉验证如何用于模型选择的图表</figcaption></figure><p id="3126" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在选择灵活性级别时，您需要记住一件事。由于较低的cv估计值意味着模型在预测方面更好，您可能认为选择具有最低cv估计值的模型就是答案。然而，盲目选择具有最小cv估计值的模型可能会导致过度拟合问题。</p><p id="f77d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从上图可以看出，最小值出现在6次方。然而，3次方相当低。那么你应该选择哪一个呢？</p><div class="iy iz ja jb fd ab cb"><figure class="mr jc ms mt mu mv mw paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/1851c5573648ababb02656eb138297a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*eYDwl-3upkpORtsBxuw6YQ.png"/></div></figure><figure class="mr jc mx mt mu mv mw paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><img src="../Images/90da97990ec4f486312e631ae7e2dc7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*1ynYu1yoWOMnnEM-nZkfRw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx my di mz na translated">显示具有最低cv估计值的模型如何导致过度拟合的图。(左)带有多边形(3)的模型/(右)带有多边形(6)的模型</figcaption></figure></div><p id="0322" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">两条线中间没有巨大的区别。然而，在右图的右下端，您可以看到红线与点的趋势完全相似。这表明具有6次方的模型与数据集过度拟合。因此，对于这个数据集，它会给出一个准确的结果，但是对于一个全新的数据集，它的性能会很差。考虑到这一点，在选择交叉验证的灵活性级别时，您应该意识到过度拟合问题。</p><h1 id="0b1a" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated"><strong class="ak">自举</strong></h1><p id="47ad" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">Bootstrap是一种通过替换从数据集中模拟获取新样本的方法，这样观测值就不会用完。使用这些新的bootstrap样本，bootstrap通过计算估计值、标准误差和置信区间来评估您选择的样本统计数据 的<strong class="jq hj"> <em class="lh">准确性。</em></strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nb"><img src="../Images/6191f3af949abb2bc51c1a21c5571df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*CN8g3bMuR5tR74x85R9NXw.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">引导程序如何工作</figcaption></figure><h2 id="310e" class="lx kl hi bd km ly lz ma kq mb mc md ku jx me mf kw kb mg mh ky kf mi mj la mk bi translated"><strong class="ak">利弊</strong></h2><p id="f34f" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">由于方法简单，bootstrap具有广泛的适用性。因此，如果您能提供一个返回样本统计值的函数，您可以选择任何想要的样本统计值。例如，假设您对上面使用的数据集中汽车价格的第一个和第三个四分位数感到好奇。您只需要创建一个函数来返回这些统计数据，在boot()中从boot库中为它们提供一个数据集，并指定您将获取多少引导程序样本。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nc"><img src="../Images/44a8079d7d86e31bffa1e6b5ecd24f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9rgILS2ySwxsSkb6PcwGoQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在R中执行bootstrap以获得四分位数的标准误差</figcaption></figure><p id="a5c2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">正如您所看到的，boot()提供了您在“原始”列下选择的样本统计的估计值，并在“标准”列下提供了每个统计的标准误差。错误”栏。因此，通过这些输出，您可以评估样本统计的准确性。如果您需要一个置信区间，您只需要将boot()作为boot.ci()中的一个参数进行传递。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nd"><img src="../Images/e424a0d747f865c2f5a99963cfecd4df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*luMbvdHsEMd1-qwlI1ZQRg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">得到R中的bootstrap置信区间</figcaption></figure><p id="3002" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在5种bootstrap中，BCa - <em class="lh">偏差修正和加速</em> -置信区间一般是首选。然而，当提供少量引导样本时，BCa可能变得不稳定。关于这些bootstrap置信区间的更详细的解释可以在杰里米·奥尔布赖特的<a class="ae jn" href="https://blog.methodsconsultants.com/posts/understanding-bootstrap-confidence-interval-output-from-the-r-boot-package/" rel="noopener ugc nofollow" target="_blank"><em class="lh"/></a>帖子中找到。</p><p id="6a30" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一个优势来自它的非参数方法。因为非参数bootstrap不假设模型分布，所以它可以给出比不正确假设的方法更准确的标准误差估计。尽管bootstrap似乎是许多情况下的解决方案，但它有其局限性。</p><p id="0afe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为非参数bootstrap是从单个数据集中进行重采样，所以它只能获得数据集中的值。因此，如果给定一个小的数据集——10个或更少的观察值——或者一个数据集不具有代表性，就会产生问题。</p><h1 id="72b1" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">综上</h1><p id="20f6" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">当你阅读时，交叉验证和引导告诉你不同的事情。交叉验证为评估模型在新数据上的表现提供了交叉验证估计值。此外，您可以使用交叉验证评估来评估哪个模型优于其他模型。另一方面，bootstrap告诉我们一个样本统计与真实总体统计相比有多精确。您还可以将系数设置为样本统计数据，以使用bootstrap评估模型的准确性。因此，在交叉验证和bootstrap之间选择使用哪种方法取决于您的研究目的。</p></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><h1 id="0a57" class="kk kl hi bd km kn nl kp kq kr nm kt ku io nn ip kw ir no is ky iu np iv la lb bi translated">参考</h1><p id="524a" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">[1]迈克尔·切尔尼克。"自举的利与弊。"<em class="lh">交叉验证</em>，2017年5月20日，stats . stack exchange . com/questions/280725/pros-and-cons-of-bootstrapping。</p><p id="b733" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">[2]鲍勃·德兰斯菲尔德。"参数或非参数自举？"<em class="lh">参数或非参数Bootstrap </em>，influency points . com/Training/nonparameter-or-parameter _ Bootstrap . htm</p><p id="2a07" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">[3]弗罗斯特，吉姆。"用一个例子介绍统计中的自举."<em class="lh">吉姆统计</em>，2020年6月12日，statisticsbyjim.com/hypothesis-testing/bootstrapping/.</p><p id="ec73" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">[4]霍尔迪。" r/Statistics——Bootstrap vs . Cross-Validation:哪一个使用得更频繁，为什么？"<em class="lh"> Reddit </em>，2015，<a class="ae jn" href="http://www.reddit.com/r/statistics/comments/2wao3u/bootstrap_vs_crossvalidation_which_is_used_more/." rel="noopener ugc nofollow" target="_blank">www . Reddit . com/r/statistics/comments/2 wao3u/bootstrap _ vs _ cross validation _ which _ is _ used _ more/。</a></p><p id="32ef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">[5]詹姆斯，加雷斯。<em class="lh">统计学习简介:在r中的应用</em>。斯普林格，2021。</p></div></div>    
</body>
</html>