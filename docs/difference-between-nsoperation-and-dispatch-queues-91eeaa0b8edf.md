# n 操作队列和调度队列之间的差异

> 原文：<https://medium.com/codex/difference-between-nsoperation-and-dispatch-queues-91eeaa0b8edf?source=collection_archive---------1----------------------->

![](img/f404767fa09038df60a0955259f414bb.png)

*并发性*意味着多个计算同时发生。无论我们喜欢与否，并发在现代编程中无处不在:

*   网络中的多台计算机
*   在一台计算机上运行多个应用程序
*   一台计算机中的多个处理器(今天，通常在一个芯片上有多个处理器内核)

事实上，并发在现代编程中是必不可少的:

*   网站必须同时处理多个用户。
*   移动应用程序需要在服务器上进行一些处理(“在云端”)。
*   图形用户界面几乎总是需要不打断用户的后台工作。例如，当您还在编辑 Java 代码时，Eclipse 就会编译它。

在未来，能够进行并发编程仍然很重要。处理器时钟速度不再增加。相反，每一代新的芯片都有更多的内核。因此，在未来，为了让计算运行得更快，我们必须将计算分成并发的部分。

所以在开始写任何并发代码之前，先想想为什么需要并发，需要用哪个 API 来解决这个问题？在 iOS 中，我们有不同的 API 可以使用。在本教程中，我们将讨论两个最常用的 API——操作和调度队列。

# 关于并发，你需要知道什么？

> 在本教程中，我将解释理解并发性所需的一切，并消除您对并发性的所有恐惧。首先，我们建议看一下块(Swift 中的闭包),因为它们在并发 API 中被大量使用。然后我们将讨论调度队列和操作队列。我将向您介绍每个并发概念、它们的区别以及如何实现它们。

# 大中央调度

在 iOS 中使用 Grand Central Dispatch 在 iOS 应用程序中引入并发性和并行性，以便在后台执行多个繁重的任务，从而实现应用程序使用的流畅体验，因为主线程不受繁重的后台任务的影响。

GCD 是在 iOS 4 中引入的，以避免任务的串行执行，因为串行执行可能会很痛苦。

串行执行不是一件理想的事情，因为一个任务正在等待处理器，直到另一个任务完成。如果当前执行的任务很重，而等待的任务很小，那该怎么办？因此，我们得到的是大量等待我们的小任务，直到大任务完成。

# 调度队列

调度队列是在应用程序中异步并发执行任务的一种简单方法。它们是你的应用程序以块(代码块)的形式提交任务的队列。有两种调度队列:(1)串行队列，(2)并发队列。在讨论区别之前，您需要知道分配给两个队列的任务是在不同的线程中执行的，而不是在创建它们的线程中执行的。换句话说，您创建代码块并提交给主线程中的调度队列。但是所有这些任务(代码块)将在单独的线程中运行，而不是在主线程中运行。

# 什么是串行队列？

串行调度队列一次只执行一项任务。串行队列通常用于同步对特定值或资源的访问，以防止发生数据竞争。

# 什么是并发队列？

并发队列允许我们同时执行多个任务。任务总是按照它们被添加的顺序开始，但是它们可以按照不同的顺序完成，因为它们可以并行执行。任务将在由调度队列管理的不同线程上运行。同时运行的任务数量是可变的，取决于系统条件。

# 演示项目

在我们的演示项目中，我们有一个下载器来下载一些图像，向您展示 GCD 和 Operation 之间的区别。

首先创建一个简单的应用程序。基于你的知识，你可以选择故事板或 SwiftUI。在这个演示中，我们继续使用故事板界面。

![](img/7258e9cfaa21b28f04a11318dab1d208.png)

创建项目后，打开 Main.storyboard 并放置四个 UIImageView、一个 UISlider 和 UIButton，如下图所示。

![](img/2c33919528b332217490fc00215c1152.png)

现在为图像和下载按钮和滑块的动作创建出口。

为了下载图片，我写了一个简单的下载器，放了 4 个图片 url 来下载并显示在我们的 UIImageViews 中。

![](img/2bd79881d45f7471795c70ce2845a04c.png)

首先，我编写了 *regularDownload* 函数，并在下载按钮按下时调用这个函数。你会发现你不能改变滑块的值，因为所有的图片都是在主线程中下载的。

![](img/534c8a586edd15236d670d97c5fbea21.png)

每个下载器被认为是一个任务，所有的任务现在都在主队列中执行。现在让我们参考一个全局并发队列，它是默认的优先级队列。

![](img/61f95efaa34120c84b716633e0dc018e.png)

我们首先使用 *DispatchQueue.global* 获得对默认并发队列的引用，然后在块中提交一个任务，下载第一个图像。一旦图像下载完成，我们向主队列提交另一个任务，用下载的图像更新图像视图。换句话说，我们将图像下载任务放在后台线程中，但是在主队列中执行与 UI 相关的任务。

如果您对其余的图像进行同样的操作，您的代码应该如下所示:

![](img/56a68d745e682c5e2a5e57a2cc6cea62.png)

现在，如果你用 *concurrentQueue* 功能更改 *regularDownload* ，应用程序应该会运行得更快，并且在下载图像时，你可以更改滑块的值。

# 使用串行调度队列

这一次我们将使用一个串行队列来下载图像。使用串行队列时，您需要密切注意您引用的是哪个串行队列。每个应用程序都有一个默认的串行队列，它实际上是 UI 的主队列。所以请记住，当使用串行队列时，您必须创建一个新队列，否则您将在应用程序试图执行更新 UI 的任务时执行您的任务。这将导致破坏用户体验的错误和延迟。更改后，代码将如下所示:

![](img/56266de4c416efcc1aeae67a21eaf3dc.png)

现在，如果您将 *concurrentQueue* 更改为serialQueue 函数，应用程序应该会像以前一样工作，但您应该注意两件事:

1.  与同时排队的情况相比，下载图像需要较长的时间。原因是我们一次只加载一个图像。每个任务在执行前都要等待前一个任务完成。
2.  图像按照图像 1、图像 2、图像 3 和图像 4 的顺序加载。这是因为队列是一个串行队列，一次执行一个任务。

# 操作队列

与 GCD 不同，操作队列不符合先进先出的顺序。以下是操作队列与调度队列的不同之处:

1.  在操作队列中，您可以为操作设置优先级，还可以为操作添加相关性，这意味着您可以定义某些操作仅在其他操作完成后执行。
2.  操作队列并发运行，如果您想将它们用作串行队列，您应该通过添加依赖关系来处理它。

现在让我们重写我们的项目演示，但这次我们将使用 OperationQueues。首先在 ViewController 类中声明下面的变量:

```
**var** queue = OperationQueue()
```

接下来，添加 *operationQueue* 方法，并将其更改为 serialQueue:

![](img/f73af4b4b0bda9c301c616be4e01bfbc.png)

正如您在上面的代码中看到的，您使用方法 *addOperation* 创建一个带有给定块的新操作(或者我们在 Swift 中称之为闭包)。很简单吧？为了在主队列中执行任务，而不是像使用 GCD 时那样调用 DispatchQueue.main.async，我们可以从 operation queue(operation queue . main)中执行相同的操作，并在主队列中提交要执行的操作。

你可以运行应用程序进行快速测试。如果代码输入正确，应用程序应该能够在后台下载图像，而不会阻止用户界面。

在前面的例子中，我们使用 addOperation 方法在队列中添加操作。让我们看看如何使用 BlockOperation 来做同样的事情，但同时，给我们更多的功能和选项，如设置完成处理程序。

![](img/e92d5d1cea10b618d3b8f8047409dc82.png)

现在，当操作完成时，将调用完成处理程序。为了简单起见，我们只记录一条简单的消息来表明操作已经完成。如果您运行演示，您会在控制台中看到类似这样的内容:

```
**Operation 4 completed****Operation 3 completed****Operation 1 completed****Operation 2 completed**
```

# 取消操作

正如我之前提到的，BlockOperation 允许您管理操作。现在让我们看看如何取消操作。为此，首先在下载按钮下面添加另一个按钮，并将其标题设置为取消。为了显示取消操作，我们在操作#2 和操作#1 之间建立了相关性，并在操作#3 和操作#2 之间建立了另一个相关性。现在，操作#2 将在操作#1 完成后开始，对于其他相关性也是如此。现在，为了取消操作，您需要调用 *cancelAllOperations()。*

```
**@IBAction** **func** cancelBtnPressed(**_** sender: **Any**) { **self**.queue.cancelAllOperations()}
```

现在添加依赖项，并更改操作#1 的完成块，如下所示:

```
operation2.addDependency(operation1)operation3.addDependency(operation2)operation1.completionBlock = { print("Operation 1 completed, cancelled: \(operation1.isCancelled)")}
```

现在，如果您运行该项目并查看结果，您会看到操作#1 或#4 将首先执行，在操作#1 完成后，操作#2 执行，在操作#2 完成后，您将看到操作#3 执行。

点击下载按钮后，按取消按钮。这将在操作#1 完成后取消所有操作。事情是这样的:

取消永远不会影响操作#1，但是如果您足够快地点击取消按钮，操作#2 被取消并且图像#2 不被下载，因此由于操作#2 和#3 之间的相关性，第三个图像也不被下载，但是操作#4 没有任何相关性并且并发运行。

我希望您更好地理解了 Swift 中 GCD 和操作队列之间的区别，并能够在您未来的项目中使用和集成它们。

你也可以在这个 [***并发库***](https://github.com/shayan77/Concurrency) 找到完整的源代码。