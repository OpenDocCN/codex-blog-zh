<html>
<head>
<title>Divide and Conquer Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分治算法</h1>
<blockquote>原文：<a href="https://medium.com/codex/divide-and-conquer-algorithm-f766640ef038?source=collection_archive---------5-----------------------#2021-03-21">https://medium.com/codex/divide-and-conquer-algorithm-f766640ef038?source=collection_archive---------5-----------------------#2021-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d06a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顾名思义，分而治之的方法是把给定的问题分成几个部分，然后每个问题独立解决。当我们继续将问题分成更小的部分时，当问题不能再分成更小的部分时，这些更小的部分被求解，所有这些更小的部分或子部分的解最终被合并以获得原始问题的解。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/7ab7aa38c0262b317757c7327dc8397e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPXTT7fBFyeFjEYA0RqwaQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">分治算法</figcaption></figure><p id="3150" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个算法非常有用，有非常有趣的应用，优点，缺点。我们将在这篇博客中仔细观察它们，这将使你理解为什么这个算法在这个世界上非常有用。</p><p id="a4be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你还在等什么？我们开始吧！</p><h1 id="8737" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">分治算法包含以下步骤:</h1><ol class=""><li id="b256" class="kr ks hi ih b ii kt im ku iq kv iu kw iy kx jc ky kz la lb bi translated">划分:这包括将问题划分成更小的子问题。</li><li id="7e8d" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">征服:</strong>递归地解决更小的子问题。</li><li id="e4d8" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">组合:</strong>将递归过程中的子问题的解组合起来，以解决实际问题。</li></ol><h1 id="b116" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">何时何地使用分治算法:</h1><p id="7c4c" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">如果我们有一个与分治算法密切相关的问题，这个算法将是有用的。我们可以在问题可以被分成子问题的情况下使用这种算法，但是要确保同一个子问题不会被解决多次。如果同一个子问题被解决了几次，那么你应该明白，这个问题将通过动态方法而不是分治算法来解决。</p><h1 id="5a6b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">分而治之的优势:</strong></h1><ol class=""><li id="d78b" class="kr ks hi ih b ii kt im ku iq kv iu kw iy kx jc ky kz la lb bi translated">这种算法使给定的问题变得更容易，因为它将给定的问题分成更容易解决的子问题，然后单独解决它们中的每一个，并将所有子问题的所有解决方案组合成一个来解决原始问题。</li><li id="b299" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">该算法提高了快速排序、合并排序等其他算法的效率。这些算法都是分治算法的应用。</li><li id="0312" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">大多数处理器都支持这种算法，尤其是在共享存储器系统中，处理器之间的数据通信不需要预先编程。</li><li id="0490" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">该算法以高效的方式使用内存缓存。</li></ol><h1 id="e268" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">分而治之的缺点:</h1><ol class=""><li id="5e4d" class="kr ks hi ih b ii kt im ku iq kv iu kw iy kx jc ky kz la lb bi translated">这种算法的主要问题是递归速度慢，增加了时间复杂度。</li><li id="9d06" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">这种算法的另一个问题是，当通过这种方法解决问题时，有时会变得复杂，而基本的迭代方法似乎更容易。</li><li id="9ca1" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">当通过这种方法解决问题时，有时会有相同的子问题。所以最好保存重复的子问题的解。</li><li id="70e1" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">当使用这个算法时，确保有足够的内存分配给返回堆栈；否则，处理可能会因堆栈溢出而失败。</li></ol><h1 id="6944" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">分而治之应用:</strong></h1><ol class=""><li id="697b" class="kr ks hi ih b ii kt im ku iq kv iu kw iy kx jc ky kz la lb bi translated"><strong class="ih hj">二分搜索法:</strong>这是一种基于分治算法原理的快速搜索算法。为了使该算法正常工作，数据应该是排序后的形式。该算法通过比较集合中最中间的项来查找特定的项。如果出现匹配，则返回该项的索引。如果中间项大于项，则在中间项左侧的子数组中搜索该项。否则，将在中间项目右侧的子数组中搜索该项目。这个过程也在子阵列上继续，直到子阵列的大小减小到零。</li><li id="4e72" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">合并排序:</strong>这种排序技术也基于分治算法的原理。该算法首先将数组分成相等的两半，然后以排序的方式组合它们。</li><li id="1d64" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">快速排序:这种排序技术也是基于同样的原理。该算法选取一个pivot元素，以这样一种方式重新排列数组元素，即小于所选取的pivot元素的所有元素都移动到pivot的左侧，而所有较大的元素都移动到右侧。最后，该算法对pivot元素左右的子数组进行递归排序。</li><li id="2346" class="kr ks hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><strong class="ih hj">斯特拉森矩阵乘法:</strong>这种技术也是基于同样的原理。这种技术是两个矩阵相乘的有效算法。</li></ol><h1 id="bc4e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">时间复杂度</h1><p id="4298" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">分而治之算法的复杂度使用如下的主定理来计算。</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="f5d7" class="lp ju hi ll b fi lq lr l ls lt">T(n) = aT(n/b) + f(n),<br/>where,<br/>n = size of input<br/>a = number of subproblems in the recursion<br/>n/b = size of each subproblem. All subproblems are assumed to have the same size.<br/>f(n) = cost of the work done outside the recursive call, which includes the cost of dividing the problem and cost of merging the solutions</span></pre><p id="d203" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们举一个例子，找出一个递归问题的时间复杂度</p><pre class="je jf jg jh fd lk ll lm ln aw lo bi"><span id="4bad" class="lp ju hi ll b fi lq lr l ls lt">T(n) = aT(n/b) + f(n)<br/>     = 2T(n/2) + O(n)<br/>Where, <br/>a = 2 (each time, a problem is divided into 2 subproblems)<br/>n/b = n/2 (size of each sub problem is half of the input)<br/>f(n) = time taken to divide the problem and merging the subproblems<br/>T(n/2) = O(n log n) (To understand this, please refer to the master theorem.)<br/><br/>Now, T(n) = 2T(n log n) + O(n)<br/>          ≈ O(n log n)</span></pre><p id="56f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，该算法允许我们在很大程度上降低时间复杂度。</p><p id="34d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，冒泡排序使用O(n ^ 2)的复杂度，而快速排序(分而治之的应用)将时间复杂度降低到O(nlog(n))。线性搜索的时间复杂度为O(n)，而二分搜索法(分而治之的一种应用)将时间复杂度降低到O(log(n))。</p><h1 id="4f92" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">总结</strong></h1><p id="1f0c" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">你要做的第一件事是确定给定的问题是否能被分治算法解决。一旦你知道这个问题可以用D&amp;C算法来解决，那么你的任务就变得简单了，因为现在你只需要遵循三个步骤:使用递归调用将给定的问题分成子问题，解决子问题，然后将它们组合在一起找到原问题的答案。该算法的时间复杂度也大大降低。</p><p id="8076" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个博客到此为止。我希望你们都明白这个话题。如果您对此有任何疑问，可以在<a class="ae lu" href="https://www.linkedin.com/in/harsh-8711a81a0/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上发表评论或联系我。</p></div></div>    
</body>
</html>