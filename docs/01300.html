<html>
<head>
<title>GraphQL Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL基础知识</h1>
<blockquote>原文：<a href="https://medium.com/codex/graphql-basics-82d69b280198?source=collection_archive---------12-----------------------#2021-04-17">https://medium.com/codex/graphql-basics-82d69b280198?source=collection_archive---------12-----------------------#2021-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="950c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">RESTful APIs的替代方案</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ccb3d97cc901f1173aacbfa1f26e897b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MwCzc4kY_EsigE_UOyJdZQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图片来源:<a class="ae jn" href="https://www.freesion.com/article/67601031375/" rel="noopener ugc nofollow" target="_blank">freesion.com</a></figcaption></figure><h1 id="881a" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">起源故事</h1><p id="f5dd" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">2012年，脸书的开发团队引入了GraphQL，作为他们在原生移动平台上遇到的一些抓取问题的解决方案。用他们自己的话说，他们“需要一个足够强大的数据获取API来描述整个脸书，同时又足够简单，便于我们的产品开发人员学习和使用”。于是，GraphQL诞生了，后来在2015年发布供公众使用。</p><p id="e381" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">它可以与几乎任何编程语言结合使用，并从此获得了惊人的普及。开发人员喜欢它在客户机-服务器通信中提供的灵活性和效率。GitHub、Twitter、PayPal、Yelp和Shopify只是财富500强公司中使用GraphQL的几家。</p><h1 id="baaf" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">介绍</h1><p id="5626" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">定义就在名字里。GraphQL代表图形查询语言。它被用作REST和查询API的替代品，只检索所需的特定信息。在向客户端发送响应之前查询我们的API的好处之一是，我们不必过度获取不必要的数据，这可以加快我们的应用程序。</p><p id="0a81" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">另一方面，如果我们需要从几个不同的模型中获取数据，我们可以在一个请求中完成。以用户仪表板为例。您可能希望显示用户的姓名、上次登录、他们关注的其他用户、他们保存的一些文章等。这些信息需要从模式中的不同位置提取，但是可以在一个请求中完成，而不是在RESTful API架构中对不同端点的多个请求。</p><h1 id="0a4d" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">查询和突变</h1><p id="1c1c" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">想象一下GraphQL充当我们的客户机和数据库之间的中间人。它接受来自客户端的查询请求，并只返回需要的内容。</p><p id="f2e8" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">下面是一个查询示例:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="0e30" class="lm jp hi li b fi ln lo l lp lq">query [<br/>  user(id:278){<br/>    name<br/>    subscriptions {<br/>      title<br/>     }<br/>     bio<br/>     friends (first:3){<br/>       name<br/>     }<br/>  }<br/>]</span></pre><p id="7b13" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如您所见，GraphQL是一种强类型语言，因此它可以帮助我们快速捕捉错误。传入用户的id允许我们只获取特定用户的数据。传入first: 3 to friends允许我们只获取该用户数据库中前3个朋友的数据。我们也可以最后传入并改变我们想要返回的朋友的数量。响应是一个JSON对象，如下所示…</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="071f" class="lm jp hi li b fi ln lo l lp lq">{<br/> "data":{<br/>   "user": {<br/>      "name": "Lucy",<br/>      "subscriptions": [<br/>          {title: "Tech for Good"}<br/>          {title: "Daily Digest"}<br/>        ], <br/>       "friends": [<br/>          {name: "Todd"},<br/>          {name: "Tammy"}<br/>         ]<br/>      }   <br/>    }<br/>}</span></pre><p id="372d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">看看我们如何获得与该用户相关的数据，如订阅标题和朋友的名字。我们可以收集更多关于用户朋友的信息，比如他们订阅了什么，但是我们只收集了客户需要的信息。查询用于从后端读取数据，但是当我们需要操作一些数据时呢？</p><p id="964e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">为了更新或删除数据，我们以突变的形式发送请求。我们的变异中的信息将被用作HTTP请求中的对象。请查看GraphQL文档中的这个示例:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="ee44" class="lm jp hi li b fi ln lo l lp lq">mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {<br/>  createReview(episode: $ep, review: $review) {<br/>    stars<br/>    commentary<br/>  }<br/>}</span></pre><p id="eaef" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">请注意！在剧集和回顾之后。这是告诉GraphQL我们需要这些值返回除null之外的值的一种方式。您可能无法理解上面的所有代码，但是您可能会猜到$ep和$review是作为参数传入的变量，用于创建一个review。我们必须这样定义这些…</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="d6af" class="lm jp hi li b fi ln lo l lp lq">{<br/>  "ep": "JEDI",<br/>  "review": {<br/>    "stars": 5,<br/>    "commentary": "This is a great movie!"<br/>  }<br/>}</span></pre><p id="9966" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">就是这样！如果我们简单地在突变后添加一个return语句，数据将被更新，客户端可以反映这种变化。</p><h1 id="fe39" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">模式和类型</h1><p id="6b7d" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">您可以看到，查询基本上只是在字段中搜索已定义的对象。模式定义了我们可以从一个根对象中访问的字段，如果有子对象，那么也可以从这些子对象中访问哪些类型的字段。根据模式对查询进行验证，以确保我们正在寻找的内容是可用的，并且我们期望返回的数据类型反映了数据库中特定字段的类型。</p><p id="9270" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">所有模式都有一个查询类型，以便我们可以读取数据。如果预期要对数据库进行更改，那么模式也需要一个突变类型。如果没有这些，我们在发送查询和变异请求时就不能收到任何反馈。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="3b99" class="lm jp hi li b fi ln lo l lp lq">schema {<br/>  query: Query<br/>  mutation: Mutation<br/>}</span></pre><p id="ca9a" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">然后，您可以在您的模式中添加其他类型对象，如下所示:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="cd41" class="lm jp hi li b fi ln lo l lp lq">type: Member {<br/>  id: ID!<br/>  name: String<br/>  bio: String<br/>}</span></pre><p id="9264" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如果需要，类型字段可以接受参数。</p><p id="53d3" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">默认的内置类型有Int、Float、String、Boolean和ID。也可以创建自定义的标量和枚举类型。</p><p id="6208" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如果您熟悉TypeScript接口，它们在GraphQL中是可以接受的。接口是我们定义的一种类型，它具有由不同对象共享的特定字段。这有点像分类。当我们定义一个包含与接口相同字段的类型时，我们可以扩展接口。看看这个实现车辆接口的汽车类型的例子。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="5f88" class="lm jp hi li b fi ln lo l lp lq">interface Vehicle {<br/>  make: String<br/>  model: String<br/>  year: Int<br/>}</span><span id="a362" class="lm jp hi li b fi lr lo l lp lq">type Car implements Vehicle {<br/>  id: ID!<br/>  make: String<br/>  model: String<br/>  year: Int<br/>}</span></pre><p id="59d5" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">注意，汽车类型可以有比定义为车辆更多的字段，但至少，它必须有我们期望从车辆接口得到的所有相同的字段。</p><p id="354d" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">当我们希望不止一种类型作为返回值有效时，我们可以使用联合类型。例如，如果我们的数据库中的一些数字是整数，一些是字符串，那该怎么办？您可以定义一个union并将其赋给Int | String。该语法允许返回任一类型。</p><p id="8d51" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">最后，我们有输入类型。当我们需要创建一个传递给变异的对象时，就会用到这些。可以把它想象成补丁请求中的JSON对象。它们的定义很简单，使用input关键字，后跟任何合适的名称和一个将被传递给变异的对象。</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="33b7" class="lm jp hi li b fi ln lo l lp lq">input KarmaScore {<br/>  score: Int<br/>  comments: String<br/>}</span></pre><h2 id="2c63" class="lm jp hi bd jq ls lt lu ju lv lw lx jy kp ly lz ka kt ma mb kc kx mc md ke me bi translated">便利的工具和库</h2><p id="0230" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">正如我们前面讨论的，GraphQL是最近的热门话题。一路走来，已经有许多贡献和库来帮助我们。</p><p id="6fab" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">您首先想要熟悉的工具之一是浏览器内IDE graphic QL(发音:graphical)。您可以查看模式以了解在查询和变异中使用什么类型的字段，编写这些查询或变异，然后查看结果。它非常适合测试验证。最重要的是，它是自文档化的！</p><p id="9b39" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">对于基于JavaScript的应用程序，Apollo库通常用于客户机和/或服务器。一些React应用程序使用Relay库作为替代。其他流行的工具有GraphQL Yoga和Express GraphQL。</p><h2 id="4b20" class="lm jp hi bd jq ls lt lu ju lv lw lx jy kp ly lz ka kt ma mb kc kx mc md ke me bi translated">GraphQL的案例</h2><p id="9f4e" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">GraphQL太神奇了！它允许我们在一个请求中从多个API获取信息，并只获取我们需要的信息。它为前端和后端开发人员独立工作提供了灵活性。此外，我们应用程序的最终用户将获得更快响应时间的好处。</p><p id="37d4" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如果您还不喜欢这项技术，请查看GraphQL社区中的大量沟通和支持渠道！</p><p id="bca5" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如果你在Twitter上，看看#graphql、#graphqlweekly和#apolloql。您还可以通过访问<a class="ae jn" href="https://graphql.org/community/" rel="noopener ugc nofollow" target="_blank">https://graphql.org/community</a>加入正在进行的讨论或参加世界各地举行的众多GraphQL会议之一。</p></div></div>    
</body>
</html>