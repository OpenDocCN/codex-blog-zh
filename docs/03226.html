<html>
<head>
<title>ConMan:{Docker} internals Revealed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">骗子:{Docker}内部透露</h1>
<blockquote>原文：<a href="https://medium.com/codex/conman-docker-internals-revealed-23b8f29c52dc?source=collection_archive---------18-----------------------#2021-08-23">https://medium.com/codex/conman-docker-internals-revealed-23b8f29c52dc?source=collection_archive---------18-----------------------#2021-08-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/261aa6d826cb82e5e240a26a32e904de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yU0-ijMTiEaD57f5CP-Z-Q.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">码头工人是“骗子”</figcaption></figure><p id="a8c5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这篇文章中，我们将讨论容器运行时(docker)的内部。(先决条件，即应了解docker或任何容器引擎)</p><p id="f726" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">其实Docker不是运行时。是<strong class="iw hj">容器管理器</strong>帮助(*mark只帮助但不午餐，<strong class="iw hj"> runc* </strong>是启动容器的实际运行时)启动和执行容器上的不同操作。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="e2fc" class="kb kc hi jx b fi kd ke l kf kg"><strong class="jx hj">runc</strong> →runc is a runtime that runs the bundle (docker image)provided to it. runc can be compaired with the python in “python my.py”,where my.py consist of some python code ,similar ways runc is the runtime of container where as python is runtime of above mentioned command. </span></pre><p id="753b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">关于内核特殊功能的一点历史，容器使用</strong>内核3推出后，它推出了一些特殊功能，即当基础操作系统上的某个程序启动任何进程时，默认情况下，内核版本会将所有基础操作系统资源共享给所有由某个程序启动的进程，但新版本内核拥有的特殊功能是， 我们可以一起向流程显示不同的视图，这将与基础操作系统资源完全不同(即基础操作系统的资源是抽象的)</p><p id="85aa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，Linux内核的强制隔离/特殊功能可以通过以下方式实现</p><ul class=""><li id="5a00" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated"><strong class="iw hj">命名空间</strong> - &gt;通过调整命名空间中的资源，只有该特定命名空间的成员才能看到或使用命名空间中存在的那些资源。</li><li id="b8e6" class="kh ki hi iw b ix kq jb kr jf ks jj kt jn ku jr km kn ko kp bi translated"><strong class="iw hj"> Cgroup </strong> - &gt; Cgroup对进程可能使用的资源量进行限制，即避免在主机/基本操作系统上使用过多资源。</li><li id="1de0" class="kh ki hi iw b ix kq jb kr jf ks jj kt jn ku jr km kn ko kp bi translated">它限制进程如何使用系统调用。</li><li id="975f" class="kh ki hi iw b ix kq jb kr jf ks jj kt jn ku jr km kn ko kp bi translated">安全增强的Linux是一个对进程的强制访问控制系统，因此用于保护进程免受彼此和主机系统的影响。</li></ul><h1 id="2dce" class="kv kc hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">现在让我们从Docker/容器管理器的内部架构开始</strong></h1><p id="ec40" class="pw-post-body-paragraph iu iv hi iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr hb bi translated">谈到容器管理器，它是帮助完成容器生命周期管理的软件。cri-o、rkt等都是容器管理器的例子。</p><figure class="js jt ju jv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/4ccd12eeff948a61d054ea7753f5c627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8TJoV3KARk7YJmS39CKeWA.png"/></div></div></figure><p id="8265" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">容器只不过是带有上述限制的<strong class="iw hj">进程</strong>(在Linux中)，CMD如日期、cal等。也是进程，进程的生命周期直到特定程序的特定进程/CMD运行，因此我们可以控制进程，即容器操作系统，并根据使用情况使用。</p><p id="877c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下图就是证明，运行容器就是流程</p><figure class="js jt ju jv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/46e905986567013518667dc4c7e1d109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQWWoc1M-S_7_hUKRCltFQ.png"/></div></div></figure><p id="6954" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要启动容器，我们需要Docker映像，容器管理器帮助运行这段代码，runc负责启动容器或对容器执行操作，因此在坚果壳Docker中，即容器管理器以json格式向runc发送声明性信息，该信息存储在config.json文件中，这是一个文件，它要求或声明容器管理器使用指定的资源创建容器，最后runc(容器运行时)按照config.json文件的指示运行容器。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="23e0" class="kb kc hi jx b fi kd ke l kf kg"><strong class="jx hj">REQUIREMENT OF "config.json" FILE<br/></strong>config file is the one that provides the information (filesystem(fstab),network card, unique process tree etc)for the container that is to be launched it actually comes from the bundle i.e. the docker images<strong class="jx hj">.<br/>Its exactly like all the resources information are stored in the hardware and once we boot the system the complete hardrive is mountated to c drive (talking wrt windows)</strong></span></pre><h1 id="efe5" class="kv kc hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak"> Docker内部架构</strong></h1><figure class="js jt ju jv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/423a5a0267e7382770a41023743a310d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZAC98-_KO_-5pRCWEDibA.png"/></div></div></figure><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="4ce0" class="kb kc hi jx b fi kd ke l kf kg">docker (cli tool)<br/>        |<br/>        v<br/> dockerd (daemon) <br/>        |<br/>        v<br/> containerd (daemon) -┐<br/>                      |<br/>                      --&gt; runtime-shim -&gt; runc -&gt; container<br/>                      |<br/>                      --&gt; runtime-shim -&gt; runc -&gt; container<br/>                      |<br/>                     --&gt; runtime-shim -&gt; runc -&gt; container</span></pre><figure class="js jt ju jv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/2c2802b65e3787dc8ffc7260abd607be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HUxuUgYFPp_93HxjwuofTg.png"/></div></div></figure><p id="67f5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">cli工具是docker的客户端，其中docker和containerd是服务器部分，上面的块清楚地描述了docker不是联系runc的人，这就是为什么我们调用docker容器管理器而不是调用docker作为运行时。</p><p id="cc1f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下图显示containerd服务也在运行:-</p><figure class="js jt ju jv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/b0a3fbafc67ece68b96033126314c1f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1IjAYBtQ45wNM7TxVIgdg.png"/></div></div></figure><p id="1d61" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，containerd实际上是联系runc的人，因为我们与docker cli交互，但containerd是在docker后面运行的实际服务器，因此containerd被称为Containerd</p><h1 id="a1cc" class="kv kc hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">现在谈论容器管理器wrt kubernetes </strong></h1><figure class="js jt ju jv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/5b9ce21195012ab03f54a1fe2b0745cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4H3hV0Y_ov9mMUFwKey4Mg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">docker之前的架构已被弃用</figcaption></figure><p id="51ee" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">kubelet是worker节点上的一个，它联系docker shim(这是一个接口或API ),帮助联系docker，因此，在后台docker联系Docker守护进程(containerd ),然后被包含的联系runc，它是最后一个根据收到的包启动容器的联系(完全按照config.json一节中讨论的方式)</p><figure class="js jt ju jv fd ij er es paragraph-image"><div class="er es md"><img src="../Images/43c1852a4e00c88d5dd94dced69ce481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*nZZtVHhKXCoD0x2_jTpoQw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">docker之后的架构已被弃用</figcaption></figure><p id="d2f9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">注意:kubernetes不赞成使用docker，有些是在2020年12月左右，因此导致了Dockershim层的删除，所以在Dockershim的位置，引入了容器运行时接口(CRI ),它本身是一种可以与许多容器运行时管理器通信的Shim，因此启动了另一个容器管理器，称为CRI-O，它充当容器引擎并联系运行时<strong class="iw hj"> runc。</strong></p><p id="6602" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">事实:podman是无服务的(无守护程序的)，因此不需要接口层/垫层，它直接联系runc(容器运行时)来执行关于容器的动作</p><figure class="js jt ju jv fd ij er es paragraph-image"><div class="er es me"><img src="../Images/84ce39522bb4d170ee7aa4d2928bd38c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*OV7zvlUNV9DI_7JE2-rlHA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">可以看到没有服务运行@ podman</figcaption></figure></div></div>    
</body>
</html>