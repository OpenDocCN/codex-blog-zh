<html>
<head>
<title>The Transformers in NLP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NLP中的变压器</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-transformers-in-nlp-d0ee42c78e00?source=collection_archive---------2-----------------------#2021-03-16">https://medium.com/codex/the-transformers-in-nlp-d0ee42c78e00?source=collection_archive---------2-----------------------#2021-03-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4607" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博客中，我们将讨论比以前的方法更好的变形金刚<strong class="ih hj"><em class="jd"/></strong><em class="jd">。然而，transformer是基于注意力的，但是在体系结构中增加了并行化的概念。</em></p><p id="8eb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae je" rel="noopener" href="/nerd-for-tech/what-is-attention-in-nlp-f67411426e64?source=your_stories_page">之前的博客</a>中，我们讨论了关于<strong class="ih hj">注意力的问题。</strong>在最近的深度学习模型中，注意力是一个有助于提高NLP应用性能的概念，如神经机器翻译、图像字幕和各种其他应用。注意力机制像人类一样工作。例如，当你听到任何句子时，你的大脑会试图找出重要的关键词，并在此基础上理解句子的上下文。像这样，注意机制在编码器侧尝试将每个LSTM单元的输出传递给注意机制，并基于注意分数找出序列的重要性。然后，该上下文向量与解码器的先前输出一起被提供给解码器架构中的下一个LSTM单元，并计算出翻译。</p><p id="77af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">论文'<a class="ae je" href="https://arxiv.org/pdf/1706.03762.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="jd">关注是你所需要的全部</em> </a>'是2017年推出的一种叫做<strong class="ih hj"> Transformer的新颖架构。</strong>顾名思义，该架构使用编码器/解码器架构，但在下图所示的架构中添加了并行化功能。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es jf"><img src="../Images/a16fe7243d662d12c93d4f35b281ac5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*46c7LPV22532Svcewui37g.png"/></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">变压器架构来源:-<a class="ae je" href="https://arxiv.org/pdf/1706.03762.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1706.03762.pdf</a></figcaption></figure><p id="e1b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像可以很容易地解释建筑。让我们深入了解一下这种架构。编码器显示在左侧，由N = 6个相同层的堆叠组成。每层有两个子层，一个是多头自关注机制，另一个是简单的全连接前馈网络。此外，这里还添加了残差连接和图层归一化。6个编码器相互堆叠，最后一个编码器输出给解码器。</p><p id="3861" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解码器也由堆叠的N = 6层组成。此外，解码器插入第三个子层，该子层对编码器堆栈的输出执行多头关注。此外，剩余连接与所有子层一起添加，随后是层标准化。解码器中的自我关注子层也不像传统的关注方法。这里添加了掩蔽的多头注意力，它与位置嵌入相结合，以确保输入和输出的依赖性。</p><p id="9a6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">整个架构可以这样看。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jr"><img src="../Images/8b887d6a9935f757039c4311a027e69c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ILQShc4bFAWM6sCV.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">《变形金刚》的编解码架构/来源:<a class="ae je" href="http://jalammar.github.io/illustrated-transformer/" rel="noopener ugc nofollow" target="_blank">http://jalammar.github.io/illustrated-transformer/</a></figcaption></figure><p id="59ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在传统的编码器架构中，我们使用RNN/LSTM/GRU作为单元，但在此架构中，方法发生了变化，编码器单元被相互堆叠的自关注和前馈神经网络所取代。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jw"><img src="../Images/95cae28635c6ea75d3b2b6ce95fdce8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3r5tQ3IYOxkk8W38.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">变压器编码器架构/来源:【http://jalammar.github.io/illustrated-transformer/ T2】</figcaption></figure><p id="318a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编码器的输入首先通过自注意层，因为注意的功能是根据序列识别权重。然后自我注意的输出通过前馈神经网络。然后，该单个编码器的输出被传递到另一个编码器层(因为在该架构中有6个编码器层)。最后，最后一个编码器的输出被送到解码器。解码器由相似的结构组成，只有一层编码器-解码器关注(类似于Seq2Seq关注)被添加在它们之间。下图概述了编码器和解码器的架构。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jx"><img src="../Images/a9719c0dfe11d7eaf044f6db4fa72d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LR3RWpDJihlayxeS.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">《变形金刚》解码器架构/来源:【http://jalammar.github.io/illustrated-transformer/ T4】</figcaption></figure><h1 id="842f" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">编码器</strong></h1><p id="a156" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">让我们深入了解一下单个编码器单元的内部。任何NLP问题的第一步都是将文本数据转换成数字表示。因此，根据研究论文，我们必须将我们的文本转换成512大小的矢量表示。有多种方法可以将单词转换成矢量，如Word2Vec、GloVe、TFIDF和BOW。这个转换后的大小为512的嵌入现在被发送到底部编码器的自关注层。自关注层的输出然后被发送到前馈层，然后它将被传递到另一个编码器层。输入的大小可以根据最长的句子来决定。这里，我们以大小为3的词X1，X2，X3为例。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es lb"><img src="../Images/f51fcc2162b48f2b926de9a51fb2534f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kadADLMDUbZK6HRRFsLqIw.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">编码器的输入</figcaption></figure><p id="d4e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嵌入后，单词按输入顺序排列，所有单词通过编码器的每一层。</p><p id="bd36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">自我关注</strong></p><p id="798d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们先来看看当我们通过大小为512的向量时，自我注意是如何工作的。<strong class="ih hj">注:——矢量的大小是根据研究论文提及的，根据其他研究而变化。</strong>第一步，计算查询向量、关键向量、值向量。这些向量是通过将每个单词嵌入与所有三个度量相乘来计算的。简单地说，例如，我们有X11、X12……的输入。X512将与Wq1、Wq2……相乘..Wq512计算查询向量。与计算键向量和值向量的方式相同，如下图所示。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es lc"><img src="../Images/dcff523956f828f2c4c9a89ab01440b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_HbZLRVOVDnUzRgvOg-Pnw.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">查询、键和值向量计算</figcaption></figure><p id="2cf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据研究论文，该向量的维数被降低，为64，但是编码器的输出大小仅为512。这个模型的真正优点在于，我们不是计算一个关系，而是发现每个单词的多个关系。</p><p id="e8ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将使用这个向量来计算注意力得分。我们在这里使用注意力，所以在我们的例子中第一个单词是“I ”,所以我们需要检查这个单词与句子中使用的所有单词的得分。分数是通过查询和我们正在评分的相应单词的关键向量的点积来计算的。例如，我们正在计算“I”的分数，那么分数1将是q1*k1，分数2将是q1*k2，分数3将是q1*k3。在这里，我们简单地对查询和关键指标进行<strong class="ih hj">点积，结果我们会得到分数。</strong></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es ld"><img src="../Images/7d3c59040b17233bf18f8d3bb1b12fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VRtM8QLPsjoeu3tcd4kfXQ.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">计算单词“I”与所有其他单词的得分</figcaption></figure><p id="f6c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据研究论文计算分数后，分数除以8。关键向量的维数的实际值是64，所以分数除以8。然后，将从softmax函数传递Score/8值，我们将得到的值在0-1之间，根据我们的注意标准和softmax属性，所有值的总和将为1。这个函数决定了单词在每个地方的重要性。单词本身具有最高分，但是我们也可以确定其他单词与当前单词的相关性。因此，根据研究论文，关注度用下面的公式计算。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es le"><img src="../Images/a98bcf73d9225a608d4ee8b9203a362c.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*ok3Pr-mTdgyVsU0kG-eKSg.png"/></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">计算关注度的公式/来源:【https://arxiv.org/pdf/1706.03762.pdf T4】</figcaption></figure><p id="4d4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是将所有的softmax值乘以它们的值向量。通过这一步，我们可以排除所有具有微小softmax值的单词，并且我们可以获得我们需要关注的单词的相关性。在下一步中，加权值向量被求和以生成特定单词的自我注意层的输出。产生的矢量被送到前馈神经网络进行进一步处理。整个流程如下图所示。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es lf"><img src="../Images/587af83ab4ba78a936338943e8ebdde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhWVDBxdVUFF9wGh2gOYwA.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">计算关注层输出的整个流程</figcaption></figure><p id="e020" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如变压器<strong class="ih hj">架构所示，使用了</strong>多头关注。到目前为止，我们已经讨论了单方向注意力，随着多方向注意力的加入，注意力的表现将会得到改善。首先，当我们处理长序列时，它将扩展对其他单词的关注。其次，它包括随机初始化的多个查询、键和值矩阵。由于变形金刚使用了8种不同的注意力，我们将得到8种不同的z矩阵。整个流程如下图所示。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es lg"><img src="../Images/d59f3d0aeba1aeeeb20cdd64db223c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yiHUk5yC-JWJWhmyKi_V0A.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">用8种不同的注意头计算Z矩阵</figcaption></figure><p id="d23a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个步骤问题是前馈神经网络接受单个输入，因此所有的注意力头部需要被连接。此外，研究人员在这里提出了另一个权重W0，它乘以所有关注头的串联，以获得最终的z。这个过程如下图所示。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es lh"><img src="../Images/f5738849ce24b5e7f2d436e04f435413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*0oUuqshIdN2Q9kvYoryd3g.png"/></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">计算多头https://arxiv.org/pdf/1706.03762.pdf<a class="ae je" href="https://arxiv.org/pdf/1706.03762.pdf" rel="noopener ugc nofollow" target="_blank">的公式</a></figcaption></figure><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es li"><img src="../Images/1b3580d374b32975c1800da22ea15d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qo3-1DlIHFp56zHfKOFCiw.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">参考:【http://jalammar.github.io/illustrated-transformer/ T4】</figcaption></figure><h1 id="4a3c" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">位置编码</h1><p id="23b4" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">位置编码是识别两个单词之间的距离和单词输入顺序的关键因素。为了创建这种编码，所有的输入向量被加上位置向量(位置向量遵循模型学习的特定模式)，然后它将被提供给编码器的输入。这背后的原因是，当将这些值映射到查询/键和向量时，将这些值添加到嵌入中会在向量之间创建有意义的距离。同样，每个单词的位置和每个单词之间的距离可以用这种位置编码来确定。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es lj"><img src="../Images/8ef27ff8c9f0b364772741431b4f7950.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*3fBC1lF1bJQW2hImdKdqFg.png"/></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">计算位置向量的公式</figcaption></figure><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es lk"><img src="../Images/eeac6fd26d85c5531870b57b0cbe3d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQYhDjrFy_5vpsmTW8G9Wg.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">参考:<a class="ae je" href="http://jalammar.github.io/illustrated-transformer/" rel="noopener ugc nofollow" target="_blank">http://jalammar.github.io/illustrated-transformer/</a></figcaption></figure><h1 id="ad0c" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">剩余网络(跳过连接)</h1><p id="e467" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">在编码器的架构中，围绕多头关注和前馈网络提到了剩余连接。这个跳过连接之后是层标准化步骤。具有自我关注和层标准化的可视化可以看起来像这样。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es ll"><img src="../Images/443e75b97233e90ff2982c94822d8cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OQiWwHhdTtTcisn60-WSSA.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">从编码器1的输入到输出的整个流程</figcaption></figure><p id="dc74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，第一个编码器的输出被提供给第二个编码器，这样整个编码器架构就工作了。如果我们考虑2编码器架构，那么它会是这样的。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es lm"><img src="../Images/d548321a07d9a70e354932a3d22d6271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jCwsz6M5eJusJMIoG-UDHQ.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">参考:-<a class="ae je" href="http://jalammar.github.io/illustrated-transformer/" rel="noopener ugc nofollow" target="_blank">http://jalammar.github.io/illustrated-transformer/</a></figcaption></figure><h1 id="a243" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">解码器</h1><p id="b9b2" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">在体系结构中，编码器的输出提供给第二层解码器。第一层如果解码器被屏蔽-多头关注，然后添加和规范化。在这里，掩蔽多头注意力与编码器一样，采用输出嵌入和位置嵌入。例如，如果我们正在进行语言翻译，输出语言将作为解码器的输入。屏蔽意味着一些字被屏蔽，以便模型可以学习预测数据和被屏蔽的字将在每次迭代中改变。这一层将为解码器生成查询度量。从编码器输出中获取关键字和值度量，编码器输出直接给予编码器-解码器关注，如图所示。对句子的整个序列重复该过程，直到到达完成符号。比如:-句尾。整个流程可以在下图中看到。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es ln"><img src="../Images/23731f804fe606394febc6a3af373448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4wQUruJ1Fy90asu3aQu1ug.png"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">参考:-<a class="ae je" href="http://jalammar.github.io/illustrated-transformer/" rel="noopener ugc nofollow" target="_blank">http://jalammar.github.io/illustrated-transformer/</a></figcaption></figure><p id="8a4a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，堆叠解码器的输出被送到线性层，线性层是一个简单的全连接神经网络。线性层生成向量，这些向量是我们不能直接预测单词的大向量。这一层我们可以假设我们整个数据集的字典。然后从softmax层传递以转换成概率，选择具有最高概率的单元并将其转换成该时间戳的最佳可能单词。</p><p id="9f5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个博客中，我们看到了第一个变形金刚，这是目前所有研究的基础。<strong class="ih hj">在下一篇文章中，我们将尝试赶上伯特(变压器的双向编码器表示)和GPT。</strong></p><p id="014b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">建议随时欢迎。</em> </strong></p><p id="b598" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献</strong></p><ol class=""><li id="ef43" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated"><a class="ae je" href="http://jalammar.github.io/illustrated-transformer/" rel="noopener ugc nofollow" target="_blank">http://jalammar.github.io/illustrated-transformer/</a></li><li id="02fa" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><a class="ae je" href="https://arxiv.org/pdf/1706.03762.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1706.03762.pdf</a></li></ol></div></div>    
</body>
</html>