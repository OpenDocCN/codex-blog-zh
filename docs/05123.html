<html>
<head>
<title>Cubit + Freezed combination to manage the state powerfully in Flutter (2022 version)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cubit +冻结组合，强力管理颤振状态(2022版)</h1>
<blockquote>原文：<a href="https://medium.com/codex/cubit-freezed-combination-to-manage-the-state-powerfully-in-flutter-2022-version-e64339e7c641?source=collection_archive---------3-----------------------#2022-02-02">https://medium.com/codex/cubit-freezed-combination-to-manage-the-state-powerfully-in-flutter-2022-version-e64339e7c641?source=collection_archive---------3-----------------------#2022-02-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/af64b7904518a23071736e2d467f3d4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ME68YcayB3flWa8IvaA98g.png"/></div></div></figure><p id="3dfb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae jo" rel="noopener" href="/@sahinefe/bloc-pattern-for-login-bloc-login-in-flutter-551fd05beb99">上一部分(登录的BLoC模式:cubit _ log in in in Flutter)</a>中，我们使用cubit创建了一个带有Flutter的登录应用程序，它是BLoC的一个子类(我实际上是这样调用的，因为它有一些BloC属性)。当我们创建以前版本的登录应用程序时，我们没有使用“冻结”包。在这一部分，我们将使用它，我们将看到冻结的软件包如何为我们的状态管理提供强大的功能。</p><h1 id="13f3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我们将建造什么？</h1><p id="c5a4" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们要用冷冻的包裹重新制作腕尺。我们将使用与上一部分相同的UI，因为我们将在这篇中型文章中关注状态管理。简单来说，我们可以说，我们会更新上一个项目的路由器和状态管理，会更好。</p><p id="b13c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们不使用冻结的包，我们必须在我们的主状态文件中编写所有的样板代码。在这种情况下，让我们比较冻结和不冻结包的代码。</p><h2 id="d22e" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">auth_state.dart(未冻结)</h2><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h2 id="cdea" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">auth_state.dart(已冻结)</h2><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="5d91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里你可以说有什么区别吗？仅仅是7(13–6)行吗？当然不是！让我们看看冷冻包为我们做了什么(227行，对此表示抱歉)。</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="5c1c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，我们不需要做所有的事情，也不应该像上面说的那样手工修改代码。我们再看一个例子(当然没有200行代码)。</p><h2 id="c098" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">login_state.dart(无冻结)</h2><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><h2 id="cea5" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">login_state.dart(带冻结)</h2><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="1ea3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用freezed，我们创建一个构造函数，如果我们愿意，我们用<em class="lm"> "@Default()" </em>标签给它们赋予初始值(如果您将Freezed导入到<em class="lm"> pubspec.yaml </em>文件并创建带有bloc扩展名的cubit，那么它将创建带有 freezed包的默认cubit <strong class="is hj">)，就这样！</strong></p><p id="4121" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我们已经浏览了cubits中的基本冻结包，现在让我们看看如何正确地创建它。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h1 id="0210" class="jp jq hi bd jr js lu ju jv jw lv jy jz ka lw kc kd ke lx kg kh ki ly kk kl km bi translated">带肘的冷冻包装</h1><p id="58a8" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">创建腕尺后，我们会有这样的代码:</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="b062" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，如果您在代码中看到(我确信您会看到)红线/错误，请不要惊慌。我们将使用build runner运行神奇的代码来完成冻结包的魔法。</p><blockquote class="lz ma mb"><p id="37d0" class="iq ir lm is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">神奇代码:</em> </strong> <em class="hi">扑扑pub run build _ runner watch—delete—conflicted—outputs</em></p></blockquote><p id="6915" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将此代码粘贴到终端，之后您将获得1个(或更多)输出。如果您不想一直打开构建运行器，您可以将<em class="lm">手表</em>更改为<em class="lm">构建</em>。</p><h2 id="6642" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">如果我想在状态中创建特殊的方法呢？</h2><p id="2be2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">因此，您需要在构造函数中使用带下划线的点，比如:</p><blockquote class="lz ma mb"><p id="acae" class="iq ir lm is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi"> const SignUpState。_();</em> </strong></p></blockquote><p id="68e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">之后，您可以创建特殊的方法，如<em class="lm"> SignUpState.loading()、</em>等。</p><h2 id="df16" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">丘比特呢，不是国家？</h2><p id="d9fb" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">对于cubits，我们可以使用SignUpState.initial()作为构造函数。除此之外，当我们更新状态时，我们知道我们需要为此使用emit。当我们使用emit时，我们可以很容易地通过<strong class="is hj">状态到达<strong class="is hj"> copywith </strong>方法。让我们看一个例子，看看cubit和Freezed的用法。</strong></p><h2 id="454c" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">auth_cubit.dart</h2><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="1925" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们没有给变量<em class="lm"> isSignedIn </em>一个默认值，所以我们用<em class="lm"> required </em>关键字编写。所以我们可以给构造函数赋值。在本例中，如果用户为null，我们说将状态(isSignedIn)更新为false，但如果用户不为null，则使用true值进行更新。很简单，对吧？</p><h2 id="b295" class="ks jq hi bd jr kt ku kv jv kw kx ky jz jb kz la kd jf lb lc kh jj ld le kl lf bi translated">是时候使用flow_builder根据“状态”路由用户了</h2><p id="8cd8" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><em class="lm"> flow_builder </em>包根据我们的状态提供路由屏幕。例如，如果我们的用户已经登录，那么用户应该停留在主页上，反之亦然，如果用户没有登录，那么用户应该停留在登录页面上。那么，如何才能轻松使用<em class="lm"> flow_builder包</em>？</p><figure class="lg lh li lj fd ij"><div class="bz dy l di"><div class="lk ll l"/></div></figure><p id="c678" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此处更新了登录页面。当应用程序启动时，它首先在阻止提供程序后工作。我们又有了<em class="lm">flow builder&lt;ourState&gt;、pages和State。对于页面，我们创建静态的final方法来调用它们根据状态进行路由。</em></p><blockquote class="lz ma mb"><p id="c4cf" class="iq ir lm is b it iu iv iw ix iy iz ja mc jc jd je md jg jh ji me jk jl jm jn hb bi translated">static Page Page()= &gt; const material Page<void>(child:home Page())；</void></p></blockquote></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h1 id="6ea3" class="jp jq hi bd jr js lu ju jv jw lv jy jz ka lw kc kd ke lx kg kh ki ly kk kl km bi translated">结论</h1><p id="0b00" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我已经在Google Play Store上为我的大学(伊兹密尔理工学院)创建了一个应用程序，它的名字是cepte西普特，当我创建这个应用程序时，我没有使用冻结的软件包，也没有使用flow_builder。过了一段时间，我意识到它们为我们提供了动力。你可以在这里找到所有的代码。我希望这篇教程能帮助你理解你应该如何在freezed和flow_builder包中使用cubit_login。欢迎在评论区提问。</p><p id="31cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您的阅读，敬请关注！</p><p id="9dbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">干杯。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/8715be236e11811a791be3c3bf94b1f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9y-LGIlrxPiTyiAWDHOQHw.gif"/></div></div></figure></div></div>    
</body>
</html>