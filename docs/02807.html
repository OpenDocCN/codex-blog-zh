<html>
<head>
<title>How to keep Tailwind DRY</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何保持顺风干燥</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-keep-tailwind-dry-5116cbfbb839?source=collection_archive---------8-----------------------#2021-08-06">https://medium.com/codex/how-to-keep-tailwind-dry-5116cbfbb839?source=collection_archive---------8-----------------------#2021-08-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/18f60952634e9e2383dd74c67d2e2f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*URJan4WWpQgwQO9Ro7wKTw.jpeg"/></div></div></figure><div class=""/><p id="b6b9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在网上看到很多关于Tailwind的抱怨:它是湿的，不是干的，它和内联样式一样，你不能进行全局更改，它很难阅读。我理解当你第一次开始使用Tailwind时，这种情况可能会出现。需要记住的是<strong class="is hu"> Tailwind与传统的CSS完全不同，你不应该这样对待它</strong>。</p><p id="f502" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Tailwind有很多方式可以让我们受益，比如它极小的包大小和超快的原型制作能力。但我们只有在正确的情况下使用它，才能获得这些好处；用在错误的上下文中，顺风只会给你带来头痛。</p><h1 id="7523" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么时候使用Tailwind CSS是错误的？</h1><p id="0f06" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我首先会推荐<strong class="is hu">反对</strong>使用Tailwind，因为它是普通的HTML静态网站。当你构建一个静态站点时，你不可避免地要复制和粘贴HTML，因为在一个页面上可能不止一次出现相同的组件/部分。</p><p id="ba61" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你使用传统的CSS方法，比如<a class="ae kr" href="http://getbem.com/" rel="noopener ugc nofollow" target="_blank"> BEM </a>，这完全没问题:你的CSS和HTML完全独立存在，所以你可以依赖你的CSS作为你网站外观的唯一来源。如果你改变了一个CSS类，这个改变将会在这个类被使用的任何地方被反映出来，而不需要更新HTML。通过这种方式，如果你已经复制并粘贴了一些HTML，这并不太重要。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="0ccd" class="lc jp ht ky b fi ld le l lf lg">// you can copy and paste these classes anywhere<br/>&lt;button class="button button--negative"&gt;&lt;/button&gt;</span><span id="3cf2" class="lc jp ht ky b fi lh le l lf lg">&lt;button class="button button--negative"&gt;&lt;/button&gt;</span><span id="73f3" class="lc jp ht ky b fi lh le l lf lg">// but you could also break rules like this<br/>&lt;div class="button"&gt;&lt;/div&gt;</span></pre><figure class="kt ku kv kw fd hk er es paragraph-image"><div class="er es li"><img src="../Images/1de610321d90c212627a8aa4bbd1400d.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/0*7t5MOrPKkDAGMO69"/></div></figure><p id="c453" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于CSS和普通HTML来说，这是你能做的最多的事情了。就我个人而言，我仍然认为这种方法不太合适，因为你在多个地方复制和粘贴相同的代码，但这是你用基本的HTML所能做到的最好的了——在我学习CSS的时候，这种方法从来都不适合我。为了使这个系统真正的干燥，你需要使用某种形式的模板或者基于组件的框架，这样你就可以一次只为一个部分编写HTML，然后在任何你喜欢的地方重用这个组件。这让我想到了…</p><h1 id="24bf" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么时候使用Tailwind CSS比较合适？</h1><p id="87be" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">很高兴你问了！如果你不想在用Tailwind构建网站时重复自己的工作，你可能会想使用某种JavaScript框架。无论是React、Vue还是其他一些新奇的框架，重要的是你可以构建可以反复重用的JS组件。你也许可以让它和PHP模板一起工作，但是我认为这种方法最适合JavaScript，因为你可以把HTML、JS和CSS都保存在同一个文件中。</p><p id="c066" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这才是真正应该使用Tailwind的方式:作为一个完全不同的范例，关注点的分离并不意味着分离HTML、CSS和JS，而是意味着分离整个组件，并将与该组件相关的所有内容保存在一个文件或文件夹中。这是一种与我们习惯的应对挑战的方式截然不同的工作方式，但这种方法有一些很大的好处:</p><ul class=""><li id="1ae4" class="lj lk ht is b it iu ix iy jb ll jf lm jj ln jn lo lp lq lr bi translated">组件可以彼此独立地运行，并且可以毫无争议地跨不同的项目使用</li><li id="f81b" class="lj lk ht is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">组件可以独立测试，所以您不需要担心以后会发生变化</li><li id="7a93" class="lj lk ht is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">原型开发要快得多，因为您不需要为每个元素编写一个定制的类</li><li id="4cb9" class="lj lk ht is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">使用JavaScript进行比常规HTML更高级的条件样式化的完全访问权限</li><li id="c047" class="lj lk ht is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">鼓励组件组合——一旦你有了一堆组件，就很容易通过组合你已有的组件来构建页面，甚至是组件的新变体</li></ul><h1 id="9cfe" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">拥抱基于组件的架构</h1><p id="877d" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">一旦你把HTML、JavaScript和CSS都放在一个地方，你会意识到把组件放在它们自己的文件夹中比把资源分散在不同的文件树中更容易。以这种方式工作开辟了新的机会，比如能够使用JavaScript来规定您的样式，并为视图构建更复杂的逻辑。</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div class="er es lx"><img src="../Images/42e7069ef8f0dd52ef1b20006ac72bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/0*iFiKNympO_VoQ8Vj"/></div></figure><p id="6dfe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是一些帮助您适应基于组件的开发的技巧:</p><h1 id="3f52" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">1.将组件分解成小的、可重复使用的部分</h1><p id="3f0c" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">你有没有注意到，在看一个设计时，往往有许多重复的模式？你可以在课堂作文中利用这一点。常见的是一面是文本，另一面是某种媒体的50/50布局。我倾向于称它们为<code class="du ly lz ma ky b">SplitContent</code>块。这方面经常会有变化，可能有些文本是不同的大小，或者媒体插槽是用一个转盘而不是一个图像来填充的。</p><p id="3578" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以创建一个带有props和slots的容器组件，您可以在其中添加任何类型的内容，而不是构建两个在很大程度上使用完全相同样式的组件。你可以在里面为你的样式设置逻辑——也许你想要一个道具来改变内容将出现在哪一边，或者在某一边添加填充。或者，您可以只添加一个可以传递一串类名的prop，让您能够定制容器，因为它在不同的上下文中使用。</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mb"><img src="../Images/0dddf4314d1417934a4a9d938de53a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MWrsyLxizMP756jW"/></div></div></figure><p id="72f0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于我想使用SplitContent作为CMS(如Wordpress)的动态内容块的区域，我可能会创建一个<code class="du ly lz ma ky b">Handler</code>组件，它分解CMS中定义的样式选项，并传递相关的组件组合。</p><p id="d2be" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，您可能希望您的客户端只能访问CMS中的一个SplitContent组件，但可以选择使用该组件创建许多不同的布局。一些选择可能包括:</p><ul class=""><li id="19cc" class="lj lk ht is b it iu ix iy jb ll jf lm jj ln jn lo lp lq lr bi translated">您希望每一面都包含哪种类型的内容？</li><li id="7d8e" class="lj lk ht is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">每种内容类型应该在哪一边？</li><li id="e500" class="lj lk ht is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">这个组件需要不同的配色方案吗？</li></ul><p id="e9c3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">组件处理程序可以接受这些选项，它将返回正确的布局，同时保持所有这些逻辑包含在它自己内部，以便其他组件仍然可以跨不同的组件使用。</p><p id="e078" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我通常将与SplitContent相关的所有内容保存在一个文件夹中，并添加一个由组成主要组件的较小部分组成的子文件夹:</p><figure class="kt ku kv kw fd hk er es paragraph-image"><div class="er es mc"><img src="../Images/43d46459f7405a0ac973be62b332b5d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/0*JDBkrEp-MLHmHwUk"/></div></figure><p id="e318" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这只是一个例子；本质上，您的组件应该都有一个单一的目的，这样使用您已经创建的组件来构建更大更复杂的组件就更容易了。</p><h1 id="d6bd" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">2.使用JS构建类列表</h1><p id="5fb4" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">如果你觉得《顺风》很难读懂，你并不孤单。这是最常见的抱怨之一，我可以理解为什么:你必须阅读每个类才能理解发生了什么，这并不适用于每个人。</p><p id="ab52" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">依靠JavaScript来构建类名可能会有所帮助。我通常更喜欢这种方法，而不是为了它而编写新的CSS类，尤其是当它们可能只在一个地方使用时。有些人可能会说这与使用@apply指令是一样的，但是如果这个类不会在其他任何地方使用，就没有理由为它编写一个全新的类。像这样用JavaScript编写类有助于将与该组件相关的所有内容放在一个相似的地方，而不是放在几英里之外的CSS文件夹中。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="1308" class="lc jp ht ky b fi ld le l lf lg">// components/Modal/View.jsx</span><span id="8938" class="lc jp ht ky b fi lh le l lf lg">export default function ModalView () {<br/>  const modalContainerClass = "bg-white p-4 rounded shadow";<br/>  const modalHeadingClass = "heading-1 text-darkgrey";</span><span id="1962" class="lc jp ht ky b fi lh le l lf lg">  return (<br/>    &lt;aside className={modalContainerClass}&gt;<br/>      &lt;h1 className={modalHeadingClass}&gt;...&lt;/h1&gt;<br/>    &lt;/aside&gt;<br/>  );<br/>}</span></pre><p id="780e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将类存储在JavaScript变量中可以让我们更清楚地了解它要完成的任务，同时也为我们提供了使用比CSS更高级的逻辑的机会。</p><h1 id="b07c" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">3.使用道具来扩展组件</h1><p id="f2a2" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">与普通CSS相比，我们在使用Tailwind时遇到的一个问题是，我们失去了将组件的基本版本扩展为带有类的新修改版本的能力:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="123f" class="lc jp ht ky b fi ld le l lf lg">// _button.scss</span><span id="ad3b" class="lc jp ht ky b fi lh le l lf lg">.button {<br/>  padding: 20px;<br/>  border: 1px solid black;<br/>}<br/>.button--negative {<br/>  border-colour: red;<br/>}</span><span id="4eaf" class="lc jp ht ky b fi lh le l lf lg">// index.html</span><span id="cb66" class="lc jp ht ky b fi lh le l lf lg">&lt;button class="button"&gt;Accept&lt;/button&gt;<br/>&lt;button class="button button--negative"&gt;Cancel&lt;/button&gt;</span></pre><p id="f158" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，我们可以手动将<code class="du ly lz ma ky b">border-red</code> Tailwind类添加到任何我们想要设置为负的按钮中，但是如果有不止一种样式呢？如果背景和文本颜色也改变了怎么办？</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="383b" class="lc jp ht ky b fi ld le l lf lg">// this would be a nightmare if the negative styles ever changed</span><span id="e851" class="lc jp ht ky b fi lh le l lf lg">&lt;button class="p-5 border-red bg-red text-white"&gt;Cancel&lt;/button&gt;</span></pre><p id="d986" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">解决方案:使用JavaScript扩展你的组件</strong></p><p id="981c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们切换到基于组件的开发时，我们获得了使用JavaScript代替CSS来创建组件的能力。因为您不再受限于单独的样式表，所以您可以通过将组件抽象到不同的文件来创建组件的变体，使用您的基本组件作为起点。</p><p id="69f2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最灵活的方法之一是将类名作为道具传递下去，并将它们与组件上现有的类合并。这是一个<a class="ae kr" href="https://reactpatterns.com/#merge-destructured-props-with-other-values" rel="noopener ugc nofollow" target="_blank">将被破坏的道具与其他值</a>合并的例子，如神奇资源<a class="ae kr" href="https://reactpatterns.com/" rel="noopener ugc nofollow" target="_blank">reactpatterns.com</a>所示。</p><p id="f25d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是使用这种方法时我们的按钮变体的外观:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="1ffb" class="lc jp ht ky b fi ld le l lf lg">// components/Button/index.jsx</span><span id="0924" class="lc jp ht ky b fi lh le l lf lg">export default function Button = ({ classnames, handleOnClick, label }) {<br/>  const buttonClass = [<br/>    "p-5 border-1", // default button styles<br/>    classnames      // any additional styles<br/>  ].join(' ');<br/>  <br/>  return (<br/>    &lt;button className={buttonClass} onClick={handleOnClick}&gt;<br/>      {label}<br/>    &lt;/button&gt;<br/>  )<br/>}</span><span id="ba97" class="lc jp ht ky b fi lh le l lf lg">// components/Button/Negative.jsx</span><span id="c3b0" class="lc jp ht ky b fi lh le l lf lg">export default function ButtonNegative = (props) {<br/>  return (<br/>    &lt;Button<br/>      classnames="border-red bg-red text-white"<br/>      {...props}<br/>    /&gt;<br/>  )<br/>}</span></pre><p id="fa2c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以使用<code class="du ly lz ma ky b">index.jsx</code>作为按钮的基础层，并保持所有的逻辑都在这个层次上，同时也清楚地定义了按钮的变体，而没有任何功能上的改变。这样，如果以后样式改变了，任何使用<code class="du ly lz ma ky b">&lt;ButtonNegative /&gt;</code>的地方都会反映出文件中的改变。</p><h1 id="20ad" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">4.将视图逻辑和业务逻辑移动到单独的文件中</h1><p id="8e8a" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">对于使用JavaScript框架来说，这是一个非常通用的技巧，但是在Tailwind中，它可以提供更多的帮助，因为它将您的风格与您的业务逻辑分开，而不会将它们放到一个完全不同的文件夹中。你可以进入你的按钮文件夹，知道那个文件夹里的所有东西都会和按钮有关。</p><p id="51cf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦你把所有东西都放在一个地方，你就可以开始进一步分解它:在React中，你可以把组件的外观和行为分开。这里有一个例子:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="4eef" class="lc jp ht ky b fi ld le l lf lg">// components/Carousel/View.jsx (view logic only)<br/>export default function CarouselView ({ slides }) {<br/>  return (<br/>    &lt;SomeCarouselPlugin&gt;<br/>      {Array.isArray(slides) &amp;&amp; slides.map(slide =&gt; (<br/>        &lt;CarouselSlide {...slide} /&gt;<br/>      ))}<br/>    &lt;/SomeCarouselPlugin&gt;<br/>  )<br/>}</span><span id="26b7" class="lc jp ht ky b fi lh le l lf lg">// components/Carousel/Jobs.jsx (business logic only)<br/>export default function JobsCarousel () {<br/>  const [jobs, setJobs] = useState(null);<br/>  <br/>  const fetchJobs = async () =&gt; {<br/>    const res = await request({<br/>      url: 'my-api-url.com/jobs?limit=16',<br/>      method: 'GET'<br/>    })<br/>    setJobs(res.data)<br/>  }<br/>  <br/>  useEffect(() =&gt; {<br/>    fetchJobs();<br/>  }, [])<br/>  <br/>  return !!jobs ? (<br/>    &lt;CarouselView slides={jobs.map(job =&gt; ({<br/>      title: job.title,<br/>      description: job.description,<br/>      salary: 'Up to ' + job.salary.max<br/>    }))} /&gt;<br/>  ) : &lt;&gt;Loading...&lt;/&gt;<br/>}</span></pre><p id="f398" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想制作另一个使用相同风格的转盘，也许我们想让转盘装满职员而不是工作，我们可以通过在<code class="du ly lz ma ky b">Carousel/Staff.jsx</code>中创建一个新的容器组件来实现。</p><p id="f022" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这极大地有助于分解具有数百甚至数千行的巨大组件，这种方法意味着如果你想进行更多的定制，你还可以包括额外的层。这个扩展系统使得分解一个组件应该做什么变得更加容易，同时确保你不会重复自己。</p><h1 id="2998" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">5.对容器、文本样式和组件之间使用的任何东西使用类组合</h1><p id="1abd" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">没错:即使组件是真理的来源，定制类仍然有一席之地。例如，您可能会在许多不同的组件上使用一个容器类，具有最大宽度、margin: auto和一些侧边填充。因为这些不太可能改变，所以使用@apply指令构造一个新的定制类是有意义的。</p><p id="3277" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就个人而言，我也喜欢包含排版类，比如标题、标准内容块等等。为这些东西创建一个新的JavaScript组件并没有太大的意义，但是它们在很多地方结合了相同的风格。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="9739" class="lc jp ht ky b fi ld le l lf lg">.page-wrap {<br/>  @apply max-w-page mx-auto px-4 tablet:px-5 laptop:px-6;<br/>}</span><span id="1787" class="lc jp ht ky b fi lh le l lf lg">.paragraph {<br/>  @apply text-16 font-body leading-loose;<br/>}</span><span id="3500" class="lc jp ht ky b fi lh le l lf lg">// we can still create variants of .paragraph<br/>&lt;p class="paragraph text-white"&gt;Hello world!&lt;/p&gt;</span></pre><h1 id="929d" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">6.编写类时，避免使用边距</h1><p id="d89c" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">通过使类与位置无关，可以提高类的可重用性。如果您忽略了仅影响元素位置的属性(如边距),您可以更频繁地重用它。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="52a3" class="lc jp ht ky b fi ld le l lf lg">// _typography.scss</span><span id="7a1c" class="lc jp ht ky b fi lh le l lf lg">.heading-2 {<br/>  @apply text-black text-24 bold;<br/>}</span><span id="09f3" class="lc jp ht ky b fi lh le l lf lg">&lt;h2 className="heading-2 mb-4"&gt;Hello world!&lt;/h2&gt;</span></pre><p id="8f55" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这可能不是你在每种情况下都想要的——也许你<em class="ks">确实</em>想要每个标题都有一定的边距。但是在很多情况下，这是一个值得记住的技巧，它使你的组件更加灵活，更少依赖于它们在页面上的位置。</p><h1 id="77d3" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">7.将tailwind.config.js视为您的真理来源</h1><p id="ae83" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在SCSS或更小的版本中，你可以为常量创建变量，比如颜色、字体和最大宽度。您可以在CSS中的任何地方重用这些变量，如果您更改了变量，这种更改将在使用它的任何地方得到反映。</p><p id="1cb2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">顺风的工作方式也差不多，除了<em class="ks">一切都是由变量定义的。这不仅意味着你可以使用的文本或背景颜色，还包括间距、大小、边框和几乎任何你能想到的属性。您可以通过<code class="du ly lz ma ky b">tailwind.config.js</code>中的<code class="du ly lz ma ky b">theme</code>对象来利用这一点，或者通过<code class="du ly lz ma ky b">extend</code>对象来扩展默认主题。</em></p><p id="0a35" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个文件定义了你的整个应用程序的外观:如果你的设计者使用了一个通常使用像<code class="du ly lz ma ky b">4, 8, 12, 16, 32</code>等数字的设计系统。您可以将该系统直接构建到您CSS中:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="a7e3" class="lc jp ht ky b fi ld le l lf lg">spacing: {<br/>  1: '4px',<br/>  2: '8px',<br/>  3: '12px',<br/>  4: '16px',<br/>}</span></pre><p id="4b5b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后这些类就可以直接使用了，在<code class="du ly lz ma ky b">spacing</code>属性的情况下，这些类将被应用到<code class="du ly lz ma ky b">padding</code>、<code class="du ly lz ma ky b">margin</code>和<code class="du ly lz ma ky b">relative</code>定位类，比如<code class="du ly lz ma ky b">left</code>和<code class="du ly lz ma ky b">right</code>。</p><p id="27de" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不要忘记，您也可以使用常规的JavaScript来生成这些属性，这样可以节省一点时间并清理文件。我喜欢制作一个<code class="du ly lz ma ky b">const</code>，包含一个类似于上面的数组，并使用它作为<code class="du ly lz ma ky b">spacing</code>、<code class="du ly lz ma ky b">width</code>、<code class="du ly lz ma ky b">height</code>和任何其他类似的属性——甚至是<code class="du ly lz ma ky b">font size</code>。</p><p id="26f0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我还考虑过使用<a class="ae kr" href="https://grtcalculator.com/" rel="noopener ugc nofollow" target="_blank">黄金比例</a>生成这样一个间距/字体系统的想法，这可能是快速原型制作的一个很好的选择，同时也保持了很好的视觉效果。</p><h1 id="59dc" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">8.使用工具找出重复的模式</h1><p id="1a67" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">关于构造类的主题，有一些很棒的工具可以帮助您在类列表中找到重复的模式，这样您就可以将它们重构为自己的泛型类。</p><p id="6475" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中最有用的一个是Refactor CSS，这是一个VS代码扩展，可以自动找到并呈现非常相似的类字符串，这有助于找到通用模式以抽象成新的类。如果类字符串有3个以上的类，并且这3个类在当前文档中重复3次以上，则它们将被突出显示。类的顺序被忽略，所以你不需要担心维护一个<a class="ae kr" href="https://www.matuzo.at/blog/ordering-css-properties/" rel="noopener ugc nofollow" target="_blank">属性排序顺序</a>来确保工具工作。</p><p id="917f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你<em class="ks">担心属性排序顺序</em>(如果你担心的话，顺风更易读)，那么你可以使用另一个工具来解决这个问题:<a class="ae kr" href="https://github.com/heybourn/headwind" rel="noopener ugc nofollow" target="_blank">逆风</a>。这个VS代码扩展将在保存时格式化你的Tailwind类，并根据它们的功能对它们进行分组，确保一切都在你期望的地方。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="b9be" class="lc jp ht ky b fi ld le l lf lg">// before saving<br/>&lt;div class="bg-red container mb-6 text-white"&gt;&lt;/div&gt;</span><span id="f4b1" class="lc jp ht ky b fi lh le l lf lg">// after saving<br/>&lt;div class="container mb-6 text-white bg-red"&gt;&lt;/div&gt;</span></pre><p id="b29a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你也可以改变逆风的正则表达式，这样你就可以完全按照你喜欢的方式定制排序顺序。</p><h1 id="fa4e" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="2316" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我不会假装转移到这种工作方式是特别容易的，并且有许多问题仍然需要解决。我们仍然处于实用优先的框架和基于组件的开发的早期，所以一切都还没有搞清楚。</p><p id="69c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管如此，我相信我们会开始看到新的工具、软件包和方法来解决我们可能面临的任何问题。我们从这种方法中得到的是轻量级的、快速的、真正干燥的应用程序。隔离的、独立的组件非常适合跨不同平台构建，所以我认为我们会看到很多构建无头系统的公司采用这种工作方式。</p><p id="3ce9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在我的博客<a class="ae kr" href="https://npmrundev.wordpress.com/" rel="noopener ugc nofollow" target="_blank"> npm run dev </a>上写了更多类似这篇关于无头系统和基于组件的开发的文章。如果你想的话，可以去看看，我很乐意得到一些关于我的想法和写作风格的反馈。感谢阅读！</p></div></div>    
</body>
</html>