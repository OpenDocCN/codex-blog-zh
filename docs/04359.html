<html>
<head>
<title>Load Shedding for Busy Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">繁忙服务的减载</h1>
<blockquote>原文：<a href="https://medium.com/codex/load-shedding-governance-on-busy-services-38193ed4888b?source=collection_archive---------6-----------------------#2021-11-24">https://medium.com/codex/load-shedding-governance-on-busy-services-38193ed4888b?source=collection_archive---------6-----------------------#2021-11-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="43b0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">为什么我们需要减载</h1><p id="b75c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在微服务集群中，调用链是复杂的，作为服务提供者，它需要一种机制来保护自己不被无意识的调用所淹没，并确保自己服务的高可用性。</p><p id="8186" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">最常见的保护机制是限流机制，使用限流器的前提是要知道自己能处理的最大并发数，通常是在上线前通过压力测试得到最大并发数，而在日常的请求过程中每个接口的限流参数都是不同的，而系统一直在不断迭代，其处理能力会经常变化，每次上线前都要进行压力测试，然后调整限流参数，变得非常繁琐。</p><p id="22d9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">那么有没有更简洁的限流机制，可以实现最大程度的自我保护呢？</p><h1 id="0109" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">什么是自适应减载？</h1><p id="34fa" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">自适应减载是保护服务本身的一种非常智能的方式，并根据服务本身的系统负载动态地确定是否需要减载。</p><p id="1697" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">设计目标。</p><ol class=""><li id="1343" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">以确保系统不会崩溃。</li><li id="9109" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">在系统稳定的前提下保持系统吞吐量。</li></ol><p id="1581" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">关键是如何测量服务本身的负载？</p><p id="bc41" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">判断高负载要看CPU是否过载。如果CPU过载，自适应减载将被激活。</p><p id="93a9" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">还需要注意的是，高并发场景的cpu负载和并发往往波动较大，我们从数据上称这种现象为毛刺，可能会导致频繁的auto-download操作，所以我们一般会获取一段时间内指标的平均值，使指标更加平滑。可以通过准确记录一段时间内的指标，然后直接计算平均值来实现，但是会占用一些系统资源。</p><p id="1c50" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">有一种统计算法:指数移动平均，可以用来估计变量的局部平均值，使得变量的更新与一段时间内的历史值相关，不需要记录所有的历史局部变量就可以估计出平均值，节省了宝贵的服务器资源。</p><p id="b0a0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><a class="ae ku" href="https://www.cnblogs.com/wuliytTaotao/p/9479958.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj">滑动平均算法的原理</strong> </a>参见本文获得非常清晰的解释。</p><p id="9b9e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">变量V记为t时刻的Vt，θt为t时刻的变量V值，即不使用滑动平均模型时Vt=θt，使用滑动平均模型后，Vt由下式更新。</p><p id="5f7f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><code class="du kv kw kx ky b">Vt=β⋅Vt-1+(1-β)⋅θt</code></p><ul class=""><li id="1a3c" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kz km kn ko bi translated">β = 0时Vt = θt</li><li id="11ea" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kz km kn ko bi translated">β = 0.9，约为最后10 θt值的平均值</li><li id="e572" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kz km kn ko bi translated">β = 0.99，约为最后100 θt值的平均值</li></ul><h1 id="2783" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">代码实现</h1><p id="e20a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">接下来，让我们看看go-zero自适应负载减少的代码实现。</p><p id="0ed6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><code class="du kv kw kx ky b">core/load/adaptiveshedder.go</code></p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es la"><img src="../Images/46324a94c1fd17d0309fb79020087857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hQ3M-IChroMnhPyF.png"/></div></div></figure><p id="f3d0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">自适应减载接口定义。</p><pre class="lb lc ld le fd lm ky ln lo aw lp bi"><span id="6148" class="lq ig hi ky b fi lr ls l lt lu">// callback function<br/>Promise interface {<br/>    // This function is called back when the request succeeds<br/>    Pass()<br/>    // Callback when the request fails<br/>    Fail()<br/>}<br/>​<br/>// Drop the interface definition<br/>Shedder interface {<br/>    // Drop check<br/>    // 1. Allow the call, you need to manually execute Promise.accept()/reject() to report the actual execution task structure<br/>    // 2. Reject the call and it will return err: Service overloaded error ErrServiceOverloaded<br/>    Allow() (Promise, error)<br/>}</span></pre><p id="536e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">接口定义非常简洁，这意味着它实际上使用起来非常简单，向外界公开了一个“Allow()(Promise，error)。</p><p id="36ff" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">归零用法示例。</p><p id="f128" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">该业务只需要调用该方法来判断是否dowload，如果dowload则直接结束流程，否则该业务的执行最后使用返回值承诺根据回调结果执行即可。</p><pre class="lb lc ld le fd lm ky ln lo aw lp bi"><span id="528d" class="lq ig hi ky b fi lr ls l lt lu">func UnarySheddingInterceptor(shedder load.Shedder, metrics *stat.Metrics) grpc.UnaryServerInterceptor {<br/>    ensureSheddingStat()<br/>​<br/>    return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo,<br/>        handler grpc.UnaryHandler) (val interface{}, err error) {<br/>        sheddingStat.IncrementTotal()<br/>        var promise load.Promise<br/>        // Check if it should be dropped<br/>        promise, err = shedder.Allow()<br/>        // drop the load and record the relevant logs and metrics<br/>        if err ! = nil {<br/>            metrics.AddDrop()<br/>            sheddingStat.IncrementDrop()<br/>            return<br/>        }<br/>        // Final callback execution result<br/>        defer func() {<br/>            // Failed to execute<br/>            if err == context.DeadlineExceeded {<br/>                promise.Fail()<br/>            // Execution succeeded<br/>            } else {<br/>                sheddingStat.IncrementPass()<br/>                Promise.Pass()<br/>            }<br/>        }()<br/>        // Execute the business method<br/>        return handler(ctx, req)<br/>    }<br/>}</span></pre><p id="21e8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">接口实现类定义。</p><p id="b034" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">有三种主要类型的属性</p><ol class=""><li id="8c5c" class="kg kh hi jf b jg kb jk kc jo ki js kj jw kk ka kl km kn ko bi translated">cpu负载阈值:超过这个值意味着cpu处于高负载状态。</li><li id="18e7" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">冷却期:如果服务之前已经被下载，那么它将进入冷却期，目的是防止负载在下载过程中被下载并立即加压导致来回抖动。因为降低负载需要一些时间，所以在冷却期你要继续检查并发数是否超过限制，超过限制就继续丢弃请求。</li><li id="58ae" class="kg kh hi jf b jg kp jk kq jo kr js ks jw kt ka kl km kn ko bi translated">并发:当前正在处理的并发数，当前正在处理的平均并发数，以及最近一段时间的请求数和响应时间，以此来计算当前正在处理的并发数是否大于系统所能承载的最大并发数。</li></ol><pre class="lb lc ld le fd lm ky ln lo aw lp bi"><span id="d0b9" class="lq ig hi ky b fi lr ls l lt lu">// option parameter pattern<br/>ShedderOption func(opts *shedderOptions)<br/>​<br/>// Optional configuration parameters<br/>shedderOptions struct {<br/>    // sliding time window size<br/>    window time.Duration<br/>    // Number of sliding time windows<br/>    buckets int<br/>    // cpu load threshold<br/>    cpuThreshold int64<br/>cpuThreshold int64 }<br/>​<br/>// adaptiveShedder struct, need to implement Shedder interface<br/>adaptiveShedder struct {<br/>    // cpu load threshold<br/>    // higher than the threshold means high load needs to be down loaded to ensure service<br/>    cpuThreshold int64<br/>    // How many buckets in 1s<br/>    windows int64<br/>    // number of concurrent<br/>    flying int64<br/>    // Number of concurrent sliding smoothing<br/>    avgFlying float64<br/>    // Spin lock, one service shares one drop<br/>    // Lock must be applied when counting the number of requests currently being processed<br/>    // lossless concurrency, improves performance<br/>    avgFlyingLock syncx.SpinLock<br/>    // Last rejection time<br/>    dropTime *syncx.AtomicDuration<br/>    // whether it has been rejected recently<br/>    droppedRecently *syncx.AtomicBool<br/>    // request count statistics, with a sliding time window to record metrics for the most recent period<br/>    passCounter *collection.RollingWindow<br/>    // response time statistics, with a sliding time window to record metrics over the most recent period<br/>    rtCounter *collection.RollingWindow<br/>}</span></pre><p id="6a0b" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">自适应dropload构造函数。</p><pre class="lb lc ld le fd lm ky ln lo aw lp bi"><span id="7299" class="lq ig hi ky b fi lr ls l lt lu">func NewAdaptiveShedder(opts . .ShedderOption) Shedder {<br/>    // To ensure code uniformity<br/>    // return the default empty implementation when the developer closes, to achieve code uniformity<br/>    // go-zero uses this design in many places, such as Breaker, the logging component<br/>    if !enabled.True() {<br/>        return newNopShedder()<br/>    }<br/>    // options mode sets optional configuration parameters<br/>    options := shedderOptions{<br/>        // Default statistics for the last 5s<br/>        window: defaultWindow,<br/>        // default bucket count of 50<br/>        buckets: defaultBuckets,<br/>        // cpu load<br/>        cpuThreshold: defaultCpuThreshold,<br/>    }<br/>    for _, opt := range opts {<br/>        opt(&amp;options)<br/>    }<br/>    // Calculate the interval for each window, default is 100ms<br/>    bucketDuration := options.window / time.Duration(options.buckets)<br/>    return &amp;adaptiveShedder{<br/>        // cpu load<br/>        cpuThreshold: options.cpuThreshold,<br/>        // How many sliding window units are contained in 1s of time<br/>        windows: int64(time.Second / bucketDuration),<br/>        // last rejection time<br/>        dropTime: syncx.NewAtomicDuration(),<br/>        // whether it has been rejected recently<br/>        droppedRecently: syncx.NewAtomicBool(),<br/>        // qps statistics, sliding time window<br/>        // ignore the current writing window (bucket), incomplete time period may lead to data exceptions<br/>        NewRollingWindow(options.buckets, bucketDuration.), // passCounter: collection,<br/>            IgnoreCurrentBucket()),<br/>        // Response time statistics, sliding time window<br/>        // Ignore the current writing window (bucket), incomplete time period may lead to data exceptions<br/>        rtCounter: collection.NewRollingWindow(options.buckets, bucketDuration,<br/>            collection.IgnoreCurrentBucket()),<br/>    }<br/>}</span></pre><p id="99f6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">跌落检查<code class="du kv kw kx ky b">Allow()</code>。</p><p id="7ab5" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">检查当前请求是否应该被丢弃，如果被丢弃，业务侧需要直接中断请求以保护服务，这也意味着在进入冷却期时减载生效。如果释放，则返回承诺，并等待业务方执行回调函数来执行指标统计。</p><pre class="lb lc ld le fd lm ky ln lo aw lp bi"><span id="3ff1" class="lq ig hi ky b fi lr ls l lt lu">// Drop check<br/>func (as *adaptiveShedder) Allow() (Promise, error) {<br/>    // Check if the request was dropped<br/>    if as.shouldDrop() {<br/>        // Set the drop time<br/>        as.dropTime.Set(timex.Now())<br/>        // Recently dropped<br/>        as.droppedRecently.Set(true)<br/>        // return overloaded<br/>        return nil, ErrServiceOverloaded<br/>    }<br/>    // Add 1 to the number of requests being processed<br/>    as.addFlying(1)<br/>    // Each allowed request here returns a new promise object<br/>    // promise holds the drop pointer object internally<br/>    return &amp;promise{<br/>        start: timex.Now(),<br/>        shedder: as,<br/>    }, nil<br/>}</span></pre><p id="f122" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">检查是否<code class="du kv kw kx ky b">shouldDrop()</code>。</p><pre class="lb lc ld le fd lm ky ln lo aw lp bi"><span id="d517" class="lq ig hi ky b fi lr ls l lt lu">// whether the request should be dropped or not<br/>func (as *adaptiveShedder) shouldDrop() bool {<br/>    // The current cpu load exceeds the threshold<br/>    // The service should continue to check the load and try to drop the request while it is on cooldown<br/>    if as.systemOverloaded() || as.stillHot() {<br/>        // Check if the concurrency being processed exceeds the current maximum number of concurrency that can be hosted<br/>        // Discard the request if it exceeds it<br/>        if as.highThru() {<br/>            flying := atomic.LoadInt64(&amp;as.flying)<br/>            as.avgFlyingLock.Lock()<br/>            avgFlying := as.avgFlying<br/>            as.avgFlyingLock.Unlock()<br/>            msg := fmt.Sprintf(<br/>                "dropreq, cpu: %d, maxPass: %d, minRt: %.2f, hot: %t, flying: %d, avgFlying: %.2f",<br/>                stat.CpuUsage(), as.maxPass(), as.minRt(), as.stillHot(), flying, avgFlying)<br/>            logx.Error(msg)<br/>            stat.Report(msg)<br/>            return true<br/>        }<br/>    }<br/>    return false<br/>}</span></pre><p id="b8a1" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">cpu阈值检查<code class="du kv kw kx ky b">systemOverloaded()</code>。</p><p id="cd38" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">cpu负载值计算算法使用滑动平均算法来防止出现毛刺。每250ms采样β为0.95，大致相当于历史上20次cpu负载的平均值，时间段约为5s。</p><pre class="lb lc ld le fd lm ky ln lo aw lp bi"><span id="650e" class="lq ig hi ky b fi lr ls l lt lu">// whether the cpu is overloaded<br/>func (as *adaptiveShedder) systemOverloaded() bool {<br/>    return systemOverloadChecker(as.cpuThreshold)<br/>}<br/>​<br/>// cpu checker function<br/>systemOverloadChecker = func(cpuThreshold int64) bool {<br/>        return stat.CpuUsage() &gt;= cpuThreshold<br/>}<br/>​<br/>// cpu sliding average<br/>curUsage := internal.RefreshCpu()<br/>prevUsage := atomic.LoadInt64(&amp;cpuUsage)<br/>// cpu = cpuᵗ-¹ * beta + cpuᵗ * (1 - beta)<br/>// sliding average algorithm<br/>usage := int64(float64(prevUsage)*beta + float64(curUsage)*(1 - beta))<br/>atomic.StoreInt64(&amp;cpuUsage, usage)</span></pre><p id="1cce" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">检查系统是否处于冷却期<code class="du kv kw kx ky b">stillHot</code>:</p><p id="6d78" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">确定当前系统是否处于冷却期，如果是，它应该继续尝试检查请求是否被丢弃。主要目的是防止系统在从过载恢复的过程中负载还没有降下来，就立即再次增加压力从而导致来回抖动，此时应该尝试继续丢弃请求。</p><pre class="lb lc ld le fd lm ky ln lo aw lp bi"><span id="3eb2" class="lq ig hi ky b fi lr ls l lt lu">func (as *adaptiveShedder) stillHot() bool {<br/>    // No requests have been dropped recently<br/>    // means the service is fine<br/>    if !as.droppedRecently.True() {<br/>        return false<br/>    }<br/>    // Not on cooldown<br/>    dropTime := as.dropTime.Load()<br/>    if dropTime == 0 {<br/>        return false<br/>    }<br/>    // cool down time defaults to 1s<br/>    hot := timex.Since(dropTime) &lt; coolOffDuration<br/>    // not in the cool off period, normal processing of requests in progress<br/>    if !hot {<br/>        // reset the drop record<br/>        as.droppedRecently.Set(false)<br/>    }<br/>​<br/>    return hot<br/>}</span></pre><p id="810d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">检查当前正在处理的并发数<code class="du kv kw kx ky b">highThru()</code>。</p><p id="14f2" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">一旦<strong class="jf hj">当前并发被处理&gt;并发承载极限</strong>则进入下载状态。</p><p id="a7a0" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为什么我们需要在这里添加锁？因为全局使用自适应降级来确保并发平均值是正确的。</p><p id="0362" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">为什么我们需要在这里添加自旋锁？因为并发处理可以在不阻塞其他goroutine执行任务的情况下完成，使用无锁并发来提高性能。</p><pre class="lb lc ld le fd lm ky ln lo aw lp bi"><span id="b0ea" class="lq ig hi ky b fi lr ls l lt lu">func (as *adaptiveShedder) highThru() bool {<br/>    // locking<br/>    as.avgFlyingLock.Lock()<br/>    // Get the sliding average<br/>    // update at the end of each request<br/>    avgFlying := as.avgFlying<br/>    // Unlock<br/>    as.avgFlyingLock.Unlock()<br/>    // Maximum number of concurrent requests at this point in the system<br/>    maxFlight := as.maxFlight()<br/>    // whether the number of concurrent processes and the average number of concurrent processes is greater than the system's maximum number of concurrent processes<br/>    return int64(avgFlying) &gt; maxFlight &amp;&amp; atomic.LoadInt64(&amp;as.flying) &gt; maxFlight<br/>}</span></pre><p id="693a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">我如何获得正在处理的并发数与平均并发数的比值？</p><p id="b779" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">目前的并发计数其实很简单:每个允许的请求+1并发，请求完成后的promise对象回调-1并发，平均并发可以用滑动平均算法求解。</p><pre class="lb lc ld le fd lm ky ln lo aw lp bi"><span id="6a8e" class="lq ig hi ky b fi lr ls l lt lu">type promise struct {<br/>    // request start time<br/>    // count the time spent on request processing<br/>    start time.<br/>    shedder *adaptiveShedder<br/>shedder *adaptiveShedder }<br/>​<br/>func (p *promise) Fail() {<br/>    // End of request, -1 for the number of requests currently being processed<br/>    p.shedder.addFlying(-1)<br/>}<br/>​<br/>func (p *promise) Pass() {<br/>    // response time in milliseconds<br/>    rt := float64(timex.Since(p.start)) / float64(time.Millisecond)<br/>    // end of request, number of requests currently being processed -1<br/>    p.shedder.addFlying(-1)<br/>    p.shedder.rtCounter.Add(math.Ceil(rt))<br/>    p.shedder.passCounter.Add(1)<br/>}<br/>​<br/>func (as *adaptiveShedder) addFlying(delta int64) {<br/>    flying := atomic.AddInt64(&amp;as.flying, delta)<br/>    // After the request ends, count the concurrency of requests currently being processed<br/>    if delta &lt; 0 {<br/>        as.avgFlyingLock.Lock()<br/>        // Estimate the average number of requests for the current service over the recent time period<br/>        as.avgFlying = as.avgFlying*flyingBeta + float64(flying)*(1-flyingBeta)<br/>        as.avgFlyingLock.Unlock()<br/>    }<br/>}</span></pre><p id="132a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">仅仅获得当前的系统计数是不够的，我们还需要知道系统可以处理的最大并发请求数，即最大并发请求数。</p><p id="6a44" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">通过一个滑动窗口来实现请求的传递数量和响应时间，可以在<code class="du kv kw kx ky b">Adaptive Fuse</code>文章中实现。</p><p id="e5c3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">当前系统的最大并发数=窗口单位时间的最大通过次数*窗口单位时间的最小响应时间。</p><pre class="lb lc ld le fd lm ky ln lo aw lp bi"><span id="d2e8" class="lq ig hi ky b fi lr ls l lt lu">// Calculate the maximum concurrency of the system per second<br/>// max concurrency = max requests (qps) * min response time (rt)<br/>func (as *adaptiveShedder) maxFlight() int64 {<br/>    // windows = buckets per second<br/>    // maxQPS = maxPASS * windows<br/>    // minRT = min average response time in milliseconds<br/>    // maxQPS * minRT / milliseconds_per_second<br/>    // as.maxPass() * as.windows - maximum qps per bucket * number of buckets contained in 1s<br/>    // as.minRt()/1e3 - the smallest average response time of all buckets in the window / 1000ms here to convert to seconds<br/>    return int64(math.Max(1, float64(as.maxPass()*as.windows)*(as.minRt()/1e3)))<br/>}    <br/>​<br/>// Sliding time window with multiple buckets<br/>// find the one with the highest number of requests<br/>// Each bucket takes up internal ms<br/>// qps refers to the number of requests in 1s, qps: maxPass * time.Second/internal<br/>func (as *adaptiveShedder) maxPass() int64 {<br/>    var result float64 = 1<br/>    // The bucket with the highest number of requests in the current time window<br/>    as.passCounter.Reduce(func(b *collection.Bucket) {<br/>        if b.Sum &gt; result {<br/>            result = b.Sum<br/>        }<br/>    })<br/>​<br/>    return int64(result)<br/>}<br/>​<br/>// Sliding time window with multiple buckets<br/>// Calculate the minimum average response time<br/>// because it is necessary to calculate the maximum number of concurrency the system can handle in a recent period of time<br/>func (as *adaptiveShedder) minRt() float64 {<br/>    // default is 1000ms<br/>    result := defaultMinRt<br/>​<br/>    as.rtCounter.Reduce(func(b *collection.Bucket) {<br/>        if b.Count &lt;= 0 {<br/>            return<br/>        }<br/>        // request average response time<br/>        avg := math.Round(b.Sum / float64(b.Count))<br/>        if avg &lt; result {<br/>            result = avg<br/>        }<br/>    })<br/>    <br/>    return result<br/>}</span></pre><h1 id="5f14" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考</h1><p id="2c6b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae ku" href="https://queue.acm.org/detail.cfm?id=3022184" rel="noopener ugc nofollow" target="_blank">谷歌BBR拥塞控制算法</a></p><p id="09f6" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><a class="ae ku" href="https://www.cnblogs.com/wuliytTaotao/p/9479958.html" rel="noopener ugc nofollow" target="_blank">滑动平均算法原理</a></p><p id="10a3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><a class="ae ku" href="https://go-zero.dev/cn/loadshedding.html" rel="noopener ugc nofollow" target="_blank">归零自适应减载</a></p><h1 id="ed56" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">项目地址</h1><p id="1d6e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae ku" href="https://github.com/zeromicro/go-zero" rel="noopener ugc nofollow" target="_blank">https://github.com/zeromicro/go-zero</a></p><p id="617f" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">随时用<code class="du kv kw kx ky b">go-zero</code>和<strong class="jf hj">明星</strong>支持我们！</p></div></div>    
</body>
</html>