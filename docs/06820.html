<html>
<head>
<title>The FIFO fallacy of event-driven architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">事件驱动架构的FIFO谬误</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-fifo-fallacy-of-event-driven-architecture-8742477fefd0?source=collection_archive---------3-----------------------#2022-05-15">https://medium.com/codex/the-fifo-fallacy-of-event-driven-architecture-8742477fefd0?source=collection_archive---------3-----------------------#2022-05-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/cbef6d11df3b06d2c52f4fda8e508384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGhEGUgBWxPhlN02KX1jCQ.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由Tranmautritam拍摄:<a class="ae hv" href="https://www.pexels.com/photo/cute-tabby-kitten-on-a-sofa-2194261/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/cute-tabby-kitten-on-a-sofa-2194261/</a></figcaption></figure><div class=""/><p id="0df5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近，不同的团队问我同样的问题:</p><p id="a88e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们对域事件的顺序做些什么？我们的消息总线有这个很好的FIFO特性，但是不知何故我们的解决方案变得非常复杂！</p><p id="8eb5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我:如果你依赖事件的顺序，那你就错了。这是事件驱动架构中的反模式。</p><p id="210b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">他们:但这怎么可能是反模式，我们的消息总线可以被配置为保证消息在队列中的顺序。</p><p id="1c81" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我:嗯，你可以，不代表你应该。</p><h2 id="a2d7" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">耦合服务</strong></h2><p id="c3f7" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">事件驱动架构描述了去耦服务之间的异步消息传递系统。这意味着生产者和消费者都不应该知道或对彼此做任何假设。但是对消息进行排序并依赖它们却恰恰相反。</p><p id="9adc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的服务通过引入生产者的假设和消费者的假设来耦合，生产者假设有一个消费者将按顺序处理事件，消费者假设生产者将严格按顺序发送那些消息。</p><p id="6df8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分布式紧耦合服务最终导致了所谓的分布式整体结构，在这种结构中，我们得到了两个世界的最坏情况:分布式系统的复杂性和整体系统的紧耦合性。</p><h2 id="5b92" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">事件信息太多</strong></h2><p id="f6e9" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我能想到的排序需求的一个原因是，消息包括将由消费者直接处理的数据负载。但这更类似于分布式事务，而不是其他任何事务。让我们看一个简单的“反”例子。</p><p id="4a47" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们有一个计数器和一个更新计数器并发布事件“计数器更新”的<strong class="ix hz">服务A </strong>。此外，我们有一个<strong class="ix hz">服务B </strong>，它有自己的计数器副本，并订阅“计数器更新”事件。</p><p id="2060" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在想象一下，服务A总是将当前值包含到“计数器更新”事件中，而服务B只是用这个值来更新它自己的副本。我们迟早会遇到数据库中一个众所周知的并发问题:更新丢失问题。如果序列</p><ul class=""><li id="c4fa" class="kt ku hy ix b iy iz jc jd jg kv jk kw jo kx js ky kz la lb bi translated">"计数器更新:值=1 "</li><li id="0c1c" class="kt ku hy ix b iy lc jc ld jg le jk lf jo lg js ky kz la lb bi translated">"计数器更新:值=2 "</li></ul><p id="cb3f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">出了故障，那么服务B的计数器最后将是1而不是2。</p><p id="e91d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">解决方案很简单:服务A不应该在消息中包含真正的值，而应该只包含一个服务B或任何其他消费者可以找到当前值的引用。现在，消息的顺序并不重要，因为服务B将总是从指定的位置获取最新的值。</p><p id="c908" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果更新的不是一个计数器，而是一个大的数据结构。许多消息传递系统对消息大小有严格的限制。我们的新解决方案是可行的，因为它只包含了对真实数据的引用。</p><h2 id="1e45" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated"><strong class="ak">基础设施的责任太大</strong></h2><p id="7d18" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">最后，关于事件顺序的假设是由某些业务规则驱动的。例如，客户总是在更新之前创建。但是这个不变量在我们的领域模型中没有被强制执行，相反，它已经成为基础设施的责任。我们的领域模型现在更加脆弱，逻辑上依赖于基础设施，这显然是错误的依赖方向。</p><p id="8333" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总之，依赖域事件的顺序不是一个好主意。尽管有针对FIFO队列的技术解决方案，但它们并不适合事件驱动的架构。</p></div></div>    
</body>
</html>