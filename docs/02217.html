<html>
<head>
<title>C++20 three way comparison operator: Part 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++20三向比较运算符:第5部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/c-20-three-way-comparison-operator-part-5-e986b5ab29d9?source=collection_archive---------3-----------------------#2021-07-08">https://medium.com/codex/c-20-three-way-comparison-operator-part-5-e986b5ab29d9?source=collection_archive---------3-----------------------#2021-07-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/04da347af45f1fa31dc6e62303fa369f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jX2_IkYGpUJIN6JvFpnohA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片:gajendra gulgulia</figcaption></figure><p id="0c42" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在教程的<a class="ae js" rel="noopener" href="/nerd-for-tech/c-20-three-way-comparison-operator-part-4-6a8ea2c0a3f0"> <strong class="iw hj">第四部分</strong> </a>中，我介绍了C++20中三元运算符返回类型背后的理论思想，并演示了程序中可能存在语义限制，允许比较等价而不是相等。我还通过一个简单的例子演示了什么时候两个对象在语义上是不可比的，即使程序的语法允许比较它们，以及如何借助于<code class="du jt ju jv jw b">operator&lt;=&gt;</code>来处理这种情况。</p><p id="70ad" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在教程的这一部分，我将解释<code class="du jt ju jv jw b"><a class="ae js" href="https://en.cppreference.com/w/cpp/header/compare" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">compare</strong></a></code>头中三个比较类别中的一个，它是三元运算符的返回类型，即<code class="du jt ju jv jw b">std::strong_ordering</code>。更具体地说，本教程将有助于理解使用cpp参考页中的<code class="du jt ju jv jw b">std::strong_ordering</code>的规则，并将指导开发者在定义自定义<code class="du jt ju jv jw b">operator&lt;=&gt;</code>时何时返回<code class="du jt ju jv jw b">std::strong_ordering</code>。</p><p id="6132" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">回忆第四部分的代码片段:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="6ab4" class="kf kg hi jw b fi kh ki l kj kk">MyClass obj1{1, 'a'};<br/>MyClass obj1{2, 'b'};<br/>auto intermediateResult = obj1 &lt;=&gt; obj2;<br/>bool result = intermediateResult &lt; 0;</span></pre><p id="8bb1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们想了解当<code class="du jt ju jv jw b">intermediateResult</code>的类型为<code class="du jt ju jv jw b">std::strong_ordering</code>时的条件，以及<strong class="iw hj"> <em class="kl">强命令</em> </strong>意味着什么。</p><h1 id="71e0" class="km kg hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">1.<code class="du jt ju jv jw b">std::strong_ordering</code></h1><p id="ccc2" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated"><code class="du jt ju jv jw b">std::strong_ordering</code>上的cpp参考页说明如下:</p><blockquote class="lo lp lq"><p id="63ca" class="iu iv kl iw b ix iy iz ja jb jc jd je lr jg jh ji ls jk jl jm lt jo jp jq jr hb bi translated">(1)接受所有六个关系运算符(<code class="du jt ju jv jw b">==</code>、<code class="du jt ju jv jw b">&gt;=</code>、<code class="du jt ju jv jw b">&lt;=</code>、<code class="du jt ju jv jw b">!=</code>、<code class="du jt ju jv jw b">&gt;</code>、<code class="du jt ju jv jw b">&lt;</code>)</p><p id="f1f1" class="iu iv kl iw b ix iy iz ja jb jc jd je lr jg jh ji ls jk jl jm lt jo jp jq jr hb bi translated">(2)隐含可替代性:如果<code class="du jt ju jv jw b">a</code>等价于<code class="du jt ju jv jw b">b</code> , <code class="du jt ju jv jw b">f(a)</code>也等价于<code class="du jt ju jv jw b"><em class="hi">f(b)</em></code>，其中<code class="du jt ju jv jw b"><em class="hi">f</em></code>表示一个函数，它只读取可通过参数的公共const成员访问的比较突出状态。换句话说，等值是无法区分的。</p><p id="5998" class="iu iv kl iw b ix iy iz ja jb jc jd je lr jg jh ji ls jk jl jm lt jo jp jq jr hb bi translated">(3)不允许不可比的值:<code class="du jt ju jv jw b">a &lt; b</code>、<code class="du jt ju jv jw b"><em class="hi">a ==b</em></code>或<code class="du jt ju jv jw b"><em class="hi">a &gt; b</em></code>中必须有一个是<code class="du jt ju jv jw b">true</code></p></blockquote><p id="dfd1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们试着一个一个地理解上面的规则。</p><h2 id="caa0" class="kf kg hi bd kn lu lv lw kr lx ly lz kv jf ma mb kz jj mc md ld jn me mf lh mg bi translated">1.1允许所有六个关系运算符…</h2><p id="a3ef" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">考虑上面代码片段中初始化<code class="du jt ju jv jw b">intermediateResult</code>的部分</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="b693" class="kf kg hi jw b fi kh ki l kj kk">auto intermediateResult = obj1 &lt;=&gt; obj2;</span></pre><p id="ce84" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们暂时假设<code class="du jt ju jv jw b">intermediateResult</code>属于<code class="du jt ju jv jw b">std::strong_ordering</code>类型，这仅仅意味着所有六个关系运算符(<code class="du jt ju jv jw b"><em class="kl">==</em></code>、<code class="du jt ju jv jw b"><em class="kl">&gt;=</em></code>、<code class="du jt ju jv jw b"><em class="kl">&lt;=</em></code>、<code class="du jt ju jv jw b"><em class="kl">!=</em></code>、<code class="du jt ju jv jw b"><em class="kl">&gt;</em></code>、<code class="du jt ju jv jw b"><em class="kl">&lt;</em></code>)都可以应用于<code class="du jt ju jv jw b">intermediateResult</code>，但是问题是它只能与文字<code class="du jt ju jv jw b">0</code>进行比较:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="884c" class="kf kg hi jw b fi kh ki l kj kk">bool res1 = <!-- -->intermediateResult == 0<br/>bool <!-- -->res2 = <!-- -->intermediateResult &gt;= 0<br/>bool res3 = <!-- -->intermediateResult &lt;= 0<br/>bool res4 = <!-- -->intermediateResult != 0<br/>bool res5 = <!-- -->intermediateResult &lt;  0<br/>bool res6 = <!-- -->intermediateResult &gt; 0<!-- --> </span></pre><p id="4987" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="kl">“接受关系运算符……”</em></strong>简单地说，关系运算符可以与三元运算符一起使用。</p><h2 id="5b83" class="kf kg hi bd kn lu lv lw kr lx ly lz kv jf ma mb kz jj mc md ld jn me mf lh mg bi translated">1.2隐含可替代性:如果<code class="du jt ju jv jw b"><em class="mh">a</em></code>等价于<code class="du jt ju jv jw b"><em class="mh">b</em></code>，<code class="du jt ju jv jw b"><em class="mh">f(a)</em></code>也等价于<code class="du jt ju jv jw b"><em class="mh">f(b) ...</em></code></h2><p id="d7f8" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">为了理解第二条规则，我需要再解释几个出现在第二条规则中的术语:</p><p id="e1d1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">(1)一个对象的<strong class="iw hj"> <em class="kl">值</em></strong>:<br/>在C++中，一个对象的<strong class="iw hj"> <em class="kl">值</em> </strong>是可以用来比较该对象与另一个对象的属性。对于一个简单的<code class="du jt ju jv jw b">int i = 29</code>对象，<code class="du jt ju jv jw b">i</code>的值是其寄存器中保存的值，即数字<code class="du jt ju jv jw b">29</code>，而不是对象<code class="du jt ju jv jw b">i</code>在内存中分配的地址。对于C样式字符串:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="8c7a" class="kf kg hi jw b fi kh ki l kj kk">char* str[] = "hello"</span></pre><p id="c9f2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该值既是字符串<code class="du jt ju jv jw b">hello</code>又是指针分配的地址。不严格地说，对象的值取决于程序和所用对象的语义，以及两个值何时相等</p><p id="5bbc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">(2) <strong class="iw hj"> <em class="kl">一个对象的显著属性</em></strong>:<br/>c++中的一个自定义对象有类成员<strong class="iw hj"> <em class="kl">可以</em> </strong>共同定义对象的值。我说..<strong class="iw hj"> <em class="kl">可以</em> </strong>合起来……’因为所有成员对定义对象的值都没有用。例如，<code class="du jt ju jv jw b">std::vector</code>有一个指向存储数组的内存的指针，成员函数<code class="du jt ju jv jw b">size()</code>和<code class="du jt ju jv jw b">capacity()</code>、<code class="du jt ju jv jw b">push_back()</code>、<code class="du jt ju jv jw b">empty()</code>等等。但是在比较两个<code class="du jt ju jv jw b">std::vector</code>时，只对数组的内容和大小感兴趣。换句话说，当数组的内容相等时，两个<code class="du jt ju jv jw b">std::vector</code>对象相等。因此这些就是<code class="du jt ju jv jw b">std::vector</code>的<strong class="iw hj"> <em class="kl">显著特性</em> </strong>。</p><p id="9bc7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">任何能够读取<code class="du jt ju jv jw b">std::vector</code>对象的显著属性并基于这些显著属性返回值的函数<code class="du jt ju jv jw b">f</code>都被认为是可替换函数，并且可以与关系比较运算符一起使用(关系比较运算符<code class="du jt ju jv jw b">==</code>、<code class="du jt ju jv jw b">&gt;=</code>、<code class="du jt ju jv jw b">&lt;=</code>、<code class="du jt ju jv jw b">!=</code>、<code class="du jt ju jv jw b">&gt;</code>、<code class="du jt ju jv jw b">&lt;</code>中的一个)。这些函数可以是成员函数，也可以是非成员函数。在<code class="du jt ju jv jw b">std::vector</code>的情况下，可替代功能的例子有<code class="du jt ju jv jw b">size()</code>和<code class="du jt ju jv jw b">empty()</code>。不读取对象显著属性的函数示例有<code class="du jt ju jv jw b">capacity()</code>和<code class="du jt ju jv jw b">push_back()</code>，因此它们是不可替代的。</p><p id="19bb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了证明这些事实，考虑两个<code class="du jt ju jv jw b"><a class="ae js" href="https://en.cppreference.com/w/cpp/container/vector" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">std::vector&lt;T&gt;</strong></a></code>对象的例子，这两个对象提供了自C++20以来的三路操作符，可用于获得两个对象之间的相等关系:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="9d47" class="kf kg hi jw b fi kh ki l kj kk">#include &lt;iostream&gt;<br/>#include &lt;compare&gt;<br/>#include &lt;vector&gt;</span><span id="5397" class="kf kg hi jw b fi mi ki l kj kk">void fillIntVectorFrom1To100(std::vector&lt;int&gt;&amp; vec)<br/>{<br/>    for(int i{0}; i&lt;=100; ++i)<br/>    {<br/>        vec.push_back(i);<br/>    }<br/>}</span><span id="7a55" class="kf kg hi jw b fi mi ki l kj kk">int main(){<br/>    std::vector&lt;int&gt; v1, v2;<br/>    v1.reserve(10000);<br/>    v2.reserve(9999);<br/>    <br/>    fillIntVectorFrom1To100(v1);<br/>    fillIntVectorFrom1To100(v2);</span><span id="5ea4" class="kf kg hi jw b fi mi ki l kj kk">    std::cout &lt;&lt; "Are vectors equal: " &lt;&lt; ((v1 &lt;=&gt; v2)==0) &lt;&lt; "\n";</span><span id="6d41" class="kf kg hi jw b fi mi ki l kj kk">    std::cout &lt;&lt; "Are capacities equal: " <br/>              &lt;&lt; (v1.capacity() == v2.capacity()) &lt;&lt; "\n";</span><span id="84f1" class="kf kg hi jw b fi mi ki l kj kk">    std::cout &lt;&lt; "Are sizes equal: " <br/>              &lt;&lt; (v1.size() == v2.size()) &lt;&lt; "\n";</span><span id="e310" class="kf kg hi jw b fi mi ki l kj kk">stdout<br/>------<br/>true<br/>false<br/>true</span></pre><p id="3c3a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">注意在上面的例子中,<code class="du jt ju jv jw b">operator&lt;=&gt;</code>是如何在<code class="du jt ju jv jw b">std::vector</code>对象上被调用来进行比较的，以证明它在自C++20以来的大多数标准库组件中都是可用的。显然，<code class="du jt ju jv jw b">operator&lt;=&gt;</code>并不依赖于两个向量的容量来进行比较。它只依靠可替换的函数调用(如果有的话)来检查相等性。上面的例子也可以在<a class="ae js" href="https://godbolt.org/z/veMnGsf7o" rel="noopener ugc nofollow" target="_blank">这里找到</a>。</p><p id="d61e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">类似地，对于<code class="du jt ju jv jw b">std::shared_ptr</code>,值是指针指向的指针对象和非控制计数或我们在解引用指针后得到的值。为了证明这一点，考虑下面的例子，当两个不同的<code class="du jt ju jv jw b">std::shared_ptr</code>具有完全相同的被指向的值(值<code class="du jt ju jv jw b">1</code>)时，它打印出<code class="du jt ju jv jw b">false</code>。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="4f1c" class="kf kg hi jw b fi kh ki l kj kk">#include &lt;memory&gt;<br/>#include &lt;compare&gt;<br/>#include &lt;iostream&gt;</span><span id="d54d" class="kf kg hi jw b fi mi ki l kj kk">int main(){<br/>    std::cout &lt;&lt; std::boolalpha;<br/>    <br/>    std::shared_ptr&lt;int&gt; sptr1 = std::make_shared&lt;int&gt;(1);<br/>    std::shared_ptr&lt;int&gt; sptr2 = std::make_shared&lt;int&gt;(1);<br/>    std::shared_ptr&lt;int&gt; sptr3 = sptr1;</span><span id="8558" class="kf kg hi jw b fi mi ki l kj kk">   std::cout &lt;&lt; ((sptr1 &lt;=&gt; sptr2) == 0) &lt;&lt; "\n";<br/>   std::cout &lt;&lt; ((sptr1 &lt;=&gt; sptr3) == 0) &lt;&lt; "\n";</span><span id="dff4" class="kf kg hi jw b fi mi ki l kj kk">stdout<br/>-------<br/>false<br/>true</span></pre><p id="e42f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要记住的主要思想应该作为一个强有力的提示来指导开发，以及何时应该从对象上的自定义<code class="du jt ju jv jw b">operator&lt;=&gt;</code>返回<code class="du jt ju jv jw b">std::strong_ordering</code>:</p><ol class=""><li id="f074" class="mj mk hi iw b ix iy jb jc jf ml jj mm jn mn jr mo mp mq mr bi translated">在<code class="du jt ju jv jw b">operator&lt;=&gt;</code>的主体中，成员按照顺序和字典顺序进行比较。在这种情况下，默认值<code class="du jt ju jv jw b">operator&lt;=&gt;</code>就足够了。</li><li id="1024" class="mj mk hi iw b ix ms jb mt jf mu jj mv jn mw jr mo mp mq mr bi translated">在<code class="du jt ju jv jw b">operator&lt;=&gt;</code>的主体中，成员需要按顺序或无序进行比较，应在每个成员上使用<code class="du jt ju jv jw b">operator&lt;=&gt;</code>进行比较。</li><li id="6953" class="mj mk hi iw b ix ms jb mt jf mu jj mv jn mw jr mo mp mq mr bi translated">在比较主体<code class="du jt ju jv jw b">operator&lt;=&gt;</code>中对象的成员时，它们本身应该返回<code class="du jt ju jv jw b">std::strong_ordering</code>(参见<a class="ae js" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0515r3.pdf" rel="noopener ugc nofollow" target="_blank">一致性比较</a>论文第1.4.2节中的示例和下面的第2.1节)</li><li id="f580" class="mj mk hi iw b ix ms jb mt jf mu jj mv jn mw jr mo mp mq mr bi translated">在<code class="du jt ju jv jw b">operator&lt;=&gt;</code>的主体中，只有可替换函数(成员或非成员)被调用来进行比较，即只使用对象的显著属性来比较值的函数。</li></ol><p id="85e0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们最后看看cppreference页面中的第三条也是最后一条语句</p><h2 id="cee8" class="kf kg hi bd kn lu lv lw kr lx ly lz kv jf ma mb kz jj mc md ld jn me mf lh mg bi translated">1.3.不允许不可比的值:必须有<code class="du jt ju jv jw b"><em class="mh">a &lt; b</em></code>、<code class="du jt ju jv jw b"><em class="mh">a == b</em></code>或<code class="du jt ju jv jw b"><em class="mh">a &gt; b</em></code>中的一个为<code class="du jt ju jv jw b"><em class="mh">true</em></code></h2><p id="e248" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">如果您还记得本系列教程第四部分 的<a class="ae js" rel="noopener" href="/nerd-for-tech/c-20-three-way-comparison-operator-part-4-6a8ea2c0a3f0"> <strong class="iw hj">的第2.1节，其中我举例说明了两个对象何时不可比较，除了1.1和1.2小节中描述的所有规则都成立之外，对象必须是可比较的，并且除了<code class="du jt ju jv jw b">!=</code>之外，<code class="du jt ju jv jw b">&gt;</code>、<code class="du jt ju jv jw b">&lt;</code>或<code class="du jt ju jv jw b">==</code>中的一个应该返回<code class="du jt ju jv jw b">true</code>，因为自定义<code class="du jt ju jv jw b">operator&lt;=&gt;</code>返回<code class="du jt ju jv jw b">std::strong_ordering</code>。</strong></a></p><h1 id="a961" class="km kg hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">2.需要注意的要点</h1><p id="ff8f" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">在这一节中，我想用刚才提到的例子来详细解释一些想法，以支持概念并形成清晰的理解。</p><h2 id="0dc2" class="kf kg hi bd kn lu lv lw kr lx ly lz kv jf ma mb kz jj mc md ld jn me mf lh mg bi translated">2.1类对象必须有返回<code class="du jt ju jv jw b">std::strong_ordering</code>的成员</h2><p id="770d" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">我之前提到过，为了让<code class="du jt ju jv jw b">operator&lt;=&gt;</code>的主体返回<code class="du jt ju jv jw b">std::strong_ordering</code>，所有成员都应该使用<code class="du jt ju jv jw b">&lt;=&gt;</code>进行比较，并且它们都必须返回<code class="du jt ju jv jw b">std::strong_ordering</code>，要么显式返回，要么用<code class="du jt ju jv jw b">auto</code>进行推导。首先考虑以下带有默认<code class="du jt ju jv jw b">operator&lt;=&gt;</code>的示例:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="99fe" class="kf kg hi jw b fi kh ki l kj kk">#include &lt;compare&gt;<br/>#include &lt;iostream&gt;<br/>#include &lt;typeinfo&gt; //needed to print type of object</span><span id="57a2" class="kf kg hi jw b fi mi ki l kj kk">class Person{<br/>    private:<br/>        std::string name_;<br/>        int age_;<br/>    public:<br/>        Person(std::string name, int age): name_{name}, age_{age}<br/>        {           //empty body           }<br/>        <br/>        auto operator&lt;=&gt;(const Person&amp; rhs) const = default;<br/>};</span><span id="cffc" class="kf kg hi jw b fi mi ki l kj kk">int main(){<br/>    Person john{"John", 26};<br/>    Person jane{"Jane", 27};<br/>    auto resType = john &lt;=&gt; jane;</span><span id="6167" class="kf kg hi jw b fi mi ki l kj kk">    std::cout &lt;&lt; typeid(resType).name() &lt;&lt; "\n";<br/>};</span><span id="ea56" class="kf kg hi jw b fi mi ki l kj kk">stdout on my machine with gcc 10.2<br/>----------------------------------<br/><strong class="jw hj">St15strong_ordering</strong></span></pre><p id="41e9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的例子中，默认的三向比较操作符返回的类型名是<strong class="iw hj"> St15strong_ordering </strong>，也就是<code class="du jt ju jv jw b">std::strong_ordering</code>。这是因为当编译器通过<code class="du jt ju jv jw b">&lt;=&gt;</code>按字典顺序比较两个成员(<code class="du jt ju jv jw b">name_</code>和<code class="du jt ju jv jw b">age_</code>)时，它们都返回了<code class="du jt ju jv jw b">std::strong_ordering</code>。如果其中一个或两个返回的比较类别不是<code class="du jt ju jv jw b">std::strong_ordering</code>，则打印输出会有所不同。</p><p id="2a89" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，让我们定义一个显式的三路操作符来代替默认的三路操作符，做编译器为我们做的事情。因为我明确地定义了<code class="du jt ju jv jw b">operator&lt;=&gt;</code>，所以我也需要定义<code class="du jt ju jv jw b">operator==</code>，但是为了不离题，我在这里省略了它:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="2465" class="kf kg hi jw b fi kh ki l kj kk">auto Person::operator&lt;=&gt;(const Person&amp; rhs) const<br/>{<br/>    if(auto cmp = name_ &lt;=&gt; rhs.name_; cmp != 0)<br/>    {return cmp;}<br/>    return age_ &lt;=&gt; rhs.age_;<br/>}</span><span id="f7f0" class="kf kg hi jw b fi mi ki l kj kk">//explicitly define operator== too ...</span></pre><p id="2f9a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这种情况下，我试图展示的是对<code class="du jt ju jv jw b">Person</code>成员的<code class="du jt ju jv jw b">&lt;=&gt;</code>调用返回<code class="du jt ju jv jw b">std::strong_ordering</code>，因此<code class="du jt ju jv jw b">Person::operator&lt;=&gt;(const Person&amp; rhs)</code>的整体返回也是<code class="du jt ju jv jw b">std::strong_ordering</code>。</p><h2 id="2919" class="kf kg hi bd kn lu lv lw kr lx ly lz kv jf ma mb kz jj mc md ld jn me mf lh mg bi translated">2.2类对象包含不返回的成员<code class="du jt ju jv jw b">std::strong_ordering</code></h2><p id="ea0c" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">为了完整起见，谨慎的做法是看看当一个类包含一个返回比较类别而不是<code class="du jt ju jv jw b">std::strong_ordering</code>的成员，但是类本身的<code class="du jt ju jv jw b">operator&lt;=&gt;</code>返回<code class="du jt ju jv jw b">operator&lt;=&gt;</code>时会发生什么:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="0c22" class="kf kg hi jw b fi kh ki l kj kk">#include &lt;iostream&gt;<br/>#include &lt;compare&gt;</span><span id="37f7" class="kf kg hi jw b fi mi ki l kj kk">struct Int{<br/>   int intNum_;<br/>   std::strong_ordering operator&lt;=&gt;(const Int&amp; rhs) const = default;<br/>};</span><span id="90c4" class="kf kg hi jw b fi mi ki l kj kk">struct Float{<br/>    float floatNum_;<br/>    auto operator&lt;=&gt;(const Float&amp; rhs) const = default;<br/>};</span><span id="a29e" class="kf kg hi jw b fi mi ki l kj kk">struct Numbers{<br/>    Int first_;<br/>    Float second_;</span><span id="8530" class="kf kg hi jw b fi mi ki l kj kk">    std::strong_ordering operator&lt;=&gt;(const&amp; Numbers rhs) const<br/>    {<br/>        if(auto cmp = first_&lt;=&gt; rhs.first_; cmp != 0)<br/>        {return cmp;}</span><span id="6b3b" class="kf kg hi jw b fi mi ki l kj kk">        return second_ &lt;=&gt; rhs.second_;<br/>    }<br/>};</span></pre><p id="f4ee" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">编译上述代码会导致编译错误，表明成员<code class="du jt ju jv jw b">Numbers::second_</code>无法返回带有<code class="du jt ju jv jw b">operator&lt;=&gt;</code>的比较类别<code class="du jt ju jv jw b">std::strong_ordering</code></p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="50e5" class="kf kg hi jw b fi kh ki l kj kk">In member function 'std::strong_ordering NumericWrapper::operator&lt;=&gt; (const NumericWrapper&amp; ) const':</span><span id="ecdd" class="kf kg hi jw b fi mi ki l kj kk">error: <strong class="jw hj">couldn't convert</strong> '((const NumericWrapper*)this-&gt;NumericWrapper::second_.FloatWrapper::operator&lt;=&gt;(rhs.NumericWrapper::second)' <strong class="jw hj">from std::partial_ordering to std::strong_ordering</strong></span><span id="8004" class="kf kg hi jw b fi mi ki l kj kk">|        return <strong class="jw hj">second_ &lt;=&gt; rhs.second_</strong>;<br/>|               <strong class="jw hj">~~~~~~~~~^~~~~~~~~~~~~~~</strong><br/>|                        <strong class="jw hj">|</strong><br/>|                       <strong class="jw hj">std::partial_ordering</strong></span></pre><p id="b47b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，很明显，试图从一个类对象的<code class="du jt ju jv jw b">operator&lt;=&gt;</code>返回<code class="du jt ju jv jw b">std::strong_ordering</code>而成员本身不返回，就会导致编译错误。即使<code class="du jt ju jv jw b">operator&lt;=&gt;</code>是默认的，您也可以预期看到类似的编译器错误。</p><h1 id="ee37" class="km kg hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">3.<code class="du jt ju jv jw b">equal</code>和<code class="du jt ju jv jw b">equivalent</code>的区别</h1><p id="9c02" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">所有三个比较类别都可以用来确定两个对象是否是<code class="du jt ju jv jw b">equivalent</code>。另外<code class="du jt ju jv jw b">std::strong_ordering</code>也可以用来判断两个物体是否是<code class="du jt ju jv jw b">equal</code>。在大多数情况下，当我们编写默认版本的三元运算符时，这对我们来说无关紧要。但是当我们被要求定义一个自定义的宇宙飞船操作符时，知道如何编写程序来检查等式和等价性是没有坏处的。</p><p id="bd5e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">C++ STL在下面的way⁴:中区分了相等和等价</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="3771" class="kf kg hi jw b fi kh ki l kj kk">if(a == b){<br/>     std::cout &lt;&lt; "a and b are equal\n";<br/>}<br/>if(!(a &lt; b) &amp;&amp; !(a &gt; b)){<br/>     std::cout &lt;&lt; "a and b are equivalent\n";<br/>}</span></pre><p id="3f87" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，当编写一个自定义的三向比较运算符时，可以利用这个构造来检查等价性。你可以看看我的教程<a class="ae js" href="https://ggulgulia.medium.com/c-20-three-way-comparison-operator-ensure-backward-compatibility-part-8-cae984559a08" rel="noopener"> <strong class="iw hj">第8部分</strong> </a>，它独立于本系列教程的其余部分，看看上面的构造是如何用于返回<code class="du jt ju jv jw b">std::strong_ordering::equivalent</code>的。</p><h1 id="c03c" class="km kg hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">摘要</h1><ol class=""><li id="8849" class="mj mk hi iw b ix lj jb lk jf mx jj my jn mz jr mo mp mq mr bi translated">对于自定义<code class="du jt ju jv jw b">operator&lt;=&gt;</code>中返回<code class="du jt ju jv jw b">std::strong_ordering</code>的对象，所有成员都必须与<code class="du jt ju jv jw b">operator&lt;=&gt;</code>主体中的<code class="du jt ju jv jw b">&lt;=&gt;</code>进行比较，它们都应该返回<code class="du jt ju jv jw b">std::strong_ordering</code>。</li><li id="c9cd" class="mj mk hi iw b ix ms jb mt jf mu jj mv jn mw jr mo mp mq mr bi translated">在大多数情况下包括默认的<code class="du jt ju jv jw b">operator&lt;=&gt;</code>，返回类型被推导为<code class="du jt ju jv jw b">std::strong_ordering</code>。</li><li id="5ddf" class="mj mk hi iw b ix ms jb mt jf mu jj mv jn mw jr mo mp mq mr bi translated">在<code class="du jt ju jv jw b">operator&lt;=&gt;</code>中被比较的对象的所有成员(显式定义或默认)也必须返回<code class="du jt ju jv jw b">std::strong_ordering</code>，以便<code class="du jt ju jv jw b">operator&lt;=&gt;</code>总运算符返回<code class="du jt ju jv jw b">std::strong_ordering</code>，否则会导致编译错误。</li><li id="7ea3" class="mj mk hi iw b ix ms jb mt jf mu jj mv jn mw jr mo mp mq mr bi translated">被比较对象的成员必须是可比较的，并且除了<code class="du jt ju jv jw b">!=</code>之外，只有<code class="du jt ju jv jw b">&gt;</code>、<code class="du jt ju jv jw b">&lt;</code>或<code class="du jt ju jv jw b">==</code>中的一个应该返回<code class="du jt ju jv jw b">true</code>。</li></ol><h1 id="a470" class="km kg hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="fcbb" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">在本系列教程的这一部分中，我解释了自定义<code class="du jt ju jv jw b">operator&lt;=&gt;</code>何时应该返回比较类别<code class="du jt ju jv jw b">std::strong_ordering</code>，并且在这个过程中，我解释了一些对本教程接下来的部分有用的概念。在<a class="ae js" href="https://ggulgulia.medium.com/c-20-three-way-comparison-operator-part-6-c66a173dcc99" rel="noopener"> <strong class="iw hj">第六部分</strong> </a>中，我解释了比较范畴<code class="du jt ju jv jw b">std::weak_ordering</code>。敬请期待！</p><h1 id="edb6" class="km kg hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">参考</h1><p id="d833" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">[1]经Jonathan Müller许可，来自他的博客<a class="ae js" href="https://www.foonathan.net/2018/06/equivalence-relations/" rel="noopener ugc nofollow" target="_blank">比较数学:第1部分</a><br/>【2】经Jonathan Müller许可，从他的博客<a class="ae js" href="https://www.foonathan.net/2018/06/equivalence-relations/" rel="noopener ugc nofollow" target="_blank">比较数学:第1部分</a><br/>【3】<a class="ae js" href="https://open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0515r0.pdf" rel="noopener ugc nofollow" target="_blank">一致性比较</a>，Herb Stutter，Jens Maurer，Walter e . Brown<br/>【4】相等与等价之间的区别来自cpp参考页上的<a class="ae js" href="https://en.cppreference.com/w/cpp/language/operator_comparison" rel="noopener ugc nofollow" target="_blank">比较运算符</a></p></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><h1 id="bbd0" class="km kg hi bd kn ko nh kq kr ks ni ku kv kw nj ky kz la nk lc ld le nl lg lh li bi translated">youtube和课程上的C++20个视频</h1><p id="34d2" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">你可以从<a class="ae js" href="https://youtu.be/C9OTiOJjssI" rel="noopener ugc nofollow" target="_blank">这段youtube视频</a>中了解更多关于<strong class="iw hj">比较显著态</strong>。订阅我的<a class="ae js" href="https://www.youtube.com/channel/UCITUBa1OVUC2oc-w3u33leg" rel="noopener ugc nofollow" target="_blank"> youtube频道</a>以了解更多关于C++20的协程和其他高级主题，或者浏览<a class="ae js" href="https://mastering-modern-cpp-features.thinkific.com/courses/mastering-modern-cpp-features" rel="noopener ugc nofollow" target="_blank">我的课程页面</a>以访问所有C++20视频、测验和个人支持。</p></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><h1 id="5bf6" class="km kg hi bd kn ko nh kq kr ks ni ku kv kw nj ky kz la nk lc ld le nl lg lh li bi translated">成为会员来支持我</h1><p id="25ca" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">如果你喜欢我的教程和文章，请考虑支持我，通过我的媒介<a class="ae js" href="https://ggulgulia.medium.com/membership" rel="noopener"> <strong class="iw hj">推荐链接</strong> </a> <strong class="iw hj"> </strong>成为会员，每月只需5美元就可以无限制地阅读medium.com的所有文章。</p></div></div>    
</body>
</html>