<html>
<head>
<title>Abstraction In Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的抽象</h1>
<blockquote>原文：<a href="https://medium.com/codex/abstraction-in-java-1f392018d0c4?source=collection_archive---------10-----------------------#2021-07-31">https://medium.com/codex/abstraction-in-java-1f392018d0c4?source=collection_archive---------10-----------------------#2021-07-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3977" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想从我最喜欢的关于这个概念的比喻开始。例如，当我们使用咖啡机时，我们只需添加一些水和咖啡，然后按下按钮。我们只是接触到它的按钮功能，我们不需要知道它的其他功能(如加热水的功能)。而要使用那台咖啡机，我们不需要知道它的内部系统。它的工作原理是从我们这里抽象出来的。这同样适用于编程。</p><p id="fc3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编程中的抽象意味着只显示对象的重要特征，而隐藏其他特征。因此，我们可以用一种更模块化的方式向用户(程序员)公开我们的对象。简单地说，抽象意味着只关注重要的东西，隐藏其余的。此外，使用抽象，我们不必担心方法的实现。因此，我们可以处理概念而不是它们的实现，这也是软件工程的最佳实践(声明和实现应该分开，我们应该通过接口进行交流)。总之，使用抽象我们可以实现模块化。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="b801" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">封装和抽象的区别</strong></p><p id="36f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">抽象-&gt;实现隐藏</p><p id="0053" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">封装-&gt;信息隐藏</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="0306" class="jt ju hi jp b fi jv jw l jx jy">interface IDog{</span><span id="2627" class="jt ju hi jp b fi jz jw l jx jy">public void bark();</span><span id="b1cf" class="jt ju hi jp b fi jz jw l jx jy">}</span><span id="35e9" class="jt ju hi jp b fi jz jw l jx jy">class Dog implements IDog{</span><span id="8533" class="jt ju hi jp b fi jz jw l jx jy">private String name = “Max” -&gt; using private is Encapsulation (Information hiding) this field cannot be accessed outside this class.</span><span id="3170" class="jt ju hi jp b fi jz jw l jx jy">@Override</span><span id="28ff" class="jt ju hi jp b fi jz jw l jx jy">public void bark(){</span><span id="1223" class="jt ju hi jp b fi jz jw l jx jy">//does stuff</span><span id="0d88" class="jt ju hi jp b fi jz jw l jx jy"> }</span><span id="8fd0" class="jt ju hi jp b fi jz jw l jx jy">}</span><span id="1fbb" class="jt ju hi jp b fi jz jw l jx jy">class Main{<br/>public static void main(String[] args)<br/>{<br/>  IDog dog = new Dog();<br/>  dog.bark()-&gt; Abstraction (implementation hiding) we can just use   the method without knowing its internal implementation<br/>}</span></pre></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="efaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在Java中实现抽象的方法</strong></p><p id="6f47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">java 8的接口(%100抽象)-&gt;</p><p id="a388" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">抽象类(% 0–100抽象(因为它们可以有具体的方法))</p><p id="95d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">界面</strong></p><p id="f592" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接口是用户必须遵守的契约。我们可以在这里声明一个对象最基本的用法。它组织了一个类应该能够做什么，并确保它实现了这些行为。(否则编译器无法运行应用程序)</p><p id="dae3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">接口的结构</strong></p><p id="5b11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过使用<em class="ka">接口</em>关键字来创建接口</p><p id="473b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接口可以有变量(虽然这并不常见),默认情况下它们是公共的、静态的和最终的。</p><p id="b924" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> public </strong>:它们是公共的，就像它们的方法一样，因为如果它们不是公共的，其他类就不能访问它们。</p><p id="9d08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">静态</strong>:它们是静态的，因为接口不能自己实例化。因此它们的值必须分配给静态上下文。</p><p id="b3da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> final </strong>:它们是最终的，因为它确保分配给接口变量的值不能被程序代码重新分配。</p><p id="8ce2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，接口的方法是公共的和抽象的，它们不能被定义。(虽然在JAVA 11之后我们可以像填充抽象类一样填充它们，但这与OOP的逻辑相矛盾)。</p><p id="a3f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意</strong>:抽象方法是可以声明为未定义的方法。它们必须由使用它们的类来实现。还要注意，当我说声明和定义时，我的意思是:</p><figure class="jk jl jm jn fd kc er es paragraph-image"><div class="er es kb"><img src="../Images/fc0db53c8c6ed8bc69ff4687ff71f319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*TWDhFumXeJrXH1mtV2PyTw.png"/></div></figure><figure class="jk jl jm jn fd kc er es paragraph-image"><div class="er es kf"><img src="../Images/e02b50b4831ceba93301b11c2094c435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*R0bQWlKGgNk9Rid8DYgq7w.png"/></div></figure><p id="abda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">它们为什么有用？</strong></p><p id="857f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建它们我们创建契约(必须实现的方法)并强迫它们实现它们。通过只使用最基本的方法创建一个对象并隐藏其余的方法，我们实现了抽象。在下面的代码中，你可以更好地理解它。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="0ff3" class="jt ju hi jp b fi jv jw l jx jy">public interface ICoffeeMachine{<br/>    void pressButton();<br/>   //We need to declare method signatures here</span><span id="7c7c" class="jt ju hi jp b fi jz jw l jx jy"> }</span><span id="932c" class="jt ju hi jp b fi jz jw l jx jy">public class CoffeeMachine implements ICoffeeMachine{<br/> <br/> @Override  <br/> void pressButton(){   //must be implemented -remember the contract-<br/>  boil();<br/>  mixCoffeeAndHotWater();<br/>}</span><span id="0c19" class="jt ju hi jp b fi jz jw l jx jy">void boil(){<br/>//does stuff<br/>}</span><span id="59bd" class="jt ju hi jp b fi jz jw l jx jy">void mixCoffeeAndHotWater(){<br/>//does stuff<br/>}</span><span id="db90" class="jt ju hi jp b fi jz jw l jx jy">}</span><span id="9e49" class="jt ju hi jp b fi jz jw l jx jy">class User{<br/>public static void main(String[] args)<br/>{<br/>  ICoffeeMachine coffeeMachine = new CoffeeMachine();<br/>  coffeMachine.pressButton(); -&gt; programmer can only access press button function like it was supposed to be it doesn't need to access other methods. (supposed programmer only needs to use press button function)</span><span id="102b" class="jt ju hi jp b fi jz jw l jx jy">}</span></pre><p id="2465" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们在上面使用接口所看到的，我们已经实现了完全的抽象。同样重要的是要注意，通过使用接口，我们也可以实现松散耦合的类。(希望在我的下一篇文章中，我会谈到这一点)。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="786c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">抽象类</strong></p><p id="704f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">抽象类基本上是那些想要使用它的类的模板。它们是可以拥有类似于接口的抽象方法的类。因此它们不能被初始化。抽象类可以有抽象方法(需要由它的子类实现)和具体方法(像常规方法一样，可以被覆盖)</p><p id="37e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">抽象类的结构</strong></p><p id="7c5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它可以像普通类一样创建任何变量和定义方法。但它也可以声明抽象方法，这使它不同于常规类。</p><p id="8c48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">它们为什么有用？</strong></p><p id="18b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们想为相关类创建基类时，应该使用它们。我们可以为它们提供默认的方法实现(可以像常规方法一样被覆盖)。此外，我们可以定义抽象方法，每个类可以不同地实现这些方法。你可以在下面的代码中更好地理解它。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="c08f" class="jt ju hi jp b fi jv jw l jx jy">public abstract class Human{<br/>    public void breath(){<br/>      //same for all the humans<br/>     }</span><span id="efd0" class="jt ju hi jp b fi jz jw l jx jy">    public abstract void speak(){<br/>    //It is abstract because it can be different for every human and      also every human speaks so it must be implemented and it can be implemented differently for every human.<br/>    }<br/>}<br/>public class Asian extends Human{</span><span id="e067" class="jt ju hi jp b fi jz jw l jx jy">@Override<br/>public void speak(){<br/>//speak chinese (assuming asian person is from china)<br/>}</span><span id="c4e7" class="jt ju hi jp b fi jz jw l jx jy">}<br/>class Main{<br/>public static void main(String[] args)<br/>{<br/>  Human asian = new Asian();<br/>  asian.breath(); //uses base class default method<br/>  asian.speak(); //speaks chinese because it has been implemented in that way.<br/>}</span></pre><p id="3705" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:抽象类的默认方法可以被它们的子类覆盖，就像普通类一样。抽象类不能有自己的对象，因为它们是抽象的，这意味着它们只是不完整的概念，因此不能被实例化。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="24cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">抽象类vs接口</strong></p><p id="9e5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它们都可以有抽象方法，但是一个接口不能有具体方法，而抽象类可以。抽象类像常规类一样有各种各样的变量，而接口只能有公共静态和最终类型的变量。</p><p id="b8cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接口只能有抽象方法，另一方面，抽象类可以有各种各样的方法。</p><p id="7ec1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个类可以实现各种接口，而一个类只能扩展一个抽象类。</p><p id="692a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你应该为相关类使用抽象类。另一方面，您可以为不相关的类使用接口。</p></div></div>    
</body>
</html>