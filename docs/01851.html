<html>
<head>
<title>Using Interfaces to Write Better PHP Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用接口编写更好的PHP代码</h1>
<blockquote>原文：<a href="https://medium.com/codex/using-interfaces-to-write-better-php-code-429f4635421d?source=collection_archive---------2-----------------------#2021-06-08">https://medium.com/codex/using-interfaces-to-write-better-php-code-429f4635421d?source=collection_archive---------2-----------------------#2021-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/90b12531ddae09242f2d1d95d6141b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R5b9neP7LThWZ70u.png"/></div></div></figure><h1 id="e1b0" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">介绍</h1><p id="5060" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在编程中，确保你的代码可读性、可维护性、可扩展性和易测试性是很重要的。我们可以在代码中改进所有这些因素的方法之一是使用接口。</p><h1 id="1e32" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">目标受众</h1><p id="1866" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">本文面向对OOP(面向对象编程)概念和在PHP中使用继承有基本理解的开发人员。如果你知道如何在你的PHP代码中使用继承，这篇文章应该是可以理解的。</p><h1 id="c0b5" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">什么是接口？</h1><p id="3883" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">从根本上来说，接口只是对一个类应该做什么的描述。它们可用于确保实现该接口的任何类都将包含该接口中定义的每个公共方法。</p><p id="be63" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接口<strong class="jq hj">可以是:</strong></p><ul class=""><li id="fe62" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">用于定义类的公共方法。</li><li id="d66e" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">用于定义类的常数。</li></ul><p id="8c82" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接口<strong class="jq hj">不能</strong>是:</p><ul class=""><li id="ed08" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">自行实例化。</li><li id="b0d8" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">用于为类定义私有或受保护的方法。</li><li id="b574" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">用于定义类的属性。</li></ul><p id="d005" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接口用于定义一个类应该包含的公共方法。重要的是要记住，只定义了方法签名，它们不包括方法体(就像你通常在类的方法中看到的那样)。这是因为接口仅用于定义对象之间的通信，而不是像在类中那样定义通信和行为。为了给出一点上下文，这个例子展示了一个定义了几个公共方法的示例接口:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="01c8" class="lo ir hi lk b fi lp lq l lr ls">interface DownloadableReport<br/>{<br/>    public function getName(): string;<br/>  <br/>    public function getHeaders(): array;<br/>  <br/>    public function getData(): array;<br/>}</span></pre><p id="9cee" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">根据php.net<a class="ae lt" href="https://www.php.net/manual/en/language.oop5.interfaces.php" rel="noopener ugc nofollow" target="_blank">的说法，接口有两个主要用途:</a></p><ol class=""><li id="151d" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl lu kx ky kz bi translated">允许开发人员创建可互换使用的不同类的对象，因为它们实现相同的一个或多个接口。一个常见的例子是多个数据库访问服务、多个支付网关或不同的缓存策略。不同的实现可以交换，而不需要对使用它们的代码进行任何更改。</li><li id="c7e9" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lu kx ky kz bi translated">允许函数或方法接受符合接口的参数并对其进行操作，而不关心对象还可以做什么或如何实现。这些接口通常被命名为Iterable、Cacheable、Renderable等等，以描述行为的重要性。</li></ol><h1 id="b0c6" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">在PHP中使用接口</h1><p id="57b8" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">接口可能是OOP(面向对象编程)代码库的无价部分。它们允许我们分离代码并提高可扩展性。举个例子，让我们看看下面这个类:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="6b75" class="lo ir hi lk b fi lp lq l lr ls">class BlogReport<br/>{<br/>    public function getName(): string<br/>    {<br/>        return 'Blog report';<br/>    }<br/>}</span></pre><p id="fbfa" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">正如你所看到的，我们已经用一个返回字符串的方法定义了一个类。通过这样做，我们已经定义了方法的行为，因此我们可以看到<code class="du lv lw lx lk b">getName()</code>是如何构建返回的字符串的。然而，假设我们在另一个类的代码中调用这个方法。另一个类不会关心字符串是如何建立的，它只关心字符串是如何返回的。例如，让我们看看如何在另一个类中调用这个方法:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="46a6" class="lo ir hi lk b fi lp lq l lr ls">class ReportDownloadService<br/>{<br/>    public function downloadPDF(BlogReport $report)<br/>    {<br/>        $name = $report-&gt;getName();</span><span id="eaa5" class="lo ir hi lk b fi ly lq l lr ls">        // Download the file here...<br/>    }<br/>}</span></pre><p id="b0f0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">尽管上面的代码可以工作，但是让我们想象一下，我们现在想要添加下载包装在<code class="du lv lw lx lk b">UsersReport</code>类中的用户报告的功能。当然，我们不能在我们的<code class="du lv lw lx lk b">ReportDownloadService</code>中使用现有的方法，因为我们已经强制要求只能传递一个<code class="du lv lw lx lk b">BlogReport</code>类。因此，我们必须重命名现有方法，然后添加一个新方法，如下所示:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="d77a" class="lo ir hi lk b fi lp lq l lr ls">class ReportDownloadService<br/>{<br/>    public function downloadBlogReportPDF(BlogReport $report)<br/>    {<br/>        $name = $report-&gt;getName();<br/>   <br/>        // Download the file here...<br/>    }<br/>  <br/>    public function downloadUsersReportPDF(UsersReport $report)<br/>    {<br/>        $name = $report-&gt;getName();<br/>   <br/>        // Download the file here...<br/>    }<br/>}</span></pre><p id="1e35" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">虽然您实际上看不到它，但是让我们假设上面的类中的其余方法使用相同的代码来构建下载。我们可以将共享代码提升到方法中，但是我们仍然可能有一些共享代码。除此之外，我们将有多个进入类的入口点，这些入口点运行几乎相同的代码。这可能会在将来尝试扩展代码或添加测试时导致额外的工作。</p><p id="3bb5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">例如，让我们想象我们创造了一个新的<code class="du lv lw lx lk b">AnalyticsReport</code>；我们现在需要向类中添加一个新的<code class="du lv lw lx lk b">downloadAnalyticsReportPDF()</code>方法。您可能会看到这个文件开始快速增长。这可能是一个使用界面的完美地方！</p><p id="1c56" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们从创建一个开始；我们称之为<code class="du lv lw lx lk b">DownloadableReport</code>,定义如下:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="c44d" class="lo ir hi lk b fi lp lq l lr ls">interface DownloadableReport<br/>{<br/>    public function getName(): string;<br/>  <br/>    public function getHeaders(): array;<br/>  <br/>    public function getData(): array;<br/>}</span></pre><p id="e196" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们现在可以更新<code class="du lv lw lx lk b">BlogReport</code>和<code class="du lv lw lx lk b">UsersReport</code>来实现<code class="du lv lw lx lk b">DownloadableReport</code>接口，如下例所示。但是请注意，我故意写错了<code class="du lv lw lx lk b">UsersReport</code>的代码，这样我就可以演示一些东西了！</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="3e56" class="lo ir hi lk b fi lp lq l lr ls">class BlogReport implements DownloadableReport<br/>{<br/>    public function getName(): string<br/>    {<br/>        return 'Blog report';<br/>    }<br/>  <br/>    public function getHeaders(): array<br/>    {<br/>        return ['The headers go here'];<br/>    }<br/>  <br/>    public function getData(): array<br/>    {<br/>        return ['The data for the report is here.'];<br/>    }<br/>}</span><span id="4708" class="lo ir hi lk b fi ly lq l lr ls">class UsersReport implements DownloadableReport<br/>{<br/>    public function getName()<br/>    {<br/>        return ['Users Report'];<br/>    }<br/>  <br/>    public function getData(): string<br/>    {<br/>        return 'The data for the report is here.';<br/>    }<br/>}</span></pre><p id="51b8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果我们试图运行我们的代码，我们会因为以下原因而出错:</p><ol class=""><li id="43a4" class="kr ks hi jq b jr km jv kn jz kt kd ku kh kv kl lu kx ky kz bi translated">缺少<code class="du lv lw lx lk b">getHeaders()</code>方法。</li><li id="e9f9" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lu kx ky kz bi translated"><code class="du lv lw lx lk b">getName()</code>方法不包括在接口的方法签名中定义的返回类型。</li><li id="fda6" class="kr ks hi jq b jr la jv lb jz lc kd ld kh le kl lu kx ky kz bi translated"><code class="du lv lw lx lk b">getData()</code>方法定义了一个返回类型，但它与接口的方法签名中定义的类型不同。</li></ol><p id="f59a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">因此，为了更新<code class="du lv lw lx lk b">UsersReport</code>以使其正确实现<code class="du lv lw lx lk b">DownloadableReport</code>接口，我们可以将其改为:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="31a0" class="lo ir hi lk b fi lp lq l lr ls">class UsersReport implements DownloadableReport<br/>{<br/>    public function getName(): string<br/>    {<br/>        return 'Users Report';<br/>    }<br/>  <br/>    public function getHeaders(): array<br/>    {<br/>       return [];<br/>    }<br/>  <br/>    public function getData(): array<br/>    {<br/>        return ['The data for the report is here.'];<br/>    }<br/>}</span></pre><p id="c3ac" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">既然我们的两个报表类都实现了相同的接口，我们可以像这样更新我们的<code class="du lv lw lx lk b">ReportDownloadService</code>:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="28da" class="lo ir hi lk b fi lp lq l lr ls">class ReportDownloadService<br/>{<br/>    public function downloadReportPDF(DownloadableReport $report)<br/>    {<br/>        $name = $report-&gt;getName();<br/>   <br/>        // Download the file here...<br/>    }<br/>}</span></pre><p id="4619" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们现在可以将一个<code class="du lv lw lx lk b">UsersReport</code>或<code class="du lv lw lx lk b">BlogReport</code>对象正确无误地传递给<code class="du lv lw lx lk b">downloadReportPDF()</code>方法。这是因为我们现在知道报表类上需要的必要方法存在，并且以我们期望的类型返回数据。</p><p id="342a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">作为向方法传递接口而不是类的结果，这允许我们基于方法做什么而不是如何做来松散地耦合T4和报告类。</p><p id="5b02" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果我们想要创建一个新的<code class="du lv lw lx lk b">AnalyticsReport</code>，我们可以让它实现相同的接口，然后这将允许我们将报告对象传递到相同的<code class="du lv lw lx lk b">downloadReportPDF()</code>方法中，而不需要添加任何新的方法。如果您正在构建自己的包或框架，并且希望给予开发人员创建自己的类的能力，这可能特别有用。您可以简单地告诉他们实现哪个接口，然后他们可以创建自己的新类。例如，在<a class="ae lt" href="https://laravel.com/docs/8.x/cache#adding-custom-cache-drivers" rel="noopener ugc nofollow" target="_blank"> Laravel </a>中，您可以通过实现<code class="du lv lw lx lk b">Illuminate\Contracts\Cache\Store</code>接口来创建自己的自定义缓存驱动程序类。</p><p id="51c2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">除了使用接口来改进实际代码之外，我倾向于喜欢接口，因为它们充当了代码即文档的角色。例如，如果我试图弄清楚一个类能做什么和不能做什么，我倾向于在使用它的类之前先看接口。它告诉你所有被调用的方法，而我不需要太关心这些方法是如何运行的。</p><p id="5ca7" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">值得我的Laravel开发者读者注意的是，你会经常看到术语“契约”和“接口”互换使用。根据<a class="ae lt" href="https://laravel.com/docs/8.x/contracts" rel="noopener ugc nofollow" target="_blank"> Laravel文档</a>，“Laravel的契约是一组定义框架提供的核心服务的接口”。因此，重要的是要记住契约是一个接口，但是接口不一定是契约。通常，契约只是框架提供的一个接口。要了解更多关于使用合同的信息，我建议阅读一下<a class="ae lt" href="https://laravel.com/docs/8.x/contracts" rel="noopener ugc nofollow" target="_blank">文档</a>,因为我认为它很好地分解了它们是什么，如何使用它们以及何时使用它们。</p><h1 id="c63f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="bf3e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">希望通过阅读这篇文章，它能让你对什么是接口、如何在PHP中使用接口以及使用接口的好处有一个简单的了解。</p><p id="6bcf" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">对于我的任何Laravel开发人员读者，我将在下周写一篇新的博文，向你们展示如何在Laravel中使用适配器模式。如果你对此感兴趣，可以在我的网站上<a class="ae lt" href="https://ashallendesign.co.uk/blog" rel="noopener ugc nofollow" target="_blank">订阅我的时事通讯，这样我发布的时候你就能得到通知。</a></p><p id="95f5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果这篇文章对你理解接口有所帮助，我很乐意听到评论。继续建造令人敬畏的东西！🚀</p><p id="dd93" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">非常感谢<a class="ae lt" href="https://www.linkedin.com/in/aditya-kadam-77a594134/" rel="noopener ugc nofollow" target="_blank">阿迪蒂亚·卡达姆</a>、<a class="ae lt" href="https://www.linkedin.com/in/jae-toole/" rel="noopener ugc nofollow" target="_blank">杰·托勒</a>和<a class="ae lt" href="https://www.linkedin.com/in/hannah-tinkler-28783792/" rel="noopener ugc nofollow" target="_blank">汉娜·廷克勒</a>校对了这篇文章并帮助我改进它！</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="b27f" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><em class="mg">最初发表于</em><a class="ae lt" href="https://ashallendesign.co.uk/blog/using-interfaces-to-write-better-php-code" rel="noopener ugc nofollow" target="_blank"><em class="mg">https://ashallendesign.co.uk</em></a><em class="mg">。</em></p></div></div>    
</body>
</html>