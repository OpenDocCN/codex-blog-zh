<html>
<head>
<title>Mongoose Partial Dump</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">猫鼬部分倾倒</h1>
<blockquote>原文：<a href="https://medium.com/codex/mongoose-partial-dump-607432cbf204?source=collection_archive---------20-----------------------#2021-09-08">https://medium.com/codex/mongoose-partial-dump-607432cbf204?source=collection_archive---------20-----------------------#2021-09-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1bbd" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">复制生产缺陷</h2></div><p id="655c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大家好，我叫Afonso Araújo Neto，是Entria公司的一名软件工程师。自从Sibelius Seraphini开始与我讨论如何在本地环境中重现生产错误以来，已经有一段时间了。为此，我们需要调试它，然后在本地数据库中引入错误的数据，最后将软件本地行为与生产行为进行比较。这是确保bug消失的常用方法。您至少需要在您的本地环境中重现它，修复它，然后将新的行为与旧的错误进行比较。</p><h1 id="f4b1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">解决办法</h1><p id="5132" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">在我们讨论的一会儿，他提出了一个关于“部分转储”的想法。我想，他以前已经想过这件事了，我从来没有顺便问过。这种“部分转储”可以解决使用公共转储来重现bug的问题。每当一个奇怪的错误出现时，复制整个数据库的成本很高，需要大量时间，并且创建和共享大量生产数据也不安全。但是，如果我们能够只提取出我们知道的产生漏洞的有限数量的数据呢？</p><p id="b397" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，以用户详细信息页面为例。有一天，在一天开始的时候，你和你的团队正在开发一个新功能，分享一些信息。然后突然一个客户在他的用户页面上报告了一个错误，它无法加载。所以你在他的页面上发现了一个“无法读取未定义的空属性”的错误。作为一名有经验的开发人员，您已经知道在用户详细信息页面上代码的某个地方可以有一个动态对象属性，如下所示:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="446c" class="kz ju hi kv b fi la lb l lc ld">const property = getProperty();<br/>console.log(property) // null</span><span id="27fd" class="kz ju hi kv b fi le lb l lc ld">const user = getUser();<br/>console.log(user) // undefined</span><span id="a0f0" class="kz ju hi kv b fi le lb l lc ld">const userPropertyValue = user[property] // &lt;- error. user is undefined</span></pre><p id="859f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在前端字段上，如果用户<em class="lf">未定义</em>，您可以很容易地提前返回。但这只会隐藏你的bug。为什么后端会发送一个未定义的用户？为什么只有那个客户的用户页面有bug？<strong class="iz hj">为什么这里的用户是未定义的？</strong>有一件事可以回答所有这些问题，那就是我们的部分转储。仅导入构成此用户详细信息页面的数据关系。</p><blockquote class="lg lh li"><p id="d656" class="ix iy lf iz b ja jb ij jc jd je im jf lj jh ji jj lk jl jm jn ll jp jq jr js hb bi translated"><em class="hi">当然“属性”变量为空也是一个错误。对于我们的研究案例，让我们关注用户未定义。“属性为空”也可能是用户未定义的结果。就像我们可以认为这段代码的上下文在sanitize函数内部。该函数删除未定义的用户对象的</em><strong class="iz hj"><em class="hi">undefined/null/NaN</em></strong><em class="hi">。</em></p></blockquote><h1 id="5c5d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">数据关系策略</h1><p id="633c" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">为了开始开发部分转储，我需要解决如何正确提取与我想要再现的模块相关的数据。让我们更深入地了解用户详细信息示例。我想采取一个用户详细信息页面，显示一些细节分析加上其他信息转储。如果用户页面是一个电子商务，它将显示所有用户的采购订单，价值支出等..</p><p id="71fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们用这张图片来代表所有相关的模型示例:</p><figure class="kq kr ks kt fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lm"><img src="../Images/09564c3c624d4872b3e50553e4b37ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q8p3Ryg_gUUijoWd"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">数据库集合关系</figcaption></figure><blockquote class="lg lh li"><p id="8fe3" class="ix iy lf iz b ja jb ij jc jd je im jf lj jh ji jj lk jl jm jn ll jp jq jr js hb bi translated"><em class="hi">也许这不是这种情况下的最佳关系，但让我们把重点放在我们的研究案例上</em></p></blockquote><p id="6b60" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正确导出用户页面详细信息业务规则的可用转储。我们需要提取一个用户文档，所有相关的用户购买文档，所有相关的订单和最终项目。ItemType、ItemFactory和Factory是与项目相关的集合，因此它们对于项目部分转储是有用的，而不是对于用户。</p><p id="462d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果项目类型与业务规则中的用户页面相关，将创建一个新的集合用户项目(用户Id、项目Id、数量等..)或用户项目类型(用户标识、项目类型标识、数量购买等..).但是在这种情况下，我们的use details页面只显示所有用户订单。因此，用户部分转储应该是:</p><figure class="kq kr ks kt fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ly"><img src="../Images/13b837b6aec75c62527c1ff805bccd15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t7N8YdRjR1lPgPlD"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">用户部分转储</figcaption></figure><p id="d556" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">开始时，我们使用部分转储来接收要转储的collectionName列表。比如:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="ee00" class="kz ju hi kv b fi la lb l lc ld">const collectionNameList = ['User', 'UserPurchase', 'Order', 'Item'];</span></pre><p id="e784" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是当我们使用它时，我们注意到这种关系模式重复了很多次。这太频繁了，所以我决定将其抽象为默认的“转储策略”。</p><h1 id="2e32" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">转储策略</h1><p id="0af1" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">在<strong class="iz hj">mongose-partial-dump</strong>中,“转储策略”是一个代码块，用于按照某种关系模式从数据库文档中提取数据。<strong class="iz hj">默认</strong>策略是基于以下规则列表制定的:</p><ul class=""><li id="b7c5" class="lz ma hi iz b ja jb jd je jg mb jk mc jo md js me mf mg mh bi translated">提取给定的模型(<strong class="iz hj">主集合</strong>)</li><li id="d007" class="lz ma hi iz b ja mi jd mj jg mk jk ml jo mm js me mf mg mh bi translated">提取给定模型的所有外键文档</li><li id="ad22" class="lz ma hi iz b ja mi jd mj jg mk jk ml jo mm js me mf mg mh bi translated">用给定模型的外键提取所有文档(<strong class="iz hj"> secondaryCollections </strong>)</li><li id="8f35" class="lz ma hi iz b ja mi jd mj jg mk jk ml jo mm js me mf mg mh bi translated">对于所有secondaryCollections文档，我们递归地重复这个列表的步骤1和2，找到secondaryCollection。</li></ul><p id="200d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些规则的结果是数据库<strong class="iz hj">图</strong>的<strong class="iz hj">子图</strong>:</p><figure class="kq kr ks kt fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mn"><img src="../Images/915321a25f8e29759ff813cc1c73e1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n5Y_cAcnXEtg1OFe"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">默认转储策略图</figcaption></figure><h1 id="966a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">数据匿名化</h1><p id="96e8" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">随着该软件包不断得到升级和新功能，在投入生产使用之前，它还需要一个新功能。因为巴西的LGPD法律，我们不能操纵生产数据库。这条法律不允许操纵个人数据，就像我们使用部分转储那样。</p><p id="4242" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了解决这个问题，我们实现了匿名功能。该功能使用<a class="ae mo" href="https://www.npmjs.com/package/faker" rel="noopener ugc nofollow" target="_blank"> FakerJS </a>在转储导出之前更改生产数据(名称、地址、头像图像等)。就像包里说的:“在浏览器和node.js里产生海量的假数据”。</p><p id="67c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样，我们就可以无所畏惧地生成我们的转储，知道我们不会弄乱人们的个人数据。</p><figure class="kq kr ks kt fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mp"><img src="../Images/bfd14fa16638b8191a2411752355f7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MQpJolhYfOHzOgMR"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">Faker示例页面位于<a class="ae mo" href="https://rawgit.com/Marak/faker.js/master/examples/browser/index.html" rel="noopener ugc nofollow" target="_blank">https://raw git . com/Marak/faker . js/master/examples/browser/index . html</a></figcaption></figure><h1 id="d20e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">性能</h1><h1 id="da62" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">不变性</h1><p id="12ea" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">软件行为不会改变。不管环境如何，如果任何特征发生了变化，所有的行为都将是一样的。您甚至可以复制/粘贴功能url。在我们的例子中，我们使用来自文档<strong class="iz hj"> _id </strong>的base64转换，例如(用户示例):</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="2e27" class="kz ju hi kv b fi la lb l lc ld">**User:613514b8d5ae0e081ca7cd2d // value<br/>VXNlcjo2MTM1MTRiOGQ1YWUwZTA4MWNhN2NkMmQ= // base64 encode**</span></pre><p id="05e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，如果一个生产url是<code class="du mq mr ms kv b">&lt;domain&gt;/user/VXNlcjo2MTM1MTRiOGQ1YWUwZTA4MWNhN2NkMmQ=/details</code>，8080端口url中的一个相关的<a class="ae mo" href="http://localhost" rel="noopener ugc nofollow" target="_blank">本地主机</a>将是:<code class="du mq mr ms kv b">localhost:8080/user/VXNlcjo2MTM1MTRiOGQ1YWUwZTA4MWNhN2NkMmQ=/details</code>。因为在MongoDB中，我们可以通过预先创建的唯一标识符(ObjectId)创建新文档，所以相同的用户页面将存在相同的url。</p><h1 id="6e2d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">最小工作示例(MWE)</h1><p id="b771" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">MWE是:"<em class="lf">源代码和其他数据文件的集合，它允许一个错误或问题被演示和重现。</em>”(<a class="ae mo" href="https://en.wikipedia.org/wiki/Minimal_working_example" rel="noopener ugc nofollow" target="_blank">维基</a>)。哪些数据文件可以使用部分转储。</p><h1 id="ccd5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">结论</h1><p id="be4b" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">我们的部分转储成为我们日常调试流程中的一个有用工具。有了它，我们不需要额外的时间来试图重现错误，所以我们可以花更多的时间来为我们的错误修复创造更好的解决方案。因为<strong class="iz hj">时间</strong>对我来说是一个关键的资源，它变得如此有价值，以至于我决定将其开源。您可以在以下位置访问它:</p><ul class=""><li id="ec1e" class="lz ma hi iz b ja jb jd je jg mb jk mc jo md js me mf mg mh bi translated"><a class="ae mo" href="https://github.com/Streeterxs/mongoose-partial-dump" rel="noopener ugc nofollow" target="_blank">https://github.com/Streeterxs/mongoose-partial-dump</a>(代码)</li><li id="9abf" class="lz ma hi iz b ja mi jd mj jg mk jk ml jo mm js me mf mg mh bi translated">https://www.npmjs.com/package/mongoose-partial-dumper(包)</li></ul><p id="82f4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">试试看。=)</p></div></div>    
</body>
</html>