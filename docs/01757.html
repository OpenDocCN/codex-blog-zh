<html>
<head>
<title>Android: Room, Saving Local Data the Modern Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android: Room，以现代方式保存本地数据</h1>
<blockquote>原文：<a href="https://medium.com/codex/android-room-saving-local-data-the-modern-way-b5f5f0e8b423?source=collection_archive---------3-----------------------#2021-05-28">https://medium.com/codex/android-room-saving-local-data-the-modern-way-b5f5f0e8b423?source=collection_archive---------3-----------------------#2021-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e92ed52661e71a9b5d6528a62b2e7345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EXgR86nVzflAvx4b"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">弗兰基·查马基在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d9ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们使用的几乎每个应用程序都出于这样或那样的目的存储数据，比如存储图像、文件、用户偏好等。一个最常见的用例是缓存相关的数据，以便当设备无法访问网络时，用户仍然可以在离线时浏览这些内容。根据我们的使用情况，Android有很多存储数据的方法。在本文中，我将讨论存储结构化数据的最佳推荐方式，那就是房间库。</p><blockquote class="jt"><p id="63c9" class="ju jv hi bd jw jx jy jz ka kb kc js dx translated">Room persistence库在SQLite上提供了一个抽象层，允许流畅的数据库访问，同时充分利用SQLite的强大功能。</p></blockquote><h2 id="732c" class="kd ke hi bd kf kg kh ki kj kk kl km kn jg ko kp kq jk kr ks kt jo ku kv kw kx bi translated"><strong class="ak">我们为什么要在SQLite上使用空间？</strong></h2><ul class=""><li id="f20f" class="ky kz hi ix b iy la jc lb jg lc jk ld jo le js lf lg lh li bi translated">没有运行时查询错误，因为Room提供了SQL查询的编译时验证。</li><li id="6b39" class="ky kz hi ix b iy lj jc lk jg ll jk lm jo ln js lf lg lh li bi translated">最大限度减少重复和容易出错的样板代码的便利注释。</li><li id="ddc2" class="ky kz hi ix b iy lj jc lk jg ll jk lm jo ln js lf lg lh li bi translated">它与其他架构组件无缝集成。</li></ul><h2 id="7924" class="kd ke hi bd kf kg lo ki kj kk lp km kn jg lq kp kq jk lr ks kt jo ls kv kw kx bi translated"><strong class="ak">主要部件</strong></h2><ul class=""><li id="8d07" class="ky kz hi ix b iy la jc lb jg lc jk ld jo le js lf lg lh li bi translated">实体</li><li id="c266" class="ky kz hi ix b iy lj jc lk jg ll jk lm jo ln js lf lg lh li bi translated">数据访问对象(Data Access Object)</li><li id="b196" class="ky kz hi ix b iy lj jc lk jg ll jk lm jo ln js lf lg lh li bi translated">数据库ˌ资料库</li></ul><h2 id="a729" class="kd ke hi bd kf kg lo ki kj kk lp km kn jg lq kp kq jk lr ks kt jo ls kv kw kx bi translated"><strong class="ak">实体</strong></h2><p id="7177" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">表示应用程序数据库中的表。Room为每个具有@Entity注释的类创建一个表，类中的字段对应于表中的列。因此，实体类是不包含任何逻辑的数据类。</p><h2 id="9667" class="kd ke hi bd kf kg lo ki kj kk lp km kn jg lq kp kq jk lr ks kt jo ls kv kw kx bi translated"><strong class="ak">刀</strong></h2><p id="39a1" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">Dao是用@Dao注释的接口，它们提供了应用程序可以用来查询、更新、插入和删除数据库中的数据的方法。</p><h2 id="bb2e" class="kd ke hi bd kf kg lo ki kj kk lp km kn jg lq kp kq jk lr ks kt jo ls kv kw kx bi translated"><strong class="ak">数据库</strong></h2><p id="b672" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lt ji jj jk lu jm jn jo lv jq jr js hb bi translated">database类保存数据库，并作为应用程序持久数据的底层连接的主要访问点。database类为您的应用程序提供了与该数据库相关联的Dao实例。反过来，应用程序可以使用DAOs从数据库中检索数据，作为相关数据实体对象的实例。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/025f23ecf458e4569741638d858978c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bvhKqvqbNxlwInUnfju1cg.png"/></div></div></figure></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="eda4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们通过一个例子来理解实现。</p><p id="0bc3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要开始使用Room，请将以下依赖项添加到您的应用程序的<em class="mi"> build.gradle </em>文件中:</p><pre class="lx ly lz ma fd mj mk ml mm aw mn bi"><span id="2bba" class="kd ke hi mk b fi mo mp l mq mr">dependencies {<br/>    def roomVersion = "2.3.0"</span><span id="27b0" class="kd ke hi mk b fi ms mp l mq mr">    implementation("androidx.room:room-runtime:$roomVersion")<br/>    kapt "androidx.room:room-compiler:$roomVersion"</span><span id="60ec" class="kd ke hi mk b fi ms mp l mq mr">    implementation "androidx.room:room-ktx:$roomVersion"<br/>    androidTestImplementation "androidx.room:room-       testing:$roomVersion"<br/>    <br/> }</span></pre><p id="e6a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面的代码片段定义了一个<strong class="ix hj">配方</strong>模型，它包含一个<strong class="ix hj">结果</strong>的列表，其中Result类包含每个配方的属性。我们将在数据库中保存一个食谱列表。</p><pre class="lx ly lz ma fd mj mk ml mm aw mn bi"><span id="5956" class="kd ke hi mk b fi mo mp l mq mr">data class Recipe(<br/>    @SerializedName("results")<br/>    val results: List&lt;Result&gt;<br/>)</span><span id="8edb" class="kd ke hi mk b fi ms mp l mq mr">data class Result(<br/>    @SerializedName("sourceName")<br/>    val sourceName: String,<br/>    @SerializedName("sourceUrl")<br/>    val sourceUrl: String,<br/>    @SerializedName("summary")<br/>    val summary: String,<br/>    @SerializedName("title")<br/>    val title: String,<br/>    @SerializedName("vegan")<br/>    val vegan: Boolean,<br/>    @SerializedName("vegetarian")<br/>    val vegetarian: Boolean,<br/>    @SerializedName("veryHealthy")<br/>    val veryHealthy: Boolean<br/>)</span></pre><p id="5f08" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">数据实体:</strong></p><pre class="lx ly lz ma fd mj mk ml mm aw mn bi"><span id="8743" class="kd ke hi mk b fi mo mp l mq mr">@Entity(tableName = "recipes_table<em class="mi">"</em>)<br/>class RecipesEntity(<br/>    var recipe: Recipe<br/>) {<br/><br/>    @PrimaryKey(autoGenerate = false)<br/>    var id: Int = 0<br/><br/>}</span></pre><p id="5d80" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们用<strong class="ix hj"> @Entity </strong>标注的实体类，有个名字<strong class="ix hj"><em class="mi">recipes _ table</em></strong><em class="mi">。</em>我们在表中只有一行食谱列表，因此<em class="mi"> </em>在这种情况下我们不需要主键，这就是为什么我将<strong class="ix hj"> <em class="mi">自动生成</em> </strong>属性设置为false。</p><p id="60fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">数据访问对象(Dao): </strong></p><p id="82cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的<strong class="ix hj"> <em class="mi"> RecipesDao </em> </strong>，用<strong class="ix hj"> @Dao </strong>标注，有两个方法，一个是在表中插入我们的菜谱(<em class="mi"> RecipeEntity </em>)，另一个是读取缓存的菜谱，返回菜谱实体列表流。</p><pre class="lx ly lz ma fd mj mk ml mm aw mn bi"><span id="5225" class="kd ke hi mk b fi mo mp l mq mr">@Dao<br/>interface RecipesDao {<br/><br/>    @Insert(onConflict = OnConflictStrategy.<em class="mi">REPLACE</em>)<br/>    suspend fun insertRecipes(recipesEntity: RecipesEntity)<br/><br/>    @Query("SELECT * FROM recipes_table ORDER BY id ASC")<br/>    fun readRecipes(): Flow&lt;List&lt;RecipesEntity&gt;&gt;<br/><br/>}</span></pre><p id="1067" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">默认情况下，Room只能存储原始类型，要存储自定义对象，我们需要使用<strong class="ix hj"> TypeConverter </strong>将自定义对象转换为已知的数据库类型。在我们的例子中，我们将把食谱列表转换成一个字符串。进行类型转换的方法需要用<strong class="ix hj"><em class="mi">type converter</em></strong><em class="mi">进行注释。</em></p><pre class="lx ly lz ma fd mj mk ml mm aw mn bi"><span id="b292" class="kd ke hi mk b fi mo mp l mq mr">class RecipesTypeConverter {<br/><br/>    val gson = Gson()<br/><br/>    @TypeConverter<br/>    fun recipeToString(recipe: Recipe): String {<br/>        return gson.toJson(recipe)<br/>    }<br/><br/>    @TypeConverter<br/>    fun stringToRecipe(recipeString: String): Recipe {<br/>        val objectType = object : TypeToken&lt;Recipe&gt;() {}.<em class="mi">type<br/>        </em>return gson.fromJson(recipeString, objectType)<br/>    }<br/><br/>}</span></pre><p id="aa85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我定义了两个方法，一个将我们的Recipe对象转换成字符串，另一个将字符串转换回Recipe对象。我使用<strong class="ix hj"> Gson </strong>进行类型转换。</p><p id="ebfa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">数据库</strong></p><pre class="lx ly lz ma fd mj mk ml mm aw mn bi"><span id="0969" class="kd ke hi mk b fi mo mp l mq mr">@Database(<br/>    entities = [RecipesEntity::class],<br/>    version = 1,<br/>    exportSchema = true<br/>)<br/>@TypeConverters(RecipesTypeConverter::class)<br/>abstract class RecipesDatabase : RoomDatabase() {<br/><br/>    abstract fun recipesDao(): RecipesDao<br/><br/>}</span></pre><p id="d40f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们用<strong class="ix hj"> @Database </strong>标注的数据库类定义了数据库配置，并作为应用程序对持久数据的主要访问点。在数据库中，如果我们想要<strong class="ix hj">将数据库模式</strong>导出到一个文件夹中，我们需要提到<strong class="ix hj">实体列表</strong>、<strong class="ix hj">数据库版本</strong>，以及t <strong class="ix hj">类型转换器</strong>(如果有的话)。</p><p id="01ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">用法</strong>:</p><p id="8ac2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们定义了数据实体、DAO和数据库对象之后，我们可以使用下面的代码来创建数据库的实例。我用刀柄做DI。</p><pre class="lx ly lz ma fd mj mk ml mm aw mn bi"><span id="5898" class="kd ke hi mk b fi mo mp l mq mr">@Module<br/>@InstallIn(SingletonComponent::class)<br/>object DatabaseModule {<br/><br/>    @Singleton<br/>    @Provides<br/>    fun provideDatabase(<br/>        @ApplicationContext context: Context<br/>    ) = Room.databaseBuilder(<br/>        context,<br/>        RecipesDatabase::class.<em class="mi">java</em>,<br/>        <em class="mi">RECIPES_DATABASE_NAME<br/>    </em>).build()<br/><br/>    @Singleton<br/>    @Provides<br/>    fun provideDao(database: RecipesDatabase) =    database.recipesDao()<br/><br/>}</span></pre><p id="4ed3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我已经创建了一个LocalDataSource类，它将向存储库公开DAO的方法。这里我通过构造函数注入来注入Dao类。</p><pre class="lx ly lz ma fd mj mk ml mm aw mn bi"><span id="d760" class="kd ke hi mk b fi mo mp l mq mr">class LocalDataSource @Inject constructor(<br/>    private val recipesDao: RecipesDao<br/>) {<br/><br/>    suspend fun insertRecipes(recipesEntity: RecipesEntity) {<br/>        recipesDao.insertRecipes(recipesEntity)<br/>    }<br/><br/>    fun readRecipes(): Flow&lt;List&lt;RecipesEntity&gt;&gt; {<br/>        return recipesDao.readRecipes()<br/>    }<br/>}</span></pre><p id="054b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，在存储库中，我将注入远程数据源。我使用了<strong class="ix hj">@ activity retained scoped</strong>，这样我们的存储库在配置更改后仍然存在。</p><pre class="lx ly lz ma fd mj mk ml mm aw mn bi"><span id="9866" class="kd ke hi mk b fi mo mp l mq mr">@ActivityRetainedScoped<br/>class Repository @Inject constructor(<br/>    localDataSource: LocalDataSource<br/>) {<br/>    val local = localDataSource<br/>}</span></pre><blockquote class="jt"><p id="f6e9" class="ju jv hi bd jw jx mt mu mv mw mx js dx translated">您可以类似地将远程数据注入到存储库中，然后在ViewModel类中使用它。</p></blockquote><pre class="my mz na nb nc mj mk ml mm aw mn bi"><span id="0124" class="kd ke hi mk b fi mo mp l mq mr">@HiltViewModel<br/>class MainViewModel @Inject<br/>constructor(<br/>    private val repository: Repository,<br/>    application: Application,<br/>) :<br/>    AndroidViewModel(application) {<br/><br/>    <em class="mi">/**ROOM DATABASE*/<br/><br/>    </em>val readRecipes: LiveData&lt;List&lt;RecipesEntity&gt;&gt; = repository.local.readRecipes().<em class="mi">asLiveData</em>()<br/><br/>    private fun insertRecipes(recipesEntity: RecipesEntity) {<br/>        <em class="mi">viewModelScope</em>.<em class="mi">launch</em>(Dispatchers.IO) <strong class="mk hj">{<br/>            </strong>repository.local.insertRecipes(recipesEntity)<br/>        <strong class="mk hj">}<br/>    </strong>}<br/><br/>    private fun cacheRecipes(recipe: Recipe) {                        // saving recipe as a Recipe Entity object, and inserting in the db.<br/>        val recipesEntity = RecipesEntity(recipe)<br/>        insertRecipes(recipesEntity)<br/>    }</span><span id="ec86" class="kd ke hi mk b fi ms mp l mq mr">    // Other logic </span><span id="88f0" class="kd ke hi mk b fi ms mp l mq mr">}</span></pre><p id="de75" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我从注入的存储库中读取数据，并将其作为实时数据存储在<strong class="ix hj"> readRecipes </strong>变量中。在一个成功的API响应上，我调用<strong class="ix hj">cache recipes(Recipe:Recipe)</strong>。</p><p id="07a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我正在访问我的片段中的食谱，并将数据设置到适配器，</p><pre class="lx ly lz ma fd mj mk ml mm aw mn bi"><span id="a8b9" class="kd ke hi mk b fi mo mp l mq mr">private fun readCachedData() {<br/>    <em class="mi">lifecycleScope</em>.<em class="mi">launch </em><strong class="mk hj">{<br/>        </strong>mainViewModel.readRecipes.<em class="mi">observeOnce</em>(<em class="mi">viewLifecycleOwner</em>) <strong class="mk hj">{ </strong>dataBase <strong class="mk hj">-&gt;<br/>            </strong>if (dataBase.<em class="mi">isNotEmpty</em>()) {<br/>                Log.d(TAG, "readCachedData:() ")<br/>               <br/>              recipesAdapter.submitList(dataBase[0].recipe.results)<br/>            } else {                                               // in case database is empty<br/>                requestApiData()<br/>            }<br/>        <strong class="mk hj">}<br/>    }<br/></strong>}</span></pre><p id="0fa2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在数据库中的数据会像这样，</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/88e2827c3d73d0e0ac36bc967de284d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*On39KrP7jnbgNzggcZAuVw.png"/></div></div></figure><blockquote class="jt"><p id="0ac6" class="ju jv hi bd jw jx mt mu mv mw mx js dx translated">您可以使用数据库检查器来可视化您的数据并实时运行查询。</p></blockquote><p id="8a44" class="pw-post-body-paragraph iv iw hi ix b iy ne ja jb jc nf je jf jg ng ji jj jk nh jm jn jo ni jq jr js hb bi translated">这是给你们的房间，希望对你们有所帮助。</p><p id="bd12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章的灵感来自斯蒂芬·约万诺维奇在<a class="ae iu" href="https://www.udemy.com/course/modern-food-recipes-app-android-development-with-kotlin/" rel="noopener ugc nofollow" target="_blank"> Udemy </a>上的一堂课。</p></div></div>    
</body>
</html>