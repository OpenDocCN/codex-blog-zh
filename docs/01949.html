<html>
<head>
<title>JavaScript Data Structures And Algorithms (Graphs, Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript数据结构和算法(图表，第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/javascript-data-structures-and-algorithms-graphs-part-2-533534289b23?source=collection_archive---------11-----------------------#2021-06-17">https://medium.com/codex/javascript-data-structures-and-algorithms-graphs-part-2-533534289b23?source=collection_archive---------11-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/fada4ee16d6728ccfbb3fcb55d4bb06d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f8BDhTtn0UCxSGS1"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">Justin W 在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="e294" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你好！这是我分解图形数据结构的延续。上次我们讨论了一些常用的不同图形类型(循环/非循环、有向/无向、加权/未加权)及其在Javascript中的实现。你可以在这里看到这篇文章<a class="ae hv" rel="noopener" href="/@be00f566a88f/67cc1d9bfcc7?sk=">的第一部分。今天，我将介绍广度优先搜索和深度优先搜索，以及它们的一些实际应用。让我们开始吧！</a></p><h2 id="0546" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">图中的广度优先搜索和深度优先搜索</h2><p id="939c" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">因为图可以是有向的或无向的，所以可以遍历它们来寻找顶点。像树(可以认为是图的一种类型)一样，我们可以通过使用<a class="ae hv" rel="noopener" href="/codex/javascript-data-structures-and-algorithms-search-algorithms-part-2-6f7c577b32e9"> <em class="kt">广度优先搜索</em>和<em class="kt">深度优先搜索</em> </a> <em class="kt">在图中运行搜索算法。</em>它们的实现略有不同，但在结构上完全相同。例如，当执行BFS时，图形将在遍历到下一个顶点之前检查一个顶点的邻居，类似于树在遍历到下一个级别以访问它们的子级之前将访问一个级别上的所有子级。</p><figure class="kv kw kx ky fd hk er es paragraph-image"><div class="er es ku"><img src="../Images/0b85e652b36b914bc3ff34311e4fd9ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*7RHDUmMCbjNu9DlnW9Xapw.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">有向无权重图中广度优先搜索的可视化，显示当前顶点(橙色)访问其最近的相邻节点(蓝色)。(创建于https://visualgo.net)</figcaption></figure><p id="790f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，从0开始，BFS将访问顶点1和2，然后遍历顶点1并访问其相邻的顶点。</p><h1 id="0795" class="kz ju hy bd jv la lb lc jz ld le lf kd lg lh li kg lj lk ll kj lm ln lo km lp bi translated">履行</h1><p id="4c2b" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">如果我们要实现BFS，我们必须做的第一件事是定义一个入口点。我们不像对待一棵树那样受限于指定的根，但是我们仍然需要定义一个初始点。在上面的例子中，如果我们将0指定为底部图形中的入口点，BFS将首先访问与其共享一条边的任何顶点(0，1，3，5)。</p><p id="7860" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还需要将一个队列变量初始化为一个空对象，我们将遍历的顶点和一个已经访问过的顶点列表推入该对象。我们的队列将从每个插入的键中提取相邻顶点的列表，并检查每个匹配。这类似于BFS访问父节点的子节点来寻找匹配。在访问每个邻居后，我们的BFS方法将遍历邻接表中的下一个键。下面是一个针对无向图的广度优先搜索方法的实现:</p><figure class="kv kw kx ky fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lq"><img src="../Images/7a2b5bebe0e0955db32299cf199f5b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kyZ6taNmmGzM4aRM7z65gw.png"/></div></div></figure><p id="3c0e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">广度优先搜索在许多大规模web应用中使用。这种方法的一个用途是测量地图上两点之间的英里距离，假设该图具有加权边来指示顶点之间的英里数。如果我们正在构建一个搜索引擎，我们还可以衡量与搜索查询结果列表的相关性。或者你可能想提供一个推荐的朋友列表，BFS会根据相似度来衡量用户与推荐用户的关系，比如共同的朋友、家庭关系、共同兴趣等。如果目标顶点在其图形的入口点附近，则BFS是最佳方法。</p><h1 id="78db" class="kz ju hy bd jv la lb lc jz ld le lf kd lg lh li kg lj lk ll kj lm ln lo km lp bi translated">深度优先搜索</h1><p id="55b0" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">像BFS一样，图和树数据结构之间深度优先搜索实现的相似之处非常少。像二分搜索法树一样，我们可以通过在访问一个顶点的任何兄弟节点之前访问它的子节点来遍历一个图。这意味着在转移到其他节点之前，DFS会沿着一个分支向下遍历到它的最深层。DFS用于在移动到下一个相邻顶点之前访问路径中的每个顶点。在下面的示例中，值为0的顶点是入口点，按照顺序，DFS会沿着一条由连接的顶点组成的路径遍历，直到不再可能，然后再沿着下一条路径移动。从0开始，DFS将向下遍历到其值为1的相邻顶点(以及其相邻节点)，然后继续移动到其值为2的另一个相邻顶点。</p><figure class="kv kw kx ky fd hk er es paragraph-image"><div class="er es lr"><img src="../Images/0426fabae2fe9b38562cba4035bf9b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*TTULwYdlA6hqE6laYxQJBg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">深度优先搜索的可视化，其中在移动到连接到源的任何其他路径之前，遍历相邻节点的单个路径(红色)被访问(蓝色)。(创建于<a class="ae hv" href="https://visualgo.net)." rel="noopener ugc nofollow" target="_blank">https://visualgo.net)</a></figcaption></figure><p id="7e8e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过创建一个堆栈或队列来保存遍历顺序，从而实现深度优先的搜索方法。我们可以将它与一个列表结合起来，就像一个包含我们已经遍历过的节点的集合。如果你看看下面，这个DFS的例子弹出遍历序列中的下一个顶点，并存储到一个变量中(<em class="kt"> nextVertex </em>)。当顶点被推入堆栈时，已经被访问过的顶点被推入<em class="kt"> exploredVertex </em>集合。</p><figure class="kv kw kx ky fd hk"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">DFS的一种实现，使用一个堆栈将遍历中的下一个顶点排入队列，并使用一个Set将所有访问过的顶点推入。</figcaption></figure><p id="b9a4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦路径被尽可能深入地遍历，DFS就会检查尚未被访问过的路径的其他相邻边。换句话说，如果它不在已访问节点的集合中，那么将遍历序列中的下一条边。这也确保了DFS算法不会多次访问一个顶点。以这种方式遍历，通过<em class="kt">深度探索，</em>可以用作搜索图中值的存在或根据路径边的权重找到从一个顶点到另一个顶点的最短路径，或搜索图中循环的存在的解决方案。</p><p id="a399" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与二叉查找树一样，DFS可以在图中递归实现，因为遍历需要回溯已经访问过的顶点，以继续下一个可能的路径。我们需要一个基础案例来实现递归方法；结束递归回调的最低可能值。下面的例子展示了这个基础案例以及我们的递归回调。</p><figure class="kv kw kx ky fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lu"><img src="../Images/13c127614fcb336da6eb337bc7899adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T-bDydyvc9euYVvr6dmo2Q.png"/></div></div></figure><p id="8200" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">深度优先搜索，使用递归方法实现。</p><p id="4c5e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的递归函数接收已定义队列中的下一个顶点以及已访问顶点的列表。一旦到达路径中的基本情况，DFS将回溯到起始点，并对下一个相邻路径重复该过程。</p><p id="4c8d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读！下一次我将介绍更多的图算法，包括Dijkstra算法和拓扑排序，以及本文中讨论的算法的时间复杂性。下次见！</p><h1 id="5811" class="kz ju hy bd jv la lb lc jz ld le lf kd lg lh li kg lj lk ll kj lm ln lo km lp bi translated">引用的消息来源</h1><blockquote class="lv lw lx"><p id="95ed" class="iv iw kt ix b iy iz ja jb jc jd je jf ly jh ji jj lz jl jm jn ma jp jq jr js hb bi translated">威斯康辛州切斯维克；h . burch(1999年4月)。“绘制互联网地图”。IEEE计算机。32 (4).</p><p id="393c" class="iv iw kt ix b iy iz ja jb jc jd je jf ly jh ji jj lz jl jm jn ma jp jq jr js hb bi translated">海西扎克。“对象与数组。Zac Heisey认为对象和数组都是“中等的”<em class="hy">介质</em>，介质，2019年4月25日，<a class="ae hv" rel="noopener" href="/@zac_heisey/objects-vs-arrays-42601ff79421.">https://Medium . com/@ Zac _ heisey/objects-vs-arrays-42601 ff 79421。</a></p><p id="aad4" class="iv iw kt ix b iy iz ja jb jc jd je jf ly jh ji jj lz jl jm jn ma jp jq jr js hb bi translated">裴，余思敏。JavaScript数据结构和算法。第一版。，Apress，2019年，第279页。</p><p id="5134" class="iv iw kt ix b iy iz ja jb jc jd je jf ly jh ji jj lz jl jm jn ma jp jq jr js hb bi translated">梅希亚艾德里安。"面向初学者的JavaScript图形数据结构|阿德里安·梅希亚博客."<em class="hy">阿德里安·梅希亚博客</em>，亚当·梅希亚，2020年12月15日，l https://adrianmeijia . com/data-structures-for-初学者-graphs-time-complexity-tutorial/。</p><p id="165a" class="iv iw kt ix b iy iz ja jb jc jd je jf ly jh ji jj lz jl jm jn ma jp jq jr js hb bi translated">"图表遍历|零到精通学院."<em class="hy"> ZTM学院|零到精通学院</em>，Zero To Mastery，2021，<a class="ae hv" href="https://academy.zerotomastery.io/courses/master-the-coding-interview-data-structures-algorithms/lectures/12670913." rel="noopener ugc nofollow" target="_blank">https://Academy . Zero tomastery . io/courses/master-the-coding-interview-data-structures-algorithms/lections/12670913。</a></p><p id="f88b" class="iv iw kt ix b iy iz ja jb jc jd je jf ly jh ji jj lz jl jm jn ma jp jq jr js hb bi translated">" Javascript中深度优先的搜索遍历."<em class="hy"> RxJS，Ggplot2，Python数据持久化，Caffe2，PyBrain，Python数据访问，H2O，Colab，Theano，Flutter，KNime，Mean。Js，Weka，Solidity </em>，<a class="ae hv" href="https://www.tutorialspoint.com/Depth-first-search-traversal-in-Javascript." rel="noopener ugc nofollow" target="_blank">https://www . tutorialspoint . com/Depth-first-search-traversal-in-Javascript。</a>2021年6月15日访问。</p></blockquote></div></div>    
</body>
</html>