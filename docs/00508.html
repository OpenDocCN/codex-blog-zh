<html>
<head>
<title>An Angular service to manage loading state indicators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理装载状态指示器的角度服务</h1>
<blockquote>原文：<a href="https://medium.com/codex/an-angular-service-to-manage-loading-state-indicators-cea4503575f3?source=collection_archive---------2-----------------------#2021-02-17">https://medium.com/codex/an-angular-service-to-manage-loading-state-indicators-cea4503575f3?source=collection_archive---------2-----------------------#2021-02-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="f735" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><div class=""><h2 id="6ef9" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">创建可重用且有效的服务来管理对用户交互的视觉响应</h2></div><p id="4b30" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果您已经构建了一两个angular应用程序，那么您可能已经实现了异步服务，比如REST API。当您的用户与您的应用程序交互并触发异步事件时，他们需要知道发生了什么。因此，您创建了加载微调器、状态消息和条件逻辑。这可能会变得重复、令人沮丧，并且不可维护。</p><p id="24b8" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">使用服务来处理响应UI或任何其他发射器触发的事件的逻辑，可以节省大量重复工作，并在应用程序中提供一致性。</p><p id="ae56" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这项服务的目的是:</p><ul class=""><li id="d7f1" class="kc kd hi ji b jj jk jm jn jp ke jt kf jx kg kb kh ki kj kk bi translated">为启用可视元素和消息控制的事件创建状态对象</li><li id="5b9d" class="kc kd hi ji b jj kl jm km jp kn jt ko jx kp kb kh ki kj kk bi translated">提供管理这种状态的功能</li><li id="32fe" class="kc kd hi ji b jj kl jm km jp kn jt ko jx kp kb kh ki kj kk bi translated">为组件之间共享状态提供可观察性</li></ul><p id="1c3a" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">本文给出了这种服务的一个例子。它管理状态对象，这些对象为使用者提供用于向用户呈现信息的参数和方法。它包括反应式编程，以帮助在组件之间共享信息。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kq"><img src="../Images/43d0b44bd41b5695931e6048d58a2a69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K06NdrfZAVh9SKMA5GgS_A.jpeg"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">基本服务让世界运转，而棱角分明的应用程序。(照片M.Raju)</figcaption></figure><p id="bf24" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">要添加完整的服务并开始使用它，请在您的项目中运行这个命令:<code class="du lg lh li lj b">npm i @bit/mxds.angular-components.async-ui-feedback-module</code>。请继续阅读以理解它的构造，或者获得如何实现您自己版本的想法。</p><p id="bf8f" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">旁注:如果你还没有开始使用<a class="ae lk" href="http://bit.dev" rel="noopener ugc nofollow" target="_blank">位</a>，你应该开始使用了。它使你的代码立即可重用，易于维护，并可以在几分钟内设置好。<a class="ae lk" href="https://max-a-raju.medium.com/creating-an-angular-library-to-share-components-with-bit-e1412106d059" rel="noopener">阅读本文，开始行动</a>。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="4986" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">实现分为3个关键部分:状态接口、事件类和服务。<a class="ae lk" href="https://bit.dev/mxds/angular-components/async-uifeedback/~code" rel="noopener ugc nofollow" target="_blank">点击这里查看服务</a>的完整代码。</p><h2 id="fd3c" class="ls lt hi bd lu lv lw lx ly lz ma mb mc jp md me mf jt mg mh mi jx mj mk ml ho bi translated">状态界面</h2><pre class="kr ks kt ku fd mm lj mn mo aw mp bi"><span id="f8bd" class="ls lt hi lj b fi mq mr l ms mt">export interface AsyncUIState {   <br/>    id: number;   <br/>    loading: boolean;   <br/>    error: boolean;   <br/>    complete: boolean;   <br/>    errMessage?: string;   <br/>    successMessage?: string; <br/>}</span></pre><p id="c4f3" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这是组件将用来渲染微调器、文本按钮等的数据…取决于实现该接口的实例的当前值。</p><h2 id="5a84" class="ls lt hi bd lu lv lw lx ly lz ma mb mc jp md me mf jt mg mh mi jx mj mk ml ho bi translated">事件类别</h2><p id="3551" class="pw-post-body-paragraph jg jh hi ji b jj mu is jl jm mv iv jo jp mw jr js jt mx jv jw jx my jz ka kb hb bi translated">这个类提供了控制状态的函数，提供了组件使用的参数，并包含了当前状态的可观察值。对于本文来说太大了，所以点击这里阅读AsyncUIEvent代码。</p><p id="cab2" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">每次需要管理新事件时，服务都会实例化一个事件类对象。然后，该事件保存在要使用的组件中，以及服务中的数组中。</p><p id="c8d0" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">传递给事件构造的参数可以允许关闭反应性(可观察的)特性，并且可以传递一个<code class="du lg lh li lj b">MatSnackBar</code>实例来使事件能够在完成或出错时打开小吃店。</p><p id="f53a" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><code class="du lg lh li lj b">start(), complete(), error()</code>和<code class="du lg lh li lj b">reset()</code>都可以在事件上被调用，以在状态上设置适当的标志/消息。然后，所有这些方法都通过<code class="du lg lh li lj b">state$</code>可观察对象发出状态。</p><h2 id="8ed9" class="ls lt hi bd lu lv lw lx ly lz ma mb mc jp md me mf jt mg mh mi jx mj mk ml ho bi translated">服务</h2><p id="2a4c" class="pw-post-body-paragraph jg jh hi ji b jj mu is jl jm mv iv jo jp mw jr js jt mx jv jw jx my jz ka kb hb bi translated">这是一个单例服务，在root中提供。它创建、获取和删除事件。它还包含所有现有事件的可观察值。每当一个<code class="du lg lh li lj b">event.state$</code>发出一个值时，这个可观测值就会发出。</p><p id="6871" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">delete函数删除事件的现有订阅，应该用于避免任何性能问题。在这里查看服务的完整代码。</p></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><h2 id="d00d" class="ls lt hi bd lu lv lw lx ly lz ma mb mc jp md me mf jt mg mh mi jx mj mk ml ho bi translated">把所有的放在一起</h2><p id="e733" class="pw-post-body-paragraph jg jh hi ji b jj mu is jl jm mv iv jo jp mw jr js jt mx jv jw jx my jz ka kb hb bi translated">有了接口、事件类和服务，您现在可以在您的组件中实现这个服务了。<a class="ae lk" href="https://bit.dev/mxds/angular-components/async-uifeedback/~code#src/async-uifeedback/async-uifeedback.component.ts" rel="noopener ugc nofollow" target="_blank">您可以查看此组件代码，以了解示例实现</a>。</p><p id="cac6" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">希望这里提供的示例代码已经给了您实现自己的类似服务所需的想法。如果您有任何反馈或问题，请发表评论。</p><p id="6858" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">您可以通过调用<code class="du lg lh li lj b">npm i @bit/mxds.angular-components.async-uifeedback</code>下载并实现本文中的服务，并使用该服务将以下内容添加到模块中:</p><pre class="kr ks kt ku fd mm lj mn mo aw mp bi"><span id="fe26" class="ls lt hi lj b fi mq mr l ms mt">import { AsyncUIFeedbackService } from '@bit/mxds.angular-components.async-uifeedback';</span><span id="076d" class="ls lt hi lj b fi mz mr l ms mt">import { MatSnackBarModule } from '@angular/material/snack-bar';</span><span id="e613" class="ls lt hi lj b fi mz mr l ms mt">@NgModule({<br/>    declarations: [AsyncUIExampleComponent],<br/>    imports: [<br/>        CommonModule<br/>        AsyncUIFeedbackModule,<br/>        MatSnackBarModule<br/>    ],<br/>    providers: [AsyncUIFeedbackService]<br/>})<br/>export class ExampleModule { }</span></pre></div></div>    
</body>
</html>