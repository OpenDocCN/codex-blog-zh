<html>
<head>
<title>Why HTTP/3?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么是HTTP/3？</h1>
<blockquote>原文：<a href="https://medium.com/codex/why-http3-cacb2aa45938?source=collection_archive---------6-----------------------#2022-02-04">https://medium.com/codex/why-http3-cacb2aa45938?source=collection_archive---------6-----------------------#2022-02-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="43a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了理解我们为什么需要HTTP/3，让我们花些时间首先理解一些基本的网络术语，然后了解整个互联网在HTTP协议上是如何发展的</p><p id="ac19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在电线上，传输的是互联网数据包。它是由不同网络协议添加的数据+元数据的结构化信息。</p><p id="7342" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网络协议形成一个堆栈来处理不同方面的工作。在IP数据包中，每个协议都添加自己的元数据(称为报头),以插入安全传输和传递这些数据包所需的信息。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/17c329df481cb112c741b0a8eca29a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bUavxhCtnLrxlGqf_Z6AfQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">分组有效载荷</figcaption></figure><p id="aa47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们一点一点地理解几个重要的协议</p><h1 id="ead3" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">互联网协议:</h1><blockquote class="kr"><p id="78c7" class="ks kt hi bd ku kv kw kx ky kz la jc dx translated"><em class="lb"> IP ( </em> <a class="ae lc" href="https://datatracker.ietf.org/doc/html/rfc791" rel="noopener ugc nofollow" target="_blank"> <em class="lb">互联网协议</em> </a> <em class="lb">)是网络层协议</em><strong class="ak"><em class="lb">(</em></strong><a class="ae lc" href="https://images.app.goo.gl/XK2GxHqUV1hCUe7C9" rel="noopener ugc nofollow" target="_blank"><strong class="ak"><em class="lb">第三层</em></strong></a><strong class="ak"><em class="lb">)</em></strong><em class="lb">用来在两台机器之间传输数据。互联网协议在其报头中添加源和客户端ip地址，这样当任一端接收到数据包时，ip协议负责决定是接受还是丢弃数据包。</em></p></blockquote><figure class="le lf lg lh li ji er es paragraph-image"><div class="er es ld"><img src="../Images/e3b5f84d6309b86da79c9b2ed243fc65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*CH0fqG-sjP_ZSfy00Lrlvw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae lc" href="https://datatracker.ietf.org/doc/html/rfc791" rel="noopener ugc nofollow" target="_blank"> IP协议头</a></figcaption></figure><p id="69eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果需要通过小型分组网络传输，因特网协议还提供长数据报(也称为数据或消息)的重组。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lj"><img src="../Images/dddc20a7c71101650bd8efac9ffdf616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqij2DplE5DvB_Q1IXh70Q.png"/></div></div></figure><p id="d145" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">IP协议还有更多，请访问<a class="ae lc" href="https://datatracker.ietf.org/doc/html/rfc791" rel="noopener ugc nofollow" target="_blank">https://datatracker.ietf.org/doc/html/rfc791</a>了解更多信息和报头字段的每个功能。</p><p id="b3c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">互联网协议不可靠，不能保证数据包的传送以及数据包被接收的顺序。所以这是高层协议的工作。</p><h1 id="bc8a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">传输层协议:</h1><p id="1c6e" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">有了IP报头，我们就可以知道哪台计算机向我们发送了internet数据包，哪台计算机应该接收该数据包，但我们不知道在某个端口上运行的哪个应用程序发送了该数据包，以及哪个应用程序将在客户端或服务器端接收该数据包。</p><p id="ebcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们使用TCP和UDP协议。TCP也被认为是一种可靠的协议，除了添加源端口和目的端口，它还执行许多其他功能。</p><h2 id="c7d1" class="lp ju hi bd jv lq lr ls jz lt lu lv kd iq lw lx kh iu ly lz kl iy ma mb kp mc bi translated">传输控制协议:</h2><blockquote class="kr"><p id="ab2c" class="ks kt hi bd ku kv kw kx ky kz la jc dx translated"><em class="lb"> TCP是传输层</em><strong class="ak"><em class="lb">(</em></strong><a class="ae lc" href="https://images.app.goo.gl/XK2GxHqUV1hCUe7C9" rel="noopener ugc nofollow" target="_blank"><strong class="ak"><em class="lb">第4层</em></strong></a><strong class="ak"><em class="lb">)</em></strong><em class="lb">的协议。它允许不同端点上的两台机器可靠地交换数据。把它想象成一个邮递员，他会保证把我们的信息从主机送到目的地，没有任何丢包</em></p></blockquote><figure class="le lf lg lh li ji er es paragraph-image"><div class="er es md"><img src="../Images/8c099dc199e9167ad8568b4752b42fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*VCzbDmMQvToNIvpFThYqkg.png"/></div></figure><p id="8cf3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TCP是一种基于连接的协议，在由4元组标识的3次握手期间创建。这个4元组也被称为套接字</p><ul class=""><li id="f828" class="me mf hi ih b ii ij im in iq mg iu mh iy mi jc mj mk ml mm bi translated">源IP地址</li><li id="fab4" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">源端口</li><li id="57d2" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">客户端IP地址</li><li id="f11e" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">客户端端口</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ms"><img src="../Images/3f813d28140d3b5df53e22bc5441fbec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gb_Jmw8JKA59n7CAch06Bw.jpeg"/></div></div></figure><h2 id="3173" class="lp ju hi bd jv lq lr ls jz lt lu lv kd iq lw lx kh iu ly lz kl iy ma mb kp mc bi translated">TCP协议的工作原理:</h2><ul class=""><li id="769d" class="me mf hi ih b ii lk im ll iq mt iu mu iy mv jc mj mk ml mm bi translated">创建新连接时，TCP首先开始与服务器进行3次握手</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mw"><img src="../Images/f3d10722798bdfbc2c75d04f10568610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06bGpggIstTpWDet06cQRg.png"/></div></div></figure><p id="f7fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在此过程中，客户端和服务器彼此共享初始序列号。</p><p id="8843" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">客户端和服务器使用序列号和确认号来计算发送和接收的字节数。序列号可以随机选择，这只是一种方式，表示我开始计算以这个号码发送的数据。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mx"><img src="../Images/d586879c91ee21693c01c7832720017e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WGAPxlKZeMWxv38GBLd7lQ.png"/></div></div></figure><p id="8ad1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是由于序列号和确认号，如果数据包丢失，TCP可以重新传输数据，并能够以合理的方式对数据进行排序。但是这是有代价的，所有这些开销使得TCP很慢。这就是为什么创建一个新的TCP连接和通过TCP传输数据是缓慢的。</p><h2 id="4aa6" class="lp ju hi bd jv lq lr ls jz lt lu lv kd iq lw lx kh iu ly lz kl iy ma mb kp mc bi translated">用户数据报协议:</h2><p id="3511" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">UDP协议是一种无连接协议，也不保证IP数据包的传递和顺序，因为它缺乏TCP提供的功能，使其比TCP更快。UDP协议添加的元数据的大小较小，这为我们提供了较小数据包消耗较少带宽的优势。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es my"><img src="../Images/557adee9cef2d40960bf7d19af762f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*D_bHWA7Eu8i7ZIxeLDJDUA.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">UDP报头</figcaption></figure><h2 id="457d" class="lp ju hi bd jv lq lr ls jz lt lu lv kd iq lw lx kh iu ly lz kl iy ma mb kp mc bi translated">超文本传输协议:</h2><blockquote class="kr"><p id="ddd7" class="ks kt hi bd ku kv kw kx ky kz la jc dx translated">HTTP(超文本传输协议)是应用层<strong class="ak"> ( </strong> <a class="ae lc" href="https://medium.com/r?url=https%3A%2F%2Fimages.app.goo.gl%2FXK2GxHqUV1hCUe7C9" rel="noopener"> <strong class="ak">第7层</strong> </a> <strong class="ak"> ) </strong>协议，互联网上的两台机器客户端和服务器使用该协议相互通信。把它想象成语法，它塑造了用来交流的语言。</p></blockquote><h2 id="fbb5" class="lp ju hi bd jv lq mz ls jz lt na lv kd iq nb lx kh iu nc lz kl iy nd mb kp mc bi translated">Http的历史:</h2><p id="1ca7" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">HTTP协议是在20世纪90年代引入的。这是一个建立在TCP/IP协议之上的协议。</p><h2 id="6c30" class="lp ju hi bd jv lq lr ls jz lt lu lv kd iq lw lx kh iu ly lz kl iy ma mb kp mc bi translated">HTTP 1/1.1:</h2><p id="0a87" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">HTTP 1/1.1使用基于文本的协议，即使当它发送数据时，它只是发送原始字节，而不是它们的文本编码。但是让HTTP成为文本协议的是数据的交换方式。</p><p id="89de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在HTTP/1.1之前，我们使用基于文本的协议，但在HTTP/2中，我们切换到基于二进制的协议，从而减少了数据包的大小，消耗了更少的带宽。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nf"><img src="../Images/c4b9699c09d2f4d07d20ebf6af5bc6ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ud8D_exILHmjWhbH2fw0sQ.png"/></div></div></figure></div><div class="ab cl ng nh gp ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="hb hc hd he hf"><p id="643f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">基于不同黑白文本和二进制的协议</strong></p><p id="3b12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于二进制的协议面向数据结构，基于文本的协议面向文本(也称为字符串)</p><p id="ce27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如:</p><p id="ee45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我想发送一个32位的整数值:1000000000，即10⁹</p><p id="6f07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在二进制中，只有4个字节。然而，如果我做的是纯文本协议，我必须发送:1，0，0，0，0，0，0，0，0。那是10个字节。</p></div><div class="ab cl ng nh gp ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="hb hc hd he hf"><p id="d8ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.在HTTP/1中，一旦请求得到满足，TCP连接就会关闭，正如我们所知道的，创建一个新的TCP连接和关闭一个新的TCP连接是很昂贵的，如果我们多次发送和接收数据，就会招致巨大的损失。</p><p id="61f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在Http/1.1中，引入了一个新的报头<strong class="ih hj"> keep-alive </strong>来使连接在一段时间内保持打开，这允许客户端重用TCP连接，从而消除了初始连接建立的开销以及跨多个请求的缓慢启动</p><h2 id="1851" class="lp ju hi bd jv lq lr ls jz lt lu lv kd iq lw lx kh iu ly lz kl iy ma mb kp mc bi translated">HTTP 2:</h2><p id="077c" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">HTTP 2协议于2015年推出。它仍然是建立在TCP/IP协议之上的<em class="ne">协议。</em></p><ol class=""><li id="4834" class="me mf hi ih b ii ij im in iq mg iu mh iy mi jc nn mk ml mm bi translated">使用基于二进制的协议来询问如何交换数据会导致执行更小的数据足迹。</li></ol><p id="d30b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.尽管<strong class="ih hj"> keep-alive </strong>报头允许我们为多个请求重用同一个TCP/IP连接，但我们仍然只在这个连接上执行一个请求/响应周期，这导致了HTTP/2(又名SPDY)的引入，它是由Google开发的，引入了HTTP流的概念。一种抽象，允许HTTP实现将不同的HTTP交换并发复用到同一个TCP连接上。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es no"><img src="../Images/9cb3cf553e004cb8d898f255633b4f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5JQcueCCYRpFRyJ2YOpl-A.png"/></div></div></figure><p id="08be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HTTP/2解决了这个问题，即单个TCP连接的低效使用，因为多个请求/响应现在可以同时在同一连接上传输。</p><p id="d86a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，所有的请求和响应都同样受到数据包丢失的影响。即使丢失的数据只涉及单个请求。这是因为虽然应用层的HTTP/2可以在不同的流上隔离不同的HTTP交换，但是TCP仍然不知道这种抽象，它看到的只是没有特定含义的字节流。</p><p id="6956" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TCP是一种可靠的协议，它保证数据包的顺序和传递，因此当TCP发现携带这些字节的数据包丢失时，它会重新传输丢失的数据包，从而导致属于完全独立的请求的数据包的传递延迟，在这些请求中没有数据包丢失。这个问题被称为“行首阻塞”。</p><h2 id="3753" class="lp ju hi bd jv lq lr ls jz lt lu lv kd iq lw lx kh iu ly lz kl iy ma mb kp mc bi translated">HTTP 3:</h2><p id="05f1" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">进入了一个叫做QUIC的新协议，它是由google引入的。早在2013年，也就是HTTP/2协议发布的两年前，谷歌就尝试了这种协议，并在QUIC上部署了HTTP/2。</p><p id="1bf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">QUIC是建立在UDP之上的一种新的传输层协议。HTTP/3现在使用QUIC作为它的传输层。</p><ul class=""><li id="4b6b" class="me mf hi ih b ii ij im in iq mg iu mh iy mi jc mj mk ml mm bi translated">由于握手比TCP上TLS更快，所以新QUIC连接的创建更快。</li></ul><div class="je jf jg jh fd ab cb"><figure class="np ji nq nr ns nt nu paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><img src="../Images/cb050329eaff5126b16a7e49ad3a5634.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*Kp_AbfrW_x9imS53yuLOZA.png"/></div></figure><figure class="np ji nv nr ns nt nu paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><img src="../Images/c2c4fd8eeed194a44c7ed33145853a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*WufqAz9IO4ey7yGri9mWkw.png"/></div></figure></div><ul class=""><li id="ff03" class="me mf hi ih b ii ij im in iq mg iu mh iy mi jc mj mk ml mm bi translated">QUIC借助并行流解决了头部阻塞问题</li><li id="d10e" class="me mf hi ih b ii mn im mo iq mp iu mq iy mr jc mj mk ml mm bi translated">QUIC在传输层提供流，因此任何建立在QUIC之上的应用级协议都将免费获得并行流，无论是HTTP、WS、GRPC、FTP、SMTP。以前，流作为一项功能位于HTTP/2的应用层。<strong class="ih hj"> HTTP/2是TCP上的二进制多路复用，而HTTP/3是多路复用QUIC上的二进制多路复用</strong></li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nw"><img src="../Images/515af6431c88abed4b766d9dbebe0673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATq6quBg6mRWI5UsazPZig.png"/></div></div></figure><p id="5fe4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢谢你跟随了这么久。让我在评论中知道这篇文章的任何改进。</p></div></div>    
</body>
</html>