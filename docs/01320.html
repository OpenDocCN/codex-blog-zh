<html>
<head>
<title>User-Interfacing Software Design Patterns, Revisited</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用户界面软件设计模式，重温</h1>
<blockquote>原文：<a href="https://medium.com/codex/user-interfacing-software-design-patterns-revisited-2ac1dcfd445d?source=collection_archive---------5-----------------------#2021-04-19">https://medium.com/codex/user-interfacing-software-design-patterns-revisited-2ac1dcfd445d?source=collection_archive---------5-----------------------#2021-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/0bde71998cea9542c2bdc971e4e3aec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kHvOFRtxFTlbM_dK"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">凯利·西克玛在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="41c6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当开发面向大众的软件时，最重要的是正确地与用户交互。如果对他们来说，浏览你的应用程序绝对是一场噩梦的话，没有人会在乎幕后有没有花哨的设计模式。</p><p id="fa41" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管如此，记住有两类人在使用你的软件也是很重要的:用户和开发者。一个软件的成功依赖于与用户的交互，而一个软件开发团队的成功依赖于它如何构建软件。在这个阶段，设计模式变得很重要。</p><p id="c62e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，让我们看看一直延伸到用户交互的设计模式。我们将研究MVC(模型-视图-控制器)、MVVM(模型-视图-视图模型)、萨姆(状态-动作-模型)和CQRS(命令-查询责任分离)，以及BFF(后端对前端)“反”模式。</p><p id="7235" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个故事中需要注意的一点是，这些模式是从web应用程序的角度来考察的，在应用于其他任何东西时，可能需要稍作调整。</p><h1 id="b96d" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">手动音量调节</h1><p id="628b" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">MVC代表模型-视图-控制器，可能是列表中最古老的，是在20世纪70年代发明的。</p><figure class="kx ky kz la fd hk er es paragraph-image"><div class="er es kw"><img src="../Images/807dd3177bf6676a112f4657fcbec9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*vX4jZvdyHVflcgccaV93dA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">MVC模式:查询(顶部)和命令(底部)</figcaption></figure><p id="1a1f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用户的主要入口点是控制器，它公开操作。当用户决定与软件交互时，他们通过调用控制器上的动作来实现。然后，控制器做它应该做的事情，并创建一个模型，它本质上是一个结构化的数据包，并在其上应用一个视图，该视图将数据转换成可以发送回客户端的格式(在web应用程序的情况下是HTML)。然后，客户端向用户显示数据，整个系统暂停，等待用户的进一步操作。</p><p id="18e0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果用户决定与呈现在他们面前的东西进行交互，他们可以对模型进行修改，并可以通过一个动作(可以是相同的，但不是必须的)将其提交回控制器。控制器将采用修改后的模型，并在验证(这取决于框架和业务逻辑，可以在多个地方以多种方式发生)后开始做动作应该做的事情。完成后，它生成另一个模型，并在其上应用一个视图，将其发送回用户。</p><p id="2255" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一些关键的东西要拿出来:</p><ul class=""><li id="f942" class="lb lc hy ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">MVC仅仅是对用户的请求做出反应(不管是手动的还是自动的)，根据定义，离开用户什么都不做；某些动作可以由浏览器自动调用，但是对于控制器来说，它们将显示为用户调用的动作，因为它(原则上)无法判断是一段JavaScript代码在执行请求</li><li id="22f6" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">这种模式是以控制器和动作为中心的——控制器和它们公开的动作是为了使这种模式工作而实际需要存在的唯一组件；控制器可能不创建或接受模型，或者可能根本不需要模型，并且实际上可能没有视图本身(除非您将原始数据输出为符合HTTP的格式视为某种默认视图)</li><li id="ce2f" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">就数据呈现给用户的方式而言，更改相对容易——包括对浏览器、各种视窗等的扩展支持。，不影响应用程序的业务逻辑；即使你确实引入了一个bug，如果MVC做得正确，并且模型得到了很好的验证(这通常是一个困难的任务)，在大多数情况下发现和纠正它应该是相当容易的</li><li id="fad2" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">有了好的基于MVC的设计，CQRS和关注点分离都很容易实现</li><li id="6755" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">概念化测试相对容易，但实际编写测试相对困难，因为控制器内部存在严重的紧密耦合，尤其是与底层框架的紧密耦合(ASP.NET MVC就是一个很好的例子，因为在大多数情况下，对底层框架的调用不能被抽象掉，而且这种调用对于许多功能来说是必要的)</li><li id="ea58" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">许多开发人员假设模型与持久性模型(例如，数据库模型)有某种联系，但这是不正确的，因为MVC模式没有这样的要求，模型是否以任何方式匹配数据库完全由实现者决定，数据库模型可以服从组合或相关的MVC模式，如下所述:</li></ul><figure class="kx ky kz la fd hk er es paragraph-image"><div class="er es lp"><img src="../Images/1273831c6ec09a5b252ebcde927b731f.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*LpdEf9pTyZizW2le04O6mA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">MVC中的组合</figcaption></figure><p id="1300" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MVC是一种易于理解、易于实现的模式，但是也容易被误解，并且非常容易被误用。使用这种模式的开发人员最大的缺点是:</p><ul class=""><li id="8a43" class="lb lc hy ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">没有意识到他们在不应该的时候使用了合成</li><li id="096d" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">看不到底层框架的所有链接，以及随之而来的紧密耦合</li><li id="d6cb" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">在业务逻辑中混合UI代码(尤其是在不鼓励紧密分离的框架中，比如Blazor)</li><li id="8bfc" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">糟糕的模型/视图设计，导致业务数据、运营数据和UI数据之间的界限模糊</li><li id="4a85" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">设计不良的中间件，在不应该的时候干扰正常操作，或者在应该的时候不干扰正常操作</li><li id="66e2" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">由于糟糕的执行路径设计而导致脆弱的请求状态，特别是对于实际上要求异步操作的底层框架</li></ul><p id="4f92" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MVC是一种久经考验的设计模式，经受住了时间的考验，但正在成为过去，因为越来越多的开发人员设法将他们的头脑包裹在控制流、安全性、CQRS、可伸缩性、大规模并行性等高级概念上。</p><p id="303c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">延伸阅读:</p><ul class=""><li id="3480" class="lb lc hy ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">Martin Fowler的MVC和其他UI架构的历史:<a class="ae hv" href="https://martinfowler.com/eaaDev/uiArchs.html" rel="noopener ugc nofollow" target="_blank"> GUI架构(martinfowler.com)</a></li><li id="fdbf" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">ASP。NET MVC:【ASP.NET T2】MVC模式|。NET(microsoft.com)</li></ul><h1 id="9a5c" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">MVVM</h1><p id="5956" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">MVVM代表模型-视图-视图模型，从用户交互设计的角度来看，乍一看，它是MVC模式的对立面。</p><figure class="kx ky kz la fd hk er es paragraph-image"><div class="er es lq"><img src="../Images/a9d39cbb2b1a6b1c6149ce69d43672e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*n1u1y5XhgT0nQSma8Tf9Vw.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">MVVM模式</figcaption></figure><p id="0a8d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MVVM的入口是视图，所有与用户的交互都是通过它完成的。视图规定了向用户呈现什么数据，以及如何呈现。视图有它自己的生命，并且在实践中，组成应用程序的视图集合中的任何视图可能有也可能没有任何其他组件，同时仍然正确地实现作为一个整体的模式。</p><p id="7024" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MVVM中的视图通常被认为是声明性的，这意味着它们应该是数据和一切如何绑定的声明，以及命令性的，这意味着用户可用的各种操作是通过绑定到命令来声明的(或者通过一个非常类似的可重写系统来声明默认操作或内部工作)。在这种情况下。NET环境中，这是通过可扩展应用程序标记语言(XAML)实现的。</p><p id="3db6" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">模型是域模型，或者，实际上，是我们希望操作的任何数据模型(它可能是也可能不是数据访问模型，或者数据库模型，或者REST/SOAP数据模型，等等)。)，限制不大。</p><p id="eab7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">视图模型基本上是一个对用户界面有用的模型抽象，用于将事物连接在一起，并保存模型和视图之间的所有中间状态。视图模型，作为一个抽象的概念，不需要以任何方式起作用，然而，在实践中，支持UI的逻辑，支持模型上的变化的逻辑，以及视图的内部状态，都保存在视图模型中。</p><p id="42d4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如上图所述，附件是活页夹，其目的是将视图的各个部分与视图模型的各个部分联系起来，并且通常是MVVM绑定系统的核心，在任何框架中都会有不同的具体实现。</p><p id="5ce3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一些关键的东西要拿出来:</p><ul class=""><li id="057d" class="lb lc hy ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">MVVM是以视图为中心的，这意味着用户交互是其哲学的中心，并且清楚地分离了模型，这意味着唯一紧密耦合并且总是受非表面变化影响的组件是视图模型(注意:视图模型只是在概念上与视图紧密耦合——在实践中，由于它们依赖于完全不同的编写风格，大多数编译器和ide不会注意到许多可能的错误，特别是如果绑定不是类型安全的，这只会在运行时出现；一个特别烦人的实现是WPF，它的绑定系统依赖于可视化树，这并不总是开发者所期望的)</li><li id="33bf" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">MVVM提供了模型和视图之间的分离，但是视图-模型与两者紧密耦合</li><li id="3da3" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">除非有人把他们的设计搞得一团糟，否则支持UI的代码应该与模型完全分离</li><li id="98e8" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">MVVM的组合可以在任何层次上完成，每个视图都可以分解成子组件，子组件通过自己的视图模型、与父视图模型相同的模型、与父视图模型相同的模型，或者以上任意数量的组合来实现自己的MVVM模式(组件可以同时使用父视图模型和自己的视图模型，模型也是如此)</li><li id="f253" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">单元测试和模拟相当容易</li><li id="cfd9" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">相比之下，MVVM模型的学习曲线很陡</li></ul><p id="2d64" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">延伸阅读:</p><ul class=""><li id="315a" class="lb lc hy ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">杰瑞米·利克内斯(Jeremy Likness)MVVM简介:<a class="ae hv" href="https://blog.jeremylikness.com/blog/model-view-viewmodel-mvvm-explained/" rel="noopener ugc nofollow" target="_blank">模型-视图-视图模型(MVVM)讲解|终身开发者(jeremylikness.com)</a></li><li id="c3cf" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">SyncFusion关于布拉佐尔的MVVM的文章，作者Marco Dalla Libera: <a class="ae hv" href="https://www.syncfusion.com/blogs/post/mvvm-pattern-in-blazor-for-state-management.aspx" rel="noopener ugc nofollow" target="_blank">布拉佐尔的MVVM国家管理模式——完全指南| Syncfusion博客</a></li></ul><h1 id="91b5" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">地对空导弹</h1><p id="4cac" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">SAM代表State-Action-Model，与之前描述的体系结构不同，它明确区分了域驱动模型和应用程序状态，并为域驱动模型提供了明确的选项，使其能够根据自己的规则更新自己。</p><figure class="kx ky kz la fd hk er es paragraph-image"><div class="er es lr"><img src="../Images/41f7af4b4d91b475ddf30d37b1707b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*qD6ojClaICi8KEMTeZVPNg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">SAM模式</figcaption></figure><p id="7a9d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">向用户呈现一个视图，它是应用程序状态的纯函数。该视图的工作方式与人们期望的MVC视图非常相似。</p><p id="7b54" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后用户有机会执行一个动作。事实上，一个动作是一个以某种方式改变模型的提议，这个提议通过它自己的一组验证器(在实践中，这些验证器验证提议的改变在形式上是否有效)，移动到模型。</p><p id="17ff" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">模型通过接受者(考虑到模型的当前状态，根据业务规则验证提议的变更是否有效)，选择是接受提议的变更，还是丢弃它。</p><p id="6f4f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果模型接受提议的改变，它将合并该改变，并使它自己的内部状态根据该改变有效，然后或者对其作出反应，更新应用程序状态(通过反应器)，或者通过使状态了解突变(通过学习器)，作为回报，该状态可以根据它自己的规则，提议新的动作，和/或更新呈现给它的用户的视图。</p><p id="0145" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要拿出来的关键东西:</p><ul class=""><li id="c5ac" class="lb lc hy ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">SAM模式赋予模型自己的生命，强调关于它的领域规则，同时将它与视图完全分离</li><li id="74fe" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">该模式将模型的突变作为状态变化的来源</li><li id="9b46" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">该视图在数学上可以描述为在任何时刻状态的纯函数，并且应该随着状态的变化而重新计算</li><li id="e065" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">SAM回避了管理事件订阅的想法，而是依赖于用户的交互来推送状态突变的建议</li><li id="9c45" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">SAM源于TLA+，这是一种软件建模语言，由Leslie Lamport教授创建，是微软研究院的一部分</li></ul><p id="e0ba" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">延伸阅读:</p><ul class=""><li id="da35" class="lb lc hy ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">SAM模式:<a class="ae hv" href="http://sam.js.org/" rel="noopener ugc nofollow" target="_blank"> SAM —状态|操作|模型</a></li><li id="ff5e" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">【lamport.azurewebsites.net】【TLA+】首页</li><li id="7f03" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">Jean-Jacques Dubray的InfoQ文章公开反对MVC并介绍了SAM:【infoq.com，T4】为什么我不再使用MVC框架</li></ul><h1 id="1ecb" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">CQRS</h1><p id="a74a" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">CQRS主张命令-查询责任分离，他建议任何命令/动作/事件处理程序都应该是单向的，也就是说，它要么查询数据，要么改变数据。它不是对以前模式的替代，而是对它们的补充。</p><figure class="kx ky kz la fd hk er es paragraph-image"><div class="er es ls"><img src="../Images/afe0bbaff6b4b569061ab1a134f02d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*gvJazh3gwkq4Eo-dSs-MBA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">CQRS模式</figcaption></figure><p id="5fdc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">查询部分表示单向的数据选择、转换和排列，目的是以特定的和期望的格式(或者是视图，或者是导出，或者是报告)向用户提供数据。</p><p id="fb41" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">命令部分代表单向数据突变。</p><p id="039f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，实际上，很多时候，该命令也有一个查询部分，用于检索它已经变异的实体，以便向用户显示它的新状态。这通常由只关注一个实体的小页面使用，这通常与域实体有几乎一对一的映射。</p><p id="f2b0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然这种实际情况没有实现最严格定义的CQRS，但它通常被认为是一种可接受的实践，因为一个实体不太可能以只影响其书写方式而不影响其阅读方式的方式发生变化。</p><p id="8972" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在MVC中实现CQRS是相当容易的，因为控制器中的动作可以被专门设计为查询或变异。例如，在ASP.NET MVC和其他大多数涉及HTTP的框架中，人们可能会认为其目的是从一开始就支持这种模式的专门实现。</p><p id="ce98" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于MVVM，事情没有那么简单，因为突变和数据绑定的简单效果之间不一定有明确的区别。由于(通常是不正确的，或者至少是过于急切的)绑定逻辑会使底层模型发生超出UI逻辑所要求的变化，因此CQRS最好严格地在视图模型内部实现，也就是说，即使视图模型由于数据绑定而使其内部状态发生变化，这些变化也不会影响底层模型，除非一个命令(比如一个概念性的“save”)触发了这种变化。</p><p id="57e3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">山姆并不太关心CQRS，因为突变仅仅是模型的意愿(因此从CQRS的角度来看“命令”的概念并不特别相关)，而视图(作为一个概念上的查询)基本上是国家的功能。从接受者和反应者/学习者的角度来看，CQRS在定义上是实现的。</p><p id="cbec" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">几样东西要拿出来:</p><ul class=""><li id="7f17" class="lb lc hy ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">CQRS的目标是让数据单向流动，以简化应用程序</li><li id="228d" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">通过将查询从命令中分离出来，CQRS旨在通过减少易变来源的数量来隔离应用程序中的变化；如果一个实体改变了它的结构，但不是以影响某些查询的方式，则这些查询不需要被触及；类似地，如果某个查询因某种业务需求而改变，那么就不需要修改命令，即使该查询被扩展以包括新的实体</li><li id="4c3a" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">复杂的域从CQRS中受益最多，尤其是在应用程序设计中结合单点更改策略时，尽管在实践中，这并不总是可能的</li><li id="79fe" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">对于资源访问同步需要特别小心，因为一个遵循严格CQRS的实现不佳的多线程应用程序几乎肯定会出现许多不一致的问题和竞争情况</li></ul><p id="ca60" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">延伸阅读:</p><ul class=""><li id="9b96" class="lb lc hy ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">马丁·福勒的CQRS文章:<a class="ae hv" href="https://www.martinfowler.com/bliki/CQRS.html" rel="noopener ugc nofollow" target="_blank">(martinfowler.com)CQRS</a></li><li id="111f" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">微软的Azure架构中心文章:<a class="ae hv" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs" rel="noopener ugc nofollow" target="_blank"> CQRS模式— Azure架构中心|微软文档</a></li></ul><h1 id="24b8" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">最好的朋友</h1><p id="6f92" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Sam Newman的BFF被许多人认为是一种反模式或滑稽的最后手段模式，它代表后端对前端，可以被认为是对通用后端API架构的有力批评，也可以被认为是在没有理由拥有通用后端API架构时的一种有用模式。</p><figure class="kx ky kz la fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lt"><img src="../Images/730808d6c473a1d4b5970d29ca00ef55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bTG4ts9ACCAa8tOIuXqOXg.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">通用后端(左)和BFF模式(右)</figcaption></figure><p id="9277" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种模式背后的思想是，独特的前端(或前端类别)有独特的需求，因此，也应该有独特的后端(或者至少是面向公众的API集)。</p><p id="3f67" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个想法已经被广泛使用，因为基于AJAX的web应用程序的需求不同于iOS应用程序的需求，例如，在会话管理、安全性、信任、可访问性、数据流等方面。因此，我们的想法是，没有理由用有限的API来增加应用程序拥有更好的API功能的负担。</p><p id="9e22" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似地，可以通过多种方式进行通信(最简单的例子是使用web sockets技术的web程序集，而不是传统的基于AJAX的应用程序)，这意味着一些API工具可以极大地提高性能、速度和特性，而这对于通用后端来说是非常困难的。</p><p id="17dd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一些关键的东西要拿出来:</p><ul class=""><li id="2802" class="lb lc hy ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">BFF基于不同类型的前端和/或客户端之间的框架、硬件和底层系统设施的不平等</li><li id="e90f" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">被许多纯粹主义者认为是一种反模式，BFF背后的思想实际上在特定的环境中非常有用</li><li id="b696" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">BFF并不一定意味着不能实现其他模式——事实上，每个后端都可以正确、完整地实现其他模式</li><li id="59f2" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">当实现BFF时，总是存在代码重复的风险——在这种情况下，要么使后端具有一个公共根，要么，根据重复代码的性质，可以为该公共部分实现一个新的服务</li><li id="08c8" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">BFF也可以面向外部服务消费者实现，这意味着在同一组服务上，不同的下游服务(联合、流等。)将连接到不同的“前端”</li><li id="c878" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">BFF是一种跨团队并行开发的方式，同时提供了自治</li><li id="2dc1" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">BFF的一个关键问题是保持功能的同步，这意味着产品所有者将更难管理这样的架构选择</li></ul><p id="e079" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">延伸阅读:</p><ul class=""><li id="f008" class="lb lc hy ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">萨姆·纽曼的介绍和理由:<a class="ae hv" href="https://samnewman.io/patterns/architectural/bff/" rel="noopener ugc nofollow" target="_blank">萨姆·纽曼——前端的后端</a></li><li id="6345" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">Lukasz Plotnicki关于SoundCloud的BFF:<a class="ae hv" href="https://www.thoughtworks.com/insights/blog/bff-soundcloud" rel="noopener ugc nofollow" target="_blank">BFF @ SoundCloud | ThoughtWorks</a></li><li id="cac0" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">微软简介:<a class="ae hv" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/backends-for-frontends" rel="noopener ugc nofollow" target="_blank">前端模式的后端—云设计模式|微软文档</a>(特别是相关指导部分)</li></ul></div></div>    
</body>
</html>