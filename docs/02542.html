<html>
<head>
<title>ExecutorService Internal Working in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的ExecutorService内部工作</h1>
<blockquote>原文：<a href="https://medium.com/codex/executorservice-internal-working-in-java-7b286882f54e?source=collection_archive---------2-----------------------#2021-07-25">https://medium.com/codex/executorservice-internal-working-in-java-7b286882f54e?source=collection_archive---------2-----------------------#2021-07-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c60a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Executor服务框架可以说是并行执行工作的最受欢迎和易于使用的概念。它有助于并行执行，而不需要开发人员负责多线程带来的复杂性。开发人员可以生成一个Executor服务，并向它提交任务，让它以并行方式运行。</p><p id="85b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我一直喜欢理解它实际上是如何并行处理所有这些任务的，并理解随之而来的所有细微差别，如CorePoolSize、队列、处理程序等。我们将更详细地了解这些概念，并理解我们可以利用的开箱即用功能的出色之处。</p><h1 id="135a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">什么是遗嘱执行人服务？</h1><p id="dd8f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在编程时，您可能遇到过这样的场景:您有一些类似的任务要执行，并且希望并行执行它们以加快速度。例如，如果您有一个服务，它接受用户输入并调用后端服务来处理它们。</p><p id="cc22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以选择串行处理，对于每一个输入，您进行后端调用，并对收到的每一个输入都这样做。但你可以想象，这将是一个缓慢的系统。</p><p id="24b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了实现并行性，您可以利用线程模型，假设您有10个线程，每个线程可以接收一个输入，并进行后端调用来处理它们。这样，您的系统可以支持10倍于以前的负载。因为您将有10个线程等待接收输入并处理它们，所以在任何给定的时间，您将能够处理10个输入。但是，这也是有代价的。</p><p id="51b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您需要担心线程间的通信，在高负载时产生新线程，在低负载时终止空闲线程，确保锁定、竞争条件、线程间的死锁，维护各种线程的状态，等等。因此，为了减轻这些事情，以便开发人员可以专注于他感兴趣的核心事情，例如，这里只是进行后端调用，Java JDK中有ExecutorService框架。</p><p id="c738" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ThreadPoolExecutor只是ExecutorService接口的实现。</p><h1 id="6ea3" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">线程池执行器的基本工作方式:</h1><p id="3923" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">线程池执行器需要一些已定义的参数，它使用这些参数来控制它将创建的线程数量，以处理提交给它的任务。我们将详细了解所有这些参数，但让我们从1000英尺的高度了解ThreadPoolExecutors实际上是如何工作的:</p><p id="48f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，基本原则是任务提交频率可能与任务处理速率不同步，这意味着如果每秒提交100个任务，而所有线程在1秒内只能处理10个任务，那么我们仍然不想丢失这90个任务。</p><p id="ad9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以有一个众所周知的数据结构来处理这种情况:队列。<br/>因此，如果没有线程空闲，我们可以将所有任务推到队列中，一旦任务从当前工作中释放出来，它们最终将被线程读取执行。</p><p id="b358" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，线程池中的线程可以读取提交的最旧的任务(位于队列的最前面)，并开始处理它。</p><p id="6a1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，使用队列，线程可以按照自己的速度处理任务。根据给定的某些参数，线程数可以增加/减少，我们将在下面看到它是如何工作的。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/c1203f5e2cb1d904e595c99af4c2f7fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tC7YTIgRK5FxRqyOIr0VSw.png"/></div></div></figure><h1 id="5eb0" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">线程池执行器中的术语:</h1><h2 id="8818" class="ks je hi bd jf kt ku kv jj kw kx ky jn iq kz la jr iu lb lc jv iy ld le jz lf bi translated"><strong class="ak"> 1。CorePoolSize </strong></h2><p id="1b3b" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">CorePoolSize是新任务到达时必须并行运行的线程数。如果CorePoolSize = 10，并且到目前为止只有5个任务被提交，那么我们将有5个线程正在运行/活动。当提交第6个任务时，不是将新任务放入队列，而是创建第6个线程，该任务将立即提交给它。即使先前创建的5个线程是空闲的，并且已经完成了它们的工作并等待新的任务，也是如此。因此，如果运行的线程少于CorePoolSize线程，将始终创建一个新线程来处理新任务。</p><h2 id="ba2c" class="ks je hi bd jf kt ku kv jj kw kx ky jn iq kz la jr iu lb lc jv iy ld le jz lf bi translated"><strong class="ak"> 2。最大尺寸</strong></h2><p id="7ddb" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">该属性控制可以运行的最大线程数。因此，当我们创建了CorePoolSize数量的线程，并且新任务到达时，它们将被放入队列。现在，一旦队列也变满，如果MaximumPoolSize &gt; CorePoolSize，就会创建新的线程。假设CorePoolSize为10，MaximumPoolSize=15，我们有一个大小为10的队列。如果我们有20个高频率的请求，那么所有10个线程都被创建并开始运行它们的任务，另外10个任务被放入队列。现在，当第21个任务到达时，由于MaximumPoolSize &gt; CorePoolSize，将创建一个新线程，它可以开始从队列中读取数据，以便为队列中的第21个任务腾出空位。</p><p id="0032" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以当新任务到达时<strong class="ih hj">规则</strong>是:</p><p id="7e36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a.如果运行的线程少于CorePoolSize，执行器总是倾向于创建一个新线程，而不是排队。</p><p id="b67f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b.如果CorePoolSize或更多线程正在运行，执行器总是更喜欢将请求排队，而不是创建一个新线程。</p><p id="30db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">c.如果请求无法排队，将创建一个新线程，除非它超过maximumPoolSize，在这种情况下，任务将被拒绝。</p><h2 id="8497" class="ks je hi bd jf kt ku kv jj kw kx ky jn iq kz la jr iu lb lc jv iy ld le jz lf bi translated"><strong class="ak"> 4。KeepAliveTime </strong></h2><p id="d9a3" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这可以防止线程闲置和浪费资源，并且可以用来控制何时终止空闲线程。因此，如果CorePoolSize=10，在上面的例子中，我们有11个线程在运行。一旦所有的任务都被处理，并且说这些线程正在等待新任务的到来，它们就会处于空闲状态，浪费资源。然后，如果多余的线程(大于CorePoolSize，即这里的1)处于空闲状态的时间超过了KeepAliveTime，那么这些线程将被终止。因此，当池未被频繁使用时，该属性有助于减少资源消耗。</p><h2 id="7c90" class="ks je hi bd jf kt ku kv jj kw kx ky jn iq kz la jr iu lb lc jv iy ld le jz lf bi translated"><strong class="ak"> 5。工作队列</strong></h2><p id="1b1d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">队列用于保存提交的任务。可以使用3种类型的队列:</p><ul class=""><li id="6042" class="lg lh hi ih b ii ij im in iq li iu lj iy lk jc ll lm ln lo bi translated"><strong class="ih hj">直接移交(类似同步队列)</strong>:它不会保存任何任务，每当有请求加入队列时，它会移交给线程。如果没有可用的线程，那么排队操作将会失败。通常，如果要使用这样的队列，MaximumPoolSize被设置为一个非常大的值，以便我们可以用新线程处理所有传入的请求，而不是将它们保留在队列中。它在需要执行更多实时操作而不需要存储它们并在以后执行它们的地方找到了它的用途。</li><li id="4a37" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated"><strong class="ih hj">无界队列(如LinkedBlockingQueue) </strong>:这种队列没有任何大小设置，因此称为无界队列。因为这样的队列永远不会满，所以en-queue永远不会失败，并且永远不会创建比CorePoolSize更多的线程，因此在这样的队列中，MaximumPoolSize属性不可用。(回想一下，如果添加到队列失败，那么如果MaximumPoolSize&gt;CorePoolSize，则会创建新线程)。</li><li id="f261" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated"><strong class="ih hj">有界队列(像ArrayBlockingQueue) </strong>:这种队列有固定的大小，所以当请求&gt; CorePoolSize时，一个新的请求会被添加到队列中。一旦这个队列也满了，新的线程(如果MaximumPoolSize&gt;CorePoolSize)将被创建。</li></ul><h2 id="3ed4" class="ks je hi bd jf kt ku kv jj kw kx ky jn iq kz la jr iu lb lc jv iy ld le jz lf bi translated"><strong class="ak"> 6。线程工厂</strong></h2><p id="df0a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">因为新线程是随着新请求的到来而创建的，所以我们需要一个可以创建新线程的工厂。默认情况下，所有创建的线程都具有相同的优先级、相同的线程组、非守护进程状态等。当然，这样的事情可以通过提供自己的ThreadFactory来改变。</p><h2 id="2ba9" class="ks je hi bd jf kt ku kv jj kw kx ky jn iq kz la jr iu lb lc jv iy ld le jz lf bi translated"><strong class="ak"> 7。RejectedExecutionHandler </strong></h2><p id="2985" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">当执行器关闭时，如果队列已满且创建了MaximumPoolSize线程，则无法处理新的请求，因此在这些场景中，传入的请求将被拒绝。您可以提供自己的RejectionHandler来处理这种拒绝。默认情况下，提供了4个这样的处理程序:</p><ul class=""><li id="4cd2" class="lg lh hi ih b ii ij im in iq li iu lj iy lk jc ll lm ln lo bi translated"><strong class="ih hj"> AbortPolicy: </strong>如果使用此处理程序，将抛出RejectedExecutionException。</li><li id="c8ea" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated"><strong class="ih hj">caller run policy:</strong>有了这个处理程序，一旦任务被执行器拒绝，客户机就自己运行任务。</li><li id="210c" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated"><strong class="ih hj"> DiscardPolicy: </strong>使用这个处理程序，被拒绝的请求被简单地丢弃/忽略。</li><li id="1ea8" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated"><strong class="ih hj"> DiscardOldestPolicy: </strong>使用这个处理程序，队列中最旧的任务被丢弃，然后重试这个任务。</li></ul><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lu"><img src="../Images/417f6254eb40699453c7371480c99fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gqriEbZv58WLfcHD1_ESaw.png"/></div></div></figure><p id="360c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，线程池有5种状态:</p><ol class=""><li id="eb98" class="lg lh hi ih b ii ij im in iq li iu lj iy lk jc lv lm ln lo bi translated"><strong class="ih hj">正在运行</strong> : ThreadPool可以接收新任务。</li><li id="0752" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc lv lm ln lo bi translated"><strong class="ih hj">关机</strong>。不接受新任务，但可以处理已经添加到队列中的任务。</li><li id="3585" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc lv lm ln lo bi translated"><strong class="ih hj">停止</strong>:不接受新任务，不处理队列中的任务，也中断当前正在执行的任务。</li><li id="ff93" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc lv lm ln lo bi translated"><strong class="ih hj">整理</strong>:所有任务已经终止，WorkerCount为零。线程将处于整理状态，并很快运行Terminated()钩子方法。</li><li id="41c4" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc lv lm ln lo bi translated"><strong class="ih hj">终止:</strong>执行终止()方法。这是一个钩子方法，我们可以在ThreadPool结束时做一些处理。</li></ol></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="9ca6" class="jd je hi bd jf jg md ji jj jk me jm jn jo mf jq jr js mg ju jv jw mh jy jz ka bi translated">创建ThreadPoolExecutor:</h1><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="2033" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过指定corePoolSize、MaximumPoolSize、keepAliveTime等，我们可以修改我们希望ThreadPoolExecutor看起来是什么样子。<br/> <br/>但是如果我们不想太担心所有这些，那么我们也可以利用一些现有的内置方法:</p><p id="6f34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.<strong class="ih hj">固定线程池执行器</strong> —创建一个线程池，它重用固定数量的线程来执行任意数量的任务。如果在所有线程都处于活动状态时提交额外的任务，它们将在队列中等待，直到有一个线程可用。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="e40a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">缓存线程池执行器</strong> —创建一个线程池，该线程池根据需要创建新线程，并在先前构建的线程可用时重用它们。由于这将在需要时创建线程，如果任务是长期运行的，那么必须使用<strong class="ih hj">而不是</strong>。如果线程数量超出了系统的处理能力，就会导致系统崩溃。如果你能想到这是如何工作的-这很简单，它将maximumPoolSize设置为无穷大。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="5ebd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj">调度线程池执行器</strong> —创建一个线程池，该线程池可以调度命令在给定延迟后运行，或者定期执行。<br/>为此，使用了一种特殊类型的队列(DelayedWorkQueue ),当轮询请求到来时，它只在一定的延迟后返回值。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="62f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.<strong class="ih hj">单线程池执行器</strong> —创建单线程来执行所有任务。由于所有任务都将由一个线程执行，因此所有任务都是按顺序执行的。您可能已经猜到了，它的corePoolSize和maximumPoolSize = 1。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mi mj l"/></div></figure></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="ba7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ThreadPoolExecutors中使用了另一个非常巧妙的东西，我非常喜欢。如果您对二进制操作感兴趣，请阅读一下。是<strong class="ih hj"> ctl的用法。</strong></p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="a287" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ThreadPoolExecutor每次需要知道两种状态:</p><ul class=""><li id="1f81" class="lg lh hi ih b ii ij im in iq li iu lj iy lk jc ll lm ln lo bi translated">说明它在。有5种状态:运行，关机，停止，整理，终止。</li><li id="ecce" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">正在运行的线程数。</li></ul><p id="1fd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用一个对象来拥有这两种状态，但是由于这两种状态都是整数，为了加快速度，我们用一个整数值来表示这两种状态。我们来看看是怎么做的。</p><p id="9f30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在java中，整数有32位。因此，我们必须利用这32位来表示上述2个参数。因为我们只有5个状态，而5可以用3位来表示:000，001，010，011，101，所以32位整数中最左边的3位用来表示线程池执行器的状态。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mk"><img src="../Images/40c9466d5edb87fa8f7e30425e9a8ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w8pOOtGzXnw7_F4MfXZUeQ.png"/></div></div></figure><p id="dfc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">剩余的29位用于表示线程池执行器中运行的线程数量。所以现在我们要担心两个操作:</p><ul class=""><li id="7922" class="lg lh hi ih b ii ij im in iq li iu lj iy lk jc ll lm ln lo bi translated">如何将两个参数合并成一个整数？</li><li id="a85a" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">如何从一个整数中检索State和WorkerCount？</li></ul><p id="4a02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试着理解这些:</p><pre class="kh ki kj kk fd ml mm mn mo aw mp bi"><span id="900a" class="ks je hi mm b fi mq mr l ms mt">COUNT_BITS = Integer.SIZE - 3; <br/>COUNT_BITS = 32 - 3 = 29</span><span id="5184" class="ks je hi mm b fi mu mr l ms mt">CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;<br/>i.e. 00000000000000000000000000000001 &lt;&lt; 29 - 1<br/>i.e. 00100000000000000000000000000000 - 1<br/>i.e. 00011111111111111111111111111111</span></pre><p id="464c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有状态都存储在最左边的3位，并携带0到5之间的值，因此这些0-5值左移29位。例如</p><pre class="kh ki kj kk fd ml mm mn mo aw mp bi"><span id="7571" class="ks je hi mm b fi mq mr l ms mt">RUNNING   = -1 &lt;&lt; COUNT_BITS i.e.  <strong class="mm hj"><em class="mv">111</em></strong>00000000000000000000000000000<br/>SHUTDOWN<!-- -->   = 0 &lt;&lt; COUNT_BITS i.e.  <strong class="mm hj"><em class="mv">000</em></strong>00000000000000000000000000000<br/>STOP       = 1 &lt;&lt; COUNT_BITS i.e.  <strong class="mm hj"><em class="mv">001</em></strong>00000000000000000000000000000<br/>TIDYING    = 2 &lt;&lt; COUNT_BITS i.e.  <strong class="mm hj"><em class="mv">010</em></strong>00000000000000000000000000000<br/>TERMINATED = 3 &lt;&lt; COUNT_BITS i.e. <strong class="mm hj"> </strong><strong class="mm hj"><em class="mv">011</em></strong>00000000000000000000000000000</span></pre><p id="7210" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们可以看到，这些状态仅设置了前3位，其余29位为0，供正在运行的线程数或“WorkerThreads”使用。为了将状态和工作线程结合起来，使用了ctlOf方法:</p><pre class="kh ki kj kk fd ml mm mn mo aw mp bi"><span id="c426" class="ks je hi mm b fi mq mr l ms mt">int ctlOf(int rs, int wc) { return rs | wc; }</span><span id="e419" class="ks je hi mm b fi mu mr l ms mt">E.g. if rs = RUNNING = <strong class="mm hj"><em class="mv">111</em></strong>00000000000000000000000000000<br/>And wc = 2 = 00000000000000000000000000000010<br/>Then ctl = <strong class="mm hj"><em class="mv">111</em></strong>00000000000000000000000000000 | 00000000000000000000000000000010<br/>= 11100000000000000000000000000010</span></pre><p id="8311" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们在<code class="du mw mx my mm b">11100000000000000000000000000010</code>中看到的，前3位= 111 =运行，其余29位代表2 =工作线程。为了从ctl中检索这些值；使用了RunStateOf方法；</p><pre class="kh ki kj kk fd ml mm mn mo aw mp bi"><span id="a8f8" class="ks je hi mm b fi mq mr l ms mt">runStateOf(int c)     { return c &amp; ~CAPACITY; }<br/>e.g. if c = <!-- -->11100000000000000000000000000010<br/> CAPACITY = <!-- -->00011111111111111111111111111111<br/>~CAPACITY = 11100000000000000000000000000000</span><span id="1649" class="ks je hi mm b fi mu mr l ms mt">c &amp; ~CAPACITY = <br/>  <!-- -->11100000000000000000000000000010<br/>&amp; 11100000000000000000000000000000 to get<br/>  11100000000000000000000000000000 i.e. RUNNING State</span></pre><p id="b59a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于~CAPACITY的右29位= 0，&amp; with ctl将使29位为0，并将只返回最左边的2位。类似地，为了获得工作线程计数，使用WorkerCountOf:</p><pre class="kh ki kj kk fd ml mm mn mo aw mp bi"><span id="727f" class="ks je hi mm b fi mq mr l ms mt">workerCountOf(int c)  { return c &amp; CAPACITY; }<br/>e.g. if c = <!-- -->11100000000000000000000000000010<br/>CAPACITY = <!-- -->00011111111111111111111111111111</span><span id="0197" class="ks je hi mm b fi mu mr l ms mt">c &amp; CAPACITY = <br/>  <!-- -->11100000000000000000000000000010<br/>&amp; 00011111111111111111111111111111 to get<br/>  000<!-- -->00000000000000000000000000010<!-- --> i.e. WorkerCount=2</span></pre><p id="8300" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为CAPACITY的所有29位都是1，最左边的3位=0，所以&amp; with ctl将只返回最右边的29位值，它反映了workerCount。因此，我们可以看到如何使用简单的位操作概念来封装ThreadPoolExecutor的两个重要属性。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="8c27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果上面的理论是清楚的，我们就可以进入代码在线程池执行器中的样子，以及它如何支持上面所有的用例。execute(Runnable Runnable)——在这里我们将任务提交给ExecutorService。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="ca64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它在3 if块中涵盖了3种场景——如果可以创建新线程，如果可以将任务推入队列，或者如果需要拒绝任务。</p><p id="b47e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第8–12行</strong>:如果worker Thread count&lt;CorePoolSize，那么我们需要生成一个新线程，并直接将任务交给它。<br/>我们将看到addWorker做了什么，但它基本上创建了一个新线程，并让它运行Runnable/task。</p><p id="1912" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第17行:</strong>如果worker thread counts≥CorePoolSize，那么我们需要在线程池没有停止(处于运行状态)的情况下，将传入任务推送到队列中。</p><p id="7497" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第22–23行:</strong>为了处理线程池在新任务添加到队列后停止的情况，我们重新检查线程池是否仍在运行。如果没有，我们撤销队列。提供()并拒绝任务。</p><p id="c018" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第27–28行:</strong>处理CorePoolSize设置为0的场景。在这种情况下，任务将被添加到队列中，但是永远不会创建线程来执行这些任务。所以我们检查活动线程的数量。如果WorkerThread count为0，我们只需创建一个新线程，它将从队列中读取数据，以处理队列中的任务。</p><p id="32db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第32–33行:</strong>如果worker thread count&lt;CorePoolSize和队列已经满了，并且我们无法将该任务添加到队列中，我们将简单地拒绝该任务。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="829a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加工作方法:</p><p id="ac5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">AddWorker()有三个函数:</p><ol class=""><li id="329e" class="lg lh hi ih b ii ij im in iq li iu lj iy lk jc lv lm ln lo bi translated"><strong class="ih hj"> addWorker(Runnable firstTask，corePoolSize=true) </strong> <br/>用firstTask生成一个线程，新线程必须在corePoolSize边界内创建。可以看作是一种生成核心线程的方法。</li><li id="4cf0" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc lv lm ln lo bi translated"><strong class="ih hj"> addWorker(Runnable firstTask，corePoolSize=false) </strong> <br/>用firstTask生成一个线程，在MaximumPoolSize边界内必须创建一个新线程。它可以被视为一种生产非核心线程的方法。</li><li id="fa39" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc lv lm ln lo bi translated"><strong class="ih hj">add worker(Runnable firstTask = null，corePoolSize=false) </strong> <br/>生成一个空闲线程(没有first task)，必须在MaximumPoolSize边界内创建一个新线程。因为它的FirstTask为null，所以它将从队列中读取数据来获取需要执行的任务。</li></ol><p id="3a96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回想一下，如果ThreadPool = RUNNING state，那么它可以执行新的任务。如果ThreadPool = SHUTDOWN state，那么它不能接受新任务(因此对于SHUTDOWN情况，firstTask = null)，但是它仍然可以执行排队的任务。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="afe8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试着详细理解这一点:</p><p id="b0da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第12–14行:</strong>检查线程池是否处于运行状态。如果是，那么我们可以继续进行。如果处于关闭状态，则检查firstTask是否为null，因为在关闭状态下，它不能接受新任务，而只能执行排队的任务。在关闭状态下，它还检查队列是否为空。如果队列是空的，那么就没有任务要执行，所以创建一个新线程是没有意义的。</p><p id="e8a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第18–22行:</strong>检查当前有多少工作线程处于活动状态。我们检查WorkerThreads是否超过了OS允许的线程容量，如果超过了CorePoolSize和maximumPoolSize，那么我们就不能创建新的线程，所以我们不会继续。</p><p id="7252" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第25–26行:</strong>如果上述条件都不成立，我们将增加工作线程数。如果增量成功完成，我们可以继续创建一个新的线程，否则这个逻辑在循环中再次执行。</p><p id="f117" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们知道新任务已经存在(firstTask或者在队列中)，我们可以继续创建新线程(Worker Thread)。</p><p id="bf9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第41行</strong>:创建一个新的工作线程，将第一个任务传递给它。Worker Thread具有处理这种情况的逻辑(我们将在后面的部分看到),如果传递的firstTask为null，它从队列中读取以执行任务，否则它首先执行这个firstTask。</p><p id="6b5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Line 52–64</strong>:我们在访问/更新工作者列表之前获取锁。但是为了处理线程池可能在锁获取期间关闭的情况，我们再次检查了条件。<br/>检查线程池是否处于运行状态，然后我们就好了。如果它处于关闭状态，并且第一个任务是空的，那么我们也可以创建新的线程。这些是以前做过的检查，现在再次复查。<br/>如果我们可以继续，我们会将新创建的工作线程添加到工作线程列表中。</p><p id="ca6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Line 70–72</strong>:一旦我们创建了新的工作线程，我们就立即启动它，这样它就可以开始执行第一个任务或者队列中的任务。我们将在下面看到这个WorkerThread是如何工作的。</p><p id="9338" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Line 76–78</strong>:如果工作线程由于某种原因无法启动，我们需要撤销已经完成的操作。<br/>我们将从workerList中删除该工作者+减少工作者计数+终止/中断该工作者。这个逻辑在addWorkerFailed方法中处理。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h2 id="c053" class="ks je hi bd jf kt ku kv jj kw kx ky jn iq kz la jr iu lb lc jv iy ld le jz lf bi translated">工作线程</h2><p id="a270" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">工人只是可以跑的:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="c1fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如在上面的addWorker处理中所看到的，当工作线程被创建时，我们启动它。因此，我们将看到它的run方法是如何实现的，因为一旦Worker启动，它就会被调用。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="a5da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦WorkerThread启动，它将首先尝试执行提供给它的第一个Task。一旦它执行了这个任务，或者如果这个任务为空，它将从队列中选择新的任务，并执行它。它将继续这样做，直到线程池停止，所以一旦我们启动了10个工作线程，所有这10个线程将从队列中轮询以选择要执行的任务。</p><p id="7557" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第12行:如果FirstTask = null，它将从队列中挑选一个新任务运行。</p><p id="e7b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第25–37行</strong>:调用beforeExecute钩子方法，然后运行任务，再调用afterExecute钩子方法。如果客户机希望在任务执行前后做一些额外的日志记录/处理，这些就很有用。</p><p id="5205" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第46行</strong>:为了处理线程池状态变化，或者执行任务时出现的外部错误，调用processWorkerExit。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="693e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第2–14行</strong>:如果这个方法由于某种异常被调用(completedAbruptly=true ),那么我们减少工作者计数，从工作者列表中删除这个工作者，并终止这个工作者线程。</p><p id="40ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">第17-25行</strong>:如果线程池仍在运行，如果WorkerThreads小于CorePoolSize，并且如果Queue有任务要执行，那么这个方法将创建一个新的WorkerThread，基本上替换之前失败的那个。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="04b5" class="jd je hi bd jf jg md ji jj jk me jm jn jo mf jq jr js mg ju jv jw mh jy jz ka bi translated">总结</h1><ol class=""><li id="bcbf" class="lg lh hi ih b ii kb im kc iq mz iu na iy nb jc lv lm ln lo bi translated">ThreadPool Executor具有CorePoolSize，它控制每个传入请求产生多少个活动线程。</li><li id="ce8b" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc lv lm ln lo bi translated">一旦CorePoolSize线程处于活动状态，新的传入任务将被添加到队列中，这些线程将主动从队列中轮询以执行它们。</li><li id="a4ac" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc lv lm ln lo bi translated">一旦队列变满，可能会创建新的线程(如果maximumPoolSize &gt; CorePoolSize)，以处理更多的负载。</li><li id="8307" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc lv lm ln lo bi translated">创建的新线程将立即启动，要么开始执行给定的任务，要么从队列中提取。</li><li id="9e44" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc lv lm ln lo bi translated">如果由于执行任务时的一些外部错误，任何工作线程出错，那么将创建一个新的工作线程来替换它。</li></ol></div></div>    
</body>
</html>