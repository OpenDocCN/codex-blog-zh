<html>
<head>
<title>Why I prefer Guava’s ImmutableCollection over Java’s unmodifiableCollection?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我更喜欢番石榴的不变集合而不是Java的不变集合？</h1>
<blockquote>原文：<a href="https://medium.com/codex/why-i-prefer-guavas-immutablecollection-over-java-s-unmodifiablecollection-d9f546122402?source=collection_archive---------6-----------------------#2021-07-13">https://medium.com/codex/why-i-prefer-guavas-immutablecollection-over-java-s-unmodifiablecollection-d9f546122402?source=collection_archive---------6-----------------------#2021-07-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ih ii ij ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es ig"><img src="../Images/725c444944cc251b0afd6fa5f2f68c97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f07aJZm84ZpA-XX8-4Z5gg.jpeg"/></div></div><figcaption class="ir is et er es it iu bd b be z dx translated">照片由<a class="ae iv" href="https://unsplash.com/@davideragusa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">大卫·拉古萨</a>在<a class="ae iv" href="https://unsplash.com/s/photos/strings?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9005" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">有时，我们会遇到需要在Java中创建不可修改的集合的情况。创建此类集合最流行的方法是</p><ul class=""><li id="f4af" class="ju jv hi iy b iz ja jd je jh jw jl jx jp jy jt jz ka kb kc bi translated">使用Java的内部包装方法(<code class="du kd ke kf kg b">java.util.Collections#unmodifiableX</code>)</li><li id="addb" class="ju jv hi iy b iz kh jd ki jh kj jl kk jp kl jt jz ka kb kc bi translated">使用谷歌的番石榴库(<code class="du kd ke kf kg b">com.google.common.collect.ImmutableX</code>)</li></ul><p id="d86c" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated"><strong class="iy hj"><em class="km"/></strong>大多数时候，番石榴库是我默认的选择，在这篇文章中，我将解释为什么。</p><p id="c5fc" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">原因只有一个——Java的不可修改集合具有误导性，容易出错。如果在没有真正理解它们的行为的情况下使用它们，它们将隐藏错误。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="28d5" class="ku kv hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Java . util . collections #不可修改列表</h1><p id="0994" class="pw-post-body-paragraph iw ix hi iy b iz ls jb jc jd lt jf jg jh lu jj jk jl lv jn jo jp lw jr js jt hb bi translated">让我们看看下面的例子。</p><figure class="lx ly lz ma fd ik"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="7123" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在上面的代码中，我们创建了一个水果列表。然后，我们将水果列表传递给<code class="du kd ke kf kg b">Collections.unmodifiableList()</code>助手方法，该方法返回另一个不可修改的列表。在第10行，我们试图通过添加一个新的水果来修改列表。当我们运行这段代码时，我们得到<code class="du kd ke kf kg b">java.lang.UnsupportedOperationException</code></p><p id="e000" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">不是意料之中的吗？绝对是。这就是误导。这给了我们错误的信心，以为我们得到了一个永远不会改变的不可变列表。</p><p id="bb17" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">让我们稍微修改一下上面的代码。</p><figure class="lx ly lz ma fd ik"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="aa35" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">在这个例子中，我首先获得了一个不可修改的列表，然后修改了原始列表。当我打印<code class="du kd ke kf kg b">unmodifiableFruits</code>列表时，输出是这样的—</p><figure class="lx ly lz ma fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es md"><img src="../Images/c61cad23185b3e46ea9b711b1f82d755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BDrYyRLWz8MphpjtEj6Gng.png"/></div></div></figure><p id="226d" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这不是很奇怪吗？你不是期望列表是不可变的吗？我做到了。</p><p id="3327" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">那么，怎么回事？<code class="du kd ke kf kg b">java.util.Collections#unmodifiableList</code>方法只返回一个包装器，对所有可以修改列表的操作抛出<code class="du kd ke kf kg b">UnsupportedOperationException</code>。但是，它不会创建原始列表的防御性副本。因此，如果您在代码中引用了原始列表，并且如果该列表被意外修改，您将会看到意外的行为，并且很难找到错误的原因。这就是我所说的‘误导’。</p><p id="d4ce" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">来自<code class="du kd ke kf kg b">java.util.Collections</code>类的所有其他<code class="du kd ke kf kg b">unmodifiableX</code>方法也是如此。也许这些方法的目的不是返回不可变的集合，但是，如果不知道它们的行为，在代码中使用它们是非常危险的。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="046e" class="ku kv hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">芭乐永恒的拯救系列</h1><p id="0e30" class="pw-post-body-paragraph iw ix hi iy b iz ls jb jc jd lt jf jg jh lu jj jk jl lv jn jo jp lw jr js jt hb bi translated">让我们修改前面的代码，使用Guava的ImmutableList类来获得一个真正的不可变列表。</p><figure class="lx ly lz ma fd ik"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="1037" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">这里，在第8行，我使用了<code class="du kd ke kf kg b">com.google.common.collect.ImmutableList#copyOf</code>方法从我原来的可变列表中获得一个不可变列表。返回的列表是原始列表的防御性副本。如果原始列表发生任何变化，防御副本不会产生任何影响。此外，像<code class="du kd ke kf kg b">List#add</code>这样的赋值方法会抛出<code class="du kd ke kf kg b">UnsupportedOperationException</code>，因此列表根本无法修改。这是鼓舞人心的。</p><p id="cd28" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">番石榴有像样的文件。这里我会推荐大家看一下<a class="ae iv" href="https://github.com/google/guava/wiki/ImmutableCollectionsExplained" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="37ef" class="ku kv hi bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">一句警告</h1><p id="3242" class="pw-post-body-paragraph iw ix hi iy b iz ls jb jc jd lt jf jg jh lu jj jk jl lv jn jo jp lw jr js jt hb bi translated">你可能已经注意到，我在第一段的大部分时间里都强调了'<strong class="iy hj"><em class="km">'</em></strong>'。你可能会问为什么我不一直使用Guava的不可变集合。这是一个公平的问题。</p><p id="8c1e" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">Guava不可变集合不支持<code class="du kd ke kf kg b">null</code>元素。看起来这是他们有意识的决定。在他们的文件中，他们提到—</p><blockquote class="me mf mg"><p id="488a" class="iw ix km iy b iz ja jb jc jd je jf jg mh ji jj jk mi jm jn jo mj jq jr js jt hb bi translated">每个Guava不可变集合实现<em class="hi">都拒绝空值。</em>我们对谷歌的内部代码库进行了详尽的研究，研究表明<code class="du kd ke kf kg b">null</code>元素在集合中被允许出现的时间约为5%,而其他95%的情况下最好通过在nulls上快速失败来实现。如果需要使用空值，可以考虑在允许空值的集合实现上使用<code class="du kd ke kf kg b">Collections.unmodifiableList</code>和它的朋友。</p></blockquote><p id="b741" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">如果原来的可变列表有<code class="du kd ke kf kg b">null</code>元素，<code class="du kd ke kf kg b">ImmutableList#copyOf</code>会抛出一个<code class="du kd ke kf kg b">NullPointerException</code>。只有当你绝对确定你的收藏没有<code class="du kd ke kf kg b">null</code>元素时，才使用番石榴。</p><p id="eeab" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">此外，创建防御性副本的成本略高。因此，与Java不可修改的集合包装器相比，创建这些不可修改的集合将花费更多的时间。如果您的应用程序是性能关键型的，您可能希望避免使用Guava库。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><p id="dafe" class="pw-post-body-paragraph iw ix hi iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt hb bi translated">感谢阅读。如果你已经走了这么远，希望你已经找到了一些有用的东西。别忘了鼓掌，跟着学。</p></div></div>    
</body>
</html>