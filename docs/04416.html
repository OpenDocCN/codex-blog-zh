<html>
<head>
<title>Introduction To Time Complexity in Programming: Big-O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编程中的时间复杂性介绍:Big-O符号</h1>
<blockquote>原文：<a href="https://medium.com/codex/introduction-to-time-complexity-in-programming-big-o-notation-c44780c65739?source=collection_archive---------7-----------------------#2021-11-29">https://medium.com/codex/introduction-to-time-complexity-in-programming-big-o-notation-c44780c65739?source=collection_archive---------7-----------------------#2021-11-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7eb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我正处于编码面试对我来说有点可怕的阶段。这是招聘过程中我们大多数人都害怕的一个阶段。要度过这一关，需要耗费大量的精力和努力。这就是为什么，在过去的几周里，我一直在练习编写面试代码。我正准备面对一个编码面试，因为我最近一直在申请一个职位空缺。在编码面试中最常谈论的话题之一是Big-O符号。</p><p id="edef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当我们编写和执行代码时，它都必须消耗我们的资源(在这种情况下是时间和空间)。时间是指代码将执行多长时间，而空间是指代码将占用我们多大的内存。这就是大O的由来。它用于测量我们代码的时间和空间复杂度。如果我们能够识别代码的复杂性，那么我们就能够提高它的性能。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h1 id="3025" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">大操作系统</h1><p id="a6a7" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">有一个名为<a class="ae kn" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank"> Big-O Cheat Sheet </a>的网站，在那里我们可以找到不同Big-O符号的列表。它是从最差到最好排列的，你可以参考符号所在区域的颜色。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ko"><img src="../Images/76311d12f2fb60f3603485e23411d34b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eg3bAHoJBaAmV_DNAJKIOQ.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">Big-O复杂度图(来源:【https://www.bigocheatsheet.com/】T2)</figcaption></figure><p id="421c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据上面的这些符号，我们可以在执行代码时使用它们来提高性能。例如，当我们创建一个复杂度为O(n)的函数时，我们可能会想办法让我们的函数以更好的复杂度运行(这些复杂度被标记为一般、良好或优秀)。我们如何改进我们的代码？这就是数据结构和算法派上用场的时候。我们可以使用另一种方法来存储数据，或者我们也可以使用另一种方法来编写解决方案。</p><h1 id="4310" class="jk jl hi bd jm jn le jp jq jr lf jt ju jv lg jx jy jz lh kb kc kd li kf kg kh bi translated">但是首先，我们需要能够确定代码的复杂性</h1><p id="b5ef" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">当我们想要确定代码的复杂性时，有一个规则可以参考。这些是计算我们的Big-O的简单方法，而不是在我们的代码中一行一行地去做。</p><h2 id="4824" class="lj jl hi bd jm lk ll lm jq ln lo lp ju iq lq lr jy iu ls lt kc iy lu lv kg lw bi translated">1.总是最坏的情况</h2><p id="a019" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">你可能会猜测第一条规则是什么意思。这条规则表明，无论何时执行代码，我们都需要考虑可能的最坏情况。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lx"><img src="../Images/a12eb48181bdb685cf3147e8a8c9bf1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQIOaYuRkji_GT1o63WnBw.png"/></div></div></figure><p id="aa95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，当我们使用循环访问数组成员时，我们会陷入O(n)符号。但是，当我们只想找到某个成员，并且该元素是数组的第一个成员时，这意味着我们只运行一次迭代(如果我们在迭代成功找到特定元素时放置break)。</p><p id="a1b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，我们需要考虑这个循环的最坏情况。该项可能是数组的最后一个成员，这意味着我们需要遍历每个成员，直到找到我们需要的项。</p><h2 id="96dd" class="lj jl hi bd jm lk ll lm jq ln lo lp ju iq lq lr jy iu ls lt kc iy lu lv kg lw bi translated">2.移除常数</h2><p id="3494" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">因为我们只关心代码的可伸缩性，所以我们可以很容易地删除Big-O中的常量。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ly"><img src="../Images/5eea5ea8f555ef7b0cce4a87fe80a693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bKRUZGFXydtPyzAB_VrSjw.png"/></div></div></figure><p id="d7b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码片段中，我们有一个从数组中打印项目的函数。然后，它将遍历数组的每个成员，并再循环100次。如果我们逐行计算Big-O，我们将得到O(1 + n + 1000)。</p><p id="f610" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">常量的问题是，无论何时输入或数组大小改变，它们都不会改变。如果我们传递一个10个成员的数组，那么n将由10个成员组成。但是，如果我们传递一个一百万的数组，那么n的值也是一百万。但是，常数会保持不变。</p><h2 id="c0d3" class="lj jl hi bd jm lk ll lm jq ln lo lp ju iq lq lr jy iu ls lt kc iy lu lv kg lw bi translated">3.不同的输入应该有不同的变量</h2><p id="a5d6" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">第三条规则非常简单，我们需要在代码中为不同的输入使用不同的变量。所以，如果你有一个有两个输入的方法，比如输入1和输入2。然后，该方法将逐个遍历input1成员，并对input2执行同样的操作。这个案子的关键是什么？</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lz"><img src="../Images/f690783afa1cb6fc1aea35676ba7a6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESUtP0M_ipmWsNHitv8p_A.png"/></div></div></figure><p id="2723" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，如果你遵循我们的规则，那么你可能已经猜到在我们的大O中有两个不同的变量，它是O(a + b)。这与O(n)基本相同，但是O(n)意味着我们有一个输入。在这种情况下，我们有两个输入，这两个输入可能有不同的成员数，所以我们需要为Big-O指定两个不同的变量。</p><h2 id="8cc2" class="lj jl hi bd jm lk ll lm jq ln lo lp ju iq lq lr jy iu ls lt kc iy lu lv kg lw bi translated">4.删除非主导术语</h2><p id="eb4d" class="pw-post-body-paragraph if ig hi ih b ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc hb bi translated">最后，我们来到了最后一条规则。让我们看一下下面的例子，因为如果我们看一个例子会更容易理解。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es ma"><img src="../Images/e73fa333fd795c1dbdff6065fec37f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tNAgP6eC1VVAPgkDQ3qtEA.png"/></div></div></figure><p id="b56a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码片段复杂度为O(n + n)。因为规则说要去掉非支配项，这意味着我们需要去掉n，只留下n，所以它是O(n)。为什么？因为，使用Big-O，我们关心代码的可伸缩性。一旦将来我们的投入越来越大，n将消耗更多的资源。我们想把重点放在最糟糕的部分，这就是为什么我们只为我们的Big-O选择主导术语。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="b9c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已！我们已经讨论了为什么我们需要理解时间复杂性，不同的Big-O符号，以及确定Big-O的规则。这是我最近的在线课程<a class="ae kn" href="https://www.udemy.com/course/master-the-coding-interview-data-structures-algorithms/" rel="noopener ugc nofollow" target="_blank">Master the Coding Interview:Data Structures+Algorithms</a>的摘要，来自Andrei Neagoie(我建议你购买并观看课程，Andrei比我更好地解释了这个概念)。该课程还解释了一些我在本文中还没有涉及到的概念。</p><p id="c140" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我知道这篇文章只涉及了Big-O的基础知识，我计划再写一篇文章来更深入地探讨这个概念。也许我会解释一下我们从上面的图表中看到的每个大操作系统。</p></div></div>    
</body>
</html>