<html>
<head>
<title>Add header to every request in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向Go中的每个请求添加标题</h1>
<blockquote>原文：<a href="https://medium.com/codex/add-header-to-every-request-in-go-de3d2e4dc960?source=collection_archive---------7-----------------------#2020-09-08">https://medium.com/codex/add-header-to-every-request-in-go-de3d2e4dc960?source=collection_archive---------7-----------------------#2020-09-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d01575e7cd90e61ecb20e43f1e53e25e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B8yWSl6a8fsWSANoe5ifYg.jpeg"/></div></div></figure><p id="29cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对所有HTTP请求进行更改会很方便。你可能想添加一个API密钥或一些关于发送者的信息，如应用程序版本等。不管你为什么想这么做，你都有几个选择来实现目标。</p><p id="3622" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一种方法是构建一个工厂方法来添加所需的头。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="2694" class="jx jy hi jt b fi jz ka l kb kc">func newRequest(endpoint string) *http.Request {<br/>    req, _ := http.NewRequest(http.MethodGet, fmt.Sprintf("https://%s", endpoint), nil)<br/>    req.Header.Add("x-api-key", "my-secret-token")<br/>    return req<br/>}</span></pre><p id="a11e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这非常简单明了，但是它要求你为每个HTTP方法创建一个新方法，或者直接调用另一个函数。每次创建新请求时，您都必须这样做。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="a7e1" class="jx jy hi jt b fi jz ka l kb kc">func addHeaders(r *http.Request) {<br/>	req.Header.Add("x-api-key", "my-secret-token")<br/>}<br/><br/>// somewhere in your code<br/><br/>req, err := http.NewRequest(/* ... */)<br/>if err != nil {<br/>	return nil<br/>}<br/><br/>addHeaders(req)<br/><br/>// do your job here</span></pre><p id="4cf3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种方法很简单，但是需要在所有容易出错的模块中反复重复相同的代码。使用<a class="ae kd" href="https://godoc.org/net/http#RoundTripper" rel="noopener ugc nofollow" target="_blank">往返器</a>可以更容易地获得类似的结果。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="2426" class="jx jy hi jt b fi jz ka l kb kc">type transport struct {<br/>	underlyingTransport http.RoundTripper<br/>}<br/><br/>func (t *transport) RoundTrip(req *http.Request) (*http.Response, error) {<br/>	req.Header.Add("x-api-key", "my-secret-token")<br/>	return t.underlyingTransport.RoundTrip(req)<br/>}</span></pre><p id="c3c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在创建HTTP客户端时</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="f23c" class="jx jy hi jt b fi jz ka l kb kc">c := http.Client{Transport: &amp;transport{ underlyingTransport: http.DefaultTransport } }</span></pre><p id="8801" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这看起来优雅，清晰，简单。然而，在文件中有一个注释</p><blockquote class="ke kf kg"><p id="f07a" class="iq ir kh is b it iu iv iw ix iy iz ja ki jc jd je kj jg jh ji kk jk jl jm jn hb bi translated">除了消费和关闭请求体之外，往返不应修改请求。</p></blockquote><p id="2b95" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着我们<strong class="is hj">不应该</strong>以我们的方式改变请求。往返通常用于速率限制或缓存响应，这是更有效的用法。有没有其他方法可以做到这一点？当然——使用Go接口的强大功能。</p><p id="d11b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你应该做的是用你使用的所有方法为<code class="du kl km kn jt b">http.Client</code>写一个包装器/中间件，并在那里添加你的头文件。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="53d2" class="jx jy hi jt b fi jz ka l kb kc">type httpClient struct {<br/>	c        http.Client<br/>	apiToken string<br/>}<br/><br/>func (c *httpClient) Get(url string) (resp *Response, err error) {<br/>	req, err := http.NewRequest("GET", url, nil)<br/>	if err != nil {<br/>		return nil, err<br/><br/>	}<br/><br/>	return c.Do(req)<br/><br/>}<br/><br/>func (c *Client) Post(url, contentType string, body io.Reader) (resp *Response, err error) {<br/>	req, err := http.NewRequest("POST", url, body)<br/>	if err != nil {<br/>		return nil, err<br/><br/>	}<br/><br/>	req.Header.Set("Content-Type", contentType)<br/><br/>	return c.Do(req)<br/><br/>}<br/><br/>func (c *httpClient) Do(req *Request) (*Response, error) {<br/>	req.Header.Add("x-api-key", c.apiToken)<br/>	return c.c.Do(req)<br/><br/>}</span></pre><p id="ccc7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你所看到的，它需要更多的代码，但另一方面，它给了你更多的灵活性，让你知道我们在请求中改变了什么。</p><h1 id="8cf9" class="ko jy hi bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">摘要</h1><p id="314a" class="pw-post-body-paragraph iq ir hi is b it ll iv iw ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn hb bi translated">有几种方法可以达到相同或相似的效果。你应该选择哪一个？这取决于您的用例。总是试图找到最简单和可读性更强的方法。如果工厂方法对你来说很好，不要让你的代码过于复杂。当你的工厂方法变得越来越复杂时，考虑将它重构为更小的方法或者直接使用包装器。</p><p id="9e2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae kd" href="https://www.buymeacoffee.com/bklimczak" rel="noopener ugc nofollow" target="_blank">给我买杯咖啡</a></p></div><div class="ab cl lq lr gp ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="hb hc hd he hf"><p id="e4c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kh">最初发表于</em><a class="ae kd" href="https://developer20.com/add-header-to-every-request-in-go/" rel="noopener ugc nofollow" target="_blank"><em class="kh">https://developer20.com</em></a><em class="kh">。</em></p></div></div>    
</body>
</html>