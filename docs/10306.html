<html>
<head>
<title>Mathematics (Linear Algebra)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数学(线性代数)</h1>
<blockquote>原文：<a href="https://medium.com/codex/mathematics-linear-algebra-7b431be2c2d4?source=collection_archive---------7-----------------------#2022-12-20">https://medium.com/codex/mathematics-linear-algebra-7b431be2c2d4?source=collection_archive---------7-----------------------#2022-12-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="c927" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">线性代数</h1><ul class=""><li id="adff" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">线性代数是数学的一个分支，研究<a class="ae jv" href="https://en.wikipedia.org/wiki/Vector_space" rel="noopener ugc nofollow" target="_blank">向量空间</a>和向量空间之间的线性变换，比如旋转一个形状，放大或缩小，平移(即移动)等。</li><li id="b822" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">机器学习在很大程度上依赖于线性代数，因此理解什么是向量和矩阵，可以用它们执行什么操作，以及它们如何有用是至关重要的。</li></ul><h1 id="f1c1" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">向量</h1><h2 id="da47" class="kb ig hi bd ih kc kd ke il kf kg kh ip jk ki kj it jm kk kl ix jo km kn jb ko bi translated">定义</h2><ul class=""><li id="8c57" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">矢量是由大小和方向定义的量。例如，火箭的速度是一个三维向量:它的大小是火箭的速度，方向是向上的。一个向量可以用一个叫做<em class="kp">标量</em>的数组来表示。每个标量对应于向量在每个维度上的大小。</li><li id="a2dd" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">例如，假设火箭以微小的角度上升:它的垂直速度为5000米/秒，向东的速度为10米/秒，向北的速度为50米/秒。火箭的速度可由以下矢量表示:</li></ul><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es kq"><img src="../Images/5fe559ffa03dce6efd29eb878052db65.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*_-hPHOu__ekngxC1tddHGQ.png"/></div></figure><ul class=""><li id="6c1d" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">注意:按照惯例，向量通常以列的形式出现。此外，向量名通常是小写的，以区别于矩阵(我们将在下面讨论),并且是粗体的(如果可能),以区别于简单的标量值，例如米每秒=5026米每秒= 5026。</li><li id="65d5" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">一列NN数也可能表示一个点在NN维空间中的坐标，所以把向量表示为简单的点而不是箭头是相当频繁的。有1个元素的向量可能表示为轴上的箭头或点，有2个元素的向量表示为平面上的箭头或点，有3个元素的向量表示为空间中的箭头或点，有NN个元素的向量表示为NN维空间中的箭头或点……这是大多数人难以想象的。</li></ul><h2 id="27a6" class="kb ig hi bd ih kc kd ke il kf kg kh ip jk ki kj it jm kk kl ix jo km kn jb ko bi translated">目的</h2><ul class=""><li id="05f3" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">向量在机器学习中有许多用途，最显著的是用来表示观察和预测。例如，假设我们建立了一个机器学习系统，根据我们对视频的了解将视频分为3类(好的、垃圾的、点击诱饵的)。对于每个视频，我们将有一个向量来表示我们对它的了解，例如:</li></ul><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es ld"><img src="../Images/98acbd26439bc1108ea9903a006320f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*QnsXK4Q6KNE_4gATzgyjXA.png"/></div></figure><ul class=""><li id="5d74" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">这个向量可以表示一个持续10.5分钟的视频，但是只有5.2%的观众观看超过一分钟，它平均每天获得3.25次观看，并且它被标记为垃圾邮件7次。如您所见，每个轴可能有不同的含义。</li><li id="0938" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">基于这个向量，我们的机器学习系统可以预测它有80%的概率是垃圾视频，18%的概率是点击诱饵，2%的概率是好视频。这可以表示为以下向量:</li></ul><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es le"><img src="../Images/dbad2dcb347e4053c43d2423b5438188.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*KZLC7wcz_BeHCgBW-v7W6g.png"/></div></figure><h1 id="d653" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">Python中的向量</h1><ul class=""><li id="9016" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">在python中，向量可以用多种方式表示，最简单的是一个常规的python数字列表:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="c3dc" class="lk ig hi lg b be ll lm l ln lo">[10.5, 5.2, 3.25, 7.0]</span></pre><ul class=""><li id="5542" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">因为我们计划进行大量的科学计算，所以使用NumPy的<code class="du lp lq lr lg b">ndarray</code>会好得多，它提供了许多对向量的基本数学运算的方便和优化的实现，例如:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="cac6" class="lk ig hi lg b be ll lm l ln lo">import numpy as np<br/>video = np.array([10.5, 5.2, 3.25, 7.0])<br/>video</span></pre><ul class=""><li id="33db" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">向量的大小可以使用<code class="du lp lq lr lg b">size</code>属性获得:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="8ddd" class="lk ig hi lg b be ll lm l ln lo">video.size</span></pre><ul class=""><li id="00fb" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">向量v的第I个元素(也称为<em class="kp">条目</em>或<em class="kp">条目</em>)记为vi</li><li id="a032" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">请注意，数学中的索引一般从1开始，但编程中的索引通常从0开始。因此，要以编程方式访问video3，我们应该编写:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="8837" class="lk ig hi lg b be ll lm l ln lo">video[2] ## 3rd element</span></pre><h1 id="9f54" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">绘制向量</h1><ul class=""><li id="9b3a" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">为了绘制向量，我们将使用matplotlib，所以让我们从导入它开始(关于Matplotlib的详细信息，请查看我们的<a class="ae jv" href="https://aman.ai/primers/matplotlib" rel="noopener ugc nofollow" target="_blank"> Matplotlib教程</a>):</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="3085" class="lk ig hi lg b be ll lm l ln lo">import matplotlib.pyplot as plt</span></pre><ul class=""><li id="39c8" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">在Jupyter/Colab笔记本中，我们可以通过运行<code class="du lp lq lr lg b">%matplotlib inline</code>魔术命令简单地输出笔记本中的图形。</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="1ebf" class="lk ig hi lg b be ll lm l ln lo">%matplotlib inline</span></pre><h1 id="c784" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">2D向量</h1><ul class=""><li id="2358" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">现在，为数组容器导入NumPy来处理我们要绘制的输入数据:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="bfa8" class="lk ig hi lg b be ll lm l ln lo">import numpy as np</span></pre><ul class=""><li id="fd6a" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">让我们创建几个非常简单的2D向量来绘制:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="fabe" class="lk ig hi lg b be ll lm l ln lo">u = np.array([2, 5])<br/>v = np.array([3, 1])</span></pre><ul class=""><li id="af1e" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">这些向量每个都有两个元素，因此可以很容易地在2D图上用图形表示，例如用点表示:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="8d3c" class="lk ig hi lg b be ll lm l ln lo">x_coords, y_coords = zip(u, v)<br/>plt.scatter(x_coords, y_coords, color=["r","b"])<br/>plt.axis([0, 9, 0, 6])<br/>plt.grid()<br/>plt.show()</span></pre><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ls"><img src="../Images/bf11fb36181303b56234e4b11349a67a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G2bK6_7w4qxlG4kp.jpg"/></div></div></figure><h1 id="a2d8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">三维矢量</h1><ul class=""><li id="ce82" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">绘制3D矢量也相对简单。首先让我们创建两个3D向量:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="1a6c" class="lk ig hi lg b be ll lm l ln lo">import numpy as np</span></pre><pre class="lx lf lg ly lz aw ma bi"><span id="7f7c" class="kb ig hi lg b fi mb mc l md lo">a = np.array([1, 2, 8])<br/>b = np.array([5, 6, 3])</span></pre><ul class=""><li id="47ca" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">现在让我们使用matplotlib的<code class="du lp lq lr lg b">Axes3D</code>来绘制它们。注意，我们将使用<code class="du lp lq lr lg b">mpl_toolkits</code>来执行这一步(并且<code class="du lp lq lr lg b">matplotlib</code>在安装过程中不会加载<code class="du lp lq lr lg b">mpl_toolkits</code>作为依赖项)，所以让我们首先使用<code class="du lp lq lr lg b">pip install --upgrade matplotlib</code>来加载它(如果您在Jupyter笔记本中运行这一步，请使用<code class="du lp lq lr lg b">!pip install --upgrade matplotlib</code>)。</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="100a" class="lk ig hi lg b be ll lm l ln lo">import matplotlib.pyplot as plt<br/>from mpl_toolkits.mplot3d import Axes3D</span></pre><pre class="lx lf lg ly lz aw ma bi"><span id="8280" class="kb ig hi lg b fi mb mc l md lo">subplot3d = plt.subplot(111, projection='3d')<br/>x_coords, y_coords, z_coords = zip(a,b)<br/>subplot3d.scatter(x_coords, y_coords, z_coords)<br/>subplot3d.set_zlim3d([0, 9])<br/>plt.show</span></pre><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es me"><img src="../Images/353fc73ce60f4f7e7cacba540552027e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yRS-A47wVuHxwqjq.jpg"/></div></div></figure><ul class=""><li id="023d" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">很难想象这两个点在空间中的确切位置，所以让我们添加垂直线。我们将创建一个方便的小函数来绘制一个附有垂直线的3D向量列表:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="25f2" class="lk ig hi lg b be ll lm l ln lo">def plot_vectors3d(ax, vectors3d, z0, **options):<br/>    for v in vectors3d:<br/>        x, y, z = v<br/>        ax.plot([x,x], [y,y], [z0, z], color="gray", linestyle='dotted', marker=".")<br/>    x_coords, y_coords, z_coords = zip(*vectors3d)<br/>    ax.scatter(x_coords, y_coords, z_coords, **options)</span></pre><pre class="lx lf lg ly lz aw ma bi"><span id="208a" class="kb ig hi lg b fi mb mc l md lo">subplot3d = plt.subplot(111, projection='3d')<br/>subplot3d.set_zlim([0, 9])<br/>plot_vectors3d(subplot3d, [a,b], 0, color=("r","b"))<br/>plt.show()</span></pre><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mf"><img src="../Images/0b048ae303de5ddbf7b87901813a9ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xdH6GeTkreTvxWE0.jpg"/></div></div></figure><h1 id="f63f" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">标准</h1><ul class=""><li id="6112" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">∣∣u∣∣指出，向量u的范数是u的长度的度量。有多种可能的范数，但最常见的是欧几里德范数，其定义为:</li></ul><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es mg"><img src="../Images/c0eb4d53c46a0e4b3c7c279fd5137e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*X-FjpwwwYXROEjQa2cTyEg.png"/></div></figure><ul class=""><li id="845f" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">回想一下，我们可以用纯python轻松实现这一点</li></ul><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es mh"><img src="../Images/3fae09050bb04f0fb4f139ad8cebc082.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*Urnh4t9uCc5JxUnwiXCRqQ.png"/></div></figure><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="72c1" class="lk ig hi lg b be ll lm l ln lo">def vector_norm(vector):<br/>    squares = [element**2 for element in vector]<br/>    return sum(squares)**0.5</span></pre><pre class="lx lf lg ly lz aw ma bi"><span id="5abd" class="kb ig hi lg b fi mb mc l md lo">u = np.array([2, 5])<br/>print("||", u, "|| =")<br/>vector_norm(u) # Prints 5.385164807134504</span></pre><ul class=""><li id="788f" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">然而，使用NumPy的<code class="du lp lq lr lg b">norm</code>函数更有效，该函数在<code class="du lp lq lr lg b">linalg</code>(<strong class="jf hj">Lin</strong>ear<strong class="jf hj">Alg</strong>ebra)模块中可用:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="457e" class="lk ig hi lg b be ll lm l ln lo">import numpy.linalg as LA<br/>LA.norm(u) # Prints 5.385164807134504</span></pre><ul class=""><li id="40ec" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">让我们画一个小图来证实向量v的长度确实是≈5.4:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="f9e3" class="lk ig hi lg b be ll lm l ln lo">radius = LA.norm(u)<br/>plt.gca().add_artist(plt.Circle((0,0), radius, color="#DDDDDD"))</span></pre><pre class="lx lf lg ly lz aw ma bi"><span id="ac6c" class="kb ig hi lg b fi mb mc l md lo">def plot_vector2d(vector2d, origin=[0, 0], **options):<br/>    return plt.arrow(origin[0], origin[1], vector2d[0], vector2d[1], head_width=0.2, <br/>           head_length=0.3, length_includes_head=True, **options)</span><span id="9104" class="kb ig hi lg b fi mi mc l md lo">plot_vector2d(u, color="red")<br/>plt.axis([0, 8.7, 0, 6])<br/>plt.grid()<br/>plt.show()</span></pre><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mj"><img src="../Images/12886351e7d936be658acd1854ca55ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bGFoK4yhI_J6o7ah.jpg"/></div></div></figure><ul class=""><li id="c902" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">看起来差不多吧！</li></ul><h1 id="5120" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">添加</h1><ul class=""><li id="13cc" class="jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">相同大小的向量可以加在一起。逐元素执行添加<em class="kp"/>:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="78c4" class="lk ig hi lg b be ll lm l ln lo">import numpy as np</span></pre><pre class="lx lf lg ly lz aw ma bi"><span id="79b6" class="kb ig hi lg b fi mb mc l md lo">u = np.array([2, 5])<br/>v = np.array([3, 1])</span><span id="4476" class="kb ig hi lg b fi mi mc l md lo">print(" ", u)<br/>print("+", v)<br/>print("-"*10)<br/>u +</span></pre><ul class=""><li id="6413" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">哪些输出:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="e5d5" class="lk ig hi lg b be ll lm l ln lo">[2 5]<br/>+ [3 1]<br/>----------<br/>array([5, 6]</span></pre><ul class=""><li id="0a8a" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">让我们看看矢量加法是什么样的图形:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="1559" class="lk ig hi lg b be ll lm l ln lo">plot_vector2d(u, color="r")<br/>plot_vector2d(v, color="b")<br/>plot_vector2d(v, origin=u, color="b", linestyle="dotted")<br/>plot_vector2d(u, origin=v, color="r", linestyle="dotted")<br/>plot_vector2d(u+v, color="g")<br/>plt.axis([0, 9, 0, 7])<br/>plt.text(0.7, 3, "u", color="r", fontsize=18)<br/>plt.text(4, 3, "u", color="r", fontsize=18)<br/>plt.text(1.8, 0.2, "v", color="b", fontsize=18)<br/>plt.text(3.1, 5.6, "v", color="b", fontsize=18)<br/>plt.text(2.4, 2.5, "u+v", color="g", fontsize=18)<br/>plt.grid()<br/>plt.show()</span></pre><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es mk"><img src="../Images/10ffa08e7c02cdba8ffad2fac365863d.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/0*azl59BMJ0g6n5IP4.png"/></div></figure><ul class=""><li id="16af" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">向量加法是<strong class="jf hj">可换的</strong>，意思是u+v=v+u，你可以在上一张图中看到:跟随uu <em class="kp">然后</em> vv导致的点与跟随vv <em class="kp">然后</em> uu的点相同。</li><li id="fbb3" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">向量加法也是<strong class="jf hj">联想</strong>，意思是u+(v+w)=(u+v)+w</li><li id="c6fe" class="jd je hi jf b jg jw ji jx jk jy jm jz jo ka jq jr js jt ju bi translated">如果你有一个由多个点(向量)定义的形状，你在所有这些点上加上一个向量v，那么整个形状就会移动v，这叫做几何平移:</li></ul><pre class="kr ks kt ku fd lf lg lh bn li lj bi"><span id="0891" class="lk ig hi lg b be ll lm l ln lo">t1 = np.array([2, 0.25])<br/>t2 = np.array([2.5, 3.5])<br/>t3 = np.array([1, 2])</span></pre><pre class="lx lf lg ly lz aw ma bi"><span id="08b9" class="kb ig hi lg b fi mb mc l md lo">x_coords, y_coords = zip(t1, t2, t3, t1)<br/>plt.plot(x_coords, y_coords, "c--", x_coords, y_coords, "co")</span><span id="f683" class="kb ig hi lg b fi mi mc l md lo">plot_vector2d(v, t1, color="r", linestyle=":")<br/>plot_vector2d(v, t2, color="r", linestyle=":")<br/>plot_vector2d(v, t3, color="r", linestyle=":")</span><span id="83c9" class="kb ig hi lg b fi mi mc l md lo">t1b = t1 + v<br/>t2b = t2 + v<br/>t3b = t3 + v</span><span id="4e48" class="kb ig hi lg b fi mi mc l md lo">x_coords_b, y_coords_b = zip(t1b, t2b, t3b, t1b)<br/>plt.plot(x_coords_b, y_coords_b, "b-", x_coords_b, y_coords_b, "bo")</span><span id="e634" class="kb ig hi lg b fi mi mc l md lo">plt.text(4, 4.2, "v", color="r", fontsize=18)<br/>plt.text(3, 2.3, "v", color="r", fontsize=18)<br/>plt.text(3.5, 0.4, "v", color="r", fontsize=18)</span><span id="a8ec" class="kb ig hi lg b fi mi mc l md lo">plt.axis([0, 6, 0, 5])<br/>plt.grid()<br/>plt.show()</span></pre><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es mk"><img src="../Images/f94e134330246c410f4d9b89936f8dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/0*HAVswoeRkOVAUrdZ.png"/></div></figure><ul class=""><li id="be16" class="jd je hi jf b jg ky ji kz jk la jm lb jo lc jq jr js jt ju bi translated">最后，减去一个向量就像加上相反的向量。</li></ul></div></div>    
</body>
</html>