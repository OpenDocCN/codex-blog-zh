<html>
<head>
<title>Why You Should Learn Functional Programming: Type Classes vs. Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该学习函数式编程:类型类与接口</h1>
<blockquote>原文：<a href="https://medium.com/codex/why-you-should-learn-functional-programming-type-classes-vs-interfaces-9d2192d20ac2?source=collection_archive---------1-----------------------#2021-05-11">https://medium.com/codex/why-you-should-learn-functional-programming-type-classes-vs-interfaces-9d2192d20ac2?source=collection_archive---------1-----------------------#2021-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e5e5360fd51cab4e67a243dd046fb1b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*43gdztymzG_n7Tep75SIzA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来自<a class="ae iu" href="https://pixabay.com/ru/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=6004000" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae iu" href="https://pixabay.com/ru/users/flutie8211-17475707/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=6004000" rel="noopener ugc nofollow" target="_blank">维基·汉密尔顿</a></figcaption></figure><p id="6f5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇文章中，我将描述一个很酷的函数式编程概念<strong class="ix hj">，类型类</strong>，以Haskell编程语言为例。我将首先提供一些Java示例，并介绍Java语言及其面向对象范例的局限性。然后，我将描述在进入函数式编程世界时，这些限制是如何被解除的。</p><p id="c242" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文主要面向Java开发人员，但是任何面向对象语言的知识都可以。在阅读本文之前，您不需要有任何Haskell方面的经验。然而，如果你在读完这篇文章后对这种奇妙的语言或者函数式编程感兴趣，我会很高兴。这可能会帮助你对你错过的东西有一个更全面的了解，并且更好地理解不同编程语言中的类型是如何工作的。</p><h1 id="010c" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Java中的接口及其局限性</h1><p id="93aa" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">接口是Java中无处不在的概念。您定义一组函数签名，然后在特定的类定义中实现它们:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="89c3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是如果你想要一个更抽象的界面呢？例如，有许多类型具有以下三个属性，这些属性需要提取到接口中:</p><p id="832b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，<strong class="ix hj">某些类型的值可以追加得到另一个相同类型的值</strong>:</p><ul class=""><li id="53ca" class="lc ld hi ix b iy iz jc jd jg le jk lf jo lg js lh li lj lk bi translated">两个字符串可以连接起来得到一个新的字符串；</li><li id="e58a" class="lc ld hi ix b iy ll jc lm jg ln jk lo jo lp js lh li lj lk bi translated">两个整数可以相加得到一个新的整数值；</li><li id="96f8" class="lc ld hi ix b iy ll jc lm jg ln jk lo jo lp js lh li lj lk bi translated">两个lambda函数可以使用<code class="du lq lr ls lt b">Function.compose()</code>来组合，这给了我们另一个函数——两者的组合。</li></ul><p id="7517" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二，<strong class="ix hj">所有这些操作都是关联的</strong>:如果你连续组合了两个以上的值，你可以用括号改变组合的顺序，这不会影响结果:</p><ul class=""><li id="6f07" class="lc ld hi ix b iy iz jc jd jg le jk lf jo lg js lh li lj lk bi translated"><code class="du lq lr ls lt b">1 + (2 + 3)</code>与<code class="du lq lr ls lt b">(1 + 2) + 3</code>相同——都等于<code class="du lq lr ls lt b">6</code>；</li><li id="9f30" class="lc ld hi ix b iy ll jc lm jg ln jk lo jo lp js lh li lj lk bi translated"><code class="du lq lr ls lt b">("hello" + " beautiful ") + "world"</code>与<code class="du lq lr ls lt b">"hello" + (" beautiful " + "world")</code>相同——都等于<code class="du lq lr ls lt b">"hello beautiful world"</code></li><li id="42c4" class="lc ld hi ix b iy ll jc lm jg ln jk lo jo lp js lh li lj lk bi translated"><code class="du lq lr ls lt b">fun1.compose(fun2.compose(fun3))</code>与<code class="du lq lr ls lt b">fun1.compose(fun2).compose(fun3)</code>相同——这只是连续应用于彼此输出的三个函数。</li></ul><p id="20e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第三，<strong class="ix hj">有一个特殊的价值，当它与另一个价值结合时，不会改变它。</strong>姑且称之为“空”值<strong class="ix hj"> : </strong></p><ul class=""><li id="33ee" class="lc ld hi ix b iy iz jc jd jg le jk lf jo lg js lh li lj lk bi translated"><code class="du lq lr ls lt b">0 + 1</code>和<code class="du lq lr ls lt b">1 + 0</code>一样只是<code class="du lq lr ls lt b">1</code>；</li><li id="7281" class="lc ld hi ix b iy ll jc lm jg ln jk lo jo lp js lh li lj lk bi translated"><code class="du lq lr ls lt b">"" + "hello"</code>和<code class="du lq lr ls lt b">"hello" + ""</code>一样只是<code class="du lq lr ls lt b">"hello"</code>；</li><li id="8a9b" class="lc ld hi ix b iy ll jc lm jg ln jk lo jo lp js lh li lj lk bi translated"><code class="du lq lr ls lt b">fun1.compose(Function.identity())</code>和<code class="du lq lr ls lt b">Function.identity().compose(fun1)</code>一样，只是<code class="du lq lr ls lt b">fun1</code>。</li></ul><p id="b103" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们看到了很多共同点，那么我们能让所有这些类型都实现某种接口吗？在代数中，<strong class="ix hj">一个具有二元运算和一个具有上述性质的特殊值的集合被称为“幺半群”</strong>，那么我们为什么不为所有这些类型声明一个<code class="du lq lr ls lt b">Monoid</code>接口呢:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="371a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lq lr ls lt b">empty()</code>方法返回特殊的“空”元素，而<code class="du lq lr ls lt b">append()</code>方法将这个值与另一个值组合起来，并返回一个新的组合值。如果我们可以在标准库中改变它的定义，下面是<code class="du lq lr ls lt b">String</code>类型的实现:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="c577" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">整洁！现在，我们可以编写通用代码，可以与任何幺半群一起工作，不管它们的真实类型是什么。例如，我们可以编写一个方法，使用<code class="du lq lr ls lt b">Stream.reduce()</code>将多个相同类型的幺半群值追加到一个中:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="f8f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，reduce方法的这个变体使用第一个列表元素作为初始值，然后使用<code class="du lq lr ls lt b">append</code>将所有其他值附加到它上面。这就是为什么该方法返回<code class="du lq lr ls lt b">Optional&lt;T&gt;</code>——当列表为空(我们没有任何值用作初始值)时，这是必需的，所以在这种情况下，该方法将返回<code class="du lq lr ls lt b">Optional.empty()</code>。</p><p id="b348" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用<code class="du lq lr ls lt b">empty()</code>值作为初始值，也可以覆盖列表为空的情况，但是我们不能调用<code class="du lq lr ls lt b">empty()</code>方法，因为它是一个实例方法，如果列表为空，那么我们没有任何实例可以调用它。</p><p id="4607" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于一列<code class="du lq lr ls lt b">Integer</code>值，这个方法会将它们相加。对于字符串，它会将一系列字符串串联起来。对于函数，它会将一组函数组合成一个大函数。看起来<strong class="ix hj">我们可以写一段简单的通用代码，对很多不同的情况都有用</strong>。然而…</p><h1 id="325e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">为什么这在Java中不起作用</h1><p id="8713" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">首先，您不能将接口的实现添加到一些现有的类型中。在撰写本文的时候(Java 17就在眼前)<strong class="ix hj">您只能在类型定义中指定实现的接口</strong>，这让我们不得不等待Java 18、19、20……或者永远等待。</p><p id="23c3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二，更概念性的问题:<strong class="ix hj">有不同的方式来表示同一个幺半群</strong>。这里至少有两种处理整数的方法，一种是加法，我们已经讨论过了:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="e698" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是另一个乘法，也有同样的性质:乘法是结合的，有一个“空”元素(即1)在乘法后不会改变另一个值:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="1974" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们完全不走运了。我们不仅不能为现有类型添加一个接口，而且不能为同一类型添加一个以上的接口实现。Java就是不允许。我们不得不求助于委托(或包装)模式，这在Java中通常很难看。</p><h1 id="c5ed" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">在Haskell中如何使用类型类</h1><p id="1578" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Haskell是一种函数式语言，不是面向对象的。您可以定义您的数据类型，但是如果您将它们与Java类进行比较，它们更像是记录——它们只有数据(字段)而没有功能(方法)。下面是我们如何使用Haskell的记录语法定义一个包含三个字段的类型——姓名、姓氏(字符串)和年龄(整数值)。</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="c4a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是如果类型不包含任何逻辑，我们如何抽象不同的类型来处理它们呢？我们定义类型类。类型类是一组函数签名，看起来非常类似于Java中的接口。</p><p id="1e38" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看如何使用type类语法在Haskell中定义我们的<code class="du lq lr ls lt b">Monoid</code>接口(来自Haskell库的实际定义稍微复杂一点，但想法是相同的):</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="6c6d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Haskell中的<code class="du lq lr ls lt b">class</code>关键字不像Java那样定义一个新类——在这里，它定义了一个新的类型类。暂时把它当做一个接口。</p><p id="adb1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的定义中，我们使用<code class="du lq lr ls lt b">class</code>关键字来定义一个带有一个类型变量m的类型类(这就是你在Java中写的<code class="du lq lr ls lt b">&lt;T&gt;</code>)。它定义了两个函数:<code class="du lq lr ls lt b">mempty</code>，返回类型参数<code class="du lq lr ls lt b">m</code>的值；以及<code class="du lq lr ls lt b">mconcat</code>，接受类型<code class="du lq lr ls lt b">m</code>的两个值，并产生第三个相同类型的值<code class="du lq lr ls lt b">m</code>。</p><p id="a7a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个字符串<code class="du lq lr ls lt b">m -&gt; m -&gt; m</code>可能看起来很奇怪，但它只是由<code class="du lq lr ls lt b">-&gt;</code>连接的一系列类型变量，这是Haskell的函数类型签名语法——字符串中的最后一个类型总是返回类型，其他都是函数参数。它看起来像是有原因的，但我们不会在这里深入这个话题。</p><p id="2dd5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很容易看出这个类型类如何对应于我们上面定义的Java接口，其中<code class="du lq lr ls lt b">mempty</code>对应于<code class="du lq lr ls lt b">empty</code>而<code class="du lq lr ls lt b">mappend</code>对应于<code class="du lq lr ls lt b">append</code>:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="5355" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Java中，我们说<strong class="ix hj">一个类实现了一个接口。在Haskell中，我们说<strong class="ix hj">对于这个类型</strong>有一个类型类的实例。一个重要的区别是我们可以在类型已经被定义之后定义一个类型类的实例。</strong></p><p id="bf53" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么，类型类如何解决接口的第二个问题——一个类型只能有一个接口实现？让我们以整数的加法和乘法为例，在这里你可以有两个不同的<code class="du lq lr ls lt b">Monoid</code>接口的实现，但是在Java中你不能轻易做到这一点。为了了解Haskell是如何做到的，让我们看看类型<code class="du lq lr ls lt b">Sum</code>和<code class="du lq lr ls lt b">Product</code>的定义:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="0103" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以看到我们在这里使用了不同的关键字来定义一个类型— <code class="du lq lr ls lt b">newtype</code>。您可以将它视为现有类型的轻量级包装器——一旦它在编译时进行了类型检查，就会在运行时使用原始类型。<code class="du lq lr ls lt b">Sum</code>类型有一个返回包装值的属性<code class="du lq lr ls lt b">getSum</code>。<code class="du lq lr ls lt b">Product</code>也是如此。</p><p id="3ad9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以简单地将整数值包装成这些类型:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="ad3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是这些包装纸有什么特别的吗？<strong class="ix hj">它们都有一个</strong> <code class="du lq lr ls lt b"><strong class="ix hj">Monoid</strong></code> <strong class="ix hj">类型的类实例为它们定义，根据乘法和加法的属性。</strong></p><p id="8585" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里是<code class="du lq lr ls lt b">Product</code>包装器的<code class="du lq lr ls lt b">Monoid</code>类型类定义的简化版本。本质上，我们说<code class="du lq lr ls lt b">Product</code>值可以被视为一个<code class="du lq lr ls lt b">Monoid</code>，并为其提供了<code class="du lq lr ls lt b">Monoid</code>函数的实现:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="e909" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关键字<code class="du lq lr ls lt b">instance</code>定义了一个新的<strong class="ix hj">类型类实例</strong>。部分<code class="du lq lr ls lt b">Num a =&gt; Monoid (Product a)</code>有点类似于Java中的<code class="du lq lr ls lt b">class Product&lt;T extends Number&gt; implements Monoid&lt;T&gt;</code>——这意味着这里的<code class="du lq lr ls lt b">Product</code>类型变量被<code class="du lq lr ls lt b">Num</code>绑定，所以这个定义只涉及数字。</p><p id="4a7f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二行和第三行定义了<code class="du lq lr ls lt b">Product</code>类型的<code class="du lq lr ls lt b">Monoid</code>函数实现。<code class="du lq lr ls lt b">mempty</code>只是一个包装在<code class="du lq lr ls lt b">Product</code>中的值1，<code class="du lq lr ls lt b">mappend</code>函数在中缀符号中被定义为两个值相乘并再次包装在<code class="du lq lr ls lt b">Product</code>中。这个定义允许我们这样说:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="89e0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lq lr ls lt b">Sum</code>的<code class="du lq lr ls lt b">Monoid</code>类型类实例看起来非常相似。你可以看到<strong class="ix hj">我们可以为同一个类型定义多个类型类实例，并且我们可以在已经定义了初始类型之后这样做</strong>。</p><p id="4960" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是我们如何定义一个函数，将多个幺半群值连接成一个，而不考虑它们的实际类型:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="eecd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这类似于在Java中说<code class="du lq lr ls lt b">reduce(Monoid::append)</code>，但是，这里我们也可以指定空的幺半群值作为初始值，即使幺半群值的集合为空，也能得到合理的结果。</p><h1 id="cdfb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="22c6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如您所见，函数式编程中的类型类类似于面向对象编程语言中的接口，但同时它们代表了一个更强大的概念:</p><ul class=""><li id="abc5" class="lc ld hi ix b iy iz jc jd jg le jk lf jo lg js lh li lj lk bi translated">您可以为现有类型定义它们，而无需更改其签名；</li><li id="418a" class="lc ld hi ix b iy ll jc lm jg ln jk lo jo lp js lh li lj lk bi translated">您可以为同一类型定义多组实现。</li></ul><p id="ffb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望这篇文章能激发您对Haskell编程语言的兴趣——让它成为您下一个要学习的编程语言！</p></div></div>    
</body>
</html>