# 软件命名——时间的考验

> 原文：<https://medium.com/codex/software-naming-the-test-of-time-1f636bc309dd?source=collection_archive---------12----------------------->

![](img/56babfd307d503fd2f1c66723059199c.png)

你将很难找到一个没有首选命名约定的有经验的软件工程师。这包括函数或方法名、类、文件、目录、项目、产品，或者我们讨论的任何潜在概念，或者我们源代码中的任何标识符。

这篇博文不是关于典型的命名惯例。我们不会讨论是使用`camelCase`还是`snake_case`，或者标识符是否应该包含一个名词，或者一个动词。我们不会详细说明如何用复数，或者用`Manager`或`Util`作为后缀是不是一个坏主意。互联网上充斥着关于这些话题的博客帖子。

相反，我们将关注你的命名选择的长期影响。从现在起，您今天选择的标识符可能会在 5 到 10 年后仍在使用。大多数开发人员希望他们的软件可以长期使用，但是他们选择的标识符不能适应时间的流逝。这个讨论是基于 20 多年在软件行业看到这些问题的经验，所以问题是真实的！

非弹性名称有什么影响？老实说，有很多其他的技术债务你可以先关注，但是一旦你的产品成功和成熟，学习如何选择一个*有弹性的*名字可以避免长期的困惑。

# 世界上有什么会改变？

为了说明时间的流逝，我们将使用一个 SaaS 应用程序的例子。想象一下 *Kitty Incorporated* 是一家小型软件公司，只有一个基于网络的产品 *KittyPics* ，允许客户上传和分享他们最喜欢的猫咪照片。

以下是凯蒂公司生活中的一些事件:

*   **扩展网络流量** —最初 *KittyPics* 只需要一台网络服务器，一个磁盘驱动器来存储图像。由于网站越来越受欢迎，现在需要多个 web 服务器和多个磁盘。
*   **项目来来去去**——在成功服务猫影业后，一个新的内部项目(代号为 *Tiger* )在 *Kitty Inc* 启动。老虎项目的目标是允许上传猫的视频，而不仅仅是照片。该项目为期六个月，所有代码都被添加到同一个 *KittyPics* 代码库中。
*   **更大的灵活性** —虽然最初版本的 *KittyPics* 做了一件事(而且做得很好)，但随着时间的推移，无数的新功能和配置设置被添加进来。用户现在有很多方法来调整他们的体验，需要更新代码中的算法。
*   **改变技术** —首席技术官认为维护大量磁盘驱动器不划算，因此启动了一个项目，使用 S3 存储桶将所有猫图片/视频转移到亚马逊网络服务。类似地，在 MySQL 中存储元数据也发生了转变，转而使用更具可伸缩性的 DynamoDB 数据库。
*   **Kitty Inc .**被收购——成功运营两年后，*Kitty Inc .*被竞争对手——*Cat Pictures Corporation*收购。
*   **KittyPics 更名**——经过仔细的市场分析，决定将 KittyPics 更名为一个更时髦的名字: *SabreShots* 。

这些事件在软件产品的生命周期中很常见。我们现在将关注这些变化如何导致我们的标识符变得过时。如果它们过时了，代码会变得更难阅读，维护成本更高，因此增加了技术债务负担。

![](img/9bfeba848aa5e10894c151db93c9ab1e.png)

# 名字是如何变得混乱或不一致的

让我们看看一些现实世界中的例子，看看我们选择的名字是如何变得令人困惑或不一致的，这主要是由于时间的流逝。对于每个例子，我们将看到一个命名选择，它在软件第一次编写时是有意义的，但在后来的时间里就不再有意义了。我们还会看到一个更能适应变化的名字的例子。

## 1 —期待新的实现，但避免称之为“新的”

让我们从一个简单的例子开始。想象一下我们的 *KittyPics* 软件包含了一个在屏幕上自动定位猫图片的算法。该算法运行良好，但我们希望添加第二个算法，同时仍然保留第一个算法作为可选功能。

如果我们从下面的代码开始:

```
def layoutAlgorithm { ... }
```

将第二种算法定义为:

```
def newLayoutAlgorithm { ... }
```

显然，这在从旧算法过渡到新算法时是有意义的，但随着时间的推移,`new`这个词变得不那么相关了。几年后，开发人员认为这两种实现都是“旧的”，并且没有任何关于算法实际上做什么的提示。还有，如果增加第三个实现，会不会叫`muchNewerLayoutAlgorithm`？

更好的做法是以描述性的方式命名算法，以表明它们之间的区别。例如:

```
def gridLayoutAlgorithm { ... }
def circularLayoutAlgorithm { ... }
```

这些名字仍然与久而久之有关，因为它们的目的被很好地描述了，即使在它们的“新”消失多年之后。

![](img/c0f1739535c8d8dcb545fb7f376521be.png)

## 2 —记住名字比项目更持久

*项目*和*产品*的区别是显著的方面。项目是有时间限制的(例如，六个月的持续时间),主要目的是向现有的代码库添加一组离散的特性。相比之下，*产品*的生命周期要长得多，可能存在 5-10 年，甚至更长。

重要的是要记住，你在软件中选择的任何名字都将超出当前项目的范围。在我们的 *Tiger* 项目的例子中(将猫视频添加到 *KittyPics* 产品中)，在项目结束后，任何名称`Tiger`的使用都变得越来越没有意义。

```
module Tiger
def tigerAlgorithm {
   count = getTigerCount()
   ...
}
```

新雇佣的开发人员将很难理解`Tiger`的含义，尤其是 Tiger 项目已经成为历史。

相反，当新添加的特性已经成为长期产品代码库的一部分时，应该使用在项目完成后有意义的名称。例如:

```
module VideoManagement
def videoPlacementAlgorithm {
  count = getVideoCount()
  ...
}
```

这个建议看起来很明显，但是很常见的是模块、类、算法、数据库或 DNS 名称中嵌入了项目名称。随着时间的推移，代码库的标识符中充斥着临时的项目名称。

这个问题的一个例子是使用项目的名称来标识新创建的软件模块。例如，`Tiger`可能成为处理视频的新软件模块的内部代号。随着时间的推移，当人们听到名称`Tiger`时，他们会想到 Tiger 模块，而不是 Tiger 项目，即使原始项目的范围更广。

![](img/ae4f6ef8166d7eabb4cc58df6b753da6.png)

## 3 —考虑到技术在变化，但是名字不需要变化

在产品的整个生命周期中，改变所使用的底层技术是很常见的。例如，我们的 *KittyPics* 产品从使用 MySQL 作为主数据库转向使用更具可伸缩性的 DynamoDB。理想情况下，这种改变对大多数软件应该是透明的，但事实并非总是如此。

在 KittyPics 的第一个实现中，编写如下代码是有意义的:

```
mySql.getImageCount()
```

但是当您切换到使用 DynamoDB 时，这显然没有意义。相反，请为您的数据存储使用更通用的名称，例如:

```
metaData.getImageCount() 
```

您仍然需要为`getImageCount()`方法修改内部代码，但是如果您更仔细地选择名称，您就不需要在每次调用`getImageCount()`方法时都修改代码。

![](img/39b0475c1579186014300f4926de1156.png)

## 4 —营销名称可能会在您的控制之外发生变化

您的产品名称(或产品中的域对象)可能会因市场营销或销售决策而改变。在我们的例子中， *KittyPics* 更名为 *SabreShots* ，目标是增加销售额。同样，产品中的域对象的名称(如`Collection`或`Image`)可能会更改为新的名称(如`Album`或`Photo`)。经验表明，产品可能在十年内经历 2-3 次名称变更，主要是由于公司收购或更名。

为了解决这个问题，您可能会选择进行一次大的重构练习，以使内部代码库与最新的外部名称保持一致。这对于小代码库是有意义的，但是对于更大的产品来说，这只会带来挫折和新引入的错误。

另外，在同一个代码库中混合旧名称和新名称时要非常小心(例如，将一个`Photo`对象传递给一个期望有`Image`对象的方法，即使它们是同一个对象)。新旧名称的混合对于开发人员来说可能会非常混乱，尤其是当他们第一次在代码库中开发时。

也许最好的建议是根本不要修改代码库，而是坦然接受内部名称不同于外部名称。也就是说，总是使用原来的名称`Collection`或`Image`，而不考虑当前面向客户的名称。当然，开发人员需要记住从内部名称到外部名称的映射，但至少代码将是一致的，并且更容易使用。

![](img/51ab83fb5ec34dcebc80a1c55e275ae1.png)

## 5 —您的公司名称也可以更改

这可能不足为奇，但是不要在源代码标识符中包含您公司的名称是一个好建议。并购很常见，被收购的公司名字消失在历史中。

无论您的公司名称是否更改，在标识符中使用它之前，您都应该三思而行。这些名字里有`Kitty`有什么附加值？您可能想要比这些更具描述性的名称:

```
kittyCollectionCount = 100
def displayKittyImage() { ... }
kittyDb.executeSql(...)
```

当然，DNS 名称是公司名称的一个明显要求，所以这不是一个硬性规定。有趣的是，许多小公司只销售单一产品，所以他们的公司名称和产品名称最终成为同义词，随着公司的发展，需要做大量的工作来打破这种联系。是产品，还是公司？

![](img/0e446e650d3612d66eeee5dab0387e2a.png)

## 6——避免对目标过于具体

当实现代码时，有一种倾向是专注于解决你当时遇到的特定问题。然而，随着产品的变化，人们希望重用过去编写的代码。重构已经成为大多数开发人员的常见活动，包括选择更合适的名称。

例如，假设您编写了一个`PhotoArranger`类，让用户能够手动更改产品主页上照片的顺序。但是，现在主页也支持视频了，`PhotoArranger`这个名字就变得令人困惑了。一个解决方案是将该类重命名为`PhotoAndVideoArranger`，但是当添加静态文本和超链接的能力被添加到该类中时，问题就更大了(我们现在应该称之为`PhotoAndVideoAndStaticTextWithHyperlinksArranger`？)

也许最初的名字应该不那么具体，使它更灵活，更能适应变化。也许是`HomePageArranger`？然而，类似于`MediaLayoutArranger`的东西会更加通用，允许它用于其他页面(不仅仅是主页)。

![](img/94b21908ae3be6db90db966313975c8d.png)

## 7——你可能有不止一个

软件通常以上市时间作为驱动因素，而不是担心长期增长(如果不快速上市，这可能永远不会发生)。这种方法的一个缺点是软件被设计成只支持特定组件的一个*，而不是多个。*

在我们的 *KittyPics* 示例中，以下组件需要从一个实例到多个实例:

*   运行软件的 web 应用程序服务器的数量。
*   用于存储图像文件的磁盘数量。
*   运行服务器的国家的数量。
*   存储元信息所需的数据库数量。

除了您需要做出的所有软件设计决策(比如使用一组服务器名称，而不是单个服务器名称)，还有命名问题。

例如，对于 API 服务器名称，您可能会以:

```
api.kitty.com
```

但是当你需要支持多个国家的服务器时，怎么称呼呢？常见的解决方案是:

```
api.kitty.com
api-nz.kitty.com
api-uk.kitty.com
...
```

这个例子当然是在技术债务范围的低端，但是第一个条目上没有国家标签看起来很奇怪，这可能会在您的自动部署脚本中造成混乱。为了避免这些情况，您应该记住扩展，并在您使用的第一个 DNS 名称上添加一个描述性标记。在可数事物的情况下，默认在名称上加一个`-1`，比如`api-1.kitty.com`。

![](img/cfaa3acef54081231064ad180249e713.png)

# 总结——你应该关心多少？

在这篇博文中，我们已经看到了许多不同的方式，在这些方式中，名称无法随着时间的推移而恢复活力，因此变得陈旧、混乱或不一致。

您应该如何解决这些问题？

老实说，虽然这些问题出现在许多产品中，但在几乎每个公司中，人们总是设法适应这种不一致。当内部名称与外部名称不匹配时，会出现混乱，特别是对于那些正在思考新代码库的新员工。然而，如果有足够的时间，人们似乎总是能够克服学习曲线，并忍受这种不一致。

我们应该重构我们的产品来解决这些不一致吗？

这个决定完全取决于你，基于解决这个问题需要多少努力，以及忍受这个问题会有多痛苦。这是我们所有人都面临的遗留代码的无处不在的技术债务问题。重构内部类名是一个简单而实用的改进，但是更改面向客户的 DNS 名称是一个挑战，您可以选择忽略它。

也许最好的建议是在第一次编写代码时尝试使用有意义的名称。然而，无论你为长期选择名字付出了多少努力，你都不会完全正确。最后，你必须准备好接受和忽略剩下的问题。

![](img/7479378285b2959484f0e46452f3a74e.png)