<html>
<head>
<title>Implementing A Multiple Linear Regression Model In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现多元线性回归模型</h1>
<blockquote>原文：<a href="https://medium.com/codex/implementing-a-multiple-linear-regression-model-in-python-24f53d4ed4c1?source=collection_archive---------6-----------------------#2022-08-08">https://medium.com/codex/implementing-a-multiple-linear-regression-model-in-python-24f53d4ed4c1?source=collection_archive---------6-----------------------#2022-08-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ae3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上一次，我们实现了一个单变量线性回归模型，根据一个变量大小来预测房子的价格。今天，我们将对此进行一点扩展，并在sqft中包括除大小之外的一些变量。因为我们将使用矢量化和矩阵，所以我将使用Python的NumPy来实现这一点。我们将在Jupyter笔记本上写下我们的代码。</p><p id="e154" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你没有Jupyter笔记本，你可以通过Anaconda安装它:</p><p id="c741" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://www.anaconda.com/products/distribution" rel="noopener ugc nofollow" target="_blank">https://www.anaconda.com/products/distribution</a></p><p id="e66f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以开始了吗？</p><p id="2cb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Jupyter笔记本上打开一个新的Python 3笔记本。如果你愿意，你可以把它命名为多元线性回归。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/a5cbe8c899d21aec0fc2cd0b1a8b74cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XlN_P4EWelRd_w93SbckYw.png"/></div></div></figure><p id="f763" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将NumPy作为np导入。本质上，NumPy是一个添加了Python支持的库，允许用户创建多维数组，这些数组支持矢量化、矩阵和其他高级数学函数，这些函数可以与提到的数组一起使用。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jq"><img src="../Images/81d4ed5768af8de2d7efdf4d6a05e146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aiqEgx3oZ1WUO8nZzJ8Ibg.png"/></div></div></figure><p id="541d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将创建一个用于训练多元线性回归模型的训练集。</p><p id="e35b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> X_train是</strong>将包含以下特征的矩阵:</p><ul class=""><li id="669e" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">房子的面积(平方英尺)</li><li id="f180" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">卧室数量</li><li id="deaf" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">楼层数</li><li id="1947" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">家的年龄</li><li id="0f75" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">以美元计的价格(千片订量)</li></ul><p id="9ea8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> y_train </strong>将代表我们的目标值(房价)。</p><p id="32c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将有三个培训示例:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kf"><img src="../Images/ad9d67354a96f2cabdc20ee23db842f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pZUJ8anT5jUK1EPDnQkidQ.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kg"><img src="../Images/ff77ae61037996e2c6a19d19005ddd3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQbo8Sxfv-WJdX49v4Tyqg.png"/></div></div></figure><p id="e2bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，NumPy的矩阵允许我们在一个训练示例中索引多个特征，这对于机器学习算法来说非常有用。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kh"><img src="../Images/f10992022a71968ffbf789629cae7612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NP2X0-OCCrHj4RN82b0BaA.png"/></div></div></figure><p id="9b51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们打印<strong class="ih hj"> X_train </strong>时，可以看到我们有三行(三个训练示例)和四列(每列代表一个不同的特性)。</p><p id="ee00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们打印<strong class="ih hj"> X_train.shape </strong>时，我们可以看到我们的矩阵的形状是(3，4)，就像我们刚才观察到的一样。</p><p id="466d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们打印<strong class="ih hj"> type(X_train)，</strong>我们可以看到我们做的数组是一个‘numpy . ndarray’(也就是n维数组，其中n是特征的个数)。</p><p id="8c79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将看看<strong class="ih hj"> w </strong>和<strong class="ih hj"> b. </strong>的参数向量</p><p id="9b98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> w，本例中的</strong>，是一个包含<em class="ki"> n </em>个元素的向量(每个特征一个)。因为我们有四个特征，n是4。</p><p id="a6f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，b 是一个标量参数。每个特性没有不同的<strong class="ih hj"> b </strong>值，所以在整个过程中它保持不变。</p><p id="9399" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">出于演示的目的，我们可以将b_init和w_init初始化为某些值。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kj"><img src="../Images/3ca41d59ac362412b76d3efbb2bc70d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Han_Til_J-Q9wWTGXEXSXw.png"/></div></div></figure><p id="2045" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> w_init </strong>是一个一维NumPy向量，有4个元素(每个元素对应一个特征)。</p><p id="eb86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b_init 是一个float类型，正如我们所料，只有一个值，并且现在保持静态。</p><p id="c213" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于单变量线性回归模型，我们使用以下等式:</p><p id="f8f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">f(x) = w*x + b</p><p id="93f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了多个特征(准确地说是四个)，我们将等式改为如下:</p><p id="d80d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">f(x)= w0 * x0+w1 * x1+w * 2 * x2+w * 3x 3+b</p><p id="90a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从0到3 (n-1)的每个x代表一个不同的特征。</p><p id="dec9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总共4个特征。</p><p id="2552" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，每个x也有一个参数w，范围从0到3 (n-1)。</p><p id="caf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了简化上面的等式，我们可以将等式写为:</p><p id="79b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">f(x) = <strong class="ih hj"> w </strong> * <strong class="ih hj"> x </strong> +b</p><p id="7d22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，与单变量线性回归模型不同，该方程中的w和x现在是分别包含w值(范围为0-3)和x值(范围为0-3)的向量。注意，<strong class="ih hj"> w </strong>和<strong class="ih hj"> x </strong>都用粗体表示矢量化。</p><p id="64a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，当我们将<strong class="ih hj"> w*x </strong>相乘时，我们得到的是这两个向量的<strong class="ih hj">点积</strong>。</p><p id="5dcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们实现一元线性回归模型时，我们将w乘以x，并添加b和结尾。</p><p id="c2a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于多元线性回归，我们可以编写一个函数来对单个训练示例进行预测。由于我们有四个特征，它把w0*x0，w1*x1，w2*x2，w3*x3相乘，加在一起，最后加上b。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kk"><img src="../Images/1c7b170d0119146ebbdf2fa53833c577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgnLlw9xbID1764UONUBOw.png"/></div></div></figure><p id="2fc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">n =特征数量(4，0–3)</p><p id="70cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">p =预测值，首先初始化为零</p><p id="6b72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">p_i =代表wi*xi，其中<em class="ki"> i </em>代表迭代次数<em class="ki">。</em></p><p id="f36f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您为所有<em class="ki"> i </em>迭代添加w*x时，更新p =总预测值。</p><p id="f0b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b =我们必须在末尾添加的标量参数，如等式所示</p><p id="2454" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">f(x)= w*<strong class="ih hj">x</strong>+b</p><p id="fca8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用一个训练示例来测试这个函数。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kl"><img src="../Images/8e64ba249810c0e6276fecaceb57a37a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n52UnIB9D_bYgxT_voRhEg.png"/></div></div></figure><p id="5182" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我初始化了<strong class="ih hj"> x_vec </strong>来对应<strong class="ih hj"> X_train[0，]。</strong></p><p id="03d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">0对应于第一行。同时，<strong class="ih hj"> : </strong>表示我想要第一行中四列中每一列的所有元素。如果我想要第二行的所有元素，我会使用<strong class="ih hj"> X_train[1，:] </strong>等等。</p><p id="8fda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到，<strong class="ih hj"> x_vec </strong>现在对应的是第一个训练实例(2104大小，5间卧室，1层，45岁)。</p><p id="854d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们通过刚刚创建的函数运行<strong class="ih hj"> x_vec </strong>，看看会发生什么。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kk"><img src="../Images/461ffb0918734f9ab2fa15b271342edd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pGVKwOV3w8DOeE6OMQ37sQ.png"/></div></div></figure><p id="5ae9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如我们所见，我们得到的值是459.999，非常接近460(我们的目标值)。当然，我们利用了为实现这一目的而优化的<strong class="ih hj"> w_init </strong>和<strong class="ih hj"> b_init </strong>的值。</p><p id="5ff1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果有更简单快捷的方法来计算向量w*x之间的点积呢？那不是很好吗？</p><p id="d462" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谢天谢地，有。我们可以简单地使用NumPy的<strong class="ih hj">点</strong>方法，而不是使用for循环来计算它:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es km"><img src="../Images/b6db33b58b6b1df8e26aa0ef5b9ee17f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8QQnQgaVbgcFtgQ3uKd2Q.png"/></div></div></figure><p id="3643" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法使得计算速度更快，因为它确保了使用计算机硬件同时进行多个计算。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kn"><img src="../Images/c095014129b37edf31517c63356ec3c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AtpmAPEh8htNJ17992oexQ.png"/></div></div></figure><p id="f807" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，我们得到了和使用for循环一样的结果。您可能会注意到，对于这个特定的示例，计算花费的时间大致相同，但是随着计算次数的增加，当使用for循环与NumPy中的dot方法时，时间上会有很大的差异。</p><p id="e500" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">成本</strong></p><p id="f73f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之前，我们使用以下等式计算了单变量回归模型的<strong class="ih hj">成本</strong>(预测值和目标值之间的差异)<strong class="ih hj"> </strong>:</p><p id="27cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">J(w，b)= 1/2m * m-1σI = 0(<em class="ki">𝑓</em>w,b(x)^(i)- y^(i))</p><p id="8f79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，多元线性回归模型使用以下等式来计算<strong class="ih hj">成本</strong>:</p><p id="b0f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">J( <strong class="ih hj"> w </strong>，b)= 1/2m * m-1σI = 0(<em class="ki">𝑓</em><strong class="ih hj"><em class="ki">w</em></strong><em class="ki">，b(</em><strong class="ih hj"><em class="ki">x</em></strong><em class="ki">【)^(i)-y^(i】)</em></p><p id="2fe1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意<strong class="ih hj"> w </strong>和<strong class="ih hj"> x </strong>现在是粗体，因为它们代表矢量。</p><p id="cc2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建一个计算成本的函数:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ko"><img src="../Images/8049473ffdcf4b5385f825f78970d87c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTpkinKX6a2IVz1Eks8_Yw.png"/></div></div></figure><p id="ab9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> m </strong> =训练样本数</p><p id="d2be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> f_wb_i </strong> =将训练示例<em class="ki"> i </em>乘以向量<strong class="ih hj"> w </strong>并加上b后的预测值</p><p id="72c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> y[i] </strong> =训练例I的目标值</p><p id="ca21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">成本</strong> =预测值与目标值的差值的平方</p><p id="fec2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，当我们把所有的变量代入我们的方程时，我们得到了一个非常小的成本数字，使用我们预先确定的<strong class="ih hj"> w </strong>和b的值</p><p id="015a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">梯度下降算法——成本函数J相对于wj和b的偏导数</strong></p><p id="281f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与成本函数类似，多元线性回归的梯度下降算法与一元线性回归的梯度下降算法非常相似。然而，w不再是单个变量，而是一个向量，在我们的具体例子中，j的范围是0-3:</p><p id="d8cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重复直到收敛:{</p><p id="3fc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">wj</strong>=<strong class="ih hj">wj</strong>-<em class="ki">𝛼* 1</em>/m * m-1∑I = 0(<em class="ki">f</em>w,b(x^(i))-y^(i))xj^(i)</p><p id="d7d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中j是特征的数量<em class="ki">。</em></p><p id="7ff5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b = b-<em class="ki">𝛼* 1</em>/m * m-1∑I = 0(<em class="ki">f w，b (x^(i))-y^(i)) </em></p><p id="2b87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">}</p><p id="28fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，我们也必须同时更新这些值。</p><p id="b072" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建一个函数来计算成本函数J相对于<strong class="ih hj"> wj </strong>和<strong class="ih hj"> b </strong>的偏导数:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kp"><img src="../Images/84e72b5e804fb2b4803d072723980121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Thdtk_bnBv6N3Ef3GXSDw.png"/></div></div></figure><p id="2c6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我首先声明这个函数叫做<strong class="ih hj"> compute_gradient </strong>。</p><p id="50be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于我们有3个训练示例和4个特征，我将使用assign m，n to <strong class="ih hj"> X.shape </strong> (3，4)。</p><p id="462f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将为<strong class="ih hj"> dj_dw </strong>创建一个有n (4)个元素的数组，每个元素都是0。</p><p id="d1fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些“点”中的每一个都将保存对应于<strong class="ih hj">wj</strong>(0–n-1)的偏导数值。</p><p id="22ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同时，<strong class="ih hj"> dj_db </strong>将是一个奇异值，因为我们没有针对每个特征的不同的<strong class="ih hj"> b </strong>值(不像<strong class="ih hj"> wj)。</strong></p><p id="cf97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我创建了一个for循环，它将遍历所有的训练示例(m)。</p><p id="2906" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我通过取X[i] (X_train[i])和<strong class="ih hj"> w </strong> (w_init)的点积，加上b，取总和，减去我们的目标值(Y_train[i])，来计算每个训练示例中的误差。</p><p id="26ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将误差乘以X[i](如偏导数等式所示)，并将成本函数J相对于迭代J处的wj值的偏导数存储在一个阵列槽中。</p><p id="68b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，在主for循环中，由于我们同时更新b的值，我们简单地将我们的误差附加到<strong class="ih hj"> dj_db </strong>(因为等式表明不需要乘以X^(i)).</p><p id="b7fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第一个for循环运行m次后，我们简单地将一维数组<strong class="ih hj"> dj_dw </strong>和变量dj_db除以m，如等式所示。</p><p id="274f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们返回<strong class="ih hj"> dj_dw </strong>(包含4个值的数组)<strong class="ih hj"> </strong>和<strong class="ih hj"> dj_db </strong>(包含1个值的变量)的值。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kq"><img src="../Images/611995ee3b4b79b13f59488ce528774c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nuFUMZTwUjuDgBcUhuSxg.png"/></div></div></figure><p id="aae1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们打印<strong class="ih hj"> dj_dw </strong>时，我们得到了<strong class="ih hj"> dj_dw </strong>中预期的4个值和<strong class="ih hj"> dj_db </strong>的单个值。</p><p id="ad29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">梯度下降算法——实现dj_dw和dj_db </strong></p><p id="f6ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们已经定义了导数<strong class="ih hj"> dj_dw </strong>和<strong class="ih hj"> dj_db </strong>的值，我们可以将这些值插入梯度下降函数:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kr"><img src="../Images/32f76f38c86bb6069526a4752e3a0639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2OZ4p6bfPqAJKoFKufACw.png"/></div></div></figure><p id="6971" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们先做一个w_in/b_in的副本，这样就不会影响全局变量。</p><p id="aaf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们创建一个for循环，它将在循环内部迭代<strong class="ih hj">inter</strong>次:</p><ul class=""><li id="c412" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">我们通过调用gradient_function(这将是我们制作的compute_gradient函数)来计算成本函数J的偏导数。</li><li id="c837" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">通过减去学习率<em class="ki"> 𝛼 </em> * dj_dw来更新w的值</li><li id="b03f" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">通过减去学习率<em class="ki"> 𝛼 </em> *dj_b来更新b的值</li></ul><p id="e522" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有迭代完成后，我们退出循环并返回w和b的值，这些值在迭代后应该会得到更好的优化。</p><p id="aab3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们的函数已经准备好了，让我们来测试一下。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ks"><img src="../Images/0f6c7188d1b9ff2ab31d73c4b35bf026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wrAK27xt75RHXk3o5Zm1QQ.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kt"><img src="../Images/ff8b0b0768dd408bb740e15ed22a5161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qkB7sVZ8qY6NLxiM9hi8Zw.png"/></div></div></figure><p id="1a78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在开始任何迭代之前，我们将把参数<strong class="ih hj"> w </strong>和b设置为0。</p><p id="4d0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将<strong class="ih hj"> initial_w </strong> (vector)初始化为一个零数组，其元素数量与<strong class="ih hj"> w_init </strong> (4)相同。</p><p id="4367" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将变量<strong class="ih hj"> b </strong>设置为“0”(使其成为与int相反的float类型)</p><p id="dfea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将从1000次迭代开始。</p><p id="325d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于alpha(学习率)，我们用8.0e-7吧。</p><p id="d7c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> w_final </strong>和<strong class="ih hj"> b _final </strong>是我们对<strong class="ih hj"> w </strong>和b的值迭代1000次后应该得到的优化值。</p><p id="7af6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我们的参数，让我们使用X_train(训练示例)、y_train(目标值)、initial _ w(0的数组)、initial_b(浮点类型零)、compute_cost(我们的成本函数J)、compute_gradient(我们的计算偏导数的函数)、alpha(我们的学习率8.0e-7)和iterations(它被设置为1000。)</p><p id="71a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，让我们通过将w_final和b_final的值代入<strong class="ih hj"> f(x) = </strong> <strong class="ih hj"> w*x+b. </strong>来计算我们的预测值</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/c2dfa57d6a1791b9d58fc69839655bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjxZL_FaSwaVYmM2K-pawA.png"/></div></div></figure><p id="2d39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">再说一次，因为我们正在实现一个多元线性回归模型，w和x是向量。所以一定要用NumPy的点方法计算它们之间的点积，最后加b。我们将对所有三个训练示例都这样做，这就是为什么我们使用迭代m次的for循环。</p><p id="5b31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以看到，迭代1000次后，结果是:</p><p id="8980" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">426.530 (ŷ或预测值)对460(目标值)</p><p id="d77c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">285.990 (ŷ或预测值)对232(目标值)</p><p id="1816" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">170.913(ŷ或预测值)对178(目标值)</p><p id="b6f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仍然有许多改进要做。如您所见，成本仍然相对较高，这意味着我们必须改变一些参数来实现收敛。从技术上讲，我们可以简单地<strong class="ih hj">增加</strong>迭代次数，但这确实意味着我们模型的训练将需要更长时间。</p><p id="4e96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，我们将<strong class="ih hj">z score</strong><strong class="ih hj">normalization</strong>来归一化特征并改变我们的学习速率，以便我们可以更有效地达到收敛。</p><p id="b1d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们创建一个函数，它将允许我们使用z分数归一化来改变<strong class="ih hj"> X_train </strong>中的特征，以便它们在值上变得相似。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kv"><img src="../Images/70e60ddedc362fcc2c8f84463b356823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CVUKlAKyzAuFq8DpzIYPvA.png"/></div></div></figure><p id="6e64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">mu =每个特征的平均值，使用NumPy的平均值方法计算。</p><p id="50cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">sigma =每个特性的标准偏差，使用NumPy的标准方法计算。</p><p id="d055" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">X_norm =我们减去X减去平均值，然后除以sigma，如下式所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kw"><img src="../Images/00192379a4fbb81ea2d36c2b40845e37.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*DM1P2JV1_j8G4iGsQWp2sg.png"/></div></div></figure><p id="2a89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们试图打印X_norm时，我们可以看到这些值的大小类似地变化——从1.5到-1.2。每个特征之间不再有巨大的数字差异。</p><p id="bc1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们使用<strong class="ih hj"> X_norm </strong>而不是<strong class="ih hj"> X_train </strong>来重新训练模型。</p><p id="e416" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将简单地将X_norm作为我们的训练集插入到我们之前构建的所有函数中:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kx"><img src="../Images/5481912d4817d0f461b6db1835947027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_EHcPd-clKKWOOf9QZfzPA.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">(J函数对应compute_cost)</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kj"><img src="../Images/bed5eebf91dc876396965b406e547891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SjWcyGvvKyTuJYV_JP-BYQ.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">注意-函数“导数”对应于compute_gradient，返回dj_dw，dj_db，而不是dj_db，dj_dw。</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lc"><img src="../Images/f7d4a943f19fa61ca47e19dab7667426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sYqGuCofRtL6ySMXZ4E2RQ.png"/></div></div></figure><p id="fa05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，让我们将alpha(学习率)调整为5.0e-2，并将迭代次数设置为1000:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ld"><img src="../Images/f58adfaffce1d046332d7ddeba28e2b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zK_HoyV9Gu8xP6Gb-VPixA.png"/></div></div></figure><p id="f45f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面分别是我们的w_final和b_final的最终值:</p><pre class="jf jg jh ji fd le lf lg lh aw li bi"><span id="766b" class="lj lk hi lf b fi ll lm l ln lo">[ 38.05161505  41.54327451 -30.98894656  36.34177447],290.00</span></pre><p id="89e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将它们代入等式<strong class="ih hj"> w </strong> * <strong class="ih hj"> x </strong> +b，看看该模型是否能准确预测给定训练集的房屋价格:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lp"><img src="../Images/4f2af3b21c46a96aa2b0250418d23bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EoAqHaVu9yjA5XfD1oSOfA.png"/></div></div></figure><p id="02e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，经过1000次迭代，我们的模型已经收敛。我们的预测值现在正确地对应于我们的目标值，并且我们的模型非常适合这些数据。</p><p id="d54f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们创建一个小程序并测试这个模型:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lq"><img src="../Images/02df6fa2f12bd1f03fc7a17507b83dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5d0MB4QPNcz51_fCa9Oqcw.png"/></div></div></figure><p id="0db2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，当我们使用第一个训练示例的参数时，我们最终得到的预测值为459.9999999，这基本上是我们四舍五入后的目标值(460)。</p><p id="ef37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，我们可以使用不同的值进行新的预测:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lr"><img src="../Images/2a9abdd52bb0fe92fc5c93d0c5dcec31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWQbdD_8AcueTxztn6tf7w.png"/></div></div></figure><p id="6ad1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">恭喜你！现在，您已经知道如何应用多元线性回归来对具有各种功能的训练示例进行预测。</p><p id="207c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为深度学习大声呐喊。人工智能和斯坦福创造了机器学习专业化。本教程深受其启发。</p><p id="4fb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想了解更多？请访问:</p><div class="ls lt ez fb lu lv"><a href="https://www.coursera.org/specializations/machine-learning-introduction" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab dw"><div class="lx ab ly cl cj lz"><h2 class="bd hj fi z dy ma ea eb mb ed ef hh bi translated">机器学习</h2><div class="mc l"><h3 class="bd b fi z dy ma ea eb mb ed ef dx translated">用机器学习专业化来突破AI。掌握基本的人工智能概念并开发实用的机器学习…</h3></div><div class="md l"><p class="bd b fp z dy ma ea eb mb ed ef dx translated">www.coursera.org</p></div></div><div class="me l"><div class="mf l mg mh mi me mj jo lv"/></div></div></a></div></div></div>    
</body>
</html>