<html>
<head>
<title>4 Use Cases for the Terraform CDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CDK地形的4个使用案例</h1>
<blockquote>原文：<a href="https://medium.com/codex/4-use-cases-for-the-terraform-cdk-5864630d147e?source=collection_archive---------3-----------------------#2021-07-21">https://medium.com/codex/4-use-cases-for-the-terraform-cdk-5864630d147e?source=collection_archive---------3-----------------------#2021-07-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/964622e464bd7bfcf14adc25b2ec27dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50TrBaPNc_ov6-8Az23VeQ.png"/></div></div></figure><div class=""/><p id="2aaa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为一个已经写了相当一部分TF的人，我有点偏向于IaC的声明性方法。声明性方法将维护负担转移到提供者维护者身上，并使不知道如何编码的从业者能够更快地开始。</p><p id="7cdc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也就是说，我认为大多数通情达理的人都会同意，并不是所有的事情都应该或者可以用静态的、声明性的方式来定义。Terraform的动态资源块和for_each支持可以很快让你想要更多。让我们深入CDK，看看它能在哪些方面有所帮助。</p><h1 id="2cdb" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是CDK地形？</h1><p id="8f85" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">2019年AWS发布了他们的云开发工具包(CDK)，基于<a class="ae kr" href="https://docs.aws.amazon.com/cdk/latest/guide/constructs.html" rel="noopener ugc nofollow" target="_blank">构造</a>库构建。构造库允许开发人员定义基于Javascript或Typescript的类，这些类可用于以任何实现JSii接口的语言生成类。</p><p id="e167" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过为Terraform提供者、资源和数据源自动创建构造，Terraform CDK (TF CDK)建立在相同的构造和JSii库之上。这使得从业者可以利用Python、Typescript、Go等语言来开发Terraform资源的本地语言表示。</p><p id="bae3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，TF CDK负责获取用这些其他语言之一编写的代码，并将其合成为JSON格式的TF配置。然后这被交给Terraform二进制来计划和应用。</p><p id="ef4d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以将TF CDK视为提供者及其资源的语言库，以及将任何语言转换为TF配置的预处理步骤。</p><h1 id="b440" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">用例</h1><h2 id="70a9" class="ks jp ht bd jq kt ku kv ju kw kx ky jy jb kz la kc jf lb lc kg jj ld le kk lf bi translated">动态资源属性</h2><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lg"><img src="../Images/8c45f6cbbd3252200eaf58f35a064ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wLZ4vtBkpJpbCW96_OEnNg.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">代码示例展示了如何将嵌套的动态块与AWS的WAF v2规则组语句一起使用，这些语句可以递归嵌套</figcaption></figure><p id="4e44" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在某些时候，您会希望将资源的属性建立在一组动态数据的基础上。在最简单的情况下，<code class="du lp lq lr ls b">for_each</code>和<code class="du lp lq lr ls b">dynamic{}</code>块允许您捕获数据和资源之间的关系。</p><p id="f041" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，有些资源，如AWS WAFv2规则组，具有更复杂的数据结构，因为它们支持递归语句。这种关系的一个例子显示在上面的右侧。用Terraform的<code class="du lp lq lr ls b">dynamic</code>块支持这种类型的关系会导致复杂的代码。在无限递归深度的情况下，它可能无法捕获整个数据结构。</p><p id="6113" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与左边的<a class="ae kr" href="https://github.com/peytoncasper/tf-cdk-examples/tree/master/dynamic-resource-attributes" rel="noopener ugc nofollow" target="_blank">动态资源属性示例</a>相比，它允许我们利用Python的原生JSON解析，并将这些嵌套语句直接转换成适当的CDK类。</p><h2 id="45c1" class="ks jp ht bd jq kt ku kv ju kw kx ky jy jb kz la kc jf lb lc kg jj ld le kk lf bi translated">动态模块组合</h2><figure class="lh li lj lk fd hk er es paragraph-image"><div class="er es lt"><img src="../Images/a8d8c15b1d47f59f8242c7f797a5c7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*0KHzqTSI14W3nRKbxQjwpQ.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">显示App A模块如何利用子模块作为构建模块的分层图</figcaption></figure><p id="9f99" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Terraform不提供动态获取提供者和模块版本的能力，因为这些信息必须在初始化之前知道。一般来说，这不是问题。尽管如此，这通常意味着您的模块最终会有一个层次结构，其中您最外层的模块代表一个“版本”或其所有子模块的特定配置。</p><p id="4c85" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个发布概念是理想的，因为它为我们提供了模块配置的时间点快照，这些模块配置相互之间交互良好。然而，如果您正在运行PaaS服务，并且有100个客户使用不同的发布版本，该怎么办呢？将客户正在运行的模块版本集合外部化可能是有益的。这允许我们支持像特性标志这样的功能，而不必手动修改任何TF代码。</p><p id="ebcd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">CDK为我们提供了这种能力，因为它充当了TF代码生成层的角色；我们可以很容易地从任何外部系统获取发布信息，比如数据库、REST API、Consul，甚至是磁盘上的文件。</p><p id="9ee6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae kr" href="https://github.com/peytoncasper/tf-cdk-examples/tree/master/dynamic-module-composition" rel="noopener ugc nofollow" target="_blank">动态模块组合示例</a>展示了从磁盘上的JSON文件中读取一组模块版本的示例。然后，它将这些信息传递到CDK库中，以生成最终的TF代码。</p><h2 id="b998" class="ks jp ht bd jq kt ku kv ju kw kx ky jy jb kz la kc jf lb lc kg jj ld le kk lf bi translated">外部配置集成</h2><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lu"><img src="../Images/b7ec0981896e4254864e22ef186c973f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O2hgszmYhQdNqbZ_eKfPIw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">该图显示了一个Python进程向BoredApi发出GET请求，并使用该响应作为CDK的输入。</figcaption></figure><p id="45f7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Terraform可以访问数百家提供商，这些提供商拥有不同程度的数据来源，我们可以从中获取信息。但是，如果我们想将我们的一些TF配置基于来自Kafka、REST API或者甚至是没有提供者的服务的数据呢？</p><p id="22af" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不幸的是，在我们运行<code class="du lp lq lr ls b">terraform apply</code>之前，如果没有一个外部进程提取数据并将其转换成TF变量，这是不可能的。这是TF CDK充当外部流程的另一个例子，为我们提供了两种可能性。</p><ol class=""><li id="21a0" class="lv lw ht is b it iu ix iy jb lx jf ly jj lz jn ma mb mc md bi translated">自动响应收到的事件，生成新的TF代码，然后执行它。</li><li id="0a5f" class="lv lw ht is b it me ix mf jb mg jf mh jj mi jn ma mb mc md bi translated">从外部来源提取数据，并使用它来动态生成我们的TF代码。</li></ol><p id="1326" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae kr" href="https://github.com/peytoncasper/tf-cdk-examples/tree/master/external-configuration-integration" rel="noopener ugc nofollow" target="_blank">外部配置集成示例</a>利用场景二，向<a class="ae kr" href="https://www.boredapi.com" rel="noopener ugc nofollow" target="_blank"> BoredApi </a>发出<code class="du lp lq lr ls b">GET</code>请求，然后使用该响应来定义AWS计算实例的名称。</p><h2 id="be83" class="ks jp ht bd jq kt ku kv ju kw kx ky jy jb kz la kc jf lb lc kg jj ld le kk lf bi translated">调配后步骤</h2><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mj"><img src="../Images/0993cd6f869d074677140a22936115d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWaf-WhBjBgJpR0f8gf-pA.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">显示Python流程的流程图，将资源添加到CDK堆栈，生成TF代码，应用它，添加提交阶段并重复</figcaption></figure><p id="6df0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在使用Terraform时只遇到过一次这种问题，它特别与Terraform Palo Alto provider的工作方式有关。不幸的是，Palo Alto provider无法在应用结束时执行提交。因此，在Statefile中更新的所有更改都是暂存的。这意味着，在terraform应用程序结束时，您需要有一些流程可以针对Palo Alto API执行提交。这也意味着，如果由于某种原因，提交步骤失败了，我们的TF状态和Palo Alto提供者基本上就不同步了。</p><p id="465f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae kr" href="https://github.com/peytoncasper/tf-cdk-examples/tree/master/post-provision-steps" rel="noopener ugc nofollow" target="_blank"> Post Provision步骤示例</a>利用了TF CDK按需生成TF代码的能力，以及通过在添加每个资源后注入commit步骤来控制Terraform生命周期的能力。</p><h1 id="ef91" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">骗局</h1><p id="6201" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我将省略优点部分，因为4个用例已经代表了其中的大部分。大多数不利因素与项目的成熟度有关，但是我确实想指出它们，因为它们对于理解您的团队是否能够支持当前状态的CDK非常重要。</p><ol class=""><li id="2e16" class="lv lw ht is b it iu ix iy jb lx jf ly jj lz jn ma mb mc md bi translated">CDK使用<code class="du lp lq lr ls b">cdktf get</code>命令获取模块、提供者和它们的JSii类。喝一杯咖啡需要足够长的时间，而且不幸的是，在跑步前似乎没有进行区分；相反，它每次都会重新下载所有内容。你可能不会运行它太多，但<code class="du lp lq lr ls b">terraform init</code>是一个非常快速的操作，在功能上是等价的。</li><li id="d91c" class="lv lw ht is b it me ix mf jb mg jf mh jj mi jn ma mb mc md bi translated">对于CDK的Python实现，导入语法高亮显示和智能感知是不存在的。我怀疑这是因为CDK将JSii类下载到了一个非标准的导入文件夹中，但是它与下一个问题混合在一起。</li><li id="7a06" class="lv lw ht is b it me ix mf jb mg jf mh jj mi jn ma mb mc md bi translated">没有关于类名或其实现的文档意味着在AWS的情况下，您将使用find命令搜索一个40MB的Python文件，而没有语法高亮显示来搜索它们的实现。</li><li id="6f63" class="lv lw ht is b it me ix mf jb mg jf mh jj mi jn ma mb mc md bi translated">类名是自动生成的，并且会产生一些有趣的名称。在我们上面的递归WAF规则语句中，这是一个例子。<code class="du lp lq lr ls b">Wafv2RuleGroupRuleStatementOrStatementStatementGeoMatchStatementForwardedIpConfig</code></li><li id="72e7" class="lv lw ht is b it me ix mf jb mg jf mh jj mi jn ma mb mc md bi translated">与所有新项目一样，错误消息会变得非常冗长，CDK也不例外。在下面的例子中，我在创建<code class="du lp lq lr ls b">TerraformHclModule</code>时传入了错误类型的对象</li></ol><figure class="lh li lj lk fd hk"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">向CDK类传递错误参数的堆栈跟踪示例</figcaption></figure><h1 id="d1b5" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="dace" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">TF CDK是一个很好的工具，可以添加到你的腰带上，但是我要提醒你不要大规模的使用它。虽然使用一种你已经知道的语言会感觉很舒服，但是声明性代码在可维护性方面有很多看不见的好处。因为我们只是简单地声明我们希望存在什么类型的资源，只要底层实现提供相同的输入和输出，它就可以很容易地升级。虽然自动生成的JSii类也是如此，但是您还需要处理另外两个随时可能发生变化的抽象层。</p><p id="dcbc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">利用CDK的最大优势，它是一个位于Terraform之上的薄层，允许您动态获取信息，然后使用它来生成底层TF代码。更具体地说，我认为有一个最佳点，其中95%的TF是声明性HCL，剩下的5%是加载数据和利用现有TF模块的CDK代码的某种变体。这允许团队维护一组共享的模块，同时仍然允许每个团队维护一个轻量级的定制层。</p><p id="abb4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我喜欢探索TF CDK，我很兴奋地看到它如何随着项目的继续迭代而变化。希望你从这篇文章中学到了一些东西，但是，我也很好奇你有什么经验，或者你对如何利用CDK有什么其他想法。在<a class="ae kr" href="https://twitter.com/peytoncasper" rel="noopener ugc nofollow" target="_blank">推特</a>上联系我；我很乐意继续这个话题。</p><div class="hh hi ez fb hj mm"><a href="https://github.com/peytoncasper/tf-cdk-examples" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hu fi z dy mr ea eb ms ed ef hs bi translated">GitHub-peytoncasper/TF-CDK-示例</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">Terraform CDK是一个相对较新的项目，它很好地扩展了Terraform…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">github.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na hp mm"/></div></div></a></div></div></div>    
</body>
</html>