<html>
<head>
<title>Getting Started Using Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux使用入门</h1>
<blockquote>原文：<a href="https://medium.com/codex/getting-started-using-redux-4dcf6845535d?source=collection_archive---------14-----------------------#2021-08-06">https://medium.com/codex/getting-started-using-redux-4dcf6845535d?source=collection_archive---------14-----------------------#2021-08-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="290a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用缩减器、动作和调度程序的单向状态管理</h2></div><p id="af15" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你好！今天我将讨论使用Redux的状态管理，这是一个基于Flux的框架，用于在react中管理状态时实施单向数据流。这个流行的框架，尽管很小，却产生了一点影响，并且一直沿用至今。当涉及到在所有样板文件中涉水时，学习Redux可能有点令人头痛。这篇文章有望帮助读者更好地理解Redux。事不宜迟，让我们开始吧！</p><h1 id="170b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">通量架构</h1><p id="e1ed" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">尽管Redux基于Flux架构，但Flux本身根本不是一个框架或库。事实上，通量架构是一种模式。通量流以单向流动的三点环形模式管理其事件。这种<em class="kq">单向数据流</em>的思想被Redux采用，由类似的架构组成。在Flux中，状态变化在一个<em class="kq">动作</em>中描述，然后被发送到一个<em class="kq">调度器</em>，在那里一个定义的动作将处理状态变化。最后，状态被保存在<em class="kq">存储器</em>中，以便在下一次状态改变时发送给调度程序。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kr"><img src="../Images/48c4a8f1bd5b525cf8d1c2cbf9fce5cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jY5YoszgF3fqbjeI_4GspQ.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">通量架构流程(在<a class="ae lh" href="https://canva.com" rel="noopener ugc nofollow" target="_blank"> Canva </a>创建)</figcaption></figure><p id="5dd2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简而言之，存储订阅动作，这些动作被发送给调度程序，然后调度程序通知存储该动作并相应地更新其状态，如果需要，更新视图，然后等待下一个动作来重复该过程。</p><h1 id="7f5f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">Redux</h1><p id="a0a3" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">Flux对单向数据流的强制是Redux的基础。这个框架允许我们的React应用程序为它们的状态维护一个单一的真实来源。使用Redux来集中我们的状态相关逻辑，我们可以重新关注组件架构。基于功能的组件现在可以专注于单个角色。此外，它在架构上的简单性使它成为管理组件之间复杂交互的首选。</p><p id="961a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要在React应用程序中开始使用Redux(假设您已经有了React前端)，您可以通过从终端运行<code class="du li lj lk ll b">npm install redux react-redux </code>或<code class="du li lj lk ll b">$yarn add redux react-redux</code>来安装Redux以及React-Redux绑定。</p><p id="af06" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在项目根，我们可以从React-Redux库中导入一个提供者到<code class="du li lj lk ll b">index.js</code>。Provider模块允许我们访问应用程序状态所在的存储区。要做到这一点，我们可以从Redux库导入<code class="du li lj lk ll b">createStore</code>来从一个reducer创建一个store对象，稍后我们将对此进行更多的讨论。下面的例子来自一个示例计数器应用程序，它使用一个<code class="du li lj lk ll b">counterReducer</code>来保存我们状态的初始值。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lm"><img src="../Images/22c1afeadf23f0979a8f2c893b4e24fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*suTcormJvsIROO_fHHrJsw.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">index.js(创建于https://carbon.now.sh)</figcaption></figure><h1 id="092f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">还原剂</h1><p id="1491" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">如前所述，我们还需要一个存储对象来保存应用程序的状态。我们的商店可以订阅从调度程序接收的动作作为状态更新。当编写一个规约时，我们必须为我们的状态传递一个初始值。对于<code class="du li lj lk ll b">counterReducer</code>来说，这意味着初始计数为零。</p><p id="6a61" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个reducer还需要接收一个action对象，该对象包含修改我们状态的一个<em class="kq">副本</em>并返回该副本的属性。记住我们不能直接修改状态，这使得我们避免做类似于<code class="du li lj lk ll b">return state.count++</code>的事情变得很重要。该示例演示了两种操作类型；一个用于递增计数，一个用于递减计数。可以选择将动作类型作为字符串常量存储在各自的文件中，即<code class="du li lj lk ll b">const INCREMENT = “INCREMENT”</code>，尤其是在处理多个动作时。这样，你可以把所有的动作类型放在一个地方。下面的例子是一个较小的项目，所以声明动作类型的字符串常量。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lm"><img src="../Images/a7f9cb0200c64fcffb4909b92b2cb496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ce_NNE315wz43v0HY9wlA.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">reducer.js(创建于<a class="ae lh" href="https://carbon.now.sh)" rel="noopener ugc nofollow" target="_blank"> https://carbon.now.sh) </a></figcaption></figure><p id="0c46" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Redux强制执行这个流，目的是保持状态树不变。不要直接改变状态！上面的例子使用一个<a class="ae lh" href="https://devdocs.io/javascript/operators/spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展操作符</a> <em class="kq">，</em>返回状态，它将为其中的每个键值对扩展我们的状态对象。spread操作符创建了一个对象文字的副本，我们可以使用动作创建器代替状态对象本身来修改它。</p><h1 id="5c98" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated">调度员</h1><p id="2f17" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">为了分派我们已经定义的动作，我们可以使用分派函数来通知存储需要执行的动作。下面的示例通过在每个操作的方法中调用dispatch函数来实现dispatch函数的使用。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lm"><img src="../Images/d79c1076448f0d85cac13f26ed05d297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*shU4I9OVbcE_5I5u3FO6lA.png"/></div></div></figure><p id="d8e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在你知道了！如果您运行这个React应用程序，您将有一个简单的计数器，它有一个增加显示的计数的按钮和一个减少计数的按钮。(如果您想保持您的功能组件的纯净，您可以简单地分别定义您的调度程序。)</p><p id="14f1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">今天就到这里吧！查看下面的链接，获得更多关于使用Redux的学习资源，包括Redux文档以及一本介绍实现Redux来反应应用程序的基础知识的书。感谢阅读！下次见！</p><h2 id="9ec2" class="ln ju hi bd jv lo lp lq jz lr ls lt kd jg lu lv kf jk lw lx kh jo ly lz kj ma bi translated">引用的消息来源</h2><p id="069c" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">" API参考| Redux。"<em class="kq">Redux——JavaScript应用的可预测状态容器。| Redux </em>，<a class="ae lh" href="https://redux.js.org/api." rel="noopener ugc nofollow" target="_blank">https://redux.js.org/api.</a>2021年8月2日访问。</p><p id="c4ba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">丁克维奇、鲍里斯和伊利亚·格尔曼。<em class="kq">完全还原本</em>。Leanpub，2017年，第12–24页。</p></div></div>    
</body>
</html>