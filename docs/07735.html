<html>
<head>
<title>The Journey of an Operator in a Deep Learning Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习框架中的运营者之旅</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-journey-of-an-operator-in-a-deep-learning-framework-60d404750cb1?source=collection_archive---------10-----------------------#2022-06-24">https://medium.com/codex/the-journey-of-an-operator-in-a-deep-learning-framework-60d404750cb1?source=collection_archive---------10-----------------------#2022-06-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/aa1367a5d0b130cde3b8eef4ccfaa8a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6fdyuVGol57-wTj8F3FNQ.jpeg"/></div></div></figure></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="d75c" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj"> <em class="jv">赵鲁阳写的；译自董、胡</em> </strong></p><blockquote class="jw jx jy"><p id="ce1e" class="ix iy jv iz b ja jb jc jd je jf jg jh jz jj jk jl ka jn jo jp kb jr js jt ju hb bi translated">上一篇文章<a class="ae kc" rel="noopener" href="/codex/the-execution-process-of-a-tensor-in-a-deep-learning-framework-a4d853645d5b">深度学习框架中一个张量的执行过程</a>已经介绍了<a class="ae kc" href="https://github.com/Oneflow-Inc/oneflow" rel="noopener ugc nofollow" target="_blank"> OneFlow </a>中一个张量的执行机制。在本文中，我们将以<code class="du kd ke kf kg b">output = flow.relu(input)</code>为例来说明一个op是如何在OneFlow中从Python执行到C++的。希望本文对深度学习框架的系统设计有所启发。</p></blockquote><p id="59c6" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">Op是operator的缩写。Ops是深度学习中的基本操作。用于各种类型的数值和张量运算的数百个op构成了深度学习框架。nn。Module是构建神经网络的模块，op是制作模块的原材料。</p><p id="849e" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">以演示网络为例:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="6bab" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">从结构上看，这个网络是由各种神经网络构成的。线性、ReLU和Softmax等模块。而这些nn。模块由matmul、relu和softmax等基本运算组成。</p><p id="6687" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在OneFlow中，现有的op如何完成从Python层到C++层的调用、流程和执行过程？</p><p id="f63d" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">本文将以<code class="du kd ke kf kg b">output = flow.relu(input)</code>为例，说明一个op从Python到C++的完整执行过程。分析将基于源代码进行。</p><p id="403e" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">下面的流程图说明了本文的结构:</p><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/dd644532b21e4c7830fe0d30f68bf6d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8FImLrMZy_aVNH_K"/></div></div></figure><h1 id="7c62" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">1.有约束力的</h1><p id="1be1" class="pw-post-body-paragraph ix iy hi iz b ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq lq js jt ju hb bi translated">通常，我们使用Python来构建网络、训练模型和调用函数。但是，这些函数通常只是Python层的一层包装器，底层实现由C++完成。Python绑定允许您从Python调用C++，并利用这两种语言的优势。</p><p id="62d8" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在深度学习框架的实现中，Python/C api和pybind11是实现绑定的两种实用方式。这两种方法都在OneFlow中使用。</p><ul class=""><li id="b6e8" class="lr ls hi iz b ja jb je jf ji lt jm lu jq lv ju lw lx ly lz bi translated"><code class="du kd ke kf kg b">oneflow/api/python/framework/tensor.cpp</code></li><li id="64ed" class="lr ls hi iz b ja ma je mb ji mc jm md jq me ju lw lx ly lz bi translated"><code class="du kd ke kf kg b">oneflow/api/python/framework/tensor_functions.cpp</code></li></ul><p id="5f82" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">上面代码中tensor.xxx的绑定方法有Python/C API；</p><ul class=""><li id="a484" class="lr ls hi iz b ja jb je jf ji lt jm lu jq lv ju lw lx ly lz bi translated"><code class="du kd ke kf kg b">oneflow/core/functional/functional_api.yaml</code></li></ul><p id="f991" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">上面代码中flow.xxx的绑定方法有pybind11有关Python/C api和pybind11的更多详细信息，请参考以下文档:</p><ul class=""><li id="6fde" class="lr ls hi iz b ja jb je jf ji lt jm lu jq lv ju lw lx ly lz bi translated"><a class="ae kc" href="https://docs.python.org/zh-cn/3.8/c-api/index.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/zh-cn/3.8/c-api/index.html</a></li><li id="524f" class="lr ls hi iz b ja ma je mb ji mc jm md jq me ju lw lx ly lz bi translated"><a class="ae kc" href="https://pybind11.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank">https://pybind11.readthedocs.io/en/stable/index.html</a></li></ul><p id="e311" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">回到flow.relu，Python层中调用的flow.relu的底层就是<code class="du kd ke kf kg b">python/oneflow/__init__.py</code>中定义的<code class="du kd ke kf kg b">oneflow._C.relu</code>，这里的<code class="du kd ke kf kg b">_C</code>表示它现在在底层C++层。和PyTorch类似，我们也定义了一套基于. yaml的接口导出和代码生成的规则，比如在<code class="du kd ke kf kg b">functional_api.yaml</code>中，我们可以看到relu的导出接口的函数签名:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="f859" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">如上面的代码所示，流。_C.relu接收两个参数，一个张量和一个布尔值。它和C++ Relu绑定在一起，函数返回值也是张量。编译OneFlow的时候，C++。h和。cpp文件将通过运行<code class="du kd ke kf kg b">tools/functional/generate_functional_api.py</code>的文件并解析<code class="du kd ke kf kg b">functional_api.yaml</code>动态生成:</p><ul class=""><li id="8529" class="lr ls hi iz b ja jb je jf ji lt jm lu jq lv ju lw lx ly lz bi translated">build/one flow/core/functional/functional _ API . YAML . h</li><li id="9a5a" class="lr ls hi iz b ja ma je mb ji mc jm md jq me ju lw lx ly lz bi translated">build/one flow/core/functional/functional _ API . YAML . CPP</li></ul><p id="340a" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">此外，对应的函子在。将调用cpp文件来完成C++级别的函数调用。</p><p id="55b0" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">走心流。_C.relu为例，其对应的函子定义位于<code class="du kd ke kf kg b">oneflow/core/functional/impl/activation_functor.cpp</code>:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="15f0" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">ReluFunctor通过下面的代码完成了函子的注册。注册为功能接口后，流。_C.relu被绑定到python层的“relu”。同时，这个函数也可以在C++中通过functional::Relu直接调用。</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><h1 id="b677" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">2.函子</h1><p id="0d79" class="pw-post-body-paragraph ix iy hi iz b ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq lq js jt ju hb bi translated">函子是将Python扩展到C++的核心，也是调用ops和对输入参数进行推导和检查的第一步。通常，ops不仅需要在函子层检查输入张量的形状、数据类型、维数和元素个数，还需要解析和处理ops的特定逻辑。</p><p id="ddbd" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">Relu函子的代码如下:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="d25c" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">ReluFunctor定义了一个由OpBuilder构造的私有变量<code class="du kd ke kf kg b">std::shared_ptr&lt;OpExpr&gt; op_;</code>，这个op_就是需要执行的relu op。根据inplace=True还是False，仿函数运算符()的内部进入两个不同的分支。而op、输入张量和参数是通过OpInterpUtil::Dispatch()分派给解释器的。</p><h1 id="5df0" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">3.派遣</h1><p id="17dd" class="pw-post-body-paragraph ix iy hi iz b ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq lq js jt ju hb bi translated">在函子中完成检查和逻辑处理后，大部分op都需要通过OpInterpUtil::Dispatch()进行调度，目的地是解释器，op将在这里进行进一步的处理。</p><p id="b52f" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><code class="du kd ke kf kg b">oneflow/core/framework/op_interpreter/op_interpreter_util.h</code>中有各种超载的调度模板:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="cae4" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">这些重载函数的参数包括input、output、OpExprInterpContext等。OpExprInterpContext是解释器中op所需的上下文，它应该携带op所需的属性(如conv2d op所需的<em class="jv"> kernel_size </em>和<em class="jv"> padding </em>)、device、sbp和parallel等描述信息。</p><p id="2d08" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">这些过载的调度函数最终将运行到:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="bacf" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">下一站是口译员。</p><h1 id="e6cc" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">4.解释者</h1><h2 id="0985" class="mf kp hi bd kq mg mh mi ku mj mk ml ky ji mm mn lc jm mo mp lg jq mq mr lk ms bi translated">获取解释器</h2><p id="c041" class="pw-post-body-paragraph ix iy hi iz b ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq lq js jt ju hb bi translated">从字面上看，GetInterpreter的意思是获取后续执行op所需的解释器，下面是代码的精简版本(省略了与“check”相关的逻辑)<code class="du kd ke kf kg b">oneflow/core/framework/op_interpreter/op_interpreter_util.cpp</code>:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="5d5c" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">从上面可以看出，口译员大致可以分为两种:渴望型口译员和懒惰型口译员。此外，还可以根据是快速镜像的还是快速一致的来细分快速解释器。</p><p id="2aca" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">总而言之，我们有以下三种类型的子类实现:</p><ul class=""><li id="bc05" class="lr ls hi iz b ja jb je jf ji lt jm lu jq lv ju lw lx ly lz bi translated">EagerMirroredInterpreter</li><li id="d147" class="lr ls hi iz b ja ma je mb ji mc jm md jq me ju lw lx ly lz bi translated">EagerConsistentInterpreter</li><li id="d84b" class="lr ls hi iz b ja ma je mb ji mc jm md jq me ju lw lx ly lz bi translated">激光判读仪</li></ul><p id="bdb9" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在常规的eager模式下(无论是单GPU训练还是DDP训练)，您都需要遵循EagerMirroredInterpreter逻辑；否则，如果您已经为输入张量设置了SBP和位置，您将需要遵循EagerConsistentInterpreter逻辑；在懒惰模式下(使用nn。Graph)，您将需要遵循LazyInterpreter逻辑。</p><p id="3468" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在让我们看看这三种类型的解释器是如何构建的:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="6eb9" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">如你所见，这三种类型的解释器将被用作“内部”变量(私有变量)来构建一个AutogradInterpreter，并最终返回一个AutogradInterpreter。</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><h2 id="82d0" class="mf kp hi bd kq mg mh mi ku mj mk ml ky ji mm mn lc jm mo mp lg jq mq mr lk ms bi translated">应用()</h2><p id="aab5" class="pw-post-body-paragraph ix iy hi iz b ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq lq js jt ju hb bi translated">如上面的代码所示，EagerMirroredInterpreter、EagerConsistentInterpreter、LazyInterpreter将被打包成一个AutogradInterpreter，以触发“Apply”的调用。顾名思义，一个亲笔签名的解释者所扮演的角色与亲笔签名密切相关。它主要是为前向传播中的op节点增加相应的通过反向传播计算梯度的节点。</p><p id="369e" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">代码如下(提供了关键部分的注释):</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="f8f0" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">唷，这对你来说太多了，对吗？但是不用担心。简单来说，你只需要关注这一部分:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="f653" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在让我们回到前面提到的flow.relu的例子。由于它处于一种渴望模式，我们将需要使用EagerInterpreter的Apply()方法。</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="d4c7" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">通过为APPLY_IF定义一个宏，我们为不同类型的ops添加了分支处理。其中，UserOp是我们的用户最常用的类型，这意味着他们最有可能进入这个分支:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="9192" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在我们来看看EagerMirroredInterpreter::ApplyImpl。就是这里:<code class="du kd ke kf kg b">oneflow/core/framework/op_interpreter/eager_mirrored_op_interpreter.cpp</code>；</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="47ba" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">最终实现是NaiveInterpret。</p><h2 id="b8f4" class="mf kp hi bd kq mg mh mi ku mj mk ml ky ji mm mn lc jm mo mp lg jq mq mr lk ms bi translated">天真地解释</h2><p id="17f0" class="pw-post-body-paragraph ix iy hi iz b ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq lq js jt ju hb bi translated">简单地说，NaiveInterpret用于以下目的:</p><ul class=""><li id="a0a3" class="lr ls hi iz b ja jb je jf ji lt jm lu jq lv ju lw lx ly lz bi translated">检查输入张量的设备是否与默认设备相同</li><li id="3cce" class="lr ls hi iz b ja ma je mb ji mc jm md jq me ju lw lx ly lz bi translated">创建输出张量</li><li id="66ed" class="lr ls hi iz b ja ma je mb ji mc jm md jq me ju lw lx ly lz bi translated">推导并检查输出张量的形状/步幅/数据类型</li><li id="84ff" class="lr ls hi iz b ja ma je mb ji mc jm md jq me ju lw lx ly lz bi translated">构建op执行指令，并将它们分派给虚拟机(VM)</li></ul><p id="dd82" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">下面是代码的简化版本:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="09bb" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">如您所见，VM是解释器的目的地。OneFlow有其独特的VM设计，这也值得一提。但是为了便于理解，我就这么说吧:</p><p id="4b3e" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">在VM接收到分派的指令后，op将在任务队列中等待调度和执行。</p><h1 id="6a88" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">5.计算</h1><p id="6b1d" class="pw-post-body-paragraph ix iy hi iz b ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq lq js jt ju hb bi translated">由解释器分派给VM的op执行指令将由VM中的调度逻辑处理。然后指令将在<code class="du kd ke kf kg b">oneflow/core/eager/opkernel_instruction_type.cpp</code>中被触发并执行。</p><p id="d615" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">核心代码如下:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="34bd" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">上面这行代码会触发op内核的执行:<code class="du kd ke kf kg b">operand-&gt;user_opkernel()-&gt;Compute(compute_ctx, state, cache);</code></p><p id="daee" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">通常，基于不同的设备，操作内核将被分配到不同的实现，通常是<code class="du kd ke kf kg b">oneflow/user/kernels/xxx_kernel.cpp</code>或<code class="du kd ke kf kg b">oneflow/user/kernels/xxx_kernel.cu</code>。</p><p id="abd3" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">然而，ReLU op是一个例外，因为它是由原语实现的。(OneFlow也有其独特的原语，具有良好的抽象性和可组合性。)例如，下面的一元基元是elementwise一元模板和一元函数的组合。一元本原的痕迹如下:</p><figure class="kh ki kj kk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/1987972c50cce5bb2236eed4e38701a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6nioLquWChI7OMJ5"/></div></div></figure><h2 id="e92e" class="mf kp hi bd kq mg mh mi ku mj mk ml ky ji mm mn lc jm mo mp lg jq mq mr lk ms bi translated">一元原始核</h2><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><h2 id="882d" class="mf kp hi bd kq mg mh mi ku mj mk ml ky ji mm mn lc jm mo mp lg jq mq mr lk ms bi translated">原始的</h2><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><h2 id="8f20" class="mf kp hi bd kq mg mh mi ku mj mk ml ky ji mm mn lc jm mo mp lg jq mq mr lk ms bi translated">一元函数</h2><p id="66e5" class="pw-post-body-paragraph ix iy hi iz b ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq lq js jt ju hb bi translated">一元函数为每个一元运算类型呈现一个特定的函数实现。例如，ReLU op的仿函数实现如下:</p><p id="19bb" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><code class="du kd ke kf kg b">oneflow/core/ep/common/primitive/unary_functor.h</code>:</p><figure class="kh ki kj kk fd ij"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="5913" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在，我们已经走过了一个op的Python -&gt; C++之旅。</p><p id="c2e1" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">你可能会发现细节复杂得吓人，但如果你把它放大，看到大图，你会意识到这只是一个简单的四步过程:</p><p id="679b" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">函子- &gt;分派- &gt;解释器- &gt;内核计算</strong></p><p id="61fa" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">通常，实现/添加一个op，不需要太注意中间步骤，即“分派”和“解释器”。您可以只关注与op密切相关的内容，即仿函数步骤中的参数和op逻辑检查，以及内核计算步骤中的op计算。</p><h1 id="5e5f" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">参考</h1><p id="ce4f" class="pw-post-body-paragraph ix iy hi iz b ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq lq js jt ju hb bi translated">OneFlow源代码:</p><p id="cc3e" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><a class="ae kc" href="https://github.com/Oneflow-Inc/oneflow/commit/1dbdf8faed988fa7fd1a9034a4d79d5caf18512d" rel="noopener ugc nofollow" target="_blank">https://github.com/Oneflow-Inc/oneflow</a></p></div><div class="ab cl iq ir gp is" role="separator"><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv iw"/><span class="it bw bk iu iv"/></div><div class="hb hc hd he hf"><p id="bf1e" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">T3】相关文章:T5】</strong></p><ol class=""><li id="62df" class="lr ls hi iz b ja jb je jf ji lt jm lu jq lv ju mu lx ly lz bi translated"><a class="ae kc" href="https://oneflow2020.medium.com/how-to-derive-ring-all-reduces-mathematical-property-step-by-step-9951500db96" rel="noopener"> <strong class="iz hj"> <em class="jv">如何逐步推导环全归约的数学性质</em> </strong> </a></li><li id="aeeb" class="lr ls hi iz b ja ma je mb ji mc jm md jq me ju mu lx ly lz bi translated"><a class="ae kc" href="https://oneflow2020.medium.com/how-to-increase-computational-efficiency-for-prelu-in-cuda-oneflow-performance-optimization-20e6e336b8b8" rel="noopener"> <strong class="iz hj"> <em class="jv">如何提高CUDA中PReLU的计算效率— OneFlow性能优化</em> </strong> </a></li></ol><p id="431c" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><em class="jv">欢迎访问OneFlow on</em><strong class="iz hj"><em class="jv"/></strong><a class="ae kc" href="https://github.com/Oneflow-Inc/oneflow" rel="noopener ugc nofollow" target="_blank"><strong class="iz hj"><em class="jv">GitHub</em></strong></a><strong class="iz hj"><em class="jv"/></strong><em class="jv">并关注我们on</em><strong class="iz hj"><em class="jv"/></strong><a class="ae kc" href="https://twitter.com/home" rel="noopener ugc nofollow" target="_blank"><strong class="iz hj"><em class="jv">Twitter</em></strong></a><strong class="iz hj"><em class="jv"/></strong><em class="jv">和</em> <strong class="iz hj"> 【T5 </strong></p><p id="80af" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">还有，欢迎加入我们的<a class="ae kc" href="https://discord.gg/4kpjGA5bZY" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj"> <em class="jv">不和谐群</em></strong></a><strong class="iz hj"><em class="jv"/></strong>讨论和提问OneFlow相关问题，与OneFlow贡献者和全球用户联系。</p></div></div>    
</body>
</html>