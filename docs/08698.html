<html>
<head>
<title>How does Dijkstra’s Algorithm work? Easy explanation in Less than 5 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dijkstra的算法是如何工作的？不到5分钟的简单解释</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-does-dijkstras-algorithm-work-easy-explanation-in-less-than-5-minutes-e27f46795c18?source=collection_archive---------0-----------------------#2022-08-27">https://medium.com/codex/how-does-dijkstras-algorithm-work-easy-explanation-in-less-than-5-minutes-e27f46795c18?source=collection_archive---------0-----------------------#2022-08-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bc2bf600967c2221677f1b2b1c3aad57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mUTzPbcN-rrFbKi6ivYmbw.jpeg"/></div></div></figure><p id="349d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">目前，我正在完成我的计算机科学学位。如果我想获得我的头衔，我必须通过的科目之一是“<strong class="is hj">非线性数据结构</strong>”。在这个主题中，我学习了<strong class="is hj">树</strong>和<strong class="is hj">图</strong>以及一些与两者相关的算法(Dijkstra、Floyd、Prim和Kruskal)。老实说，我一直认为我的教授用一种非常复杂的方式解释这些算法。由于这个原因，我在课堂上从来没有正确理解过它们，我不得不在业余时间大量学习来理解这些算法。</p><p id="4c7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了纠正我过去收到的不好的解释，今天我将<strong class="is hj">以一种非常非常简单的方式</strong>解释Dijkstra算法。如果你知道什么是图，你就会理解这个算法。所以，如果你想<strong class="is hj">找到一个图的两个顶点之间的最短路径</strong>，这篇文章就是为你准备的。</p><p id="040c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">免责声明在阅读</strong> : <em class="jo">在这篇文章里面，你会找到关于一个图算法的信息。我假设你知道什么是图，以及图的元素，并且你有关于图和数据结构的最低限度的知识。如果你没有，不用担心，我以后会把这些概念都解释清楚。</em></p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h2 id="618d" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq bi translated">这个算法的真实例子</h2><p id="f793" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">我不喜欢解释任何人需要的东西。出于这个原因，让我向您展示一个Dijkstra算法的真实例子，让您想了解它。</p><p id="eb47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设你是谷歌地图开发项目中的一名谷歌工程师。您想要部署一个包含在<strong class="is hj">模式中的新特性，在该模式中，用户可以找到两个城市之间的最短路线</strong>。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c73ba2aad6723254358c51b4531cfe32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2VovHKDL-CL7-JgDZYiag.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">谷歌地图示例</figcaption></figure><p id="80eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了在地图上表示所有的城市，你可以使用一个<strong class="is hj">图</strong>(因为城市之间没有等级或顺序)。实现这个新特性的问题是如何找到用户选择的两个城市之间的最短路线。为此，您将使用<strong class="is hj"> Dijkstra的算法</strong>。</p><h1 id="b574" class="le jx hi bd jy lf lg lh kc li lj lk kg ll lm ln kj lo lp lq km lr ls lt kp lu bi translated">Dijkstra的算法是什么？</h1><p id="cede" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">首先，我们必须知道这个算法是什么，它的目的是什么。</p><p id="b7c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Dijkstra算法</strong>是一种在<strong class="is hj">图</strong>中使用的算法(一组我们可以给出问题解决方案的指令)。它是埃德格在1956年构思的。w DijkstraT27】解决图中节点间最短路径的问题。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/654ec5fa0c65a983e54f01e07bb61087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w5sM-uUqEKS2G-vWo-493w.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated"><a class="ae lv" href="https://www.programiz.com/dsa/dijkstra-algorithm#:~:text=Dijkstra's%20Algorithm%20works%20on%20the,between%20vertices%20B%20and%20D.&amp;text=Djikstra%20used%20this%20property%20in,vertex%20from%20the%20starting%20vertex." rel="noopener ugc nofollow" target="_blank">编程加权图</a></figcaption></figure><p id="7167" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如今，这种算法有多种变体。最初的目的是我之前提到的，但是常见的变体(我今天将解释)<strong class="is hj">将单个节点固定为<em class="jo">起点</em>，并且它在图中找到从该起点到所有其他节点的最短路径</strong>。</p><p id="247e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，例如，如果我们只想走去一个城市的最短路径，我们只需访问数据结构中用于表示算法返回的元素。如果我们使用一个数组，我们可以用最小距离[A]获得原点和A之间的最短路径。</p><h1 id="4932" class="le jx hi bd jy lf lg lh kc li lj lk kg ll lm ln kj lo lp lq km lr ls lt kp lu bi translated">算法的伪代码</h1><pre class="kw kx ky kz fd lx ly lz ma aw mb bi"><span id="c0f8" class="jw jx hi ly b fi mc md l me mf"><strong class="ly hj">function</strong> Dijkstra(<em class="jo">Graph</em>, <em class="jo">source</em>)     <br/>     <strong class="ly hj">for each</strong> vertex <em class="jo">v</em> in <em class="jo">Graph.Vertices</em>:<br/>         dist[<em class="jo">v</em>] ← INFINITY<br/>         prev[<em class="jo">v</em>] ← UNDEFINED<br/>         add <em class="jo">v</em> to <em class="jo">Q</em><br/>     dist[<em class="jo">source</em>] ← 0<br/>     <br/>     <strong class="ly hj">while</strong> <em class="jo">Q</em> is not empty:<br/>          <em class="jo">u</em> ← vertex in <em class="jo">Q</em> with min dist[u]<br/>          remove u from <em class="jo">Q</em><br/>   <br/>          <strong class="ly hj">for each</strong> neighbor <em class="jo">v</em> of <em class="jo">u</em> still in <em class="jo">Q</em>:<br/>              <em class="jo">alt</em> ← dist[<em class="jo">u</em>] + Graph.Edges(<em class="jo">u</em>, <em class="jo">v</em>)<br/>              <strong class="ly hj">if</strong> <em class="jo">alt</em> &lt; dist[<em class="jo">v</em>]:<br/>                  dist[<em class="jo">v</em>] ← <em class="jo">alt</em><br/>                  prev[<em class="jo">v</em>] ← <em class="jo">u</em><br/><br/>      <strong class="ly hj">return</strong> dist[], prev[]</span></pre><p id="f388" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该算法使用一种<a class="ae lv" href="https://www.programiz.com/dsa/greedy-algorithm#:~:text=A%20greedy%20algorithm%20is%20an,if%20the%20choice%20is%20wrong." rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">贪婪方法</strong> </a>(因此在负权重下无法正确工作)来获得最佳解决方案。</p><p id="f7ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以用很多不同的方法实现它:返回一个数组，使用一个优先级队列，优化无限图，只获得到一个指定顶点的距离…</p><h1 id="479e" class="le jx hi bd jy lf lg lh kc li lj lk kg ll lm ln kj lo lp lq km lr ls lt kp lu bi translated">Dijkstra的算法是如何工作的？</h1><p id="8074" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">概括地说，该算法…</p><ol class=""><li id="4395" class="mg mh hi is b it iu ix iy jb mi jf mj jj mk jn ml mm mn mo bi translated"><strong class="is hj">从我们作为参数给出的节点</strong>开始，它<strong class="is hj">将返回该节点和图中所有其他节点</strong>(或顶点)之间的最短路径。</li><li id="4daf" class="mg mh hi is b it mp ix mq jb mr jf ms jj mt jn ml mm mn mo bi translated"><strong class="is hj">计算从每个节点到源节点的最短距离，如果发现比之前保存的路径更短的路径，则保存该值</strong>。它计算一个节点和源节点之间的距离，如果这个距离小于它以前保存的距离，新的最小距离将是新的距离。</li><li id="d6de" class="mg mh hi is b it mp ix mq jb mr jf ms jj mt jn ml mm mn mo bi translated">一旦Dijkstra的算法找到了源节点和另一个节点之间的最短路径，<strong class="is hj">它将该节点标记为已访问过</strong>(如果没有找到，该算法将进入无限循环)。</li><li id="e1e6" class="mg mh hi is b it mp ix mq jb mr jf ms jj mt jn ml mm mn mo bi translated"><strong class="is hj">重复步骤2和3，直到访问完所有节点</strong>。这样，我们已经访问了所有节点，并保存了到达每个节点的最短路径。</li></ol><p id="5fe2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想知道如何用特定的语言实现这个算法，你可以在互联网上搜索。算法在<a class="ae lv" href="https://www.programiz.com/dsa/dijkstra-algorithm#:~:text=Dijkstra's%20Algorithm%20works%20on%20the,between%20vertices%20B%20and%20D.&amp;text=Djikstra%20used%20this%20property%20in,vertex%20from%20the%20starting%20vertex." rel="noopener ugc nofollow" target="_blank">很多网站</a>上实现(以优化和未优化的方式)。</p><h1 id="9f2c" class="le jx hi bd jy lf lg lh kc li lj lk kg ll lm ln kj lo lp lq km lr ls lt kp lu bi translated">Dijkstra算法复杂性</h1><p id="f429" class="pw-post-body-paragraph iq ir hi is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hb bi translated">虽然复杂度可以根据实现来提高，但是看到我上面提供的伪代码，算法的时间复杂度是<strong class="is hj"> O(n ) </strong>是n个顶点。以及空间复杂度<strong class="is hj"> O(n)。</strong></p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><p id="a21e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">综上所述，<strong class="is hj"> Dijkstra的算法取一个原始节点，并返回该节点与图中其他节点之间的最短路径(可以用向量、树……来表示)</strong>。我们已经基本理解了这个算法是如何工作的，我们知道使用它的目的。如果我们想实现它，我们可以在互联网上搜索代码，或者我们可以尝试自己实现它(我不建议这样做，这太痛苦了)。如果你有任何疑问，请在下面的评论中告诉我。</p><p id="56b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">你以前知道这个算法吗？你在任何时候都使用图表吗？</em></p></div></div>    
</body>
</html>