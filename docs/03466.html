<html>
<head>
<title>Understanding Java Functional Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Java函数接口</h1>
<blockquote>原文：<a href="https://medium.com/codex/understanding-java-functional-interfaces-d028b04c15d0?source=collection_archive---------7-----------------------#2021-09-04">https://medium.com/codex/understanding-java-functional-interfaces-d028b04c15d0?source=collection_archive---------7-----------------------#2021-09-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="462c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">下面是功能接口的类型和细节。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/4ede88a375d2dafb8a8b39c50a4968c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AEyqWIg8lDue_Zej"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">由<a class="ae jn" href="https://unsplash.com/@kikisad?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">基利安·卡蒂涅斯</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="cce0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当lambda <br/>表达式或方法引用作为参数传递给方法时，函数接口是用于参数的类型。</p><h2 id="d776" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">兰姆达斯是什么？</h2><p id="74e4" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">Lambdas是简洁表达的单一方法类，表示Java 8中引入的行为。它们既可以赋给变量，也可以传递给其他方法，就像我们将数据作为参数传递一样。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="75a2" class="kk kl hi ll b fi lp lq l lr ls">// Concatenating strings<br/>(String s1, String s2) -&gt; s1+s2;</span></pre><p id="776a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就像普通的Java方法一样，lambda表达式有可选的输入参数、主体和可选的返回值。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="06e2" class="kk kl hi ll b fi lp lq l lr ls">input-arguments -&gt; body</span></pre><h2 id="112c" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">拉姆达类型</h2><p id="2412" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">你可能想知道这些表达式的类型是什么。由于Java是一种强类型语言，通常必须声明类型；否则，编译器会嘲笑我们。然而，我们在声明上述lambda表达式时省略了类型。那么，lambda表达式的类型是什么？它是字符串、对象还是新的函数类型？任何lambda的类型都是一个<em class="lt">功能接口。</em></p><h2 id="e25a" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">界面与功能界面</h2><p id="7312" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">接口是没有实现所有方法的类，所以使用接口的人必须实现逻辑。随着Java 8的引入，这个定义已经改变，现在接口可以将实现逻辑作为默认方法，也就是说，我们可以给出一个默认的实现，其他人可以在需要时覆盖它们。Java 8还引入了另一种拥有未实现方法的方式，称为静态方法。</p><p id="a3ef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Functional Interface是Java接口的变体，其中只允许一个未实现的(抽象)方法，而允许任意数量的默认和静态方法。可选地，它可以用可选的<code class="du lu lv lw ll b">@FunctionalInterface</code>注释来修饰。这允许编译器在带注释的接口不满足条件时生成错误。</p><h2 id="34da" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">样品</h2><p id="f756" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">让我们创建一个如下的功能界面:</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="d07a" class="kk kl hi ll b fi lp lq l lr ls">@FunctionalInterface<br/>interface IAddable&lt;T&gt; {<br/>    <em class="lt">// To add two objects<br/>    </em>public T add(T t1, T t2);<br/>}</span></pre><p id="8a84" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们可以使用它了</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="4f75" class="kk kl hi ll b fi lp lq l lr ls">IAddable&lt;String&gt; iAddable = (t1, t2) -&gt; t1+" "+t2+"!";<br/>System.<em class="lt">out</em>.println(iAddable.add("Hi","There"));<br/><br/>IAddable&lt;Integer&gt; integerIAddable = (t1, t2) -&gt; t1+t2;<br/>System.<em class="lt">out</em>.println(integerIAddable.add(3,5));</span><span id="c49b" class="kk kl hi ll b fi lx lq l lr ls">//Output<br/>//Hi There !<br/>//8</span></pre><p id="cb36" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">重要的是，现在您可以从类实现中移除业务逻辑，并作为参数传递。</p><h2 id="92b0" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">匿名类</h2><p id="4e59" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">如果我们不使用lambda，事情会变得多么混乱。技术垃圾遮蔽了业务逻辑。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="a23d" class="kk kl hi ll b fi lp lq l lr ls">IAddable&lt;String&gt; stringIAddable = new IAddable&lt;String&gt;() {<br/>    @Override<br/>    public String add(String t1, String t2) {<br/>        return t1+t2;<br/>    }<br/>};</span></pre><h2 id="7ff7" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">Lambda表达式与内部/匿名类</h2><p id="231b" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">当我们使用内部类时，它创建了一个新的作用域。可以通过实例化同名的新局部变量来隐藏封闭范围内的局部变量。关键字<strong class="jq hj"> <em class="lt">这个</em> </strong>在我们的内部类里面可以作为对它的实例的引用。</p><p id="296f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，Lambda表达式使用封闭范围。无法隐藏lambda主体内封闭范围的变量。在这种情况下，关键字<strong class="jq hj"> <em class="lt"> this </em> </strong>是对封闭实例的引用。</p><h2 id="779e" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">Java现在是智能的</h2><p id="1523" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">即使我们没有用lambda发送任何类型的信息，java也会根据分配的变量识别类型，下面是一个字符串而不是整数。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="9878" class="kk kl hi ll b fi lp lq l lr ls">IAddable&lt;String&gt; iAddable = (t1, t2) -&gt; t1+" "+t2+"!";</span></pre><p id="411d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">输入类型将由左边的类型决定，方法的返回类型由方法决定。</p><h1 id="9144" class="ly kl hi bd km lz ma mb kq mc md me ku io mf ip kx ir mg is la iu mh iv ld mi bi translated">内置功能接口</h1><p id="9958" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">你可能认为我们需要一个新的函数类型来表示这种表达式。取而代之的是，Java设计者巧妙地利用现有的接口和一个单一的抽象方法作为lambda的类型，这就是所谓的函数接口。并将它们存储在一个名为<code class="du lu lv lw ll b">java.util.function</code>的库中</p><p id="bc12" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Java定义了许多类型的函数接口，在这里阅读:</p><div class="mj mk ez fb ml mm"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hj fi z dy mr ea eb ms ed ef hh bi translated">java.util.function (Java平台SE 8)</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">函数接口为lambda表达式和方法引用提供目标类型。每个功能界面都有…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">docs.oracle.com</p></div></div></div></a></div><p id="cc6d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Java函数接口是一个标准，在这里你可以定义你自己的函数接口。需要时，您可以使用自己的功能接口。</p><h2 id="2c53" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">关键功能界面</h2><p id="823e" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">java提供的函数接口对我们来说很少是重要的。让我们看一看。</p><h2 id="8987" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">1.述语</h2><p id="3c7d" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">检查条件并返回布尔值。输入可以是任何类型。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="4633" class="kk kl hi ll b fi lp lq l lr ls">@FunctionalInterface<br/>public interface Predicate&lt;T&gt; {<br/>  boolean test(T t);<br/>}</span></pre><p id="1118" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以用这个来检查一个字符串是空的还是不是这样:</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="0c17" class="kk kl hi ll b fi lp lq l lr ls">Predicate&lt;String&gt; stringPredicate= s -&gt; s.isEmpty();<br/>System.<em class="lt">out</em>.println(stringPredicate.test("nuwan"));<br/>//Output: false</span></pre><h2 id="1ad1" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">2.功能</h2><p id="fb2b" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">Function接口表示接受单个参数并返回单个值的函数(方法)。这将接受类型T并返回类型r。可以在方法内进行数据转换。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="959a" class="kk kl hi ll b fi lp lq l lr ls">@FunctionalInterface<br/>public interface Function&lt;T, R&gt; {<br/>  R apply(T t);<br/>}</span></pre><p id="0942" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下面将把一个整数转换成一个字符串。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="f109" class="kk kl hi ll b fi lp lq l lr ls">Function&lt;String,Integer&gt; fun = s -&gt; Integer.<em class="lt">valueOf</em>(s);<br/>System.<em class="lt">out</em>.println(fun.apply("0001"));<br/>//Output: 1</span></pre><h2 id="62d9" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">3.消费者</h2><p id="4fff" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">使用者接受单个参数，但不返回任何结果:</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="48d0" class="kk kl hi ll b fi lp lq l lr ls">@FunctionalInterface<br/>public interface Consumer&lt;T&gt; {<br/>  void accept(T t);<br/>}</span></pre><p id="b189" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例子</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="aabd" class="kk kl hi ll b fi lp lq l lr ls">Consumer&lt;String&gt; consumer = o -&gt; System.<em class="lt">out</em>.println(o);<br/>consumer.accept("Use consumer interface");</span></pre><h2 id="ee61" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">4.供应者</h2><p id="1fac" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">不使用输入参数返回某些内容。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="7295" class="kk kl hi ll b fi lp lq l lr ls">@FunctionalInterface<br/>public interface Supplier&lt;T&gt; {<br/>  T get();<br/>}</span></pre><p id="5eef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例子</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="3c78" class="kk kl hi ll b fi lp lq l lr ls">Supplier&lt;String&gt; supplier = () -&gt;  "Return Something";<br/>System.<em class="lt">out</em>.println(supplier.get());</span></pre><h2 id="dac8" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">5.一元运算符</h2><p id="04ce" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">这采用单个参数并返回相同类型的参数。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="f345" class="kk kl hi ll b fi lp lq l lr ls">UnaryOperator&lt;String&gt; uo = s -&gt; s.toUpperCase();<br/>System.<em class="lt">out</em>.println(uo.apply("send lowercase"));<br/>//Output: SEND LOWERCASE</span></pre><h2 id="6714" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">6.二元运算符</h2><p id="8bf7" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">接受两个参数并返回一个值。参数和返回类型必须是同一类型。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="b317" class="kk kl hi ll b fi lp lq l lr ls">BinaryOperator&lt;String&gt; bo = (s, s2) -&gt; s+" - "+s2;<br/>System.<em class="lt">out</em>.println(bo.apply("Hi","There"));<br/>//Output: Hi - There</span></pre><h2 id="663b" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">两个自变量函数</h2><p id="01e6" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">我们上面讨论的函数是单输入或无参数函数，如果我们要使用两个参数作为输入，我们可以使用</p><ul class=""><li id="c99e" class="mv mw hi jq b jr js ju jv jx mx kb my kf mz kj na nb nc nd bi translated">双预测</li><li id="2abf" class="mv mw hi jq b jr ne ju nf jx ng kb nh kf ni kj na nb nc nd bi translated">双消费者</li><li id="0d68" class="mv mw hi jq b jr ne ju nf jx ng kb nh kf ni kj na nb nc nd bi translated">双功能</li></ul><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="4fbf" class="kk kl hi ll b fi lp lq l lr ls">@FunctionalInterface<br/>public interface BiFunction&lt;T, U, R&gt; {<br/>  R apply(T t, U u);<br/>}</span></pre><h2 id="01a5" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">原始函数专门化</h2><p id="cb07" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">由于基元类型不能是泛型类型实参，所以对于最常用的基元类型<em class="lt"> double </em>、<em class="lt"> int </em>、<em class="lt"> long </em>，以及它们在实参和返回类型中的组合，都有不同版本的<em class="lt">函数</em>接口。一般来说，建议使用更专业的形式来避免自动装箱。例如，<code class="du lu lv lw ll b">IntFunction&lt;Foo&gt;</code>应该优先于<code class="du lu lv lw ll b">Function&lt;Integer, Foo&gt;</code>。</p><h2 id="96bd" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">传统功能接口</h2><p id="5a9e" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">Java以前版本的许多接口都符合a <code class="du lu lv lw ll b"><em class="lt">FunctionalInterface</em></code>的约束，我们可以把它们当作lambdas来使用。突出的例子包括在并发API中使用的<code class="du lu lv lw ll b"><em class="lt">Runnable</em></code>和<code class="du lu lv lw ll b"><em class="lt">Callable</em></code>接口。</p><h2 id="9499" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">虚拟(默认)方法</h2><p id="3c1a" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">虽然lambdas被添加到语言中很好，但是如果它们不能用于现有的API，那么使用它们就没有意义了。为了支持将lambdas吸收到我们的库中，接口需要发展。也就是说，我们需要能够向已经发布的API添加额外的功能。</p><p id="060b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Java 8之前，接口是抽象的，你当然不能给它添加实现。然而，Java 8对此进行了改造，称之为虚拟方法。collections API就是这样一个例子，其中将lambdas引入到等式中彻底改变并增强了API。</p><p id="ec45" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">由于Java支持接口多重继承，相同的缺省方法可能会出现不止一次，在这种情况下，编译器会有麻烦，开发人员需要提供他们自己的实现来解决这个问题。</p><h2 id="bdb1" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">方法引用</h2><p id="e03c" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">方法引用是调用现有方法的快捷方式。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="9b00" class="kk kl hi ll b fi lp lq l lr ls">Consumer&lt;String&gt; consumer = <strong class="ll hj">o -&gt; System.<em class="lt">out</em>.println(o)</strong>;<br/>consumer.accept("Use consumer interface");</span></pre><p id="72cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的lambda表达式可以使用方法引用重写如下。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="f3ce" class="kk kl hi ll b fi lp lq l lr ls">Consumer&lt;String&gt; stringConsumer = <strong class="ll hj">System.<em class="lt">out</em>::println</strong>;<br/>consumer.accept("Use consumer interface");</span></pre><h2 id="4ded" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">目标类型</h2><p id="6d62" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">函数接口可以在多种上下文中提供目标类型，如赋值上下文、方法调用或强制转换上下文:</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="40c1" class="kk kl hi ll b fi lp lq l lr ls">     // Assignment context<br/>     Predicate&lt;String&gt; p = String::isEmpty;<br/><br/>     // Method invocation context<br/>     stream.filter(e -&gt; e.getSize() &gt; 10)...<br/><br/>     // Cast context<br/>     stream.map((ToIntFunction) e -&gt; e.getSize())...</span></pre><h2 id="3e7a" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">模式和最佳实践</h2><p id="e206" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">开发者在创建新的功能接口之前，应该先探索<a class="ae jn" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/package-summary.html" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">Java . util . function</strong></a>包。</p><p id="4e84" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用<a class="ae jn" href="http://twitter.com/FunctionalInterface" rel="noopener ugc nofollow" target="_blank"> @FunctionalInterface </a>注释来避免对接口的意外更改，以免违反功能接口标准。</p><p id="e083" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">向接口添加太多的默认方法不是一个很好的架构决策，用相同的默认方法扩展不同的功能接口可能会有问题。</p><p id="b183" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">避免重载以函数接口为参数的方法，要使用不同名称的方法，避免冲突。</p><p id="0a67" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">保持Lambda表达式简短且不言自明，使用单行结构而不是一大段代码。</p><p id="387e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">避免为Lambda指定参数类型，在大多数情况下，编译器能够解析类型。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="05af" class="kk kl hi ll b fi lp lq l lr ls">//Use this <br/>(a, b) -&gt; a.toLowerCase() + b.toLowerCase();<br/>//instead of this<br/>(String a, String b) -&gt; a.toLowerCase() + b.toLowerCase();</span></pre><p id="19ec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">避免在单个参数周围使用括号</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="5ed3" class="kk kl hi ll b fi lp lq l lr ls">a -&gt; a.toLowerCase();//YES<br/>(a) -&gt; a.toLowerCase();//NO</span></pre><p id="d8ef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">避免Return语句和大括号</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="af9c" class="kk kl hi ll b fi lp lq l lr ls">a -&gt; a.toLowerCase();//Yes<br/>a -&gt; {return a.toLowerCase()};//No</span></pre><p id="3611" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">尽可能使用方法引用</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="9a7d" class="kk kl hi ll b fi lp lq l lr ls">a -&gt; a.toLowerCase();//No<br/>String::toLowerCase;//Yes</span></pre><h2 id="9906" class="kk kl hi bd km kn ko kp kq kr ks kt ku jx kv kw kx kb ky kz la kf lb lc ld le bi translated">有效最终</h2><p id="ba0b" class="pw-post-body-paragraph jo jp hi jq b jr lf ij jt ju lg im jw jx lh jz ka kb li kd ke kf lj kh ki kj hb bi translated">对有效最终变量的限制禁止了对动态变化的局部变量的访问，这些变量的捕获可能会引入并发问题。</p><p id="86d0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用“有效的Final”变量，否则会导致编译时错误。这种方法使得lambda的执行是线程安全的。</p><p id="beab" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">即使变量不能改变，但是里面的变量可以改变，所以用Lambdas做并行计算的时候</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="943c" class="kk kl hi ll b fi lp lq l lr ls">//compile time error<br/>public void method() {<br/>    String localVariable = "Local";<br/>    Foo foo = parameter -&gt; {<br/>        String localVariable = parameter;<br/>        return localVariable;<br/>    };<br/>}</span></pre><p id="bfc3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是这是可能的</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="b54d" class="kk kl hi ll b fi lp lq l lr ls">int[] total = new int[1];<br/>Runnable r = () -&gt; total[0]++;<br/>r.run();</span></pre><p id="7166" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">参考:</p><p id="2cf2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="https://www.oreilly.com/content/whats-new-in-java-8-lambdas/" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/content/whats-new-in-Java-8-lambdas/</a><br/><a class="ae jn" href="https://www.oreilly.com/content/java-8-functional-interfaces/" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/content/Java-8-functional-interfaces/</a><br/><a class="ae jn" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/8/docs/API/Java/util/function/package-summary . html</a><br/><a class="ae jn" href="https://www.baeldung.com/java-8-lambda-expressions-tips" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-8-lambda-expressions-tips</a></p></div></div>    
</body>
</html>