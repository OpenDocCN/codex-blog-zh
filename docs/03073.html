<html>
<head>
<title>Clean Code — Formatting (Summary)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">清除代码—格式化(摘要)</h1>
<blockquote>原文：<a href="https://medium.com/codex/clean-code-formatting-summary-9a475ba10ac8?source=collection_archive---------13-----------------------#2021-08-17">https://medium.com/codex/clean-code-formatting-summary-9a475ba10ac8?source=collection_archive---------13-----------------------#2021-08-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1372b4250a05aa6f54d1dbbe52fd05f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2xLG6LdqapMRIeOS"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">阿里萨·查塔萨在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="iv"><p id="49cd" class="iw ix hi bd iy iz ja jb jc jd je jf dx translated">代码格式很重要。它与沟通有关，而沟通是专业开发人员的首要任务。</p></blockquote><h1 id="bd55" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd bi translated">垂直格式</h1><h2 id="a7c3" class="ke jh hi bd ji kf kg kh jm ki kj kk jq kl km kn ju ko kp kq jy kr ks kt kc ku bi translated">报纸隐喻</h2><p id="3e61" class="pw-post-body-paragraph kv kw hi kx b ky kz la lb lc ld le lf kl lg lh li ko lj lk ll kr lm ln lo jf hb bi translated">想一篇写得很好的报纸文章。你垂直阅读它。在顶部，你期待一个能告诉你故事内容的标题。第一段给了你整个故事的梗概。继续往下，细节会增加，直到你有了所有的日期、名字、引用、声明和其他细节。</p><p id="87c3" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">和报纸一样，你应该有一个写得很好的代码。名称应该足以告诉我们是否在正确的模块中。源文件的最上面部分应该提供高层次的概念和算法。随着我们向下移动，细节应该增加，直到最后我们在源文件中找到最低级别的函数和细节。</p><h2 id="ab15" class="ke jh hi bd ji kf kg kh jm ki kj kk jq kl km kn ju ko kp kq jy kr ks kt kc ku bi translated">概念之间的纵向开放性</h2><p id="0c0a" class="pw-post-body-paragraph kv kw hi kx b ky kz la lb lc ld le lf kl lg lh li ko lj lk ll kr lm ln lo jf hb bi translated">每行代表一个表达式或一个子句，每组行代表一个完整的思想。你应该用空行把每一个想法分开。了解不同之处:</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/8a84534f20822a811ca1893005e442de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJyeSK8GkwPn4niM7lrdnw.png"/></div></div></figure><p id="9f81" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">随着</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/3b4cabe311fae7e78278208e750432b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DDb_BqG6OvyjoofSoer8RQ.png"/></div></div></figure><p id="4019" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">哪个代码可读性更好？</p><h2 id="9855" class="ke jh hi bd ji kf kg kh jm ki kj kk jq kl km kn ju ko kp kq jy kr ks kt kc ku bi translated">垂直密度</h2><p id="4da5" class="pw-post-body-paragraph kv kw hi kx b ky kz la lb lc ld le lf kl lg lh li ko lj lk ll kr lm ln lo jf hb bi translated">紧密相关的代码行应该看起来垂直密集(彼此靠近)。看到区别了吗:\</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/fcb16ec6b1c9897b1e9f01b476f49bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zW9FhbAnu7sDLpUcR0lhAQ.png"/></div></div></figure><p id="8b54" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">随着</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/628a360aa12364272cf12b7c8b34a785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bos7BHYW5ecFybhs7Tx3fg.png"/></div></div></figure><p id="0555" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">第一张图片有一些无用的评论，第二张图片更容易阅读，无需移动头部或眼睛。</p><h2 id="9c7b" class="ke jh hi bd ji kf kg kh jm ki kj kk jq kl km kn ju ko kp kq jy kr ks kt kc ku bi translated">垂直距离</h2><blockquote class="iv"><p id="51b6" class="iw ix hi bd iy iz mb mc md me mf jf dx translated">密切相关的概念应该在垂直方向上相互靠近</p></blockquote><p id="5704" class="pw-post-body-paragraph kv kw hi kx b ky mg la lb lc mh le lf kl mi lh li ko mj lk ll kr mk ln lo jf hb bi translated">执行上述规则有一些提示:</p><ol class=""><li id="4859" class="ml mm hi kx b ky lp lc lq kl mn ko mo kr mp jf mq mr ms mt bi translated"><strong class="kx hj">变量声明</strong>。变量的声明应该尽可能接近它们的用法，局部变量应该出现在每个函数的顶部。</li></ol><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/1a3460603c7fb4792e635fd4026d3093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*BP4xYPrmo2JEOpwxXjOU0Q.png"/></div></figure><p id="a5b0" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">循环的控制变量<strong class="kx hj">通常应该在循环语句</strong>中声明<strong class="kx hj"/></p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/c264dd0c0dc0d1233d176af32ac8e488.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*_M5seXxglXgCvLIkKgvTQg.png"/></div></figure><p id="ee04" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated"><strong class="kx hj">实例变量</strong>应该在类的顶部声明，因为它们被类的许多方法使用。关于实例变量该何去何从，有过很多争论。在C++中，通常把所有的实例变量放在底部。与Java不同的是，Java的惯例是把它们都放在类的顶部。但是重要的是实例变量要在<strong class="kx hj">一个众所周知的地方</strong>声明。</p><p id="20a2" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated"><strong class="kx hj">依赖函数。</strong>如果一个函数调用另一个函数，它们应该<strong class="kx hj">垂直靠近</strong>，调用方应该在被调用方之上<strong class="kx hj"/></p><p id="73ac" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated"><strong class="kx hj">概念一致性。</strong>如果一组功能执行相似的操作，共享共同的命名方案，并执行相同基本任务的变体。他们应该靠得很近。</p><h2 id="4598" class="ke jh hi bd ji kf kg kh jm ki kj kk jq kl km kn ju ko kp kq jy kr ks kt kc ku bi translated">垂直排序</h2><p id="11c5" class="pw-post-body-paragraph kv kw hi kx b ky kz la lb lc ld le lf kl lg lh li ko lj lk ll kr lm ln lo jf hb bi translated">被调用的函数应该在执行调用的函数之下。这创建了从高级到低级的源代码模块的良好流程。</p><h1 id="adfb" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr mw jt ju jv mx jx jy jz my kb kc kd bi translated">水平格式</h1><p id="d9bf" class="pw-post-body-paragraph kv kw hi kx b ky kz la lb lc ld le lf kl lg lh li ko lj lk ll kr lm ln lo jf hb bi translated">作者说，他过去常常遵循这样一条规则，即你永远不必向右滚动，并亲自将屏幕上的字符限制在120个。</p><h2 id="8729" class="ke jh hi bd ji kf kg kh jm ki kj kk jq kl km kn ju ko kp kq jy kr ks kt kc ku bi translated">横向开放度和密度</h2><p id="b6df" class="pw-post-body-paragraph kv kw hi kx b ky kz la lb lc ld le lf kl lg lh li ko lj lk ll kr lm ln lo jf hb bi translated">使用水平的<strong class="kx hj">空白</strong>来关联<strong class="kx hj">强相关</strong>的事物，并分离<strong class="kx hj">弱相关</strong>的事物。例如:</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/07a8841ee5b4ec604a09bd266359b9ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xseXjmLTXPzcWBOSCa_jQ.png"/></div></div></figure><p id="fb49" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">从上图看，作者有一些建议，重点是:</p><ul class=""><li id="0360" class="ml mm hi kx b ky lp lc lq kl mn ko mo kr mp jf na mr ms mt bi translated">用空格将赋值运算符括起来，以突出它们。空格使这种分离变得明显(<strong class="kx hj">弱相关</strong>)。</li><li id="3077" class="ml mm hi kx b ky nb lc nc kl nd ko ne kr nf jf na mr ms mt bi translated">不要在函数名和左括号之间加空格。把它们分开，让它们看起来是脱节的，而不是连体的(<strong class="kx hj">强相关</strong>)。</li><li id="e0ea" class="ml mm hi kx b ky nb lc nc kl nd ko ne kr nf jf na mr ms mt bi translated">分隔函数中的参数以强调逗号，并显示参数是独立的。</li></ul><p id="52d3" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">空白的另一个用途是强调运算符的<strong class="kx hj">优先级</strong>。例如:</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ng"><img src="../Images/377c5c1f6d058a760fe74417a529919b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QIoCyUjdZqTAYfF0HSAX0g.png"/></div></div></figure><p id="e137" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">这些因素在等式之间没有空格，因为它们具有高优先级。因为加法和减法的优先级<strong class="kx hj">比</strong>低，所以术语用空格<strong class="kx hj">分隔</strong>。</p><h2 id="1b3e" class="ke jh hi bd ji kf kg kh jm ki kj kk jq kl km kn ju ko kp kq jy kr ks kt kc ku bi translated">水平线向</h2><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/68a49aebcb505068609c23372c11bd50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFJEGVYYAlcN6RvTlWS52w.png"/></div></div></figure><p id="cdf1" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">水平校准<strong class="kx hj">无用</strong>。这种排列方式似乎<strong class="kx hj">强调了错误的东西</strong>，并且将视线从真正的意图上引开。上面的声明列表试图在不查看变量类型的情况下读取变量名列表。同样，赋值语句列表试图向下查看值列表，但从未看到赋值操作符。</p><p id="c7fc" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">不要对声明和赋值使用水平对齐，如下所示。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/133ac10624a9855fa027719cf5f40855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVD1mQrF0JleUlR-2BjC8Q.png"/></div></div></figure><h2 id="1aa0" class="ke jh hi bd ji kf kg kh jm ki kj kk jq kl km kn ju ko kp kq jy kr ks kt kc ku bi translated">刻痕</h2><p id="4407" class="pw-post-body-paragraph kv kw hi kx b ky kz la lb lc ld le lf kl lg lh li ko lj lk ll kr lm ln lo jf hb bi translated"><strong class="kx hj">按照源代码行在层次结构中的位置比例缩进</strong>源代码行，以使这个层次结构的作用域<strong class="kx hj">可见</strong>。遵循以下要点:</p><ul class=""><li id="ead3" class="ml mm hi kx b ky lp lc lq kl mn ko mo kr mp jf na mr ms mt bi translated">文件级的语句，如大多数类声明，根本不缩进。</li><li id="b1bf" class="ml mm hi kx b ky nb lc nc kl nd ko ne kr nf jf na mr ms mt bi translated">类中的方法在类的右边缩进一级。</li><li id="3652" class="ml mm hi kx b ky nb lc nc kl nd ko ne kr nf jf na mr ms mt bi translated">这些方法的实现在方法声明的右边缩进了一级。</li><li id="74a2" class="ml mm hi kx b ky nb lc nc kl nd ko ne kr nf jf na mr ms mt bi translated">块实现被<strong class="kx hj">缩进</strong>到其包含块的右边一级。</li></ul><p id="e4e6" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">考虑以下在语法和语义上完全相同的程序:</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/4e9d7182e14ed41ae02347b287a83124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h6YasHBmRsfQhVq256EmCQ.png"/></div></div></figure><p id="fd6d" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">随着</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/19021fc2dc7040ec4d148c5d64cf4791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CvbeGVZD-uPYQX6Rnrlmfg.png"/></div></div></figure><p id="a139" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">有时候，对于短的<code class="du nl nm nn no b">if</code>语句、短的<code class="du nl nm nn no b">while</code>循环或像这样的短函数，打破缩进规则是很诱人的:</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es np"><img src="../Images/d0864f841e4163232606549d945b8660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*loOjm2_Joi9oW4tRi-hI6A.png"/></div></div></figure><p id="f9b1" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">但是，尽可能尝试扩展和缩进范围，就像这样:</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nq"><img src="../Images/de37c9ea99d5628dbca834ffa8faf070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nNdL3IyVVeMHfPO9Jnk-rw.png"/></div></div></figure><h2 id="652e" class="ke jh hi bd ji kf kg kh jm ki kj kk jq kl km kn ju ko kp kq jy kr ks kt kc ku bi translated">虚拟示波器</h2><p id="9806" class="pw-post-body-paragraph kv kw hi kx b ky kz la lb lc ld le lf kl lg lh li ko lj lk ll kr lm ln lo jf hb bi translated">当你有一个while或for语句的伪体时，如下所示，要避免这种结构。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nr"><img src="../Images/ad1e5fbe4e3769b975861fa4abafa37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2CJmAgt8wPRgZILNsu02w.png"/></div></div></figure><h1 id="c9d5" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr mw jt ju jv mx jx jy jz my kb kc kd bi translated">团队规则</h1><blockquote class="iv"><p id="f728" class="iw ix hi bd iy iz mb mc md me mf jf dx translated">一个好的软件系统是由一组易读的文档组成的。他们需要有一致流畅的风格。</p></blockquote><p id="c432" class="pw-post-body-paragraph kv kw hi kx b ky mg la lb lc mh le lf kl mi lh li ko mj lk ll kr mk ln lo jf hb bi translated">一个开发团队应该就单一的格式样式达成一致，然后该团队的每个成员都应该使用该样式。目标是，软件要有一致的风格。</p><h1 id="edae" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr mw jt ju jv mx jx jy jz my kb kc kd bi translated">鲍勃叔叔的格式规则</h1><p id="5e46" class="pw-post-body-paragraph kv kw hi kx b ky kz la lb lc ld le lf kl lg lh li ko lj lk ll kr lm ln lo jf hb bi translated">请将此视为代码如何成为最佳编码标准文档的示例。</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ns"><img src="../Images/7e2011b4ca7ad84925044e9de902d5d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctZKp6IPMeq4_Kkmuii5YQ.png"/></div></div></figure></div><div class="ab cl nt nu gp nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="hb hc hd he hf"><p id="c027" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated">这些都是我一直在努力学习的那本书的第5章总结，并且得到了书名为《干净的代码》的那本书的要点，作者是Robert C. Martin。</p><p id="a641" class="pw-post-body-paragraph kv kw hi kx b ky lp la lb lc lq le lf kl lr lh li ko ls lk ll kr lt ln lo jf hb bi translated"><strong class="kx hj">请随时给出一些建议和反馈。谢了。</strong></p><h1 id="e605" class="jg jh hi bd ji jj jk jl jm jn jo jp jq jr mw jt ju jv mx jx jy jz my kb kc kd bi translated">参考</h1><p id="b4e0" class="pw-post-body-paragraph kv kw hi kx b ky kz la lb lc ld le lf kl lg lh li ko lj lk ll kr lm ln lo jf hb bi translated">罗伯特·c·马丁的《干净的代码》</p></div></div>    
</body>
</html>