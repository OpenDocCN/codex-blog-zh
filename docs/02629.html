<html>
<head>
<title>Strategy Pattern In PHP 8+</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP 8+中的策略模式</h1>
<blockquote>原文：<a href="https://medium.com/codex/strategy-pattern-in-php-8-54fbb4ae53f5?source=collection_archive---------9-----------------------#2021-07-29">https://medium.com/codex/strategy-pattern-in-php-8-54fbb4ae53f5?source=collection_archive---------9-----------------------#2021-07-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/63c085eb93da64ac01246bcb20387633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UcM1_uM38q5ED3Q_"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae hv" href="https://unsplash.com/@jeshoots?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><div class=""/><div class=""><h2 id="9213" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated">如何使用模式解决现实世界的问题，同时保持代码整洁</h2></div><p id="875a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在本文中，我们将讨论<strong class="jp hz">策略</strong>模式，如何在PHP中应用它，以及我如何使用它来解决我工作的公司中的一个现实问题，从代码中删除几个具有类似行为的类。</p><h1 id="bb19" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">♟战略设计模式</h1><p id="beae" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">策略是一种行为设计模式，让你定义一系列算法，将它们放入一个单独的类中，并使它们的对象可以互换。这种模式具有<strong class="jp hz">低复杂度</strong>并且<strong class="jp hz">非常流行</strong>。</p><p id="3411" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这个模式由两种类型的类组成:上下文<strong class="jp hz">和策略</strong>。</p><p id="991b" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">第一个是主类，必须有一个属性来保存一个<strong class="jp hz">策略</strong>。然后，<strong class="jp hz">上下文</strong>将部分工作委托给<strong class="jp hz">策略</strong>对象，而不是单独完成。</p><p id="e925" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">策略</strong>可以被认为是具有相似行为的算法，即做同样的事情，但方式不同。</p><p id="cf82" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">上下文</strong>没有责任为每个案例选择合适的策略，这个责任在于<strong class="jp hz">客户</strong>本身。事实上，<strong class="jp hz">语境</strong>对策略了解不多。它只知道所有<strong class="jp hz">策略</strong>实现的通用接口。</p><p id="a663" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">策略</strong>模式可以应用于您希望在一个对象中使用不同的算法变体，并且能够在运行时从一种算法切换到另一种算法的情况。</p><p id="1f0a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">使用该模式的另一个用例是当一个类有许多行为并使用许多条件命令时，这会使应用程序的性能不令人满意。使用该模式，您可以删除条件，并为每个条件创建名为<strong class="jp hz">策略</strong>的新类，从而提高性能。</p><p id="bc49" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">策略</strong>也可以<strong class="jp hz"> </strong>用于重构几个类似的类，这些类的不同之处仅在于它们通过将每个表单提取到单独的<strong class="jp hz">策略</strong>中来执行行为。</p><h1 id="4892" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">👷‍♂️实施</h1><p id="ba86" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">最后，我将解释我如何在我工作的公司中解决一个现实世界的问题，使用<strong class="jp hz">策略</strong>模式<strong class="jp hz"> </strong>来消除几个具有相似行为的类，并使代码更干净。</p><p id="4d44" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先，简单介绍一下:</p><p id="ab20" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在我工作的应用程序中，我们有课程和可以注册这些课程的用户。问题是，这些注册可能来自不同的来源，我们必须在创建新注册时存储该来源，以控制发生的情况，并使调试更容易。</p><p id="a1ab" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">此外，每个起点都有自己的逻辑来计算登记到期时间。</p><p id="331a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">以下是一些可能的注册来源:</p><ul class=""><li id="a853" class="lg lh hy jp b jq jr jt ju jw li ka lj ke lk ki ll lm ln lo bi translated"><strong class="jp hz">自动</strong> -自动创建免费课程或已确认付款的付费课程的注册</li><li id="2960" class="lg lh hy jp b jq lp jt lq jw lr ka ls ke lt ki ll lm ln lo bi translated"><strong class="jp hz">手动</strong> -由管理员手动创建的注册</li><li id="da47" class="lg lh hy jp b jq lp jt lq jw lr ka ls ke lt ki ll lm ln lo bi translated"><strong class="jp hz">组</strong> -因为用户是已注册课程的组的成员而创建的注册</li><li id="1584" class="lg lh hy jp b jq lp jt lq jw lr ka ls ke lt ki ll lm ln lo bi translated"><strong class="jp hz">批次</strong> -通过批次导入创建的注册</li><li id="b901" class="lg lh hy jp b jq lp jt lq jw lr ka ls ke lt ki ll lm ln lo bi translated"><strong class="jp hz">组合</strong> -注册已创建，因为用户已注册课程组合</li></ul><p id="1b88" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在我重构之前运行的代码对每个原点都有一个类。这些类有太多的代码重复，在某些情况下，客户端负责实现到期逻辑。</p><p id="2f01" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在，让我们来看看我使用的解决方案:</p><p id="0895" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">为了解决这个问题，我可以使用继承，为每个起源创建一个子类，并创建一个抽象超类来实现起源之间的公共逻辑。</p><p id="553c" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">但是最好的解决方案可能是遵循OOP的良好实践，并且更喜欢<strong class="jp hz">组合而不是继承</strong>。因此，<strong class="jp hz">策略</strong>模式非常适合。</p><p id="b66f" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先，我们需要创建一个所有策略都将实现的接口:</p><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">策略界面</figcaption></figure><p id="797e" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">重构代码的第二步是创建一个主类，名为<strong class="jp hz">名为</strong>。在这个例子中，我们将它命名为<em class="ma"> Enroll </em>，以更好地表达该类的功能:</p><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">上下文类</figcaption></figure><p id="e6f1" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> OBS:面向在构造函数中定义的映射器对象，像一个通用类一样处理数据，创建模型，并将它们保存在某个地方</strong></p><blockquote class="mb mc md"><p id="812b" class="jn jo ma jp b jq jr iz js jt ju jc jv me jx jy jz mf kb kc kd mg kf kg kh ki hb bi translated">Enroll类拥有策略之间的所有公共逻辑，并拥有一个保存已定义的<strong class="jp hz">策略</strong>的属性。在这个例子中，策略是在构造函数中定义的，但是如果需要更多的灵活性，您可以实现一个策略设置器</p></blockquote><p id="8309" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然后，我们可以根据需要创建任意多的策略。在这种情况下，我们需要为每个注册来源创建一个<strong class="jp hz">策略</strong>，下面是一个示例:</p><figure class="lu lv lw lx fd hk"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">战略实施示例</figcaption></figure><h1 id="608f" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">📉优势</h1><p id="72f9" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">使用<strong class="jp hz">策略</strong>模式的主要优势是使代码更加灵活和可扩展，使得维护和新特性的创建更加容易。此外，这种模式可以帮助我们消除重复代码。</p><p id="c211" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">策略</strong>设计模式让我们在运行时交换对象内部使用的算法，并将算法的实现细节与使用它的代码隔离开来。</p><p id="1851" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这种模式也遵循编程的良好实践，因为它让我们在类中用组合代替继承。再者，它符合<a class="ae hv" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hz">开合原理</strong> </a> <strong class="jp hz"> </strong>中所述<strong class="jp hz"/><a class="ae hv" href="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#:~:text=SOLID%20is%20an%20acronym%20for,OOD)%20principles%20by%20Robert%20C.&amp;text=O%20%2D%20Open%2Dclosed%20Principle,I%20%2D%20Interface%20Segregation%20Principle" rel="noopener ugc nofollow" target="_blank"><strong class="jp hz"/></a>原理。</p><h1 id="731d" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">📈不足之处</h1><p id="9a19" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">我在这个主题中的意图是展示实现这个模式的权衡，不要像面对“问题”一样面对它，而是在决定是否实现它时要考虑的要点。</p><p id="da1a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">要注意的第一个问题是，如果你只有几个算法，而且它们很少改变。在这种情况下，没有真正的理由随着模式增加新的类和接口来增加代码的复杂性。</p><p id="5eb5" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">策略</strong>模式也迫使客户意识到可用策略之间的差异，以选择合适的策略。</p><h1 id="f4ff" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">✅结论</h1><p id="0f62" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">PHP代码中经常使用<strong class="jp hz">策略</strong>模式，尤其是在运行时需要切换算法的时候。它为我们提供了一种定义算法族的方法，将每个算法封装成一个对象，并使它们可以互换。这种模式具有<strong class="jp hz">低复杂度</strong>并且<strong class="jp hz">非常流行</strong>。</p><p id="a6c0" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">使用<strong class="jp hz">策略</strong>模式的主要优势是使代码更加灵活和可扩展，使得维护和新特性的创建更加容易。另一方面，它会给代码带来不必要的复杂性。</p><p id="fd93" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在本文中，我展示了如何使用这种模式来解决现实世界中的问题，从应用程序中删除大量重复的代码。</p><p id="43a7" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我希望你们喜欢这篇文章，如果你们喜欢，请留下掌声和评论。如果你不喜欢它，让我知道为什么，建设性的批评总是受欢迎的！</p><p id="7242" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果你想更深入的了解这个主题，我推荐你去访问我在文章末尾留下的所有参考资料！</p><p id="ea57" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果你喜欢这篇文章，我想邀请你访问我的另一篇关于Medium的文章，它讨论了<a class="ae hv" rel="noopener" href="/codex/observer-pattern-in-php-8-569c71dd7837?sk=7e926d06b0f5c9035e0127caeec82dab">观察者设计模式</a>，在那里我解释了这个模式到底是什么，并且给了你一些教导性的例子，展示了实现这个模式的优点和缺点。如果你想看，就去下面的链接:)</p><div class="hh hi ez fb hj mh"><a rel="noopener follow" target="_blank" href="/codex/observer-pattern-in-php-8-569c71dd7837"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hz fi z dy mm ea eb mn ed ef hx bi translated">PHP 8+中的观察者模式</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">在PHP 8+中实现观察者模式的最简单指南</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">medium.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv hp mh"/></div></div></a></div><h1 id="0ccc" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">📚参考</h1><p id="96a7" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated"><a class="ae hv" href="https://pt.wikipedia.org/wiki/Strategy" rel="noopener ugc nofollow" target="_blank">攻略-维基百科</a></p><p id="6c4a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><a class="ae hv" href="https://refactoring.guru/design-patterns/strategy/" rel="noopener ugc nofollow" target="_blank">战略模式重构大师</a></p><p id="a48c" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><a class="ae hv" href="https://dzone.com/articles/design-patterns-strategy" rel="noopener ugc nofollow" target="_blank">带Java示例的策略模式教程- DZone </a></p></div></div>    
</body>
</html>