<html>
<head>
<title>JavaScript SVG diagram editor 6.5 times smaller than Bootstrap (open source library)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比Bootstrap(开源库)小6.5倍的JavaScript SVG图编辑器</h1>
<blockquote>原文：<a href="https://medium.com/codex/javascript-svg-diagram-editor-which-weighs-6-5-less-than-bootstrap-open-source-library-b753feaaf835?source=collection_archive---------2-----------------------#2022-01-31">https://medium.com/codex/javascript-svg-diagram-editor-which-weighs-6-5-less-than-bootstrap-open-source-library-b753feaaf835?source=collection_archive---------2-----------------------#2022-01-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/97a403cca9fd8d3983f4c39763ae45c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rhg5yjq_lv6yOLUYqoTgOQ.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">状态机工作流编辑器</figcaption></figure><p id="e2db" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://alexeyboiko.github.io/DgrmJS/" rel="noopener ugc nofollow" target="_blank">试玩</a> | <a class="ae js" href="https://github.com/AlexeyBoiko/DgrmJS" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p><p id="3f93" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用Blazor Webassembly创建图编辑器的实验(<a class="ae js" rel="noopener" href="/codex/blazor-webassembly-svg-drag-and-drop-e680769ac682"> Blazor Webassembly SVG拖放</a>，<a class="ae js" href="https://alexey-boyko.medium.com/blazor-webassembly-connecting-lines-in-svg-c319f93c1475" rel="noopener"> Blazor WebAssembly:连接SVG中的线</a>)表明Blazor不适合密集的DOM操作。</p><p id="f58e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">事先就知道会有下沉:WebAssembly不能直接访问DOM，WebAssembly使用JavaScript interop来改变DOM。延迟是如此之高，以至于在添加第三个形状后，在移动设备上的拖动速度变慢了。</p><h1 id="d50a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">拒绝框架(对于此任务)</h1><p id="c23a" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">怀疑Blazor的虚拟DOM不正确地跟踪变化(可能Blazor试图更新比需要更多的DOM对象)是没有道理的。事件限制和其他微软建议(<a class="ae js" href="https://docs.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-6.0" rel="noopener ugc nofollow" target="_blank">ASP.NET核心Blazor性能最佳实践</a>)没有帮助。</p><p id="1bb1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">更新一个属性有许多细微差别:</p><ul class=""><li id="e5dd" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">虚拟DOM、树、子树，</li><li id="ed68" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">变化的“循环”(一个地方的变化导致另一个地方的变化，那里的变化导致第一个地方的变化)，</li><li id="3757" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">向组件传递参数并跟踪它们的更改、订阅/取消订阅的细微差别。</li></ul><p id="952c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用Blazor，一个琐碎的JavaScript任务变得太复杂了。框架在这里只会碍事。过度复杂不仅表现在Blazor上，在其他框架上也是如此。如果你还没看过，可以看看《苗条的哈里斯——反思反应》的创作者的谈话。在视频中有一个React应用程序刹车的例子:当进入文本字段时，DOM被动态重建。在这里，DOM是随着鼠标的移动(拖动形状)而动态重建的。</p><p id="531b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Vanilla-JavaScript原型在1000个形状时没有表现出变慢的迹象。</p><p id="d87f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在使用Angular多年之后，用普通的JavaScript做一些事情似乎是一种倒退。好的:手动读取HTML属性并挂起处理程序。但是没有组件，没有IoC，没有模板，怎么开发呢？最重要的是——没有“反应力”？然而，退出。很快就过去了。事实证明，存在超越框架边界的生命，并且在某些方面更加完整。</p><h1 id="f710" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">拒绝类型脚本(类型脚本编译器)</h1><p id="891f" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">类型检查、智能感知和其他工具——这就是TypeScript受欢迎的原因。TypeScript有接口、文字甚至泛型。TypeScript如此容易让人上瘾，以至于人们很容易忘记TypeScript只是JavaScript描述类型的一种方式。是的，在<a class="ae js" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">typescriptlang.org</a>的主页上写着:“TypeScript是带有类型语法的JavaScript。”</p><p id="b9c2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://jsdoc.app/" rel="noopener ugc nofollow" target="_blank"> JSDoc </a>提供了所有相同的特性(类型检查、智能感知等。).</p><p id="a53a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">用JSDoc“打字”的例子:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="a885" class="lt ju hi lp b fi lu lv l lw lx">/**<br/> * <a class="ae js" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {SVGGraphicsElement} svgEl<br/> * <a class="ae js" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {number} transform<br/> * <a class="ae js" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {SVGSVGElement=} svg pass if svgEl not yet in DOM<br/> * <a class="ae js" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> {SVGTransform}<br/> */<br/> function ensureTransform(svgEl, transform, svg) {<br/>    ...<br/>    return ...;<br/>}</span></pre><p id="07c1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您甚至可以在TypeScript中描述类型，并在js文件中使用它们:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="26b4" class="lt ju hi lp b fi lu lv l lw lx">// ts-file<br/>interface IDiagram {<br/>    on(evtType: DiagramEventType,<br/>        listener: EventListenerOrEventListenerObject): this;<br/>    shapeAdd(param: PresenterShapeAppendParam): IDiagramShape;<br/>    shapeDel(shape: IDiagramShape): void;<br/>    shapeConnect(param: DiagramShapeConnectParam): void;<br/>}</span><span id="57c0" class="lt ju hi lp b fi ly lv l lw lx">// js-file - Diagram implements IDiagram<br/>/** <a class="ae js" href="http://twitter.com/implements" rel="noopener ugc nofollow" target="_blank">@implements</a> {IDiagram} */<br/>export class Diagram {<br/>    …<br/>}</span></pre><p id="1a48" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这种情况下,“查找所有引用”、“重命名”和“检查对象是否实现了接口”都将起作用(至少在Visual Studio代码中，一切都是现成的)。</p><p id="2d81" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">不使用TypeScript编译器的优点:</p><ul class=""><li id="7710" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">JS代码正是你写的，</li><li id="e56e" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">加速开发—无需等待编译，</li><li id="989a" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">不需要映射文件，更容易调试。</li></ul><p id="9b63" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">JSDoc不如TypeScript简洁，语法不常见，IDE支持较差。<br/>一个混合的方法被证明是方便的:</p><ul class=""><li id="6c85" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">TypeScript中ts文件的类型描述</li><li id="598b" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">用JSDoc实现JavaScript中的真实代码。</li></ul><h1 id="936e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">DgrmJS</h1><p id="33e8" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">结果是一个普通的JavaScript库。</p><p id="a960" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">DgrmJS 是一个用于创建SVG图的JavaScript库。该库的主要目标是在BPM(业务流程管理)系统中建立工作流。</p><ul class=""><li id="0934" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">适用于桌面和移动设备</li><li id="4183" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">没有依赖关系</li><li id="0da9" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">小尺寸</li><li id="5631" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">形状是以声明方式创建的</li></ul><p id="51ff" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">主要思想</p><ul class=""><li id="7688" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">允许开发人员使用标准SVG对象和功能，以声明方式创建将在图表中使用的形状。<br/>要创建形状，开发人员应该在标准SVG标记中添加特殊的数据属性。因此任何svg图像都可以用作图表中的形状。</li><li id="eace" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">DgrmJS调度事件，如“形状被选中”或“形状正在连接到另一个形状”。<br/>开发者可以使用这些事件来实现自己的逻辑，例如，对工作流进行JSON描述。</li></ul><p id="e2f8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">“圆形”形状模板的声明性描述示例:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="4eee" class="lt ju hi lp b fi lu lv l lw lx">&lt;g data-templ="circle"&gt;<br/>    &lt;circle ... /&gt;<br/>    &lt;text data-key="text"&gt;&lt;/text&gt;<br/> <br/>    &lt;!--<br/>        out connector<br/>        data-connect-point - point into shape where connector line starts<br/>        data-connect-dir - direction of connector line<br/>    --&gt;<br/>    &lt;circle<br/>        data-connect="out"<br/>        data-connect-point="60,0"<br/>        data-connect-dir="right" ...&gt;<br/>    &lt;/circle&gt;<br/> <br/>    &lt;!--<br/>        in connector<br/>    --&gt;<br/>    &lt;circle<br/>        data-connect="in"<br/>        data-connect-point="-60,0"<br/>        data-connect-dir="left" ...&gt;<br/>    &lt;/circle&gt;<br/>&lt;/g&gt;</span></pre><p id="c930" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下图显示了使用“圆”模板创建的两个形状(两个圆)。通过点击图—显示输出连接器，您可以从中拉出连接线。当您将连接线的末端悬停在图形上时，将显示输入连接器。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/75c45c5d9c9e374a730e5cd169661f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*Co3-AcQ5hpa9vWc55JePKA.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">形状的连接</figcaption></figure><p id="22c5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">向图表添加形状的代码:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="560b" class="lt ju hi lp b fi lu lv l lw lx">import { svgDiagramCreate } from './diagram/svg-presenter/svg-diagram-fuctory.js';</span><span id="cece" class="lt ju hi lp b fi ly lv l lw lx">const diagram =<br/>    svgDiagramCreate(document.getElementById('diagram'));</span><span id="34a1" class="lt ju hi lp b fi ly lv l lw lx">diagram.shapeAdd({<br/>    templateKey: 'circle',<br/>    position: { x: 120, y: 120 }<br/>});</span></pre><p id="2629" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">关于GitHub的更多例子。</p><h1 id="2228" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="0327" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">这篇文章并没有呼吁放弃框架或类型脚本。长期坚持同样的范式、方法、框架，结果会“盲目”，缩小视野范围。往往我们甚至不做选择——试着给Blazor WebAssembly或者Svelte developer找个空缺，你只能在React和Angular(也有Vue)之间选择。</p><p id="e594" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有机会去实验就好了。从“反应式方法”的泡沫中走出来是很有趣的。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/52e194633953f22caf1e2e54f5137319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nbS5Gmfi29Axu5JeLCZp8w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">DgrmJS和Bootstrap的大小比较</figcaption></figure></div></div>    
</body>
</html>