<html>
<head>
<title>The Mystery of Variable Declaration in JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS中变量声明的奥秘</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-mystery-of-variable-declaration-in-js-24da9e3c6dfe?source=collection_archive---------12-----------------------#2022-10-30">https://medium.com/codex/the-mystery-of-variable-declaration-in-js-24da9e3c6dfe?source=collection_archive---------12-----------------------#2022-10-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4139" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">VAR vs LET vs CONST —如何选择正确！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/0ca1c9f8ba87ce7e1530f1e84027131c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVOWNgsK3qd5gpNIhwvw3g.jpeg"/></div></div></figure><h1 id="8311" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">介绍</h1><p id="30fe" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">尽管我们大多数前端开发人员一直在定义<em class="kx">Java脚本</em>变量，但我经历过很多，尤其是初级开发人员，并不真正<em class="kx">了解</em>或真正<em class="kx">关心</em>他们在JS中如何声明变量的区别。</p><p id="3df7" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">我个人认为这个主题<strong class="kd hj">非常重要</strong>，因为变量声明<em class="kx">(在任何语言中)</em>，是编写代码的一个基本部分，忽略事实将最终导致性能问题，或者你会发现自己在<em class="kx">调试地狱中。</em>特别是JS，作为一个子集或纯粹的，仍然是前端应用程序中使用最多的语言之一，<strong class="kd hj">性能</strong>可能很快成为一个问题。</p><h1 id="f41a" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">为什么这很重要？</h1><p id="ccb6" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">你们中的一些人可能会问为什么要这么麻烦，因为最终我们如何定义变量并不重要，除非我们使用像<em class="kx"> Typescript </em>这样的东西。🤯由于JS被认为是一种高级语言，因此开发人员不需要处理代码中变量的内存分配，一些开发人员忽略了这样一个事实:内存仍然需要以某种方式被分配和释放。它们只是声明一个变量，JS处理内存分配。</p><p id="b498" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">然而，这样的内存分配必须在某一点被释放，以避免内存泄漏和性能问题。收集所有这些<em class="kx">死</em>对象并从内存中移除它们的分配的过程称为<em class="kx">垃圾收集</em>。<a class="ae ld" rel="noopener" href="/@_lrlna/garbage-collection-in-v8-an-illustrated-guide-d24a952ee3b8">这里有一篇由<a class="le lf ge" href="https://medium.com/u/408458b1f6aa?source=post_page-----24da9e3c6dfe--------------------------------" rel="noopener" target="_blank"> Irina Shestak </a>撰写的精彩文章</a>，讲述了JS中垃圾收集的工作原理。</p><p id="4ac7" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">但是不仅仅糟糕的内存分配会成为一个问题，忽略<em class="kx">最佳实践</em>也会对代码稳定性产生影响。例如，您可能无意中在代码中的某个地方重新声明了一个<code class="du lg lh li lj b">result</code>对象，这会导致数据损坏。如果你的编译器没有警告你，这将很快导致一场耗费你数小时时间的调试闹剧！</p><p id="4f2a" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">尽管JavaScript并不坏，但它仍然允许您做一些非常奇怪的事情——作为开发人员，您应该意识到这一点！</p><h2 id="55bb" class="lk jk hi bd jl ll lm ln jp lo lp lq jt kk lr ls jv ko lt lu jx ks lv lw jz lx bi translated">辖域</h2><p id="2c50" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">为了理解声明差异的主题，我们首先需要建立<em class="kx">范围的定义。</em>它不是什么神秘的东西，基本上只是你代码里面一个对象<em class="kx">(函数，变量，类)</em>的<em class="kx">定义空间</em>。基本上有两个范围定义:一个对象是</p><ul class=""><li id="9f8f" class="ly lz hi kd b ke ky kh kz kk ma ko mb ks mc kw md me mf mg bi translated"><strong class="kd hj">函数作用域，</strong>如果它<strong class="kd hj"> </strong>可以在代码的<em class="kx">根级别</em>上访问，并且</li><li id="452d" class="ly lz hi kd b ke mh kh mi kk mj ko mk ks ml kw md me mf mg bi translated"><strong class="kd hj">块范围，</strong>如果对象只能在<em class="kx">块</em> <em class="kx">内访问(如if语句、嵌套函数等)。).</em></li></ul><p id="7bf8" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">范围的重要性可能还不清楚，但是我们将在后面的例子中关注这个问题。</p><h2 id="619e" class="lk jk hi bd jl ll lm ln jp lo lp lq jt kk lr ls jv ko lt lu jx ks lv lw jz lx bi translated">提升</h2><p id="a398" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">提升是<em class="kx"> JS解释器</em>的默认行为，将所有声明移动到它们作用域的顶部，使它们在整个定义空间都是可访问的。这些声明包括函数、变量和类，尽管提升通常被认为是<code class="du lg lh li lj b">var</code>声明的一个特征。根据<a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting?retiredLocale=de" rel="noopener ugc nofollow" target="_blank"> MDN </a>，下列任何一种行为都可以被认为是吊装:</p><ol class=""><li id="ec50" class="ly lz hi kd b ke ky kh kz kk ma ko mb ks mc kw mm me mf mg bi translated"><em class="kx">值提升</em> →在变量被声明之前访问变量<strong class="kd hj">的值。</strong></li><li id="4026" class="ly lz hi kd b ke mh kh mi kk mj ko mk ks ml kw mm me mf mg bi translated"><em class="kx">声明提升</em> →引用声明前的变量，但值赋给<code class="du lg lh li lj b">undefined</code>。</li><li id="2e20" class="ly lz hi kd b ke mh kh mi kk mj ko mk ks ml kw mm me mf mg bi translated"><em class="kx">词法提升</em> →声明前引用变量或引用变量范围外导致<em class="kx">引用错误</em>。</li></ol><p id="8ffd" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">通常，<em class="kx">函数声明</em> ( <code class="du lg lh li lj b">function</code>，<code class="du lg lh li lj b">async function</code>)受制于<strong class="kd hj">类型1 </strong>，<code class="du lg lh li lj b">var</code>是<strong class="kd hj">类型2 </strong>和<code class="du lg lh li lj b">let</code>，<code class="du lg lh li lj b">const</code>和<code class="du lg lh li lj b">class</code> <em class="kx">(词法声明)</em>的行为类似于<strong class="kd hj">类型3 </strong>的提升。</p><p id="8fec" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">既然本文重点讨论<em class="kx">变量</em>声明<em class="kx">，</em>那我们最后来说说JS中不同的<em class="kx">声明选项</em>。</p><h1 id="314e" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">VAR-declaration</h1><p id="207e" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated"><code class="du lg lh li lj b">var</code>声明基本上是<a class="ae ld" href="https://www.w3schools.com/js/js_es6.asp" rel="noopener ugc nofollow" target="_blank"> ES6 </a>之前时代的遗留物，但在现代应用程序中仍在定期攀升。</p><blockquote class="mn mo mp"><p id="a57a" class="kb kc kx kd b ke ky ij kg kh kz im kj mq la km kn mr lb kq kr ms lc ku kv kw hb bi translated">在我看来，<code class="du lg lh li lj b">var</code> <strong class="kd hj">不应该在任何现代应用中使用</strong>，除了极少数例外。❌——不要用它！</p></blockquote><p id="d470" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">首先，<code class="du lg lh li lj b">var</code> <strong class="kd hj">是函数作用域的</strong>，因此会导致很多问题！让我们看一个例子:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="437c" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">如您所见，<code class="du lg lh li lj b">rusty</code>在<code class="du lg lh li lj b">if</code>语句的内部和外部都是可访问的，因为解释器将它移动到了父作用域的顶部！🤯</p><p id="659d" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">虽然起初这似乎不是一个大问题，但是变量已经被分配并停留在内存中，直到<strong class="kd hj">整个函数</strong>完成。这意味着<em class="kx">垃圾收集</em>永远无法<em class="kx">释放</em>该变量的分配，因为只要该函数正在执行<strong class="kd hj">就可以到达</strong>！</p><p id="5325" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">想象一个正在运行的web应用程序，它有一堆在子作用域中声明的内存密集型对象(例如if语句)。因为这些对象仍然可以从父作用域中的任何地方访问，所以这些对象的内存永远不会被释放，即使实际使用变量的子作用域不再运行！👎</p><p id="a4ce" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">此外，由于<code class="du lg lh li lj b">var</code>的行为类似于<strong class="kd hj">类型2提升</strong>，变量用<code class="du lg lh li lj b">undefined</code>进行初始化，因此在实际声明之前甚至有一个值<em class="kx">。这里有一个例子:</em></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="153a" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">我们可以看到<code class="du lg lh li lj b">rusty</code>甚至在变量被赋值之前就已经可以访问了！</p><h2 id="0d29" class="lk jk hi bd jl ll lm ln jp lo lp lq jt kk lr ls jv ko lt lu jx ks lv lw jz lx bi translated">VAR变量的重新声明</h2><p id="a631" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">在我看来，使用<code class="du lg lh li lj b">var</code>声明最可怕的<em class="kx">含义是，我们可以在函数中的任何时候<strong class="kd hj">重新声明</strong>这样的变量！这不仅在我们每次重新声明的时候分配一个新的内存，而且也考虑到了大量的赋值错误。</em></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><h1 id="9435" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">信件声明</h1><p id="99ab" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">JS团队显然也同意这样一个事实，即<code class="du lg lh li lj b">var</code>的行为可能会有问题，因此，随着ES6的兴起，引入了新的<em class="kx">块范围的</em>声明选项<code class="du lg lh li lj b">let</code>和<code class="du lg lh li lj b">const</code>。</p><blockquote class="mn mo mp"><p id="f81d" class="kb kc kx kd b ke ky ij kg kh kz im kj mq la km kn mr lb kq kr ms lc ku kv kw hb bi translated">如果你不确定如何声明你的变量，使用 <code class="du lg lh li lj b"><strong class="kd hj"><em class="hi">let</em></strong></code>！这是现代JS应用程序中声明变量的首选方式，并且导致的问题最少。</p></blockquote><p id="bceb" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">但是让我们首先通过一个例子来讨论与<code class="du lg lh li lj b">var</code>声明的区别:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="ba83" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">正如你所看到的，<code class="du lg lh li lj b">rusty</code>现在是<em class="kx">块范围的</em>，只有<strong class="kd hj">存在于定义它的</strong>块中！这意味着一旦这个块终止，分配就变成受制于<em class="kx">垃圾收集</em>，因为它不能再被到达。这不仅可以提高性能，还可以显著降低重写全局值和类型的风险。</p><p id="e04c" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">此外，<code class="du lg lh li lj b">let</code>可以被重新赋值，但<strong class="kd hj">不能被重新声明！这意味着你仍然可以给变量分配新的值，但是你不能为变量分配一个全新的内存槽。所以，虽然这是正确的</strong></p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="bc88" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">这不是</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="c680" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">最后，与<code class="du lg lh li lj b">var</code>不同的是，<code class="du lg lh li lj b">let</code>没有用<code class="du lg lh li lj b">undefined</code>初始化<strong class="kd hj"/>——实际上<strong class="kd hj">根本没有初始化</strong>，因为它的行为类似于3型起重。<strong class="kd hj"> </strong>因此，试图在变量实际声明之前访问它，会导致引用错误:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><h1 id="7c91" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">常量声明</h1><p id="d0f3" class="pw-post-body-paragraph kb kc hi kd b ke kf ij kg kh ki im kj kk kl km kn ko kp kq kr ks kt ku kv kw hb bi translated">最后要讨论的申报选项是<code class="du lg lh li lj b">const</code>。正如上一节简要提到的，<code class="du lg lh li lj b">const</code>与<em class="kx">非常相似</em>与<code class="du lg lh li lj b">let</code>。带有<code class="du lg lh li lj b">const</code>的变量声明是<em class="kx">块范围的</em>，不能被重新声明。在某些情况下，你可能想要一个更严格的定义，例如，如果你知道你的变量的值在你的声明语句之后不会改变。这正是<code class="du lg lh li lj b">const</code>发挥作用的时候。用<code class="du lg lh li lj b">const</code>声明的变量在变量范围内固定其值:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="cabd" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">就是这样！🚀</p><p id="4b06" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">我希望这篇文章能帮助你更多地了解JS中的变量声明以及它们对你工作的影响！也许你甚至开始理解后端工程师对编程语言中严格规则的迂腐主张。👀</p><p id="7f0e" class="pw-post-body-paragraph kb kc hi kd b ke ky ij kg kh kz im kj kk la km kn ko lb kq kr ks lc ku kv kw hb bi translated">一如既往，如果有任何问题或意见，请联系我们！🙏</p></div></div>    
</body>
</html>