# 服务类和贫血对象

> 原文：<https://medium.com/codex/class-design-is-important-99bd4725ecb8?source=collection_archive---------23----------------------->

随着我职业生涯的进展，我遇到了越来越多的项目，在这些项目中“*一个类设计* *如果有效就足够好了”。*由于这一点，程序员经常想出短视的类设计，这些设计会制造维护噩梦。

![](img/aa23d523ea873e75b595d76d28066b9f.png)

弗拉德·亚历山德鲁·波帕摄于 Pexels

为了这篇文章，我将提供一个简单的例子，尽管是一个真实的例子。考虑一个目的是处理支付的应用程序。这种应用程序中的核心域类是一个 *Money* 类。毕竟没有*钱*处理款项是不可能的。

一个常见版本的 *Money* 类如下所示:

这个类泄露了它的内部状态。

当你需要用这个类做业务操作的时候，问题就显现出来了。具有上述数据对象风格类的业务逻辑倾向于通过特定的*服务/* [*事务脚本*](https://dzone.com/articles/transaction-script-pattern) 类来处理。

虽然这对于超小型应用程序来说完全没问题，但是对于具有复杂业务逻辑的大型应用程序来说是绝对不行的。

例如，我看到的事件涉及

1.  必须知道客户的最终发票是否高于 275 欧元的特定阈值，以及
2.  做一些非常具体的事情。

请注意，这个应用程序适用于各个欧洲国家，甚至是那些没有采用欧元的国家。

完成此操作的类看起来很像这样:

在我提到的特殊例子中，你在上面看到的这个*服务*是在两个独立的模块中实现的。实现这一新功能的开发人员并不知道，函数参数中的*阈值*在一个模块中以欧元的形式发送，而在另一个模块中则以当地货币的形式发送。

代码和语义都没有明确说明这一点。这是一场迫在眉睫的灾难。

## 让它变得更好

现在，我们可以采取简单的方法，仅仅将函数参数重命名为 *thresholdValueInEuros* 来表示意图。

## 进一步的变化

我们可以再调整一下。在这个迭代中，我们可以使函数参数成为 Money 类本身的一个实例。现在函数的定义是这样的

## 我们能做得更多吗？

绝对的。

我对上述解决方案的问题是，与核心 *Money* 相关的逻辑现在将分布在另外两个类中，即 *ConversionService* (用于转换)和*billcutamingservice*(一个 *Money* 的数值比另一个大)。

这意味着这三个类都是耦合的。

我们在这里举了一个简单的单个类的例子，但是想象一个场景，其中整个应用程序是用类似于 *Money* 类的*数据对象*编写的，并且所有的业务逻辑分布在各个 *Service* 类中。随着项目越来越多的特性，引入极度耦合的类的机会越来越多，这使得更改变得非常麻烦。

## 我的首选方法

我的首选方法的关键是创建不暴露其内部状态的封装类。

一个不同的货币类实现如下所示

这里有两个不同之处

*   **值*和货币*都没有通过 getter****公开
*   **值的比较是通过** *钱* **类本身**来完成的

这消除了对*billcutamingservice*类中货币比较的需要，并且 *ConversionService* 中的转换逻辑也通过 *Money* 类调用。

但我会更进一步。我不会仅仅调用 *ConversionService* 方法，而是将该逻辑移到别处。

使用这种方法，每次在应用程序中引入一种新货币时(例如，在一个新的国家推出)，都必须指定转换因子，因为这将是一次编译时检查。

## 更多地思考“对象”

我想到的最后一个变化是将 *thresholdAmount* 参数转换为特定的 *ThresholdAmount* 对象。

现在如果你想一想*threshold amount*[**是*-a***](https://en.wikipedia.org/wiki/Is-a)*Money，但唯一的区别是它是如何初始化的，前者是通过*配置完成的。*(记住，这个值是可配置的)*

*这就是为什么我认为可以有一个 *ThresholdAmount* 对象。*

## *结论*

*过多的前期设计会适得其反。*

*太少也可以！*

*找到最佳点是我们需要学习的东西，而且根据经验这经常会发生。*

*关键是要知道什么时候需要重构，然后说服你的团队，也许还有你的经理。设计良好的类通常是帮助您更快实现新功能或避免错误的重要工具。下一个维护你的代码库的人会感谢你的。*