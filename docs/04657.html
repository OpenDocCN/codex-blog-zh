<html>
<head>
<title>Kernel Optimizations &amp; Upgrade Guide for Apache ShardingSphere 5.0.0 — The Ideal Database Management Ecosystem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache ShardingSphere 5.0.0的内核优化和升级指南—理想的数据库管理生态系统</h1>
<blockquote>原文：<a href="https://medium.com/codex/kernel-optimizations-upgrade-guide-for-apache-shardingsphere-5-0-0-49942fd31898?source=collection_archive---------6-----------------------#2021-12-23">https://medium.com/codex/kernel-optimizations-upgrade-guide-for-apache-shardingsphere-5-0-0-49942fd31898?source=collection_archive---------6-----------------------#2021-12-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f9a1" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">经过近两年的开发和优化，Apache ShardingSphere 5.0.0 GA版本最近发布了。</p><p id="cc3c" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">与4.1.1 GA版本相比，新版本的内核有了很大改进:</p><ul class=""><li id="917d" class="jf jg hi ij b ik il io ip is jh iw ji ja jj je jk jl jm jn bi translated">内核优化受制于可插拔架构，允许用户按照自己的意愿组合内核特性。</li><li id="8415" class="jf jg hi ij b ik jo io jp is jq iw jr ja js je jk jl jm jn bi translated">联邦执行引擎旨在提高SQL分布式查询能力，以满足用户在复杂业务场景中的需求。</li><li id="0a42" class="jf jg hi ij b ik jo io jp is jq iw jr ja js je jk jl jm jn bi translated">我们还在API层面做了优化，帮助用户降低成本。</li></ul><p id="fadc" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">本文将让您更好地理解我们所做的一些与内核相关的更改，以及新版本和以前版本之间的特性差异。您还将了解有关这些优化的更多信息，以及如何在集成了数据分片、读/写拆分以及加密和解密的实际场景中使用5.0.0版本。</p><h2 id="a8f2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd is ke kf kg iw kh ki kj ja kk kl km kn bi translated"><strong class="ak">可插拔架构内核</strong></h2><p id="fad9" class="pw-post-body-paragraph ih ii hi ij b ik ko im in io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je hb bi translated">Apache sharding sphere 5 . 0 . 0 GA版本的北极星。我们的Database Plus概念的使命是在碎片化数据库的基本服务之上建立一个标准层和生态系统，并为用户提供附加功能。统一和标准化的数据库使用规范为上层应用程序提供了支持，企业因底层数据库碎片化而面临的挑战得到了尽可能的最小化。Database Plus的三个特征是链接、增强和可插拔。</p><p id="b0d8" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">ShardingSphere可以为用户提供管理服务和增强功能，包括分布式数据库、数据安全、数据库网关和压力测试。面向插件的内核架构允许模块化，用户可以根据需要灵活地扩展特性。</p><p id="292e" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">Database Plus概念的出现标志着ShardingSphere已经从一个中间件发展成为一个创新的分布式数据库生态系统。因为我们将Database Plus作为我们的新方向，而且在我们的可插拔系统中有许多扩展点，所以拥有一个可插拔的内核是理所当然的。下图说明了新的可插拔内核:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es kt"><img src="../Images/d2c1ec57b4ad205d568f35060d4a82a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nx68WD8e4_3TpRA80y2ncg.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx translated">面向Apache ShardingSphere插件的内核</figcaption></figure><p id="ac72" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">Apache ShardingSphere内核的所有进程(即元数据加载器、SQL解析器、SQL路由器、SQL重写器以及SQL执行器和结果合并器)都提供了扩展点，ShardingSphere在这些扩展点上实现了默认特性，如数据分片、读/写拆分、加密和解密、影子数据库压力测试以及高可用性。</p><p id="3a42" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">我们可以将扩展点分为两类:基于特性的扩展点和基于技术的扩展点。</p><p id="acf0" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">在内核进程中，技术扩展点包括SQL解析器引擎和SQL执行器引擎的扩展点。函数扩展点是元数据加载、SQL路由器引擎、SQL重写器引擎以及SQL执行器和结果合并引擎的扩展点。</p><p id="c632" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">SQL解析器引擎的扩展点是SQL AST分析和SQL树遍历。在这两个扩展点上构建的SQL解析引擎，默认情况下可以解析和支持<a class="ae lj" href="https://www.mysql.com/customers/view/?id=1461" rel="noopener ugc nofollow" target="_blank"> MySQL </a>、<a class="ae lj" rel="noopener" href="/codex/create-a-distributed-database-solution-based-on-postgresql-opengauss-b30d0e1ced2c"> PostgreSQL </a>、Oracle、SQLServer、openGauss、SQL92等多种数据库方言。用户还可以编写代码来解析Apache ShardingSphere SQL Parser目前不支持的更多数据库方言，或者开发SQL Audit和其他新功能。</p><p id="f352" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">SQL执行引擎扩展点怎么样？它的扩展依赖于不同的执行方法。目前Apache ShardingSphere的SQL Executor有单线程执行引擎和多线程执行引擎。单线程执行引擎用于执行事务语句，多线程则适用于不包含事务的场景，以提高SQL执行性能。在未来，我们将提供更多的执行引擎，如MPP执行引擎，满足分布式场景中SQL执行的要求。</p><p id="ef1a" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">Apache ShardingSphere为数据分片、读/写分离、加密和解密、影子数据库压力测试和高可用性提供了功能扩展点。这些特性实现了全部或部分功能扩展点，以满足他们的需求。同时，在每个模块中，还提供了内部子级功能扩展点，如分片策略、分布式ID生成器和负载平衡算法。Apache ShardingSphere内核函数中实现了以下扩展点:</p><ul class=""><li id="6f9d" class="jf jg hi ij b ik il io ip is jh iw ji ja jj je jk jl jm jn bi translated"><strong class="ij hj">数据分片:</strong>实现元数据加载器、SQL路由器、SQL重写器和结果合并的所有扩展点。对于数据分片函数，提供了分片算法、分布式ID等扩展点。</li><li id="9649" class="jf jg hi ij b ik jo io jp is jq iw jr ja js je jk jl jm jn bi translated"><strong class="ij hj">读写拆分:</strong>实现函数扩展点SQL Router，为函数提供负载均衡算法扩展点。</li><li id="c404" class="jf jg hi ij b ik jo io jp is jq iw jr ja js je jk jl jm jn bi translated"><strong class="ij hj">加密&amp;解密:</strong>实现元数据加载器、SQL重写器和结果合并。在内部，提供了加密和解密算法扩展点。</li><li id="5be4" class="jf jg hi ij b ik jo io jp is jq iw jr ja js je jk jl jm jn bi translated"><strong class="ij hj">影子数据库压力测试:</strong>实现扩展点SQL路由器。给出了子级扩展点阴影算法。</li><li id="4c3e" class="jf jg hi ij b ik jo io jp is jq iw jr ja js je jk jl jm jn bi translated"><strong class="ij hj">高可用性:</strong>还实现了SQL Rounter扩展点。</li></ul><p id="b342" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">给定扩展点，Apache ShardingSphere函数是真正可伸缩的。多租户、SQL审计和其他新特性将通过这些扩展点无缝地添加到生态系统中。</p><p id="fd78" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">此外，当开发需要快速部署分布式数据库系统时，用户还可以利用这些扩展点来开发定制功能。关于可插拔架构的扩展点的详细描述，请参考开发者手册:<a class="ae lj" href="https://shardingsphere.apache.org/document/current/en/dev-manual/" rel="noopener ugc nofollow" target="_blank">https://sharding sphere . Apache . org/document/current/en/dev-manual/</a></p><p id="9169" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">我们比较了5.0.0 GA版本和4.1.1 GA版本的可插拔内核，发现了一些主要差异(如下表所示):</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lk"><img src="../Images/2bb28348ccdd8ffff1867e96f6867448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ASTs09g3c7LhyCLAfr-jEw.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx translated">版本比较</figcaption></figure><p id="5568" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">首先，两个版本的产品定位不同。版本5.0.0 GA是Apache ShardingSphere从数据库分片中间件向分布式数据库生态系统发展的里程碑，在分布式数据库生态系统中，功能可以很容易地集成到可插拔架构中。</p><p id="08fe" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">第二，4.1.1 GA版本只支持基本功能，而5.0.0 GA版本关心的是基础设施和特性最佳实践。用户甚至可以放弃一些特性，在内核基础设施上开发自己的定制功能。在耦合性方面，5.0.0 GA版本中的内核函数是相互隔离的，因此无法感知另一个特性的存在，最大程度上保证了内核的稳定性。最后，考虑到功能组合，5.0.0版本将所有功能(例如，数据分片、读/写拆分、影子数据库压力测试、加密和解密以及高可用性)置于同一级别，因此用户可以根据自己的喜好组合功能。4.1.1 GA版本在其他函数上强加了数据分片。</p><p id="9a78" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">总之，增强的5.0.0 GA版本的可插拔内核允许用户自由组合功能以满足他们的业务需求，就像他们是构建块一样。然而，采用新的可插拔架构也改变了我们使用内核函数的方式。</p><p id="08d2" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">在本文中，我们将展示一些实际的例子，并展示如何在5.0.0 GA版本中组合这些功能。</p><h2 id="321a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd is ke kf kg iw kh ki kj ja kk kl km kn bi translated"><strong class="ak">联邦执行引擎</strong></h2><p id="2c3e" class="pw-post-body-paragraph ih ii hi ij b ik ko im in io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je hb bi translated">联邦执行引擎是5.0.0 GA版本内核的另一个亮点。我们的目标是支持在4.1.1 GA版本中不工作的分布式查询语句，例如跨数据库实例相关的查询和子查询。由于联邦执行引擎，开发人员不再需要担心SQL的使用范围，他们可以专注于他们的业务功能开发，减少业务级别的功能限制。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ll"><img src="../Images/537000dfc8e34b8a6dfb9df930c77a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hM2mG4VQGznG7Ya2Tep6AA.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx translated">联邦执行引擎流</figcaption></figure><p id="8529" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">上图展示了联邦执行引擎的流程。一般来说，流程仍然遵循这样的顺序:SQL解析器、SQL路由器、SQL重写器，然后是SQL执行器。唯一不同的步骤是在联邦执行引擎中使用了额外的SQL优化器。优化器包含RBO(基于规则的优化器)和CBO(基于成本的优化器)，用于优化分布式查询语句，并以最小的成本获得执行计划。在SQL路由器中，路由器引擎分析SQL语句是否被提供给跨数据库实例，如果是，它确定使用联邦执行引擎来执行SQL。</p><p id="408c" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">联邦执行引擎仍然是一个实验性的特性，所以默认情况下是禁用的。如果要使用引擎，可以通过配置<code class="du lm ln lo lp b">sql-federation-enabled: true</code>来启用。</p><p id="9120" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">联合执行引擎适用于跨数据库实例的相关查询和子查询，以及一些内核不支持的聚合查询。下面是我们给出的具体场景示例，以帮助您理解联邦执行引擎支持的语句。</p><ul class=""><li id="af09" class="jf jg hi ij b ik il io ip is jh iw ji ja jj je jk jl jm jn bi translated"><strong class="ij hj">跨DataNode相关查询:</strong>当一个关系查询的多个表分布在不同的数据库实例上时，使用联邦执行引擎。</li></ul><p id="8080" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">比如看下面的数据分片配置:<code class="du lm ln lo lp b">t_order</code>和<code class="du lm ln lo lp b">t_order_item</code>表是有多个datanodes的表分片，没有配置绑定表规则，而<code class="du lm ln lo lp b">t_user</code>和<code class="du lm ln lo lp b">t_user_role</code>是分布在不同数据库实例上的单个表。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lq"><img src="../Images/746b4ce5d68b4deda4ae4c033be44e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0UQVMCsaoiwTGQAsYbphw.png"/></div></div></figure><p id="8a7a" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">以下SQL命令通常用于跨数据库实例，因此建议使用联邦执行引擎来完成这些关系查询:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lr"><img src="../Images/e366769a25b79ef6d8df97e58723c43f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tTZe81XOcjnkUCDdR8ePcA.png"/></div></div></figure><ul class=""><li id="a5d5" class="jf jg hi ij b ik il io ip is jh iw ji ja jj je jk jl jm jn bi translated"><strong class="ij hj">子查询:</strong>简单下推引擎支持具有一致分片条件的子查询，并且子查询被路由到单个分片。如果没有为子查询和外部查询指定相同的分片键，或者分片键的值不一致，那么就需要联邦执行引擎。</li></ul><p id="eac4" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">下面的代码块显示了联邦执行引擎支持的一些子查询:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lq"><img src="../Images/ab332c6c9bc626d814966cb9fb9f6ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RAyEWs-Lk8qQK2SjWTIXQ.png"/></div></div></figure><ul class=""><li id="1687" class="jf jg hi ij b ik il io ip is jh iw ji ja jj je jk jl jm jn bi translated"><strong class="ij hj">聚合查询:</strong>目前Apache ShardingSphere简单下推引擎还不能支持所有的聚合查询。但是，您可以使用联邦执行引擎来执行简单下推引擎不支持的聚合查询。</li></ul><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ls"><img src="../Images/0688dbc69953370406e539fc14fcccf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tqVlT1gK4ZFWeHYXHlmkJg.png"/></div></div></figure><p id="c6af" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">联邦执行引擎显著增强了Apache ShardingSphere的分布式查询能力。未来，我们将继续优化Apache ShardingSphere，旨在减少联邦执行引擎的内存使用，并改进分布式查询功能。</p><h2 id="3978" class="jt ju hi bd jv jw jx jy jz ka kb kc kd is ke kf kg iw kh ki kj ja kk kl km kn bi translated"><strong class="ak">特性API调整</strong></h2><p id="d4e9" class="pw-post-body-paragraph ih ii hi ij b ik ko im in io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je hb bi translated">为了帮助用户最小化相关成本，5.0.0 GA版本在API层面做了很多优化。根据一些社区反馈，数据分片API过于复杂，难以理解。经过社区层面的讨论，我们决定在新的GA版本中提供一个全新的数据分片API。</p><p id="135c" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">随着Apache ShardingSphere项目定位从数据库中间件转变为分布式数据库生态系统，我们必须开发一个透明的数据分片功能。准确地说，<strong class="ij hj">在5.0.0 GA中，我们为用户提供了自动分片策略，所以他们不需要担心数据库和表的细节，因为他们可以使用自动分片来指定分片的数量。</strong>由于新的可插拔架构和影子数据库压力测试等一些增强功能，内核函数API也做了相应的调整。在这一节中，我们将介绍在不同的API中所做的调整。</p><p id="9ffa" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj">数据分片API </strong></p><p id="662d" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">在之前的4.x版本发布之后，用户经常在社区中联系我们，抱怨用于数据分片的API太复杂和难以使用。下面的代码块向您展示了4.1.1 GA版本中的数据分片配置。在旧版本中，有五种分片策略，即标准、复杂、内联、提示和无。用户很难理解和使用不同分片策略的不同参数。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lq"><img src="../Images/24efef896269880eb12228efba1a8dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JdTCO4RoR-yzQakBIhyrMA.png"/></div></div></figure><p id="50d8" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">在5.0.0 GA版本中，我们简化了数据分片API中的分片策略。首先，现在删除了原来的<code class="du lm ln lo lp b">inline</code>策略，我们保留了剩下的四种分片策略，即<code class="du lm ln lo lp b">standard</code>、<code class="du lm ln lo lp b">complex</code>、<code class="du lm ln lo lp b">hint</code>和<code class="du lm ln lo lp b">none</code>。</p><p id="d925" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">同时，从分片策略中提取出分片算法。现在用户可以在属性<code class="du lm ln lo lp b">shardingAlgorithm</code>下配置它，并指定<code class="du lm ln lo lp b">shardingAlgorithmName</code>作为分片策略中的参考。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lr"><img src="../Images/7dc829858e3cf1895c097ba502a8dfa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Axud4XskApQj_ISpmYaJAw.png"/></div></div></figure><p id="8783" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">上面的代码块是新的配置，不同于4.1.1 GA版本中的分片配置。新的分片API更加简洁明了。</p><p id="c10b" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">为了帮助用户减少配置工作量，Apache ShardingSphere提供了许多内置的分片算法，他们也可以通过分片算法<code class="du lm ln lo lp b">CLASS_BASED</code>选择自定义设置。有关内置分片算法的更多信息，请阅读<em class="lt">“内置算法-分片算法”</em>:</p><p id="222e" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">为了实现透明的数据分片，我们在5.0.0 GA版本中添加了自动化分片策略。下面的代码块向您展示了自动分片策略配置和手动分片策略配置之间的区别:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lr"><img src="../Images/57eb83f27c16a278c8b1da0fa5ddc952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4qsyyQGZdN-BclbAEsRCwg.png"/></div></div></figure><p id="a504" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">自动分片策略必须在<code class="du lm ln lo lp b">autoTables </code>属性下配置。用户只需通过自动分片算法指定数据存储的数据源以及分片的数量。他们不再需要通过<code class="du lm ln lo lp b">actualDataNodes</code>手动设置数据分布，或者额外关注设置数据库分片策略和表分片策略，因为Apache ShardingSphere会自动帮助用户管理数据分片。</p><p id="129d" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">我们也从数据分片API中移除了<code class="du lm ln lo lp b">defaultDataSourceName</code>。我们反复强调Apache ShardingSphere现在是一个分布式数据库生态系统。我们想向用户传达的信息是，您可以直接使用Apache ShardingSphere提供的服务，但是当您使用这些服务时，您可能会感觉您只是在使用传统的数据库。您不必感知底层数据库存储。Apache ShardingSphere内置的<code class="du lm ln lo lp b">SingleTableRule</code>可以管理数据分片之外的单表，旨在帮助用户实现单表自动加载&amp;路由。</p><p id="6613" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">此外，为了进一步简化配置，结合数据分片API中的<code class="du lm ln lo lp b">defaultDatabaseStrategy</code>和<code class="du lm ln lo lp b">defaultTableStrategy</code>分片策略，还增加了默认分片键defaultShardingColumn。</p><p id="94d3" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">当多个表具有相同的分片键时，用户只需要使用默认的defaultshardingcolumnfiguration，而不是shardingColumn。t_order表的分片策略是通过默认的defaultshardingcolumnfiguration设置的(参见下面的代码)。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lu"><img src="../Images/a7637d8c75a6f3a8c87644440fadc3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8QeA2zawvuGAkPWXT8M4fg.png"/></div></div></figure><ul class=""><li id="3eff" class="jf jg hi ij b ik il io ip is jh iw ji ja jj je jk jl jm jn bi translated"><strong class="ij hj">读/写拆分API </strong></li></ul><p id="b223" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">在5.0.0 GA版本中，我们没有对读/写拆分API进行大量更改。我们只从<code class="du lm ln lo lp b">MasterSlave</code>调整到<code class="du lm ln lo lp b">ReadWriteSplitting</code>，其他用法不变。以下代码块向您展示了4.1.1 GA版本和5.0.0 GA版本的读/写拆分API之间的差异。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lv"><img src="../Images/a07151c0a3298dc11b9081e889251797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EmS99AVum8AYBbNNoUjJeQ.png"/></div></div></figure><p id="854b" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">此外，在可插拔架构中开发的高可用性功能加上读/写拆分可以提供主设备和从设备之间的自动切换，从而产生高可用性版本的读/写拆分。如果你对高可用性功能感兴趣，请关注我们的GitHub repo或socials。我们将很快发布相关文档和技术博客。</p><ul class=""><li id="cf35" class="jf jg hi ij b ik il io ip is jh iw ji ja jj je jk jl jm jn bi translated"><strong class="ij hj">加密&amp;解密API </strong></li></ul><p id="4a88" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">我们在加密&amp;解密API中加入<code class="du lm ln lo lp b">table</code>级别的<code class="du lm ln lo lp b">queryWithCipherColumn</code>属性，方便用户在一个表中切换加密/解密字段的明文和密文。5.0.0版API没有其他变化。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lw"><img src="../Images/3504db64b0fe9149e3d4ea97ec5cf637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xkdl2JE04pmPKSmqvnuXlQ.png"/></div></div></figure><ul class=""><li id="b33d" class="jf jg hi ij b ik il io ip is jh iw ji ja jj je jk jl jm jn bi translated"><strong class="ij hj">影子数据库压力测试API </strong></li></ul><p id="0c70" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">我们在5.0.0 GA版本中完全调整了影子数据库压力测试API。第一个调整是删除影子数据库中的逻辑列，创建影子数据库匹配算法，帮助用户灵活控制路由。</p><p id="bb6c" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">下面的代码块是旧的4.1.1 GA版本的影子数据库压力测试API。老实说，功能相当简单:根据逻辑列值，用户可以判断是否启用影子数据库压力测试。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lx"><img src="../Images/7dee0e5453ffd459a461cff540cdf450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMKvXmwsDQWPUfiOgae4YA.png"/></div></div></figure><p id="3c75" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">在5.0.0 GA版本中，影子数据库压力测试API要强大得多。用户可以通过<code class="du lm ln lo lp b">enable</code>属性启用测试。同时实现了对生产表的细粒度控制。</p><p id="44eb" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">新的API还支持多种匹配算法，如列值匹配算法、列正则表达式匹配算法和SQL注释匹配算法。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ly"><img src="../Images/ea91efa86dd9538a30496b8b598b537d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhE3hrpP_5AqtllejYxhdw.png"/></div></div></figure><p id="a95e" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">由于文章的字数限制，我们无法详细介绍影子数据库压力测试功能——但我们将很快分享更多相关的技术内容。如果你对影子数据库匹配算法感兴趣，请阅读<em class="lt">“影子算法”</em>:<a class="ae lj" href="https://shardingsphere.apache.org/document/5.0.0/en/user-manual/shardingsphere-jdbc/configuration/built-in-algorithm/shadow/" rel="noopener ugc nofollow" target="_blank">https://sharding sphere . Apache . org/document/5 . 0 . 0/en/user-manual/sharding sphere-JDBC/configuration/built-in-Algorithm/Shadow/</a></p><h2 id="9b9e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd is ke kf kg iw kh ki kj ja kk kl km kn bi translated"><strong class="ak">Apache sharding sphere 5 . 0 . 0升级指南</strong></h2><p id="8dd7" class="pw-post-body-paragraph ih ii hi ij b ik ko im in io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je hb bi translated">在前面的章节中，我们讨论了一些与5.0.0 GA的内核相关的优化，即可插拔内核、联邦执行引擎和内核函数API调整。后面还有额外的区别要讨论，<strong class="ij hj">不过我猜你现在最关心的是如何从4.1.1 GA升级到5.0.0 GA版本。</strong></p><p id="86b6" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">在本节中，我们将以集成数据分片、读/写拆分和加密/解密的典型场景为例，详细说明您在升级过程中可能遇到的一些问题的解决方案。</p><p id="a8d3" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">使用4.1.1 GA版本，您必须在数据分片上添加读/写拆分和加密/解密。旧版本的配置如下所示:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lz"><img src="../Images/6ae64b4d301ce1bdf408130b2760c599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SlOIF9_dZSjs3vTr8Zf_ag.png"/></div></div></figure><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ma"><img src="../Images/5b6abfb71f24fbc041c54e120be4ac13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3kzLzZ9iHcnkkWLrMnWOw.png"/></div></div></figure><p id="2686" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">在上面的配置中，<code class="du lm ln lo lp b">t_order</code>和<code class="du lm ln lo lp b">t_order_item </code>配置了分片规则，<code class="du lm ln lo lp b">t_order </code>表的<code class="du lm ln lo lp b">content </code>字段也设置了AES加密器算法的加密规则。<code class="du lm ln lo lp b">t_user </code>是非共享表，<code class="du lm ln lo lp b">telephone</code>字段也配置了加密规则。此外，请注意，读/写分割规则和加密规则在碎片规则中被配置为属性。这样的配置证明了4.1.1 GA中其他功能都严重依赖数据分片。</p><p id="6c07" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">配置完成后，我们启动4.1.1 GA版本的代理适配器并初始化<code class="du lm ln lo lp b">t_order</code>、<code class="du lm ln lo lp b">t_order_item</code>和<code class="du lm ln lo lp b">t_user</code>表。初始化语句的执行结果如下:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mb"><img src="../Images/7279565c425b459a2574cc826ad0e17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ML7K8Q5hFNIsz0It-VhJsQ.png"/></div></div></figure><p id="f69d" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><code class="du lm ln lo lp b">t_order</code>表分片的路由和重写正常，但加密/解密函数的重写失败。为什么？</p><p id="d73e" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">因为4.1.1 GA版本不支持在加解密场景下重写DDL语句。因此，用户必须事先在底层数据库上创建加密和解密表。<strong class="ij hj">目前，DDL语句的加密和解密重写在5.0.0 GA版本中已经完善，用户不再需要重复不必要的操作</strong>。</p><p id="fc87" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">由于<code class="du lm ln lo lp b">t_order_item</code>表不需要加密或解密，其路由&amp;重写结果是正常的。但是，<code class="du lm ln lo lp b">t_user</code>表也有加密/解密DDL语句重写失败的问题，更糟糕的是，<code class="du lm ln lo lp b">t_user</code>表被路由到ds_0数据源。为了解决这些问题，我们在分片规则中配置了<code class="du lm ln lo lp b">defaultDataSourceName: ds_0</code>。该规则设计用于路由非共享表。</p><p id="5281" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">至于<code class="du lm ln lo lp b">t_order</code>表和<code class="du lm ln lo lp b">t_user</code>表，我们使用下面的SQL语句，并在路由结果的底层数据库上手动创建加密/解密表。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lv"><img src="../Images/5af65f90e0810272475bd1cb4ff0d716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bg8wXxpBRFQFFY1BDQVM-g.png"/></div></div></figure><p id="4fbb" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">重启代理后，我们将数据添加到<code class="du lm ln lo lp b">t_order</code>、<code class="du lm ln lo lp b">t_order_item</code>和<code class="du lm ln lo lp b">t_user</code>表中，在此期间，数据将根据分片键和配置的分片策略被路由到数据节点。根据<code class="du lm ln lo lp b">defaultDataSourceName</code>配置将<code class="du lm ln lo lp b">t_user</code>表路由至<code class="du lm ln lo lp b">ds_0</code>数据源。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lx"><img src="../Images/812d8cf38db9ac88be01ab1eb701f540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0pv2OOVOMTNrdlVbbwQ_g.png"/></div></div></figure><p id="56ec" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">然后，我们可以执行一些简单的查询语句来检查读/写拆分功能是否有效。在日志中可以看到,<code class="du lm ln lo lp b">t_order</code>和<code class="du lm ln lo lp b">t_order_item</code>表已经被加密、解密和重写，并且它们也被路由到正确的从数据库。然而，当配置的读写分离不起作用时，<code class="du lm ln lo lp b">t_user</code>表仍然被路由到<code class="du lm ln lo lp b">ds_0</code>数据源进行执行。为什么？</p><p id="a959" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">因为在4.1.1 GA版本中，读/写拆分和加密&amp;解密被集成到数据分片中，自然限制了分片以外的功能。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mc"><img src="../Images/b80ed1d9590959a0e4ac21f2500c3c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZI6fqYCLzxABWWyJ4Vtvyw.png"/></div></div></figure><p id="600d" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj">5 . 0 . 0 GA版本采用可插拔架构和升级内核，允许用户不受任何限制地组合这些功能。此外，在新版本中，我们删除了</strong> <code class="du lm ln lo lp b"><strong class="ij hj">defaultDataSourceName</strong></code> <strong class="ij hj">，因此用户不再需要额外的配置。现在ShardingSphere默认通过</strong> <code class="du lm ln lo lp b"><strong class="ij hj">SingleTableRule</strong></code> <strong class="ij hj">实现单表元数据加载和路由。</strong>我们来看看5.0.0 GA版本中的功能是如何配置和使用的。配置代码如下所示:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es md"><img src="../Images/b590dea288f657483677a5cfc5fc2666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-4FVMILmmaLRyhLPLXm4Xw.png"/></div></div></figure><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es me"><img src="../Images/9cc571212539db351ebe5c530d4ca6e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*ii4mmLQfrdEh2ow5Na2QWg.png"/></div></figure><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es me"><img src="../Images/6cbf86edb9018fe4007b18bb859ab6f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*3oi5TY3_3CpZlVsZhajjVw.png"/></div></div></figure><p id="5378" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj">5 . 0 . 0 GA版本和4.1.1 GA版本最大的配置区别在于不同功能之间的关系。在5.0.0版本中，它们的位置是平行独立的，不像4.1.1 GA中的函数依赖关系。用户可以灵活地加载或卸载这些可插拔功能。当您一起使用一些功能时，部署非常类似于交付管道。</strong></p><p id="d079" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">比如你的读写拆分规则是基于两套主从关系，然后聚合两个逻辑数据源，分别是<code class="du lm ln lo lp b">ms_ds_0</code>和<code class="du lm ln lo lp b">ms_ds_1</code>；那么由于你的数据分片规则是基于读/写拆分聚合的逻辑数据源，你配置的数据分片规则聚合逻辑表<code class="du lm ln lo lp b">t_order</code>；加密/解密功能侧重于重写列和值，并为数据分片功能聚集的逻辑表配置加密和解密规则。读写拆分、数据分片、加解密等功能逐一转移，同时通过修饰的方式不断增加功能。</p><p id="90fd" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">为了与4.1.1 GA版本的功能进行比较，我们执行相同的初始化语句、Insert Into语句和Query语句来测试5.0.0 GA版本。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ll"><img src="../Images/70c554ad4977b58d635075e0e3aabcc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BMOrzUauJfCUSJ3Kl3CEzw.png"/></div></div></figure><p id="f062" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">5.0.0 GA版本支持重写加密和解密DDL语句，因此在创建<code class="du lm ln lo lp b">t_order</code>时，数据分片、读写拆分和加密/解密中的路由和重写执行得很好。</p><p id="f9fc" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">您可以在日志中看到，<code class="du lm ln lo lp b">t_user</code>表被路由到<code class="du lm ln lo lp b">ds_1</code>数据源进行执行。在5.0.0 GA版本中，虽然<code class="du lm ln lo lp b">t_user</code>表是单个表，但是用户不需要配置数据源，因为当表创建语句执行时，ShardingSphere可以随机选择一个数据源进行路由。为了保证精确的路由结果，我们必须保证它在逻辑数据库中的唯一性。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mf"><img src="../Images/acf811355f608154ccca52fcb50f1484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ER_JoRTL_XR3mI3PQIVnw.png"/></div></div></figure><p id="6ed7" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">当您将数据插入到<code class="du lm ln lo lp b">t_user</code>表中时，会根据存储在元数据中的信息执行自动路由。例如，由于在前面的步骤中<code class="du lm ln lo lp b">t_user</code>被路由到<code class="du lm ln lo lp b">ds_1</code>数据源，其他语句将跟随元数据<code class="du lm ln lo lp b">t_user: ds_1</code>。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ll"><img src="../Images/3a5ca77c5ca58705661b48dd1ad26c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wI8ZiMUpTifd3N4uUUnvhQ.png"/></div></div></figure><p id="a6fe" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">当我们执行查询语句时，我们发现<code class="du lm ln lo lp b">t_user</code>表被路由到<code class="du lm ln lo lp b">ds_1_slave_0</code>数据源，这样就完成了对单个表的读/写拆分。Apache ShardingSphere 5.0.0 GA内核可以通过元数据加载在内部维护单个表的数据分布信息；我们还充分考虑了不同函数组合的场景，使得Apache ShardingSphere完美支持单个表上的操作。</p><p id="2b9f" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">当然，5.0.0 GA版本还有更多新特性。在本升级指南中，我们仅比较两个GA版本中支持的一些功能。我们希望本文能够帮助您了解新特性，并成功实现版本升级。如果你有兴趣，请访问我们的repo，或者请阅读我们的文档并自行测试新版本。</p><h2 id="bea6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd is ke kf kg iw kh ki kj ja kk kl km kn bi translated"><strong class="ak">结论</strong></h2><p id="3b1f" class="pw-post-body-paragraph ih ii hi ij b ik ko im in io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je hb bi translated">经过两年的开发，带有<strong class="ij hj">可插拔内核的全新Apache ShardingSphere为所有开发者提供了无限的开发可能性。未来，我们将继续开发更多可插拔内核的新特性，以惊人的功能扩展Apache ShardingSphere生态系统。</strong>联邦执行引擎只是分布式查询的开始。我们将更加努力地优化其内存和性能，为您提供更加可靠和高效的分布式查询。</p><p id="cea3" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">一如既往，欢迎您加入我们开发Apache ShardingSphere项目。</p><h2 id="8afa" class="jt ju hi bd jv jw jx jy jz ka kb kc kd is ke kf kg iw kh ki kj ja kk kl km kn bi translated"><strong class="ak">参考文献</strong></h2><ol class=""><li id="8aae" class="jf jg hi ij b ik ko io kp is mg iw mh ja mi je mj jl jm jn bi translated">Apache ShardingSphere发行说明:https://github . com/Apache/sharding sphere/releases</li><li id="3ba9" class="jf jg hi ij b ik jo io jp is jq iw jr ja js je mj jl jm jn bi translated">5.x版的全新分片配置API:https://github . com/Apache/sharding sphere/issues/5017</li><li id="257f" class="jf jg hi ij b ik jo io jp is jq iw jr ja js je mj jl jm jn bi translated">数据库和表的自动分片策略:https://github . com/Apache/Sharding sphere/issues/5937</li><li id="ec55" class="jf jg hi ij b ik jo io jp is jq iw jr ja js je mj jl jm jn bi translated">投稿指南:<a class="ae lj" href="https://shardingsphere.apache.org/community/en/contribute/" rel="noopener ugc nofollow" target="_blank">https://shardingsphere.apache.org/community/en/contribute/</a></li><li id="32b1" class="jf jg hi ij b ik jo io jp is jq iw jr ja js je mj jl jm jn bi translated"><a class="ae lj" href="https://docs.oracle.com/en/" rel="noopener ugc nofollow" target="_blank">https://docs.oracle.com/en/</a></li><li id="40ea" class="jf jg hi ij b ik jo io jp is jq iw jr ja js je mj jl jm jn bi translated"><a class="ae lj" href="https://www.mysql.com/customers/view/?id=1461" rel="noopener ugc nofollow" target="_blank">https://www.mysql.com/customers/view/?id=1461</a></li><li id="b7a3" class="jf jg hi ij b ik jo io jp is jq iw jr ja js je mj jl jm jn bi translated"><a class="ae lj" rel="noopener" href="/codex/create-a-distributed-database-solution-based-on-postgresql-opengauss-b30d0e1ced2c">https://medium . com/codex/create-a-distributed-database-solution-based-on-PostgreSQL-open gauss-b 30d 0 E1 ced 2c</a></li></ol><h2 id="a56a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd is ke kf kg iw kh ki kj ja kk kl km kn bi translated">开源项目链接:</h2><p id="5ca9" class="pw-post-body-paragraph ih ii hi ij b ik ko im in io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je hb bi translated"><strong class="ij hj"><em class="lt">sharding sphere Github:</em></strong><a class="ae lj" href="https://github.com/apache/shardingsphere" rel="noopener ugc nofollow" target="_blank">https://github.com/apache/shardingsphere</a></p><p id="3da0" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj">https://twitter.com/ShardingSphere</strong>T21<a class="ae lj" href="https://twitter.com/ShardingSphere" rel="noopener ugc nofollow" target="_blank"/></p><p id="0201" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj"> <em class="lt"> ShardingSphere Slack频道:</em></strong><a class="ae lj" href="https://join.slack.com/t/apacheshardingsphere/shared_invite/zt-sbdde7ie-SjDqo9~I4rYcR18bq0SYTg" rel="noopener ugc nofollow" target="_blank">https://join . Slack . com/t/Apache sharding sphere/shared _ invite/ZT-sbd de 7 ie-sjdqo 9 ~ I 4 rycr 18 bq 0 sytg</a></p><p id="2e2a" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj"> <em class="lt"> GitHub问题:</em></strong>【https://github.com/apache/shardingsphere/issues】T4</p><p id="9911" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated"><strong class="ij hj"> <em class="lt">投稿指南:</em></strong><a class="ae lj" href="https://shardingsphere.apache.org/community/cn/contribute/" rel="noopener ugc nofollow" target="_blank">https://shardingsphere.apache.org/community/cn/contribute/</a></p><h2 id="9aa6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd is ke kf kg iw kh ki kj ja kk kl km kn bi translated"><strong class="ak">作者</strong></h2><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es mk"><img src="../Images/38dfd45a36b7b5caf6e395d49a90f98a.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*jThBLLZ_cm3jm7Xhq4OgeA.png"/></div></figure><p id="afc4" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">段郑强</p><blockquote class="ml mm mn"><p id="c4f6" class="ih ii lt ij b ik il im in io ip iq ir mo it iu iv mp ix iy iz mq jb jc jd je hb bi translated">SphereEx高级中间件开发工程师&amp; Apache ShardingSphere委员会成员</p></blockquote><p id="ec2b" class="pw-post-body-paragraph ih ii hi ij b ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je hb bi translated">他于2018年开始为Apache ShardingSphere中间件做出贡献，此前曾是众多数据分片项目的工程师领导。他喜欢开源，并与他人分享他的技术故事和经验。他现在致力于开发Apache ShardingSphere内核模块。</p></div></div>    
</body>
</html>