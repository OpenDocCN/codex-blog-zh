<html>
<head>
<title>Un-permitted Parameters in Ruby on Rails — Why they don’t raise errors, and should they?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby on Rails中不允许的参数——为什么它们没有引发错误，它们应该引发错误吗？</h1>
<blockquote>原文：<a href="https://medium.com/codex/un-permitted-parameters-in-ruby-on-rails-why-they-dont-raise-errors-and-should-they-354a6c5ee759?source=collection_archive---------2-----------------------#2021-08-25">https://medium.com/codex/un-permitted-parameters-in-ruby-on-rails-why-they-dont-raise-errors-and-should-they-354a6c5ee759?source=collection_archive---------2-----------------------#2021-08-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/f88665390475bfd538965b2bf2a80d97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZzgofBiE-2KkF121AdqNg.jpeg"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">不要输入标志，贷方:<em class="jc"> Unsplash </em></figcaption></figure><p id="e9d8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi kb translated">在使用Ruby on Rails后端进行我最近的项目时，我注意到在使用批量赋值和强参数时有一个有趣的默认行为。如果你需要复习RoR的强参数，请点击这里查看文档<a class="ae kk" href="https://api.rubyonrails.org/classes/ActionController/StrongParameters.html" rel="noopener ugc nofollow" target="_blank"/>！</p><p id="0405" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">对于这个项目，我只是在后端工作，所以我使用<a class="ae kk" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮递员</a>来检查我的路线，确保一切正常。在这里，我注意到任何不允许的参数都被自动过滤掉了，并返回一个2xx的HTML状态代码(“OK”或“Created”取决于场景)。我想知道为什么在试图传入一个不允许的参数时没有4xx HTML代码，所以我做了一些调查！让我们从头开始，建立这个项目的一部分。</p><h2 id="fd24" class="kl km hi bd kn ko kp kq kr ks kt ku kv jo kw kx ky js kz la lb jw lc ld le lf bi translated"><strong class="ak">在Ruby on Rails中构建一个简单的用户模型</strong></h2><p id="9938" class="pw-post-body-paragraph jd je hi jf b jg lg ji jj jk lh jm jn jo li jq jr js lj ju jv jw lk jy jz ka hb bi translated">假设我们正在为我们的应用程序构建一个用户。我们首先使用内置的rails生成器来创建我们需要的一切；我们数据库的模型、控制器、路由和模式。<code class="du ll lm ln lo b">rails g resource User username password_digest --no-test-framework</code>。</p><blockquote class="lp lq lr"><p id="92b2" class="jd je ls jf b jg jh ji jj jk jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz ka hb bi translated">*我喜欢添加<code class="du ll lm ln lo b">--no-test-framework</code>，它删除了我们用户模型的规范文件，因为对于这个项目，我不会做任何TDD(测试驱动开发)。</p></blockquote><p id="0174" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们的用户模型已经创建好了，它有了<code class="du ll lm ln lo b">username</code>和<code class="du ll lm ln lo b">password_digest</code>的参数。</p><blockquote class="lw"><p id="d9cc" class="lx ly hi bd lz ma mb mc md me mf ka dx translated">当使用安全加密我们密码的<a class="ae kk" href="https://github.com/bcrypt-ruby/bcrypt-ruby" rel="noopener ugc nofollow" target="_blank"> bcrypt </a> Ruby gem时，我们使用<code class="du ll lm ln lo b">password_digest</code>。但是，在创建新用户时，我们仍然应该在Postman中的JSON主体中使用<code class="du ll lm ln lo b">{"password": "&lt;insert-password&gt;"}</code>来创建它。</p></blockquote><p id="d2b2" class="pw-post-body-paragraph jd je hi jf b jg mg ji jj jk mh jm jn jo mi jq jr js mj ju jv jw mk jy jz ka hb bi translated">为了允许使用<code class="du ll lm ln lo b">:password</code>和<code class="du ll lm ln lo b">:username</code>参数，我们将<code class="du ll lm ln lo b">user_params</code>方法作为私有方法添加到我们的<code class="du ll lm ln lo b">UsersController</code>中。确保将这些参数传递给我们的<code class="du ll lm ln lo b">create</code>方法。此时，我们的整个代码应该如下所示:</p><pre class="in io ip iq fd ml lo mm mn aw mo bi"><span id="92dc" class="kl km hi lo b fi mp mq l mr ms">class UsersController &lt; ApplicationController</span><span id="721b" class="kl km hi lo b fi mt mq l mr ms">def create<br/>    user = User.create(user_params)<br/>    render json: user, status: :created<br/>end</span><span id="b39f" class="kl km hi lo b fi mt mq l mr ms">private</span><span id="79ed" class="kl km hi lo b fi mt mq l mr ms">def user_params<br/>    params.permit(:password, :username)<br/>end</span></pre><h2 id="0850" class="kl km hi bd kn ko kp kq kr ks kt ku kv jo kw kx ky js kz la lb jw lc ld le lf bi translated">在邮递员中测试</h2><p id="4dd1" class="pw-post-body-paragraph jd je hi jf b jg lg ji jj jk lh jm jn jo li jq jr js lj ju jv jw lk jy jz ka hb bi translated">现在，在Postman中，假设我试图创建一个新用户，但是为<code class="du ll lm ln lo b">email</code>传入一个参数。默认行为是过滤掉不允许的参数，保留上面定义的允许的参数。结果是创建了一个新用户，HTTP代码为201(按照上面代码中的定义创建的)，email参数被过滤掉。</p><p id="33df" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果我们想知道在构建应用程序的开发过程中什么是不允许的参数，该怎么办？如果我们不知不觉地传入了一个错误的参数，并想在部署之前调试我们的程序，该怎么办？</p><p id="f8f9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">幸运的是，我们有办法提出rails内置的错误！</p><h1 id="839e" class="mu km hi bd kn mv mw mx kr my mz na kv nb nc nd ky ne nf ng lb nh ni nj le nk bi translated">如何为不允许的参数引发错误</h1><p id="ee50" class="pw-post-body-paragraph jd je hi jf b jg lg ji jj jk lh jm jn jo li jq jr js lj ju jv jw lk jy jz ka hb bi translated">查看rails/strong_parameters的文档，特别是对不允许的键<a class="ae kk" href="https://github.com/rails/strong_parameters#handling-of-unpermitted-keys" rel="noopener ugc nofollow" target="_blank">的处理。您将会看到，只要您拥有rails版本4或更高版本，就已经有了为不允许的参数引发错误的能力！说明在链接中，但是我还需要一些额外的步骤来呈现错误。我会这么做！</a></p><ol class=""><li id="605c" class="nl nm hi jf b jg jh jk jl jo nn js no jw np ka nq nr ns nt bi translated">转到<code class="du ll lm ln lo b">config/environments/development.rb</code>并添加<code class="du ll lm ln lo b">config.action_controller.action_on_unpermitted_parameters = :raise</code>这将导致当您传递一个在更新或创建操作中不允许的参数时，弹出<code class="du ll lm ln lo b"><em class="ls">ActionController</em>::UnpermittedParameters</code>错误，只要您有<code class="du ll lm ln lo b">create!</code>或<code class="du ll lm ln lo b">update!</code>并在其后带有<code class="du ll lm ln lo b">!</code>。</li><li id="e4dd" class="nl nm hi jf b jg nu jk nv jo nw js nx jw ny ka nq nr ns nt bi translated">然后你可以在你想要的控制器文件的顶部使用一个<code class="du ll lm ln lo b">rescue_from</code>来挽救这个错误，就像这样:<br/> <code class="du ll lm ln lo b">rescue_from <em class="ls">ActionController</em>::UnpermittedParameters, with: :&lt;name-of-method&gt;</code></li><li id="461e" class="nl nm hi jf b jg nu jk nv jo nw js nx jw ny ka nq nr ns nt bi translated">请确保将该方法添加到您的私有方法中！您可以自定义错误消息。我选择让它呈现不允许的参数的key:value对，如下所示:<br/> <code class="du ll lm ln lo b">render json: { "Unpermitted Parameters": <a class="ae kk" href="http://params.to/" rel="noopener ugc nofollow" target="_blank">params.to</a>_unsafe_h.except(:controller, :action, &lt;include-your-permitted-params-here!!&gt;)}, status: :unprocessable_entity</code></li><li id="4603" class="nl nm hi jf b jg nu jk nv jo nw js nx jw ny ka nq nr ns nt bi translated">在<code class="du ll lm ln lo b">params</code>上使用<code class="du ll lm ln lo b">.to_unsafe_h</code>将会把所有的参数变成一个标准的Ruby散列。除非参数都被允许，否则不能在参数上使用<code class="du ll lm ln lo b">.to_h</code>，这就是<code class="du ll lm ln lo b">.to_unsafe_h</code>存在的原因。然后我使用<code class="du ll lm ln lo b">.except</code>从错误消息中排除允许的参数，因为我们只想显示导致错误的参数！</li></ol><p id="9a4a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们最终版本的<code class="du ll lm ln lo b">UsersController</code>将会是这样的:</p><pre class="in io ip iq fd ml lo mm mn aw mo bi"><span id="c51e" class="kl km hi lo b fi mp mq l mr ms">class UsersController &lt; ApplicationController<br/>wrap_parameters format: []<br/>rescue_from <em class="ls">ActionController</em>::UnpermittedParameters, with: :render_unpermitted_params_response</span><span id="2ffe" class="kl km hi lo b fi mt mq l mr ms">def create<br/>    user = User.create!(user_params)<br/>    render json: user, status: :created<br/>end</span><span id="1332" class="kl km hi lo b fi mt mq l mr ms">def update<br/>    user = <em class="ls">User</em>.find(params[:id])<br/>    user.update!(user_params)<br/>    render json: user<br/>end</span><span id="4823" class="kl km hi lo b fi mt mq l mr ms">private </span><span id="9cf3" class="kl km hi lo b fi mt mq l mr ms">def user_params<br/>    params.permit(:password, :username)<br/>end</span><span id="a850" class="kl km hi lo b fi mt mq l mr ms">def render_unpermitted_params_response<br/>    render json: { "Unpermitted Parameters": params.to_unsafe_h.except(:controller, :action, :id, :username, :password).keys }, status: :unprocessable_entity<br/>end</span></pre><p id="eff2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，当传入一个不允许的参数时，我们会收到一条错误消息，显示哪些键是不允许的，同时还会显示一个HTTP状态代码422。太好了！有用！但是……什么时候需要有这种行为呢？</p><blockquote class="lw"><p id="c542" class="lx ly hi bd lz ma mb mc md me mf ka dx translated">我们改变行为是为了发展，而不是生产。为什么不两者都要？</p></blockquote><p id="f260" class="pw-post-body-paragraph jd je hi jf b jg mg ji jj jk mh jm jn jo mi jq jr js mj ju jv jw mk jy jz ka hb bi translated">在生产中，将任何不允许的参数作为默认行为过滤掉更有意义。我只建议在开发过程中加入这个行为来调试。理想情况下，在一个完整的全栈应用程序中，您应该创建自己的前端来控制表单，并确定客户端传入什么信息，同时利用RoR验证来检查它们的响应。</p><blockquote class="lp lq lr"><p id="73ff" class="jd je ls jf b jg jh ji jj jk jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz ka hb bi translated">应用程序的客户端不应该能够传入不允许的<em class="hi">键</em>，只要你记住这一点就可以了！</p></blockquote><p id="58d9" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jf hj">希望这为您的调试工具箱提供了另一个工具！编码快乐！</strong></p></div></div>    
</body>
</html>