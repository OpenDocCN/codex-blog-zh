<html>
<head>
<title>SQL Stored Procedures: Cursors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL存储过程:游标</h1>
<blockquote>原文：<a href="https://medium.com/codex/sql-stored-procedures-cursors-2e4984d39599?source=collection_archive---------5-----------------------#2021-08-31">https://medium.com/codex/sql-stored-procedures-cursors-2e4984d39599?source=collection_archive---------5-----------------------#2021-08-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1c8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个故事中，我们将介绍什么是游标以及有关游标的基本语法。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/c2135ce19e0f6fddb836c86b0cc925ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGFTxowhCjZlBoH0HrnE4g.png"/></div></div></figure><h1 id="fe8c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">什么是SQL游标？</h1><p id="1d19" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">游标为我们提供了对单个记录执行操作的能力，而默认的SQL行为使我们能够对一组数据进行操作。游标指向数据集中的单个记录，并沿表移动以对后续记录进行操作。</p><p id="bbd9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">游标为我们提供了一种非常精细的操作单个记录的方式，因此游标操作比通常的操作要慢，因为在单个记录中移动需要更多的时间。</p><p id="a377" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们把手弄脏。</p><ol class=""><li id="5e8c" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated"><strong class="ih hj">声明光标</strong></li></ol><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="1b61" class="lg jq hi lc b fi lh li l lj lk">DECLARE Cursor_Name CURSOR<br/>    FOR SELECT Col1, Col2 FROM [dbo].[table1]</span></pre><p id="45a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要定义一个游标，我们只需使用<code class="du ll lm ln lc b">DECLARE</code>语句，后跟游标名称，然后将数据类型定义为<code class="du ll lm ln lc b">CURSOR</code>。游标总是为一组记录声明，然后我们使用<code class="du ll lm ln lc b">FOR</code>语句指向那组记录。<code class="du ll lm ln lc b">SELECT</code>语句后面是<code class="du ll lm ln lc b">FOR</code>语句，用于定义我们想要操作的记录集。</p><p id="85dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">打开&amp;关闭光标</strong></p><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="143d" class="lg jq hi lc b fi lh li l lj lk">OPEN Cursor_Name<br/>    -- Do Something<br/>CLOSE Cursor_Name<br/>DEALLOCATE Cursor_Name</span></pre><p id="f129" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要开始使用光标，我们首先需要打开它。使用<code class="du ll lm ln lc b">OPEN</code>关键字后跟光标名称来打开它。然后我们编写使用打开的光标的代码。当使用光标的代码被执行时，我们可以使用<code class="du ll lm ln lc b">CLOSE</code>关键字后跟光标名称来关闭它。</p><p id="d045" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此时，光标仍然停留在SQL的工作内存中，并且位于它的最后一个位置。要删除对光标的任何引用，我们只需使用<code class="du ll lm ln lc b">DEALLOCATE</code>关键字来释放与光标相关的所有内存。</p><p id="f83b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj">读取单个记录</strong></p><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="0412" class="lg jq hi lc b fi lh li l lj lk">OPEN Cursor_Name<br/>    FETCH NEXT FROM Cursor_Name<br/>CLOSE Cursor_Name<br/>DEALLOCATE Cursor_Name</span></pre><p id="66ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了将光标移动到第一条记录，我们使用了<code class="du ll lm ln lc b">FETCH NEXT FROM</code>子句，后跟光标名称。这将光标移动到所选记录集中的第一条记录。</p><p id="9bcf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.<strong class="ih hj">读取多条记录(从第一条到最后一条)</strong></p><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="a7e0" class="lg jq hi lc b fi lh li l lj lk">DECLARE Cursor_Name CURSOR<br/>    FOR SELECT Col1, Col2 FROM [dbo].[table1]</span><span id="b6c6" class="lg jq hi lc b fi lo li l lj lk">OPEN Cursor_Name<br/>    FETCH NEXT FROM Cursor_Name</span><span id="8a79" class="lg jq hi lc b fi lo li l lj lk">    WHILE @@FETCH_STATUS=0<br/>        FETCH NEXT FROM Cursor_Name</span><span id="9fb1" class="lg jq hi lc b fi lo li l lj lk">CLOSE Cursor_Name<br/>DEALLOCATE Cursor_Name</span></pre><p id="1c08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了读取多个记录，我们使用了全局变量<code class="du ll lm ln lc b">@@FETCH_STATUS</code>。在游标能够提取记录之前，此变量等于0。如果游标无法获取记录，则该值不为0。所以我们使用<code class="du ll lm ln lc b">WHILE @@FETCH_STATUS=0</code>继续循环。要读取下一条记录，我们只需使用<code class="du ll lm ln lc b">FETCH NEXT FROM</code>语句。</p><p id="7e0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当光标到达最后一条记录时，<code class="du ll lm ln lc b">FETCH NEXT FROM</code>没有成功获取下一条记录，并且<code class="du ll lm ln lc b">@@FETCH_STATUS</code>不再为0，因此循环中断。至此，我们已经逐个读取了所选集合中的所有记录。</p><p id="164b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.<strong class="ih hj">读取多条记录(从最后一条到第一条)</strong></p><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="fcb9" class="lg jq hi lc b fi lh li l lj lk">DECLARE Cursor_Name CURSOR SCROLL<br/>    FOR SELECT Col1, Col2 FROM [dbo].[table1]</span><span id="b8c0" class="lg jq hi lc b fi lo li l lj lk">OPEN Cursor_Name<br/>    FETCH LAST FROM Cursor_Name</span><span id="9532" class="lg jq hi lc b fi lo li l lj lk">WHILE @@FETCH_STATUS=0<br/>        FETCH PRIOR FROM Cursor_Name</span><span id="bf06" class="lg jq hi lc b fi lo li l lj lk">CLOSE Cursor_Name<br/>DEALLOCATE Cursor_Name</span></pre><p id="9035" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SQL中有不同类型的游标。一个这样的游标是上面定义的滚动游标，在声明游标时使用<code class="du ll lm ln lc b">CURSOR SCROLL</code>关键字。滚动光标让我们使用<code class="du ll lm ln lc b">FETCH LAST FROM</code>子句从要读取的已定义记录集的最后一条记录开始读取记录。</p><p id="4f7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了从最后到第一个读取记录，我们首先将最后一个记录读入游标，然后使用<code class="du ll lm ln lc b">FETCH PRIOR FROM</code>子句在<code class="du ll lm ln lc b">WHILE</code>循环中向上移动。</p><p id="b022" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lp">注意:滚动光标还允许我们使用类似于</em> <code class="du ll lm ln lc b"><em class="lp">FETCH FIRST FROM</em></code> <em class="lp">的子句来访问第一条记录。如果光标刚刚打开，这相当于</em> <code class="du ll lm ln lc b"><em class="lp">FETCH NEXT FROM</em></code> <em class="lp">。主要区别是滚动光标让我们直接滚动到给定集合中的不同记录，而普通光标从开始移动到结束。</em></p><p id="38f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.<strong class="ih hj">读取第n条记录</strong></p><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="51b2" class="lg jq hi lc b fi lh li l lj lk">DECLARE Cursor_Name CURSOR SCROLL<br/>    FOR SELECT Col1, Col2 FROM [dbo].[table1]</span><span id="df25" class="lg jq hi lc b fi lo li l lj lk">OPEN Cursor_Name<br/>    FETCH ABSOLUTE 5 FROM Cursor_Name</span><span id="ee77" class="lg jq hi lc b fi lo li l lj lk">CLOSE Cursor_Name<br/>DEALLOCATE Cursor_Name</span></pre><p id="09c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了直接读取第<em class="lp">条记录，我们将再次使用滚动光标。在上面的例子中，我们读取了给定集合中的第6条</em>记录(假设它至少有5条记录)。我们简单地使用<code class="du ll lm ln lc b">FETCH ABSOLUTE N-1 FROM</code>子句。这里的<em class="lp"> N </em>是我们要读取的第<em class="lp">N</em>条记录。</p><p id="b3f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了向后读取记录，我们简单地使用<code class="du ll lm ln lc b">FETCH ABSOLUTE -N FROM</code>。这将让我们从末尾读取第n条记录。在下面的例子中，我们从集合的末尾读取第5条记录。</p><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="f192" class="lg jq hi lc b fi lh li l lj lk">DECLARE Cursor_Name CURSOR SCROLL<br/>    FOR SELECT Col1, Col2 FROM [dbo].[table1]</span><span id="194a" class="lg jq hi lc b fi lo li l lj lk">OPEN Cursor_Name<br/>    FETCH ABSOLUTE -5 FROM Cursor_Name</span><span id="8de3" class="lg jq hi lc b fi lo li l lj lk">CLOSE Cursor_Name<br/>DEALLOCATE Cursor_Name</span></pre><p id="edd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">7.<strong class="ih hj">读取记录时步进</strong></p><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="a44e" class="lg jq hi lc b fi lh li l lj lk">DECLARE Cursor_Name CURSOR SCROLL<br/>    FOR SELECT Col1, Col2 FROM [dbo].[table1]</span><span id="4922" class="lg jq hi lc b fi lo li l lj lk">OPEN Cursor_Name<br/>    FETCH ABSOLUTE 5 FROM Cursor_Name</span><span id="ad15" class="lg jq hi lc b fi lo li l lj lk">WHILE @@FETCH_STATUS=0<br/>        FETCH RELATIVE 10 FROM Cursor_Name</span><span id="4ded" class="lg jq hi lc b fi lo li l lj lk">CLOSE Cursor_Name<br/>DEALLOCATE Cursor_Name</span></pre><p id="9e26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码让我们从集合的第五条记录开始。然后我们使用<code class="du ll lm ln lc b">FETCH RELATIVE N FROM</code>从当前点跳转N条记录。循环中读取的下一个记录将是第16个<em class="lp">记录。</em></p><p id="4d0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了逆向阅读，我们简单地否定了关键字<code class="du ll lm ln lc b">RELATIVE</code>后面的数字。</p><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="cc9b" class="lg jq hi lc b fi lh li l lj lk">DECLARE Cursor_Name CURSOR SCROLL<br/>    FOR SELECT Col1, Col2 FROM [dbo].[table1]</span><span id="3dcc" class="lg jq hi lc b fi lo li l lj lk">OPEN Cursor_Name<br/>    FETCH ABSOLUTE -5 FROM Cursor_Name</span><span id="3bc7" class="lg jq hi lc b fi lo li l lj lk">WHILE @@FETCH_STATUS=0<br/>        FETCH RELATIVE -10 FROM Cursor_Name</span><span id="43f0" class="lg jq hi lc b fi lo li l lj lk">CLOSE Cursor_Name<br/>DEALLOCATE Cursor_Name</span></pre><p id="6920" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">8.<strong class="ih hj">变量和光标</strong></p><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="1df9" class="lg jq hi lc b fi lh li l lj lk">DECLARE @ValCol1 INT<br/>DECLARE @ValCol2 VARCHAR(100)</span><span id="14e7" class="lg jq hi lc b fi lo li l lj lk">DECLARE Cursor_Name CURSOR<br/>    FOR SELECT Col1, Col2 FROM [dbo].[table1]</span><span id="dcdb" class="lg jq hi lc b fi lo li l lj lk">OPEN Cursor_Name<br/>    FETCH NEXT FROM Cursor_Name<br/>        INTO @ValCol1, @ValCol2</span><span id="3c37" class="lg jq hi lc b fi lo li l lj lk">WHILE @@FETCH_STATUS=0<br/>        FETCH NEXT FROM Cursor_Name<br/>            INTO @ValCol1, @ValCol2<br/>        SELECT @ValCol1, @ValCol2</span><span id="c36b" class="lg jq hi lc b fi lo li l lj lk">CLOSE Cursor_Name<br/>DEALLOCATE Cursor_Name</span></pre><p id="f77c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了将光标的值读入变量，我们首先创建<code class="du ll lm ln lc b">@ValCol1</code>和<code class="du ll lm ln lc b">@ValCol2</code>来分别存储<code class="du ll lm ln lc b">Col1</code>和<code class="du ll lm ln lc b">Col2</code>的值。接下来，在<code class="du ll lm ln lc b">FETCH NEXT FROM</code>语句之后，我们使用<code class="du ll lm ln lc b">INTO</code>关键字，后跟声明用来存储列值的变量的名称。</p><p id="62ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在<code class="du ll lm ln lc b">WHILE</code>循环的代码块中使用了类似的语法。然后我们做一个<code class="du ll lm ln lc b">SELECT</code>来输出读入变量的值。</p><p id="37f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">9.<strong class="ih hj">光标范围</strong></p><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="e4eb" class="lg jq hi lc b fi lh li l lj lk">DECLARE Cursor_Name CURSOR GLOBAL<br/>    FOR SELECT Col1, Col2 FROM [dbo].[table1]</span><span id="f943" class="lg jq hi lc b fi lo li l lj lk">OPEN Cursor_Name<br/>    -- Do Something</span><span id="2f19" class="lg jq hi lc b fi lo li l lj lk">CLOSE Cursor_Name<br/>DEALLOCATE Cursor_Name</span></pre><p id="cea1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有两种类型的光标<code class="du ll lm ln lc b">GLOBAL</code>和<code class="du ll lm ln lc b">LOCAL</code>。如上所示，我们可以通过在关键字<code class="du ll lm ln lc b">CURSOR</code>之后的游标声明语句中使用相应的关键字来定义这个范围。</p><p id="9c43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">局部游标仅在给定的一批语句中可用，而全局游标在当前连接引用中的任何位置都可用。为了更好地理解，下面的代码将导致一个错误，因为本地光标在当前批处理的范围之外。</p><pre class="je jf jg jh fd lb lc ld le aw lf bi"><span id="195a" class="lg jq hi lc b fi lh li l lj lk">DECLARE Cursor_Name CURSOR LOCAL<br/>    FOR SELECT Col1, Col2 FROM [dbo].[table1]<br/>GO</span><span id="81ca" class="lg jq hi lc b fi lo li l lj lk">OPEN Cursor_Name<br/>    -- Do Something</span><span id="fc11" class="lg jq hi lc b fi lo li l lj lk">CLOSE Cursor_Name<br/>DEALLOCATE Cursor_Name</span></pre><p id="8707" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">10.<strong class="ih hj">光标类型</strong></p><p id="befb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们已经讨论了两种类型的游标:</p><ol class=""><li id="588a" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated">仅向前</li><li id="4fed" class="ks kt hi ih b ii lq im lr iq ls iu lt iy lu jc kx ky kz la bi translated">卷轴。</li></ol><p id="b6e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“仅向前”是默认光标，仅在一个方向读取，即相对于其当前位置向前。滚动光标让我们读取第<em class="lp">条</em>条记录，也让我们向前(<code class="du ll lm ln lc b">NEXT</code>)、向后(<code class="du ll lm ln lc b">PRIOR</code>)读取，并以步长跳过中间记录(<code class="du ll lm ln lc b">RELATIVE N</code>)。</p><p id="4bd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他类型的光标:</p><ol class=""><li id="d280" class="ks kt hi ih b ii ij im in iq ku iu kv iy kw jc kx ky kz la bi translated">快进</li><li id="b315" class="ks kt hi ih b ii lq im lr iq ls iu lt iy lu jc kx ky kz la bi translated">静态</li><li id="e653" class="ks kt hi ih b ii lq im lr iq ls iu lt iy lu jc kx ky kz la bi translated">动态的</li><li id="0c22" class="ks kt hi ih b ii lq im lr iq ls iu lt iy lu jc kx ky kz la bi translated">键盘</li></ol><p id="43b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lp">请参考本</em> <a class="ae lv" href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/declare-cursor-transact-sql?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> <em class="lp">微软文档</em> </a> <em class="lp">了解这些光标类型的更多详情。</em></p><p id="5233" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止，我们已经讨论了光标的基础知识。下次让我们看看如何用游标修改数据。如果您还没有检查SQL和存储过程  <em class="lp">中的</em> <a class="ae lv" rel="noopener" href="/@yuvrendergill21/sql-stored-procedures-loops-a3cb6d6114a9"> <em class="lp">循环，请确保检查最后一个帖子。</em></a></p></div></div>    
</body>
</html>