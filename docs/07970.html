<html>
<head>
<title>Tracing Gorm queries with OpenCensus &amp; Google Cloud Tracing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenCensus和Google Cloud Tracing跟踪Gorm查询</h1>
<blockquote>原文：<a href="https://medium.com/codex/tracing-gorm-queries-with-opencensus-google-cloud-tracing-50bfab69abbb?source=collection_archive---------16-----------------------#2022-07-07">https://medium.com/codex/tracing-gorm-queries-with-opencensus-google-cloud-tracing-50bfab69abbb?source=collection_archive---------16-----------------------#2022-07-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f0a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="http://incident.io/" rel="noopener ugc nofollow" target="_blank"> incident.io </a>我们使用<a class="ae jd" href="http://gorm.io/" rel="noopener ugc nofollow" target="_blank"> gorm.io </a>作为Postgres数据库的orm库，这是一个非常强大的工具，我很高兴在Go &amp; Postgres应用程序中使用了多年的手工SQL。你可能已经从我们的<a class="ae jd" href="https://incident.io/blog/tracing" rel="noopener ugc nofollow" target="_blank">其他博客帖子</a>中看到，我们在追踪方面投入了大量资金，特别是通过<a class="ae jd" href="https://opencensus.io/" rel="noopener ugc nofollow" target="_blank"> OpenCensus </a>库使用谷歌云追踪。我们应用程序的大量时间都花在通过gorm与Postgres对话上，所以我们想在跟踪堆栈中更好地了解这一点。</p><p id="b282" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，Gorm为我们提供了完美的钩子来通过<a class="ae jd" href="https://gorm.io/docs/write_plugins.html#Callbacks" rel="noopener ugc nofollow" target="_blank">回调API </a>进行跟踪，这允许我们为Gorm提供在查询生命周期的特定部分调用的函数，允许您在传统的中间件方法中改变查询行为，或者在我们的情况下，提取数据以实现可观察性。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="3659" class="jn jo hi jj b fi jp jq l jr js">func beforeQuery(scope *gorm.DB) {<br/>	// do stuff!<br/>}</span><span id="2b7c" class="jn jo hi jj b fi jt jq l jr js">db.Callback().<br/>	Create().<br/>	Before("gorm:query").<br/>	Register("instrumentation:before_query", beforeQuery)</span></pre><p id="30e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们的目标是将跟踪范围引入到我们的Gorm查询中，为了做到这一点，我们需要捕捉开始和结束事件，并相应地处理这些范围。在这些例子中，我将使用由<a class="ae jd" href="http://go.opencensus.io/trace" rel="noopener ugc nofollow" target="_blank">go.opencensus.io/trace</a>提供的追踪工具，这些工具被用于谷歌云追踪，但是其他追踪库应该有类似的行为。</p><p id="261d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了一个函数，当查询开始时，我们需要开始我们的跨度:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="7059" class="jn jo hi jj b fi jp jq l jr js">func beforeQuery(scope *gorm.DB) {<br/>	db.Statement.Context = startTrace(<br/>    db.Statement.Context,<br/>    db,<br/>    operation,<br/>  )<br/>}</span><span id="3107" class="jn jo hi jj b fi jt jq l jr js">func startTrace(<br/>  ctx context.Context,<br/>  db *gorm.DB,<br/>) context.Context {<br/>	// Don't trace queries if they don't have a parent span.<br/>	if span := trace.FromContext(ctx); span == nil {<br/>		return ctx<br/>	}</span><span id="fd9c" class="jn jo hi jj b fi jt jq l jr js">	ctx, span := trace.StartSpan(ctx, "gorm.query")<br/>	return ctx<br/>}</span></pre><p id="4c92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后我们也需要结束这个跨度:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="cdf5" class="jn jo hi jj b fi jp jq l jr js">func afterQuery(scope *gorm.DB) { endTrace(scope) }</span><span id="b9ec" class="jn jo hi jj b fi jt jq l jr js">func endTrace(db *gorm.DB) {<br/>	span := trace.FromContext(db.Statement.Context)<br/>	if span == nil || !span.IsRecordingEvents() {<br/>		return<br/>	}</span><span id="0e21" class="jn jo hi jj b fi jt jq l jr js">	var status trace.Status</span><span id="f191" class="jn jo hi jj b fi jt jq l jr js">	if db.Error != nil {<br/>		err := db.Error<br/>		if err == gorm.ErrRecordNotFound {<br/>			status.Code = trace.StatusCodeNotFound<br/>		} else {<br/>			status.Code = trace.StatusCodeUnknown<br/>		}</span><span id="7d4d" class="jn jo hi jj b fi jt jq l jr js">		status.Message = err.Error()<br/>	}<br/>	span.SetStatus(status)<br/>	span.End()<br/>}</span><span id="ed75" class="jn jo hi jj b fi jt jq l jr js">db.Callback().<br/>	Query().<br/>	After("gorm:query").<br/>	Register("instrumentation:after_query", afterQuery)</span></pre><p id="b51f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以在跟踪中看到我们所有的gorm查询，太好了！</p><figure class="je jf jg jh fd jv er es paragraph-image"><div class="er es ju"><img src="../Images/a4c0f2289610835a277b548378b88920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/0*v5YnBmd-PetRtiW2.png"/></div></figure><p id="45a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，他们并不十分清楚我们实际在做什么，让我们看看是否可以通过添加以下内容使这些跨度提供更多信息:</p><ul class=""><li id="1264" class="jy jz hi ih b ii ij im in iq ka iu kb iy kc jc kd ke kf kg bi translated">表名&amp;查询span名称的指纹。</li><li id="4391" class="jy jz hi ih b ii kh im ki iq kj iu kk iy kl jc kd ke kf kg bi translated">调用我们的代码行</li><li id="c733" class="jy jz hi ih b ii kh im ki iq kj iu kk iy kl jc kd ke kf kg bi translated">来自选择查询的WHERE参数</li><li id="66a5" class="jy jz hi ih b ii kh im ki iq kj iu kk iy kl jc kd ke kf kg bi translated">受影响的行数</li></ul><p id="63c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查询指纹是查询的唯一标识符，与格式和变量无关，因此您可以唯一地标识在数据库中行为相同的查询。</p><p id="c8e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们扩展前面的代码:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="c6ce" class="jn jo hi jj b fi jp jq l jr js">func startTrace(ctx context.Context, db *gorm.DB) context.Context {<br/>	// Don't trace queries if they don't have a parent span.<br/>	if span := trace.FromContext(ctx); span == nil {<br/>		return ctx<br/>	}</span><span id="8ecd" class="jn jo hi jj b fi jt jq l jr js">	// start the span<br/>	ctx, span := trace.StartSpan(ctx, fmt.Sprintf("gorm.query.%s", db.Statement.Table))</span><span id="9115" class="jn jo hi jj b fi jt jq l jr js">	// set the caller of the gorm query, so we know where in the codebase the<br/>	// query originated.<br/>	//<br/>	// walk up the call stack looking for the line of code that called us. but<br/>	// give up if it's more than 20 steps, and skip the first 5 as they're all<br/>	// gorm anyway<br/>	var (<br/>		file string<br/>		line int<br/>	)<br/>	for n := 5; n &lt; 20; n++ {<br/>		_, file, line, _ = runtime.Caller(n)<br/>		if strings.Contains(file, "/gorm.io/") {<br/>			// skip any helper code and go further up the call stack<br/>			continue<br/>		}<br/>		break<br/>	}<br/>	span.AddAttributes(trace.StringAttribute("caller", fmt.Sprintf("%s:%v", file, line)))</span><span id="eeec" class="jn jo hi jj b fi jt jq l jr js">	// add the primary table to the span metadata<br/>	span.AddAttributes(trace.StringAttribute("gorm.table", db.Statement.Table))<br/>	return ctx<br/>}</span><span id="7b2d" class="jn jo hi jj b fi jt jq l jr js">func endTrace(db *gorm.DB) {<br/>	// get the span from the context<br/>	span := trace.FromContext(db.Statement.Context)<br/>	if span == nil || !span.IsRecordingEvents() {<br/>		return<br/>	}</span><span id="8666" class="jn jo hi jj b fi jt jq l jr js">	// set the span status, so we know if the query was successful<br/>	var status trace.Status<br/>	if db.Error != nil {<br/>		err := db.Error<br/>		if err == gorm.ErrRecordNotFound {<br/>			status.Code = trace.StatusCodeNotFound<br/>		} else {<br/>			status.Code = trace.StatusCodeUnknown<br/>		}</span><span id="9003" class="jn jo hi jj b fi jt jq l jr js">		status.Message = err.Error()<br/>	}<br/>	span.SetStatus(status)</span><span id="492b" class="jn jo hi jj b fi jt jq l jr js">	// add the number of affected rows &amp; query string to the span metadata<br/>	span.AddAttributes(<br/>		trace.Int64Attribute("gorm.rows_affected", db.Statement.RowsAffected),<br/>		trace.StringAttribute("gorm.query", db.Statement.SQL.String()),<br/>	)<br/>	// Query fingerprint provided by github.com/pganalyze/pg_query_go<br/>	fingerprint, err := pg_query.Fingerprint(db.Statement.SQL.String())<br/>	if err != nil {<br/>		fingerprint = "unknown"<br/>	}</span><span id="ff42" class="jn jo hi jj b fi jt jq l jr js">	// Rename the span with the fingerprint, as the DB handle<br/>	// doesn't have SQL to fingerprint before being executed<br/>	span.SetName(fmt.Sprintf("gorm.query.%s.%s", db.Statement.Table, fingerprint))</span><span id="999b" class="jn jo hi jj b fi jt jq l jr js">	// finally end the span<br/>	span.End()<br/>}</span><span id="c5f0" class="jn jo hi jj b fi jt jq l jr js">func afterQuery(scope *gorm.DB) {<br/>	// now in afterQuery we can add query vars to the span metadata<br/>	// we do this in afterQuery rather than the trace functions so we<br/>	// can re-use the traces for non-select cases where we wouldn't want<br/>	// to record the vars as they may contain sensitive data</span><span id="331d" class="jn jo hi jj b fi jt jq l jr js">	// first we extract the vars from the query &amp; map them into a<br/>  // human readable format<br/>	fieldStrings := []string{}<br/>	if scope.Statement != nil {<br/>		fieldStrings = lo.Map(scope.Statement.Vars, func(v any i int) string {<br/>			return fmt.Sprintf("($%v = %v)", i+1, v)<br/>		})<br/>	}<br/>	// then add the vars to the span metadata<br/>	span := trace.FromContext(scope.Statement.Context)<br/>	if span != nil &amp;&amp; span.IsRecordingEvents() {<br/>		span.AddAttributes(<br/>			trace.StringAttribute("gorm.query.vars", strings.Join(fieldStrings, ", ")),<br/>		)<br/>	}<br/>	endTrace(scope)<br/>}</span></pre><p id="deb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们终于有了超级丰富的易于扫描的跨度，让我们更容易理解我们的应用程序正在花费时间做什么，耶！</p><figure class="je jf jg jh fd jv er es paragraph-image"><div class="er es km"><img src="../Images/f51b56da97a6c0f98097150ff9ecb6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*QWmrk_atux42ewjO.png"/></div></figure><p id="60e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Gorm为查询生命周期的许多不同部分提供了回调，您可以为它们添加特定的行为，我们目前分别跟踪创建、删除、更新和查询，但是如果您想更进一步，您可以查看<a class="ae jd" href="https://gorm.io/docs/write_plugins.html" rel="noopener ugc nofollow" target="_blank"> gorm文档</a>！你可以在这个帖子<a class="ae jd" href="https://gist.github.com/arussellsaw/bbedfdefee119b4600ce085b773da4b9" rel="noopener ugc nofollow" target="_blank">这里</a>找到所有的代码。</p><p id="94dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，如果你不小心，你可能会追踪到一些敏感数据。因此，如果适用的话，请确保清理您的查询变量。一个好的做法是只跟踪选择查询，因为它们通常是通过IDs完成的，而不是任何敏感信息。</p></div></div>    
</body>
</html>