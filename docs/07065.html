<html>
<head>
<title>How low-coding saves costs, money and your nervous system. Acure.io example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">低编码如何节省成本、金钱和你的神经系统。Acure.io示例</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-low-coding-saves-costs-money-and-your-nervous-system-acure-io-example-918b214d736?source=collection_archive---------12-----------------------#2022-05-27">https://medium.com/codex/how-low-coding-saves-costs-money-and-your-nervous-system-acure-io-example-918b214d736?source=collection_archive---------12-----------------------#2022-05-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0810" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我之前的一篇文章中，我谈到了AIOps系统如何帮助解决业务问题。但不只是管理者有需求。越来越多的，当创建一个产品时，IT系统的开发者转向那些将使用这个产品的人的需求——IT专家，他们将不得不在将来实现、维护，如果必要的话，修改系统。因此，最近开发人员经常选择支持低代码引擎。</p><h1 id="576a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">更少的代码——更少的成本</strong></h1><p id="aaea" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">低代码是一种软件开发方法，在图形界面中建模，最少手工编码。只需拖放可视块来构建脚本。使用低代码，您可以轻松地改进应用程序、设置集成和创建自动化场景，而无需编写数百行复杂的代码。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/d40df0b912ab131061cc8d64026ba544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/0*TejXcjnZx5tj96_A"/></div></figure><p id="8313" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Gartner估计，到2024年，低代码将负责超过65%的应用程序开发活动。难怪。低代码节省了开发成本和时间。不需要涉及极其昂贵的实现团队来设置系统并进一步维护它，或者等到供应商滚动、测试、回滚、测试并发布一个特性。没有特殊编程技能的IT通才，自己也能轻松搞定。</p><p id="464d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么Acure呢，我们也与时俱进，最近实现了低代码引擎。在这篇文章中，我想展示如何在我们的平台上实现低代码。</p><h1 id="5572" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak"> CMDB自动发现</strong></h1><p id="36a4" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">借助Acure中的自动化脚本，用户可以显著扩展系统的功能。新服务内置于现有系统中，允许您创建任意的事件处理管道。新的自动化功能建立在低代码可视化编程引擎及其自己的脚本和执行系统上，允许用户使用可视化块并在它们之间建立链接来创建任意事件处理场景。</p><p id="98b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">场景可以是自定义的，也可以由开发人员自己作为成熟的服务提供。未来服务之间的交互将通过建立路线图来确定，这将允许您将单个场景组合成单个解决方案。路线图决定了特定类型的场景将处理哪些事件。在当前版本中，用户可以使用CMDB自动发现类型，该类型处理通过流进入系统的事件，并被定制为使用资源服务模型。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kp"><img src="../Images/cc73bb83c06983fc0c60d3859e49da01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O10PrFGT7sa57KEr"/></div></div></figure><h1 id="85ae" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">创建一个简单的场景</strong></h1><p id="99ea" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">自动化场景的创建从用关于其所有者和名称的信息填写表单并选择根节点开始。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ku"><img src="../Images/9e2db9d11c525fae87ca191615a2343d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YHvdlupZGqyui36h"/></div></div></figure><p id="7ecd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建后，我们进入场景构建器页面。</p><p id="8173" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，有一个start块，每当相应的事件到达时，它就运行我们的脚本。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kv"><img src="../Images/d8ef2bc4cffd7027394b05118b63b604.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/0*V5fQkRwRYx8GxJ5d"/></div></figure><p id="9589" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要创建一个规则，以便对特定事件执行序列。为此，我们需要一些块形式的函数。我们通过右键单击空白区域从上下文菜单中添加它们。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kw"><img src="../Images/f21ac0870736621594ec41a477ba58ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/0*Pa-B6YcaFcCfCgFS"/></div></figure><p id="6667" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们构建一个简单的规则，只接收来自特定流的事件。</p><p id="78b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们将添加<em class="jd"> FiltredByStreamId </em>函数，并以这样一种方式连接序列，即当事件到达系统时，脚本检查它来自的流的Id，如果过滤成功，脚本将继续运行。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kx"><img src="../Images/e3af5f79a9111492ff5e3b7c98515ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/0*eTL7e2wbc3P47XqN"/></div></figure><p id="c4fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">脚本函数的执行顺序由蓝色箭头表示——确切的引脚。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ky"><img src="../Images/05f2d664ee55492d41416c8bd78efffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GmmcSkF6y_q7U4sq"/></div></div></figure><p id="076c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，除了精确引脚，还有数据引脚。如果前者负责序列，那么后者负责发送和接收数据。</p><p id="e697" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们分析一下我们的函数。要执行它，必须向它提供输入数据。在我们的例子中，该函数请求一个输入流模型和过滤参数(流id)。</p><p id="e5d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们必须从初级事件中获得初始数据，即从那里获得流模型。为了做到这一点，我们使用基函数分解原始结构，并与我们的过滤器建立连接。</p><p id="6421" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们需要指定所需的参数(我们从先前创建的流中获取)，并将其复制粘贴到<em class="jd"> FiltredByStreamId </em>块中。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kz"><img src="../Images/778b0bd399acae0c718e8cc9c5a63096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*53pIBfX-Et4Wo0-r"/></div></div></figure><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es la"><img src="../Images/9f63de3c969b33c860ee3364be4ed688.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/0*yLY6uTLjgna8k889"/></div></figure><p id="23a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">搞定了。简单的规则已经准备好了。现在，只有当事件来自我们指定的流时，才会执行进一步的操作。</p><p id="bbc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一个动作，我们可以使用一个特殊的函数发送一个测试请求:设置它并发送我们的主事件作为请求体。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lb"><img src="../Images/53361bf0463787d658f5145c3718a375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5Zn3Vlb3fUvAIHcl"/></div></div></figure><p id="fe55" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让场景工作，必须编译并激活它。</p><p id="56fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们重现向线程分派事件的过程。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lc"><img src="../Images/7909aa26e4f1c237b6e2d2269b60fe25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DAhUKUNlfwpiTAdK"/></div></div></figure><p id="7fbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一切都设置正确，那么应该显示一个请求，其中主体是我们的事件。我们看到我们的请求和事件，确认一切都是正确的。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ld"><img src="../Images/079dafb8422f65aa15711ad55d16b6a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tbhs5ilIGVDLVVjA"/></div></div></figure><p id="30e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看编辑器中可用的其他工具。</p><p id="8f8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">左侧面板包含当前场景的对象。在这里，您可以创建和管理局部变量、结构和整个函数。在这里，可以将它们添加到屏幕上，以便在脚本中使用，或者选择它们进行进一步的定制。</p><p id="19d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设置在右边的面板中，我们填写所有必需的字段，如果是本地函数，编写可执行代码。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es le"><img src="../Images/80ee2c4c80c1269d99f89d818c934c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/0*rZHx6IXfKKjVrYh5"/></div></figure><p id="ba84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这项服务的一个重要特性是，用户可以导出脚本并与其他人共享。反过来，接收者使用导入工具创建该脚本的精确副本。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lf"><img src="../Images/b21a051b632f1c662cd1736645f7e780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hMisHwJnigxcI-D6"/></div></div></figure><h1 id="9d90" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated"><strong class="ak">结论</strong></h1><p id="9373" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在本文中，我展示了如何不用硬编码来构建简单的脚本。当然，这只是一个简短的介绍，Acure中engine的功能更多。在接下来的文章中，我将讨论变量、结构、数据类型，并展示如何创建完整的场景。现在，留下你的反馈并分享你的忏悔:你是优秀文本编码的专家还是相信可视化编程的力量？</p></div></div>    
</body>
</html>