<html>
<head>
<title>Two different ways to style Pseudo-elements with Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Javascript设计伪元素的两种不同方式</h1>
<blockquote>原文：<a href="https://medium.com/codex/two-different-ways-to-style-pseudo-elements-with-javascript-3d9260d9c61b?source=collection_archive---------1-----------------------#2021-04-11">https://medium.com/codex/two-different-ways-to-style-pseudo-elements-with-javascript-3d9260d9c61b?source=collection_archive---------1-----------------------#2021-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f5436df46c9f8bf7413069bcc3411a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXNTbobtFMxugXAyXtOX8g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">因为现在，瞄准一个伪元素是不可能的…</figcaption></figure><p id="268d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上次在一个项目中，我想在javascript中通过悬停一个元素来定位页面的所有<strong class="iw hj">:</strong>之前的元素，而不仅仅是它之前的元素。然后我试着写了这样的东西:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="cbda" class="kb kc hi jx b fi kd ke l kf kg">const links = document.querySelectorAll( "a" );</span><span id="5c1b" class="kb kc hi jx b fi kh ke l kf kg">const changeBefore = () =&gt; {<br/>  <br/>  for ( let i = 0; i &lt; links.length; i++ ) {<br/>  <br/>    const before = links[ i ].querySelector( "::before" );<br/>    console.log( before );<br/>    before.style.color = "#f00";<br/>  <br/>  }</span><span id="89bf" class="kb kc hi jx b fi kh ke l kf kg">}, initBefore = () =&gt; {<br/>  <br/>  for ( let i = 0; i &lt; links.length; i++ ) {<br/><br/>    const before = links[ i ].querySelector( "::before" );    <br/>    before.style.color = "#000";<br/>  <br/>  }</span><span id="2207" class="kb kc hi jx b fi kh ke l kf kg">}</span><span id="c059" class="kb kc hi jx b fi kh ke l kf kg">for ( let i = 0; i &lt; links.length; i++ ) {</span><span id="ca15" class="kb kc hi jx b fi kh ke l kf kg">  const link = links[ i ];<br/>  link.addEventListener("mouseover", function() { changeBefore() });<br/>  link.addEventListener("mouseout", function() { initBefore() });</span><span id="d277" class="kb kc hi jx b fi kh ke l kf kg">}</span></pre><blockquote class="ki kj kk"><p id="1a10" class="iu iv kl iw b ix iy iz ja jb jc jd je km jg jh ji kn jk jl jm ko jo jp jq jr hb bi translated">【https://jsfiddle.net/Fromager/0t6mqgr7/ T2】号</p></blockquote><p id="ff80" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好了，现在的问题是，什么都没发生！当我检查控制台时，它对我说“<strong class="iw hj">之前是空的</strong>”。</p></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="ebd2" class="kx kc hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">但是，为什么呢？？？</h1><p id="a9b2" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">我暂时不确定答案，但我觉得只是因为DOM只针对html节点，伪元素不是节点，是“伪”的。当您检查您的页面时，您会发现它们没有像<pseudo-element>这样的标记约定，而是像那样::伪元素。这是因为它们是在浏览器的CSSOM中定义的，并不存在于DOM中，这就是为什么不可能在javascript中定位它。我向你推荐由James Starkie 在dev.to上写的这篇很棒的文章，这篇文章更详细地解释了浏览器如何呈现网页。</pseudo-element></p></div><div class="ab cl kq kr gp ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hb hc hd he hf"><h1 id="7b34" class="kx kc hi bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">好吧，但是，现在呢？</h1><p id="5ab6" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">如果我们不能用javascript直接访问伪元素，我们仍然可以使用后门来设计它们。</p><h2 id="9735" class="kb kc hi bd ky lz ma mb lc mc md me lg jf mf mg lk jj mh mi lo jn mj mk ls ml bi translated">1.使用自定义属性</h2><p id="9846" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">是的，这是目前修改伪元素的常用方法。我拿最后一个例子来说明。首先，我在CSS中指定了一个自定义属性，使其具有默认值:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="b8b3" class="kb kc hi jx b fi kd ke l kf kg">:root {<br/>  --color: #000;<br/>}</span><span id="acf3" class="kb kc hi jx b fi kh ke l kf kg">::before {<br/>  background: var(--color);<br/>}</span></pre><p id="2669" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后我将旧脚本替换为:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="120d" class="kb kc hi jx b fi kd ke l kf kg">const links = document.querySelectorAll( "a" );</span><span id="1c02" class="kb kc hi jx b fi kh ke l kf kg">for ( let i = 0; i &lt; links.length; i++ ) {</span><span id="706e" class="kb kc hi jx b fi kh ke l kf kg">  const link = links[ i ];</span><span id="3335" class="kb kc hi jx b fi kh ke l kf kg">  link.addEventListener( "mouseover", function() {<br/>    document.documentElement.style.setProperty('--color', "#00f")<br/>  });<br/>  link.addEventListener( "mouseout", function() {<br/>    document.documentElement.style.setProperty('--color', "#000")<br/>  });</span><span id="7710" class="kb kc hi jx b fi kh ke l kf kg">}</span></pre><figure class="js jt ju jv fd ij"><div class="bz dy l di"><div class="mm mn l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae kp" href="https://jsfiddle.net/Fromager/vg8r34jh/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/Fromager/vg8r34jh/</a></figcaption></figure><p id="10e5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您只需要这一行来设置全局根中的自定义值:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="bba5" class="kb kc hi jx b fi kd ke l kf kg">document.documentElement.style.setProperty('--your-prop', "YOUR COLOR")</span></pre><h2 id="ee0c" class="kb kc hi bd ky lz ma mb lc mc md me lg jf mf mg lk jj mh mi lo jn mj mk ls ml bi translated">2.使用数据属性管理内容</h2><p id="2bba" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">正如您可能已经知道的，伪元素::before和::after有一个<a class="ae kp" href="https://developer.mozilla.org/fr/docs/Web/CSS/content" rel="noopener ugc nofollow" target="_blank">内容属性</a>，允许您插入像图像或文本这样的对象。但是并不是每个人都知道，您可以使用标签数据属性来管理内容。然后，如果我有一个有序列表，我想设置纯文本和不同语言的列表编号，我可以使用它！</p><p id="5918" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，我用数据属性和一个切换语言的按钮创建了一个有序列表:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="b300" class="kb kc hi jx b fi kd ke l kf kg">&lt;ol&gt;<br/>  &lt;li data-style-type="One"&gt;Garlic&lt;/li&gt;<br/>  &lt;li data-style-type="Two"&gt;Tomato&lt;/li&gt;<br/>  &lt;li data-style-type="Three"&gt;Ginger&lt;/li&gt;<br/>&lt;/ol&gt;</span><span id="8f48" class="kb kc hi jx b fi kh ke l kf kg">&lt;button&gt;Toggle language&lt;/button&gt;</span></pre><p id="5e7a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我简单地对<li>进行了样式化，删除了style-type，用内容中的数据属性替换为before:</li></p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="4a14" class="kb kc hi jx b fi kd ke l kf kg">li {<br/>  list-style: none;<br/>}</span><span id="f4a3" class="kb kc hi jx b fi kh ke l kf kg">li::before {<br/>  content: attr(data-style-type) ": ";<br/>}</span></pre><p id="4a93" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，我将它定义为<strong class="iw hj">attr(data-style-type)":"</strong>，因为我希望在列出的元素之前有一个冒号。如果你想在字符串中连接属性，只需使用简单的间距。但是如果你只想要属性，你可以。</p><p id="c105" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">之后我写了一个切换语言脚本:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="e085" class="kb kc hi jx b fi kd ke l kf kg">const list = document.querySelectorAll( "li" );<br/>const arrEn = [ "One", "Two", "Three" ];<br/>const arrFr = [ "Un", "Deux", "Trois" ];</span><span id="8aa7" class="kb kc hi jx b fi kh ke l kf kg">let arr = arrEn;</span><span id="6952" class="kb kc hi jx b fi kh ke l kf kg">const setStyleType = (arr, i) =&gt; {<br/>  list[ i ].dataset.styleType = arr[ i ];<br/>}</span><span id="23ec" class="kb kc hi jx b fi kh ke l kf kg">document.querySelector( "button" ).addEventListener( "click",<br/>  function() {<br/>    arr = arr === arrEn ? arrFr : arrEn;<br/>    for( i = 0; i &lt; list.length; i ++ ) {<br/>      setStyleType(arr, i);<br/>    }<br/>  }<br/>);</span></pre><figure class="js jt ju jv fd ij"><div class="bz dy l di"><div class="mm mn l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae kp" href="https://jsfiddle.net/Fromager/1cbkzaey/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/Fromager/1cbkzaey/</a></figcaption></figure><p id="ad0f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里最重要的是DOM改变了元素的数据集。我认为在某些情况下这是有用的。</p><h1 id="5bfd" class="kx kc hi bd ky kz mo lb lc ld mp lf lg lh mq lj lk ll mr ln lo lp ms lr ls lt bi translated">结论</h1><p id="1fa0" class="pw-post-body-paragraph iu iv hi iw b ix lu iz ja jb lv jd je jf lw jh ji jj lx jl jm jn ly jp jq jr hb bi translated">就像我接下来几周将要写的其他文章一样，这些例子是我在面对一个问题时所做的探索的微小成果。有很多其他的方法来管理::伪元素风格，有时是更好的方法，但是看这些是很重要的。</p><p id="4f2f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">也许我会写第二部分，研究另一种方法，或者用全CSS做同样的事情，这可能会很有趣。</p></div></div>    
</body>
</html>