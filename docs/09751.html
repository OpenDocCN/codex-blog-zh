<html>
<head>
<title>The Testing Library meets Selenium</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试库符合硒</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-testing-library-meets-selenium-5f74cc712114?source=collection_archive---------2-----------------------#2022-11-07">https://medium.com/codex/the-testing-library-meets-selenium-5f74cc712114?source=collection_archive---------2-----------------------#2022-11-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ec4e" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><a class="ae ix" href="http://testing-library.com/" rel="noopener ugc nofollow" target="_blank">测试库</a>支持用户测试。它可用于多种JavaScript框架(例如React、Vue、Cypress)。我意识到把它带到科特林的硒中是可能的，也是有价值的。</h2></div><blockquote class="iy iz ja"><p id="f560" class="jb jc jd je b jf jg ij jh ji jj im jk jl jm jn jo jp jq jr js jt ju jv jw jx hb bi translated">你的测试越像你的软件被使用的方式，它们就越能给你信心。<em class="hi"> ( </em> <a class="ae ix" href="https://twitter.com/kentcdodds/status/977018512689455106" rel="noopener ugc nofollow" target="_blank"> <em class="hi">)肯特</em> </a> <em class="hi"> ) </em></p></blockquote><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es jy"><img src="../Images/40e9af11c601423fa5d6d59a002a8721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WS69y1nNdbpUs2dfd3I4Kg.png"/></div></div></figure><h1 id="da5e" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">什么</h1><p id="2dc5" class="pw-post-body-paragraph jb jc hi je b jf lc ij jh ji ld im jk le lf jn jo lg lh jr js li lj jv jw jx hb bi translated">我开发了一组定制的<a class="ae ix" href="https://www.selenium.dev/" rel="noopener ugc nofollow" target="_blank"> Selenium </a>定位器(例如<code class="du lk ll lm ln b">ByRole</code>、<code class="du lk ll lm ln b">ByText</code>)，包装了相应的<a class="ae ix" href="https://testing-library.com/docs/queries/about" rel="noopener ugc nofollow" target="_blank">测试库查询</a>(特别是<a class="ae ix" href="https://github.com/testing-library/dom-testing-library" rel="noopener ugc nofollow" target="_blank"> DOM测试库</a>):</p><pre class="jz ka kb kc fd lo ln lp bn lq lr bi"><span id="e47b" class="ls kl hi ln b be lt lu l lv lw">// with the Selenium Testing Library (Kotlin)<br/>driver.findElement(ByAltText("First name"))<br/>driver.findElement(<br/>   ByRole("heading", name = "/as a user/i".asJsRegex())<br/>)</span></pre><pre class="lx lo ln lp bn lq lr bi"><span id="661e" class="ls kl hi ln b be lt lu l lv lw">// with the Testing Library (JavaScript)<br/>screen.queryByAltText('First name')<br/>screen.queryByRole('heading', { name: /as a user/i })</span></pre><p id="9b1e" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated">我相信<a class="ae ix" rel="noopener" href="/codex/automated-testing-goals-d3ace8fd223a">测试</a>给出了最好的例子，所以<a class="ae ix" href="https://github.com/lsoares/selenium-testing-library/tree/main/lib/src/test/kotlin/seleniumtestinglib" rel="noopener ugc nofollow" target="_blank">去看看</a>。先睹为快，下面是测试库的<a class="ae ix" href="https://testing-library.com/docs/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hj">核心API </strong> </a>的更多例子:</p><pre class="jz ka kb kc fd lo ln lp bn lq lr bi"><span id="89ec" class="ls kl hi ln b be lt lu l lv lw">val firstName = driver.findElements(ByAltText("first name"))<br/>val person = driver.findElements(ByDisplayValue("/john/i".asRegex()))<br/>val active = driver.findElements(ByLabelText("active"))<br/>val input = driver.findElements(ByPlaceholderText("first name", exact = false))<br/>val title = driver.findElements(ByRole("heading", name = "/as a user/i".asRegex()))<br/>val panel = driver.findElements(ByTestId("test-id"))<br/>val block = driver.findElements(ByText("present", exact = false, selector = "span"))<br/>val title1 = driver.findElements(ByTitle("title 1"))</span></pre><p id="f1c3" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated">我还实现了测试库<a class="ae ix" href="https://testing-library.com/docs/user-event/intro/" rel="noopener ugc nofollow" target="_blank"> <strong class="je hj">用户交互API </strong> </a>:</p><pre class="jz ka kb kc fd lo ln lp bn lq lr bi"><span id="5bd4" class="ls kl hi ln b be lt lu l lv lw">driver.user.click(driver.findElement(ByRole("navigation")))<br/>driver.user.type(driver.findElement(ByRole("textbox")), "foobar")<br/>driver.user.selectOptions(driver.findElement(ByRole("listbox")), "C")<br/>driver.user.keyboard("[/ShiftLeft][/ShiftRight]{Tab}")<br/>driver.user.tab()<br/>driver.user.clear(driver.findElement(By.Id("description")))<br/>driver.user.pointer("[MouseLeft]", "[MouseRight]")</span></pre><p id="a8ae" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated"><a class="ae ix" href="https://github.com/testing-library/jest-dom" rel="noopener ugc nofollow" target="_blank"> <strong class="je hj"> jest-dom </strong> </a>也可用:</p><pre class="jz ka kb kc fd lo ln lp bn lq lr bi"><span id="cbc6" class="ls kl hi ln b be lt lu l lv lw">// API similar to the original version:<br/>expect(button.toHaveAccessibleDescription("Register"))<br/>expect(checkboxMarketing).toBeChecked()<br/>assertEquals(setOf("btn", "btn-danger", "extra"), deleteButton.classes)<br/>expect(element).not.toBePartiallyChecked()<br/><br/>// utilities that can be used on their own:<br/>val formValues = registrationForm.formValues<br/>val userAgrees = checkboxMarketing.isChecked<br/>val name = element.accessibleName<br/>val displayedValue = element.displayValue</span></pre><p id="028c" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated">我已经把这一切打包到<a class="ae ix" href="https://search.maven.org/artifact/com.luissoares/selenium-testing-library" rel="noopener ugc nofollow" target="_blank"> <strong class="je hj">硒测试库</strong> </a>(针对Kotlin，但在Java中也有效)<strong class="je hj"/><a class="ae ix" href="https://github.com/lsoares/selenium-testing-library" rel="noopener ugc nofollow" target="_blank">开源它</a>(顺便说一下，有人对Python 做了<a class="ae ix" href="https://github.com/anze3db/selenium-testing-library" rel="noopener ugc nofollow" target="_blank">同样的事情)。</a></p><h1 id="d7bc" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">为什么</h1><p id="82cd" class="pw-post-body-paragraph jb jc hi je b jf lc ij jh ji ld im jk le lf jn jo lg lh jr js li lj jv jw jx hb bi translated">创建这个库的原因不止一个:</p><ul class=""><li id="8162" class="ly lz hi je b jf jg ji jj le ma lg mb li mc jx md me mf mg bi translated">为开源世界做贡献，希望已经创造了对别人有用的东西；</li><li id="bfcd" class="ly lz hi je b jf mh ji mi le mj lg mk li ml jx md me mf mg bi translated">深入研究Selenium、测试库和webpack</li><li id="cc3f" class="ly lz hi je b jf mh ji mi le mj lg mk li ml jx md me mf mg bi translated">学习<a class="ae ix" href="https://maciejwalkowiak.com/blog/guide-java-publish-to-maven-central/" rel="noopener ugc nofollow" target="_blank">如何发布一个库到Maven Central </a>(也许还有如何用<a class="ae ix" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub actions </a>自动化它)；</li><li id="c231" class="ly lz hi je b jf mh ji mi le mj lg mk li ml jx md me mf mg bi translated">以我认为UI测试应该做的方式使用Selenium作为用户进行测试。</li></ul><p id="83fe" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated">为什么我相信作为用户的<em class="jd">测试</em>优于依赖技术方面(id、类、标记名、测试id、<a class="ae ix" href="https://en.wikipedia.org/wiki/XPath" rel="noopener ugc nofollow" target="_blank"> XPath </a> /CSS选择器)？这与自动化测试的<a class="ae ix" rel="noopener" href="/codex/automated-testing-goals-d3ace8fd223a">目标</a>相关:</p><ul class=""><li id="fa79" class="ly lz hi je b jf jg ji jj le ma lg mb li mc jx md me mf mg bi translated">测试与用户交互的方式越相似，我就越有信心(注意，这并不意味着端到端的测试；测试库可用于测试简单的反应组件)。如果我能够改变底层的实现细节，我会觉得重构更安全，更有指导意义。<a class="ae ix" rel="noopener" href="/codex/decoupling-tests-from-implementation-details-238a9ab06e4f"> CSS和XPath选择器以及HTML结构本身都是易变的底层细节</a>。测试id是一种变通方法，但是这意味着仅仅为了测试而创建实现代码(一个<a class="ae ix" rel="noopener" href="/codex/anti-patterns-of-automated-software-testing-b396283a4cb6">测试反模式</a>)。</li><li id="a35a" class="ly lz hi je b jf mh ji mi le mj lg mk li ml jx md me mf mg bi translated">作为一名开发人员，如果你在寻找UI元素上有困难，用户又如何能找到呢？当<em class="jd">作为用户</em>进行测试时，你会被强迫并鼓励遵循良好的可用性实践，比如编写<a class="ae ix" href="https://web.dev/learn/html/semantic-html/" rel="noopener ugc nofollow" target="_blank">语义HTML </a>(例如<code class="du lk ll lm ln b">article</code>、<code class="du lk ll lm ln b">section</code>、<code class="du lk ll lm ln b">nav</code>)以及提供可访问性标签(例如<code class="du lk ll lm ln b">title</code>、<code class="du lk ll lm ln b">alt</code>、<code class="du lk ll lm ln b">aria-label</code>)。</li><li id="8d4e" class="ly lz hi je b jf mh ji mi le mj lg mk li ml jx md me mf mg bi translated">当测试描述真实的使用场景时，我从测试中获得了更多的文档力量。如果我几个月后阅读这些测试，我可以很容易地理解他们的目标，并且不会迷失在技术细节中。</li></ul><p id="ae72" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated">为什么不首先使用测试库(在JavaScript或TypeScript中)？我在过去的一些项目中做过(这就是我了解测试库的原因)，但并不是每个人都在用这些语言/运行时工作。一些现实世界的项目已经在运行并使用Selenium for JVM，它们也应该受益于测试库。此外，我很欣赏编译语言能给测试套件带来什么。</p><p id="0a52" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated">如果没有这个库，您将不得不求助于id、类和测试id。如果你不想依赖这些技术细节，你需要大量的工具。在某些情况下，这甚至是不可能的。例如，不区分大小写的contains搜索不能用XPath实现(至少在当前的浏览器中)。</p><pre class="jz ka kb kc fd lo ln lp bn lq lr bi"><span id="011a" class="ls kl hi ln b be lt lu l lv lw">&lt;input placeholder='Username' /&gt;</span></pre><pre class="lx lo ln lp bn lq lr bi"><span id="e794" class="ls kl hi ln b be lt lu l lv lw">// 🟠 With pure Selenium<br/>val result = driver.findElements(By.cssSelector("*"))<br/>    .first() {<br/>        it.getAttribute("placeholder")?<br/>          .contains("USER", ignoreCase = true) == true<br/>    }</span></pre><pre class="lx lo ln lp bn lq lr bi"><span id="2b87" class="ls kl hi ln b be lt lu l lv lw">// 🟢 With Selenium Testing Library<br/>val result = driver.findElement(<br/>   ByPlaceholderText("USER", exact = false)<br/>)</span></pre><p id="944a" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated">注意，如果元素不是立即可用的，您仍然需要等待它们(就像本地定位器一样)；你可以求助于<a class="ae ix" href="https://lsoares.medium.com/different-types-of-waits-in-selenium-9522fc40f515" rel="noopener">硒的等待能力</a>。然而，如果你愿意，你可以使用我添加的一个API来依赖<a class="ae ix" href="https://testing-library.com/docs/dom-testing-library/api-async" rel="noopener ugc nofollow" target="_blank">测试库的等待</a>:</p><pre class="jz ka kb kc fd lo ln lp bn lq lr bi"><span id="4694" class="ls kl hi ln b be lt lu l lv lw">val firstName = driver.queryBy(<br/>   PlaceholderText, "first name", mapOf("exact" to false)<br/>)</span></pre><h1 id="c17b" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">怎么</h1><p id="7750" class="pw-post-body-paragraph jb jc hi je b jf lc ij jh ji ld im jk le lf jn jo lg lh jr js li lj jv jw jx hb bi translated">我如何在Selenium中集成测试库？通过评估它的JavaScript以便以后使用(相当于在JavaScript控制台中粘贴并运行它)。然后，我可以调用测试库函数并将结果映射回Java/Kotlin对象。这是这项技术有趣的部分:</p><pre class="jz ka kb kc fd lo ln lp bn lq lr bi"><span id="f69b" class="ls kl hi ln b be lt lu l lv lw">// 1️⃣ in JS, store a handle to TL's screen:<br/>import {screen} from '@testing-library/dom'<br/>window.screen = screen</span></pre><pre class="lx lo ln lp bn lq lr bi"><span id="ee86" class="ls kl hi ln b be lt lu l lv lw"># 2️⃣ generate the TL script to be injected:<br/>webpack --mode production<br/>cp dist/testing-library.js ../lib/src/main/resources</span></pre><pre class="lx lo ln lp bn lq lr bi"><span id="8970" class="ls kl hi ln b be lt lu l lv lw">// 3️⃣ evaluate the TL script so it gets stored in screen:<br/>driver.executeScript(<br/>   {}.getResource("/testing-library.js").readText()<br/>)</span></pre><pre class="lx lo ln lp bn lq lr bi"><span id="c448" class="ls kl hi ln b be lt lu l lv lw">// 4️⃣ call a TL function from screen and rely on Selenium to map the results to WebElements<br/>val results = driver.executeScript(<br/>   "return screen.queryAllByRole(arguments[0])", <br/>   "listbox"<br/>)</span></pre><p id="a080" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated">如您所见，所有繁重的工作都由测试库webpack和Selenium来完成。但是有一个缺失的部分:如何让这些查询对Selenium透明？我想使用它们，比如本地的(例如<code class="du lk ll lm ln b">driver.findElement(By.Id("profile"))</code>)。Selenium很容易用新的定位器扩展:继承<code class="du lk ll lm ln b">By</code>并实现<code class="du lk ll lm ln b">findElements</code>。下面是一个自定义定位器的示例(不是来自我的库):</p><pre class="jz ka kb kc fd lo ln lp bn lq lr bi"><span id="394e" class="ls kl hi ln b be lt lu l lv lw">data class ByAttribute(private val name: String, private val value: String) : By() {<br/>    override fun findElements(context: SearchContext): List&lt;WebElement&gt; =<br/>        context.findElements(<br/>            cssSelector("[$name='${value.replace("'", "\\''")}']")<br/>        )<br/>}</span></pre><p id="8a79" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated">我可以像使用任何原生Selenium定位器一样使用自定义定位器:<code class="du lk ll lm ln b">driver.findElement(ByAttribute("href", "http://example.com"))</code>。</p><h2 id="4895" class="mm kl hi bd km mn mo mp kq mq mr ms ku le mt mu kw lg mv mw ky li mx my la mz bi translated">获取、查询还是查找？一个还是全部？</h2><p id="9096" class="pw-post-body-paragraph jb jc hi je b jf lc ij jh ji ld im jk le lf jn jo lg lh jr js li lj jv jw jx hb bi translated">测试库核心API有三类查询:<code class="du lk ll lm ln b">get*</code>、<code class="du lk ll lm ln b">query*</code>、<code class="du lk ll lm ln b">find*</code>。选哪个？<code class="du lk ll lm ln b">get*</code>找不到元素时失败，我想把它留给硒。<code class="du lk ll lm ln b">find*</code>等待元素可用，同样，<a class="ae ix" href="https://lsoares.medium.com/different-types-of-waits-in-selenium-9522fc40f515" rel="noopener">硒有等待机制</a>。这使得<code class="du lk ll lm ln b">query*</code>成为更灵活的选项，也是我使用的选项。</p><p id="ec82" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated">每个函数族都有单数版本(例如<code class="du lk ll lm ln b">query</code>)和复数版本(例如<code class="du lk ll lm ln b">queryAll</code>)。我使用复数是因为要创建Selenium定位器，我们只需要实现<code class="du lk ll lm ln b">findElements</code>(复数)。Selenium基于它提供<code class="du lk ll lm ln b">findElement</code>(单数)。</p><h2 id="db68" class="mm kl hi bd km mn mo mp kq mq mr ms ku le mt mu kw lg mv mw ky li mx my la mz bi translated">移植还是适应？</h2><p id="2070" class="pw-post-body-paragraph jb jc hi je b jf lc ij jh ji ld im jk le lf jn jo lg lh jr js li lj jv jw jx hb bi translated">注入测试库脚本并将其连接到Kotlin/Java被称为<a class="ae ix" href="https://en.wikipedia.org/wiki/Adapter_pattern" rel="noopener ugc nofollow" target="_blank">适配器模式</a>。然而，我最初的方法是依靠Selenium定位器(例如，<code class="du lk ll lm ln b">xpath</code>，<code class="du lk ll lm ln b">cssSelector</code>)来移植测试库行为，目的是实现特性对等。事实证明这是一种有限的方法，因为:</p><ul class=""><li id="4513" class="ly lz hi je b jf jg ji jj le ma lg mb li mc jx md me mf mg bi translated">由于<a class="ae ix" href="https://webdriver.io/" rel="noopener ugc nofollow" target="_blank"> WebdriverIO </a>和浏览器限制(例如XPath的不区分大小写的文本搜索)，Selenium locators无法与测试库搜索功能竞争；</li><li id="29a5" class="ly lz hi je b jf mh ji mi le mj lg mk li ml jx md me mf mg bi translated">我必须移植所有的功能，这是一个很大的工作量；</li><li id="d3a0" class="ly lz hi je b jf mh ji mi le mj lg mk li ml jx md me mf mg bi translated">我可能会引入bugs</li><li id="b10f" class="ly lz hi je b jf mh ji mi le mj lg mk li ml jx md me mf mg bi translated">我不容易得到图书馆的更新。</li></ul><p id="c58d" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated">我最终使用了注入方法，基于测试库的MIT许可，这是有效的。一个例外是我移植了jest-dom而不是桥接它。为了弥合它，我不得不注入笑话和笑话界，这被证明是麻烦的。</p><h2 id="20fa" class="mm kl hi bd km mn mo mp kq mq mr ms ku le mt mu kw lg mv mw ky li mx my la mz bi translated">不会很慢吗？</h2><p id="6d5f" class="pw-post-body-paragraph jb jc hi je b jf lc ij jh ji ld im jk le lf jn jo lg lh jr js li lj jv jw jx hb bi translated">注入测试库会对性能产生影响。但是，请考虑以下优化:</p><ul class=""><li id="476a" class="ly lz hi je b jf jg ji jj le ma lg mb li mc jx md me mf mg bi translated">源JS脚本被缩小了(每个大约250KB)。</li><li id="3438" class="ly lz hi je b jf mh ji mi le mj lg mk li ml jx md me mf mg bi translated">JS文件最多从文件系统中读取一次，之后从内存中读取。</li><li id="1c6e" class="ly lz hi je b jf mh ji mi le mj lg mk li ml jx md me mf mg bi translated">每个脚本最多独立注入一次(直到出现页面导航或刷新)，并且仅在需要时注入。</li></ul><p id="1afc" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated">注射时间大致在20至40毫秒之间变化。考虑到测试库的好处，我相信这是值得的。</p></div><div class="ab cl na nb gp nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="hb hc hd he hf"><p id="988f" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated">这是这个库的源代码:</p><div class="nh ni ez fb nj nk"><a href="https://github.com/lsoares/selenium-testing-library" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">GitHub-lsoares/Selenium-testing-library:类似于</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">为什么？当我使用Selenium时，我不想依赖于id、类等等。我是测试库的粉丝，因为…</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ki nk"/></div></div></a></div><p id="c414" class="pw-post-body-paragraph jb jc hi je b jf jg ij jh ji jj im jk le jm jn jo lg jq jr js li ju jv jw jx hb bi translated"><strong class="je hj">这是在Maven Central发布的库:</strong></p><div class="nh ni ez fb nj nk"><a href="https://search.maven.org/artifact/com.luissoares/selenium-testing-library" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab dw"><div class="nm ab nn cl cj no"><h2 class="bd hj fi z dy np ea eb nq ed ef hh bi translated">Maven中央存储库搜索</h2><div class="nr l"><h3 class="bd b fi z dy np ea eb nq ed ef dx translated">Maven中央存储库维护者的官方搜索</h3></div><div class="ns l"><p class="bd b fp z dy np ea eb nq ed ef dx translated">search.maven.org</p></div></div></div></a></div></div></div>    
</body>
</html>