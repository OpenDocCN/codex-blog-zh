# 谁做得更好？番石榴还是爪哇？

> 原文：<https://medium.com/codex/who-did-it-better-guava-or-java-b7155cebeafd?source=collection_archive---------6----------------------->

## 不可变集合与集合。不可修改集合等等

Guava 是最流行的 Java 库之一。但是它已经存在很长时间了，而且 Java 已经实现了许多可以与 Guava 中的特性相媲美的特性。现在的问题是，哪一个做得更好？

![](img/4f28ab19cadbe90d20bebaeb1a69282a.png)

胡安·卡米洛·瓜林 P 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

# 不可变集合

Guava 对 Java 的所有公共集合都有不可变的实现，当然还有它自己的集合。虽然 Java 没有为它提供接口，但它提供了两种创建不可变集合的方法:`[Collections.unmodifiableXXX](https://docs.oracle.com/javase/9/docs/api/java/util/Collections.html#unmodifiableCollection-java.util.Collection-)`包装现有集合，`[XXX.of](https://docs.oracle.com/javase/9/docs/api/java/util/List.html#of--)`创建新集合。

为了简化起见，我以`ImmutableList`、`Collections.unmodifiableList`和`List.of`为例，但同样的事情也适用于所有其他版本。

## 额外的依赖

使用 Guava 会给你的代码引入一个新的依赖项。依我看，这很值得。即使对于这里的例子，您选择使用 Java 的实现，Guava 仍然提供了许多实用程序，这是值得的。

另一个不同的故事是在你的公共 API 中包含了番石榴类。在这种情况下，你会强迫该 API 的每个用户使用番石榴*和你的特定版本*。您也无法将其作为依赖项删除。

这个*可能*对你知道用户也将使用番石榴的图书馆来说是好的，但是即使在那里也应该避免。

## 明确的诉说

当你在某处看到`ImmutableList`时，你知道那个值是不可变的。Java 的方法则不然，它们将简单地返回一个`List`。

这种显式告诉非常有用:

*   **在参数中:**调用者被保证方法不会改变列表。另一方面，用户必须首先将他们的集合包装在一个不可变的集合中。
*   **返回值:**调用者知道这个集合不应该被改变。这也有助于实现，因为您通常可以避免创建新的实例，只在需要时更新列表。您不必查看方法的文档来判断改变返回的集合是否合适。
*   **在字段和变量中:**当阅读代码时，很明显这个字段或变量没有也不应该变异。这有助于减轻一些精神负担。它还能捕捉到“林挺时间”的一些潜在错误。

## 较少的防御性副本

为了更好地保证给定的列表在给定的上下文中不被更改，通常会创建防御性副本。“防御性副本”指的是首先创建一个给定集合的不可变版本，然后严格地对该版本进行操作。

这种做法有助于确保列表不会在不应该发生变化的时候发生变化。然而，这只会在运行时被注意到，并且与直接使用列表相比会花费一些运行时间。

直接使用不可变版本作为参数可能会迫使用户创建一个不可变版本，但这也向他们表明，它可以在其他不改变列表的方法中重用。这可能会导致生成更少的副本，但肯定会导致更加清晰，因为我不需要看到实现就可以知道列表是否会发生变化。

## 不可变列表是真正不可变的

Java 的`Collections.unmodifiableList`只会在集合上提供一个不可变的**视图**。这是一个重要的区别。

首先，也是最重要的，这意味着它们不是真正不可变的:如果原始实例改变了，它们也会改变。

这也意味着他们不能像 Guava 的实现那样充分利用不变性。它们仍然必须包括不必要的并发检查，可能会分配不必要的空间等等。

这些差异对于`List.of`方法来说不太相关，它无论如何都会创建一个新的列表——即使使用了接受一个字符串数组的重载。然而，需要注意的是，我在任何官方文档中都没有提到这一点，所以，从技术上来说，不能保证这种情况会持续下去，或者在所有实现中都是一样的。

然而,`ImmutableList`和 Java 的不可修改列表都不能阻止它们的元素被修改。为此，您必须创建一个深层副本。在我的研究过程中，我偶然发现了这篇漂亮的博客文章，它以一种漂亮、直观的方式概述了这些方法的不同之处。

## ImmutableList 是一个列表

这可能不是关于 Guava 实现的争论，而是一个重要的注意事项:`ImmutableList`实现了`List`接口。

这意味着您可以在任何可以使用 Java 中不可修改列表的地方使用`ImmutableList`的实例。

但是，有一种情况需要注意:当被调用的方法使用 Java 方法创建防御性副本时。在这种情况下，当您传递一个`ImmutableList`时，它将创建一个新的实例，而不是重用旧的实例。当提供 Java 的不可修改列表时，它会直接使用那个实例。

反过来也是一样:`ImmutableList.copyOf`不会创建一个新的实例，如果传递给它的是一个`ImmutableList`的话，但是如果传递的是一个不可修改的列表，它就会创建一个新的实例。

实现`List`接口也意味着它们有一个共同的大问题:你仍然可以调用修改集合的方法。它只会在运行时失败，而不会在编译时失败。Guava 的版本更好地缓解了这一问题，因为他们主动将这些方法标记为`deprecated`，这将出现在大多数编辑器中。当然，这只在使用 raw `ImmutableList`时有效，而当它用作`List`时无效。

## 裁决

我相信与 Java 标准库方法相比，Guava 的集合带来了很多价值，所以如果项目中有 Guava，我会一直使用这些方法。我甚至可能会考虑为他们添加番石榴，但幸运的是番石榴有很多其他好的特性，这使得添加它变得非常容易。

# 可选择的

在 Java 添加可选之前，Guava 添加了可选。在这种情况下，最好的比较可能是在 Guava 自己的文档中找到的[:](https://guava.dev/releases/19.0/api/docs/com/google/common/base/Optional.html)

> Java 8 增加了一个新的`Optional`类。这两个类非常相似，但是不兼容(它们不能共享一个公共的超类型)。*所有已知的差异都列在这里或用下面的相关方法列出。*
> 
> -此类是可序列化的；`java.util.Optional`不是。
> 
> - `java.util.Optional`有另外的方法`ifPresent`、`filter`、`flatMap`和`orElseThrow`。
> 
> - `java.util`提供原始专用版本`OptionalInt`、`OptionalLong`和`OptionalDouble`，推荐使用；番石榴没有这些。
> 
> 在可预见的将来，没有计划弃用该职业。然而，我们温和地建议您尽可能喜欢新的标准 Java 类。

所以根据 Google 自己的推荐，你应该选择 Java 库版本。我倾向于同意，主要是因为你可以在公共 API 中安全地使用那个版本。额外的方法(主要是`filter`和`flatMap`)也是一个不错的奖励。

奇怪的是，出于某种原因，这两个方法以及`map`在它们的原始对应物中不见了。我猜甲骨文认为它们不够有用。

# 字符集与标准字符集

这两个实际上是一样的。两者都提供了与静态字段相同的字符集列表:UTF-8、UTF-16、UTF-16BE、UTF-16LE、US-ASCII 和 ISO-8859–1。

这也有助于[番石榴的文档](https://guava.dev/releases/19.0/api/docs/com/google/common/base/Charsets.html)对每个常量都有这样的句子:

> **Java 7 及更高版本注意:**该常量应被视为已弃用；用`StandardCharsets.XXX`代替。

因此，出于与`Optional`相同的原因，我建议使用 Java 版本。

# 摘要

总之，我会使用 Guava 版本的不可变集合，但是使用标准库版本的`Optional`和字符集。对于后两者，没有足够的理由在现有的基础上使用一个库。

概括地说，不可变集合的原因是:

*   明确告诉我们某件事是不可改变的。
*   它们可以作为简单的`List`使用，就像 Java 的实现一样。
*   如果源集合被修改(如果存在的话)，它们也不会被修改。
*   他们可以在实现集合时利用不变性。这意味着有时方法的运行时间更好，需要的内存更少。

然而，它们也有一些缺点:

*   它们需要额外的依赖，如果您想在公共 API 中使用这些类/方法，这尤其成问题。
*   他们仍然有来自实现`List`的相同问题。

最后一点:番石榴也有自己处理未来的方式，而 Java 现在有`CompletableFuture`。这个话题应该有自己的博文，然而，[所以我在这里写了一篇](https://oscarablinger.medium.com/the-ultimate-guide-to-futures-in-java-and-guava-c53263dd69dc)。