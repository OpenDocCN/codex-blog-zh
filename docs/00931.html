<html>
<head>
<title>Median of two sorted arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两个排序数组的中值</h1>
<blockquote>原文：<a href="https://medium.com/codex/median-of-two-sorted-arrays-a84a4315e85?source=collection_archive---------3-----------------------#2021-03-26">https://medium.com/codex/median-of-two-sorted-arrays-a84a4315e85?source=collection_archive---------3-----------------------#2021-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/df306fa113a30db09d44291d17a18233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g3QXU5JCIcccqfbA"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由<a class="ae hv" href="https://unsplash.com/@dtopkin1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">戴恩·托普金</a>在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="9a0b" class="hw hx hy bd b fp hz ia ib ic id ie dx if translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">抄本</a></h2><div class=""/><p id="7593" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们得到两个排序后的数组，我们的目标是在<strong class="jg ii">对数</strong>时间和<strong class="jg ii"> O(1) </strong>空间复杂度(<a class="ae hv" href="https://leetcode.com/problems/median-of-two-sorted-arrays/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>)下找到这些数组的中值。这是一个非常常见的问题，在互联网上有很多解决方法。然而，我花了一些时间来理解它。我想在这里描述一下我的思考过程和解决方案。</p><h2 id="6798" class="kc kd hy bd ke kf kg kh ki kj kk kl km jp kn ko kp jt kq kr ks jx kt ku kv ie bi translated">问题陈述</h2><p id="b0b7" class="pw-post-body-paragraph je jf hy jg b jh kw jj jk jl kx jn jo jp ky jr js jt kz jv jw jx la jz ka kb hb bi translated">首先，这是我们计算单个排序数组的中值的方法:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es lb"><img src="../Images/a04bb1098d8197206923a4a13a439973.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*ZST_RRJdHop72wCbQbzIdw.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图一。寻找单个偶数长度排序数组的中值</figcaption></figure><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es lg"><img src="../Images/8dba767cc6db9e6d3a51a468f9ee8014.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*ayc8lwJCNwNObtAY7HdeYg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图二。寻找单个奇数长度排序数组的中值</figcaption></figure><p id="60b6" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们先把问题陈述形象化。考虑如下所示的两个数组:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es lh"><img src="../Images/72cf686bd7dbd1f72f2d82f24c60a526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*Zy7YXUY-jCn2_I3SPYptiQ.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图三。寻找两个排序数组的中间值(问题陈述)</figcaption></figure><p id="5e96" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这里，我们有两个排序的数组A和b。为了找到这些数组的中值，我们可能需要组合这两个数组，对其排序并计算组合数组的中值。这种方法不能满足问题陈述的要求，因为:</p><p id="2311" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">a)将两个数组组合成一个数组并对其排序(使用类似merge sort的算法)是一个<strong class="jg ii"> O(n*log(n)) </strong>时间操作</p><p id="8cc6" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">b)空间复杂度也是O(n) 因为我们需要创建一个新的数组来容纳这两个数组</p><p id="4d38" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">不能通过简单地将一个数组附加到另一个数组来获得组合数组A+B。这就是为什么试图组合数组来确定中值的方法不能满足问题所强加的对数时间约束——我们知道每个数组中元素之间的关系，因为它们是排序的。所以，最小的在开头，最大的在结尾。但是，我们不知道数组中元素之间的关系。如果不完全遍历两个数组，我们就找不到它们之间的关系，这违反了时间限制。</p><h2 id="1950" class="kc kd hy bd ke kf kg kh ki kj kk kl km jp kn ko kp jt kq kr ks jx kt ku kv ie bi translated">解决方法</h2><p id="146a" class="pw-post-body-paragraph je jf hy jg b jh kw jj jk jl kx jn jo jp ky jr js jt kz jv jw jx la jz ka kb hb bi translated">如果你仔细想想，这些约束确实在把我们推向不必担心组合数组的方向。一个O(log(n))算法(像二分搜索法)基本上是在每次迭代中根据一些标准丢弃数组的一部分。因此，我们需要想办法将其纳入我们的解决方案。</p><p id="8a05" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">也就是说，如果我们知道A和B已经排序，我们就不需要知道A+B看起来是什么样子来计算中位数。我们只需要知道组合数组的<strong class="jg ii">前半部分</strong>就可以求出中值。根据A+B的长度，中间带的位置会略有不同:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es li"><img src="../Images/8b60b6255a6b0c8b057ea9f65b5d9b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*K788oxnm_MrzulhbIJonkw.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图4。当A+B中的中间元素的长度为奇数时，它的索引</figcaption></figure><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es lj"><img src="../Images/ba06cbf12e8e63dc44d07dadf8603236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*9RbebIVHV7f6gWTU_cw-4Q.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图五。A+B中长度为偶数的中间元素的索引</figcaption></figure><p id="8b73" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">底线是，一旦我们知道A和B中的哪些元素对组合数组A+B的前半部分(左侧)有贡献，我们并不真正关心其余的元素，这将帮助我们在对数时间内解决这个问题。</p><p id="261e" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">好，那么O(1)空间约束呢？这意味着，我们不应该为任何临时数组分配内存。严格来说我们不需要。一旦我们开始实施解决方案，我们将进一步讨论这一点。</p><p id="c803" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">简而言之，我们将对两个数组应用二分搜索法，画一条线来表示给定数组的多少部分将贡献给组合数组的左半部分或前半部分。这可以想象成这样:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es lk"><img src="../Images/1119d1e28a622b0c3516339bf28f0a84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*Ip6pRMUzLFKLbZCog5mzrg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图六。可视化二分搜索法方法以确定每个阵列中的哪些元素对组合阵列有贡献(奇数长度)</figcaption></figure><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es ll"><img src="../Images/2bbe6651d00c944ed0ef8bdbbc9739dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*VA3tasV-K2l8FvRXdGbu9Q.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图7。可视化二分搜索法方法以确定每个数组中的哪些元素对组合数组有贡献(偶数长度)</figcaption></figure><h2 id="2ab8" class="kc kd hy bd ke kf kg kh ki kj kk kl km jp kn ko kp jt kq kr ks jx kt ku kv ie bi translated">实施细节</h2><p id="83d5" class="pw-post-body-paragraph je jf hy jg b jh kw jj jk jl kx jn jo jp ky jr js jt kz jv jw jx la jz ka kb hb bi translated">请记住，我们的目标是使用二分搜索法来计算每个数组对组合数组的贡献。二分搜索法问题的结构是什么？</p><figure class="lc ld le lf fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lm"><img src="../Images/d65b7576d1cca0e7e2a434ac07ede6fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9DsWJtklqxW_yo8PYIiXA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图8。二分搜索法伪代码</figcaption></figure><p id="65db" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">因此，我们需要将我们的问题陈述映射成这种格式。我们有两个数组可以使用。我们应该关注一个数组(较小的那个)并用它来确定两个数组的贡献。假设A是较小的数组。</p><p id="d965" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="jg ii"> a)什么能让我们的循环继续下去？</strong></p><p id="ceda" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们应该继续循环，直到我们探索了所有可能的方法来组合两个数组以确定A+B的左半部分。例如，如果A+B的左侧大小为4，并且我们从A中选取了一个元素，这自动意味着我们需要从B中选取三个元素。我们可以从A中不选取任何元素，从A中选取几个元素，或者从A中选取所有元素。因此，我们继续循环，直到A的贡献等于其长度。</p><p id="9371" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="jg ii"> b)我们的目标是什么，我们应该如何测试它？</strong></p><p id="ce31" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们想找到A+B的左边，这样我们就可以很容易地计算出中间值。所以，我们想找到一个能帮助我们达到中间值的分割。</p><p id="623f" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">每个拆分将两个数组分成4部分，我们将拆分的左半部分的元素组合起来，形成A+B的前半部分，如下所示:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es ln"><img src="../Images/794a6f0b93e017db90a661fb745e2903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*Pm2qpa2dUSRssk2kWPeA8w.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图九。目标可视化</figcaption></figure><p id="afe6" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果左边的所有元素都小于右边的所有元素，那么，我们知道分裂给了我们A+B的前半部分。</p><p id="ec64" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">那就是:</p><p id="7508" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="jg ii"> A[aL] &lt; B[bR]和B[bL] &lt; A[aR]，</strong>其中aL、bL、bR和aR对应于分裂两侧元素的索引。</p><p id="7ece" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="jg ii"> c)如果我们找到目标分割点，我们如何计算中位数？</strong></p><p id="4b27" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">考虑A+B的长度为奇数的情况(图9 ),并假设我们已经找到了目标分割。现在，我们有一个分裂，a1 &lt; b4 and b3 &lt; a3. Since A+B has a length of 7, the median is the 4th element in A+B and this has to be either a1,b1,b2 or b3 (elements on the left half). We have 4 numbers and there are 4! ways of arranging them (assuming no repetition), as shown below:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es lo"><img src="../Images/7f2632ea5b5b34bdbce5739ac9e5dc33.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*bDFvVoEA0HoFAhoRJVa_6w.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">Fig 10. Different ways in which elements on the left side of the A+B array (odd length)can be arranged, depending on their values</figcaption></figure><p id="a060" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">But, do we really care about these arrangements? We are only interested in the fourth element:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es lp"><img src="../Images/7f3bfa384fbd2c7e7c7e645deb1bbf53.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*tDI30h4pxraVXYlYdyGK0g.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">Fig 11. Position of median in A+B (odd length) that we are interested in</figcaption></figure><p id="c8c0" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">The 4th element has to be the largest number on the left-hand side and we only need to compare the largest numbers from A and B to get this! So:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es lq"><img src="../Images/7a0b3f9fd974e1f8ec4aa7a3af0bdf8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*os33pEG1SiTeE2m3zq7o9w.png"/></div></figure><p id="ab78" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">Similarly, let’s look at a situation where A+B has an even length:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es lr"><img src="../Images/9076e80d8ea731fb5d6e70bdaa7f8673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*APg-zKK-fqt6B5BWuY2FtA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">Fig 12. Finding median of A+B which has an even length</figcaption></figure><p id="b1ee" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">Now, we have a split where a2 &lt; b3 and b2 &lt; a3. Since A+B has a length of 8, the median is the average of the 4th and 5th elements in A+B.</p><p id="4b1c" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">There are 4! ways of arranging {a1,a2,b1,b2} and for each arrangement, there are 2 ways of picking the 5th element (a3 or b3):</p><figure class="lc ld le lf fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ls"><img src="../Images/c81eaecb1823a0f305b5baaea45aacd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*C32K6ymXqee7RRmrgcMh2g.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">Fig 13. Different ways in which elements on the left side of the A+B array (even length)can be arranged, depending on their values</figcaption></figure><p id="4f07" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">Here again, do we really care about these arrangements? We are only interested in the 4th and 5th elements:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es lt"><img src="../Images/c5776230c28ae71d8b41c40c4431b0f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*1kcBM14bDmtuA0_85c9m4A.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">Fig 14. Position of median in A+B (odd length) that we are interested in</figcaption></figure><p id="007b" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">The 4th element is the largest on the left side of A+B and it must be max(a2,b2), just like what we saw for the odd length case. The 5th element has to be either a3 or b3. But, it must be just next to the 4th element. So, we pick the minimum value, i.e. min(a3,b3):</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es lu"><img src="../Images/3686b31be00f03b4cfe010d316c96430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*r88YlzIe4oOUn841lFmklQ.png"/></div></figure><p id="6ff8" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="jg ii"> d)如果我们找不到目标，我们如何继续循环？</strong></p><p id="0d56" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">简而言之，如果我们没有找到目标分割，我们应该包含或多或少的a。</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es lv"><img src="../Images/dfb6c36ee4f9f96025e764735a9ba5c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*_k5Tun3zeQ8-NjGqqpjbaA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图15:当A+B的长度为奇数时，首先拆分两个数组来计算中值</figcaption></figure><p id="5db4" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在这个例子中，A+B的奇数长度为7，中位数是第4个元素。我们首先从A中选取一个元素，从B中选取3个元素来计算A+B的左半部分。</p><p id="6c49" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">1 &lt; 6. However, 5 &gt; 4。这表明A的右边有更小的元素，这意味着5都不是第四个最小的元素。我们需要包含更多的A来发现这个元素。所以，我们继续下一次迭代:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es lw"><img src="../Images/598f3a57eacd45b462fe8c3056bb27e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*Xb4ds7MS7KhqIgNzPggyTg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图16:当A+B的长度为奇数时，第二次拆分两个数组以计算中值</figcaption></figure><p id="29e5" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">让我们再次比较两侧的元素— 4 &lt; 5和3 &lt; 7，左侧有4个元素。所以，我们找到了正确的分割！</p><p id="426f" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">因为A+B的长度是奇数，所以我们需要找到这个子数组中的最后一个元素。这必须是数组A和B最右端的最大值，即max(4，3)，也就是4。</p><p id="9ee7" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">让我们看另一个例子，A+B的长度是偶数:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es lx"><img src="../Images/49d103dbf074b11fba714afd12460fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*HKO9ttG8ezMV9pkwAbEVUQ.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图17:当A+B的长度为偶数时，第一次拆分两个数组以计算中值</figcaption></figure><p id="32a8" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">A+B的偶数长度为8，中位数是第4个和第5个元素的平均值(mean(4，5))。我们从A中选取1个元素，从b中选取3个元素。</p><p id="f89b" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">1 &lt; 6. However, 5 &gt; 4。这意味着5都不能是第四个最小的元素。我们需要包含更多的A来发现这个元素。所以，我们继续下一次迭代:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div class="er es ly"><img src="../Images/d1170b3c2d8146180254e56d6017d5ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*nnzgwXH7ZDFB1GHhxm7BXA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图18:当A+B的长度为偶数时，第二次拆分两个数组以计算中值</figcaption></figure><p id="8fb9" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在这里，4个&lt; 6 and 5 &lt; 7. So, we have found the median split! So, the median is the average of max(4,3)and min(5,7).</p><p id="3cb2" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">One thing to remember is, we can be in a situation where the split results in one more more of the halves being empty. For example:</p><figure class="lc ld le lf fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lz"><img src="../Images/9b31f12cf40064ddb8d32546717e18c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GhcxS5jGw8QyxyjGsUwUYA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">Fig 19: Special situation to consider in implementation</figcaption></figure><p id="cef7" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">This is an interesting case where two of the splits to the right are empty! What do we compare 1 and 2 to? The smaller values are on the left and the larger ones are on the right. Since we have no valid number to compare to, we just assume that 1 and 2 satisfy the condition for a median split. This can be done by comparing them to very large values (+∞). Similarly, if there are empty values on the left, we compare it with -∞.</p><h2 id="fb57" class="kc kd hy bd ke kf kg kh ki kj kk kl km jp kn ko kp jt kq kr ks jx kt ku kv ie bi translated">Time complexity analysis</h2><p id="5c1c" class="pw-post-body-paragraph je jf hy jg b jh kw jj jk jl kx jn jo jp ky jr js jt kz jv jw jx la jz ka kb hb bi translated">Now that we know how to implement this algorithm, it is time to make sure it satisfies the constraints of the problem.</p><p id="3bca" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">We have not used any temporary arrays and we just rely on the indices for our implementation. So, the space complexity is O(1).</p><p id="8232" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">We always pick the smaller array to iterate and and every step we either include more of it (less of the other array) or less of it (more of the other array). So, the time complexity is O(log(min(A,B))).</p><h2 id="927e" class="kc kd hy bd ke kf kg kh ki kj kk kl km jp kn ko kp jt kq kr ks jx kt ku kv ie bi translated">Link to Github repository: <a class="ae hv" href="https://github.com/madhu90/CodeExamplesForBlogPosts.git" rel="noopener ugc nofollow" target="_blank">https://github.com/madhu90/CodeExamplesForBlogPosts.git</a></h2><h2 id="b889" class="kc kd hy bd ke kf kg kh ki kj kk kl km jp kn ko kp jt kq kr ks jx kt ku kv ie bi translated">参考</h2><p id="69aa" class="pw-post-body-paragraph je jf hy jg b jh kw jj jk jl kx jn jo jp ky jr js jt kz jv jw jx la jz ka kb hb bi translated">[1]<a class="ae hv" href="https://www.geeksforgeeks.org/median-of-two-sorted-arrays/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/median-of-two-sorted-arrays/</a></p><p id="bbc9" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">[2]<a class="ae hv" href="https://www.geeksforgeeks.org/median-of-two-sorted-arrays-of-different-sizes/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/median-of-two-sorted-arrays-of-different-size/</a></p><p id="df77" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">[3]<a class="ae hv" href="https://www.youtube.com/watch?v=LPFhl65R7ww&amp;ab_channel=TusharRoy-CodingMadeSimple" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=LPFhl65R7ww&amp;ab _ channel = TusharRoy-coding made simple</a></p><p id="35d2" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">[4]<a class="ae hv" href="https://www.youtube.com/watch?v=MHNTl_NvOj0&amp;ab_channel=IDeserve" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=MHNTl_NvOj0&amp;ab _ channel = IDeserve</a></p></div></div>    
</body>
</html>