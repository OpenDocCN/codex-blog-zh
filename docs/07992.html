<html>
<head>
<title>Implementing a Clean Architecture Application in Scala — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Scala中实现一个干净的架构应用——第2部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/implementing-a-clean-architecture-application-in-scala-part-2-4555af428d34?source=collection_archive---------6-----------------------#2022-07-09">https://medium.com/codex/implementing-a-clean-architecture-application-in-scala-part-2-4555af428d34?source=collection_archive---------6-----------------------#2022-07-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="90b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">干净架构是由罗伯特·c·马丁(鲍勃大叔)提出的一套指导方针。在我之前的一篇文章“<a class="ae jd" href="https://saeiddadkhah.medium.com/clean-architecture-in-scala-41d1ab05a618" rel="noopener">在Scala </a>中清理架构”中，我已经写了关于这个架构的文章，并描述了我们的风格，我建议你在开始这篇文章之前阅读一下。下图是我们干净的建筑风格。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/c055d8f3ee9ead0066dcc1456ed8ffcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*VvEDFkd5-7crH_PHzw34Mg.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">我们干净的建筑</figcaption></figure><div class="jq jr ez fb js jt"><a rel="noopener follow" target="_blank" href="/codex/clean-architecture-in-scala-41d1ab05a618"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hj fi z dy jy ea eb jz ed ef hh bi translated">Scala中干净的架构</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">首先，什么是干净的架构？罗伯特·c·马丁(鲍勃大叔)声称虽然系统架构…</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">medium.com</p></div></div><div class="kc l"><div class="kd l ke kf kg kc kh jk jt"/></div></div></a></div></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="8523" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在我的<a class="ae jd" href="https://github.com/SaeidDadkhah/clean-arch-example" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上实现了一个类似Medium的小型博客应用程序。这个实现不是一个性能实现，它的唯一用途是描述这里提供的概念。</p><div class="jq jr ez fb js jt"><a href="https://github.com/SaeidDadkhah/clean-arch-example" rel="noopener  ugc nofollow" target="_blank"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hj fi z dy jy ea eb jz ed ef hh bi translated">GitHub-SaeidDadkhah/Clean-arch-example:Scala中干净架构的实现</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">Scala中干净架构的实现。我们将使用Clean架构实现一个简单的博客应用程序…</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">github.com</p></div></div><div class="kc l"><div class="kp l ke kf kg kc kh jk jt"/></div></div></a></div><p id="dcb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇博客完全基于我之前的文章“<a class="ae jd" href="https://saeiddadkhah.medium.com/implementing-a-clean-architecture-application-in-scala-part-1-1442f0438b03" rel="noopener">在Scala中实现一个干净的架构应用——第1部分</a>”，所以请务必阅读并理解其中描述的概念。</p><div class="jq jr ez fb js jt"><a rel="noopener follow" target="_blank" href="/codex/implementing-a-clean-architecture-application-in-scala-part-1-1442f0438b03"><div class="ju ab dw"><div class="jv ab jw cl cj jx"><h2 class="bd hj fi z dy jy ea eb jz ed ef hh bi translated">在Scala中实现一个干净的架构应用——第1部分</h2><div class="ka l"><h3 class="bd b fi z dy jy ea eb jz ed ef dx translated">干净的架构是由罗伯特·c·马丁(鲍勃大叔)提出的一套指导方针，我将实现一个…</h3></div><div class="kb l"><p class="bd b fp z dy jy ea eb jz ed ef dx translated">medium.com</p></div></div><div class="kc l"><div class="kd l ke kf kg kc kh jk jt"/></div></div></a></div></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h1 id="de8b" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">应用层-用例</h1><p id="07c2" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi lt translated">应用程序的主要层是用例层，它是应用程序层的一部分。该层的完整实现在<code class="du mc md me mf b">04_application</code>目录下的<code class="du mc md me mf b">04_application</code>项目中提供。<code class="du mc md me mf b">com.github.saeiddadkhah.application</code>包的结构与<code class="du mc md me mf b">com.github.saeiddadkhah.contract.service</code>包的结构完全相同。对于同名的<code class="du mc md me mf b">service</code>包中的每个服务，在<code class="du mc md me mf b">application</code>包中都有一个用例，每个用例都扩展了它对应的服务并实现了它的<code class="du mc md me mf b">call</code>方法。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es mg"><img src="../Images/c97ddd0d887026655ed21aaddd7dfa28.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*t8Tsp5mPh9QeT9M-fXTjzA.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">应用层用例的结构</figcaption></figure><p id="e88f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">任何想要使用该应用程序的人都应该首先注册，所以这是任何人与之交互的第一个用例，也是我们开始检查架构的一个好点。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">注册用例的实现</figcaption></figure><p id="72f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是注册用例的实现。注册服务已经被定义为<code class="du mc md me mf b">abstract class SignUpService extends Service[SignUpService.Request, User]</code>，所以它的<code class="du mc md me mf b">call</code>方法的签名是<code class="du mc md me mf b">def call(request: SignUpService.Request)(implicit ec: ExecutionContext): Future[User]</code>，我在<code class="du mc md me mf b">SignUpUseCase</code>中覆盖了它。</p><p id="a0c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我散列用户提供的密码，检查用户名的可用性，并创建用户。在实际实现中，在添加用户之前，您可能会检查密码强度、验证用户名和电子邮件，并进行一些其他验证。检查用户名可用性的结果是一个<code class="du mc md me mf b">Future[Unit]</code>的实例。在用户名不可用的情况下，我们不是抛出任何类型的异常，而是返回一个failed <code class="du mc md me mf b">Future</code>的实例，以遵循函数式编程的原则。</p><p id="f1c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个用例需要访问用户来验证用户名的可用性并添加用户。我们给构造函数添加了<code class="du mc md me mf b">userCallback: UserCallback</code>参数来显示这个需求。正如依赖倒置原则所陈述的，重要的一点是使用回调<strong class="ih hj"> <em class="mn">(不是存储库)</em> </strong>来指定这些需求。如果用例使用其他服务，我们应该将服务<strong class="ih hj"> <em class="mn">(非用例)</em> </strong>添加到构造函数中。例如，假设我们应该更改实现，使服务返回一个<code class="du mc md me mf b">Session</code>类的实例，我们希望使用<code class="du mc md me mf b">SignInService</code>。我们可以修改上面的代码，使用<code class="du mc md me mf b">SignInService</code>，在<code class="du mc md me mf b">call</code>方法实现的最后调用它。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">注册用例的实现依赖于注册服务</figcaption></figure><h1 id="c4a9" class="kq kr hi bd ks kt mo kv kw kx mp kz la lb mq ld le lf mr lh li lj ms ll lm ln bi translated">配置</h1><p id="5d48" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi lt translated">在谈论存储库之前，让我解释一下模块。有三个基本模块<code class="du mc md me mf b">ConfigModule</code>、<code class="du mc md me mf b">CallbackModule</code>和<code class="du mc md me mf b">ServiceModule</code>。每种类型的外部数据源都应该有一个模块，例如数据库和REST API。</p><h2 id="f43b" class="mt kr hi bd ks mu mv mw kw mx my mz la iq na nb le iu nc nd li iy ne nf lm ng bi translated">配置模块</h2><p id="029f" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">Config模块提供了几种方法来读取与应用程序运行环境相关的一些数据。例如，如果我们想在测试和生产环境中使用不同的数据库，我们可以使用不同的配置文件来设置与每个环境相关的连接信息，而无需更改代码。尽管使用一组环境变量似乎是一个好的选择，但是由于构造配置条目的能力，还有更好的选择，例如JSON和XML文件。我们使用<code class="du mc md me mf b">com.typesafe</code>的<code class="du mc md me mf b">config</code>库来加载配置。它利用<a class="ae jd" href="https://github.com/lightbend/config/blob/main/HOCON.md" rel="noopener ugc nofollow" target="_blank"> HOCON </a>文件加载配置。下面是我们的<code class="du mc md me mf b">ConfigModule</code>的实现。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">配置模块</figcaption></figure><p id="87d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有多种方法可以指定我们希望用来运行应用程序的配置文件。正如所料，<code class="du mc md me mf b">config</code>库提供了<code class="du mc md me mf b">c.t.c.ConfigFactory.parseFile</code>函数来解析配置文件。您可以设置一个环境变量来指定配置文件的位置，并使用此函数加载它。一种更优雅的方法是使用<code class="du mc md me mf b">-DConfig.file</code> JVM选项并使用这个函数<code class="du mc md me mf b">ConfigFactory.load().withFallback(ConfigFactory.defaultApplication()).resolve</code>。</p><p id="52fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个重要的<strong class="ih hj">安全</strong>点是<strong class="ih hj"> <em class="mn">不是</em> </strong>提交配置文件。在<code class="du mc md me mf b">.gitignore</code>文件中放一些忽略配置文件的条目，例如<code class="du mc md me mf b">application.conf</code>、<code class="du mc md me mf b">application.staging*.conf</code>和<code class="du mc md me mf b">application.prodcution*.conf</code>。因为您应该指定所需的配置条目，并为枚举提供样本值和可能的有效值，所以您可以在存储库中包含<code class="du mc md me mf b">application.template.conf</code>文件，并用样本值填充它。</p><h2 id="f724" class="mt kr hi bd ks mu mv mw kw mx my mz la iq na nb le iu nc nd li iy ne nf lm ng bi translated">回拨和服务模块</h2><p id="8f1e" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">我们使用这些模块将实现绑定到抽象。下面是<code class="du mc md me mf b">ServiceModule</code>的实现。我们使用从<code class="du mc md me mf b">CallbackModule</code>导入的回调实例，而不是在这里实例化存储库。在这个实现中，我们只实例化每个用例一次，这使它们成为单例。将值设为<code class="du mc md me mf b">lazy</code>可能是一个更好的主意。如果您想要使用依赖注入库，您应该将实现绑定到这些文件中的抽象。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ml mm l"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">服务舱</figcaption></figure><h2 id="2be3" class="mt kr hi bd ks mu mv mw kw mx my mz la iq na nb le iu nc nd li iy ne nf lm ng bi translated">简单的内存模块</h2><p id="f6b2" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">在这个模块中，我实现了一个简单的非性能内存数据库。</p><h1 id="38d0" class="kq kr hi bd ks kt mo kv kw kx mp kz la lb mq ld le lf mr lh li lj ms ll lm ln bi translated">适配器层-存储库</h1><p id="582c" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">我们应该为这个包中的每种类型的数据源创建一个特定的包。我们目前只使用内存中的数据源，所以在<code class="du mc md me mf b">repository</code>包中只有一个包。每个存储库包可能包含两个名为<code class="du mc md me mf b">repository</code>和<code class="du mc md me mf b">adapter</code>的包。内存中的数据源不包含一个<code class="du mc md me mf b">adapter</code>包，因为它的实现需要一个类型参数，我们将它用于域类。适配器和存储库的包结构应该分别与域和回调相同。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es nh"><img src="../Images/2147f4ab45922568d7c8c4a6cc4f4e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*VOyprlA2iZF9ZGqNNv1vlw.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">适配器层的存储库的结构</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ni"><img src="../Images/93d44a09a1312b02a3e554c5839f1714.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*ylsxYlXGXhXpLL-nFwznQg.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">具有多种数据源类型和适配器包的适配器层的存储库结构</figcaption></figure><p id="3129" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">储存库类扩展它们相应的回调和模块，并实现它们的抽象成员。这里是<code class="du mc md me mf b">UserRepository</code>的定义。</p><pre class="jf jg jh ji fd nj mf nk nl aw nm bi"><span id="f96f" class="mt kr hi mf b fi nn no l np nq">class UserRepository extends UserCallback with SimpleInMemoryModule[User] {<br/>   ???<br/>}</span></pre><h1 id="c8af" class="kq kr hi bd ks kt mo kv kw kx mp kz la lb mq ld le lf mr lh li lj ms ll lm ln bi translated">使用应用程序</h1><p id="d33f" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi lt translated">应用程序现在已经可以使用了。您应该只使用服务模块中提供的服务实例或者从依赖注入框架中获取服务实例，并且只调用<code class="du mc md me mf b">call</code>方法。例如，如果您正在实现一个REST服务器，那么您可以为每个端点使用一个服务，并使用身份验证和授权服务来控制用户对端点的访问并过滤请求。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="b572" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">敬请关注下一篇添加条目的帖子，例如REST API。请随意检查<a class="ae jd" href="https://github.com/SaeidDadkhah/clean-arch-example" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>和开放问题。我希望你喜欢这个教程。谢谢你。</p></div></div>    
</body>
</html>