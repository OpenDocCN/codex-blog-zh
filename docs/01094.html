<html>
<head>
<title>Unity3D: Eliminate Clutter when Instantiating many Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity3D:在实例化许多对象时消除混乱</h1>
<blockquote>原文：<a href="https://medium.com/codex/unity3d-eliminating-clutter-when-instantiating-many-objects-db79c31a0305?source=collection_archive---------14-----------------------#2021-04-03">https://medium.com/codex/unity3d-eliminating-clutter-when-instantiating-many-objects-db79c31a0305?source=collection_archive---------14-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9f9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时我们需要在查看层次面板时消除混乱并保持简单。这样，我们可以在游戏模式下保持环境整洁。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/429ccd77942c4af8f30112606a95dd0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*HfGacKpC_tT5OA0EIGTiPQ.gif"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">让敌人在未被消灭时繁殖和回收会造成混乱。</figcaption></figure><p id="ffba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">目标是在容器中繁殖敌人，并作为父对象的子对象。</p><p id="f7a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在Spawn Manager游戏对象下创建一个新的子对象。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/3ee6e491fcdccda2d4e7d19bacbaea94.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*Ir9TsSdM9M-l7gQZgTph6w.gif"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">在Spawn Manager中创建一个子对象，其中已定义对象的所有实例都将实例化为。</figcaption></figure><p id="9f1d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Spawn Manager附带了一个脚本，该脚本具有实例化敌人的逻辑。</p><p id="9396" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要存储这个子游戏对象(敌人容器)所在位置的引用。所以我们必须初始化并声明一个类型为<code class="du jp jq jr js b">GameObject</code>的对象。</p><p id="1427" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jp jq jr js b">private GameObject _enemyContainer = null;</code></p><p id="1a48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们添加一个[SerializeField]属性，以便我们可以在检查器面板中看到它。</p><p id="41f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jp jq jr js b">[SerializeField] private GameObject _enemyContainer = null;</code></p><p id="ac62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将敌人容器对象拖放到检查器中的敌人容器字段中，当选择Spawn Manager游戏对象时可以看到该字段。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jt"><img src="../Images/226a4644cdbd88012dbd01389917a184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fB1eZt8-lAUSa9F52s_dxw.gif"/></div></div></figure><p id="529d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们需要缓存实例化敌人对象的位置。所谓缓存，我的意思是将它存储到一个变量中，以便我们可以在其他地方使用它。在我的例子中，我的实例化逻辑在一个名为“SpawnRoutine”的协程中</p><pre class="je jf jg jh fd jy js jz ka aw kb bi"><span id="2d89" class="kc kd hi js b fi ke kf l kg kh"> private IEnumerator SpawnRoutine()<br/> {<br/>   while (!_stopSpawning)<br/>   {<br/>     float randomX = Random.Range(-11, 11);<br/>     Vector3 randomXposition = new Vector3(randomX, 8, 0);</span><span id="567c" class="kc kd hi js b fi ki kf l kg kh">     <strong class="js hj">Instantiate(_enemyPrefab, randomXposition,Quaternion.identity);</strong></span><span id="bebb" class="kc kd hi js b fi ki kf l kg kh">     yield return new WaitForSeconds(_waitTime);<br/>   }<br/> }</span></pre><p id="ba5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了缓存正在被实例化的敌人的实例，我们需要分配一个名为<code class="du jp jq jr js b">enemyInstance</code>的<code class="du jp jq jr js b">GameObject</code>数据类型。</p><pre class="je jf jg jh fd jy js jz ka aw kb bi"><span id="5ab1" class="kc kd hi js b fi ke kf l kg kh">GameObject enemyInstance = Instantiate(_enemyPrefab, randomXposition, Quaternion.identity);</span></pre><p id="16c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经将实例化的敌人存储在了<code class="du jp jq jr js b">enemyInstance</code>变量中。我们将在下一行代码中使用它。</p><p id="2ed6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们希望将我们的敌人实例实例化为敌人容器游戏对象的子对象。我们有一个名为_enemyContainer的敌方容器的引用，我们在前面将游戏对象附加到了检查器中的字段。</p><p id="1f94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们需要获取<code class="du jp jq jr js b">enemyInstance </code>及其转换父对象，并将其分配给<code class="du jp jq jr js b">_enemyContainer</code>的转换。</p><p id="6937" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jp jq jr js b">enemyInstance.transform.parent = _enemyContainer.transform;</code></p><p id="2ffc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在这行代码中所说的是:</p><blockquote class="kj kk kl"><p id="e869" class="if ig km ih b ii ij ik il im in io ip kn ir is it ko iv iw ix kp iz ja jb jc hb bi translated">嘿，<code class="du jp jq jr js b">enemyInstance</code>，我要你移动到<code class="du jp jq jr js b">_enemyContainer</code>的变形位置。</p></blockquote><p id="b405" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">记住，每个游戏对象都有一个变换组件，每个变换组件都是一个游戏对象。</strong>通过抓取<code class="du jp jq jr js b">_enemyContainer</code>的变形，我们暗示我们希望<code class="du jp jq jr js b">enemyInstance</code>重新定位到<code class="du jp jq jr js b">_enemyContainer</code>游戏对象中。</p><p id="c4c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们在游戏模式下，我们现在可以看到我们的层次窗口整洁干净！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/44a683a342f08f7fa2e8c5b810d464e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*er5B0jwv8Rkub1BGbfEWOw.gif"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">整洁干净。层级更快乐，作为程序员的你也更快乐！</figcaption></figure><p id="35d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天到此为止！谢谢你的时间。:)</p></div></div>    
</body>
</html>