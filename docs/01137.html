<html>
<head>
<title>The basics of abstract classes in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中抽象类的基础</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-basics-of-abstract-classes-in-scala-5b8dff15ca3a?source=collection_archive---------10-----------------------#2021-04-06">https://medium.com/codex/the-basics-of-abstract-classes-in-scala-5b8dff15ca3a?source=collection_archive---------10-----------------------#2021-04-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9e371185e045bc28a7047e12988177da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*udqitslmbjdLcLZy"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">这种戏剧性的棋子排列在真实的国际象棋比赛中永远不会发生。费利克斯·米特迈尔在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f88f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您了解Java中的抽象类，并且对Scala语法有所了解，您可能会认为您已经知道了抽象类在Scala中是如何工作的:与Java中的非常相似，只有一些小的不同。</p><p id="fc94" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你是对的。Scala抽象类很像Java抽象类。不过，微小的差异可能偶尔会让你犯错。或者它们可能是令人愉快的惊喜。</p><p id="5729" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于本文，我将假设您确实了解Java中的抽象类，所以我不会重复Java语法，除非与Scala语法进行比较和对比。</p><p id="abbb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我还假设你首先已经知道了使用抽象类的原因，所以我也不打算赘述。</p><p id="a0e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，我可以使用银行账户:<code class="du jt ju jv jw b">Account</code>是一个抽象类，<code class="du jt ju jv jw b">CheckingAccount</code>和<code class="du jt ju jv jw b">SavingsAccount</code>是<code class="du jt ju jv jw b">Account</code>的“具体”子类。</p><p id="a27b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我认为这是一个很好的例子。但是我更喜欢不那么世俗的东西，那么，象棋怎么样？作为一个例子，象棋的唯一缺点是，不是每个阅读这篇文章的人都知道如何玩。我不打算在国际象棋上做太深入的探讨，我会尝试解释所有可能不明显的事情。</p><p id="9bd8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你有一个8乘8的棋盘，两边各有16个棋子。游戏的目标是困住对手的国王，同时保证自己的国王安全。你所有的其他棋子都是可牺牲的，但是比你的对手有更多的棋子通常会有所帮助。</p><p id="14fc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每个棋子都有自己的起始位置和在棋盘上移动的方式。但是不同的部分肯定有足够的共同点，为它们创建一个抽象超类可能是值得的。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="0da8" class="kf kg hi jw b fi kh ki l kj kk">package chess</span><span id="f691" class="kf kg hi jw b fi kl ki l kj kk">abstract class ChessPiece</span></pre><p id="142f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第一行末尾添加一个分号，在最后一行末尾添加一对花括号，这样Java编译器就不会有问题了。</p><p id="b880" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是请注意，在Java上下文中，如果<code class="du jt ju jv jw b">ChessPiece</code>没有被显式标记为public，那么它在<code class="du jt ju jv jw b">chess</code>包之外是不可访问的。由于大多数Java类最终都被声明为public，Martin Odersky认为public作为Scala类和特征(接口)的默认设置更有意义。</p><p id="74dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与Java一样，Scala中的抽象类可能有抽象的“方法”。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="b18a" class="kf kg hi jw b fi kh ki l kj kk">package chess</span><span id="9c99" class="kf kg hi jw b fi kl ki l kj kk">abstract class ChessPiece {</span><span id="922e" class="kf kg hi jw b fi kl ki l kj kk">  abstract def move(position: Position)</span><span id="efa0" class="kf kg hi jw b fi kl ki l kj kk">}</span></pre><p id="7b67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">move()</code>的抽象修饰语是多余的，可能会被省略，就像备受争议的分号也可以被省略一样(尽管加入分号会给出警告)。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="6394" class="kf kg hi jw b fi kh ki l kj kk">package chess</span><span id="24a6" class="kf kg hi jw b fi kl ki l kj kk">abstract class ChessPiece {</span><span id="17c0" class="kf kg hi jw b fi kl ki l kj kk">  def move(position: Position)</span><span id="dfa7" class="kf kg hi jw b fi kl ki l kj kk">}</span></pre><p id="ee16" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">ChessPiece</code>的子类，比如<code class="du jt ju jv jw b">Pawn</code>和<code class="du jt ju jv jw b">Rook</code>(看起来像塔的那个)就要定义<code class="du jt ju jv jw b">move()</code>，除非他们本身也是抽象类。</p><p id="d90a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">无论是否抽象，Java子类都不能覆盖超类的字段。当子类有一个与超类字段同名(但不一定是相同类型)的字段时，超类字段是“隐藏的”，但仍然可以访问。子类字段实际上并不覆盖超类字段。</p><p id="a423" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">字段隐藏迷惑了许多Java初学者，甚至一些专业人员。当Martin Odersky设计Scala时，他显然认为这是他不想在Scala中使用的Java特性之一。</p><p id="a397" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以在Scala中，子类字段可以覆盖超类字段，语法非常类似于覆盖超类函数和过程的语法。</p><p id="d9d2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于下一个例子，我将使用一个棋子的布尔属性<code class="du jt ju jv jw b">canJumpOver</code>。大多数棋子不能跳过任何一方的其他棋子，但骑士可以(骑士是看起来像马的棋子)。</p><p id="fa5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在游戏开始时，任一玩家可以选择让他们的一名骑士跳过己方的棋子。在游戏的后期，跳过任何一方的棋子的能力都会派上用场。</p><p id="714d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其他棋子都不能跳过其他棋子。例如，皇后能够一步就从棋盘的一边移动到另一边。但在游戏开始时，女王被前面的棋子和两边的主教和国王包围。</p><p id="04a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，<code class="du jt ju jv jw b">ChessPiece</code>声明<code class="du jt ju jv jw b">canJumpOver</code>为假是有意义的。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="b7d3" class="kf kg hi jw b fi kh ki l kj kk">package chess</span><span id="f015" class="kf kg hi jw b fi kl ki l kj kk">abstract class ChessPiece {<br/>  val canJumpOver: Boolean = false</span><span id="5414" class="kf kg hi jw b fi kl ki l kj kk">  def move(position: Position)</span><span id="ed86" class="kf kg hi jw b fi kl ki l kj kk">}</span></pre><p id="8192" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后<code class="du jt ju jv jw b">Knight</code>可以覆盖它，就像它覆盖<code class="du jt ju jv jw b">move()</code>一样。</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="0f25" class="kf kg hi jw b fi kh ki l kj kk">package chess</span><span id="c0aa" class="kf kg hi jw b fi kl ki l kj kk">class Knight extends ChessPiece {<br/>  <strong class="jw hj">override</strong> val canJumpOver: Boolean = <strong class="jw hj">true</strong></span><span id="060f" class="kf kg hi jw b fi kl ki l kj kk">  <strong class="jw hj">override</strong> def move(position: Position): Unit = {<br/>    // TODO: Figure out what this needs to do<br/>  }</span><span id="9bc8" class="kf kg hi jw b fi kl ki l kj kk">}</span></pre><p id="2243" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，我们可以这样做:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="482c" class="kf kg hi jw b fi kh ki l kj kk">package chess</span><span id="6c74" class="kf kg hi jw b fi kl ki l kj kk">abstract class ChessPiece {<br/>  val canJumpOver: Boolean</span><span id="904c" class="kf kg hi jw b fi kl ki l kj kk">  def move(position: Position)</span><span id="4a36" class="kf kg hi jw b fi kl ki l kj kk">}</span></pre><p id="026c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是那样我们就不得不在<code class="du jt ju jv jw b">Queen</code>、<code class="du jt ju jv jw b">Bishop</code>、<code class="du jt ju jv jw b">Knight</code>等等中写下<code class="du jt ju jv jw b">override val canJumpOver: Boolean = true</code>。那就不会很“干”(意思是“不要重复自己”)。</p><p id="2efd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除非这些类也是抽象类。尽管把这个特殊的罐子踢到后面真的没有多大意义。</p><p id="31f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们用Java来做这件事，我们可能应该使它成为一个布尔调用，而不是一个布尔字段，以避免字段隐藏带来的问题，例如:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="9d0c" class="kf kg hi jw b fi kh ki l kj kk">package chess;</span><span id="7b95" class="kf kg hi jw b fi kl ki l kj kk">public abstract class ChessPiece {<br/>  <br/>    <strong class="jw hj">public boolean canJumpOver() { <br/>        return true;<br/>    }</strong></span><span id="a5b9" class="kf kg hi jw b fi kl ki l kj kk">    abstract void move(Position position);</span><span id="eee1" class="kf kg hi jw b fi kl ki l kj kk">}</span></pre><p id="383f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也许Java和Scala版本的<code class="du jt ju jv jw b">ChessPiece</code>编译成相同的东西，或者几乎相同的东西。但是希望Scala版本比Java版本更直观。</p><p id="ee97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样，这些就是Scala中抽象类的基础。没什么大不了的，这是一个基于Java概念的简单概念。</p></div></div>    
</body>
</html>