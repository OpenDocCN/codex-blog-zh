<html>
<head>
<title>Build the Game of Life with React and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React和TypeScript构建生活的游戏</h1>
<blockquote>原文：<a href="https://medium.com/codex/build-the-game-of-life-with-react-and-typescript-a83cec96d18a?source=collection_archive---------18-----------------------#2021-08-19">https://medium.com/codex/build-the-game-of-life-with-react-and-typescript-a83cec96d18a?source=collection_archive---------18-----------------------#2021-08-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e18207e7b46ec113ef5ee69aaac55714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ONzW28wfuGgnj2ru.png"/></div></div></figure><p id="e3df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本教程中，我们将使用React和TypeScript开发流行的生活游戏。《生命的游戏》是已故的约翰·康威在1970年创造的。它由一个细胞网格组成，每个细胞或者是活的，或者是死的，它们按照一套规则与相邻的细胞相互作用。它更像是一个<strong class="is hj">模拟</strong>或<strong class="is hj">细胞自动化</strong>而不是一个游戏，因为它不需要用户的输入。</p><p id="5287" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我发现这是一个在React中练习一些有用概念的好项目。它相对容易构建，只需要大约150行代码就可以完成。这个项目最初是由Ben Awad <a class="ae jo" href="https://www.youtube.com/watch?v=DvVt11mPuM0" rel="noopener ugc nofollow" target="_blank">在这个视频</a>中录制的，然而，这个教程对代码库做了一些修改。</p><h1 id="7b72" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">先决条件</h1><p id="d4b0" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">本教程假设对React(包括<a class="ae jo" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子</a>)和<a class="ae jo" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">类型脚本</a>有基本的了解。</p><h1 id="e94c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">入门指南</h1><p id="efc3" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们通过在终端中运行以下命令，用TypeScript设置React项目:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="3f35" class="lb jq hi kx b fi lc ld l le lf">npx create-react-app game-of-life --template typescript</span></pre><p id="18a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您也可以在这里获取项目<a class="ae jo" href="https://github.com/toluagboola/game-of-life-starter-files" rel="noopener ugc nofollow" target="_blank">的启动文件，如果您愿意，可以按照自述文件中的说明进行操作。</a></p><h1 id="15b3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">创建网格</h1><p id="8f7d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">网格自然是由许多行和列组成的。让我们首先在<code class="du lg lh li kx b">App.tsx</code>中创建变量来跟踪这些值，包括网格本身。将网格存储在state中，以便于更新。为此，我们将使用<code class="du lg lh li kx b"><a class="ae jo" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">useState</a></code>挂钩。<code class="du lg lh li kx b">useState</code>钩子返回一个有状态值和一个更新它的函数。将这些返回值析构为如下所示的<code class="du lg lh li kx b">grid</code>和<code class="du lg lh li kx b">setGrid</code>变量。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d7f9" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>import { FC, useState } from "react";<br/><br/>const numRows = 25;<br/>const numCols = 35;<br/><br/>const App: FC = () =&gt; {<br/>  const [grid, setGrid] = useState();<br/>};</span></pre><p id="533d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，我们将组件的类型标注为<strong class="is hj">功能组件(FC) </strong>。这确保了我们函数的签名是正确的，并且它返回有效的JSX。还有，本教程的所有代码都会写在一个文件里，即<code class="du lg lh li kx b">App.tsx</code>。</p><p id="6db2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们要初始化网格。<code class="du lg lh li kx b">useState</code>接受一个参数，该参数将在第一次渲染时作为初始状态返回。创建一个返回随机活细胞和死细胞数组的函数。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="add4" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>const randomTiles: = () =&gt; {<br/>  const rows = [];<br/>  for (let i = 0; i &lt; numRows; i++) {<br/>    rows.push(Array.from(Array(numCols), () =&gt; (Math.random() &gt; 0.7 ? 1 : 0))); // returns a live cell 70% of the time<br/>  }<br/>  return rows;<br/>}<br/><br/>const App = () =&gt; {<br/>  const [grid, setGrid] = useState(() =&gt; {<br/>    return randomTiles();<br/>  });<br/>};</span></pre><p id="237f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">函数创建一个随机放置的0和1的多维数组。0表示死亡，1表示活着。数组的长度是我们之前声明的行数，其中的每个数组包含<code class="du lg lh li kx b">numCols</code>项(在本例中是35)。请注意，该类型被注释为0和1的数组。你可以在下面看到我们的网格是什么样子:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/12e67a50daea595802dad4c458f2b939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EOvntguDcD-LpFvM.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">0和1的多维数组</figcaption></figure><p id="ac56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，每当第一次呈现App组件时，初始状态将是随机单元格的网格。接下来就是展示它们。如下所示更新你的<code class="du lg lh li kx b">App.tsx</code>文件:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="9fd6" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>const App = () =&gt; {<br/>  const [grid, setGrid] = useState(() =&gt; {<br/>    return randomTiles();<br/>  });<br/><br/>  return (<br/>    &lt;div&gt;<br/>      {grid.map((rows, i) =&gt;<br/>        rows.map((col, k) =&gt; (<br/>          &lt;div<br/>            style={{<br/>              width: 20,<br/>              height: 20,<br/>              backgroundColor: grid[i][k] ? "#F68E5F" : undefined,<br/>              border: "1px solid #595959",<br/>            }}<br/>          /&gt;<br/>        ))<br/>      )}<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="46ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码在网格上迭代，网格已经初始化为<code class="du lg lh li kx b">randomTiles</code>，每次生成一个20 x 20的盒子代表一个单元格。每个细胞的背景颜色取决于它是活的还是死的。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lo"><img src="../Images/9fd029b2b04ff60bbc68aeeab7de1037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/0*PIFiii65jQmkWnEH.png"/></div></figure><p id="04e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，形成的细胞呈直线排列，如上图所示。我们需要将它们整齐地排列成网格。为了实现这一点，让我们把包装<code class="du lg lh li kx b">div</code>做成一个网格容器，样式如下:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="45fc" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>&lt;div<br/>  style={{<br/>    display: "grid",<br/>    gridTemplateColumns: `repeat(${numCols}, 20px)`,<br/>    width: "fit-content",<br/>    margin: "0 auto",<br/>  }}<br/>&gt;{...}&lt;/div&gt;</span><span id="b44f" class="lb jq hi kx b fi lp ld l le lf">//I use ... to denote code already established.</span></pre><p id="1284" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经得到了我们想要的东西，您可以用任何您想要的方式来设计页面的样式。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lq"><img src="../Images/602fdc3ed1168610e58a6b8468eed253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/0*QBJPiPFUT9iJPEvx.png"/></div></figure><h1 id="504c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">处理单元格点击</h1><p id="4ca5" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">除了随机生成的细胞状态，我们希望每个细胞都是可点击的，以使其活或死。向单元格<code class="du lg lh li kx b">div</code>添加一个事件处理程序，如下所示:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="edbd" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>return (<br/>  &lt;div<br/>    style={<br/>      {<br/>        // ...<br/>      }<br/>    }<br/>  &gt;<br/>    {grid.map((rows, i) =&gt;<br/>      rows.map((col, k) =&gt; (<br/>        &lt;div<br/>          key={`${i}-${k}`}<br/>          onClick={() =&gt; {<br/>            let newGrid = JSON.parse(JSON.stringify(grid));<br/>            newGrid[i][k] = grid[i][k] ? 0 : 1;<br/>            setGrid(newGrid);<br/>          }}<br/>          style={<br/>            {<br/>              // ...<br/>            }<br/>          }<br/>        &gt;&lt;/div&gt;<br/>      ))<br/>    )}<br/>  &lt;/div&gt;<br/>);</span></pre><p id="42ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的click事件处理程序的作用是:</p><ul class=""><li id="c771" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn lw lx ly lz bi translated">它将<code class="du lg lh li kx b">grid</code>数组克隆成<code class="du lg lh li kx b">newGrid</code>，</li><li id="3223" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">通过索引找到被点击的单元格并检查它是活的还是死的，</li><li id="657b" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">如果细胞目前是活的，它就使它死亡，反之亦然，</li><li id="a1a1" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">最后，它用修改后的<code class="du lg lh li kx b">newGrid</code>更新状态。</li></ul><p id="5782" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最佳实践是始终向React中的元素添加唯一的标识，以帮助React知道它何时发生了变化。将每个单元格的<code class="du lg lh li kx b">key</code>属性设置为其在网格中的特定位置。</p><h1 id="4987" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">运行模拟</h1><p id="ae04" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">没有细胞间的实际相互作用，就没有生命的游戏，所以让我们努力吧。让我们从在state中存储模拟的运行状态开始，与我们处理网格的方式相同，然后将其初始化为<code class="du lg lh li kx b">false</code>。让我们允许TypeScript在这里为我们推断类型，这将是<code class="du lg lh li kx b">boolean</code>。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b23a" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>const App = () =&gt; {<br/>  const [grid, setGrid] = useState(() =&gt; {<br/>    return randomTiles();<br/>  });<br/><br/>  const [running, setRunning] = useState(false);<br/><br/>  // ...<br/>};</span></pre><p id="6d2a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">默认情况下，模拟不运行。现在，让我们创建一个按钮来开始或停止模拟:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="63e2" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>&lt;button<br/>  onClick={() =&gt; {<br/>    setRunning(!running);<br/>  }}<br/>&gt;<br/>  {running ? "Stop" : "Start"}<br/>&lt;/button&gt;</span></pre><p id="607f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将按照游戏规则实现细胞与其邻居之间的互动，游戏规则包括:</p><ul class=""><li id="e76e" class="lr ls hi is b it iu ix iy jb lt jf lu jj lv jn lw lx ly lz bi translated">任何少于两个活邻居的活细胞都会死亡，就好像是由于人口减少。</li><li id="3469" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">任何有两个或三个活邻居的活细胞都会延续到下一代。</li><li id="89c4" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">任何有三个以上活邻居的活细胞都会死亡，好像是由于人口过多。</li><li id="7374" class="lr ls hi is b it ma ix mb jb mc jf md jj me jn lw lx ly lz bi translated">任何一个死细胞，只要有三个活的邻居，就会变成活细胞，就像通过繁殖一样。</li></ul><p id="63d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在App组件外创建一个<code class="du lg lh li kx b">positions</code>数组。这个数组表示一个单元周围的八个邻居，我们将在模拟中使用它们。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6c82" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>import { useState, useCallback } from "react";<br/><br/>const positions = [<br/>  [0, 1],<br/>  [0, -1],<br/>  [1, -1],<br/>  [-1, 1],<br/>  [1, 1],<br/>  [-1, -1],<br/>  [1, 0],<br/>  [-1, 0],<br/>];</span></pre><p id="4e3c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在App组件中，使用<code class="du lg lh li kx b"><a class="ae jo" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank">useCallback</a></code>钩子创建一个名为<code class="du lg lh li kx b">runSimulation</code>的函数，并将网格作为参数传递。这里使用<code class="du lg lh li kx b">useCallback</code>的原因是为了防止每次渲染App组件时都创建我们的函数。<code class="du lg lh li kx b">useCallback</code>在每次它的依赖数组改变时创建一个<strong class="is hj">记忆化的</strong>函数，这意味着该函数将只被创建一次，然后在需要时运行。在这种情况下，我们将让依赖数组为空。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e3ea" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>const App = () =&gt; {<br/>  // ...<br/>  const runningRef = useRef(running);<br/>  runningRef.current = running;<br/><br/>  const runSimulation = useCallback((grid) =&gt; {<br/>    if (!runningRef.current) {<br/>      return;<br/>    }<br/><br/>    let gridCopy = JSON.parse(JSON.stringify(grid));<br/>    for (let i = 0; i &lt; numRows; i++) {<br/>      for (let j = 0; j &lt; numCols; j++) {<br/>        let neighbors = 0;<br/><br/>        positions.forEach(([x, y]) =&gt; {<br/>          const newI = i + x;<br/>          const newJ = j + y;<br/><br/>          if (newI &gt;= 0 &amp;&amp; newI &lt; numRows &amp;&amp; newJ &gt;= 0 &amp;&amp; newJ &lt; numCols) {<br/>            neighbors += grid[newI][newJ];<br/>          }<br/>        });<br/><br/>        if (neighbors &lt; 2 || neighbors &gt; 3) {<br/>          gridCopy[i][j] = 0;<br/>        } else if (grid[i][j] === 0 &amp;&amp; neighbors === 3) {<br/>          gridCopy[i][j] = 1;<br/>        }<br/>      }<br/>    }<br/><br/>    setGrid(gridCopy);<br/>  }, []);<br/><br/>  // ...<br/>};</span></pre><p id="7421" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们创建了一次<code class="du lg lh li kx b">runSimulation</code>,但是我们一直想要当前的<code class="du lg lh li kx b">running</code>值，函数不会一直为我们更新这个值。为了解决这个问题，让我们使用<code class="du lg lh li kx b"><a class="ae jo" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank">useRef</a></code>钩子创建一个<code class="du lg lh li kx b">runningRef</code>变量，并将其初始化为<code class="du lg lh li kx b">running</code>状态的当前值。这样，运行状态在我们的模拟中总是最新的，因为它存储在ref中。每当<code class="du lg lh li kx b">runningRef</code>的<code class="du lg lh li kx b">.current</code>属性为假时，该函数将停止，否则它将按照游戏规则继续工作。</p><p id="b9b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，<code class="du lg lh li kx b">runSimulation</code>克隆网格，遍历网格中的每个单元，并通过迭代<code class="du lg lh li kx b">positions</code>数组来计算每个单元的活邻居。然后，它检查以确保我们没有越界，并且在网格的行和列内。如果满足该条件，它将增加相关单元的活邻居的数量。对于每个单元，<code class="du lg lh li kx b">forEach</code>循环将运行8次。</p><p id="f051" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，它执行规则。如果细胞的活细胞数<code class="du lg lh li kx b">neighbors</code>小于2或大于3，则细胞死亡。否则，如果该细胞死亡，并且它正好有3个邻居，则该细胞存活并进行下一代。覆盖所有单元格后，它用<code class="du lg lh li kx b">gridCopy</code>更新网格状态。</p><h1 id="2011" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">一个非常有用的自定义钩子</h1><p id="5a58" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">为了使模拟连续进行，我们需要一个函数在指定的时间间隔后运行它。让我们在单击开始按钮时触发<code class="du lg lh li kx b">setInterval</code>方法:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d382" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>&lt;button<br/>  onClick={() =&gt; {<br/>    setRunning(!running);<br/>    if (!running) {<br/>      runningRef.current = true;<br/>    }<br/>    setInterval(() =&gt; {<br/>      runSimulation(grid);<br/>    }, 1000);<br/>  }}<br/>&gt;<br/>  {running ? "Stop" : "Start"}<br/>&lt;/button&gt;</span></pre><p id="9fac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">click事件处理程序将运行状态更新为它的对立面，但如果是false，它会将ref更改为true，并每秒调用一次<code class="du lg lh li kx b">runSimulation</code>。如果您在浏览器中运行此程序，您将会看到模拟没有正常运行。它似乎陷入了两代或三代人之间的循环。这是由于React编程模型和<code class="du lg lh li kx b">setInterval</code>之间的不匹配，你可以在这里阅读更多关于<a class="ae jo" href="https://overreacted.io/making-setinterval-declarative-with-react-hooks/" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/7fd518da1e8df6a4ae7a00beaaf5bc33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/0*EzUOOTAt5Ius3oYF.gif"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">setInterval引起的bug</figcaption></figure><p id="b03f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在研究这个问题的解决方案时，我发现了这个由Dan Abramov编写的名为<code class="du lg lh li kx b">useInterval</code>的<a class="ae jo" href="https://usehooks-typescript.com/react-hook/use-interval" rel="noopener ugc nofollow" target="_blank">定制钩子</a>。在您的项目目录中创建一个名为<code class="du lg lh li kx b">useInterval.tsx</code>的文件，并将以下代码粘贴到其中:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="14a1" class="lb jq hi kx b fi lc ld l le lf">// useInterval.tsx<br/>import { useEffect, useRef } from "react";<br/><br/>function useInterval(callback: () =&gt; void, delay: number | null) {<br/>  const savedCallback = useRef(callback);<br/><br/>  // Remember the latest callback if it changes.<br/>  useEffect(() =&gt; {<br/>    savedCallback.current = callback;<br/>  }, [callback]);<br/><br/>  // Set up the interval.<br/>  useEffect(() =&gt; {<br/>    // Don't schedule if no delay is specified.<br/>    if (delay === null) {<br/>      return;<br/>    }<br/><br/>    const id = setInterval(() =&gt; savedCallback.current(), delay);<br/><br/>    return () =&gt; clearInterval(id);<br/>  }, [delay]);<br/>}<br/><br/>export default useInterval;</span></pre><p id="8218" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将挂钩导入到App组件中，并按如下方式使用它:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="43f4" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>import useInterval from "./useInterval";<br/><br/>// Put this right under runSimulation() inside the App function<br/>useInterval(() =&gt; {<br/>  runSimulation(grid);<br/>}, 150);</span></pre><p id="351f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个钩子的语法看起来和<code class="du lg lh li kx b">setInterval</code>一样，但是工作方式有点不同。它更像是<code class="du lg lh li kx b">setInterval</code>和<code class="du lg lh li kx b">clearInterval</code>合二为一，它的自变量是<strong class="is hj">动态</strong>。从点击处理程序中删除<code class="du lg lh li kx b">setInterval</code>函数，看着我们的应用程序平稳运行。</p><h1 id="b8ab" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">清除网格</h1><p id="8ed1" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们添加一个函数来清空所有活细胞的网格。创建一个名为<code class="du lg lh li kx b">generateEmptyGrid</code>的函数:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b8c9" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>const generateEmptyGrid = (): number[][] =&gt; {<br/>  const rows = [];<br/>  for (let i = 0; i &lt; numRows; i++) {<br/>    rows.push(Array.from(Array(numCols), () =&gt; 0));<br/>  }<br/>  return rows;<br/>};</span></pre><p id="899e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个函数看起来像<code class="du lg lh li kx b">randomTiles</code>，除了它返回一个只包含零的多维数组。创建一个按钮，用新的死单元数组更新状态:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e334" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>&lt;button<br/>  onClick={() =&gt; {<br/>    setGrid(generateEmptyGrid());<br/>  }}<br/>&gt;<br/>  Clear board<br/>&lt;/button&gt;</span></pre><p id="9ad9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当您检查浏览器时，应该会看到如下所示的错误:</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/9fee0b87cfd0b43a74d8895cec263d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1JeNnuZqvTrgaia-.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">浏览器中引发的类型错误</figcaption></figure><p id="7339" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是因为TypeScript的工作方式。当你初始化一个变量时，如果你不明确地注释它，类型脚本<strong class="is hj">尽可能精确地推断出它的类型。在我们的例子中，当我们声明<code class="du lg lh li kx b">grid</code>状态时，我们将其初始化为<code class="du lg lh li kx b">randomTiles</code>。因为我们没有注释<code class="du lg lh li kx b">randomTiles</code>的类型，所以它的类型被推断为<code class="du lg lh li kx b">() =&gt; (0 | 1)[][]</code>，也就是只返回零和一的函数。</strong></p><p id="398b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，<code class="du lg lh li kx b">generateEmptyGrid</code>的类型被推断为<code class="du lg lh li kx b">() =&gt; number[][]</code>，不可赋给<code class="du lg lh li kx b">() =&gt; (0 | 1)[][]</code>。这就是上面显示我们的代码无法编译的错误背后的原因。对于我们的应用程序来说，类型必须兼容。让我们注释它们的类型，使它们是相同的:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e4dc" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>const generateEmptyGrid = (): number[][] =&gt; {<br/>  const rows = [];<br/>  for (let i = 0; i &lt; numRows; i++) {<br/>    rows.push(Array.from(Array(numCols), () =&gt; 0));<br/>  }<br/>  return rows;<br/>};<br/><br/>const randomTiles = (): number[][] =&gt; {<br/>  const rows = [];<br/>  for (let i = 0; i &lt; numRows; i++) {<br/>    rows.push(Array.from(Array(numCols), () =&gt; (Math.random() &gt; 0.7 ? 1 : 0)));<br/>  }<br/>  return rows;<br/>};</span></pre><p id="df61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然它们都是包含数字的多维数组，并且可以相互赋值，我们的<strong class="is hj"> Clear </strong>按钮应该可以正常工作。如果用户愿意，让我们添加另一个按钮来再次随机化瓷砖。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="3dbd" class="lb jq hi kx b fi lc ld l le lf">// App.tsx<br/>&lt;button<br/>  onClick={() =&gt; {<br/>    setGrid(randomTiles());<br/>  }}<br/>&gt;<br/>  Random<br/>&lt;/button&gt;</span></pre><p id="d114" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个点击处理程序只是用我们之前声明的返回随机放置的0和1的<code class="du lg lh li kx b">randomTiles</code>函数来更新状态。</p><h1 id="a807" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="442a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在本教程中，我们已经使用React和TypeScript成功构建了康威的《生活的游戏》。我们介绍了如何使用一些React钩子，包括<code class="du lg lh li kx b">useState</code>、<code class="du lg lh li kx b">useCallback</code>和<code class="du lg lh li kx b">useRef</code>。我们看到了React和<code class="du lg lh li kx b">setInterval</code>如何不能很好地一起工作，并用一个自定义挂钩修复了这个问题。我们还讨论了TypeScript如何在没有注释的情况下推断类型，类型不匹配如何导致我们的代码无法编译，以及如何解决这个问题。</p><p id="7a10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个项目的完整代码可以在GitHub库中找到。我希望你已经从这篇文章中获得了一些价值。我们将在评论中感谢您的反馈。</p><p id="1cc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>