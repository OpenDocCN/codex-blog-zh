<html>
<head>
<title>Understanding SwiftUI Property Wrappers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解SwiftUI属性包装</h1>
<blockquote>原文：<a href="https://medium.com/codex/understanding-swiftui-property-wrappers-f9b75b4790a8?source=collection_archive---------12-----------------------#2021-04-01">https://medium.com/codex/understanding-swiftui-property-wrappers-f9b75b4790a8?source=collection_archive---------12-----------------------#2021-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/36eed7eaa2ac7e368013fbc2b64186cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62-vUQFkHE3vPL8k7LgIhA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">萨姆·穆卡达姆在<a class="ae iu" href="https://unsplash.com/s/photos/head-spin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b179" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你是SwiftUI的新手，你可能会大吃一惊。这是一个全新的世界！虽然设置UI相当简单，也很容易实现，但是当您试图在视图之间共享数据时，就会停下来挠头。</p><p id="907b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有IBActions或IBOutlets，没有故事板来控制从一个片段到另一个片段的拖动，prepareForSegue和performSegue方法不再是一个东西。那怎么办呢？别担心，苹果已经开发出一些方便的属性包装器来满足你的所有需求。</p><p id="64dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么这些属性包装器是什么，它们做什么？</p><p id="e3f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将讨论用于存储临时数据的内存:</p><p id="64db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">@State、@Binding、@StateObject、@ObservedObject、@Published和@EnvironmentObject。</p><p id="5a4f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我不得不说，当我第一次被介绍到这些的时候，我的头有点晕。我一直跟着教程走，这有点道理，但当我去构建自己的应用程序时，我不太确定什么时候用什么。希望这个概述将帮助您区分何时使用每个属性包装器。</p><p id="6638" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">先说<strong class="ix hj">@状态</strong>。</p><p id="b083" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">**苹果实际上说它应该写成<strong class="ix hj"> @State private </strong>，因为它只能在那个视图中使用。</p><p id="d3d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您将希望使用<strong class="ix hj"> @State </strong>来存储视图本地使用的值类型。当视图中的属性将发生变化时，您将需要使用它。</p><p id="958c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">等一下…💡你可能会对自己说，SwiftUI中的视图是结构，这意味着它们是不可变的，你不能改变它们的属性。这就是为什么苹果公司创建了<strong class="ix hj"> @State </strong>属性包装器，以允许我们修改结构中的值。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="9c56" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将我们带到<strong class="ix hj"> @Binding </strong>属性包装器。与<strong class="ix hj"> @State </strong>齐头并进。</p><p id="0d27" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里是苹果的定义:<strong class="ix hj"><em class="ka">@ Binding</em></strong><em class="ka">是一个属性包装器类型，可以读写一个真实来源所拥有的值。使用绑定在存储数据的属性和显示并更改数据的视图之间创建双向连接。绑定将属性连接到其他地方的真实源，而不是直接存储数据。</em></p><p id="c658" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ka">例如，在播放和暂停之间切换的按钮可以使用绑定属性包装器创建到其父视图的属性的绑定。</em></p><figure class="kc kd ke kf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kb"><img src="../Images/6dcf3bc5eee6c68e4c78359544511ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LCrVP69m35xE2EvT4PTyMQ.png"/></div></div></figure><figure class="kc kd ke kf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es et"><img src="../Images/5cb14ca6dcc5d05596788ff62e91fa8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbNb_QJuVJhOEJEt4GS-pw.png"/></div></div></figure><p id="44db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">每当用户点击播放按钮时，PlayerView将更新正在播放的状态。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="4ad3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，当谈到跨许多视图共享数据时，苹果给了我们一些属性包装器来使用。</p><p id="47cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">先说<strong class="ix hj"> @StateObject </strong>和<strong class="ix hj"> @ObservedObject </strong>，两者都有很多相似的功能但是用途不同。</p><p id="bf41" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简而言之，<strong class="ix hj"> @StateObject </strong>应该用于初始化对象，而<strong class="ix hj"> @ObservedObject </strong>则用于从先前的视图中传递对象。它依赖于来自父视图的数据。</p><p id="353e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个帮助你记住区别的小提示，每当你看到<strong class="ix hj"> @State </strong>或者<strong class="ix hj"> @StateObject </strong>，就意味着当前视图拥有这个数据。永远不要使用<strong class="ix hj"> @ObservedObject </strong>来创建你的对象的实例，这就是<strong class="ix hj"> @StateObject </strong>的用途。<strong class="ix hj"> @ObservedObject </strong>用于当您从另一个视图传递数据，并且您需要来自那个视图的数据时。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="708a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来我们有了<strong class="ix hj"> @EnvironmentObject </strong>属性包装器，它允许我们在任何需要的地方共享模型数据，同时也确保我们的视图在数据改变时自动保持更新。</p><p id="1c6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用<strong class="ix hj"> @ObservedObject </strong>你必须将它从一个视图传递到下一个视图，才能访问它，比如说，两个视图。有了<strong class="ix hj"> @EnvironmentObject </strong>，所有的视图都会自动访问它。</p><p id="8c10" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样像<strong class="ix hj"> @ObservedObject </strong>一样，您永远不会给<strong class="ix hj"> @EnvironmentObject </strong>属性赋值。该值应该从其他地方传入，很可能是由某个地方的<strong class="ix hj"> @StateObject </strong>创建的。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="ee6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很重要的一点要注意:<strong class="ix hj"> @StateObject </strong>、<strong class="ix hj"> @ObservedObject </strong>、<strong class="ix hj"> @EnvironmentObject </strong>必须引用符合<strong class="ix hj"> ObservableObject </strong>协议的类。</p><p id="37bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> ObservableObject </strong>是一个方便的协议，它将类实例转化为发布者，发布者可以向订阅它们的任何人发送值。为此，必须使用<strong class="ix hj"> @Published </strong>属性包装器声明类中的属性。</p><p id="823d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> @Published </strong>属性包装器向SwiftUI广播更改已经发生，它应该触发视图重载。与必须告诉tableview重新加载的时代相比，这无疑是一次升级。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="9abf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快速回顾一下，尽量让它保持清晰:记住，无论何时看到State，不管它是<strong class="ix hj"> @State </strong>还是<strong class="ix hj"> @StateObject </strong>，它都是用来在内存中保存状态的。</p><p id="7fb2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于在本地创建和管理的简单值类型数据，使用<strong class="ix hj"> @State </strong>。<strong class="ix hj"> @Binding </strong>指的是在不同视图上拥有的值类型数据，在本地改变绑定也会改变远程数据。</p><p id="de88" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> @StateObject </strong>用于在本地创建和管理引用类型数据，并且可以使用<strong class="ix hj"> @ObservedObject </strong>在其他视图之间共享。但是不要忘记，为了更新你的视图，你需要设置你的类来符合<strong class="ix hj"> ObservableObject </strong>协议，并且你需要设置你的属性为<strong class="ix hj"> @Published </strong>，这样当有变化时它们会广播，这样视图就可以刷新。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="88ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这只是属性包装器的冰山一角。我们只触及了其中六个的表面。查看Paul Hudson的这篇<a class="ae iu" href="https://www.hackingwithswift.com/quick-start/swiftui/all-swiftui-property-wrappers-explained-and-compared" rel="noopener ugc nofollow" target="_blank">好文章</a>，它讨论了iOS 14中目前可用的所有17个属性包装器。</p><p id="1edb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">编码快乐！</p></div></div>    
</body>
</html>