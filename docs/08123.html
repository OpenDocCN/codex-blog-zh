<html>
<head>
<title>Google sign-in REST API with python-social-auth and Django REST Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用python-social-auth和Django REST框架的Google登录REST API</h1>
<blockquote>原文：<a href="https://medium.com/codex/google-sign-in-rest-api-with-python-social-auth-and-django-rest-framework-4d087cd6d47f?source=collection_archive---------0-----------------------#2022-07-19">https://medium.com/codex/google-sign-in-rest-api-with-python-social-auth-and-django-rest-framework-4d087cd6d47f?source=collection_archive---------0-----------------------#2022-07-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a370" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为在你的前端或移动应用程序中注册了谷歌、脸书或其他第三方OAuth提供商的用户验证你的Django后端。</p><p id="2ab9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="jd">TL；DR:这个项目的GitHub repo可以在这里找到</em></strong><a class="ae je" href="https://github.com/florianabel/social-auth-example-django" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="jd"/></strong></a><strong class="ih hj"><em class="jd">。</em>T13】</strong></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/4d0cb67b61b1982f139f6a6e7990c87f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PWpVGpK2GzmMJwLd"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx translated"><a class="ae je" href="https://unsplash.com/@impelling?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ed Hardie </a>在<a class="ae je" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="988d" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="0b82" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">在本文中，您将为社交认证构建REST API端点。它们可以和一个单独的前端一起使用，就像一个单页或移动应用程序。我们将使用<a class="ae je" href="https://python-social-auth.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> python-social-auth </a>和<a class="ae je" href="https://www.django-rest-framework.org/" rel="noopener ugc nofollow" target="_blank">Django REST Framework</a>(DRF)来交换由第三方OAuth提供者(GoogleOAuth2)获得的访问令牌和来自DRF的认证令牌。</p><p id="4ded" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">注意:在这个例子中，我们将只使用API端点，不使用Djangos的内置模板语言。</em></p><h2 id="524c" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">认证过程</h2><p id="4ae3" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">OAuth2身份验证提供了不同的流程，这取决于您的应用程序所使用的特定设置。Aaron Parecki 和Auth0 的两篇文章很好地涵盖了基础知识以及为您的项目选择哪个流程。</p><p id="39b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本例中，我们使用<a class="ae je" href="https://oauth.net/2/pkce/" rel="noopener ugc nofollow" target="_blank">带有代码交换证明密钥的授权代码流(PKCE) </a>，这是公共客户端(如单页面和移动应用程序)向OAuth2提供者请求访问令牌时的推荐方式。与提供商的身份验证过程发生在客户端，在成功的身份验证之后，客户端将收到的访问令牌与来自后端的另一个身份验证令牌进行交换。有了这个令牌，客户机就可以通过身份验证，使用后端提供的API。</p><p id="f152" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于这个流程的更多细节在这篇<a class="ae je" href="https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-proof-key-for-code-exchange-pkce" rel="noopener ugc nofollow" target="_blank"> Auth0文章</a>中有很好的解释。我们的例外是，我们直接连接到GoogleOAuth2，而不是Auth0。</p><p id="cd2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">这是适合我的社交认证包吗？<br/> </em> </strong> <em class="jd">注意:如果您不确定这是否是您的用例的最佳包，您可以在</em> <a class="ae je" rel="noopener" href="/codex/django-allauth-vs-dj-rest-auth-vs-python-social-auth-vs-drf-social-oauth2-ef7d50f92d16"> <em class="jd">这篇文章</em> </a> <em class="jd">中找到Django的四个流行的社会认证包的简要比较。</em></p><h1 id="b67e" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">先决条件</h1><h2 id="43fc" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">姜戈</h2><p id="c83e" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">在我们开始之前，我要求你安装和设置你的Django项目。如果您不确定如何操作，请查看'<a class="ae je" href="https://www.djangoproject.com/start/" rel="noopener ugc nofollow" target="_blank">Django</a>入门'文档。</p><h2 id="c9a4" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">Django REST框架</h2><p id="a132" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">我们正在使用<a class="ae je" href="https://www.django-rest-framework.org/" rel="noopener ugc nofollow" target="_blank">Django REST Framework</a>(DRF)来设置REST API端点，建议对它有一个基本的了解。这篇文章的范围不会涵盖太多关于DRF本身的内容，但是，在它的“<a class="ae je" href="https://www.django-rest-framework.org/tutorial/quickstart/#quickstart" rel="noopener ugc nofollow" target="_blank">快速入门</a>”教程中提供的信息足够让你在这里继续学习下去了。</p><h2 id="0084" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">获取访问令牌</h2><p id="d19a" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">为了测试您的应用程序，您将需要一个GoogleOAuth2访问令牌。这通常由您的前端获得，如单页或移动应用程序。出于开发目的，您也可以使用web浏览器和curl来完成，如这里的<a class="ae je" rel="noopener" href="/codex/manually-obtain-googleoauth2-access-token-with-your-web-browser-and-curl-fd93effe15ff">所述</a>。</p><p id="8e29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">注意:当向客户端发送OAuth请求时，确保请求所需的范围，以充分填充您的用户模型。<br/>对于GoogleOAuth2来说就是:</em> <code class="du lm ln lo lp b"><em class="jd">scope = ['email', 'profile']</em></code> <em class="jd">。</em></p><h1 id="a40a" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">入门指南</h1><p id="d7c6" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">假设您已经建立了您的Django项目，并且已经应用了您的初始迁移，让我们从添加一个名为<code class="du lm ln lo lp b">users</code>的新应用程序开始。在那里，我们正在构建我们的身份验证逻辑:</p><pre class="jg jh ji jj fd lq lp lr ls aw lt bi"><span id="04f5" class="ky jw hi lp b fi lu lv l lw lx">python manage.py startapp users</span></pre><p id="6630" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们安装所需的第三方软件包。</p><pre class="jg jh ji jj fd lq lp lr ls aw lt bi"><span id="2bf3" class="ky jw hi lp b fi lu lv l lw lx">pip install django \</span><span id="f6bb" class="ky jw hi lp b fi ly lv l lw lx">djangorestframework \</span><span id="1727" class="ky jw hi lp b fi ly lv l lw lx">social-auth-core \</span><span id="685f" class="ky jw hi lp b fi ly lv l lw lx">social-auth-app-django</span></pre><p id="0209" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装后，我们在设置中注册用户和外部应用程序。py:</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="d5e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们运行<a class="ae je" href="https://www.django-rest-framework.org/" rel="noopener ugc nofollow" target="_blank"> DRF </a>和<a class="ae je" href="https://python-social-auth.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> python-social-auth </a>带来的迁移。</p><pre class="jg jh ji jj fd lq lp lr ls aw lt bi"><span id="4a43" class="ky jw hi lp b fi lu lv l lw lx">python manage.py migrate</span></pre><p id="2c9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">对于PostgreSQL用户:</em> </strong> <em class="jd"> <br/>在这个例子中，我们使用的是SQLite3数据库，Django默认使用这个数据库。如果您正在使用PostgreSQL数据库，建议使用内置的JSONB字段来存储提取的</em> <code class="du lm ln lo lp b"><em class="jd">extra_data</em></code> <em class="jd">，方法是将这一行添加到您的settings.py: </em> <code class="du lm ln lo lp b">SOCIAL_AUTH_JSONFIELD_ENABLED = True</code></p><p id="5962" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">针对MongoEngineORM用户:</em> </strong> <em class="jd"> <br/>如果你使用的是</em><a class="ae je" href="http://mongoengine.org/" rel="noopener ugc nofollow" target="_blank"><em class="jd">MongoEngine</em></a><em class="jd">ORM，安装设置略有不同。请查看</em><a class="ae je" href="https://python-social-auth.readthedocs.io/en/latest/configuration/django.html" rel="noopener ugc nofollow" target="_blank"><em class="jd">python-social-auth</em></a><em class="jd">的官方文档。</em></p><h1 id="1dad" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">配置</h1><h2 id="e390" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">来自DRF的基于令牌的身份验证和权限类</h2><p id="7a77" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">对于DRF，我们正在我们的<code class="du lm ln lo lp b">settings.py</code>中添加一些条目来定义认证和许可类。</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="lz ma l"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">DRF的设置</figcaption></figure><p id="62d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">认证<br/> </strong>通过将<code class="du lm ln lo lp b">rest_framework.authtoken</code>添加到我们的<code class="du lm ln lo lp b">INSTALLED_APPS</code>并将<code class="du lm ln lo lp b">TokenAuthentication</code>添加到默认认证类列表，我们启用了<a class="ae je" href="https://www.django-rest-framework.org/api-guide/authentication/#tokenauthentication" rel="noopener ugc nofollow" target="_blank"> DRFs内置令牌认证</a>。它提供了一个简单的基于令牌的HTTP认证方案。</p><p id="6ca0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的示例中，我们将从前端的社交提供者那里接收到的访问令牌交换为这些toke中的一个。然后可以使用它来验证我们受保护的API端点。</p><p id="9f0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">注意:这不是一个非常安全的认证方案，仅用于演示目的。对于生产级应用程序，您需要考虑更安全的替代方案。</em>T46】</strong></p><p id="4bb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">权限<br/> </strong>默认情况下，所有API请求都需要通过该设置进行认证。稍后，我们可以在打算公开的API上改变这种行为。</p><h2 id="d171" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">身份验证后端</h2><p id="3b30" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">Django保存了一个认证后端列表，用于遍历一个认证请求。它默认为Django的基本认证后端，但可以根据需要<a class="ae je" href="https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#authentication-backends" rel="noopener ugc nofollow" target="_blank">扩展或替换</a>。在这个例子中，我们为<a class="ae je" href="https://python-social-auth.readthedocs.io/en/latest/backends/google.html#google-oauth2" rel="noopener ugc nofollow" target="_blank"> GoogleOAuth2 </a>认证添加了一个后端。你可以在这里找到python-social-auth可用选项的完整列表。</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="0e99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">注意:如果</em> <code class="du lm ln lo lp b"><em class="jd">AUTHENTICATION_BACKENDS</em></code> <em class="jd">条目不存在，必须自己创建。</em></p><h2 id="1a48" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">社交授权管道</h2><p id="9b6c" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated"><a class="ae je" href="https://python-social-auth.readthedocs.io/en/latest/pipeline.html" rel="noopener ugc nofollow" target="_blank">管道机制</a>用于处理python-social-auth中的认证、关联和断开流程。这些管道存在默认流，可以根据需要进行调整(添加自定义函数；移除默认项目)。</p><p id="d46c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以找到默认的认证管道，<a class="ae je" href="https://python-social-auth.readthedocs.io/en/latest/pipeline.html#authentication-pipeline" rel="noopener ugc nofollow" target="_blank">这里</a>。要定义自己的，可以添加到自己的<code class="du lm ln lo lp b">settings.py</code>。</p><p id="56ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">注意:在这个例子中，我们使用默认管道，没有添加我们自己的版本。但是，您可以在下面找到一个示例版本。</em></p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h2 id="af1a" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">创建API端点</h2><p id="04a7" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">我们将使用一个注册端点来注册/登录一个具有来自社交提供者(GoogleOAuth2)的访问令牌的用户。这个终点将对公众开放。此外，我们正在定义第二个端点，该端点可以与后端分发的身份验证令牌一起使用。</p><h2 id="446b" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">创建视图</h2><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h2 id="45bd" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">@psa()装饰器</h2><p id="1ba1" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated"><code class="du lm ln lo lp b">@psa()</code>装饰是我们的观点的关键部分。它将我们的视图与<a class="ae je" href="https://python-social-auth.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> python-social-auth </a>连接起来，并向请求对象添加细节。</p><ul class=""><li id="a1d9" class="mb mc hi ih b ii ij im in iq md iu me iy mf jc mg mh mi mj bi translated">社会战略(在我们的例子中，Django)</li><li id="73c8" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">要使用的社交认证后端(在我们的例子中是GoogleOAuth2)，基于我们的观点中的<code class="du lm ln lo lp b">backend</code>参数。</li><li id="1344" class="mb mc hi ih b ii mk im ml iq mm iu mn iy mo jc mg mh mi mj bi translated">提供重定向URL(在我们的例子中:无。我们在客户端执行认证)</li></ul><p id="6b4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">注:遗憾的是，@psa() decorator在</em><a class="ae je" href="https://python-social-auth.readthedocs.io/en/latest/use_cases.html?highlight=%40psa#signup-by-oauth-access-token" rel="noopener ugc nofollow" target="_blank"><em class="jd">python-social-auth</em></a><em class="jd">的官方文档中几乎没有提及，但在这个</em><a class="ae je" href="https://stackoverflow.com/questions/28626718/what-is-the-purpose-of-the-psa-decorator-and-how-do-we-use-it" rel="noopener ugc nofollow" target="_blank"><em class="jd">stack overflow post</em></a><em class="jd">中可以找到一些附加信息。</em></p><h2 id="5dc1" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">添加URL</h2><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h1 id="cb16" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">测试我们的API</h1><h2 id="f5c9" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">注册/登录用户</h2><p id="2277" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">使用从我们的客户端获得的访问令牌，我们现在可以测试我们的API:</p><pre class="jg jh ji jj fd lq lp lr ls aw lt bi"><span id="9c89" class="ky jw hi lp b fi lu lv l lw lx">curl -X POST \</span><span id="4959" class="ky jw hi lp b fi ly lv l lw lx">http://127.0.0.1/api/register-by-access-token/social/google-oauth2/ \</span><span id="e4c6" class="ky jw hi lp b fi ly lv l lw lx">-H 'Accept: application/json' \</span><span id="8210" class="ky jw hi lp b fi ly lv l lw lx">-H 'Content-Type: application/json' \</span><span id="1cfa" class="ky jw hi lp b fi ly lv l lw lx">-d '{"access_token": "&lt;GoogleOAuth2-ACCESS-TOKEN-FROM-CLIENT&gt;"}'</span></pre><p id="be99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这会产生类似于<code class="du lm ln lo lp b">{"token": "&lt;TOKEN-FROM-BACKEND"}</code>的结果。</p><h2 id="ffa9" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">测试返回的令牌</h2><p id="2fe8" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">使用从后端接收到的身份验证令牌，我们现在可以访问受保护的端点。</p><pre class="jg jh ji jj fd lq lp lr ls aw lt bi"><span id="d643" class="ky jw hi lp b fi lu lv l lw lx">curl \</span><span id="dfbd" class="ky jw hi lp b fi ly lv l lw lx">http://127.0.0.1/api/authentication-test/ \</span><span id="6f45" class="ky jw hi lp b fi ly lv l lw lx">-H 'Accept: application/json' \</span><span id="312e" class="ky jw hi lp b fi ly lv l lw lx">-H 'Content-Type: application/json' \</span><span id="c31f" class="ky jw hi lp b fi ly lv l lw lx">-H 'Authorization: Token fd4d4cca9163e5afb251f6310b9c725413979f10'</span></pre><p id="b413" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du lm ln lo lp b">{"message": "User successfully authenticated"}</code></p><h1 id="9b43" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">摘要</h1><p id="d0ee" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">现在您有了一个简单的REST API端点来创建和登录Google用户。要接收访问，只需将从前端获得的访问令牌交换为后端的身份验证令牌。要使用其他认证提供商，如脸书或Twitter，遵循相同的原则，使用不同的认证后端。</p><p id="cebb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">欢迎在评论里发表你的问题/评论或者在</strong> <a class="ae je" href="https://twitter.com/florian_abel_" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">推特</strong></a><strong class="ih hj">(</strong><a class="ae je" href="https://twitter.com/florian_abel_" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">@ Florian _ Abel _</strong></a><strong class="ih hj">)上打我。我很高兴听到你的想法、问题和经历。</strong></p></div></div>    
</body>
</html>