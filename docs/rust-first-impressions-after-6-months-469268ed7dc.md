# 生锈，第一印象

> 原文：<https://medium.com/codex/rust-first-impressions-after-6-months-469268ed7dc?source=collection_archive---------0----------------------->

![](img/a91961d2d83a6c6f00dfaa5acc1e474b.png)![](img/8f09f16d13d7fb27092963b032390665.png)

[腾雅特](https://unsplash.com/@tengyart?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

# 我有什么资格评判？

当我写这篇文章时，我已经有二十多年的 IT 和开发经验了。

经过这样一段时间，工程师/开发人员不可避免地要在不同的业务环境中使用不同的语言。

最近，我或多或少经常练习以下开发语言:C、C++、Haskell、Elixir、Dart、Scala、Go、Kotlin，当然还有 Rust。

我排除了我使用解释型语言的经验，比如 PHP、HTML / CSS、shell 脚本、Wolfram 语言或 Java 脚本，它们对我来说属于脚本工具的范畴。

在过去的 5 年里，我开发了几百个项目(从一个小型的 CLI 工具到通过 Kubernetes 插件或 BtoC 平台的政府规模的生产监控系统)，大部分都是用 Go 语言，我已经在这里表达了我的观点[。](https://bastienvigneron.medium.com/pourquoi-jutilise-go-41bba48dfe47)

大约 6 个月前，我开始对 Rust 感兴趣，主要有三个原因:

*   我最近的一个项目(医学图像处理)在 Go 中找不到合适的库
*   由于垃圾收集对性能的不可避免的影响，我对我的一个相当“内存密集型”的开发(内存数据库)感到沮丧
*   对发现和学习的永久渴望指导着我们所有人从事这项工作

# 发现过程

Rust 被认为是一门难学的语言，有着相当长的学习曲线，冒着缩短悬念的风险:这是真的。

不是因为它的语法如此奇特(那些习惯于 Python 或 Ocalm 的人不会太迷惑)，也不是因为它的表达性使它不可读(至少当你使用 Scala 时……)，而是因为它如此强大的原因:它完全没有嵌入式运行时，因此也没有垃圾收集器。

Rust 确实是开发世界中的一个异类，它是一种现代的超表达语言，但是底层的，两个通常矛盾的属性。

我们将回到这种不同寻常的定位的技术后果，但就发现过程而言，它意味着一件事:不要在没有事先研究语言的理论方面的情况下一头扎进你的第一个程序，这注定是失败的，甚至是令人厌恶的。

以 Go 为例，你可以在几天内通过[使用它](https://tour.golang.org/welcome/1)来掌握这门语言，与此不同，强烈推荐你至少阅读一本关于 Rust 的书。

参考文献是官方的“[锈书](https://doc.rust-lang.org/book/)”。

或者，或者另外，有或多或少完整的视频教程，我会建议[瑞安莱维克](https://www.youtube.com/channel/UCpeX4D-ArTrsqvhLapAHprQ)的优秀频道。

一旦你吸收了 Rust 的基本概念(所有权、借用、生存期、宏等等)，你将能够在不诅咒编译器的情况下开始，直到你厌倦它(相反，它会很快成为你最好的朋友)。

# 是什么让它如此特别？

如前所述，Rust 是软件工程领域的一个异常现象:它是一种高级的、高度表达的语言，但却是低级的。

## 说明

传统上，开发语言分为三类:

*   所谓的“系统语言”或者低级语言:C 是近 50 年来无可争议的王者。它们不是很有表现力(也就是说，你经常不得不重新发明轮子或者使用别人为你开发的库)。它们不是非常安全(稳定性和安全性完全基于被给予所有自由的开发者级别)，但是它们允许获得非常接近“金属”(例如，CPU)的二进制文件，从而允许其最佳利用(如果开发者是好的)。
*   所谓的“高级”或“表达性”语言:本质上是为了通过不同的范例(对象、函数)提高开发人员的生产力而设计的[...它们允许限制第一类固有的风险(避免堆栈溢出和其他“悬空指针”的自动内存管理)。我们可以把 Java，Scala，Kotlin，Go，C#，Swift，…他们的性能和效率(性能和资源消耗之间的比率)显然不太好，但是在一个机器的能力每 18 个月以不变的价格翻倍的世界里，没有人认为这是一个问题。](/geekculture/software-development-what-has-changed-cd901207fa0d)
*   解释或“脚本”语言:它们不产生任何编译代码，而是在执行时被动态解释。它们将开发人员的生产力轴推得更远，但代价是往往是灾难性的性能和效率水平。例如，我们可以提到 Python、Ruby、PHP、JavaScript、R、Perl。

Rust 旨在融合第一类和第二类，在某些方面，它取得了成功。

Rust 显然是一种高级语言，它没有完全包含面向对象编程的概念(这是一件好事，因为没有人再需要它了)，但像 Go 一样，它允许定义数据结构和适用于它们的方法、接口和组合。

它也不是一种纯函数式语言，但是它有它的大部分属性(默认不变性、单子、高阶函数、闭包等等)。

它嵌入了非常发达的泛型管理，使用大量的类型推理或模式匹配。

所有这些能力使它在进化等级中处于相当高的位置，并使它明显成为一种现代语言…但是…

但是，它的编译器生成的机器码至少接近硬件，并且与 C 编译器一样高效(在某些情况下甚至更高效)，没有垃圾收集，并且具有几乎从未达到过的安全级别。

Rust 本身被称为“[内存安全](https://en.wikipedia.org/wiki/Memory_safety)”(一种通常只在垃圾收集语言中发现的属性)，开发人员无需手动管理分配/解除分配。它提供了针对[并发编程](https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html)中的“竞争条件”或“死锁”的保证，所有这些都具有非常高的抽象级别，并且对性能没有任何影响(我们谈论“[零成本抽象](https://doc.rust-lang.org/stable/embedded-book/static-guarantees/zero-cost-abstractions.html)”)。

编译器足够强大，可以生成完全确定性的代码(包括内存管理)，从而消除了对运行时和运行时垃圾收集器的需求。

# 这是怎么做到的？

这个解释可以写满整本书(确实如此)，所以我会尽可能地简化和综合。

## 内存管理

不进行垃圾回收，如何做到“内存安全”？

它基于一个创新的概念:所有权管理。

几条规则由此而来:

*   一个值(即一个内存区域，无论它包含一个简单的整数还是一个更复杂的结构)都有一个所有者(即一个函数)
*   它一次只能有一个所有者
*   当执行离开所有者的范围时(即离开函数)，该值被销毁(解除分配)
*   该属性可以从一个函数转移到另一个函数(原始函数将无法访问该值)
*   一个函数可以从另一个函数“借用”对一个值的访问，而这个函数仍然是所有者(就像借一本书)
*   可以有任意多的只读借用
*   一次只能有一个读/写借用
*   读/写借用禁止任何只读借用
*   借用必须引用活动值(尚未销毁，则没有 null/nill 指针)

这组规则允许编译器以静态方式:

*   以确定何时分配以及何时释放内存，从而直接在生成的二进制文件中对其进行编码
*   为了保证没有悬空指针
*   为了保证不出现竞争情况(以不确定的顺序同时写入同一存储区)
*   为了保证没有内存溢出，引用或借用是遵循最后一个规则的智能指针

据估计，这最后一点是世界上报告的 70%到 80%的错误和安全事件(CVE)的原因。

这种机制对于新手来说显然是最令人困惑的(我没有提到随之而来的生存期的概念)。

如果开发人员和编译器顽固地拒绝遵守这些规则，就会导致他们之间史诗般的频繁争斗。

为什么它们看起来如此有意义，却如此令人困惑？因为没有其他语言强迫你跟着他们走。

*   传统的系统语言，比如 C，允许你违反它们而不受惩罚(在运行时会有可怕的后果)
*   Java 或 Go 等传统高级语言为您处理分配/释放，因此您永远不会受到它们的约束。

## 宏指令

这种编译时完全确定性的必要性带来了一个问题，它禁止(除了其他事情之外)变量函数(即函数接受未知数量的参数)。

但这是一个非常有用的函数类型，至少对于字符串格式化来说是如此。

例如，以下 Go 代码的 Rust 等价物是不可能的:

```
fmt.Printf("Hello world, my name is %s I'm %d old", "bastien", 42)
```

函数`fmt.Printf`将可变数量的参数(带有占位符的初始字符串和要使用的值)作为参数。

Go 运行时实际上会根据实际出现的参数数量生成最终代码。但是 Rust 没有运行时间。

确定性地编译与`fmt.Printf`等价的代码将意味着产生从 1 到无限个参数的无限个版本，这显然是不可能的。

解决方法是“宏观”的概念。

他们的名字后面有一个感叹号:

```
println!("Hello world, my name is {}, I'm {} old", "bastien", 42);
```

一个宏被“编译”两次。

*   第一步将根据实际使用的参数数量(这里是 3 个，通过分析参数中使用的值的类型)生成一个 Rust 代码(我们讨论 Marco 的扩展)
*   第二步将把这个 Rust 代码编译成机器码。

简单而优雅。

# 为了什么日常结果？

运行时/垃圾收集器的缺失打开了有趣的视角。

它允许使用 Rust 开发操作系统和/或嵌入式系统。

*   微软已经宣布逐步将它纳入其操作系统的核心，以取代 C 和 C++
*   Linus Torvald 已经[接受了在 Linux 内核中试验使用 Rust 的想法](https://lkml.org/lkml/2021/4/14/1023)(当你知道 Linus 在语言方面的强势地位时，这是一个很好的信号)
*   亚马逊成功地用它开发了隐藏在 AWS Lambda 后面的 T4 微虚拟化系统
*   谷歌用它来开发 Android 的可能替代品

在另一个极端，它也允许通过 [WebAssembly](https://developer.mozilla.org/fr/docs/WebAssembly) 在“前端”(我们通常遇到 JavaScript 和其他东西的地方)使用它。

因此，我们可以合理地认为，从应用范围的一端到另一端，它最终都是可用的。

这会让它成为圣杯吗？，每个开发者都向往的通用语言？

我会小心不要得出这样的结论。

一方面是因为只有时间能证明一切，另一方面是因为一切都不是那么完美。

# 弱点

## 入门成本

首先，如前所述，有一个很长的学习曲线。

这可能会让许多人失去动力，尤其是那些经验不足或刚刚“皈依”的人。

在法国和其他国家，学校(例如 42)和其他快速培训中心(例如 Le Wagon)已经兴起了几年，允许任何想培训开发人员的人这样做。

他们的目标是通过补充更多传统学校的毕业生(这是一个供不应求的领域)，来弥补市场上可用档案的缺乏。

刚毕业的学生(无论年龄大小)将倾向于专注于他们所接受的培训:web 开发、移动、AI、大数据(不，这已经过时了)。

在培训结束时投入运营(从公司的角度来看)意味着后者专注于快速产生结果的技术和方法学(解释语言、敏捷方法学……)，即使这意味着忽略信息论和计算机科学的整个部分。

然而，如果不了解冯·诺依曼的体系结构，不了解堆栈和堆之间的区别，不知道不同分配方法的成本数量级，就无法理解和欣赏 Rust。

因此，在我看来，Rust 的目标是那些经验丰富的人，他们已经对其他语言有了扎实的经验，并且已经触及了后者的极限。

我认为，掌握它所必需的认知投资不会让它取代所有其他工具。

## 阅读的困难

我把 Rust 归类为一种高度表达的语言。

因此，它允许以简洁优雅的方式实现复杂甚至复杂的问题。

但这并没有使它成为一种易读的语言。

数学的形式主义简洁优雅，但这并没有让高等数学成为大众的消遣。

一个开发人员平均花费 90%的工作时间来阅读代码(他自己的或别人的)，只有 10%的时间来编写代码。

因此，阅读和理解的速度对整体生产力至关重要，项目越重要(代码行数和参与人数)，它们就越重要。

Go 在这一领域非常出色，它非常简单(冒着有时缺乏简洁性或优雅性的风险),以至于项目的新来者很快就能理解它，并且可以快速操作。

理解可以在单行代码中链接的 Rust 函数的多重嵌套的智力机制是不同的，它从数学形式主义中汲取其哲学(函数式编程)。

读 Rust 代码永远比读 Go 代码需要更多的努力，所以问题是是否值得。

## 包装系统的力量

Rust(货物+板条箱)的包装和依赖管理系统极其强大。

将它归类为弱点似乎有些奇怪，但这种力量是有代价的。

例如，对于希望拥有私有注册中心(Crates warehouse)的公司来说，它需要比 Go 更重的基础设施(它满足于简单的源代码库(例如:Git)，通常已经部署在公司中)。

最后，和强大的系统一样，掌握它需要大量的智力投资。

## 并发编程缺乏成熟度

当谈到 Go 语言时，这是一个经常被引用作为参考的方面，因为它从一开始就被设计为可以在网络中连接的多核机器上执行。

Rust 和 Go 大约在同一年诞生，但奇怪的是，在它短暂的历史中，并发编程和异步的处理经历了许多犹豫和退缩。

如果今天事情看起来稳定了，我们就远不是简单的围棋程序了。

同样，所选择的方法是基于权力和选择的自由:例如，可以选择自己的线程管理引擎，无论是“OS 线程”还是“绿色线程”。

## 汇编的缓慢

正如你所看到的，Rust 编译器有许多工作要做，在检查所有权和借用规则、宏的扩展、泛型类型的管理或者将高级抽象转换为超优化的机器代码之间，它不是空闲的。

这在处理时间上是有回报的，Rust 在执行上很快，但在编译上肯定不行。

结果，开发人员的生产力受到了打击。

虽然实时验证工具允许限制对编译器的调用，但语言的复杂性使后者在开发周期中不可或缺。

它对代码中遇到的错误提供了非常有价值和详细的解释，有时甚至给出了解决方案。

最好有一个速度快的机器来做防锈。

# 优势

## 表演

当它的价值高于一切(操作系统、视频游戏、人工智能引擎、区块链等)时。)，上面提到的认知投资的价格显然居于第二位。

无论如何，性能(通常与效率密切相关)是要付出高昂代价的，我们要清楚的是，直到今天，没有什么比 Rust 更快了(可能除了用汇编语言编码，这是几年前废除的一种折磨形式)。

Rust 所能达到的关于性能级别的唯一选择是 C，它既没有安全性也没有表达性级别。

它只有两个优势:它的历史(可用库的数量)和市场上可用的概要文件的数量。

在这些类型的应用程序上，Rust 的未来似乎非常明朗。

## 安全性

集成到编译器中的控制机制使其对关键系统或特别暴露于安全风险的系统(加密库、身份管理系统、防火墙/网络代理等)特别有吸引力。).

当你的代码编译(最终)时，你保证它将正确执行，并且它将做你要求它做的事情(但不一定是你认为你要求它做的事情)。

运行时没有意外，没有“随机”崩溃，攻击面仅限于程序的逻辑，而不是传统的向量(内存操作)。

## 轻便

在撰写本文时，Rust 可以针对 84 种不同的目标进行编译(一对 CPU 架构和操作系统)。

因此它拥有比 Go 更便携的奢侈，它有 37 个支持的目标，即使在 Rust 中不是所有的目标都有相同的[支持水平](https://doc.rust-lang.org/rustc/platform-support.html)。

## 包装系统的力量

如前所述，在某些方面是弱项，但也是强项。

它的模块化允许令人难以置信的和强大的管理:依赖性管理、版本控制，甚至是您决定在导入库时激活或不激活的特性。

在我使用的其他语言中，我个人没有经历过这样的事情。

## 文档

Rust 有很好的文档记录，无论是语言本身(这是必要的)，它的标准库(分成几个模块)，还是一般意义上的公共可用库。

这主要是由于其自动文件生成系统(通过货物)的能力。

通过正确地注释你的代码(Markdown 格式是本地支持的)，一个真正的网站将会自动生成，不仅是在你的代码的文档上，而且是在它所有的依赖项上。

# 结论

Rust 已经成为软件开发领域的重要语言，这是无可争议的，尽管它还很年轻(大约十年)。

经过这六个月的使用和我的第一个结论性的结果，我给你我的谦虚的结论。

*   我还会继续用吗？当然可以。
*   我会用 Rust 代替 Go 吗？当然不是。

这两种技术有很强的互补性。

即使是优秀的 Rust 开发者也永远达不到优秀 Go 开发者的生产力水平。

对于高速项目，规格一天要发展几次，团队数量众多且不断变化，协作很重要，Go 对我来说仍然是无与伦比的。

对于关键的、功能复杂的项目，性能以纳秒(甚至皮秒)来衡量，Rust 是正确的解决方案，只要你接受成本。

尽管它有令人难以置信的多功能性和真正的品质，我不认为它代表圣杯，**将取代所有其他语言的通用语言**。

但在我们之间，谁还相信它？

# 进一步发展的资源

在 Rust 中有很多可以用来训练和提高的资源，你会在下面找到我选择的最有趣的(对我来说，直到现在)

## 视频:

*   https://www.youtube.com/c/RyanLevicksVideos**瑞安·莱维克**的 youtube 频道(现场编码教程)
*   **《让我们生锈吧》** youtube 频道(快捷高效的 tutos):[https://www.youtube.com/c/LetsGetRusty](https://www.youtube.com/c/LetsGetRusty)
*   道格·米尔福德的 youtube 频道(读者推荐):[https://www.youtube.com/channel/UCmBgC0JN41HjyjAXfkdkp-Q](https://www.youtube.com/channel/UCmBgC0JN41HjyjAXfkdkp-Q)

## 书籍:

*   **《铁锈编程语言》**:官方免费书([https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/))
*   **《编程 Rust，第二版》**:大概是我看过的最好的 Rust 书，很好的例子，简单的讲解，详细的描述([https://www . oreilly . com/library/view/Programming-Rust-2nd/9781492052586/](https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/))

想知道接下来会发生什么吗？[https://bastienvigneron . medium . com/rust-second-impression-6ff 6 c 26 a 95d 0](https://bastienvigneron.medium.com/rust-second-impression-6ff6c26a95d0)