<html>
<head>
<title>Why Hoisting: Javascript.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么吊装:Javascript。</h1>
<blockquote>原文：<a href="https://medium.com/codex/why-hoisting-javascript-4d7c882b1e99?source=collection_archive---------4-----------------------#2021-10-08">https://medium.com/codex/why-hoisting-javascript-4d7c882b1e99?source=collection_archive---------4-----------------------#2021-10-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3fd2ad955df26952db0104888c32b7b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p1KT2GijRoWd5ZU_mR8K-Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@hudsoncrafted" rel="noopener ugc nofollow" target="_blank">王思然·哈德森</a>T2【Unsplash】拍摄</figcaption></figure><p id="cda2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">不！没有抬起来，只有回忆。</em></p><p id="0b0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一段时间以来，我一直在研究什么是吊装，经过一些研究，我发现并不是所有关于这个特殊概念的资源都是100%清楚的。这就是为什么我花时间以一种简单易懂的方式写这篇文章。</p><p id="80aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">欢迎每个人阅读这篇文章，但是当然，你应该对Javascript的基础知识有很深的了解。好了，我们终于可以深入了解起重是怎么一回事了。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="fb10" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">大问题:什么是吊装？</h1><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/471070a877ad8bd2a10b5db85f34c07e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ge-Q-ytzAIAmjVQowdmwvQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">埃文·丹尼斯 <a class="ae iu" href="https://unsplash.com/photos/i--IN3cvEjg" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="d35f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">提升是javascript中的一种现象，函数或变量甚至在初始化之前就可以被访问或调用。</em></p><p id="a80e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们检查一下这个代码示例，这样更直观:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="bfe4" class="lj kc hi lf b fi lk ll l lm ln">getCoffee();</span><span id="d22d" class="lj kc hi lf b fi lo ll l lm ln">console.log(x)</span><span id="3d56" class="lj kc hi lf b fi lo ll l lm ln">console.log(y)<br/>var x = 'something....'</span><span id="7954" class="lj kc hi lf b fi lo ll l lm ln">function getCoffee(){<br/>console.log('get me some coffee');<br/>}<br/></span></pre></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="304b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们注意到“getCoffee”函数甚至在创建之前就被调用了，嗯，我们应该预料到一个你可能会想到的错误，但是这里发生了一些非常奇怪的事情。如果我们将下面的代码复制到我们的开发工具中，我们会发现有一些事情正在发生。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lp"><img src="../Images/53886fa8bba2b1d9af67248d7f1015a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KLl63DZSQQFI3qz2n9rBpg.png"/></div></div></figure></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="d276" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们在浏览器中运行代码时，我们会得到这个结果，我希望您关注三件事:第一个结果是从函数“getCoffee()”中得到的，未定义的结果是从控制台日志记录x中得到的，最后一个未捕获的引用错误:说y未定义是从控制台日志记录y中得到的。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="2cab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们假设我们至少理解了“getCoffee()”函数，那么从控制台日志记录x返回的undefined呢，我们为什么不也得到结果并打印出来呢？我会回答这个问题，但首先我想让你知道这是由javascript中的提升引起的，提升可以有两种形式，即:<strong class="ix hj">部分提升</strong>和<strong class="ix hj">完全提升。</strong></p><p id="b785" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">他们到底有什么区别？<strong class="ix hj">部分提升</strong>在创建阶段，将其变量的值设置为未定义。当我们检查窗口对象时，我们可以清楚地看到这一点。在下面的截图中，您应该已经看到变量<strong class="ix hj"> x </strong>被设置为未定义。它得到了分配的内存，但是没有赋值，所以它自动将这个值设置为undefined。注意，这发生在变量(var)中，但不适用于ES6变量，即let和const。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/f21b272a3ad645480557b8a37e2fa5a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95mXlMEA7kx_Ax2eWX6vSQ.png"/></div></div></figure><p id="043b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<strong class="ix hj">完全提升时，</strong>函数<strong class="ix hj"> </strong>也获得分配的内存，但其值已定义，我们返回完整的函数。当检查窗口对象时，我们还会发现函数“getCoffee”存在，它返回完整的函数，就像在我们的代码编辑器中编写的一样。花点时间看看下面的截图，更清楚地了解背景中发生的事情。</p><figure class="la lb lc ld fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/798219b96777dacc1ecfb230e9bd2d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gth_7EJouXoxcysMaNXpDg.png"/></div></div></figure><p id="5e04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Less，我忘了，你还记得抛出ReferenceError的console . log(y)error:y没有定义？我们得到这个错误是因为在我们的代码中没有名为<strong class="ix hj"> y </strong>的变量，所以我们得到一个referenceError，需要注意的是“未定义”不同于“未定义”。是的，它们是不同的，我们可以清楚地看到，“未定义”意味着变量y不存在或不存在，而未定义仅仅意味着变量存在但其值未设置。</p><p id="81e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哦天啊！那太多了，去休息一下，然后你可以继续...欢迎回来！那么幕后到底发生了什么呢？</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="0449" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">在幕后</h1><p id="1c9c" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">当提升发生时，后台有很多事情在进行，变量和函数在创建阶段获得分配的内存，对于变量，它们在函数被定义时获得一个特殊的值undefined。如果提升必须发生，javascript引擎会寻找两个特定的关键字，它们是<strong class="ix hj">变量</strong>和<strong class="ix hj">函数声明</strong>。如果这些关键字不存在，我们会得到一个referenceError。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="b110" class="lj kc hi lf b fi lk ll l lm ln">(function cook(){ <br/>  console.log('cooking....')<br/>})<br/>// if we try to call the cook() function we will get Uncaught ReferenceError: cook is not defined<br/></span></pre><p id="359e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们用一个括号把函数声明包起来，这样做是为了隐藏函数不被提升。因为Javascript引擎没有找到function关键字，所以会抛出一个错误。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h2 id="ef3d" class="lj kc hi bd kd lx ly lz kh ma mb mc kl jg md me kp jk mf mg kt jo mh mi kx mj bi translated">提升是否发生在所有功能中？</h2><p id="3a82" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">嗯，不，它不会发生，原因是这样的，在调用函数的三种不同方式中，这些不同的方式是<strong class="ix hj">函数表达式</strong>、<strong class="ix hj">函数声明</strong>和<strong class="ix hj">箭头函数</strong>，只有<strong class="ix hj">函数声明</strong>会被提升。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="4567" class="lj kc hi lf b fi lk ll l lm ln">// function expression</span><span id="5924" class="lj kc hi lf b fi lo ll l lm ln">console.log(playSong())</span><span id="67b3" class="lj kc hi lf b fi lo ll l lm ln">var playSong = function(){ console.log('playing jason derulo')}</span><span id="a307" class="lj kc hi lf b fi lo ll l lm ln">If we try to call the function we will get an error, this is because we can only call the playSong() function after its defined</span></pre><p id="5d92" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它们都被部分提升，这意味着它们没有被定义为一个值。但棘手的是，只有当我们调用console.log(playSong)和<strong class="ix hj">而不是</strong>函数时，我们才能得到这种行为</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="95ce" class="lj kc hi lf b fi lk ll l lm ln">console.log(playSong)</span><span id="11b3" class="lj kc hi lf b fi lo ll l lm ln">var playSong = function(){ console.log('playing jason derulo')}<br/>this way we can get the exact behavior as the var variable.</span></pre><p id="e863" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，对于arrow函数，我们得到了与函数表达式相同的行为。所以没必要再重复一遍。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="dafe" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">吊装是一种好的做法吗？</h1><p id="6813" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">让我们来看看这段代码</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="3e76" class="lj kc hi lf b fi lk ll l lm ln">read()</span><span id="fb09" class="lj kc hi lf b fi lo ll l lm ln">function read(){<br/> console.log('I am reading some novel')<br/>}</span><span id="1f47" class="lj kc hi lf b fi lo ll l lm ln">function read(){<br/> console.log('I am done reading the novel')<br/>}</span><span id="496c" class="lj kc hi lf b fi lo ll l lm ln">function read(){<br/> console.log('I am confused')<br/>}</span></pre><p id="0c9b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">哪个函数被返回？在javascript的执行阶段，javascript引擎从下到上读取代码，并为编写的代码分配内存，如果我们有与上面相同的函数，它将只为最后一个函数分配内存，不管它找到相同的函数多少次。这里最大的问题是除了最后一个函数之外的其他函数总是会被覆盖，这意味着我们将无法运行其他函数。写好程序的最佳实践之一是<strong class="ix hj">可预测性</strong>，当你使用提升时，你将永远无法预测你的代码。在我看来，你不应该写不可预测的程序。所以我要说避免吊装。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><h1 id="4cbb" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">总结</h1><p id="7dd3" class="pw-post-body-paragraph iv iw hi ix b iy ls ja jb jc lt je jf jg lu ji jj jk lv jm jn jo lw jq jr js hb bi translated">哇，我们终于完成了。</p><p id="d5ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们试着回顾一下我们到目前为止所学的一切，在提升过程中，内存被分配给函数或变量，它们被赋值，提升可以有完全和部分两种形式，所有在var中声明的变量都是部分提升的，而函数声明是完全提升的。javascript引擎寻找两个关键字:function和var，最后，您应该尽量避免提升，因为它会覆盖您的代码，并使您的程序难以预测。就这样，伙计们。一如既往，请随时发送您的反馈和您认为我可以改进的地方。干杯，编码快乐。</p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><blockquote class="mk ml mm"><p id="9d74" class="iv iw jt ix b iy iz ja jb jc jd je jf mn jh ji jj mo jl jm jn mp jp jq jr js hb bi translated"><em class="hi">灵感来源于Javascript:由</em> <a class="ae iu" href="https://www.linkedin.com/in/andreineagoie/" rel="noopener ugc nofollow" target="_blank"> <em class="hi">安德烈</em> </a> <em class="hi">的创始人</em> <a class="ae iu" href="https://zerotomastery.io" rel="noopener ugc nofollow" target="_blank"> <em class="hi">零到精熟</em> </a> <em class="hi">。</em></p></blockquote></div></div>    
</body>
</html>