<html>
<head>
<title>Using NextJS API Routes as a BFF</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NextJS API路由作为BFF</h1>
<blockquote>原文：<a href="https://medium.com/codex/using-nextjs-api-routes-as-a-bff-4c5065d2dbae?source=collection_archive---------4-----------------------#2022-05-07">https://medium.com/codex/using-nextjs-api-routes-as-a-bff-4c5065d2dbae?source=collection_archive---------4-----------------------#2022-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="852a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">NextJS API路由如何作为开箱即用的BFF工作</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/5479a4e50cc708d638e08f6af7f81f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lZfnsmY4fimg3Ukm"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">由<a class="ae jn" href="https://unsplash.com/@alesnesetril?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ales Nesetril </a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="c26c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是NextJS</h2><p id="8982" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">NextJS是一个非常受欢迎的React web框架，它允许开箱即用的服务器端呈现和静态站点生成，以及一套固执己见的设置和工具，如“<em class="lf"/>和“<em class="lf">动态导入”</em>。其中一个特性是“<a class="ae jn" href="https://nextjs.org/docs/api-routes/introduction" rel="noopener ugc nofollow" target="_blank"><em class="lf">API routes</em></a><em class="lf">”</em>，自动公开API文件夹下的文件作为端点。文档对该功能的描述如下:</p><pre class="iy iz ja jb fd lg lh li lj aw lk bi"><span id="342b" class="jo jp hi lh b fi ll lm l ln lo">Any file inside the folder <!-- -->pages/api<!-- --> is mapped to <!-- -->/api/*<!-- --> and will be treated as an API endpoint instead of a <!-- -->page<!-- -->. They are server-side only bundles and won't increase your client-side bundle size.</span></pre><h2 id="fe32" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是BFF架构设计模式</h2><p id="5f4a" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">BFF或“后端对前端”架构模式涉及创建一个指定的后端服务，该服务具有一个接口或一组指定给特定前端服务的契约。<a class="ae jn" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/backends-for-frontends" rel="noopener ugc nofollow" target="_blank">微软在他们的“云架构”系列</a>中对此模式有很好的描述。</p><p id="366a" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated"><a class="ae jn" href="https://samnewman.io/patterns/architectural/bff/" rel="noopener ugc nofollow" target="_blank">这有许多风格和变化，Sam Newman在他的文章《谈论模式》中概述了其中一些。出于实现的目的，我们将引用一个单独的BFF，它为NextJS前端提供了一个接口。</a></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lu"><img src="../Images/5eb6123ce808afef392bd04196902a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rfkx4boNQHcDMUiB-GJzwQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">使用NextJS的BFF模式的服务交互示例图</figcaption></figure><h2 id="c8c0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">利用API路由创建BFF</h2><p id="d1f1" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">如前所述，默认情况下，NextJS有一种自以为是的方式来创建API路由和前端代码。下面是一个NextJS如何构建其前端和API路由的例子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lv"><img src="../Images/e997fd4bef035a50d21af71ff586d0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*T-5Td_Yk7g-d7s02PFqMMQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">API路由与前端路由共存的示例</figcaption></figure><p id="9e99" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">在本例中，API路由映射如下:</p><ul class=""><li id="f6a3" class="lw lx hi ko b kp lp ks lq jz ly kd lz kh ma le mb mc md me bi translated">https://{some-host:api-port}com/users/{id}</li></ul><p id="a973" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">前端路由是这样的:</p><ul class=""><li id="d619" class="lw lx hi ko b kp lp ks lq jz ly kd lz kh ma le mb mc md me bi translated"><a class="ae jn" href="https://{some-host}.com/users/{id}" rel="noopener ugc nofollow" target="_blank">https://{ some-host:frontend-port }。com/ </a></li><li id="2e38" class="lw lx hi ko b kp mf ks mg jz mh kd mi kh mj le mb mc md me bi translated"><a class="ae jn" href="https://{some-host}.com/users/{id}" rel="noopener ugc nofollow" target="_blank">https://{ some-host:frontend-port }。com/c </a> reateTrip</li></ul><p id="b10d" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">这样，我们就能够使用某种形式的HTTP客户端(如Fetch或Axios)向BFF发出请求，在BFF中，我们将拥有执行以下任务的端点:</p><ul class=""><li id="b3d7" class="lw lx hi ko b kp lp ks lq jz ly kd lz kh ma le mb mc md me bi translated"><strong class="ko hj">数据转换:</strong>BFF可以调用一些服务，并对响应数据进行转换，使其适合前端。</li><li id="5616" class="lw lx hi ko b kp mf ks mg jz mh kd mi kh mj le mb mc md me bi translated"><strong class="ko hj">集成多个服务:</strong>BFF能够将许多不同的服务编排在一起，即使它们位于不同的服务边界内。它可以用来与Stripe或MailChimp等公共API集成，并将这些API与可能的内部服务交织在一起。</li><li id="b909" class="lw lx hi ko b kp mf ks mg jz mh kd mi kh mj le mb mc md me bi translated"><strong class="ko hj">缓存:</strong>为了防止过度调用服务，可以专门为BFF建立中间缓存，并根据前端的需求定制它们的设置。</li><li id="e814" class="lw lx hi ko b kp mf ks mg jz mh kd mi kh mj le mb mc md me bi translated"><strong class="ko hj">统一错误处理:</strong>由于BFF是前端使用的唯一接口，我们可以提供一种统一的方式来处理和形成前端将使用的错误代码，允许我们操纵或丰富服务可能返回的现有错误，使其成为前端可以轻松解析的内容。</li><li id="eab2" class="lw lx hi ko b kp mf ks mg jz mh kd mi kh mj le mb mc md me bi translated"><strong class="ko hj">认证:</strong>BFF可以提供和控制JWT令牌生命周期的端点，并进一步使用它们来保护某些API路由，还可以将令牌代理给其他服务，或者只是控制前端的认证流。</li></ul><p id="5d1f" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">虽然这些好处可以通过BFF模式单独实现，但是NextJS允许在新的或现有的项目中建立BFF的一种方便有效的方式。此外，它确实在模式之上提供了额外的好处，因为它们协同工作。</p><h2 id="c875" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">共享代码和类型</h2><p id="4f8f" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">在前端和BFF之间共享代码的好处是，您可以跨两个系统重用代码和类型。这意味着您能够在两个服务之间拥有类型安全和稳定的契约，因为BFF是前端将与之交互的唯一接口。当在两个包含某些常用类型的服务之间创建请求和响应时，这非常方便。</p><p id="24c4" class="pw-post-body-paragraph km kn hi ko b kp lp ij kr ks lq im ku jz lr kw kx kd ls kz la kh lt lc ld le hb bi translated">虽然这在服务之间引入了紧密耦合，但是由于这种模式的本质，它实际上对我们是有益的。</p><h2 id="3626" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">较少的部署</h2><p id="7212" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">由于服务共同存在于同一个NextJS代码库中，所以可以以垂直方式跨整个堆栈进行更改，并且只需要一次部署。这也减少了维护项目所需的IaaC的数量，并且应该使实施和维护CI/CD实践更加有效。</p><h2 id="1c55" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h2><p id="29b5" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">BFF模式强大而灵活。它可以被设计成几种不同的变体，并为前端开发提供一个精简和集中的接口。NextJS正在成为一个越来越受欢迎的React web框架，通过其预打包的API路由，开发人员可以轻松地为他们的前端创建和维护一个强大的BFF服务。</p></div></div>    
</body>
</html>