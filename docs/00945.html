<html>
<head>
<title>The grip on Object-Oriented Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Python中面向对象编程的掌握</h1>
<blockquote>原文：<a href="https://medium.com/codex/object-oriented-programming-concepts-in-python-45df4ceca037?source=collection_archive---------17-----------------------#2021-03-26">https://medium.com/codex/object-oriented-programming-concepts-in-python-45df4ceca037?source=collection_archive---------17-----------------------#2021-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="0b6c" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><figure class="ev ex ip iq ir is er es paragraph-image"><div class="er es io"><img src="../Images/5c67dfd4ceacabd55081f7574be613eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*U_8p8ACGqZaUCtuMYErv8g.jpeg"/></div></figure><p id="8fbd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hs">面向对象编程(OOP) </strong>就是创建<strong class="ix hs">对象</strong>，可以包含变量和函数:字段形式的<strong class="ix hs">变量</strong>(称为<strong class="ix hs">属性</strong>或特性)和过程形式的<strong class="ix hs">函数</strong>(称为<strong class="ix hs">方法</strong>)。</p><p id="b35b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简而言之，这些变量通常被称为对象的属性，而函数被称为对象的行为。</p><p id="be03" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一个例子——如果我们把一只狗看作一个物体，那么它的属性将是——它的颜色、品种、名字、体重等等。并且他的行为/功能将是行走、吠叫、玩耍等。</p><p id="a446" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，一个对象可以代表一个具有<strong class="ix hs">属性</strong>的人，如姓名、年龄、地址和行为，如走路、说话、呼吸和跑步。或者它可以表示一封电子邮件，具有像收件人列表、主题和正文这样的属性，以及像添加附件和发送这样的<strong class="ix hs">行为(或方法)</strong>。</p><p id="75a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">换句话说，面向对象编程是一种对具体的、真实世界的事物建模的方法，如汽车，以及事物之间的关系，如公司和雇员、学生和教师等等。OOP将现实世界中的实体建模为软件对象，这些对象有一些与之相关的数据，并且可以执行某些功能。</p><p id="e08e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hs">OOP的构建模块</strong>:</p><ul class=""><li id="258f" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">&gt;<strong class="ix hs">类</strong>-&gt;-<strong class="ix hs">对象</strong>-&gt;-<strong class="ix hs">方法</strong> - &gt;属性</li></ul><h1 id="e93e" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">快速导航</h1><h2 id="13d3" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated"><a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#1" rel="noopener ugc nofollow" target="_blank"> 1。类别和对象</a></h2><h2 id="f83e" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated"><a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#2" rel="noopener ugc nofollow" target="_blank"> 2。初始化方法</a></h2><h2 id="a3ea" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated"><a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#2" rel="noopener ugc nofollow" target="_blank"> 3。构造者，自身</a></h2><h2 id="bbdf" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated"><a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#5" rel="noopener ugc nofollow" target="_blank"> 4。方法的类型</a></h2><h2 id="e5e5" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated"><a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#6" rel="noopener ugc nofollow" target="_blank"> 5。继承</a></h2><h2 id="7885" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated"><a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#7" rel="noopener ugc nofollow" target="_blank"> 6。封装</a></h2><h2 id="c55e" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated">7 .<a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#8" rel="noopener ugc nofollow" target="_blank">。多态现象</a></h2><h2 id="3911" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated"><a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#9" rel="noopener ugc nofollow" target="_blank"> 8。抽象类</a></h2><h1 id="aaae" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">1.类别和对象</h1><h1 id="1d8e" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">关于类和对象的简单术语— —</h1><p id="1914" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">类是对象的集合。</p><p id="c38e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hs">类与对象:</strong> - &gt;类用于创建用户自定义的数据结构。类定义了名为<strong class="ix hs">方法</strong>的函数，这些方法标识了从类创建的对象可以用其变量执行的行为和动作。</p><p id="6d56" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类是对象的蓝图或设计。从类构建的包含真实数据的实例(对象)。</p><p id="595e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">汽车类的对象不再是一个蓝图。这是一辆真正的汽车，型号名称像“奥迪R8”，颜色是“红色”。</p><figure class="lu lv lw lx fd is er es paragraph-image"><div class="er es lt"><img src="../Images/9c963f0a45c68c208b559ee92884d924.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*oB2LrUQnB_qzTm4BZyFYbw.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated"><a class="ae ln" href="http://www.danamuise.net/blog/2016/1/12/v12kquly0pw63trxg7bg1kvr8qwguj" rel="noopener ugc nofollow" target="_blank">类和对象为汽车</a></figcaption></figure><pre class="lu lv lw lx fd mc md me mf aw mg bi"><span id="c0a4" class="la kd hi md b fi mh mi l mj mk"><em class="ml">''' </em><br/><em class="ml">    Creating a Class named "Car"</em><br/><em class="ml">    </em><br/><em class="ml">    Class Variables = 'feul_type' --Same across all car class object       </em><br/><em class="ml">    Object Variable = 'model','color','mileage'-- Different for      different car objects</em><br/><em class="ml">    Object Methods/Attributes = 'description','max_speed'</em></span><span id="9eb0" class="la kd hi md b fi mm mi l mj mk"><em class="ml">'''</em><br/>class <strong class="md hs">Car</strong>:<br/>    <br/>    'Common for all the objects of Car Class'<br/>    fuel_type = 'Petrol'       <em class="ml">## Class Attribute</em><br/>    <br/>    def __init__(self, model,color,mileage): <em class="ml">## the default method                      </em><br/>    ## called <em class="ml">automatically when the object of this calls is called.</em><br/>        <br/>        self.model_name = model <em class="ml">## object attribute</em><br/>        self.color = color     <em class="ml">## object attribute</em><br/>        self.mileage = mileage <em class="ml">## object attribute</em><br/>        print("In init method")<br/>        <br/>    <br/>    def description(self):<br/>        print("The <strong class="md hs">{}</strong> gives the mileage of <strong class="md hs">{}</strong>      kmpl".format(self.model_name,self.mileage))<br/>        <br/>    <br/>    def max_speed(self,speed):<br/>        return("The <strong class="md hs">{}</strong> runs at the maximum speed of <strong class="md hs">{}</strong>kmphr".format(self.model_name,speed))</span></pre><h1 id="f1e9" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">如何创建类对象，如何调用类的方法和变量。</h1><pre class="lu lv lw lx fd mc md me mf aw mg bi"><span id="2203" class="la kd hi md b fi mh mi l mj mk"><em class="ml">## Create an object of Class Car</em><br/>obj1 = Car("Audi A6","Red",17.01)</span><span id="45a1" class="la kd hi md b fi mm mi l mj mk"><em class="ml">## Call the methods and variables defined for this object from Car class.</em><br/>obj1.description()<br/>print(obj1.max_speed(233))<br/>print(obj1.color)</span><span id="b738" class="la kd hi md b fi mm mi l mj mk"><em class="ml">## Call the Car Class variable.</em><br/>print(Car.fuel_type)</span><span id="3cba" class="la kd hi md b fi mm mi l mj mk"><em class="ml">## Create another object of Class car.</em><br/>obj2 = Car("Audi A8","Black",19)<br/>obj2.max_speed(800)</span></pre><h2 id="0bee" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated">注意:对象/实例存储在具有不同内存地址的堆内存中。每次创建一个对象，它都会被分配到堆内存中的新空间。</h2><h1 id="c8c1" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">类构造函数</h1><p id="754a" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">类别建构函式的工作是在建立类别的物件时，将值指派给类别的资料成员。汽车可以有各种属性，如名称、颜色、型号、品牌名称、发动机功率、重量、价格等。</p><p id="ae79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">汽车或任何其他对象的属性必须在我们称为<strong class="ix hs"> init </strong>()的方法中。这个<strong class="ix hs"> init </strong>()方法也称为构造函数方法。每当构造一个类的对象时，我们就调用一个构造函数方法。</p><p id="d55a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们来谈谈<strong class="ix hs"> init </strong>()方法的参数。所以这个方法的第一个参数必须是self。那么只有剩下的参数才会出现。</p><p id="7dd1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">构造函数方法中的两条语句是–</p><p id="2905" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hs"> self.model_name = model </strong></p><p id="d376" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hs"> self.color = color </strong></p><p id="4348" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hs"> self.mileage = milegage </strong></p><p id="2ffa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将创建新的属性，即车型名称、颜色和里程，然后为它们分配相应的参数值。</p><p id="7123" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">“self”关键字表示该类的实例。通过使用“self”关键字，我们可以访问该类的属性和方法。它在方法定义和变量初始化中很有用。每当我们定义一个方法的时候,“自我”就会被明确地使用。</p><p id="276d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:您也可以在这个<strong class="ix hs"> init </strong>()方法之外创建属性。但是这些属性对整个类都是通用的，你必须给它们赋值。</p><p id="b1d3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您展厅中的所有汽车都有fuel_type“汽油”，您可以通过在<strong class="ix hs"> init </strong>()之外创建一个属性，将fuel_type的值固定为“汽油”，而不是反复指定它。</p><h1 id="e4a0" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">理解“自我”关键词</h1><p id="0e2e" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated"><strong class="ix hs">类方法</strong>与普通函数只有一个特殊的区别——它们必须有一个额外的名字，这个名字必须添加到参数列表的开头，但是在调用方法时不要给这个参数赋值，Python会提供它。这个特殊的变量指的是物体本身，按照惯例，它被命名为<strong class="ix hs">自我</strong>。</p><p id="5ccb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您有一个名为<strong class="ix hs"> Car </strong>的<strong class="ix hs">类</strong>和一个名为<strong class="ix hs"> obj1 </strong>的该类实例。当你调用这个对象的一个方法为<strong class="ix hs"> obj1.method(arg1，arg2) </strong>时，这被Python自动转换为<strong class="ix hs"> Car.method(obj1，arg1，arg 2)</strong>——这就是特殊自我的全部。</p><p id="e7e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这也意味着，如果你有一个不带参数的方法，那么你仍然需要一个参数——自我。</p><h1 id="7c42" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">方法的类型</h1><p id="f47e" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated"><strong class="ix hs"> 1。实例方法</strong></p><p id="0b9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">a)访问器方法b)赋值器方法</p><p id="db93" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hs"> 2。类方法</strong></p><p id="e634" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hs"> 3。静态法</strong></p><p id="eee6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hs">实例方法</strong>:以对象为参数的方法称为实例方法。简而言之，使用实例变量的方法称为实例方法。</p><p id="cb6d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实例方法进一步分为访问器和赋值器方法。</p><p id="c07c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hs">访问器方法:</strong>如果我们只使用该方法来获取实例变量的值，那么它被称为访问器方法。</p><p id="ad8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hs"> Mutator方法:</strong>如果我们使用该方法来修改实例变量的现有值，那么它被称为Mutator方法。</p><p id="f799" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hs">类方法:</strong>使用类变量的方法称为类方法。</p><p id="7246" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hs">静态方法:</strong>那些与类变量或者实例变量无关的方法我们就可以使用这个静态方法。</p><pre class="lu lv lw lx fd mc md me mf aw mg bi"><span id="054b" class="la kd hi md b fi mh mi l mj mk">class <strong class="md hs">Car</strong>:<br/>    <br/>    'Common for all the objects of Car Class'<br/>    fuel_type = 'Petrol'<em class="ml">## Class Attribute</em><br/>    <br/>    def __init__(self, model,color,mileage): <em class="ml">## the default method which will be called automatically </em><br/>                                             <em class="ml">## when the object of this calls is called.</em><br/>        <br/>        self.model_name = model <em class="ml">## object attribute</em><br/>        self.color = color     <em class="ml">## object attribute</em><br/>        self.mileage = mileage <em class="ml">## object attribute</em></span><span id="2ca4" class="la kd hi md b fi mm mi l mj mk">    def get_mileage(self): <em class="ml">### ------&gt; The Accessor Method as it is fetching the values</em><br/>        return(self.mileage)<br/>    <br/>    def set_mileage(self,value): <em class="ml">### -----&gt; The Mutators method as it is modifying the existing Value</em><br/>        self.mileage = value<br/>        return(self.mileage)<br/>    <br/>    @classmethod  <em class="ml">## ---&gt; We must indicate the "decorator" here which is indicating it is a Class method</em><br/>    def info(cls): <em class="ml">## ---&gt; This is a Class Method example</em><br/>        <br/>        return(cls.fuel_type)<br/>    <br/>    @staticmethod   <em class="ml">## ----&gt; We must use the decorator to define that it is a "static method"</em><br/>    def about_car():<br/>        print("This is all about Audi Cars")<br/>    <br/>car1 = Car("Audi A6","Red",18)</span><span id="7da2" class="la kd hi md b fi mm mi l mj mk">print(car1.get_mileage())<br/>print(car1.set_mileage(19))</span><span id="1ec1" class="la kd hi md b fi mm mi l mj mk">Car.about_car() <em class="ml">## ---&gt; This is how we call the "Static methods" using the class names</em></span><span id="f9e6" class="la kd hi md b fi mm mi l mj mk">print(Car.info()) <em class="ml">## --&gt; This is how we call the "Call methods"</em></span></pre><h1 id="47b0" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">2.遗产</h1><p id="e5d7" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated"><strong class="ix hs">继承</strong>是一个类继承另一个类的属性和方法的过程。其属性和方法被继承的类称为父类。从父类继承属性的类是子类。</p><figure class="lu lv lw lx fd is er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mn"><img src="../Images/a275ead3766d4adfec57179040663acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qQkQA2GedHggYqAOa6OqNw.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated"><a class="ae ln" href="https://www.geeksforgeeks.org/inheritance-in-c/" rel="noopener ugc nofollow" target="_blank">继承</a></figcaption></figure><h2 id="7db7" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated">句法</h2><p id="8868" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">类parent_class:</p><p id="02b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">父类的主体</p><p id="aad6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类child_class( parent_class):</p><p id="99bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">子类的主体</p><pre class="lu lv lw lx fd mc md me mf aw mg bi"><span id="460c" class="la kd hi md b fi mh mi l mj mk">class <strong class="md hs">Car</strong>:  <em class="ml">## Parent class</em></span><span id="6267" class="la kd hi md b fi mm mi l mj mk">    def __init__(self, name, mileage):<br/>        self.name = name <br/>        self.mileage = mileage </span><span id="97fa" class="la kd hi md b fi mm mi l mj mk">    def description(self):                <br/>        return f"The <strong class="md hs">{</strong>self.name<strong class="md hs">}</strong> car gives the mileage of <strong class="md hs">{</strong>self.mileage<strong class="md hs">}</strong>km/l"</span><span id="5e41" class="la kd hi md b fi mm mi l mj mk">class <strong class="md hs">BMW</strong>(Car): <em class="ml">## Child Class</em><br/>    pass</span><span id="e686" class="la kd hi md b fi mm mi l mj mk">class <strong class="md hs">Audi</strong>(Car):     <em class="ml">## Child class</em><br/>    def audi_desc(self):<br/>        return "This is the description method of class Audi."</span><span id="ca6a" class="la kd hi md b fi mm mi l mj mk">obj1 = BMW("BMW 7-series",39.53)<br/>print(obj1.description())</span><span id="e695" class="la kd hi md b fi mm mi l mj mk">obj2 = Audi("Audi A8 L",14)<br/>print(obj2.description())<br/>print(obj2.audi_desc())</span></pre><h2 id="fd48" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated">需要记住的要点:</h2><p id="3a9a" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">我们创建了两个子类，即“BMW”和“Audi ”,它们继承了父类“Car”的方法和属性。我们没有在BMW类中提供额外的功能和方法。而Audi类中的另一个方法。</p><p id="bb04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意父类的实例方法描述()是如何被子类的对象在obj1.description()和obj2.description()的帮助下访问的。另外，使用obj2.audi_desc()也可以访问类Audi的单独方法。</p><h1 id="d719" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">3.包装</h1><p id="1540" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">封装是面向对象编程(OOP)的基本概念之一。它描述了包装数据的思想和在一个单元中处理数据的方法。这限制了直接访问变量和方法，并且可以防止数据的意外修改。为了防止意外更改，对象的变量只能由对象的方法来更改。这些类型的变量被称为<strong class="ix hs">私有变量</strong>。</p><figure class="lu lv lw lx fd is er es paragraph-image"><div class="er es ms"><img src="../Images/390291801a57d58a21c1cfa1772e0626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*n3wKOZmPEBP6xaYL_ViYcw.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated"><a class="ae ln" href="http://online.infomatics.info/Course/Core-Python/Encapsulation" rel="noopener ugc nofollow" target="_blank">封装</a></figcaption></figure><h2 id="70be" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated">类是封装的一个例子，因为它封装了所有的数据，如成员函数、变量等。</h2><p id="d4a9" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">基本上，它将数据隐藏起来，不让外人访问。例如，如果一个组织想要保护一个对象/信息不被客户或任何未经授权的人访问，那么封装就是确保这一点的方法。</p><p id="570f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以通过在名称前使用单个下划线(_)来声明受保护的方法或属性。比如——自我。_name或def _ method()；这两行告诉我们属性和方法是受保护的，不应该在类和子类的访问之外使用，但是可以由类方法和对象访问。</p><p id="dd55" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然Python使用' _ '只是作为一种编码约定，但它告诉我们应该在类的范围内使用这些属性/方法。但是您仍然可以像往常一样访问被定义为受保护的变量和方法。</p><p id="5233" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，为了防止从类的范围之外访问属性/方法，可以使用“私有成员”。为了将属性/方法声明为私有成员，请在前缀中使用双下划线(<strong class="ix hs">)。比如——自我。</strong> name或def _ _ method()；这两行都表明属性和方法是私有的，不能从类外部访问。</p><pre class="lu lv lw lx fd mc md me mf aw mg bi"><span id="cec6" class="la kd hi md b fi mh mi l mj mk">class <strong class="md hs">car</strong>:</span><span id="7155" class="la kd hi md b fi mm mi l mj mk">    def __init__(self, name, mileage):<br/>        self._name = name  <em class="ml">#protected variable</em><br/>        self.mileage = mileage </span><span id="2326" class="la kd hi md b fi mm mi l mj mk">    def description(self):                <br/>        return f"The <strong class="md hs">{</strong>self._name<strong class="md hs">}</strong> car gives the mileage of <strong class="md hs">{</strong>self.mileage<strong class="md hs">}</strong>km/l"<br/>obj = car("BMW 7-series",39.53)</span><span id="ac6a" class="la kd hi md b fi mm mi l mj mk"><em class="ml">#accessing protected variable via class method </em><br/>print(obj.description())</span><span id="1e22" class="la kd hi md b fi mm mi l mj mk"><em class="ml">#accessing protected variable directly from outside</em><br/>print(obj._name)<br/>print(obj.mileage)</span></pre><h2 id="33a8" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated">请注意我们是如何正确无误地访问受保护变量的。很明显，对变量的访问仍然是公开的。让我们看看封装是如何工作的</h2><pre class="lu lv lw lx fd mc md me mf aw mg bi"><span id="0719" class="la kd hi md b fi mh mi l mj mk">class <strong class="md hs">Car</strong>:</span><span id="b192" class="la kd hi md b fi mm mi l mj mk">    def __init__(self, name, mileage):<br/>        self.__name = name              <em class="ml">#private variable        </em><br/>        self.mileage = mileage </span><span id="f409" class="la kd hi md b fi mm mi l mj mk">    def description(self):                <br/>        return f"The <strong class="md hs">{</strong>self.__name<strong class="md hs">}</strong> car gives the mileage of <strong class="md hs">{</strong>self.mileage<strong class="md hs">}</strong>km/l"</span><span id="c2b5" class="la kd hi md b fi mm mi l mj mk">obj = Car("BMW 7-series",39.53)</span><span id="f61e" class="la kd hi md b fi mm mi l mj mk"><em class="ml">#accessing private variable via class method </em><br/>print(obj.description())</span><span id="6e52" class="la kd hi md b fi mm mi l mj mk"><em class="ml">#accessing private variable directly from outside</em><br/>print(obj.mileage)<br/>print(obj.__name)</span></pre><h1 id="23da" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">注意:</h1><p id="c764" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">当我们尝试使用description()方法访问私有变量时，没有遇到错误。但是当我们试图直接在类外访问私有变量时，Python给出了一个错误:car对象没有属性' __name '。</p><p id="cc02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您仍然可以使用其损坏的名称直接访问该属性。名称管理是我们用来从外部访问类成员的一种机制。Python解释器将任何带有“<strong class="ix hs"> var”的标识符重写为“_ClassName </strong> var”。使用它你也可以从外部访问类成员。</p><pre class="lu lv lw lx fd mc md me mf aw mg bi"><span id="510f" class="la kd hi md b fi mh mi l mj mk">class <strong class="md hs">Car</strong>:</span><span id="ee30" class="la kd hi md b fi mm mi l mj mk">    def __init__(self, name, mileage):<br/>        self.__name = name  <em class="ml">#private variable        </em><br/>        self.mileage = mileage </span><span id="eed4" class="la kd hi md b fi mm mi l mj mk">    def description(self):                <br/>        return f"The <strong class="md hs">{</strong>self.__name<strong class="md hs">}</strong> car gives the mileage of <strong class="md hs">{</strong>self.mileage<strong class="md hs">}</strong>km/l"</span><span id="7bd0" class="la kd hi md b fi mm mi l mj mk">obj = Car("BMW 7-series",39.53)</span><span id="fda3" class="la kd hi md b fi mm mi l mj mk"><em class="ml">#accessing private variable via class method </em><br/>print(obj.description())</span><span id="d5a7" class="la kd hi md b fi mm mi l mj mk"><em class="ml">#accessing private variable directly from outside</em><br/>print(obj.mileage)<br/>print(obj._Car__name)      <em class="ml">#mangled name</em></span></pre><h2 id="ffc1" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated">请注意，mangling规则的设计主要是为了避免事故。但是仍然可以访问或修改被认为是私有的变量。这在特殊情况下甚至很有用，比如在调试器中。</h2><h1 id="ec3b" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">4.多态性</h1><p id="eaf2" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">这是一个希腊单词。如果我们打破术语多态性，我们得到“多”-许多和“变体”-形式。所以多态性意味着有许多形式。在面向对象程序设计中，它指的是具有相同名称但具有不同功能的函数。</p><figure class="lu lv lw lx fd is er es paragraph-image"><div class="er es mt"><img src="../Images/facc147d8448169c9a2b33adc6bbd91b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*V9TUdv8AQpRKH2iJSlQRQQ.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated"><a class="ae ln" href="https://javatutorial.net/java-polymorphism-example" rel="noopener ugc nofollow" target="_blank">多态性</a></figcaption></figure><pre class="lu lv lw lx fd mc md me mf aw mg bi"><span id="830d" class="la kd hi md b fi mh mi l mj mk">class <strong class="md hs">Audi</strong>:<br/>    def description(self):<br/>        print("This the description function of class AUDI.")</span><span id="1967" class="la kd hi md b fi mm mi l mj mk">class <strong class="md hs">BMW</strong>:<br/>    def description(self):<br/>        print("This the description function of class BMW.")</span><span id="27f4" class="la kd hi md b fi mm mi l mj mk">audi = Audi()<br/>bmw = BMW()<br/>for car <strong class="md hs">in</strong> (audi,bmw):<br/>    car.description()</span></pre><h2 id="6ccf" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated">注意:</h2><p id="8b66" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">当使用对象audi调用该函数时，则调用类Audi的函数，当使用对象bmw调用该函数时，则调用类BMW的函数。</p><h1 id="c1a7" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">5.Python中的抽象类</h1><p id="eda9" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">一个<strong class="ix hs">抽象</strong>类可以被认为是其他类的蓝图。它允许您创建一组方法，这些方法必须在从抽象类构建的任何子类中创建。包含一个或多个抽象方法的类称为抽象类。抽象方法是有声明但没有实现的方法。当我们设计大型功能单元时，我们使用一个抽象类。当我们想为一个组件的不同实现提供一个公共接口时，我们使用一个抽象类。</p><figure class="lu lv lw lx fd is er es paragraph-image"><div class="er es mu"><img src="../Images/52151599452f664bf46dbcea8c1f36c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*IzgecvcF1TWM_ssopy2WwA.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated"><a class="ae ln" href="https://www.programminghunk.com/2020/02/abstract-classes-in-python.html" rel="noopener ugc nofollow" target="_blank">抽象类</a></figcaption></figure><h2 id="17e4" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated">为什么使用抽象基类:</h2><p id="5ac0" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">通过定义一个抽象基类，可以为一组子类定义一个公共应用程序接口(API)。这种能力在第三方提供实现的情况下特别有用，比如插件，但是在大型团队或大型代码库中工作，很难或不可能记住所有的类时，这种能力也会对您有所帮助。</p><h2 id="6289" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated">抽象基类如何工作:</h2><p id="e90c" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">默认情况下，Python不提供抽象类。Python附带了一个模块，该模块为定义<strong class="ix hs">抽象基类(ABC) </strong>提供了基础，该模块名为ABC。ABC的工作方式是将基类的方法修饰为抽象，然后将具体的类注册为抽象基类的实现。当用关键字@abstractmethod修饰一个方法时，它就变成了抽象的。</p><pre class="lu lv lw lx fd mc md me mf aw mg bi"><span id="782f" class="la kd hi md b fi mh mi l mj mk">from abc import ABC, abstractmethod <br/>  <br/>class <strong class="md hs">Polygon</strong>(ABC): <br/>  <br/>    <em class="ml"># abstract method </em><br/>    def noofsides(self): <br/>        pass</span><span id="6ea2" class="la kd hi md b fi mm mi l mj mk">class <strong class="md hs">Triangle</strong>(Polygon): <br/>  <br/>    <em class="ml"># overriding abstract method </em><br/>    def noofsides(self): <br/>        print("I have 3 sides") </span><span id="54d9" class="la kd hi md b fi mm mi l mj mk">        <br/>class <strong class="md hs">Pentagon</strong>(Polygon): <br/>  <br/>    <em class="ml"># overriding abstract method </em><br/>    def noofsides(self): <br/>        print("I have 5 sides") <br/>        <br/>class <strong class="md hs">Hexagon</strong>(Polygon): <br/>  <br/>    <em class="ml"># overriding abstract method </em><br/>    def noofsides(self): <br/>        print("I have 6 sides") <br/>        <br/>        <br/>class <strong class="md hs">Quadrilateral</strong>(Polygon): <br/>  <br/>    <em class="ml"># overriding abstract method </em><br/>    def noofsides(self): <br/>        print("I have 4 sides") <br/>  <br/><em class="ml"># Driver code </em><br/>R = Triangle() <br/>R.noofsides() <br/>  <br/>K = Quadrilateral() <br/>K.noofsides() <br/>  <br/>R = Pentagon() <br/>R.noofsides() <br/>  <br/>K = Hexagon() <br/>K.noofsides()</span></pre><figure class="lu lv lw lx fd is er es paragraph-image"><div class="er es mv"><img src="../Images/5aa692b796648ae8a15ddf5164b13983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*ShFPPTy6cXxONDJfztnCxQ.gif"/></div></figure><p id="b913" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你喜欢我的文章，给它一些掌声，或者更好地与你的朋友或同事分享。</p><p id="3771" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在LinkedIn上找到我:<a class="ae ln" href="https://www.linkedin.com/in/hiteshtripathi/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/hiteshtripathi/</a></p><h1 id="2f90" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">参考资料:</h1><h2 id="ca43" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated"><a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#1" rel="noopener ugc nofollow" target="_blank">1 . https://youtu . be/qiscmnbip 2g</a></h2><h2 id="388d" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated"><a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#2" rel="noopener ugc nofollow" target="_blank">2 . https://python . swaroopch . com/OOP . html</a></h2><h2 id="320a" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated"><a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#2" rel="noopener ugc nofollow" target="_blank"> 3。https://www . analyticsvidhya . com/blog/2020/09/面向对象编程/ </a></h2><h2 id="178a" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated"><a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#4" rel="noopener ugc nofollow" target="_blank"> 4。https://medium . com/@ manjuladube/encapsulation-abstraction-35999 b0a 3911</a></h2><h2 id="8513" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated"><a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#5" rel="noopener ugc nofollow" target="_blank"> 5。https://www.geeksforgeeks.org/polymorphism-in-python/</a></h2><h2 id="7269" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated"><a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#6" rel="noopener ugc nofollow" target="_blank"> 6。https://www.faceprep.in/python/abstraction-in-python/</a></h2><h2 id="3275" class="la kd hi bd ke lb lc ld ki le lf lg km jg lh li kq jk lj lk ku jo ll lm ky ho bi translated"><a class="ae ln" href="https://www.kaggle.com/hiteshtripathi/demystifying-object-oriented-programming-concepts#7" rel="noopener ugc nofollow" target="_blank"> 7。https://www.geeksforgeeks.org/abstract-classes-in-python/</a></h2></div></div>    
</body>
</html>