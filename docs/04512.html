<html>
<head>
<title>SQL Server Query Store: The story of a performance regressed query!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL Server查询存储:性能回归查询的故事！</h1>
<blockquote>原文：<a href="https://medium.com/codex/sql-server-query-store-the-story-of-a-performance-regressed-query-385273d06d29?source=collection_archive---------3-----------------------#2021-12-08">https://medium.com/codex/sql-server-query-store-the-story-of-a-performance-regressed-query-385273d06d29?source=collection_archive---------3-----------------------#2021-12-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ac85" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">与查询计划选择更改相关的性能问题</h2></div><p id="a851" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上一篇文章<a class="ae jt" href="https://segovoni.medium.com/introduction-to-sql-server-query-store-9e45a563a502" rel="noopener">SQL Server查询存储简介</a>中，我谈到了查询存储如何捕获数据以及它能为您做什么！现在，我将讨论与查询计划选择更改相关的性能问题，以及查询存储如何帮助我们识别变慢的查询！</p><p id="b542" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了向您展示查询存储是如何工作的，以及DBA如何轻松地强制执行计划(针对特定的查询)，我开发了<a class="ae jt" href="https://github.com/segovoni/sqlcmdcli" rel="noopener ugc nofollow" target="_blank"> sqlcmdcli </a>这是一个开源的命令行实用程序，用于在SQL Server上以特定的交互式方式执行命令，以模拟特定的工作负载、匿名化数据等等。<a class="ae jt" href="https://github.com/segovoni/sqlcmdcli/wiki#querystoreworkload-qsw" rel="noopener ugc nofollow" target="_blank"> querystoreworkload </a>命令运行特定的工作负载来重现查询的回归。它可以用来分析带有<a class="ae jt" href="https://docs.microsoft.com/en-us/sql/relational-databases/performance/monitoring-performance-by-using-the-query-store?WT.mc_id=DP-MVP-4029181" rel="noopener ugc nofollow" target="_blank"> SQL Server查询存储</a>的查询的回归。一旦确定了回归，就有可能继续手动强制最佳执行计划！querystoreworkload命令在一个长循环(300，000次迭代)中执行以下查询。请注意参数，因为它们的值将由随机函数生成，该函数返回0到100之间的随机值。当参数值小于2时，该命令还会清除计划缓存。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="38d1" class="kd ke hi jz b fi kf kg l kh ki">SELECT<br/>  *<br/>FROM<br/>  dbo.Tab_A<br/>WHERE<br/>  (Col1 = @Parameter1) AND (Col2 = @Parameter2);</span></pre><p id="e32d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们使用<a class="ae jt" href="http://github.com/segovoni/sqlcmdcli" rel="noopener ugc nofollow" target="_blank"> sqlcmdcli </a>在AdventureWorks2017数据库上运行示例工作负载。我使用了以下命令行:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="0678" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">sqlcmdcli.exe</strong> querystoreworkload -servername:MyServerName -databasename:AdventureWorks2017 -username:MyUserName -password:MyPassword -verbose</span></pre><p id="9b4c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下图显示了工作中的控制台应用程序。</p><figure class="ju jv jw jx fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kj"><img src="../Images/e8633abb8516bdeacaf40b6fc35478d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQ8G1Y2iuk-1CJhmRLvp2g.jpeg"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">sqlcmdcli—<a class="ae jt" href="https://github.com/segovoni/sqlcmdcli" rel="noopener ugc nofollow" target="_blank">https://github.com/segovoni/sqlcmdcli</a></figcaption></figure><p id="e99b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以通过SQL Server Management Studio以及我在上一篇文章<a class="ae jt" href="https://segovoni.medium.com/introduction-to-sql-server-query-store-9e45a563a502" rel="noopener">SQL Server查询存储简介</a>中提到的dmv来查看查询存储捕获了哪些数据。使用SQL Server Management Studio，您可以找到一个名为“查询存储”的新分支，它位于数据库分支下。首先，双击“回归查询”菜单项，可以看到“回归查询”报告。下图显示了所选数据库在过去5分钟内的前25个回归查询。</p><figure class="ju jv jw jx fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kv"><img src="../Images/6bf03e7efcc5bf32aed9f960bb79bc41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zNGuZePsY7jnBgHcS6oQeA.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">查询存储捕获的前25个回归查询</figcaption></figure><p id="7c16" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如图所示，SQL Server对同一个查询使用了两个执行计划，query_id等于1的查询。这两个执行计划完全不同，plan_id等于2的计划使用“表扫描”操作符来访问表dbo。Tab_A，相反，plan_id等于1的第二个使用最有效的“索引查找”从同一个表中检索数据。对于同一个查询，我们有两个执行计划，这意味着SQL Server根据分配给参数的不同值选择了两种不同的方法来访问数据。当分配给参数1和参数2的值等于1时，查询检索大约100000行，相反，对于其他值，查询检索不到10行，执行计划完全不同。存储了与每个计划相关的指标，您可以通过单击按钮“以网格格式查看计划摘要”获得这些指标，如下图所示。</p><figure class="ju jv jw jx fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kw"><img src="../Images/f31b770af68438971f4e758525d85f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9JciMRTQ69ZWM_2NUQhoCw.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">query_id 1的计划摘要</figcaption></figure><p id="433b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以注意到，与plan_id等于2的计划相比，plan_id等于1的计划使用的次数更多。这两个计划在“平均CPU使用率”指标上也有很大的不同。与plan_id等于1的执行计划的相同指标相比，plan_id等于2的计划的CPU平均使用率高出20倍。</p><p id="4f12" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您还可以比较两个计划的图形表示，您可以使用右侧工具栏上的“比较”按钮进行比较。比较这两个执行计划，您可能会决定对这个特定的查询强制使用其中的一个(两个或多个),查询存储使这项任务变得很容易。在这种情况下，我的选择是将plan_id等于1的计划强制用于query_id等于1的查询。我可以通过右上角的工具栏上的“强制计划”按钮来实现。</p><figure class="ju jv jw jx fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kx"><img src="../Images/667f69192221e34a9877304962504126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UCdLYsBkseYrZkVYp2-w8A.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">执行计划比较</figcaption></figure><p id="fade" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">SQL Server Management Studio询问我是否确定要强制执行该计划，如果我回答是，则强制完成！从现在开始，SQL Server查询优化器将使用我强制的计划，而不是另一个计划。</p><figure class="ju jv jw jx fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es ky"><img src="../Images/da1e47f38f770b52dd2dbc1f6b7b06ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_1KWGI5vfvsjEtaRfow4Mg.png"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">计划标识1已被强制用于查询标识1</figcaption></figure><p id="4d3a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就是这样！</p><p id="7a31" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于意大利人来说，在Vimeo的<a class="ae jt" href="https://www.ugiss.org/" rel="noopener ugc nofollow" target="_blank">UGISS</a>(SQL Server的意大利用户组)频道上有一段关于SQL Server查询存储e自动调优的视频:</p><figure class="ju jv jw jx fd kk"><div class="bz dy l di"><div class="kz la l"/></div></figure><h2 id="e121" class="kd ke hi bd lb lc ld le lf lg lh li lj jg lk ll lm jk ln lo lp jo lq lr ls lt bi translated">接下来会发生什么？</h2><p id="5ee9" class="pw-post-body-paragraph ix iy hi iz b ja lu ij jc jd lv im jf jg lw ji jj jk lx jm jn jo ly jq jr js hb bi translated">在名为<a class="ae jt" href="https://www.microsoft.com/en-us/sql-server/sql-server-2022" rel="noopener ugc nofollow" target="_blank"> SQL Server 2022 </a>的SQL Server下一版本中，查询存储将默认启用，并与<strong class="iz hj">的<strong class="iz hj">新一代</strong>智能查询处理</strong>相结合，将允许在一些常见场景中提高性能，而无需更改T-SQL代码。<strong class="iz hj">参数敏感性计划</strong> (PSP)允许为同一个参数查询缓存多个执行计划！<strong class="iz hj">基数估计(CE)反馈</strong>将为查询优化器和查询处理提供更多关于查询执行指标的详细信息，以改进未来的决策！</p><p id="1783" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅此而已！享受查询商店！</p></div></div>    
</body>
</html>