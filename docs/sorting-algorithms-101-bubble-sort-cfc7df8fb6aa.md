# 排序算法 101:冒泡排序

> 原文：<https://medium.com/codex/sorting-algorithms-101-bubble-sort-cfc7df8fb6aa?source=collection_archive---------13----------------------->

![](img/da7d5ff1ab3ceeea1ace5eb8b911929b.png)

照片由[雷诺·莱蒂恩](https://unsplash.com/@renolaithienne?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

关于编码技术面试，我发现最令人畏惧的事情之一是对数据结构和算法的过分强调。也许是因为我来自一个训练营的背景，这不是很重要的话题——但不管我和谁说话(是否有计算机科学学位),这都是一个经过严格测试的话题，也是面试时必须知道的。

因此，在这个由五部分组成的迷你系列中，我将介绍五种最流行的排序算法。今天，我将回顾冒泡排序，选择、插入、合并和快速排序将在后续文章中讨论。

如果你准备好了，让我们开始吧！

# **冒泡排序:工作原理**

冒泡排序是最简单的排序算法。它的工作原理是比较相邻的元素，如果它们的顺序不对，就交换它们。

```
list = [ 4, 7, 1, 6, 10, 8, 3, 9, 7, 5, 2 ]
```

就拿上面的`list`来说吧。目标是从升序对这个列表进行排序。所以，在上面的例子中，从 1 一直到 10。

在第一次迭代中，冒泡排序从列表中的第一个元素(本例中为 4)开始，并与第二个元素(7)进行比较。如果第一个元素大于第二个元素，则两者交换位置。如果第一个元素*不比第二个数字*大，那么什么都不会发生，我们继续处理列表中的下两个元素(7 和 1)。

因为 7 大于 1，所以这两个数字交换了位置，我们再次移动到下两个元素(7 和 6)。当 7 大于 6 时，这两个数字交换位置，我们继续下两个元素(7 和 10)。因为 7 不大于 10，所以没有交换发生，我们移到 10 和 8。这个过程一直持续到我们到达列表的末尾，在那里 10 和 2 交换了位置，产生了下面的列表:

```
list = [ 4, 1, 6, 7, 8, 3, 9, 7, 5, 2, 10 ]
```

如您所见，10 是列表中最高的数字，并且位于正确的位置，但是列表的其余部分仍然是无序的。因此，我们将再次遍历列表，重复循环。

继续第二次迭代，我们从 4 开始，重复上面的过程。在第二次迭代结束时，我们得到下面的列表:

```
list = [ 1, 4, 6, 7, 3, 8, 7, 5, 2, 9, 10 ]
```

现在，9 和 10 都在正确的位置上，但是有几个数字仍然是乱序的。为了解决这个问题，我们需要对这个列表执行 *n* 次迭代 *n* 次，以将所有内容排序( ** n 表示列表中元素的数量)。*

最终，当不再发生交换时，排序算法停止，这意味着所有元素都在正确的位置，列表最终按升序排序。

```
list = [ 1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10 ]
```

# 时间复杂度

由于我们需要遍历列表 *n* 次来完成排序，所以冒泡排序具有**时间复杂度**或**大 O 符号**的 **O(n2)** 。

为什么是 O(n2)？

在上面的例子中，我们有 *n = 11* 个元素。当我们遍历数组长度时，我们第一次遍历了 *n* (11)个元素。然后，我们一次又一次地遍历这个列表。理论上，对于一个完全未排序的列表，我们遍历列表中的每个元素( *n* ，对于列表的大小( *n* ，导致时间复杂度为( *n x n* ，或者( *n2* )。

# 算法

现在我们已经有了理论，让我们建立自己的冒泡排序算法！ **下面的代码是用 Python 写的，但是无论你选择什么语言，一般的逻辑应该是一样的。*

简单来说，首先选择并比较列表中的前两个数字:`arr[0] > arr[1]`。

我们不只是处理前两个数字，所以让我们添加一个 for 循环，让它遍历数组。

```
for num in range (len(arr) - 1):
    arr[num] > arr[num + 1]
```

请记住，我们使用`len(arr) - 1`是因为我们不需要遍历最后一个数字，因为没有第二个数字可供比较！

现在要执行实际的交换，我们可以动态地重新分配这两个值:`arr[num], arr[num + 1] = arr[num + 1], arr[num]`

因为我们只希望交换发生在*if*arr[num]>arr[num+1]的情况下，我们将抛出一个 if 语句:

```
for num in range (len(arr) - 1):
    if arr[num] > arr[num + 1]:
        arr[num], arr[num + 1] = arr[num + 1], arr[num]
```

不过，这还不完全是。上面的代码将只覆盖列表的第一次迭代。那么，如何通过*迭代 n 次*呢？

一种方法是针对列表中的元素数量运行一个循环。例如，使用文章开头的`list`，我们运行上面的代码 11 次。虽然这不是非常有效的代码，因为如果你在第四次或第五次迭代中得到一个排序列表，循环仍然会继续，这使得效率很低。

实现这一点的另一种方法是在布尔值的帮助下加入状态跟踪器。当状态跟踪器为`True`时，我们进入 while 循环，在这里我们将状态跟踪器重置为`False`(以防止无限 while 循环)，然后进入 for 循环。

for 循环将继续贯穿数组的长度(减 1)，直到一个数大于另一个数。当这种情况发生时，交换最终会发生。然后，我们将状态跟踪器重置为`True`，跳出 for 循环，并重新开始 while 循环。

在最后一次迭代中，当列表被完全排序，并且没有交换发生时，状态跟踪器将永远不会被重置为`True`，从而脱离 while 循环并结束排序算法。

我知道—这有很多措辞，但是下面的代码总结了所有这些:

```
def bubble_sort(arr):
    swap_happened = True  
    while swap_happened:
        swap_happened = False 
        for num in range(len(arr) - 1):
            if arr[num] > arr[num + 1]:
                arr[num], arr[num + 1] = arr[num + 1], arr[num]
                swap_happened = True
```

而且，就是这样！希望这篇冒泡排序教程给了你一个良好的基础。如果你仍然有疑问，最好是进行一些练习。我最好的建议是查看 Leet 代码上的练习题，然后从那里开始。

请继续关注本系列的下一个主题:选择排序！回头见。感谢阅读！