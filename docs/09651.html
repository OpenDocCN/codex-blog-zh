<html>
<head>
<title>Java Date Format with Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java日期格式及示例</h1>
<blockquote>原文：<a href="https://medium.com/codex/java-date-format-5a2515b07c2c?source=collection_archive---------5-----------------------#2022-10-31">https://medium.com/codex/java-date-format-5a2515b07c2c?source=collection_archive---------5-----------------------#2022-10-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/913dbf66f02a5bb71f9d9ac1262768e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4SjPAbDfKFVOF36NaV4LoQ.gif"/></div></div></figure><h1 id="3d69" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">java。util。日期</h1><p id="7749" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这在Java中用来表示日期和时间。该类用于保持协调世界时(UTC)。该类表示特定的时间瞬间，精度为毫秒。有许多构造函数和方法可以用来处理时间和日期。Date类已经从可序列化、可克隆和可比较的接口中实现。这个类可以在java.util包中找到。日期对象是可变的。一旦我们初始化了它，我们就可以改变它的内部值。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/842134bb1870c4559df967ead4b072ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B4heDoWgL82BPAPQpkqZCw.png"/></div></div></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/7500fa22fc44dc83ac2e97dd9601e20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*XzOMUdoWm1bJpdmTF51aMA.png"/></div></figure><p id="a4e0" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">引入Calander类后，一些构造函数和方法被弃用。可以参考下面一个日期类的模板类。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="e7d9" class="lc ir hi ky b fi ld le l lf lg">public class Date implements Serializable, Cloneable, Comparable&lt;Date&gt; {</span><span id="398f" class="lc ir hi ky b fi lh le l lf lg">private static final BaseCalendar gcal;<br/>    private static BaseCalendar jcal;<br/>    private transient long fastTime;<br/>    private transient BaseCalendar.Date cdate;<br/>    private static int defaultCenturyStart;<br/>    private static final long serialVersionUID = 7523967970034938905L;<br/>    private static final String[] wtb;<br/>    private static final int[] ttb;</span><span id="c5f5" class="lc ir hi ky b fi lh le l lf lg">public Date() {}</span><span id="c517" class="lc ir hi ky b fi lh le l lf lg">public Date(long l) {}</span><span id="d81a" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public Date(int i, int i1, int i2) {}</span><span id="9a25" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public Date(int i, int i1, int i2, int i3, int i4) {}</span><span id="c346" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public Date(int i, int i1, int i2, int i3, int i4, int i5) {}</span><span id="af71" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public Date(String string) {}</span><span id="4767" class="lc ir hi ky b fi lh le l lf lg">public Object clone() {}</span><span id="bf57" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public static long UTC(int i, int i1, int i2, int i3, int i4, int i5) {}</span><span id="4ed6" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public static long parse(String string) {}</span><span id="c7d1" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public int getYear() {}</span><span id="6ab5" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public void setYear(int i) {}</span><span id="f599" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public int getMonth() {}</span><span id="aa6b" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public void setMonth(int i) {}</span><span id="4efd" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public int getDate() { }</span><span id="e276" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public void setDate(int i) {}</span><span id="96b0" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public int getDay() {}</span><span id="8988" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public int getHours() {}</span><span id="1849" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public void setHours(int i) { }</span><span id="b745" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public int getMinutes() {}</span><span id="06e1" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public void setMinutes(int i) {}</span><span id="8f83" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public int getSeconds() { }</span><span id="efab" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public void setSeconds(int i) {}</span><span id="8551" class="lc ir hi ky b fi lh le l lf lg">public long getTime() {}</span><span id="4d78" class="lc ir hi ky b fi lh le l lf lg">private final long getTimeImpl() {}</span><span id="87f5" class="lc ir hi ky b fi lh le l lf lg">public void setTime(long l) { }</span><span id="210f" class="lc ir hi ky b fi lh le l lf lg">public boolean before(Date date) {}</span><span id="9c7c" class="lc ir hi ky b fi lh le l lf lg">public boolean after(Date date) {}</span><span id="3ad4" class="lc ir hi ky b fi lh le l lf lg">public boolean equals(Object o) {}</span><span id="6605" class="lc ir hi ky b fi lh le l lf lg">static final long getMillisOf(Date date) {}</span><span id="bf7d" class="lc ir hi ky b fi lh le l lf lg">public int compareTo(Date date) {}</span><span id="c276" class="lc ir hi ky b fi lh le l lf lg">public int hashCode() {}</span><span id="d9a2" class="lc ir hi ky b fi lh le l lf lg">public String toString() {}</span><span id="ed44" class="lc ir hi ky b fi lh le l lf lg">private static final StringBuilder convertToAbbr(StringBuilder sb, String string) {}</span><span id="c46c" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public String toLocaleString() {}</span><span id="e3bf" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public String toGMTString() {}</span><span id="38d3" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public int getTimezoneOffset() {}</span><span id="69c9" class="lc ir hi ky b fi lh le l lf lg">private final BaseCalendar.Date getCalendarDate() {}</span><span id="55cc" class="lc ir hi ky b fi lh le l lf lg">private final BaseCalendar.Date normalize() { }</span><span id="3423" class="lc ir hi ky b fi lh le l lf lg">private final BaseCalendar.Date normalize(BaseCalendar.Date date) {}</span><span id="25a1" class="lc ir hi ky b fi lh le l lf lg">private static final BaseCalendar getCalendarSystem(int i) {}</span><span id="c7ec" class="lc ir hi ky b fi lh le l lf lg">private static final BaseCalendar getCalendarSystem(long l) { }</span><span id="1e44" class="lc ir hi ky b fi lh le l lf lg">private static final BaseCalendar getCalendarSystem(BaseCalendar.Date date) { }</span><span id="b64c" class="lc ir hi ky b fi lh le l lf lg">private static final synchronized BaseCalendar getJulianCalendar() {}</span><span id="b99e" class="lc ir hi ky b fi lh le l lf lg">private void writeObject(ObjectOutputStream stream) throws IOException {}</span><span id="783e" class="lc ir hi ky b fi lh le l lf lg">private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {}</span><span id="cc98" class="lc ir hi ky b fi lh le l lf lg">public static Date from(Instant instnt) {}</span><span id="4423" class="lc ir hi ky b fi lh le l lf lg">public Instant toInstant() {}<br/>}</span></pre><p id="eb03" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">让我们了解一下在util中可以找到的方法和构造函数。日期类。但是我不打算讨论不赞成使用的方法和构造函数。</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="0be1" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated"><strong class="jq hj">构造函数</strong></p><ul class=""><li id="80ef" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated"><em class="ly">日期(){} </em></li></ul><p id="17fc" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">此构造函数用当前日期和时间初始化并分配Date对象。它从你的本地机器或服务器获取时间。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="f63d" class="lc ir hi ky b fi ld le l lf lg">import java.util.Date;</span><span id="4ceb" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="2522" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="1c3d" class="lc ir hi ky b fi lh le l lf lg">Date date = new Date();<br/>        System.out.println(date);<br/>    }<br/>}</span></pre><p id="bbe6" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/a0eaa9192d7e327b64fa44b08b09c72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WPWZBH4sFT4gPa_s30Dnhw.png"/></div></div></figure><p id="b81d" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这是当我的本地机器使用下面的时区时的输出。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/9a1f2abfa267d20da177ef1bc43969c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*OUbNzkiDXTSV47X2ICkEOA.png"/></div></figure><p id="1a50" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">我改变了我的时区如下。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/e8c1416100e4a6119ccd5e0ce74cbdf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*dT8uTyE1lFlWm3TdjmvCvw.png"/></div></figure><p id="d198" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">然后输出被改变。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/b0d9c6cdeb3678567eb5af3e10859a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NaT3j3eC-2Ovw7L_rEdrsQ.png"/></div></div></figure></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><ul class=""><li id="d049" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated"><em class="ly">日期(长l) {} </em></li></ul><p id="6973" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这是一个构造函数，它为自1970年1月1日00:00:00 GMT以来的给定毫秒创建一个date对象。</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><h2 id="bf79" class="lc ir hi bd is md me mf iw mg mh mi ja jz mj mk je kd ml mm ji kh mn mo jm mp bi translated">方法</h2><ul class=""><li id="bc2a" class="lp lq hi jq b jr js jv jw jz mq kd mr kh ms kl lu lv lw lx bi translated"><em class="ly"> public long getTime(){} </em></li></ul><p id="aac2" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">此方法返回由Date对象表示的自1970年1月1日00:00:00 GMT以来的毫秒数。它返回一个长整型值。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="587b" class="lc ir hi ky b fi ld le l lf lg">public class A {</span><span id="ba83" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="474e" class="lc ir hi ky b fi lh le l lf lg">Date d=new Date();  <br/>        long time=d.getTime();<br/>        System.out.println(d);  <br/>      <br/>    }<br/>}</span></pre><p id="4c57" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/4cf9259f849b3bf16f4cf5d87f0c8d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0VAQlH6I7BYRpZAqqQTNA.png"/></div></div></figure><ul class=""><li id="05ec" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">公共void设置时间(长l){}</li></ul><p id="784b" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">此方法将date对象设置为表示一个时间点，即1970年1月1日00:00:00 GMT之后的时间毫秒。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="3a37" class="lc ir hi ky b fi ld le l lf lg">public class A {</span><span id="c09f" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="d4b7" class="lc ir hi ky b fi lh le l lf lg">Date d=new Date(); <br/>        System.out.println("Date before setting time : "+d);<br/>        d.setTime(2000);<br/>        System.out.println("Date after setting time : "+d);  <br/>      <br/>    }<br/>}</span></pre><p id="a02c" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/6ed50bc01ecd46684b60f8f932df0dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yOVYpNoJ0OO9-NmNKIRztg.png"/></div></div></figure><ul class=""><li id="b68e" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated"><em class="ly">public boolean before(Date Date){ }</em></li></ul><p id="1642" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">此方法检查一个给定的日期是否在另一个给定的指定日期之前。这将返回一个布尔值。</p><p id="43ab" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated"><strong class="jq hj">！</strong> Date d1=new Date(int 1，int 2，int 3) →这是一个不推荐使用的构造函数，编码时不要使用。这只是用来给出一个想法。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="c9ce" class="lc ir hi ky b fi ld le l lf lg">public class A {</span><span id="bcd3" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="c704" class="lc ir hi ky b fi lh le l lf lg">        Date d1=new Date(2022,10,30); <br/>        Date d2=new Date(2022,11,21);  <br/>        <br/>        boolean result=d1.before(d2);<br/>        <br/>        System.out.println("2022/10/30 Date before 2022/11/21 :      "+result);<br/>       <br/>      <br/>    }<br/>}</span></pre><p id="6c5f" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/8696c6b683308def31afb59e9fb37cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r7SWK_o94ZxpSNxGSEMo0g.png"/></div></div></figure><ul class=""><li id="fba0" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated"><em class="ly">(Date Date)之后的公共布尔{} </em></li></ul><p id="4154" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这与之前的方法相反。此方法检查一个给定的日期是否在另一个给定的指定日期之后。这将返回一个布尔值。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="d6a1" class="lc ir hi ky b fi ld le l lf lg">public class A {</span><span id="913f" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="cf1e" class="lc ir hi ky b fi lh le l lf lg">        Date d1 = new Date(2022, 10, 30);<br/>        Date d2 = new Date(2022, 11, 21);</span><span id="6677" class="lc ir hi ky b fi lh le l lf lg">boolean result = d1.after(d2);</span><span id="f1a9" class="lc ir hi ky b fi lh le l lf lg">System.out.println("2022/10/30 Date after 2022/11/21 : " + result);</span><span id="345a" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="2620" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/f7077959ad301305f60049f725130263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LWEWLIWjWq9X0muBtaQxvA.png"/></div></div></figure><p id="c42e" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这些是util中最常用的构造函数和方法。日期类。</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><h1 id="17c1" class="iq ir hi bd is it mw iv iw ix mx iz ja jb my jd je jf mz jh ji jj na jl jm jn bi translated">SQLDate</h1><p id="b231" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这位于java.sql包中。这也是一个帮助用java表示日期的类。它继承了java.util.Date类。如果你正在处理基于SQL的数据库，你可以使用SQLite。一个毫秒值周围的薄薄的包装允许JDBC将它识别为一个SQL日期值。毫秒值表示自1970年1月1日00:00:00.000 GMT以来经过的毫秒数。这不会保留任何关于时区的信息。它也使用服务器或本地时间。</p><p id="7e6c" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这是由util继承的。日期类。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es km"><img src="../Images/6af50dd11a1e187c1f9f53ca97939552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NncKbVKeneDjrr7fnTg5ug.png"/></div></div></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/888a2aa0dfc238ac6eebaeeb56b05052.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*pIspkZPyuQWik1U6GA0Qzg.png"/></div></figure><p id="a2fe" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">随着Java 8的引入，一些构造函数和方法被弃用了。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="345e" class="lc ir hi ky b fi ld le l lf lg">public class Date extends java.util.Date {</span><span id="6d11" class="lc ir hi ky b fi lh le l lf lg">static final long serialVersionUID = 1511598038487230103L;</span><span id="79a7" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public Date(int i, int i1, int i2) {}</span><span id="d685" class="lc ir hi ky b fi lh le l lf lg">public Date(long l) {}</span><span id="b7fa" class="lc ir hi ky b fi lh le l lf lg">public void setTime(long l) {}</span><span id="dc0b" class="lc ir hi ky b fi lh le l lf lg">public static Date valueOf(String string) {}</span><span id="986f" class="lc ir hi ky b fi lh le l lf lg">public String toString() {}</span><span id="5063" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public int getHours() {}</span><span id="02c2" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public int getMinutes() {}</span><span id="06fb" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public int getSeconds() {}</span><span id="ff0e" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public void setHours(int i) {}</span><span id="bdf4" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public void setMinutes(int i) {}</span><span id="2a0a" class="lc ir hi ky b fi lh le l lf lg">@Deprecated<br/>    public void setSeconds(int i) { }</span><span id="b5de" class="lc ir hi ky b fi lh le l lf lg">public static Date valueOf(LocalDate ld) {}</span><span id="0166" class="lc ir hi ky b fi lh le l lf lg">public LocalDate toLocalDate() {}</span><span id="c152" class="lc ir hi ky b fi lh le l lf lg">public Instant toInstant() {}<br/>}</span></pre><p id="3888" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">让我们了解一下sql中的方法和构造函数。日期类。但是我不打算讨论不赞成使用的方法和构造函数。</p><ul class=""><li id="128a" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated"><em class="ly">公开日期(长l){} </em></li></ul><p id="5816" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这是一个使用给定的毫秒时间值构建日期对象的构造函数。如果不传递长整型值，就无法创建sql。日期对象。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="21ce" class="lc ir hi ky b fi ld le l lf lg">import java.sql.Date;</span><span id="4c56" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="c772" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="dde6" class="lc ir hi ky b fi lh le l lf lg">Date d = new Date(0);<br/>        System.out.println(0);</span><span id="69f4" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="705d" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/6007d323919665391d01ef5542deed5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*prB_nbfwOCm8NXi822qC4w.png"/></div></figure><ul class=""><li id="5c89" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">公共void设置时间(长l){}</li></ul><p id="d0a7" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这是使用给定的毫秒时间值设置现有Date对象的方法。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="72a8" class="lc ir hi ky b fi ld le l lf lg">import java.sql.Date;</span><span id="6789" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="3259" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="3cd8" class="lc ir hi ky b fi lh le l lf lg">Date d = new Date(0);<br/>        System.out.println("Date before setting : "+d);<br/>        d.setTime(1111111111);<br/>        System.out.println("Date after setting : "+d);</span><span id="cc87" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="f7f0" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nd"><img src="../Images/45c64e361140c960dfddaaedd117f26a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*NPNhXP7GEsSrzW9vqOZ0Ig.png"/></div></div></figure><ul class=""><li id="aace" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">公共LocalDate toLocalDate(){}</li></ul><p id="f6ef" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">此方法用于将SQL日期对象转换为本地日期对象。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="e171" class="lc ir hi ky b fi ld le l lf lg">import java.sql.Date;<br/>import java.time.LocalDate;</span><span id="761d" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="90fd" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="7b65" class="lc ir hi ky b fi lh le l lf lg">Date d = new Date(0);<br/>        <br/>        System.out.println(d.getClass());<br/>        LocalDate l= d.toLocalDate();<br/>        System.out.println(l.getClass());</span><span id="2efc" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="8717" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es ne"><img src="../Images/a9f7dd670d251bc60d2bdce43048a7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*iMemGLYZMz8hVuCuoRYVeQ.png"/></div></figure><ul class=""><li id="61da" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">公共静态日期值Of(String string){}</li></ul><p id="4430" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这是一个用于返回给定字符串的SQL日期对象的方法。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="8e55" class="lc ir hi ky b fi ld le l lf lg">import java.sql.Date;</span><span id="a6a5" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="6c27" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="c0e7" class="lc ir hi ky b fi lh le l lf lg">String stringDate = "2022-10-31";<br/>        Date date = Date.valueOf(stringDate);<br/>        System.out.println("Date :" + date);<br/>        System.out.println(date.getClass());</span><span id="f443" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="42b2" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es nf"><img src="../Images/f9d5e54edc005fd7e86470eac5e73fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*1looC5pB8NFSJfnLwl3apg.png"/></div></figure><ul class=""><li id="a3d7" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">(本地日期id){}的公共静态日期值</li></ul><p id="7fc2" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这是一种用于返回给定本地日期对象的SQL日期对象的方法。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="b859" class="lc ir hi ky b fi ld le l lf lg">import java.sql.Date;<br/>import java.time.LocalDate;</span><span id="b18c" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="789e" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="59e6" class="lc ir hi ky b fi lh le l lf lg">LocalDate ldate = LocalDate.now();<br/>        Date date = Date.valueOf(ldate);<br/>        System.out.println("Date :" + date);<br/>        System.out.println(date.getClass());</span><span id="e191" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="ee6b" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/9649f76f192ead2db7bc8322e9951b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*OVs0W-h3aHgWD6JaRb8L8g.png"/></div></figure></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><h1 id="b7e5" class="iq ir hi bd is it mw iv iw ix mx iz ja jb my jd je jf mz jh ji jj na jl jm jn bi translated">Java日期时间API</h1><p id="dc42" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在Java 8中，oracle决定引入新的类来管理日期和时间，以解决java.util.Date和java.util.Calendar中存在的问题。</p><p id="a5d5" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">在迁移新的Java日期时间API之前，我们应该对现有的日期时间API存在的问题有所了解。</p><ul class=""><li id="e756" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">线程安全——日历和日期类不是线程安全的。然后，开发人员必须添加处理线程安全的代码。调试并发问题非常复杂。为了解决这些问题，oracle在Java 8新的日期和时间API中增加了线程安全性和不变性。</li><li id="d0f9" class="lp lq hi jq b jr nh jv ni jz nj kd nk kh nl kl lu lv lw lx bi translated">API设计和易于理解——日期和日历API的设计很差，没有足够的方法来执行日常操作。新的日期/时间API是以ISO为中心的，并遵循一致的日期、时间、持续时间和周期的域模型。有各种各样的实用方法支持最常见的操作。</li><li id="0a7d" class="lp lq hi jq b jr nh jv ni jz nj kd nk kh nl kl lu lv lw lx bi translated">时区日期和时间——使用旧的API，开发人员必须实现额外的逻辑来管理时区。但是oracle引入了新的本地和时区日期/时间API来管理时区问题。</li></ul><p id="5531" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">让我们了解一下新的日期和时间API中常用的类。</p><h2 id="553a" class="lc ir hi bd is md me mf iw mg mh mi ja jz mj mk je kd ml mm ji kh mn mo jm mp bi translated">Java本地日期</h2><p id="cc8f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这个类可以在java.time包中找到。这是一个不可变的类。它用默认的ISO格式yyyy-mm-dd(年-月-日)表示日期。这个类是用final修饰符修改的。当不需要在上下文中显式指定时区时，使用此类。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/06b1c62b5a979a5b1c9b1ec216d4b716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GvoNBwhoDgK9BV32Qk_IDw.png"/></div></div></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/22d55f6263d75c033b4d7d9395f858b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JQhMLDYlmoHHrskGxa8bEg.png"/></div></div></figure><p id="797f" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">我不期望讨论LocalDate类中的所有方法。我将主要关注作为一名软件工程师你可能知道的最常用和最有用的方法。</p><p id="ed4a" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这是用于获取当前日期的方法。这使用本地主机日期。</p><ul class=""><li id="d4b8" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">LocalDate.now()</li></ul><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="0e28" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalDate;</span><span id="62c9" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="db3a" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="84ce" class="lc ir hi ky b fi lh le l lf lg">LocalDate date = LocalDate.now();<br/>        System.out.println("Current Date: "+date);</span><span id="fc89" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="04de" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es no"><img src="../Images/039a9015346c43aaff72f443aa0e5672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*yroVi2LLRS4kljnfl_nDjw.png"/></div></figure><ul class=""><li id="0c7a" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">getMonth()、getDayOfMonth() &amp; getDayOfWeek()</li></ul><p id="455e" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">getMonth →这是一个用于获取当前月份的实例方法。</p><p id="16be" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">getDaysOfMonth →这是一个实例方法，用于获取当前月份的日期。</p><p id="3ce3" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">getDayOfWeek →这也是一个实例方法，用于获取一周中的某一天。这将返回DayOfWeek对象。所以您应该使用toString方法将其转换为字符串。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="36d8" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalDate;</span><span id="890e" class="lc ir hi ky b fi lh le l lf lg">import java.time.LocalDate;</span><span id="27a9" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="7fb2" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="1d18" class="lc ir hi ky b fi lh le l lf lg">LocalDate date = LocalDate.now();<br/>        String month = date.getMonth().toString();<br/>        String weekday = date.getDayOfWeek().toString();<br/>        int days = date.getDayOfMonth();<br/>        System.out.println("Days for " + month + " : " + days + " &amp; It is :" + weekday);</span><span id="fc85" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="d2fb" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es np"><img src="../Images/bdbcedf92b76ace10dc1d08175472f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UTGn4VXsjeh7d-PiogOxdQ.png"/></div></div></figure><ul class=""><li id="0a49" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">()的LocalDate.of</li></ul><p id="e045" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这是一个静态方法，我们可以通过使用方法的LocalDate .来获取代表特定日、月、年的<em class="ly"> </em> LocalDate。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="42e7" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalDate;<br/>import java.time.Month;<br/>public class A {</span><span id="f92e" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="ead5" class="lc ir hi ky b fi lh le l lf lg">LocalDate date = LocalDate.of(1998, Month.NOVEMBER, 21);<br/>        String week = date.getDayOfWeek().toString();<br/>        System.out.println(date + " &amp; It is : " + week);<br/>    }<br/>}</span></pre><p id="aa17" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es nq"><img src="../Images/eef46713cb09e9a4126bbbeb027b61d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*CqwuGVkfkQwq0TPR-c1DGg.png"/></div></figure><ul class=""><li id="5c1a" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">isLeapYear()</li></ul><p id="c9ea" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">寻找闰年是开发人员面临的最常见的问题。所以我们必须写一个额外的代码来找到它。但是在Java 8中，他们包含了一个解决这个问题的方法。这是一个返回布尔值的实例方法。此方法根据ISO预测日历系统规则检查当前年份是否是闰年。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="9a98" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalDate;</span><span id="7155" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="a4bf" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="e291" class="lc ir hi ky b fi lh le l lf lg">LocalDate date = LocalDate.now();<br/>        boolean result = date.isLeapYear();<br/>        System.out.println(date.getYear() + "  is Leap year : " + result);<br/>    }<br/>}</span></pre><p id="27e0" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es nr"><img src="../Images/2b92ba0c6bf4d24e96dea614ae5d0216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*i17ISy3cZgYxbor8rncjkA.png"/></div></figure><ul class=""><li id="bc43" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">多日(长l)和少日(长l)</li></ul><p id="fb01" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这些也是返回LocalDate的实例方法。这些方法用于获取即将到来的日期和以前的日期。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="a6a4" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalDate;</span><span id="e486" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="6d3b" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="50f1" class="lc ir hi ky b fi lh le l lf lg">LocalDate date = LocalDate.now();<br/>        LocalDate tomoorow = date.plusDays(1);<br/>        System.out.println("Tommorow is : " + tomoorow);</span><span id="7b4c" class="lc ir hi ky b fi lh le l lf lg">LocalDate yesterday = date.minusDays(1);<br/>        System.out.println("Yesterday is : " + yesterday);<br/>    }<br/>}</span></pre><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es ns"><img src="../Images/c1658d30528e7416f16d5f344926bece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*m6NrfkM2d7AOzCKxzan2tg.png"/></div></figure><p id="dd1a" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">如上所述，你可以加上或减去一周、一月或一年，得到下一周、一月、一年，以及上一周、一月和一年。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="2695" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalDate;</span><span id="298e" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="85ec" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="10dc" class="lc ir hi ky b fi lh le l lf lg">LocalDate date = LocalDate.now();<br/>        LocalDate nextweek = date.plusWeeks(1);<br/>        LocalDate nextmonth = date.plusMonths(1);<br/>         LocalDate nextyear = date.plusYears(1);<br/>        System.out.println("next week is : " + nextweek);<br/>        System.out.println("next month is : " + nextmonth);<br/>        System.out.println("next year is : " + nextyear);<br/>         <br/>        LocalDate previousweek = date.minusWeeks(1);<br/>        LocalDate previousmonth = date.minusMonths(1);<br/>         LocalDate previousyear = date.minusYears(1);<br/>        System.out.println("previous week is : " + previousweek);<br/>        System.out.println("previous month is : " + previousmonth);<br/>        System.out.println("previous year is : " + previousyear);<br/>    }<br/>}</span></pre><p id="cb6f" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es nt"><img src="../Images/d524b46044e658b3b66ce90cb4262e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*ZEKeBbZxCZNVTHG0a5_snA.png"/></div></figure><ul class=""><li id="ef19" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">isBefore()</li></ul><p id="cdab" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">此方法检查一个给定的日期是否在另一个给定的指定日期之前。这将返回一个布尔值。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="801e" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalDate;<br/>import java.time.Month;</span><span id="86de" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="0765" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="25a0" class="lc ir hi ky b fi lh le l lf lg">        LocalDate date1 = LocalDate.of(2022, Month.OCTOBER, 30);<br/>        LocalDate date2 = LocalDate.of(2023, Month.MARCH, 10);<br/>        boolean result = date1.isBefore(date2);</span><span id="039e" class="lc ir hi ky b fi lh le l lf lg">System.out.println(date1 + " is before " + date2 + " : " + result);</span><span id="79db" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><ul class=""><li id="f0d2" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">isAfter()</li></ul><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="423a" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalDate;<br/>import java.time.Month;</span><span id="e408" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="ec42" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="5e5b" class="lc ir hi ky b fi lh le l lf lg">LocalDate date1 = LocalDate.of(2022, Month.OCTOBER, 30);<br/>        LocalDate date2 = LocalDate.of(2023, Month.MARCH, 10);<br/>        boolean result = date1.isAfter(date2);</span><span id="3394" class="lc ir hi ky b fi lh le l lf lg">System.out.println(date1 + " is after " + date2 + " : " + result);</span><span id="e5c5" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="db4b" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nu"><img src="../Images/cc7855ba7d6a84c92ff1cb73e645a118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJOJsXrgdHwPXXSoW7PBmw.png"/></div></div></figure><p id="5eca" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">在LocalDate类中可以找到很多方法。所以可以参考其他方法作为作业。</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><h1 id="b7d4" class="iq ir hi bd is it mw iv iw ix mx iz ja jb my jd je jf mz jh ji jj na jl jm jn bi translated">当地时间</h1><p id="f4e4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这个类可以在java.time包中找到。这是一个不可变的类。它表示时间，默认格式为hh-MM-ss(小时-分钟-秒)。这个类是用final修饰符修改的。这类似于LocalDate类。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/503b33fb9a3c405300aa6de84c25f5e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RBDJcccJd27ar1IncJDchA.png"/></div></div></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nv"><img src="../Images/f7e0cfd926ec52b7869c2b9e18935abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utnkU-5DWeIr13mI4oqESg.png"/></div></div></figure><p id="f468" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">您可以从系统时钟创建一个当前本地时间的实例。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="7a09" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalTime;</span><span id="2490" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="f861" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="6ec6" class="lc ir hi ky b fi lh le l lf lg">LocalTime localTime = LocalTime.now();<br/>        System.out.println(localTime);</span><span id="daf7" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="bf91" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es nw"><img src="../Images/344e7af7f5b8a4dc6849ac188135c5ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*etRSuQJ490E27L8zQb9iVQ.png"/></div></figure><ul class=""><li id="0a52" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">LocalTime.of(int 1，int 2，int 3)</li></ul><p id="d2a1" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这是一个静态方法，我们可以通过使用方法的LocalTime .来获取代表特定小时、分钟和秒的<em class="ly"> </em> LocalTime。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="2ffd" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalTime;</span><span id="44d1" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="7ba7" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="b167" class="lc ir hi ky b fi lh le l lf lg">LocalTime localTime = LocalTime.of(05, 30, 20);<br/>        System.out.println(localTime);</span><span id="1285" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="3e0c" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es nx"><img src="../Images/35da165936e03432ca02aeea26dbe240.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*m9gsxlny4hiMQWPIXmDafg.png"/></div></figure><ul class=""><li id="b8a2" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">plusHour(长l)和plusMinutes</li></ul><p id="496d" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这用于计算几小时和几分钟后的时间。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="4849" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalTime;</span><span id="5d37" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="484a" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="fab4" class="lc ir hi ky b fi lh le l lf lg">LocalTime localTime = LocalTime.now();<br/>        LocalTime hour = localTime.plusHours(1);<br/>        LocalTime minute = localTime.plusMinutes(30);</span><span id="4a79" class="lc ir hi ky b fi lh le l lf lg">System.out.println("Time After a Hour : " + hour);<br/>        System.out.println("Time After 30 minutes : " + minute);</span><span id="9015" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="8d20" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ny"><img src="../Images/707eed9b7ecc5acad883eb7afe54fc9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WyFeAABFs_Yx3Pnx2JFVKw.png"/></div></div></figure><ul class=""><li id="6927" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">minusHour(长l)和minusMinutes(长l)</li></ul><p id="2ed9" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这用于计算几小时和几分钟之前的时间。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="b92a" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalTime;</span><span id="ead4" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="7782" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="8a60" class="lc ir hi ky b fi lh le l lf lg">LocalTime localTime = LocalTime.now();<br/>        LocalTime hour = localTime.minusHours(1);<br/>        LocalTime minute = localTime.minusMinutes(30);</span><span id="84e0" class="lc ir hi ky b fi lh le l lf lg">System.out.println("Time before a Hour : " + hour);<br/>        System.out.println("Time before 30 minutes : " + minute);</span><span id="5bdc" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><h1 id="0eb0" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">本地日期时间</h1><p id="1924" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这个类可以在java.time包中找到。这是一个不可变的类。它表示日期和时间，默认格式为yyyy-MM-dd-HH-mm-ss.zzz(年-月-日-小时-分钟-秒)。这个类是用final修饰符修改的。当不需要在上下文中显式指定时区时，使用此类。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/6ef8cd55b736ca98378178c0160bda08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ggI7d19iDqPtbcfw83bWRA.png"/></div></div></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nz"><img src="../Images/6eee347d4e80caf5764c1c8e7081865c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JrTVzhBVy08EWyREVKdf2Q.png"/></div></div></figure><p id="acb5" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">可以从类似于LocalDate和LocalTime的系统时钟中获得LocalDateTime的实例。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="c187" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalDateTime;</span><span id="099e" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="5b75" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="ea6a" class="lc ir hi ky b fi lh le l lf lg">LocalDateTime dateTime=LocalDateTime.now();<br/>        System.out.println(dateTime);<br/>    }<br/>}</span></pre><p id="9d80" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es oa"><img src="../Images/a8242d1c363708c833abf592f0a3d81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*smqwycOZbzdzbil-V2m0Cw.png"/></div></figure><ul class=""><li id="2fc0" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">LocalDateTime of(int i，Month month，int i1，int i2，int i3)</li></ul><p id="6de1" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这是一个静态方法，我们可以通过使用LocalDateTime.of方法得到代表特定的日、月、年、小时和分钟的<em class="ly"> </em> LocalDateTime。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="71a7" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalDateTime;<br/>import java.time.Month;</span><span id="4c4f" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="cdd1" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="5fa8" class="lc ir hi ky b fi lh le l lf lg">LocalDateTime dateTime = LocalDateTime.of(2022, Month.NOVEMBER, 21, 10, 19);<br/>        System.out.println(dateTime);<br/>    }<br/>}</span></pre><p id="c8f2" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es ob"><img src="../Images/085f7c773273cf5e6abc2187371a6e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*ik_GAJpUufP6CcReLqWskQ.png"/></div></figure><p id="4ba4" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">您可以使用格式化程序来格式化日期。</p><ul class=""><li id="6337" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">datetime formatter dtf = datetime formatter . of pattern(" yyyy-MM-DD hh:MM ")；</li></ul><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="359a" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalDateTime;<br/>import java.time.Month;<br/>import java.time.format.DateTimeFormatter;</span><span id="4737" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="7553" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="8b92" class="lc ir hi ky b fi lh le l lf lg">DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm");<br/>        LocalDateTime dateTime = LocalDateTime.of(2022, Month.NOVEMBER, 21, 10, 19);<br/>        String i = dateTime.format(dtf);<br/>        System.out.println(i);</span><span id="3958" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="fc75" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es oc"><img src="../Images/b1381903a4fc949fc37bb086b4cd20ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*GXpOWutUkYoZAxz1zXMQNA.png"/></div></figure><ul class=""><li id="a8ad" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">添加月份、年份、日期、小时或分钟</li></ul><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="5d3f" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalDateTime;<br/>import java.time.Month;<br/>import java.time.format.DateTimeFormatter;</span><span id="6e45" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="25f8" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="40ae" class="lc ir hi ky b fi lh le l lf lg">DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm");<br/>        LocalDateTime dateTime = LocalDateTime.of(2022, Month.NOVEMBER, 21, 10, 19, 22).plusDays(2);<br/>        String i = dateTime.format(dtf);<br/>        System.out.println("After adding two days : " + i);</span><span id="142d" class="lc ir hi ky b fi lh le l lf lg">LocalDateTime ph = LocalDateTime.of(2022, Month.NOVEMBER, 21, 10, 19, 22).plusHours(2);<br/>        String i1 = ph.format(dtf);<br/>        System.out.println("After adding two hours : " + i1);</span><span id="a767" class="lc ir hi ky b fi lh le l lf lg">LocalDateTime py = LocalDateTime.of(2022, Month.NOVEMBER, 21, 10, 19, 22).plusYears(2);<br/>        String i2 = py.format(dtf);<br/>        System.out.println("After adding two years : " + i2);</span><span id="762b" class="lc ir hi ky b fi lh le l lf lg">LocalDateTime pm = LocalDateTime.of(2022, Month.NOVEMBER, 21, 10, 19, 22).plusMinutes(30);<br/>        String i3 = pm.format(dtf);<br/>        System.out.println("After adding 30 minutes : " + i3);</span><span id="26de" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="c734" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es od"><img src="../Images/946cedbed055dc98ff1f13eb6dcc75c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sCAayjo2sfGzKE-ChknikQ.png"/></div></div></figure><ul class=""><li id="375e" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">getMinute()、getHour()、getDayOfWeek()、getMonthValue()、getMonth()、getDayOfMonth()、getYear()、getDayOfYear()</li></ul><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="6bb6" class="lc ir hi ky b fi ld le l lf lg">import java.time.LocalDateTime;</span><span id="61ae" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="f324" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="3c25" class="lc ir hi ky b fi lh le l lf lg">LocalDateTime dateTime = LocalDateTime.now();<br/>        int minutes = dateTime.getMinute();<br/>        System.out.println("minutes pass in current hour : " + minutes);</span><span id="f3c7" class="lc ir hi ky b fi lh le l lf lg">int hour = dateTime.getHour();<br/>        System.out.println("Hour : " + hour);</span><span id="4c12" class="lc ir hi ky b fi lh le l lf lg">String week = dateTime.getDayOfWeek().toString();<br/>        System.out.println("day of the week : " + week);</span><span id="66ba" class="lc ir hi ky b fi lh le l lf lg">int monthValue = dateTime.getMonthValue();<br/>        String month = dateTime.getMonth().toString();<br/>        int daycountmonth = dateTime.getDayOfMonth();<br/>        System.out.println("This is : " + month + " &amp; value is : " + monthValue + " contains days " + daycountmonth);</span><span id="1c91" class="lc ir hi ky b fi lh le l lf lg">int year = dateTime.getYear();<br/>        int daycountyear = dateTime.getDayOfYear();<br/>        System.out.println("year : " + year + "is contains " + daycountyear + " days");</span><span id="c0e8" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="9633" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oe"><img src="../Images/c9d1387ec46604773d4b946350a3cd95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVDHVtVQrxqY6Ph_ABxo5w.png"/></div></div></figure><p id="592d" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这些是LocalDateTime类中最常用的方法。有很多方法可以处理不同类型的与任务相关的日期和时间。</p><h1 id="714b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">ZonedDateTime API</h1><p id="ea25" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Java ZonedDateTime类是带有时区的日期时间的不可变表示。当我们需要处理特定时区的日期和时间时，我们可以使用ZonedDateTime API。这个类是用final修饰符修改的。</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es of"><img src="../Images/78ec767e8b2c835db2f111954b785216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I57tBgor9l4a2oQptxpQcw.png"/></div></div></figure><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es og"><img src="../Images/d676d02d52791298df24c8d53f6f05a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4IbQSeTaphDrjLfTpDh-Tg.png"/></div></div></figure><ul class=""><li id="a78f" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">ZonedDateTime.now()</li></ul><p id="6fe9" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这是一个静态方法，它返回ZonedDateTime对象，并从默认时区的系统时钟中获取当前日期时间。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="33b5" class="lc ir hi ky b fi ld le l lf lg">import java.time.ZonedDateTime;</span><span id="e109" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="51be" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="bbe3" class="lc ir hi ky b fi lh le l lf lg">ZonedDateTime zdt = ZonedDateTime.now();<br/>        System.out.println(zdt);</span><span id="6c37" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="b242" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oh"><img src="../Images/f5994dabebae1b1b9a190564eb72e160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZ7KppY_Wr9BYfqyqmuxkA.png"/></div></div></figure><p id="2cff" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">您可以根据需要使用ZoneId类创建一个时区。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="931b" class="lc ir hi ky b fi ld le l lf lg">import java.time.ZoneId;<br/>import java.time.ZonedDateTime;</span><span id="95c4" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="7571" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="5378" class="lc ir hi ky b fi lh le l lf lg">      ZoneId zoneId = ZoneId.of("Europe/Paris");<br/>        System.out.println(zoneId);</span><span id="c54e" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="03ca" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">使用下面的链接，您可以找到可用的时区。</p><p id="8aab" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated"><a class="ae oi" href="https://docs.oracle.com/middleware/1221/wcs/tag-ref/MISC/TimeZones.html" rel="noopener ugc nofollow" target="_blank">T1】https://docs . Oracle . com/middleware/1221/wcs/tag-ref/MISC/time zones . htmlT3】</a></p><p id="5a49" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">你也可以使用下面的代码来生成时区id。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="9d3c" class="lc ir hi ky b fi ld le l lf lg">import java.time.ZoneId;<br/>import java.util.Set;</span><span id="5648" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="71ed" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="1887" class="lc ir hi ky b fi lh le l lf lg">Set&lt;String&gt; allZoneIds = ZoneId.getAvailableZoneIds();</span><span id="bfb1" class="lc ir hi ky b fi lh le l lf lg">for (String allZoneId : allZoneIds) {<br/>            System.out.println("time zone : " + allZoneId);<br/>        }</span><span id="7399" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="f626" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">在创建一个ZoneID对象后，使用它作为一个参数，现在，这个方法在ZoneDateTime.now()方法中。然后，您可以获得与您作为参数传递的时区相关的时间和日期。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="d8dc" class="lc ir hi ky b fi ld le l lf lg">import java.time.ZoneId;<br/>import java.time.ZonedDateTime;</span><span id="38f1" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="0e2f" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="0270" class="lc ir hi ky b fi lh le l lf lg">ZoneId zoneId = ZoneId.of("Europe/Paris");<br/>        ZonedDateTime time = ZonedDateTime.now(zoneId);<br/>        System.out.println(time);</span><span id="55fa" class="lc ir hi ky b fi lh le l lf lg">}<br/>}</span></pre><p id="d4c0" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oj"><img src="../Images/4eb425fc022033d28746c112b9ea53f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6aZFBU0YBSnH0D7s4CVCDw.png"/></div></div></figure><ul class=""><li id="4a23" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">getZone()</li></ul><p id="c262" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这是根据ZoneDateTime对象返回时区的方法。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="e565" class="lc ir hi ky b fi ld le l lf lg">import java.time.ZonedDateTime;</span><span id="7374" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="844f" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="bfe4" class="lc ir hi ky b fi lh le l lf lg">ZonedDateTime zdt=ZonedDateTime.now();<br/>        String zone=zdt.getZone().toString();<br/>        System.out.println(zone);<br/>    }<br/>}</span></pre><p id="5fe6" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">输出:</p><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es ok"><img src="../Images/ce054179cfb7ffb1e6c2628078e5c132.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*nNUAwOQb07pmCn7OnN3NwA.png"/></div></figure><ul class=""><li id="3a5b" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">减号()和加号()</li></ul><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="f780" class="lc ir hi ky b fi ld le l lf lg">import java.time.Period;<br/>import java.time.ZonedDateTime;</span><span id="c20d" class="lc ir hi ky b fi lh le l lf lg">public class A {</span><span id="a5c0" class="lc ir hi ky b fi lh le l lf lg">public static void main(String[] args) {</span><span id="1db2" class="lc ir hi ky b fi lh le l lf lg">ZonedDateTime zdt = ZonedDateTime.now();<br/>        String plus = zdt.plus(Period.ofMonths(1)).toString();<br/>        String minus = zdt.minus(Period.ofMonths(1)).toString();<br/>    }<br/>}</span></pre><p id="9aa6" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这些是ZoneDateTime类中最常用的方法。</p><h1 id="6085" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Joda-Time</h1><p id="92b4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Joda-Time API由Joda org开发。在Java 8发布之前，Joda-Time是最常用的日期和时间处理库。它的目的是为处理日期和时间提供一个直观的API，并解决Java日期/时间API中存在的设计问题。这是Java 8随Java附带的。时间包。Joda-Time使用不可变的类来处理日期和时间。所以对象是线程安全的。</p><p id="a0a1" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">它支持7种日历系统，如佛教，科普特语，埃塞俄比亚语，公历，公历，伊斯兰教和儒略历。</p><p id="e490" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">您可以将它集成到您的项目中。您可以将Joda-Time库作为Maven central的依赖项添加到项目中。</p><pre class="kn ko kp kq fd kx ky kz la aw lb bi"><span id="078f" class="lc ir hi ky b fi ld le l lf lg">&lt;dependency&gt;    <br/>  &lt;groupId&gt;joda-time&lt;/groupId&gt;     <br/>  &lt;artifactId&gt;joda-time&lt;/artifactId&gt;     <br/>  &lt;version&gt;2.10&lt;/version&gt; <br/>&lt;/dependency&gt;</span></pre><p id="a7c9" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">使用Joda-Time有很多好处</p><ul class=""><li id="1db4" class="lp lq hi jq b jr ks jv kt jz lr kd ls kh lt kl lu lv lw lx bi translated">跨多个Java平台的类似用法。</li><li id="ac99" class="lp lq hi jq b jr nh jv ni jz nj kd nk kh nl kl lu lv lw lx bi translated">elf-报告了更好的性能。</li><li id="460f" class="lp lq hi jq b jr nh jv ni jz nj kd nk kh nl kl lu lv lw lx bi translated">支持额外的日历，如佛教和埃塞俄比亚。</li></ul><h2 id="67aa" class="lc ir hi bd is md me mf iw mg mh mi ja jz mj mk je kd ml mm ji kh mn mo jm mp bi translated">谢谢大家！</h2></div></div>    
</body>
</html>