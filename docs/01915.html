<html>
<head>
<title>You already know Monads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你已经知道单子了</h1>
<blockquote>原文：<a href="https://medium.com/codex/you-already-know-monads-2065f6309971?source=collection_archive---------7-----------------------#2021-06-14">https://medium.com/codex/you-already-know-monads-2065f6309971?source=collection_archive---------7-----------------------#2021-06-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6a87" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不会解释单子背后的抽象理论，我只会向您展示一些您已经理解的Java代码。使用这种实用的方法，你会意识到你很可能已经使用过几次单子了。</p><p id="e8ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哦，如果你更喜欢听我说，这篇文章是基于我的一个简短演讲，我试图在7分钟内解释清楚。</p><h1 id="13c7" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">单子是什么？</h1><p id="5585" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">单子只是实现以下两个方法的类:</p><ul class=""><li id="6a20" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><code class="du kq kr ks kt b"><a class="ae jd" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#of-T...-" rel="noopener ugc nofollow" target="_blank">of</a></code>(在解释中通常称为<code class="du kq kr ks kt b">unit</code>或<code class="du kq kr ks kt b">return</code>)和</li><li id="d5b8" class="kh ki hi ih b ii ku im kv iq kw iu kx iy ky jc km kn ko kp bi translated"><code class="du kq kr ks kt b"><a class="ae jd" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#flatMap-java.util.function.Function-" rel="noopener ugc nofollow" target="_blank">flatMap</a></code>(通常称为<code class="du kq kr ks kt b">bind</code>)</li></ul><p id="6c35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du kq kr ks kt b">of</code>应该简单地接受一些值并返回一个包装器(单子)。<code class="du kq kr ks kt b">flatMap</code>然后允许通过对所有这些值应用一个函数来访问这些值，获取这些函数返回的单子，并再次将它们组合(也称为“展平”)成一个。</p><p id="d73b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">利用这一点，最简单的单子如下:</p><pre class="kz la lb lc fd ld kt le lf aw lg bi"><span id="664a" class="lh jf hi kt b fi li lj l lk ll">public class Monad&lt;T&gt; {<br/>    private T value;</span><span id="b449" class="lh jf hi kt b fi lm lj l lk ll">    private Monad(T value) {<br/>        this.value = value;<br/>    }</span><span id="a590" class="lh jf hi kt b fi lm lj l lk ll">    public static &lt;T&gt; Monad&lt;T&gt; of(T value) {<br/>        return new Monad&lt;&gt;(value);<br/>    }</span><span id="1454" class="lh jf hi kt b fi lm lj l lk ll">    public&lt;R&gt; Monad&lt;R&gt; flatMap(Function&lt;T, Monad&lt;R&gt;&gt; f){<br/>        return f.apply(value);<br/>    }<br/>}</span></pre><h2 id="a3d0" class="lh jf hi bd jg ln lo lp jk lq lr ls jo iq lt lu js iu lv lw jw iy lx ly ka lz bi translated">就这样吗？</h2><p id="c386" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">大部分是这样，但是很明显你不能用一种特定的方式命名这些方法，并且有一个单子。这两种方法需要如何协同工作是有规则的。</p><p id="d614" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好消息是，如果你像上面描述的那样实现了这些方法(正如他们通常理解的那样)，你就已经实现了所有这些方法。但不管怎样，它们都在这里:</p><ol class=""><li id="f367" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc ma kn ko kp bi translated"><code class="du kq kr ks kt b">of</code>方法是<code class="du kq kr ks kt b">flatMap</code>的<strong class="ih hj">左标识</strong>，</li><li id="ecf3" class="kh ki hi ih b ii ku im kv iq kw iu kx iy ky jc ma kn ko kp bi translated"><code class="du kq kr ks kt b">of</code>方法是<code class="du kq kr ks kt b">flatMap</code>的<strong class="ih hj">权限标识</strong></li><li id="1e9e" class="kh ki hi ih b ii ku im kv iq kw iu kx iy ky jc ma kn ko kp bi translated"><code class="du kq kr ks kt b">flatMap</code>方法是<strong class="ih hj">关联</strong>。</li></ol><p id="7ca4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，在代码中:</p><pre class="kz la lb lc fd ld kt le lf aw lg bi"><span id="166e" class="lh jf hi kt b fi li lj l lk ll">// using<br/>Monad&lt;V&gt; m;<br/>V x;<br/>Function&lt;V, Monad&lt;V&gt;&gt; f;<br/>Function&lt;V, Monad&lt;V&gt;&gt; g;</span><span id="23ef" class="lh jf hi kt b fi lm lj l lk ll">// rule 1: of is left-identity of flatMap<br/>of(x).flatMap(f) .equals(f.apply(x))</span><span id="6cbb" class="lh jf hi kt b fi lm lj l lk ll">// rule 2<br/>m.flatMap(Monad::of) .equals(m)</span><span id="7618" class="lh jf hi kt b fi lm lj l lk ll">// rule 3<br/>m.flatMap(f).flatMap(h)<br/>    .equals(m.flatMap(v -&gt; g.apply(v).flatmap(h)))</span></pre><h1 id="7292" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">我为什么要在乎？</h1><p id="7500" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">现在你知道了单子是什么，以及如何创建单子，但是为什么它还有一个名字呢？</p><p id="915b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你使用的是一种功能强大的语言，那么这甚至不是一个真正的问题，因为你在进行功能性编程时会遇到的工具和问题很可能会自然地导致你创建一些单子。单子最初就是从那里来的。</p><p id="0d95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，它们在这些语言之外也非常有用，事实上许多新的API都有单子的特性。</p><h2 id="9829" class="lh jf hi bd jg ln lo lp jk lq lr ls jo iq lt lu js iu lv lw jw iy lx ly ka lz bi translated">在您的域中包含(错误)状态</h2><p id="55a9" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">最好的API试图阻止你犯错。实现这一点的方法之一是在其返回值中显式包含错误状态。当一行中的多个函数调用可能返回错误时，这还有一个额外的好处，就是使结果代码更漂亮。</p><p id="97b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个使用Optional的例子:</p><pre class="kz la lb lc fd ld kt le lf aw lg bi"><span id="f659" class="lh jf hi kt b fi li lj l lk ll">public Optional&lt;Integer&gt; doSomething(Stream&lt;Integer&gt; stream) {<br/>    return stream<br/>        .findFirst()<br/>        .flatMap(this::integerHalf)<br/>        .flatMap(v -&gt; Optional.of(v*5));<br/>}</span><span id="21ca" class="lh jf hi kt b fi lm lj l lk ll">public Optional&lt;Integer&gt; integerHalf(Integer i) {<br/>    if (i%2 == 0) {<br/>        return Optional.of(i/2);<br/>    } else {<br/>        return Optional.empty();<br/>    }<br/>}</span></pre><p id="d8e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，我们不仅可以选择在任何时候返回一个“错误”,而且之后我们不必立即检查它。相反，这可以在稍后的点<em class="mb">完成。</em></p><p id="16bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单子也可以用来处理非错误状态。这经常在集合或异步编程中使用(见<code class="du kq kr ks kt b"><a class="ae jd" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" rel="noopener ugc nofollow" target="_blank">CompletableFuture</a></code>)，在那里它也可以防止回调。</p><h2 id="dd45" class="lh jf hi bd jg ln lo lp jk lq lr ls jo iq lt lu js iu lv lw jw iy lx ly ka lz bi translated">允许使用更通用的函数</h2><p id="b4c4" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">以上面的函数<code class="du kq kr ks kt b">integerHalf</code>为例:我们可以对普通整数使用这个函数，也可以对任何单子使用这个函数，比如使用<code class="du kq kr ks kt b">flatMap</code>方法的<code class="du kq kr ks kt b">Optional</code>或<code class="du kq kr ks kt b">Stream</code>。</p><p id="171c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种在不离开Monad域的情况下访问底层信息的便利性可以创建惊人的API，防止许多错误。</p><h1 id="bba7" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">你知道一些单子吗？</h1><p id="d01d" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我已经提到了Java中三种最常见的单子:</p><ul class=""><li id="9dbd" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated"><code class="du kq kr ks kt b">Optional</code>，</li><li id="75eb" class="kh ki hi ih b ii ku im kv iq kw iu kx iy ky jc km kn ko kp bi translated"><code class="du kq kr ks kt b">Stream</code>和</li><li id="b60d" class="kh ki hi ih b ii ku im kv iq kw iu kx iy ky jc km kn ko kp bi translated"><code class="du kq kr ks kt b">CompletableFuture</code></li></ul><p id="e1e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但我相信你已经遇到更多了。如果你知道另一个好例子，请发表评论。</p><h1 id="bfa0" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">更多链接</h1><ul class=""><li id="ba7f" class="kh ki hi ih b ii kc im kd iq mc iu md iy me jc km kn ko kp bi translated"><a class="ae jd" href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" rel="noopener ugc nofollow" target="_blank">可能是单子(以及函子和应用程序)背后理论的最佳解释——附图片！</a></li><li id="8bdf" class="kh ki hi ih b ii ku im kv iq kw iu kx iy ky jc km kn ko kp bi translated"><a class="ae jd" href="https://stackoverflow.com/questions/28139259/why-do-we-need-monads/28139260#28139260" rel="noopener ugc nofollow" target="_blank">很好地解释了为什么函数式编程时单子会自然出现</a></li><li id="f69f" class="kh ki hi ih b ii ku im kv iq kw iu kx iy ky jc km kn ko kp bi translated"><a class="ae jd" href="https://www.youtube.com/watch?v=w0fhQCzy2g0&amp;t=1308s" rel="noopener ugc nofollow" target="_blank">我的7分钟闪电谈这个话题</a></li></ul><figure class="kz la lb lc fd mg er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es mf"><img src="../Images/70471ed6638347b7b09e1215481ff337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZBl7GSRnm4FQ2tiyyqG_Q.jpeg"/></div></div><figcaption class="mn mo et er es mp mq bd b be z dx translated">单子的精确图像(摄影:<a class="ae jd" href="https://burst.shopify.com/@ndekhors" rel="noopener ugc nofollow" target="_blank">妮可·德·霍尔斯</a></figcaption></figure></div></div>    
</body>
</html>