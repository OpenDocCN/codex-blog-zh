<html>
<head>
<title>Communicating API Resource Creation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">交流API资源创建</h1>
<blockquote>原文：<a href="https://medium.com/codex/communicating-resource-creation-60893f108623?source=collection_archive---------24-----------------------#2021-08-02">https://medium.com/codex/communicating-resource-creation-60893f108623?source=collection_archive---------24-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/599d70c3302b8b37fc1ad72d29d3a251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YfGT126wjhBeDvO2"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@deviyahya?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Devi Puspita Amartha Yahya </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d88f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<a class="ae iu" href="https://dillonredding.medium.com/the-empty-search-result-anti-pattern-f23c140ab871" rel="noopener">我的上一篇文章</a>之后，我想我应该再写一篇关于HTTP礼仪的文章，这一次是关于API中常见的误用<code class="du jt ju jv jw b"><a class="ae iu" href="https://datatracker.ietf.org/doc/html/rfc7231#section-6.3.2" rel="noopener ugc nofollow" target="_blank">201 (Created)</a></code>状态代码。这可能有点棘手，因为虽然您可能正确地使用了状态代码本身，但是消息的另一部分可能有您可能没有意识到的含义。</p><p id="17b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我看到的最常用的方式是响应向集合追加项目的<code class="du jt ju jv jw b">POST</code>请求。大概是这样的:</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="232b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在<code class="du jt ju jv jw b">/books</code>有一个收藏，我们想给它添加一本书。典型的反应通常很简单:</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="b6bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在响应中，我们通常在表示中获得某种服务器生成的标识符(在上面的例子中是<code class="du jt ju jv jw b">id</code>)。这与HTTP无关，但是我们的API通常试图传达的是在<code class="du jt ju jv jw b">/books/1234</code>有一个新的资源，然而这种方法产生了一些问题。</p><p id="14bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，客户需要理解服务器的URL设计策略。为了以后访问新资源，他们必须知道获取标识符的值，并将其作为路径段附加到集合的URL。(如果您的媒体类型定义了这种行为，那没问题，但是我主要关注使用普通JSON的传统“REST”API。在以后的文章中会有更多的介绍。)这一要求将客户端耦合到服务器，因为<a class="ae iu" href="https://www.w3.org/DesignIssues/Axioms.html#opaque" rel="noopener ugc nofollow" target="_blank">URL是不透明的</a>，因此是服务器的实现细节。</p><p id="111d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其次，也是这篇文章的重点，是协议层面的问题。为了更好地理解这一点，让我们看看HTTP标准<a class="ae iu" href="https://datatracker.ietf.org/doc/html/rfc7231" rel="noopener ugc nofollow" target="_blank">中<code class="du jt ju jv jw b">201</code>状态代码的定义:</a></p><blockquote class="kd ke kf"><p id="ffcd" class="iv iw kg ix b iy iz ja jb jc jd je jf kh jh ji jj ki jl jm jn kj jp jq jr js hb bi translated"><em class="hi"/><code class="du jt ju jv jw b"><em class="hi">201 (Created)</em></code><em class="hi">状态代码表示请求已经完成，并导致一个或多个新资源被创建。由请求创建的主要资源由响应中的</em> <code class="du jt ju jv jw b"><em class="hi">Location</em></code> <em class="hi">报头字段标识，或者如果没有接收到</em> <code class="du jt ju jv jw b"><em class="hi">Location</em></code> <em class="hi">字段，则由有效请求URI标识。</em></p></blockquote><p id="7e45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于我们上面的响应缺少了一个<code class="du jt ju jv jw b"><a class="ae iu" href="https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.2" rel="noopener ugc nofollow" target="_blank">Location</a></code>头，我们的服务器<em class="kg">实际上</em>说的是在<code class="du jt ju jv jw b">/books</code>创建了一个新资源。显然，事实并非如此。那是我们的收藏，早就有了。因此，更合适的反应如下:</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="893a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这表示为了响应我们的请求，在<code class="du jt ju jv jw b">http://example.com/books/9781449358068</code>创建了一个新资源。我们本来可以发送回绝对URL，但是HTTP标准将<code class="du jt ju jv jw b">Location</code>头定义为一个<a class="ae iu" href="https://datatracker.ietf.org/doc/html/rfc3986#section-4.1" rel="noopener ugc nofollow" target="_blank"> URI引用</a>，当它是一个<a class="ae iu" href="https://datatracker.ietf.org/doc/html/rfc3986#section-4.2" rel="noopener ugc nofollow" target="_blank">相对引用</a>时，它是针对<a class="ae iu" href="https://datatracker.ietf.org/doc/html/rfc7230#section-5.5" rel="noopener ugc nofollow" target="_blank">有效请求URI </a> : <code class="du jt ju jv jw b">http://example.com/books</code>的<a class="ae iu" href="https://datatracker.ietf.org/doc/html/rfc3986#section-5" rel="noopener ugc nofollow" target="_blank">解析</a>。</p><p id="e637" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还可以在响应中包含表示，但是现在客户端已经有了新资源的URL，他们不需要标识符，因为这是我们在响应中添加到表示中的所有内容，所以客户端不需要它，我们在这个过程中节省了一些网络带宽。此外，我们通过减少客户端理解服务器URL的需求来放松耦合。</p><h1 id="4143" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><code class="du jt ju jv jw b">201</code>不带<code class="du jt ju jv jw b">Location</code></h1><p id="baa1" class="pw-post-body-paragraph iv iw hi ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">我们看到不包括一个<code class="du jt ju jv jw b">Location</code> <em class="kg">在技术上是有效的，但是我们什么时候想要这样做呢？一个原因是让客户控制URI，但是<em class="kg">为什么</em>我们要这么做？也许我们不想为每个资源生成一个URL。</em></p><p id="83a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回到我们的图书示例，假设我们希望允许客户端创建表示在<code class="du jt ju jv jw b">/wish-lists/{id}</code>找到的图书的期望列表的资源，但是不是服务器为<code class="du jt ju jv jw b">id</code>生成值，而是让客户端选择它。</p><p id="da70" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可能熟悉使用<code class="du jt ju jv jw b">PUT</code>来更新资源，但是根据HTTP标准(<a class="ae iu" href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.4" rel="noopener ugc nofollow" target="_blank"> RFC 7231 </a>)，一个<code class="du jt ju jv jw b">PUT</code>请求要求“目标资源是<em class="kg">创建的</em>或替换的【强调矿】”。它接着说“如果目标资源<em class="kg">没有</em>的当前表示，并且<code class="du jt ju jv jw b">PUT</code> <em class="kg">成功地创建了一个</em>，那么源服务器必须通过发送<code class="du jt ju jv jw b">201 (Created)</code>响应来通知用户代理。”因此，如果一个资源在特定的URL上不存在，可以使用一个<code class="du jt ju jv jw b">PUT</code>来创建它(假设服务器允许)。</p><p id="c5e4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，创建愿望列表的请求可能如下所示:</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="3603" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设<code class="du jt ju jv jw b">/wish-lists/classics</code>处的资源没有表示(即它不存在)，服务器创建它并通知客户机:</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="c5b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有<code class="du jt ju jv jw b">Location</code>头，这个响应表示在<a class="ae iu" href="https://datatracker.ietf.org/doc/html/rfc7230#section-5.5" rel="noopener ugc nofollow" target="_blank">有效请求URI </a> : <code class="du jt ju jv jw b">http://example.com/wish-lists/classics</code>处成功创建了资源。</p><p id="c44c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，我们的服务器可以允许类似的请求在资源被创建后<em class="kg">更新</em>资源。对于<code class="du jt ju jv jw b">PUT</code>请求，“如果目标资源<em class="kg">具有当前表示，并且该表示被成功修改[…]，那么源服务器必须发送<code class="du jt ju jv jw b">200 (OK)</code>或<code class="du jt ju jv jw b">204 (No Content)</code>响应”(RFC 7231)。</em></p><h1 id="121b" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">摘要</h1><p id="a890" class="pw-post-body-paragraph iv iw hi ix b iy li ja jb jc lj je jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">当接受<code class="du jt ju jv jw b">POST</code>来创建一个条目并将其追加到集合中时，用一个<code class="du jt ju jv jw b">201</code>来响应并包含一个<code class="du jt ju jv jw b">Location</code>头。如果你不能包含一个<code class="du jt ju jv jw b">Location</code>头(或者只是不想)，就使用一个<code class="du jt ju jv jw b">200 (OK)</code>。谎报已经存在的资源的创建是没有价值的。</p><p id="612b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，使用<code class="du jt ju jv jw b">PUT</code>创建您的资源，在这种情况下，根本不用担心发送<code class="du jt ju jv jw b">Location</code>头。</p><p id="b67a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我很乐意听到你对这篇文章的想法、评论和反馈，尤其是如果你已经看到了类似的东西。你可以通过Twitter <a class="ae iu" href="https://twitter.com/dillon_redding" rel="noopener ugc nofollow" target="_blank"> @dillon_redding </a>联系我。</p></div></div>    
</body>
</html>