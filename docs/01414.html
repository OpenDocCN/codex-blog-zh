<html>
<head>
<title>How does MDN Intercept `console.log`?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MDN如何拦截` console.log `？</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-does-mdn-intercept-console-log-27ef015f6dd4?source=collection_archive---------8-----------------------#2021-04-26">https://medium.com/codex/how-does-mdn-intercept-console-log-27ef015f6dd4?source=collection_archive---------8-----------------------#2021-04-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3c27" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这是魔法还是诡计？</h2></div><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="jc jd l"/></div><figcaption class="je jf et er es jg jh bd b be z dx translated"><a class="ae ji" href="https://www.youtube.com/watch?v=VBUEoOSj4OE" rel="noopener ugc nofollow" target="_blank">本帖视频版</a></figcaption></figure><p id="009d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae ji" rel="noopener" href="/codex/how-i-shared-my-websites-code-b35ae397ddfc">在上一篇文章</a>中，我们看到:</p><ul class=""><li id="6cf9" class="kf kg hi jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn bi translated">从WebStorm上传到GitHub</li><li id="b513" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">语义版本控制</li><li id="cafa" class="kf kg hi jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">常规提交</li></ul><p id="dde8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这篇文章中，我们想继续开发我们的代码编辑器。基本目标是创建一个框，用户可以输入一些代码，并通过触摸按钮，可以看到他们的代码的结果。</p><h1 id="0dc7" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">首次迭代行为</h1><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/c2e4e2a9a2d5ebf7a22b0dd90170b182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WiZSFMFgP3Y_bO-xe8znOA.png"/></div></div></figure><p id="37f0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">第一个实现是围绕<code class="du ls lt lu lv b">eval</code>函数设计的，其结果将显示在结果窗格中。输入字符串“hello”将导致显示<code class="du ls lt lu lv b">hello</code>。此外，分配一个变量，然后将该变量单独放在最后一行，结果窗格会显示该变量的值。</p><p id="f614" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">相反，使用<code class="du ls lt lu lv b">console.log</code>会更直观，MDN在他们的交互式例子中就是这么做的。</p><h1 id="46a6" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">第二次迭代的背景</h1><p id="f368" class="pw-post-body-paragraph jj jk hi jl b jm lw ij jo jp lx im jr js ly ju jv jw lz jy jz ka ma kc kd ke hb bi translated">在NodeJS中，可以读取<code class="du ls lt lu lv b">process.stdout</code>流，或者用自定义流创建一个新的记录器。因此，我寻找关于如何挂钩浏览器的<code class="du ls lt lu lv b">console.log</code>输出的资源。据我所知，没有办法在浏览器中获得<code class="du ls lt lu lv b">console</code>语句的输出。</p><p id="6318" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但是，调用时可以截取<code class="du ls lt lu lv b">console.log</code>的参数。<a class="ae ji" href="https://stackoverflow.com/questions/19846078/how-to-read-from-chromes-console-in-javascript" rel="noopener ugc nofollow" target="_blank">一个StackOverflow答案有解</a>。通过将原来的<code class="du ls lt lu lv b">console.log</code>语句重新分配给一个新变量，我们可以将自己的自定义函数分配给<code class="du ls lt lu lv b">console.log</code>。注意，这并不截取日志语句的输出，而只是截取参数。</p><h1 id="fa13" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">MDN是怎么做到的？</h1><p id="ae30" class="pw-post-body-paragraph jj jk hi jl b jm lw ij jo jp lx im jr js ly ju jv jw lz jy jz ka ma kc kd ke hb bi translated">MDN似乎具有读取控制台输出的能力，但进一步检查后，MDN的交互式编辑器输出与浏览器的控制台不同。这意味着他们必须自己处理格式化。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mb"><img src="../Images/3096954015fb826d9c41a81c90ecc394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*z0Rq_YNpWFcjPabRxQIXCw.png"/></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mc"><img src="../Images/28d49e16500952869f15c0c0b0357b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*H8Ov1lr07Tm0df3Si9qdjw.png"/></div></figure><p id="0381" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">查看MDN的简化的<code class="du ls lt lu lv b">editor-js</code>代码，使用了<code class="du ls lt lu lv b">new Function(t)()</code>而不是<code class="du ls lt lu lv b">eval(t)</code>来解析和运行输入。还有一个<code class="du ls lt lu lv b">try-catch</code>块来处理错误。</p><pre class="ix iy iz ja fd md lv me mf aw mg bi"><span id="1789" class="mh ku hi lv b fi mi mj l mk ml">!function(t) {<br/>  d.classList.add("fade-in");<br/>  try {<br/>    new Function(t)()<br/>  } catch (t) {<br/>    d.textContent = "Error: " + t.message<br/>  }<br/>  d.addEventListener("animationend", function() {<br/>    d.classList.remove("fade-in")<br/>  })<br/>}(e.getDoc().getValue())</span></pre><p id="c247" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在查找<code class="du ls lt lu lv b">console.log</code>赋值时，在同一个文件中发现了以下代码:</p><pre class="ix iy iz ja fd md lv me mf aw mg bi"><span id="5132" class="mh ku hi lv b fi mi mj l mk ml">var e = t("./console-utils")<br/>  , n = console.log<br/>  , r = console.error;<br/>console.error = function(t) {<br/>  e.writeOutput(t),<br/>  r.apply(console, arguments)<br/>},<br/>console.log = function() {<br/>  for (var t = [], r = 0, i = arguments.length; r &lt; i; r++) {<br/>    var o = e.formatOutput(arguments[r]);<br/>    t.push(o)<br/>  }<br/>  var a = t.join(" ");<br/>  e.writeOutput(a),<br/>  n.apply(console, arguments)<br/>}</span></pre><p id="3660" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这段代码非常符合StackOverflow的答案。每个参数都被迭代和格式化，然后连接在一起。原始参数也被传递回原始的<code class="du ls lt lu lv b">console.log</code>。</p><h1 id="9bb8" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">寻找源代码</h1><p id="49b5" class="pw-post-body-paragraph jj jk hi jl b jm lw ij jo jp lx im jr js ly ju jv jw lz jy jz ka ma kc kd ke hb bi translated">经过一番侦查，我发现了<a class="ae ji" href="https://github.com/mdn/bob" rel="noopener ugc nofollow" target="_blank"> MDN的比特建造者(BoB) </a>。它是负责MDN上交互式示例的存储库。Mozilla还慷慨地给了repo一个MIT许可。</p><p id="2120" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">例如，<a class="ae ji" href="https://github.com/mdn/bob/blob/afa4e2fcb37725072d9f7b8a9a816c5c8af25f17/editor/js/editor-libs/console.js" rel="noopener ugc nofollow" target="_blank">这是上面</a>的缩小代码块的原始源代码:</p><pre class="ix iy iz ja fd md lv me mf aw mg bi"><span id="b03a" class="mh ku hi lv b fi mi mj l mk ml">module.exports = function() {<br/>    'use strict';</span><span id="c2ee" class="mh ku hi lv b fi mm mj l mk ml">var consoleUtils = require('./console-utils');<br/>    var originalConsoleLogger = console.log; // eslint-disable-line no-console<br/>    var originalConsoleError = console.error;</span><span id="faac" class="mh ku hi lv b fi mm mj l mk ml">console.error = function(loggedItem) {<br/>        consoleUtils.writeOutput(loggedItem);<br/>        // do not swallow console.error<br/>        originalConsoleError.apply(console, arguments);<br/>    };</span><span id="aff8" class="mh ku hi lv b fi mm mj l mk ml">// eslint-disable-next-line no-console<br/>    console.log = function() {<br/>        var formattedList = [];<br/>        for (var i = 0, l = arguments.length; i &lt; l; i++) {<br/>            var formatted = consoleUtils.formatOutput(arguments[i]);<br/>            formattedList.push(formatted);<br/>        }<br/>        var output = formattedList.join(' ');<br/>        consoleUtils.writeOutput(output);<br/>        // do not swallow console.log<br/>        originalConsoleLogger.apply(console, arguments);<br/>    };<br/>};</span></pre><p id="29f7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">好奇的朋友，负责格式化MDN日志的文件在这里:<a class="ae ji" href="https://github.com/mdn/bob/blob/master/editor/js/editor-libs/console-utils.js" rel="noopener ugc nofollow" target="_blank">https://github . com/MDN/bob/blob/master/editor/js/editor-libs/console-utils . js</a>。当本地<code class="du ls lt lu lv b">toString()</code>方法的输出不够时，它有一些负责格式化日志行的规则。</p><h1 id="8c2a" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">寻找其他选择</h1><p id="7b63" class="pw-post-body-paragraph jj jk hi jl b jm lw ij jo jp lx im jr js ly ju jv jw lz jy jz ka ma kc kd ke hb bi translated">安装了<code class="du ls lt lu lv b">mdn-bob</code>之后，我认为这个库对于MDN的用例来说太具体了。例如，库包含了我不需要的CSS样式。我只需要代码中的一小部分，格式化程序。</p><p id="e80f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">NodeJS本身有一个<a class="ae ji" href="https://nodejs.org/api/util.html#util_util_inspect_object_options" rel="noopener ugc nofollow" target="_blank">原生</a> <code class="du ls lt lu lv b"><a class="ae ji" href="https://nodejs.org/api/util.html#util_util_inspect_object_options" rel="noopener ugc nofollow" target="_blank">util</a></code> <a class="ae ji" href="https://nodejs.org/api/util.html#util_util_inspect_object_options" rel="noopener ugc nofollow" target="_blank">库，这个库有一个</a> <code class="du ls lt lu lv b"><a class="ae ji" href="https://nodejs.org/api/util.html#util_util_inspect_object_options" rel="noopener ugc nofollow" target="_blank">inspect</a></code> <a class="ae ji" href="https://nodejs.org/api/util.html#util_util_inspect_object_options" rel="noopener ugc nofollow" target="_blank">方法</a>，可以格式化任何东西。在NPM上搜索了一下<code class="du ls lt lu lv b">util.inspect</code>的浏览器端口后，我选择了<code class="du ls lt lu lv b"><a class="ae ji" href="https://github.com/inspect-js/object-inspect" rel="noopener ugc nofollow" target="_blank">object-inspect</a></code>。</p><p id="68ad" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">尽管输出可能与浏览器不同，但我认为这种便利是一种合理的妥协。如果我的代码很整洁，将来换一个更好的库应该很容易。</p><h1 id="c7b1" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">构建第二次迭代</h1><p id="0072" class="pw-post-body-paragraph jj jk hi jl b jm lw ij jo jp lx im jr js ly ju jv jw lz jy jz ka ma kc kd ke hb bi translated">结合StackOverflow的答案和MDN BoB的答案，我从分配原始控制台语句开始。</p><pre class="ix iy iz ja fd md lv me mf aw mg bi"><span id="e9b1" class="mh ku hi lv b fi mi mj l mk ml"><em class="mn">const </em>originalConsoleLogger = console.log;<br/><em class="mn">const </em>originalConsoleError = console.error;</span></pre><p id="c63a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意，由于调用的是<code class="du ls lt lu lv b">console.log</code>而不是<code class="du ls lt lu lv b">window.console.log</code>，我们应该不会遇到服务器端渲染(SSR)的问题。</p><p id="f447" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我将<code class="du ls lt lu lv b">console.log</code>和<code class="du ls lt lu lv b">console.error</code>重新分配给我各自的自定义功能。这些最终需要进入我们的React组件，因为处理参数的结果应该是组件状态的更新。</p><pre class="ix iy iz ja fd md lv me mf aw mg bi"><span id="f856" class="mh ku hi lv b fi mi mj l mk ml">console.error = function () {<br/>  // handle arguments<br/>  originalConsoleError.apply(console, arguments)<br/>}</span><span id="117b" class="mh ku hi lv b fi mm mj l mk ml">console.log = function () {<br/>  // handle arguments<br/>  originalConsoleLogger.apply(console, arguments)<br/>}</span></pre><p id="922b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我注意到我们可以通过使用箭头函数以及使用rest参数而不是<code class="du ls lt lu lv b">arguments</code>将它转换成ES6语法。<a class="ae ji" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments#description" rel="noopener ugc nofollow" target="_blank">MDN</a>建议采用这种方法。为了保持函数参数和执行原始控制台函数之间的对称性，我选择使用<code class="du ls lt lu lv b">.call</code>而不是<code class="du ls lt lu lv b">.apply</code>。</p><pre class="ix iy iz ja fd md lv me mf aw mg bi"><span id="c9a5" class="mh ku hi lv b fi mi mj l mk ml">console.error = (...args) =&gt; {<br/>  // handle arguments<br/>  originalConsoleError.call(console, ...args)<br/>}</span><span id="93a1" class="mh ku hi lv b fi mm mj l mk ml">console.log = (...args) =&gt; {<br/>  // handle arguments<br/>  originalConsoleLogger.call(console, ...args)<br/>}</span></pre><p id="8276" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后，参数将需要由<code class="du ls lt lu lv b">object-inspect</code>库进行处理。我没有使用<code class="du ls lt lu lv b">for</code>循环，而是选择使用<code class="du ls lt lu lv b">Array.reduce</code>。尽管多年的ESLint训练我不要使用<code class="du ls lt lu lv b">any</code>类型，但我认为在这种情况下这是可以接受的，因为<code class="du ls lt lu lv b">objectInspect</code>期望<code class="du ls lt lu lv b">any</code>作为输入。有这么多的“参数”,这无疑是一个盗版者最喜欢的功能。</p><pre class="ix iy iz ja fd md lv me mf aw mg bi"><span id="478d" class="mh ku hi lv b fi mi mj l mk ml"><em class="mn">import objectInspect from </em>"object-inspect";</span><span id="c979" class="mh ku hi lv b fi mm mj l mk ml">/* ... */</span><span id="9f45" class="mh ku hi lv b fi mm mj l mk ml"><em class="mn">const </em>reduceArgs = (formattedList: <em class="mn">any</em>[], arg: <em class="mn">any</em>) =&gt; [<br/>  ...formattedList,<br/>  <em class="mn">objectInspect</em>(arg),<br/>];<br/><br/><em class="mn">const </em>formatArgs = (args: <em class="mn">any</em>[]) =&gt; args.reduce(reduceArgs, []).join(" ");</span></pre><h1 id="8635" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">使用函数代替Eval</h1><p id="ff8a" class="pw-post-body-paragraph jj jk hi jl b jm lw ij jo jp lx im jr js ly ju jv jw lz jy jz ka ma kc kd ke hb bi translated">基于MDN的建议，使用<code class="du ls lt lu lv b">Function</code>比<code class="du ls lt lu lv b">eval</code>更快更安全。请注意，在大多数情况下，使用这两种方法都不安全。在这种情况下，代码是由用户在他们自己的浏览器中提供的，而不是在其他任何地方存储或重用。</p><pre class="ix iy iz ja fd md lv me mf aw mg bi"><span id="c84e" class="mh ku hi lv b fi mi mj l mk ml"><em class="mn">try </em>{<br/>  <em class="mn">new </em>Function(code)();<br/>} <em class="mn">catch </em>(e) {<br/>  console.error(e);<br/>}</span></pre><h1 id="de1f" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">让它起反应</h1><p id="8df9" class="pw-post-body-paragraph jj jk hi jl b jm lw ij jo jp lx im jr js ly ju jv jw lz jy jz ka ma kc kd ke hb bi translated">所有需要做的就是在与<code class="du ls lt lu lv b">setResult</code>和<code class="du ls lt lu lv b">setError</code>状态相同的范围内移动每个函数，并使用<code class="du ls lt lu lv b">formatArgs</code>的输出更新状态。</p><pre class="ix iy iz ja fd md lv me mf aw mg bi"><span id="5d56" class="mh ku hi lv b fi mi mj l mk ml"><em class="mn">const StringPage </em>= () =&gt; {<br/>  <em class="mn">const </em>[result, setResult] = <em class="mn">React</em>.<em class="mn">useState</em>("");<br/>  <em class="mn">const </em>[error, setError] = <em class="mn">React</em>.<em class="mn">useState</em>("");<br/>  const codeRef = React.useRef&lt;HTMLTextAreaElement&gt;(null);</span><span id="e03e" class="mh ku hi lv b fi mm mj l mk ml">  console.log = (...args: <em class="mn">any</em>[]) =&gt; {<br/>    <em class="mn">const </em>formattedLog = formatArgs(args);<br/>    setResult(formattedLog);<br/>    originalConsoleLogger.call(console, ...args);<br/>  };<br/><br/>  console.error = <em class="mn">function </em>(...args: <em class="mn">any</em>[]) {<br/>    <em class="mn">const </em>formattedError = formatArgs(args);<br/>    setError(formattedError);<br/>    originalConsoleError.call(console, ...args);<br/>  };</span><span id="d673" class="mh ku hi lv b fi mm mj l mk ml"><em class="mn">  const </em>evaluateCode = () =&gt; {<br/>    <em class="mn">if </em>(codeRef.current === <em class="mn">null</em>) <em class="mn">return</em>;<br/>    <em class="mn">const </em>code = codeRef.current.value;<br/>    if(code.length &lt; 1) return;</span><span id="8959" class="mh ku hi lv b fi mm mj l mk ml">    <em class="mn">try </em>{<br/>      <em class="mn">new </em>Function(code)();<br/>    } <em class="mn">catch </em>(e) {<br/>      console.error(e);<br/>    }<br/>  };</span><span id="ecdd" class="mh ku hi lv b fi mm mj l mk ml">  <em class="mn">return </em>(<br/>    &lt;&gt;<br/>      {/* surrounding JSX removed for clarity */}<br/>      {result}<br/>      {error}<br/>    &lt;/&gt;<br/>  );</span></pre><h1 id="7ae2" class="kt ku hi bd kv kw kx ky kz la lb lc ld io le ip lf ir lg is lh iu li iv lj lk bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="fe78" class="pw-post-body-paragraph jj jk hi jl b jm lw ij jo jp lx im jr js ly ju jv jw lz jy jz ka ma kc kd ke hb bi translated">浏览器的<code class="du ls lt lu lv b">console</code>输出无法读取。MDN的交互例子覆盖了<code class="du ls lt lu lv b">console.log</code>，格式化了网页的参数，然后调用了原来的<code class="du ls lt lu lv b">console.log</code>。我在React中创建了一个组件来完成同样的事情。</p></div><div class="ab cl mo mp gp mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hb hc hd he hf"><p id="84fb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><em class="mn">最初来自:</em></p><div class="mv mw ez fb mx my"><a href="https://www.bayanbennett.com/posts/how-does-mdn-intercept-console-log-devlog-003" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">MDN如何拦截` console.log `？| DevLog 003</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">在上一篇文章中，我们看到了:从WebStorm上传到GitHub语义版本化常规提交…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">www.bayanbennett.com</p></div></div></div></a></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es nh"><img src="../Images/011a195b1b8a26dee756f72274732cd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIICU6YqI4gB4ZDYsJlCtg.png"/></div></div><figcaption class="je jf et er es jg jh bd b be z dx translated">这只是为了故事</figcaption></figure></div></div>    
</body>
</html>