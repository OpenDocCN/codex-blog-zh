<html>
<head>
<title>So, You Want To Build A Pipeline?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">所以，你想建一条管道？</h1>
<blockquote>原文：<a href="https://medium.com/codex/so-you-want-to-build-a-pipeline-b16c69bc7902?source=collection_archive---------4-----------------------#2021-09-20">https://medium.com/codex/so-you-want-to-build-a-pipeline-b16c69bc7902?source=collection_archive---------4-----------------------#2021-09-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/548c081d2cce670a0d8306d2b7a0d479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JEslvtXS6XMkxCQ2.jpg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">这宝贝能装这么多数据！|<a class="ae iu" href="https://www.flickr.com/photos/50693818@N08/11720986694" rel="noopener ugc nofollow" target="_blank"/><a class="ae iu" href="https://www.flickr.com/photos/50693818@N08" rel="noopener ugc nofollow" target="_blank">大峡谷NPS </a>的【跨峡谷管道(历史)2400】由2.0 在<a class="ae iu" href="https://creativecommons.org/licenses/by/2.0/?ref=ccsearch&amp;atype=html" rel="noopener ugc nofollow" target="_blank"> CC下许可</a></figcaption></figure><p id="1495" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">看，我只打算说一次:</strong>写代码的首要原则之一就是不要重复自己(干)。这是一条适用于所有语言的通用规则，在处理数据时尤其重要。DRY是我们为循环而不是复制粘贴而写的原因；这就是为什么我们声明函数而不是复制粘贴；这也是我们使用管道来预处理数据、拟合模型以及交叉验证模型的原因。</p><p id="d02a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代码中的重复不仅仅是混乱和令人困惑——当你重写变量值时，它会导致严重的错误。还记得那次你忘了你已经预处理了<code class="du jt ju jv jw b">X_train</code>并且你最终填充了整个数据帧will <code class="du jt ju jv jw b">np.nan</code>，然后花了一个小时试图弄清楚为什么你的模型有土豆的精度吗？开始使用管道，让这种体验成为一个故事，你告诉你的孩子，让他们无聊入睡。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div class="ab fe cl kb"><img src="../Images/ae1aed3cc129b00a4ca7428c6e0300d2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*4xAo8_gyXNG5wYDCq-PvdA.png"/></div></figure><h1 id="0f31" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">管道中的企鹅</h1><p id="8dd8" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">在这个小操作指南中，我们将看到一些管道在运行，并学习一些策略来使管道更加方便。我们将使用通过Seaborn导入的<a class="ae iu" href="https://github.com/allisonhorst/palmerpenguins" rel="noopener ugc nofollow" target="_blank"> Allison Horst的企鹅数据集</a>，建立一个可以预测企鹅种类的模型。列出的每只企鹅的特征有:本岛、喙和鳍的尺寸、体重和性别。数据集中的三种企鹅:阿德利企鹅、巴布亚企鹅和下巴颏企鹅。它们都很可爱，尤其是阿德利。</p><p id="d8a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lf">注意:我通常会在笔记本的顶部看到一个巨大的代码块，用于导入依赖项，但是我认为这样做更有帮助，因为这样可以更容易地看到所有内容的来源。</em></p><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="c94f" class="lk kd hi jw b fi ll lm l ln lo">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/><br/># To print some nice tables (https://pypi.org/project/tabulate/)<br/>from tabulate import tabulate<br/><br/># Load in the penguins<br/>penguins = sns.load_dataset("penguins")<br/>display(penguins.head())<br/>print(penguins.shape)</span></pre><figure class="jx jy jz ka fd ij er es paragraph-image"><div class="ab fe cl kb"><img src="../Images/aceb841db94f445a68aff24deaf48cf4.png" data-original-src="https://miro.medium.com/v2/format:webp/1*oWbzWLdyaTf4qTyc6Yt1rQ.png"/></div></figure><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="ee0b" class="lk kd hi jw b fi ll lm l ln lo">(344, 7)</span></pre><figure class="jx jy jz ka fd ij er es paragraph-image"><div class="ab fe cl kb"><img src="../Images/6a311e9ab8ba47e8bad9972c1e0b7ca9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*FoUrply5l-jF9dMzULJ_OQ.png"/></div></figure><p id="a42c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们假设我们已经做了一些探索性的数据分析(EDA ),以查看每个特性的分布，它们之间的潜在关系，等等。，我们准备做一些建模。像往常一样，我们将使用<a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank"> Scikit-learn的</a> <code class="du jt ju jv jw b"><a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank">test_train_split</a></code>从目标类中分离出我们的特性。由于我们试图预测企鹅的种类，这将是我们的目标，<code class="du jt ju jv jw b">y</code>。</p><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="6e52" class="lk kd hi jw b fi ll lm l ln lo">from sklearn.model_selection import train_test_split<br/><br/># Separate features from target<br/>X = penguins.drop('species', axis=1)<br/>y = penguins['species']<br/><br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=42)<br/><br/># Print out the sizes<br/>shape_table = [['Original', X.shape, y.shape], ['Training', X_train.shape, y_train.shape], <br/>         ['Testing', X_test.shape, y_test.shape]]<br/>print(tabulate(shape_table, headers=['Dataset', 'X shape', 'y shape']))</span><span id="c7f0" class="lk kd hi jw b fi lp lm l ln lo">Dataset    X shape    y shape<br/>---------  ---------  ---------<br/>Original   (344, 6)   (344,)<br/>Training   (275, 6)   (275,)<br/>Testing    (69, 6)    (69,)</span></pre><p id="33eb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们走得太远之前，我们最好看一下缺失值的计数。</p><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="76c2" class="lk kd hi jw b fi ll lm l ln lo">penguins.isna().sum()</span><span id="ffe6" class="lk kd hi jw b fi lp lm l ln lo">species               0<br/>island                0<br/>bill_length_mm        2<br/>bill_depth_mm         2<br/>flipper_length_mm     2<br/>body_mass_g           2<br/>sex                  11<br/>dtype: int64</span></pre><p id="6597" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯……不太多，但是在我们尝试适合一个模型之前，我们仍然必须对它们做一些事情。由于我们一开始没有那么多数据，并且因为本教程依赖于这些数据，所以让我们填充它们而不是删除它们。</p><p id="2fea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们需要采取的下一步措施是:</p><ol class=""><li id="5274" class="lq lr hi ix b iy iz jc jd jg ls jk lt jo lu js lv lw lx ly bi translated">用以下内容填充缺失值:</li></ol><ul class=""><li id="a7fd" class="lq lr hi ix b iy iz jc jd jg ls jk lt jo lu js lz lw lx ly bi translated">数字特征含义</li><li id="e594" class="lq lr hi ix b iy ma jc mb jg mc jk md jo me js lz lw lx ly bi translated">分类特征的模式</li></ul><p id="9475" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.缩放数字数据</p><p id="1b61" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.对分类数据进行一次性编码</p><p id="c397" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.拟合模型(我们将只使用简单的逻辑回归)</p><p id="2d38" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.评估模型</p><p id="a682" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用管道来完成。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div class="ab fe cl kb"><img src="../Images/855a1193b6c338d1376e95fdf9768429.png" data-original-src="https://miro.medium.com/v2/1*D1PiCt9inwoJukLgDBjVig.gif"/></div></figure><h1 id="6da8" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">但是我现在的做事方式有什么问题吗？</h1><p id="4da2" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">在管道出现之前，我的工作流程可能是这样的:</p><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="43b6" class="lk kd hi jw b fi ll lm l ln lo">from sklearn.linear_model import LogisticRegression<br/>from sklearn.preprocessing import StandardScaler, OneHotEncoder<br/>from sklearn.impute import SimpleImputer<br/>from sklearn.model_selection import cross_val_score<br/><br/># I want to fill in missing values, <br/># but some of my columns are categorical and some are numerical<br/>num_imputer = SimpleImputer(strategy='median')<br/>cat_imputer = SimpleImputer(strategy='most_frequent')<br/><br/># Apply each imputer to the correct columns by selecting datatypes<br/>X_train_num_imputed = num_imputer.fit_transform(X_train.select_dtypes(include=['int64', 'float64']))<br/>X_train_cat_imputed = cat_imputer.fit_transform(X_train.select_dtypes(include='object'))<br/><br/># Might as well scale the numerical stuff...<br/>ss = StandardScaler()<br/>X_train_num_imputed_scaled = ss.fit_transform(X_train_num_imputed)<br/><br/># ...and one-hot-encode the categorical stuff<br/>ohe = OneHotEncoder(handle_unknown='ignore', sparse=False)<br/>X_train_cat_imputed_ohe = ohe.fit_transform(X_train_cat_imputed)<br/><br/># Now I gotta put 'em back together<br/>X_train_preprocessed = np.concatenate([X_train_num_imputed_scaled, X_train_cat_imputed_ohe], axis=1)<br/><br/># And finally fit and evaluate the model<br/>logreg = LogisticRegression(random_state=42)<br/>logreg.fit(X_train_preprocessed, y_train)<br/>initial_score = logreg.score(X_train_preprocessed, y_train)<br/>initial_crossval_score = cross_val_score(logreg, X_train_preprocessed, y_train).mean()<br/><br/># Print out scores<br/>scores_table = [['Original', initial_score, initial_crossval_score]]<br/>scores_headers = ['Dataset', 'Training score', 'Cross-val score']<br/>print(tabulate(scores_table, headers=scores_headers))</span><span id="b9b3" class="lk kd hi jw b fi lp lm l ln lo">Dataset      Training score    Cross-val score<br/>---------  ----------------  -----------------<br/>Original           0.996364           0.992727</span></pre><p id="ceb4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="lf">真乱！</em>T9】</strong></p><p id="8c45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你跳过了那段代码，我不能责怪你。就是重复，组织不好。我对数据集进行了六次拆分和重命名，然后又将它们重新组合在一起。我第一次尝试运行它时，我不得不调试多个错误，其中大部分是因为我为每个新版本的<code class="du jt ju jv jw b">X_train</code>写了不同的名字而导致的简单的打字错误。如果以后我想更改或添加任何东西，我将不得不搜索我的代码并重命名一堆东西。最糟糕的是，为了对我的模型做最后的评估，我不得不对<code class="du jt ju jv jw b">X_test</code>重复整个<em class="lf">过程。</em></p><figure class="jx jy jz ka fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/2326c70944ce40916e867bd063d10e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*rEy0joKlByR6JbfUUYdK_w.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">一定有更好的办法！</figcaption></figure><h1 id="9d46" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">管道:更好的方式</h1><p id="a428" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">使用管道将使代码更简单、更清晰、更少重复。当使用机器学习模型时，管道可以更容易地预处理数据，并使模型适合训练和测试集。管道还可以防止数据泄漏，尤其是在通过交叉验证评估模型时。</p><p id="1c6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如函数存储你可以反复运行的进程一样，<a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank"> sklearn的Pipeline类</a>存储其他类的实例以在你的数据集上运行。一些类是转换器，而另一些类是估计器。变形金刚大战霸天虎——等等，不对。</p><ul class=""><li id="c5f3" class="lq lr hi ix b iy iz jc jd jg ls jk lt jo lu js lz lw lx ly bi translated"><strong class="ix hj">转换程序</strong>处理或修改你的数据:<code class="du jt ju jv jw b"><a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" rel="noopener ugc nofollow" target="_blank">StandardScaler</a></code>和<code class="du jt ju jv jw b"><a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank">OneHotEncoder</a></code>都可以在转换程序中使用。</li><li id="9296" class="lq lr hi ix b iy ma jc mb jg mc jk md jo me js lz lw lx ly bi translated"><strong class="ix hj">估计器</strong>将模型拟合到您的数据:<code class="du jt ju jv jw b"><a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html" rel="noopener ugc nofollow" target="_blank">LogisticRegression</a></code>和<code class="du jt ju jv jw b"><a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html" rel="noopener ugc nofollow" target="_blank">KNeighborsClassifier</a></code>都是sklearn估计器。</li></ul><p id="9681" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">pipelines如此神奇的部分原因是它们对sklearn一致的API的直观使用。任何你可以用转换器或估算器来做的事情，你都可以用管道来做。这意味着您可以在管道上使用像<code class="du jt ju jv jw b">.fit()</code>、<code class="du jt ju jv jw b">.transform()</code>或<code class="du jt ju jv jw b">.predict()</code>这样的方法，就像您可以在每个单独的部分上使用一样。您还可以在交叉验证中使用管道来评估模型的性能。</p><h1 id="6f72" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">你如何建立一个管道？</h1><p id="2826" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">当您实例化sklearn的Pipeline类时，您需要定义的主要参数是<code class="du jt ju jv jw b">steps</code>，它接受您希望包含在管道中的转换器和估计器的列表。每一步都以一个<a class="ae iu" href="https://www.w3schools.com/python/python_tuples.asp" rel="noopener ugc nofollow" target="_blank">元组</a>的形式编写。元组中的第一项是变换器/估计器的名称，第二项是变换器/估计器本身。</p><p id="0909" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个典型的流水线可能包含多个变压器和一个最终估计器，但是你不一定需要在每个流水线中有多个元件。事实上，最简单的管道只包含一样东西:</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div class="ab fe cl kb"><img src="../Images/b7d605b326ec0a2e321f98af948864d3.png" data-original-src="https://miro.medium.com/v2/format:webp/1*542VaeFU-DXOx_BpIiPFWw.png"/></div></figure><p id="968d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上，管道通常至少有两个步骤。最终，我们将建立一个由其他管道组成的管道！</p><p id="8fb1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要构建管道，您需要知道处理数据和拟合模型的步骤。这很难完全提前知道，所以有时从一些混乱的代码开始，然后重构它会更容易。另一个策略是在组装之前先建造较小的管道。</p><h2 id="ef74" class="lk kd hi bd ke mg mh mi ki mj mk ml km jg mm mn kq jk mo mp ku jo mq mr ky ms bi translated">按编号排列管道</h2><p id="91b2" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">让我们从数据集中的数字列的管道开始。我们将使用每列的平均值来估算空值，然后在用<code class="du jt ju jv jw b">LogisticRegression()</code>估算器拟合之前缩放数据。</p><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="8c43" class="lk kd hi jw b fi ll lm l ln lo">from sklearn.pipeline import Pipeline<br/><br/># Pipeline for numerical data only<br/>num_pipe = Pipeline(steps=[<br/>    ('num_imputer', SimpleImputer(strategy='mean')),<br/>    ('ss', StandardScaler()),<br/>    ('logreg', LogisticRegression(random_state=42))<br/>])<br/><br/># Select only the numerical columns and drop all nulls<br/>X_train_numerical = X_train.select_dtypes(include='float64')<br/><br/># Fit and score the pipeline<br/>num_pipe.fit(X_train_numerical, y_train)<br/>num_score = num_pipe.score(X_train_numerical, y_train)<br/>num_crossval_score = cross_val_score(num_pipe, X_train_numerical, y_train).mean()<br/><br/># Compare scores<br/>scores_table.append(['Numerical', num_score, num_crossval_score]) <br/>print(tabulate(scores_table, headers=scores_headers))</span><span id="53ed" class="lk kd hi jw b fi lp lm l ln lo">Dataset      Training score    Cross-val score<br/>---------  ----------------  -----------------<br/>Original           0.996364           0.992727<br/>Numerical          0.989091           0.985455</span></pre><p id="e5de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的分数下降是有道理的-请记住，原始分数包括原始数据集中的所有要素，而数字分数仅包括数字要素。</p><p id="aaea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">比较使用和不使用管线来完成数据处理和模型拟合的语法:</p><p id="7b67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有管道:</p><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="8bc4" class="lk kd hi jw b fi ll lm l ln lo">imputer = SimpleImputer()<br/>ss = StandardScaler()<br/>logreg = LogisticRegression()<br/><br/>X_train_imp = imputer.fit_transform(X_train)<br/>X_train_scl = ss.fit_transform(X_train_imp)<br/>logreg.fit(X_train_scl)</span></pre><p id="95ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用管道:</p><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="9b7b" class="lk kd hi jw b fi ll lm l ln lo">pipe = Pipeline(steps=[<br/>    ('num_imputer', SimpleImputer()),<br/>    ('ss', StandardScaler()),<br/>    ('logreg', LogisticRegression())<br/>])<br/><br/>pipe.fit(X_train)</span></pre><p id="a5cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">看看使用管道如何减少代码总量，并完全消除为每个步骤创建新的、重命名版本的<code class="du jt ju jv jw b">X_train</code>的需要。更简单，更少出错的风险，而且非常干！</p><h2 id="fa9b" class="lk kd hi bd ke mg mh mi ki mj mk ml km jg mm mn kq jk mo mp ku jo mq mr ky ms bi translated">绝对的是</h2><p id="f694" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">我们可以在分类栏中添加吗？你打赌！为此，我们将引入另一个名为<code class="du jt ju jv jw b"><a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.compose.ColumnTransformer.html" rel="noopener ugc nofollow" target="_blank">ColumnTransformer</a></code>的类。ColumnTransformer在这种情况下非常有用，因为它允许我们对不同的列执行不同的操作，一次完成。</p><p id="293f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了使用ColumnTransformer，我们将稍微重构一下代码，并创建两个子管道:一个用于数值数据，一个用于分类数据。</p><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="4606" class="lk kd hi jw b fi ll lm l ln lo"># Sub-pipeline for the numerical columns<br/>num_transformer = Pipeline(steps=[<br/>                           ('num_imputer', SimpleImputer(strategy='mean')),<br/>                           ('ss', StandardScaler())])<br/><br/># Sub-pipeline for the categorical columns<br/>cat_transformer = Pipeline(steps=[<br/>                           ('cat_imputer', SimpleImputer(strategy='most_frequent')),<br/>                           ('ohe', OneHotEncoder(handle_unknown='ignore'))])</span></pre><p id="b80c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，这些管道都没有以我们的LogisticRegression估计器结束！我们将把它留到最后的流水线上。相反，我们将使用ColumnTransformer将这两个子管道连接在一起，column transformer接受您希望包含在管道中的转换器的列表。每个转换器都以三元组的形式编写，包含以下各项:</p><ol class=""><li id="22e7" class="lq lr hi ix b iy iz jc jd jg ls jk lt jo lu js lv lw lx ly bi translated">变压器的名称(a <code class="du jt ju jv jw b">string</code></li><li id="4216" class="lq lr hi ix b iy ma jc mb jg mc jk md jo me js lv lw lx ly bi translated">转换器或子管道的类或实例</li><li id="c96e" class="lq lr hi ix b iy ma jc mb jg mc jk md jo me js lv lw lx ly bi translated">要应用转换器的列</li></ol><p id="c8e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过给出一个列表来指定列，比如<code class="du jt ju jv jw b">['bill_length_mm', 'bill_depth_mm']</code>，但是使用<code class="du jt ju jv jw b"><a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.compose.make_column_selector.html" rel="noopener ugc nofollow" target="_blank">make_columns_selector</a></code>更容易，因为我们是通过数据类型而不是名称来选择列的。</p><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="fc7e" class="lk kd hi jw b fi ll lm l ln lo">from sklearn.compose import ColumnTransformer, make_column_selector<br/><br/>preprocessing = ColumnTransformer(<br/>    transformers=[<br/>        ('numerical sub-pipe', num_transformer, make_column_selector(dtype_include=['float64'])),<br/>        ('categorical sub-pipe', cat_transformer, make_column_selector(dtype_include=['object']))<br/>    ])</span></pre><h1 id="e3d7" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">把所有的放在一起</h1><p id="7ad1" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">现在，我们可以制作一个完整的管道，预处理我们所有的特性，并以我们的估计器结束。注意，现在在<code class="du jt ju jv jw b">'preprocessing'</code>步骤中，我们传入包含两个子管道的ColumnTransformer，然后让LogisticRegression在我们整个完全处理过的数据集上施展魔法。</p><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="8514" class="lk kd hi jw b fi ll lm l ln lo"># A complete pipeline <br/>complete_pipe = Pipeline(steps=[<br/>    ('preprocessing', preprocessing),<br/>    ('logreg', LogisticRegression(random_state=42))<br/>])</span></pre><p id="fa2a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，完整的管道由一个ColumnTransformer和一个LogisticRegression分类器组成。在ColumnTransformer中有两个子管道，分别对应于数据集中的一种数据类型。每个子管道由一个简单的估算器和另一个步骤组成:一个用于数字数据的标准缩放器和一个用于分类数据的OneHotEncoder。</p><p id="a104" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果还有很多碎片要拼的话，不用担心。只看一个画面可能更容易些:</p><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="9138" class="lk kd hi jw b fi ll lm l ln lo"># This will allow us to see a nice diagram of our pipeline</span><span id="4bfe" class="lk kd hi jw b fi lp lm l ln lo">from sklearn import set_config<br/>set_config(display='diagram')<br/><br/>complete_pipe</span></pre><figure class="jx jy jz ka fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/ffb64b8ccaf3da2473f7b776aec24d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*AGgfMy1NX5yQgqkXSWAK5g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">注意:如果您自己在Jupyter笔记本上运行这段代码，看看当您单击图中的每个组件时会发生什么！</figcaption></figure><p id="db79" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，当我们想要对管道进行调整和评分时，我们不必选择管道外部的列或数据类型——这一切都发生在管道内部！我们现在可以直接传入X_train，而不必手动转换或干预它。</p><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="19f7" class="lk kd hi jw b fi ll lm l ln lo"># Fit and score the pipeline<br/>complete_pipe.fit(X_train, y_train)<br/>complete_score = complete_pipe.score(X_train, y_train)<br/>complete_crossval_score = cross_val_score(complete_pipe, X_train, y_train).mean()<br/><br/># Compare scores<br/>scores_table.append(['Complete', complete_score, complete_crossval_score]) <br/>print(tabulate(scores_table, headers=scores_headers))</span><span id="46ff" class="lk kd hi jw b fi lp lm l ln lo">Dataset      Training score    Cross-val score<br/>---------  ----------------  -----------------<br/>Original           0.996364           0.992727<br/>Numerical          0.989091           0.985455<br/>Complete           0.996364           0.996364</span></pre><p id="7805" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如预期的那样，我们的完整训练分数与原始分数相同，因为我们再次使用了我们所有的功能。但是请注意，cross-val分数是不同的！(提示:与原模型构建过程中数据意外泄露有关！但是我们将把它留到另一篇文章中……)</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div class="ab fe cl kb"><img src="../Images/06804d2a55592294dbf2c200b0574a5f.png" data-original-src="https://miro.medium.com/v2/1*v-wRG2O6tKGfdw8835IH7g.gif"/></div></figure><h1 id="396a" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">不重复我自己…</h1><p id="7caa" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">…但是让我们再来看一下这两种方法，看看完整的管道，并欣赏管道的力量，使我们的代码更简单、更干净，就像关于管道的文章一样枯燥。</p><h2 id="c650" class="lk kd hi bd ke mg mh mi ki mj mk ml km jg mm mn kq jk mo mp ku jo mq mr ky ms bi translated">无管道:</h2><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="f11a" class="lk kd hi jw b fi ll lm l ln lo"><em class="lf">If you skipped over this code block before, this time try to identify each part that we included in our complete pipeline.</em></span><span id="814b" class="lk kd hi jw b fi lp lm l ln lo">num_imputer = SimpleImputer(strategy='median')<br/>cat_imputer = SimpleImputer(strategy='most_frequent')<br/><br/>X_train_num_imputed = num_imputer.fit_transform(X_train.select_dtypes(include=['int64', 'float64']))<br/>X_train_cat_imputed = cat_imputer.fit_transform(X_train.select_dtypes(include='object'))<br/><br/>ss = StandardScaler()<br/>X_train_num_imputed_scaled = ss.fit_transform(X_train_num_imputed)<br/><br/>ohe = OneHotEncoder(handle_unknown='ignore', sparse=False)<br/>X_train_cat_imputed_ohe = ohe.fit_transform(X_train_cat_imputed)<br/><br/>X_train_preprocessed = np.concatenate([X_train_num_imputed_scaled, X_train_cat_imputed_ohe], axis=1)<br/><br/>logreg = LogisticRegression(random_state=42)<br/>logreg.fit(X_train_preprocessed, y_train)<br/>initial_score = logreg.score(X_train_preprocessed, y_train)<br/>initial_crossval_score = cross_val_score(logreg, X_train_preprocessed, y_train).mean()<br/><br/>scores_table = [['Original', initial_score, initial_crossval_score]]<br/>scores_headers = ['Dataset', 'Training score', 'Cross-val score']<br/>print(tabulate(scores_table, headers=scores_headers))</span><span id="5f8b" class="lk kd hi jw b fi lp lm l ln lo">Dataset      Training score    Cross-val score<br/>---------  ----------------  -----------------<br/>Original           0.996364           0.992727</span></pre><p id="1725" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">没有管道，我们必须:</p><ul class=""><li id="5674" class="lq lr hi ix b iy iz jc jd jg ls jk lt jo lu js lz lw lx ly bi translated">手动执行每个步骤</li><li id="3762" class="lq lr hi ix b iy ma jc mb jg mc jk md jo me js lz lw lx ly bi translated">跟踪<code class="du jt ju jv jw b">X_train</code>的各种版本和拆分</li><li id="4ce0" class="lq lr hi ix b iy ma jc mb jg mc jk md jo me js lz lw lx ly bi translated">最后把它们重新组合在一起。</li></ul><p id="9159" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很复杂，重复，而且很有可能因为打字错误或步骤顺序错误而出错。更不用说还有数据泄露(提示:和StandardScaler有关！).最糟糕的是，为了在我们的维持集上评估我们的模型，我们必须用X_test的全新版本和拆分集重复整个过程，还要记住将每个<code class="du jt ju jv jw b">.fit_transform()</code>改为<code class="du jt ju jv jw b">.transform()</code>，并完全删除<code class="du jt ju jv jw b">logreg.fit()</code>。这是无休止的调试和无效结果的秘诀。不用了，谢谢！</p><h2 id="71bf" class="lk kd hi bd ke mg mh mi ki mj mk ml km jg mm mn kq jk mo mp ku jo mq mr ky ms bi translated">对于管道:</h2><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="2ed6" class="lk kd hi jw b fi ll lm l ln lo"><em class="lf">Here's our pipeline, all in one go.</em></span><span id="7f26" class="lk kd hi jw b fi lp lm l ln lo">num_transformer = Pipeline(steps=[<br/>                           ('num_imputer', SimpleImputer(strategy='mean')),<br/>                           ('ss', StandardScaler())])<br/><br/>cat_transformer = Pipeline(steps=[<br/>                           ('cat_imputer', SimpleImputer(strategy='most_frequent')),<br/>                           ('ohe', OneHotEncoder(handle_unknown='ignore'))])<br/><br/>preprocessing = ColumnTransformer(<br/>    transformers=[<br/>        ('numerical sub-pipe', num_transformer, make_column_selector(dtype_include=['float64'])),<br/>        ('categorical sub-pipe', cat_transformer, make_column_selector(dtype_include=['object']))<br/>    ])<br/><br/>complete_pipe = Pipeline(steps=[<br/>    ('preprocessing', preprocessing),<br/>    ('logreg', LogisticRegression(random_state=42))<br/>])<br/><br/>complete_pipe.fit(X_train, y_train)<br/>complete_score = complete_pipe.score(X_train, y_train)<br/>complete_crossval_score = cross_val_score(complete_pipe, X_train, y_train).mean()<br/><br/>scores_table.append(['Complete', complete_score, complete_crossval_score]) <br/>print(tabulate(scores_table, headers=scores_headers))</span><span id="2fc1" class="lk kd hi jw b fi lp lm l ln lo">Dataset      Training score    Cross-val score<br/>---------  ----------------  -----------------<br/>Original           0.996364           0.992727<br/>Complete           0.996364           0.996364</span></pre><p id="001b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了管道，我们的代码更干净，每一步都清楚地拼写出来。对整个管道的任何部分进行更改或添加都很容易，不需要一连串的重命名。此外，为了在我们的维持集上评估我们的模型，我们要做的就是:</p><pre class="jx jy jz ka fd lg jw lh li aw lj bi"><span id="5423" class="lk kd hi jw b fi ll lm l ln lo">final_score = complete_pipe.score(X_test, y_test)<br/>print('Final score on holdout set: ', final_score)</span><span id="25fe" class="lk kd hi jw b fi lp lm l ln lo">Final score on holdout set:  0.9855072463768116</span></pre><figure class="jx jy jz ka fd ij er es paragraph-image"><div class="ab fe cl kb"><img src="../Images/62f8abe7ad960d29edbf988f0be89253.png" data-original-src="https://miro.medium.com/v2/1*5EHnLx1X2TYKqnK02Zs7Rg.gif"/></div></figure><h2 id="e694" class="lk kd hi bd ke mg mh mi ki mj mk ml km jg mm mn kq jk mo mp ku jo mq mr ky ms bi translated">但是等等，还有呢！</h2><p id="3723" class="pw-post-body-paragraph iv iw hi ix b iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js hb bi translated">如果你想升级你的管道，看看下面这些方法:</p><ul class=""><li id="4bdb" class="lq lr hi ix b iy iz jc jd jg ls jk lt jo lu js lz lw lx ly bi translated">使用<a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.FunctionTransformer.html" rel="noopener ugc nofollow" target="_blank"> FunctionTransformer </a>添加您自己的自定义函数！</li><li id="e498" class="lq lr hi ix b iy ma jc mb jg mc jk md jo me js lz lw lx ly bi translated"><a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.FeatureUnion.html" rel="noopener ugc nofollow" target="_blank"> FeatureUnion </a>用于并联组合变压器！</li><li id="887a" class="lq lr hi ix b iy ma jc mb jg mc jk md jo me js lz lw lx ly bi translated">在管道上执行<a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html" rel="noopener ugc nofollow" target="_blank">网格搜索</a>！</li></ul><p id="b708" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望这有助于您过渡到使用管道！学习管道让我对机器学习的理解更加清晰，也让我的代码得到了很多改进。我仍然是数据科学的新手，所以请在评论中留下建议或(特别是)更正！</p><p id="5017" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快乐造型！</p><p id="3e36" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lf">在:</em><a class="ae iu" href="https://github.com/jmarkowi/build_a_pipeline" rel="noopener ugc nofollow" target="_blank"><em class="lf">https://github.com/jmarkowi/build_a_pipeline</em></a>查看我的代码并亲自尝试</p><div class="mu mv ez fb mw mx"><a href="https://github.com/jmarkowi/build_a_pipeline" rel="noopener  ugc nofollow" target="_blank"><div class="my ab dw"><div class="mz ab na cl cj nb"><h2 class="bd hj fi z dy nc ea eb nd ed ef hh bi translated">GitHub-jmarkowi/build _ a _ pipeline:关于如何用…</h2><div class="ne l"><h3 class="bd b fi z dy nc ea eb nd ed ef dx translated">下面是一个关于如何用sklearn的API构建机器学习管道的简短教程。我使用Pipeline()类，因为…</h3></div><div class="nf l"><p class="bd b fp z dy nc ea eb nd ed ef dx translated">github.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl io mx"/></div></div></a></div></div></div>    
</body>
</html>