<html>
<head>
<title>Computer Vision 🤖 Fundamentals with OpenCV 📒</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机视觉🤖OpenCV基础知识📒</h1>
<blockquote>原文：<a href="https://medium.com/codex/computer-vision-fundamentals-with-opencv-9fc93b61e3e8?source=collection_archive---------3-----------------------#2022-10-31">https://medium.com/codex/computer-vision-fundamentals-with-opencv-9fc93b61e3e8?source=collection_archive---------3-----------------------#2022-10-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6002ace6038ab44324407e6c502766d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IicyVgZkYHIoD5O4KFFjRw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片由<a class="ae iu" href="https://pixabay.com/users/placidplace-25572496/" rel="noopener ugc nofollow" target="_blank"> Placidplace </a>来自<a class="ae iu" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><h1 id="96b8" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">什么是计算机视觉？</h1><p id="1aaf" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">人类是天生的视觉动物。我们看，我们听，我们学。<strong class="jv hj"> <em class="kr">计算机视觉</em> </strong>是受人类视觉系统启发的<strong class="jv hj"> <em class="kr">人工智能</em> </strong>的子集，它使计算机能够模仿人类视觉系统从数字图像、视频和其他视觉输入中获取有意义的信息，并根据这些信息采取行动或提出建议。如果说AI使计算机能够思考，那么计算机视觉则使它们能够看到、观察和理解。计算机视觉使用图像处理将图像与预先存在的图像数据库进行比较，然后使用该信息推断图像中的内容。</p><p id="10da" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">计算机视觉可用于多种目的，包括<strong class="jv hj">但不限于</strong>:</p><blockquote class="kx ky kz"><p id="6a49" class="jt ju kr jv b jw ks jy jz ka kt kc kd la ku kg kh lb kv kk kl lc kw ko kp kq hb bi translated">- <strong class="jv hj">识别图像中的物体。</strong></p><p id="1463" class="jt ju kr jv b jw ks jy jz ka kt kc kd la ku kg kh lb kv kk kl lc kw ko kp kq hb bi translated"><strong class="jv hj"> -检测图像中的特定颜色或图案。</strong></p><p id="0c4a" class="jt ju kr jv b jw ks jy jz ka kt kc kd la ku kg kh lb kv kk kl lc kw ko kp kq hb bi translated"><strong class="jv hj"> -识别图像中的人、动物或物体。</strong></p><p id="9c3d" class="jt ju kr jv b jw ks jy jz ka kt kc kd la ku kg kh lb kv kk kl lc kw ko kp kq hb bi translated"><strong class="jv hj"> -检测物体是运动还是静止等。</strong></p></blockquote><h1 id="e213" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">计算机视觉是如何工作的？</h1><p id="8476" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">计算机视觉技术倾向于模仿人脑的工作方式。但是我们的大脑是如何解决视觉物体识别的呢？一个流行的假设是，我们的大脑依靠模式来解码单个物体。这个概念被用来创建计算机视觉系统。</p><p id="5220" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">我们今天使用的计算机视觉算法是基于模式识别的。我们在大量的视觉数据上训练计算机——计算机处理图像，在图像上标记对象，并在这些对象中找到模式。例如，如果我们发送一百万幅花的图像，计算机将分析它们，识别与所有花相似的图案，并在这个过程结束时，创建一个模型“花”因此，每当我们向计算机发送图片时，计算机将能够准确地检测出特定图像是否是花朵。</p><p id="3626" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">今天，我们不缺乏计算机能力。云计算，配合强大的算法，可以帮助我们解决甚至是最复杂的问题。但推动计算机视觉技术向前发展的不仅仅是配有复杂算法的新硬件(我们将在下一节回顾它们)；我们每天生成的令人印象深刻的大量公开可用的视觉数据是这项技术最近发展的原因。据福布斯报道，用户每天在网上分享超过30亿张图片，这些数据被用来训练计算机视觉系统。</p><h1 id="9e9e" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">图像基础</h1><h2 id="feda" class="ld iw hi bd ix le lf lg jb lh li lj jf ke lk ll jj ki lm ln jn km lo lp jr lq bi translated">什么是像素？</h2><p id="c553" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">像素又名图片元素(pix =图片，el =元素)是图像的原子元素。像素组合在一起形成完整的图像、视频、文本或计算机显示器上的任何可见事物。</p><p id="037c" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">在任何显示屏上，一个像素都由一个点或正方形来表示。每个图像是一个矩阵/网格，网格中的每个方块包含一个像素。</p><h2 id="45e1" class="ld iw hi bd ix le lf lg jb lh li lj jf ke lk ll jj ki lm ln jn km lo lp jr lq bi translated">什么是图像？</h2><p id="5351" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">图像表示为像素网格(图像是3D场景的2D投影)。它是图像平面中两个坐标的连续函数；通常表示为(I，j)或(列/宽，行/高)或有些容易混淆的(y，x)。</p><p id="1d62" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">假设一幅图像的分辨率为100 x 200，这意味着我们的图像被表示为像素网格，具有100行和200列，宽度被表示为列数，行数表示图像的高度。总的来说，我们的图像中有100 x 200 = 30，000个像素。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/7d4158173991b016bc8cf77c137bcb9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PuLijRh9qZNfqi-MhNjRKA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">犹他大学<a class="ae iu" href="http://www.math.utah.edu/" rel="noopener ugc nofollow" target="_blank">的二进制像素艺术</a></figcaption></figure><p id="3644" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">任一点的像素值对应于撞击该点的光子强度。每个像素都有一个唯一的逻辑地址，大小为八位或更多，这取决于颜色系统的灰度或颜色。在灰度图像中，每个像素的值在0到255之间，其中0对应“黑色”，255对应“白色”。0到255之间的值是不同的灰度，越接近0的值越暗，越接近255的值越亮。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/f7020ace7b237cba1279758a25ebecae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IQghCaZuouNQvm9hLVHgTA.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片—使用Streamlit制作</figcaption></figure><h2 id="d504" class="ld iw hi bd ix le lf lg jb lh li lj jf ke lk ll jj ki lm ln jn km lo lp jr lq bi translated">色彩空间的类型</h2><p id="ef01" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">对于彩色图像，像素是一组代表各个颜色通道强度的数字。常见的颜色表示有<strong class="jv hj"> RGB(红、绿、蓝)、HSL </strong> ( <strong class="jv hj">色相、饱和度、明度</strong>)、<strong class="jv hj"> HSV </strong> ( <strong class="jv hj">色相、饱和度、明度)</strong> a.k.a <strong class="jv hj"> HSB(色相、饱和度、明度</strong>)。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/797c7c4efbb4b32b38410609c2cf8888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qq2f23im4aBlqx-YMdBG-g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">不同颜色的型号。来源:<a class="ae iu" href="https://commons.wikimedia.org/wiki/File:Color_solid_comparison_hsl_hsv_rgb_cone_sphere_cube_cylinder.png" rel="noopener ugc nofollow" target="_blank">维基媒体</a></figcaption></figure><p id="d6a1" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">这三种颜色中的每一种都由0到255范围内的整数表示，这表示颜色的“多少”。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/0a54d25c68ab64c5b69b364a4d85bcfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMfJq9zTuYP5QkfLU_9qOA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">RGB色域。来源:<a class="ae iu" href="https://en.wikipedia.org/wiki/HSL_and_HSV#To_RGB" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="bfb3" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">根据颜色系统，可以分配不同数量的字节来指定像素的每个颜色分量。例如，在8位颜色系统中，每个像素仅分配一个字节，将调色板限制为仅256种颜色。在用于几乎所有PC显示器和智能手机显示器的常见24位颜色系统中，分配了三个字节，每个字节用于RGB标度的一种颜色，导致总共16，777，216种颜色变化。</p><p id="3958" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">然后，我们将这些值组合成一个RGB元组(红色、绿色和蓝色)，这个元组代表我们的颜色。例如，为了构造一个白色，我们将完全填满红色、绿色和蓝色的桶，就像这样:(255，255，255)。我们可以通过将其他颜色通道的值设置为0来隔离每个颜色通道。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/5890c0ee3bd554e0d2f9680626ca9a71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFBc2vts7roaAbZjPoKHvg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="9595" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">滑块控制每个颜色分量的饱和度，范围从0(无)到255(完全饱和)。每个参数(红色、绿色和蓝色)用一个在<code class="du ma mb mc md b">0</code>和<code class="du ma mb mc md b">255</code>之间的值定义颜色的强度。这意味着有<code class="du ma mb mc md b">256 x 256 x 256 = 16777216</code>种可能的颜色！</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es me"><img src="../Images/cbca7ab14f47c5fce3e6cb6ca8866587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/1*0dGv3Qmon9141r9lkqmpKg.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="b476" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">现在我们已经有了一个基础，所以让我们开始学习OpenCV基础知识。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><h1 id="140f" class="iv iw hi bd ix iy mm ja jb jc mn je jf jg mo ji jj jk mp jm jn jo mq jq jr js bi translated">OpenCV是什么？</h1><p id="e74e" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">OpenCV(开源计算机视觉库)是一个开源的计算机视觉和机器学习软件库。该库拥有超过2500种优化算法，包括一套全面的经典和最先进的计算机视觉和机器学习算法。</p><p id="fd2e" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">OpenCV原生是用C++编写的，但它有Python、Java和MATLAB接口，并支持Windows、Linux、Android和Mac OS。OpenCV的主要目标是实时图像处理。</p><h2 id="c01e" class="ld iw hi bd ix le lf lg jb lh li lj jf ke lk ll jj ki lm ln jn km lo lp jr lq bi translated">安装OpenCV</h2><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mr ms l"/></div></figure><h2 id="7f60" class="ld iw hi bd ix le lf lg jb lh li lj jf ke lk ll jj ki lm ln jn km lo lp jr lq bi translated">加载库并读取图像</h2><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mr ms l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/5586a9d44b52c8f2642097383fe52452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*Bpfktw09dHAQORgquQSacg.png"/></div></figure><p id="b840" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">不，你不是色盲！！！</p><p id="573f" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">图像已经被openCV正确地加载为NumPy数组，但是每个像素的颜色已经被排序为<strong class="jv hj"> <em class="kr"> BGR，而不是RGB </em> </strong>。这是因为当OpenCV在许多年前首次开发时，标准是BGR指令。多年来，标准现在已经变成了RGB，但是OpenCV仍然保持着这种<strong class="jv hj"> <em class="kr">【传统】</em> </strong> BGR顺序，以确保现有代码不会被破坏。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mu ms l"/></div></figure><p id="4cb9" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">好吧，好吧，好吧，我知道这是令人困惑的，所以没有进一步的麻烦，让我们玩像素来可视化和理解。</p><h2 id="a363" class="ld iw hi bd ix le lf lg jb lh li lj jf ke lk ll jj ki lm ln jn km lo lp jr lq bi translated">改变色彩空间，裁剪图像的感兴趣区域</h2><p id="1494" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">图像矩阵的大小= 411*420，图像有许多白色边框，在所有三个通道中的值都是255。因此，我们需要裁剪图像，或者从技术上对图像进行切片，以获得我们的ROI(感兴趣区域)。由于每个图像都是一个NumPy数组，因此我们可以利用NumPy数组切片来裁剪图像。</p><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/4df8c27d055f2ca5457d82c9e087eef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCNrt6MoMuSk2-b7xgeuPQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">NumPy索引和切片:<a class="ae iu" href="http://scipy-lectures.org/intro/numpy/array_object.html" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="6cc6" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">首先，我们需要记住</p><ol class=""><li id="dc29" class="mw mx hi jv b jw ks ka kt ke my ki mz km na kq nb nc nd ne bi translated"><strong class="jv hj"> <em class="kr">高度</em> </strong>是<em class="kr">行的<strong class="jv hj">数。</strong></em> </li><li id="c2fe" class="mw mx hi jv b jw nf ka ng ke nh ki ni km nj kq nb nc nd ne bi translated"><strong class="jv hj"> <em class="kr">宽度</em> </strong>是<em class="kr">列的<strong class="jv hj">号。</strong></em> </li></ol><p id="b9ad" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">屏幕分辨率通常表示为<strong class="jv hj">(水平像素/宽度)x(垂直像素/高度)</strong>。比如<strong class="jv hj"> 1920x1080 </strong>又名<strong class="jv hj"> FHD </strong>，最常见的桌面屏幕分辨率，是指屏幕水平显示1920像素，垂直显示1080像素。</p><p id="8f72" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">在OpenCV中，当我们运行<strong class="jv hj"> <em class="kr"> image.shape </em> </strong>时，它会返回数组维数的元组，通常是单通道的<strong class="jv hj"> <em class="kr">行x列</em> </strong>，即<strong class="jv hj"> <em class="kr">高x宽。</em> </strong></p><p id="6b04" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">所以对于切片图像来说:</p><blockquote class="kx ky kz"><p id="4fa1" class="jt ju kr jv b jw ks jy jz ka kt kc kd la ku kg kh lb kv kk kl lc kw ko kp kq hb bi translated"><strong class="jv hj">img[height _ start:height _ stop，width _ start:width _ stop]= img[x1:x2，y1:y2]= img[rows _ start:rows _ stop，column_start : colmn_stop] </strong></p></blockquote><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/d78520fb48fac0807b7db3db4abd3259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CP_OUwvcQIpJJMx-373DSA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Numpy数组的形状:<a class="ae iu" href="https://www.freecodecamp.org/news/exploratory-data-analysis-with-numpy-pandas-matplotlib-seaborn/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="3e32" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">在OpenCV中，<code class="du ma mb mc md b"><strong class="jv hj">cv2.cvtColor()</strong></code>方法用于将图像从一个颜色空间转换到另一个颜色空间。根据使用情况，OpenCV中有许多可用的颜色空间转换方法。这里我们需要从BGR转换到RGB，我们将看到像素如何在数组中交换它们的位置。</p><p id="64ea" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">让我们对图像中除白色像素外的部分进行切片。请注意，坐标系从左上角开始，到底部—高度，右—宽度。</p><pre class="ls lt lu lv fd nl md nm nn aw no bi"><span id="669b" class="ld iw hi md b fi np nq l nr ns"><strong class="md hj">gmap[100:300, 76:350]</strong></span></pre><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nt"><img src="../Images/01a79c87f52a2ff297e88b5a7e3001d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJFkVQXXD4mO4wMlbNXhlw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">z</figcaption></figure><p id="3d9d" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">为了将图像从BGR的<strong class="jv hj"> <em class="kr">转换成RGB的</em> </strong>，我们需要运行以下程序</p><pre class="ls lt lu lv fd nl md nm nn aw no bi"><span id="829a" class="ld iw hi md b fi np nq l nr ns"><strong class="md hj">rgb_gmap = cv2.cvtColor(gmap, cv2.COLOR_BGR2RGB)</strong></span></pre><p id="3801" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">让我们将图像中除白色像素之外的部分切片，比较像素的交换。</p><pre class="ls lt lu lv fd nl md nm nn aw no bi"><span id="29c8" class="ld iw hi md b fi np nq l nr ns"><strong class="md hj">plt.imshow(gmap[100:300, 76:350])</strong></span><span id="3b74" class="ld iw hi md b fi nu nq l nr ns"><strong class="md hj">plt.imshow(rgb_gmap[100:300, 76:350])</strong></span></pre><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/147377c33d63ba1ec63ddf75ac08b41a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSmTdcjX-rV4J_J55TpLqQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">BGR(左)，RGB(右)</figcaption></figure><p id="fc63" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">现在看一下阵列本身，这里发生了什么</p><blockquote class="nv"><p id="569d" class="nw nx hi bd ny nz oa ob oc od oe kq dx translated">毕竟，数字从来不会说谎:它们只是根据出纳员的数学来讲述不同的故事—路易斯·阿尔贝托·乌雷亚，《魔鬼高速公路:一个真实的故事》</p></blockquote><pre class="og oh oi oj ok nl md nm nn aw no bi"><span id="d332" class="ld iw hi md b fi np nq l nr ns"><strong class="md hj">gmap[100:300, 76:350]<br/></strong>&gt;&gt; array([[[238, 244, 230],<br/>           [155, 218,  92],<br/>           [105, 204,  10], <br/>           ...,<br/>           [217, 217, 217],<br/>           [217, 217, 217],<br/>           [217, 217, 217]]], dtype=uint8)</span><span id="ab5e" class="ld iw hi md b fi nu nq l nr ns"><strong class="md hj">rgb_gmap[100:300, 76:350]<br/></strong>&gt;&gt; array([[[230, 244, 238],<br/>           [ 92, 218, 155],<br/>           [ 10, 204, 105], <br/>           ...,<br/>           [217, 217, 217],<br/>           [217, 217, 217],<br/>           [217, 217, 217]]], dtype=uint8)</span></pre><p id="1578" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">它在矩阵中清晰可见。第三列和第一列交换它们在数组中的值，R← →B</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="ol ms l"/></div></figure><h2 id="d1e9" class="ld iw hi bd ix le lf lg jb lh li lj jf ke lk ll jj ki lm ln jn km lo lp jr lq bi translated">旋转图像</h2><p id="3572" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">OpenCv中的图像旋转是使用方法<code class="du ma mb mc md b"><strong class="jv hj">getRotationMatrix2D().</strong></code> <strong class="jv hj"> </strong>完成的，它需要三个参数:</p><pre class="ls lt lu lv fd nl md nm nn aw no bi"><span id="dab6" class="ld iw hi md b fi np nq l nr ns"><strong class="md hj">1. Center of the image (To act as a pivot).</strong></span><span id="1805" class="ld iw hi md b fi nu nq l nr ns"><strong class="md hj">2. The angle of rotation in degrees. +ve for anti-clockwise, -ve for clockwise.</strong></span><span id="99af" class="ld iw hi md b fi nu nq l nr ns"><strong class="md hj">3. An isotropic scale factor which scales the image up or down according to the value provided.</strong></span></pre><p id="6b15" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">然后，我们使用上一步中的旋转矩阵，对图像应用<code class="du ma mb mc md b"><strong class="jv hj">warpAffine()</strong></code>函数。<a class="ae iu" href="https://docs.opencv.org/3.4/d4/d61/tutorial_warp_affine.html" rel="noopener ugc nofollow" target="_blank">阅读更多</a>。让我们把它应用到我们的图像中。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="mr ms l"/></div></figure><figure class="ls lt lu lv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es om"><img src="../Images/5ea94ef1e5f32848fbfa26c88f75728c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rfWpsWNW-c2fQah_87v4QA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">旋转图像</figcaption></figure><h2 id="87d3" class="ld iw hi bd ix le lf lg jb lh li lj jf ke lk ll jj ki lm ln jn km lo lp jr lq bi translated">调整B <strong class="ak">对和对比度</strong></h2><p id="9d1b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">现在我们知道，当我们在RGB/灰度色彩空间中接近255时，光的强度会更高。为了增加亮度，直观上我们只需要在每个通道中加入常量值，使其接近255。<strong class="jv hj">但是，如果我们检查一个亮度为<em class="kr"> 250 </em>的像素，并尝试给它加上25，会发生什么呢？</strong></p><p id="e564" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">在正常的算术规则下，我们最终得到的值是<em class="kr"> 275 </em>。然而，由于我们将RGB图像表示为8位无符号整数，该整数只能取范围<em class="kr">【0，255】</em>内的值，<strong class="jv hj"> 275是<em class="kr">而不是</em>有效值。那么接下来呢？</strong>好消息是<strong class="jv hj"> OpenCV将执行裁剪并确保像素值不会超出范围<em class="kr">【0，255】</em></strong><em class="kr">又名</em> <strong class="jv hj"> <em class="kr">图像算法</em>。</strong></p><pre class="ls lt lu lv fd nl md nm nn aw no bi"><span id="8ac5" class="ld iw hi md b fi np nq l nr ns"><strong class="md hj">x = np.uint8([250])<br/>y = np.uint8([25])<br/>print(cv2.add(x,y) ) # 250+25 = 275 =&gt; 255<br/>&gt;&gt; </strong>[[255]]</span><span id="0af8" class="ld iw hi md b fi nu nq l nr ns"><strong class="md hj">x = np.uint8([250])<br/>y = np.uint8([255])<br/>print( cv2.subtract(x, y) ) # 250–255 = -5 =&gt; 0<br/>&gt;&gt; </strong>[[0]]</span></pre><p id="0e9a" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">让我们继续增加亮度:</p><pre class="ls lt lu lv fd nl md nm nn aw no bi"><span id="af9d" class="ld iw hi md b fi np nq l nr ns"><strong class="md hj">brighter = np.ones(rgb_gmap.shape, dtype = “uint8”) * 100 </strong><br/># 100 --&gt; can be any value 0-255<br/><strong class="md hj">plt.imshow(cv2.add(rgb_gmap, brighter))</strong></span></pre><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es on"><img src="../Images/711be88ece01ac965a1a52fdc70766e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*PD8tj8TnAUw5rOoMi45YHA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">增亮图像</figcaption></figure><p id="98ea" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">实际上，由于每个通道的像素强度增加了100，图像看起来更“褪色”，比原始图像亮得多。在减法运算中会出现它的对映体。</p><pre class="ls lt lu lv fd nl md nm nn aw no bi"><span id="c1ee" class="ld iw hi md b fi np nq l nr ns"><strong class="md hj">lighter = np.ones(rgb_gmap.shape, dtype = “uint8”)*100<br/></strong># 100 --&gt; can be any value 0-255<br/><strong class="md hj">plt.imshow(cv2.subtract(rgb_gmap, lighter))</strong></span></pre><figure class="ls lt lu lv fd ij er es paragraph-image"><div class="er es oo"><img src="../Images/c4bbe509768ca33dab2f8760bea61ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*vvYzkAO0Rq1hdcCx2iI0Eg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">暗图像</figcaption></figure><p id="4fc4" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">恭喜你！！！现在我们知道了CV和图像的基本原理。下一步是使用OpenCV执行图像处理，我将在下一篇博客中分享。</p><figure class="ls lt lu lv fd ij"><div class="bz dy l di"><div class="ol ms l"/></div></figure><p id="1e10" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">我会试着提出更多机器学习/数据科学的概念，并试着把听起来花哨的术语和概念分解成更简单的。</p><p id="5863" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">我希望你喜欢这篇文章！你可以<strong class="jv hj">关注我</strong> <a class="ae iu" href="https://medium.com/u/430bc504f9d9?source=post_page-----ffbeb5f76a92--------------------------------" rel="noopener"> Afaque Umer </a>获取<strong class="jv hj">更多</strong>这样的文章。</p><p id="d0d8" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kw ko kp kq hb bi translated">感谢阅读🙏继续学习🧠继续分享🤝保持敬畏🤘</p></div></div>    
</body>
</html>