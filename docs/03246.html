<html>
<head>
<title>The ultimate guide to Futures in Java and Guava</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">爪哇和番石榴未来终极指南</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-ultimate-guide-to-futures-in-java-and-guava-c53263dd69dc?source=collection_archive---------9-----------------------#2021-08-24">https://medium.com/codex/the-ultimate-guide-to-futures-in-java-and-guava-c53263dd69dc?source=collection_archive---------9-----------------------#2021-08-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2f18" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">解开未来的混乱</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3c4874ff434254a1e33339a9d146b879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tx8_v_qqK-STfw8e"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@dizzyd718?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">德鲁·格雷厄姆</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="af77" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Java 8中引入了<code class="du kk kl km kn b">CompletableFuture</code>,最终为Java带来了一种更好的处理异步逻辑的方法。与此同时，番石榴为这个问题创造了自己的解决方案。</p><p id="f614" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，你应该使用哪一个？</p><p id="abee" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，让我指出，番石榴有许多与期货交互的类，它们应该一起使用。所以大部分的课程不一定会互相影响。</p><p id="c23e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但是首先，让我们看看普通的Java实现:</p><h1 id="b90d" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">将来的</h1><p id="47a5" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated"><code class="du kk kl km kn b"><a class="ae jn" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html" rel="noopener ugc nofollow" target="_blank">Future</a></code>是基础接口，被Java自己的<code class="du kk kl km kn b">CompletableFuture</code>和Guava的大部分接口和类使用。从Java 5开始就有了。</p><p id="570e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">该接口非常简单，只提供了检查其状态、取消它或以阻塞方式(可选地带有超时)获得结果的方法。这适用于最简单的情况，但是如果您想同时处理多个<code class="du kk kl km kn b">Future</code>或者甚至是链式操作，这个接口很快就会变得乏味。</p><p id="2234" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">摘自java文档的一些示例代码:</p><pre class="iy iz ja jb fd ll kn lm ln aw lo bi"><span id="6733" class="lp kp hi kn b fi lq lr l ls lt">interface ArchiveSearcher { String search(String target); }<br/>class App {</span><span id="9506" class="lp kp hi kn b fi lu lr l ls lt">    ExecutorService executor = ...<br/>    ArchiveSearcher searcher = ...</span><span id="d68a" class="lp kp hi kn b fi lu lr l ls lt">    void showSearch(final String) throws InterruptedException {</span><span id="72b2" class="lp kp hi kn b fi lu lr l ls lt">        Future&lt;String&gt; future<br/>          = executor.submit(new Callable&lt;String&gt;() {<br/>            public String call() {<br/>                return searcher.search(target);<br/>            }});</span><span id="28ce" class="lp kp hi kn b fi lu lr l ls lt">        displayOtherThings(); // do other things while searching</span><span id="391a" class="lp kp hi kn b fi lu lr l ls lt">        try {<br/>            displayText(future.get()); // use future<br/>        } catch (ExecutionException ex) { cleanup(); return; }<br/>    }<br/>}</span></pre><h1 id="3e28" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">可完成的未来</h1><p id="2aef" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">在Java 8中添加了<code class="du kk kl km kn b"><a class="ae jn" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" rel="noopener ugc nofollow" target="_blank">CompletableFuture</a></code>和它的接口<code class="du kk kl km kn b">CompletableTask</code>，以允许更强大的期货操作。这两者紧密耦合，接口基本上可以忽略。</p><p id="c902" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du kk kl km kn b">CompletableFuture</code>实现了<code class="du kk kl km kn b">Future</code>并提供了更多的方法来处理结果:</p><ul class=""><li id="7209" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated"><code class="du kk kl km kn b">thenAccept</code>允许您注册一个函数，该函数将在完成时被调用，其结果将用于从该方法返回的新的<code class="du kk kl km kn b">CompletableFuture</code>。</li><li id="599b" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated"><code class="du kk kl km kn b">exceptionally</code>的功能与<code class="du kk kl km kn b">thenAccept</code>相同，只是在<code class="du kk kl km kn b">CompletableFuture</code>异常完成时被调用。</li><li id="7e1b" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated"><code class="du kk kl km kn b">handle</code>允许您在同一个函数中处理成功值和异常。</li><li id="723e" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated"><code class="du kk kl km kn b">join</code>将阻塞，直到<code class="du kk kl km kn b">CompletableFuture</code>完成，或者返回值或者抛出任何发生的异常。</li></ul><p id="9397" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它还提供了一些创建<code class="du kk kl km kn b">CompletableFutures</code>的便捷方法:</p><ul class=""><li id="c493" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated"><code class="du kk kl km kn b">supplyAsync</code>让我们指定一个将被异步调用的供应商，一旦完成，其结果将是<code class="du kk kl km kn b">CompletableFuture</code>的结果。</li><li id="38ff" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated"><code class="du kk kl km kn b">completedFuture</code>将立即返回一个成功完成的未来。它的对等物<code class="du kk kl km kn b">failedFuture</code>是在Java 9中添加的。</li></ul><p id="8f83" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一些示例代码:</p><pre class="iy iz ja jb fd ll kn lm ln aw lo bi"><span id="73a3" class="lp kp hi kn b fi lq lr l ls lt">public CompletableFuture&lt;List&lt;User&gt;&gt; loadActiveUsers() {</span><span id="43e5" class="lp kp hi kn b fi lu lr l ls lt">    return httpClient.&lt;List&lt;User&gt;&gt;sendAsync(request, bodyHandler)<br/>        .thenApply(this::filterListOfUsersForActiveOnes)<br/>        .exceptionally(throwable -&gt; {<br/>            LOG.warn(throwable);<br/>            return List.of();<br/>       });<br/>}</span><span id="57fe" class="lp kp hi kn b fi lu lr l ls lt">public void displayListOfActiveUsers() {</span><span id="2dad" class="lp kp hi kn b fi lu lr l ls lt">    try {<br/>        CompletableFuture&lt;&gt; activeUsersFuture = loadActiveUsers();<br/>        displayOtherStuff();<br/>  <br/>        try {<br/>            displayActiveUsers(activeUsersFuture.join());<br/>        } catch (CompletionException e) {<br/>            LOG.error(e);<br/>   <br/>            displayNoUsers();<br/>        }<br/>    }<br/>}</span></pre><h2 id="1b4e" class="lp kp hi bd kq mj mk ml ku mm mn mo ky jx mp mq la kb mr ms lc kf mt mu le mv bi translated"><code class="du kk kl km kn b">CompletableFuture</code>的问题</h2><p id="73ff" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">虽然<code class="du kk kl km kn b">CompletableFuture</code>流畅的风格无疑是对<code class="du kk kl km kn b">Future</code>简单方法的巨大改进，但它仍然有其怪癖。</p><p id="1c0e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，人们很容易忘记它也可以被取消。这意味着如果你回复一个<code class="du kk kl km kn b">CompletableFuture</code> <strong class="jq hj">呼叫者可以取消它！</strong>这可能会导致资源没有被正确关闭或出现意外状态。避免这种情况的最简单方法是用另一个包裹你的<code class="du kk kl km kn b">CompletableFuture</code>。</p><p id="1c31" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">另一个问题是异常的处理有点不一致，文档中没有提到:</p><pre class="iy iz ja jb fd ll kn lm ln aw lo bi"><span id="9ca6" class="lp kp hi kn b fi lq lr l ls lt">NullPointerException exception = new NullPointerException(":(");</span><span id="ca80" class="lp kp hi kn b fi lu lr l ls lt">CompletableFuture.failedFuture(exception)<br/>    .exceptionally(throwable -&gt; {<br/>        // here throwable is the exception from above<br/>        return null;<br/>    });</span><span id="bdd7" class="lp kp hi kn b fi lu lr l ls lt">CompletableFuture.failedFuture(exception)<br/>    .thenApply(Object::toString)<br/>    .exceptionally(throwable -&gt; {<br/>        // here throwable is a CompletionException that wraps the<br/>        //  exception from above<br/>        return null;<br/>    });</span></pre><p id="4107" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，只处理特定的异常并不容易。<code class="du kk kl km kn b">exceptionally</code>中的函数接收到一个<code class="du kk kl km kn b">Throwable</code>的实例，这是一个被检查的异常。这意味着如果不先用<code class="du kk kl km kn b">RuntimeException</code>包起来，最好是用<code class="du kk kl km kn b">CompletionException</code>包起来，你就不能再扔了。</p><p id="1a00" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当这些方法中的一个抛出的<code class="du kk kl km kn b">CompletionException</code>被直接返回时(例如当使用<code class="du kk kl km kn b">join</code>时)，嵌套的方法不会被解包。这意味着您很可能会得到类似这样的样板代码:</p><pre class="iy iz ja jb fd ll kn lm ln aw lo bi"><span id="a335" class="lp kp hi kn b fi lq lr l ls lt">.exceptionally(throwable -&gt; {<br/>    while (throwable instanceof CompletionException) {<br/>        throwable = throwable.getCause();<br/>    }</span><span id="7cd0" class="lp kp hi kn b fi lu lr l ls lt">    if (throwable instanceof NullPointerException) {<br/>        // handle the exception I care about<br/>        return null;<br/>    } else {<br/>        throw new CompletionException(throwable);<br/>    }<br/>})</span></pre><h1 id="60c9" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">期货</h1><p id="3d01" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">离开Java标准库，Guava的静态类<code class="du kk kl km kn b"><a class="ae jn" href="https://guava.dev/releases/snapshot/api/docs/com/google/common/util/concurrent/Futures.html" rel="noopener ugc nofollow" target="_blank">Futures</a></code>包含了更有效地处理未来的方法。这主要是通过利用我们接下来要看的<code class="du kk kl km kn b">ListenableFuture</code>接口来实现的。</p><p id="206b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，值得注意的是，它还有一个<code class="du kk kl km kn b">transform</code>方法，允许你基于另一个方法和一个函数创建一个新的未来。新的未来将以所提供的未来被给定的功能转换的结果来完成。这本质上模仿了<code class="du kk kl km kn b">CompletableFuture.thenApply</code>的工作方式。</p><p id="a24c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这堂课应该是你尝试期货和番石榴的第一站！</p><h1 id="df10" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">ListenableFuture</h1><p id="c68a" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated"><code class="du kk kl km kn b"><a class="ae jn" href="https://guava.dev/releases/snapshot/api/docs/com/google/common/util/concurrent/ListenableFuture.html" rel="noopener ugc nofollow" target="_blank">ListenableFuture</a></code>是Guava中实现<code class="du kk kl km kn b">Future</code>的一个简单接口，只增加了一个方法:<code class="du kk kl km kn b">addListener</code>。</p><p id="5ac8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此方法允许您注册一旦将来完成就调用的侦听器。尽管它们不直接得到结果，但是您可以使用<code class="du kk kl km kn b">ListenableFuture</code>本身的<code class="du kk kl km kn b">get</code>方法得到结果。</p><p id="46aa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个接口是在<code class="du kk kl km kn b">Futures</code>类中使用的主要接口。也是大部分Guava未来的类实现的。</p><h2 id="b1fa" class="lp kp hi bd kq mj mk ml ku mm mn mo ky jx mp mq la kb mr ms lc kf mt mu le mv bi translated">ListenableFutureTask</h2><p id="f2c6" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated"><a class="ae jn" href="https://guava.dev/releases/snapshot/api/docs/com/google/common/util/concurrent/ListenableFutureTask.html" rel="noopener ugc nofollow" target="_blank">这个类</a>本质上是<code class="du kk kl km kn b">ListenableFuture</code>接口的一个基本实现。它有两个使用<code class="du kk kl km kn b">Callable</code>或<code class="du kk kl km kn b">Runnable</code>的工厂方法，但除此之外只实现其接口的方法。</p><h2 id="5da4" class="lp kp hi bd kq mj mk ml ku mm mn mo ky jx mp mq la kb mr ms lc kf mt mu le mv bi translated">可确定的未来</h2><p id="61e1" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated"><code class="du kk kl km kn b"><a class="ae jn" href="https://guava.dev/releases/snapshot/api/docs/com/google/common/util/concurrent/SettableFuture.html" rel="noopener ugc nofollow" target="_blank">SettableFuture</a></code>用setter方法扩展了<code class="du kk kl km kn b">ListenableFuture</code>接口的方法。你可以设置它的成功值，例外甚至基于另一个未来来设置。</p><p id="9c37" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个类主要用于当你已经有一个线程，你想完成你的未来。</p><h2 id="62a6" class="lp kp hi bd kq mj mk ml ku mm mn mo ky jx mp mq la kb mr ms lc kf mt mu le mv bi translated">未来</h2><p id="5572" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">顾名思义，<code class="du kk kl km kn b"><a class="ae jn" href="https://guava.dev/releases/snapshot/api/docs/com/google/common/util/concurrent/AbstractFuture.html" rel="noopener ugc nofollow" target="_blank">AbstractFuture</a></code>是<code class="du kk kl km kn b">ListenableFuture</code>接口的抽象实现。除了已经提到的<code class="du kk kl km kn b">addListener</code>和setters，它还有一些公开其内部状态的方法。</p><p id="35c2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你不太可能需要这个类，但是它可以用来实现你自己版本的<code class="du kk kl km kn b">ListenableFuture</code>。</p><h1 id="8443" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">流动未来</h1><p id="5f2b" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated"><code class="du kk kl km kn b">FluentFuture</code>与Java的<code class="du kk kl km kn b">CompletableFuture</code>最为相似。它实现了<code class="du kk kl km kn b">ListenableFuture</code>，还提供了<code class="du kk kl km kn b">transform</code>和<code class="du kk kl km kn b">catching</code>中的映射方法。</p><p id="930f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这种情况下，<code class="du kk kl km kn b">catching</code>允许捕捉特定的异常，而不仅仅是<code class="du kk kl km kn b">Throwable</code>。这使得异常处理的方法更具选择性，理论上检查异常的可能性不会导致大量样板代码。</p><p id="b700" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一些来自其文档的示例代码:</p><pre class="iy iz ja jb fd ll kn lm ln aw lo bi"><span id="4164" class="lp kp hi kn b fi lq lr l ls lt">ListenableFuture&lt;Boolean&gt; adminIsLoggedIn =<br/>     FluentFuture.from(usersDatabase.getAdminUser())<br/>         .transform(User::getId, directExecutor())<br/>         .transform(ActivityService::isLoggedIn, threadPool)<br/>         .catching(RpcException.class, e -&gt; false, directExecutor());</span></pre><h1 id="1cec" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">关闭未来</h1><p id="3656" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated"><code class="du kk kl km kn b"><a class="ae jn" href="https://guava.dev/releases/snapshot/api/docs/com/google/common/util/concurrent/ClosingFuture.html" rel="noopener ugc nofollow" target="_blank">ClosingFuture</a></code>类似于<code class="du kk kl km kn b">FluentFuture</code>，但更多的是作为一个建设者，而不是未来本身。它提供了转换值、捕捉异常和组合多个异常的方法。最后，一个<code class="du kk kl km kn b">ClosingFuture</code>总是要被“完成”。</p><p id="f45d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">目前有两种方法可以完成它:</p><ul class=""><li id="eae4" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated"><code class="du kk kl km kn b">finishToFuture</code>将返回一个<code class="du kk kl km kn b">FluentFuture</code>,一旦<code class="du kk kl km kn b">ClosingFuture</code>定义的所有步骤完成，它将完成。</li><li id="f410" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated"><code class="du kk kl km kn b">finishToValueAndCloser</code>完成后将调用回调。</li></ul><p id="8f87" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">其文档中的一个示例:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mw mx l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">使用ClosingFuture的示例代码摘自其文档</figcaption></figure><h1 id="7a09" class="ko kp hi bd kq kr ks kt ku kv kw kx ky io kz ip la ir lb is lc iu ld iv le lf bi translated">结论</h1><p id="8464" class="pw-post-body-paragraph jo jp hi jq b jr lg ij jt ju lh im jw jx li jz ka kb lj kd ke kf lk kh ki kj hb bi translated">当使用普通Java时，你最好的选择是<code class="du kk kl km kn b">CompletableFuture</code>。一旦你也有番石榴，你有无数的选择。它们都填补了略有不同的空白，并意味着不同层次的细节。</p><p id="75c3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，芭乐的很多课可以很快变得让人应接不暇，一头雾水。</p><p id="b7d1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就个人而言，我可能会多尝试一下<code class="du kk kl km kn b">ClosingFuture</code>和<code class="du kk kl km kn b">FluentFuture</code>，但是现在坚持使用<code class="du kk kl km kn b">CompletableFuture</code>——主要是因为我可以安全地将它放在API中，而不必担心引入新的依赖项。</p></div></div>    
</body>
</html>