<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/codex/lets-build-business-software-an-alternative-approach-to-the-standard-ddd-implementation-47e586b5f81f?source=collection_archive---------1-----------------------#2022-05-14">https://medium.com/codex/lets-build-business-software-an-alternative-approach-to-the-standard-ddd-implementation-47e586b5f81f?source=collection_archive---------1-----------------------#2022-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/52f99ba9cd420007d9bca5db6b1e229b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgLGTQylfj-0E8PNkd9GvA.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由pix abay:<a class="ae hv" href="https://www.pexels.com/photo/close-up-photo-of-cute-sleeping-cat-416160/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/close-up-photo-of-cute-sleeping-cat-416160/</a></figcaption></figure><p id="bb65" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">让我们构建商业软件——标准DDD实施的替代方法</strong></p><p id="6e38" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">无论是运行在门铃芯片上的web应用程序还是代码，世界上每个程序的简化视图都由以下三个步骤组成:</p><p id="f5ee" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">1.取一些数据作为输入</p><p id="24a2" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">2.对数据输入进行一些逻辑运算</p><p id="da10" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">3.产生一些数据输出</p><p id="85d8" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">我们可以把这个过程想象成一个管道，我们在一端输入一些数据，在另一端输出一些数据。</p><p id="e42c" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">真实世界的应用程序是建立在大量这样的管道上的复杂系统。这种复杂性是惊人的，也是人类巨大心智能力的见证。同时，一个人无法单独监督整个复杂性。抽象和模式的引入是为了帮助我们思考软件系统并就此进行交流。编程语言是将我们的想法翻译成机器可读代码的最重要的工具，但它们还不够。</p><p id="49cd" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">在每种编程语言之上，我们使用不同的编程范例来构建和编写程序，例如过程式、函数式、面向对象编程等等。</p><p id="0f33" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">程序员发现了许多不同的代码结构和实现模式，并将其作为下一代的最佳实践记录下来。但是有一个问题。大量的模式、最佳实践、指南和框架本身变得越来越复杂。这违背了降低软件程序复杂性的最初目的。</p><p id="2e61" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">日益增加的复杂性对业务方面产生了直接且可衡量的影响。看似简单的功能和更新的开发时间延长，消耗了我们大量的时间和预算，这阻碍了我们在创新的商业理念上的工作。</p><p id="0517" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">商业价值是原因</strong></p><p id="7f7e" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">开发软件时，我们应该优化三个主要目标:</p><p id="e29a" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">-创造商业价值</p><p id="5d4b" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">-尽可能保持程序代码简单</p><p id="b76b" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">-符合安全性、性能和其他非功能性要求</p><p id="cb14" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">但是商业价值是我们写软件的主要原因。其他任何东西都只是帮助我们快速安全到达目的地的工具。任何决定最终都是由商业驱动的。影响我对软件思考的书籍之一是Eric Evans的“蓝皮书”领域驱动设计。这是软件商业价值的宣言。编程语言、平台、模式、方法和其他任何东西都只是将我们的想法转化为工作代码的手段。</p><p id="66f7" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">实施细节</strong></p><p id="aa9c" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">Eric Evans在他的书中提供了一个被称为技术DDD的实现模型。在那里，您可以找到聚合根、值对象、域服务等等。我花了相当多的时间研究这个模型，参观DDD工作室，并在现实世界的应用程序和几个项目中应用它。在下文中，我将展示一个替代的实现模型，它是从我自己应用技术DDD模式的经验中发展而来的。</p><p id="1ea9" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">一切都是服务</strong></p><p id="d01d" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">一个非常常见的混淆来源是这样一个问题:某个特定的功能是应该作为聚合根的一个方法来实现，还是应该作为域服务来实现。一般的建议是尝试使它成为一个方法，因为聚合根的职责是创建这个事务边界，并确保业务规则在这个边界内是一致的。</p><p id="e4ad" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">不幸的是，随着项目的成熟和我们对领域了解的越来越多，我们开始意识到我们最初的事务边界远远不够。为了满足一个新的复杂的业务规则，我们需要与其他聚合根交互，这引入了一个不想要的和潜在危险的依赖性。</p><p id="2b67" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">进入“域服务”。这是我们开始用来管理不同聚合根之间的交互的东西，同时假装我们的聚合根仍然负责游戏。但不幸的是，情况并非如此。最有趣和最重要的事情现在发生在我们的领域服务中。最终的结局是我们的聚合根变得“贫血”,我们所有的业务逻辑都驻留在域服务中。</p><p id="270d" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">那么我们能做什么呢？回到书本上，再读一遍，学习，参观另一个工作室，最终意识到我们太笨了，不知道如何改正？这当然是一个选择。但是我们也可以尝试为实现细节找到一个实用的解决方案，并且仍然使用DDD的战略模式。</p><p id="f428" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">让我们想一想:如果有价值的业务逻辑倾向于在域服务中结束，那么也许它只是属于这个地方？是的，域服务是丑陋的野兽，但归根结底，它们只是接受一些输入、应用一些业务规则和创建一些输出的管道。等等，这听起来像纯函数，我们应该使用函数式编程来实现我们的领域规则吗？在我们更好地理解我们正在处理的问题之前，我们不要过于匆忙地走向另一个极端。</p><p id="55a8" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">我们需要后退一步，想想我们真正想要实现的是什么。我就是这么做的。在下文中，我将描述最重要的模式，它们帮助我建立了一个直接、一致的方法来实现业务规则。</p><p id="1cd7" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">基于任务的命令——行为优先</strong></p><p id="dda2" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">基于任务的命令是一个对象，其中命令的名称描述了应用程序用户改变应用程序状态的意图。例如“预订选定的房间”描述了一个命令，您猜对了，它的目的是预订选定的房间。该物体可以具有以下形状:</p><pre class="iw ix iy iz fd ja jb jc jd aw je bi"><span id="5362" class="jf jg hy jb b fi jh ji l jj jk">class BookSelectedRoom {<br/>    selectedRoomId: string;<br/>    startTime: Date;<br/>    endTime: Date;<br/>}</span></pre><p id="362f" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">该命令描述了意图，并以属性的形式提供了一些上下文。我们可以实现业务规则来完成给定的任务并运行命令。当命令执行成功时，应用程序状态的一部分应该被改变，例如，会议被创建，邀请电子邮件和提醒被创建等等。</p><p id="0a94" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">为了使命令成功，我们希望满足重要的业务规则，例如，我们可能希望将一个房间限制为同时举行一次会议。这种逻辑通常驻留在所谓的命令处理程序中，但我认为更好的选择是将属于一起的东西放在一起，只需向我们的<em class="jl"> BookSelectedRoom </em>类添加一个方法“handle”。这样我们也去掉了额外的类<em class="jl"> BookSelectedRoomHandler </em>，降低了一点代码的复杂性。</p><p id="f205" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">但是，在没有任何应用程序状态信息的情况下，handle方法应该如何确保所有这些复杂的业务不变量呢？</p><p id="971f" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">在命令处理程序中，依赖问题通常通过依赖注入来解决，其中命令处理程序被DI容器代替，并接收其他服务和存储库作为依赖。但是这种对实际内部实现细节的明确陈述对于测试来说是一个问题。</p><p id="2d9e" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">一个好的经验法则是，我们的测试应该测试公共api，并且不应该在实现细节改变时改变。假设我们的命令处理程序有一个依赖项X。在我们的测试中，我们模拟或初始化这个依赖项X，并将其传递给被测试者。一个月后，我们决定用依赖项Y替换依赖项X，或者添加一个依赖项z。现在，我们需要修复所有的测试，并设置正确的模拟或存根，尽管业务规则或需求没有改变。</p><p id="7493" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">总之，我们有两个理由不使用命令处理程序:</p><ol class=""><li id="8f2b" class="jm jn hy hz b ia ib ie if ii jo im jp iq jq iu jr js jt ju bi translated">代码复杂性增加</li><li id="490a" class="jm jn hy hz b ia jv ie jw ii jx im jy iq jz iu jr js jt ju bi translated">我们的测试套件的稳定性。</li></ol><p id="fef2" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">为了解决代码复杂性问题，我们选择直接在命令中实现handle方法。但是如何解决依赖问题呢？进入“应用状态”。</p><p id="5882" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">应用状态</strong></p><p id="446e" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">一个思想实验:想象一下，如果你有所有的计算能力和所有的存储在你的指尖，每个数据库提交即时发生，网络故障不存在，带宽是无限的，延迟等于零。你会如何编写你的计算机程序？</p><p id="902c" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">我们所知道的许多设计和架构模式都源于优化系统性能的需要。在一个完美的世界中，我们可以简单地获取一个巨大而复杂的应用程序的完整状态，在系统的某个角落改变那个微小对象的字符串，并保存整个应用程序状态，而不会影响任何其他用户。在现实世界中，我们必须确保只读取所需的对象，并且在保存更改时不会锁定整个应用程序状态。</p><p id="f005" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">我们不能违背物理定律，但是让应用程序状态唾手可得的想法仍然很有吸引力。我们可以传递对整个应用程序状态的引用吗？然后，我们的handle方法可以决定它需要状态的哪些部分来满足复杂的业务不变量。这种应用程序状态的界面可能如下所示:</p><pre class="iw ix iy iz fd ja jb jc jd aw je bi"><span id="55ee" class="jf jg hy jb b fi jh ji l jj jk">interface State {<br/>    getById&lt;T&gt;(id: string): T where T is Entity;<br/>    findAll&lt;T&gt;(query: QueryExpression)<br/>    add(entity: Entity);<br/>    remove(entity: Entity);<br/>    resolveService&lt;S&gt;();<br/>    saveChanges();<br/>}</span></pre><p id="ffa0" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">上面的实现看起来有点像通用存储库，但是它有一些显著的不同。首先，它不局限于单个实体类型。其次，它表示应用程序状态，不仅是数据，还包括注册的服务和一些应用程序特定的方法。它更像是我们应用程序世界的一个门面。</p><p id="7d62" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">工作模式单位</strong></p><p id="4c4b" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">我们在内存中引用的状态显然不是物理磁盘上的完整状态。我们只使用内存中的一部分状态，并延迟加载手头任务所需的数据。</p><p id="de19" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">此外，当我们向状态添加一个新对象时，它不会立即提交到磁盘。相反，我们在内存状态中累积我们的更改，并在完成后尝试一次提交所有更改，如果失败，我们将丢弃我们的更改，并可能稍后再试。</p><p id="300a" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">这就是所谓的“工作单元”模式的工作原理。主要的优势是我们可以在内存中工作，并确保我们的更改要么全部提交，要么不提交。我们可以在内存中链接我们的命令处理程序，并确保没有不一致的更改被写入磁盘。</p><p id="dde6" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">处理方法</strong></p><p id="aace" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">现在让我们实现我们的handle方法并添加一些上下文。</p><pre class="iw ix iy iz fd ja jb jc jd aw je bi"><span id="64e3" class="jf jg hy jb b fi jh ji l jj jk">interface Entity {<br/>    id: string;<br/>}</span><span id="6d6a" class="jf jg hy jb b fi ka ji l jj jk">class Room : Entity {<br/>    lastBookedOn: Date;<br/>}</span><span id="ce64" class="jf jg hy jb b fi ka ji l jj jk">class RoomBooking : Entity {<br/>    roomId: string<br/>    startDate: Date;<br/>    endDate: Date;<br/>    isBlockedOn(date: Date) {<br/>        return date &gt; endDate || date &lt; startDate;<br/>    }<br/>}</span><span id="543c" class="jf jg hy jb b fi ka ji l jj jk">class ClockService {<br/>    getTime(): {<br/>        return new Date();<br/>    }<br/>}</span><span id="edcd" class="jf jg hy jb b fi ka ji l jj jk">class RoomBookedEvent {<br/>    id: string;<br/>    roomBookingId: string;<br/>    isHandled: boolean;<br/>}</span><span id="e83d" class="jf jg hy jb b fi ka ji l jj jk">class BookSelectedRoom {<br/>    selectedRoomId: string;<br/>    startTime: Date;<br/>    endTime: Date;<br/>    handle(State state) {<br/>       // find future room bookings<br/>       var roomBookings = state<br/>          .findAll&lt;RoomBooking&gt;(r =&gt; <br/>              r.roomId == selectedRoomId &amp;&amp;<br/>              r.endDate &gt; startDate);<br/>       // check if room is already booked<br/>       if (roomBookings<br/>           .Any(r =&gt; <br/>                r.isBlockedOn(startTime) || <br/>                 r.isBlockedOn(endTime))) {<br/>            throw new BusinessError(“room is already booked”);<br/>       }</span><span id="24ae" class="jf jg hy jb b fi ka ji l jj jk">       // add a new room booking<br/>       var roomBooking = new RoomBooking() {<br/>                           id: Rand.newId(),<br/>                           roomId: selectedRoomid,<br/>                           startDate: startDate,<br/>                           endDate: endDate,<br/>                         }<br/>       state.add(roomBooking)</span><span id="7b94" class="jf jg hy jb b fi ka ji l jj jk">      // update the last booked date for optimistic concurrency<br/>      var clockService = state.ResolveService&lt;ClockService&gt;()<br/>      var room = state.getById&lt;Room&gt;(selectedRoomId);<br/>      room.lastBookedOn = clockService.getTime();<br/>     <br/>      // add a domain event to the state<br/>      state.add(new RoomBookedEvent(){<br/>                  id: Rand.newId(),<br/>                  isHandled: boolean;<br/>                  roomBookingId: roomBooking.id<br/>              })<br/>    }<br/>}</span></pre><p id="a6a6" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">handle方法使用应用程序状态为房间选择所有相关的未来预订。然后，它检查在选定的时间段内是否已经存在任何房间预订。如果已经有房间预订，我们抛出一个BusinessError。我们希望区别对待业务错误和技术错误。业务错误可能只是在用户界面上触发一个警告，而技术错误应该通知开发团队发生了意想不到的事情。如果这个时间段还没有房间预订，我们就创建一个新的。然后其他有趣的事情也发生了。</p><p id="905f" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">依赖注入</strong></p><p id="bb4c" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">首先，我们解决时钟服务。显然，只有在我们使用某种依赖注入的情况下，它才会起作用。应用程序状态的实现需要将我们的请求转发给返回ClockService的DI容器。我们使用这种依赖性，而没有在构造函数或其他地方进行显式声明。如果你像我一样已经使用DI很多年了，当你看到这个的时候，它可能会伤害你的身体，但是我认为它实际上没有那么糟糕。</p><p id="ada6" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">ClockService是一个依赖项，但它不是公共API的一部分。我们不会给普通用户压力去考虑这个时钟服务以及如何传递正确的实例。这是一个不应该破坏公共API的实现细节。例如，我们现在也可以将ClockService换成某个UtcClockService。然后，我们只需要更新我们的测试DI容器，我们的测试应该仍然工作，我们不必经历所有的测试和更新所有的实例。</p><p id="5021" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">乐观并发</strong></p><p id="1b40" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">第二个有趣的部分是对Room对象的lastBookedOn属性的更新。这似乎真的没有用，因为我们没有在这里执行任何规则。但是出于并发性的原因，我们需要它。假设另一个用户试图在同一时间同一时间段预订房间。两个用户都阅读了现有房间预订列表，都发现还没有房间预订，都创建了一个新的房间预订。没有其他检查可以防止在命令完成后将两个房间预订都写入磁盘，这将导致双重预订。</p><p id="98e5" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">为了防止这种并发问题，两个用户都需要读取和更改一个现有的对象。当两者都试图在同一个对象上保存它们的更改时，开放式并发就开始了。根据我们使用的数据库技术，开放式并发的实现会有所不同，但总的想法是:</p><p id="732a" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">数据库保存对象的内部版本或散列。当我们将一个对象从数据库加载到内存中时，我们也保存最新的版本号/哈希，当我们试图更新对象时，我们也将这个版本发送到数据库。数据库检查在此期间版本是否发生了变化，如果发生了变化，将拒绝写操作。</p><p id="f55c" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">域名事件</strong></p><p id="426f" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">在最后一步中，我们存储一个新域事件，告诉系统发生了什么:一个房间被预订了。显然，域事件还没有被处理，它保存了对房间预订id的引用。请注意，我们不会尝试在域事件上实现一个handle方法，因为可能有很多或者根本没有处理程序，这样一个方法的实现很快就会变得一团糟。相反，我们将创建新的命令来处理这个事件。例如，我们可以考虑在发票上下文中使用HandleRoomBooking命令，该命令将为房间预订创建发票。</p><p id="735c" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">域事件处理</strong></p><p id="4af2" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">您可能已经注意到只有一个isHandled布尔标志，而我们期望有多个事件处理程序。这个标志实际上只用于确保域事件被提交给消息总线。消息总线必须确保事件的所有订阅者都能收到事件的副本。订阅者也是带有handle方法和域事件副本属性的命令。下一个问题是:我们实际上如何确保域事件被提交到消息总线。</p><p id="470c" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">发布域事件</strong></p><p id="52d6" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">一种选择是在我们保存更改后，直接在消息总线上发布域事件。这确实引入了两阶段提交的问题。这个问题一般不容易解决。主要的问题是，在我们保存我们的更改后，消息总线连接可能会消失，因此，域事件将永远不会发布。此外，仅仅重试域事件的发布是很困难的，因为我们需要重新运行命令。</p><p id="720d" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">第二种选择只有在底层数据库技术有一个内置的消息队列来通知订阅者变化时才有效。不利的一面是，我们需要一个永远在线的服务来订阅这些变化。在一个没有服务器的世界里，这不是一个令人满意的解决方案。此外，我们的架构变得有点复杂，因为我们必须实现、部署和监控额外的服务。</p><p id="c4e0" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">我最终接受的选择是第一个选择的变体。我没有将真正的域事件提交给消息总线，而是首先在消息总线上发布一个“检查事件”,它将在以后触发一个检查功能。如果“检查事件”的发布失败，我们只需要重新运行发布。同样，下一个命令也很有可能完成发布。check函数将收集所有未决的域事件，并将它们提交给消息总线。主要优点是这个过程是可重复的，我们可以在任何时候触发检查功能来解决所有未处理的域事件。</p><p id="63b9" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">薄应用层</strong></p><p id="5034" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">现在我们已经有了所有的构建模块，我们需要把它们缝合在一起，让它真正工作。这些命令可以通过简单的http post请求来触发。我们可以创建一个简单的命令控制器，它在主体中以json对象的形式接收命令。主体被反序列化，命令对象实例被创建。现在我们需要从DI容器中解析应用程序状态，并运行handle命令。此时，我们可以添加重试逻辑、日志记录等。或者在命令上添加更多的方法来处理权限逻辑、验证命令属性等等。</p><p id="4092" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">最好的部分是，我们只需要实现一次应用层，并将其用于任何进一步的命令。</p><p id="54fe" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated"><strong class="hz iv">回到正题</strong></p><p id="9861" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">我们后退一步，为领域的实现定义了新的构建块。它解决了域服务的初始问题吗？在我看来，答案是肯定的。</p><p id="701c" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">DDD原著中提到的技术实现的一个问题是对面向对象的关注。如果你从写这本书的时代背景来看，这是完全有意义的，但是在我与不同团队合作并了解DDD的这些年中，我得出的结论是，技术上的DDD实现模型要么太难理解，要么不够简单，无法经得起考验。</p><p id="d498" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">最后，为了把事情做好，我们必须务实，我的方法现在是把100%的注意力放在领域的行为——命令——上，把逻辑集中在那里，而不是试图为“汽车”或“银行账户”或“房间”的概念找到完美的聚合根。似乎面向对象很难做对，并且经常以spagetthi代码告终。</p><p id="187f" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">另一方面，我们有这种简单的命令式方法，它使用基于任务的命令来处理单一用例。只要阅读命令类的名称，就很容易理解代码的意图。handle方法中的代码可以是过程化的、函数式的和面向对象的范例的混合。这些只是可以改变的实现细节，希望不会破坏我们的自动化测试。</p><p id="7ff4" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">这是我在过去2年中在现实世界应用程序的生产中使用的设计模式的一个非常简短的概述。在这段时间里，我能够减少技术细节的复杂性，将更多的精力放在能够构建和管理复杂的在线预订系统的领域上。</p><p id="b492" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">我希望你喜欢这本书，干杯！</p><p id="ddb0" class="pw-post-body-paragraph hw hx hy hz b ia ib ic id ie if ig ih ii ij ik il im in io ip iq ir is it iu hb bi translated">古罗马的</p></div></div>    
</body>
</html>