<html>
<head>
<title>TypeScript Type Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字指南</h1>
<blockquote>原文：<a href="https://medium.com/codex/typescript-type-guide-747377f39afb?source=collection_archive---------6-----------------------#2021-07-06">https://medium.com/codex/typescript-type-guide-747377f39afb?source=collection_archive---------6-----------------------#2021-07-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/86952ea0859659152c0f719b75df67ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2f1lCdtqoP_BnPeZby3QRg.png"/></div></div></figure><div class=""/><p id="2385" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用于编写大型应用程序的最有趣的语言之一是<strong class="is hu"> TypeScript </strong>语言。它很特别，因为它是一个<strong class="is hu"> JavaScript超集</strong>，但是添加了类型、接口和许多其他东西。这意味着它并不打算取代JavaScript，它只是为了方便开发，使JavaScript应用程序更具可伸缩性和可维护性。</p><p id="dd13" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这种语言不需要任何关于JavaScript或任何其他类型语言(如Java或C)的高级知识，因此，中级JavaScript开发人员已经可以享受它的优势，因为可以一点一点地学习它的特性并逐渐应用它们。</p><blockquote class="jo jp jq"><p id="ab34" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">本指南试图解决与语言理论相关的概念，将某些部分如安装和配置放在一边。</p></blockquote><h1 id="6a94" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">💙打字</h1><p id="2ba5" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">与许多人的想法相反，<strong class="is hu"> TypeScript不是一种强类型语言</strong>，因为它没有必要键入所有的变量。简单变量类型可以在声明时由TypeScript自动推断，如数字或字符串。这个特性叫做<strong class="is hu">型推理</strong>。</p><blockquote class="jo jp jq"><p id="8556" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">任何类型不能由TypeScript推断的变量都会自动类型化为Any。</p></blockquote><h2 id="93a0" class="ky jw ht bd jx kz la lb kb lc ld le kf jb lf lg kj jf lh li kn jj lj lk kr ll bi translated">任何:</h2><p id="b2e3" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">意味着任何东西，当变量的类型不确定时使用，主要情况是当我们不知道第三方库的实体类型时。应该尽可能避免使用它。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="6ebc" class="ky jw ht lr b fi lv lw l lx ly">let anyType: any;<br/>anyType = 5;<br/>anyType = 'Hello World';<br/>anyType = true;</span></pre><h2 id="ebbd" class="ky jw ht bd jx kz la lb kb lc ld le kf jb lf lg kj jf lh li kn jj lj lk kr ll bi translated">字符串:</h2><p id="16be" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">由单引号、双引号或反勾号包围的字符集。这些代表字母、单词或短语。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="496e" class="ky jw ht lr b fi lv lw l lx ly">const myString: string = 'My String';</span></pre><h2 id="c37d" class="ky jw ht bd jx kz la lb kb lc ld le kf jb lf lg kj jf lh li kn jj lj lk kr ll bi translated">编号:</h2><p id="4b5e" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">任何数字，无论是自然数、整数还是有理数。它们没有引号，因为在这种情况下它们会被视为字符串。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="88a2" class="ky jw ht lr b fi lv lw l lx ly">const myNumber: number = 8;</span></pre><h2 id="6ddb" class="ky jw ht bd jx kz la lb kb lc ld le kf jb lf lg kj jf lh li kn jj lj lk kr ll bi translated">布尔型:</h2><p id="de37" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">只能取两个值的变量类型:<strong class="is hu"> true </strong>或<strong class="is hu"> false </strong>。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="1702" class="ky jw ht lr b fi lv lw l lx ly">const myBoolean: boolean = true;</span></pre><h2 id="3eb0" class="ky jw ht bd jx kz la lb kb lc ld le kf jb lf lg kj jf lh li kn jj lj lk kr ll bi translated">数组:</h2><p id="ee78" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">数组是一个无序的数据列表，它有几个相同类型的元素。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="e838" class="ky jw ht lr b fi lv lw l lx ly">const myNumberArray: Array&lt;number&gt; = [1, 2, 5, 10];</span><span id="8cec" class="ky jw ht lr b fi lz lw l lx ly">const myStringArray: Array&lt;string&gt; = ['Hello', 'World', '!'];</span></pre><h2 id="664b" class="ky jw ht bd jx kz la lb kb lc ld le kf jb lf lg kj jf lh li kn jj lj lk kr ll bi translated">元组:</h2><p id="71c4" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">虽然JavaScript本身没有元组，但是TypeScript允许我们在数组中模拟它们。元组是有限元素的列表，通常很短，每个元素都有特定的类型。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="2761" class="ky jw ht lr b fi lv lw l lx ly">const myTuple: [string, number] = ['Hello World', 16];</span></pre><h2 id="0612" class="ky jw ht bd jx kz la lb kb lc ld le kf jb lf lg kj jf lh li kn jj lj lk kr ll bi translated">枚举:</h2><p id="64c0" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">这是一种将熟悉的名字添加到数字列表中的方法。默认情况下，值从零开始，自动递增。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="68a7" class="ky jw ht lr b fi lv lw l lx ly">enum MyNumbersList {Zero, One, Two};</span><span id="db18" class="ky jw ht lr b fi lz lw l lx ly">const myNumber: MyNumberList = MyNumbersList.One; // 1</span></pre><p id="135b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还可以为每个元素设置一个特定的值。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="5a5c" class="ky jw ht lr b fi lv lw l lx ly">enum AgeList {<br/>  MyAge = 18,<br/>  DadAge = 40,<br/>  MomAge = 38<br/>}</span><span id="29da" class="ky jw ht lr b fi lz lw l lx ly">const myAge: AgeList = AgeList.MyAge; // 18  </span></pre><p id="82d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，我们可以做相反的过程。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="87d1" class="ky jw ht lr b fi lv lw l lx ly">enum ColorList {Red, Green, Blue};</span><span id="523a" class="ky jw ht lr b fi lz lw l lx ly">const myColor: string = ColorList[1]; // 'Green'</span></pre><h2 id="debf" class="ky jw ht bd jx kz la lb kb lc ld le kf jb lf lg kj jf lh li kn jj lj lk kr ll bi translated">无效:</h2><p id="7965" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">就像any的反义词，void就是完全没有类型。通常用于键入不返回任何内容的函数。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="8035" class="ky jw ht lr b fi lv lw l lx ly">function helloWorld(): void {<br/>  console.log('Hello World!');<br/>}</span></pre><blockquote class="jo jp jq"><p id="e782" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">将void赋给变量是没有用的，因为在这些情况下我们只能将其设置为null或undefined。</p><p id="22cc" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">如果我们想在一个变量中存储一个void函数的返回，我们将有值<strong class="is hu">未定义</strong></p></blockquote><h2 id="d554" class="ky jw ht bd jx kz la lb kb lc ld le kf jb lf lg kj jf lh li kn jj lj lk kr ll bi translated">空且未定义:</h2><p id="6e25" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">就像void、null和undefined本身没有用一样，通常与<strong class="is hu">联合类型</strong>一起使用(我们将在本文后面讨论)。Null和undefined表示变量中没有值。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="c727" class="ky jw ht lr b fi lv lw l lx ly">const u: undefined = undefined;<br/>const n: null = null;</span></pre><h2 id="60cf" class="ky jw ht bd jx kz la lb kb lc ld le kf jb lf lg kj jf lh li kn jj lj lk kr ll bi translated">从不:</h2><p id="9e82" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">那种类型表示函数永远不会返回，当我们确信某事永远不会发生时。使用这种类型的一些情况:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="d28f" class="ky jw ht lr b fi lv lw l lx ly">// Function that always throw an error<br/>function error(): never {<br/>  throw new Error('Something went wrong!');<br/>}</span><span id="ddb7" class="ky jw ht lr b fi lz lw l lx ly">// Function with an unreachable end<br/>function loop() {<br/>  while(true) {<br/>    console.log('It will never end!');<br/>  }<br/>}</span></pre><h2 id="c90e" class="ky jw ht bd jx kz la lb kb lc ld le kf jb lf lg kj jf lh li kn jj lj lk kr ll bi translated">对象:</h2><p id="70c6" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">根据TypeScript文档，对象是具有属性的值。要定义一个对象类型，只需列出它的属性和类型。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="3982" class="ky jw ht lr b fi lv lw l lx ly">// Define object properties types<br/>const Person {<br/>  name: string;<br/>  age: number;<br/>  description?: string;<br/>};</span><span id="7b17" class="ky jw ht lr b fi lz lw l lx ly">// Give each property a value<br/>person = {<br/>  name: 'Rafael',<br/>  age: 18<br/>};</span></pre><h1 id="0c97" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">👫工会类型</h1><p id="8fad" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">当我们需要一个变量有多种类型时，就会用到这个特性。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="a6d9" class="ky jw ht lr b fi lv lw l lx ly">// Declares a function that receives name (string)<br/>// and age (string or number)<br/>function sayMyNameAndAge(name: string, age: string | number) {<br/>  console.log(`My name is ${name} and I'm ${age} years old`)<br/>}</span><span id="fae6" class="ky jw ht lr b fi lz lw l lx ly">sayMyNameAndAge('Rafael', 19); // OK<br/>sayMyNameAndAge('Rafael', '19'); // OK<br/>sayMyNameAndAge('Rafael', true); // Error</span></pre><h1 id="4412" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">🔍类型断言</h1><p id="a9d6" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">有时，在某些情况下，您会比TypeScript本身更了解一个值。<strong class="is hu">类型断言</strong>是告诉编译器“嘿，相信我，我知道我在做什么”的一种方式，防止编译时可能出现的错误(在运行时没什么区别)。</p><p id="ff8d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类型断言有两种可能的语法:</p><h2 id="1156" class="ky jw ht bd jx kz la lb kb lc ld le kf jb lf lg kj jf lh li kn jj lj lk kr ll bi translated">尖括号语法</h2><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="ea1a" class="ky jw ht lr b fi lv lw l lx ly">const message: any = 'This is a string with any type!';<br/>const messageLength: number = (&lt;string&gt;message).length;</span></pre><h2 id="4297" class="ky jw ht bd jx kz la lb kb lc ld le kf jb lf lg kj jf lh li kn jj lj lk kr ll bi translated">“As”语法</h2><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="ba7a" class="ky jw ht lr b fi lv lw l lx ly">const message: any = 'This is a string with any type!';<br/>const messageLength: number = (message as string).length;</span></pre><h1 id="3df3" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">🗺类型别名</h1><p id="642e" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">基本上是为某个类型创建一个名字，它们类似于接口，但是可以命名原语、并集、元组等。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="8c19" class="ky jw ht lr b fi lv lw l lx ly">type myTuple = [string, number, boolean];</span><span id="4604" class="ky jw ht lr b fi lz lw l lx ly">const tuple: myTuple = ['Hello', 25, true];</span></pre><p id="91ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们也可以使用这个功能来定义变量的精确可能值。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="29af" class="ky jw ht lr b fi lv lw l lx ly">type OS = 'Windows' | 'Mac OS' | 'Linux';</span><span id="f311" class="ky jw ht lr b fi lz lw l lx ly">const myOs = 'Windows'; //OK<br/>const myPhoneOs = 'ios'; //Error</span></pre><h1 id="4d65" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">📃连接</h1><p id="2e90" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">接口本质上是一个对象的类型。该功能允许我们使用相同类型的对象，而无需代码重复。</p><p id="c604" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看看两个具有相同属性但没有使用接口的对象的声明:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="0659" class="ky jw ht lr b fi lv lw l lx ly">const point: {<br/>  x: number;<br/>  y: number;<br/>};<br/><br/>point = { x: 5, y: 12 };<br/><br/>const point2: {<br/>  x: number;<br/>  y: number;<br/>};<br/><br/>point2 = { x: 8, y: 20 };</span></pre><p id="ed47" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在看同一个例子，但是这次使用了接口:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="3730" class="ky jw ht lr b fi lv lw l lx ly">interface IPoint {<br/>  x: number;<br/>  y: number;<br/>};<br/><br/>const point: IPoint = { x: 5, y: 12 };<br/>const point2: IPoint = { x: 8, y: 20 };</span></pre><p id="7536" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想给某个对象添加某个属性，我们也可以扩展一个接口。看:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="fd91" class="ky jw ht lr b fi lv lw l lx ly">interface IPoint {<br/>  x: number;<br/>  y: number;<br/>};<br/><br/>interface IPoint3d extends IPoint{<br/>  z: number;<br/>};<br/><br/>const point: IPoint = { x: 5, y: 12 };<br/>const point3d: IPoint3d = { x: 8, y: 20, z: 5 };</span></pre><p id="b8ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者更好的是，我们可以将“z”定义为可选属性，从而创建一个唯一的接口:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="914d" class="ky jw ht lr b fi lv lw l lx ly">interface IPoint {<br/>  x: number;<br/>  y: number;<br/>  z?: number;<br/>};<br/><br/>const point: IPoint = { x: 5, y: 12 };<br/>const point3d: IPoint = { x: 8, y: 20, z: 5 };</span></pre><blockquote class="jo jp jq"><p id="a593" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">根据TypeScript文档，尽管很相似，但这些接口在代码中带来了更多的资源。因此，从理想的角度来看，使用接口比使用类型别名功能更好，类型别名功能只是作为最后的手段使用。</p></blockquote><h1 id="6c6b" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">📐交叉点类型</h1><p id="328b" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">这个特性使得某个变量必须满足分配给它的所有类型的契约。看:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="e1fe" class="ky jw ht lr b fi lv lw l lx ly">interface IUser {<br/>  name: string;<br/>  password: string;<br/>};<br/><br/>interface IChar {<br/>  nickname: string;<br/>  level: number;<br/>};<br/><br/>type UserInfo = IUser &amp; IChar;<br/><br/>const userInfo: UserInfo = {<br/>  name: 'Rafael',<br/>  password: '123456',<br/>  nickname: 'LopeKillz',<br/>  level: 255<br/>};</span></pre><h1 id="6380" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">❓通用类型</h1><p id="517c" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">泛型类型可以理解为必须包含或引用另一种类型的类型。最常见的是<strong class="is hu">数组</strong>和<strong class="is hu">承诺</strong>。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="4e3f" class="ky jw ht lr b fi lv lw l lx ly">// Array<br/>// Declares a number array<br/>const numbersArray: Array&lt;number&gt; = [0 , 5, 10];<br/><br/>// Promise<br/>// Declares a Promise that returns a string when resolved <br/>const stringPromise: Promise&lt;string&gt; = new Promise(resolve =&gt; {<br/>  resolve('Hello World!');<br/>});</span></pre><p id="d405" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过使用泛型类型，我们可以避免在一个函数中使用any类型，该函数接受一个具有几种可能类型的参数。使用这种策略，我们只允许在调用函数时声明参数类型。看:</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="d84b" class="ky jw ht lr b fi lv lw l lx ly">// First of all, we declare a function that will take a parameter of <br/>// any type and return it<br/>function indentify&lt;T&gt;(arg: T): T {<br/>  return arg;<br/>};</span><span id="aaf3" class="ky jw ht lr b fi lz lw l lx ly">// So we can call the function above passing as parameter a string<br/>identify&lt;string&gt;('Hello World');</span><span id="2230" class="ky jw ht lr b fi lz lw l lx ly">// We can also call the same function, but this time passing a <br/>// number as parameter<br/>identify&lt;number&gt;(18);</span></pre><blockquote class="jo jp jq"><p id="47f1" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">很多时候，我们不需要指定参数类型，因为<strong class="is hu">类型推断</strong></p></blockquote><h1 id="3843" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">✅结论</h1><p id="791e" class="pw-post-body-paragraph iq ir ht is b it kt iv iw ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn hb bi translated">这是关于类型脚本类型以及如何最好地使用它们的一般指南。当然，这种语言还有其他几个特性，比如decorators，但是重要的是从基础开始，一点一点深入下去。</p><p id="c7d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文是进入类型化JavaScript世界的一个很好的入口，因为我们以简单明了的方式介绍了许多功能。我希望我已经帮助了那些花时间阅读所有主题的人。</p><p id="56a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想更深入地了解这个主题，我建议你访问我在下面留下的所有参考资料，尤其是官方文档！</p><h1 id="37cd" class="jv jw ht bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">📚参考</h1><blockquote class="jo jp jq"><p id="517b" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="ht">打字稿官方文档:</em><a class="ae ma" href="https://www.typescriptlang.org/docs/home.html" rel="noopener ugc nofollow" target="_blank"><em class="ht"/></a></p><p id="2ee4" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="ht">爱德华多·拉贝罗文章，“TypeScript: O阿桂定义VO”:</em><a class="ae ma" rel="noopener" href="/@oieduardorabelo/typescript-o-guia-definitivo-1a63b04259cc"><em class="ht">https://medium . com/@ oieduardorabelo/TypeScript-O-阿桂-定义vo-1a63b04259cc </em> </a></p><p id="723c" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="ht">YouTube上的威利安Justen迷你课程:</em><a class="ae ma" href="https://www.youtube.com/playlist?list=PLlAbYrWSYTiPanrzauGa7vMuve7_vnXG_" rel="noopener ugc nofollow" target="_blank"><em class="ht">https://www.youtube.com/playlist?list = pllabyrwsytipanrzaga 7 vmuve 7 _ vnXG _</em></a></p><p id="8fe6" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="ht">TutorialsTeacher中的打字教程:</em><a class="ae ma" href="https://www.tutorialsteacher.com/typescript" rel="noopener ugc nofollow" target="_blank">【https://www.tutorialsteacher.com/typescript】T21</a></p><p id="a301" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="ht">文章《Tipos básicos-Manual do TypeScript》，作者WebDevBr:</em><a class="ae ma" href="https://webdevbr.com.br/tipos-basicos-manual-do-typescript" rel="noopener ugc nofollow" target="_blank"><em class="ht">https://webdevbr.com.br/tipos-basicos-manual-do-typescript</em></a></p></blockquote></div></div>    
</body>
</html>