<html>
<head>
<title>Parallel Programming in Python — Lesson 2. The Thread</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的并行编程——第2课。线</h1>
<blockquote>原文：<a href="https://medium.com/codex/parallel-programming-in-python-lesson-2-the-thread-b3986e215d4f?source=collection_archive---------13-----------------------#2021-08-06">https://medium.com/codex/parallel-programming-in-python-lesson-2-the-thread-b3986e215d4f?source=collection_archive---------13-----------------------#2021-08-06</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><figure class="hi hj fa fc hk hl es et paragraph-image"><div role="button" tabindex="0" class="hm hn di ho bf hp"><div class="es et hh"><img src="../Images/e528ebd9f3ea1a80ff179c57af1bbe8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpEYnHZPiK7cpnFloHeusQ.jpeg"/></div></div></figure><div class=""/><p id="abac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">这是系列课程的第二部分，涵盖了Python编程语言为并行编程提供的各种工具以及使用它们的动机。在上一课中，我们探讨了并行设计的应用需求，并使用Python线程进行了演示。在本课中，我们将详细研究Python线程。</p><p id="38ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">本课的章节:</p><ol class=""><li id="d819" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">线程:解决方案领域</li><li id="642a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">“文件监视器”线程功能</li><li id="8613" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">封装文件监视器</li><li id="c9a2" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">详细说明Python线程</li><li id="bbf1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">练习:“尾部效用”</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h1 id="f674" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">1.线程:解决方案领域</h1><p id="e64b" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hc bi translated">最初的计算模型包括一个处理器，输入(指令和数据)以离散的形式输入，处理每个输入并相应地改变其内部状态。然后，<em class="jp">存储程序</em>数字计算机将程序(指令和数据序列)存储在自己的存储器中。它仍然以离散的顺序片段读取输入，但它们来自内部，使用一个<em class="jp">程序计数器</em>指向要执行的下一条指令。虽然这两种模式看似相似，但它们之间存在着巨大的差异和机遇。直接从外部被告知做什么和被告知(仍然是从外部)如何告诉自己做什么之间有着巨大的差异。第一台机器只能和它的操作员一样聪明。后者是具有学习潜力的智能机器。</p><p id="112c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">有了以正确顺序执行指令的可靠机制，并假设指令位于连续的内存中(并因此可能与唯一的内存<em class="jp">地址</em>相关联)，我们可以，例如，将一系列循环逻辑集中在<em class="jp">函数</em>(过去被称为<em class="jp">子例程)</em>中，如果足够通用，它可以是从程序中的不同位置调用的<em class="jp">。当一个函数被调用时，程序计数器被改变指向它的入口点。但首先必须记录下调用代码中下一个指令的地址(函数<em class="jp">返回时恢复)</em>，以及其他信息，比如函数调用的结果放在哪里(如果有的话)。由于被调用的函数可能还会调用另一个函数(或者它自己，据我们所知)等等，额外的这种执行<em class="jp">帧</em>可能会被堆叠在一个称为执行<em class="jp">堆栈的专用结构中。</em></em></p><p id="6c90" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">这些函数调用被描述为<em class="jp">阻塞</em>或<em class="jp">同步</em>，因为一旦一个函数调用了另一个函数，它的执行就被“暂停”了，直到另一个函数返回(因为只有一个程序计数器，它暂时指向别处)。</p><figure class="lp lq lr ls fe hl es et paragraph-image"><div class="es et lo"><img src="../Images/55771a239b94c537ee49dd119bdbd974.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*e1_yTRPgw9Q2jUSMeTZrTQ.png"/></div></figure><p id="dbd3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">现代计算机允许程序管理一个以上的堆栈，由此而来的是同时运行几个<em class="jp">控制线程</em>的能力。不同的控制线程可能会通过智能分时方案(在单个处理器上)或分配给不同的处理器(在可用的情况下)，或者(最有可能)两者来交叉。对于<em class="jp">函数和函数调用</em>范例，m <em class="jp">多线程</em>选项提供了模拟<em class="jp">非阻塞</em>或<em class="jp">异步</em>函数调用的机会。(此类功能的应用需求将在这些课程的其他部分详细讨论)。调用函数——而不是同步调用另一个函数<em class="jp"/>并阻塞自己(将程序计数器交给它)——现在有机会<em class="jp">在单独的线程上启动</em>被调用的函数(让操作系统担心部署)，并继续并行执行。但这仅仅是开始。并行编程产生了许多需要解决的小问题(如果我们坚持仍然模拟一些——或者全部——阻塞函数调用用例，我们为什么要这样做是另一回事):当异步“调用”结束时会发生什么？(当它发生时，我们，打电话的人，不在那里)。如何检索异步调用的结果(如果有)？同时，如何监控并行控制线程的进度？如何干预并行线程的操作？等等。</p><p id="1433" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">我们总结了这些(和许多其他)技术挑战的特殊解决方案，说这两个功能必须在一个<em class="jp">协议上达成一致。</em></p><figure class="lp lq lr ls fe hl es et paragraph-image"><div class="es et lt"><img src="../Images/2880f04da1f51be664c18616a3ac3dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*up5jRM17wgHC0J--TaNm8Q.png"/></div></figure><p id="9b45" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">从理论上讲，这似乎并没有超出正常人的理解范围，但是在实践中，它却非常难学，而且它的实现是出了名的容易出错。依我拙见，使线程概念难以获得的是具体化的<em class="jp">谬误</em>(将我们对我们看到的事物背后的动机的理解误认为是物理上存在的<em class="jp">事物</em>)。我们有一种将计算机程序视为T4事物的自然倾向，这可能是真的——但只是在问题领域。在<em class="jp">解决方案</em>域(即运行它的计算机)中，它并不存在。只有这么多离散的指令，静静地等待执行，在一个序列尚未展开。由于只有一个程序计数器(假设有一个内核)，并且给定了执行堆栈机制，因此在任何给定时间都只能有一个函数“运行”。当一个函数“调用”另一个函数时，它无法继续运行，因为它不存在(程序计数器去了别处)。实际上，它的状态被保留了下来(在执行堆栈上)，所以如果一切顺利的话，它可能会在适当的时候复活。在这种情况下，执行堆栈和多线程(多执行堆栈的能力)代表了程序员在实现程序(或者至少是函数)需求的过程中取得的重大胜利。(只要一个人不会忘乎所以，把这个比喻误认为是真实的世界，把自己的无能归咎于他人——例如多线程的便利性)。</p><p id="b995" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">虽然“异步函数调用”只是执行一个离散的任务(并行)并离开是可能的和合法的，但有趣的(并且相当频繁的)多线程用例涉及一个无限循环的线程，一次处理一个离散的输入，产生的响应以某种方式按时到达每个发送线程。(这也称为<em class="jp">事件循环</em>，如介绍性课程中所述)。整个中断的流程(由使用线程和已使用线程组成)必须仔细编排，以确保每个控制线程按时完成工作，并与其他线程协调一致。</p><figure class="lp lq lr ls fe hl es et paragraph-image"><div class="es et lu"><img src="../Images/9ba8c7902cd29fc3ee0d47a071f5f2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*Jlxq-y51jAwjzk4bbWvVIA.png"/></div></figure></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h1 id="ade8" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">2.“文件监视器”线程功能</h1><p id="47b4" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hc bi translated"><em class="jp">问题:</em>监控一个磁盘文件，修改时记录警告信息。</p><p id="6bd4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">解决方案:</em><em class="jp">文件监视器</em>功能使用操作系统工具来监视文件的最新已知修改时间，并在修改时间发生变化时提醒其客户端。</p><p id="ea59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">一些设计决策:</em></p><ul class=""><li id="8eb5" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo lv jw jx jy bi translated">文件监视器是在一个单独的控制线程中启动的(为了不妨碍正在使用的应用程序同时完成它的工作)。</li><li id="4f35" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">文件监视器通过负责通知的回调与人机界面分离。</li></ul><p id="8021" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">下面是一个简单的Python (3.9)实现(注释如下):</em></p><figure class="lp lq lr ls fe hl"><div class="bz dz l di"><div class="lw lx l"/></div></figure><ol class=""><li id="e296" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated"><em class="jp">全球</em>结束警戒旗。这个简单的解决方案可以满足这个初始原型的需要。(我们将在适当的时候考虑更强大的解决方案)。</li><li id="642d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">文件监视器使用客户端提供的回调函数来提醒它的客户端。这将信息的生产者(文件观察者)从人机界面(可以是终端、对话窗口、套接字、计数器等)中分离出来。</li><li id="38ac" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">在确认要被监视的文件确实存在之后，文件监视器获得其最新的已知修改时间(“get-m-time”)，并继续每两秒对其进行一次迭代比较，当检测到改变时发出警报。当全局结束标志发出信号时，迭代停止(据我们所知，是由客户端发出的)。</li><li id="b63a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">这个例子的简单报警功能输出到终端，格式化(二进制)变化时间用于显示。</li><li id="dfda" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">该程序试图从命令行获取要监视的文件的名称。否则它向用户请求它。</li><li id="3a3b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">程序向文件中写入一些东西，以确保它将存在(当文件监视器访问它时)。</li><li id="759c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">现在，我们有了一个要监视的文件，文件监视器在一个单独的控制线程中启动，给出了要监视的文件的名称和控制台通知回调。该线程尚未激活！</li><li id="2c4c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">现在线自由了！文件监视器功能将很快被调用(异步！).</li><li id="ba6c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">测试程序对文件进行修改，以五秒钟为间隔，连续五次追加一些文本。它期望文件监视器(以前在它自己的线程中启动)能够动态地捕捉这些变化。测试程序在每次访问时打开和关闭文件(以更新文件修改时间)。</li><li id="29dc" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated"><em class="jp">五秒钟</em>对于文件监视器(每隔<em class="jp">两秒钟</em>唤醒一次)来说是足够的时间来检测变化。(它还保持进度可被人眼看到)。</li><li id="1269" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">测试完成后，测试程序会通知文件监视器结束。</li><li id="7df8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">测试程序等待线程结束(it " <em class="jp"> joins" </em> it)，以防止线程继续运行超过主程序的结尾。这种预防措施在这里并不重要(我们可以相信文件监视器无论如何都会结束，因为它刚刚被告知要这样做)。尽管如此，这仍然是很好的并行编程风格！</li></ol><p id="d7cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:</em></p><pre class="lp lq lr ls fe ly lz ma mb aw mc bi"><span id="c639" class="md km hu lz b fj me mf l mg mh">file "fileWatcherTest.txt" changed on Sat Dec 12 19:35:22 2015 file "fileWatcherTest.txt" changed on Sat Dec 12 19:35:27 2015 file "fileWatcherTest.txt" changed on Sat Dec 12 19:35:32 2015 file "fileWatcherTest.txt" changed on Sat Dec 12 19:35:37 2015 file "fileWatcherTest.txt" changed on Sat Dec 12 19:35:42 2015</span></pre><p id="131c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">在这个例子中我们学到了什么？</p><ul class=""><li id="69a6" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo lv jw jx jy bi translated">一个Python控制线程接受一个<em class="jp">函数</em>和可选的<em class="jp">参数</em>传递给它(当它最终启动时)。</li><li id="4c41" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">当请求启动时，线程调用函数，但是在专用的执行堆栈上，所以它不会<em class="jp">阻塞</em>线程的启动器。</li><li id="5b48" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">当线程函数返回时，线程终止。(线程对象继续存在，但没有太大用处)。</li><li id="362b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">线程应该结束是有原因的。要么这个线程已经完成了它的任务，要么启动它的另一个线程(在我们的例子中是主程序)不再需要它了。终止线程需要<em class="jp">同步</em>。线程和它的启动器都必须同意一个专有的<em class="jp">协议</em>。主程序必须能够用<em class="jp">信号</em>通知线程结束，并且线程必须能够捕捉到该信号。这种设计模式在并行编程中很常见。线程在循环中，客户端也可以访问的布尔值是循环的终止条件。</li><li id="2fca" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">由于编程上的疏忽，线程可能会继续运行(至少在Python中)，即使在主程序应该返回之后。如果程序员确定线程确实注定要结束(例如，它刚刚被告知这一结果)，但应该允许一些时间来清理，主程序<em class="jp">加入</em>线程——它被<em class="jp">阻塞</em>直到线程结束。</li></ul><p id="8b69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">其他Python线程功能。</em>尽管CPython似乎将它的线程实现为主机操作系统线程的包装器，但它没有公开后者的全部功能(并添加了一些次要的属性)。</p><ul class=""><li id="d704" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo lv jw jx jy bi translated">你不能杀死一个Python线程(即通过暴力终止它)。尽管这种限制有很大的教育价值(见上面的讨论)，但在那些(并不罕见的)现实生活中，当一个线程由于程序员无法控制的原因而被阻塞时(例如，正在阻塞I/O)，除了从外部终止整个程序之外别无选择，这可能会成为一种负担！</li><li id="b517" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">由于<em class="jp">全局解释器锁</em>(“GIL”)，Python线程从不同时运行<em class="jp"/>。在未来的某个版本中，这一点可能会有所放松，但在此之前，它会阻止多线程Python程序从多核平台的性能中获益。</li><li id="4b9f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">您不能查询线程终止状态(默认情况下)。如果需要的话，自己实现这个功能。</li></ul><p id="e754" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">附加功能(线程特定):</em></p><ul class=""><li id="4151" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo lv jw jx jy bi translated">将线程标记为“守护进程”。(在UNIX世界中，这个术语专用于在后台静默工作并且也将被静默删除的服务器)。守护进程线程(至少在理论上)以主程序结束(并且不必被加入)。</li><li id="a4d9" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">给线程一个用户定义的名称。</li><li id="251e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">判断线程是否处于活动状态(或者已经返回)。</li></ul><p id="ce00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">附加功能(非特定线程):</em></p><ul class=""><li id="3ffd" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo lv jw jx jy bi translated">获取当前线程。这包括获得主程序的包装器(实际上也是一个线程)。</li><li id="cadc" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">计数和枚举活动Python线程(在当前进程中)</li><li id="7758" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">获取当前线程id (Python给定的和OS给定的)</li><li id="8306" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">获取和设置线程堆栈大小(在极少数情况下，默认情况下不会这样做)。</li></ul></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h1 id="4124" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">3.封装文件监视器功能</h1><p id="666c" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hc bi translated"><em class="jp">问题:</em>文件监视器线程<em class="jp">函数</em>在这个简单的例子中完成了工作，但是，作为一个通用的基础设施，它还有一些不足之处。特别是，它将受益于以下功能:</p><ul class=""><li id="3916" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo lv jw jx jy bi translated">在几个不相关的场合观看《T4》的多个文件。(相反，当前由函数实现的、由全局布尔表示的功能限制了应用程序只能查看一个文件！)</li><li id="87ae" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">将文件监视器分离到一个库(例如真实的基础设施)。全局变量挡住了去路。</li></ul><p id="7dcb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">一个解决方案:</em>文件监视器功能值得拥有一个<em class="jp">类</em>。</p><p id="a7de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">一些设计决策:</em></p><ul class=""><li id="1425" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo lv jw jx jy bi translated">文件监视器是使用文件名和警告函数(而不是线程函数)构建的。</li><li id="8f26" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">Python线程由文件监视器在内部创建。</li><li id="3ae6" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">线程函数是文件监视器的一个(私有)方法。</li><li id="2af9" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">文件监视器请求启动文件监视器线程。</li><li id="3645" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">终结符标志是文件监视器的私有属性，客户端可以通过getter和setter访问它。</li></ul><p id="942f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">重构starter原型代码，以满足面向对象的设计(注释如下，输出保持不变):</em></p><figure class="lp lq lr ls fe hl"><div class="bz dz l di"><div class="lw lx l"/></div></figure><ol class=""><li id="9457" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">“文件守望者”现在是一个职业的骄傲的名字。</li><li id="afca" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">过去是文件监视器函数的参数和局部变量，现在是文件监视器类的成员数据。</li><li id="5022" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">终结符标志现在是文件监视器类的成员。</li><li id="fa2e" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">Python线程是文件观察器类的成员，在后者的构造函数中构造。对于<em class="jp">线程函数，</em>被赋予了一个<em class="jp">绑定方法</em>，由文件监视器<em class="jp">对象</em>(“self”)和文件监视器<em class="jp">方法</em>(“File Watcher . run”)组成。</li><li id="ea8f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated"><em class="jp">开始</em>线程现在由线程对象负责(但由客户端请求)。</li><li id="8649" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">相反地，停止线程现在也是线程对象的责任，保护客户端免受布尔实现的影响。</li><li id="6bc8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">提取事件循环以运行线程方法，恰当地称为<em class="jp">。</em></li><li id="3017" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序使用文件名和警告函数(而不是线程函数)初始化一个文件监视器对象。主程序逻辑的其余部分保持不变。</li></ol><p id="e2a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">现在，有了这个面向对象的设计，我们可以直观地检查并行逻辑:</em></p><figure class="lp lq lr ls fe hl es et paragraph-image"><div class="es et mi"><img src="../Images/c20c02f05cee2a7bac2f0ea34a152385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*rz6TjHHaVk_Erhz62KCPzw.png"/></div></figure><p id="660c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">序列图注释:</em></p><ul class=""><li id="8f30" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo lv jw jx jy bi translated">文件监视器在控件<em class="jp">的并行线程上启动。</em>这里主程序和文件监视器部分各司其职。</li><li id="7571" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">两个主循环(“向文件添加行”和“监视文件”)独立发生，仍然并行。</li><li id="e42f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">“通知变更”是<em class="jp">与</em>(通过数据)和“向文件添加行”的耦合。第一个(“文件修改日期[已更改]”)的输入是后者“文件附加行[并关闭]”的输出，即文件已更改。“数据耦合”是并行设计中一个常见的设计习语，取代了你可能从过程编程中了解到的<em class="jp">时间耦合</em>(命令按照书写的顺序出现)。过程化编程就像“先做A再做B”(按此顺序)。在事件驱动的设计中，这被替换为“B消费A生产的”(因此，必须遵循它)。</li><li id="b6ca" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">停止文件监视器是主程序的<em class="jp">同步</em>。该作业(发信号)由主程序线程中的文件监视器对象<em class="jp">立即执行(非阻塞)。但是对于文件监视器线程来说是<em class="jp">异步</em>，在后台运行。根据协议，计划在下一次迭代中停止</em>上方的循环<em class="jp">。</em></li></ul><p id="1330" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">许多人忽略了一个事实，因此至少造成了一些并行编程错误，那就是，在一个<em class="jp">面向对象的</em>并行设计中，一个线程可能被异步<em class="jp">和同步</em>访问。(1) <em class="jp">异步:</em>首先，线程被启动以独立完成工作，然后，它偶尔会收到信号或以自己的速度接收数据。(2) <em class="jp">同步:</em>线程方法被调用改变线程状态，非阻塞。注意歧义:<em class="jp">信令</em>出现在两个列表中！在这里不迷失方向的关键是记住控制的<em class="jp">线程——不考虑编程的习语——不是一个对象！这是一个函数的执行状态。除此之外，您的实现可以添加任何您需要的东西(比如保持状态同步可用、发信号和发送数据)，只要您记住调用函数的线程<em class="jp">才是最重要的！当您在主程序的上下文中同步调用线程的方法时，您的<em class="jp">当前线程就是主程序</em>(而不是线程对象，它一直在后台运行)！</em></em></p></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h1 id="1ac7" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">4.等一下！Python已经有线程类了！</h1><p id="bca0" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hc bi translated">内含内置<em class="jp">螺纹。用户定义的线程类中的线程</em>，比如我们的文件监视器，是多余的。我们可以通过<em class="jp">继承</em>来达到同样的目的。重构相当简单:逻辑保持不变，因为<em class="jp">从一个类继承</em>和<em class="jp">包含</em>的一个实例——至少在目前的情况下——实际上是一样的。(这里我们有通过重用的面向对象<em class="jp">。穿线。Thread不是抽象基类也不是接口，不涉及<em class="jp">可替代性</em>)。除此之外，更少的编码和<em class="jp">继承</em>所有其他的东西——数据和方法。(相反，如果我们可以忍受的话，这种被限制在基类的设计中是理所当然的惩罚)。在这种情况下，限制(如下所列)是我们可以轻松忍受的。</em></p><p id="aa55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">唯一可覆盖的线程方法是<em class="jp">run</em>——线程函数。</p><ul class=""><li id="4c4c" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo lv jw jx jy bi translated">考虑到Python不支持“虚拟”函数。基础线程<em class="jp"> start </em>方法调用<em class="jp"> self.run() </em>，如果这样的方法存在(否则不调用)。因此，必须不折不扣地调用“run”方法。任何其他名称(比如“Run”)都不能被调用，留给我们的是默认的什么都不做！</li><li id="513d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">基本Python线程不支持事件循环。(也不应该！并非所有(甚至大多数)线程都是基于事件循环的)。无论在<em class="jp"> run </em>方法中发生什么，都是派生类作者的责任。因此，底线对<em class="jp">停止</em>没有反应。(相当不对称。正如我们已经看到的，它确实响应<em class="jp">开始</em>。如果需要的话，实现你自己的<em class="jp">停止</em>方法。</li></ul><p id="0990" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">重构基于类的原型代码，以满足符合库的设计(注释如下，输出和逻辑保持不变):</em></p><figure class="lp lq lr ls fe hl"><div class="bz dz l di"><div class="lw lx l"/></div></figure><ol class=""><li id="a406" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">“文件监视器”类继承了内置的“线程”。线程”。</li><li id="0663" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">这个文件监视器中不再有内置的线程成员(而是继承了一个)。文件观察器构造函数委托给基本内置线程构造函数。</li><li id="61f6" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">其余的文件监视器成员保持不变。</li><li id="9876" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated"><em class="jp">运行</em>的方法保持不变。它的名字(“run”)将它指定为线程函数。</li><li id="f524" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">我们必须添加的唯一方法是<em class="jp">停止</em>。(基础线程不支持停止，因为它不知道线程方法的功能)。</li><li id="ed88" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序不受文件监视器类内部更改的影响。</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h1 id="445f" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">5.练习:“启动器尾部实用程序”</h1><p id="e892" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hc bi translated">“Tail”是一个Unix实用程序，其逻辑非常类似于我们的“文件监视器”示例，但是，它没有宣布文件被修改的事实，而是输出了非常多的行，假设(1)文件仅通过追加进行修改，以及(2)文件包含纯文本。tail的典型用途是跟踪日志文件(当它们被创建时)。</p><p id="815b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">将“文件监视器”示例修改成一个基本的“Tail”实用程序。请考虑以下情况:从末尾(而不是从开头)读取文件，这需要:</p><ul class=""><li id="d23b" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo lv jw jx jy bi translated">以<em class="jp">二进制</em>模式—‘Rb’—打开文件，然后…</li><li id="a938" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">到结束位置— inp.seek(0，2)</li><li id="c9e4" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">下一行(经过最后一个已知的文件结尾)由inp.readline()获取。非空结果表示有效行(要显示)。空结果意味着我们仍然在文件的末尾(但这不是错误)。</li><li id="226f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo lv jw jx jy bi translated">从另一面在文件上写入保持不变。不要忘记在<em class="jp">追加</em>模式下打开文件——“a+”！</li></ul><p id="425a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">努力做一份诚实的工作！在接下来的课程中，您将重构这个简单的初学者作为练习！</p><h1 id="cc3b" class="kl km hu bd kn ko mj kq kr ks mk ku kv kw ml ky kz la mm lc ld le mn lg lh li bi translated"><em class="mo">下一步是什么？</em></h1><p id="2583" class="pw-post-body-paragraph ir is hu it b iu lj iw ix iy lk ja jb jc ll je jf jg lm ji jj jk ln jm jn jo hc bi translated">在下一课中，我们将看到经典的<em class="jp">生产者/消费者</em>示例。我们将考虑一些使用Python同步原语的“徒手”实现，并尝试评估它们各自的优点。然后，在接下来的课程中，我们将使用高级Python工具实现生产者/消费者算法:多处理和协作处理(同步和异步)。</p><ol class=""><li id="55fc" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">介绍</li><li id="ee7d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">线程<em class="jp">(你在这里！)</em></li><li id="c507" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">同步原语(多线程)</li><li id="3d71" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">同步原语(多处理)</li><li id="58aa" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">协作处理—同步</li><li id="bcf1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">协作处理—异步</li></ol></div></div>    
</body>
</html>