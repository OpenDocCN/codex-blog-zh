<html>
<head>
<title>Binary Search (704)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二分搜索法(下)704</h1>
<blockquote>原文：<a href="https://medium.com/codex/binary-search-704-688bbbc93e61?source=collection_archive---------16-----------------------#2022-12-06">https://medium.com/codex/binary-search-704-688bbbc93e61?source=collection_archive---------16-----------------------#2022-12-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0033" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">LeetCode (C++)</h2></div><h2 id="ecad" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated"><a class="ae jv" href="https://leetcode.com/problems/binary-search/" rel="noopener ugc nofollow" target="_blank">问题</a></h2><p id="c79d" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke ji kf kg kh jm ki kj kk jq kl km kn ko hb bi translated">给定一个按升序排序的整数数组<code class="du kp kq kr ks b">nums</code>和一个整数<code class="du kp kq kr ks b">target</code>，编写一个函数在<code class="du kp kq kr ks b">nums</code>中搜索<code class="du kp kq kr ks b">target</code>。如果<code class="du kp kq kr ks b">target</code>存在，那么返回它的索引。否则，返回<code class="du kp kq kr ks b">-1</code>。</p><p id="3750" class="pw-post-body-paragraph jw jx hi jy b jz kt ij kb kc ku im ke ji kv kg kh jm kw kj kk jq kx km kn ko hb bi translated">你必须写一个运行时复杂的算法。示例1</p><p id="7da0" class="pw-post-body-paragraph jw jx hi jy b jz kt ij kb kc ku im ke ji kv kg kh jm kw kj kk jq kx km kn ko hb bi translated"><strong class="jy hj">例1: </strong></p><pre class="ky kz la lb fd lc ks ld bn le lf bi"><span id="86d4" class="lg iy hi ks b be lh li l lj lk">Input: nums = [-1,0,3,5,9,12], target = 9<br/>Output: 4<br/>Explanation: 9 exists in nums and its index is 4</span></pre><p id="2421" class="pw-post-body-paragraph jw jx hi jy b jz kt ij kb kc ku im ke ji kv kg kh jm kw kj kk jq kx km kn ko hb bi translated"><strong class="jy hj">例2: </strong></p><pre class="ky kz la lb fd lc ks ld bn le lf bi"><span id="9bf1" class="lg iy hi ks b be lh li l lj lk">Input: nums = [-1,0,3,5,9,12], target = 2<br/>Output: -1<br/>Explanation: 2 does not exist in nums so return -1</span></pre><h2 id="e306" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">解决办法</h2><p id="70a9" class="pw-post-body-paragraph jw jx hi jy b jz ka ij kb kc kd im ke ji kf kg kh jm ki kj kk jq kl km kn ko hb bi translated">这个问题直接表明我们将使用二分搜索法。你也可以使用线性搜索来解决这个问题，但是我们将会花费太多的时间来解决这个问题，最好的运行时间复杂度将会是O(n)。我们现在将坚持二分搜索法，并尽快解决这个问题。</p><p id="856d" class="pw-post-body-paragraph jw jx hi jy b jz kt ij kb kc ku im ke ji kv kg kh jm kw kj kk jq kx km kn ko hb bi translated"><strong class="jy hj"> <em class="ll">【二分搜索法】</em> </strong> <em class="ll">是一种</em> <a class="ae jv" href="https://www.geeksforgeeks.org/searching-algorithms/" rel="noopener ugc nofollow" target="_blank"> <em class="ll">搜索算法</em> </a> <em class="ll">用在一个由</em> <strong class="jy hj"> <em class="ll">反复划分搜索区间的有序数组中</em> </strong> <em class="ll">。二分搜索法的思想是利用数组排序的信息，将时间复杂度降低到O(Log n)。</em></p><figure class="ky kz la lb fd ln er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lm"><img src="../Images/e9eb2d1c8e8b3885cffb41a31fc2d92b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o23dagqqzSzesNJjospgVg.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">图片由<a class="ae jv" href="https://www.geeksforgeeks.org/binary-search/" rel="noopener ugc nofollow" target="_blank"> GeeKforgeeks </a>提供</figcaption></figure><p id="427a" class="pw-post-body-paragraph jw jx hi jy b jz kt ij kb kc ku im ke ji kv kg kh jm kw kj kk jq kx km kn ko hb bi translated">这个想法是将数组一分为二，在左边寻找目标数字，然后在右边寻找。这种方法将把复杂度减少2倍，每次迭代我们将试图找到目标数，结果复杂度为O(logn)。</p><figure class="ky kz la lb fd ln"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="0ec9" class="pw-post-body-paragraph jw jx hi jy b jz kt ij kb kc ku im ke ji kv kg kh jm kw kj kk jq kx km kn ko hb bi translated">本例中的Low是vector的第一个元素(vectors在c++中也可以作为数组使用)。另一方面是向量的最后一个元素或向量最右边的元素。我们计算数组的中间值<code class="du kp kq kr ks b">(low+hight)/2</code></p><p id="fc93" class="pw-post-body-paragraph jw jx hi jy b jz kt ij kb kc ku im ke ji kv kg kh jm kw kj kk jq kx km kn ko hb bi translated">只要低点没有那么高，我们就通过if语句检查我们是否找到了目标数字。如果目标数字是向量的实际中间值，我们返回中间位置。如果目标数大于向量的中间数，则新的低位变为中间+ 1，我们将只关注向量的右边部分。如果目标小于向量的中间，则高位将变为中间-1，我们将只关注数组的左边部分。我们将在第一次迭代后不断寻找中间值，因为低变量和高变量在每次迭代后都会发生变化。如果目标不在向量中，我们将返回-1。</p><p id="2780" class="pw-post-body-paragraph jw jx hi jy b jz kt ij kb kc ku im ke ji kv kg kh jm kw kj kk jq kx km kn ko hb bi translated"><strong class="jy hj">参考</strong></p><div class="ma mb ez fb mc md"><a href="https://leetcode.com/problems/binary-search/" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">二分搜索法-李特码</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">给定一个按升序排列的整数数组nums和一个整数目标，写一个函数来搜索…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">leetcode.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr ls md"/></div></div></a></div><div class="ma mb ez fb mc md"><a href="https://ynnenu.medium.com/membership" rel="noopener follow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hj fi z dy mi ea eb mj ed ef hh bi translated">通过我的推荐链接加入Medium-Eniela p . Vela</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">ynnenu.medium.com</p></div></div><div class="mm l"><div class="ms l mo mp mq mm mr ls md"/></div></div></a></div></div></div>    
</body>
</html>