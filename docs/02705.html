<html>
<head>
<title>Implementing Authentication and Authorization in React JS: A Stepwise Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React JS中实现身份验证和授权:分步指南</h1>
<blockquote>原文：<a href="https://medium.com/codex/implementing-authentication-and-authorization-in-react-js-a-stepwise-guide-b5b5dc848689?source=collection_archive---------9-----------------------#2021-08-01">https://medium.com/codex/implementing-authentication-and-authorization-in-react-js-a-stepwise-guide-b5b5dc848689?source=collection_archive---------9-----------------------#2021-08-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8497aa04691e6962bbce30c34656c034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WsWz1fnXht2MKu5V.png"/></div></div></figure><p id="bed6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">授权是应用程序中使用的一个过程，有助于控制信息访问和限制用户执行的操作。类似地，身份验证是检查用户是否被允许访问信息或执行任何操作的过程。如果经过身份验证的用户正在使用您的应用程序，他们已经通过多种方式识别了自己的真实身份，例如提供正确的凭据。</p><p id="179a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然身份验证将帮助您了解用户的真实身份，但它不能帮助您控制访问，这就是为什么我们在身份验证中使用授权。如果没有这两者中的任何一个，你的应用程序就会出现混乱。例如，任何用户都可以更改另一个用户的密码或删除另一个用户发布的数据。</p><h1 id="ba93" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">我们可以通过以下方式在ReactJS中实现身份验证:</h1><ul class=""><li id="af0c" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn kt ku kv kw bi translated">基于Cookie的身份验证</li><li id="e864" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">基于令牌的认证</li><li id="5ff4" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">第三方访问(OAuth、API令牌)</li><li id="e051" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">OpenId</li><li id="244a" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">安全声明标记语言（Security Assertion Markup Language的缩写）</li></ul><blockquote class="lc ld le"><p id="88e3" class="iq ir lf is b it iu iv iw ix iy iz ja lg jc jd je lh jg jh ji li jk jl jm jn hb bi translated">在本文中，我们将在ReactJS中使用基于令牌的认证或JWT令牌进行认证和授权。请继续阅读，了解其工作原理。</p></blockquote><h1 id="9b29" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">更多关于JWT令牌</h1><p id="df8c" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">在许多资源中，我们需要限制访问，以确保没有用户能够阻碍其他用户的活动。因此，我们利用id和密码进行安全访问和身份验证。然而，这里的问题是HTTP API不知道两个不同的请求是否由一个用户提出，因为HTTP是无状态的。</p><p id="b7f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然我们可以要求用户在每次API调用时提供ID和密码，但这也意味着糟糕的用户体验。相反，我们需要的是请求一次身份验证并在后续请求中通过其他方式识别用户的能力。一个有效的系统是JSON Web Token，通常被称为JWT。</p><blockquote class="lc ld le"><p id="28e5" class="iq ir lf is b it iu iv iw ix iy iz ja lg jc jd je lh jg jh ji li jk jl jm jn hb bi translated">JWT令牌是一种开放标准(<a class="ae lm" href="https://datatracker.ietf.org/doc/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> RFC 7519 </a>)，它提供了一种独立的方法来以安全的方式向不同的方传输信息。因为这些信息是数字签名的，所以是可信的和可验证的。</p></blockquote><p id="3050" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每当用户登录时，都会生成JWT令牌。这对于与一个用户相关联的一个帐户是可访问的。用户可以使用该令牌来利用他们的访问权限，直到他们注销。</p><h1 id="1657" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">JWT令牌的结构</h1><p id="7c20" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">通常，您会发现HTTP请求头中的JWT是使用<strong class="is hj">承载</strong>模式的<strong class="is hj">授权</strong>密钥。</p><p id="61d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用JWT令牌，您可以找到用句点分隔的三个字符串。这些base 64编码的字符串是头、有效负载和签名。它看起来像XXXXXX . yyyyyy . zzzz</p><p id="1943" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">下面我们解码了这些字符串，以便更清楚地理解JWT的结构。</strong></p><h1 id="6579" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">页眉</h1><p id="eeb6" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">周期之前的第一部分是报头，其包含令牌或JWT的元信息或数据。它包含两个部分:令牌类型和签名算法，该算法以Base64编码，构成令牌的第一部分。</p><p id="ebcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">举例:</strong></p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="fc94" class="lw jp hi ls b fi lx ly l lz ma">1.{<br/>2. "alg":"SHA256",<br/>3. "typ":"JWT" <br/>4.}</span></pre><h1 id="f340" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">有效载荷</h1><p id="88da" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">有效负载是令牌的第二部分，它有声明。这些语句包含与用户相关的实体或额外数据。</p><h1 id="5c98" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">我们可以在令牌中添加不同的声明，这里有三种类型:</h1><ul class=""><li id="9429" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn kt ku kv kw bi translated"><strong class="is hj">注册声明</strong>是预定义的，它们并不是强制性的，但建议使用它们。比如受众(aud)、到期时间(exp)等。由于JWT很紧凑，您会发现索赔的名称仅由三个字符组成。</li><li id="bbdd" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">在定义<strong class="is hj">公共声明</strong>时，我们需要消除冲突，为此你可以通过URI(包含抗冲突的名称空间)或<a class="ae lm" href="https://www.iana.org/assignments/jwt/jwt.xhtml" rel="noopener ugc nofollow" target="_blank"> IANA JSON Web Token Registry </a>来定义公共声明。</li><li id="293b" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">正是通过私人声明，我们在同意使用这些声明的双方之间共享数据。这些既不是公开的也不是登记的索赔。</li></ul><p id="9069" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有效载荷的安全性很弱，因为任何人都可以毫不费力地解码JWT并看到有效载荷的内容。因此，我们不应该将任何敏感和秘密的信息放在有效载荷中。如果需要，在添加到有效负载之前加密数据。</p><p id="827d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">有效载荷看起来是这样的:</strong></p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="87f1" class="lw jp hi ls b fi lx ly l lz ma">1.{ <br/>2."jti": "359a2088-2276-48c3-8375-378802e039af", <br/>3."iat": 1617631282, 4."http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier": "1413f2f2-5214-413f-8b12-d09cb9a8fa7b", 5."http://schemas.microsoft.com/ws/2008/06/identity/claims/role":<br/>"Admin", <br/>6."nbf": 1617631282,<br/>7."exp": 1712239282,<br/>8."iss": "MyProject", <br/>9."aud": "https://www.desuvit.com/" <br/>10.}</span></pre><p id="1c4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管有效负载是用户识别的唯一识别因素，但它并不验证用户。在这种情况下，任何一知半解的用户都可以找到信息并创建一个假令牌。因此，我们利用签名，这是JWT中的关键认证因素，以确保信息不会在途中被更改。</p><h1 id="01df" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">哈希算法</h1><p id="203a" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated"><strong class="is hj">但是，在我们跳到签名之前，让我们来看看哈希算法。</strong></p><p id="6ce7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在哈希算法的帮助下，我们可以将任何字符串转换成哈希函数。例如，<strong class="is hj"> Hello，world </strong>可以通过SHA265算法转换成hash。这些算法有一个重要的特性，它不允许你借助你有的散列来找出原始字符串。</p><p id="e8a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是说，如果你已经把<strong class="is hj"> Hello，world </strong>转换成hash，那么你就不能用那个hash去找字符串<strong class="is hj"> Hello，world </strong>。</p><h1 id="e6bc" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">JWT签名</h1><p id="62b9" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated"><strong class="is hj">在JWT签名中，我们利用了三样东西:</strong></p><p id="258d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先是算法的名字，比如HMACSHA256，它是从SHA265派生出来的。</p><p id="950b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其次，编码的头和有效载荷字符串被转换成散列。</p><p id="48ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，使用一个只有服务器知道的密钥。它包含了我们无法解码的任意数据。</p><p id="cfb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们对整个JWT(包括有效载荷和报头)进行编码或使用哈希的原因是为了确保一个特定令牌的签名的唯一性。</p><h1 id="de09" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">用于生成JWT令牌的Rest API</h1><p id="7c91" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">通常在ReactJS应用程序中，我们使用Rest API来获取数据或保存数据。即使是登录用户，我们也使用API端点。对于博客的其余部分，我们假设API端点会在用户通过身份验证后返回JWT。我们将在任何后续请求中使用这个JWT令牌。</p><h1 id="e6ca" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用Rest API进行身份验证</h1><p id="0986" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">到目前为止，我们已经了解了JWT及其结构。我们将如何在API的认证过程中使用它？</p><p id="a6d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">让我们来看看:- </strong></p><h1 id="71fb" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">登录</h1><ul class=""><li id="23ae" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn kt ku kv kw bi translated">每当用户通过向Rest API端点提供凭证(通常是用户名和密码)进行登录时，就会在服务器上生成一个JWT令牌并发送回客户端。</li><li id="f31f" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">一旦客户端收到令牌，他们就可以在将来的任何请求中使用它，以便通过正确的身份验证来识别用户。</li><li id="be13" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">我们将从API中获取JWT令牌，我们将把它存储在会话中，以便在需要时进一步使用。调用API并将令牌存储在会话存储中的代码如下所示。在这种方法中，我们使用redux saga。</li></ul><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="13cb" class="lw jp hi ls b fi lx ly l lz ma">1.export function* loginFlow() { <br/>2.const check = true;<br/>3. while (check) { <br/>4.const { email, password } = yield take(LOGIN_REQUEST);<br/>5.<br/>6. const token = yield apiCall(Api.login, email, password);<br/>7.<br/>8. if (token) { <br/>9.sessionStorage.setAuthToken(JSON.stringify(token));<br/>10. const parsedAccessToken = parseJwtToken(token.auth_token); <br/>11.constrole=parsedAccessToken["http://schemas.microsoft.com/ws/2008/06/identity/claims/role"];<br/>12. yield put(setLoginSuccess());<br/>13.     <br/>14      } <br/>15.   } <br/>16. }</span></pre><p id="a643" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样在上面这段代码中，我们解析JWTToken来获取用户的角色，该角色被称为claim。</p><p id="d668" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">下面是解析JWT令牌的代码，</strong></p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="ff30" class="lw jp hi ls b fi lx ly l lz ma">1.function parseJwt(token) { <br/>2.const base64Url = token.split('.')[1];<br/>3.const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/'); 4.return JSON.parse(window.atob(base64)); <br/>5.}</span></pre><h1 id="6b58" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">当我们的服务器收到通过授权令牌对用户进行身份验证的请求时，会发生以下情况:</h1><ul class=""><li id="f605" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn kt ku kv kw bi translated">令牌被解码，并且从有效载荷中提取ID。</li><li id="e70f" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">在用户数据库中检查该用户ID。</li><li id="8303" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">现在对请求令牌和用户模型令牌进行比较。如果匹配，用户的身份验证就完成了。否则，用户就不能访问。</li></ul><h1 id="c17e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">注销</h1><p id="10e8" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">当JWT令牌被创建时，我们也应该为其设置一些到期时间。通过这种方式，令牌在特定的时间框架后失效。还有一种机制，通过该机制可以刷新令牌，以避免令牌的任何滥用。</p><h1 id="c53f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">ReactJS专用路线</h1><p id="748f" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">在ReactJS中，路由器是一个重要的组件，它有助于同步您的URL和UI。在本节中，我们将了解如何使用私有和公共路由。</p><h1 id="ba24" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">让我们先来看看一个简单应用程序的结构:</h1><ul class=""><li id="583d" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn kt ku kv kw bi translated">每个人都可以访问主页/登录/注册页面，因此这是一条公共路径。</li><li id="6d3d" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">经过身份验证的用户可以访问仪表板/我的帐户页面，因此这是一条私人路线。</li></ul><h1 id="57d7" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">私人路线</h1><p id="fc9d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">在PrivateRoute组件中，包含了您的应用程序的每条路线。当用户登录后，他们可以看到这条路线的组成部分。例如，仪表板。如果该用户未登录，他们将被重定向或转到登录页面。</p><p id="b707" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以定义如下所示的专用路由。正如您在代码中所看到的，我们获得了在会话中派生和存储的角色，如上一节所述。根据角色，我们授予对组件的访问权限，或者重定向到登录屏幕</p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="63a1" class="lw jp hi ls b fi lx ly l lz ma">1.export const PrivateCandidateRoute = ({ component: Component, ...rest }) =&gt; {<br/>2. const { location } = rest; <br/>3.const role = helper.fetchRole();<br/>4.let isCandidate = false;<br/>5.if (role == constant.CANDIDATE_ROLE) { <br/>6.  isCandidate = true; <br/>7.} <br/>8.const adminRol = isCandidate == true ? true : false;<br/>9. return ( <br/>10.    &lt;Route {...rest} render={(props) =&gt; <br/>11.       adminRol ? <br/>12.           &lt;Component {...rest} {...props} /&gt; :<br/>13.                &lt;Redirect to={{ <br/>14.                     pathname: constant.LOGIN_SCREEN, <br/>15.                       state:{<br/>16.                          prevLocation: location <br/>17.                       } <br/>18.                  }} /&gt; <br/>19.     } /&gt;<br/>20.   );<br/>21. };</span></pre><h1 id="6057" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">公共路线</h1><p id="1798" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">PublicRoute提供对受限组件和公共组件的访问。公共路由可能如下:- </p><pre class="ln lo lp lq fd lr ls lt lu aw lv bi"><span id="70b1" class="lw jp hi ls b fi lx ly l lz ma">&lt;Route path={constant.SEARCH_SCREEN} render={() &lt;SearchScreenContainer {...props} /&gt;} /&gt;</span></pre><h1 id="c7c1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">摘要</h1><p id="304d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">一旦任何用户登录到REST API，就会创建JWT令牌。在这个令牌的帮助下，提取所需的角色，这有助于提供和显示用户有权查看的页面。如果获得授权，该用户也可以看到私人航线的网页。</p><p id="5cca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae lm" href="https://www.desuvit.com/implementing-authentication-and-authorization-in-react-js-a-stepwise-guide/www.desuvit.com" rel="noopener ugc nofollow" target="_blank">德苏威</a>在移动应用程序开发方面拥有多年的经验和专业知识。<a class="ae lm" href="https://share.hsforms.com/1E6PleoXCRFSK1W8R7ockaw44fu7" rel="noopener ugc nofollow" target="_blank">联系我们</a>了解更多。</p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><blockquote class="lc ld le"><p id="3352" class="iq ir lf is b it iu iv iw ix iy iz ja lg jc jd je lh jg jh ji li jk jl jm jn hb bi translated"><strong class="is hj"> Desuvit是一家诞生于挪威的软件开发公司，为各种垂直行业和业务领域提供定制软件开发、移动应用和Web应用开发。</strong></p><p id="46c2" class="iq ir lf is b it iu iv iw ix iy iz ja lg jc jd je lh jg jh ji li jk jl jm jn hb bi translated"><strong class="is hj">我们为没有软件或IT部门的公司、初创公司以及需要扩大软件开发规模但缺乏所需专业知识的公司提供端到端解决方案。我们帮助客户发展业务，因此我们可以与他们一起成长。</strong></p><p id="da9c" class="iq ir lf is b it iu iv iw ix iy iz ja lg jc jd je lh jg jh ji li jk jl jm jn hb bi translated"><strong class="is hj">我们使用的一些技术:。Net、Azure、微服务、Azure functions(无服务器计算)、React Native、Flutter、React JS、TypeScript、Angular、NServiceBus、Azure Service Bus、Azure Queues、SQL Service、MySQL、Cosmos DB等。</strong></p><p id="40cf" class="iq ir lf is b it iu iv iw ix iy iz ja lg jc jd je lh jg jh ji li jk jl jm jn hb bi translated"><a class="ae lm" href="https://www.desuvit.com/contact-us/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">联系我们</strong></a><strong class="is hj">&amp;</strong><a class="ae lm" href="https://share.hsforms.com/1E6PleoXCRFSK1W8R7ockaw44fu7" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">获取您的项目预估</strong> </a></p></blockquote></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><blockquote class="lc ld le"><p id="c911" class="iq ir lf is b it iu iv iw ix iy iz ja lg jc jd je lh jg jh ji li jk jl jm jn hb bi translated"><em class="hi">最初发表于2021年8月1日</em><a class="ae lm" href="https://www.desuvit.com/implementing-authentication-and-authorization-in-react-js-a-stepwise-guide/" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://www.desuvit.com</em></a><em class="hi">。</em></p></blockquote></div></div>    
</body>
</html>