<html>
<head>
<title>What makes Putout so fast?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是什么让输出这么快？</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-makes-putout-so-fast-54419ce6bc3f?source=collection_archive---------14-----------------------#2022-06-12">https://medium.com/codex/what-makes-putout-so-fast-54419ce6bc3f?source=collection_archive---------14-----------------------#2022-06-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1e5ba2fb48abd05fbc26ad13da937183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7J0LZpXolLdnEfma.jpg"/></div></div></figure><blockquote class="iq ir is"><p id="0e0c" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">“速度不是真正的战略方式的一部分。速度意味着事物看起来快或慢，取决于它们是否有节奏。不管是哪种方式，战略大师都不会很快出现。”—宫本武藏</p></blockquote><p id="7457" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">嗨伙计们！除了AST之外，我今天最激动人心的消息是我的速度冒险，所以系好安全带，我们走吧！</p><h1 id="4d01" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">隐藏物</h1><p id="6865" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je js kw jh ji jt kx jl jm ju ky jp jq jr hb bi translated">好的，让我们检查一下🐊<a class="ae jv" href="https://github.com/coderaiser/putout" rel="noopener ugc nofollow" target="_blank">放出</a>本身。在撰写本文时，它有<strong class="iw hj"> 2402 </strong>个文件，包括:<br/>-✅JavaScript；<br/>-✅JSON；<br/> - ✅降价(+ js，ts，JSON)；<br/>——✅YAML；<br/> - ✅ `.gitignore '和`. npmignore '</p><p id="ffb0" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">以下是关于<a class="ae jv" href="https://m.do.co/c/331c4947c5df" rel="noopener ugc nofollow" target="_blank">数字海洋水滴</a>的结果:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="42ba" class="li jx hi le b fi lj lk l ll lm">coderaiser@cloudcmd:~/putout$ time redrun lint<br/>&gt; putout . — raw — rulesdir rules</span><span id="25d7" class="li jx hi le b fi ln lk l ll lm">real 0m23.321s<br/>user 0m21.971s<br/>sys 0m1.137s</span></pre><p id="29a1" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">为什么这么快就问？原因是:缓存位于</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="ba38" class="li jx hi le b fi lj lk l ll lm">node_modules/.cache/putout/places</span></pre><p id="b391" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">它是在第一个正确的基础上创建的，有3个独特之处:<br/>-node . js的版本；<br/> -版本🐊输出；<br/> -选项；</p><p id="1af3" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">当这部分发生变化时，我们将使用`— fresh '标志:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="80a3" class="li jx hi le b fi lj lk l ll lm">coderaiser@cloudcmd:~/putout$ time redrun lint — — fresh<br/>&gt; putout . — raw — rulesdir rules “ — fresh”</span><span id="8050" class="li jx hi le b fi ln lk l ll lm">real 4m24.870s<br/>user 4m16.093s<br/>sys 0m5.757s</span></pre><p id="7b52" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated"><strong class="iw hj"> 4分钟</strong>，所以大约是<strong class="iw hj"> 264秒，</strong>所以如果我们按时间划分文件数，我们将得到:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="564b" class="li jx hi le b fi lj lk l ll lm">2402 / 264 = 9</span></pre><p id="c9e0" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated"><strong class="iw hj">不使用缓存每秒9个文件！</strong></p><p id="003a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">这是跑步的结果🐊<strong class="iw hj">输出</strong> + <strong class="iw hj"> ESLint </strong>这么多支持的格式！而这仅仅是为了一个如此大的项目的新运行。</p><p id="1676" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated"><strong class="iw hj">记忆化</strong></p><blockquote class="iq ir is"><p id="4b75" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">记忆化——一种优化技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序</strong>。</p><p id="98d9" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">维基网</p></blockquote><p id="eed5" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">最简单的插件格式是<a class="ae jv" href="https://github.com/coderaiser/putout/tree/master/packages/engine-runner#replacer" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">Replacer</strong></a><strong class="iw hj">。</strong>它用了很多🦎<a class="ae jv" href="https://github.com/coderaiser/putout/blob/master/docs/putout-script.md#-putoutscript" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">输出脚本</strong> </a>，下面是例子:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="2c2b" class="li jx hi le b fi lj lk l ll lm">module.exports.report = () =&gt; 'any message here';<br/><br/>module.exports.replace = () =&gt; ({<br/>    'let __a = __b': 'const __a = __b',<br/>});</span></pre><p id="6186" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">像这样的表情:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="4c67" class="li jx hi le b fi lj lk l ll lm">let __a = __b</span></pre><p id="c770" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">被解析成<a class="ae jv" href="https://github.com/coderaiser/putout/blob/master/docs/the-book-of-ast.md#the-book-of-ast" rel="noopener ugc nofollow" target="_blank"> AST </a>格式。这是一个扩展的操作，但是这个简短的表达式经常重复，所以记忆版本的解析用来使事情变得更快。</p><h1 id="e499" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">什么能让事情变得更快？</h1><p id="f220" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je js kw jh ji jt kx jl jm ju ky jp jq jr hb bi translated">在中使用了几个操作🐊<strong class="iw hj">输出</strong>大部分时间:</p><ul class=""><li id="edef" class="lo lp hi iw b ix iy jb jc js lq jt lr ju ls jr lt lu lv lw bi translated">读/写文件；</li><li id="2c66" class="lo lp hi iw b ix lx jb ly js lz jt ma ju mb jr lt lu lv lw bi translated">解析文件；</li><li id="083f" class="lo lp hi iw b ix lx jb ly js lz jt ma ju mb jr lt lu lv lw bi translated">从语法上分析🦎<strong class="iw hj">PutoutScript；</strong></li><li id="b4c0" class="lo lp hi iw b ix lx jb ly js lz jt ma ju mb jr lt lu lv lw bi translated">穿越；</li></ul><p id="631c" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">使用文件系统不会给我们带来任何好处，所以我们可以跳过它。</p><p id="2422" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">解析文件更好，但是我们稍后再回来。遍历应该在JavaScript端进行，因为所有的插件都是基于JavaScript的。</p><p id="d917" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">所以我们可以解析🦎<strong class="iw hj">输出脚本</strong>更快<strong class="iw hj">。</strong>如何<strong class="iw hj">？</strong></p><h2 id="c282" class="li jx hi bd jy mc md me kc mf mg mh kg js mi mj kk jt mk ml ko ju mm mn ks mo bi translated"><a class="ae jv" href="https://github.com/napi-rs/napi-rs" rel="noopener ugc nofollow" target="_blank">皮娜-rs </a></h2><blockquote class="iq ir is"><p id="31f6" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">用于在<code class="du mp mq mr le b">Rust</code>中编译<code class="du mp mq mr le b">Node.js</code>附加组件的最小库。</p></blockquote><p id="41e6" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">我首先想到的是用Rust来加速。但是如前所述，memoization用于解析目的，当我们需要<a class="ae jv" href="https://github.com/coderaiser/putout/tree/master/packages/compare#readme" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">比较</strong> </a>节点时，这也是非常快速的操作(大约2ms)，并且为了使用Rust我们需要做一件事情:</p><ul class=""><li id="66df" class="lo lp hi iw b ix iy jb jc js lq jt lr ju ls jr lt lu lv lw bi translated">使用Rust遍历JSON</li><li id="d33c" class="lo lp hi iw b ix lx jb ly js lz jt ma ju mb jr lt lu lv lw bi translated">转换为BSON，然后将结果传递给Rust，然后再次转换；</li></ul><p id="c620" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">这两种情况都很难超越基于JavaScript的2毫秒<strong class="iw hj">比较</strong>。</p><h2 id="ffcd" class="li jx hi bd jy mc md me kc mf mg mh kg js mi mj kk jt mk ml ko ju mm mn ks mo bi translated"><a class="ae jv" href="https://github.com/rustwasm/wasm-bindgen" rel="noopener ugc nofollow" target="_blank"> wasm-bindgen </a></h2><blockquote class="iq ir is"><p id="1b49" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">促进Wasm模块和JavaScript之间的高级交互。</p></blockquote><p id="d8ad" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">几乎相同，但基于WebAssembly的解决方案。同样，有一个问题没有答案，那就是在铁锈上应该写些什么🤷‍♂️.</p><h2 id="ee44" class="li jx hi bd jy mc md me kc mf mg mh kg js mi mj kk jt mk ml ko ju mm mn ks mo bi translated">swc </h2><blockquote class="iq ir is"><p id="c3a7" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">基于Rust的网络平台</p></blockquote><p id="bb8f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">好吧，这是一个解决方案，因为我们仍然有一个文件解析，这肯定是可以加速的。</p><p id="aaa0" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">下面是我们用来比较一个非常大的文件(<strong class="iw hj"> 44k </strong>)的速度的代码:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="a09c" class="li jx hi le b fi lj lk l ll lm">const {readFileSync} = require('fs');</span><span id="dfd1" class="li jx hi le b fi ln lk l ll lm">const {parseSync} = require('<a class="ae jv" href="http://twitter.com/swc/core" rel="noopener ugc nofollow" target="_blank">@swc/core</a>');<br/>const {parse} = require('putout');</span><span id="ed68" class="li jx hi le b fi ln lk l ll lm">const source = readFileSync('./lib/cli/index.spec.js', 'utf8');</span><span id="98bd" class="li jx hi le b fi ln lk l ll lm">console.time('swc #1');<br/>parseSync(source);<br/>console.timeEnd('swc #1');</span><span id="a731" class="li jx hi le b fi ln lk l ll lm">console.time('swc #2');<br/>parseSync(source);<br/>console.timeEnd('swc #2');</span><span id="6f8b" class="li jx hi le b fi ln lk l ll lm">console.time('babel #1');<br/>parse(source);<br/>console.timeEnd('babel #1');</span><span id="5670" class="li jx hi le b fi ln lk l ll lm">console.time('babel #2');<br/>parse(source);<br/>console.timeEnd('babel #2');</span></pre><p id="b115" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">结果如下:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="26ed" class="li jx hi le b fi lj lk l ll lm">swc #1: 13.898ms<br/>swc #2: 13.33ms<br/>babel #1: 236.062ms<br/>babel #2: 132.123ms</span></pre><p id="c54f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated"><strong class="iw hj"> SWC </strong>比<strong class="iw hj">快10倍</strong>比<strong class="iw hj">通天塔</strong>！所以我们可以用它来解析。</p><p id="abd2" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">酪它有不同的内部格式:AST。这个其实是可以解决的，有一个工具<a class="ae jv" href="https://github.com/coderaiser/swc-to-babel" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">SWC-to-Babel</strong></a><strong class="iw hj"/>旨在将<strong class="iw hj"> SWC </strong>格式转换为<strong class="iw hj"> Babel </strong>，但是差别很大，<strong class="iw hj"> SWC </strong>不支持:</p><ul class=""><li id="4548" class="lo lp hi iw b ix iy jb jc js lq jt lr ju ls jr lt lu lv lw bi translated">评论；</li><li id="8354" class="lo lp hi iw b ix lx jb ly js lz jt ma ju mb jr lt lu lv lw bi translated">位置数据(已求解)；</li><li id="dcc6" class="lo lp hi iw b ix lx jb ly js lz jt ma ju mb jr lt lu lv lw bi translated">部分解析；</li><li id="5a60" class="lo lp hi iw b ix lx jb ly js lz jt ma ju mb jr lt lu lv lw bi translated">所有新语法<strong class="iw hj">巴别塔</strong>支持</li></ul><p id="d07d" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">甚至在进行了一些转换之后，像删除节点这样简单的转换也不起作用。使用额外的解析器也会使事情变得不稳定，因为我们已经使用了<a class="ae jv" href="https://github.com/benjamn/recast" rel="noopener ugc nofollow" target="_blank">重铸</a>、<a class="ae jv" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank">巴别塔</a>和<a class="ae jv" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>。他们每个人都有自己的冒险经历。</p><h1 id="c6a5" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h1><p id="f260" class="pw-post-body-paragraph it iu hi iw b ix ku iz ja jb kv jd je js kw jh ji jt kx jl jm ju ky jp jq jr hb bi translated">是的，有些事情是可以改进的，而且肯定会改进！我很感激任何方向的帮助。不管怎样，事情仍然进行得很快。</p><p id="9af7" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je js jg jh ji jt jk jl jm ju jo jp jq jr hb bi translated">如果你喜欢我正在做的事情，你可以在<a class="ae jv" href="https://www.patreon.com/coderaiser" rel="noopener ugc nofollow" target="_blank"> Patreon </a>或<a class="ae jv" href="https://ko-fi.com/coderaiser" rel="noopener ugc nofollow" target="_blank"> ko-fi </a>上支持我。如果您需要任何代码转换，只需<a class="ae jv" href="https://github.com/coderaiser/putout/issues/new" rel="noopener ugc nofollow" target="_blank">创建一个问题</a>，我随时乐意提供帮助🙂。</p></div></div>    
</body>
</html>