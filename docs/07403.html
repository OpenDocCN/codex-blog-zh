<html>
<head>
<title>Dynamic Programming: An Overview and Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态编程:概述和实现</h1>
<blockquote>原文：<a href="https://medium.com/codex/dynamic-programming-an-overview-and-implementation-e29aa424bad7?source=collection_archive---------39-----------------------#2022-06-13">https://medium.com/codex/dynamic-programming-an-overview-and-implementation-e29aa424bad7?source=collection_archive---------39-----------------------#2022-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4fe6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">动态规划是以最佳方式解决复杂问题的算法方法。基本上，一个复杂的问题被分成多个更简单的子问题，这些子问题更容易解决，最终的解决方案取决于所有子问题的解决方案。</p><p id="ffab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">动态规划问题涉及递归模式，其中解决方案是从最基础的情况一直向上构建到最高层。因此，它在时间和空间复杂性方面相当密集。但是人们很少使用一些技术来优化他们的解决方案，因此他们的算法需要更少的时间和内存来执行。最受欢迎的有:</p><ul class=""><li id="6cef" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">记忆化</li><li id="6355" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">表格</li></ul></div><div class="ab cl jr js gp jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hb hc hd he hf"><p id="e845" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">记忆:</strong></p><p id="ba31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于递归算法的性质，许多子问题是重复的，但又被解决了。例如，考虑以下斐波纳契数列:</p><p id="0e23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jy"> 0，1，1，2，3，5，8，13，… </em></p><p id="784f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们知道序列中的每个Fib(n)都等于Fib(n-1)+Fib(n-2)。让我们看看代码和它的树形结构:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="d06f" class="ki kj hi ke b fi kk kl l km kn">const Fib = (n) =&gt; {<br/>    if(n &lt;= 1) return n;<br/>    <br/>    return Fib(n-1) + Fib(n-2);<br/>}</span><span id="0373" class="ki kj hi ke b fi ko kl l km kn">console.log(Fib(7));</span></pre><figure class="jz ka kb kc fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kp"><img src="../Images/5fc52d45b795d284f8c1f990151031ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRv74IX_MXfUltJbXWeL4Q.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx translated">coderbyte.com</figcaption></figure><p id="954f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这个树形图中我们可以看到，要计算Fib(7)，就得计算Fib(6)和Fib(5)。并且为了计算Fib(6)，Fib(5)需要与Fib(4)一起被再次计算，并且这个循环继续。</p><p id="b5de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">估计时间复杂度:O(2^n)</p><p id="87e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">估计的空间复杂度:O(n)</p><blockquote class="lb lc ld"><p id="f229" class="if ig jy ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated">记忆是一种技术，在这种技术中，我们存储子问题的解决方案，以便我们可以在以后需要时使用它们，因此避免了重复。</p></blockquote><p id="a7a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一下记忆解决方案:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="9370" class="ki kj hi ke b fi kk kl l km kn">const Fib = (n, memo={}) =&gt; {<br/>    if(n in memo) return memo[n];<br/>    if(n &lt;= 1) return n;<br/>    <br/>    memo[n] = Fib(n-1, memo) + Fib(n-2, memo);<br/>    return memo[n];<br/>}</span><span id="eb2f" class="ki kj hi ke b fi ko kl l km kn">console.log(Fib(7));</span></pre><figure class="jz ka kb kc fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lh"><img src="../Images/747ab2ef8536f0e86901a323d5eee933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*BzC72SgmHxQhOOHRoDYJrw.png"/></div></div></figure><p id="500b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Fib(2)、Fib(3)、Fib(4)、Fib(5)被计算一次并存储在memo对象中以备后用。因此，这种方法计算结果快得多。</p><p id="21c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">估计时间复杂度:O(n)</p><p id="2ab6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">估计的空间复杂度:O(n)</p></div><div class="ab cl jr js gp jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hb hc hd he hf"><p id="2510" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">制表:</strong></p><p id="df5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这种技术，动态问题被迭代地而不是递归地解决。基本上，在确定了主要问题和它的子问题之间的关系之后，我们从最基本的情况开始，直到解决主要问题。结果被存储在适合于这类问题的数据结构中。</p><p id="5235" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用这种方法解决同一个Fib(n)问题:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="9795" class="ki kj hi ke b fi kk kl l km kn">const Fib = (n) =&gt; {<br/>    const sequence = new Array(n+1).fill(0);<br/>    <br/>    //base case<br/>    sequence[0] = 0;<br/>    sequence[1] = 1;<br/>    // relation: sequence[i] = sequence[i-1] + sequence[i-2];<br/>    <br/>    for(let i = 2; i &lt;= n; i++){<br/>        sequence[i] = sequence[i-1] + sequence[i-2];<br/>    }<br/>    return sequence[n];<br/>}</span><span id="d593" class="ki kj hi ke b fi ko kl l km kn">console.log(Fib(n));</span></pre><p id="0f7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是优化动态问题解决方案的另一种方式。</p><p id="77eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">估计时间复杂度:O(n)</p><p id="ac3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">估计的空间复杂度:O(n)</p></div><div class="ab cl jr js gp jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hb hc hd he hf"><blockquote class="lb lc ld"><p id="1b18" class="if ig jy ih b ii ij ik il im in io ip le ir is it lf iv iw ix lg iz ja jb jc hb bi translated"><strong class="ih hj">记忆</strong>和<strong class="ih hj">列表</strong>都可以有效减少动态规划算法的执行时间和内存。在<strong class="ih hj">记忆</strong>中，我们通过存储结果以备后用来解决这个问题，在<strong class="ih hj">列表</strong>中，采用迭代方法而不是递归。</p></blockquote></div></div>    
</body>
</html>