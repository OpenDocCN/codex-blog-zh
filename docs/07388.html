<html>
<head>
<title>Implementing a Custom Simple Data Pipeline And Superset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现自定义简单数据管道和超集</h1>
<blockquote>原文：<a href="https://medium.com/codex/implementing-so-simple-data-pipeline-and-superset-5d9011f10e80?source=collection_archive---------24-----------------------#2022-06-13">https://medium.com/codex/implementing-so-simple-data-pipeline-and-superset-5d9011f10e80?source=collection_archive---------24-----------------------#2022-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="cf72" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">真实案例:Python、Crontab、Docker、超集、SQLite和PostgreSQL</h2></div><p id="ae2d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你好。在这个故事中，我们将要谈论的话题将是我最近为一个客户完成的工作之一。我实现了一个定制的数据管道来创建他们的BI报告。然后，我设置了一个超集实例，让他们拥有自己的BI工具。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/dcc14252581f85d473e7a46b45dfdda2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hb1mtRLM5acFJSOtrOsrOQ.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">照片由<a class="ae kj" href="https://unsplash.com/@emilymorter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">艾米丽·莫特</a>在<a class="ae kj" href="https://unsplash.com/s/photos/data-pipeline?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="9593" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">介绍</h1><p id="1b37" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">Python是我用来创建管道的主要工具。我编写了一个定制脚本，从服务器上的<code class="du lh li lj lk b">SQLite</code>数据库中提取数据，然后将其加载到我在服务器上作为仓库创建的新的<code class="du lh li lj lk b">Postgres</code>数据库中。在实现提取和装载到仓库的过程之后，我通过使用服务器上的<code class="du lh li lj lk b">crontab</code>来安排数据的刷新频率。最后，我设置了一个超集实例来创建BI报告。此外，我为自己设置了一个<code class="du lh li lj lk b">PgAdmin</code>实例，以便在需要时修复问题。让我们探索我采取的每一步。</p><h1 id="e4e4" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">设置Postgres &amp; PgAdmin</h1><p id="5dc0" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">在这一步创建了一个新的Postgres数据仓库。此外，在这一步还创建了一个PgAdmin实例来监控和管理Postgres数据仓库。</p><p id="693b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了创建Postgres数据库，我得到了Docker的帮助。我还将一个卷绑定到warehouse容器来存储数据，即使它重启了也是如此。</p><pre class="ju jv jw jx fd ll lk lm ln aw lo bi"><span id="3c44" class="lp kl hi lk b fi lq lr l ls lt"><em class="lu">#! /bin/bash</em></span><span id="c35c" class="lp kl hi lk b fi lv lr l ls lt">sudo docker run --name wh-db -p 5434:5432 -e POSTGRES_PASSWORD=MY_PASSWORD -d -v /tmp/path/:/var/lib/postgresql/data postgres</span></pre><p id="2cff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我创建了一个新的容器来启动PgAdmin。</p><pre class="ju jv jw jx fd ll lk lm ln aw lo bi"><span id="4575" class="lp kl hi lk b fi lq lr l ls lt"><em class="lu">#! /bin/bash</em></span><span id="e464" class="lp kl hi lk b fi lv lr l ls lt">sudo docker container run --name pgadmin-wh -d -e PGADMIN_DEFAULT_EMAIL=info@MYMAIL.com -e PGADMIN_DEFAULT_PASSWORD=MY_PASSWORD -e PGADMIN_LISTEN_PORT=5435 -p 5435:5435 dpage/pgadmin4</span></pre><h2 id="9293" class="lp kl hi bd km lw lx ly kq lz ma mb ku jg mc md kw jk me mf ky jo mg mh la mi bi translated">PgAdmin的Nginx配置</h2><p id="b7ca" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">我还将一个域与PgAdmin实例绑定，使它可以在web上访问。为此，我使用了下面的配置要点。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mj mk l"/></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es ml"><img src="../Images/6eaa524f04aab267fe78882796143d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*opoPcLqdlhJF9Ai2-tF-3g.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">我部署的实例</figcaption></figure><h1 id="0740" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">实现ETL脚本</h1><p id="da42" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">我在web app的文件夹里创建了一个<code class="du lh li lj lk b">script.py</code>文件。在这个文件中，我编写了ETL过程的代码。当然，我创建了一个virtualenv并安装了以下软件包:</p><ul class=""><li id="d898" class="mm mn hi iz b ja jb jd je jg mo jk mp jo mq js mr ms mt mu bi translated">熊猫</li><li id="82f4" class="mm mn hi iz b ja mv jd mw jg mx jk my jo mz js mr ms mt mu bi translated">sqlalchemy</li></ul><pre class="ju jv jw jx fd ll lk lm ln aw lo bi"><span id="4a68" class="lp kl hi lk b fi lq lr l ls lt"><em class="lu">#! ./venv/bin/python3</em></span><span id="3560" class="lp kl hi lk b fi lv lr l ls lt">import pandas as pd<br/>import sqlite3<br/>from sqlalchemy import create_engine</span><span id="3a87" class="lp kl hi lk b fi lv lr l ls lt"><em class="lu"># Read sqlite query results into a pandas DataFrame<br/></em>con = sqlite3.connect("/home/path/project/db.sqlite3")<br/>df = pd.read_sql_query("SELECT * from &lt;TABLE_NAME&gt;", con)<br/>df['revenue'] = pd.to_numeric(df['revenue']) / 100<br/>df['datetime'] = pd.to_datetime(df['datetime'])</span><span id="9cb5" class="lp kl hi lk b fi lv lr l ls lt">con.close()</span><span id="e9cb" class="lp kl hi lk b fi lv lr l ls lt"><em class="lu"># PostgreSQL connection<br/></em>engine = create_engine('postgresql://postgres:&lt;PASSWORD&gt;@localhost:5434/postgres')</span><span id="2ab2" class="lp kl hi lk b fi lv lr l ls lt"><em class="lu"># Load the data into the warehouse<br/></em>df.to_sql('&lt;TABLE_NAME&gt;', con=engine, if_exists='replace',index=False)</span></pre><p id="6bf5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">脚本的第一行让自己在执行时，通过使用位于第一行的python环境来执行自己。</p><p id="92a1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基本上，该脚本从prod db中提取transactions表，并在一些数据类型转换后将数据加载到我们使用Postgres创建的仓库中。还有一件非常重要的事情就是提供数据的刷新。让我们在下一步探索我是如何做到的。</p><h1 id="76dc" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">使用Crontab提供新数据</h1><p id="50a6" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated"><code class="du lh li lj lk b">crontab</code>是大多数Linux发行版中的内置程序。我们可以使用它来调度我们的cron作业。另外，如果您想深入了解crontab，您应该访问下面的链接。</p><div class="na nb ez fb nc nd"><a href="https://man7.org/linux/man-pages/man5/crontab.5.html" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">crontab(5) - Linux手册页</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">NAME | DESCRIPTION | EXAMPLE CRON FILE | Jobs IN/etc/CRON . d/| EXAMPLE OF A Jobs IN/etc/CRON . d/JOB | SELinux with…</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">man7.org</p></div></div><div class="nm l"><div class="nn l no np nq nm nr kd nd"/></div></div></a></div><p id="c4f8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过在终端执行<code class="du lh li lj lk b">crontab -e</code>命令来使用它。我将下面一行添加到crontab文件中。</p><pre class="ju jv jw jx fd ll lk lm ln aw lo bi"><span id="9a52" class="lp kl hi lk b fi lq lr l ls lt">0 0,8,16 * * * /home/path/project/venv/bin/python3 /home/path/project/script.py</span></pre><p id="47f2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我每天在00.00，08.00和16.00提供最新数据。通过访问下面的链接，您可以了解更多关于如何使用crontab安排时间的信息。</p><div class="na nb ez fb nc nd"><a href="https://crontab.guru/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">crontab . guru——cron调度表达式编辑器</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">cron调度表达式的快速简单的编辑器我们创建了Cronitor，因为cron本身不能…</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">crontab.guru</p></div></div></div></a></div><p id="29a0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上，我们已经使用纯Python创建了一个简单的ETL管道。现在，我们需要使用这些数据来创建报告。让我们在下一节看看如何创建报告。</p><h1 id="64bb" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">设置超集和创建BI报表</h1><p id="da60" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">为了创建一个超集实例，我从我创建的关于完全相同问题的资源中获得了帮助。</p><div class="na nb ez fb nc nd"><a href="https://github.com/mebaysan/Superset-Production-Environment" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hj fi z dy ni ea eb nj ed ef hh bi translated">GitHub-mebaysan/Superset-Production-Environment:我创建这个repo是为了准备一个超集…</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">实际上，这是一个保存了一些脚本的简单回购。那么，我为什么要创造这个呢？我在试着跑的时候很痛苦…</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">github.com</p></div></div><div class="nm l"><div class="ns l no np nq nm nr kd nd"/></div></div></a></div><p id="63f0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以很容易地使用回购超集。我只是将回购克隆到客户端的服务器上，然后运行实例。下图是客户报告的一个例子。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es nt"><img src="../Images/69a82e5310a804485ef3a1b1b02c5cbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2oZMDF1IxhSGjlfTJtHJQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">作者图片</figcaption></figure><p id="44b5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我还使用上面提到的脚本将一个域绑定到超集实例中。</p><h1 id="71b7" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后</h1><p id="42dd" class="pw-post-body-paragraph ix iy hi iz b ja lc ij jc jd ld im jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">希望你喜欢这个故事。我觉得分享一个现实生活中的案例会有帮助。我知道流程会得到改进。然而，客户的需求非常简单。因此，我选择了最简单的方法来解决他们的问题。</p><p id="d62d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">亲切的问候。</p></div></div>    
</body>
</html>