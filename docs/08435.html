<html>
<head>
<title>Over-engineering an Application in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">过度设计Rust中的应用程序</h1>
<blockquote>原文：<a href="https://medium.com/codex/over-engineering-an-application-in-rust-f01d1b7980?source=collection_archive---------3-----------------------#2022-08-08">https://medium.com/codex/over-engineering-an-application-in-rust-f01d1b7980?source=collection_archive---------3-----------------------#2022-08-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3c96" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">以下是我学到的，以及为什么你也应该这么做。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/1061796139145d24233737faa9aabc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TrDECLkMkq6MX_zNVUoi6w.png"/></div></div></figure><p id="860b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我最近开始在工作中自动化一项任务，这项任务需要大量样板代码和手动格式化。我的解决方案是获取一个JSON文件，其中包含生成结果文本文件所需的参数和属性。</p><p id="fb5f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">看起来很简单，对吧？简单的python脚本或笔记本可能是实现这一结果的最简单方式。但是我采取了不同的方法。相反，我创建了一个用(等一下)… rust编写的多线程命令行工具。一种我没有经验的语言。我从这个练习中学到了什么，为什么我认为你应该尝试类似的东西？</p><h2 id="72bb" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">🤖铁锈很漂亮，但很粗糙</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/487abe0e51a93be89de606fbcc0dbb80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yS0I-KSi1iC_9Q-0Fm7DOg.png"/></div></div></figure><p id="b811" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我以写Python和JavaScript为生。它们以简单、高级、可移植和非常动态而闻名。在学校学习和练习C++之后，我开始怀念静态编译语言的“严格”本质。</p><p id="91e3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">因此，我决定开始学习Rust，并利用这种新语言的宣传。我选择学习Rust而不是GO或其他同类产品的一些原因是:</p><p id="a850" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">💨<strong class="jl hj">静态编译</strong>，因此速度极快，专为性能而设计。</p><p id="0f34" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">🖥它是一种<strong class="jl hj">低级系统编程语言</strong>。因此，它迫使你在构建任何东西之前习惯于考虑数据结构、内存和应用程序架构。</p><p id="88c9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">可以用这种语言构建的✅应用范围— <strong class="jl hj">从游戏和web服务器</strong>到使用<strong class="jl hj"> web assembly (WASM) </strong>引导web应用。</p><p id="4032" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">太好了，所有这些听起来都不错。只是有个问题。Rust因其陡峭的学习曲线而臭名昭著。经过一门课程、一本书和几个小时的阅读rust文档，我仍然会被编译器困扰。但总的来说，Rust是一种设计非常优雅的语言，一旦你掌握了它，它会非常直观。</p><h2 id="49c4" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">🏃🏽测试驱动开发(TDD)</h2><p id="5b07" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">TDD是一个让我纠结的概念。一方面，当它工作时，它允许解决方案设计的快速迭代。另一方面，当问题陈述变化太快时，它也变得非常繁琐。这意味着测试用例也会发生变化，导致工作量加倍。</p><p id="b98e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这个项目中，我采用了一种<strong class="jl hj">混合方法</strong>，看起来效果很好。对于有具体结果的功能，我首先开发测试。与此同时，对于其他更不稳定的函数来说，测试来得更晚。</p><p id="9902" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在rust中编写单元测试的惯用方式是将它们放在与源代码相同的文件中。这非常令人耳目一新，并提升了TDD，因为<strong class="jl hj">更少的上下文切换</strong>和<strong class="jl hj">更易访问</strong>。</p><h2 id="a19e" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">🧵并发</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a45e6e4f919729281a8be50a2ecc21bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C55acr3ENXFrq8CSwUzNcA.png"/></div></div></figure><p id="e1ca" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在我知道您在想什么，为什么您需要多线程来处理一个简单的JSON文件，并使用一些逻辑将它写入一个文本文件？但是听我说完。</p><p id="9337" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">来自非计算机科学背景的我，并发似乎一直是编程的巅峰。它还提供了重温和学习线程管理、消息传递、内存共享等的机会。</p><p id="4edb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但在后台，我也听到程序员在喊分段错误、内存泄漏和竞争条件的微弱噪音。无论如何，我决定学习rust标榜的“无畏并发”。在此过程中，我在并行化应用时遇到了以下挑战:</p><p id="94f3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">⁉️:我应该并行化应用程序的哪一部分？主线程应该负责读写字符串对象吗？</p><p id="5901" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">⁉️:从JSON文件中读取数据后，如何分割数据？</p><p id="8b42" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">⁉️:我如何处理去串行化的输入数据？我是使用互斥体在不同的线程之间共享它，还是分解它并将其视为不可变的？</p><p id="7ec2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这些问题让我重新思考这个程序是如何构建的，也凸显了数据不变性的重要性。最后，我选择的路线是让主线程进行读写。然后，读取的数据被反序列化为struct对象的向量，并分布在每个线程中。每个线程处理完对象后，都会返回一个字符串，然后将它们发送给主线程。一旦接收到所有数据，主线程最终聚集字符串并将其写入文件。</p><p id="6b39" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">简单…没有？</p><h2 id="8bd2" class="kf kg hi bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz bi translated">为什么你应该做类似的练习？</h2><p id="d063" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">所以你可能会再次问，为什么我要为一个相对简单的问题构思一个如此复杂的解决方案？这么说吧，通过这个练习，我获得了以下副作用:</p><p id="ca45" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">✅对用rust编写惯用代码更加得心应手了。</p><p id="582b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">✅阅读其他更有经验的开发人员编写的代码，同时寻找问题的解决方案。</p><p id="2567" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">✅尝试了多线程和消息传递。</p><p id="3c66" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有时候采取更艰难的方式来解决问题是有好处的😉</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h1 id="f681" class="lm kg hi bd kh ln lo lp kl lq lr ls kp io lt ip ks ir lu is kv iu lv iv ky lw bi translated">想要连接吗？</h1><p id="5667" class="pw-post-body-paragraph jj jk hi jl b jm la ij jo jp lb im jr js lc ju jv jw ld jy jz ka le kc kd ke hb bi translated">感谢您阅读我的文章。你也可以在<a class="ae lx" href="https://www.linkedin.com/in/mukkundsunjii/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我，在<a class="ae lx" href="https://github.com/mukkund1996" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到我的工作。</p></div></div>    
</body>
</html>