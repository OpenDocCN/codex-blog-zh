<html>
<head>
<title>Extracting the business logic — the project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提取业务逻辑——项目</h1>
<blockquote>原文：<a href="https://medium.com/codex/extracting-the-business-logic-the-project-62c07977c9e1?source=collection_archive---------19-----------------------#2021-03-30">https://medium.com/codex/extracting-the-business-logic-the-project-62c07977c9e1?source=collection_archive---------19-----------------------#2021-03-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/87f09ae518c25840ac50dea792b97fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jtwDnqkOwH7zgKPFA-n0iQ.jpeg"/></div></div></figure><p id="b21f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<a class="ae jo" href="https://developer20.com/refactoring-for-better-testability/" rel="noopener ugc nofollow" target="_blank">的上一篇文章</a>中，我们为一个项目写了一些测试，以确保我们的重构不会破坏任何东西。为了更好地理解这个项目，我们将分离这个领域的一部分，并向它添加一个测试。这将使测试更加真实。</p><p id="3732" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">端到端(e2e)测试有一个问题:数据库在引擎盖下。这种态度不是无忧无虑的。首先，那些测试相当慢。当测试数量增加时，这可能是一个问题。我们使用一个有开销的真实数据库连接。</p><p id="06ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其次，这些测试不像孤立的测试那样稳定。我们必须记住在运行测试、运行所有迁移和(有时)清除表之前启动数据库。如果某样东西可以分裂——它最终会发生。如果我们想要一个有用的CI，我们也必须在那里运行那些测试。我们需要像在本地机器上那样配置配置项。设置比仅仅运行<code class="du jp jq jr js b">go test ./...</code>要复杂得多。</p><p id="5119" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">已经证实集成测试是有帮助的。单元测试应该是我们测试集的基础。这些知识激励我们去写它们。我们必须先了解核心领域。根据我们发送请求的顺序，我们可以假设创建项目是起点。看看下面的处理程序。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="b7bc" class="kb kc hi js b fi kd ke l kf kg">func (p Project) Create(w http.ResponseWriter, r *http.Request) {<br/>	b, err := ioutil.ReadAll(r.Body)<br/>	if err != nil {<br/>		log.Printf("cannot read the body: %s", err)<br/>		http.Error(w, "cannot read the body", http.StatusBadRequest)<br/>		return<br/>	}<br/><br/>	req := httpmodels.CreateProjectRequest{}<br/>	err = json.Unmarshal(b, &amp;req)<br/>	if err != nil {<br/>		log.Printf("cannot read the body: %s", err)<br/>		http.Error(w, "invalid JSON provided", http.StatusBadRequest)<br/>		return<br/>	}<br/><br/>	if req.Name == "" {<br/>		log.Printf("the name is required")<br/>		http.Error(w, "the name is required", http.StatusBadRequest)<br/>		return<br/>	}<br/><br/>	id, err := p.Repo.CreateProject(req.Name)<br/>	if err != nil {<br/>		log.Printf("internal server error: %s", err)<br/>		http.Error(w, err.Error(), http.StatusInternalServerError)<br/>		return<br/>	}<br/><br/>	resp := httpmodels.CreateProjectResponse{id}<br/>	b, _ = json.Marshal(resp)<br/><br/>	w.Header().Add("content-type", "application/json")<br/>	w.WriteHeader(http.StatusOK)<br/>	_, _ = w.Write(b)<br/>}</span></pre><p id="1e4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一行在这一点上不是很有用。读取请求并将其解组到一个结构中是唯一的标准。我们可以看到一个看起来有点可疑的<code class="du jp jq jr js b">if</code>语句。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="23e0" class="kb kc hi js b fi kd ke l kf kg">if req.Name == "" {<br/>		log.Printf("the name is required")<br/>		http.Error(w, "the name is required", http.StatusBadRequest)<br/>		return<br/>	}</span></pre><p id="a8c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它说我们需要添加名字，这是绝对必要的。当我们继续阅读时，我们会注意到我们将项目的id返回给了API调用者。id是从创建项目的函数中下载的。要创建新方案，我们必须输入其名称。每个项目都有一个<code class="du jp jq jr js b">ID</code>。我将向您展示如何在代码中对此建模。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="1f45" class="kb kc hi js b fi kd ke l kf kg">type Project struct {<br/>    id string<br/>    name string<br/>}<br/><br/>func (p Project) Name() string {<br/>	return p.name<br/>}<br/><br/>func (p Project) ID() string {<br/>	return p.id<br/>}</span></pre><p id="9093" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们用私有方法创建了一个新的结构。它将提供项目的正确状态，不会导致任何问题。我们使用私有字段，它是通过编写两个getter方法得到的。他们没有构造函数。尽管我们仍然可以创建一个自定义的构造函数。</p><p id="e682" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的领域中，项目必须有一个有效的名称和一个id。我们至少可以通过两种方式实现这一目标。第一个是创建构造函数方法。这个方法将完成所有的审计。第二种方法是创建一个函数<code class="du jp jq jr js b">func (p Project) IsValid() bool</code>。每次我们想检查项目是否是重要对象时，都会用到它。</p><p id="cd09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就我个人而言，我更喜欢第一种选择，但第二种也是有效的。这都是关于偏好和案件的细节。现在，您可以进行测试了。创建一个名为domain/project_test.go的新文件，并如下所示放置测试。请注意，我们创建了一个新的域包。</p><p id="b546" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">域包里有什么？</strong></p><p id="162d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在领域驱动设计(DDD)中，领域是我们应用程序的基础。它保存了应用程序的所有业务逻辑。它不能包含任何与基础结构交互的代码。该领域应该是平台和框架不可知的。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="6547" class="kb kc hi js b fi kd ke l kf kg">package domain<br/><br/>import "testing"<br/><br/>func TestProject_Test_Validation(t *testing.T) {<br/>	testCases := map[string]struct {<br/>		id string<br/>		name string<br/>	}{<br/>		"empty ID": {<br/>			name: "jfslfjal",<br/>		},<br/><br/>		"empty name": {<br/>			id: "jfslfjal",<br/>		},<br/>	}<br/><br/>	for _, tc := range testCases {<br/>		_, err := NewProject(tc.id, tc.name)<br/>		if err == nil {<br/>			t.Error("expected that the validation fails but got no error")<br/>		}<br/>	}<br/>}</span></pre><p id="d731" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们必须确保检查所有的要求。测试变成红色(不编译)。这意味着还没有这样一个<code class="du jp jq jr js b">NewProject</code>。此时，您必须将它添加到domain/project.go文件中。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="0377" class="kb kc hi js b fi kd ke l kf kg">func NewProject(id, name string) (Project, error)  {<br/>	if id == "" {<br/>		return Project{}, errors.New("the ID cannot be empty")<br/>	}<br/><br/>	if name == "" {<br/>		return Project{}, errors.New("the name cannot be empty")<br/>	}<br/><br/>	return Project{id: id, name: name}, nil<br/>}</span></pre><p id="1ccb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">测试现在应该变成绿色。我们提取了域的第一部分！该域不能与代码的其他部分直接结合。我们需要一个额外的层。现在我们将创建一个新的包，并将其命名为<code class="du jp jq jr js b">app</code>(用于应用层)。</p><p id="7a71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">app包里有什么？</strong></p><p id="c6f4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">应用层负责协调外部世界(DB、HTTP等)和您的应用程序之间的通信。这个过程通常是这样的:从存储库中获取一个域对象，执行一个动作，然后把它放回那里。</p><p id="5adb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们查看创建项目的HTTP处理程序时，我们会注意到一个简单的流程:用户提供名称，我们创建一个新项目，并返回它的<code class="du jp jq jr js b">ID</code>。我们应该写一个测试来模拟它。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="842c" class="kb kc hi js b fi kd ke l kf kg">package app<br/><br/>import (<br/>	"context"<br/>	"github.com/bkielbasa/gotodo/domain"<br/>	"github.com/google/uuid"<br/>	"testing"<br/>)<br/><br/>func TestAddNewProject(t *testing.T) {<br/>	name := "my name:" + uuid.New().String()<br/>	ctx := context.Background()<br/><br/>	projectServ := NewProjectService()<br/>	p, err := projectServ.Add(ctx, name)<br/>	if err != nil {<br/>		t.Errorf("expected no error but got: %s", err)<br/>	}<br/><br/>	if p.ID() == "" {<br/>		t.Errorf("ID is empty")<br/>	}<br/><br/>	if name != p.Name() {<br/>		t.Errorf("name don't match, expected (%s) but got (%s)", name, p.Name())<br/>	}<br/>}</span></pre><p id="17cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，我们创建了一个新的应用程序服务。服务工作是接受项目的名称，并返回一个新创建的项目，后面跟一个错误(如果发生的话)。之后，我们必须确保名称和我们提供的一样，并且ID不是空字符串(这是我们现在知道的关于<code class="du jp jq jr js b">ID</code>的信息)。您可以看到测试没有编译。这就是如何让它工作。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="5969" class="kb kc hi js b fi kd ke l kf kg">type ProjectService struct {}<br/><br/>func NewProjectService() ProjectService {<br/>	return ProjectService{}<br/>}<br/><br/>func (serv ProjectService) Add(ctx context.Context, name string) (domain.Project, error) {<br/>	return domain.Project{}, nil<br/>}</span></pre><p id="9f89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们为新类型——应用程序服务——创建了缺失的构造函数。该服务有一个简单的方法来编译初始代码。当我们运行测试时，我们会注意到它失败了。这并不奇怪，因为我们在<code class="du jp jq jr js b">Add</code>函数中什么也没做。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="4412" class="kb kc hi js b fi kd ke l kf kg">func (serv ProjectService) Add(ctx context.Context, name string) (domain.Project, error) {<br/>	id := "gopher"<br/>	return domain.NewProject(id, name)<br/>}</span></pre><p id="4f24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从现在开始，测试是绿色的。我们可以再添加一个测试来检查我们是否写对了名字。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="63c4" class="kb kc hi js b fi kd ke l kf kg">func TestAddNewProjectWithEmptyName(t *testing.T) {<br/>	name := ""<br/><br/>	projectServ := NewProjectService()<br/>	_, err := projectServ.Add(context.Background(), name)<br/>	if err == nil {<br/>		t.Errorf("expected error but got nil")<br/>	}<br/>}</span></pre><p id="37eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">测试应该是绿色的。我们没有检查正确，所以我们必须改变它。我们将通过获取特定ID的项目来更新第一个测试，并检查<code class="du jp jq jr js b">Get()</code>方法是否仍然返回相同的项目。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="6c0b" class="kb kc hi js b fi kd ke l kf kg">func TestAddNewProject(t *testing.T) {<br/>	name := "my name:" + uuid.New().String()<br/>	ctx := context.Background()<br/><br/>	projectServ := NewProjectService()<br/>	p, err := projectServ.Add(ctx, name)<br/>	if err != nil {<br/>		t.Errorf("expected no error but got: %s", err)<br/>	}<br/><br/>	if p.ID() == "" {<br/>		t.Errorf("ID is empty")<br/>	}<br/><br/>	if name != p.Name() {<br/>		t.Errorf("name don't match, expected (%s) but got (%s)", name, p.Name())<br/>	}<br/><br/>	p2, err := projectServ.Get(ctx, p.ID())<br/>	if err != nil {<br/>		t.Errorf("expected no error but got: %s", err)<br/>	}<br/><br/>	if p.ID() !=  p2.ID() {<br/>		t.Errorf("expected ID %s but %s given", p.ID(),  p2.ID())<br/>	}<br/><br/>	if p.Name() !=  p2.Name() {<br/>		t.Errorf("expected name %s but %s given", p.Name(),  p2.Name())<br/>	}<br/>}</span></pre><p id="5808" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如您所见，代码看起来很难读懂。我们可以通过提供一个助手函数requireProject来修复代码。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="0167" class="kb kc hi js b fi kd ke l kf kg">func TestAddNewProject(t *testing.T) {<br/>	name := "my name:" + uuid.New().String()<br/>	ctx := context.Background()<br/><br/>	projectServ := NewProjectService(newStoreMock())<br/>	p, err := projectServ.Add(ctx, name)<br/>	if err != nil {<br/>		t.Errorf("expected no error but got: %s", err)<br/>	}<br/><br/>	checkProjectName(t, p, name)<br/><br/>	p2, err := projectServ.Get(ctx, p.ID())<br/>	if err != nil {<br/>		t.Errorf("expected no error but got: %s", err)<br/>	}<br/><br/>	checkProjectName(t, p2, p.Name())<br/>	checkProjectID(t, p2, p.ID())<br/>}<br/><br/>func checkProjectID(t *testing.T, p domain.Project, expectedID string) {<br/>	if p.ID() !=  expectedID {<br/>		t.Errorf("expected ID %s but %s given", expectedID,  p.ID())<br/>	}<br/>}<br/><br/>func checkProjectName(t *testing.T, p domain.Project, expectedName string) {<br/>	if p.Name() !=  expectedName {<br/>		t.Errorf("expected name %s but %s given", expectedName,  p.Name())<br/>	}<br/>}</span></pre><p id="d496" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在看起来好多了，但是代码不编译。要修复它，我们必须添加缺失的<code class="du jp jq jr js b">Get</code>函数。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="6221" class="kb kc hi js b fi kd ke l kf kg">func (serv ProjectService) Get(ctx context.Context, id string) (domain.Project, error) {<br/>	return domain.NewProject(id, "fjsfsl")<br/>}</span></pre><p id="66cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">测试还是红色的。为了让它工作，我们必须添加存储，以保留我们创建的项目列表，并能够取回它。这就是我如何设计它的界面并更新<code class="du jp jq jr js b">Add()</code>和<code class="du jp jq jr js b">Get()</code>函数来使用的。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="6cd0" class="kb kc hi js b fi kd ke l kf kg">type Repository interface {<br/>	Store(ctx context.Context, p domain.Project) error<br/>	Get(ctx context.Context, id string) (domain.Project, error)<br/>}<br/><br/>func (serv ProjectService) Add(ctx context.Context, name string) (domain.Project, error) {<br/>	id := "gopher"<br/>	p, err := domain.NewProject(id, name)<br/>	if err != nil {<br/>		return domain.Project{}, err<br/>	}<br/><br/>	err = serv.storage.Store(ctx, p)<br/>	if err != nil {<br/>		return domain.Project{}, err<br/>	}<br/><br/>	return p, err<br/>}<br/><br/>func (serv ProjectService) Get(ctx context.Context, id string) (domain.Project, error) {<br/>	return serv.storage.Get(ctx, id)<br/>}</span></pre><p id="3c82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jp jq jr js b">ProjectService</code>不包含新功能。我们现在应该添加它。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="34c2" class="kb kc hi js b fi kd ke l kf kg">type ProjectService struct {<br/>	repo Repository<br/>}<br/><br/>func NewProjectService(storage Repository) ProjectService {<br/>	return ProjectService{storage: storage}<br/>}</span></pre><p id="24c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">差不多完成了。我们只需在创建新的ProjectService结构的任何地方放置新的依赖项。我们需要一个新的结构来实现这个接口。让我们用一个包含domain.Project实例的映射创建一个新的。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="6c07" class="kb kc hi js b fi kd ke l kf kg">type repoMock struct {<br/>	data map[string]domain.Project<br/>}<br/><br/>func newRepoMock() *storeMock {<br/>	return &amp;repoMock{<br/>		data: make(map[string]domain.Project),<br/>	}<br/>}<br/>func (s *repoMock) Store(ctx context.Context, p domain.Project) error {<br/>	s.data[p.ID()] = p<br/>	return nil<br/>}<br/><br/>func (s *repoMock) Get(ctx context.Context, id string) (domain.Project, error) {<br/>	return s.data[id], nil<br/>}</span></pre><p id="1180" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">又变绿了！我将增加一个测试，因为我们没有覆盖一个重要的案例。项目不存在怎么办？Get函数不应该返回错误吗？存储知道项目是否存在，所以错误应该来自它。我们应该为这种情况创建一个单独的错误。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="40b8" class="kb kc hi js b fi kd ke l kf kg">// in app/project.go<br/>var ErrProjectNotFound = errors.New("the project is not found")</span></pre><p id="889c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了使我们的测试更容易，我们需要向模拟storeMock添加一个新的错误，并创建一个新的方法来设置给定的错误。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="62e7" class="kb kc hi js b fi kd ke l kf kg">type repoMock struct {<br/>	data map[string]domain.Project<br/>	err error // new field<br/>}<br/><br/>func (s *repoMock) Get(ctx context.Context, id string) (domain.Project, error) {<br/>	return s.data[id], s.err // added the error here<br/>}<br/><br/>func (s *repoMock) withError(err error) *storeMock {<br/>	s.err = err<br/>	return s<br/>}</span></pre><p id="172f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在它是安全的，因为有了新的帮助器方法。我们可以很容易地编写一个测试。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="331c" class="kb kc hi js b fi kd ke l kf kg">func TestAGetNotExistingProject(t *testing.T) {<br/>	id := "not exists"<br/>	ctx := context.Background()<br/>	storage := newRepoMock().withError(ErrProjectNotFound)<br/><br/>	projectServ := NewProjectService(storage)<br/><br/>	_, err := projectServ.Get(ctx, id)<br/>	if !errors.Is(err, ErrProjectNotFound) {<br/>		t.Errorf("expected error ErrProjectNotFound but got %v", err)<br/>	}<br/>}</span></pre><p id="261d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这项工作现在差不多完成了。您应该注意到，我们对每个项目ID都有一个硬编码的ID: <code class="du jp jq jr js b">gopher</code>。我们需要准备一个能迫使我们成功的测试。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="ce08" class="kb kc hi js b fi kd ke l kf kg">func TestEveryProjectShouldHaveUniqueID(t *testing.T) {<br/>	name := "a name"<br/><br/>	projectServ := NewProjectService(newRepoMock())<br/>	p1, err := projectServ.Add(context.Background(), name)<br/>	if err != nil {<br/>		t.Errorf("expected no error but got: %s", err)<br/>	}<br/><br/>	p2, err := projectServ.Add(context.Background(), name)<br/>	if err != nil {<br/>		t.Errorf("expected no error but got: %s", err)<br/>	}<br/><br/>	if p1.ID() == p2.ID() {<br/>		t.Error("every project should have a unique ID")<br/>	}<br/>}</span></pre><p id="d921" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在是红色的。有许多方法可以生成唯一的ID。为了消除红色，我们将使用简单的方法— <a class="ae jo" href="https://github.com/google/uuid" rel="noopener ugc nofollow" target="_blank"> uuid </a>。</p><pre class="jt ju jv jw fd jx js jy jz aw ka bi"><span id="46d7" class="kb kc hi js b fi kd ke l kf kg">id := uuid.New().String()</span></pre><p id="8490" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅此而已！我们通过了测试。我们从当前代码中提取了域。当然，这不是我们要重构的全部业务逻辑，但这是一个很好的起点。你可以在这个<a class="ae jo" href="https://github.com/bkielbasa/chamgotodo/pull/2" rel="noopener ugc nofollow" target="_blank">拉取请求</a>中找到我们变化的不同之处。如果你对这部分有任何问题或建议，下面有一个评论区。回头见！</p><p id="30a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">PS。如果你想了解更多关于领域驱动设计的知识，我可以推荐埃里克·埃文斯的这本书。(#ad)。</p><p id="ff80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://www.buymeacoffee.com/bklimczak" rel="noopener ugc nofollow" target="_blank">给我买杯咖啡</a></p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="4040" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ko">原载于</em><a class="ae jo" href="https://developer20.com/extracting-the-business-logic-project/" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://developer20.com</em></a><em class="ko">。</em></p></div></div>    
</body>
</html>