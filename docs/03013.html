<html>
<head>
<title>Actually understanding useState hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实际了解使用状态挂钩</h1>
<blockquote>原文：<a href="https://medium.com/codex/all-about-react-usestate-hook-54b432d61be3?source=collection_archive---------2-----------------------#2021-08-15">https://medium.com/codex/all-about-react-usestate-hook-54b432d61be3?source=collection_archive---------2-----------------------#2021-08-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3377" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这里是关于useState钩子的所有内容，以及调试你的应用程序所需要知道的一切…</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ebb8c0dc17578d8a170847df4f8acffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-elqCzR-DmkQjQkFE1Yz2g.jpeg"/></div></div></figure><p id="cb01" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">React的<em class="kf"> useState </em>钩子是我们学到的第一个钩子，但在我看来它是最难学的。据我所知，所有的使用状态教程和文档只是教我们使用使用状态的基本用法，但这不是全部。比如:-</p><ol class=""><li id="024e" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke kl km kn ko bi translated">如何处理<strong class="jl hj">异步</strong> <strong class="jl hj">的情况？</strong></li><li id="114f" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke kl km kn ko bi translated">setState是同步函数还是异步函数？</li></ol><p id="efbe" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我会试着用一些例子来澄清这些事情。</p><h1 id="29a4" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">回归基础</h1><p id="847c" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">如果你对<em class="kf"> useState </em>钩子一无所知，让我快速展示一下它的基本用法。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lr ls l"/></div></figure><ul class=""><li id="c281" class="kg kh hi jl b jm jn jp jq js ki jw kj ka kk ke lt km kn ko bi translated">在上面的代码中，我们只是声明了一个状态变量，<code class="du lu lv lw lx b">counter</code>。</li><li id="b375" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke lt km kn ko bi translated">点击“增量值”按钮，我们将<code class="du lu lv lw lx b">counter</code>的值设置为<code class="du lu lv lw lx b">counter + 1</code>，因此每次点击都会增加变量的值。</li><li id="d637" class="kg kh hi jl b jm kp jp kq js kr jw ks ka kt ke lt km kn ko bi translated">因此，变量的<strong class="jl hj">状态改变</strong>并且组件被<strong class="jl hj">重新呈现</strong>，这允许我们在UI中看到更新的值。</li></ul><h2 id="a44d" class="ly kv hi bd kw lz ma mb la mc md me le js mf mg lg jw mh mi li ka mj mk lk ml bi translated">那么为什么要使用状态变量呢？我们可以使用普通的javascript变量？</h2><p id="cbb4" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">不，我们不能。如果我们使用普通的旧的“var”或“let”JavaScript变量，则不会触发<strong class="jl hj">重新渲染</strong>，因为React只看到<em class="kf">使用状态</em>变量的状态变化。</p><h2 id="768a" class="ly kv hi bd kw lz ma mb la mc md me le js mf mg lg jw mh mi li ka mj mk lk ml bi translated">什么是状态变化？</h2><p id="fd67" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">Ans &gt;对于React，当<code class="du lu lv lw lx b">prevState !== currentState</code>时发生状态变化。所以对于原始值(数字、布尔、字符串)来说，只是改变它们的值。例如:-</p><pre class="iy iz ja jb fd mm lx mn mo aw mp bi"><span id="ad74" class="ly kv hi lx b fi mq mr l ms mt">const [name, setName] = useState("Me"); // setName("Hamster")<br/>const [marks, setMarks] = useState(0); // setMyNumber(100)<br/>const [working, setWorking] = useState(false); // setWorking(true)</span></pre><p id="69a8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">以上都将触发状态变化。</p><p id="aa69" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">对于对象和数组，你必须传递一个新的对象或数组。如果你熟悉不变性，那么这对你来说并不陌生。如果你传递一个新的对象或数组，那么只有条件<code class="du lu lv lw lx b">prevState !== currentState</code>会被触发。如果你想通过例子学习不变性，这里的是一个很好的资源。<strong class="jl hj">扩展操作符</strong>将对此非常有用。</p><pre class="iy iz ja jb fd mm lx mn mo aw mp bi"><span id="da8b" class="ly kv hi lx b fi mq mr l ms mt">const [students, setStudents] = useState(["me"]);<br/>// setSudents([...students, "another student"]);</span><span id="cd8a" class="ly kv hi lx b fi mv mr l ms mt">const [obj, setObj] = useState({something: "hello"});<br/>// setObj({...obj, someMoreThings: "bye"});</span></pre><p id="df20" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">以上都将触发状态变化，重新呈现组件。</p><h1 id="3c39" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">同步还是异步？</h1><p id="b71c" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">这对我来说是一个很长时间的误解。我们上面使用的<em class="kf">【set】</em>方法是同步的还是异步的？答案可能会让你吃惊…这些方法是同步的。哦，等等，这一点也不奇怪，但是，等等，你面临着一个挑战。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="a6c0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么你认为在调用了<code class="du lu lv lw lx b">setCounter(counter +1)</code>之后<code class="du lu lv lw lx b">console.log(counter)</code>会打印出什么？</p><p id="5960" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您将看到<code class="du lu lv lw lx b">counter</code>值在增加1后是相同的。那么发生了什么？<code class="du lu lv lw lx b">setCounter</code>应该是同步函数吧？所以这种变化应该立即反映在下一行中？<strong class="jl hj"> NOO </strong>。</p><p id="c8a2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">原来React是故意这么做的。因为setState函数非常昂贵，所以React批处理许多setState-s，所以我们不能依赖任何计算的状态变化。在这里，打印该值的正确方法是只打印<code class="du lu lv lw lx b">console.log(counter + 1)</code>。</p><h1 id="f886" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">如何处理<strong class="ak">异步</strong> <strong class="ak">的情况？</strong></h1><p id="faac" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">好了，到目前为止，我们已经知道了<em class="kf">使用状态</em>的基本知识，但是还有更多，我在很多地方都没有看到这部分的正确解释。</p><p id="15cb" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">那么一些异步的情况呢？比如一个回调函数或者一些套接字操作？对于这些情况，setState将同样工作，对吗？</p><p id="b5a1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">恐怕事实并非如此。让我们考虑一些例子。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mw ls l"/></div><figcaption class="mx my et er es mz na bd b be z dx translated">异步计数器，正常方式</figcaption></figure><p id="81c1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在这里，我们在文档上设置了一个点击监听器，这样当您点击页面时，计数器应该增加1。但是正如你所看到的，计数器第一次增加了1，但是之后就卡住了。</p><p id="c070" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为什么它不起作用？</p><p id="8533" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">基本上，对于异步的事情，React将状态变量与初始值0绑定，因此第一次<code class="du lu lv lw lx b">counter + 1</code>导致1，但是当屏幕再次被点击用于<strong class="jl hj">功能</strong>时，计数器变量仍然是0，因此计数器再次被设置为1。因此，为了防止这种情况，我们需要最后的渲染值，并用<strong class="jl hj">渲染值进行计算。</strong></p><p id="4c10" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">新的部分来了，setState变量也可以接受一个函数作为参数。举个例子就很清楚了。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="3a10" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">上面的代码类似于CodeSandbox代码，但是第8–10行有所不同。这次我们将一个函数传递给了<code class="du lu lv lw lx b">setCounter</code>函数。该函数的参数基本上是状态变量的<strong class="jl hj"> <em class="kf">渲染值</em> </strong>，因此当点击屏幕时，时间一切都按预期工作，计数器上升！！！</p><h1 id="d11c" class="ku kv hi bd kw kx ky kz la lb lc ld le io lf ip lg ir lh is li iu lj iv lk ll bi translated">结论</h1><p id="0c52" class="pw-post-body-paragraph jj jk hi jl b jm lm ij jo jp ln im jr js lo ju jv jw lp jy jz ka lq kc kd ke hb bi translated">上述方法也可以用于套接字或任何其他异步情况。向setState函数传递一个函数在教程中没有涉及太多，但我认为这是一个非常重要的情况，在应用程序中需要多次。除此之外，我想读者也很好地理解了<em class="kf">使用状态</em>钩子。谢谢你的阅读。希望你有美好的一天！！！干杯😄</p></div></div>    
</body>
</html>