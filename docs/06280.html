<html>
<head>
<title>Python GroupBy Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python分组技巧</h1>
<blockquote>原文：<a href="https://medium.com/codex/python-groupby-tricks-234004132c14?source=collection_archive---------0-----------------------#2022-04-17">https://medium.com/codex/python-groupby-tricks-234004132c14?source=collection_archive---------0-----------------------#2022-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="54e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论何时处理数据，都不可避免地要根据某些属性对其进行分组。这通常被称为“GroupBy ”,指的是<code class="du jd je jf jg b">GROUP BY</code> SQL语句。Python标准库在名为<code class="du jd je jf jg b">groupby</code>的<code class="du jd je jf jg b"><a class="ae jh" href="https://docs.python.org/3/library/itertools.html" rel="noopener ugc nofollow" target="_blank">itertools</a></code>包中提供了一个很棒的工具，它可以做到这一点。在本文中，我将探索一些技巧来充分利用它的功能。</p><p id="0726" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将探索一个包含信用卡申请的数据集，该数据集可以在Kaggle上免费检索。数据集包含信用卡申请的各种参数以及它是否被授权。本文使用的所有代码都可以在<a class="ae jh" href="https://github.com/bverhoeve/groupby-tricks" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><h2 id="c036" class="ji jj hi bd jk jl jm jn jo jp jq jr js iq jt ju jv iu jw jx jy iy jz ka kb kc bi translated"><code class="du jd je jf jg b">groupby</code>是做什么的？</h2><p id="a064" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">如文档所述:<em class="ki">创建一个迭代器，从iterable </em>中返回连续的键和组。这意味着迭代器将遍历您的数据，为每一行计算一个属性，并根据计算出的属性遍历每个组。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kj"><img src="../Images/bfd84906ae1ad5930dcbdd65d5b5f521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tApdJkIkSat_5o8DW6zyMQ.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">groupby遍历数据集，并根据提供的键函数将每个条目分配给一个组。</figcaption></figure><p id="0016" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，<code class="du jd je jf jg b">groupby</code>返回的是一个<strong class="ih hj">迭代器</strong>——而不是一个数据结构。这确保了不分配额外的内存，但是，也意味着一旦你开始迭代，就没有回头路了——如果你想重新开始，你必须创建一个新的迭代器。您可以通过在迭代器上迭代一次并将元素存储在一个数据结构(通常是一个<code class="du jd je jf jg b">dict</code>)中来减轻这个问题。在使用<code class="du jd je jf jg b">groupby</code>之前，你还需要在同一个按键功能上对数据进行排序。</p><p id="e320" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将此付诸实践，并使用<code class="du jd je jf jg b">groupby</code>根据每个申请人的子女总数对信用卡申请进行分组:</p><pre class="kk kl km kn fd kz jg la lb aw lc bi"><span id="f740" class="ji jj hi jg b fi ld le l lf lg">import itertools<br/>from collections.abc import Iterator</span><span id="60b3" class="ji jj hi jg b fi lh le l lf lg"><strong class="jg hj">def</strong> create_dict_from_groupby(iterator: Iterator) -&gt; dict:<br/>  """<br/>  Captures the groupby result in a dict so<br/>  it can be reused multiple times<br/>  """<br/>  groupby_dict = {}<br/>  for key, group in iterator:<br/>    groupby_dict[key] = list(group)<br/>  return groupby_dict</span><span id="8110" class="ji jj hi jg b fi lh le l lf lg"># key function<br/>total_children = <strong class="jg hj">lambda</strong> row: row["Total_Children"]</span><span id="7907" class="ji jj hi jg b fi lh le l lf lg"><em class="ki"># first sort by the total children<br/></em>sorted_by_children = sorted(data, key=total_children)</span><span id="472d" class="ji jj hi jg b fi lh le l lf lg"><em class="ki"># groupby the total children<br/></em>groupby_children_iter = itertools.groupby(<br/>  sorted_by_children, key=total_children<br/>)<br/>groupby_children = create_dict_from_groupby(groupby_children_iter)</span></pre><p id="3f11" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当将分组结果与批准申请的比例进行对比时，我们可以看到申请人有1-5个孩子，几乎每个申请都获得了批准，而不考虑孩子的数量。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div class="er es li"><img src="../Images/96df5c47f88289ebb322d03517c0319d.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*DXmvQBy6hlBirSZJ1WPUXA.png"/></div></figure><p id="76e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些是使用<code class="du jd je jf jg b">groupby</code>的基础:定义一个关键函数，对数据集排序，创建分组迭代器。由于<code class="du jd je jf jg b">groupby</code>是如何实现的，你可以用它做一些额外的有趣的事情。</p><h2 id="f5fa" class="ji jj hi bd jk jl jm jn jo jp jq jr js iq jt ju jv iu jw jx jy iy jz ka kb kc bi translated">通过不排序查找重复组</h2><p id="1adb" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">我们已经看到，在使用<code class="du jd je jf jg b">groupby</code>之前，我们首先需要用key函数对数据进行排序。但是如果我们不对数据进行排序会发生什么呢？文档表明<code class="du jd je jf jg b">groupby</code>每次遇到一个新的密钥都会生成一个新的组，因为它不记得已经见过它了。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es lj"><img src="../Images/4a6b5f3d9d5953b40b15addf39ad875f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hKx9VdM709-qapIwPoCzw.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">使用groupby而不排序。因为稍后会再次遇到A键，所以会创建一个新组！</figcaption></figure><p id="52f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种行为可以被滥用来寻找重复序列，这在分析顺序数据时会很有用。例如，考虑平均温度上升到30度以上的超过10天的温暖时期，或者DNA中重复核苷酸的长片段。</p><p id="e567" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到我们的信用卡应用程序，我们可以调查基于住房类型的数据中是否有任何规律性。这可能意味着每个邻域都有条目。这次我们不能将我们的<code class="du jd je jf jg b">groupby</code>结果存储在<code class="du jd je jf jg b">dict</code>中，因为那样会删除任何重复的组。我们将通过将组存储为一个<code class="du jd je jf jg b">tuples</code>列表来缓解这个问题，第一个成员是键，第二个是组条目。</p><pre class="kk kl km kn fd kz jg la lb aw lc bi"><span id="5ce1" class="ji jj hi jg b fi ld le l lf lg"><strong class="jg hj">def</strong> create_tuples_from_groupby(iterator) -&gt; list[tuple[str, list]]:<br/>  groupby_list = []<br/>  for key, group in iterator:<br/>    groupby_list.append((key, list(group)))<br/>  return groupby_list</span><span id="4ff5" class="ji jj hi jg b fi lh le l lf lg">groupby_housing_type_iter = itertools.groupby(<br/>  data, key=<strong class="jg hj">lambda</strong> row: row["Housing_Type"]<br/>)<br/>groupby_housing = create_tuples_from_groupby(<br/>  groupby_housing_type_iter<br/>)</span></pre><p id="ca3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们绘制由<code class="du jd je jf jg b">groupby</code>发现的前10组，我们可以看到基于房屋类型的一些规律性:在前200行左右，有更大的房屋和公寓集中。如果住房类型是一个重要的参数，我们可以考虑重新平衡数据，使其分布更加均匀。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div class="er es lk"><img src="../Images/1f920910342c9ac6e20e39df4d999502.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*-fVdh9saqiBnbP2nyxQsPw.png"/></div></figure><h2 id="cfaf" class="ji jj hi bd jk jl jm jn jo jp jq jr js iq jt ju jv iu jw jx jy iy jz ka kb kc bi translated">使用数据类维护组属性</h2><p id="f5e9" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">您必须为<code class="du jd je jf jg b">groupby</code>提供一个关键函数，该函数提取iterable中您想要分组的每个条目的属性。如果您想对单个属性进行分组，您通常会使用一个简单的<a class="ae jh" href="https://www.w3schools.com/python/python_lambda.asp" rel="noopener ugc nofollow" target="_blank"> lambda函数</a>来检索它:</p><pre class="kk kl km kn fd kz jg la lb aw lc bi"><span id="eca6" class="ji jj hi jg b fi ld le l lf lg">groupby_housing_type_iter = itertools.groupby(<br/> data, <em class="ki">key</em>=<em class="ki">lambda</em> <em class="ki">row</em>: <em class="ki">row</em>["Housing_Type"]<br/>)</span></pre><p id="4c4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是如果你想按多个值分组呢？您可以创建一个字符串或两个属性的散列，并将其用作键。假设我们在<code class="du jd je jf jg b">Housing Type</code>和<code class="du jd je jf jg b">Total Children</code>上分组:</p><pre class="kk kl km kn fd kz jg la lb aw lc bi"><span id="de37" class="ji jj hi jg b fi ld le l lf lg">key = <em class="ki">lambda</em> <em class="ki">row</em>: <em class="ki">f</em>"{<em class="ki">row</em>['Housing_Type']}_{<em class="ki">row</em>['Total_Children']}"<br/>groupby_housing_children = itertools.groupby(data, <em class="ki">key</em>=key)</span><span id="f24b" class="ji jj hi jg b fi lh le l lf lg">for key, group in groupby_housing_children:<br/>  housing_type = key.split('_')[0]<br/>  total_children = next(iter(group))['Total_Children'] </span></pre><p id="82a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码运行得很好，但是当您需要访问组属性时会失败。您要么求助于字符串解析，要么读取其中一个组成员的属性。这两种技术都不是特别好。</p><p id="3fa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过创建一个更复杂的返回自定义对象的键函数来解决这个问题。<code class="du jd je jf jg b">groupby</code>的唯一前提是对象具有可比性。因为自定义对象默认情况下通过内存引用进行比较，所以我们需要实现自己的<code class="du jd je jf jg b">__eq__</code>函数。幸运的是，标准库的<code class="du jd je jf jg b">dataclasses</code>包包含了为我们做这件事的功能。向<code class="du jd je jf jg b">dataclass</code>装饰器提供<code class="du jd je jf jg b">eq=True</code>将生成一个<code class="du jd je jf jg b">__eq__</code>方法，该方法根据对象的属性来比较对象，这正是我们所需要的！我还喜欢添加<code class="du jd je jf jg b">frozen=True</code>使组键不可变。</p><p id="6f30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码现在变得更具可读性，我们可以直接从键中访问每个组的属性。作为一个额外的好处，key对象具有类型化属性，可由IntelliSense和静态代码分析工具使用。</p><pre class="kk kl km kn fd kz jg la lb aw lc bi"><span id="f4ac" class="ji jj hi jg b fi ld le l lf lg">from dataclasses import dataclass</span><span id="6f58" class="ji jj hi jg b fi lh le l lf lg">@dataclass(<em class="ki">eq</em>=True, <em class="ki">frozen</em>=True)<br/><em class="ki">class</em> HousingTypeTotalChildren:<br/>  housing_type: str<br/>  total_children: int</span><span id="d0ea" class="ji jj hi jg b fi lh le l lf lg">  @classmethod<br/>  <em class="ki">def</em> from_row(<em class="ki">cls</em>, <em class="ki">row</em>: dict) -&gt; "HousingTypeTotalChildren":<br/>    return <em class="ki">cls</em>(<br/>      <em class="ki">housing_type</em>=<em class="ki">row</em>['Housing_Type'],<br/>      <em class="ki">total_children</em>=int(<em class="ki">row</em>['Total_Children'])<br/>    )</span><span id="e040" class="ji jj hi jg b fi lh le l lf lg">group_by_housing_children = itertools.groupby(<br/>  data, <em class="ki">key</em>=HousingTypeTotalChildren.from_row<br/>)</span><span id="b3bd" class="ji jj hi jg b fi lh le l lf lg">for key, group in group_by_housing_children:<br/>  # Access group properties directly from the key<br/>  print(<br/>    <em class="ki">f</em>"Housing type: {key.housing_type}, "<br/>    f"Total children: {key.total_children}"<br/>  )</span></pre><h1 id="ba06" class="ll jj hi bd jk lm ln lo jo lp lq lr js ls lt lu jv lv lw lx jy ly lz ma kb mb bi translated">结论</h1><p id="c68c" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">这个<code class="du jd je jf jg b">itertools</code>包包含了许多优秀的工具，比如<code class="du jd je jf jg b">groupby</code>。对于大多数简单的用例来说，它已经足够强大，因此您不必求助于第三方库。当然，<code class="du jd je jf jg b">groupby</code>有它的局限性，对于复杂的数据分析，你会想要使用一个像<a class="ae jh" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>这样的专用库。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><p id="9db5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ki"> Brecht是</em><a class="ae jh" href="https://www.qargo.io/" rel="noopener ugc nofollow" target="_blank"><em class="ki">qar go</em></a><em class="ki">的软件工程师，使用Python为下一代运输&amp;物流软件提供动力。</em></p></div></div>    
</body>
</html>