<html>
<head>
<title>Extractors in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中的提取器</h1>
<blockquote>原文：<a href="https://medium.com/codex/extractors-in-scala-fb0b7949562b?source=collection_archive---------10-----------------------#2022-04-03">https://medium.com/codex/extractors-in-scala-fb0b7949562b?source=collection_archive---------10-----------------------#2022-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/063ab632aac982d6890652212c005e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IizzflXXDYmEczPPNooNVA.png"/></div></div></figure><p id="723f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你是一个scala开发者，你可能习惯于在模式匹配中使用<strong class="is hj"> case类</strong>。例如，Some(x)是一个有效的模式，因为Some(x)是一个case类，让我们看一个提取电子邮件地址的case类的例子。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6fcd" class="jx jy hi jt b fi jz ka l kb kc">case class Email(User: String, domain: String)</span></pre><p id="7fe2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包含用户和域的案例类<strong class="is hj">电子邮件</strong>。如果字符串包含嵌入的<em class="kd"> '@' </em>符号，则模式匹配。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6acc" class="jx jy hi jt b fi jz ka l kb kc">def pattern(email: Email) = {<br/>    email match {<br/>      case <em class="kd">Email</em>(user, domain) =&gt; <em class="kd">println</em>(user, domain)<br/>      case _ =&gt; <em class="kd">println</em>("Not a valid email")<br/>    }<br/><br/><br/>  }<br/>  <br/>}</span></pre><p id="e8d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">提取器提供了一种创建模式的方法，而不需要提供case类。</p><p id="d497" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">提取器</strong></p><p id="47b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Scala中的Extractor是一个对象，它有一个<strong class="is hj"> unapply </strong>方法与之相关联，这个unapply方法的目的是匹配一个值并将其分离。</p><p id="c9b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用提取器提取电子邮件地址。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="7070" class="jx jy hi jt b fi jz ka l kb kc">object EMail {<br/>  // The injection method (optional)<br/>  def apply(user: String, domain: String) = user + "@" + domain<br/>  // The extraction method (mandatory)<br/>  def unapply(str: String): Option[(String, String)] = {<br/>    val parts = str split "@"<br/>    if (parts.length == 2) <em class="kd">Some</em>(parts(0), parts(1)) else None<br/>  }<br/>}</span></pre><p id="6953" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对象email有两个关联的方法apply方法和unapply方法。</p><ul class=""><li id="0407" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn kj kk kl km bi translated">apply方法接受两个字符串并将其转换成电子邮件。</li><li id="fe09" class="ke kf hi is b it kn ix ko jb kp jf kq jj kr jn kj kk kl km bi translated">unapply方法与apply方法正好相反，它接受一个字符串并分成两部分，但与apply方法不同，unapply必须处理字符串不是电子邮件的情况，这就是unapply返回一个<strong class="is hj">选项</strong>而不是一对字符串的原因。</li></ul><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="8ad2" class="jx jy hi jt b fi jz ka l kb kc"><em class="kd">println</em>(EMail.<em class="kd">unapply</em>("someone@example.com"))<br/><em class="kd">println</em>(EMail.<em class="kd">unapply</em>("someone"))</span><span id="2b0f" class="jx jy hi jt b fi ks ka l kb kc">Some((someone,example.com))<br/>None</span></pre><p id="742c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">具有零个或多个变量的模式</strong></p><p id="11b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">提取器模式也可能不绑定任何变量，在这种情况下，unapply方法返回true或false。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="77e0" class="jx jy hi jt b fi jz ka l kb kc">object UpperCase {<br/>  def unapply(s: String): Boolean = s.toUpperCase == s<br/>}</span></pre><p id="df57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果字符串是大写的，上面的函数将返回true，否则返回false。</p><p id="b4d6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">可变参数提取器</strong></p><p id="60c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在前面的示例中，电子邮件地址都返回固定数量的值。有时这不够灵活。例如</p><p id="bb0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="kd">tom@java.org</em></p><p id="9d2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于上述电子邮件地址，您可能希望域名是一个字符串序列。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="39ff" class="jx jy hi jt b fi jz ka l kb kc">object ExpandedEMail {<br/>  def unapplySeq(email: String)<br/>  : Option[(String, Seq[String])] = {<br/>    val parts = email split "@"<br/>    if (parts.length == 2)<br/>      <em class="kd">Some</em>(parts(0), parts(1).split("\\.").reverse)<br/>    else<br/>      None<br/>  }</span></pre><p id="7c3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述方法将返回字符串形式的用户和字符串序列形式的域。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0134" class="jx jy hi jt b fi jz ka l kb kc">val <em class="kd">email1</em>="tom@java.example.org"<br/><em class="kd">println</em>(ExpandedEMail.<em class="kd">unapplySeq</em>(<em class="kd">email1</em>))</span><span id="f269" class="jx jy hi jt b fi ks ka l kb kc">Some((tom,WrappedArray(org, example, java)))</span></pre><p id="780a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">提取者对案件类别</strong></p><p id="a86f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管它们非常有用，但是它们有一个缺点，就是暴露了数据的具体表示。提取器打破了数据表示和模式之间的联系，模式与所选对象的数据类型无关。这种特性被称为表述独立性。</p></div></div>    
</body>
</html>