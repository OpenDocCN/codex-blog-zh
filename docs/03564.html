<html>
<head>
<title>The future of Java is to absorb Scala features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java的未来是吸收Scala的特性</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-future-of-java-is-to-absorb-scala-features-965ceaf7c8e4?source=collection_archive---------3-----------------------#2021-09-09">https://medium.com/codex/the-future-of-java-is-to-absorb-scala-features-965ceaf7c8e4?source=collection_archive---------3-----------------------#2021-09-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/65716d87c4271a2eacdd25bc08ac8d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vajdCyuqub4J4unn"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@lindsayhenwood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">林赛·亨伍德</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="ea32" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">距离Java 17的正式发布还有不到一周的时间，这是自Java 11以来的第一个Java长期支持(LTS)版本。2021年9月14日，Java 17运行时环境(JRE)和开发工具包(JDK)将提供下载和安装。</p><p id="f91c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">读完Java 17的特性，我更加确信Java的未来是慢慢地逐渐吸收Scala的特性。</p><p id="53da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">众所周知，Scala是Java虚拟机(JVM)的编程语言。Scala编译器将Scala源代码编译成JVM字节码，就像Java编译器一样。</p><p id="a8da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Scala是由Martin Odersky创建的，他在Java 1.3编译器方面走在了时代的前面。他希望Java编程语言采用泛型。最后，在Java 5中增加了泛型，它使我们能够使用具有类型灵活性的数据结构，同时保持强大的类型检查(带有警告)。</p><p id="c22a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，在Scala中，我们可能会写</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3705" class="kc kd hi jy b fi ke kf l kg kh">var transactions: List[Transaction] = List()</span></pre><p id="3c59" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而在Java中，我们可能会写</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2680" class="kc kd hi jy b fi ke kf l kg kh">List&lt;Transaction&gt; transactions = new ArrayList&lt;&gt;();</span></pre><p id="55a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这两种情况下，如果您无意中试图将错误类型的元素添加到这样的列表中，编译器以及集成开发环境(IDE )(如果您使用IDE)将会发出警告。</p><p id="e85f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">即使我们在运行时不能完全避免类型问题，编译时类型检查仍然是一个很大的帮助。</p><p id="e7b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Scala从一开始就有泛型。Odersky希望从Java 1.3开始Java就有泛型，但那必须等到Java 5。当然，Odersky明白Java编程语言的发展受到向后兼容性的限制，现在仍然如此。</p><p id="6af3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以有把握地预测，Java将会慢慢增加更多的Scala特性，因为它已经在增加Scala特性了。</p><p id="04bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看看一个相当小但却广为人知的特性:Java 10中添加了<code class="du ki kj kk jy b">var</code>。让Java以冗长著称的一点是类型声明的明显冗余。举个例子，</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="cf8e" class="kc kd hi jy b fi ke kf l kg kh">SomeReallyLongClassName obj = new SomeReallyLongClassName(param);</span></pre><p id="d711" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像IntelliJ IDEA这样的集成开发环境(IDE)中的自动完成确实有所帮助，但是，必须重复长的类标识符往往会使Java程序员给实例取非常短的名字，比如<code class="du ki kj kk jy b">obj</code>和<code class="du ki kj kk jy b">param</code>，或者更糟，单个字母。</p><p id="62af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了<code class="du ki kj kk jy b">var</code>，上面的例子变成了</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="dbec" class="kc kd hi jy b fi ke kf l kg kh">var obj = new SomeReallyLongClassName(param);</span></pre><p id="a4df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我看来，这没什么大不了的。更重要的是在Java 8中增加了lambdas和函数接口，这让Java更接近Scala的“函数是一等公民”的理念。</p><p id="9cdc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，假设在您的本地Scala REPL中，您有一个包含形式为<em class="kl"> n </em> + <em class="kl"> n </em> + 1的整数的<code class="du ki kj kk jy b">IndexedSeq[Int]</code>，例如3、7、13、21、31、43、57、73、91等。，为<code class="du ki kj kk jy b">res13</code>。</p><p id="ec5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你想知道哪一个是质数，你有一个布尔函数，<code class="du ki kj kk jy b">isPrime()</code>，就是为了这个目的而定义的。</p><p id="ea1f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后就是用<code class="du ki kj kk jy b">isPrime()</code>作为“谓词”(布尔函数的一个奇特的数学术语)进行过滤。实际上是自己写的:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="dc1a" class="kc kd hi jy b fi ke kf l kg kh">scala&gt; res13.filter(isPrime)<br/>res14: IndexedSeq[Int] = Vector(3, 7, 13, 31, 43, 73, 157, 211, 241, 307, 421, 463, 601, 757, 1123, 1483, 1723, 2551, 2971, 3307, 3541, 3907, 4423, 4831, 5113, 5701, 6007, 6163, 6481, 8011, 8191, 9901)</span></pre><p id="4f1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你没有一个本地的Scala REPL，你可以在一个Scastie片段中尝试一下，就像我<a class="ae iu" href="https://scastie.scala-lang.org/ffMCYaHjTZqjgGNyPaa68w" rel="noopener ugc nofollow" target="_blank">发布的</a>那样。</p><p id="f1a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">顺便说一下，Java 9的JDK增加了JShell，一个Java的本地REPL。在没有lambdas或函数接口的情况下，您可以在JShell中获得相同的结果，但是会非常笨拙。因为这些是在Java 8中添加的，所以它们在JShell中也是可用的。大概是这样的:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b997" class="kc kd hi jy b fi ke kf l kg kh">res13.stream().filter(new Predicate&lt;Integer&gt; {</span><span id="1776" class="kc kd hi jy b fi km kf l kg kh">    @Override<br/>    public boolean test(Integer v) {<br/>        return isPrime(v);<br/>    }</span><span id="a87e" class="kc kd hi jy b fi km kf l kg kh">});</span></pre><p id="248a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有一种更好的方法，但对我来说它没有Scala的<code class="du ki kj kk jy b">filter(predicate)</code>语法那么明显(非常感谢Julian，参见他9月17日的评论中的几个更好的选项)。</p><p id="6c0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">过滤的一个更普通的用途是将余额低于最小余额的账户列表放在一起。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="58aa" class="kc kd hi jy b fi ke kf l kg kh">val minBalAccounts = accounts.filter(_.balance &lt; MINIMUM_BALANCE)</span></pre><p id="014d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我把<code class="du ki kj kk jy b">_.balance</code>和<code class="du ki kj kk jy b">MINIMUM_BALANCE</code>想象成专门为金额设计的适当类型，而不是浮点数。我不认为Java会有操作符重载(除了<code class="du ki kj kk jy b">String</code>连接的特殊情况)，但是我可能错了。</p><p id="2576" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">无论如何，Java程序员可能更需要大量其他Scala特性，比如Switch-Case语句的更复杂的模式匹配。</p><p id="39b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您查看我之前链接的Scastie片段，您会看到我是如何定义<code class="du ki kj kk jy b">isPrime()</code>函数的:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="b828" class="kc kd hi jy b fi ke kf l kg kh">def isPrime(num: Int): Boolean = Math.abs(num) match {<br/>  case 0 =&gt; false<br/>  case 1 =&gt; false<br/>  case n =&gt; (2 to <br/>      Math.floor(Math.sqrt(n)).toInt) forall (p =&gt; n % p != 0)<br/>}</span></pre><p id="bc13" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Java中，你可以用一个Switch-Case来写，每个Case都有一个返回，这样你就不用担心Switch-Case因为忽略了Breaks而失败了。</p><p id="0a98" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以在Scala中编写更复杂的匹配用例语句，比如基于类型匹配的用例。举个例子，</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="53f1" class="kc kd hi jy b fi ke kf l kg kh">urlConn match {<br/>  case httpsConn: HttpsURLConnection =&gt; // TODO: Process HTTPS<br/>  case httpConn: HttpURLConnection =&gt; // TODO: Process HTTP<br/>}</span></pre><p id="9abd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你也可以把“警卫”放在箱子里。当然，你必须小心地从窄到宽安排你的案件。如果模式不太复杂，您的IDE可能会提醒您不可及的情况。</p><p id="6c46" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">据宣布，Java 17将为Switch-Case语句添加模式匹配，以及Scala中的Case guards。</p><p id="3295" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Java 17也有望添加密封的类和接口，它们与Scala中的密封类和特征相对应。我将不得不另找时间详细说明这一点。</p><p id="3a7f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">至于备受指责的分号，它们可能会留在Java中，因为添加分号推断可能比<code class="du ki kj kk jy b">var</code>之类的东西对向后兼容性的挑战更大。</p><p id="152c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我相信，只要我们继续使用电子计算机，Java就会继续被使用。与此同时，专家们将继续预测Java即将灭亡。</p><p id="0006" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也许Martin Odersky对JVM垃圾收集器的改进不太感兴趣(我知道我不感兴趣)，但是也许他关于Java编程语言应该如何发展的大多数想法都将会实现，在他第一次在Scala语言中提出这些想法之后很久。</p></div></div>    
</body>
</html>