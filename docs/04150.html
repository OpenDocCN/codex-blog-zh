<html>
<head>
<title>Delayed queue: a message queue with delay feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">延迟队列:具有延迟特性的消息队列</h1>
<blockquote>原文：<a href="https://medium.com/codex/delayed-queue-a-message-queue-with-delay-feature-268c8647c2fd?source=collection_archive---------1-----------------------#2021-10-31">https://medium.com/codex/delayed-queue-a-message-queue-with-delay-feature-268c8647c2fd?source=collection_archive---------1-----------------------#2021-10-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><ol class=""><li id="4c00" class="ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix bi translated">延迟→未来不确定的时间</li><li id="a9ef" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">mq →消费行为是顺序的</li></ol><p id="3e1b" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">有了这个解释，整个设计就清晰了。<strong class="ii hj">你的目的是延迟，而承运人集装箱是mq。</strong></p><h1 id="7b97" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">背景</h1><p id="6316" class="pw-post-body-paragraph jd je hi ii b ij kq jf jg il kr jh ji in ks jk jl ip kt jn jo ir ku jq jr it hb bi translated">列出我日常业务中可能存在的场景。</p><ol class=""><li id="61eb" class="ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix bi translated">创建一个延迟的时间表，需要提醒老师上课</li><li id="6d17" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">延迟推送→推送老师需要宣布和布置作业</li></ol><p id="ce86" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">要解决以上问题，最简单直接的方法就是定时扫描日程。</p><blockquote class="kv kw kx"><p id="ff40" class="jd je ky ii b ij ik jf jg il im jh ji kz jj jk jl la jm jn jo lb jp jq jr it hb bi translated"><em class="hi">服务启动时，打开一个异步并发进程→定时扫描msg表，到达时触发一个事件，调用相应的处理程序。</em></p></blockquote><p id="f487" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">几个缺点。</p><ol class=""><li id="7151" class="ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix bi translated">每个需要定时/延迟任务的服务都需要一个msg表，用于额外的存储→存储和业务耦合</li><li id="c967" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">定时扫描→时间不好控制，可能错过触发时间</li><li id="5070" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">这对msg表实例来说是一个负担。一个服务不断地对数据库产生持续的压力。</li></ol><p id="0d5e" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">最大的问题是什么？</p><p id="09a7" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated"><strong class="ii hj">调度模式基本统一，不做重复的业务逻辑</strong></p><p id="b90b" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">可以考虑把具体业务逻辑中的逻辑拿出来，变成一个通用的部分。</p><p id="81b6" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">而这个调度模型就是<strong class="ii hj">延迟队列</strong>。</p><p id="8ba6" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">其实说白了。</p><p id="9511" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated"><strong class="ii hj"> <em class="ky">延迟队列模型，是预先存储未来执行的事件，然后不断扫描这个存储，触发执行时间后再执行相应的任务逻辑。</em>T15】</strong></p><p id="0b47" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">那么开源社区有现成的解决方案吗？答案是肯定的。青苗(<a class="ae lc" href="https://github.com/beanstalkd/beanstalkd" rel="noopener ugc nofollow" target="_blank"><strong class="ii hj">)https://github.com/beanstalkd/beanstalkd</strong></a>)基本符合上述要求</p><h1 id="0a44" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">设计目标</h1><ol class=""><li id="a1b3" class="ig ih hi ii b ij kq il kr in ld ip le ir lf it iu iv iw ix bi translated">至少消费行为</li><li id="bb30" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">高可用性</li><li id="06a2" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">实时的</li><li id="4e8c" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">支持消息删除</li></ol><p id="2cad" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">针对这些目的的设计方向一次陈述一个。</p><h1 id="7d5c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">消费行为</h1><p id="7419" class="pw-post-body-paragraph jd je hi ii b ij kq jf jg il kr jh ji in ks jk jl ip kt jn jo ir ku jq jr it hb bi translated">这个概念取自mq。mq中为消费者造型提供了几个方向。</p><ul class=""><li id="1502" class="ig ih hi ii b ij ik il im in io ip iq ir is it lg iv iw ix bi translated"><code class="du lh li lj lk b">at most once</code> →消息最多可以被丢弃一次，但不能重复</li><li id="5f00" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it lg iv iw ix bi translated"><code class="du lh li lj lk b">at least once</code> →至少一次，消息肯定不会丢失，但可能会重复</li><li id="df41" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it lg iv iw ix bi translated"><code class="du lh li lj lk b">exactly once</code> →是且仅一次，消息不会丢失或重复，且仅消费一次。</li></ul><p id="9318" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated"><code class="du lh li lj lk b">exactly once</code>如果可能的话，在生产者和消费者两方面都有保证。当生产者得不到保证时，那么消费者需要在消费前做一次去重，实现一次消费，不重复消费，直接在延迟队列内部得到保证。</p><p id="65a7" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">最简单:<strong class="ii hj">使用redis setNX实现作业id的唯一消费</strong></p><h1 id="488f" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">高可用性</h1><p id="70f7" class="pw-post-body-paragraph jd je hi ii b ij kq jf jg il kr jh ji in ks jk jl ip kt jn jo ir ku jq jr it hb bi translated">支持多实例部署。当一个实例关闭时，有一个备份实例继续提供服务。</p><p id="7bb1" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">这个外部可用的API使用一个集群模型，该模型在内部封装了多个节点，并在多个节点之间提供冗余存储。</p><h1 id="8b13" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">为什么不是卡夫卡？</h1><p id="5c20" class="pw-post-body-paragraph jd je hi ii b ij kq jf jg il kr jh ji in ks jk jl ip kt jn jo ir ku jq jr it hb bi translated">考虑过类似的基于消息队列的解决方案，如kafka/rocketmq作为存储，但最终放弃了存储设计模型中的此类选项。</p><p id="da3e" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">例如，假设像Kafka这样的消息队列存储用于实现延迟功能，每个队列时间需要创建一个单独的主题(例如，Q1–1s，Q1–2s…)。这种设计在延迟时间固定的场景下问题不大，但如果延迟时间变化较大，就会导致话题过多，使磁盘从顺序读/写变成随机读/写并导致性能下降，还会带来重启或恢复时间长等其他问题。</p><ol class=""><li id="ef3b" class="ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix bi translated">话题太多→存储压力</li><li id="0608" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">主题是实时存储的，当调度不同时间的读取时(主题)，顺序读取→随机读取。3.</li><li id="50fb" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">同样，写入时，顺序写入→随机写入</li></ol><h1 id="4963" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">建筑设计</h1><figure class="lm ln lo lp fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es ll"><img src="../Images/db9c7fc347d9cc8b65898f8b8dae8579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OH0sCF6OioXkTz5T"/></div></div></figure><h1 id="6e1c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">API设计</h1><p id="4848" class="pw-post-body-paragraph jd je hi ii b ij kq jf jg il kr jh ji in ks jk jl ip kt jn jo ir ku jq jr it hb bi translated">生产者</p><ol class=""><li id="1ac4" class="ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix bi translated"><code class="du lh li lj lk b">producer.At(msg []byte, at time.Time)</code></li><li id="676e" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated"><code class="du lh li lj lk b">producer.Delay(body []byte, delay time.Duration)</code></li><li id="6d6d" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated"><code class="du lh li lj lk b">producer.Revoke(ids string)</code></li></ol><p id="9a9b" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">消费者</p><ol class=""><li id="00e5" class="ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix bi translated"><code class="du lh li lj lk b">consumer.Consume(consume handler)</code></li></ol><p id="6523" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">使用延迟时间队列，服务的总体结构如下，以及队列中作业的状态变化。</p><figure class="lm ln lo lp fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lx"><img src="../Images/704ada616a02258cdf839a3b7a5e8ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d2IS844Wpe2YqDhR"/></div></div></figure><ol class=""><li id="34e9" class="ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix bi translated">服务→ <code class="du lh li lj lk b">producer.At(msg []byte, at time.Time)</code> →将延迟的工作插入试管</li><li id="95c6" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">定时触发→作业状态更新为就绪</li><li id="87c4" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">消费者准备好作业→获取作业并开始消费；并将状态更改为保留</li><li id="236c" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">执行传递给使用者的处理程序逻辑函数</li></ol><h1 id="5473" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">生产实践</h1><p id="da4b" class="pw-post-body-paragraph jd je hi ii b ij kq jf jg il kr jh ji in ks jk jl ip kt jn jo ir ku jq jr it hb bi translated">我们将主要介绍我们在日常开发中对于延迟队列使用了哪些具体的函数。</p><h1 id="773b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">生产侧</h1><ol class=""><li id="4c45" class="ig ih hi ii b ij kq il kr in ld ip le ir lf it iu iv iw ix bi translated">生产开发中的一个延迟任务，<strong class="ii hj">只是为了确定任务的执行时间</strong> 1。</li></ol><ul class=""><li id="91b3" class="ig ih hi ii b ij ik il im in io ip iq ir is it lg iv iw ix bi translated">在()<code class="du lh li lj lk b">producer.At(msg []byte, at time.Time)</code>传入</li><li id="b415" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it lg iv iw ix bi translated">在内部，它将自己计算时间差值并插入试管</li></ul><ol class=""><li id="6c3d" class="ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix bi translated"><strong class="ii hj">如果修改了任务时间，修改了任务内容</strong></li></ol><ul class=""><li id="594f" class="ig ih hi ii b ij ik il im in io ip iq ir is it lg iv iw ix bi translated">您可能需要在生产时创建一个附加的logic_id → job_id关系表</li><li id="1fc5" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it lg iv iw ix bi translated">查询到job_id → <code class="du lh li lj lk b">producer.Revoke(ids string)</code>,将其删除，然后重新插入</li></ul><h1 id="5e48" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">消费端</h1><p id="7509" class="pw-post-body-paragraph jd je hi ii b ij kq jf jg il kr jh ji in ks jk jl ip kt jn jo ir ku jq jr it hb bi translated">首先，框架层保证消费行为<code class="du lh li lj lk b">exactly once</code>，但是上层业务逻辑消费失败或者网络问题，或者各种问题，导致消费失败，底层交给业务开发来做。这样做的原因。</p><ol class=""><li id="ea9c" class="ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix bi translated">框架和底层组件只保证工作状态流的正确性</li><li id="1c49" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">消费者一方的框架只能保证消费行为的一致性</li><li id="0b1f" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">延迟任务在不同的业务行为中是不统一的</li></ol><ul class=""><li id="f6dc" class="ig ih hi ii b ij ik il im in io ip iq ir is it lg iv iw ix bi translated">对任务的强调必须达到，那么失败的消耗需要不断的重试，直到任务成功</li><li id="9a0f" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it lg iv iw ix bi translated">强调任务的准时性，失败的消耗，商业的不敏感，那么你可以选择丢弃</li></ul><p id="3c82" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">这里描述的是框架的消费者一方如何确保消费行为的一致性。</p><p id="c63d" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">分为集群和节点。</p><p id="eabc" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated"><strong class="ii hj">集群:</strong></p><blockquote class="kv kw kx"><p id="67d0" class="jd je ky ii b ij ik jf jg il im jh ji kz jj jk jl la jm jn jo lb jp jq jr it hb bi translated"><a class="ae lc" href="https://github.com/zeromicro/go-queue/blob/master/dq/consumer.go#L45" rel="noopener ugc nofollow" target="_blank"><strong class="ii hj"><em class="hi">https://github . com/zero micro/go-queue/blob/master/dq/consumer . go # L45</em></strong></a></p></blockquote><ol class=""><li id="4335" class="ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix bi translated">集群内部将消费处理程序包装在另一层中。2.</li><li id="9b49" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated"><strong class="ii hj">对消费主体进行哈希处理，并将此哈希用作redis重复数据删除的密钥</strong>。3.</li><li id="0a5e" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">如果存在，则不进行处理并被丢弃</li></ol><p id="54ed" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated"><strong class="ii hj">节点:</strong></p><blockquote class="kv kw kx"><p id="658e" class="jd je ky ii b ij ik jf jg il im jh ji kz jj jk jl la jm jn jo lb jp jq jr it hb bi translated"><a class="ae lc" href="https://github.com/zeromicro/go-queue/blob/master/dq/consumernode.go#L36" rel="noopener ugc nofollow" target="_blank"><strong class="ii hj"><em class="hi">https://github . com/zero micro/go-queue/blob/master/dq/consumer node . go # L36</em></strong></a></p></blockquote><ol class=""><li id="a5ff" class="ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix bi translated">消费者节点准备工作；首先执行保留(TTR)，预订该作业，将执行该作业进行逻辑处理</li><li id="15b1" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated">在节点中删除(作业);然后消费</li><li id="d469" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it iu iv iw ix bi translated"><strong class="ii hj">如果失败，将被扔给业务层做相应的口袋重试</strong></li></ol><p id="63f3" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">所以对于消费端，开发者需要自己实现消费的幂等性。</p><figure class="lm ln lo lp fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es ly"><img src="../Images/b73aee5242f0f6318a2cfc07bf905150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hX71xSbfJrL_tjCa"/></div></div></figure><h1 id="77f3" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">项目地址</h1><p id="50c3" class="pw-post-body-paragraph jd je hi ii b ij kq jf jg il kr jh ji in ks jk jl ip kt jn jo ir ku jq jr it hb bi translated"><code class="du lh li lj lk b">go-queue</code>由<code class="du lh li lj lk b">go-zero</code>提供动力，性能卓越。</p><ul class=""><li id="0572" class="ig ih hi ii b ij ik il im in io ip iq ir is it lg iv iw ix bi translated">归零:<a class="ae lc" href="https://github.com/zeromicro/go-zero" rel="noopener ugc nofollow" target="_blank"><strong class="ii hj">https://github.com/zeromicro/go-zero</strong></a></li><li id="5d59" class="ig ih hi ii b ij iy il iz in ja ip jb ir jc it lg iv iw ix bi translated">排队:<a class="ae lc" href="https://github.com/zeromicro/go-queue" rel="noopener ugc nofollow" target="_blank"><strong class="ii hj">https://github.com/zeromicro/go-queue</strong></a></li></ul><p id="aab9" class="pw-post-body-paragraph jd je hi ii b ij ik jf jg il im jh ji in jj jk jl ip jm jn jo ir jp jq jr it hb bi translated">欢迎使用<strong class="ii hj">和</strong>星来支持我们！</p></div></div>    
</body>
</html>