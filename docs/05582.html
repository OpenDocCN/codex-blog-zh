<html>
<head>
<title>GraalVM-Native Images &amp; Microframeworks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraalVM-本机映像和微框架</h1>
<blockquote>原文：<a href="https://medium.com/codex/graalvm-native-images-microframeworks-9b3fab2e8f17?source=collection_archive---------3-----------------------#2022-03-13">https://medium.com/codex/graalvm-native-images-microframeworks-9b3fab2e8f17?source=collection_archive---------3-----------------------#2022-03-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2a55fe6ccab4b651f836d95aab610a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q7w2gCEdnS9Sm8VwO2pi6g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像致谢—Emumba</figcaption></figure><p id="cd5a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在本文中，我们将讨论GraalVM、本机映像和微框架，我们为什么需要它们，潜在的用例是什么，以及它们如何帮助我们踏上应用程序现代化之旅。</p><p id="670e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当我们回顾IT(信息技术)架构演进周期时，我们从大型机开始我们的旅程，逐渐开始向monolith移动，随后采用微服务来克服各自架构在非功能性需求方面的限制，并最终导致松散耦合的架构。</p><p id="5067" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">随着无服务器平台最近的发展，非常需要分析我们现有的基于微服务的工作负载，以采用无服务器架构。这就是GraalVM和本机映像的亮点，它具有快速启动时间和低内存占用。</p><h1 id="2bd6" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">传统架构的挑战<a class="ae kq" href="https://github.optum.com/pages/csharm33/oi-payer-engineering/blog/graalvm#challenges-with-legacy-architecture" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="5c27" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">众所周知，monolith应用程序是一个紧密耦合的系统，将相关模块打包成一个可部署的可执行文件。这些系统开始随着时间的推移而增长，以满足业务需求。在某种程度上，当我们开始添加新的特性时，一个单一的应用程序开始遇到各种问题，比如大规模负载场景下的可伸缩性、延迟、容错、异步处理等。</p><p id="2474" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了应对这些挑战，我们开始用微服务取代单片，使系统松散耦合，但这增加了收益的复杂性。</p><p id="0283" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">随着我们从微服务转向无服务器，代码块变得更小更简单，降低了成本，而总的复杂性却在增加。</p><p id="a678" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下图描述了这种情况…</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/7db4e64dfed58a11128fd4c7f5e21c97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ljgt67RdkR7tFCPICwtJgw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像来源—freeCodeCamp.com</figcaption></figure><h1 id="f795" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">3要素架构&amp;无服务器功能<a class="ae kq" href="https://github.optum.com/pages/csharm33/oi-payer-engineering/blog/graalvm#3factor-architecture--serverless-functions" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="2f5b" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">3factor app是一种基于无服务器架构创建现代应用的架构模式。</p><p id="cc6c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这种模式使我们能够通过使用“功能即服务”以及云的力量来构建健壮且可扩展的应用程序。“功能即服务”是GraalVM表现出色的地方。</p><p id="d3c4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下图描述了这种情况…</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/a0455e416f605eda13606b6fb015db15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UzgC9KYc72NgCVgsKE7c7w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片致谢3factor.app</figcaption></figure><h1 id="d58e" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">GraalVM概述<a class="ae kq" href="https://github.optum.com/pages/csharm33/oi-payer-engineering/blog/graalvm#graalvm-overview" rel="noopener ugc nofollow" target="_blank">T5】</a></h1><p id="abb2" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">让我们对GraalVM做一个高层次的概述…</p><blockquote class="lc ld le"><p id="0d23" class="iu iv lf iw b ix iy iz ja jb jc jd je lg jg jh ji lh jk jl jm li jo jp jq jr hb bi translated">GraalVM是一个高性能的JDK (Java开发工具包)发行版，旨在加速用Java和其他JVM (Java虚拟机)语言编写的应用程序的执行，并支持JavaScript、Ruby、Python和其他几种流行的语言。—graalvm.org</p></blockquote><h2 id="793b" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">GraalVM的主要特性:</h2><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/5775f125bb29d659b670d4dca666cf2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHLKMJXusgvAbB_CYDKSQg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像来源—graalvm.org</figcaption></figure><h1 id="d132" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">热点虚拟机vs GraalVM <a class="ae kq" href="https://github.optum.com/pages/csharm33/oi-payer-engineering/blog/graalvm#hotspot-vm-vs-graalvm" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="e778" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">由于GraalVM是一个高性能的JDK (Java开发工具包)发行版，让我们快速比较一下Hotspot VM和GraalVM。</p><p id="7931" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">GraalVM编译器建立在JVMCI之上，提供了更好的JIT(即时)编译器实现，并做了进一步的优化。它还提供了一个AOT(提前)选项，在这里我们可以直接创建一个独立的机器代码。</p><p id="0b2f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在下图中，我们可以看到编译器接口已经被JVM编译器接口取代，C2编译器被GraalVM编译器取代。两者都是用Java编写的，并且在现有的Hotspot VM上提供了更好的优化。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/5edf502647afc4af8a26f8042f8a23f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*fBNIt1_OnTwGT_19mylI6A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像来源—graalvm.org</figcaption></figure><h1 id="4c82" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">JIT vs AOT<a class="ae kq" href="https://github.optum.com/pages/csharm33/oi-payer-engineering/blog/graalvm#jit-vs-aot" rel="noopener ugc nofollow" target="_blank">T3】</a></h1><p id="cb92" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">让我们来理解JIT(及时)和AOT(提前)编译方法以及本机映像的概念。</p><p id="2a46" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您熟悉java生态系统，您可以将JIT(及时)与传统的Java编译过程联系起来。Java代码首先被编译成字节码，然后被JVM (Java虚拟机)解释器处理，进行机器代码转换。C1和C2基于剖析算法进一步优化了代码。</p><p id="21d2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">AOT(提前)是将这些工作负载编译成本机映像的过程。我们通过AOT获得了更快的启动时间和更低的内存占用，但却失去了便携性。</p><p id="e627" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过在GraalVM上使用JIT运行现有的工作负载，可以获得更好的性能。此外，为了获得GraalVM的好处(更快的启动时间和更低的内存占用量)，可以将本机映像与更适合无服务器用例的AOT编译结合使用。</p><p id="a2f4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于无服务器部署——采用AOT更有意义，而对于长期运行的基于容器/基于虚拟机的部署，JIT可能更有意义。</p><p id="4508" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下图描述了比较…</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/dfeeb2f8b02d9f0ddfd42a2bf3cbfe7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*Se5DCpja8j02IUaysMOXqQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像来源—graalvm.org</figcaption></figure><h1 id="7113" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">GraalVM架构<a class="ae kq" href="https://github.optum.com/pages/csharm33/oi-payer-engineering/blog/graalvm#graalvm-architecture" rel="noopener ugc nofollow" target="_blank">T5】</a></h1><blockquote class="lc ld le"><p id="58bf" class="iu iv lf iw b ix iy iz ja jb jc jd je lg jg jh ji lh jk jl jm li jo jp jq jr hb bi translated">GraalVM向HotSpot Java虚拟机添加了一个用Java编写的高级实时(JIT)优化编译器。</p><p id="a8f2" class="iu iv lf iw b ix iy iz ja jb jc jd je lg jg jh ji lh jk jl jm li jo jp jq jr hb bi translated">除了运行基于Java和JVM的语言，GraalVM的语言实现框架(Truffle)使得在JVM上运行JavaScript、Ruby、Python和其他几种流行的语言成为可能。有了GraalVM Truffle，Java和其他支持的语言可以直接互操作，在同一个内存空间来回传递数据。—graalvm.org</p></blockquote><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/b17aefb28f7f8d7d101846cf50932cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6wfOLh8UWJCuS8Gi5lThYA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像来源—graalvm.org</figcaption></figure><h1 id="15b1" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">GraalVM性能图<a class="ae kq" href="https://github.optum.com/pages/csharm33/oi-payer-engineering/blog/graalvm#graalvm-performance-graph" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="5d6d" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">与Hotspot VM模式相比，使用GraalVM本机映像的各种微框架的内存占用量降低了约5倍，启动时间加快了约50倍。</p><p id="684d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Helidon、Micronaut和Quarkus是微框架，我们将在下一节讨论它们。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/8141f53f16dd0be7bf6de1abd559acda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*sLpTZHQGpbGt2N3ERfgb2A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像来源—graalvm.org</figcaption></figure><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/d3e040a105d61154bf401783d2508cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*kCWA0kXRzNxRYyp5yvrneg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像来源—graalvm.org</figcaption></figure><h1 id="903d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">GraalVM <a class="ae kq" href="https://github.optum.com/pages/csharm33/oi-payer-engineering/blog/graalvm#pros--cons-of-graalvm" rel="noopener ugc nofollow" target="_blank">的利弊</a></h1><h2 id="6f74" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">优点:<a class="ae kq" href="https://github.optum.com/pages/csharm33/oi-payer-engineering/blog/graalvm#pros" rel="noopener ugc nofollow" target="_blank"> </a></h2><ul class=""><li id="080d" class="md me hi iw b ix kr jb ks jf mf jj mg jn mh jr mi mj mk ml bi translated">更快启动</li><li id="32b5" class="md me hi iw b ix mm jb mn jf mo jj mp jn mq jr mi mj mk ml bi translated">更低的内存占用</li><li id="f1a2" class="md me hi iw b ix mm jb mn jf mo jj mp jn mq jr mi mj mk ml bi translated">原生图像</li><li id="9a7e" class="md me hi iw b ix mm jb mn jf mo jj mp jn mq jr mi mj mk ml bi translated">高性能</li><li id="067c" class="md me hi iw b ix mm jb mn jf mo jj mp jn mq jr mi mj mk ml bi translated">语言互操作性和多语言工具</li></ul><h2 id="e9e3" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">缺点:<a class="ae kq" href="https://github.optum.com/pages/csharm33/oi-payer-engineering/blog/graalvm#cons" rel="noopener ugc nofollow" target="_blank"> </a></h2><ul class=""><li id="a051" class="md me hi iw b ix kr jb ks jf mf jj mg jn mh jr mi mj mk ml bi translated">没有JVMTI、Java代理、JMX或JFR支持</li><li id="feb2" class="md me hi iw b ix mm jb mn jf mo jj mp jn mq jr mi mj mk ml bi translated">仅对较小的堆有效</li><li id="a230" class="md me hi iw b ix mm jb mn jf mo jj mp jn mq jr mi mj mk ml bi translated">生成的本机代码并不完全有效</li><li id="8a29" class="md me hi iw b ix mm jb mn jf mo jj mp jn mq jr mi mj mk ml bi translated">不支持线程转储和堆转储</li><li id="4729" class="md me hi iw b ix mm jb mn jf mo jj mp jn mq jr mi mj mk ml bi translated">无动态类加载/卸载</li></ul><h1 id="7b61" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">GraalVM的微框架<a class="ae kq" href="https://github.optum.com/pages/csharm33/oi-payer-engineering/blog/graalvm#microframeworks-for-graalvm" rel="noopener ugc nofollow" target="_blank"> </a></h1><blockquote class="lc ld le"><p id="0f53" class="iu iv lf iw b ix iy iz ja jb jc jd je lg jg jh ji lh jk jl jm li jo jp jq jr hb bi translated">微框架是一个用来指极简web应用程序框架的术语。它与全栈框架形成对比。wikipedia.org</p></blockquote><p id="be40" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Helidon、Micronaut、Quarkus、Javalin和Spring Native是GraalVM生态系统中最著名的微框架。</p><p id="2809" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">借助GraalVM的AOT特性，我们可以用这些微框架创建本机映像，并获得性能提升。</p><p id="2e54" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所有这些框架都有容器支持，可以部署在无服务器平台上，如Knative或AWS Lambda。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/4a7ab4a67812aa4c08e4b3821eb7644e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4QL830eSy1gU7JreQKnX4A.png"/></div></div></figure><h1 id="5031" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">微服务框架对比<a class="ae kq" href="https://github.optum.com/pages/csharm33/oi-payer-engineering/blog/graalvm#microservices-frameworks-comparison" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="02f2" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">这是最后一节讲微服务框架之间的比较。</p><p id="8296" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们开始之前，让我们快速地讨论一下微概要文件。</p><blockquote class="lc ld le"><p id="383a" class="iu iv lf iw b ix iy iz ja jb jc jd je lg jg jh ji lh jk jl jm li jo jp jq jr hb bi translated">MicroProfile是一个社区驱动的规范，旨在提供一个基线平台定义，该定义优化了微服务架构的企业Java，并提供了跨多个MicroProfile运行时(包括Open Liberty)的应用程序可移植性。— microprofile.io</p></blockquote><p id="054f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">像spring boot这样的全栈框架在外部依赖性和集成方面提供了很大的灵活性，但与其他框架相比，它显得过于沉重。</p><p id="2105" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">基于微文件的框架在整个堆栈上提供了特别好的优化，重量更轻，并且符合微文件规范。该框架为微服务架构优化了企业Java。</p><p id="028b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">微框架是轻量级的，具有更快的启动时间，更低的内存占用，非常适合无服务器架构用例(作为服务的功能)。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/825b407e84eb64530813887374fcf88c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oYtqqT8Yz8JRNpTqt2c54w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图像来源—infoq.com</figcaption></figure><h1 id="3294" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论<a class="ae kq" href="https://github.optum.com/pages/csharm33/oi-payer-engineering/blog/graalvm#conclusion" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="3232" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">随着IT(信息技术)架构的发展，代码块变得越来越精简和简单，松散耦合系统的采用正在赶上，但整体复杂性正在增加。为了满足日益增长的复杂性需求并降低总体成本，采用事件驱动架构并发现无服务器架构的潜在用例有着巨大的机会。</p><p id="0b5c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">借助GraalVM和本机映像，我们可以进一步优化我们的无服务器工作负载，并获得更快的启动时间和更低的内存占用的优势，最终实现有效的成本优化。</p><p id="641d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在是时候重新评估我们半现代化的工作负载，找到潜在的用例，并开始采用基于微配置文件的框架和使用GraalVM的微框架。</p><p id="cfd6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一定要让我知道你对GraalVM的想法…</p><p id="2a9d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>