<html>
<head>
<title>Modern JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript</h1>
<blockquote>原文：<a href="https://medium.com/codex/modern-javascript-e78bfae8bea5?source=collection_archive---------19-----------------------#2022-07-05">https://medium.com/codex/modern-javascript-e78bfae8bea5?source=collection_archive---------19-----------------------#2022-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="220a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jd translated">假设一个变量隐藏在它定义的边界之外。在这种情况下，k变量的范围仅限于循环的。访问变量k会导致如下所示的错误。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jm"><img src="../Images/5285e6e0fc3be7c99bd506cf64f85ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j_rYSxaR9gFgSbsb"/></div></div></figure><p id="8d69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们在这种情况下使用var，它将正确地打印，没有任何错误，但是，var的范围使得很难在长代码中看到错误。字母确保在{}代码内部产生效果。</p><p id="8f46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果用const代替var，那么在for循环中声明变量也会出现同样的问题。当在循环外使用const时，为了避免错误，我们必须在声明行中初始化const变量。</p><p id="edfc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为const被初始化了两次，一次在第1行，另一次在第3行，所以下面的代码会产生一个错误。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jy"><img src="../Images/0c701ffe0b86eac6ceac6e62102a6664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZGxN3qa7ou2FTuQK"/></div></div></figure><p id="3d18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于范围影响从第1行到第8行的整个代码，所以在循环外使用allow不会导致错误。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jz"><img src="../Images/fbb296659cf4d4ce40dac693d518dc80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cy92mS-4vxuCWl88"/></div></div></figure><p id="c37d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Const只为不是对象或数组的变量提供保护。</strong></p><p id="48e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在下面看到的，在一个常量变量被赋值后，我们不能给它一个新的值。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es ka"><img src="../Images/eb54f66ffab238c556306679fef4f74d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*whor8rEUFNiJjK65"/></div></div></figure><p id="6774" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们可以使用一个常量数组并添加2个或更多的值。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jz"><img src="../Images/f687f207811509f3a85d8c08553117cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tz1id-jSad_PcURT"/></div></div></figure><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jz"><img src="../Images/6f44627319720d0c7ca327b33d152ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VdELZunJ9yL2qWeF"/></div></div></figure><p id="3102" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不管是对象还是数组。它可以增加或修改常量变量的值。</p><p id="a2eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">JavaScript中的箭头函数</strong></p><p id="f06e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用箭头，我们可以使函数更简单。如果我们传递两个参数，那么括号是必需的；如果我们只是传递一个参数，那么就不需要括号。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kb"><img src="../Images/de436b4ddb9a85a3355521bcd351fb6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zUJYsa89B2jG_Wvv"/></div></div></figure><p id="5976" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果编写了调用函数，那么正则函数中的这个关键字表示调用函数。但是，如果我们使用的是箭头函数，这个术语并不表示调用者。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jz"><img src="../Images/906cc5c860414bcb3337f5714eaadd26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PTXMQGzR6ZYvzfQ4"/></div></div></figure><p id="3a09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">提示-:这不代表呼叫者。</p><p id="78fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对象处理</strong></p><p id="bf6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们在执行的时候不确定这个键，由于动态属性，我们可以使用一个占位符作为键。</p><p id="58cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Key有时候挺活泼的。当我们通过服务传输一个项目时，我们不确定密钥是什么。服务提供的任何内容都可以分配给占位符，如下所示。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kc"><img src="../Images/f5897254d6e8c7df4ce3e087b38a8bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BDplJ8ECXQbcL_Jo"/></div></div></figure><p id="1f8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，第1行已经有一个值，因此SQRT2不需要值。启用动态属性时，会出现一条错误消息。</p><p id="02a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们在执行时不确定值，我们可以使用一个占位符作为键，如下所示。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kd"><img src="../Images/0714dd6f93324d7d8849569589d9be44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v4Fh1WVcLZ8qoh4c"/></div></div></figure><p id="0d2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">冻结物体</strong></p><p id="b0c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以很容易地给一个对象重新赋值，如下所示。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es ke"><img src="../Images/0d774e43be20a8617f08d8866660769b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aPM6Z2iJx6ydRs9Q"/></div></div></figure><p id="9575" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果我们使用freeze方法，第二个对象的值不会改变，因为在冻结后，该对象保留其原始值。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kf"><img src="../Images/e2349d1aecc755c9a5e9a54eeae53dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NEJbs-7qbqhQodvH"/></div></div></figure><p id="281f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该项目将因此冻结，使其不可更改。</p><p id="26c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果希望对象从一个服务移动到另一个服务或从一个函数移动到另一个函数，但不想修改其值，请使用freeze方法。</p><p id="68ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此冻结仅影响一级值；它对内部级别的对象没有影响。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kg"><img src="../Images/0ced4ea0bd2402b63e2e3aa0f1aaf087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M2h6SxDOdFvNTFv_"/></div></div></figure><p id="33fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Name是一级变量，而t1和t2是二级变量，如你所见。只有一级变量，比如名字，会被冻结。因此，该名称没有被更改。T1改变，因为冻结方法在那里没有影响。</p><p id="b945" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">模板</strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es ke"><img src="../Images/ba558bfc6a704ebf3949e2ddaf1784ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WJjGaGK-p_qVFy2J"/></div></div></figure><p id="90d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">超驰功能</strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es ke"><img src="../Images/9c4738832ead7cba36661855cad69368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UEtqqXCZnKpRr9QJ"/></div></div></figure><p id="c564" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当通过对象调用函数时，我们可以用任何东西覆盖它。类可能有函数，但在运行时，我们可能会选择在覆盖函数中覆盖它们，例如。</p><p id="609c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">自毁</strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kg"><img src="../Images/9f69d1208fdaa3f50d83fa335d7adca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nn34Pp2jp7Ev-CS_"/></div></div></figure><p id="d9d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不用在这里演示，我们可以像在数学课上学到的那样写PI和SQRT2。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kd"><img src="../Images/f01e3243d1d7a3942e5fb2a39f98118e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NaG9u83Z2rO6WHJO"/></div></div></figure><p id="9a9a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算面积时，我们只需要一个基础；不需要额外的变量。我们传递对象的同时提供参数，但是它计算面积没有任何问题。</p><p id="77ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所看到的，当执行这个操作时，创建了两个文本文件。在这里，我们可以选择忽略fs，在使用destruct时只写它。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kh"><img src="../Images/8fbe6d9cd5c6a5358a5f37cb7e3e8fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NAMBTaUutSfi5aaL"/></div></div></figure><p id="e767" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">承诺</strong></p><p id="bda7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Http GET偶尔会连接到服务器并请求响应，代码必须包装在承诺中，如下所示。这将触发承诺，当它完成时，如果它被包裹在一个承诺。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es ke"><img src="../Images/98035fd1609231d32ec071bd5d855e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AGRJNJ09IMmex_fP"/></div></div></figure><p id="89f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果使用below函数代替catch finally块，这将导致undefined。这包含在promise对象中，但是我们首先声明长度。通常，在这种情况下，我们不会等待结果。这并不等待诺言的实现。</p><p id="eddf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将返回一个promise对象，并等待直到通过使用fetch web页面解析该承诺。一旦承诺兑现，它就转移到下一个。如果await关键字被删除，它将变成未定义的。</p><p id="1a36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">术语“await”只在异步函数中有效。删除async关键字会使await无效。</p></div></div>    
</body>
</html>