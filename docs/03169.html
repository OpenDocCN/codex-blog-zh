<html>
<head>
<title>Hypertable Management System (HTMS) for tabular network databases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">表格网络数据库的超级表格管理系统(HTMS)</h1>
<blockquote>原文：<a href="https://medium.com/codex/hypertable-management-system-htms-for-tabular-network-databases-1e9ef617f0ad?source=collection_archive---------27-----------------------#2021-08-20">https://medium.com/codex/hypertable-management-system-htms-for-tabular-network-databases-1e9ef617f0ad?source=collection_archive---------27-----------------------#2021-08-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0dd1" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">超表格或表格网络数据库——关系数据库和网络数据库概念与Python中面向对象编程的交叉点上的新方法</h2></div><p id="ce85" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">【这是<em class="jt">表格网络数据模型</em>系列的第4部分。点击查看所有帖子的链接<a class="ae ju" rel="noopener" href="/@azur06400/tabular-network-data-model-series-f7b8469ed333">。为了清楚起见，代码示例将在Python/Django生态系统的框架内提供。要理解这些例子，需要Python和Django的知识，或者至少是面向对象编程(OOP)的基础知识。]</a></p><p id="7be3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了更具体地理解表格网络数据模型及其与关系模型的区别，让我们看一个例子。其结构如下:</p><ol class=""><li id="2383" class="jv jw hi iz b ja jb jd je jg jx jk jy jo jz js ka kb kc kd bi translated">根据众所周知的用Python创建网站的教育和方法解决方案，制定了“民意测验”数据库的概念模型:template⁶.微软Visual Studio Django网络项目</li><li id="8d6a" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js ka kb kc kd bi translated">Django ORM⁷.公司的API在关系数据库(RDB)的逻辑级别上对数据库“轮询”概念模型的常规实现由于使用ORM来形式化原始操作(创建、读取、更新和删除<strong class="iz hj"> ) </strong>以及数据检索和过滤操作的技术是众所周知的，因此在示例中省略了这一点。</li><li id="f0b8" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js ka kb kc kd bi translated">HTMS API在表格式网络数据库(TNDB)的逻辑层实现了数据库“轮询”的概念模型。为了便于理解，偶尔会省略一些类属性和方法参数，因为它们并不扮演基本的角色。感兴趣的读者可以参考上传到我在<code class="du kj kk kl km b">github.com</code> ⁴ ⁵.的知识库上的HTMS API的完整程序代码和文档</li><li id="9352" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js ka kb kc kd bi translated">比较</li></ol><h2 id="a8f4" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">概念模型:数据库轮询的一个例子</h2><p id="89c3" class="pw-post-body-paragraph ix iy hi iz b ja li ij jc jd lj im jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">实体(关系)见图1</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ln"><img src="../Images/fb355ba8d47931c5586cc47d6ddb7378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tFXykCh_ulpjQQOwVNNHqg.jpeg"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx translated">图1:数据库轮询概念模型的表格</figcaption></figure><p id="1dac" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">依赖性和约定:</p><ol class=""><li id="2123" class="jv jw hi iz b ja jb jd je jg jx jk jy jo jz js ka kb kc kd bi translated">每个投票(<em class="jt">投票</em>表中的一行)有两个或多个答案，即<em class="jt">答案</em>表中的行。</li><li id="d408" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js ka kb kc kd bi translated">每个答案(<em class="jt">答案</em>表中的一行)对应零个或多个评论，即<em class="jt">评论</em>表中的行。</li><li id="8fdf" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js ka kb kc kd bi translated">如果站点访问者第一次投票，将在<em class="jt">访问者</em>表中为该访问者创建一个新行。</li><li id="1a41" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js ka kb kc kd bi translated">用户通过他们的IP地址来识别。</li><li id="cfa4" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js ka kb kc kd bi translated">每次投票后，投票中所选答案的投票数增加1。</li><li id="bf27" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js ka kb kc kd bi translated">网站应该记住每个访问者给出的答案和他们的评论。每个用户注释都保存在注释表的新行中。</li></ol><p id="5d92" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">备注:</p><ul class=""><li id="7464" class="jv jw hi iz b ja jb jd je jg jx jk jy jo jz js md kb kc kd bi translated"><em class="jt">答案</em>表中的<em class="jt">答案编号</em>仅在显示投票的UI页面时使用。</li><li id="6b68" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js md kb kc kd bi translated"><em class="jt">访客</em>表中的<em class="jt">用户名</em>仅供注册用户使用(非注册用户也可以投票和评论)。</li></ul><h2 id="5c47" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">数据库“民意测验”的逻辑关系模型——用ORM形式化</h2><p id="d705" class="pw-post-body-paragraph ix iy hi iz b ja li ij jc jd lj im jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">让我们从展示如何使用Django ORM的类来描述数据库开始。</p><pre class="lo lp lq lr fd me km mf mg aw mh bi"><span id="d1c9" class="kn ko hi km b fi mi mj l mk ml"><strong class="km hj">class </strong>Comment(models.Model):<br/>    <strong class="km hj">#</strong> <em class="jt">table with comments on answers to the polls:</em><br/>    text = models.CharField()                    <strong class="km hj"># </strong><em class="jt">comment text</em></span><span id="b789" class="kn ko hi km b fi mm mj l mk ml"><strong class="km hj">class</strong> Answer(models.Model):<br/>    <strong class="km hj">#</strong> table with answers for the polls:<br/>    text = models.CharField()                    <strong class="km hj">#</strong> <em class="jt">answer text</em><br/>    votes = models.IntegerField()                <strong class="km hj">#</strong> <em class="jt">number of votes</em><br/>    number = models.PositiveSmallIntegerField()  <strong class="km hj">#</strong> <em class="jt">answer number</em><br/>    comments = models.ManyToManyField(Comment)   <strong class="km hj">#</strong> <em class="jt">answer comments</em><br/>    <strong class="km hj">def</strong> votes_percentage(self):<br/>        <strong class="km hj"># </strong><em class="jt">calculation of the percentage of votes for the answer:</em><br/>        total = self.poll.total_votes()<br/>        <strong class="km hj">return</strong> str(<br/>            self.votes / <strong class="km hj">float</strong>(total) * 100 <strong class="km hj">if </strong>total &gt; 0 <strong class="km hj">else</strong> 0<br/>        )[:5]  <strong class="km hj">#</strong> <em class="jt">show no more than 3 decimal places</em></span><span id="89a9" class="kn ko hi km b fi mm mj l mk ml"><strong class="km hj">class</strong> Poll(models.Model):<br/>    <strong class="km hj"># </strong><em class="jt">table with polls:</em><br/>    pub_date = models.DateTimeField()       <strong class="km hj"># </strong><em class="jt">date and time</em><br/>    active = models.BooleanField()          <strong class="km hj"># </strong><em class="jt">status (active/not</em>)<br/>    text = models.CharField()               <strong class="km hj">#</strong> <em class="jt">poll text</em><br/>    choice = models.ManyToManyField(Answer) <strong class="km hj"># </strong><em class="jt">poll answers</em><br/>    <strong class="km hj">def</strong> total_votes(self):<br/>        <strong class="km hj">#</strong> <em class="jt">calculation of the votes cast by the poll:</em><br/>        choices = self.choice_set.all()<br/>        votes = 0<br/>        <strong class="km hj">for </strong>choice <strong class="km hj">in</strong> choices:<br/>            votes += choice.votes<br/>        <strong class="km hj">return</strong> votes</span><span id="cad7" class="kn ko hi km b fi mm mj l mk ml"><strong class="km hj">class</strong> Visitor(models.Model):<br/>    <strong class="km hj">#</strong> <em class="jt">table with participants info:<br/>    </em>user_IP_address = models.CharField()<br/>    last_visit = models.DateTimeField()<strong class="km hj"># </strong>date and time of last visit<br/>    reg_user_id = models. ForeignKey(   <strong class="km hj">#</strong> user link in Django admin<br/>        on_delete= models.SET_NULL)<br/>    choices = models.ManyToManyField(Choice)  <strong class="km hj">#</strong> choice of answers<br/>    comments = models.ManyToManyField(Comment)<strong class="km hj"># </strong>comments on answers<br/>    polls =  models.ManyToManyField(Poll) <strong class="km hj"># </strong>polls participated</span></pre><p id="96fc" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt"> Visitor </em>类中的<em class="jt"> polls </em>属性可能看起来是多余的，因为投票列表可以通过答案列表获得，但是如果答案被删除，该属性用于保存用户参与投票的记录。</p><p id="8a8d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt"> Visitor </em>类中的<em class="jt"> reg_user_id </em>属性表示与标准Django认证系统通信的关系。</p><p id="1885" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Django ORM在第一次启动基于模型的用户子类的站点程序之前，物理地创建(或修改)数据库。Python命令<code class="du kj kk kl km b">manage.py migrate</code>和<code class="du kj kk kl km b">manage.py makemigrations</code>在应用上下文中执行。</p><p id="4b54" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于本例，Django ORM创建了下面的表——参见图2</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ln"><img src="../Images/3c1e3c974766cc7b9df5b90db1ca7797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OsEEyLmhSkND6Q48WThH-A.jpeg"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx translated">图Django ORM生成的数据库轮询的真实关系结构。</figcaption></figure><p id="0761" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">添加属性(代理键)<em class="jt"> poll_id </em>、<em class="jt"> choice_id </em>、<em class="jt"> visitor_id </em>、<em class="jt"> comment_id </em>来组织数据之间的关系。</p><p id="5fda" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关系模型的开销是显而易见的:四个额外的属性和五个额外的连接表:<em class="jt"> Poll-Choice </em>、<em class="jt"> Visitor-Comments、</em> <em class="jt"> Choice-Comments </em>、<em class="jt"> Visitor-Choices、Visitor-Polls </em>。</p><h2 id="ae2e" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">数据库“民意测验”的逻辑表格网络模型——用HTMS形式化。第一部分。数据库结构</h2><p id="5e0e" class="pw-post-body-paragraph ix iy hi iz b ja li ij jc jd lj im jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">本小节将演示如何在API HTMS中描述“投票”数据库。参见<a class="ae ju" rel="noopener" href="/@azur06400/tabular-network-data-model-part-1-conceptual-definition-49e84104b8aa">这里</a>的“超表”(HT)、语义类型、显著变化数据类型属性(DTA)和引用类型属性(RTA)的定义以及<a class="ae ju" rel="noopener" href="/@azur06400/tabular-network-data-model-part-2-important-features-99a07f514b4">这里</a>的搜索波和超表管理系统(HTMS)的定义。</p><p id="f058" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">A)</strong><strong class="iz hj"><em class="jt">HT _ Obj</em></strong>类用于在应用程序内存(RAM)中创建特定数据库(HT)的实例。</p><p id="d8b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> <em class="jt"> HT_Obj </em> </strong>实例可以在服务器上创建一个新的数据库作为一组必要的文件，或者“打开”一个现有的数据库——将其核心从文件加载到RAM中。</p><p id="4479" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实例还可以使用<strong class="iz hj"> <em class="jt"> HT_Obj </em> </strong>类方法对数据库结构进行更改，例如添加、重命名或删除属性。这将在下一篇文章中举例说明。</p><p id="7e01" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当初始化具有特定HT的类的对象时，所需的参数是:</p><ul class=""><li id="7f7b" class="jv jw hi iz b ja jb jd je jg jx jk jy jo jz js md kb kc kd bi translated"><code class="du kj kk kl km b">db_name</code>:文件服务器中HT的符号名；</li><li id="4574" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js md kb kc kd bi translated"><code class="du kj kk kl km b">server</code>:带有数据库的文件服务器的IP地址(或DNS)；</li><li id="4e64" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js md kb kc kd bi translated"><code class="du kj kk kl km b">db_root</code>:文件服务器上HT文件的路径。</li></ul><p id="9f3e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以另外指定参数<code class="du kj kk kl km b">new</code>:如果“<em class="jt">真”</em>，则创建一个新的数据库，作为一组文件和一个新的类；如果“<em class="jt">False”</em>(默认情况下)，则现有数据库“打开”，即打开其文件，并根据其中的信息创建该类的对象实例。</p><p id="6ad4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要确定HT的属性，即它们的名称和数据类型，应使用以下结构:</p><p id="bf08" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl km b">ht_instance_name.attribute_name = "data_type"</code>，在那里:</p><ul class=""><li id="5541" class="jv jw hi iz b ja jb jd je jg jx jk jy jo jz js md kb kc kd bi translated"><code class="du kj kk kl km b">ht_instance_name</code> —对象名称—<em class="jt">HT _ Obj</em>的实例；</li><li id="9462" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js md kb kc kd bi translated"><code class="du kj kk kl km b">attribute_name</code> —属性符号名；</li><li id="0ab1" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js md kb kc kd bi translated"><code class="du kj kk kl km b">data_type </code> —数据类型，例如:“int4”(整数)、“float8”(双浮点数)、“* utf”(UTF-8字符字符串。Unicode转换格式，8位是一种通用的字符编码标准，使用可变的字节数(从1到4)可以更紧凑地存储和传输字符。)、“*link”(对表格行的引用)等。(documentation⁵).中给出了HTMS数据类型的完整列表</li></ul><p id="8b25" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl km b">ht_object_name.relation(dictionary)</code>方法为RTA添加了明确的类别描述(“整体”、“多部分”、“原因”)。</p><p id="d02a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">b)</strong><strong class="iz hj"><em class="jt">表格</em> </strong> class⁴用于为表格创建对象。必需的参数:</p><ul class=""><li id="76fd" class="jv jw hi iz b ja jb jd je jg jx jk jy jo jz js md kb kc kd bi translated"><code class="du kj kk kl km b">ht_name</code>:HT的符号名；</li><li id="0dd4" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js md kb kc kd bi translated"><code class="du kj kk kl km b">t_name</code>:表格的符号名。</li></ul><p id="9f64" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当一个表对象被初始化时，它在HT中的存在被检查，现有的对象或者被“打开”或者一个新的被创建。</p><p id="8034" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了确定表的列，即它们与HT属性的对应关系，使用以下结构:</p><p id="0d35" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl km b">table_instance_name.fields_add = {&lt;HT attributes subset&gt;}</code>，其中:</p><ul class=""><li id="b36b" class="jv jw hi iz b ja jb jd je jg jx jk jy jo jz js md kb kc kd bi translated"><code class="du kj kk kl km b">table_instance_name</code>是表对象实例的名称；</li><li id="1b3c" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js md kb kc kd bi translated"><code class="du kj kk kl km b">fields_add </code>是<em class="jt">表</em>类的特殊系统属性(字段)，利用其值Python解释器生成一组新的表属性(基于被覆盖的<code class="du kj kk kl km b"> __setattr __ ()</code>系统方法)；</li><li id="c676" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js md kb kc kd bi translated"><code class="du kj kk kl km b">{&lt;HT attributes subset&gt;}</code>是HT属性的子集(符号名)。</li></ul><p id="ad0f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">示例数据库“民意测验”结构形式化</strong></p><p id="baea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在站点程序执行期间，HTMS创建一个新的数据库或直接打开一个现有的数据库。相关选项:</p><p id="a9c4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> A) </strong> <strong class="iz hj">创建一个名为“polls”的新</strong> HT。</p><p id="2d06" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl km b">polls_db = HT_Obj(db_name= ’polls’, server=’…’, db_root=’…’, new = True)</code></p><p id="6d41" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果:</p><ul class=""><li id="d476" class="jv jw hi iz b ja jb jd je jg jx jk jy jo jz js md kb kc kd bi translated">主数据库files⁵(“空”)被物理地创建；</li><li id="4e53" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js md kb kc kd bi translated">主数据库对象实例<code class="du kj kk kl km b">polls_db</code>在内存中创建。</li></ul><p id="a7e4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">或</strong></p><p id="ee1c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">B)</strong>T19】打开现有的 HT，名称为“polls”。</p><p id="da95" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kj kk kl km b">polls_db = HT_Obj(db_name= ’polls’, server=’…’, db_root=’…’,)</code></p><p id="73c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">结果:</p><ul class=""><li id="8c68" class="jv jw hi iz b ja jb jd je jg jx jk jy jo jz js md kb kc kd bi translated">现有数据库的主文件被物理打开；</li><li id="7924" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js md kb kc kd bi translated">对象<code class="du kj kk kl km b">polls_db</code>在内存中创建，其属性包含从其文件中读取的关于数据库的公共信息(HT descriptor⁵)。</li></ul><p id="42d7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于在<strong class="iz hj"> HTdb </strong>子类的实例初始化期间创建的新数据库，有必要确定逻辑层的结构(方案)。</p><p id="9f04" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">定义所有数据库属性、它们的名称和它们的数据类型:</strong></p><pre class="lo lp lq lr fd me km mf mg aw mh bi"><span id="b474" class="kn ko hi km b fi mi mj l mk ml">polls_db.poll_pub_date = "datetime" <strong class="km hj"># </strong><em class="jt">poll publication time</em></span><span id="c330" class="kn ko hi km b fi mm mj l mk ml">polls_db.poll_status = "byte1" <strong class="km hj">#<em class="jt"> </em></strong><em class="jt">poll status “active/not” (byte)</em></span><span id="f40d" class="kn ko hi km b fi mm mj l mk ml">polls_db.poll_text = "*utf" <strong class="km hj">#</strong> <em class="jt">poll text - variable length)</em></span><span id="db31" class="kn ko hi km b fi mm mj l mk ml">polls_db.poll_answers = "*link" <strong class="km hj">#</strong> <em class="jt">RTA - poll answers</em></span><span id="4486" class="kn ko hi km b fi mm mj l mk ml">polls_db.answer_text = "*utf"  <strong class="km hj"># </strong><em class="jt">answer text</em></span><span id="07c9" class="kn ko hi km b fi mm mj l mk ml">polls_db.answer_votes = "int4" <strong class="km hj">#</strong> <em class="jt">number of answer votes</em></span><span id="e9e1" class="kn ko hi km b fi mm mj l mk ml">polls_db.answer_number = "int4" <strong class="km hj"># </strong><em class="jt">poll answer serial number</em></span><span id="a602" class="kn ko hi km b fi mm mj l mk ml">polls_db.answer_comment = "*link"  <strong class="km hj"># </strong>RTA -  <em class="jt">comments on the answer</em></span><span id="ff75" class="kn ko hi km b fi mm mj l mk ml">polls_db.comment_text = "*utf"  <strong class="km hj">#</strong> <em class="jt">comment text</em></span><span id="2e7f" class="kn ko hi km b fi mm mj l mk ml">polls_db.user_IP_address = "*utf"  <strong class="km hj">#</strong> <em class="jt">poll participant IP address</em></span><span id="9a67" class="kn ko hi km b fi mm mj l mk ml">polls_db.user_last_visit = "datetime" <strong class="km hj">#</strong> <em class="jt">time of last site visit</em></span><span id="dbe8" class="kn ko hi km b fi mm mj l mk ml">polls_db.user_name = "*utf"  <strong class="km hj">#</strong> <em class="jt">registered (in admin) username</em></span><span id="f192" class="kn ko hi km b fi mm mj l mk ml">polls_db.user_answers = "*link"  <strong class="km hj"># </strong><em class="jt">RTA - answers selected poll</em>  <br/>                                 <strong class="km hj"># </strong>     <em class="jt"> by the participant</em></span><span id="cf52" class="kn ko hi km b fi mm mj l mk ml">polls_db.user_comments = "*link" <strong class="km hj"># </strong><em class="jt">RTA - participant comments</em></span></pre><p id="0385" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">定义RTA的语义类型(默认情况下，其余类型为“原因”):</strong></p><pre class="lo lp lq lr fd me km mf mg aw mh bi"><span id="ef07" class="kn ko hi km b fi mi mj l mk ml">polls_db.relation(<br/>    {<br/>        "poll_answers": "whole",</span><span id="1fd7" class="kn ko hi km b fi mm mj l mk ml"><strong class="km hj">           #</strong> <em class="jt">when a poll is deleted, all answers to it are deleted,</em><br/>           <strong class="km hj"># </strong><em class="jt">and when any answer is deleted,</em><br/>           <strong class="km hj">#</strong> <em class="jt">the poll with all answers is deleted</em></span><span id="ec34" class="kn ko hi km b fi mm mj l mk ml">        "answer_comments": "multipart",</span><span id="33b5" class="kn ko hi km b fi mm mj l mk ml"><strong class="km hj">           #</strong> <em class="jt">when an answer is deleted, all comments to it are</em><br/>           <strong class="km hj"># </strong><em class="jt">deleted, but when the comment is deleted, </em><br/>           <strong class="km hj">#</strong> <em class="jt">the answer is not deleted</em></span><span id="bede" class="kn ko hi km b fi mm mj l mk ml">        "user_comments": "multipart",</span><span id="3a7a" class="kn ko hi km b fi mm mj l mk ml"><strong class="km hj">           #</strong> <em class="jt">if  a participant is deleted, all their comments</em><br/>           <strong class="km hj">#</strong> <em class="jt">are deleted, but if a comment is deleted, </em><br/>           <strong class="km hj">#</strong> <em class="jt">the participant is not deleted</em><br/>    }<br/>)</span></pre><p id="f3e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">创建表格实例，并从HT的公共属性集中为其选择属性(列)</strong></p><pre class="lo lp lq lr fd me km mf mg aw mh bi"><span id="3062" class="kn ko hi km b fi mi mj l mk ml">class Polls(Table)<br/>    pass<br/>class Answers(Table)<br/>    pass<br/>class Comments(Table)<br/>    pass<br/>class Users(Table)<br/>    pass</span><span id="7e59" class="kn ko hi km b fi mm mj l mk ml">polls = Polls(polls_db.db_name)</span><span id="a718" class="kn ko hi km b fi mm mj l mk ml">polls.fields_add = {<br/>    "poll_pub_date",<br/>    "poll_status",<br/>    "poll_answers",<br/>    "poll_text"<br/>}</span><span id="a80c" class="kn ko hi km b fi mm mj l mk ml">answers = Answers(polls_db.db_name)</span><span id="4a96" class="kn ko hi km b fi mm mj l mk ml">answers.fields_add = {<br/>    "answer_text",<br/>    "answer_votes",<br/>    "answer_number",<br/>    "answer_comments",<br/>}</span><span id="49d7" class="kn ko hi km b fi mm mj l mk ml">users = Users(polls_db.db_name)</span><span id="55e9" class="kn ko hi km b fi mm mj l mk ml">users.fields_add = {<br/>    "user_IP_address",<br/>    "user_last_visit",<br/>    "user_name",<br/>    "user_answers",<br/>    "user_comments",<br/>}</span><span id="f5f5" class="kn ko hi km b fi mm mj l mk ml">comments = Comments(polls_db.db_name)</span><span id="cab2" class="kn ko hi km b fi mm mj l mk ml">comments.fields_add = {"comment_text"}</span></pre><p id="76e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该代码的执行导致数据库结构的形成和服务器上相应文件的创建。如果已经创建了一个数据库，那么使用它只需要创建HT类和table类的实例。</p><p id="f77e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于本示例，HTMS创建HT(表格网络数据库)的结构，如图3所示。</p><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ln"><img src="../Images/7fbc70208f8e9e8bf824e74ede24eafc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xppsSk5nFfPA7VU_0PlA6w.jpeg"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx translated">图3:表格网络数据库“polls_db”。该图通常以属性集的形式显示带有名称(“用户”、“投票”、“回答”、“评论”)和结构的表格。加粗的单元格边框表示数据类型属性(DTA)，带箭头的非加粗单元格边框表示引用类型属性(RTA)。每个箭头都标有RTA的语义类型，并指向一个表，其中的行出现在给定属性的值中(链接对:“table，row”)。</figcaption></figure><figure class="lo lp lq lr fd ls er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mn"><img src="../Images/bb808ad6e93d209412132111ef5555a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*srKvL1LvzhSjNfHIytSHnA.jpeg"/></div></div><figcaption class="lz ma et er es mb mc bd b be z dx translated">图4:表格网络数据库的HTed web编辑器的屏幕截图</figcaption></figure><h2 id="e443" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">比较</h2><p id="6b2e" class="pw-post-body-paragraph ix iy hi iz b ja li ij jc jd lj im jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">通过比较关系模型和表格网络模型，可以清楚地看出，与关系数据库相比，表格网络模型更容易理解，更能代表经验场景。HTMS和ORM中逻辑级别的数据方案的形式化是相似的，但是存在根本的区别:</p><ul class=""><li id="ca1c" class="jv jw hi iz b ja jb jd je jg jx jk jy jo jz js md kb kc kd bi translated">在HTMS中，属性和数据类型被定义为数据库的公共集合，并且可以在应用程序算法中添加或删除它们；在ORM中，它们被绑定到不同的表中，不可能在运行的程序中改变它们。</li><li id="2b6d" class="jv jw hi iz b ja ke jd kf jg kg jk kh jo ki js md kb kc kd bi translated">ORM中每个表的属性是静态的，但在HTMS中是动态的。HTMS中的表结构被定义为公共属性空间的投影，这比ORM中的更简单、更直观。使用HTMS的应用程序算法可以改变表的结构，例如，通过添加新列或删除现有列，这在ORM技术中是不可能的。</li></ul><p id="ee0b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我计划继续撰写关于表格网络数据模型和我的HTMS实现的文章。在下一篇文章中，我将继续讨论数据库“投票”示例——HTMS数据操作，以及搜索和过滤。</p><p id="8efe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本文授权文本:<a class="ae ju" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="noopener ugc nofollow" target="_blank"> CC BY-NC-ND 4.0 </a></p><p id="b00e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所示代码的许可:<a class="ae ju" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener ugc nofollow" target="_blank"> CC BY-NC-SA 4.0 </a></p><h2 id="20cc" class="kn ko hi bd kp kq kr ks kt ku kv kw kx jg ky kz la jk lb lc ld jo le lf lg lh bi translated">引文</h2><p id="93a0" class="pw-post-body-paragraph ix iy hi iz b ja li ij jc jd lj im jf jg lk ji jj jk ll jm jn jo lm jq jr js hb bi translated">【1】:<em class="jt">笼具系统。</em><a class="ae ju" href="https://github.com/Arselon/Cage" rel="noopener ugc nofollow" target="_blank">github.com/Arselon/Cage</a></p><p id="3870" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">【2】:<em class="jt">HTMS</em>T10】github.com/Arselon/HTMS</p><p id="d031" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[3]: <em class="jt"> HTMS对象级别</em>。<a class="ae ju" href="https://github.com/Arselon/HTMS/tree/main/htms_obj" rel="noopener ugc nofollow" target="_blank">github.com/Arselon/HTMS/tree/main/htms_obj</a></p><p id="8a97" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">【4】:<em class="jt">HTMS中层。</em><a class="ae ju" href="https://github.com/Arselon/HTMS/tree/main/htms_mid" rel="noopener ugc nofollow" target="_blank">github.com/Arselon/HTMS/tree/main/htms_mid</a></p><p id="d46d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">【5】:<em class="jt">HTMS低水平。<a class="ae ju" href="https://github.com/Arselon/HTMS/tree/main/htms_low" rel="noopener ugc nofollow" target="_blank">github.com/Arselon/HTMS/tree/main/htms_low</a>T21</em></p><p id="96de" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[6]: <em class="jt"> Django web项目模板</em>。<a class="ae ju" href="https://docs.microsoft.com/en-gb/visualstudio/python/python-django-web-application-project-template?view=vs-2019" rel="noopener ugc nofollow" target="_blank">docs . Microsoft . com/en-GB/visual studio/python/python-django-we B- application-project-template？view=vs-2019 </a></p><p id="25a9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">[7]: <em class="jt"> Django ORM </em>。【www.fullstackpython.com/django-orm.html T2】号</p></div></div>    
</body>
</html>