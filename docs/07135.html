<html>
<head>
<title>GENERICS in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的泛型</h1>
<blockquote>原文：<a href="https://medium.com/codex/generics-in-swift-b120ec9c4540?source=collection_archive---------2-----------------------#2022-06-01">https://medium.com/codex/generics-in-swift-b120ec9c4540?source=collection_archive---------2-----------------------#2022-06-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6961" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">深入探究受约束和不受约束的泛型</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/520e783dd5bf9aa98dabc2b018db992b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gCTFTiC8EzdBiPiI"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡·布拉沃</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="a700" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个故事就有点长了。请原谅我。我将确保在这里传递关于泛型的最佳知识。到这个故事结束的时候，我们将会学到以下的东西。如何编写泛型代码<br/> 2？如何用协议约束泛型<br/> 3。如何使用等价、可比和可散列的协议<br/> 4。如何创建高度可重用的类型</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="1f6a" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">我们开始吧！</h2><h2 id="c7a4" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">什么是泛型？</h2><p id="6af5" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">在<strong class="jq hj"> </strong>之前，我们学习什么是泛型。我们将会看到什么是多态性概念。解码<code class="du lr ls lt lu b">Polymorphism</code>的词义，我们可以了解到<strong class="jq hj">多态</strong>的意思是:<br/> <strong class="jq hj">聚</strong> =多<br/> <strong class="jq hj">语素</strong> =形式</p><blockquote class="lv lw lx"><p id="2678" class="jo jp ly jq b jr js ij jt ju jv im jw lz jy jz ka ma kc kd ke mb kg kh ki kj hb bi translated">所以多态等于很多形式。</p></blockquote><p id="1c57" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如，我们将考虑锁门的场景。<br/> <strong class="jq hj">我们有多少种方法可以锁门？</strong></p><div class="iy iz ja jb fd ab cb"><figure class="mc jc md me mf mg mh paragraph-image"><img src="../Images/83a2245a70343725710256077b02982c.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*unZfCL46ZBFdXnQ6eFn1YQ.jpeg"/></figure><figure class="mc jc md me mf mg mh paragraph-image"><img src="../Images/b5c8c0f25efc5252ac47ed848f30ec67.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*O9Caf4OgQzR_WPQyh7C2Kw.jpeg"/></figure><figure class="mc jc md me mf mg mh paragraph-image"><img src="../Images/79f2172a44d010bc0beaf1978fd97a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*S9Ew3j7UdkSj3E5mAfbnag.jpeg"/></figure></div><p id="ba14" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">手动钥匙锁、生物识别锁、自动锁等。锁门有很多种方法。但是结果总是一样的锁上门或者是锁上门的过程。在编程中，我们可以编写一个中央锁定函数，而不考虑锁的类型。无论你遇到什么样的锁，你的中控锁功能都会帮你搞定。这就是多态性的含义。简而言之，我们可以说多态是一种允许相似操作以相同名称分组的方式。继承让我们从另一个类继承属性和方法。多态性使用这些方法来执行不同的任务。</p><p id="39e2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lr ls lt lu b">Generics</code>对于创建多态代码至关重要。一旦你开始使用<code class="du lr ls lt lu b">Generics</code>，你会看到你的代码库变得精简，你会写出非常优雅和高度可重用的代码。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="5695" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">让我们创建第一个泛型函数。</h2><p id="1508" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">我们将首先编写一个简单的非泛型函数来查找数组的第一项和最后一项。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="fb69" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里你可以看到我们有一个函数<code class="du lr ls lt lu b">getFirstLast</code>，它接受一个整数数组输入并返回一个元组，元组中的第一个元素作为数组的第一个元素，元组中的第二个元素作为数组的最后一个元素。现在，让我们假设你的需求已经做了一点调整，我们将有一个字符串数组作为输入和(String，String)作为函数返回，而不是整数数组输入。你将如何处理这件事？你将不得不用[String]输入和(String，String)输出编写一个不同的函数。</p><p id="6f04" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这些场景中，泛型可以提供帮助。在这里，我将展示泛型是如何帮助我们的。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="5715" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">将非泛型函数转换为泛型函数是一个简单的过程。<br/>我们将在函数参数中添加一个通用的<code class="du lr ls lt lu b">&lt;T&gt;</code>类型参数。现在，一旦我们为函数引入了一个泛型，我们就可以很容易地在函数的其余部分引用它。<br/>举例:<code class="du lr ls lt lu b">array: [T]</code>及其返回类型<code class="du lr ls lt lu b">(T, T)</code> <br/>这里的<strong class="jq hj"> T </strong>只是一个抽象。我们用T，U或V等。，作为惯例。你可以用任何单词代替t。</p><p id="6640" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们将看到我们的泛型函数如何与其他类型一起工作。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="0153" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">结果:</p><pre class="iy iz ja jb fd mk lu ml mm aw mn bi"><span id="7007" class="kr ks hi lu b fi mo mp l mq mr">Nikhil Vinod<br/>1 2<br/>1.0 2.0</span></pre></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="b3e0" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">具有自定义类型的泛型</h2><p id="3852" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">我们也可以在泛型中传递自定义类型。例如</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="78fe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">结果:</p><pre class="iy iz ja jb fd mk lu ml mm aw mn bi"><span id="41c2" class="kr ks hi lu b fi mo mp l mq mr">Dog(name: “Snow”) Dog(name: “Snowy”)</span></pre><p id="b6a4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">不像<code class="du lr ls lt lu b">Any</code>在运行时没有向下转换。编译器在编译时声明一切。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="45f5" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">用协议约束泛型</h2><p id="0cb4" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">我们看到了一个简单的<code class="du lr ls lt lu b">T</code>是如何成为任何事物的。这意味着我们的<code class="du lr ls lt lu b">T</code>上面的例子是无约束的泛型。我们可以通过用协议约束来限制泛型应该表示什么。<br/>比如:<br/>我们写一个函数，返回一个输入数组中的最低值。既然我们已经学会了如何编写通用代码，我们将编写如下代码。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="ceb3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">但不幸的是，我们的代码会抛出一个错误。</p><pre class="iy iz ja jb fd mk lu ml mm aw mn bi"><span id="09a3" class="kr ks hi lu b fi mo mp l mq mr">error: binary operator '&lt;' cannot be applied to two 'T' operands<br/>      return first &lt; second</span></pre><p id="97a4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">是因为我们的<code class="du lr ls lt lu b">T</code>还不够成熟，不能进行比较运算。我们将使用协议解决此问题。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h2 id="55e2" class="kr ks hi bd kt ku kv kw kx ky kz la lb jx lc ld le kb lf lg lh kf li lj lk ll bi translated">等价的、可比较的和可散列的协议</h2><p id="dd6a" class="pw-post-body-paragraph jo jp hi jq b jr lm ij jt ju ln im jw jx lo jz ka kb lp kd ke kf lq kh ki kj hb bi translated">什么是<code class="du lr ls lt lu b">Protocols</code>？协议只不过是一套规则。那么协议如何帮助我们完成我们的<code class="du lr ls lt lu b">lowest</code>功能呢？协议定义了泛型工作的规则。符合<code class="du lr ls lt lu b">Protocol</code>的类需要在类中定义该协议所需的所有功能和变量。这对我们来说是一个众所周知的事实。同样，我们将在<code class="du lr ls lt lu b">lowest</code>函数中为<code class="du lr ls lt lu b">T</code>定义<code class="du lr ls lt lu b">Protocols</code>来完成它。</p><p id="99d9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<code class="du lr ls lt lu b">lowest</code>函数中，问题是比较器不与<code class="du lr ls lt lu b">T</code>一起工作。所以我们有一个<code class="du lr ls lt lu b">Comparable</code>救援协议。</p><p id="3a66" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">可比<br/> </strong>可比协议有几个静态函数用于以下操作:<code class="du lr ls lt lu b">&lt;</code> <code class="du lr ls lt lu b">&lt;=</code> <code class="du lr ls lt lu b">&gt;=</code> <code class="du lr ls lt lu b">&gt;</code> <br/>现在来完成我们的<code class="du lr ls lt lu b">lowest</code>功能。我们将通过使<code class="du lr ls lt lu b">T</code>符合<code class="du lr ls lt lu b">Comparable</code>来给<code class="du lr ls lt lu b">lowest</code>补充助推器</p><p id="32bc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">既然我们知道输入数组中的所有项都可以进行比较，那么我们可以通过编写下面的代码来完成最低层的函数:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="37b1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">等价协议允许我们检查两个类型是否相等。<br/>等价协议有一个用于操作<code class="du lr ls lt lu b">==</code>的静态函数，它和我们之前看到的可比协议一样简单。</p><p id="2317" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如:<br/>我们将尝试创建一个可以接受整数输入作为值的结构。我们还将创建几个带有一些值的结构对象，检查它们是否相等。如果我们用非泛型结构对对象进行比较，编译器会抛出一个错误。让我们使它符合一个等价的协议。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="1233" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里<code class="du lr ls lt lu b">AlienInteger</code>符合等价协议，我们可以使用<code class="du lr ls lt lu b">==</code>操作符。</p><p id="25ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">结果:</p><pre class="iy iz ja jb fd mk lu ml mm aw mn bi"><span id="e8b3" class="kr ks hi lu b fi mo mp l mq mr">true, false</span></pre><p id="1ceb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Hashable <br/> </strong> Hashable协议定义了一种方法，该方法接受一个哈希器来产生一个整数哈希值。然后，具有Hashable类型的泛型可以将值提供给哈希函数。<br/>可散列类型可用作字典键或集合的一部分。<br/>很多<code class="du lr ls lt lu b">Equatable</code>的内置类型也是<code class="du lr ls lt lu b">Hashable</code>。</p><p id="d106" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当您定义一个没有关联值的枚举时，它会自动获得<code class="du lr ls lt lu b">Hashable</code>一致性，并且您可以通过实现<code class="du lr ls lt lu b">hash(into:)</code>方法将<code class="du lr ls lt lu b">Hashable</code>一致性添加到您的其他定制类型中。<br/>对于存储属性都是<code class="du lr ls lt lu b">Hashable</code>的结构，以及具有all- <code class="du lr ls lt lu b">Hashable</code>关联值的枚举类型，编译器能够自动提供<code class="du lr ls lt lu b">hash(into:)</code>的实现。</p><p id="8afd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">例如:<br/>一名教师想要将他/她的班级学生的详细信息从一个大列表输入到她的班级数据库中，该列表也有重复项。所有学生都将拥有一个唯一的ID。现在，老师必须将唯一的学生输入到新列表中。让我们来解决这个问题。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="6d1e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了解决重复的问题，我们将保留一批学生。因为<code class="du lr ls lt lu b">Student</code>型是hashable，所以可以成套使用。</p><p id="c9e0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们通过提供一个<code class="du lr ls lt lu b">==</code>操作函数并实现<code class="du lr ls lt lu b">hash(into:)</code>方法，将<code class="du lr ls lt lu b">Student</code>类型变成了<code class="du lr ls lt lu b">Hashable</code>。<br/>本例中的<code class="du lr ls lt lu b">hash(into:)</code>方法将学生的<code class="du lr ls lt lu b">name</code>和<code class="du lr ls lt lu b">id</code>属性输入到提供的哈希函数中。这些属性与用于测试<code class="du lr ls lt lu b">==</code>运算符函数中的相等性的属性相同。既然<code class="du lr ls lt lu b">Student</code>符合<code class="du lr ls lt lu b">Hashable</code>协议，我们可以创建一组currentList。</p><p id="6ada" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">结果:</p><pre class="iy iz ja jb fd mk lu ml mm aw mn bi"><span id="e470" class="kr ks hi lu b fi mo mp l mq mr">New student added (Snow, 2).</span></pre></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="aa50" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们已经到了这个故事的结尾。我希望你已经理解了泛型和多态的概念。接下来是<strong class="jq hj">泛型和子类型Swift中的子类型和不变性概念</strong></p><p id="3639" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你喜欢这个故事，请分享并关注更多这样的故事。如果你有任何疑问或建议，请告诉我。感谢你阅读❤️</p></div></div>    
</body>
</html>