<html>
<head>
<title>Fun with Flags</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">旗帜带来的乐趣</h1>
<blockquote>原文：<a href="https://medium.com/codex/fun-with-flags-8c137052e245?source=collection_archive---------5-----------------------#2022-03-29">https://medium.com/codex/fun-with-flags-8c137052e245?source=collection_archive---------5-----------------------#2022-03-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1d7bdccfc3d3f98e7d86bae1025748bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bMDvIPVXTjPcfLwi"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@lemonvlad?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗拉季斯拉夫·克拉平</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2f97" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">bazel build system最初是Google内部的一个构建工具，是一个开源项目，专注于跨各种编程语言和平台的快速、可靠和可重复的软件开发。</p><p id="6455" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一个典型的bazel项目是一个目录树，在树的根部有一个名为<code class="du jt ju jv jw b">WORKSPACE</code>的文件，它定义了外部依赖关系，还有一个或多个名为<code class="du jt ju jv jw b">BUILD</code>(或<code class="du jt ju jv jw b">BUILD.bazel</code>)的文件，其中包含构建目标的声明。更多信息和例子可以在<a class="ae iu" href="https://bazel.build/start" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="06c3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最近，在一个项目中，我需要一种方法来根据用户选择的值在几个不同的版本之间进行选择。Bazel使用<a class="ae iu" href="https://bazel.build/rules/config#user-defined-build-settings" rel="noopener ugc nofollow" target="_blank">用户定义的构建设置</a>来支持这一点。为了简单起见，我们将使用<code class="du jt ju jv jw b"><a class="ae iu" href="https://github.com/bazelbuild/bazel-skylib" rel="noopener ugc nofollow" target="_blank">bazel_skylib</a></code>库，它包含一些定义构建设置的规则。我们需要在我们的<code class="du jt ju jv jw b">WORKSPACE</code>文件中声明这一点:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="9caf" class="kf kg hi jw b fi kh ki l kj kk">load("<a class="ae iu" href="http://twitter.com/bazel_tools" rel="noopener ugc nofollow" target="_blank">@bazel_tools</a>//tools/build_defs/repo:http.bzl", "http_archive")</span><span id="5446" class="kf kg hi jw b fi kl ki l kj kk">http_archive(<br/>    name = "bazel_skylib",<br/>    urls = [<br/>        "<a class="ae iu" href="https://mirror.bazel.build/github.com/bazelbuild/bazel-skylib/releases/download/1.2.0/bazel-skylib-1.2.0.tar.gz" rel="noopener ugc nofollow" target="_blank">https://mirror.bazel.build/github.com/bazelbuild/bazel-skylib/releases/download/1.2.0/bazel-skylib-1.2.0.tar.gz</a>",<br/>        "<a class="ae iu" href="https://github.com/bazelbuild/bazel-skylib/releases/download/1.2.0/bazel-skylib-1.2.0.tar.gz" rel="noopener ugc nofollow" target="_blank">https://github.com/bazelbuild/bazel-skylib/releases/download/1.2.0/bazel-skylib-1.2.0.tar.gz</a>",<br/>    ],<br/>)</span></pre><p id="b2ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这使用了内置<code class="du jt ju jv jw b">bazel_tools</code>库中的<code class="du jt ju jv jw b">http_archive</code>规则，我们用它来导入<code class="du jt ju jv jw b">bazel_skylib</code>存储库。</p><p id="1a1e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以在<code class="du jt ju jv jw b">BUILD</code>文件中为我们的项目添加一个构建设置:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="ddc1" class="kf kg hi jw b fi kh ki l kj kk">load("<a class="ae iu" href="http://twitter.com/bazel_skylib" rel="noopener ugc nofollow" target="_blank">@bazel_skylib</a>//rules:common_settings.bzl", "string_flag")<br/><br/>string_flag(<br/>    name = "foo",<br/>    build_setting_default = "42",<br/>)</span></pre><p id="179d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的项目中，我需要一种方法在一些C++代码中使用这个构建设置的值。这就是事情开始变得有点棘手的地方。首先，让我们添加程序代码:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="f3f2" class="kf kg hi jw b fi kh ki l kj kk">// test.cpp<br/>#include &lt;iostream&gt;<br/>using namespace std;<br/>int main() {<br/>    cout &lt;&lt; FLAG &lt;&lt; endl;<br/>    return 0;<br/>}</span></pre><p id="8f3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">按照现在的情况，除非我们在C编译器命令行中添加一些东西来为<code class="du jt ju jv jw b">FLAG</code>定义一个值，否则它不会编译。我们可以在我们的<code class="du jt ju jv jw b">BUILD</code>文件中使用<code class="du jt ju jv jw b">cc_binary</code>规则的<code class="du jt ju jv jw b">defines</code>属性来做到这一点:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="b498" class="kf kg hi jw b fi kh ki l kj kk">cc_binary(<br/>    name = "test",<br/>    srcs = ["test.cpp"],<br/>    defines = ["FLAG=99"],<br/>)</span></pre><p id="610d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们需要弄清楚如何将我们的构建设置链接到代码中的<code class="du jt ju jv jw b">FLAG</code>值。为此，我们将使用bazel Starlark语言定义一个定制规则。我们添加了一个新文件<code class="du jt ju jv jw b">defs.bzl</code>，它包含规则实现:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="69a9" class="kf kg hi jw b fi kh ki l kj kk"># defs.bzl<br/>load("<a class="ae iu" href="http://twitter.com/bazel_skylib" rel="noopener ugc nofollow" target="_blank">@bazel_skylib</a>//rules:common_settings.bzl", "BuildSettingInfo")</span><span id="7fee" class="kf kg hi jw b fi kl ki l kj kk">def _define_from_flag_impl(ctx):<br/>    return CcInfo(<br/>        compilation_context = cc_common.create_compilation_context(<br/>            defines = depset([<br/>                "FLAG=\"{}\"".format(<br/>                    ctx.attr.value[BuildSettingInfo].value,<br/>                ),<br/>            ]),<br/>        ),<br/>    )</span><span id="a761" class="kf kg hi jw b fi kl ki l kj kk">define_from_flag = rule(<br/>    implementation = _define_from_flag_impl,<br/>    attrs = {<br/>        "value": attr.label(),<br/>    },<br/>)</span></pre><p id="d4a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分解一下，我们定义了一个名为<code class="du jt ju jv jw b">define_from_flag</code>的新规则，它有一个名为<code class="du jt ju jv jw b">value</code>的带标签的属性。该属性将与引用我们的构建设置的标签一起使用。如需进一步阅读，请查看更深入讨论该主题的<a class="ae iu" href="https://bazel.build/rules/rules-tutorial" rel="noopener ugc nofollow" target="_blank">规则教程</a>。</p><p id="05f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Starlark中，标签包含一个<a class="ae iu" href="https://bazel.build/rules/lib/starlark-provider" rel="noopener ugc nofollow" target="_blank">提供者</a>的集合，这些提供者用标签描述对象的细节。对于<code class="du jt ju jv jw b">bazel_skylib</code>的<code class="du jt ju jv jw b">string_flag</code>规则，这包括一个保存标志值的<code class="du jt ju jv jw b">BuildSettingInfo</code>——我们将它从标签中取出，并用它来格式化<code class="du jt ju jv jw b">FLAG</code>的定义设置。最后一部分将该定义包装在一个<code class="du jt ju jv jw b">CcInfo</code>提供程序中，该提供程序的行为类似于一个包含我们的定义值的空<code class="du jt ju jv jw b">cc_library</code>。</p><p id="b825" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以在我们的<code class="du jt ju jv jw b">BUILD</code>文件中把它连接起来:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="0b88" class="kf kg hi jw b fi kh ki l kj kk">load("<a class="ae iu" href="http://twitter.com/bazel_skylib" rel="noopener ugc nofollow" target="_blank">@bazel_skylib</a>//rules:common_settings.bzl", "string_flag")<br/>load("defs.bzl", "define_from_flag")</span><span id="d2aa" class="kf kg hi jw b fi kl ki l kj kk">cc_binary(<br/>    name = "test",<br/>    srcs = ["test.cpp"],<br/>    deps = [":flag"],<br/>)</span><span id="47ba" class="kf kg hi jw b fi kl ki l kj kk">define_from_flag(<br/>    name = "flag",<br/>    value = ":foo",<br/>)</span><span id="b562" class="kf kg hi jw b fi kl ki l kj kk">string_flag(<br/>    name = "foo",<br/>    build_setting_default = "42",<br/>)</span></pre><p id="e4e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这添加了一个<code class="du jt ju jv jw b">define_from_flag</code>的实例作为我们<code class="du jt ju jv jw b">cc_binary</code>的依赖项。因为定义从库传播到目标依赖于那些库，这将自动添加一个<code class="du jt ju jv jw b">-DFLAG=”42"</code>到编译器命令行。</p><p id="c098" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们需要弄清楚如何更改构建设置值。幸运的是，这很容易—可以使用bazel命令行来更改标志值:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="da52" class="kf kg hi jw b fi kh ki l kj kk">$ bazel run:test --//foo=hello<br/>...<br/>hello</span></pre><p id="8d6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过在<code class="du jt ju jv jw b">.bazelrc</code>中定义一个别名来使其更加用户友好:</p><pre class="jx jy jz ka fd kb jw kc kd aw ke bi"><span id="f9a1" class="kf kg hi jw b fi kh ki l kj kk"># .bazelrc<br/>build --flag_alias=foo=//:foo</span></pre><p id="7620" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个例子的所有代码都在github <a class="ae iu" href="https://github.com/dfr/fun_with_flags.git" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>