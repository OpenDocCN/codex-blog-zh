<html>
<head>
<title>I ❤ Ember.js — Templates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一.❤·恩伯. js——模板</h1>
<blockquote>原文：<a href="https://medium.com/codex/i-ember-js-templates-bf01190ce4c?source=collection_archive---------9-----------------------#2021-01-21">https://medium.com/codex/i-ember-js-templates-bf01190ce4c?source=collection_archive---------9-----------------------#2021-01-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="8bc6" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><div class=""><h2 id="de7a" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">在Ember中单独编写表示代码是非常强大的，原因如下。</h2></div><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="ab fe cl jl"><img src="../Images/be990de658472bb6fdf6f612a4023d16.png" data-original-src="https://miro.medium.com/v2/format:webp/1*xEOLl2-qU5fQCzkzEybNag.jpeg"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">保罗·斯科鲁普斯卡斯在<a class="ae js" href="https://unsplash.com/s/photos/lens?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="70f2" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">我❤ Ember.js是一个系列，在这里我谈论如何使用Ember以及为什么你应该在你的项目中使用它。我使用Ember已经有几年了，它已经成为我最喜欢的创建强大的web应用程序的工具，而且非常简单！</p><p id="7171" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">当我在做软件的时候，我很容易因为脑子里一次装了太多东西而不知所措。这是因为构建前端应用程序是一项复杂的任务！突然，开发人员需要编写代码来呈现可视元素，将这些元素绑定到数据，并使其交互以执行业务/应用程序逻辑。我使用❤ Ember.js的一个原因是因为它将你的表示代码分成模板文件，这样当你使用模板时，你就可以专注于应用程序的表示方面。此外，Handlebars允许我们引入逻辑，而不影响代码的语义。</p><h1 id="34b3" class="kq kr hi bd ks kt ku kv kw kx ky kz la ix lb iy lc ja ld jb le jd lf je lg lh bi translated">快速回顾</h1><p id="6f13" class="pw-post-body-paragraph jt ju hi jv b jw li is jy jz lj iv kb kc lk ke kf kg ll ki kj kk lm km kn ko hb bi translated">模板可以访问来自后台类(如控制器)的数据。该类中定义的任何属性都可以在相应的模板中呈现。给定一个控制器:</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="71f1" class="ls kr hi lo b fi lt lu l lv lw">class MyController extends Controller {<br/>  favoriteAnimal = 'dog'<br/>}</span></pre><p id="727c" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">我们可以在模板中使用属性，如下所示:</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="da99" class="ls kr hi lo b fi lt lu l lv lw">&lt;div&gt;<br/>  &lt;p&gt;My favorite animal: {{this.favoriteAnimal}}&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="e41f" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">我们还没有深入讨论组件，但是如果这是一个组件的模板，唯一的区别就是如果<code class="du lx ly lz lo b">favoriteAnimal</code>被传入，它将被一个<code class="du lx ly lz lo b">@</code>符号访问:</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="f51e" class="ls kr hi lo b fi lt lu l lv lw">&lt;div&gt;<br/>  &lt;p&gt;My favorite animal: {{@favoriteAnimal}}&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="15ea" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">很简单，对吧？这很像React中的JSX，除了我们不能在那些弯弯曲曲的括号中写Javascript，我们必须使用已经定义的变量。</p><h1 id="7515" class="kq kr hi bd ks kt ku kv kw kx ky kz la ix lb iy lc ja ld jb le jd lf je lg lh bi translated">助手</h1><p id="723e" class="pw-post-body-paragraph jt ju hi jv b jw li is jy jz lj iv kb kc lk ke kf kg ll ki kj kk lm km kn ko hb bi translated">尽管我们不能在模板中直接编写Javascript，但是我们可以访问<strong class="jv hs">助手</strong>。帮助器允许我们以模板代码保持不变的方式在模板中实现逻辑</p><ul class=""><li id="31f2" class="ma mb hi jv b jw jx jz ka kc mc kg md kk me ko mf mg mh mi bi translated"><strong class="jv hs">整齐的</strong>，</li><li id="6d46" class="ma mb hi jv b jw mj jz mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><strong class="jv hs">表象</strong>，以及</li><li id="c636" class="ma mb hi jv b jw mj jz mk kc ml kg mm kk mn ko mf mg mh mi bi translated"><strong class="jv hs">语义</strong></li></ul><p id="6b32" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">想象一下，我们必须迭代一个<code class="du lx ly lz lo b">users</code>数组，每个用户都有一个流行语，如果他们很有名，我们希望有条件地呈现出来(我知道，这是一个奇怪的场景)。下面是我们如何在React渲染函数中实现它:</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="e7a4" class="ls kr hi lo b fi lt lu l lv lw">render() {<br/>  const { users } = this.props;</span><span id="29fc" class="ls kr hi lo b fi mo lu l lv lw">return (<br/>    &lt;div&gt;<br/>      {<br/>        users.map(user =&gt; {<br/>          if (user.isFamous) {<br/>            return &lt;h1&gt;{user.catchPhrase}&lt;/h1&gt;;<br/>          }<br/>          <br/>          return &lt;p&gt;Hello!&lt;/p&gt;;<br/>        })<br/>      }<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="796d" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">这还不算太糟！它有适当的间距，并且很容易理解这个函数将呈现什么。现在让我们将它与我们在Ember中编写的模板进行比较:</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="c2da" class="ls kr hi lo b fi lt lu l lv lw">&lt;div&gt;<br/>  {{#each @users as |user|}}</span><span id="83b9" class="ls kr hi lo b fi mo lu l lv lw">{{#if user.isFamous}}<br/>      &lt;h1&gt;{{user.catchPhrase}}&lt;/h1&gt;<br/>    {{else}}<br/>      &lt;p&gt;Hello!&lt;/p&gt;<br/>    {{/if}}</span><span id="b5de" class="ls kr hi lo b fi mo lu l lv lw">{{/each}}<br/>&lt;/div&gt;</span></pre><p id="ec64" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">现在我可能有偏见，但我认为Ember模板代码更容易理解(也更容易编写)！原因如下:</p><ul class=""><li id="d50f" class="ma mb hi jv b jw jx jz ka kc mc kg md kk me ko mf mg mh mi bi translated">帮助器将逻辑压缩成简单的操作符，如<code class="du lx ly lz lo b">each</code>，所以我们不需要弄乱代码来执行常见的操作，如迭代数组。</li><li id="88bd" class="ma mb hi jv b jw mj jz mk kc ml kg mm kk mn ko mf mg mh mi bi translated">模板中唯一的逻辑与我们将呈现给用户的内容有关。这里没有任何关于我们如何获得<code class="du lx ly lz lo b">@users</code>属性的内容。这让我们保持专注。</li><li id="2b93" class="ma mb hi jv b jw mj jz mk kc ml kg mm kk mn ko mf mg mh mi bi translated">模板文件更容易阅读。当您必须在同一个空间内解析HTML和Javascript算法之间切换时，肯定会发生小的上下文切换。车把上使用的语言是自然的，让我们保持一种表象的心态。</li></ul><p id="d1b4" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">即使手柄限制了我们可以实现的逻辑，我们仍然可以做很多很酷的事情。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es mp"><img src="../Images/23702b117d524f512ef5c6b254c764c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BhNLevFRu2bLdXyK6fL27A.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">照片由<a class="ae js" href="https://unsplash.com/@joshrako?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Josh Rakower </a>在<a class="ae js" href="https://unsplash.com/s/photos/loop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="59dd" class="kq kr hi bd ks kt ku kv kw kx ky kz la ix lb iy lc ja ld jb le jd lf je lg lh bi translated">循环&amp;循环</h1><p id="9fa0" class="pw-post-body-paragraph jt ju hi jv b jw li is jy jz lj iv kb kc lk ke kf kg ll ki kj kk lm km kn ko hb bi translated">我们已经看到了如何迭代数组，但是<code class="du lx ly lz lo b">each</code>助手可以为我们做更多的事情！也许您需要呈现每个条目的索引:</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="597d" class="ls kr hi lo b fi lt lu l lv lw">&lt;div&gt;<br/>  &lt;h1&gt;Guest List&lt;/h1&gt;</span><span id="fe7b" class="ls kr hi lo b fi mo lu l lv lw">{{#each @guests as |guest index|}}<br/>    &lt;p&gt;{{guest.fullName}} is number {{index}} in the list.&lt;/p&gt;<br/>  {{/each}}<br/>&lt;/div&gt;</span></pre><p id="5440" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">或者，如果数组为空，您可能希望使用<code class="du lx ly lz lo b">else</code>呈现不同的内容:</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="e82d" class="ls kr hi lo b fi lt lu l lv lw">&lt;div&gt;<br/>  {{#each @blogPosts as |post|}}<br/>    &lt;p&gt;{{post.content}}&lt;/p&gt;<br/>  {{else}}<br/>    &lt;h1&gt;You haven't written anything yet!&lt;/h1&gt;<br/>  {{/each}}<br/>&lt;/div&gt;</span></pre><h1 id="47a1" class="kq kr hi bd ks kt ku kv kw kx ky kz la ix lb iy lc ja ld jb le jd lf je lg lh bi translated">做点什么！</h1><p id="4d30" class="pw-post-body-paragraph jt ju hi jv b jw li is jy jz lj iv kb kc lk ke kf kg ll ki kj kk lm km kn ko hb bi translated">您的模板很可能需要是交互式的，并且您可以轻松地调用组件或控制器中定义的函数:</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="ee29" class="ls kr hi lo b fi lt lu l lv lw">&lt;!-- template.hbs --&gt;</span><span id="af0a" class="ls kr hi lo b fi mo lu l lv lw">&lt;div&gt;<br/>  {{#each @artists as |artist|}}<br/>    &lt;button {{on 'click' this.likeArtist artist}}&gt;Like&lt;/button&gt;<br/>  {{/each}}<br/>&lt;/div&gt;</span></pre><p id="0ea1" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">其中<code class="du lx ly lz lo b">likeArtist</code>是在组件中定义的函数，如下所示:</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="66dd" class="ls kr hi lo b fi lt lu l lv lw">// component.js</span><span id="f3cd" class="ls kr hi lo b fi mo lu l lv lw">class ArtistList extends Component {<br/>  @action<br/>  likeArtist(artist) {<br/>    // perform the 'like' functionality<br/>  }<br/>}</span></pre><h1 id="76e8" class="kq kr hi bd ks kt ku kv kw kx ky kz la ix lb iy lc ja ld jb le jd lf je lg lh bi translated">自定义助手</h1><p id="81e3" class="pw-post-body-paragraph jt ju hi jv b jw li is jy jz lj iv kb kc lk ke kf kg ll ki kj kk lm km kn ko hb bi translated">你甚至可以写你自己的助手！您可以使用ember-cli创建一个新的助手，然后在模板中使用它。例如，跑步后</p><p id="6022" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated"><code class="du lx ly lz lo b">ember g helper hotdog</code></p><p id="09c3" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">您将获得一个可以编辑的新帮助文件:</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="2a67" class="ls kr hi lo b fi lt lu l lv lw">// helpers/hotdog.js</span><span id="38ed" class="ls kr hi lo b fi mo lu l lv lw">function hotdog(testString) {<br/>  if (testString === 'hot dog') {<br/>    return 'hot dog';<br/>  } else {<br/>    return 'not hot dog';<br/>  }<br/>}</span></pre><p id="a525" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">然后你可以开始在模板中使用你的新助手了！</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="f97a" class="ls kr hi lo b fi lt lu l lv lw">&lt;div&gt;<br/>  {{#each testSubjects as |subject|}}<br/>    &lt;p&gt;Subject Status: {{hotdog subject}}&lt;/p&gt;<br/>  {{/each}}<br/>&lt;/div&gt;</span></pre><h1 id="04ba" class="kq kr hi bd ks kt ku kv kw kx ky kz la ix lb iy lc ja ld jb le jd lf je lg lh bi translated">子组件</h1><p id="f6ef" class="pw-post-body-paragraph jt ju hi jv b jw li is jy jz lj iv kb kc lk ke kf kg ll ki kj kk lm km kn ko hb bi translated">我留了一个超级酷的东西你可以留到最后做。假设您有一个article组件，您已经将它分解为子组件，用于呈现标题、正文和页脚等内容。您可以在模板中使用它们，如下所示:</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="9eaa" class="ls kr hi lo b fi lt lu l lv lw">&lt;div&gt;<br/>  &lt;ArticleHeader @title="Isn't Ember Great?" /&gt;</span><span id="5d67" class="ls kr hi lo b fi mo lu l lv lw">  &lt;ArticleBody @content="Yes it is." /&gt;</span><span id="af72" class="ls kr hi lo b fi mo lu l lv lw">  &lt;ArticleFooter @author="Evan Martinez" /&gt;<br/>&lt;/div&gt;</span></pre><p id="145e" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">这很好，但是Ember提供了一个简洁的捷径。如果重新排列文件，使子组件都在同一个文件夹中，如下所示:</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es mu"><img src="../Images/092b16d83a18fe4d52cbf601f9ce0ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*deaYa6wGXditHo-GLnCAzQ.png"/></div></figure><p id="f4a0" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">然后Ember将让您以更直观的方式访问它们:</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="adcc" class="ls kr hi lo b fi lt lu l lv lw">&lt;div&gt;<br/>  &lt;Article::Header @title="Isn't Ember Great?" /&gt;</span><span id="8144" class="ls kr hi lo b fi mo lu l lv lw">  &lt;Article::Body @content="Yes it is." /&gt;</span><span id="089a" class="ls kr hi lo b fi mo lu l lv lw">  &lt;Article::Footer @author="Evan Martinez" /&gt;<br/>&lt;/div&gt;</span></pre><p id="3cf5" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">我觉得这太棒了。</p><h1 id="359a" class="kq kr hi bd ks kt ku kv kw kx ky kz la ix lb iy lc ja ld jb le jd lf je lg lh bi translated">模板就是方法</h1><p id="d86d" class="pw-post-body-paragraph jt ju hi jv b jw li is jy jz lj iv kb kc lk ke kf kg ll ki kj kk lm km kn ko hb bi translated">在Ember中实现应用程序的表示层非常容易。这篇文章代码有点多，但是希望手柄的简单性使它容易理解。此外，我们只是触及了Ember开箱即用的所有内置助手的表面！他们的共同点是语言自然、整洁，注重表达逻辑。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es mv"><img src="../Images/9c17c4a9207135ca62d8b3a51cb393ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWeBgjP36-D_YkDYxiJp2w.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">照片由<a class="ae js" href="https://unsplash.com/@joshrako?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">乔希·拉科尔</a>在<a class="ae js" href="https://unsplash.com/s/photos/cool?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="cf0d" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">为了更进一步，这里有一个更复杂的组件示例:</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="afdb" class="ls kr hi lo b fi lt lu l lv lw">&lt;!-- the parent controller template --&gt;</span><span id="6aab" class="ls kr hi lo b fi mo lu l lv lw">&lt;div&gt;<br/>  &lt;UserTable<br/>    @users={{this.users}}<br/>    @columns={{this.columns}}<br/>  /&gt;<br/>&lt;/div&gt;</span></pre><p id="f4fe" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">这里是<code class="du lx ly lz lo b">UserTable</code>组件:</p><pre class="jg jh ji jj fd ln lo lp lq aw lr bi"><span id="a756" class="ls kr hi lo b fi lt lu l lv lw">&lt;!-- component template, UserTable.hbs --&gt;</span><span id="b9c9" class="ls kr hi lo b fi mo lu l lv lw">&lt;table&gt;<br/>  &lt;tr&gt;<br/>    {{#each @columns as |column|}}<br/>      &lt;td&gt;{{column.displayName}}&lt;/td&gt;<br/>    {{/each}}<br/>  &lt;/tr&gt;</span><span id="6063" class="ls kr hi lo b fi mo lu l lv lw">{{#each @users as |user|}}<br/>    &lt;tr&gt;<br/>      {{#each @columns as |column|}}<br/>        &lt;td&gt;{{get user column.propertyKey}}&lt;/td&gt;<br/>      {{/each}}<br/>    &lt;/tr&gt;<br/>  {{/each}}<br/>&lt;/table&gt;</span></pre><p id="c39c" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated">如果组件名没有泄露，您能告诉我组件模板将呈现什么吗？这是一个真正的问题，对于任何刚接触Ember的开发者来说，所以请留下评论。如果还是胡言乱语也不要难受。下次见！</p><p id="f7c8" class="pw-post-body-paragraph jt ju hi jv b jw jx is jy jz ka iv kb kc kd ke kf kg kh ki kj kk kl km kn ko hb bi translated"><em class="kp">此页面/产品/etc与Ember项目无关。Ember是Tilde公司的商标</em></p></div></div>    
</body>
</html>