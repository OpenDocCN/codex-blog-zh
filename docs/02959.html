<html>
<head>
<title>Cryptocurrency Development in Python Using Blockchain Lists (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用区块链列表在Python中开发加密货币(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/cryptocurrency-development-in-python-using-blockchain-lists-part-1-495c7f77472c?source=collection_archive---------22-----------------------#2021-08-12">https://medium.com/codex/cryptocurrency-development-in-python-using-blockchain-lists-part-1-495c7f77472c?source=collection_archive---------22-----------------------#2021-08-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/f614d46135117e6f2d392ac81e7b186d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99pSuVYWsxEWctBoDFlIzQ.jpeg"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">图片来自Pixabay的WorldSpectrum</figcaption></figure><p id="73f2" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">随着区块链和加密货币的发展在过去几年中持续领先，越来越多的人希望开发自己的加密货币。这背后的原因各不相同；一个独特的创业公司的财务灵活性，奖励用户使用自己的新推出的软件，以及实践开发区块链的能力。</p><p id="66c6" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">不管什么原因，本文将描述开发自己的加密货币的初始步骤。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="74f1" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">Python是一种动态类型语言；因此，这意味着变量只在运行时确定，而不是静态类型化。此外，Python是一种强类型语言，因为所有变量在执行操作时都有一个类型——即使用户没有输入所述类型。</p><p id="6c32" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这是Python简单性的一个例子。Python允许用一个简单的函数执行许多任务。因此，Python是首次区块链开发的推荐语言。</p><p id="1a55" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">然而，对于更开发的项目，我推荐使用C++。与Python相比，C++允许操作指针和访问指针，这对于开发更复杂的链表是必不可少的。</p><p id="e354" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">然而，由于这是一个简单的介绍，Python将足够好地工作。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="e356" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在本文中，正在编写的代码将在本地执行。对于未来的文章，区块链将必须登录到一个系统或通过云，以允许其他人访问上述加密货币。</p><p id="e6bb" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">通过这样做，其他人将能够开采货币并将其添加到当前的区块链中。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="95bf" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">代码将写在两个文件之间:</p><p id="aa21" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">cryptoFunctions.py</p><p id="f4d0" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">mainBlock.py</p><p id="e084" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">mainBlock.py文件有两个类:</p><ul class=""><li id="b806" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated">块值</li><li id="9d6f" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">主要的</li></ul><p id="75db" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">cryptoFunctions.py文件没有类，但有多个定义。</p><p id="ee5c" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">其中包括以下内容:</p><ul class=""><li id="eb2a" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated">getPreviousHash()</li><li id="1221" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">返回块()</li><li id="22a0" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">setHash()</li><li id="b5ac" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">runData()</li><li id="cdaf" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">我的()</li><li id="a407" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">newTransactionData()</li><li id="5897" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">验证链()</li></ul></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="4c7d" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">我们要做的第一件事是导入必要的库和文件。</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="b56a" class="kt ku hi kp b fi kv kw l kx ky">import time<br/>import CryptoFunctions</span></pre><p id="e493" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">时间导入用于块创建的时间戳。我们还必须导入加密函数，这样我们就可以使用该文件中包含的定义。</p><p id="a634" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">接下来，我们需要初始化全局变量。</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="5647" class="kt ku hi kp b fi kv kw l kx ky">diff = 3<br/>nonce = 0<br/>number = 1<br/>arrayOfValues = []<br/>currentArray = []<br/>currentIndex = 0<br/>previous_hash = "0" *64</span></pre><p id="3d7c" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">上面列出的主要变量——diff——代表短语“难度”困难在于区块链试图寻找的散列偏移量处的0的数量。</p><p id="bbf7" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">当试图找到必要的散列时，数据将由停滞数据组成，例如挖掘开始的当前时间以及所述加密货币的发送者和接收者。</p><p id="9728" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">然而，能够继续操纵加密的是随机数的迭代。如果nonce发生更改，块的整体哈希将会更改。因此，随机数将需要递增，直到该块满足所需的难度。对于每个块，nonce值将从0开始，这在全局变量中声明。</p><p id="1ea1" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">第三个全局变量——number——表示当前块。</p><p id="5697" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">其他四个全局变量只是占位符。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="3ca4" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">下一组全局变量将表示本地设置的“事务信息”。</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="6ddd" class="kt ku hi kp b fi kv kw l kx ky">senderData = ["Sender_One", "Sender_Two", "Sender_Three", "Sender_Four", "Sender_Five"]</span><span id="a502" class="kt ku hi kp b fi kz kw l kx ky">recipientData = ["Recieve_One", "Recieve_Two", "Recieve_Three", "Recieve_Four", "Recieve_Five"]</span><span id="8730" class="kt ku hi kp b fi kz kw l kx ky">amountData = ["1", "2", "3", "4", "5"]</span><span id="15ac" class="kt ku hi kp b fi kz kw l kx ky">transactionIndex = 0</span></pre><p id="b331" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">第一个全局变量表示“数据”,它将在本地表示通过加密货币发送的数据。这被表示为变量“senderData”</p><p id="fa21" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">类似地，第二个变量— recipientData —保存本地设置的数据，模拟“收件人数据”的真实示例</p><p id="fb0a" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">下一个变量是“amountData ”,它表示发送方和接收方之间发送的加密货币的可能数量。</p><p id="c018" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">最后，transactionIndex表示必须从哪里提取事务数据。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="32d2" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">接下来，让我们初始化第二个文件CryptoFunctions.py。</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="39ad" class="kt ku hi kp b fi kv kw l kx ky">from hashlib import sha256</span></pre><p id="7cd1" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">我们将应用的加密区块链的方法是sha256，这是一种行业标准的加密方法。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="5602" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">接下来，我们将通过编写BlockValue类继续开发主文件。</p><p id="7512" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">BlockValue类将有两个定义，“__init__”和“new_data”</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="2d2d" class="kt ku hi kp b fi kv kw l kx ky">class BlockValue:</span><span id="e0cb" class="kt ku hi kp b fi kz kw l kx ky">def __init__()</span><span id="f944" class="kt ku hi kp b fi kz kw l kx ky">def new_data()</span></pre><p id="be64" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">每个函数的参数如下。</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="51a3" class="kt ku hi kp b fi kv kw l kx ky">def __init__(self, index, transactions, timestamp, previous_hash, number, transactionIndexUpdated):</span><span id="2ab6" class="kt ku hi kp b fi kz kw l kx ky">def new_data(self):</span></pre><ul class=""><li id="06b3" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated">index参数将用于跟踪更大的数组“arrayOfValues”的索引</li><li id="ad6c" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">事务是一个占位符，但它是一个数组，由每个块的当前发送者、接收者和数字数据组成。</li><li id="7f66" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">时间戳参数将用于标识形成的时间。</li><li id="c36b" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">previous_hash参数用于验证连续链。下一个链的previous_chain应该是与当前块hash相同的hash。</li><li id="8b67" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">number参数用于标识当前被引用的块，不是根据索引值，而是根据数字。</li><li id="7b06" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">transactionIndexUpdated参数用于标识从哪个索引中提取事务数据。</li></ul></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="a2a1" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在__init__定义中，代码将设置如下:</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="5f54" class="kt ku hi kp b fi kv kw l kx ky">def __init__(self, index, transactions, timestamp, previous_hash, number, transactionIndexUpdated):</span><span id="8159" class="kt ku hi kp b fi kz kw l kx ky">self.index = index<br/>  self.transactions = transactions <br/>  self.timestamp = timestamp<br/>  self.previous_hash = previous_hash<br/>  self.nonce = 0<br/>  self.number = number<br/>  self.transactionIndex = transactionIndexUpdated</span></pre><p id="31e1" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在main函数中，我们将传入这些基于自身的变量，以便在以后需要使用它们时可以提取它们。</p><p id="94ac" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">BlockValue类的第二部分— new_data() —将表示如下:</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="f600" class="kt ku hi kp b fi kv kw l kx ky">def new_data(self):<br/>  timestamp = time.time()<br/>  transactions = CryptoFunctions.newTransactionData(    <br/>  senderData[self.transactionIndex],     <br/>  recipientData[self.transactionIndex],<br/>  amountData[self.transactionIndex], [])</span><span id="7419" class="kt ku hi kp b fi kz kw l kx ky">currentArray, number = CryptoFunctions.runData(self.index, <br/>  transactions, timestamp, previous_hash, nonce, self.number,     <br/>  arrayOfValues,diff)<br/>  <br/>  return currentArray, number</span></pre><ul class=""><li id="bc80" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated">时间戳函数将用于检索块完全公式化的时间。</li><li id="529d" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">事务将使用“newTransactionData”函数从senderData、recipientData和amountData中检索当前事务数据。</li></ul></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="4eaa" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">现在，我们需要检查CryptoFunctions文件中提供的各种函数。</p><p id="7c0b" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">第一个函数是“getPreviousHash(currentIndex，arrayOfValues)”，它接受参数“currentIndex”和“arrayOfValues”。</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="7c38" class="kt ku hi kp b fi kv kw l kx ky">def getPreviousHash(currentIndex, arrayOfValues):<br/>   if (currentIndex == 0):<br/>      return "0" * 64<br/>   else:<br/>      array = arrayOfValues[currentIndex - 1]<br/>      return array[1]</span></pre><p id="ecd7" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">如果currentIndex等于0，这意味着没有前一个块，因此返回初始块为“0”* 64。所有散列都用64个数字初始化。</p><p id="8bbe" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">如果存在前一个块，则可以在较大的“arrayOfValues”内的前一个块中的索引1处检索前一个散列这是因为哈希值存储在索引1处。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="3b65" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">第二个函数将返回当前块。函数returnBlock将接受两个参数:arrayIndex和arrayOfValues。</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="f6a9" class="kt ku hi kp b fi kv kw l kx ky">def returnBlock(arrayIndex, arrayOfValues):<br/>   arraySubsection = arrayOfValues[arrayIndex]     <br/>   newValue =  ("Block Number: " + str(arraySubsection[0]) +      <br/>   "\nHash: " + str(arraySubsection[1]) + "\nPrevious: "                <br/>   + str(arraySubsection[2]) + "\nTransactional Data: " +  <br/>   str(arraySubsection[3]) + "\nNonce: " + <br/>   str(arraySubsection[4]) + "\nTimestamp: " +      <br/>   str(arraySubsection[5]) + "\n")<br/>   return (newValue)</span></pre><p id="12e7" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">该函数用于返回每个块中的各种值。每个块以索引0处的块号组织，散列将在索引1处初始化，先前的散列将在索引2处陈述，交易数据(发送者、接收者和金额)将在索引3处陈述，随机数值将在索引4处初始化，并且块形成的时间戳将在索引5处呈现。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="24de" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">将要声明的第三个函数将用于返回接受五个参数的哈希值——事务、时间戳、previous_hash、nonce、<br/>number——它将被初始化为“*args”</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="fb78" class="kt ku hi kp b fi kv kw l kx ky">def setHash(*args):<br/>   hashing_text = ""<br/>   hashing = sha256()</span><span id="0880" class="kt ku hi kp b fi kz kw l kx ky">for arg in args: <br/>      hashing_text += str(arg)</span><span id="31b2" class="kt ku hi kp b fi kz kw l kx ky">hashing.update(hashing_text.encode('utf-8'))<br/>   return hashing.hexdigest()</span></pre><p id="8706" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这个函数要做的第一件事是初始化sha256()加密方法。然后，通过迭代，它将加密通过参数推送的内容。</p><p id="841d" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在结果散列值被更新之后，加密将被返回。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="c011" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">第四个函数将对正在开发的货币进行挖掘。哈希很可能不适合这个难度。因此，必须使用mine函数重复挖掘它。</p><p id="235b" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">接受的参数将是事务、nonce、hash、number、previous_hash、timestamp、currentIndex和diff。</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="3f66" class="kt ku hi kp b fi kv kw l kx ky">def mine(transactions, nonce, hash, number, previous_hash, timestamp, currentIndex, diff):</span><span id="fc34" class="kt ku hi kp b fi kz kw l kx ky">while (hash[:diff] != "0" * diff):<br/>      nonce += 1<br/>      hash = setHash(transactions,timestamp,previous_hash, nonce,    <br/>      number)</span><span id="dc5a" class="kt ku hi kp b fi kz kw l kx ky">return (nonce, hash)</span></pre><p id="9ddc" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">如前所述，可以增加nonce值来进一步改变散列以满足必要的难度。这就是在这个功能中发生的事情。</p><p id="c65f" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">一旦遇到困难，就会返回适当的nonce和hash值。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="9a1e" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">将使用的第五个函数是将当前发送者、接收者和数据量设置为一个单一值。</p><p id="b8d6" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">函数newTransactionData将具有参数sender、recipient、amount和值。</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="18f9" class="kt ku hi kp b fi kv kw l kx ky">def newTransactionData(sender, recipient, amount, values):<br/>   <br/>   values.extend([sender, recipient, amount])</span><span id="e675" class="kt ku hi kp b fi kz kw l kx ky">return values</span></pre></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="88f6" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">第六个函数用于验证链内的块值。这个简单的函数将仅仅用于检查当前散列是否等于下一个块的先前散列。</p><p id="7bdf" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">将采用的参数是arrayOfValues和lengthData。</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="f2a2" class="kt ku hi kp b fi kv kw l kx ky">def verifyChain (arrayOfValues, lengthData):<br/>   if (lengthData &gt; 1):        <br/>      for x in range(lengthData-1):            <br/>          currentArray = arrayOfValues[x]            <br/>          secondaryArray = arrayOfValues[x+1]            <br/>          if (currentArray[1] == secondaryArray[2]):                    <br/>             continue            <br/>          else:                <br/>             return(False)     <br/>   return (True)</span></pre></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="8fd1" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在CryptoFunctions文件中，将要执行的主要函数是runData。该函数将接受参数currentIndex、transactions、timestamp、previous_hash、nonce、number、arrayOfValues和diff。</p><p id="d26f" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">此函数用于组织各种变量，这些变量将用于制定arrayOfValues。此外，该函数将用于组织散列和挖掘方法。</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="50d5" class="kt ku hi kp b fi kv kw l kx ky">def runData(currentIndex, transactions, timestamp, previous_hash, nonce, number, arrayOfValues, diff):</span><span id="9326" class="kt ku hi kp b fi kz kw l kx ky">previous_hash = getPreviousHash(currentIndex, arrayOfValues)</span><span id="4f5d" class="kt ku hi kp b fi kz kw l kx ky">hash = setHash(transactions, timestamp, previous_hash, nonce, <br/>     number)</span><span id="e45b" class="kt ku hi kp b fi kz kw l kx ky">nonce, hash = mine(transactions, nonce, hash, number,   <br/>     previous_hash, timestamp, currentIndex, diff)</span><span id="d728" class="kt ku hi kp b fi kz kw l kx ky">arrayOfValues = [number, hash, previous_hash, transactions,     <br/>     nonce, timestamp]</span><span id="b7c2" class="kt ku hi kp b fi kz kw l kx ky">number += 1</span><span id="6007" class="kt ku hi kp b fi kz kw l kx ky">return arrayOfValues, number</span></pre><ul class=""><li id="7015" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated">如BlockValue类所示，在检索事务数据后，BlockValue函数将使用所有有效参数执行“runData”。</li><li id="253d" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">在这个定义中，出现的第一个方法是使用getPreviousHash方法提取previous_hash数据。</li><li id="0d41" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">然后，使用得到的有效参数检索哈希。</li><li id="556c" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">哈希很可能不适合这个难度。因此，必须使用mine函数重复挖掘它。</li><li id="2252" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">在检索到previous_hash、nonce和hash值之后，可以更新arrayOfValues。</li><li id="2e96" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">对于先前的迭代，也应该更新块号。</li><li id="245f" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">最后，返回arrayOfValues和更新后的数字。</li></ul></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="ba4e" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">现在，让我们完成内瓦林娜的档案。</p><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="37d9" class="kt ku hi kp b fi kv kw l kx ky">class main:</span><span id="a1cc" class="kt ku hi kp b fi kz kw l kx ky">for value in range(len(senderData)):<br/>     <br/>      genisisBlock = BlockValue(currentIndex, [], time.time(), <br/>      "0" * 64, number, transactionIndex)<br/>      <br/>      currentArray, number = genisisBlock.new_data()</span><span id="68d3" class="kt ku hi kp b fi kz kw l kx ky">arrayOfValues.append(currentArray)</span><span id="fe98" class="kt ku hi kp b fi kz kw l kx ky">print(CryptoFunctions.returnBlock(currentIndex,  <br/>      arrayOfValues))</span><span id="207b" class="kt ku hi kp b fi kz kw l kx ky">currentIndex += 1</span><span id="2215" class="kt ku hi kp b fi kz kw l kx ky">transactionIndex += 1</span><span id="69f4" class="kt ku hi kp b fi kz kw l kx ky">print(CryptoFunctions.verifyChain(arrayOfValues,   <br/>   len(senderData)))</span></pre><ul class=""><li id="210b" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated">在主类中，我们将基于senderData范围内的值的数量进行迭代。</li><li id="b292" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">没有任何修改的主块将被设置在genisisBlock的条件下。</li><li id="67e4" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">arrayOfValues将追加currentArray以构成列表集合。</li><li id="a4d0" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">在每次迭代结束时，打印当前数组。</li></ul><pre class="in io ip iq fd ko kp kq kr aw ks bi"><span id="7478" class="kt ku hi kp b fi kv kw l kx ky">if __name__ == '__main__':<br/>   main()</span></pre><p id="002e" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在开始时添加主初始化。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="3ac1" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">结论:</p><p id="cbd9" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">截至目前，这个程序允许我们运行一个本地制定的加密货币程序。因此，块可以被挖掘，并且所有需要的加密将被陈述。</p><p id="62f9" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">然而，这个本地运行的程序之外的用户将无法挖掘货币。这将在未来的更新中进一步解释。</p><p id="69e9" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">到目前为止，您可以在GitHub的这个位置看到这个程序:</p><p id="790f" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated"><a class="ae la" href="https://github.com/AliFakhry/Nevalinna" rel="noopener ugc nofollow" target="_blank">https://github.com/AliFakhry/Nevalinna</a></p></div></div>    
</body>
</html>