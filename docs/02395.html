<html>
<head>
<title>Pro Tips For Designing Robust React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计坚固React组件的专业技巧</h1>
<blockquote>原文：<a href="https://medium.com/codex/pro-tips-for-designing-robust-react-components-c3eaf9cd7ae4?source=collection_archive---------7-----------------------#2021-07-18">https://medium.com/codex/pro-tips-for-designing-robust-react-components-c3eaf9cd7ae4?source=collection_archive---------7-----------------------#2021-07-18</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><div class=""><h2 id="afe0" class="pw-subtitle-paragraph ig hi hj bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dy translated">“如何让我的React应用程序更具响应性和可维护性？”</h2></div><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et iy"><img src="../Images/d72999e7e7f2d1e606152165c2a6fa26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-KErrUn2eIHqayfGNt_UA.jpeg"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">由<a class="ae jo" href="https://unsplash.com/@les_photos_de_raph?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拉斐尔·比斯卡尔迪</a>在<a class="ae jo" href="https://unsplash.com/s/photos/atoms?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="fe80" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">众所周知，React组件现在是作为函数而不是类来编写的。除此之外，它允许我们免除绑定方法和<code class="dv kl km kn ko b">this</code>道具。但是对于这两种方法，您最终都必须编写一个<code class="dv kl km kn ko b">render</code>方法，以JSX的形式返回DOM的一部分。</p><p id="c350" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">它们返回DOM的一部分，并不生成一个全新的，因为DOM更新起来相当昂贵，所以开发人员尽量减少DOM更新的次数。</p><p id="b1b5" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">因此，大多数web开发人员将组件呈现的数量减少到最小，以减少客户端浏览器和服务器的负载。</p><p id="cd0d" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">React组件的另一个重要需求是它们能够相当快速地更新它们的UI。这可以防止用户在应用前端进行不必要的等待，并改善用户体验。</p><p id="96db" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">最后，当您的组件可重用时，它会有所帮助。您不仅可以避免两次编写相同的代码，从而满足DRY(不要重复自己)原则，还可以确信可重用的独立组件的每个实例都将进行最少次数的重新呈现。</p><p id="b522" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">在这篇文章中，以及本系列接下来的几篇文章中，我将与您分享一些减少web应用程序渲染次数的技巧。</p><h1 id="e57b" class="kp kq hj bd kr ks kt ku kv kw kx ky kz ip la iq lb is lc it ld iv le iw lf lg bi translated">尝试对应用程序进行分区，使每个组件都独立于其他组件</h1><p id="a27f" class="pw-post-body-paragraph jp jq hj jr b js lh ik ju jv li in jx jy lj ka kb kc lk ke kf kg ll ki kj kk hc bi translated">原因是，如果您的组件是相互依赖的，那么一个组件中的每个状态更新可能需要另一个组件中的状态更新。这将导致重新渲染，因此当您进行更高级别的组件更新时，您将会多次渲染。理想情况下，您希望在每次高级更新时更新一次组件，但是当然，这并不总是可能的。</p><p id="5d23" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">如果你试着以一种代表你的应用程序的UI布局的方式来划分每个组件，这将会有所帮助。例如，大多数应用程序都有一个带有按钮和链接的标题栏。因此，您应该将按钮组件包含在标题组件中的那个位置。</p><p id="ca51" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">您创建的每个组件都会增加整个应用程序的复杂性。您必须确保参数是正确的，并且返回的JSX是您所期望的，并且，在arrow或lambda函数的情况下，它们是按照一定的顺序定义的，这样一个函数就不会在文件中调用它上面的另一个这样的arrow或lambda函数。</p><p id="c5b3" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">尽量让组件的嵌套层次尽可能的扁平。尽管React更新DOM的方式确保了如果嵌套组件没有在父组件中被修改，它们就不会被重新呈现，但是将组件树变平的好处是它使您可以更容易地单独调试每个组件。</p><h2 id="4f42" class="lm kq hj bd kr ln lo lp kv lq lr ls kz jy lt lu lb kc lv lw ld kg lx ly lf lz bi translated">何时使用适当析构</h2><p id="a524" class="pw-post-body-paragraph jp jq hj jr b js lh ik ju jv li in jx jy lj ka kb kc lk ke kf kg ll ki kj kk hc bi translated">方法中的属性析构可以极大地减少属性变量名的长度——如果处理得当的话。首先，不建议同时析构多层属性(嵌套析构),因为您无法验证中间层属性中的数据，这是语义错误的来源。</p><p id="ce64" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">组件有几十个属性并不少见，所以当你编写功能组件时，仅仅是这些属性本身的拼写就会变得混乱。</p><p id="3ba3" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">当你的道具数量很少时，你应该一级一级的摧毁它们，就像这样:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="ma mb l"/></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">演职员表:<a class="ae jo" href="https://javascript.plainenglish.io/destructure-react-props-with-es6-object-destructuring-for-cleaner-code-3984453e484d" rel="noopener ugc nofollow" target="_blank">https://JavaScript . plain English . io/destruct-react-props-with-es6-object-destructing-for-cleaner-code-3984453 e484d</a></figcaption></figure><p id="84f5" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">这样可以避免编写像这样连续引用<code class="dv kl km kn ko b">props</code>的函数:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="ma mb l"/></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">演职员表:<a class="ae jo" href="https://javascript.plainenglish.io/destructure-react-props-with-es6-object-destructuring-for-cleaner-code-3984453e484d" rel="noopener ugc nofollow" target="_blank">https://JavaScript . plain English . io/destruct-react-props-with-es6-object-destructing-for-cleaner-code-3984453 e484d</a></figcaption></figure><div class="mc md fa fc me mf"><a href="https://javascript.plainenglish.io/destructure-react-props-with-es6-object-destructuring-for-cleaner-code-3984453e484d" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dx"><div class="mh ab mi cl cj mj"><h2 class="bd hk fj z dz mk eb ec ml ee eg hi bi translated">用ES6对象进行析构来获得更清晰的代码</h2><div class="mm l"><h3 class="bd b fj z dz mk eb ec ml ee eg dy translated">当您在React中为组件编写渲染函数时，它会接受一个包含属性的props对象…</h3></div><div class="mn l"><p class="bd b fq z dz mk eb ec ml ee eg dy translated">javascript.plainenglish.io</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt ji mf"/></div></div></a></div><p id="998a" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">以另一个组件为例，我们可以进行两种不同的析构赋值来深入分析属性，相当于嵌套析构:</p><figure class="iz ja jb jc fe jd"><div class="bz dz l di"><div class="ma mb l"/></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">演职员表:<a class="ae jo" href="https://stackoverflow.com/questions/60589914/destructuring-props-in-react" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/60589914/destructing-props-in-react</a></figcaption></figure><p id="6e11" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">除此之外，spread操作符非常适合包含析构变量的赋值的右边。</p></div><div class="ab cl mu mv gq mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hc hd he hf hg"><p id="b116" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">今天就到这里吧，伙计们。请继续关注下周的帖子，在那里我会写一些管理组件状态的专业技巧。另外，如果你有任何问题，请在下面的评论中告诉我。</p></div></div>    
</body>
</html>