<html>
<head>
<title>Process PostgreSQL Changes With Logical Replication And Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用逻辑复制和Ruby处理PostgreSQL更改</h1>
<blockquote>原文：<a href="https://medium.com/codex/process-postgresql-changes-with-logical-replication-and-ruby-a4454cac529a?source=collection_archive---------5-----------------------#2022-05-02">https://medium.com/codex/process-postgresql-changes-with-logical-replication-and-ruby-a4454cac529a?source=collection_archive---------5-----------------------#2022-05-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="089c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您是否尝试过将数据库活动日志发送到事件系统？获取最新的更改，以便您可以更好地管理您的缓存，甚至基于数据更改触发其他事件。</p><p id="883b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在具有<a class="ae jd" href="https://www.postgresql.org/docs/12/logicaldecoding.html" rel="noopener ugc nofollow" target="_blank">逻辑解码</a>特性的PostgreSQL中，每次数据库中发生变化时，您都可以很容易地获得最新的变化。在这里，我们将首先设置逻辑解码，然后创建一个脚本，将这些更改推送到Kafka、Redis或任何流处理平台，以供进一步使用。</p><h1 id="3e0c" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">数据库设置</h1><p id="75c3" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">现在我们要用docker建立一个PostgreSQL服务器。我假设你有使用docker和CLI的基本知识，你也可以阅读我的文章<a class="ae jd" href="https://faun.pub/tips-on-using-docker-5c19c8ad17a2" rel="noopener ugc nofollow" target="_blank">使用Docker </a>的技巧，这是我最常用的。</p><p id="5e58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们需要创建一个名为<code class="du kh ki kj kk b">Dockerfile-postgres</code>的docker文件来构建我们的PostgreSQL映像。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="5095" class="kt jf hi kk b fi ku kv l kw kx"># Dockerfile-postgres</span><span id="9044" class="kt jf hi kk b fi ky kv l kw kx">FROM postgres:12.3</span><span id="1a33" class="kt jf hi kk b fi ky kv l kw kx">RUN apt update &amp;&amp; apt install -y postgresql-12-wal2json postgresql-contrib</span></pre><p id="a779" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在使用PostgreSQL版本12.3，并安装我们稍后需要的包<code class="du kh ki kj kk b">wal2json</code>。</p><p id="37be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们用这些配置创建一个docker-compose文件，并启动数据库容器。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="6767" class="kt jf hi kk b fi ku kv l kw kx"># docker-compose.yml</span><span id="dc17" class="kt jf hi kk b fi ky kv l kw kx">version: '2'<br/>services:<br/>  db:<br/>    build:<br/>      context: .<br/>      dockerfile: Dockerfile-postgres<br/>    volumes:<br/>      - ./pgdata:/var/lib/postgresql/data<br/>      - ./stream:/stream<br/>    ports:<br/>      - 5555:5432<br/>    environment:<br/>      POSTGRES_PASSWORD: "123123"<br/>      POSTGRES_DB: "myworld"</span></pre><p id="0340" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果你运行<code class="du kh ki kj kk b">docker-compose up</code>，容器应该开始工作。</p><p id="a2bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是成功启动的容器日志。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="a97d" class="kt jf hi kk b fi ku kv l kw kx">db_1   | 2022-05-02 06:26:58.664 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432<br/>db_1   | 2022-05-02 06:26:58.664 UTC [1] LOG:  listening on IPv6 address "::", port 5432<br/>db_1   | 2022-05-02 06:26:58.667 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"<br/>db_1   | 2022-05-02 06:26:58.694 UTC [26] LOG:  database system was interrupted; last known up at 2022-04-24 12:18:14 UTC<br/>db_1   | 2022-05-02 06:26:58.791 UTC [26] LOG:  database system was not properly shut down; automatic recovery in progress<br/>db_1   | 2022-05-02 06:26:58.792 UTC [26] LOG:  redo starts at 0/1669FB0<br/>db_1   | 2022-05-02 06:26:58.792 UTC [26] LOG:  invalid record length at 0/166A0B0: wanted 24, got 0<br/>db_1   | 2022-05-02 06:26:58.792 UTC [26] LOG:  redo done at 0/166A078<br/>db_1   | 2022-05-02 06:26:58.806 UTC [1] LOG:  database system is ready to accept connections</span></pre><h1 id="e944" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">什么是逻辑解码？</h1><blockquote class="kz la lb"><p id="cf34" class="if ig lc ih b ii ij ik il im in io ip ld ir is it le iv iw ix lf iz ja jb jc hb bi translated">逻辑解码是将对数据库表的所有持久更改提取为一致、易于理解的格式的过程，这种格式可以在不了解数据库内部状态的详细信息的情况下进行解释。</p></blockquote><p id="a476" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这个用于复制设置的特性的帮助，对数据库的每个更改都会被记录下来，并在处理后发出。</p><p id="a4e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们需要更改一些配置，以便可以启动复制插槽。你可以在这里详细阅读<a class="ae jd" href="https://www.postgresql.org/docs/12/logicaldecoding-example.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5d46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经将PostgreSQL数据挂载到了<code class="du kh ki kj kk b">pgdata</code>目录中。在这个目录中，有一个叫做<code class="du kh ki kj kk b">postgresql.conf</code>的文件，我们需要对它做一些修改。在文件中找到这些键并如下设置它们，然后用<code class="du kh ki kj kk b">docker-compose restart</code>重启数据库容器。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="8bfb" class="kt jf hi kk b fi ku kv l kw kx">wal_level = logical<br/>max_replication_slots = 1</span><span id="ff09" class="kt jf hi kk b fi ky kv l kw kx">shared_preload_libraries = 'wal2json'</span></pre><blockquote class="kz la lb"><p id="35a5" class="if ig lc ih b ii ij ik il im in io ip ld ir is it le iv iw ix lf iz ja jb jc hb bi translated">在使用逻辑解码之前，必须将<a class="ae jd" href="https://www.postgresql.org/docs/12/runtime-config-wal.html#GUC-WAL-LEVEL" rel="noopener ugc nofollow" target="_blank"> wal_level </a>设置为<code class="du kh ki kj kk b">logical</code>并将<a class="ae jd" href="https://www.postgresql.org/docs/12/runtime-config-replication.html#GUC-MAX-REPLICATION-SLOTS" rel="noopener ugc nofollow" target="_blank"> max_replication_slots </a>至少设置为1。</p></blockquote><p id="a3e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们向PostgreSQL添加了<code class="du kh ki kj kk b">wal2json</code>库，这样我们就可以获得JSON格式的复制流输出，这种格式更容易阅读和处理。</p><h1 id="d8d3" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">设置复制插槽</h1><p id="e719" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">设置数据库并应用配置更改后，我们将设置复制插槽。为此，您需要进入PostgreSQL CLI。您可以运行下面的命令来访问它。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="57e3" class="kt jf hi kk b fi ku kv l kw kx">docker-compose exec db psql -U postgres -d myworld</span></pre><p id="b987" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用<code class="du kh ki kj kk b">json</code>输出创建一个名为<code class="du kh ki kj kk b">regression_slot</code>的逻辑复制槽。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="72e7" class="kt jf hi kk b fi ku kv l kw kx">SELECT * FROM pg_create_logical_replication_slot('regression_slot', 'wal2json');</span></pre><p id="4fb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果命令运行成功，您应该会看到以下输出。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="2650" class="kt jf hi kk b fi ku kv l kw kx">    slot_name    |    lsn    <br/>-----------------+-----------<br/> regression_slot | 0/1645E78<br/>(1 row)</span></pre><p id="a9e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，您可以运行下面的查询来获取有关复制插槽的更多信息。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="181e" class="kt jf hi kk b fi ku kv l kw kx">myworld=# SELECT slot_name, plugin, slot_type, database, active, restart_lsn, confirmed_flush_lsn FROM pg_replication_slots;</span><span id="c08e" class="kt jf hi kk b fi ky kv l kw kx"><br/>-[ RECORD 1 ]-------+----------------<br/>slot_name           | regression_slot<br/>plugin              | wal2json<br/>slot_type           | logical<br/>database            | myworld<br/>active              | f<br/>restart_lsn         | 0/1645E40<br/>confirmed_flush_lsn | 0/1645E78</span></pre><p id="5603" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到此插槽尚未激活，它刚刚创建。</p><h1 id="e58e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">激活逻辑复制插槽</h1><p id="f0ef" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">有不同的命令可以激活复制插槽并从中读取更改。其中大部分已经在<a class="ae jd" href="https://www.postgresql.org/docs/12/logicaldecoding-example.html" rel="noopener ugc nofollow" target="_blank"> PostgreSQL逻辑解码实例中讨论过。</a></p><p id="14a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行下面的命令，这将启动名为<code class="du kh ki kj kk b">regression_slot</code>的插槽，并将输出流式传输到位于<code class="du kh ki kj kk b">/stream</code>目录下名为<code class="du kh ki kj kk b">psql-regresstion-slot.json</code>的文件中。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="66bc" class="kt jf hi kk b fi ku kv l kw kx">docker-compose exec db pg_recvlogical -d myworld -U postgres -W --slot regression_slot --start -f /stream/<!-- -->psql-regresstion-slot.json</span></pre><p id="064f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在检查复制插槽，它已被激活。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="7f91" class="kt jf hi kk b fi ku kv l kw kx">myworld=# SELECT slot_name, plugin, slot_type, database, active, restart_lsn, confirmed_flush_lsn FROM pg_replication_slots;</span><span id="dd89" class="kt jf hi kk b fi ky kv l kw kx">-[ RECORD 1 ]-------+----------------<br/>slot_name           | regression_slot<br/>plugin              | wal2json<br/>slot_type           | logical<br/>database            | myworld<br/>active              | t<br/>restart_lsn         | 0/1645E40<br/>confirmed_flush_lsn | 0/1645E78</span></pre><p id="0216" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们用一个tail命令来监视输出文件，看看那里会有什么。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="fae9" class="kt jf hi kk b fi ku kv l kw kx">$  tail -f stream/psql-regresstion-slot.json</span></pre><h1 id="aef6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">虚拟数据</h1><p id="82e2" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">是时候创建一个简单的表并开始向其中插入几条记录了。我将创建一个名为<code class="du kh ki kj kk b">data</code>的表，包含两列<code class="du kh ki kj kk b">id</code>和<code class="du kh ki kj kk b">value</code>。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="de63" class="kt jf hi kk b fi ku kv l kw kx">myworld=# CREATE TABLE data(id serial primary key, value text);</span><span id="fe08" class="kt jf hi kk b fi ky kv l kw kx">myworld=# \d data<br/>                            Table "public.data"<br/> Column |  Type   | Collation | Nullable |             Default              <br/>--------+---------+-----------+----------+----------------------------------<br/> id     | integer |           | not null | nextval('data_id_seq'::regclass)<br/> value  | text    |           |          | <br/>Indexes:<br/>    "data_pkey" PRIMARY KEY, btree (id)</span></pre><p id="9ad0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们向表中插入一些随机数据。多次运行该查询，将一些数据放入表中。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="88bc" class="kt jf hi kk b fi ku kv l kw kx">myworld=# INSERT INTO data(value) VALUES(random());</span></pre><h1 id="686b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">流输出</h1><p id="4d42" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在表格中插入一些记录后，再次检查<code class="du kh ki kj kk b">psql-regresstion-slot.json</code>文件。对于您插入的每条记录，都有这样一行。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="6d0f" class="kt jf hi kk b fi ku kv l kw kx">{"change":[{"kind":"insert","schema":"public","table":"data","columnnames":["id","value"],"columntypes":["integer","text"],"columnvalues":[1,"0.8077364682987209"]}]}</span></pre><p id="184f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在像这样运行一个更新查询。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="d93e" class="kt jf hi kk b fi ku kv l kw kx">myworld=# update data set value = 'test' where id = 1;</span></pre><p id="3e99" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以看到像这样添加了一个新行。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="b7ae" class="kt jf hi kk b fi ku kv l kw kx">{"change":[{"kind":"update","schema":"public","table":"data","columnnames":["id","value"],"columntypes":["integer","text"],"columnvalues":[1,"test"],"oldkeys":{"keynames":["id"],"keytypes":["integer"],"keyvalues":[1]}}]}</span></pre><p id="6ceb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试试删除。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="bb52" class="kt jf hi kk b fi ku kv l kw kx">myworld=# delete from data where id = 1;</span></pre><p id="247c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">并且下面的行将被添加。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="7b29" class="kt jf hi kk b fi ku kv l kw kx">{"change":[{"kind":"delete","schema":"public","table":"data","oldkeys":{"keynames":["id"],"keytypes":["integer"],"keyvalues":[1]}}]}</span></pre><p id="cf32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选择查询呢？它不会向文件中添加任何行，因为SELECT不会更改数据库中的任何内容。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><p id="e8f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止一切顺利。我们已经用逻辑解码设置了数据库，并将所有更改放入一个文件中，我们需要小心，并应用类似logrotate的东西，因为如果数据库中有太多更改，它可能会耗尽所有磁盘。是时候根据这些变化来创建事件了。因此，我将创建一个ruby脚本来监控输出文件并处理更改。</p><h1 id="a3aa" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">应用程序设置</h1><p id="b87f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">首先，让我们用下面的命令创建所需的Gemfile。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="af6c" class="kt jf hi kk b fi ku kv l kw kx">docker run --rm -v $PWD/app:/app ruby:2.6.3 bash -c "cd /app &amp;&amp; bundle init"</span></pre><p id="7128" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你需要添加这些宝石以备将来使用。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="2f9a" class="kt jf hi kk b fi ku kv l kw kx"># app/Gemfile</span><span id="8551" class="kt jf hi kk b fi ky kv l kw kx"># frozen_string_literal: true</span><span id="0fc0" class="kt jf hi kk b fi ky kv l kw kx">source "<a class="ae jd" href="https://rubygems.org" rel="noopener ugc nofollow" target="_blank">https://rubygems.org</a>"</span><span id="ddb5" class="kt jf hi kk b fi ky kv l kw kx">git_source(:github) {|repo_name| "<a class="ae jd" href="https://github.com/#{repo_name" rel="noopener ugc nofollow" target="_blank">https://github.com/#{repo_name</a>}" }</span><span id="1e0c" class="kt jf hi kk b fi ky kv l kw kx">gem 'yajl-ruby', require: 'yajl'<br/>gem "eventmachine"<br/>gem "eventmachine-tail"</span></pre><p id="c6d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们对docker-compose文件做一些更改，这样我们就可以运行我们的应用程序了。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="cc31" class="kt jf hi kk b fi ku kv l kw kx"># docker-compose.yml</span><span id="c187" class="kt jf hi kk b fi ky kv l kw kx">version: '2'<br/>services:<br/>  app:<br/>    image: ruby:2.6.3<br/>    working_dir: /app<br/>    volumes:<br/>      - ./stream:/stream<br/>      - ./app:/app<br/>    command: bash -c "bundle install &amp;&amp; ruby streamer.rb /stream/psql-regresstion-slot.json"<br/>  db:<br/>    build:<br/>      context: .<br/>      dockerfile: Dockerfile-postgres<br/>    volumes:<br/>      - ./pgdata:/var/lib/postgresql/data<br/>      - ./stream:/stream<br/>    ports:<br/>      - 5555:5432<br/>    environment:<br/>      POSTGRES_PASSWORD: "123123"<br/>      POSTGRES_DB: "myworld"</span></pre><p id="e727" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经添加了一个使用ruby 2 . 6 . 3版映像的应用程序服务，我们还挂载了包含我们的复制槽输出和应用程序目录的流目录。如果你启动容器，你会得到一个错误，因为我们还没有创建<code class="du kh ki kj kk b">streamer.rb</code>文件。</p><p id="170c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们在app目录中创建<code class="du kh ki kj kk b">streamer.rb</code>文件。把下面的内容，然后我们将一步一步地去理解代码。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="0394" class="kt jf hi kk b fi ku kv l kw kx"># app/streamer.rb</span><span id="aa77" class="kt jf hi kk b fi ky kv l kw kx">require "yajl"<br/>require "eventmachine"<br/>require "eventmachine-tail"</span><span id="7449" class="kt jf hi kk b fi ky kv l kw kx">class Streamer &lt; EventMachine::FileTail<br/>  def initialize(path, startpos=-1)<br/>    super(path, startpos)<br/>    <a class="ae jd" href="http://twitter.com/parser" rel="noopener ugc nofollow" target="_blank">@parser</a> = Yajl::Parser.new(:symbolize_keys =&gt; true)<br/>    <a class="ae jd" href="http://twitter.com/parser" rel="noopener ugc nofollow" target="_blank">@parser</a>.on_parse_complete = method(:object_parsed)<br/>  end</span><span id="ff21" class="kt jf hi kk b fi ky kv l kw kx">def object_parsed(obj)<br/>    puts "data: #{obj} \n\n"<br/>### Send data to Kafka stream, Redis stream or create async jobs or ### make more API calls.</span><span id="c291" class="kt jf hi kk b fi ky kv l kw kx">  end</span><span id="5d01" class="kt jf hi kk b fi ky kv l kw kx">def receive_data(data)<br/>    <a class="ae jd" href="http://twitter.com/parser" rel="noopener ugc nofollow" target="_blank">@parser</a> &lt;&lt; data<br/>  end<br/>end</span><span id="8c57" class="kt jf hi kk b fi ky kv l kw kx">def main(args)<br/>  if args.length == 0<br/>    puts "Usage: #{$0} &lt;path&gt; [path2] [...]"<br/>    return 1<br/>  end</span><span id="41b9" class="kt jf hi kk b fi ky kv l kw kx">$topic = $0 || "default"</span><span id="074a" class="kt jf hi kk b fi ky kv l kw kx">EventMachine.run do<br/>    args.each do |path|<br/>      EventMachine::file_tail(path, Streamer)<br/>    end<br/>  end<br/>end</span><span id="a191" class="kt jf hi kk b fi ky kv l kw kx">exit(main(ARGV))</span></pre><p id="de2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在使用<code class="du kh ki kj kk b">yajl</code> gem与JSON合作。还有<code class="du kh ki kj kk b">eventmachine</code>和<code class="du kh ki kj kk b">eventmachine-tail</code>，它们帮助我们观察一个文件并获取添加到该文件中的更改。</p><h1 id="d2a9" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">流光级</h1><p id="d7ea" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">现在我们要定义一个类来监控<code class="du kh ki kj kk b">psql-regression-slot.json</code>文件的变化。</p><p id="a8fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Streamer类扩展了EventMachine::FileTail类，它可以对文件进行尾部处理。在initialize方法中，我们用<code class="du kh ki kj kk b">yajl</code>创建了一个JSON解析器。此外，我们定义了一个名为<code class="du kh ki kj kk b">object_parsed.</code>的函数，每当一个对象被解析时都会被调用</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="2ab4" class="kt jf hi kk b fi ku kv l kw kx"><a class="ae jd" href="http://twitter.com/parser" rel="noopener ugc nofollow" target="_blank">@parser</a> = Yajl::Parser.new(:symbolize_keys =&gt; true)<br/><a class="ae jd" href="http://twitter.com/parser" rel="noopener ugc nofollow" target="_blank">@parser</a>.on_parse_complete = method(:object_parsed)</span></pre><p id="6e5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du kh ki kj kk b">object_parsed</code>方法中，我们现在要将数据写入输出。</p><p id="e928" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，我们添加了一个名为<code class="du kh ki kj kk b">receive_data</code>的方法，该方法覆盖了<code class="du kh ki kj kk b">EventMachine::FileTail</code>类的默认方法，并将新行推送到先前初始化的解析器对象。</p><h1 id="eea4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">主要方法</h1><p id="9b4a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在main方法中，我们从ARGV获取文件名，并检查它们是否存在。</p><p id="469e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们需要运行EventMachine，并要求它用Streamer类结束文件。</p><p id="cb3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果您再次启动应用程序容器，它将启动tail <code class="du kh ki kj kk b">/stream/psql-regression-slot.json</code>并将这些行推入解析器。</p><h1 id="7898" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">下一个？</h1><p id="f128" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">您可以很容易地定制<code class="du kh ki kj kk b">parsed_object</code>方法并向其添加更多的逻辑。您可以将更改推送到Kafka流、Redis流，或者创建其他异步作业来在后台处理数据。</p><figure class="kl km kn ko fd lo er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es ln"><img src="../Images/5d77c1dbfbac30987ddbc96ad5a8a8ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*evR-oQgQBw9_2mfcK_I4nA.png"/></div></div></figure><p id="33e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还创建了一个<a class="ae jd" href="https://gitlab.com/azolf/processpostgresqlchanges" rel="noopener ugc nofollow" target="_blank"> Gitlab存储库</a>并将所有内容都推送到那里。愿意的话可以随意交流和扩展。</p></div></div>    
</body>
</html>