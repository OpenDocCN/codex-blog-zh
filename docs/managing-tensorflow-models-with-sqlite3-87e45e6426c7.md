# 使用 SQLite3 管理张量流模型

> 原文：<https://medium.com/codex/managing-tensorflow-models-with-sqlite3-87e45e6426c7?source=collection_archive---------31----------------------->

在我的上一篇文章中，([https://medium.com/p/93c82361d0e9](/p/93c82361d0e9))我们研究了预测金融数据时的常见错误，并开发了我们自己的管道和各种各样的定制工具。在运行了一些回溯测试之后，我意识到:我的模型太多了！我不记得哪些模型做得很好，或者它们有什么参数。灾难！

![](img/3d294edb14765316cb063a460600627c.png)

被所有的模型淹没

因此，让我们使用 SQL 数据库来组织我们的模型。这将达到两个目的:

1.  在一个地方跟踪我们的模型及其参数，以防我们想要重新创建我们的模型，训练类似的模型，继续训练具有不同超参数的现有模型，或者只是欣赏我们的模型帝国。
2.  在一个地方可以方便地访问模型参数，以防我们想要创建一个 RestAPI(我们将在后面创建)或出于任何其他目的控制我们的本地应用程序变量。

为此，我们将结合 Python 使用 SQLite3。

**我们的第一步**是找出我们的数据库模式。我决定使用 2 个表:Model 和 Adam_Optimizer。

模型表将存储模型名称、模型类型、输入形状等参数，以及其他变量，如模型的训练时间间隔和训练时使用的跑马灯数据。

Adam_Optimizer 表将存储我们的 Adam 优化器的参数。在我的项目中，我只使用亚当——所以这让我们的生活变得非常简单。如果我们要制作一个包含各种优化器的表，我们需要弄清楚如何处理数量可变的参数——最有可能的方法是将整个参数字典存储为一个 BLOB 对象。不管怎样，这是一个未来的项目，现在，我们的任务相当简单。

**那么，我们开始吧！**

要使用 SQLite3，我们首先必须建立到数据库的连接:

这将连接到我们的数据库。不存在数据库吗？没问题，会创建一个。

在我们继续之前，我们使用与我上一篇文章中的项目相同的结构。(如果你对密码、市场、深度学习感兴趣，就去读吧！[https://medium.com/p/93c82361d0e9](/p/93c82361d0e9)

我们的模型使用 root/models/interval/ticker/type 文件夹子结构，其中 interval 是时间间隔，ticker 是用来训练模型的加密资产，type 是模型的类型(例如 LSTM)。

我也有 ensembly_average 类型，这是一个简单的集合，我们以前使用它来平均几个模型。

澄清了所有这些之后，下面是我们的表格:

我们在优化器和模型表之间有一个一对多的关系，这样我们就不必保存优化器的副本(因为一个设置可以用于几个模型)。为了表示这一点，我们将在模型表中的优化器表的“optimizer_id”上使用一个外键属性。我将在后面解释其余的专栏。

要创建这些新表，我们必须使用游标对象，这是一种连接到数据库的方法:

```
cursor_obj = connection.cursor()
cursor_obj.execute(create_model_table)
```

接下来，我们需要为在数据库中插入值创建准备好的语句。幸运的是，这对于 SQLite3 来说非常容易！

注意，我们对 adam_opt 表使用 INSERT 或 IGNORE，这样我们就不会存储任何重复的优化器。运行这两个函数，同时为它们提供一个参数字典，将会在我们的数据库中插入一个单独的条目。

**现在是有趣的部分**:获取我们的模型参数并传递给他们。

我将通过扫描我们项目中的所有现有模型并将它们的参数写入字典来完成。这样，我们可以用已经存在的模型填充数据库。

首先，我们初始化一个空字典来存储我们的参数。然后我们将建立一个到我们模型的路径——在我的例子中，我从/sql/ folder 运行这个脚本，所以我将获取当前文件夹，并使用 pathlib(【https://docs.python.org/3/library/pathlib.html】T2——这真的很好！)库，方法是调用. parent 方法转到上一个文件夹。然后，我们将加入我们的模型文件夹，瞧！

接下来，我们将使用 os.walk 函数遍历 models 文件夹中的所有文件。我们只对最终文件感兴趣，对任何中间文件夹都不感兴趣，所以我们做了一个额外的循环。我们需要定义我们的有效模型类型——因为我们可能在那里有集合文件夹，我们现在不想使用它们。

然后使用。split python 方法我们可以得到最终文件夹的名称——这将是我们模型的类型。

接下来，我们将使用 if 语句来检查我们的文件是否具有. h5 扩展名(Tensorflow 默认使用的扩展名)以及文件夹是否在 valid_model_types 中(整体文件夹将包含我们不想要的模型的副本)。

我们的第一个参数 model_name 非常容易获得——只需读出 for 循环的 name 变量。

ticker 就是“type”文件夹上面的文件夹，interval 就是上面的文件夹。我们通过使用。拆分方法。

我们的模型的类型取决于我们的最终文件夹——我们已经在前面的代码片段中获得了它。

最后，我们可以使用 pathlib Path 方法来定义模型的完整路径，这样我们接下来就可以开始加载它们了。

现在剩下的就是使用 Keras load_model 函数加载我们的模型(不要忘记指定您可能使用的任何自定义对象)。

其余的参数位于模型配置中——我们可以使用。get_config()方法。

我们还可以通过使用. optimizer.get_config()来获取加载模型的优化器，并读取其参数。

最后剩下的事情是检查我们的 ticker 文件夹是否有任何集合类型，如果有，将“ensemble = True”参数分配给包含在其中的模型。我们简单地检查模型是否存在于系综文件夹中，并分别设置参数。如果文件夹本身不存在，我们可以简单地将 ensemble 参数设置为 False。这样我们可以很容易地检查我们的模型是否是集合的一部分，如果是，是哪个集合。

就这样，我们从模型中完全提取了所有需要的特性！

最后一步是将参数插入到我们的 params 字典中，其中 model_name 充当一个键，parameter dictionary 是它的值。

完整代码:

从单一模型中提取参数的代码大部分是相同的，所以我在这里不包括它。

现在，我们要做的就是将所有模型及其参数插入数据库:

我们将在第 3 行循环我们的字典键(记住，我们的键是模型名，我们的值是字典本身)。注意，我们首先将值插入 adam optimizer 表——这是因为在我们的模型表中，我们有一个外键 optimizer_id，在能够完全插入数据之前，我们需要知道这个外键。

在第 9 行到第 11 行，我们将使用。游标对象的 fetchone 方法。之后，我们要做的就是按照正确的顺序提供与我们准备好的语句相匹配的参数，就这样。我们所有的模型现在都整齐地放在我们的数据库中，并有相应的优化器与之匹配。

还有最后一件事——我们需要找到一种管理新模型的方法。我们不希望每次训练我们喜欢的新模型时都重新索引我们的数据库。

因此，首先，我们将创建一个函数来将单个模型保存到我们的数据库中。我们将提供模型、ticker 和 interval 的路径(尽管后两者可以像我们之前所做的那样从模型路径中提取)。然后我们要做的就是解析我们的模型，并将其插入数据库。

但是如果我们想删除我们的模型呢？我们不能只是手动从硬盘或数据库中删除它，我们必须双管齐下。

对于这个函数，我们需要我们想要删除的模型的路径。首先，在第 5–9 行，我们将检查一个模型是否存在，如果存在，我们将从存储中删除它。然后，在第 11–25 行，我们将检查我们的 SQL 数据库，看看我们的模型是否是一个系综文件夹的一部分，如果是，也从那里删除它。最后，我们可以从 SQL 数据库中删除我们的模型。漂亮又干净！

最后，我们需要创建一个函数，将我们的新模型移动到一个系综文件夹中，如果我们想这样做的话。这很重要，因为我们跟踪一个模型是否是整体的一部分，所以我们不能只是物理地移动模型，我们还需要在我们的数据库中注册它。

幸运的是，这相当简单:我们将使用 Pythons shutil.copyfile 方法将我们的模型文件复制到我们提供的 ensemble 文件夹中，然后将 ensemble 类型和 ensemble 状态设置为数据库中正确的类型和状态。

我们完了。从这里有很多路可以走；我们可以创建一个表来存储我们的回溯测试/测试结果，这样我们就可以看到每个模型的表现，我们可以将它与 Keras 联系起来，这样经过训练的新模型就会自动注册(可能首先基于某种测试，以确保它们是合适的模型)。也许我们甚至可以为投资领域建立某种交叉训练，其基础是在单个报价器上训练的模型。可能性确实是无穷无尽的！

下次我们将使用这个数据库来创建一个非常基本的 RestAPI，并在我们的浏览器中查看模型的预测。