# 事件驱动架构的 FIFO 谬误

> 原文：<https://medium.com/codex/the-fifo-fallacy-of-event-driven-architecture-8742477fefd0?source=collection_archive---------3----------------------->

![](img/cbef6d11df3b06d2c52f4fda8e508384.png)

照片由 Tranmautritam 拍摄:[https://www . pexels . com/photo/cute-tabby-kitten-on-a-sofa-2194261/](https://www.pexels.com/photo/cute-tabby-kitten-on-a-sofa-2194261/)

最近，不同的团队问我同样的问题:

我们对域事件的顺序做些什么？我们的消息总线有这个很好的 FIFO 特性，但是不知何故我们的解决方案变得非常复杂！

我:如果你依赖事件的顺序，那你就错了。这是事件驱动架构中的反模式。

他们:但这怎么可能是反模式，我们的消息总线可以被配置为保证消息在队列中的顺序。

我:嗯，你可以，不代表你应该。

## **耦合服务**

事件驱动架构描述了去耦服务之间的异步消息传递系统。这意味着生产者和消费者都不应该知道或对彼此做任何假设。但是对消息进行排序并依赖它们却恰恰相反。

我们的服务通过引入生产者的假设和消费者的假设来耦合，生产者假设有一个消费者将按顺序处理事件，消费者假设生产者将严格按顺序发送那些消息。

分布式紧耦合服务最终导致了所谓的分布式整体结构，在这种结构中，我们得到了两个世界的最坏情况:分布式系统的复杂性和整体系统的紧耦合性。

## **事件信息太多**

我能想到的排序需求的一个原因是，消息包括将由消费者直接处理的数据负载。但这更类似于分布式事务，而不是其他任何事务。让我们看一个简单的“反”例子。

假设我们有一个计数器和一个更新计数器并发布事件“计数器更新”的**服务 A** 。此外，我们有一个**服务 B** ，它有自己的计数器副本，并订阅“计数器更新”事件。

现在想象一下，服务 A 总是将当前值包含到“计数器更新”事件中，而服务 B 只是用这个值来更新它自己的副本。我们迟早会遇到数据库中一个众所周知的并发问题:更新丢失问题。如果序列

*   "计数器更新:值=1 "
*   "计数器更新:值=2 "

出了故障，那么服务 B 的计数器最后将是 1 而不是 2。

解决方案很简单:服务 A 不应该在消息中包含真正的值，而应该只包含一个服务 B 或任何其他消费者可以找到当前值的引用。现在，消息的顺序并不重要，因为服务 B 将总是从指定的位置获取最新的值。

如果更新的不是一个计数器，而是一个大的数据结构。许多消息传递系统对消息大小有严格的限制。我们的新解决方案是可行的，因为它只包含了对真实数据的引用。

## **基础设施的责任太大**

最后，关于事件顺序的假设是由某些业务规则驱动的。例如，客户总是在更新之前创建。但是这个不变量在我们的领域模型中没有被强制执行，相反，它已经成为基础设施的责任。我们的领域模型现在更加脆弱，逻辑上依赖于基础设施，这显然是错误的依赖方向。

总之，依赖域事件的顺序不是一个好主意。尽管有针对 FIFO 队列的技术解决方案，但它们并不适合事件驱动的架构。