<html>
<head>
<title>Implementing Simon’s Algorithm in Qiskit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Qiskit中实现Simon算法</h1>
<blockquote>原文：<a href="https://medium.com/codex/implementing-simons-algorithm-in-qiskit-9155ce6a9527?source=collection_archive---------1-----------------------#2021-06-10">https://medium.com/codex/implementing-simons-algorithm-in-qiskit-9155ce6a9527?source=collection_archive---------1-----------------------#2021-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1bf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">西蒙的算法不像肖尔或格罗弗的算法那样是一种非常有影响力的量子算法。它是一个玩具算法，几乎没有一般意义上的应用。然而，这是第一个与解决这个问题的经典算法相比显示出指数级加速的算法。此外，它还启发了量子傅立叶变换等算法的发展，量子傅立叶变换是Shor的质因数分解算法的关键要素。</p><p id="2760" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事不宜迟，让我们开始研究这个问题。假设我们有一个2:1函数(即，将两个不同的输入映射到一个输出的函数)。该函数将{0,1}^n比特作为输入，并产生{0,1}^n比特作为输出，使得输出f(x) = f(x ⊕ s) (⊕表示逐位X-OR) <strong class="ih hj"> </strong>其中s也是{0,1}^n比特。我们需要找到任意的位串'<strong class="ih hj"> s </strong>'。</p><p id="7974" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在进入量子解之前，我们可以先检查一下寻找<strong class="ih hj"> s </strong>的经典技术。由于函数是2:1，我们得到2个输入的1个输出，对于2^(n)输入，有2^(n)/2或2^(n-1)唯一的输出。现在，假设x和y映射相同的输出z，使得x ⊕ y = z。在最坏的情况下，我们将不得不检查2^(n-1)+1输出以找到x和y，通过对x和y进行逐位X-OR运算，我们将得到z</p><p id="23e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以看看量子解。</p><p id="6264" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">电路</em> </strong>:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/4ed9077c60bcdd8ba0ee8252e18b0ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOarTcOHdJz-6AwB9maxRA.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">西蒙电路的两量子位例子</figcaption></figure><p id="b164" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">数学解释:</em> </strong></p><p id="525f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以一步一步来，看看电路是如何工作的。让我们考虑我们有n个量子位。</p><p id="de6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一步:我们在|0⟩^n.有两个登记处</p><p id="679d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二步:我们在第一个寄存器的量子位上应用h门，得到相等叠加的2^n态。</p><p id="17a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里|x⟩是所有2^n可能的比特串的相等叠加。</p><p id="e64a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤3:在两个寄存器上应用了oracle函数后，我们在第一个寄存器上得到|x⟩，在第二个寄存器上得到|y ⊕ f(x)⟩。作为|y⟩ =|0⟩，我们在第二个登记簿上只有|f(x)⟩。</p><p id="2bf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第四步:我们测量第二个寄存器的量子位。这里我们将在第二寄存器和第一寄存器上得到一个状态|f(z)⟩，两个输入|z ⟩和|z ⊕ s⟩的叠加可以产生f(z)。这里的<strong class="ih hj"> s </strong>是我们任意的位串。</p><p id="1e05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从现在起，我们将不需要第二个寄存器|f(z)⟩.的值</p><p id="6ada" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤5:在这个阶段，我们在第一个寄存器上应用H-gate。我们得到了这样一个丑陋的公式。</p><p id="907e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">公式显示y(z ⊕ s)在第二个指数中，等于y z ⊕ y s，如果y s = 1，则整个东西的值将为0。我们将只在y s = 0 mod(2)的情况下得到相等叠加的值。<strong class="ih hj"> (x = y mod(z)表示如果x除以z，y将是余数)。</strong></p><p id="9afa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">步骤6:在最后一步，我们重复测量第一个寄存器，以获得不同的y值，从中我们可以计算出<strong class="ih hj"> s </strong>。</p><p id="098f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">数学例题:</em> </strong></p><p id="df3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个例子将给出算法的清晰直观。</p><p id="51ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们用三个量子位做一个例子。我们认为101是隐藏的位串。我们将状态000与101进行逐位异或运算，得到值101。因此，000和101将共享相同的输出。我们可以按照上面的规则制作一个投入产出图。我们可以为每对任意选择三位输出。</p><p id="d587" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们一步一步来。</p><ol class=""><li id="ab4f" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">我们在|000⟩状态下初始化两个寄存器。</li></ol><p id="147e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.我们对第一个寄存器的量子位使用H门。</p><p id="98e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这等于:</p><p id="8a63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.在这里，我们应用了将|x&gt;|0 &gt;映射到|x&gt;|f(x)&gt;的函数。</p><p id="de3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.我们测量第二个音域。并认为我们得到了值|000 &gt;作为输出。</p><p id="39d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们在第一个寄存器中有了相等叠加的状态|010&gt; + |111 &gt;，因为我们选择状态|000 &gt;作为|010 &gt;和|111 &gt;的输出。</p><p id="94ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.我们再次对第一个寄存器应用H门。经过一些丑陋的数学运算，我们得到以下值。</p><p id="75b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想确保我们得到的状态是正确的，我们可以使用y s = 0 mod (2)来检查它。让我们以国家为例。</p><p id="11b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们得到0是因为如果我们用2除以2，我们得到1作为商，0作为余数。这里的余数是我们的答案是0。</p><p id="7ece" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.我们将重复测量第一个寄存器，以获得不同的结果状态。从这些状态中，我们可以找到s。</p><p id="f38a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设第一次测量，我们得到(010)。</p><p id="3aaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们再次测量第一个寄存器，并认为我们得到了(111)。</p><p id="54ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果1 s1 = 1 s2 = 0，我们会得到一个没有意义的微不足道的结果000。但是如果1 s1 = 1 s2，我们得到101，这是我们认为的秘密位串。</p><p id="9daf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">在Qiskit中实现算法:</em> </strong></p><pre class="jf jg jh ji fd kd ke kf kg aw kh bi"><span id="1f04" class="ki kj hi ke b fi kk kl l km kn"># considering our bit string to be ‘101’<br/>b = ‘101’<br/>n = len(b)<br/># creating two quantum register of ’n’ qubits and 1 classical register of ’n’ qubits<br/>q_reg1 = QuantumRegister (n,’reg1')<br/>q_reg2 = QuantumRegister (n,’reg2')<br/>c_reg = ClassicalRegister (n)<br/>circuit = QuantumCircuit (q_reg1, q_reg2, c_reg)<br/># applying H-gate on qubits of first register<br/>circuit.h(q_reg1)<br/>circuit.barrier()<br/># copying the data of first register to second register<br/>circuit.cx(q_reg1, q_reg2)<br/>circuit.barrier()<br/># applying bit wise X-OR from register 1 to register 2 where qubits of first register is 1<br/>circuit.cx(q_reg1[0],q_reg2[0])<br/>circuit.cx(q_reg1[0],q_reg2[2])<br/>circuit.barrier()<br/># measuring qubits of second register<br/>Circuit.measure(q_reg2,c_reg)<br/># applying H-gate to qubits of first register<br/>circuit.h(q_reg1)<br/>circuit.barrier()<br/># measuring qubits of first register<br/>circuit.measure(q_reg1, c_reg)<br/>circuit.draw()</span></pre><p id="e0c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以一步一步来，看看代码中发生了什么。我们取两个3量子位的寄存器，并在第一个寄存器上应用H-gate。<br/>现在，甲骨文功能的部分来了。我们将Oracle部分分为两步。在第一步中，我们将来自第一寄存器的量子位的CX门应用到第二寄存器的量子位。我们这样做是为了将第一个寄存器的状态复制到第二个寄存器。在第二步中，我们将来自第一寄存器的第一量子位的两个CX应用到第二寄存器的第一和第三量子位。现在，我们为什么要这么做？好吧，记住我们选择101作为我们任意的位串。我们正在创建一个函数，将逐位X-OR应用于第二个寄存器的量子位。在量子计算中，CX做逐位X-OR的工作。由于我们的任意位串的第一位和第三位都是1，我们将第一个寄存器的量子位的CXs应用到第二个寄存器的第一个和第三个量子位。我们不需要对第二位使用CX，因为它是0。至此，我们完成了oracle函数部分。在这里，我们可以任意改变第二个寄存器的量子位，就像我们在例子中所做的那样，但这不是必须的。<br/>现在，我们测量我们的第二个寄存器。我们也可以忽略这一部分，因为它在这种情况下没有区别。如果我们在Qiskit中不使用measurement，它只会忽略那部分。<br/>以上代码产生以下电路。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ko"><img src="../Images/1bc99be5344395260d6e8bfba2a1156e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSHVwCW4ur60A1bRRBiNhA.png"/></div></div></figure><p id="3350" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们运行电路并获得其输出。</p><pre class="jf jg jh ji fd kd ke kf kg aw kh bi"><span id="b8ce" class="ki kj hi ke b fi kk kl l km kn"># running the circuit using "qasm simulator"<br/>qasm_sim = Aer.get_backend("qasm_simulator")<br/>job = assemble(circuit,qasm_sim)<br/>result = qasm_sim.run(job).result()<br/>counts = result.get_counts()<br/>plot_histogram(counts)</span></pre><p id="ee33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们以相等的概率得到4个值。分别是000，010，101和111，这些是我们最终从数学例子中得到的最终值。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kp"><img src="../Images/bfd06c40e6c799541bf2cb943e5e1605.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*jeEq45Na0efVXSx-bSpbuw.png"/></div></figure><p id="20e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想确定得到的状态是否满足y s = 0，我们也可以为此写一个代码。</p><pre class="jf jg jh ji fd kd ke kf kg aw kh bi"><span id="6bb3" class="ki kj hi ke b fi kk kl l km kn"><em class="jd"># Calculate the dot product of the results</em><br/><strong class="ke hj">def</strong> <strong class="ke hj">bdotz</strong>(b, z):<br/>    accum <strong class="ke hj">=</strong> 0<br/>    <strong class="ke hj">for</strong> i <strong class="ke hj">in</strong> range(len(b)):<br/>        accum <strong class="ke hj">+=</strong> int(b[i]) <strong class="ke hj">*</strong> int(z[i])<br/>    <strong class="ke hj">return</strong> (accum <strong class="ke hj">%</strong> 2)<br/><br/><strong class="ke hj">for</strong> z <strong class="ke hj">in</strong> counts:<br/>    print( '{}.{} = {} (mod 2)'<strong class="ke hj">.</strong>format(b, z, bdotz(b,z)) )</span><span id="a63d" class="ki kj hi ke b fi kq kl l km kn">101.111 = 0 (mod 2)<br/>101.101 = 0 (mod 2)<br/>101.010 = 0 (mod 2)<br/>101.000 = 0 (mod 2)</span></pre><p id="1867" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的结果，我们可以看到，对于所有的值y s = 0。所以，我们得到的状态是正确的。</p><p id="334e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，根据这四个结果状态，我们可以按照示例中的给定方法找到我们的任意位串<strong class="ih hj">‘101’</strong>。</p><p id="c459" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，如果我们不想为甲骨文编码，我们可以为西蒙的甲骨文使用Qiskit教科书函数。</p><pre class="jf jg jh ji fd kd ke kf kg aw kh bi"><span id="2802" class="ki kj hi ke b fi kk kl l km kn">from qiskit_textbook.tools import simon_oracle</span><span id="a20a" class="ki kj hi ke b fi kq kl l km kn">b = '101'</span><span id="99f6" class="ki kj hi ke b fi kq kl l km kn">n = len(b)<br/>simon_circuit = QuantumCircuit(n*2, n)<br/>simon_circuit.h(range(n))    <br/>simon_circuit.barrier()<br/>simon_circuit+=simon_oracle(b)<br/>simon_circuit.barrier()<br/>simon_circuit.h(range(n))<br/>simon_circuit.measure(range(n), range(n))<br/>simon_circuit.draw()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kr"><img src="../Images/894de1665507a41e5d5207d48aec3ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*65fnCvNLQf3mJDDsluoffA.png"/></div></figure><p id="3fcb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看，我们有相同的电路。</p><p id="9f95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是算法的全部内容。虽然这些算法与Grover和Shor等更著名的算法相比并不重要，但这些算法因其计算速度加快而受到研究。我们今天看到的Shor算法，就是在这个算法的启发下发展起来的。西蒙问题的量子解只需要<strong class="ih hj"> O(n) </strong>个查询，而它的经典解需要<strong class="ih hj">o(2^(n/2)】</strong>个查询。所以我们的速度正在成倍增长。</p><p id="7133" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在未来的文章中涵盖更多的量子算法及其一些实际应用，敬请关注！</p></div></div>    
</body>
</html>