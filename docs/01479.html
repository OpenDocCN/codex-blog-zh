<html>
<head>
<title>Enterprise Software Patterns: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">企业软件模式:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/enterprise-software-patterns-part-2-5d374ee000db?source=collection_archive---------6-----------------------#2021-05-04">https://medium.com/codex/enterprise-software-patterns-part-2-5d374ee000db?source=collection_archive---------6-----------------------#2021-05-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6ac31eb45c57ce7ae86640e69e733cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DnaZgD9b3oCNG9sr"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">弗洛里安·奥利佛在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f939" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">欢迎回到我们的企业编码模式系列！如今，软件世界中有如此多的细微差别。如果你是一名新的开发人员，当你得到第一份工作时，理解如何将东西组合在一起可能是压倒性的。随着这么多人经历新兵训练营和其他快速培训课程，一些最重要的东西被忽略了。在下一版中，我们将深入探讨<a class="ae iu" rel="noopener" href="/codex/enterprise-software-patterns-part-1-b2da0247929e">业务层</a>的一些最常见的组件:服务、工厂、命令、查询、验证器和编排器。</p><div class="jt ju ez fb jv jw"><a rel="noopener follow" target="_blank" href="/codex/enterprise-software-patterns-part-1-b2da0247929e"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hj fi z dy kb ea eb kc ed ef hh bi translated">企业软件模式:第1部分</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">如今，软件世界中有如此多的细微差别。如果你是一个新的开发人员，它可以压倒…</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">medium.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk io jw"/></div></div></a></div><h1 id="ac90" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">很高兴为您服务</h1><p id="3ca2" class="pw-post-body-paragraph iv iw hi ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">服务是任何应用程序最基本的方面之一。为什么？因为他们太全能了！当然，它们有时最终会成为模糊相关功能的总括型组件，但这通常是它们如此伟大的原因。如果您在一个严格限定范围的领域中处理大量常见的复杂逻辑，服务组件可能正是您所需要的。您还会经常在抽象或包装外部功能的地方看到服务。不管该功能是否存在于您的应用程序中，您都希望确保用于与之交互的接口是通用的——您可能会发现，即使您从系统中的该功能开始，随着应用程序其余部分的增长，将其移出可能更有意义。</p><p id="d5f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看一个关于PDF操作的例子。有各种各样的网络服务，你可以提供PDF和必要的说明，他们可以做简单的事情，如合并，分割等。也有几乎每种语言的库，提供类似的功能，而不需要进行web调用。根据您的应用程序的性质，其中一个可能更好。这是创建足够通用的IPdfService接口的好时机，这样您就可以轻松地交换底层实现。将此类内容与服务区分开来的另一个方面是，<em class="lo">通常(但不总是)，</em>服务不直接进行数据访问，而是简单地为应用程序的其余部分提供黑盒风格的服务。</p><h1 id="1975" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">我做了一个！</h1><p id="7f81" class="pw-post-body-paragraph iv iw hi ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">你有没有发现自己一遍又一遍地写同一个对象初始化代码？或者创建多个从同一个接口派生的不同对象？那你可能要考虑工厂了。就像现实世界中的工厂一样，它们旨在帮助简化对象的创建/初始化。让我们看一个关于汽车的例子。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div class="er es lp"><img src="../Images/edb8ffcfb359c796e3c565890f2a6464.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*GqxD4J__tOGnjTpo2j6P-Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">一个简单的以汽车为中心的例子</figcaption></figure><p id="6533" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以我们有一个<em class="lo"> IAutomobile </em>接口，由三种不同类型实现:<strong class="ix hj">跑车、轿车、</strong>和<strong class="ix hj">卡车</strong>。现在，所有这三个实例可能共享许多公共组件，对吗？每辆车的细节可能会有所不同，但从高层次来看，每辆车都有4个轮子、窗户、门、引擎、变速器等。为了更容易在代码中构建这些，我们将使用类似于<strong class="ix hj"> AutomobileFactory </strong>的东西，我们可以提供一些细节，以便简化创建这些之间的大量共享代码。第二好的部分？您不需要搜索所有创建轿车实例的地方，因为它们都集中在一个地方。</p><h1 id="8805" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">去拿吧</h1><p id="6cd9" class="pw-post-body-paragraph iv iw hi ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">命令和查询通常被视为称为CQRS的更广泛概念的一部分，该概念代表命令查询责任分离。我们将在以后的文章中探讨更广泛的概念，但是现在，只需要理解这两个组件是主要的焦点。两者本身都不复杂——命令用于<em class="lo">做</em>而查询用于<em class="lo">得到</em>。换句话说，如果你需要执行一个动作，你可以写一个命令来实现它；或者，如果您需要从系统中检索一些数据，您可以编写一个查询。正如模式名所暗示的，最好将这两件事分开，即不要从查询中调用命令，反之亦然。</p><p id="f68d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">继续我们汽车工厂的主题，您可能在命令/查询世界中看到的一些东西可能是这样的:<em class="lo"> RegisterCarCommand、GetCarRegistrationQuery、CreateCarCommand </em>(可能会使用前面的<em class="lo"> IAutomobileFactory </em>)等等。请注意，这些通常也是尽可能集中的，并且通常只做一件事，以帮助减少开销——然而，这不是一个要求，只是一个最佳实践。</p><h1 id="50c6" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">我这样做对吗？</h1><p id="bffb" class="pw-post-body-paragraph iv iw hi ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">验证是任何应用程序的重要组成部分——它不仅有助于确保数据完整性，还有助于实施应用程序的某些要求和期望。您还可能看到验证发生在应用程序的多个层，通常是web/表示层和业务层。在这种情况下，您可能会看到在API级别进行非常高级别的验证，只是为了确保数据足够好，可以进入系统。在进一步操作之后，您可能希望在业务层的某个地方再次进行验证，以确保您的需求仍然得到满足。在某些情况下，对于完全相同的数据，在API和业务层执行的验证可能是相同的——这是一个很好的实践，以防您最终从不同的地方调用某些方法，即使这在某些路径上是多余的。验证也可能发生在离数据层更近的地方，但这并不常见，通常只在极其复杂的特定于数据源的场景中出现。</p><p id="7569" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">回到我们的汽车主题，让我们假设有一个API来创建一辆新车，它接受非常基本的项目，如类型、装饰、内部颜色和外部颜色。您的API将首先验证所提供的选项是否可用。例如，假设您只有黑色和米色的内饰颜色选项，而请求是红色的内饰—您希望让用户知道红色不是可用的选项(如果使用HTTP，通常通过400状态代码，但这超出了本文的范围)。接下来，假设所提供的参数在最顶层都是有效的，并且汽车已经通过了几个额外的阶段，您可能还想验证其余的必要组件&amp;文书工作是否存在。想象这一切看起来像一条装配线，你有一个最终的<em class="lo">buildcar命令</em>，该命令将验证你有一个有效的注册，所有可用的零件和任何其他你需要确保在你实际建造车辆之前。</p><h1 id="4072" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">如何把它放在一起</h1><p id="feb4" class="pw-post-body-paragraph iv iw hi ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">到现在为止，您可能想知道所有这些东西是如何协同工作的。现在，有多种方法可以做到这一点，但更常见的做法之一是Orchestrator模式。Orchestrate的意思是按照特定的顺序将事情放在一起，这正是Orchestrator类型的类在软件中所做的事情。您可以使用它将多个验证链串在一起，或者以特定的顺序调用一些服务。它甚至可能比这更复杂，因为制造一辆汽车是一个相当复杂的场景，一个管弦乐队在这里会有很大的帮助。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/09331e6e7554e56ac9b5e301a65e1ca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1JrcFi8aAzZRXQMbZfdDMA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">汽车编排序列图</figcaption></figure><p id="07c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们在上面的图表中看到的，orchestrator负责大部分工作，而其余的组件非常专注于做一件特定的事情——orchestrator也是，但是它的重点是组织而不是做。首先，orchestrator由API调用。接下来，就像我们之前讨论的那样，我们将希望使用AutomobileBasicValidator来验证初始提供的值，以检查颜色、修剪等。假设所有这些都通过了，我们将希望确保我们可以注册汽车，因此我们将调用AutomobileRegistrationService来完成这项工作。接下来，我们希望确保我们拥有实际生产所需汽车所需的所有零件，因此我们调用AutomobilePreBuildValidator来检查零件、成功注册等。最后，我们称汽车工厂为真正生产汽车的工厂。之后可能还会有额外的步骤，其中可能包括更多的验证或安装选项。希望到现在为止，你可以看到管弦乐队在大局中扮演的角色有多重要。</p><h1 id="ebb9" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">摘要</h1><p id="8e10" class="pw-post-body-paragraph iv iw hi ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">我们探索了各种业务组件，包括服务、工厂、命令、查询、验证器和编排器。我们了解了服务组件与其他组件的区别，何时使用工厂以及如何进行验证。我们还谈到了来自CQRS的命令和查询，以及将它们联系在一起的orchestrator模式。</p><h1 id="47fa" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">下一步是什么？</h1><p id="2281" class="pw-post-body-paragraph iv iw hi ix b iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo ln jq jr js hb bi translated">接下来，我们将深入探讨我们在此强调的一些概念，以及其他更高级的主题。</p><p id="0f19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">想看一些具体的东西吗？留言评论！</p></div></div>    
</body>
</html>