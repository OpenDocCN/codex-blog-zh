<html>
<head>
<title>Using Merkle Trees for Smart Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Merkle树用于智能合约</h1>
<blockquote>原文：<a href="https://medium.com/codex/using-merkle-trees-for-smart-contracts-24ccf6f75a0a?source=collection_archive---------2-----------------------#2022-02-17">https://medium.com/codex/using-merkle-trees-for-smart-contracts-24ccf6f75a0a?source=collection_archive---------2-----------------------#2022-02-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="683f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实施NFT白名单的安全而简单的方法。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/4f7854b8e36fac65d717336197101092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_qxkVvCLh35VUG4uDuysDQ.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">照片由<a class="ae ju" href="https://unsplash.com/@niko_photos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> niko photos </a>在<a class="ae ju" href="https://unsplash.com/s/photos/tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2e8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Merkle证明经常被用在NFT合约中，这些合约有某种白名单的特征。我不是它的超级粉丝，因为它也需要链外代码。但即使有了链外代码，这也是防止僵尸程序或非白名单地址制造令牌的一个非常好的方法。</p><p id="c081" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么什么是Merkle证明，Merkle树，外链代码做什么，内链代码做什么？让我们来看看这篇文章。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="c5f4" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是Merkle树？</h1><p id="4764" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">Merkle trees，顾名思义，是一种树状结构，其中每个节点都标有一些数据的散列。最底层的节点称为<strong class="ih hj">叶。</strong></p><p id="aebc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要散列的数据有多少，就有多少叶子。叶节点和根节点之间的节点由它下面的节点的连接散列决定。听起来很多，但是让我们看看下面的图像。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lf"><img src="../Images/a81dbd3503a3c96db7178569e55c2da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g0PdIq4rL557motDdbOllA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">一棵大树。图片取自<a class="ae ju" rel="noopener" href="/@ItsCuzzo/using-merkle-trees-for-nft-whitelists-523b58ada3f9">此处</a>。</figcaption></figure><p id="611b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们大致知道了Merkle树是什么，我们可以开始实现它了。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="fa4f" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">服务器端代码</h1><p id="2926" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我们的离线程序将简单地散列几个假以太坊地址，这样我们就可以在我们将要编写的智能契约中检查它们的有效性。我将编写一个简单的NodeJS程序，该程序将记录相关的哈希，我将使用Remix将其复制粘贴到智能合约的函数调用中。</p><p id="85df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从初始化项目并安装Merkle tree实现所需的正确包开始。</p><pre class="jf jg jh ji fd lg lh li lj aw lk bi"><span id="2017" class="ll kd hi lh b fi lm ln l lo lp">npm init -y<br/>npm i <!-- -->merkletreejs<br/>npm i keccak256</span></pre><p id="0ed2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，我们可以很容易地创建一个Merkle树。我列了一个小清单，上面有7个我随机挑选的以太坊地址。然后使用<code class="du lq lr ls lh b">keccak256</code>，我创建了一个名为<code class="du lq lr ls lh b">leaves</code>的新列表，其中包含每个地址的<code class="du lq lr ls lh b">keccak256</code>散列。</p><p id="e1ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这个列表，我们就可以用树叶和<code class="du lq lr ls lh b">keccak256</code>函数作为参数创建一个新的<code class="du lq lr ls lh b">MerkleTree</code>。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="7470" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，当您运行<code class="du lq lr ls lh b">node index.js</code>时，我们在控制台中就有了打印机Merkle树及其根散列。</p><h2 id="7094" class="ll kd hi bd ke lv lw lx ki ly lz ma km iq mb mc kq iu md me ku iy mf mg ky mh bi translated">Merkle证明</h2><p id="8145" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">现在我们有了根散列、树和树叶，我们可以验证给定的散列是否是树的一部分，因此是有效的。在现实世界的应用程序中，您可以从前端获取用户的地址。我们只需从列表中获取一个。</p><p id="5c4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们使用<code class="du lq lr ls lh b">keccak256</code>散列地址，并使用<code class="du lq lr ls lh b">getHexProof()</code>检索证明。该证明随后与交易一起被发送到智能合约。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="f0da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们真的想的话，我们也可以在后台验证它。它对于白名单应用程序没有用，但是知道它是如何工作的还是有好处的，因为我们将在智能合约中做一些类似的事情。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="62de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们启动Remix并创建一个智能契约来为我们做这件事。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="c094" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">智能合同</h1><p id="0dd0" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">智能契约将简单地做与最后一段中的最终代码片段相同的事情。它将使用另一个库中的一个简单函数来验证叶子和根散列的证明。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="30db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用OpenZeppelin的合同来帮助验证Merkle的证据。在生产环境中，一定要有一个设置根的功能，如果您的后端不知何故失败了，就禁用对有效证明的检查。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="17fe" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="a1d2" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">本质上就是这样。我们已经讨论了如何创建一棵Merkle树，如何为一片叶子创建一个证明，以及如何验证证明的有效性。有了这个，你可以简单地使用公共地址而不是像我一样的随机列表来创建一个白名单智能契约。</p><p id="52c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">非常感谢你的阅读，祝你有美好的一天。</strong></p><p id="12f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae ju" href="https://mbvissers.medium.com/membership" rel="noopener">支持我支持Medium成为会员</a>。它帮了我很大的忙，它不会额外花费你，你可以阅读尽可能多的中等文章！</p><p id="cf19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae ju" href="https://twitter.com/0xmbvissers" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae ju" href="https://gm.xyz/u/mbvissers.eth" rel="noopener ugc nofollow" target="_blank"> gm.xyz </a>关注我。</p><p id="fbf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里查看我是<a class="ae ju" href="https://kangaroomob.io/" rel="noopener ugc nofollow" target="_blank">的开发人员的项目</a>。</p><p id="c0cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Polygon上查看我最新的<a class="ae ju" href="https://www.pixel-pizzas.com/" rel="noopener ugc nofollow" target="_blank"> NFT收藏</a>。</p></div></div>    
</body>
</html>