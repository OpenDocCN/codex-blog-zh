<html>
<head>
<title>Linux Backup with Backblaze B2 and Email Notifications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Backblaze B2和电子邮件通知的Linux备份</h1>
<blockquote>原文：<a href="https://medium.com/codex/linux-backup-with-backblaze-b2-and-email-notifications-3acdb5282fa1?source=collection_archive---------5-----------------------#2021-08-13">https://medium.com/codex/linux-backup-with-backblaze-b2-and-email-notifications-3acdb5282fa1?source=collection_archive---------5-----------------------#2021-08-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d958a8d54585c5e63e0326e45af444b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E2aqsGYIiRjyYN7ni1Chkw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">我从备份配置中收到的定期电子邮件通知之一。</figcaption></figure><p id="8738" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我和妻子长期使用<a class="ae js" href="https://www.backblaze.com/" rel="noopener ugc nofollow" target="_blank"> Backblaze </a>来备份我们MacBooks上所有的个人文件。</p><p id="4ab6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，当我最近第一次为自己构建了一个Linux桌面时，我想要一个同样简单的备份解决方案。不幸的是，简单自动备份应用的市场似乎仅限于Windows和macOS。所以我不得不取消我的Backblaze个人备份帐户，去寻找一个Linux友好的选项。</p><p id="3345" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">针对Linux 有一千零一种备份解决方案，但是它们都是针对系统管理员的——不像我过去习惯的那样“一劳永逸”。好的一面是，一旦我着手建立这些“<strong class="iw hj">某些组装需要的</strong>”解决方案之一，我每月的云存储账单就比以前便宜了很多，所以就有了这些。</p><p id="8b11" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我选定了一个需要最少护理和喂养的解决方案，它基于四个部分:</p><ul class=""><li id="3ef7" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated"><a class="ae js" href="https://www.backblaze.com/b2/cloud-storage.html" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">Backblaze B2</strong></a><strong class="iw hj"/>作为云存储服务，并且</li><li id="16eb" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated"><code class="du kh ki kj kk b"><strong class="iw hj">restic</strong></code>要管理备份快照，</li><li id="bf61" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated"><strong class="iw hj">一个</strong> <code class="du kh ki kj kk b"><strong class="iw hj">systemd</strong></code> <strong class="iw hj">定时器</strong>来触发每日更新，并且</li><li id="d88b" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated"><code class="du kh ki kj kk b"><strong class="iw hj">mailx</strong></code>每天给我发送备份成功的消息。</li></ul><p id="f688" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我并不期望继续使用Backblaze品牌(我认为我没有理由这样做)，但B2近年来因提供类似于AWS s3的云存储服务而引起了轰动。</p><h1 id="c820" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">创建Backblaze存储桶</h1><p id="8a6f" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">首先，创建一个B2帐户，并为您的备份设置一个存储桶(云存储术语“文件夹”)。</p><p id="0e91" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">通过B2网络图形用户界面很容易做到这一点。如果您愿意，您也可以使用<code class="du kh ki kj kk b">b2</code> CLI客户端。</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/c8cedd9526dfc1159416120415a3a2aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmKOuAwgMdIKwqXQJqtVHw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在B2创建一个存储桶。</figcaption></figure><p id="c625" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你还需要设置一个<strong class="iw hj">应用程序键</strong>。记下密钥ID和密钥以备后用。</p><h1 id="82ae" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">设置Restic快照</h1><p id="02fe" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">现在我们需要一个知道如何</p><ul class=""><li id="1b7b" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated"><strong class="iw hj">扫描您的系统</strong>以查找已更改的文件</li><li id="06c6" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">使用写入时复制创建这些更改的快照</li><li id="4ae7" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated"><strong class="iw hj">管理您的快照历史记录</strong></li></ul><p id="df74" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://restic.net/" rel="noopener ugc nofollow" target="_blank"> Restic </a>是目前这一领域流行的开源解决方案。它有一个漂亮的、统一的CLI界面，并且以<strong class="iw hj">支持多种多样的存储后端</strong>(包括B2)而闻名。因为它很受欢迎并且得到了很好的支持，所以很容易从发行版的包管理器中安装(在我的例子中是<code class="du kh ki kj kk b">pacman</code>):</p><pre class="lp lq lr ls fd lt kk lu lv aw lw bi"><span id="bae5" class="lx km hi kk b fi ly lz l ma mb">sudo pacman -S restic</span></pre><p id="4a7c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">老实说，我们想要一个<em class="mc">也能</em>触发夜间备份并在出错时向您发送通知的工具。但是对于Linux来说没有这样的工具存在:快照工具比比皆是，但是假设(虔诚地遵守UNIX传统)你会把它们和其他东西串在一起作为触发器和通知(见下文)。</p><p id="0321" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用Restic，首先用<code class="du kh ki kj kk b">restic init</code>初始化<strong class="iw hj">一个(受密码保护的)备份库文件，然后用<code class="du kh ki kj kk b">restic backup</code>命令添加到它。为了在B2存储桶中创建一个存储库，我们给命令加上前缀<code class="du kh ki kj kk b">-r b2:bucketname:file</code>，如下所示。</strong></p><p id="87a1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面是我如何为我的台式机(被亲切地称为<code class="du kh ki kj kk b">alfred</code>)设置备份回购的:</p><pre class="lp lq lr ls fd lt kk lu lv aw lw bi"><span id="0e23" class="lx km hi kk b fi ly lz l ma mb">export B2_ACCOUNT_ID=&lt;keyID&gt;<br/>export B2_ACCOUNT_KEY=&lt;key&gt;</span><span id="04e8" class="lx km hi kk b fi md lz l ma mb">restic -r b2:mybucket-desktop-backups:alfred/ init</span></pre><p id="c606" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du kh ki kj kk b">&lt;keyID&gt;</code>和<code class="du kh ki kj kk b">&lt;key&gt;</code>值需要是Backblaze在您创建密钥时显示的值。</p><p id="e471" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，您可以使用以下命令手动触发系统到B2的备份:</p><pre class="lp lq lr ls fd lt kk lu lv aw lw bi"><span id="7a91" class="lx km hi kk b fi ly lz l ma mb">restic -r b2:mybucket-desktop-backups:alfred/ backup ~/Documents</span></pre><p id="709a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用<code class="du kh ki kj kk b">snapshots</code>命令，您可以随时查看存储快照的历史记录:</p><pre class="lp lq lr ls fd lt kk lu lv aw lw bi"><span id="46f8" class="lx km hi kk b fi ly lz l ma mb">restic -r b2:mybucket-desktop-backups:alfred/ snapshots</span></pre><h1 id="255a" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">设置邮件</h1><p id="b5f3" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">跟我重复:<strong class="iw hj">手动备份毫无价值。</strong>让我们设置一个备份脚本，这样我们就可以自动创建快照。</p><p id="11f7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，因为备份如此重要，所以我们需要通知，以便我们知道它在工作和/或是否出现了问题。<code class="du kh ki kj kk b">mailx</code>命令是实现这一点的一种很好的、轻量级的方式(不用跳进全面的<code class="du kh ki kj kk b">sendmail</code>深渊)。</p><pre class="lp lq lr ls fd lt kk lu lv aw lw bi"><span id="2f2a" class="lx km hi kk b fi ly lz l ma mb">sudo pacman -S mailx</span></pre><p id="330a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们需要通过<strong class="iw hj">向</strong> <code class="du kh ki kj kk b"><strong class="iw hj">/etc/mail.rc</strong></code>添加以下行来配置合法的<strong class="iw hj"> SMTP服务器</strong>。我有一个GMail帐户，所以我将利用GMail的SMTP服务:</p><pre class="lp lq lr ls fd lt kk lu lv aw lw bi"><span id="a635" class="lx km hi kk b fi ly lz l ma mb">set v15-compat<br/><br/>set mta=smtp://username:[app-password]@smtp.gmail.com smtp-use-starttls<br/>set from="Eric 'Siggy' Scott &lt;username@gmail.com&gt;"</span></pre><p id="6457" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">其中<code class="du kh ki kj kk b">[app-password]</code>是我的谷歌账户让我生成的16个字符的唯一密码。这让我可以绕过2FA。</p><p id="e6dd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在我们可以像这样发送邮件:</p><pre class="lp lq lr ls fd lt kk lu lv aw lw bi"><span id="3c41" class="lx km hi kk b fi ly lz l ma mb">echo "Test test test" | mailx --subject "Test from Alfred" destinationaddress@gmail.com</span></pre><h1 id="31e2" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">创建备份脚本</h1><p id="3af1" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">综合起来，这是我想要每天触发的<strong class="iw hj">完整脚本</strong>。</p><p id="c62b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它在我的系统上备份了两个目录(我的文件夹和保存我所有克隆的库的目录)。</p><p id="6634" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，它根据<code class="du kh ki kj kk b">restic</code>调用的<strong class="iw hj">返回代码</strong>构造并发送一个<strong class="iw hj">电子邮件消息</strong>，其中包含成功消息或失败消息:</p><figure class="lp lq lr ls fd ij"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="ddc9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了方便起见，我选择将它放在<code class="du kh ki kj kk b">/usr/bin/backup_script.sh</code>中。</p><h1 id="856b" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">触发器:创建一个系统计时器</h1><p id="ffa6" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">同样，手动备份是没有价值的，所以我们希望这个脚本自动执行。</p><p id="b925" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在Linux系统上，这个问题的当代答案是使用一个T4计时器。对于外行人来说，这是经典的<code class="du kh ki kj kk b">cron</code>工作的现代等价物——现在<strong class="iw hj">我们仁慈的霸主</strong> <code class="du kh ki kj kk b"><strong class="iw hj">systemd</strong></code>已经成为所有Linux发行版核心的上帝使者。你可以在这里找到关于<code class="du kh ki kj kk b">systemd</code>定时器<a class="ae js" href="https://opensource.com/article/20/7/systemd-timers" rel="noopener ugc nofollow" target="_blank">的深入教程</a>。</p><p id="2840" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是基本上，我们需要创建<strong class="iw hj">两个</strong>配置文件:一个<em class="mc">服务</em>和一个<em class="mc">定时器</em>。</p><h2 id="252b" class="lx km hi bd kn mg mh mi kr mj mk ml kv jf mm mn kz jj mo mp ld jn mq mr lh ms bi translated"><code class="du kh ki kj kk b"> backup.service</code>单位文件</h2><p id="f63a" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">首先，我们将构建一个调用备份脚本的<code class="du kh ki kj kk b">systemd</code> <strong class="iw hj">单元文件</strong>。单元将基本的<strong class="iw hj">子程序</strong>归档，这些子程序构成了<code class="du kh ki kj kk b">systemd</code>作业和服务的构件。</p><p id="b51f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">将以下内容放入文件<code class="du kh ki kj kk b">/etc/systemd/system/backup.service</code></p><pre class="lp lq lr ls fd lt kk lu lv aw lw bi"><span id="f990" class="lx km hi kk b fi ly lz l ma mb">[Unit]<br/>Description=Restic backup script<br/>Wants=backup.timer</span><span id="8d75" class="lx km hi kk b fi md lz l ma mb">[Service]<br/>Type=oneshot<br/>ExecStart=/usr/bin/backup_script.sh<br/>User=yourusername</span><span id="975b" class="lx km hi kk b fi md lz l ma mb">[Install]<br/>WantedBy=multi-user.target</span></pre><p id="4e6a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="mc">注意</em>:重要的是<strong class="iw hj">要包含</strong> <code class="du kh ki kj kk b">User=yourusername</code>(在我的例子中是<code class="du kh ki kj kk b">User=eric</code>)，否则我们的备份脚本将以root用户身份运行——这除了通常令人害怕之外，还会导致<code class="du kh ki kj kk b">restic</code>无法使用其缓存功能，导致您的备份每次都要花费<strong class="iw hj">小时而不是</strong>秒钟！</p><p id="c81c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了确保备份服务正常工作，我们可以像这样手动触发它:</p><pre class="lp lq lr ls fd lt kk lu lv aw lw bi"><span id="97b1" class="lx km hi kk b fi ly lz l ma mb">systemctl start backup.service</span></pre><h2 id="afcc" class="lx km hi bd kn mg mh mi kr mj mk ml kv jf mm mn kz jj mo mp ld jn mq mr lh ms bi translated"><code class="du kh ki kj kk b"> backup.timer</code>单位文件</h2><p id="3203" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">其次，我们将建立一个单元文件，它使用一个计时器在每晚2:00AM 触发一次<strong class="iw hj">备份服务。</strong></p><p id="6c98" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">把这个放在<code class="du kh ki kj kk b">/etc/systemd/system/backup.timer</code>:</p><pre class="lp lq lr ls fd lt kk lu lv aw lw bi"><span id="fe52" class="lx km hi kk b fi ly lz l ma mb">[Unit]<br/>Description=Daily Backup Script<br/>Requires=backup.service </span><span id="db84" class="lx km hi kk b fi md lz l ma mb">[Timer]<br/>Unit=backup.service<br/>OnCalendar=*-*-* 02:00:00<br/>; Run immediately if the system was off<br/>Persistent=true</span><span id="c598" class="lx km hi kk b fi md lz l ma mb">[Install]<br/>WantedBy=timers.target</span></pre><p id="1d51" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里特别重要的是<code class="du kh ki kj kk b">Persisent=true</code>行。没有它，如果机器在凌晨2点关机或睡眠，定时器<strong class="iw hj">不会被触发。因为这是我的工作站，不是服务器，所以几乎总是这样！</strong></p><p id="6064" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du kh ki kj kk b">Persistent=true</code>确保作业将在凌晨2点后的第一个机会<em class="mc">运行。因此，<strong class="iw hj">实际上，我的备份在每天早上7点左右运行，也就是我第一次坐在机器前的时候。</strong></em></p><h2 id="1ddf" class="lx km hi bd kn mg mh mi kr mj mk ml kv jf mm mn kz jj mo mp ld jn mq mr lh ms bi translated">启动计时器</h2><pre class="lp lq lr ls fd lt kk lu lv aw lw bi"><span id="5a02" class="lx km hi kk b fi ly lz l ma mb">systemctl start backup.timer</span></pre><p id="71c4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">或者更重要的是，<code class="du kh ki kj kk b">enable</code>定时器，这样它会在每次系统重启时激活:</p><pre class="lp lq lr ls fd lt kk lu lv aw lw bi"><span id="84a5" class="lx km hi kk b fi ly lz l ma mb">systemctl enable backup.timer</span></pre><p id="6ec4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">瞧啊。像这样的信息现在是我早晨例行公事的一部分:</p><figure class="lp lq lr ls fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/880a3aa2e0550ab65b75cc994a96457f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TlNRdSkZu8g_vO-9yvO3hg.png"/></div></div></figure><h2 id="94f5" class="lx km hi bd kn mg mh mi kr mj mk ml kv jf mm mn kz jj mo mp ld jn mq mr lh ms bi translated">排除故障</h2><p id="2068" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">我们单位档案的所有日志都是由<code class="du kh ki kj kk b">journald</code>、<code class="du kh ki kj kk b">systemd</code>的承租人(也是老<code class="du kh ki kj kk b">syslog</code>传统的替代者)收集的。</p><p id="ba5e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当您试图确保您的<code class="du kh ki kj kk b">systemd</code>服务和定时器正确运行时，以下是一些有用的命令:</p><pre class="lp lq lr ls fd lt kk lu lv aw lw bi"><span id="5930" class="lx km hi kk b fi ly lz l ma mb">journalctl -S today -u backup.service<br/>journalctl -t systemd | grep backup.service<br/>journalctl -t systemd | grep backup.timer<br/>journalctl -t backup_script.sh</span></pre><h1 id="22fe" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">旁白:用Git管理系统配置</h1><p id="7705" class="pw-post-body-paragraph iu iv hi iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr hb bi translated">为了设置这个，我们<strong class="iw hj">接触或创建了相当多的</strong>配置文件和脚本。Linux是关于自由配置的，但是它让我很不舒服，因为它积累了很多像这样的未记录的和高度特定的系统调整。</p><ul class=""><li id="f124" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">实施起来很费时间</li><li id="f428" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">他们可能会被系统更新意外<strong class="iw hj">核爆</strong></li><li id="042a" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">当我重新安装我的操作系统时，它们都从宇宙中消失了</li><li id="257f" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">很难记住哪些配置文件携带了重要的定制内容，哪些只是锅炉板或cruft(我在看你，点文件在T7！)</li></ul><p id="b2b6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当然，如果你陷入真正的重配置活动——比如设置一个轻量级窗口管理器之类的，而不是选择Gnome的默认设置，问题会变得更糟。</p><p id="c058" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">出于这些原因，我非常喜欢在一个<strong class="iw hj"> git仓库</strong>中跟踪我所有的手工Linux定制。信不信由你，我实际上把我的<strong class="iw hj">根目录</strong>变成了一个巨大的git repo。然而，我使用了一个<code class="du kh ki kj kk b">.gitignore</code>文件，因此在默认情况下，除非我显式地提交它，否则不会跟踪任何东西。</p><p id="2c6d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里有一个<a class="ae js" href="https://stackoverflow.com/questions/505467/can-i-store-the-git-folder-outside-the-files-i-want-tracked" rel="noopener ugc nofollow" target="_blank">，所以张贴</a>如何做到这一点。诀窍是将回购的<code class="du kh ki kj kk b">git-dir</code>与<code class="du kh ki kj kk b">work-tree</code>分开。</p></div></div>    
</body>
</html>